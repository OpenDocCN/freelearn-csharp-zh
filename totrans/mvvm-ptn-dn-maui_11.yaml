- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating MVVM-Friendly Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we’ve navigated through a wide spectrum of topics in MVVM
    and .NET MAUI – from the fundamental design pattern to data binding, navigation,
    and even working with remote data. Now, let’s dig into another important topic
    – **custom controls**.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the built-in controls might fall short in catering to specific user
    interface requirements or unique design elements. As a consequence, you’ll need
    to create your own by combining individual UI elements into a single, more effective
    unit. Making these elements MVVM-friendly and reusable throughout your app is
    our goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll focus on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom control with bindable properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling interactions on custom controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with control templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to make custom controls that not
    only look good but are also easy to manage in an MVVM setup. Ready to dive in?
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll continue to enhance the *Recipes!* app by diving into custom controls
    and control templates, all designed with an MVVM architecture in mind. To follow
    along with the code, make sure to visit the GitHub repository at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter11).
    The `Start` folder has the initial code set up to begin this chapter, while the
    `Finish` folder contains the completed code for your reference.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom control with bindable properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a feature-rich application often requires more than just the standard
    set of UI controls. When you have a combination of controls appearing together
    across multiple parts of your application – such as an input field with a list
    of validation errors or a button that’s always used with an activity indicator
    – it makes sense to package these into custom controls. These custom, reusable
    elements not only make the code base more maintainable but also align perfectly
    with MVVM architecture when made bindable.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this section is not only to create custom controls but also to
    make them “bindable,” seamlessly integrating them into our MVVM architecture.
    By crafting controls that are bindable, you enable straightforward communication
    with your ViewModel. This is key to ensuring that the UI is always up to date
    with an application’s data and logic.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few pages, we’ll see how to combine existing controls into a custom,
    bindable control. We’ll also discuss how to add custom properties and behavior
    to controls, ensuring they can effortlessly fit into an MVVM-based application
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While we will be creating a custom control in XAML throughout this chapter,
    it’s important to note that everything we do can also be done entirely in code
    if preferred.
  prefs: []
  type: TYPE_NORMAL
- en: As we dive into creating custom controls with data binding capabilities, it’s
    important to recall the concept of a binding target, which we covered in [*Chapter
    3*](B20941_03.xhtml#_idTextAnchor051), *Data Binding Building Blocks in .NET MAUI*.
    In .NET MAUI, a binding target is typically a `BindableProperty` on a UI element
    or another `BindableObject`. To make our custom controls serve as effective binding
    targets, they need to inherit from `BindableObject`. Additionally, any properties
    that we intend to bind must be of type `BindableProperty`. This ensures that our
    custom controls will integrate seamlessly into the MVVM data-binding architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing FavoriteControl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our *Recipes!* app, displaying whether a recipe is marked as a favorite or
    not is a recurring theme. The “favorite” icon appears across various parts of
    our app. Each time this icon appears, it behaves the same way – changing colors
    when the recipe is marked as a favorite. Instead of repeating the same code everywhere,
    we can encapsulate this pattern into a reusable `FavoriteControl`. By doing so,
    we make our code more maintainable and pave the way for future improvements –
    such as additional gestures or animations – without needing to alter multiple
    sections of the code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and look at the steps needed to create our `FavoriteControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Controls` folder in the `Recipes.Mobile` project and select **Add**
    | **New Item…**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `FavoriteControl.xaml` as the name of the new item. Click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.1: Select ContentView from the dialog](img/B20941_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Select ContentView from the dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'By following these steps, two new files will be created – `FavoriteControl.xaml`
    and its code-behind file, `FavoriteControl.xaml.cs`, as shown in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Files making up FavoriteControl](img/B20941_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Files making up FavoriteControl'
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated `FavoriteControl` inherits the `ContentView` class, which itself
    is a descendant of `BindableObject`. This allows `FavoriteControl` to define `BindableProperties`,
    which is essential to make the control bindable. Speaking of which, `FavoriteControl`
    should contain a `BindableProperty` called `IsFavoriteProperty` and an `IsFavorite`
    property of type `bool`. The following code snippet shows what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining a `BindableProperty` can be confusing or unclear at first. If this
    concept is still vague, [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051), *Data
    Binding Building Blocks in .NET MAUI*, covers it in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we can dive into XAML and start working on the visual layer
    of this `FavoriteControl`.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in a custom control
  prefs: []
  type: TYPE_NORMAL
- en: When building a custom control, it’s recommended to design it so that it doesn’t
    depend on its `BindingContext`, which it inherits from its parent page or control.
    Instead of depending on its `BindingContext`, the custom control should be self-contained
    and interact directly with its own bindable properties. This approach makes your
    control more modular and reusable, freeing it from dependencies on any specific
    ViewModel or data source. Element binding or relative binding is instrumental
    in achieving this independence. However, it’s worth noting that using data binding
    within the control is not mandatory. Handling all the logic and value assignments
    programmatically in the control’s code-behind is also a solid approach. This mostly
    depends on personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at how to define the control’s appearance and see how we
    can efficiently bind to its `IsFavorite` property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `FavoriteControl.xaml` file, and add the following `local` and `toolkit`
    XML namespaces and the `x:Name` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <ContentView.Resources>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <toolkit:BoolToObjectConverter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:Key="isFavoriteToColorConverter"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: x:TypeArguments="Color"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FalseObject="#E9E9E9E9"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TrueObject="#FF0000" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ContentView.Resources>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can add the `Image` control to display the `"favorite.png"` icon.
    We also want this Image control to match the dimensions specified for `FavoriteControl`.
    Here’s how to set this up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to control the tint of the `Image`, depending on the favorite status,
    we use `IconTintColorBehavior`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This setup closely mirrors what we used on `RecipesOverviewPage` and `RecipeDetailPage`.
    The key difference lies in the source of the binding. Here, we bind directly to
    the `IsFavorite` property we just created. We achieve this using element binding
    (via `x:Reference root`), which refers back to `FavoriteControl` itself. This
    is necessary because relative binding isn’t suitable here. Behaviors, unlike other
    UI elements, are not part of the visual tree, so they can’t perform relative binding
    or find ancestors in the same way that other elements can.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With these steps completed, we’ve successfully created our first custom control,
    `FavoriteControl`. Now, we can go ahead and replace the existing image and `IconTintColorBehavior`
    setup, used to indicate favorite recipes on both `RecipesOverviewPage` and `RecipeDetailPage`,
    with this custom control. Let’s do this in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `RecipesOverviewPage` and add an `xml` namespace, referring to the namespace
    containing the newly created `FavoriteControl`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The XML namespace (`xmlns:toolkit`) pointing to the .NET MAUI Community Toolkit
    can be removed, as we won’t be using any of its functionalities anymore on this
    page. This is now encapsulated in our custom control.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the `Image` UI element along with its associated behavior, which until
    now served as the favorite indicator for a recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In place of the deleted `Image`, insert the `FavoriteControl` we just created.
    Here’s how to do it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The layout properties such as margin, size, visibility, and alignment options
    are unchanged from the removed `Image`. Also, observe how easily we can bind the
    `IsFavorite` property of our `FavoriteControl` to the corresponding `IsFavorite`
    property on the page’s `BindingContext`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For `RecipeDetailPage`, we can follow a similar approach. Include an XML namespace
    that points to `Recipes.Mobile.Controls` and swap out the `Image`, which previously
    signaled whether the recipe was a favorite, with the newly created `FavoriteControl`.
    This is what the result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**By consolidating the favorite indicator into a single, reusable `FavoriteControl`,
    we’ve achieved multiple objectives. Firstly, we’ve centralized the code, making
    it easier to manage and update. Secondly, this control can now be used consistently
    across different pages of the app, ensuring a uniform user experience. Finally,
    by doing so, we’ve also enhanced the readability and maintainability of our code
    base. *Figure 11**.3* shows `FavoriteControl` on different pages of the app. Although
    nothing has visibly changed for the user, the code and its maintainability profit
    immensely from this reusable control.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: FavoriteControl on different pages](img/B20941_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: FavoriteControl on different pages'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how we can improve this control a bit more, making the app more attractive
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Animating state changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a quick example of reacting to state changes, let’s explore how to add a
    subtle animation to `FavoriteControl` whenever the `IsFavorite` property changes.
    We’ll use the `propertyChanged` delegate method of `IsFavoriteProperty` to trigger
    this animation. Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `IsFavoriteProperty` by adding a `propertyChanged` delegate, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this modification, the static `OnIsFavoriteChanged` method will be invoked
    each time the value of the `IsFavorite` property changes. The `BindableObject`
    that gets passed in is the instance on which `BindableProperty` is set. In this
    case, it will be an instance of `FavoriteControl`. The `oldValue` and `newValue`
    parameters are self-explanatory, as they provide the previous and new values of
    the property, respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s add the animation we want to play when the control’s state changes.
    Here’s how we can add it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AnimateChange` method will scale the `Image` holding the icon to 1.5 times
    its size over a period of 100 milliseconds. Afterward, it will be scaled down
    again to its original size over the same amount of time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we need to call this method from the static `OnIsFavoriteChanged`
    method. The following code block shows how this can be done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The bindable parameter can safely be cast to `FavoriteControl`, allowing us
    to call the `AnimateChange` method, triggering the animation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the app to see the changes in action! You’ll observe a subtle animation
    on the `RecipeDetailPage` each time a recipe is toggled as a favorite. Introducing
    this custom control brings the convenience of unified animations across the application.
    Any modification made to the animation within the custom control gets automatically
    reflected everywhere it’s used. Without such a control, we’d need to manually
    update the animation at each individual instance throughout the app. Overlooking
    even a single instance would lead to inconsistent behavior. Thus, custom controls
    ensure both consistency and streamlined maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This example underscores an important point – even when you’re fully committed
    to using the MVVM pattern, there will be scenarios where writing code in the code-behind
    is not just acceptable but necessary. This is especially true when creating custom
    controls, where using code-behind is not only inevitable but also perfectly appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore how to add interactions to a custom control by leveraging
    commanding, thereby further aligning it with MVVM concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling interactions on custom controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real-world applications, controls often serve dual roles – they both display
    data and allow users to interact with it. In this section, we’ll further enhance
    our `FavoriteControl` to not only support user interactions through `IsFavoriteChangedCommand`
    but also to facilitate two-way data binding. These features will make the control
    more interactive and further align it with MVVM concepts. We want to allow users
    to tap the `Image` on the `FavoriteControl`. When `FavoriteControl`’s `IsEnabled`
    property is set to `true`, the `IsFavorite` property will be updated and `IsFavoriteChangedCommand`
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the first part of this functionality – updating the `IsFavorite`
    property when a user taps on the image and making sure the value bound to this
    property gets updated as well.
  prefs: []
  type: TYPE_NORMAL
- en: User actions and reflecting state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, let’s add the ability for users to toggle their favorite state
    by tapping on the control. This user action will then update the `IsFavorite`
    property of the control, which, in turn, will reflect back to update the bound
    property. The following steps show how to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `GestureRecognizer` to the `FavoriteControl`’s `ContentView`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `GestureRecognizer` allows you to handle user interaction events, such as
    tapping, pinching, and swiping, on a UI element. By adding a `TapGestureRecognizer`
    to the `ContentView`, we effectively instruct the application to listen for a
    tap event on this control.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s the `TapGestureRecognizer_Tapped` event handler in the code-behind:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will be triggered when a user taps on the `FavoriteControl`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s implement the logic needed to update the `IsFavorite` property in
    the `TapGestureRecognizer_Tapped` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how we first check the `IsEnabled` property before updating the `IsFavorite`.
    It’s crucial for custom controls to behave consistently with developers’ expectations.
    In this case, setting the `IsEnabled` property of a `VisualElement` to `false`
    should disable the control. As a result, we check the `IsEnabled` property before
    toggling the value of `IsFavorite`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we run the app and navigate to `RecipeDetailPage` at this point, tapping
    `FavoriteControl` should update its state. The animation we defined earlier also
    plays as a reaction to the `IsFavorite` property being updated. However, the state
    change is not reflected on the ViewModel. You might wonder why this is the case.
    It’s because `IsFavoriteProperty` has a default binding mode of `OneWay`. That’s
    why the updated value doesn’t flow from the control back to the ViewModel. This
    can easily be adjusted – change the `IsFavoriteProperty`’s default binding mode
    to `TwoWay`, or update the binding statement on the `RecipeDetailPage` and explicitly
    set it to `TwoWay`. Here’s what the first approach – updating the default binding
    mode – looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can leave the default binding mode to `OneWay` and update
    the binding statement on `RecipeDetailPage`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Either way, the `IsFavorite` property on the `FavoriteControl` will now reflect
    its state on the ViewModel. How can we verify this? By adding breakpoints in code
    of course, but also by simply tapping the control – note how the visibility of
    the `IsFavorite` property on the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When defining a bindable property, it’s crucial to select the `defaultBindingMode`
    that aligns best with the control’s primary intended behavior or the binding mode
    that will be most commonly used. In the rare instances where different behavior
    is required, the developer can always override the default by specifying a different
    binding mode in the binding statement.
  prefs: []
  type: TYPE_NORMAL
- en: '`IsFavorite` property won’t result in the underlying model being updated. Let’s
    delve into how we can incorporate commands into our `FavoriteControl` to make
    it even more versatile.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding command-based interactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s further enhance our `FavoriteControl` by exposing a command property –
    `ToggledCommand`. This command will be invoked whenever the `IsFavorite` property
    is toggled via a tap gesture on the control. To make this even more robust, the
    command will send the updated `IsFavorite` bool value as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding command-based interactions to custom controls is pretty straightforward,
    as the following steps show:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It all starts by adding a `BindableProperty` and a property of type `ICommand`.
    This code block shows how to add the `ToggledCommand` property and its corresponding
    `BindableProperty` to our `FavoriteControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can call the command’s `Execute` method whenever the user has tapped
    the control and, thus, has updated the `IsFavorite` property. Here’s what the
    updated `TapGestureRecognizer_Tapped` method looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we’re using the null-conditional operator (`?`) to prevent a `NullReferenceException`
    in case `ToggledCommand` is null.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code block shows the `FavoriteToggledCommand` that we can add
    to the `RecipeDetailViewModel`, and which we will bind to the `ToggledCommand`
    of the `FavoriteControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s add the `FavoriteToggled` method, which is called by `FavoriteToggledCommand`.
    Here’s what it looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ToggledCommand` of the `FavoriteControl` sends the updated `isFavorite`
    value as a parameter. We can use this parameter to decide what method to call
    on the `favoritesService`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this in place, we can also quickly refactor the existing `AddAsFavorite`
    and `RemoveAsFavorite` methods in order to avoid code duplication, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UpdateIsFavorite` method is added. This method takes in the new value that
    the `IsFavorite` property should get. It assigns this value to the property and
    calls the `FavoriteToggled` method that we just introduced. From the `AddAsFavorite`
    and `RemoveAsFavorite` methods, this new `UpdateIsFavorite` method can now be
    called, passing in just a `bool` value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The only thing that is left to do is to bind `FavoriteToggledCommand` of `RecipeDetailViewModel`
    to the `ToggledCommand` property of the `FavoriteControl` on the `RecipeDetailPage`.
    Here’s how:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we run the app now, we’ll see that not only does the `IsFavorite` property
    updates when the `FavoriteControl` is tapped but the bound `FavoriteToggledCommand`
    is also invoked, allowing for seamless interaction and data updates in our application.
    This completes the integration of a very basic command-based interaction into
    our custom control. Let’s continue and make the control better and more intuitive
    for both the users of our app and other developers.
  prefs: []
  type: TYPE_NORMAL
- en: Improving developer and user experience
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the previous example provided a foundational understanding of how to integrate
    command-based interactions into our custom control, it merely scratched the surface.
    Developers aiming to integrate this control across diverse use cases and the end-users
    who will interact with it both anticipate a solution that’s more polished and
    adaptable. For instance, we could enhance the user experience by providing visual
    cues that indicate the control is clickable. On the developer side, we want our
    control to be predictable; developers expect things to work in a certain way.
    Ideally, our control should adhere to the bound command’s `CanExecute` method
    and adjust its behavior accordingly. In my experience, poorly designed or inadequately
    thought-through controls have often created headaches for both myself and my colleagues.
    The goal is to make a custom control intuitive enough that it doesn’t require
    extensive explanation for straightforward tasks. Let’s see how we can bring our
    `FavoriteControl` to another level!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first introduce a new property called `IsInteractive` to `FavoriteControl`.
    This property will be set to `true` when the `IsEnabled` property of the control
    is set to `true`, the `ToggleCommand` is set, and its `CanExecute` method returns
    `true`. In all other situations, the value of the `IsInteractive` property needs
    to be `false`. This property can then be checked inside the control prior to executing
    an action. Let’s go through this step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `IsInteractive` property to `FavoriteControl`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code snippet shows the `UpdateIsInteractive` method. This method
    is responsible for setting the `IsInteractive` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `TapGestureRecognizer_Tapped` method, as shown in the next code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By updating the code that is shown here, we only allow the `IsFavorite` property
    to be toggled when the `IsInteractive` property is set to `true`. This means the
    control is enabled, its `ToggleCommand` is set, and the `ToggleCommand`’s `CanExecute`
    method returns `true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to make sure that the `UpdateIsInteractive` method is called
    when its value needs updating. That’s the case in the following three situations:'
  prefs: []
  type: TYPE_NORMAL
- en: When the value of the `IsEnabled` property changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `ToggleCommand` property is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `CanExecuteChanged` event of the command is triggered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following steps, we’ll put everything in place so that the `UpdateIsInteractive`
    method is called in the aforementioned situations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FavoriteControl` class, override the `OnPropertyChanged` method. This
    method gets called by the control’s properties in order to trigger the `PropertyChanged`
    event, just like we typically have in our ViewModels. Let’s see what we can do
    with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whenever the passed-in `propertyName` matches the `IsEnabled` property, we want
    to trigger the `UpdateIsInteractive` method. This ensures that whenever the `IsEnabled`
    property is updated, the `IsInteractive` property gets re-evaluated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we move on to make sure that the `IsInteractive` property gets updated
    when `ToggledCommand` is updated. Let’s start by adding a `propertyChanged` delegate
    to `ToggledCommandProperty`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ToggledCommandChanged` method is called when the value of the command is
    updated. This is the ideal place to call the `UpdateIsInteractive` method so that
    the `IsInteractive` property gets updated, based on the new `ToggledCommand`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, our `IsInteractive` property isn’t solely reliant on the `IsEnabled`
    property and the presence of the `ToggledCommand`. It also takes into account
    the `CanExecute` method of the defined command. To achieve this, we need to listen
    for changes in the command’s `CanExecute` state by subscribing to its `CanExecuteChanged`
    event. Here’s how we can update the `ToggleCommandChanged` method for that purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After setting the new command, we’re not just subscribing to its `CanExecuteChanged`
    event; we’re also making sure to unsubscribe from the same event on the previous
    command. This is crucial to ensure that our control only reacts to the current
    command’s `CanExecute` state. The `CanExecuteChanged` event handler merely calls
    the `UpdateIsInteractive` method, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In summary, the `IsInteractive` property serves as the gateway for user interactions
    with the control. Its state is determined by a combination of factors – the `IsEnabled`
    property of the control, the presence of a command, and that command’s `CanExecute`
    method. Importantly, the `IsInteractive` state is dynamically re-evaluated every
    time any of these contributing factors change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see this in action! For demo purposes, let’s add a maximum number of
    times the favorite state of a recipe can be toggled via `FavoriteControl`. The
    `canExecute` delegate of the `FavoriteToggledCommand` on the `RecipeDetailViewModel`
    should return `true` as long as this number is not exceeded. Let’s see how we
    can implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the following two fields to `RecipeDetailViewModel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, update the `FavoriteToggledCommand` so that it includes the `canExecute`
    predicate, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: private async Task FavoriteToggled(bool isFavorite)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: updateCount++;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: FavoriteToggledCommand.NotifyCanExecuteChanged();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this in place, we can run the app and see how the `FavoriteControl` reacts
    to the `ToggleCommand`’s `CanExecute` method. Go to the detail page of a recipe
    and press the `FavoriteControl` a couple of times. You’ll notice the favorite
    state will be updated until you’ve clicked five times. After that, the `ToggleCommand`’s
    `CanExecute` method returns `false`, resulting in `IsInteractive` being set to
    `false` as well. Any following interactions with the control will be ignored because
    of this. Additionally, on the `RecipesOverviewPage`, you’ll find that `FavoriteControl`
    is not tappable due to the absence of a defined `ToggleCommand`. Both scenarios
    illustrate that the controls behave as expected!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established how the `IsInteractive` property works, let’s turn
    our attention to leveraging it for a more intuitive user experience. Specifically,
    we’ll explore how to use this property to provide a visual cue that indicates
    whether or not the control is tappable. There’s not that much we can do about
    our `FavoriteControl` to make it really clear that it’s tappable. For the purposes
    of this demo, we’ll add a simple indicator – a black border around the heart icon
    when it’s tappable. Here’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `FavoriteControl.xaml` file and surround the existing `Image` control
    with `Grid`, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <Grid>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: HeightRequest="{Binding HeightRequest,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={x:Reference icon}}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: WidthRequest="{Binding WidthRequest,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={x:Reference icon}}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: IsVisible="{Binding IsInteractive,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={RelativeSource
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AncestorType={x:Type
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: local:FavoriteControl}}}"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scale="1.2"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source="{Binding Source,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Source={x:Reference icon}}" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <Image x:Name="icon" ...>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '...'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Image>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </Grid>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, it’s crucial not to forget to trigger the `PropertyChanged` event for
    the `IsInteractive` property whenever it is updated. Otherwise, the binding engine
    wouldn’t be notified about the updated value. The following snippet shows how
    we can update the `UpdateIsInteractive` method to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the app now and navigating to a `RecipeDetailPage`, you should
    see a black border around the favorite icon, indicating that the control is interactive.
    This border isn’t visible on the `RecipeOverviewPage` because of the absence of
    a `ToggledCommand`. Moreover, when tapping `FavoriteControl` on a `RecipeDetailPage`
    a few times, after the fifth time, the border will disappear because `FavoriteToggledCommand`’s
    `CanExecute` method returns `false`. This visual cue informs a user that the control
    is no longer interactive. *Figure 11**.4* shows the `FavoriteControl` on the `RecipeDetailPage`
    in all its different states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: FavoriteControl in different states](img/B20941_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: FavoriteControl in different states'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve fine-tuned the user and developer experience, let’s take it a
    step further by making our control’s design as adaptable as its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Working with control templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve been dealing with a hardcoded look and feel, but what if we want
    to offer more flexibility without forcing developers to rewrite or extend our
    control? By supporting control templates, we can expose the structure of our control’s
    visual tree, enabling both styling and structural changes while retaining its
    core functionality. This is an excellent way to ensure that our custom control
    seamlessly fits into a diverse array of user interfaces, providing an even greater
    degree of customization.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how this is relevant to MVVM. Consider the following – a control
    template serves to separate the logic and behavior of a control from its visual
    representation, much like how MVVM achieves loose coupling between the ViewModel
    and the View. In this sense, the control effectively serves as a ViewModel for
    the control template. It exposes properties that the template binds to. The control
    template, in turn, can be considered as the View. So, just like we are used to,
    we can use data binding in the control template and use a relative binding source
    set to `TemplatedParent` to bind to the properties of the control that the template
    is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: TemplateBinding and TemplatedParent
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming examples, we’ll use binding statements with their `RelativeSource`
    set to `TemplatedParent`. It’s worth noting that this approach performs the same
    function as the now-obsolete `TemplateBinding` markup extension. Essentially,
    setting `RelativeSource` to `TemplatedParent` manually accomplishes what `TemplateBinding`
    used to do automatically, creating a binding whose source is the control to which
    the template is applied. However, since .NET 7, the `TemplateBinding` markup extension
    has been marked as “obsolete.”
  prefs: []
  type: TYPE_NORMAL
- en: I want to quickly discuss control templates, as they reflect the MVVM philosophy.
    Whether you’re extending the visuals of existing controls or creating new ones
    from scratch, knowing how to properly structure and utilize control templates
    will make your development process more efficient and your applications more maintainable.
    I also think that being proficient in the aspects of XAML and data binding directly
    contributes to effectively applying the MVVM pattern in your projects. Without
    further ado, let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: 'The next steps show how to define a control template and apply it to the `FavoriteControl`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `RecipeDetailPage`, we can add a `ControlTemplate` to the page’s `Resource`s,
    as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how this template uses `TemplatedParent` as `RelativeSource` in its binding
    statements. By doing this, we bind to the public properties exposed by the control
    where this template will be applied, as we will see later on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following code snippet shows how we can use the key associated with the
    `ControlTemplate` (`FavoriteTemplate`), together with the `StaticResource` Markup
    extension, to assign it as the template of our `FavoriteControl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While maintaining the functionality of the `FavoriteControl`, this template
    gives an entirely different look to the control, as you can see in *Figure 11**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: FavoriteControl with an alternative template](img/B20941_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: FavoriteControl with an alternative template'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one thing missing. Remember the animation we had on the original
    control? The animation was triggered by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The original visual tree of the control is replaced by the new visual tree defined
    in the `ControlTemplate`. Therefore, the original elements are not visible and
    are not part of the current visual tree. However, those original elements do still
    exist in memory if you have references to them in your code-behind. Even though
    they are detached from the visual tree and are not visible, you can still interact
    with them using code. They just won’t have any impact on what a user sees because
    they are not in the visual tree anymore. As a result, the code responsible for
    the animation won’t crash, but there won’t be any visual effect on the screen.
    Let’s see how we can access visual elements defined on a `ControlTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing elements from a template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, when working with custom controls, UI elements are defined directly
    within the control. These controls, when given an `x:Name` attribute, can be accessed
    and manipulated from the control’s code-behind, which is a perfectly valid approach
    to defining and working with custom controls. However, when fully embracing the
    power of control templates, the need for directly defined UI elements lessens.
    Instead, the default appearance of the control should ideally be encapsulated
    within a `ControlTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration, let’s consider `FavoriteControlTemplated`, which is a variant
    of `FavoriteControl`. Unlike the original, this version doesn’t have UI elements
    defined directly within it. Instead, its default appearance is declared in a `ControlTemplate`,
    defined in the control’s `Resources`. Here’s how it looks in XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the next code block, in the constructor of the `FavoriteControlTemplated`
    class, a default template is assigned when no other template is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If the `ControlTemplate` property is null, it means the developer hasn’t specified
    a different template. In that case, the default template from the control’s `Resources`
    is retrieved and assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnApplyTemplate` method is called when the control template is fully loaded.
    This is where the `GetTemplateChild` method can be used to access specific elements
    within the template, like `Image` in our template, which we assigned the name
    `scalableContent`. The following snippet shows how we use the `GetTemplateChild`
    method to get a `VisualElement` named `scalableContent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a `VisualElement` with the name `scalableContent` is retrieved, it can
    be manipulated programmatically. For example, in the `AnimateChange` method, scaling
    animations can be applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: By adopting control templates and leveraging methods such as `GetTemplateChild`,
    we can maintain a clean separation between the logic and visual representation
    of our control, allowing more flexible and reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s update the `FavoriteTemplate` we created earlier on `RecipeDetailPage`
    by giving a certain UI element the name `scalableContent`, using `FavoriteControlTemplated`
    instead of `FavoriteControl`. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On `RecipeDetailPage`, update the `FavoriteTemplate`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By assigning `scalebleContent` as the name of the `Switch` control, it can be
    picked up later by the `FavoriteControlTemplated` control and have animations
    applied to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As shown in the next code block, let’s use the `FavoriteControlTemplated` custom
    control instead of the `FavoriteControl` from earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the app at this stage, you’ll notice the updated favorite indicator.
    When we tap the control, you’ll notice the `Switch` is scaled. This is because
    it was named `scalableContent` in the template. If you update `RecipeDetailPage`
    and leave out the assignment of the `ControlTemplate` property (`ControlTemplate="{StaticResource
    FavoriteTemplate}"`) and run the app again, you’ll see the visualization using
    the hearts we had earlier. That’s because when no `ControlTemplate` is assigned
    explicitly, the control will load the default control template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s worth noting that any control template that includes an element named `scalableContent`
    will be compatible with this code. In other words, as long as the template has
    a UI element with the name `scalableContent`, our `FavoriteControlTemplated` class
    will be able to retrieve it and apply the scaling animation. However, what if
    there’s no `scalableContent` element in the template? No worries – the control
    is designed to degrade gracefully. If the element isn’t found, all functionalities
    of the control will remain intact; only the animation will be absent. This flexibility
    allows developers to create a wide array of visual styles while the behavior of
    the control remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: The principle of separation of concerns is central to MVVM and vital to creating
    maintainable software. When you’re crafting custom controls, this same principle
    can be extended through the use of control templates. However, it’s worth mentioning
    that fully implementing control templates may not always be necessary. For simpler
    controls that are unique to your application and maintain a consistent appearance,
    directly defining UI elements within the control itself is both a practical and
    valid approach. This allows you to balance complexity with flexibility, enabling
    you to choose the approach that best suits your project’s specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the powerful possibilities offered by custom controls
    and control templates in .NET MAUI, all within the context of the MVVM architecture.
    From understanding the basics of custom controls to creating bindable properties,
    we’ve delved into the intricacies of data binding on custom controls. We also
    explored how to add interactivity to our control and how commands can be exposed
    and dealt with. Furthermore, we dived deep into the flexibility and scalability
    offered by control templates. Collectively, these techniques enhance reusability
    and adhere to the principles of separation of concerns. Mastering the art of creating
    UIs – whether through XAML or code-behind – and understanding how to craft MVVM-friendly
    controls with bindable properties and commands contributes tremendously to being
    proficient in MVVM. Whether it’s a simple control with a hardcoded appearance
    or a complex, template-driven control, the key takeaway is understanding when
    and how to appropriately apply these approaches to create maintainable, adaptable,
    and highly customizable UI components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore localization within the context of MVVM,
    enabling our UI components to be not only flexible and maintainable but also globally
    adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a custom control using handlers: [https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/create)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Customize controls with handlers: [https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize](https://learn.microsoft.com/dotnet/maui/user-interface/handlers/customize)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More about control templates: [https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate](https://learn.microsoft.com/dotnet/maui/fundamentals/controltemplate)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bind to a templated parent: [https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent](https://learn.microsoft.com/dotnet/maui/fundamentals/data-binding/relative-bindings#bind-to-a-templated-parent)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
