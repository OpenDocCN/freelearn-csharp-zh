- en: Multiplayer Setup
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人设置
- en: The desire of every indie game developer is to make a multiplayer game. The
    reality is, creating multiplayer games is difficult. There are a lot of scenarios
    that you need to take into consideration as a game designer/developer. Besides
    the technical complexities that are involved in the nature of creating online
    multiplayer games, there are also game-play elements that you will need to consider.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个独立游戏开发者的愿望都是制作一个多人游戏。现实是，创建多人游戏是困难的。作为游戏设计师/开发者，您需要考虑很多场景。除了创建在线多人游戏所固有的技术复杂性外，还有游戏玩法元素需要考虑。
- en: The purpose of this chapter is to give you a good overview of the out-of-box
    networking functionality using the new Unity networking paradigm. This is a complex
    topic, and as such we cannot cover everything in this chapter. A whole new book
    will be required to really dive into the details.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是为您提供一个使用新的Unity网络范式对开箱即用的网络功能的好概述。这是一个复杂的话题，因此我们无法在本章中涵盖所有内容。要真正深入了解细节，将需要一本全新的书籍。
- en: Having said that, I have prepared this chapter to include one simple project,
    which will be used to illustrate the fundamentals of networking. I will then show
    you how to network-enable our own game objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我已经准备了这一章，包括一个简单的项目，该项目将用于说明网络的基础知识。然后我会向您展示如何使我们的游戏对象具备网络功能。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Heads-up display
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头戴式显示器
- en: Completing a HUD design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成HUD设计
- en: Integrating the code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成代码
- en: Here we go!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们开始！
- en: Challenges of a multiplayer game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏的挑战
- en: A general rule of thumb is, if you don't need to enable your game to be multiplayer,
    don't! It just adds a whole lot of complexity and extra requirements and specifications
    that you will need to start worrying about. But if you must, then you must!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的规则是，如果您不需要使您的游戏成为多人游戏，那么就别这么做！这只会增加大量的复杂性和额外的需求和规范，您将需要开始担心。但如果是必须的，那么就必须这么做！
- en: 'You probably know by now that creating even the simplest multiplayer game has
    its own challenges you will need to address as the game designer. There are different
    types of online multiplayer game design, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能已经知道，即使是创建最简单的多人游戏也有其挑战，作为游戏设计师，您需要解决这些问题。存在不同类型的在线多人游戏设计，如下所示：
- en: Real-time multiplayer games
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时多人游戏
- en: Turn-based multiplayer games
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮流制多人游戏
- en: Asynchronous multiplayer games
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步多人游戏
- en: Local multiplayer games
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地多人游戏
- en: The most challenging out of all the different types of multiplayer games is
    real-time multiplayer gaming. This is because all players have to be synchronized
    in a proper and effective way with the latest game state at any given time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有不同类型的多人游戏中，最具挑战性的是实时多人游戏。这是因为所有玩家必须在任何给定时间以适当和有效的方式与最新的游戏状态同步。
- en: That is, if we have Player A perform a specific action, Player B will see the
    action at the same time on his or her screen. Now, consider we have another player
    join, say Player C; Players A and B will need to synchronize with Player C, and
    in turn Player C will need to synchronize its own environment with Player A's
    and Player B's state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们让玩家A执行特定的动作，玩家B将同时在他的或她的屏幕上看到这个动作。现在，考虑我们还有另一个玩家加入，比如说玩家C；玩家A和B需要与玩家C同步，而玩家C反过来需要将其自己的环境与玩家A和玩家B的状态同步。
- en: Not only does the actual position/rotation of the players have to be synchronized,
    but also all of the player data. Now, imagine what will happen when you multiply
    this by 100, 1,000, or 1,000,000 connected players.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅玩家的实际位置/旋转需要同步，所有玩家数据也需要同步。现在，想象一下当您将这个数字乘以100、1,000或1,000,000个连接的玩家时会发生什么。
- en: For a real-world multiplayer game, what we will cover here is not enough, and
    what Unity provides out of the box is not enough either. Chances are you will
    need to write your own server-side code to handle the player data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现实世界的多人游戏，我们在这里涵盖的内容是不够的，Unity提供的开箱即用的功能也不够。很可能您需要编写自己的服务器端代码来处理玩家数据。
- en: Now you can see the challenge involved in designing and developing multiplayer
    games, we can start by building our first multiplayer game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以看到设计和开发多人游戏所涉及的挑战，我们可以从构建我们的第一个多人游戏开始。
- en: Initial multiplayer game
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始多人游戏
- en: The best way to learn about multiplayer games is by looking at a simple example.
    The following project is based on the Unity networking tutorial but has been extended
    to have some other features implemented that will be helpful in the implementation
    of networking in our RPG.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 了解多人游戏的最佳方式是通过查看一个简单的示例。以下项目基于 Unity 网络教程，但已经扩展了一些其他功能，这些功能将有助于我们在 RPG 中实现网络功能。
- en: Fundamental networking components
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本网络组件
- en: Since the first edition of the book, a lot of technical and architectural changes
    have occurred within the Unity engine. Networking is one of the areas that has
    improved drastically since the publication of the first edition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自从本书第一版以来，Unity 引擎内部发生了许多技术和架构上的变化。自第一版出版以来，网络领域有了显著改进。
- en: 'Let''s take a look and see how we can quickly get started. The first thing
    you will need to do is download the *Network Lobby* asset from the Asset Store,
    as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何快速开始。首先你需要做的是从资源商店下载 *网络大厅* 资产，如下截图所示：
- en: '![](img/00169.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: This is a great starting point, as we have a generic network lobby to start
    off with, so we don't have to waste time creating everything from scratch!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的起点，因为我们有一个通用的网络大厅可以开始，所以我们不必浪费时间从头开始创建一切！
- en: 'We need to get familiar with some networking components that will be used for
    the creation of our network-enabled games. These components are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要熟悉一些将用于创建我们的网络游戏的一些网络组件。这些组件如下：
- en: Network Manager: `NetworkManager` is a high-level class that allows you to control
    the state of a networked game. It provides an interface in the editor to control
    the configuration of the network, the prefabs used for spawning, and the scenes
    to use for different network game states.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络管理器：`NetworkManager` 是一个高级类，允许你控制网络游戏的网络状态。它提供了一个编辑器界面来控制网络的配置、用于实例化的预制体以及用于不同网络游戏状态的场景。
- en: 'Network Lobby Manager: `NetworkLobbyManager` is a specialized type of `NetworkManager`
    that provides a multiplayer lobby before entering the main play scene of the game.
    Ideal for matchmaking.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络大厅管理器：`NetworkLobbyManager` 是一种特殊的 `NetworkManager` 类型，在进入游戏的主玩场景之前提供多人游戏大厅。非常适合匹配。
- en: 'Network Manager HUD: This provides a default user interface for controlling
    the network state of the game. It also shows information about the current state
    of `NetworkManager` in the editor.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络管理器HUD：这提供了一个默认的用户界面来控制游戏的网络状态。它还显示了编辑器中 `NetworkManager` 的当前状态信息。
- en: 'Network Identity: The `NetworkIdentity` component is at the heart of the new
    networking system. This component controls an object''s network identity, and
    it makes the networking system aware of it.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络身份：`NetworkIdentity` 组件是新的网络系统的核心。该组件控制对象的网络身份，并使网络系统了解它。
- en: 'Network Transform: The `NetworkTransform` component synchronizes the movement
    of game objects across the network. This component takes authority into account,
    so `LocalPlayer` objects synchronize their position from the client to the server,
    then out to other clients. Other objects (with server authority) synchronize their
    position from the server to clients.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络变换：`NetworkTransform` 组件同步网络中游戏对象的移动。该组件考虑了权限，因此 `LocalPlayer` 对象从客户端同步位置到服务器，然后同步到其他客户端。其他对象（具有服务器权限）从服务器同步位置到客户端。
- en: My tank networking project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的坦克网络项目
- en: It is assumed that you have downloaded and imported the Network Lobby asset.
    We will be using two scenes to illustrate the concept. The first scene will be
    the lobby scene, and the second scene will be where the game will take place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经下载并导入了网络大厅资产。我们将使用两个场景来展示这个概念。第一个场景将是大厅场景，第二个场景将是游戏进行的场景。
- en: 'Go ahead and create a scene, and name it `NetworkingGameLobby`. This is where
    the game will start. Take a look at the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一个场景，并将其命名为 `NetworkingGameLobby`。游戏将从这里开始。请看以下截图：
- en: '![](img/00170.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: My tank network lobby
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我的坦克网络大厅
- en: Add the `LobbyManager` prefab to the scene. Select the `LobbyManager` GameObject
    in the scene, and note the `LobbyManager` component in the Inspector window. There
    are several things to notice here. First, you will need to assign the Lobby Scene
    and the Play Scene properties. We need to assign our `NetworkingGameLobby` scene
    to the Lobby Scene property, and the `NetworkingGamePlay` scene to the Play Scene
    property. Next, you will need to assign the `Game Player` Prefab property with
    the `Player` prefab. Don't worry, we will create the `Player` prefab next. Finally,
    we need to configure the Spawn Info section, and register the prefabs (GameObjects)
    that will be spawned during game time; in our case, these will be the Bullet and
    the Enemy Tanks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Adding a player character
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add a simple player character. You can really use any primitive
    GameObject to represent your PC; I will create my player to take the shape of
    a simple tank. Take a look at the following screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00171.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot will illustrate the hierarchy of the `Tank` GameObject:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00172.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: I will not cover how to create the GameObject, as you should be able to do that
    very easily by now. What I will cover, is how to enable the new network-enabled Tank
    GameObject.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: We will attach two network components to the `Tank` GameObject. The first one
    will be `NetworkIdentity`, which can be added by selecting the `Tank` GameObject,
    and from within the Inspector window, select Add Component | Network | Network
    Identity.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done adding the component, make sure to check the Local Player
    Authority property checkbox, as shown in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Local Player Authority allows the object to be controlled by the client that
    owns it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `NetworkTransform` component to the Tank GameObject.
    Again, selecting the `Tank` GameObject, from the Inspector window, click Add Component
    | Network | NetworkTransform to add the component:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00174.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: We will keep the default values for the `NetworkTransform` component. With the
    exception of the rotation properties, since we are only rotating on the *Y*-axis,
    we don't have to send all XYZ information, so change that to Y (Top-Down 2D) and
    increase the interpolate Rotation field to 15, and change the Compress Ratio to
    High. You can read more about the different properties on your own using the online
    documentation. The main attribute you might want to adjust is the Network Send
    Rate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to create a script that will allow us to control the movement
    of the Tank. Go ahead and create a new C# script and name it `MyPlayerController.cs`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a listing of the script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code is straightforward, but there are some important concepts that we need
    to discuss. First and foremost, you will notice that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '`NetworkBehaviour` is used to work with objects with the `NetworkIdentiy` component.
    This allows you to perform network-related functions such as `Commands`, `ClientRPCs`,
    `SyncEvents`, and `SyncVars`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Variable synchronization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Synchronizing variables is one of the important aspects of a multiplayer game.
    If you recall, one of the challenges of multiplayer games is the ability to make
    sure all of the key data for the game is synchronized across the server and the
    clients. This is accomplished by the `SyncVar` attribute. You will see how this
    is applied in the next script, which we will create for the health of the unity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Network callbacks
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network callbacks are functions that are invoked on the `NetworkBehaviour`
    script for various network events. They are listed as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStartServer()` is called when an object is spawned on the server, or when
    the server is started for objects in the scene'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStartClient()` is called when the object is spawned on the client, or when
    the client connects to a server for objects in the scene'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSerialize()` is called to gather state to send from the server to the clients'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnDeSerialize()` is called to apply state to objects on clients'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnNetworkDestroy()` is called on clients when the server tells the object
    to be destroyed'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnStartLocalPlayer()` is called on clients for player objects for the local
    client only'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRebuildObservers()` is called on the server when the set of observers for
    an object is rebuilt'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnSetLocalVisibility()` is called on a host when the visibility of an object
    changes for the local client'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnCheckObserver()` is called on the server to check the visibility state for
    a new client'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `PlayerController.cs` script, you will notice that we are using `OnStartClient()`
    to highlight the local player by changing its material color to blue.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Sending commands
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Commands are how clients request a function to be performed on the server. In
    a server authoritative system, clients can only do things through commands. Commands
    are run on the player object on the server that corresponds to the client that
    sent the command. This routing happens automatically, so it is impossible for
    a client to send a command for a different player.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: A command must begin with the prefix "Cmd" and have the `[Command]` custom attribute
    on it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In our `PlayerController.cs` script, when the player fires, it sends a Command
    to the server using the `CmdFire()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Client RPC calls
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client RPC calls are a way for server objects to cause things to happen on client
    objects. This is the reverse direction to how commands send messages, but the
    concepts are the same. Client RPC calls, however, are not only invoked on player
    objects; they can also be invoked on any `NetworkIdentity` object. They must begin
    with the prefix "Rpc" and have the `[ClientRPC]` custom attribute.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: You will see an example of this on the `Health.cs` script, which we will be
    creating next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We will also need a way to keep track of our player character's health. This
    will be done using a new script called `Health.cs`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来跟踪玩家角色的健康状态。这将通过一个新的脚本`Health.cs`来实现。
- en: 'A listing of the script is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本列表如下：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that, in this script, we are also inheriting from `NetworkBehaviour`.
    The two main items I want to bring to your attention are the `SyncVar`, the `ClientRpc`,
    and the `Start()` functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个脚本中，我们还在继承自`NetworkBehaviour`。我想重点介绍的两个主要项目是`SyncVar`、`ClientRpc`和`Start()`函数。
- en: We want to synchronize the player's health across the network. To do this, we
    use the `SyncVarNetworkBehaviour`. `SyncVar` can be any basic type, not classes,
    lists, or other collections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在网络中同步玩家的健康状态。为此，我们使用`SyncVarNetworkBehaviour`。`SyncVar`可以是任何基本类型，但不能是类、列表或其他集合。
- en: When the value of *SyncVar* is changed on the server, it will be sent to all
    of the ready clients in the game. When objects are spawned, they are created on
    the client with the latest state of all *SyncVars* from the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器上*SyncVar*的值发生变化时，它将被发送到游戏中所有准备好的客户端。当对象被实例化时，它们将在客户端上创建，并具有来自服务器的所有*SyncVars*的最新状态。
- en: The `OnStartClient()` function makes sure that each object with the `Health.cs`
    script attached to it will have the most up-to-date value to display on the health
    bar UI.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStartClient()`函数确保所有附加了`Health.cs`脚本的物体都将具有最新的值，以便在健康条UI上显示。'
- en: I want to take a moment and make sure I give you a crucial pointer here. Assume
    we are running a networked game session, and we have the `Host`, `Player A`, and
    `Player B` connected and going about their business. During the gameplay, `Player
    A` and `Player B` have their health value changed. Now, we have a third player
    connect to the game, `Player C`. If `Start()` is not implemented, the client for
    `Player C` will have the correct data synchronized for all of the GameObjects
    with the `Health.cs` script; however, the data will not reflect correctly on the
    UI because we need to have a trigger for that to happen. This can be handled in
    the `Start()` function, as shown in the code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里花点时间确保我给你一个关键提示。假设我们正在运行一个网络游戏会话，我们有`主机`、`玩家A`和`玩家B`连接并正在忙于自己的事情。在游戏过程中，`玩家A`和`玩家B`的健康值发生变化。现在，有第三个玩家连接到游戏，即`玩家C`。如果没有实现`Start()`，`玩家C`的客户端将具有所有带有`Health.cs`脚本的GameObject的正确数据同步；然而，数据将不会正确反映在UI上，因为我们需要一个触发器来实现这一点。这可以在`Start()`函数中处理，如代码所示。
- en: The next function is the `RpcRespawn()` function. In the `TakeDamage()` function,
    we check the health of the current GameObject. If the health drops below zero,
    we check to see if the `destroyOnDeath` Boolean variable is set. If it is not
    set, we go ahead and reset the `currentHealth` value to `maxHealth` value, and
    we use the `RpcRespawn()` method to re-spawn the player at the origin. Remember
    this function is executed on all clients!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数是`RpcRespawn()`函数。在`TakeDamage()`函数中，我们检查当前GameObject的健康值。如果健康值降至零以下，我们检查`destroyOnDeath`布尔变量是否设置。如果没有设置，我们将`currentHealth`值重置为`maxHealth`值，并使用`RpcRespawn()`方法在原点重新生成玩家。记住，这个函数在所有客户端上都会执行！
- en: Within the function, we check to see if the caller is the local player by checking
    the `isLocalPlayer`variable. Yes, creating a multiplayer game does get confusing!
    This will become more apparent as you start experimenting with it more.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我们通过检查`isLocalPlayer`变量来查看调用者是否是本地玩家。是的，创建多人游戏确实会让人感到困惑！当你开始更多地进行实验时，这一点将变得更加明显。
- en: Creating the cannonball for the tank
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建坦克的炮弹
- en: Let's create a prefab that will represent our cannonballs! Very simply, create
    a sphere and make it the same size as the nozzle of your tank gun.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个预制体来代表我们的炮弹！非常简单，创建一个球体并使其与坦克炮的喷嘴大小相同。
- en: 'We will need to attached the following components to the Canon Ball GameObject:
    `NetworkIdentity`, `NetworkTransform`, `Rigidbody`, and `Bullet.cs` scripts.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将以下组件附加到炮弹游戏对象上：`NetworkIdentity`、`NetworkTransform`、`Rigidbody`和`Bullet.cs`脚本。
- en: Make sure that you set the `Use Gravity` property to `False` on the `Rigidbody`
    component. Also, make sure that both Server Only and Local Player Authority properties
    are *False* on the `NetworkIdentity` component. On the `NetworkTransform` component,
    change `Network Send Rate` to `0`. Once we generate the object on the server,
    the physics will take care of the motion on each client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script called `Bullet.cs`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing for the script is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All we are doing here is detecting a collision. If there is a collision, we
    get the `Health` component. If the `Health` component is not null, we call the
    `TakeDamage()` function and pass it a value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from the `Health.cs` script, the `TakeDamage()` function reduces
    `currentHealth` of the player, which in return is a `SyncVar` that gets updated
    on all active clients.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'One item we did not discuss is the idea of a `hook`. A `SyncVar` can have a
    `hook`. Think of a hook as an event handler. The hook attribute can be used to
    specify a function to be called when the `SyncVar` changes value on the client:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `OnChangeHealth()` function is responsible for updating the UI canvas for
    displaying our health value:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Go ahead and also make a prefab of the cannonball and delete the instance from
    the scene.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you have assigned the proper prefab associations that are required
    on each script. For instance, the `Tank` GameObject's `PlayerController.cs` script
    needs a reference to the cannonball prefab, and also the canon spawn location.
    The `Health.cs` script needs a reference to the HealthBar foreground image and
    so on.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tank prefab and configuring the network lobby manager
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created our `Tank` GameObject and attached all of the necessary
    components and scripts to it, we need to make a prefab of it. This is because
    we will let `NetworkLobbyManger` spawn our player character, and in order for
    it to be able to do so, it needs to refer to a prefab that is a representation
    of your player character.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkLobbyManager` has a `Spawn Info` section that you can assign the
    `Player` Prefab, determine if the `NetworkLobbyManager` can Auto Create Player
    and the `Player Spawn` Method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There is also a section for `Registered Spawnable` Prefabs. We need to register
    all of the GameObjects that will be spawned by the `NetworkServer`. For instance,
    the Canon Ball prefab will need to be registered here so that we can spawn it
    across the network on different clients.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Network Lobby Manager` GameObject in the scene, and in the Inspector window
    assign the appropriate prefabs as needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of how the `NetworkLobbyManager` should look at this point:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Lobby manager
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you are ready to test out what we have built so far. Go ahead
    and create a stand-alone version of your game using the Build Settings window.
    Once you have your build ready, launch two instances of the application. We will
    use one instance to host the game, and the other to connect as a client, as shown
    in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00176.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot illustrates how your game instance will look when
    you run it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00177.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshots illustrate how your screen will look during runtime.
    The game is created on an Android tablet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00178.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'The second player selects LIST SERVERS and gets available matches, and clicks
    JOIN to enter the room, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00179.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Once everyone is ready, the game starts. Notice that each player has a unique
    tank color assign based on their color selection in the lobby.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, note that each client has highlighted the player
    character it controls, that is, the tank it controls. It will be difficult to
    capture the fire command, but you can go ahead and use the Space Bar to fire the
    canon, and it will be triggered accordingly on all active clients.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that the health of each tank will be reflected accurately
    if they do get a hit. Now we are ready to create an enemy to illustrate the non-player
    character in the game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Adding the enemy tank
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to add some of the non-player characters to our multiplayer demo.
    Adding the Enemy Tank will be simple as we will use our Tank prefab as a base.
    Go ahead and drop the Tank prefab into the scene, and change the name to `TankEnemy`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `MyPlayerCharacter.cs` script from the GameObject. We will create
    a separate script as the controller for the enemy tank. I have also gone ahead
    and applied different material to the enemy tank so that we can visually distinguish
    which tanks will be controlled by players and which ones will be non-player. Take
    a look at the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00180.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Enemy tank setup
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates how your `Tank` and `TankEnemy` prefabs
    should look. The main difference between the two is the controller script. Tank
    has the `MylayerController.cs` script, and `TankEnemy` has the `EnemyController.cs`
    script.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'A listing of the `EnemyController.cs` script is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The script continuously searches for all players that are active in the scene
    and makes a list of them. Then it finds the closest one to itself. Once it determines
    which player is closest, it rotates to face the player.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: After that, it calculates the distance between itself and the selected player;
    if the distance is shorter than the acceptable threshold, then it starts firing
    at the player. Each time the enemy tank fires, it actually calls a `[Command]`
    named `CmdFire()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: This function is run on the server; it instantiates a cannonball prefab and
    spawns it on the network.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The `EnemyController.cs` script also has a `SyncVar` for the `playertoAttack`
    variable, with a `hook` attached as an `OnChangePlayerToAttack()` function. This,
    in turn, makes sure that all clients get updated with the latest data on each
    Enemy `Tank` GameObject.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The `Health.cs` script works the same as it does on the `Tank` GameObject.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more item we need to cover: the spawning of the `Enemy Tanks`
    by the server. We can do this easily by creating another empty GameObject and
    naming it `Enemy Spawner`. We need to attach a `NetworkIdentity` component and
    make sure we set the `Server Only` property to `True`. This will make sure that
    only the server can instantiate the enemy objects.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `EnemySpawner.cs` scripts. The listing is as
    follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code technically takes the prefab provided as the enemy tank and randomly
    spawns each enemy tank within a range over the network.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all of your prefabs have been assigned in the Inspector window for
    both the `Enemy Spawner` GameObject and the `TankEnemy` GameObject. Create a prefab
    of your `TankEnemy` if you have not done so already, and delete it from the scene.
    Do not delete the `Enemy Spawner`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: We need to register the `TankEnemy` prefab with the `NetworkLobbyManager`. Go
    ahead and select the `Network Manager` GameObject, and from the Inspectorwindow,
    add a new Prefab to the `Registered Spawnable` Prefabs option.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `Network Manager` should now look as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00181.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Lobby Network Manager Setup
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Building and testing
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are ready to do our final test. Go ahead and build the stand-alone version
    of the project, and launch a new instance of the game. Player 1 will create the
    room, and the rest of the players will join the game, as shown in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Joining a game demo
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that right after initialization, all of the enemy tanks
    will rotate toward the player character tank and if within range, they will start
    firing at it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the runtime of the game:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Notice that while I was trying to capture the screen, the enemy tanks were merciless
    and fired at Player 4 continuously. You can see that my health bar has reduced
    drastically. You can also see that one of the enemy tanks has also received some
    damage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: I assure you that I had nothing to do with the damage taken by the enemy tank;
    it was actually caused by friendly fire. Yes, at the moment, the enemy tanks are
    not smart enough to hold fire if another team member is in the line of fire!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: I will let you handle the implementation of that on your own. Shouldn't be too
    complex.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Use Raycasting to make sure there is no object between the enemy tank and the
    player prior to firing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have just created your first multiplayer game! As mentioned
    previously, creating, maintaining, and hosting a multiplayer game is no small
    task, and covering every single aspect on how to do it is simply impossible in
    a few pages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to give you the foundation and the fundamentals that you can
    take and expand upon. I would encourage you to take some time to study what we
    have just covered and do some more reading on the material, even though not much
    exists. The truth is that you will need to do a lot of experimentation and trial
    and error on your own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the basics, let's go ahead and apply what we have learned to
    our RPG assets.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Network-enabling RPG characters
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make life easier, I have decided to create a new scene that will
    be used to test and implement our network-enabled characters. This example will
    show you how to network-enable the player character, and also how to synchronize
    the player character data such as inventory items across the network, as well
    as provide you with the ability to network-enable the non-player character and
    make it synchronize its data across the clients.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Creating a scene for our RPG
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the tank demo in the previous section, we will use two new scenes
    to illustrate the RPG networking concept here. We will create two scenes, one
    called `NetworkingMenu` and the other `DeathMatchMultiplayer`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkingMenu` scene is our lobby scene, so it will be exactly the same
    as the Tank Multiplayer lobby scene, with the exception that the player character
    will be replaced by the Barbarian prefab, and the `Registered Spawnable` Prefabs
    will be different. We shall see this later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DeathMatchMultiplayer` scene, I have the following level design:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00184.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Level design spawn enemy
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Your lobby scene should look something like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00185.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: The next step is to make sure our GameObjects are network-enabled.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Networked player character
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go ahead and drag the player prefab you have created into the scene. We will
    use it as a base to create a new prefab, which will be used for the networked
    version of the game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and remove the existing `BarbarianCharacterController.cs` and `BarbarianCharacterCustomization.cs`
    components from the instance. We will create new scripts that are network-enabled
    and use them. Rename the `PC` GameObject instance to `PC-C6-Network`. Now make
    a prefab of the instance. You should now have a new prefab named `PC-C6-Network`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and attach the following components to the prefab: `NetworkIdentiy`,
    `NetworkTransform`, and `NetworkAnimator`, by using the `Inspector` Window and
    selecting Add Components *|* Network *|* <component name>.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: On the `NetworkIdentity` component, set `Local Player Authority` to `True`.
    On the `NetworkTransform` component, change Transform Sync Mode to Sync Rigidbody
    3D. On the `NetworkAnimator` component, you will need to drag the `Animator` components
    attached to the GameObject into the `Animator` slot.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: You will need to select the `Animator` component and drag it right down into
    the `Animator` slot on the `NetworkAnimator` components.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a new character controller so that it is network compatible.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Create a new C# script and call it `BarbarianCharacterNetworkController.cs`.
    Attach the script to the `PC-C6-Network` prefab. The new character controller
    is a stripped-down version of the original character controller.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'The listing for it is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first thing you should notice is that we are inheriting from `NetworkBehaviour`
    instead of `MonoBehaviour`. This is necessary if we want to enable certain network
    behaviors on the GameObject. Take a look at the following screenshot:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00186.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Level setup for RPG network
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some of the variables that need to be synchronized across
    the network for each player character that is connected. These variables are `enemyToAttack`
    and `Health`. There are two more variables, `Shield` and `Helmet`, which we will
    discuss later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update()` function, we need a way to check and make sure that it is
    the local player before giving the controller the chance to execute the player.
    This is done by having the following code check to see if the current client is
    the local player:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will make sure that the code runs only for the current client (player).
    The rest of the code in the `Update()` function checks to see if the enemy is
    in sight, and makes sure the player character is facing the enemy to attack.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player is in attack mode and the enemy is in our view, we set `enemyInSight`
    to `True` and `enemyToAttack` to the enemy GameObject, which is stored in the
    `hitAttack` variable of type `RacastHit`. The important element here is the `CmdEnemyToAttack()`
    function. The client needs to send a command to the server telling the server
    who the target of attack is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will make sure that the data is registered correctly on the server and
    that it is synchronized to other clients. We also have another function, called
    `CmdEnemyTakeDamage()`, which is used to reduce the health of the enemy character
    on the server. The server then calls the `RpcEnemyTakeDamage()` function to synchronize the
    health value of the enemy across all clients:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This idea is a bit confusing at first, but it will be clearer as you start to
    study it more carefully.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have the following function to send commands to the server when the
    player dies:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding functions make sure that the player character is dead and destroyed
    on all connected clients at the moment of the game.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the following hook functions are used by the `SyncVar` on the
    Health and `enemyToAttack` variables:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This idea is also a bit confusing at first, but it will be clearer as you start
    to study it more carefully.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: If you have not done so already, apply and save all of your changes to your
    `PC-CC-Network` prefab.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, your character is ready to be integrated with `NetworkManager`*;* you
    can drag and drop the prefab into the `Player` Prefab slot, and build a stand-alone
    version to test out your character movement and synchronization.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Networked non-player character
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like the player character network-enabled prefab, we will use the non-player
    character prefab as our base to get started. Go ahead and create an instance of
    your NPC in the scene.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and remove the existing `NPC_Movement.cs` component from the prefab.
    Rename the Prefab to `B1-Network` and attach the following components to it: `NetworkIdentity`,
    `NetworkTransform`, and `NetworkAnimator`, by selecting `Add Component` *|* Network
    *|* <component name> from the Inspector window.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `NetworkIdentity` component, set `Local Player Authority` to `True`*;* in
    the `NetworkTransform` component, set `Transform Sync Mode` to `Sync Transform`;
    and for the `NetworkAnimator` component, set the `Animator` slot to the `Animator`
    controller attached to the prefab, by dragging it and dropping into the slot,
    as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'We now need to create a new script for our NPC movement that is network-enabled.
    Go ahead and create a new C# script, and name it `NPC_Movement_Network.cs`. A
    listing of the scripts is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are a few variables that have been indicated as `SyncVars`*;* these are: `die`, `distance`, `direction`, `angle`, `playerInSight`, `fieldOfViewAngle`, `calculatedAngle`, `playerToAttack`,
    and `Health`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Some of the `SyncVars` have a `hook`*;* these are `Health`, `playerToAttack`,
    `playerInSight`, and `die`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Update()` function, we check to make sure we are the server by the
    following line:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we are the server, we use the `CmdUpdateNetwork()` and `RpcUpdateNetwork()`
    functions to perform our duties. These are just for the movement and action for
    the NPC. The key here is the `SyncVars` and `hook` functions that are used to
    synchronize the NPC data to all clients:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is all we need for the NPC. Go ahead and add the script to the prefab and
    apply the changes. Save it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new NPC prefab should have the following components attached:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing player customization and items
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for this to work, we need to perform configure and create several more
    new inventory item prefabs. I will use two inventory items to demonstrate this
    particular point.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: I will use one of the `Helmet` prefabs from my inventory items. Duplicate it,
    and remove the `InventoryItemAgent.cs` component. We will create a new script
    that is network-enabled, as we did for our PC and NPC.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Attach the following components to the instance: `NetworkIdentity` and `NetworkTransform`,
    using Add Component | Network | <component name> from the Inspector window*:*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00188.jpeg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Create a new script named `InventoryItemAgent_Network.cs`. The listing is as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All this script does is assign the inventory item to the player character using
    the `PlayerArmourChanged()` function in the `CharacterController_Network.cs` script.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayerArmourChanged()` function uses another script we need to create that
    is network enabled, and that is the `CharacterCustomization_Network.cs` script.
    I will not list the script here as it is very long. You can look at the script
    in the code supplied with the book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Spawning NPCs and other items
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need a way to spawn our NPC as well as the inventory items we will be using
    for the next demonstration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In the Hierarchy window, right-click and select Create Empty*;* this will create
    an `Empty` GameObject. Rename it `SpawnEnemy`, and add a `NetworkIdentity` component
    to it by selecting Add Component | Network | NetworkIdentity from the Inspector
    window.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new script called `EnemySpawn_Network.cs`. The listing is
    as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The script is very simple, as you can see. We are just referencing the GameObjects
    that represent the prefabs for the NPC and inventory items prefab.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Attach the new script to the `SpawnEnemy` prefab in the Hierarchy Window.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Testing our network-enabled PC and NPC
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have all of the assets needed to test out our network-enabled
    RPG characters. There is one final step that we need to perform if you have not
    done so already.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Select the `NetworkManager` GameObject in the Hierarchy window, and from the
    Inspector window, you will need to make sure certain things have been assigned
    in the *Spawn* Info section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*Player Prefab* should be assigned to your player character prefab. Mine is
    named `PC-CC-Network-1`. Make sure Auto Create Player is set to `True`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: You will also register your NPC prefabs and other network-enabled non-character
    prefabs in the Registered Spawnable Prefabs. I have the barbarian prefab named
    `B1-Network-1` assigned, `barbarian_helmet_01_LOD0_Network`, and `shield_01_LOD0_Networ`*k*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00189.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Alright, at last, we can do a build. Let''s go ahead and make a stand-alone
    build of our game. Make sure that the current scene is in the build configuration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00190.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Go ahead and launch two instances of the build. Make one of them the host, and
    the other the client.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00191.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, we have started a client as a server and the player
    character has picked up one of the inventory items, a shield. When we connect
    the second client, it should correctly take into consideration the current state
    of all PCs and NPCs active in the game:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: Keeping both of the instances running, use the Unity IDE to connect the third
    client. You can use the client to perform debugging on the client end, and also
    to see what is going on.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00193.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see all of the player characters and how
    they have been accurately synchronized with one another. Select B1-Network-1 GameObject
    from the Hierarchy Window, and use one of the client instances to take the player
    character and attack the NPC.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pause the editor and inspect the variables and how they have been properly
    synchronized, as shown in the following screenshot:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: What's next?
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have witnessed, network programming is simple, but at the same time,
    it can be difficult. The difficulty lies in managing and understanding the synchronization
    of the data between all players in an efficient and meaningful way.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: It can actually get a bit more involved if you are truly considering creating
    a game with a large number of clients. Unity networking will not be able to handle
    that; you will need to create your own backend server managers and messaging systems.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: What we have covered in this chapter will give you a good understanding to take
    it to the next level. Keep on coding until we meet again!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at network programming using the Unity networking
    components. The main objective of the chapter was to introduce you to the fundamentals
    of networking in Unity by implementing two samples.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by discussing some of the challenges you will face as
    a game designer and developer for a multiplayer game. One of the main questions
    raised is whether you really need to invest the time and energy to create a multiplayer
    mode for your game. Assuming you really do want or need to create a multiplayer
    game, we started by looking at the different types of multiplayer games popular
    today.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: We then went on with our first example of a simplified multiplayer game. The
    multiplayer game we developed are real-time, that is, all clients are synchronized
    with one another based on the activity on each active player's state; namely,
    the position, rotation, movement, and other important data needs to be synchronized
    with all clients connected to the game session.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the fundamentals of Unity's networking components, such as the
    Network Manager, Network Manager HUD, Network Identity, and Network Transform.
    These are the base components that are used to illustrate multiplayer programming
    in Unity. Once we understood what these components are used for, we started with
    a simple sample.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: We created a simple tank game that demonstrated how to put together all of the
    essential components for a multiplayer game. We created the necessary player character
    prefab with the appropriate network-enabled scripts and components. We also created
    the non-player character prefab with its own network-enabled scripts. The game
    demonstrates how to spawn, and how to synchronize between the player characters
    and non-player characters.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个简单的坦克游戏，展示了如何将多人游戏所需的所有基本组件组合在一起。我们创建了必要的玩家角色预制体，并添加了适当的网络启用脚本和组件。我们还创建了非玩家角色预制体，并为其添加了自身的网络启用脚本。游戏演示了如何生成玩家角色和非玩家角色，以及如何在它们之间进行同步。
- en: During the construction of the tank game, we covered how to synchronize variables
    and use network callbacks that are crucial for the development of a multiplayer
    game. We also covered what *Commands* and *ClientRPC* calls are and how to use
    them properly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建坦克游戏的过程中，我们介绍了如何同步变量和使用对多人游戏开发至关重要的网络回调。我们还解释了什么是*命令*和*ClientRPC*调用，以及如何正确使用它们。
- en: Next, we applied what we learned to the RPG characters we developed in previous
    chapters. We used the existing prefabs as a base, and extended them to include
    the networking components and create new network-enabled scripts to handle the
    character movement, character customization, and NPC movement scripts.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所学知识应用到之前章节中开发的RPG角色上。我们以现有的预制体为基础，扩展了它们以包含网络组件，并创建了新的网络启用脚本以处理角色移动、角色定制和非玩家角色移动脚本。
- en: One of the crucial elements that we covered is the synchronization of each player
    character's inventory items visually with the rest of the players. We closed the
    chapter by testing and discussing how to debug your code on the client and the
    server while developing your multiplayer game.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的一个关键元素是，如何将每个玩家角色的库存物品在视觉上与其他玩家同步。我们在章节的最后通过测试和讨论如何在开发多人游戏时调试客户端和服务器上的代码来结束本章。
