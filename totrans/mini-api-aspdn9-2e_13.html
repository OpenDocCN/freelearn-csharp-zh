<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-153">
    <a id="_idTextAnchor183">
    </a>
    
     13
    
   </h1>
   <h1 id="_idParaDest-154">
    <a id="_idTextAnchor184">
    </a>
    
     Best Practices for Minimal API Resiliency
    
   </h1>
   <p>
    
     Like any software system, minimal APIs can be built in many ways.
    
    
     By carefully choosing and applying different patterns and following some set practices, an application can be
    
    
     
      greatly enhanced.
     
    
   </p>
   <p>
    
     There are several good reasons to build patterns into the design of your minimal API, the first being readability.
    
    
     Since most of us are part of a team and may have other developers to delegate or hand over code, making it as accessible as possible is paramount.
    
    
     By ensuring that your endpoints are tidy, that code is as
    
    <em class="italic">
     
      self-documenting
     
    </em>
    
     as possible, and that the naming conventions are consistent, it will be relatively straightforward for another developer to support the maintenance of an
    
    
     
      API project.
     
    
   </p>
   <p>
    
     Next is scalability.
    
    
     If the volume of requests grows, so will the need to optimize an application.
    
    
     Consistency and good design make meeting demands simple.
    
    
     Whether adding a load balancer to manage traffic flow or changing the data storage method, it is essential to design APIs in such a way that modifications to the system—whether adding or removing components—do not break functionality across the application.away parts of the system does not break functionality across
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Finally, security is equally important.
    
    
     By following best security practices such as encryption at rest and in transit, password hashing and salting, and scoped access, sensitive data can be managed securely, reducing the risk of a breach and the ensuing legal challenges that present themselves as
    
    
     
      a result.
     
    
   </p>
   <p>
    
     Ultimately, achieving these goals depends on applying practices that concern the way a code base is structured for readability, the way unexpected and fatal scenarios are dealt with in error handling, and the considerations applied from a
    
    
     
      cybersecurity perspective.
     
    
   </p>
   <p>
    
     Let’s realize some of these benefits in your minimal API projects by exploring some design practices and coding conventions that can improve the quality of
    
    
     
      your code.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics
     
    
    
     
      :
     
    
   </p>
   <ul>
    <li>
     
      Code organization
     
     
      
       and structure
      
     
    </li>
    <li>
     
      
       Error handling
      
     
    </li>
    <li>
     
      
       Security considerations
      
     
    </li>
   </ul>
   <p>
    
     Let’s get
    
    
     
      into it!
     
    
   </p>
   <h1 id="_idParaDest-155">
    <a id="_idTextAnchor185">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     Visual Studio 2022 or the latest version of Visual Studio code is recommended to run the code from this chapter.
    
    
     The code examples for this chapter are available in the GitHub repository
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     One of the examples uses code from
    
    <em class="italic">
     
      Chapters 9
     
    </em>
    
     and
    
    <em class="italic">
     
      12
     
    </em>
    
     , both of which have a dependency on Entity Framework Core.
    
    
     It is recommended that you complete those chapters before
    
    
     
      this one.
     
    
   </p>
   <h1 id="_idParaDest-156">
    <a id="_idTextAnchor186">
    </a>
    
     Code organization and structure
    
   </h1>
   <p>
    
     Perhaps the most important thing to understand about organizing and structuring code in any system is that there is no one correct way to do it.
    
    
     While there are some widely accepted structural patterns, this can be quite a personal topic, as a structure must serve the maintainer.
    
    
     However, as
    
    <a id="_idIndexMarker505">
    </a>
    
     we have previously confirmed, most minimal API systems in a commercial or open-source setting will have multiple maintainers, so a consistent structure will make it as easy as possible for developers to collaborate on the
    
    
     
      code base.
     
    
   </p>
   <p>
    
     We will explore two examples of ways that a project can be organized, both sharing one key theme –
    
    
     
      modularity.
     
    
   </p>
   <p>
    <strong class="bold">
     
      Modularity
     
    </strong>
    
     is the practice of
    
    <a id="_idIndexMarker506">
    </a>
    
     organizing and structuring your code into smaller, self-contained, and reusable units or modules.
    
    
     Let’s break down some of the benefits of
    
    
     
      this practice:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Separation of concerns
      
     </strong>
     
      : By grouping
     
     <a id="_idIndexMarker507">
     </a>
     
      together code containing similar functionality, we create contexts within the
     
     <a id="_idIndexMarker508">
     </a>
     
      code base that mirror the business domains they serve.
     
     
      For example, code that is solely based on the context of managing users is separate from code that is solely based on managing products.
     
     
      Establishing clear boundaries between these contexts ensures that dependencies
     
     
      
       are minimized.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Reusability
      
     </strong>
     
      : Adopting a modular design allows you to create components such as the ones we explored in this book – for example, services and middleware.
     
     
      In a system where separation
     
     <a id="_idIndexMarker509">
     </a>
     
      of concerns is the aim, having reusable components can help bridge contexts as necessary in a way that reduces the creation
     
     
      
       of dependencies.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Ease of maintenance
      
     </strong>
     
      : Modules can be developed and tested independently of each other, making parallel development between multiple developers easier.
     
     
      Modularization also supports the open-closed principle, which states, “
     
     <em class="italic">
      
       Software entities (classes, modules, functions, etc.) should be open for extension, but closed
      
     </em>
     
      <em class="italic">
       
        for modification.
       
      </em>
     
     
      
       ”
      
     
    </li>
   </ul>
   <p>
    
     This means that, in an ideal world, whenever we want to extend our minimal API with new functionality, we
    
    <em class="italic">
     
      do
     
    </em>
    
     not need to change the existing code base to enable
    
    
     
      the change.
     
    
   </p>
   <p>
    
     Effective organization of code is often dominated by architectural design patterns.
    
    
     While this is certainly important, simply reorganizing the folder structure of a project goes a long way to making code readable and simpler
    
    
     
      to maintain.
     
    
   </p>
   <p>
    
     Let’s explore some example
    
    
     
      folder structures.
     
    
   </p>
   <h1 id="_idParaDest-157">
    <a id="_idTextAnchor187">
    </a>
    
     Exploring folder structures
    
   </h1>
   <p>
    
     Most of the time, simple consideration of the way a project’s folders are arranged within a project can significantly improve the readability and maintainability of a minimal API.
    
    
     We’re looking for a
    
    <a id="_idIndexMarker510">
    </a>
    
     consistent system to lay out classes and interfaces.
    
    
     Let’s look at some specific folder structures that we can apply to our projects to
    
    
     
      achieve this.
     
    
   </p>
   <h2 id="_idParaDest-158">
    <a id="_idTextAnchor188">
    </a>
    
     Feature-based modular structure
    
   </h2>
   <p>
    
     In this structure, the
    
    <a id="_idIndexMarker511">
    </a>
    
     minimal API project is organized by features, with
    
    <a id="_idIndexMarker512">
    </a>
    
     each feature having its own folder, containing everything related to that feature, regardless of what kind of component is used.
    
    
     Here’s an
    
    <a id="_idIndexMarker513">
    </a>
    
     example of such
    
    
     
      a structure:
     
    
   </p>
   <pre class="console">
/src
  /MyMinimalApiProject
    /Modules
      /Users
        UserEndpoints.cs
        UserService.cs
        UserRepository.cs
        User.cs
        UserDto.cs
        UserValidator.cs
      /Products
        ProductEndpoints.cs
        ProductService.cs
        ProductRepository.cs
        Product.cs
        ProductDto.cs
        ProductValidator.cs
    /Middleware
      ErrorHandlingMiddleware.cs
      AuthenticationMiddleware.cs
    /Configuration
      SwaggerConfig.cs
      DependencyInjectionConfig.cs
    /Utils
      DateTimeHelper.cs
      LoggingHelper.cs
    Program.cs
    appsettings.json</pre>
   <p>
    
     In this structure, the developer is expected to adopt a feature-based mindset.
    
    
     For example, if you want to add an endpoint relating to user management, you would head to a folder based on users rather than one dedicated
    
    
     
      to endpoints.
     
    
   </p>
   <p>
    
     As mentioned earlier in the
    
    <a id="_idIndexMarker514">
    </a>
    
     chapter, folder structures can be a personal and somewhat polarizing topic.
    
    
     Some may not prefer to mix component
    
    <a id="_idIndexMarker515">
    </a>
    
     types under the banner of a feature set, while others enjoy the domain-based nature of this structure and are less concerned with what kind of component acts within
    
    
     
      each domain.
     
    
   </p>
   <h2 id="_idParaDest-159">
    <a id="_idTextAnchor189">
    </a>
    
     Layered modular structure
    
   </h2>
   <p>
    
     This structure is the one I prefer personally because I tend to think about the type of component before I think about the feature or business domain.
    
    
     In a layered modular structure, the project is first
    
    <a id="_idIndexMarker516">
    </a>
    
     grouped by components (e.g., endpoints and
    
    <a id="_idIndexMarker517">
    </a>
    
     services) and then further broken down into
    
    
     
      business modules/features.
     
    
   </p>
   <p>
    
     If you are like me and tend to think about the kind of class or file that I am looking to create or edit before I think about the domain in which it lives, this folder structure will work better for you.
    
    
     However, it’s important to note that while this kind of structure prioritizes component types when creating folders, there is still a dedicated
    
    <strong class="source-inline">
     
      Domain
     
    </strong>
    
     folder that exists to hold entity
    
    <a id="_idIndexMarker518">
    </a>
    
     models and
    
    <strong class="bold">
     
      Data Transfer Objects
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DTO
     
    </strong>
    
     s), which describe the business domain.
    
    
     Here is an example of a layered modular file structure in a minimal
    
    
     
      API project:
     
    
   </p>
   <pre class="console">
/src
  /MyMinimalApiProject
    /Endpoints
      /Users
        UserEndpoints.cs
        UserValidator.cs
      /Products
        ProductEndpoints.cs
        ProductValidator.cs
    /Services
      /Users
        UserService.cs
      /Products
        ProductService.cs
    /Repositories
      /Users
        UserRepository.cs
      /Products
        ProductRepository.cs
    /Domain
      /Entities
        User.cs
        Product.cs
      /DTOs
        UserDto.cs
        ProductDto.cs
    /Middleware
      ErrorHandlingMiddleware.cs
      AuthenticationMiddleware.cs
    /Configuration
      SwaggerConfig.cs
      DependencyInjectionConfig.cs
    /Utils
      DateTimeHelper.cs
      LoggingHelper.cs
    Program.cs
    appsettings.json</pre>
   <p>
    
     Now that we’ve explored some simple examples of how folders can be structured within a minimal API project, let’s look at
    
    <a id="_idIndexMarker519">
    </a>
    
     some repeatable patterns that can be adopted when structuring a project’s code.
    
    
     These patterns are
    
    <a id="_idIndexMarker520">
    </a>
    
     referred to as
    
    <em class="italic">
     
      design patterns
     
    </em>
    
     , and like folder structure, there is debate around which patterns constitute
    
    
     
      best practice.
     
    
   </p>
   <h1 id="_idParaDest-160">
    <a id="_idTextAnchor190">
    </a>
    
     Design patterns
    
   </h1>
   <p>
    
     This book is not designed to tell you which patterns are the best; rather, it is designed to give you some guidance on how
    
    <a id="_idIndexMarker521">
    </a>
    
     you can structure your code consistently to create a consistent API system.
    
    
     Here are some
    
    
     
      example
     
    
    
     <a id="_idIndexMarker522">
     </a>
    
    
     
      patterns.
     
    
   </p>
   <h2 id="_idParaDest-161">
    <a id="_idTextAnchor191">
    </a>
    
     The factory pattern
    
   </h2>
   <p>
    
     A
    
    <strong class="bold">
     
      factory pattern
     
    </strong>
    
     is designed to
    
    <a id="_idIndexMarker523">
    </a>
    
     create objects without specifying the exact class of object that will be created.
    
    
     Earlier, I mentioned the open/closed principle, and factory patterns help minimal APIs adhere to this principle by closing the code for modification while making it open
    
    
     
      for extension.
     
    
   </p>
   <p>
    
     Let’s consider an example use
    
    <a id="_idIndexMarker524">
    </a>
    
     case in which you want to create logs in different locations.
    
    
     One location is via a database, and another is in a
    
    
     
      text file.
     
    
   </p>
   <p>
    
     In the future, you may want to add more log sources, such as a Webhook or third-party API.
    
    
     A factory could help you retrieve the correct logger for your use case while making it simple to add new loggers without changing the
    
    
     
      old ones.
     
    
   </p>
   <p>
    
     Let’s look at an example of how we can improve logging by implementing a
    
    
     
      factory pattern:
     
    
   </p>
   <ol>
    <li>
     
      First, create an interface called
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      , which will be implemented by all loggers, regardless of the specific log they execute when saving a log to their respective source.
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      is an
     
     <a id="_idIndexMarker525">
     </a>
     
      interface that will represent an object that implements logic for the purposes of writing logs to
     
     
      
       different sources:
      
     
     <pre class="source-code">
public interface ILogger
{
    void Log(string message);
}</pre>
    </li>
    <li>
     
      Next, create two classes that each implement
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      .
     
     
      One of the classes,
     
     <strong class="source-inline">
      
       FileLogger
      
     </strong>
     
      , will be
     
     <a id="_idIndexMarker526">
     </a>
     
      used to log to a file, and another,
     
     <strong class="source-inline">
      
       DatabaseLogger
      
     </strong>
     
      ,  will log to
     
     
      
       a database:
      
     
     <pre class="source-code">
public class FileLogger : ILogger
{
    public void Log(string message)
    {
        // Logic to log to a file
    }
}
public class DatabaseLogger : ILogger
{
    public void Log(string message)
    {
        // Logic to log to a database
    }
}</pre>
     <p class="list-inset">
      
       These classes may have different names, but they are both an
      
      <strong class="source-inline">
       
        ILogger
       
      </strong>
      
       object meaning that they must
      
      <a id="_idIndexMarker527">
      </a>
      
       implement the
      
      
       <strong class="source-inline">
        
         Log()
        
       </strong>
      
      
       
        method.
       
      
     </p>
    </li>
    <li>
     
      Furthermore, we can
     
     <a id="_idIndexMarker528">
     </a>
     
      create a function that returns
     
     <strong class="source-inline">
      
       ILogger
      
     </strong>
     
      , as
     
     
      
       shown here:
      
     
     <pre class="source-code">
public static class LoggerFactory
{
    public static ILogger CreateLogger(
        string loggerType
    )
    {
        return loggerType switch
        {
            "File" =&gt; new FileLogger(),
            "Database" =&gt; new DatabaseLogger(),
            _ =&gt; throw new ArgumentException(
            "Invalid logger type")
        };
    }
}</pre>
    </li>
   </ol>
   <p>
    
     In this example, we created a
    
    <strong class="source-inline">
     
      LoggerFactory
     
    </strong>
    
     class with a function that returns the relevant logger class, depending on the contents of a string that was entered by the caller.
    
    
     If the
    
    <strong class="source-inline">
     
      loggerType
     
    </strong>
    
     parameter is not valid, an exception is thrown, allowing the error to
    
    
     
      be handled.
     
    
   </p>
   <p>
    
     The main benefit to this is that to add another logger, we simply create a new class that implements
    
    <strong class="source-inline">
     
      ILogger
     
    </strong>
    
     before adding a new entry to the
    
    <strong class="source-inline">
     
      switch
     
    </strong>
    
     statement in
    
    <strong class="source-inline">
     
      CreateLogger()
     
    </strong>
    
     .
    
    
     We haven’t had to
    
    <a id="_idIndexMarker529">
    </a>
    
     introduce any breaking changes to extend the types of loggers that are supported in
    
    <a id="_idIndexMarker530">
    </a>
    
     
      the API.
     
    
   </p>
   <h2 id="_idParaDest-162">
    <a id="_idTextAnchor192">
    </a>
    
     The repository pattern
    
   </h2>
   <p>
    
     This pattern creates an
    
    <a id="_idIndexMarker531">
    </a>
    
     abstraction layer for data access logic, providing a more general API to access data from a database for the
    
    
     
      minimal API.
     
    
   </p>
   <p>
    
     Earlier in the book, we explored
    
    <a id="_idIndexMarker532">
    </a>
    
     Entity Framework Core to access data from a database.
    
    
     Simply by using Entity Framework Core, your code already uses a repository pattern because it provides an implementation of the repository pattern that utilizes the
    
    
     
      built-in
     
    
    
     <strong class="source-inline">
      
       DBContext
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     However, it is still worth implementing a custom repository pattern to handle data so that you further generalize the solution, meaning that Entity Framework Core could be swapped out of the minimal API application without affecting the overall data
    
    
     
      access logic.
     
    
   </p>
   <p>
    
     To create a repository pattern on top of Entity Framework Core, we can simply create a class for each entity in the database.
    
    
     Each repository class receives the Entity Framework context via dependency injection, and then the generic
    
    <strong class="bold">
     
      Create, Read, Update, Delete
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CRUD
     
    </strong>
    
     ) operations for this entity
    
    <a id="_idIndexMarker533">
    </a>
    
     can be added.
    
    
     Following this, each repository can be also registered for dependency injection for use elsewhere in
    
    
     
      an application.
     
    
   </p>
   <p>
    
     In the following example,
    
    <strong class="source-inline">
     
      EmployeeRepository
     
    </strong>
    
     reflects the available data operations available for an employee entity.
    
    
     As described, the Entity Framework context is injected as the data access layer to be used within
    
    
     
      the repository:
     
    
   </p>
   <pre class="source-code">
public class EmployeeRepository : IEmployeeRepository
{
    private readonly MyCompanyContext _context;
    public EmployeeRepository(MyCompanyContext context)
    {
        _context = context;
    }
    public async Task&lt;Employee&gt; GetByIdAsync(int id)
    {
        return await _context.Employees.FindAsync(id);
    }
    public async Task&lt;IEnumerable&lt;Employee&gt;&gt; GetAllAsync()
    {
        return await _context.Employees.ToListAsync();
    }
    public async Task AddAsync(Employee employee)
    {
        await _context.Employees.AddAsync(employee);
        await _context.SaveChangesAsync();
    }
    public async Task UpdateAsync(Employee employee)
    {
        _context.Employees.Update(employee);
        await _context.SaveChangesAsync();
    }
    public async Task DeleteAsync(int id)
    {
        var employee = await
            _context.Employees.FindAsync(id);
        if (employee != null)
        {
            _context.Employees.Remove(employee);
            await _context.SaveChangesAsync();
        }
    }
}</pre>
   <p>
    
     Going forward, if a decision is made to replace Entity Framework Core, the only thing that needs to change is the repository.
    
    
     The consumers of the repository would not be affected because the
    
    <a id="_idIndexMarker534">
    </a>
    
     methods and functions they call within the repository
    
    <a id="_idIndexMarker535">
    </a>
    
     would maintain their original signatures, despite their underlying
    
    
     
      logic changing.
     
    
   </p>
   <h2 id="_idParaDest-163">
    <a id="_idTextAnchor193">
    </a>
    
     The strategy pattern
    
   </h2>
   <p>
    
     The
    
    <strong class="bold">
     
      Strategy pattern
     
    </strong>
    
     allows us to define a family of algorithms, each one represented by a class.
    
    
     This pattern is very
    
    <a id="_idIndexMarker536">
    </a>
    
     powerful in situations where there are multiple ways of
    
    <a id="_idIndexMarker537">
    </a>
    
     executing an operation, as you can seamlessly switch between them in a
    
    
     
      dynamic fashion.
     
    
   </p>
   <p>
    
     Let’s look at an example involving a minimal API endpoint that calculates how much annual leave an employee has.
    
    
     In this example, there are different ways to calculate leave based on various factors, such as which country the employee is in, whether they are in their probationary period, and how many years they have served at
    
    
     
      the company.
     
    
   </p>
   <p>
    
     Here is an example outline of the logic to calculate leave (not related to any specific labor laws in
    
    
     
      any country!):
     
    
   </p>
   <ul>
    <li>
     
      If the employee is in their probationary period, the
     
     
      
       following applies:
      
     
     <ul>
      <li>
       
        The minimum amount of leave awarded is
       
       
        
         10 days
        
       
      </li>
      <li>
       
        If the employee is based in the United Kingdom, they get an extra
       
       
        
         three days
        
       
      </li>
     </ul>
    </li>
    <li>
     
      If the employee is not on probation, the
     
     
      
       following applies:
      
     
     <ul>
      <li>
       
        The minimum amount of leave awarded is
       
       
        
         16 days
        
       
      </li>
      <li>
       
        If the employee is based in the United Kingdom, they get an extra
       
       
        
         three days
        
       
      </li>
      <li>
       
        For each year of service, an extra day
       
       
        
         is awarded
        
       
      </li>
     </ul>
    </li>
   </ul>
   <p>
    
     There are a lot of factors in play here, but to start with, we can narrow down the operations required to calculate leave based on whether the employee is or is not on probation.
    
    
     This means we have
    
    <a id="_idIndexMarker538">
    </a>
    
     two strategies to calculate leave, which we can switch to automatically.
    
    
     How do we
    
    
     
      achieve this?
     
    
   </p>
   <ol>
    <li>
     
      First, we create
     
     <a id="_idIndexMarker539">
     </a>
     
      an interface to represent a strategy.
     
     
      It stipulates that we require a
     
     <strong class="source-inline">
      
       CalculateLeaveAllowance()
      
     </strong>
     
      function taking a parameter of type
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      and returning
     
     
      
       an integer:
      
     
     <pre class="source-code">
public interface IAnnualLeaveStrategy
{
    int CalculateLeaveAllowance(
        Models.Employee employee
    );
}</pre>
    </li>
    <li>
     
      Then, we’ll create
     
     <strong class="source-inline">
      
       ProbationaryAnnualLeaveStrategy
      
     </strong>
     
      , which implements the interface.
     
     
      Within this class,
     
     <strong class="source-inline">
      
       CalculateLeaveAllowance
      
     </strong>
     
      will encapsulate the logic to calculate the total leave available for a
     
     
      
       probationary employee:
      
     
     <pre class="source-code">
public class ProbationaryAnnualLeaveStrategy
    : IAnnualLeaveStrategy
{
    public int CalculateLeaveAllowance(
        Models.Employee employee
    )
    {
        var leaveTotal = 10;
        if(employee.Country == "United Kingdom")
        {
            leaveTotal += 3;
        }
        return leaveTotal;
    }
}</pre>
    </li>
    <li>
     
      Then, the same can
     
     <a id="_idIndexMarker540">
     </a>
     
      be done for an employee who is not
     
     
      
       on
      
     
     
      <a id="_idIndexMarker541">
      </a>
     
     
      
       probation:
      
     
     <pre class="source-code">
public class PostProbationaryAnnualLeaveStrategy
    : IAnnualLeaveStrategy
{
    public int CalculateLeaveAllowance(
        Models.Employee employee
    )
    {
        var leaveTotal = 16;
        if(employee.Country == "United Kingdom")
        {
            leaveTotal += 3;
        }
    leaveTotal += employee.YearsOfService;
        return leaveTotal;
    }
}</pre>
    </li>
    <li>
     
      The two strategies should be registered for dependency injection
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
            builder.Services
              .AddScoped&lt;
                ProbationaryAnnualLeaveStrategy
              &gt;();
            builder.Services
              .AddScoped&lt;
                PostProbationaryAnnualLeaveStrategy
              &gt;();</pre>
    </li>
    <li>
     
      Finally, an endpoint
     
     <a id="_idIndexMarker542">
     </a>
     
      can be created to calculate the annual leave for a given
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      ID.
     
     
      Within the endpoint, we create the strategy based on whether or not the employee is on probation.
     
     
      We then retrieve
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      using the ID sent by the client and call the
     
     <strong class="source-inline">
      
       CalculateLeaveAllowance()
      
     </strong>
     
      function to get the result.
     
     
      This way, the appropriate strategy is automatically
     
     <a id="_idIndexMarker543">
     </a>
     
      used to execute the correct logic, based on the data that was sent by the client in
     
     
      
       the request:
      
     
     <pre class="source-code">
app.MapGet(
    "/calculate-employee-leave-allowance/
        {employeeId}",
    async (int employeeId,
        bool employeeOnProbation,
        [FromServices]
        EmployeeService employeeService) =&gt;
{
    IAnnualLeaveStrategy annualLeaveStrategy =
        employeeOnProbation
          ? new ProbationaryAnnualLeaveStrategy()
          : new PostProbationaryAnnualLeaveStrategy();
    var employee = await
        employeeService.GetEmployeeById(employeeId);
    return annualLeaveStrategy
        .CalculateLeaveAllowance(employee);
});</pre>
    </li>
   </ol>
   <p>
    
     By separating logic into individual
    
    <a id="_idIndexMarker544">
    </a>
    
     strategies, the Strategy pattern allows minimal APIs to conform to the open/closed
    
    <a id="_idIndexMarker545">
    </a>
    
     principle.
    
    
     It does that by allowing us to extend the code base with new functionality, rather than alter the
    
    
     
      existing code.
     
    
   </p>
   <p>
    
     It also offers self-containment, meaning that ways of performing similar tasks do not cross-contaminate each other, which reduces the potential
    
    
     
      for bugs.
     
    
   </p>
   <p>
    
     Design patterns alone do not make a resilient system.
    
    
     Resiliency is achieved through a good understanding of where and how
    
    
     
      errors occur.
     
    
   </p>
   <p class="callout-heading">
    
     Years of service property required
    
   </p>
   <p class="callout">
    
     The example in this section will work with the original
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object used in
    
    <a href="B20968_09.xhtml#_idTextAnchor143">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     if you add an
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     property, called
    
    <strong class="source-inline">
     
      YearsOfService
     
    </strong>
    
     .
    
    
     We assume that you will have done this before attempting to follow this strategy
    
    
     
      pattern example.
     
    
   </p>
   <p>
    
     With that in mind, let’s move on to explore good practices around error handling in
    
    
     
      minimal APIs.
     
    
   </p>
   <h1 id="_idParaDest-164">
    <a id="_idTextAnchor194">
    </a>
    
     Error Handling
    
   </h1>
   <p>
    
     When it comes to the topic of error
    
    <a id="_idIndexMarker546">
    </a>
    
     handling and resilience, the first is the method and the second is the outcome.
    
    
     By
    
    <a id="_idIndexMarker547">
    </a>
    
     implementing effective error handling, we
    
    
     
      achieve resilience.
     
    
   </p>
   <p>
    
     So, while using
    
    <strong class="source-inline">
     
      try/catch
     
    </strong>
    
     across the code base is important, a standardized manner of handling errors at the top level is still critical.
    
    
     For a minimal API, middleware is an effective way to handle errors from the top level.
    
    
     Let’s explore
    
    
     
      an example.
     
    
   </p>
   <p class="callout-heading">
    
     Note
    
   </p>
   <p class="callout">
    
     This section assumes that you read
    
    <a href="B20968_05.xhtml#_idTextAnchor094">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     or that you already have an in-depth understanding of how to write middleware
    
    
     
      in ASP.NET.
     
    
   </p>
   <p>
    
     Implementing middleware ensures that we have a global solution to error handling in a minimal API.
    
    
     Think of it as a giant
    
    <strong class="source-inline">
     
      try/catch
     
    </strong>
    
     that wraps around all of your minimal
    
    
     
      API’s endpoints.
     
    
   </p>
   <p>
    
     As we explored middleware extensively in
    
    <a href="B20968_05.xhtml#_idTextAnchor094">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , we do not need to go through the specifics of how middleware is built, so we shall dive straight into an example of an error-handling middleware class, as shown in the upcoming
    
    
     
      code blocks.
     
    
   </p>
   <p>
    
     First, we create a class for the middleware, along with a constructor and an
    
    <strong class="source-inline">
     
      InvokeAsync
     
    </strong>
    
     method that can be used to initiate the
    
    
     
      middleware’s logic:
     
    
   </p>
   <pre class="source-code">
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger&lt;ErrorHandlingMiddleware&gt;
        _logger;
    public ErrorHandlingMiddleware(
        RequestDelegate next,
        ILogger&lt;ErrorHandlingMiddleware&gt; logger
    )
    {
        _next = next;
        _logger = logger;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(
                ex, "An unhandled exception occurred."
            );
            await HandleExceptionAsync(context, ex);
        }
    }</pre>
   <p>
    
     Following this, we can add a method
    
    <a id="_idIndexMarker548">
    </a>
    
     that takes in the current
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     to handle any
    
    
     
      detected errors:
     
    
   </p>
   <pre class="source-code">
    private static Task HandleExceptionAsync(
        HttpContext context, Exception exception)
    {
    If (context.Response.HasStarted) return;
    context.Response.ContentType = "application/json";
    context.Response.StatusCode =
        (int)HttpStatusCode.InternalServerError;
        var response = new
        {
            message =
                "An unexpected error occurred. Please try
                again later.",
            details = exception.Message
        };
        return context.Response.WriteAsJsonAsync(response);
    }
}</pre>
   <p>
    
     It is worth noting that this middleware example for error handling could easily replace the similar error handling example in
    
    <a href="B20968_05.xhtml#_idTextAnchor094">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     This middleware will catch an exception thrown higher up in the request pipeline, ensuring that the error is returned
    
    <a id="_idIndexMarker549">
    </a>
    
     to the requesting client via
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     .
    
    
     This ensures a consistent error response to the client regardless of the endpoint that
    
    
     
      was called.
     
    
   </p>
   <p>
    
     As you will be aware from earlier in the book, middleware, such as services for dependency injection, must be registered in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     .
    
    
     Register this middleware class as the first piece of middleware to be registered, and then create an example endpoint that throws
    
    
     
      an exception:
     
    
   </p>
   <pre class="source-code">
app.UseMiddleware&lt;ErrorHandlingMiddleware&gt;();
app.MapGet(
    "/error",
    () =&gt; {
        throw new InvalidOperationException(
            "This is a test exception");
    });</pre>
   <p>
    
     You should find that not
    
    <a id="_idIndexMarker550">
    </a>
    
     only the message from the exception is returned but also a generic message, consistently, like the one
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
{
    "message": "An unexpected error occurred. Please try
        again later.",
    "details": "This is a test exception"
}</pre>
   <p>
    
     Another practice that should be consistent when developing any API is that of secure development.
    
    
     Let’s explore some good security practices that you can apply when authorizing requests to your
    
    
     
      minimal API.
     
    
   </p>
   <h1 id="_idParaDest-165">
    <a id="_idTextAnchor195">
    </a>
    
     Security considerations
    
   </h1>
   <p>
    
     There are two critical areas of security within a minimal API – authentication and authorization.
    
    
     Regardless
    
    <a id="_idIndexMarker551">
    </a>
    
     of their differences, the attitude toward their implementation should be largely the same –
    
    <em class="italic">
     
      don’t roll
     
    </em>
    
     <em class="italic">
      
       your own
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     This mantra serves as a warning that a proven
    
    <a id="_idIndexMarker552">
    </a>
    
     security framework will usually be safer than one you
    
    
     
      devise yourself.
     
    
   </p>
   <p>
    
     Let’s first look at the difference between authentication and authorization, as well as how you can achieve a good degree of
    
    <a id="_idIndexMarker553">
    </a>
    
     security using the well-known technology
    
    <strong class="bold">
     
      JSON Web
     
    </strong>
    
     <strong class="bold">
      
       Tokens
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       JWTs
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <h2 id="_idParaDest-166">
    <a id="_idTextAnchor196">
    </a>
    
     Authentication
    
   </h2>
   <p>
    <strong class="bold">
     
      Authentication
     
    </strong>
    
     verifies the identity of users or systems accessing your API.
    
    
     It allows you to allow only legitimate requests to
    
    <a id="_idIndexMarker554">
    </a>
    
     enter
    
    
     
      a system.
     
    
   </p>
   <p>
    
     JWTs are widely used for their stateless
    
    <a id="_idIndexMarker555">
    </a>
    
     authentication capabilities in minimal APIs.
    
    
     Users authenticate once and receive a token, which is included in subsequent requests to access
    
    
     
      protected resources.
     
    
   </p>
   <h2 id="_idParaDest-167">
    <a id="_idTextAnchor197">
    </a>
    
     Authorization
    
   </h2>
   <p>
    <strong class="bold">
     
      Authorization
     
    </strong>
    
     is a means of checking
    
    <a id="_idIndexMarker556">
    </a>
    
     to see whether an authenticated user is accessing resources within their specific permissions.
    
    
     In JWT, these permissions
    
    <a id="_idIndexMarker557">
    </a>
    
     are known
    
    
     
      as
     
    
    
     <strong class="bold">
      
       claims
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     A claim can be the name of a
    
    <a id="_idIndexMarker558">
    </a>
    
     resource or type of user, or it can be a role.
    
    
     Either way, JWT has built-in functionality to define and validate claims against specific endpoints in a
    
    
     
      minimal API:
     
    
   </p>
   <ol>
    <li>
     
      To get started with this authorization framework, we first need to add the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Authentication.JwtBearer
      
     </strong>
     
      NuGet package.
     
     
      Do this via the NuGet Package Manager Console, accessible via
     
     <strong class="bold">
      
       Tools
      
     </strong>
     
      |
     
     <strong class="bold">
      
       NuGet Package Manager
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Package
      
     </strong>
     
      <strong class="bold">
       
        Manager Console
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">dotnet add package Microsoft</strong>
<strong class="bold">    .AspNetCore.Authentication.JwtBearer</strong></pre>
    </li>
    <li>
     
      We then need to ensure that
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      has the
     
     
      
       relevant namespaces:
      
     
     <pre class="source-code">
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using Microsoft.AspNetCore.Authorization;</pre>
    </li>
    <li>
     
      JWT can be implemented
     
     <a id="_idIndexMarker559">
     </a>
     
      as a middleware, so it should
     
     <a id="_idIndexMarker560">
     </a>
     
      first be set up
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
builder.AddAuthorization();
builder.Services.AddAuthentication(
    JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =&gt;
    {
        options.TokenValidationParameters =
            new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = "https://yourdomain.com",
            ValidAudience = "https://yourdomain.com",
            IssuerSigningKey =
                new SymmetricSecurityKey(
                    Encoding.UTF8.GetBytes(
                        "A_Not_Very_Secret_Key_1234567
                            890"
                    )
                )
        };
    });
var app = builder.Build();
app.UseAuthentication();
app.UseAuthorization();</pre>
    </li>
    <li>
     
      This registration specifies how your
     
     <a id="_idIndexMarker561">
     </a>
     
      tokens are validated.
     
     
      Next, we need to provide a means of generating a token.
     
     
      We can do this by creating
     
     <a id="_idIndexMarker562">
     </a>
     
      a dedicated
     
     
      
       API endpoint:
      
     
     <pre class="source-code">
    app.MapGet("/generate-token", () =&gt;
    {
        var tokenHandler =
            new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(
            " A_Not_Very_Secret_Key_1234567890"
        );
        var tokenDescriptor =
            new SecurityTokenDescriptor
        {
            Subject = new ClaimsIdentity(new[]
            {
    new Claim(ClaimTypes.Name, "TestUser"),
    new Claim(ClaimTypes.Role, "Admin")
}),
            Expires = DateTime.UtcNow.AddHours(1),
            Issuer = "https://yourdomain.com",
            Audience = "https://yourdomain.com",
            SigningCredentials =
                new SigningCredentials(
                    new SymmetricSecurityKey(key),
                        SecurityAlgorithms
                            .HmacSha256Signature
                )
        };
        var token =
            tokenHandler.CreateToken(tokenDescriptor);
        var tokenString =
            tokenHandler.WriteToken(token);
        return Results.Ok(tokenString);
    });</pre>
    </li>
    <li>
     
      Finally, now that we have a
     
     <a id="_idIndexMarker563">
     </a>
     
      means of creating a JWT token, we can
     
     <a id="_idIndexMarker564">
     </a>
     
      create an endpoint that requires it.
     
     
      Let’s again create a simple
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      endpoint, but this time, we add an
     
     <strong class="source-inline">
      
       [Authorize]
      
     </strong>
     
      attribute and chain
     
     <strong class="source-inline">
      
       RequireAuthorization()
      
     </strong>
     
      
       to it:
      
     
     <pre class="source-code">
app.MapGet(
    "/secure",
    [Authorize] () =&gt; "This is a secure endpoint")
    .RequireAuthorization();</pre>
    </li>
    <li>
     
      To test this, we can make a
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request to this endpoint and add the returned JWT token as a bearer token.
     
     
      With an example JWT token, the header would look something
     
     
      
       like this:
      
     
     <pre class="source-code">
<strong class="bold">"Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6IlRlc3RVc2VyIiwicm9sZSI6IkFkbWluIiwibmJmIjoxNjQyNzE2MzY0LCJleHAiOjE2NDI3MTk5NjQsImlhdCI6MTY0MjcxNjM2NCwiaXNzIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsImF1ZCI6Imh0dHBzOi8veW91cmRvbWFpbi5jb20ifQ.-Ym30PjdvWl5eYdltZd0yA5XQ1ikf5D4KrDlmHMIj0s"</strong></pre>
     <p class="list-inset">
      
       ASP.NET core will then authenticate the request, based on the validation parameters you specified when you registered the
      
      
       
        JWT middleware.
       
      
     </p>
    </li>
    <li>
     
      Taking this further, if we
     
     <a id="_idIndexMarker565">
     </a>
     
      wanted to create a more restricted
     
     <a id="_idIndexMarker566">
     </a>
     
      endpoint, which can only be accessed by users with the role claim,
     
     <strong class="source-inline">
      
       Admin
      
     </strong>
     
      , we can add a parameter to the
     
     <strong class="source-inline">
      
       [
      
     </strong>
     
      <strong class="source-inline">
       
        Authorize]
       
      </strong>
     
     
      
       attribute:
      
     
     <pre class="source-code">
app.MapGet(
    "/admin",
    [Authorize(Roles = "Admin")] () =&gt;
{
    return Results.Ok("Welcome, Admin!");
});</pre>
    </li>
   </ol>
   <p>
    
     Using JWT tokens, our minimal APIs are provided with protection against unauthorized activity.
    
    
     However, this alone will not guarantee that authorized use is
    
    
     
      not abused.
     
    
   </p>
   <p>
    
     In truth, it is impossible to guarantee this, but an extra step you can take to ensure that a minimal API is not abused is to limit the number of requests that can be made during a specified period.
    
    
     This
    
    <a id="_idIndexMarker567">
    </a>
    
     practice is called
    
    
     <strong class="bold">
      
       rate limiting
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-168">
    <a id="_idTextAnchor198">
    </a>
    
     Rate limiting
    
   </h2>
   <p>
    
     By controlling the number of requests a client can make to your minimal API within a specific timeframe, rate limiting
    
    <a id="_idIndexMarker568">
    </a>
    
     can help prevent a system from being overwhelmed by too many requests, whether the requests are legitimate
    
    
     
      or not.
     
    
   </p>
   <p>
    
     Let’s explore a simple example of rate limiting in an ASP.NET core
    
    
     
      minimal API.
     
    
   </p>
   <p>
    
     First, add the
    
    <strong class="source-inline">
     
      AspNetCoreRateLimit
     
    </strong>
    
     package from NuGet via the Package Manager Console.
    
    
     You can open this in Visual Studio by clicking
    
    <strong class="bold">
     
      Tools
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Manage NuGet Packages
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Package Manager Console
     
    </strong>
    
     .
    
    
     This will open the console, in which you can type
    
    
     
      the following:
     
    
   </p>
   <pre class="console">
dotnet add package AspNetCoreRateLimit</pre>
   <p>
    
     Then, add rate limiting (along with memory caching)
    
    
     
      via
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
using AspNetCoreRateLimit;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddMemoryCache();
builder.Services.Configure&lt;IpRateLimitOptions&gt;(options =&gt;
{
    options.GeneralRules = new List&lt;RateLimitRule&gt;
    {
        new RateLimitRule
        {
            Endpoint = "*",
            Limit = 10,
            Period = "1m"
        }
    };
});
builder.Services
    .AddSingleton&lt;IRateLimitConfiguration,
        RateLimitConfiguration&gt;();
builder.Services.AddInMemoryRateLimiting();
var app = builder.Build();
app.UseIpRateLimiting();
app.MapGet("/", () =&gt; "Hello, World!");
app.Run();</pre>
   <p>
    
     This configuration will limit all endpoints to a maximum of 100 requests per minute, per IP address.
    
    
     If the limit is
    
    <a id="_idIndexMarker569">
    </a>
    
     exceeded, the client will receive a
    
    <strong class="source-inline">
     
      429 Too Many
     
    </strong>
    
     <strong class="source-inline">
      
       Requests
      
     </strong>
    
    
     
      response.
     
    
   </p>
   <p>
    
     To try this example out, change the maximum number of requests per minute to
    
    <strong class="source-inline">
     
      2
     
    </strong>
    
     and see what the results
    
    
     
      look like.
     
    
   </p>
   <p class="callout-heading">
    
     AspNetCoreRateLimit versus Microsoft.AspNetCore.RateLimiting
    
   </p>
   <p class="callout">
    
     There is another option for rate limiting besides
    
    <strong class="source-inline">
     
      AspNetCoreRateLimit
     
    </strong>
    
     , shown in the preceding example.
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.RateLimiting
     
    </strong>
    
     can also be used to manage the rate of allowed requests.
    
    <strong class="source-inline">
     
      AspNetCoreRateLimit
     
    </strong>
    
     is a third-party library, while
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.RateLimiting
     
    </strong>
    
     is built-in middleware.
    
    
     For configuration,
    
    <strong class="source-inline">
     
      AspNetCoreRateLimit
     
    </strong>
    
     uses JSON or programmatic configuration, whereas
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.RateLimiting
     
    </strong>
    
     uses programmatic configuration
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       RateLimiterOptions
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      AspNetCoreRateLimit
     
    </strong>
    
     offers more flexibility with different strategies and distributed rate limiting, while
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.RateLimiting
     
    </strong>
    
     focuses on built-in algorithms and
    
    
     
      endpoint-specific policies.
     
    
   </p>
   <p>
    
     We’ve only scratched the surface of the practices that can be implemented to improve resilience in minimal
    
    <a id="_idIndexMarker570">
    </a>
    
     APIs, but the examples we have explored are a good starting point to improve their design.
    
    
     Let’s recap the practices that we’ve seen in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-169">
    <a id="_idTextAnchor199">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We started by observing the justification for implementing effective design practices – namely, for an increase in resiliency from a maintained scalability and
    
    
     
      security perspective.
     
    
   </p>
   <p>
    
     We then looked at folder structures, with personal preferences discussed and a couple of folder structure examples outlined for use in a
    
    
     
      fresh project.
     
    
   </p>
   <p>
    
     We then explored three design patterns in the form of factory, repository, and strategy, providing a solid foundation to arrange minimal API code in a
    
    
     
      scalable manner.
     
    
   </p>
   <p>
    
     Then, we briefly reviewed an example of how middleware can act as a “global catch,” standardizing the way error responses are returned to a client, before finally exploring some simple ways of authenticating requests and limiting the rate at which they can
    
    
     
      be processed.
     
    
   </p>
   <p>
    
     We’re moving closer to the end of the book, which means we will need to learn how to manage a minimal API that is deployed and active in a user base.
    
    
     With that in mind, the next chapter will cover the things we need to consider most when making our minimal API available to the wider world – testing, deployment,
    
    
     
      and documentation.
     
    
   </p>
  </div>
 </body></html>