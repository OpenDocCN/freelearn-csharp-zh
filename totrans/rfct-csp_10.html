<html><head></head><body>
<div id="_idContainer121">
<h1 class="chapter-number" id="_idParaDest-210"><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-211"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.2.1">Defensive Coding Techniques</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Code is almost organic and evolves over its lifetime as new features are added, fixes are implemented, and refactorings occur at regular intervals. </span><span class="koboSpan" id="kobo.3.2">As code changes and developers enter and leave the project, there’s a chance that some of these changes may </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">introduce bugs.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Part 2</span></em><span class="koboSpan" id="kobo.7.1"> of this book, we discussed testing strategies for detecting these bugs before they reach production. </span><span class="koboSpan" id="kobo.7.2">In this chapter, we’ll talk about a few additional techniques that help developers catch and resolve bugs during development. </span><span class="koboSpan" id="kobo.7.3">Along the way, we’ll also explore a few newer features in C# and their roles in keeping your code stable </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and healthy.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We’ll cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Validating inputs</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Protecting </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">against null</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Moving </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">beyond classes</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">type usage</span></span></li>
</ul>
<h1 id="_idParaDest-212"><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">The starting code for this chapter is available from GitHub at </span><a href="https://github.com/PacktPublishing/Refactoring-with-CSharp"><span class="koboSpan" id="kobo.20.1">https://github.com/PacktPublishing/Refactoring-with-CSharp</span></a><span class="koboSpan" id="kobo.21.1"> in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">Chapter10/Ch10BeginningCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.23.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">The code in this chapter talks to a REST API, which will require an active </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">internet connection.</span></span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.26.1">Introducing the Cloudy Skies API</span></h1>
<p><span class="koboSpan" id="kobo.27.1">Our fictitious sample organization, Cloudy </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.28.1">Skies, has a pre-existing set of web services in the form of a public </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">REST API</span></strong><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">This API intends to allow interested organizations to pull information about Cloudy Skies flights through the API. </span><span class="koboSpan" id="kobo.30.3">However, a steady amount of support tickets has proven that organizations are having a hard time adopting the API and using it in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">approved ways.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">In response, Cloudy Skies has built a .NET library to help others more easily use </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the API.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Early testing of this library is promising, but some developers are still encountering confusing errors that ultimately appear to be related to the data they’re passing </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the library.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The development team </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.37.1">decided that validating parameters to public methods would help improve the adoption of their library by finding issues sooner. </span><span class="koboSpan" id="kobo.37.2">We’ll explore this change in the </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">next section.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.39.1">Validating inputs</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.40.1">Input validation</span></strong><span class="koboSpan" id="kobo.41.1"> is the act of </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.42.1">verifying that any inputs to your code, such as parameters or current property values, are correct before performing the requested work. </span><span class="koboSpan" id="kobo.42.2">We validate inputs to public methods to detect potential issues </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">early on.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">To illustrate the importance of this, let’s look at a method that doesn’t validate </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">its inputs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
public FlightInfo? </span><span class="koboSpan" id="kobo.46.2">GetFlight</span><strong class="bold"><span class="koboSpan" id="kobo.47.1">(string id, string apiKey)</span></strong><span class="koboSpan" id="kobo.48.1"> {
  RestRequest request = new($"/flights/</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">{id.ToLower()}</span></strong><span class="koboSpan" id="kobo.50.1">");
  request.AddHeader("x-api-key", </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">apiKey</span></strong><span class="koboSpan" id="kobo.52.1">);
  LogApiCall(request.Resource);
  return _client.Get&lt;FlightInfo?&gt;(request);
}</span></pre>
<p><span class="koboSpan" id="kobo.53.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">GetFlight</span></strong><span class="koboSpan" id="kobo.55.1"> method takes in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">id</span></strong><span class="koboSpan" id="kobo.57.1"> parameter indicating a flight number, such as “CSA1234,” whereas the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">apiKey</span></strong><span class="koboSpan" id="kobo.59.1"> parameter represents a token that must be supplied to interact with the API and get a response. </span><span class="koboSpan" id="kobo.59.2">Think of the token as something like a digital keycard that Cloudy Skies issues to interested organizations that want to interact with its APIs. </span><span class="koboSpan" id="kobo.59.3">Every request that goes to the Cloudy Skies API must include a token to authenticate and get </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">a result.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">id</span></strong><span class="koboSpan" id="kobo.63.1"> parameter is important because it is used to identify the flight that we’re interested in. </span><span class="koboSpan" id="kobo.63.2">This parameter gets added to the URL that the code makes an HTTP GET request to using the RestSharp </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.64.1">library, which is one of many ways of interacting with web services in </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">modern .NET.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.66.1">Don’t panic!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.67.1">If any of the web services code or handling of authentication tokens is beyond your comfort zone, don’t worry. </span><span class="koboSpan" id="kobo.67.2">While these are concepts you should learn as you grow, the actual mechanics of the web API are not important for this chapter. </span><span class="koboSpan" id="kobo.67.3">Instead, we’re focusing on </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">parameter validation.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Now that we’ve established what this method is doing, let’s talk about how it could </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">be better.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">First of all, any value for a string is valid here for both </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">id</span></strong><span class="koboSpan" id="kobo.73.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">apiKey</span></strong><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">This includes values such as null and empty or whitespace strings. </span><span class="koboSpan" id="kobo.75.3">While you might not think that a developer might try those values for those parameters, I can think of compelling reasons someone might try </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">either one:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.77.1">Someone might try to pass null for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">id</span></strong><span class="koboSpan" id="kobo.79.1"> parameter, thinking that it would get the next flight, all flights, or possibly even a </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">random flight</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">A developer without an API key may think that API keys are only required for requests that modify data on the server or that you can interact with the API in low volumes without an </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">API key</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.83.1">While both assumptions are incorrect for this API, I could see someone without knowledge of the system trying either one. </span><span class="koboSpan" id="kobo.83.2">In the case of Cloudy Skies, not providing a valid API key will result in a 401 unauthorized error coming back from </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">On the other hand, not providing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">id</span></strong><span class="koboSpan" id="kobo.87.1"> parameter results in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.89.1"> error when the code tries to convert </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">id</span></strong><span class="koboSpan" id="kobo.91.1"> into lowercase, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.92.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.93.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<span class="koboSpan" id="kobo.95.1"><img alt="Figure 10.1 – A NullReferenceException error due to id being null when ToLower was called" src="image/B21324_10_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.96.1">Figure 10.1 – A NullReferenceException error due to id being null when ToLower was called</span></p>
<p><span class="koboSpan" id="kobo.97.1">Both of these errors are </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.98.1">things that a developer trying to interact with this code could encounter, and neither one of these errors adequately tells the developer that they made a mistake in the parameters they passed in. </span><span class="koboSpan" id="kobo.98.2">Let’s fix this </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">with validation.</span></span></p>
<h2 id="_idParaDest-215"><a id="_idTextAnchor214"/><span class="koboSpan" id="kobo.100.1">Performing basic validation</span></h2>
<p><span class="koboSpan" id="kobo.101.1">The goal of validation is to </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.102.1">detect bad inputs early on and explicitly point out these issues before bad data gets deeper into our system. </span><span class="koboSpan" id="kobo.102.2">In building a library, this means that we want to validate parameters sent to our code as early as possible, preferably in the public methods other developers will </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">interact with.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">Here’s a version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">GetFlight</span></strong><span class="koboSpan" id="kobo.106.1"> that performs some additional </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">validation steps:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
public FlightInfo? </span><span class="koboSpan" id="kobo.108.2">GetFlight(string id, string apiKey) {
</span><strong class="bold"><span class="koboSpan" id="kobo.109.1">  if (string.IsNullOrEmpty(apiKey)) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.110.1">    throw new ArgumentNullException("apiKey");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.111.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.112.1">  if (string.IsNullOrEmpty(id)) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.113.1">    throw new ArgumentNullException("id");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.114.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.115.1">  if (!id.StartsWith("CSA",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.116.1">                     StringComparison.OrdinalIgnoreCase)) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.117.1">    throw new ArgumentOutOfRangeException("id", "Cannot</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.118.1">        lookup non-CSA flights");</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.119.1">  }</span></strong><span class="koboSpan" id="kobo.120.1">
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  return _client.Get&lt;FlightInfo?&gt;(request);
}</span></pre>
<p><span class="koboSpan" id="kobo.121.1">Here, we check if </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">apiKey</span></strong><span class="koboSpan" id="kobo.123.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">id</span></strong><span class="koboSpan" id="kobo.125.1"> are either null or empty strings. </span><span class="koboSpan" id="kobo.125.2">If that’s true, we throw an </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">ArgumentNullException</span></strong><span class="koboSpan" id="kobo.127.1"> error to tell whoever called this method that they are not providing a valid value for a </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">specific parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">We also perform a check on </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">id</span></strong><span class="koboSpan" id="kobo.131.1"> to determine whether it refers to a flight with a Cloudy Skies Airline prefix. </span><span class="koboSpan" id="kobo.131.2">If it </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.132.1">doesn’t, this flight will never be found since it isn’t tracked by the system. </span><span class="koboSpan" id="kobo.132.2">In this case, it makes sense to alert the caller with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">ArgumentOutOfRangeException</span></strong><span class="koboSpan" id="kobo.134.1"> error. </span><span class="koboSpan" id="kobo.134.2">This exception type is also commonly used with numbers or dates that are outside of acceptable ranges for </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">a method.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.136.1">Should we really throw exceptions here?</span></p>
<p class="callout"><span class="koboSpan" id="kobo.137.1">Many new developers think that exceptions are bad. </span><span class="koboSpan" id="kobo.137.2">Most developers hate encountering exceptions, and throwing exceptions can indeed be relatively slow. </span><span class="koboSpan" id="kobo.137.3">Keeping these things </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.138.1">in mind, when you get invalid values, sometimes, the best option is to throw a specific exception that highlights the issue. </span><span class="koboSpan" id="kobo.138.2">This helps catch mistakes quickly and prevents errors that can occur from letting invalid values deeper into </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">a system.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">You may have noticed that the revised code has a lot of validation relative to the other logic in the method. </span><span class="koboSpan" id="kobo.140.2">There are a few ways of improving this, as we’ll see in the upcoming sections, but let’s work toward that goal incrementally. </span><span class="koboSpan" id="kobo.140.3">We’ll start by looking at a better way of referring to bad </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">parameter values.</span></span></p>
<h2 id="_idParaDest-216"><a id="_idTextAnchor215"/><span class="koboSpan" id="kobo.142.1">Using the nameof keyword</span></h2>
<p><span class="koboSpan" id="kobo.143.1">Right now, the code validates parameters and throws exceptions with code </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
throw new ArgumentNullException("apiKey");</span></pre>
<p><span class="koboSpan" id="kobo.146.1">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">"apiKey"</span></strong><span class="koboSpan" id="kobo.148.1"> refers to</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.149.1"> the name of the parameter, which helps developers identify which parameter the exception is </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">complaining about.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Now, what happens if</span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.152.1"> someone renames that parameter later to </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">apiToken</span></strong><span class="koboSpan" id="kobo.154.1">? </span><span class="koboSpan" id="kobo.154.2">This change wouldn’t cause any compiler errors and the exception could still be thrown. </span><span class="koboSpan" id="kobo.154.3">Unfortunately, the exception would reference the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">apiKey</span></strong><span class="koboSpan" id="kobo.156.1"> parameter name that was no longer present, which would confuse the developer encountering </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">the error.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">To help with this, C# gives us the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">nameof</span></strong><span class="koboSpan" id="kobo.160.1"> keyword, which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
public FlightInfo? </span><span class="koboSpan" id="kobo.162.2">GetFlight(string id, string apiKey) {
  if (string.IsNullOrEmpty(apiKey)) {
    throw new ArgumentNullException(</span><strong class="bold"><span class="koboSpan" id="kobo.163.1">nameof(apiKey)</span></strong><span class="koboSpan" id="kobo.164.1">);
  }</span></pre>
<p><span class="koboSpan" id="kobo.165.1">When your code is compiled, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">nameof</span></strong><span class="koboSpan" id="kobo.167.1"> keyword evaluates the name of the parameter, method, or class it is used on. </span><span class="koboSpan" id="kobo.167.2">A string with the result of that </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">nameof</span></strong><span class="koboSpan" id="kobo.169.1"> evaluation is then included in the compiled code. </span><span class="koboSpan" id="kobo.169.2">In other words, it’s identical to the code we had before – except that if the parameter is ever renamed, our code no longer compiles until the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">nameof</span></strong><span class="koboSpan" id="kobo.171.1"> keyword is updated to refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">renamed parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">This allows us to rely on the compiler to help ensure our parameter validation uses the correct parameter names, even if those parameters are renamed in </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Let’s introduce a more concise way of </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">throwing exceptions.</span></span></p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.177.1">Validation with guard clauses</span></h2>
<p><span class="koboSpan" id="kobo.178.1">Right now, our validation logic </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.179.1">consists of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">if</span></strong><span class="koboSpan" id="kobo.181.1"> statement followed by </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.182.1">a conditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">throw</span></strong><span class="koboSpan" id="kobo.184.1"> statement. </span><span class="koboSpan" id="kobo.184.2">This validation is so common and can take up many lines of code when validation is complex that .NET now gives us a more concise way of interacting with it in the form of </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.185.1">guard clauses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">We can take our validation down to a single line of code by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">ArgumentException.ThrowIfNullOrEmpty</span></strong><span class="koboSpan" id="kobo.189.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
public FlightInfo? </span><span class="koboSpan" id="kobo.191.2">GetFlight(string id, string apiKey) {
</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">  ArgumentException.ThrowIfNullOrEmpty(id, nameof(id));</span></strong></pre>
<p><span class="koboSpan" id="kobo.193.1">This method will check the value of the </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.194.1">parameter it is passed in and will throw either an </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">ArgumentNullException</span></strong><span class="koboSpan" id="kobo.196.1"> error if the value is null or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.198.1"> error if the value is an </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">empty string.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">There aren’t a lot of these validations built into .NET right now, but if you like the idea and want validations</span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.201.1"> for things such as negative values or numeric or date ranges, you’ll love Steve Smith’s excellent </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.202.1">GuardClauses library</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">.</span></span></p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.204.1">Guard clauses with the GuardClauses library</span></h2>
<p><span class="koboSpan" id="kobo.205.1">To help augment the built-in guard </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.206.1">clauses, Steve Smith created the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.207.1">Ardalis.GuardClauses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1"> library.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">To use the GuardClauses library, install the</span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.210.1"> latest version of Ardallis.GuardClauses via NuGet Package Manager, as we’ve done in </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">prior chapters.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Next, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">using Ardalis.GuardClauses;</span></strong><span class="koboSpan" id="kobo.214.1"> to the top of your </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">Once that’s been installed and referenced, you’ll be able to use guard syntax, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.220.1">
public Flights GetFlightsByMiles(int maxMiles,
  string apiKey) {
</span><strong class="bold"><span class="koboSpan" id="kobo.221.1">  Guard.Against.NegativeOrZero(maxMiles);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.222.1">  Guard.Against.NullOrWhiteSpace(apiKey);</span></strong><span class="koboSpan" id="kobo.223.1">
  // Other logic omitted…
}</span></pre>
<p><span class="koboSpan" id="kobo.224.1">Here, the GuardClauses library provides various static methods inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">Guard.Against</span></strong><span class="koboSpan" id="kobo.226.1"> syntax that allow you to validate a great </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">many things.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">If a validation condition is met – for example, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">maxMiles</span></strong><span class="koboSpan" id="kobo.230.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">4</span></strong><span class="koboSpan" id="kobo.232.1"> when </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">NegativeOrZero</span></strong><span class="koboSpan" id="kobo.234.1"> is called – the program continues as normal. </span><span class="koboSpan" id="kobo.234.2">However, if the condition is not met, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.236.1"> error will be thrown containing the name of the parameter that </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.237.1">violated </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">the condition.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">I’ve found this library to be intuitive to write and read, and it also leads to efficient and effective guard clauses that require a minimal amount </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">of effort.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">The full extent of the GuardClauses</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.242.1"> library is well beyond the scope of this book, but you can install it and see the methods available or check out the documentation referenced in the </span><em class="italic"><span class="koboSpan" id="kobo.243.1">Further reading</span></em><span class="koboSpan" id="kobo.244.1"> section at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">this chapter.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.246.1">But wait – there’s more!</span></p>
<p class="callout"><span class="koboSpan" id="kobo.247.1">This book’s wonderful technical reviewers rightly pointed out the popular </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">FluentValidation library</span></strong><span class="koboSpan" id="kobo.249.1">, which offers a rich set of validation rules that can be applied to your classes. </span><span class="koboSpan" id="kobo.249.2">You can learn more about this library in the </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.251.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.253.1">Before we move on, I want to point out one aspect of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Ardalis.GuardClauses</span></strong><span class="koboSpan" id="kobo.255.1"> library that you might not </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">have noticed.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">Let’s say you call a guard clause </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Guard.Against.Null(apiKey);</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">If this validation rule fails it will throw an </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">ArgumentException</span></strong><span class="koboSpan" id="kobo.263.1"> error. </span><span class="koboSpan" id="kobo.263.2">This exception will have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">ParamName</span></strong><span class="koboSpan" id="kobo.265.1"> property with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">apiKey</span></strong><span class="koboSpan" id="kobo.267.1">. </span><span class="koboSpan" id="kobo.267.2">Additionally, the resulting message will mention the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">apiKey</span></strong><span class="koboSpan" id="kobo.269.1"> parameter by name, </span><em class="italic"><span class="koboSpan" id="kobo.270.1">even though you didn’t provide the name when you called the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.271.1">guard clause</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">This works due to the library’s use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">CallerArgumentExpression</span></strong><span class="koboSpan" id="kobo.275.1"> attribute, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">explore next.</span></span></p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.277.1">Using CallerMemberInformation attributes</span></h2>
<p><span class="koboSpan" id="kobo.278.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">nameof</span></strong><span class="koboSpan" id="kobo.280.1"> keyword proved so successful in eliminating strings referring to things that were later renamed that C# grew to accompany four separate attributes that can tell you things about any </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">given method.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Each of these attributes is </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.283.1">applied to a method </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.284.1">parameter. </span><span class="koboSpan" id="kobo.284.2">Like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">nameof</span></strong><span class="koboSpan" id="kobo.286.1"> keyword, these attributes are evaluated at compile time and result in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">string</span></strong><span class="koboSpan" id="kobo.288.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">int</span></strong><span class="koboSpan" id="kobo.290.1"> type being used in the final compiled code in </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">their place.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">The four available caller member attributes are </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">CallerFilePath</span></strong><span class="koboSpan" id="kobo.295.1"> contains a string with the name and path of the file of the code calling to the method on the machine compiling </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the code</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">CallerLineNumber</span></strong><span class="koboSpan" id="kobo.298.1"> contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">int</span></strong><span class="koboSpan" id="kobo.300.1"> type with the line number for the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">method call</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.302.1">CallerMemberName</span></strong><span class="koboSpan" id="kobo.303.1"> contains the name of the method or property where the method </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">call occurred</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">CallerArgumentExpression</span></strong><span class="koboSpan" id="kobo.306.1"> converts the expression passed into the method into a string, before evaluating </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">the expression</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.308.1">Let’s look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">LogApiCall</span></strong><span class="koboSpan" id="kobo.310.1"> for an example </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">of this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
public static void LogApiCall(string url,
</span><strong class="bold"><span class="koboSpan" id="kobo.313.1">  [CallerFilePath] string file = "",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.314.1">  [CallerLineNumber] int line = 0,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.315.1">  [CallerMemberName] string name = "",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.316.1">  [CallerArgumentExpression(nameof(url))] string expr = "")</span></strong><span class="koboSpan" id="kobo.317.1">
{
  Console.WriteLine($"Making API Call to {url}");
  Console.WriteLine("Called in:");
  Console.WriteLine($"{</span><strong class="bold"><span class="koboSpan" id="kobo.318.1">file</span></strong><span class="koboSpan" id="kobo.319.1">}:{</span><strong class="bold"><span class="koboSpan" id="kobo.320.1">line</span></strong><span class="koboSpan" id="kobo.321.1">} at {</span><strong class="bold"><span class="koboSpan" id="kobo.322.1">name</span></strong><span class="koboSpan" id="kobo.323.1">}");
  Console.WriteLine($"Url expression: {</span><strong class="bold"><span class="koboSpan" id="kobo.324.1">expr</span></strong><span class="koboSpan" id="kobo.325.1">}");
}</span></pre>
<p><span class="koboSpan" id="kobo.326.1">This method takes in five parameters, where the first is a standard string parameter and the other four use the various caller member information attributes. </span><span class="koboSpan" id="kobo.326.2">Notice how these attributes all have a default value specified. </span><span class="koboSpan" id="kobo.326.3">When values are not specified for these parameters, the compiler</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.327.1"> will replace each parameter with values it detected </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">during compilation.</span></span></p>
<p><span class="koboSpan" id="kobo.329.1">Let’s look at an </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">example</span></span><span class="No-Break"><a id="_idIndexMarker608"/></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> call:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
public IEnumerable&lt;FlightInfo&gt; GetFlightsByMiles(
  int maxMiles, string apiKey) {
  // Validation omitted...
</span><span class="koboSpan" id="kobo.332.2">  string url = $"/flights/uptodistance/{maxMiles}";
  RestRequest request = new(url);
  request.AddHeader("x-api-key", apiKey);
</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">  LogApiCall(request.Resource);</span></strong><span class="koboSpan" id="kobo.334.1">
  IEnumerable&lt;FlightInfo&gt;? </span><span class="koboSpan" id="kobo.334.2">response =
    _client.Get&lt;IEnumerable&lt;FlightInfo&gt;&gt;(request);
  return response ?? </span><span class="koboSpan" id="kobo.334.3">Enumerable.Empty&lt;FlightInfo&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.335.1">Notice how when </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">LogApiCall</span></strong><span class="koboSpan" id="kobo.337.1"> is invoked, only the string parameter is specified. </span><span class="koboSpan" id="kobo.337.2">The remaining parameters are provided values during compilation due to the attributes on </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">each parameter.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Also, note that the expression that was used to get that string is </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">request.Resource</span></strong><span class="koboSpan" id="kobo.341.1">. </span><span class="koboSpan" id="kobo.341.2">This expression is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">CallerArgumentExpression</span></strong><span class="koboSpan" id="kobo.343.1"> uses to generate its string because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">CallerArgumentExpression</span></strong><span class="koboSpan" id="kobo.345.1"> attribute requires the name of another parameter. </span><span class="koboSpan" id="kobo.345.2">In this case, we specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">[CallerArgumentExpression(nameof(url))]</span></strong><span class="koboSpan" id="kobo.347.1"> to have it look at the expression that was passed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">url</span></strong><span class="koboSpan" id="kobo.349.1"> parameter – the first parameter the method </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">takes in.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">When this code runs, we will see the following message logged in </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">the console:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.353.1">
Making API Call to /flights/uptodistance/500
Called in:
C:\RefactorBook\Chapter10\CloudySkiesFlightProvider.cs:51
  at GetFlightsByMiles
Url expression: request.Resource</span></pre>
<p><span class="koboSpan" id="kobo.354.1">As you can see, it logged the full path to the file on my hard drive, as well as the line number of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">LogApiCall</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.356.1">method call.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">The expression of </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">request.Resource</span></strong><span class="koboSpan" id="kobo.359.1"> is the exact </span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.360.1">string of code that’s used to call that method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.362.1">
LogApiCall(</span><strong class="bold"><span class="koboSpan" id="kobo.363.1">request.Resource</span></strong><span class="koboSpan" id="kobo.364.1">);</span></pre>
<p><span class="koboSpan" id="kobo.365.1">Caller member information</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.366.1"> attributes are very handy for certain types of things, such as logging and validation, or certain </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.367.1">specialized scenarios such as raising </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">INotifyProperty</span></strong><span class="koboSpan" id="kobo.369.1"> changed in </span><strong class="bold"><span class="koboSpan" id="kobo.370.1">Windows Presentation Foundation</span></strong><span class="koboSpan" id="kobo.371.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.372.1">WPF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">) applications.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Now that we’ve sufficiently explored working with parameters for our methods, let’s look at how modern C# lets us work safely with </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">null values.</span></span></p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.376.1">Protecting against null</span></h1>
<p><span class="koboSpan" id="kobo.377.1">British computer scientist, Tony Hoare, is </span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.378.1">generally credited as the inventor of the null reference in programming. </span><span class="koboSpan" id="kobo.378.2">In 2008, he famously apologized for it, calling it his “billion-dollar mistake.” </span><span class="koboSpan" id="kobo.378.3">This was due to the countless bugs and crashes that have occurred in various programming languages when code attempted to interact with variables currently holding null values. </span><span class="koboSpan" id="kobo.378.4">While I can’t fault Tony Hoare, nulls can certainly </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">be dangerous.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">In .NET, this comes in the form of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.382.1"> error, as we saw earlier in this chapter. </span><span class="koboSpan" id="kobo.382.2">You get a </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.384.1"> error any time you attempt to invoke a method or evaluate a property on a variable that currently holds a </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">null value.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Before C# 8, developers needed to be explicitly aware that any reference type could hold a null value and write conditional logic, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
if (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">flight != null</span></strong><span class="koboSpan" id="kobo.390.1">) {
 Console.WriteLine($"Flight {</span><strong class="bold"><span class="koboSpan" id="kobo.391.1">flight.Id</span></strong><span class="koboSpan" id="kobo.392.1">}: {</span><strong class="bold"><span class="koboSpan" id="kobo.393.1">flight.Status</span></strong><span class="koboSpan" id="kobo.394.1">}");
}</span></pre>
<p><span class="koboSpan" id="kobo.395.1">This pattern of checking for nullability and then conditionally acting became prevalent in C# because when it didn’t, developers encountered </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">NullReferenceException</span></strong><span class="koboSpan" id="kobo.397.1"> errors. </span><span class="koboSpan" id="kobo.397.2">Unfortunately, this led to null checks occurring throughout the code, including in many places where nulls would never </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">be encountered.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">In C# 8, nullable reference</span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.400.1"> types were introduced, which helped developers understand when and where they were likely to encounter null values so that they would have active reminders to guard against null values in those places. </span><span class="koboSpan" id="kobo.400.2">Additionally, these improvements made it easier to remove unnecessary null checks in places where nulls were </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">not expected.</span></span></p>
<p><span class="koboSpan" id="kobo.402.1">In C# 8 and beyond, when nullability analysis is enabled, you can indicate that any reference type may be null by adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">?</span></strong><span class="koboSpan" id="kobo.404.1"> after the type indicator, as shown here </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">FlightInfo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.408.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.409.1">FlightInfo?</span></strong><span class="koboSpan" id="kobo.410.1"> GetFlight(string id, string apiKey) {
  ArgumentException.ThrowIfNullOrEmpty(id);
  ArgumentException.ThrowIfNullOrEmpty(apiKey);
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-Api-key", apiKey);
  LogApiCall(request.Resource);
  return client.Get&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">FlightInfo?</span></strong><span class="koboSpan" id="kobo.412.1">&gt;(request);
}</span></pre>
<p><span class="koboSpan" id="kobo.413.1">In this case, this indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">GetFlight</span></strong><span class="koboSpan" id="kobo.415.1"> method will return either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.417.1"> instance or a null value. </span><span class="koboSpan" id="kobo.417.2">Additionally, this indicates that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">id</span></strong><span class="koboSpan" id="kobo.419.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">apiKey</span></strong><span class="koboSpan" id="kobo.421.1"> parameters will always have a string that is not null. </span><span class="koboSpan" id="kobo.421.2">If these accepted null values, they would be declared as </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">string? </span><span class="koboSpan" id="kobo.422.2">Id, string? </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">apiKey</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1"> instead.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.425.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.426.1">Nullability analysis in C# does not prevent you from passing null to things that say they do not accept null values, nor does it prevent you from returning null values from methods that claim to return a non-null return type. </span><span class="koboSpan" id="kobo.426.2">Instead, nullability analysis flags these cases as warnings, which will help you address these issues. </span><span class="koboSpan" id="kobo.426.3">We’ll talk more about code analysis warnings in </span><a href="B21324_12.xhtml#_idTextAnchor259"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.427.1">Chapter 12</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.428.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">If we wanted to say that </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">GetFlight</span></strong><span class="koboSpan" id="kobo.431.1"> could </span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.432.1">never return null, we would remove </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">?</span></strong><span class="koboSpan" id="kobo.434.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.436.1"> return type and validate that the result from the API was </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">not null:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.438.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.439.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.440.1"> GetFlight(string id, string apiKey) {
  ArgumentException.ThrowIfNullOrEmpty(id);
  ArgumentException.ThrowIfNullOrEmpty(apiKey);
  RestRequest request = new($"/flights/{id.ToLower()}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
</span><strong class="bold"><span class="koboSpan" id="kobo.441.1">  FlightInfo? </span><span class="koboSpan" id="kobo.441.2">flightInfo=_client.Get&lt;FlightInfo?&gt;(request);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.442.1">  if (flightInfo == null) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.443.1">    </span></strong><strong class="bold"><span class="koboSpan" id="kobo.444.1">string message = $"Could not find flight {id}";</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.445.1">    throw new InvalidOperationException(message);</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.446.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.447.1">  return flightInfo;</span></strong><span class="koboSpan" id="kobo.448.1">
}</span></pre>
<p><span class="koboSpan" id="kobo.449.1">The request to the API via </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">_client.Get</span></strong><span class="koboSpan" id="kobo.451.1"> still might return a nullable value, so the code must now check for null and conditionally throw an exception if a null value is encountered. </span><span class="koboSpan" id="kobo.451.2">However, this guarantees that the code returns only a non-null value, which is what the return type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.453.1"> indicates with nullability </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">analysis active.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Let’s look at how to enable and disable nullability analysis in </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">Visual Studio.</span></span></p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.457.1">Enabling nullability analysis in C#</span></h2>
<p><span class="koboSpan" id="kobo.458.1">Since .NET 6, nullable </span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.459.1">reference types are enabled by default in new projects </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">going forward.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">However, you can enable</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.462.1"> nullable reference types in any project using C# 8 or above by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">&lt;Nullable&gt;enable&lt;/Nullable&gt;</span></strong><span class="koboSpan" id="kobo.464.1"> node to your project’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">csproj</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.467.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.468.1">
&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Library&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    </span><strong class="bold"><span class="koboSpan" id="kobo.469.1">&lt;Nullable&gt;enable&lt;/Nullable&gt;</span></strong><span class="koboSpan" id="kobo.470.1">
    &lt;RootNamespace&gt;Packt.CloudySkiesAir&lt;/RootNamespace&gt;
  &lt;/PropertyGroup&gt;
&lt;/Project&gt;</span></pre>
<p><span class="koboSpan" id="kobo.471.1">You can edit this file either in a text editor such as Notepad, or you can double-click on the project node in </span><strong class="bold"><span class="koboSpan" id="kobo.472.1">Solution Explorer</span></strong><span class="koboSpan" id="kobo.473.1"> to edit the file inside </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">Visual Studio.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">If you don’t want nullability analysis enabled for your entire project, you can enable and disable nullability analysis with preprocessor statements such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">#nullable enable</span></strong><span class="koboSpan" id="kobo.477.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">#nullable disable</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">For example, the following code temporarily disables nullability analysis for a </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">class definition:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.481.1">#nullable disable</span></strong><span class="koboSpan" id="kobo.482.1">
public class FlightInfo {
    public string Id { get; set; }
    public FlightStatus Status { get; set; }
    public string Origin { get; set; }
    public string Destination { get; set; }
    public DateTime DepartureTime { get; set; }
    public DateTime ArrivalTime { get; set; }
    public int Miles { get; set; }
    public override string ToString() =&gt;
      $"{Id} from {Origin} to {Destination} " +
      $"on {DepartureTime}. </span><span class="koboSpan" id="kobo.482.2">Status: {Status}";
}
</span><strong class="bold"><span class="koboSpan" id="kobo.483.1">#nullable restore</span></strong></pre>
<p><span class="koboSpan" id="kobo.484.1">I’d encourage you to use project-level nullability analysis and avoid using </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">#nullable</span></strong><span class="koboSpan" id="kobo.486.1"> when possible. </span><span class="koboSpan" id="kobo.486.2">I’ve known </span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.487.1">many developers who get nauseated every time they see a preprocessor</span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.488.1"> statement. </span><span class="koboSpan" id="kobo.488.2">My opinion is that </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">#nullable</span></strong><span class="koboSpan" id="kobo.490.1"> should be reserved for when you are moving a larger project to use nullability analysis but are not yet ready to enable it for the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">entire project.</span></span></p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.492.1">Using nullability operators</span></h2>
<p><span class="koboSpan" id="kobo.493.1">Earlier, we talked about how </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">?</span></strong><span class="koboSpan" id="kobo.495.1"> indicates that a type may contain a null value, but there are several other operators</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.496.1"> related to nullability you should be aware of </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">in C#.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">First of all, the non-null assertion operator of </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">!</span></strong><span class="koboSpan" id="kobo.500.1"> tells C# that something is not going to be null and to ignore nullability warnings on </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">that value.</span></span></p>
<p><span class="koboSpan" id="kobo.502.1">One common place I use this is when working with </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Console.ReadLine()</span></strong><span class="koboSpan" id="kobo.504.1">. </span><span class="koboSpan" id="kobo.504.2">This method indicates it may return a null value, but in practice, it never does in normal operation. </span><span class="koboSpan" id="kobo.504.3">This can be suppressed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">!</span></strong><span class="koboSpan" id="kobo.506.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.508.1">
Console.WriteLine("Enter a flight #: ");
</span><strong class="bold"><span class="koboSpan" id="kobo.509.1">string</span></strong><span class="koboSpan" id="kobo.510.1"> id = Console.ReadLine()</span><strong class="bold"><span class="koboSpan" id="kobo.511.1">!</span></strong><span class="koboSpan" id="kobo.512.1">;</span></pre>
<p><span class="koboSpan" id="kobo.513.1">Here, we are taking </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">ReadLine</span></strong><span class="koboSpan" id="kobo.515.1">, which is defined as having a </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">string?</span></strong><span class="koboSpan" id="kobo.517.1"> result and storing it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">string</span></strong><span class="koboSpan" id="kobo.519.1">. </span><span class="koboSpan" id="kobo.519.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">!</span></strong><span class="koboSpan" id="kobo.521.1"> operator says that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">string?</span></strong><span class="koboSpan" id="kobo.523.1"> result should be treated as if it </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">was </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Other nullability operators include </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.529.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.530.1">null-conditional operator</span></strong><span class="koboSpan" id="kobo.531.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">?</span></strong><span class="koboSpan" id="kobo.533.1">), which conditionally calls methods only if the object they’re being invoked on is</span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.534.1"> not null. </span><span class="koboSpan" id="kobo.534.2">For</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.535.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">_conn?.Dispose()</span></strong><span class="koboSpan" id="kobo.537.1"> calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">Dispose</span></strong><span class="koboSpan" id="kobo.539.1"> method only if </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">_conn</span></strong><span class="koboSpan" id="kobo.541.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">not null.</span></span></li>
<li><span class="koboSpan" id="kobo.543.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">null coalescing operator</span></strong><span class="koboSpan" id="kobo.545.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">??</span></strong><span class="koboSpan" id="kobo.547.1">), which uses a backup value in case something is null. </span><span class="koboSpan" id="kobo.547.2">For </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.548.1">example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">int miles = flight?.Miles ?? </span><span class="koboSpan" id="kobo.549.2">0;</span></strong><span class="koboSpan" id="kobo.550.1"> uses null-conditional and </span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.551.1">null coalescing operators to safely get </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">Miles</span></strong><span class="koboSpan" id="kobo.553.1"> out of a flight or use </span><strong class="source-inline"><span class="koboSpan" id="kobo.554.1">0</span></strong><span class="koboSpan" id="kobo.555.1"> when no flight </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">is present.</span></span></li>
<li><span class="koboSpan" id="kobo.557.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">null coalescing assignment operator</span></strong><span class="koboSpan" id="kobo.559.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">??=</span></strong><span class="koboSpan" id="kobo.561.1">) assigns a value to a variable only if the</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.562.1"> variable is null already. </span><span class="koboSpan" id="kobo.562.2">For</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.563.1"> example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">message ??= "An unexpected error has occurred";</span></strong><span class="koboSpan" id="kobo.565.1"> will only set the new error message in </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">message</span></strong><span class="koboSpan" id="kobo.567.1"> if </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">message</span></strong><span class="koboSpan" id="kobo.569.1"> is null. </span><span class="koboSpan" id="kobo.569.2">This allows us to effectively replace null values with </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">backup values.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.571.1">The combination of nullability analysis and nullability operators helps us make intelligent decisions around null values in concise ways. </span><span class="koboSpan" id="kobo.571.2">This keeps our code efficient and focused while guiding us toward having a cohesive strategy around handling null values </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">in code.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">Let’s take a broader look at changes we can make at the class level to help design more </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">robust applications.</span></span></p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.575.1">Moving beyond classes</span></h1>
<p><span class="koboSpan" id="kobo.576.1">In C# 9 and beyond, Microsoft</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.577.1"> has made concerted efforts to give developers new options for working with classes through things such as record types, init-only properties, primary constructors, </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.579.1">In this section, we’ll explore how these newer C# constructs can improve the design of </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">your classes.</span></span></p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.581.1">Preferring immutable classes</span></h2>
<p><span class="koboSpan" id="kobo.582.1">In recent years, immutable </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.583.1">classes have become more and more popular. </span><span class="koboSpan" id="kobo.583.2">This immutability refers to the inability to change an object after it has </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">been created.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">What this means is that once an object exists, you cannot modify its state and instead are limited to creating new objects that are like the original. </span><span class="koboSpan" id="kobo.585.2">If you’re familiar with working with string and DateTime objects in .NET, you’ve seen this concept with methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">ToLower</span></strong><span class="koboSpan" id="kobo.587.1"> on string and </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">AddDays</span></strong><span class="koboSpan" id="kobo.589.1"> on DateTime returning a new object instead of modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">original object.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Let’s look at a small class representing a boarding pass that is currently mutable (changeable) and then convert it into an </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">immutable class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.593.1">
public class BoardingPass {
  public FlightInfo Flight { get; set; }
  public string Passenger { get; set; }
  public int Group { get; set; }
  public string Seat { get; set; }
}</span></pre>
<p><span class="koboSpan" id="kobo.594.1">This is a “plain old C# object” with properties with getters and setters. </span><span class="koboSpan" id="kobo.594.2">Thinking about the class logically, there are </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">several problems:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.596.1">There’s nothing preventing </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Flight</span></strong><span class="koboSpan" id="kobo.598.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">Passenger</span></strong><span class="koboSpan" id="kobo.600.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Seat</span></strong><span class="koboSpan" id="kobo.602.1"> from having a </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">null value.</span></span></li>
<li><span class="koboSpan" id="kobo.604.1">Once a pass is created, properties such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">passenger</span></strong><span class="koboSpan" id="kobo.606.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">boarding group</span></strong><span class="koboSpan" id="kobo.608.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">seat</span></strong><span class="koboSpan" id="kobo.610.1">, and even </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">flight</span></strong><span class="koboSpan" id="kobo.612.1"> can be changed. </span><span class="koboSpan" id="kobo.612.2">This doesn’t make sense in the context of an airline business where a new boarding pass would need to be issued to </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">change these.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.614.1">We can change this object so that it’s immutable and requires valid values for these parameters by removing their setters and adding a constructor </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">with validation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
public BoardingPass(FlightInfo flight, string passenger,
  string seat, int group) {
  ArgumentNullException.ThrowIfNull(flight);
  ArgumentException.ThrowIfNullOrEmpty(passenger);
  ArgumentException.ThrowIfNullOrEmpty(seat);
  if (group &lt; 1 || group &gt; 8) {
    throw new ArgumentOutOfRangeException(nameof(group));
  }
  Flight = flight;
  Passenger = passenger;
  Seat = seat;
  Group = group;
}</span></pre>
<p><span class="koboSpan" id="kobo.617.1">This constructor now requires that valid values are present for all properties on the object in object creation. </span><span class="koboSpan" id="kobo.617.2">Meanwhile, the removal of setters for the properties ensures that the class stays</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.618.1"> valid and cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">be changed.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">If we needed to, we could add new methods to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.622.1"> class that create and return a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.624.1"> object with similar characteristics to the original in a similar manner to how various string and DateTime methods work. </span><span class="koboSpan" id="kobo.624.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">with expressions</span></strong><span class="koboSpan" id="kobo.626.1"> give us a more interesting way of doing this, as we’ll see later in </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">While using immutability may seem more inconvenient than beneficial at first, there are a few key advantages of using </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">immutable classes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.630.1">Immutable classes can be validated during creation and ensured that they are in a valid state. </span><span class="koboSpan" id="kobo.630.2">Once</span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.631.1"> created, this valid state </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">cannot change.</span></span></li>
<li><span class="koboSpan" id="kobo.633.1">When objects can be modified anywhere in your code, this makes it harder to track down what changed an object when multiple other classes may have a reference to it. </span><span class="koboSpan" id="kobo.633.2">Immutable objects prevent this </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">from occurring.</span></span></li>
<li><span class="koboSpan" id="kobo.635.1">Some concepts just make more sense as immutable objects, such as a prior version of a document or a boarding pass for a passenger at </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">an airport.</span></span></li>
<li><span class="koboSpan" id="kobo.637.1">Since immutable objects don’t change, they can be reliably worked with in multi-threaded applications. </span><span class="koboSpan" id="kobo.637.2">Without</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.638.1"> immutability, you’d need to rely on using </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Interlocked</span></strong><span class="koboSpan" id="kobo.640.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">lock</span></strong><span class="koboSpan" id="kobo.642.1"> keyword, or thread-safe collections to </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">avoid bugs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.644.1">Of course, having to specify all the properties of an object in its constructor can be cumbersome for classes with many properties. </span><span class="koboSpan" id="kobo.644.2">Additionally, not every class in your project needs to be immutable. </span><span class="koboSpan" id="kobo.644.3">For those classes that would benefit from immutability, C#’s required keyword and init-only properties help alleviate </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">this burden.</span></span></p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.646.1">Using required and init-only properties</span></h2>
<p><span class="koboSpan" id="kobo.647.1">The downside of adding every property as a parameter to class constructors is that your constructors can start to </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.648.1">become larger than you’d like. </span><span class="koboSpan" id="kobo.648.2">Additionally, creating objects that require many constructor parameters is tedious and error-prone and the </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.649.1">creation of individual objects can be tedious and confusing, particularly when many constructor parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">are needed.</span></span></p>
<p><span class="koboSpan" id="kobo.651.1">On the other hand, object initializers can be more readable, but until recently, they lacked a way of ensuring properties </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">are present.</span></span></p>
<p><span class="koboSpan" id="kobo.653.1">Look at the two ways of creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.655.1"> object and see which appears more readable </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">to you:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.657.1">
BoardingPass p1 = new(myFlight, "Amleth Hamlet", "2B", 1);
BoardingPass p2 = {
  Flight = myFlight,
  Passenger = "Amleth Hamlet",
  Seat = "2B",
  Group = 1
};</span></pre>
<p><span class="koboSpan" id="kobo.658.1">The object initializer version used in </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">p2</span></strong><span class="koboSpan" id="kobo.660.1"> is more readable and maintainable, particularly as the number of properties you might want to set in the class grows </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">The traditional downside of this </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.663.1">approach was that a developer using the object initializer might forget to </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.664.1">set important required properties. </span><span class="koboSpan" id="kobo.664.2">C# 11 introduced the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">required</span></strong><span class="koboSpan" id="kobo.666.1"> keyword, which will fail to compile if a required property is not explicitly initialized during object initialization or in the constructor when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">Passenger</span></strong><span class="koboSpan" id="kobo.668.1"> property is omitted, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.669.1">Figure 10</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.670.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<span class="koboSpan" id="kobo.672.1"><img alt="Figure 10.2 – A compiler error due to Passenger not being set" src="image/B21324_10_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.673.1">Figure 10.2 – A compiler error due to Passenger not being set</span></p>
<p><span class="koboSpan" id="kobo.674.1">To achieve this, we can add </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">required</span></strong><span class="koboSpan" id="kobo.676.1"> to any property definitions on the class that we want to make sure they are explicitly set by the time the object-initializer completes. </span><span class="koboSpan" id="kobo.676.2">The following version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.678.1"> features </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">required properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.680.1">
public class BoardingPass {
  public </span><strong class="bold"><span class="koboSpan" id="kobo.681.1">required</span></strong><span class="koboSpan" id="kobo.682.1"> FlightInfo Flight { get; </span><strong class="bold"><span class="koboSpan" id="kobo.683.1">init</span></strong><span class="koboSpan" id="kobo.684.1">; }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.685.1">required</span></strong><span class="koboSpan" id="kobo.686.1"> string Passenger { get; </span><strong class="bold"><span class="koboSpan" id="kobo.687.1">init</span></strong><span class="koboSpan" id="kobo.688.1">; }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">required</span></strong><span class="koboSpan" id="kobo.690.1"> int Group { get; </span><strong class="bold"><span class="koboSpan" id="kobo.691.1">init</span></strong><span class="koboSpan" id="kobo.692.1">; }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">required</span></strong><span class="koboSpan" id="kobo.694.1"> string Seat { get; </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">init</span></strong><span class="koboSpan" id="kobo.696.1">; }
}</span></pre>
<p><span class="koboSpan" id="kobo.697.1">You may have also noticed that this class definition defines these properties as </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">{get; init;}</span></strong><span class="koboSpan" id="kobo.699.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">{get;}</span></strong><span class="koboSpan" id="kobo.701.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">{get; set;}</span></strong><span class="koboSpan" id="kobo.703.1">. </span><span class="koboSpan" id="kobo.703.2">While the traditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">get; set;</span></strong><span class="koboSpan" id="kobo.705.1"> combination allows a property to be changed at any time, this violates immutability. </span><span class="koboSpan" id="kobo.705.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">get;</span></strong><span class="koboSpan" id="kobo.707.1"> version removes the ability to set the property anywhere but the constructor, which means properties defined as </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">get;</span></strong><span class="koboSpan" id="kobo.709.1"> cannot be set in </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">object initializers.</span></span></p>
<p><span class="koboSpan" id="kobo.711.1">The newer </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">get; init;</span></strong><span class="koboSpan" id="kobo.713.1"> combination that was added in C# 9 allows the property to be set in the constructor or initializer, but no longer allows setting after the object is initialized. </span><span class="koboSpan" id="kobo.713.2">This helps us support our immutable class design while not restricting the user to </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">using constructors.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">I believe that object initializers are the future of .NET and nowadays tend to favor required properties </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.716.1">with </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">get; init;</span></strong><span class="koboSpan" id="kobo.718.1"> when designing classes </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">for immutability.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Speaking of the </span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.721.1">future, let’s look at a brand-new feature in C# 12: primary constructors for </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">reference types.</span></span></p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.723.1">Primary constructors</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.724.1">Primary constructors</span></strong><span class="koboSpan" id="kobo.725.1"> are constructors that must be called to initialize the class and provide a way of automatically creating fields in your class. </span><span class="koboSpan" id="kobo.725.2">We’ll talk more about what that “must be called” phrase</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.726.1"> entails in a moment, but let’s start by looking at a </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">simple example:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.728.1">public class BoardingPass(string Passenger)</span></strong><span class="koboSpan" id="kobo.729.1"> {
  public required FlightInfo Flight { get; init; }
  public required int Group { get; init; }
  public required string Seat { get; init; }
  public override string ToString() =&gt;
    $"{</span><strong class="bold"><span class="koboSpan" id="kobo.730.1">Passenger</span></strong><span class="koboSpan" id="kobo.731.1">} in group {Group} " +
    $"for seat {Seat} of {Flight.Id}";
}</span></pre>
<p><span class="koboSpan" id="kobo.732.1">This version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.734.1"> has parentheses and a parameter list immediately following the class declaration. </span><span class="koboSpan" id="kobo.734.2">This is the primary constructor for </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">the class.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">Any parameters declared in the primary constructor are available as if they were init-only properties. </span><span class="koboSpan" id="kobo.736.2">This makes a primary constructor roughly equivalent to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">C# code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.738.1">
public class BoardingPass {
</span><strong class="bold"><span class="koboSpan" id="kobo.739.1">  public BoardingPass(string passenger) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.740.1">    this.Passenger = passenger;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.741.1">  }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.742.1">  public string Passenger {get; init; }</span></strong><span class="koboSpan" id="kobo.743.1">
  // Other members omitted for brevity...
</span><span class="koboSpan" id="kobo.743.2">}</span></pre>
<p><span class="koboSpan" id="kobo.744.1">The advantage of primary constructors is that they are very concise and do not require you to define a constructor or </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">field definitions.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">Primary constructors </span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.747.1">can work with other constructors, though any other constructor you declare must call the primary constructor using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">this</span></strong><span class="koboSpan" id="kobo.749.1"> keyword, as </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.751.1">
public class BoardingPass(string Passenger) {
</span><strong class="bold"><span class="koboSpan" id="kobo.752.1">  public BoardingPass(FlightInfo flight, string passenger)</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.753.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.754.1">: this(passenger) {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.755.1">    Flight = flight;</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.756.1">  }</span></strong><span class="koboSpan" id="kobo.757.1">
  // other members omitted for brevity...
</span><span class="koboSpan" id="kobo.757.2">}</span></pre>
<p><span class="koboSpan" id="kobo.758.1">Essentially, your primary constructor must always be called – either on its own or from another constructor via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">this</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.760.1"> keyword.</span></span></p>
<p><span class="koboSpan" id="kobo.761.1">Primary constructors are not unique to classes and exist for records starting in </span><span class="No-Break"><span class="koboSpan" id="kobo.762.1">C# 9.</span></span></p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.763.1">Converting classes into record classes</span></h2>
<p><span class="koboSpan" id="kobo.764.1">Throughout this book, I’ve </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.765.1">alluded to </span><strong class="bold"><span class="koboSpan" id="kobo.766.1">record classes</span></strong><span class="koboSpan" id="kobo.767.1"> several times</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.768.1"> without defining them or going into detail on why you’d want to </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">use one.</span></span></p>
<p><span class="koboSpan" id="kobo.770.1">To understand record classes, let’s talk briefly about equality in classes. </span><span class="koboSpan" id="kobo.770.2">By default, two objects are considered equal if they both live in the same memory address in </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">the heap.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">This means that, by default, two separate objects with identical properties are not equal. </span><span class="koboSpan" id="kobo.772.2">For example, the </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.773.1">following code would evaluate these two boarding passes as different from </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">each other:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.775.1">
BoardingPass pass1 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass pass2 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
Console.WriteLine(</span><strong class="bold"><span class="koboSpan" id="kobo.776.1">pass1 == pass2</span></strong><span class="koboSpan" id="kobo.777.1">); // false</span></pre>
<p><span class="koboSpan" id="kobo.778.1">You can change this behavior </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.779.1">by overriding </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">Equals</span></strong><span class="koboSpan" id="kobo.781.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">GetHashCode</span></strong><span class="koboSpan" id="kobo.783.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">BoardingPass</span></strong><span class="koboSpan" id="kobo.785.1"> class, as we did in </span><a href="B21324_05.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.786.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.787.1">. </span><span class="koboSpan" id="kobo.787.2">However, record types give us an easier way of </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">managing this.</span></span></p>
<p><span class="koboSpan" id="kobo.789.1">Record classes are like normal C# classes except equality works by comparing all properties to each other. </span><span class="koboSpan" id="kobo.789.2">In other words, record classes are like normal C# classes that have overridden </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">Equals</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.791.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">GetHashCode</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">Let’s redeclare our boarding pass as a </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">record class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.796.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.797.1">record class</span></strong><span class="koboSpan" id="kobo.798.1"> BoardingPass(string Passenger) {
  public required FlightInfo Flight { get; init; }
  public required int Group { get; init; }
  public required string Seat { get; init; }
  public override string ToString() =&gt;
    $"{Passenger} in group {Group} " +
    $"for seat {Seat} of {Flight.Id}";
}</span></pre>
<p><span class="koboSpan" id="kobo.799.1">Now, we can</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.800.1"> successfully compare two boarding passes using just </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">their values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.802.1">
BoardingPass pass1 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass pass2 = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
Console.WriteLine(pass1 == pass2); // true</span></pre>
<p><span class="koboSpan" id="kobo.803.1">These two classes are </span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.804.1">considered equal because they carry the same values. </span><span class="koboSpan" id="kobo.804.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Flight</span></strong><span class="koboSpan" id="kobo.806.1"> property refers to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.808.1"> object, which is still a standard C# class and uses traditional reference equality. </span><span class="koboSpan" id="kobo.808.2">This means that boarding passes must point to the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.810.1"> object in memory; otherwise, they will not be considered equal. </span><span class="koboSpan" id="kobo.810.2">This can be changed by making </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.812.1"> a record class </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">I recommend using record classes for small objects that you might want to compare to each other. </span><span class="koboSpan" id="kobo.814.2">They also might be helpful for classes that might be frequently instantiated, such as objects coming from the database or an external </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">API call.</span></span></p>
<p><span class="koboSpan" id="kobo.816.1">Let’s move on to talk about my favorite new way of creating objects: </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">with</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.818.1"> expressions.</span></span></p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.819.1">Cloning objects using with expressions</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.820.1">with expressions</span></strong><span class="koboSpan" id="kobo.821.1"> are a shorthand way of creating an object that’s like another object but with a few differences. </span><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">with</span></strong><span class="koboSpan" id="kobo.823.1"> expressions work very well with immutable records by allowing you to clone</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.824.1"> and slightly tweak the source record without making any modifications to the </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">original record.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">Let’s say that Hamlet’s boarding pass for seat 2B on the flight needed to be changed. </span><span class="koboSpan" id="kobo.826.2">The system could instantiate a new boarding pass that was just like the original one except for seat 2C using the </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
BoardingPass pass = new("Amleth Hamlet") {
    Flight = nextFlight,
    Seat = "2B",
    Group = 2
};
BoardingPass newPass = </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">pass with { Seat = "3B" }</span></strong><span class="koboSpan" id="kobo.830.1">;</span></pre>
<p><span class="koboSpan" id="kobo.831.1">This creates a new boarding pass based on the original one but with one property </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">slightly different.</span></span></p>
<p><span class="koboSpan" id="kobo.833.1">If we wanted to move Hamlet to have a new seat but an earlier boarding group, we could do that as well by listing an additional property, as </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.835.1">
BoardingPass newPass2 = </span><strong class="bold"><span class="koboSpan" id="kobo.836.1">pass with {Seat = "3B", Group = 1}</span></strong><span class="koboSpan" id="kobo.837.1">;</span></pre>
<p><span class="koboSpan" id="kobo.838.1">I find </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">with</span></strong><span class="koboSpan" id="kobo.840.1"> expressions to be one of the most exciting things about working with record classes in C# and I love the direction the language is going in to streamline the creation </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">of objects.</span></span></p>
<p><span class="koboSpan" id="kobo.842.1">This style of referring to property values is not unique to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">with</span></strong><span class="koboSpan" id="kobo.844.1"> expression, as we’ll see in the next section with </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">pattern matching.</span></span></p>
<h1 id="_idParaDest-229"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.846.1">Advanced type usage</span></h1>
<p><span class="koboSpan" id="kobo.847.1">In this final section of this chapter, we’ll see how new and old language features help you build </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">better types.</span></span></p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.849.1">Exploring pattern matching</span></h2>
<p><span class="koboSpan" id="kobo.850.1">It turns out that we can use the same style of syntax we used with expressions earlier to conditionally match </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.851.1">different objects through </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.852.1">pattern matching</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.854.1">To explain what I mean, let’s start with an example that loops over different </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">boarding passes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.856.1">
List&lt;BoardingPass&gt; passes = PassGenerator.Generate();
foreach (BoardingPass pass in passes) {
  if (</span><strong class="bold"><span class="koboSpan" id="kobo.857.1">pass is { Group: 1 or 2 or 3,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.858.1">                Flight.Status: FlightStatus.Pending</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.859.1">              }) </span></strong><span class="koboSpan" id="kobo.860.1">{
    Console.WriteLine($"{pass.Passenger} board now");
  } else if (</span><strong class="bold"><span class="koboSpan" id="kobo.861.1">pass is { Flight.Status: FlightStatus.Active</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.862.1">                       or FlightStatus.Completed</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.863.1">                     }</span></strong><span class="koboSpan" id="kobo.864.1">) {
    Console.WriteLine($"{pass.Passenger} flight missed");
  } else {
    Console.WriteLine($"{pass.Passenger} please wait");
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.865.1">This code loops over a collection of boarding passes and does one of </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">three things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.867.1">If the flight is </span><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">Pending</span></strong><span class="koboSpan" id="kobo.869.1"> and the passenger is in group 1, 2, or 3, we tell them </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">to board</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.871.1">If the flight is </span><strong class="source-inline"><span class="koboSpan" id="kobo.872.1">Active</span></strong><span class="koboSpan" id="kobo.873.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Completed</span></strong><span class="koboSpan" id="kobo.875.1">, we tell the passenger they missed </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">their flight</span></span></p>
<p><span class="koboSpan" id="kobo.877.1">If neither of these cases is true, the flight must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">Pending</span></strong><span class="koboSpan" id="kobo.879.1">, but the passenger’s group is not boarding, so we tell them </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">to wait</span></span></p>
<p><span class="koboSpan" id="kobo.881.1">The code is a little arbitrary, particularly in how it deals with the boarding group, but it illustrates some of the capabilities of </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">pattern matching.</span></span></p>
<p><span class="koboSpan" id="kobo.883.1">Using pattern matching, you can evaluate one or more properties on an object in an </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">if</span></strong><span class="koboSpan" id="kobo.885.1"> statement to concisely check multiple things </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">at once.</span></span></p>
<p><span class="koboSpan" id="kobo.887.1">While you can use pattern matching in </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">if</span></strong><span class="koboSpan" id="kobo.889.1"> statements, they are also commonly used in switch expressions, as we saw in </span><a href="B21324_03.xhtml#_idTextAnchor045"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.890.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.891.1">. </span><span class="koboSpan" id="kobo.891.2">We could rewrite our code from earlier into a switch </span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.892.1">expression, </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
List&lt;BoardingPass&gt; passes = PassGenerator.Generate();
foreach (BoardingPass pass in passes) {
</span><strong class="bold"><span class="koboSpan" id="kobo.895.1">  </span></strong><strong class="bold"><span class="koboSpan" id="kobo.896.1">string message = pass switch {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.897.1">    { Flight.Status: FlightStatus.Pending,</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.898.1">      Group: 1 or 2 or 3 }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.899.1">      =&gt; $"{pass.passenger} board now",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.900.1">    { Flight.Status: not FlightStatus.Pending }</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.901.1">      =&gt; $"{pass.passenger} flight missed",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.902.1">      _ =&gt; $"{pass.passenger} please wait",</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.903.1">  };</span></strong><span class="koboSpan" id="kobo.904.1">
  Console.WriteLine(message);
}</span></pre>
<p><span class="koboSpan" id="kobo.905.1">Here, we can see the switch expressions concept combined with the power of pattern matching to set a string in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">message</span></strong><span class="koboSpan" id="kobo.907.1"> variable. </span><span class="koboSpan" id="kobo.907.2">Note that the code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">not FlightStatus.Pending</span></strong><span class="koboSpan" id="kobo.909.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">FlightStatus.Active or FlightStatus.Completed</span></strong><span class="koboSpan" id="kobo.911.1"> for brevity and to illustrate the usage of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">not</span></strong><span class="koboSpan" id="kobo.913.1"> keyword in negating or inverting pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">matching expressions.</span></span></p>
<p><span class="koboSpan" id="kobo.915.1">While this code takes some adjustment to learn to read, there’s also very little “waste” in this syntax. </span><span class="koboSpan" id="kobo.915.2">Almost the entirety of every line of code is centered around either the conditions that must be true or the value to use when they are true. </span><span class="koboSpan" id="kobo.915.3">Additionally, this syntax can handle more complex scenarios such as or and not statements more easily than normal C# </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">logic can.</span></span></p>
<p><span class="koboSpan" id="kobo.917.1">Of course, as with any new C# language feature, if the readability cost is too high for you and your team, you are free to avoid switch expressions and pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.918.1">matching entirely.</span></span></p>
<p><span class="koboSpan" id="kobo.919.1">Now that we’ve seen</span><a id="_idIndexMarker648"/><span class="koboSpan" id="kobo.920.1"> how pattern matching and switch expressions work together in the latest versions of C#, let’s look at one of C#’s earliest </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">enhancements: generics.</span></span></p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.922.1">Using generics to reduce duplication</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.923.1">Generics</span></strong><span class="koboSpan" id="kobo.924.1"> are a concept that every .NET developer encounters and works </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">with daily.</span></span></p>
<p><span class="koboSpan" id="kobo.926.1">When you work with </span><strong class="source-inline"><span class="koboSpan" id="kobo.927.1">List&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.928.1"> (pronounced “list of strings”), you are working with a generic </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">List</span></strong><span class="koboSpan" id="kobo.930.1"> object that can hold something of a specific type – in this </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">case, strings.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">Generics work by specifying at least one type parameter that goes into either a class or a method and allows the class or method to be structured around </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">that type.</span></span></p>
<p><span class="koboSpan" id="kobo.934.1">To illustrate the advantage of generics, let’s look at a very simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">FlightDictionary</span></strong><span class="koboSpan" id="kobo.936.1"> class that stores </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.938.1"> objects by their identifiers using a dictionary and incorporates some light </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">console logging:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.940.1">
public class FlightDictionary {
  private readonly Dictionary&lt;string, FlightInfo&gt; _items =
    new();
  public bool Contains(string identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(string id, FlightInfo item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public FlightInfo? </span><span class="koboSpan" id="kobo.940.2">GetItem(string id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return null;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.941.1">This class is the beginning of a new collection class, like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">Dictionary</span></strong><span class="koboSpan" id="kobo.943.1"> class provided by .NET. </span><span class="koboSpan" id="kobo.943.2">It allows external callers to add, retrieve, and check for </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.945.1"> by a </span><span class="No-Break"><span class="koboSpan" id="kobo.946.1">string identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.947.1">While this code is very simple and missing several features I’d expect from a real collection class, it should serve to illustrate the need for generics by asking the following question: What happens if </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.948.1">we like this class so much for </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">FlightInfo</span></strong><span class="koboSpan" id="kobo.950.1"> objects that we want to use something like it for </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">BoardingPass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.952.1"> objects?</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">Often, this would result in someone copying and pasting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">FlightDictionary</span></strong><span class="koboSpan" id="kobo.955.1"> class to create a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">BoardingPassDictionary</span></strong><span class="koboSpan" id="kobo.957.1">, as </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.959.1">
public class BoardingPassDictionary {
  private readonly Dictionary&lt;string, BoardingPass&gt; _items
    = new();
  public bool Contains(string identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(string id, BoardingPass item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public BoardingPass? </span><span class="koboSpan" id="kobo.959.2">GetItem(string id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return null;
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.960.1">The only difference between these two classes is the type of item </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">being stored.</span></span></p>
<p><span class="koboSpan" id="kobo.962.1">What generics let us do is declare a class that takes in parameters of the types it should use for </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">different operations.</span></span></p>
<p><span class="koboSpan" id="kobo.964.1">Now, let’s look at a more reusable version of this class that accepts generic type parameters for the type</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.965.1"> used as a key for each item, as well as the type used as </span><span class="No-Break"><span class="koboSpan" id="kobo.966.1">a value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.967.1">
public class LoggingDictionary</span><strong class="bold"><span class="koboSpan" id="kobo.968.1">&lt;TKey, TValue&gt;</span></strong><span class="koboSpan" id="kobo.969.1"> {
  private readonly Dictionary&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.970.1">TKey, TValue</span></strong><span class="koboSpan" id="kobo.971.1">&gt; _items
    = new();
  public bool Contains(</span><strong class="bold"><span class="koboSpan" id="kobo.972.1">TKey</span></strong><span class="koboSpan" id="kobo.973.1"> identifier)
    =&gt; _items.ContainsKey(identifier);
  public void AddItem(</span><strong class="bold"><span class="koboSpan" id="kobo.974.1">TKey</span></strong><span class="koboSpan" id="kobo.975.1"> id, </span><strong class="bold"><span class="koboSpan" id="kobo.976.1">TValue</span></strong><span class="koboSpan" id="kobo.977.1"> item) {
    Console.WriteLine($"Adding {id}");
    _items[id] = item;
  }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.978.1">TValue?</span></strong><span class="koboSpan" id="kobo.979.1"> GetItem(</span><strong class="bold"><span class="koboSpan" id="kobo.980.1">TKey</span></strong><span class="koboSpan" id="kobo.981.1"> id) {
    if (Contains(id)) {
      Console.WriteLine($"Found {id}");
      return _items[id];
    }
    Console.WriteLine($"Could not find {id}");
    return </span><strong class="bold"><span class="koboSpan" id="kobo.982.1">default(TValue);</span></strong><span class="koboSpan" id="kobo.983.1">
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.984.1">This implementation of the class depends on two generic type arguments: </span><strong class="source-inline"><span class="koboSpan" id="kobo.985.1">TKey</span></strong><span class="koboSpan" id="kobo.986.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">TValue</span></strong><span class="koboSpan" id="kobo.988.1">. </span><span class="koboSpan" id="kobo.988.2">These parameters can</span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.989.1"> be whatever names you want them to be, but the</span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.990.1"> convention is to use </span><strong class="bold"><span class="koboSpan" id="kobo.991.1">PascalCasing</span></strong><span class="koboSpan" id="kobo.992.1"> and start each type parameter with the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">letter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">T</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.995.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.996.1">With this class, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">LoggingDictionary</span></strong><span class="koboSpan" id="kobo.998.1"> can be created for any types you might want to support using the </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1000.1">
LoggingDictionary&lt;string, BoardingPass&gt; passDict = new();
LoggingDictionary&lt;string, FlightInfo&gt; flightDict = new();</span></pre>
<p><span class="koboSpan" id="kobo.1001.1">Generics are something that has been around since .NET Framework 2.0 but still offers value today in adding reusability </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">to classes.</span></span></p>
<p><span class="koboSpan" id="kobo.1003.1">Let’s close this chapter out with a brief look into a new C# 12 feature: </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1004.1">type aliases</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">.</span></span></p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1006.1">Introducing type aliases with the using directive</span></h2>
<p><span class="koboSpan" id="kobo.1007.1">Let’s say you’re</span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.1008.1"> developing a system and you need to work with a set of data</span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.1009.1"> types you’re not certain about and may need to change in the future. </span><span class="koboSpan" id="kobo.1009.2">Alternatively, you might have a routine need for some hideous-looking types, such as needing to deal with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">List&lt;string, Dictionary&lt;Passenger, List&lt;FlightInfo&gt;&gt;&gt; </span></strong><span class="koboSpan" id="kobo.1011.1">throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">a class.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">While one approach for the latter problem might be to introduce your class to hide away some of this complexity, a new option in C# 12 is to use </span><strong class="bold"><span class="koboSpan" id="kobo.1014.1">type aliases</span></strong><span class="koboSpan" id="kobo.1015.1"> via the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">using</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">Let’s look at simplifying some of the code in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">CloudySkiesFlightProvider.cs</span></strong><span class="koboSpan" id="kobo.1020.1"> to reduce the places where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">IEnumerable&lt;FlightInfo&gt;</span></strong><span class="koboSpan" id="kobo.1022.1"> appears. </span><span class="koboSpan" id="kobo.1022.2">We’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">GetFlightsByMiles</span></strong><span class="koboSpan" id="kobo.1024.1"> method as</span><a id="_idIndexMarker655"/> <span class="No-Break"><span class="koboSpan" id="kobo.1025.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.1027.1">IEnumerable&lt;FlightInfo&gt;</span></strong><span class="koboSpan" id="kobo.1028.1"> GetFlightsByMiles(
  int maxMiles, string apiKey) {
  RestRequest request =
    new($"/flights/uptodistance/{maxMiles}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  </span><strong class="bold"><span class="koboSpan" id="kobo.1029.1">IEnumerable&lt;FlightInfo&gt;?</span></strong><span class="koboSpan" id="kobo.1030.1"> response =
    _client.Get&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.1031.1">IEnumerable&lt;FlightInfo&gt;</span></strong><span class="koboSpan" id="kobo.1032.1">&gt;(request);
  return response ?? </span><span class="koboSpan" id="kobo.1032.2">Enumerable.Empty&lt;FlightInfo&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.1033.1">This code isn’t bad, but imagine that you felt very strongly that you didn’t like looking at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">IEnumerable&lt;FlightInfo&gt;</span></strong><span class="koboSpan" id="kobo.1035.1"> everywhere and you’d rather have a custom type defined </span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">for this.</span></span></p>
<p><span class="koboSpan" id="kobo.1037.1">Using C# 12, you could add the </span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.1038.1">following line to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">using</span></strong><span class="koboSpan" id="kobo.1040.1"> statements in </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1042.1">
using Flights = System.Collections.Generic.IEnumerable&lt;
Packt.CloudySkiesAir.Chapter10.FlightInfo&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.1043.1">With this one change, you can now change your method to use your new </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">type alias:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1045.1">
public </span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">Flights</span></strong><span class="koboSpan" id="kobo.1047.1"> GetFlightsByMiles(int maxMiles,
  string apiKey) {
  RestRequest request =
    new($"/flights/uptodistance/{maxMiles}");
  request.AddHeader("x-api-key", apiKey);
  LogApiCall(request.Resource);
  </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">Flights?</span></strong><span class="koboSpan" id="kobo.1049.1"> response = _client.Get&lt;</span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">Flights</span></strong><span class="koboSpan" id="kobo.1051.1">&gt;(request);
  return response ?? </span><span class="koboSpan" id="kobo.1051.2">Enumerable.Empty&lt;FlightInfo&gt;();
}</span></pre>
<p><span class="koboSpan" id="kobo.1052.1">This code doesn’t change that you’re dealing with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">IEnumerable&lt;FlightInfo&gt;</span></strong><span class="koboSpan" id="kobo.1054.1"> in this method, but it does reduce</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.1055.1"> the amount of code you have to type and simplifies the code </span><span class="No-Break"><span class="koboSpan" id="kobo.1056.1">for reading.</span></span></p>
<p><span class="koboSpan" id="kobo.1057.1">Additionally, if you ever </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.1058.1">wanted to change to a different type in these places, you now just need to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">using</span></strong><span class="koboSpan" id="kobo.1060.1"> statement to use a different </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">type instead.</span></span></p>
<p><span class="koboSpan" id="kobo.1062.1">I’m not sure if obscuring the underlying type offers more benefit than potential confusion, but I could see some places where it might be helpful, particularly in dealing with complex generic types or working with tuples (collections of </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">multiple values).</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">Time will tell on the effectiveness of type aliases and the best places to use them, but I’m glad we now have </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">the option.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1066.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1067.1">In this chapter, we looked at a variety of ways of ensuring your classes are safe and reusable through means such as argument validation, caller member information, nullability analysis, and using modern C# features such as record classes, primary constructors, pattern matching, and enhanced properties with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1068.1">required</span></strong><span class="koboSpan" id="kobo.1069.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1071.1"> keywords.</span></span></p>
<p><span class="koboSpan" id="kobo.1072.1">These language features help you detect issues earlier in development, work with objects more effectively, and write fewer lines of </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">code overall.</span></span></p>
<p><span class="koboSpan" id="kobo.1074.1">This concludes </span><em class="italic"><span class="koboSpan" id="kobo.1075.1">Part 2</span></em><span class="koboSpan" id="kobo.1076.1"> of this book. </span><span class="koboSpan" id="kobo.1076.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1077.1">Part 3</span></em><span class="koboSpan" id="kobo.1078.1">, we’ll look at how AI and code analysis tools can help you and your team sustainably build </span><span class="No-Break"><span class="koboSpan" id="kobo.1079.1">better software.</span></span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.1080.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1081.1">Answers the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1083.1">How can throwing exceptions be beneficial to </span><span class="No-Break"><span class="koboSpan" id="kobo.1084.1">your code?</span></span></li>
<li><span class="koboSpan" id="kobo.1085.1">What are the various ways you can declare a property </span><span class="No-Break"><span class="koboSpan" id="kobo.1086.1">in C#?</span></span></li>
<li><span class="koboSpan" id="kobo.1087.1">What are the various ways you can instantiate an object </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">in C#?</span></span></li>
<li><span class="koboSpan" id="kobo.1089.1">What are the differences between classes and </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">record classes?</span></span></li>
</ol>
<h1 id="_idParaDest-235"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.1091.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1092.1">You can find more information about features discussed in this chapter at </span><span class="No-Break"><span class="koboSpan" id="kobo.1093.1">these URLs:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1094.1">Guard Clauses </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1095.1">library</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">: </span></span><a href="https://github.com/ardalis/GuardClauses"><span class="No-Break"><span class="koboSpan" id="kobo.1097.1">https://github.com/ardalis/GuardClauses</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1098.1">Fluent Validation </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1099.1">library</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">: </span></span><a href="https://github.com/FluentValidation/FluentValidation"><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">https://github.com/FluentValidation/FluentValidation</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1102.1">Caller Member </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1103.1">Information</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information"><span class="No-Break"><span class="koboSpan" id="kobo.1105.1">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/caller-information</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1106.1">Primary constructors and using </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1107.1">aliases</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">: </span></span><a href="https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/"><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">https://devblogs.microsoft.com/dotnet/check-out-csharp-12-preview/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1110.1">Safer Nullability in Modern </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1111.1">C#</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">: </span></span><a href="https://newdevsguide.com/2023/02/25/csharp-nullability/"><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">https://newdevsguide.com/2023/02/25/csharp-nullability/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1114.1">Classes, structs, and records in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1115.1">C#</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">: </span></span><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/"><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1118.1">Choosing Between Exceptions or </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1119.1">Validation: </span></em></span><a href="https://ardalis.com/guard-clauses-and-exceptions-or-validation/"><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">https://ardalis.com/guard-clauses-and-exceptions-or-validation/</span></span></a></li>
</ul>
</div>


<div class="Content" id="_idContainer122">
<h1 id="_idParaDest-236" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.1.1">Part 3: Advanced Refactoring with AI and Code Analysis</span></h1>
<p><span class="koboSpan" id="kobo.2.1">The third part of this book focuses on advanced refactoring techniques using artificial intelligence and modern code analysis capabilities built into </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">Visual Studio.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This chapter introduces GitHub Copilot Chat as a way to refactor, generate, inspect, document, and </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">test code.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">We then extensively cover the code analysis capabilities of Visual Studio by introducing the code analysis tooling and rulesets as well as some third-party tools that can help catch additional issues. </span><span class="koboSpan" id="kobo.6.2">Finally, we explore how Visual Studio’s code analysis is based on Roslyn Analyzers by building and deploying our own Roslyn Analyzer as both a Visual Studio extension and as a </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">NuGet package.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This chapter will give you a deep understanding of code analysis issues as well as new productivity tools to help detect and resolve issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">their code.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">This part contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">following chapters:</span></span></p>
<ul>
<li><a href="B21324_11.xhtml#_idTextAnchor236"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 11</span></em></a><em class="italic"><span class="koboSpan" id="kobo.13.1">, AI-Assisted Refactoring with GitHub Copilot</span></em></li>
<li><a href="B21324_12.xhtml#_idTextAnchor259"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 12</span></em></a><em class="italic"><span class="koboSpan" id="kobo.15.1">, Code Analysis in Visual Studio</span></em></li>
<li><a href="B21324_13.xhtml#_idTextAnchor275"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 13</span></em></a><em class="italic"><span class="koboSpan" id="kobo.17.1">, Creating a Roslyn Analyzer</span></em></li>
<li><a href="B21324_14.xhtml#_idTextAnchor297"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 14</span></em></a><em class="italic"><span class="koboSpan" id="kobo.19.1">, Refactoring Code with Roslyn Analyzers</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer123">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer124">
</div>
</div>
</body></html>