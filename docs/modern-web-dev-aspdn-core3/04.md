# 四、控制器和动作

本章讨论 MVC 最重要的特性：逻辑存储在哪里。这是实现应用所做的事情的地方，也是业务逻辑的重要组成部分。

控制器和动作通过约定找到，并作为路由规则的结果调用，路由规则在前一章中介绍。但是事情会变得非常复杂，有很多方法可以让一个动作从请求中检索数据；它可以是异步的，也可以是同步的，并且可以返回许多不同类型的数据。可以缓存这些数据，以便在重复请求时基本上不会造成性能损失。

正如我们所知，HTTP 是无状态的，但这在我们感兴趣的现代应用中并不起作用，因此我们需要维护请求之间的状态。我们还希望根据发出请求的人的文化和语言返回数据、数字和文本。在本章中，我们将研究所有这些主题。

在本章中，我们将学习以下主题：

*   如何使用控制器
*   如何找到控制器
*   控制器的生命周期是什么？
*   什么是控制器动作？
*   如何进行错误处理
*   如何缓存响应
*   如何维护请求之间的状态
*   使用依赖注入
*   应用全球化和本地化

# 技术要求

为了实现本章中介绍的示例，您需要.NET Core 3 SDK 和文本编辑器。当然，VisualStudio2019（任何版本）满足所有要求，但您也可以使用 VisualStudio 代码。

源代码可在[从 GitHub 检索 https://github.com/PacktPublishing/Modern-Web-Development-with-ASP.NET-Core-3-Second-Edition](https://github.com/PacktPublishing/Modern-Web-Development-with-ASP.NET-Core-3-Second-Edition) [。](https://github.com/PacktPublishing/Modern-Web-Development-with-ASP.NET-Core-3-Second-Edition)

# 开始

我们将在实际代码所在的位置工作，在哪里完成工作，在哪里处理来自浏览器的请求。我们将讨论 MVC 控制器返回视图，还将讨论跨请求持久化数据、将依赖项注入控制器和操作以及如何向代码添加本地化支持。总而言之，这是一个非常重要的章节，所以我请你们全神贯注。

在本章中，我们将讨论 MVC 应用最重要的方面：

*   控制器
*   行动

我们将在接下来的章节中研究每一个问题。

# 使用控制器

在 MVC 中，控制器负责处理请求。它是业务逻辑所在的位置、检索数据的位置、验证请求参数的位置等等。在面向对象的语言中，例如那些支持.NET Framework 的语言，这是在类中实现的。请记住，MVC 模式提倡强烈的责任分离，这使得其所有组件都特别重要；即使考虑到这一事实，控制器实际上也是 ASP.NET Core 中唯一需要的部分，因为您可以在没有视图的情况下生活。试想一下不返回任何用户界面或模型的 web 服务。这是 ASP.NET Core 的一个非常重要的方面。

## 控制器基类

ASP.NET Core（与其前身一样）提供了一个名为`ControllerBase`的基类，您可以从中继承，尽管严格来说这不是必需的。我们将在本章后面更详细地讨论这一点。然而，继承`ControllerBase`有几个优点：

*   轻松访问模型验证

*   用于返回不同结果的助手方法（重定向、JSON、视图、文本等）

*   直接访问请求和响应基础结构对象，包括头、cookie 等

*   拦截/覆盖操作事件的能力

实际上，还有另一个类，`Controller`，它依次继承自`ControllerBase`，如果您想处理视图，您应该继承该类。如果您正在编写 web 服务（web API），则不需要使用视图。

VisualStudio 中的模板始终生成从`Controller`类继承的控制器，但如果愿意，可以将其更改为 POCO。除非您想更改约定，否则唯一真正的要求是为所有控制器添加`Controller`后缀。名称空间或物理位置不相关。例如，您可以在不同的文件夹或名称空间中创建控制器。

`ControllerBase`类使以下属性可用：

*   `ControllerContext`（`ControllerContext`）：当前控制器和请求的执行上下文，包括动作描述符（用于猜测应该调用哪个动作）和获取动作参数的值提供程序工厂；它是这个类的一个实例。
*   `HttpContext`（`HttpContext`）：HTTP 上下文，包括请求和响应对象，我们可以从中获取和设置所有的头、cookie、状态码、认证信息、证书等；还提供对依赖项注入（DI）框架、框架功能、会话状态（如果已启用）和底层连接属性的访问。
*   `MetadataProvider`（`IModelMetadataProvider`：用于提取类模型的元数据验证器、文本描述符和编辑信息。

*   `ModelBinderFactory`（`IModelBinderFactory`）：这是一个用于创建绑定器的对象，该绑定器反过来用于将提交的请求属性绑定到给定的类模型。
*   `ModelState`（`ModelStateDictionary`）：这是提交的模型值和验证结果。
*   `ObjectValidator`（`IObjectModelValidator`：用于验证提交模型的实例。
*   **`Request`****`HttpRequest`**：处理指向`HttpContext`内相同对象的方便指针。
*   **`Response`****`HttpResponse`**：处理指向`HttpContext`内相同对象的方便指针。
*   **`Url`**（`IUrlHelper`）：这是一个实例，使用方便的方法生成指向特定控制器动作的 URL 链接。
*   `User`（`ClaimsPrincipal`：该字段包含对当前 ASP.NET Core 用户的引用；根据实际使用的身份验证机制，它将持有不同的值和声明，即使它没有经过身份验证，也永远不会是`null`。

`Controller`类提供了前面所有的属性以及视图特定的属性：

*   `RouteData`（`RouteData`：包含 MVC 路由数据参数。
*   `ViewBag`（`dynamic`）：这是在视图中可用的数据的动态集合。
*   `ViewData`（`ViewDataDictionary`）：与`ViewBag`相同，但以键值字典的形式强类型输入。
*   `TempData`（`ITempDataDictionary`）：这是一个强类型字典，用于在下次提交表单之前维护数据。

It's safe and convenient to inherit from `Controller`, even if you do not use views; it won't cause any problems.

当然，控制器需要提供至少一个操作方法，用于执行操作并向调用者返回有意义的内容，可以是 HTML 视图、一些 JSON 内容，也可以只是 HTTP 状态代码。

您还可以重写许多虚拟方法，以便在调用某个操作方法之前、之后或代替该操作方法执行操作。这些在接口`IActionFilter`和`IAsyncActionFilter`中定义，由`Controller`实现：

*   `OnActionExecuted`在调用动作后被调用。
*   在调用操作之前同步调用`OnActionExecuting`。
*   在调用操作之前异步调用`OnActionExecutingAsync`。

这些接口是过滤器的基础，我们将在后面更详细地讨论。

I almost forgot: if a controller class has the `[NonController]` attribute applied to it, then it is not considered and cannot be used as a controller.

## POCO 控制器

在 ASP.NET Core 中，控制器不需要从任何基类继承或实现特定接口。正如我们前面提到的，根据惯例，他们只需要使用`Controller`后缀，并避免使用`[NonController]`属性。这种方法的问题是，您会丢失所有帮助器方法和上下文属性（`HttpContext`、`ControllerContext`、`ViewBag`和`Url`），但您可以将它们注入。让我们看看这是怎么回事。

If you add the `[Controller]` attribute to any POCO class, you can turn it into a controller, regardless of its name.

### 向 POCO 控制器添加上下文

例如，假设您有一个 POCO 控制器，`HomeController`。您没有各种与上下文和视图包相关的属性，但通过将两个属性应用于适当类型的属性，您可以让基础结构注入它们，如以下示例所示：

```cs
public class HomeController
{
    private readonly IUrlHelperFactory _url;

    public HomeController(IHttpContextAccessor ctx, IUrlHelperFactory url)
    {
        this.HttpContext = ctx.HttpContext;
        this._url = url;
    }

    [ControllerContext]
    public ControllerContext { get; set; }

    public HttpContext HttpContext { get; set; }

    [ActionContext]
    public ActionContext ActionContext { get; set; }

    [ViewDataDictionary]
    public ViewDataDictionary ViewBag { get; set; }

    public IUrlHelper Url { get; set; }

    public string Index()
    {
        this.Url = this.Url ?? this._url.GetUrlHelper(this.ActionContext);
        return "Hello, World!";
    }
}
```

在这里，您会注意到一些有趣的事情：

*   只需将`[ActionContext]`、`[ControllerContext]`和`[ViewDataDictionary]`属性添加到任何名称的属性，并分别添加`ActionContext`、`ControllerContext`和`ViewDataDictionary`类型，即可自动注入`ActionContext`、`ControllerContext`和`ViewBag`。
*   当 ASP.NET Core 基础设施实例化控制器时，依赖注入框架注入`IHttpContextAccessor`和`IUrlHelperFactory`对象。
*   `HttpContext`对象需要从传递的`IHttpContextAccessor`实例中获取。
*   为了构建一个`IUrlHelper`，`IUrlHelperFactory`需要一个`ActionContext`实例；因为我们在构造函数的时候没有它，所以我们需要在以后构建它，例如，在一个 action 方法中（在这个例子中，`Index`）。

然而，为了使这项工作正常进行，我们需要告诉 ASP.NET Core 注册`IHttpContextAccessor`和`IUrlHelperFactory`的默认实现。这通常在`Startup`类的`ConfigureServices`方法中完成：

```cs
services.AddScoped<IHttpContextAccessor, HttpContextAccessor>();
//or, since version 2.1:
services.AddHttpContextAccessor();
services.AddScoped<IUrlHelperFactory, UrlHelperFactory>();
```

这些属性的行为方式与继承自`ControllerBase`和`Controller`的非 POCO 属性完全相同。

### POCO 控制器中的拦截操作

如果需要，还可以实现一个过滤器接口，以便在调用操作之前或之后与请求进行交互，例如`IActionFilter`：

```cs
public class HomeController : IActionFilter
{
    public void OnActionExecuting(ActionExecutingContext context)
    {
        //before the action is called
    }

    public void OnActionExecuted(ActionExecutedContext context)
    {
        //after the action is called
    }
}
```

如果您希望有一个异步处理程序，请改为实现异步版本（`IAsyncXXXFilter`。我们将在[第 10 章](10.html)、*理解过滤器*中进一步讨论过滤器。

现在让我们看看框架是如何发现控制器的。

# 查找控制器

无论您选择 POCO 还是非 POCO 控制器，ASP.NET Core 都将应用相同的规则来发现控制器，如下所示：

*   他们需要有`Controller`后缀（严格来说，这是可以更改的，但我们现在就不做了）。
*   它们需要是可实例化的类（非抽象、非泛化和非静态）。
*   它们不能应用`[NonController]`属性。
*   如果它们是 POCO 并且没有`Controller`后缀，您可以用`[Controller]`属性装饰它们。

By convention, the files that contain the controller classes are stored in a folder called `Controllers`, and also in a `Controllers` namespace, but this is just ignored.

控制器类通过路由中的名称和控制器参数进行查找，并在为此目的注册的程序集中进行搜索。默认情况下，搜索中包括当前正在执行的程序集，但注册为*应用部件*的所有程序集也包括在内。将 MVC 功能添加到依赖项注入框架（`ConfigureServices`方法）时，可以注册其他应用部件，如下所示：

```cs
services.AddMvc()
    .AddApplicationPart(typeof(MyCustomComponent).GetTypeInfo().Assembly);
```

在这里，我们添加了对包含一个假设类`MyCustomComponent`的程序集的引用。完成此操作后，位于其中的所有控制器都可以使用。为了获得找到的控制器的完整列表，我们可以使用`ControllerFeature`并通过`ApplicationPartManager`填充它：

```cs
services.AddMvc()
    .AddApplicationPart(typeof(MyCustomComponent).GetTypeInfo().Assembly)
    .ConfigureApplicationPartManager(parts =>
    {
        var controllerFeature = new ControllerFeature();
        parts.PopulateFeature(controllerFeature);
        //controllerFeature.Controllers contains the list of discovered 
        //controllers' types
    });
```

控制器只在启动时被发现一次，这在性能方面是一件好事。

如果有两个控制器具有相同的名称，但位于不同的命名空间中，并且它们都公开了一个与当前请求匹配的操作方法，则 ASP.NET 将不知道选择哪个控制器，并将引发异常。如果发生这种情况，我们需要通过应用`[ControllerName]`属性为其中一个类指定一个新的控制器名称，如下代码所示：

```cs
namespace Controllers
{
    public class HomeController
    {
    }

    namespace Admin
    {
        [ControllerName("AdminHome")]
        public class HomeController
        {
        }
    }
}
```

我们还可以更改动作名称，稍后我们将看到。现在，让我们看看找到控制器类型后会发生什么。

# 控制器生命周期

找到控制器的类型后，ASP.NET Core 将启动一个进程对其进行实例化。程序如下：

1.  默认控制器工厂（`IControllerFactory`来自**依赖注入**（**DI**框架）并调用其`CreateController`方法。
2.  控制器工厂使用同样从 DI 获得的注册控制器激活器（`IControllerActivator`来获取控制器的实例（`IControllerActivator.Create`。
3.  使用 DI 的`IActionSelector`定位动作方法。
4.  如果控制器实现任何过滤器接口（`IActionFilter`、`IResourceFilter`等），或者如果该操作具有任何过滤器属性，则会对其和全局过滤器调用适当的方法。
5.  动作方法由`IActionInvokerProvider`中的`IActionInvoker`调用，也从 DI 中获取。

6.  对控制器、操作方法的过滤器属性和全局过滤器调用任何过滤器方法。
7.  控制器工厂释放控制器（`IControllerFactory.ReleaseController`。
8.  控制器激活器释放控制器（`IControllerActivator.Release`。
9.  如果控制器实现了`IDisposable`，则调用`Dispose`方法。

这些组件大部分可以通过内置的 DI 框架注册，例如，如果您想替换默认的`IControllerFactory`实现，那么您可以通过`ConfigureServices`方法进行注册：

```cs
services.AddSingleton<IControllerFactory, CustomControllerFactory>();
```

现在，假设您想编写一个操作选择器，将所有调用重定向到类的特定方法。您可以编写重定向操作选择器，如下所示：

```cs
public class RedirectActionSelector : IActionSelector
{
    public ActionDescriptor SelectBestCandidate(
        RouteContext context, 
        IReadOnlyList<ActionDescriptor> candidates)
    {
        var descriptor = new ControllerActionDescriptor();
        descriptor.ControllerName = typeof(MyController).Name;
        descriptor.MethodInfo = typeof(MyController).
        GetMethod("MyAction");
        descriptor.ActionName = descriptor.MethodInfo.Name;
        return descriptor;
    }

    public IReadOnlyList<ActionDescriptor> SelectCandidates(
    RouteContext context)
    {
        return new List<ActionDescriptor>();
    }
}
```

这将把任何请求重定向到`MyController`类的`MyAction`方法。嘿，只是为了好玩，记得吗？

现在让我们来看看行动。

# 行动

动作方法是所有动作发生的地方（双关语）。它是处理您的请求的代码的入口点。从`IActionInvoker`实现调用找到的动作方法；它必须是控制器类的**物理**非通用公共实例方法。动作选择机制相当复杂，依赖于路由**动作**参数。

动作方法的名称应该与此参数相同，但这并不意味着它是物理方法名称；您还可以应用`[ActionName]`属性将其设置为不同的值，如果我们有重载方法，这一点特别有用：

```cs
[ActionName("BinaryOperation")]
public IActionResult Operation(int a, int b) { ... }

[ActionName("UnaryOperation")]
public IActionResult Operation(int a) { ... }
```

在以下部分中，我们将了解操作如何工作以及它们在控制器上下文中如何工作。

## 寻找行动

在发现一组用于处理请求的候选控制器后，ASP.NET Core 将检查它们是否提供与当前路由匹配的方法（请参见[第 3 章](03.html)、*路由*：

*   它必须是公共的、非静态的和非通用的。
*   其名称必须与路由的操作相匹配（物理名称可能不同，只要它具有`[ActionName]`属性）。
*   其参数必须与路由中指定的非可选参数（未标记为可选且无默认值的参数）匹配；如果路由指定了`id`值，则必须有`id`参数和类型，如果`id`有`int`的路由约束，如`{id:int}`中所述，则必须是`int`类型。
*   动作方法可以有`IFormCollection`、`IFormFile`或`IFormFileCollection`类型的参数，因为这些参数总是可以接受的。
*   它不能应用`[NonAction]`属性。

获取适用操作的实际规则如下所示：

*   如果 URL 中提供了操作名称，则暂时使用该名称。
*   如果在基于 fluent 配置或属性的路由中指定了默认操作，则暂时使用该操作。

当我的意思是暂时的，我的意思是说可能有约束属性（一分钟后会有更多关于这方面的内容）或需要检查的强制属性。例如，如果一个操作方法需要一个强制参数，并且在请求或任何源中都找不到它，那么该操作就不能用于服务当前请求。

## 同步和异步操作

动作方法可以是同步的，也可以是异步的。对于异步版本，其原型应如下所示：

```cs
public async Task<IActionResult> Index() { ... }
```

当然，您可以添加任意数量的参数，就像使用同步操作方法一样。然而，这里的关键是将方法标记为`async`并返回`Task<IActionResult>`，而不仅仅是`IActionResult`（或其他继承类型）。

为什么要使用异步操作？你需要了解以下事实：

*   Web 服务器有许多线程用于处理传入的请求。
*   当一个请求被接受时，其中一个线程在等待处理时被阻塞。
*   如果请求花费的时间太长，则此线程无法响应其他请求。

输入异步操作。对于异步操作，只要线程接受传入请求，它就会立即将其传递给后台线程，由后台线程处理，释放主线程。这非常方便，因为它可以接受其他请求。这与性能无关，而是与可伸缩性有关；使用异步操作允许应用始终响应，即使它仍在后台处理请求。

## 获取上下文

我们已经了解了如何在 POCO 和基于控制器的控制器中访问上下文。根据上下文，我们将讨论与行动方法有关的三件事：

*   HTTP 上下文，由`HttpContext`类表示，从中可以访问当前用户、低级请求和响应属性，如 cookie、标头等。
*   控制器上下文，`ControllerContext`的一个实例，允许您访问当前模型状态、路由数据、操作描述符等。
*   `ActionContext`类型的动作上下文，它提供的信息与您从`ControllerContext`获得的信息几乎相同，但在不同的地方使用；因此，如果将来只在一个功能上添加一个新功能，它将不会显示在另一个功能上。

访问上下文非常重要，因为您可能需要根据从上下文中获得的信息做出决策，或者直接设置响应头或 cookie。您可以看到 ASP.NET Core 已经删除了自 ASP.NET 开始以来一直存在的`HttpContext.Current`属性，因此您无法立即访问它；但是，您可以从`ControllerContext`或`ActionContext`中获取它，或者通过让构造函数获取`IHttpContextAccessor`的实例，将它注入到依赖项注入构建组件中。

## 动作约束

在应用于 action 方法的属性中实现以下属性和接口时，可能会阻止调用它：

*   `[NonAction]`：从未调用该操作。
*   `[Consumes]`：如果有许多候选方法，例如，在方法重载的情况下，则使用此属性检查是否有任何方法接受当前请求的内容类型。
*   `[RequireHttps]`：如果存在，则仅当请求协议为 HTTPS 时才会调用 action 方法。
*   `IActionConstraint`：如果应用于动作方法的属性实现了该接口，则调用其`Accept`方法，查看是否应该调用该动作。

*   `IActionHttpMethodProvider`：由`[AcceptVerbs]`、`[HttpGet]`、`[HttpPost]`等 HTTP 方法选择器属性实现；如果存在，则仅当当前请求的 HTTP 谓词与`HttpMethods`属性返回的值之一匹配时，才会调用 action 方法。
*   `IAuthorizeData`：将检查实现此接口的任何属性，其中最臭名昭著的是`[Authorize]`，以查看分配给**`HttpContext's User`**属性的`ClaimsPrincipal`当前标识是否具有正确的策略和角色。
*   `Filters`：如果将筛选器属性（例如`IActionFilter`）应用于操作，或者如果调用了`IAuthorizationFilter`（例如）并可能引发异常或返回`IActionResult`，从而阻止调用操作（`NotFoundObjectResult`、`UnauthorizedResult`等）。

`IActionConstraint`的此实现将应用自定义逻辑来决定是否可以在其`Accept`方法中调用某个方法：

```cs
public class CustomAuthorizationAttribute: Attribute, IActionConstraint
{
    public int Order { get; } = int.MaxValue;

    public bool Accept(ActionConstraintContext context)
    {
        return 
         context.CurrentCandidate.Action.DisplayName
         .Contains("Authorized");
    }
}
```

`context`参数授予对路由上下文的访问权，并从路由上下文访问 HTTP 上下文和当前候选方法。这些应该足以做出决定。

应用约束的顺序可能是相关的，因为`IActionConstraint`接口的`Order`属性在属性中使用时，将决定应用于同一方法的所有属性的相对执行顺序。

## 动作参数

动作方法可以获取参数。例如，这些参数可以是提交的表单值或查询字符串参数。基本上有三种方法可以获得所有提交的值：

*   `IFormCollection`、`IFormFile`和`IFormFileCollection`：这些类型中的任何一个参数都将包含 HTML 表单提交的值列表；它们不会用于`GET`请求，因为无法使用`GET`上传文件。
*   `HttpContext`：直接访问上下文并从`Request.Form`或`Request.QueryString`集合中检索值。
*   添加与我们希望单独访问的请求中的值匹配的命名参数。

后者可以是基本类型，如`string`、`int`等，也可以是复杂类型。其值的注入方式是可配置的，并且基于提供者模型。`IValueProviderFactory`和`IValueProvider`用于获取这些属性的值。ASP.NET Core 为开发人员提供了通过`AddMvc`方法检查价值提供者工厂集合的机会：

```cs
services.AddMvc(options =>
{
    options.ValueProviderFactories.Add(new CustomValueProviderFactory());
});
```

开箱即用，以下价值提供者工厂可用，并按以下顺序注册：

*   `FormValueProviderFactory`：从提交的表单中注入值，例如`<input type="text" name="myParam"/>`。
*   `RouteValueProviderFactory`：路线参数，例如`[controller]/[action]/{id?}`。
*   `QueryStringValueProviderFactory`：查询字符串值，例如`?id=100`。
*   `JQueryFormValueProviderFactory`：jQuery 表单值。

但是，顺序很重要，因为它决定了将值提供程序添加到 ASP.NET Core 用于实际获取值的集合中的顺序。每个值提供程序工厂将调用其`CreateValueProviderAsync`方法，并且通常会填充一个值提供程序集合（例如，`QueryStringValueProviderFactory`将添加一个`QueryStringValueProvider`实例，等等）。

这意味着，例如，如果您提交了一个名为`myField`的表单值，并通过查询字符串传递`myField`的另一个值，那么将使用第一个值；但是，可以同时使用多个提供程序，例如，如果您的路由需要一个`id`参数，但也可以接受查询字符串参数：

```cs
[Route("[controller]/[action]/{id}?{*querystring}")]
public IActionResult ProcessOrder(int id, bool processed) { ... }
```

这将愉快地访问一个请求`/Home/Process/120?processed=true`，其中`id`来自路由，并由查询字符串提供程序处理。

某些发送值的方法允许它们是可选的，例如路由参数。在这种情况下，您需要确保 action 方法中的参数也允许以下操作：

*   引用类型，包括可以有`null`值的引用类型
*   值类型，应具有默认值，如`int a = 0`

例如，如果希望将路由中的值注入到操作方法参数中，如果该值是必需的，则可以这样做：

```cs
[Route("[controller]/[action]/{id}")]
public IActionResult Process(int id) { ... }
```

如果是可选的，您可以这样做：

```cs
[Route("[controller]/[action]/{id?}")]
public IActionResult Process(int? id = null) { ... }
```

值提供程序更有趣，因为它们实际返回操作方法参数的值。他们试图从名称中找到一个值，即 action 方法参数名称。ASP.NET 将迭代提供的值提供者列表，对每个参数调用其`ContainsPrefix`方法，如果结果为`true`，则调用`GetValue`方法。

即使提供的值提供程序很方便，您也可能希望从其他来源获取值。例如，我可以想到以下几点：

*   曲奇饼
*   标题
*   会话值

假设您希望将 cookie 值自动注入到操作方法的参数中。为此，您可以编写一个`CookieValueProviderFactory`，它很可能如下所示：

```cs
public class CookieValueProviderFactory : IValueProviderFactory
{
    public Task CreateValueProviderAsync(
     ValueProviderFactoryContext context)
    {
        context.ValueProviders.Add(new 
         CookieValueProvider(context.ActionContext));
        return Task.CompletedTask;
    }
}
```

然后你可以写一个`CookieValueProvider`来配合它：

```cs
public class CookieValueProvider : IValueProvider
{
    private readonly ActionContext _actionContext;

    public CookieValueProvider(ActionContext actionContext)
    {
        this._actionContext = actionContext;
    }

    public bool ContainsPrefix(string prefix)
    {
        return this._actionContext.HttpContext.Request.Cookies
        .ContainsKey(prefix);
    }

    public ValueProviderResult GetValue(string key)
    {
        return new ValueProviderResult(this._actionContext.HttpContext
        .Request.Cookies[key]);
    }
}
```

之后，您将在`MvcOptions`的`ValueProviders`集合中的`AddMvc`方法中注册：

```cs
services.AddMvc(options =>
{
    options.ValueProviderFactories.Add(new CookieValueProviderFactory());
}):
```

现在，您可以将 cookie 值透明地注入到您的操作中，而无需任何额外的工作。

Don't forget that, because of C# limitations, you cannot have variables or parameters that contain `-` or other special characters, so you cannot inject values for parameters that have these in their names out of the box. In this cookie example, you won't be able to have a parameter for a cookie with a name like `AUTH-COOKIE`.

但是，在相同的操作方法中，可以使用来自不同来源的参数，如下所示：

```cs
[HttpGet("{id}")]
public IActionResult Process(string id, Model model) { ... }
```

但是，如果目标操作方法参数不是字符串类型怎么办？答案在于**模型绑定**。

## 模型绑定

模型绑定是 ASP.NET Core 将部分请求（包括路由值、查询字符串、提交的表单等）转换为强类型参数的过程。与 ASP.NET Core 的大多数 API 一样，这是一种可扩展的机制。不要与模型值提供者混淆；模型绑定器的责任不是提供值，而仅仅是使它们适合我们告诉它们的任何类！

开箱即用，ASP.NET 可以转换为以下内容：

*   `IFormCollection`、`IFormFile`和`IFormFileCollection`参数
*   基元/基类型（处理字符串之间的转换）
*   枚举
*   POCO 类
*   辞典
*   收藏
*   取消令牌（稍后将对此进行详细介绍）

模型绑定器提供程序在`MvcOptions`类中配置，通常可通过`AddMvc`调用访问：

```cs
services.AddMvc(options =>
{
    options.ModelBinderProviders.Add(new CustomModelBinderProvider());
});
```

应该已经支持您感兴趣的大多数场景。您还可以指定从中获取参数的源。那么，让我们看看如何使用这种能力。

### 身体

如果您正在使用 HTTP 谓词调用一个操作，该谓词允许您传递有效负载（`POST`、`PUT`和`PATCH`），您可以通过应用`[FromBody]`属性请求您的参数从该有效负载接收一个值：

```cs
[HttpPost]
public IActionResult Submit([FromBody] string payload) { ... }
```

除了使用字符串值外，您还可以提供自己的 POCO 类，如果配置的输入格式化程序之一支持该格式，则将从有效负载填充该类（稍后将对此进行详细介绍）。

### 类型

另一个选项是在提交的表单中使用来自特定命名字段的参数，为此，我们使用`[FromForm]`属性：

```cs
[HttpPost]
public IActionResult Submit([FromForm] string email) { ... }
```

有一个`Name`属性，如果提供该属性，将从指定的命名表单字段（例如，`[FromForm(Name = "UserEmail")]`）获取值。

### 标题

标头也是检索值的一个很好的候选者，因此，`[FromHeader]`属性：

```cs
public IActionResult Get([FromHeader] string accept) { ... }
```

`[FromHeader]`属性允许我们指定实际的头名称（例如，`[FromHeader(Name = "Content-Type")]`），如果没有指定，它将查找应用它的参数的名称。

默认情况下，它只能绑定到字符串或字符串集合，但您可以强制它接受其他目标类型（前提是输入对该类型有效）。配置 MVC 时只需将`AllowBindingHeaderValuesToNonStringModelTypes`属性设置为`true`：

```cs
services.AddMvc(options =>
{
    options.AllowBindingHeaderValuesToNonStringModelTypes = true;
});
```

### 查询字符串

我们还可以使用`[FromQuery]`属性通过查询字符串检索值：

```cs
public IActionResult Get([FromQuery] string id) { ... }
```

您还可以使用`Name`属性`[FromQuery(Name = "Id")]`指定查询字符串参数名称。请注意，按照惯例，如果不指定此属性，仍然可以从查询字符串传递值，这些值将传递给操作方法参数。

### 路线

路线参数也可以是数据源输入`[FromRoute]`：

```cs
[HttpGet("{id}")]
public IActionResult Get([FromRoute] string id) { ... }
```

与大多数其他绑定属性类似，您可以指定一个名称来指示值应该来自的路由参数（例如，`[FromRoute(Name = "Id")]`。

### 依赖注入

您还可以使用依赖项注入，例如（`[FromServices]`：

```cs
public IActionResult Get([FromServices] IHttpContextAccessor accessor) { ... }
```

当然，您注入的服务需要提前在 DI 框架中注册。

### 定制活页夹

也可以指定您自己的活页夹。为此，您可以使用`[ModelBinder]`属性，该属性将可选`Type`作为其参数。有趣的是，它可以用于不同的场景，例如：

*   如果将其应用于控制器类上的属性或字段，则它将绑定到来自任何受支持的值提供程序（查询字符串、路由、表单等）的请求参数：

```cs
[ModelBinder]
public string Id { get; set; }
```

*   如果您传递了实现`IModelBinder`的类的类型，那么您可以将该类用于实际的绑定过程，但仅用于应用该类的参数、属性或字段：

```cs
public IActionResult Process([ModelBinder(typeof(CustomModelBinder))] Model model) { ... }
```

进行 HTML 格式设置的简单模型活页夹可以编写如下：

```cs
public class HtmlEncodeModelBinder : IModelBinder
{
    private readonly IModelBinder _fallbackBinder;

    public HtmlEncodeModelBinder(IModelBinder fallbackBinder)
    {
        if (fallbackBinder == null)
            throw new ArgumentNullException(nameof(fallbackBinder));

        _fallbackBinder = fallbackBinder;
    }

    public Task BindModelAsync(ModelBindingContext bindingContext)
    {
        if (bindingContext == null)
            throw new ArgumentNullException(nameof(bindingContext));

        var valueProviderResult = bindingContext.ValueProvider.
        GetValue(bindingContext.ModelName);

        if (valueProviderResult == ValueProviderResult.None)
        {
            return _fallbackBinder.BindModelAsync(bindingContext);
        }

        var valueAsString = valueProviderResult.FirstValue;

        if (string.IsNullOrEmpty(valueAsString))
        {
            return _fallbackBinder.BindModelAsync(bindingContext);
        }

        var result = HtmlEncoder.Default.Encode(valueAsString);

        bindingContext.Result = ModelBindingResult.Success(result);

        return Task.CompletedTask;
    }
}
```

The code for this was written by Steve Gordon and is available at [https://www.stevejgordon.co.uk/html-encode-string-aspnet-core-model-binding](https://www.stevejgordon.co.uk/html-encode-string-aspnet-core-model-binding).

代码做的不多：它在构造函数中使用一个回退绑定器，如果没有要绑定的值，或者该值是`null`或空字符串，则使用它；否则，它将对其进行 HTML 编码。

还可以将模型绑定提供程序添加到全局列表中。将拾取处理目标类型的第一个。模型绑定提供程序的接口由`IModelBinderProvider`（谁知道？）定义，它只指定一个方法`GetBinder`。如果返回非 null，则将使用活页夹。

让我们来看一个模型绑定器提供程序，它将此模型绑定器应用于具有自定义属性的字符串参数：

```cs
public class HtmlEncodeAttribute : Attribute { }

public class HtmlEncodeModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        if (context == null) throw new 
         ArgumentNullException(nameof(context));

        if ((context.Metadata.ModelType == typeof(string)) &&
            (context.Metadata.ModelType.GetTypeInfo().
             IsDefined(typeof(HtmlEncodeAttribute))))
        {
            return new HtmlEncodeModelBinder(new SimpleTypeModelBinder(
             context.Metadata.ModelType));
        }

        return null;
    }
}
```

之后，我们在`AddMvc`中将其注册到`ValueProviderFactories`集合中；迭代此集合，直到从`GetBinder`返回正确的模型绑定器，在这种情况下，它的使用方式如下：

```cs
services.AddMvc(options =>
{
    options.ValueProviderFactories.Add(new 
     HtmlEncodeModelBinderProvider());
});
```

我们创建了一个简单的标记属性`HtmlEncodeAttribute`（以及一个模型绑定器提供程序），用于检查目标模型是否为字符串类型，并将`[HtmlEncode]`属性应用于该模型。如果是，则应用`HtmlEncodeModelBinder`。就这么简单：

```cs
public IActionResult Process([HtmlEncode] string html) { ... }
```

在本章后面讨论 HTML 表单时，我们将重新讨论模型绑定。

### 属性绑定

控制器中使用`[BindProperty]`属性修饰的任何属性也会从请求数据绑定。您也可以应用相同的绑定源属性（`[FromQuery]`、`[FromBody]`等等），但要在`GET`请求中填充它们，您需要明确地告诉框架这样做：

```cs
[BindProperty(SupportsGet = true)]
public string Id { get; set; }
```

您还可以将其应用于控制器级属性验证属性（例如，`[Required]`、`[MaxLength]`等），它们将用于验证每个属性的值。`[BindRequired]`也有效，这意味着如果未提供属性值，则会导致错误。

### 输入格式化程序

当您通过应用`[FromBody]`属性从有效负载绑定 POCO 类时，ASP.NET Core 将尝试将有效负载中的 POCO 类型反序列化为字符串。为此，它使用了一个**输入格式化程序**。与**输出格式化程序**类似，它们用于在 JSON 或 XML 等常用格式之间进行转换。对 JSON 的支持是现成的，但是您需要显式地添加对 XML 的支持。您可以通过包含 NuGet 包`Microsoft.AspNetCore.Mvc.Formatters.Xml`并显式添加对管道的支持来实现这一点：

```cs
services
    .AddMvc()
    .AddXmlSerializerFormatters();
```

如果您感到好奇，那么这将向`MvcOptions``InputFormatters`集合添加一个`XmlSerializerInputFormatter`实例。列表将被迭代，直到一个格式化程序能够处理数据。包括的格式化程序如下所示：

*   `JsonInputFormatter`，可从任何 JSON 内容导入（`application/json`）
*   `JsonPatchInputFormatter`，可从 JSON 补丁内容（`application/json-patch+json`导入）

### 显式绑定

您还可以通过应用属性来微调模型类的哪些部分被绑定，以及如何绑定。例如，如果您想从绑定中排除属性，可以应用`[BindNever]`属性：

```cs
public class Model
{
    [BindNever]
    public int Id { get; set; }
}
```

或者，如果要显式定义应该绑定哪些属性，可以将`[Bind]`应用于`Model`类：

```cs
[Bind("Name, Email")]
public class Model
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
```

如果将值传递给`Prefix`属性，则可以指示 ASP.NET Core 从具有该前缀的属性检索要绑定的值。例如，如果有多个具有相同名称的表单值（例如，`option`），则可以将它们全部绑定到一个集合：

```cs
[Bind(Prefix = "Option")]
public string[] Option { get; set; }
```

通常，如果源媒体中未提供属性值，例如`POST`有效负载或查询字符串，则属性不会获得值。但是，您可以强制执行此操作，如下所示：

```cs
[BindRequired]
public string Email { get; set; }
```

如果不传递`Email`参数，则`ModelState.IsValid`将为`false`，并抛出异常。

您还可以在类级别指定默认绑定行为，然后使用`[BindingBehavior]`逐个属性重写它：

```cs
[BindingBehavior(BindingBehavior.Required)]
public class Model
{
    [BindNever]
    public int Id { get; set; }
    public string Name { get; set; }
    public string Email { get; set; }
}
```

因此，我们有三种情况：

*   如果请求中存在值，则将其绑定到模型（`[Bind]`。
*   忽略模型中传递的任何值（`[BindNever]`。
*   要求在请求中传递值（`[BindRequired]`。

我们还应该提到，这些属性可以应用于动作方法参数，如下所示：

```cs
public IActionResult Process(string id, [BindRequired] int state) { ... }
```

### 取消请求

有时，客户端会取消请求，例如当有人关闭浏览器、导航到另一个页面或刷新页面时。问题是，您不知道它发生了，并且您继续执行您的操作方法，而不知道答案将被丢弃。为了在这些场景中提供帮助，ASP.NET Core 允许您添加一个`CancelationToken`类型的参数。这是允许取消.NET 和.NET Core 中异步任务的标准方法。其工作原理如下：

```cs
public async Task<IActionResult> Index(CancelationToken cancel) { ... }
```

如果 ASP.NET Core 主机（Kestrel、WebListener）出于任何原因检测到客户端已断开连接，则会触发取消令牌（其`IsCancelationRequested`设置为`true`，与`HttpContext.RequestAborted`相同）。一个好处是，您可以将此`CancelationToken`实例传递给您可能正在使用的任何异步方法（例如，`HttpClient.SendAsync()`、`DbSet<T>.ToListAsync()`等），它们也将随客户端请求一起取消！

## 模型验证

一旦正确构建了模型（传递给 action 方法的参数）并设置了其属性值，就可以对其进行验证。验证本身是可配置的。

从所有值提供程序获得的所有值都可以在`ControllerBase`类中定义的`ModelState`属性中使用。对于任何给定类型，`IsValid`属性将说明 ASP.NET 是否根据其配置的验证器认为模型有效。

默认情况下，注册的实现依赖于注册的模型元数据和模型验证器提供程序，其中包括`DataAnnotationsModelValidatorProvider`。这将针对`System.ComponentModel.DataAnnotations`API 执行验证，即从`ValidationAttribute`（`RequiredAttribute`、`RegularExpressionAttribute`、`MaxLengthAttribute`等）派生的所有类，以及`IValidatableObject`实现。这是.NET 中事实上的*验证标准，能够处理大多数情况。*

填充模型时，它也会自动验证，但您也可以通过在操作中调用`TryValidateModel`方法明确请求模型验证，例如，如果您更改了其中的任何内容：

```cs
public IActionResult Process(Model model)
{
    if (this.TryValidateModel(model))
    {
        return this.Ok();
    }
    else
    {
        return this.Error();
    }
}
```

自 ASP.NET Core 2.1 以来，您可以将验证属性应用于动作参数本身，并且也可以对它们进行验证：

```cs
public IActionResult Process([Required, EmailAddress] string email) { ... }
```

如前所述，`ModelState`将根据验证结果设置`IsValid`属性，但我们也可以强制重新验证。如果要检查特定属性，可以使用`TryValidateModel`的重载，该重载包含一个额外的字符串参数：

```cs
if (this.TryValidateModel(model, "Email")) { ... }
```

在幕后，所有注册的验证器都被调用，该方法将返回一个带有所有验证结果的布尔标志。

我们将在下一章中重新讨论模型验证。现在，让我们看看如何插入自定义模型验证器。我们在`ConfigureServices`中使用`AddMvc`方法进行此操作：

```cs
services.AddMvc(options =>
{
    options.ModelValidatorProviders.Add(new 
     CustomModelValidatorProvider());
});
```

`CustomModelValidatorProvider`如下所示：

```cs
public class CustomModelValidatorProvider : IModelValidatorProvider
{
    public void CreateValidators(ModelValidatorProviderContext context)
    {
        context.Results.Add(new ValidatorItem { Validator =
         new CustomModelValidator() });
    }
}
```

主要逻辑简单地放在`CustomModelValidator`中：

```cs
public class CustomObjectModelValidator : IModelValidator
{
    public IEnumerable<ModelValidationResult> 
     Validate(ModelValidationContext context)
    {
        if (context.Model is ICustomValidatable)
        {
            //supply custom validation logic here and return a collection 
            //of ModelValidationResult
        }

        return Enumerable.Empty<ModelValidationResult>();
    }
}
```

亲爱的读者，`ICustomValidatable`接口（和实现）留给您作为练习。希望这不会太难理解。

此`ICustomValidatable`实现应查看其类的状态，并针对发现的任何问题返回一个或多个`ModelValidationResults`。

由于 ASP.NET Core 2.1，`[ApiController]`属性为控制器（通常为 API 控制器）添加了一个约定，该约定在调用动作方法时自动触发模型验证。您可以使用它，但它所做的是返回一个 400 HTTP 状态码（[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400) ）和 JSON 格式的验证错误说明，这可能不是处理视图时需要的。您可以出于同样的目的使用动作过滤器；让我们看一个例子：

```cs
[Serializable]
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, 
    AllowMultiple = false, 
    Inherited = true)]
public sealed class ValidateModelStateAttribute : ActionFilterAttribute
{
    public ValidateModelStateAttribute(string redirectUrl)
    {
        this.RedirectUrl = redirectUrl;
    }

    public ValidateModelStateAttribute(
        string actionName,
        string controllerName = null, 
        object routeValues = null)
    {
        this.ControllerName = controllerName;
        this.ActionName = actionName;
        this.RouteValues = routeValues;
    }

    public string RedirectUrl { get; }
    public string ActionName { get; }
    public string ControllerName { get; }
    public object RouteValues { get; }

    public override Task OnResultExecutionAsync(ResultExecutingContext  
     context, ResultExecutionDelegate next)
    {
        if (!context.ModelState.IsValid)
        {
            if (!string.IsNullOrWhiteSpace(this.RedirectUrl))
            {
                context.Result = new RedirectResult(this.RedirectUrl);
            }
            else if (!string.IsNullOrWhiteSpace(this.ActionName))
            {
                context.Result = new RedirectToActionResult

                (this.ActionName, this.ControllerName, 
                    this.RouteValues);
            }
            else
            {
                context.Result = new BadRequestObjectResult
                 (context.ModelState);
            }
        }

        return base.OnResultExecutionAsync(context, next);
    }
}
```

这是一个操作筛选器，也是一个属性，这意味着它可以全局注册：

```cs
services.AddMvc(options =>
{
    options.AllowValidatingTopLevelNodes = true;
    options.Filters.Add(new ValidateModelStateAttribute("/Home/Error"));
});
```

也可以通过将属性添加到控制器类或操作方法来注册它。此类提供两个控制器：

*   一个用于将重定向指定为完整 URL
*   另一个用于使用控制器名称、操作方法以及可能的路由参数

它继承自`ActionFilterAttribute`，后者依次实现`IActionFilter`和`IAsyncActionFilter`。在这里，我们对异步版本感兴趣——这是一个好的实践，意味着我们重写了`OnResultExecutionAsync`。在将控件传递给 action 方法之前调用此方法，这里我们检查模型是否有效。如果不是，则根据类的实例化方式将其重定向到正确的位置。

顺便说一下，只有当`AllowValidatingTopLevelNodes`属性设置为`true`时，控制器属性才会被验证，如本例所示；否则，将忽略任何错误。

## 行动结果

操作处理请求，通常向调用客户端返回内容或 HTTP 状态代码。在 ASP.NET Core 中，广义而言，有两种可能的返回类型：

*   `IActionResult`的一个实现
*   任何.NETPOCO 类

`IActionResult`的实现包装了实际响应，加上内容类型头和 HTTP 状态码，通常很有用。此接口仅定义一个方法`ExecuteResultAsync`，该方法采用一个`ActionContext`类型的参数，该参数封装了描述当前请求的所有属性：

*   `ActionDescriptor`：描述要调用的动作方法
*   `HttpContext`：描述请求上下文
*   `ModelState`：描述提交的模型属性及其验证状态
*   `RouteData`：描述路由参数

所以您可以看到，`IActionResult`实际上是命令设计模式（[的一个实现 https://sourcemaking.com/design_patterns/command](https://sourcemaking.com/design_patterns/command) ）在实际执行的意义上，它不仅仅存储数据。返回字符串和 HTTP 状态代码`200`的`IActionResult`的一个非常简单的实现可能如下所示：

```cs
public class HelloWorldResult : IActionResult
{
    public async Task ExecuteResultAsync(ActionContext actionContext)
    {
        actionContext.HttpContext.Response.StatusCode = StatusCodes
         .Status200OK;
        await actionContext.HttpContext.Response.WriteAsync("Hello, 
         World!");
    }
}
```

正如我们将很快看到的，`IActionResult`现在是描述 HTML 结果以及 API 样式结果的接口。`ControllerBase`和`Controller`类为返回`IActionResult`实现提供了以下方便的方法：

*   `BadRequest`（`BadRequestResult`、HTTP 代码`400`：请求无效。
*   `Challenge`（`ChallengeResult`、HTTP 代码`401`：身份验证的挑战。
*   `Content`（`ContentResult`、HTTP 代码`200`：任何内容。
*   `Created`（`CreatedResult`、HTTP 代码`201`：表示已创建资源的结果。
*   `CreatedAtAction`（`CreatedAtActionResult`、HTTP 代码`201`：表示某个操作创建了资源的结果。
*   `CreatedAtRoute`（`CreatedAtRouteResult`、HTTP 代码`201`：表示在命名路由中创建了资源的结果。
*   `File`（**`VirtualFileResult`**、**`FileStreamResult`**、**`FileContentResult`**、HTTP 码`200`）。
*   `Forbid`（`ForbidResult`、HTTP 代码`403`。
*   `LocalRedirect`（`LocalRedirectResult`、HTTP 代码`302`：重定向到本地资源。
*   `LocalRedirectPermanent`（`LocalRedirectResult`、HTTP 代码`301`：对本地资源的永久重定向。
*   `NoContent`（`NoContentResult`、HTTP 代码`204`：无需部署内容。
*   `NotFound`（`NotFoundObjectResult`、HTTP 代码`404`：未找到资源。
*   `Ok`（`OkResult`、HTTP 代码`200`：可以。

*   无方法（`PartialViewResult`，HTTP 代码`200`：不支持请求的 HTTP 方法。
*   `PhysicalFile`（`PhysicalFileResult`、HTTP 代码`200`：物理文件的内容。
*   `Redirect`（`RedirectResult`、HTTP 代码`302`：重定向到绝对 URL。
*   `RedirectPermanent`（`RedirectResult`、HTTP 代码`301`：永久重定向到绝对 URL。
*   `RedirectToAction`（`RedirectToActionResult`、HTTP 代码`302`：重定向到本地控制器的动作。
*   `RedirectToActionPermanent`（`RedirectToActionResult`、HTTP 代码`301`：对本地控制器动作的永久重定向。
*   **`RedirectToPage`**（`RedirectToPageResult`、HTTP 代码`302`、来自 ASP.NET Core 2）：重定向到本地 Razor 页面。
*   `RedirectToPagePermanent`（**`RedirectToPageResult`**、HTTP 代码`301`：永久重定向到本地剃须刀页面。
*   **`RedirectToPagePermanentPreserveMethod`****`RedirectToPageResult`**、HTTP 代码`301`：永久重定向到本地页面，保留原始请求的 HTTP 方法。
*   **`RedirectToPagePreserveMethod`****`RedirectToPageResult`**、HTTP 代码`302`：重定向到本地页面。
*   `RedirectToRoute`（`RedirectToRouteResult`、HTTP 代码`302`：重定向到指定路由。
*   `RedirectToRoutePermanent`（`RedirectToRouteResult`、HTTP 代码`301`：永久重定向到指定路由。
*   `SignIn``SignInResult`：签到。
*   `SignOut``SignOutResult`：退出。
*   `StatusCode`（`StatusCodeResult`、**`ObjectResult`**、任意 HTTP 代码）。
*   无方法（`UnsupportedMediaTypeResult`、HTTP 代码`415`：接受的内容类型与可以返回的内容类型不匹配。
*   `Unauthorized`（`UnauthorizedResult`、HTTP 代码`401`：不允许请求资源。
*   `View`（`ViewResult`、HTTP 代码`200`、在`Controller`类中声明）：一个视图。
*   `ViewComponent`（`ViewComponentResult`、HTTP 代码`200`：调用视图组件的结果。

其中一些结果还指定了内容类型，例如，`ContentResult`将默认返回`text/plain`（可以更改），`JsonResult`将返回`application/json`等等。有些名字是不言自明的；其他人可能需要一些澄清：

*   `Redirect`方法通常有四个版本，一个用于临时重定向，一个用于永久重定向，另外两个版本也保留了原始的请求 HTTP 方法。可以重定向到任意 URL、特定控制器操作的 URL、Razor 页面 URL 和本地（相对）URL。
*   重定向中的 preserve 方法意味着浏览器发出的新请求将保留原始 HTTP 谓词。
*   `File`和`Physical`文件方法提供了几种返回文件内容的方法，可以通过 URL、`Stream`、字节数组或物理文件位置。`Physical`方法允许您直接从文件系统位置发送文件，这可能会提高性能。您还可以选择在希望传输的内容上设置`ETag`或`LastModified`日期。
*   `ViewResult`和`PartialViewResult`的不同之处在于后者只寻找局部视图。
*   某些方法可能会返回不同的结果，这取决于所使用的重载（当然还有它的参数）。
*   `SignIn`、`SignOut`、`Challenge`与认证相关，未配置无意义。`SignIn`将重定向到配置的登录 URL，`SignOut`将清除身份验证 cookie。
*   并非所有这些结果都返回内容；其中一些只返回状态码和一些头（例如，`SignInResult`、`SignOutResult`、`StatusCodeResult`、`UnauthorizedResult`、`NoContentResult`、`NotFoundObjectResult`、`ChallengeResult`、`BadRequestResult`、`ForbidResult`、`OkResult`、`CreatedResult`、`CreatedAtActionResult`、`CreatedAtRouteResult`以及所有的[T13 结果）。另一方面，`JsonResult`、`ContentResult`、**`VirtualFileResult`**、**`FileStreamResult`**、**`FileContentResult`**、**`ViewResult`**所有返回内容。

所有返回视图（`ViewResult`或部分视图（`PartialViewResult`的操作结果类）都采用`Model`属性，其原型为`object`。您可以使用它向视图传递任意数据，但请记住，视图必须声明兼容类型的模型。遗憾的是，您无法传递匿名类型，因为视图将无法定位其属性。在[第 6 章](06.html)*使用表单和模型*中，我将提出一个解决方案。

返回操作结果可能是控制器最典型的用法，但也可以返回任何.NET 对象。为此，必须声明方法以返回所需的任何类型：

```cs
public string SayHello()
{
    return "Hello, World!";
}
```

这是一种完全有效的行动方法；但是，有几件事你需要知道：

*   在调用任何筛选器之前（例如，`IActionFilter`、`IResultFilter`），将返回的对象包装在一个`ObjectResult`中。
*   该对象由配置的*输出格式化程序*之一格式化（序列化），第一个表示可以处理该对象。
*   如果要更改响应的状态代码或内容类型，则需要使用`HttpContext.Response`对象。

为什么返回一个 POCO 类或一个`ObjectResult`？好的，`ObjectResult`给了你一些额外的优势：

*   您可以提供输出格式化程序的集合（`Formatters`集合）。
*   您可以告诉它使用内容类型的选择（`ContentTypes`。
*   您可以指定要返回的状态码（`StatusCode`。

让我们更详细地了解有关 API 操作的输出格式化程序。现在，让我们看一个示例操作结果，它以 XML 形式返回内容：

```cs
public class XmlResult : ActionResult
{
    public XmlResult(object value)
    {
        this.Value = value;
    }

    public object Value { get; }

    public override Task ExecuteResultAsync(ActionContext context)
    { 
        if (this.Value != null)
        {
            var serializer = new XmlSerializer(this.Value.GetType());
            using (var stream = new MemoryStream())
            {
                serializer.Serialize(stream, this.Value);
                var data = stream.ToArray();
                context.HttpContext.Response.ContentType =     
                 "application/xml";
                context.HttpContext.Response.ContentLength = data.Length;
                context.HttpContext.Response.Body.Write(data, 0, 
                 data.Length);
            }
        }

        return base.ExecuteResultAsync(context);
    }
}
```

在这段代码中，我们实例化了一个绑定到要返回的值类型的`XmlSerializer`实例，并使用它将该值序列化为字符串，然后将其写入响应。您需要为`XmlSerializer`类添加对`System.Xml.XmlSerializer`NuGet 包的引用。这进一步导致操作的重定向和流化。让我们看看这些是什么。

### 重定向

当服务器在收到客户端（浏览器）的请求后指示客户端转到另一个位置时，会发生重定向：

![](img/843d3b4b-259b-4b77-9a73-d219aa5d3c6d.png)

至少有 10 种方法可以实现重定向。此处的更改是返回给客户端的 HTTP 状态代码以及重定向 URL 的生成方式。我们为以下内容提供了重定向：

*   **特定 URL，完整或本地**：`Redirect`
*   **本地 URL**：`LocalRedirect`
*   **命名路由**：`RedirectToRoute`
*   **特定控制器及动作**：`RedirectToAction`
*   **剃须刀页面（更多信息参见**[第 7 章](07.html)**、***实现剃须刀页面***：`RedirectToPage`**

 **所有这些方法都返回 HTTP 状态码 302（参见[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302) ），这是一个临时重定向。然后我们有发送 HTTP 301（[的替代版本 https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301) ），一个永久重定向，这意味着浏览器被指示缓存响应，并了解当被要求转到原始 URL 时，他们应该访问新的 URL。这些方法与前面的方法类似，但以`Permanent`结尾：

*   **特定 URL**：`RedirectPermanent`
*   **本地 URL**：`LocalRedirectPermanent`
*   **命名路由**：`RedirectToRoutePermanent`
*   **特定控制器及动作**：`RedirectToActionPermanent`
*   **剃须刀页面（更多信息参见**[第 7 章](07.html)、***实现剃须刀页面***：`RedirectToPagePermanent`****

 ****然后还有另一个变体，它保留了原来的 HTTP 动词，并且基于 HTTP 308（[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308) ）。例如，可能是浏览器试图使用 HTTP`POST`访问资源，服务器返回 HTTP 状态 308，并重定向到另一 URL；然后，客户端必须使用`POST`而不是`GET`再次请求此 URL，这是其他代码的情况。在这种情况下，我们还有其他变化：

*   **特定 URL**：`RedirectPermanentPreserveMethod`
*   **本地 URL**：`LocalRedirectPreserveMethod`
*   **命名路由**：`RedirectToRoutePermanentPreserveMethod`
*   **特定控制器及动作**：`RedirectToActionPermanentPreserveMethod`
*   **剃须刀页面（更多信息请参见**[第 7 章](07.html)、***中的**涂抹剃须刀页面***`RedirectToPagePermanentPreserveMethod`****

 ****### 流动

如果需要将内容流式传输到客户端，则应使用`FileStreamResult`类。在以下示例代码中，我们正在流式传输 MP4 文件：

```cs
[HttpGet("[action]/{name}")]
public async Task<FileStreamResult> Stream(string name)
{
    var stream = await System.IO.File.OpenRead($"{name}.mp4");
    return new FileStreamResult(stream, "video/mp4");
}
```

请注意，`ControllerBase`或`Controller`类中没有返回`FileStreamResult`的方法，因此您需要自己构建它，将流和所需的内容类型传递给它。这将保持客户端连接，直到传输结束或浏览器导航到另一个 URL。

现在让我们看看我们能做些什么来处理错误。

# 错误处理

在上一章中，我们看到了在发生错误时如何重定向到特定操作。另一种选择是利用`IExceptionFilter`和`IAsyncExceptionFilter`接口（过滤器类之一），让控制器本身或其他类直接实现错误处理。

在我们的控制器中，只需实现`IExceptionFilter`类，它只有一个方法`OnException`：

```cs
public void OnException(ExceptionContext context)
{
    var ex = context.Exception;

    //do something with the exception

    //mark it as handled, so that it does not propagate
    context.ExceptionHandled = true;
}
```

在异步版本`IAsyncExceptionFilter`中，`OnExceptionAsync`方法采用相同的参数，但必须返回一个`Task`。

在[章节](10.html)[10](10.html)*了解过滤器*中，我们将了解更多关于过滤器的概念。现在，只要说如果在实现`IExceptionFilter`的控制器中的操作引发任何异常，就会调用其`OnException`方法。

Don't forget to set `ExceptionHandled` to `true` if you don't want the exception to propagate!

下一个主题与性能相关：响应缓存。

# 响应缓存

任何类型的操作响应（例如 HTML 或 JSON）都可以缓存在客户机中以提高性能。不用说，只有当它返回的结果很少改变时，这种情况才会发生。这在**RFC 7234**、**HTTP/1.1 缓存**（[中有规定 https://tools.ietf.org/html/rfc7234](https://tools.ietf.org/html/rfc7234#section-5.2) 。本质上，响应缓存是一种机制，通过该机制，服务器通知客户机（浏览器或客户机 API）将返回的 URL 响应（包括标题）保留一段时间，并在此期间将其用于 URL 的所有后续调用。只有`GET`HTTP 谓词可以缓存，因为它被设计为幂等：`PUT`、`POST`、`PATCH`或`DELETE`不能缓存。

我们在`ConfigureServices`中增加了对资源缓存的支持，具体如下：

```cs
services.AddResponseCaching();
```

我们在`Configure`中使用它，它基本上将响应缓存中间件添加到 ASP.NET Core 管道中：

```cs
app.UseResponseCaching();
```

我们还可以在对`AddResponseCaching`的调用中设置几个选项，例如：

*   `MaximumBodySize`（`int`）：这是可以存储在客户端响应缓存中的响应的最大大小；默认值为 64 KB。
*   `UseCaseSensitivePaths`（`bool`）：可以配置缓存密钥的请求 URL 是否区分大小写；默认值为`false`。

这些可使用`AddResponseCaching`方法的过载：

```cs
services.AddResponseCaching(options =>
{
    options.MaximumBodySize *= 2;
    options.UseCaseSensitivePaths = true;
});
```

我们还可以通过将`[ResponseCache]`属性应用于动作或整个控制器类来缓存动作结果。接下来，我们有两个选项，可以直接在属性中指定每个缓存参数，也可以告诉它使用**缓存配置文件**。

方案如下：

*   `Duration`（`int`：缓存的秒数；默认值为`0`
*   `Location`（`ResponseCacheDuration`）：缓存的位置（`Client`、`None`、`Any`；默认值为`Any`
*   `NoStore`（`bool`：是否阻止结果的存储；默认值为`false`
*   `VaryByHeader`（`string`：缓存结果实例的头的逗号分隔列表；默认值为`null`
*   `VaryByQueryKeys`（`string []`：缓存结果实例的查询字符串参数列表；默认值为`null`
*   `CacheProfileName`（`string`：缓存配置文件名称，与其他选项不兼容；默认值为空

如前所述，您可以指定所有单个选项（或至少指定您需要的选项），也可以指定缓存配置文件名称。缓存配置文件通过`AddMvc`扩展方法在`ConfigureServices`方法的`Startup`定义，如下所示：

```cs
services.AddMvc(options =>
{
    options.CacheProfiles.Add("5minutes", new CacheProfile
    {
        Duration = 5 * 60,
        Location = ResponseCacheLocation.Any,
        VaryByHeader = "Accept-Language"
    });
});
```

此缓存配置文件指定结果保留五分钟，不同实例对应不同的`Accept-Language`头值。在此之后，您只需指定名称`5minutes`：

```cs
[ResponseCache(CacheProfileName = "5minutes")]
public IActionResult Cache() { ... }
```

`VaryByHeader`和`VaryByQueryKeys`属性（如果它们有值）将为请求头或查询字符串参数（或两者）的每个值保留相同缓存响应的不同实例。例如，如果您的应用支持多种语言，并且您使用`Accept-Language`HTTP 头来指示应该使用哪种语言，则结果会针对每种请求的语言保存在缓存中—一种用于`pt-PT`，另一种用于`en-GB`，依此类推。

通常最好使用缓存配置文件，而不是在属性中提供所有参数。

现在让我们看看如何在后续请求之间保持状态。

# 维护国家

如果您需要在同一请求中或跨多个请求维护从一个组件到另一个组件的状态，该怎么办？Web 应用传统上为此提供解决方案。让我们探讨一下我们的选择。

## 使用请求

存储在请求（内存中）中的任何对象都将在整个请求期间可用。条目是`HttpContext`类中的强类型词典：

```cs
this.HttpContext.Items["timestamp"] = DateTime.UtcNow;
```

您可以在访问该项之前检查该项是否存在；值得注意的是，以下内容区分大小写：

```cs
if (this.HttpContext.Items.ContainsKey("timestamp")) { ... }
```

当然，您也可以删除项目：

```cs
this.HttpContext.Items.Remove("timestamp");
```

## 使用表单数据

`Form`集合跟踪 HTML`FORM`提交的所有值，通常在`POST`请求之后。要访问它，请使用`HttpContext`的`Request`对象的`Form`属性：

```cs
var isChecked = this.HttpContext.Request.Form["isChecked"].Equals("on");
```

您可以通过首先检查值的存在（不区分大小写）进行防御性编程：

```cs
if (this.HttpContext.Request.Form.ContainsKey("isChecked")) { ... }
```

可以获得多个值，在这种情况下，可以对它们进行计数并获得它们的所有值：

```cs
var count = this.HttpContext.Request.Form["isChecked"].Count;
var values = this.HttpContext.Request.Form["isChecked"].ToArray(); 
```

## 使用查询字符串

通常，您不会在查询字符串中存储数据，而是从中获取数据，例如，`http://servername.com?isChecked=true`。`Query`集合跟踪 URL 中作为字符串发送的所有参数：

```cs
var isChecked = this.HttpContext.Request.Query["isChecked"].Equals("true");
```

为了检查是否存在值，我们使用以下方法：

```cs
if (this.HttpContext.Request.Query.ContainsKey("isChecked")) { ... }
```

这也支持多个值：

```cs
var count = this.HttpContext.Request.Query["isChecked"].Count;
var values = this.HttpContext.Request.Query["isChecked"].ToArray(); 
```

## 使用路线

与查询字符串方法一样，您通常只从路由中获取值，而不向其写入；但是，`IUrlHelper`接口中确实有方法，通常可以通过生成动作 URL 的`ControllerBase`类的`Url`属性访问该接口，从中可以打包任意值。

路由参数如`http://servername.com/admin/user/121`所示，使用`[controller]/[action]/{id}`路由模板。

要获取路由参数（字符串），请执行以下操作：

```cs
var id = this.RouteData.Values["id"];
```

要检查它是否存在，请使用以下命令：

```cs
if (this.RouteData.ContainsKey("id")) { ... }
```

## 使用 cookies

Cookie 已经存在很长时间了，它是 web 上许多功能的基础，例如身份验证和会话。它们在 RFC 6265（[中规定 https://tools.ietf.org/html/rfc6265](https://tools.ietf.org/html/rfc6265) ）。本质上，它们是在客户端存储少量文本的一种方式。

你可以读写 cookies。要读取 cookie 值，您只需要知道它的名称；其值将以字符串形式出现：

```cs
var username = this.HttpContext.Request.Cookies["username"];
```

当然，您还可以通过以下方式检查 cookie 是否存在：

```cs
if (this.HttpContext.Request.Cookies.ContainsKey("username")) { ... }
```

要将 cookie 作为响应的一部分发送到客户端，您需要更多的信息，即以下信息：

*   `Name`（`string`：一个名字（还有什么？）
*   `Value`（`string`：字符串值
*   `Expires`（`DateTime`）：可选的到期时间戳（默认情况下 cookie 基于会话，这意味着一旦浏览器关闭，cookie 将消失）
*   `Path`（`string`：cookie 可用的可选路径（默认为`/`）
*   `Domain`（`string`：可选域（默认为当前完全限定的主机名）

*   `Secure`（`bool`：一个可选的安全标志，如果存在，将导致 cookie 仅在使用 HTTPS 服务请求时可用（默认为`false`）
*   `HttpOnly`（`bool`：另一个可选标志，指示 cookie 是否可被客户端浏览器上的 JavaScript 读取（默认值也是`false`）

我们向请求对象添加 cookie，如下所示：

```cs
this.HttpContext.Response.Cookies.Append("username", "rjperes", new CookieOptions
    { 
        Domain = "packtpub.com",
        Expires = DateTimeOffset.Now.AddDays(1),
        HttpOnly = true,
        Secure = true,
        Path = "/"
    });
```

第三个参数，`CookieOptions`类型是可选的，在这种情况下，cookie 采用默认值。

撤销 cookie 的唯一方法是添加一个具有相同名称和过期日期的 cookie。

You mustn't forget that there is a limit to the number of cookies you can store per domain, as well as a limit to the actual size of an individual cookie value; these shouldn't be used for large amounts of data. For more information, please consult RFC 6265.

## 使用会话

会话是一种为每个客户端持久化数据的方法。通常，会话依赖于 cookie，但也可能（但容易出错）使用查询字符串参数，ASP.NET Core 不支持这种开箱即用的方式。在 ASP.NET Core 中，会话是选择性加入的；换句话说，它们需要明确添加。我们需要添加 NuGet 包`Microsoft.AspNetCore.Session`并在`Startup`类的`Configure`和`ConfigureServices`方法中显式添加支持：

```cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddSession();
    //rest goes here
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseSession();
    //rest goes here
}
```

之后，`Session`对象在`HttpContext`实例中可用：

```cs
var value = this.HttpContext.Session.Get("key");  //byte[]
```

更好的方法是使用`GetString`扩展方法并序列化/反序列化为 JSON：

```cs
var json = this.HttpContext.Session.GetString("key");
var model = JsonSerializer.Deserialize<Model>(json);
```

这里，`Model`只是一个 POCO 类，`JsonSerializer` 是`System.Text.Json`中的一个类，它有静态方法来序列化和反序列化 JSON 字符串。

要在会话中存储值，我们使用`Set`或`SetString`方法：

```cs
this.HttpContext.Session.Set("key", value); //value is byte[]
```

JSON 方法如下所示：

```cs
var json = JsonSerializer.Serialize(model);
this.HttpContext.Session.SetString("key", json);
```

通过将值设置为`null`或调用`Remove`来实现删除。与`GetString`和`SetString`类似，还有`GetInt32`和`SetInt32`扩展方法。使用最适合您需要的方法，但不要忘记数据始终存储为字节数组。

如果要检查会话中是否存在值，应使用`TryGetValue`方法：

```cs
byte[] data;
if (this.HttpContext.Session.TryGetValue("key", out data)) { ... }
```

这就是将会话用作通用词典的主要原因。现在是，配置时间！您可以在`SessionOptions`对象中设置一些值，主要围绕用于存储会话的 cookie 以及空闲时间间隔：

```cs
services.AddSession(options =>
{
    options.CookieDomain = "packtpub.com";
    options.CookieHttpOnly = true;
    options.CookieName = ".SeSsIoN";
    options.CookiePath = "/";
    options.CookieSecure = true;
    options.IdleTimeout = TimeSpan.FromMinutes(30);
});
```

也可以在`Configure`中的`UseSession`方法中配置：

```cs
app.UseSession(new SessionOptions { ... });
```

最后要注意的一点是，会话在默认情况下将使用内存存储，这不会使其在现实生活中的应用中具有过度的弹性或有用性；但是，如果在调用`AddSession`之前注册了分布式缓存提供程序，则会话将使用该提供程序！所以，让我们看看下一个主题，看看如何配置它。

在继续之前，我们需要记住以下几点：

*   在会话中存储对象会有一点性能损失。
*   如果达到空闲超时，对象可能会从会话中退出。
*   在会话中访问对象会延长其生存期，即重置其空闲超时。

## 使用缓存

与以前版本的 ASP.NET 不同，不再内置对缓存的支持；与.NETCore 中的大多数内容一样，它仍然可用，但作为一种可插入服务。.NET Core 中基本上有两种缓存：

*   内存缓存中，由`IMemoryCache`接口表示
*   分布式缓存，使用`IDistributedCache`接口

ASP.NET Core 包括一个默认的`IMemoryCache`实现和一个`IDistributedCache`实现。分布式实现需要注意的是，它也在内存中，只用于测试，但好的是有几种实现可用，比如 Redis（[https://redis.io/](https://redis.io/) 或 SQL Server。

In-memory and distributed caches can be used simultaneously, as they are unaware of each other.

分布式缓存和内存缓存都将实例存储为字节数组（`byte[]`），但一个好的解决方法是首先将对象转换为 JSON，然后使用处理字符串的方法扩展，如下所示：

```cs
var json = JsonSerializer.Serialize(model);
var model = JsonSerializer.Deserialize<Model>(json);
```

### 内存缓存

要使用内存缓存，您需要使用以下默认选项在`ConfigureServices`中注册其服务：

```cs
services.AddMemoryCache();
```

如果愿意，还可以使用重载扩展方法对其进行微调，该方法采用`MemoryCacheOptions`实例：

```cs
services.AddMemoryCache(options =>
{
    options.Clock = new SystemClock();
    options.CompactOnMemoryPressure = true;
    options.ExpirationScanFrequency = TimeSpan.FromSeconds(5 * 60);
});
```

这些财产的用途如下：

*   `Clock`（`ISystemClock`）：这是`ISystemClock`的一个实现，将用于到期计算。它对于单元测试和模拟非常有用；没有默认设置。
*   `CompactOnMemoryPressure`（`bool`：用于在可用内存过低时从缓存中删除最旧的对象；默认值为`true`。
*   `ExpirationScanFrequency`（`TimeSpan`）：设置.NET Core 用于确定是否从缓存中删除对象的时间间隔；默认值为一分钟。

为了使用内存缓存，我们需要从依赖项注入中检索一个`IMemoryCache`实例：

```cs
public IActionResult StoreInCache(Model model, [FromServices] IMemoryCache cache)
{
    cache.Set("model", model);
    return this.Ok();
}
```

我们将在*依赖注入**部分*中更详细地了解`[FromServices]`。

`IMemoryCache`支持您可能期望的所有操作，以及其他一些操作：

*   `CreateEntry`：在缓存中创建一个条目，并允许您访问 expiration
*   `Get`/`GetAsync`：从缓存中同步或异步检索项目
*   `GetOrCreate`/`GetOrCreateAsync`：从缓存中返回项目（如果存在），或同步或异步创建一个项目
*   `Set`/`SetAsync`：同步或异步添加或修改缓存中的项目
*   `Remove`：从缓存中删除项目
*   `TryGetValue`：尝试同步从缓存中获取项目

差不多就是这样！内存缓存将可用于同一应用中的所有请求，并在应用重新启动或停止后消失。

### 分布式缓存

分布式缓存的默认开箱即用实现在现实场景中几乎毫无用处，但它可能是一个很好的起点。以下是如何在`ConfigureServices`中添加对它的支持：

```cs
services.AddDistributedMemoryCache();
```

没有其他选择，只是这样。要使用它，请向依赖项注入容器请求一个`IDistributedCache`实例：

```cs
private readonly IDistributedCache _cache;

public CacheController(IDistributedCache cache)
{
    this._cache = cache;
}

public IActionResult Get(int id)
{
    return this.Content(this._cache.GetString(id.ToString()));
}
```

所包含的实现将以与内存缓存完全相同的方式运行，但是对于更严重的用例，也有一些很好的替代方案。它提供的 API 具有以下功能：

*   `Get`/`GetAsync`：从缓存返回一个项目
*   `Refresh`/`RefreshAsync`：刷新缓存中的项目，延长其生命周期
*   `Remove`/`RemoveAsync`：从缓存中删除项目
*   `Set`/`SetAsync`：将项目添加到缓存或修改其当前值

请注意，由于缓存现在是分布式的，同步可能需要一些时间，因此存储在其中的项目可能不会立即对所有客户端可用。

#### 雷迪斯

**Redis**是一个开源的分布式缓存系统。它的描述超出了本书的范围，但可以说微软已经以`Microsoft.Extensions.Caching.Redis`NuGet 包的形式为它提供了一个客户端实现。添加此包后，您将获得两个扩展方法，您需要使用这些方法在`ConfigureServices`中注册两个服务，这将用正确的值替换`Configuration`和`InstanceName`属性：

```cs
services.AddDistributedRedisCache(options =>
{
    options.Configuration = "servername";
    options.InstanceName = "Shopping";
});
```

就这样！现在，无论何时您请求一个`IDistributedCache`实例，您都会得到一个在下面使用 Redis 的实例。

There is a good introduction to Redis available at [https://redis.io/topics/quickstart](https://redis.io/topics/quickstart).

#### SQL Server

另一种选择是将 SQL Server 用作分布式缓存。`Microsoft.Extensions.Caching.SqlServer`是增加对其支持的 NuGet 包。您可以在`ConfigureServices`中添加对它的支持，如下所示：

```cs
services.AddDistributedSqlServerCache(options =>
{
    options.ConnectionString = @"Server=.; Database=DistCache;
     Integrated Security=SSPI;";
    options.SchemaName = "dbo";
    options.TableName = "Cache";
});
```

其余的都是一样的，所以只要从 DI 那里抓住`IDistributedCache`就可以了。

ASP.NET Core no longer includes the **`HttpApplication`** and `HttpApplicationState` classes, which is where you could keep state applications. This mechanism had its problems, and it's better if you rely on either an in-memory or distributed cache instead.

## 使用临时数据

`Controller`类提供了`ITempDataDictionary`类型的`TempData`属性。临时数据是一种在请求中存储项目的方法，以便在下一个请求中仍然可用。它基于提供商，目前有两个提供商可用：

*   饼干（`CookieTempDataProvider`）
*   会话（`SessionStateTempDataProvider`

对于后者，您需要启用会话状态支持。为此，您选择一个提供者，并使用依赖注入框架注册它，通常使用`ConfigureServices`方法：

```cs
//only pick one of these
//for cookies
services.AddSingleton<ITempDataProvider, CookieTempDataProvider>();
//for session
services.AddSingleton<ITempDataProvider, SessionStateTempDataProvider>(); 

```

从 ASP.NET Core 2 开始，`CookieTempDataProvider`已经注册。如果您使用`SessionStateTempDataProvider`，还需要启用会话。

选择其中一个提供者后，可以向`TempData`集合添加数据：

```cs
this.TempData["key"] = "value";
```

从以下代码中可以看到，检索和检查存在性非常简单：

```cs
if (this.TempData.ContainsKey("key"))
{
    var value = this.TempData["key"];
}
```

通过注册其中一个提供者启用临时数据后，可以使用**`[SaveTempData]`**属性。当应用于操作结果返回的类时，它将自动保存在临时数据中。

**`[TempData]`**属性如果应用于`model`类中的属性，将自动将该属性的值保存在临时数据中：

```cs
[TempData]
public OrderModel Order { get; set; }
```

## 状态维修技术的比较

下表提供了可用于维护请求之间状态的所有不同技术的简单比较：

| **技术** | **可存储对象** | **是安全的** | **为共享** | **正在进行** | **到期日** |
| 要求 | `object` | 对 | 不 | 对 | 不 |
| 类型 | `string` | 是（如果使用 HTTPS） | 不 | 对 | 不 |
| 查询字符串 | `string` | 不 | 对 | 对 | 不 |
| 路线 | `string` | 不 | 对 | 对 | 不 |
| 曲奇饼 | `string` | 是（如果仅设置为 HTTPS） | 不 | 不 | 对 |
| 一场 | `byte[]` | 对 | 不 | 大概 | 对 |
| 隐藏物 | `object` | 对 | 对 | 大概 | 对 |
| 临时数据 | `string` | 对 | 不 | 不 | 对 |

不用说，并非所有这些技术都有相同的用途；相反，它们用于不同的场景。

在下一节中，我们将学习如何在控制器内使用依赖项注入。

# 依赖注入

NET Core 通过其内置的**DI**框架实例化控制器。由于它完全支持构造函数注入，您可以将任何已注册的服务作为参数注入构造函数：

```cs
//ConfigureServices
services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();

//HomeController
public HomeController(IHttpContextAccessor accessor) { ... }
```

但是，您也可以通过利用`HttpContext.RequestServices`属性以服务定位器的方式从 DI 请求服务，如下所示：

```cs
var accessor = this.HttpContext.RequestServices.GetService<IHttpContextAccessor>();
```

For the strongly typed `GetService<T>` extension method, you need to add a reference to the `Microsoft.Extensions.DependencyInjection` namespace.

在 action 方法中，您还可以通过使用`[FromServices]`属性修饰其类型化参数来注入服务，如下所示：

```cs
public IActionResult Index([FromServices] IHttpContextAccessor accessor) { ... }
```

下一个主题涉及一个非常重要的主题，特别是对于那些希望实现多语言站点的人。

# 全球化与本土化

如果您需要构建一个将由不同国家的人使用的应用，您可能需要将其全部或至少部分翻译。但不仅仅是这样：您可能还希望以用户期望的方式显示十进制数字和货币符号。应用支持不同文化的过程称为**全球化**，而**本地化**则是使其适应特定文化的过程，例如，通过以特定语言呈现文本。

与以前的版本一样，ASP.NET Core 完全支持这两个相互交织的概念，它将特定的区域性应用于请求并让其流动，并且能够根据请求者的语言提供字符串资源。

我们首先需要添加对全球化和本地化的支持，我们通过向项目中添加`Microsoft.AspNetCore.Localization.Routing`包来实现这一点。就本章而言，我们希望能够做到以下几点：

*   为当前请求设置区域性
*   与当前区域性匹配的手动资源字符串

让我们通过调用`AddLocalization`在`ConfigureServices`方法中配置本地化。我们将选择`Resources`文件夹作为资源文件的源，稍后我们将看到：

```cs
services.AddLocalization(options =>
{
    options.ResourcesPath = "Resources";
});
```

我们创建这个`Resources`文件夹，并在其中创建一个`Controllers`文件夹。我们还可以使用 Visual Studio 创建两个资源文件，一个名为`HomeController.en.resx`，另一个名为`HomeController.pt.resx`。`resx`扩展名是资源文件的标准扩展名，这些文件基本上是包含键值对的 XML 文件。在这些文件中的每个文件上，添加一个带有键`Hello`和以下值的条目：

| **葡萄牙语** | **英语** |
| 奥拉！ | 你好 |

它应该看起来像下面的屏幕截图。请注意，每个文件都有控制器类的名称加上两个字母的区域性标识符：

![](img/da8d7419-ca8d-4a6d-bce6-f49bdf2b72dd.png)

现在，让我们定义一系列要支持的文化和语言。简单来说，我们将支持**葡萄牙语**（**pt**）和**英语**（**英**）：

```cs
var supportedCultures = new List<CultureInfo>
{
    new CultureInfo("pt"),
    new CultureInfo("en")
};
```

We are using `pt` and `en`, generic culture descriptors, but we could have also used `pt-pt` and `en-gb` for specific cultures. Feel free to add these if you want.

然后配置`RequestLocalizationOptions`以获得默认语言：

```cs
services.Configure<RequestLocalizationOptions>(options =>
{
    options.DefaultRequestCulture = 
        new RequestCulture(supportedCultures.First().Name, 
        supportedCultures.First().Name);
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;
    options.RequestCultureProviders = new[] {
        new AcceptLanguageHeaderRequestCultureProvider { Options =
        options } };
});
```

从浏览器获取区域性的过程基于提供者模型。以下提供程序可用：

*   `AcceptLanguageHeaderRequestCultureProvider`从`Accept-Language`头获取培养基。
*   `CookieRequestCultureProvider`从饼干中获取文化。
*   `QueryStringRequestCultureProvider`从查询字符串参数获取区域性。
*   `RouteDataRequestCultureProvider`从路由参数获取区域性。

只需将前面代码中的`RequestCultureProviders`赋值替换为您想要的。如您所见，有许多可用选项，每个选项都具有需要设置的不同功能，例如 cookie 名称、查询字符串参数、路由参数名称等：

```cs
new CookieRequestCultureProvider { CookieName = "culture" }
new QueryStringRequestCultureProvider { QueryStringKey = "culture" }
new RouteDataRequestCultureProvider { RouteDataStringKey = "culture" }
```

在第二章中，我们研究了路线约束，因此在这里我们将介绍文化路线约束：

```cs
public sealed class CultureRouteConstraint : IRouteConstraint
{
    public const string CultureKey = "culture";

    public bool Match(
        HttpContext httpContext,
        IRouter route,
        string routeKey,
        RouteValueDictionary values,
        RouteDirection routeDirection)
        {
            if ((!values.ContainsKey(CultureKey)) || (values
            [CultureKey] == null))
            {
                return false;
            }

            var lang = values[CultureKey].ToString();

            var requestLocalizationOptions = httpContext
               .RequestServices
               .GetRequiredService<IOptions<RequestLocalization
                Options>>();

            if ((requestLocalizationOptions.Value.SupportedCultures
             == null) 
               || (requestLocalizationOptions.Value.SupportedCultures.
                  Count == 0))
            {
                try
                {
                    new System.Globalization.CultureInfo(lang);
                  //if invalid, throws an exception
                    return true;
                }
                catch
                {
                    //an invalid culture was supplied
                    return false;
            }
        }

        //checks if any of the configured supported cultures matches the 
        //one requested
        return requestLocalizationOptions.Value.SupportedCultures
            .Any(culture => culture.Name.Equals(lang, StringComparison
            .CurrentCultureIgnoreCase));
    }
}
```

`Match`方法仅在存在为区域性密钥指定的值时运行；如果是，它将提取其值并检查`RequestLocalizationOptions`是否为受支持的区域性或是否为有效的区域性。本质上，这允许验证路由值，例如`{language:culture}`，如果该值不是有效的区域性，您将得到一个异常。此路由约束需要先注册，然后才能使用，如下所示：

```cs
services.Configure<RouteOptions>(options =>
{
    options.ConstraintMap.Add(CultureRouteConstraint.CultureKey, typeof
    (CultureRouteConstraint));
});
```

现在，我们希望控制器响应浏览器的语言设置。例如，在 Chrome 中，我们将在设置|语言|语言和输入设置中配置：

![](img/cea55188-5aa5-48c1-a045-785e7e0e6642.png)

此设置的作用是配置浏览器在每次请求时发送的`Accept-Language`HTTP 头。我们将利用这一点来决定我们将展示什么语言。

我们希望了解本地化的每个控制器需要进行如下更改：

*   添加中间件过滤器属性以注入中间件组件。
*   注入一个字符串定位器，我们可以使用它来获取适当翻译的资源。

下面是它应该是什么样子：

```cs
[MiddlewareFilter(typeof(LocalizationPipeline))]
public class HomeController
{
    private readonly IStringLocalizer<HomeController> _localizer;

    public HomeController(IStringLocalizer<HomeController> localizer)
    {
        this._localizer = localizer;
    }
}
```

`LocalizationPipeline`实际上是一个 OWIN 中间件组件，应该如下所示：

```cs
public class LocalizationPipeline
{
    public static void Configure(
        IApplicationBuilder app, 
        IOptions<RequestLocalizationOptions> options)
    {
        app.UseRequestLocalization(options.Value);
    }
}
```

现在，如果我们想以特定于区域性的方式访问特定的资源，我们只需执行以下操作：

```cs
var hello = this._localizer["Hello"];
```

返回的字符串将来自源于浏览器的基于当前区域性的正确资源文件。您可以通过查看`CultureInfo.CurrentCulture`和`CultureInfo.CurrentUICulture`属性来检查这一点。

最后还有几件事需要注意：

*   每个语言可以有多个资源文件，或者更准确地说，每个特定语言（例如，`en`、`pt`）和通用语言（例如，`en-gb`、`en-us`）可以有多个资源文件；如果浏览器请求特定语言（例如，`en-gb`、`en-us`），则本地化程序将尝试查找以该语言作为后缀的资源文件，如果找不到，则将尝试通用语言（例如，`en`。如果此操作也失败，它将返回提供的资源密钥（例如，`Hello`）
*   本地化程序从不返回错误或空值，但您可以使用以下内容检查当前语言是否存在该值：

```cs
var exists = this._localizer["Hello"].ResourceNotFound;
```

这里讨论的主题是非常重要的，如果您要实现需要支持多种文化或语言的站点，但如果您希望在站点中的文本中包含文本（如资源），那么也可以考虑使用它，以便可以很容易地编辑和替换它们。

# 总结

在本章中，我们看到使用 POCO 控制器并不是真正需要的，它需要做的工作比我们从中获得的任何好处都多，因此我们应该让我们的控制器继承自`Controller`。

然后我们看到，使用异步操作有助于提高可伸缩性，因为它不会对性能产生太大影响，但您的应用的响应速度会更快。

您可以忘记 XML 格式，因为 JSON 可以完美地工作，并且是在 web 上发送和处理数据的标准方式。

我们学到了应该使用 POCO 类作为我们行为的模型。内置的模型绑定器工作得很好，我们将在后面的章节中看到，但是您可以添加 cookie 值提供程序，因为它可能很方便。

就模型验证而言，我们发现最好坚持使用好的旧数据注释 API。如果需要，您应该在您的模型中实现`IValidatableObject`。

Redis 分布式缓存系统非常流行，Azure 和 AWS 都支持它。您应该选择 Redis 作为分布式缓存来保存参考数据；换句话说，那些不经常改变的东西。

就性能而言，响应缓存也很有用。产品页面应该不会有太大的变化，所以至少我们可以将其保存在缓存中几个小时。

这是一个很长的章节，我们讨论了控制器和操作，可以说是 ASP.NET Core 最重要的方面。我们还讨论了模型概念的一些部分，如绑定、注入和验证。我们看到了如何维护状态以及可以从操作返回的可能值。我们还学习了如何使用资源进行翻译。其中一些概念将在以后的章节中重新讨论；在下一节中，我们将讨论视图。

# 问题

您现在应该能够回答以下问题：

1.  模型状态的默认验证提供程序是什么？
2.  什么是行动？
3.  什么是全球化？全球化与本地化有何不同？
4.  临时数据的用途是什么？
5.  缓存有什么好处？
6.  什么是会话？
7.  从`Controller`基类继承控制器有什么好处？**********