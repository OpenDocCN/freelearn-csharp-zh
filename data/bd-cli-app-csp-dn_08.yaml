- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Building Modular and Extensible CLI Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建模块化和可扩展的 CLI 应用程序
- en: Throughout the pages of this book, we have added more and more functionalities
    to **Bookmarkr**, our beloved CLI application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的每一页，我们都为我们的心爱命令行应用程序 **Bookmarkr** 添加了更多功能。
- en: The problem is that we have also added more and more lines of code to the `Program.cs`
    file. The length of this file has grown from 191 lines of code by the end of [*Chapter
    3*](B22400_03.xhtml#_idTextAnchor035) to 479 lines of code by the end of [*Chapter
    7*](B22400_07.xhtml#_idTextAnchor105).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们还向 `Program.cs` 文件中添加了越来越多的代码行。该文件的长度从第 3 章末的 191 行代码增长到第 7 章末的 479 行代码。
- en: In this chapter, we will take a step back and refactor our code to make it more
    modular. This will make it easier to extend, test, and maintain.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将退后一步，重构我们的代码，使其更加模块化。这将使其更容易扩展、测试和维护。
- en: Refactoring is an essential part of the development life cycle. It should happen
    periodically in order to ensure that the quality of code is up to the standards.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是开发生命周期的一个基本部分。它应该定期发生，以确保代码质量符合标准。
- en: By taking this necessary step, we will greatly simplify adding more features,
    enhance the readability and stability of our application, and even introduce testability
    into it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采取这一必要的步骤，我们将极大地简化添加更多功能，提高我们应用程序的可读性和稳定性，甚至将其引入可测试性。
- en: 'More specifically, in this chapter, we’ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，我们将涵盖以下主题：
- en: Building the code map of the current application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建当前应用程序的代码图
- en: Deciding where to start refactoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定从哪里开始重构
- en: Designing the project structure to support refactoring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计项目结构以支持重构
- en: Refactoring a command
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构一个命令
- en: Applying the dependency inversion principle
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用依赖倒置原则
- en: Refactoring the `Program` class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构 `Program` 类
- en: Running the program to validate that the refactoring didn’t break anything
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行程序以验证重构没有破坏任何东西
- en: Pushing our refactoring to new boundaries
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的重构推向新的边界
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书配套的 GitHub 仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08)。
- en: Step 1 – building a code map of the application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 步 – 构建应用程序的代码图
- en: The first thing when you refactor an application is to get to know what you
    are about to refactor. This means having a high-level view of the application
    and its dependencies. This helps you visualize all the moving parts involved and
    better plan your refactoring activities by identifying where to start.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重构一个应用程序时，首先要了解你即将重构的内容。这意味着要有一个对应用程序及其依赖关系的高级视图。这有助于你可视化所有涉及的移动部分，并通过确定从哪里开始来更好地规划你的重构活动。
- en: If you have Visual Studio Enterprise edition, you can use its great architecture
    capabilities (such as code maps and dependency graphs) to visualize your code
    and its dependencies. However, since we are using Visual Studio Code (or if you
    don’t have the Enterprise edition of Visual Studio), we can do something else…
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有 Visual Studio Enterprise 版本，你可以使用其出色的架构功能（例如代码图和依赖关系图）来可视化你的代码及其依赖关系。然而，由于我们正在使用
    Visual Studio Code（或者如果你没有 Visual Studio 的企业版），我们可以做些其他的事情…
- en: Sure, we can run through the code and identify every moving part of it, but
    since this is a CLI application, let’s do something smarter. 😉
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以运行代码并识别其每一个移动部分，但既然这是一个命令行应用程序，让我们来做点更聪明的事情。😉
- en: Using the Help menu to build the code map
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用帮助菜单构建代码图
- en: The `System.CommandLine` is certainly great for learning how to use the application,
    but it is also great for figuring out the code map of the application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine` 确实非常适合学习如何使用应用程序，但它也非常适合确定应用程序的代码图。'
- en: 'Let’s start by displaying the help menu at the root command by typing this
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在根命令中通过输入以下命令来显示帮助菜单开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will get this result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '![Figure 8.1 – The help menu of the root command](img/B22400_08_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 根命令的帮助菜单](img/B22400_08_01.jpg)'
- en: Figure 8.1 – The help menu of the root command
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 根命令的帮助菜单
- en: Next, we will repeat this operation (aka displaying the help menu) for each
    of the subcommands of the root command, then for each subcommand of every subcommand,
    then for… Okay, you get the idea! 😉
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重复此操作（即显示帮助菜单）针对根命令的每个子命令，然后针对每个子命令的每个子命令，然后……好吧，你明白了！😉
- en: 'Here is an example of the `link` command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`link`命令的一个示例：
- en: '![Figure 8.2 – The help menu of the link command](img/B22400_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 链接命令的帮助菜单](img/B22400_08_02.jpg)'
- en: Figure 8.2 – The help menu of the link command
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 链接命令的帮助菜单
- en: 'When should we stop? Well, when the current command has no more subcommands.
    Here is an example with the `link` `add` command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在什么时候停止？嗯，当当前命令没有更多子命令时。以下是一个关于`link` `add`命令的示例：
- en: '![Figure 8.3 – The help menu of the link add command](img/B22400_08_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 链接添加命令的帮助菜单](img/B22400_08_03.jpg)'
- en: Figure 8.3 – The help menu of the link add command
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 链接添加命令的帮助菜单
- en: 'After completing this exercise, we will get the following code map:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，我们将得到以下代码图：
- en: '![Figure 8.4 – The code map of the Bookmarkr application](img/B22400_08_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – Bookmarkr应用程序的代码图](img/B22400_08_04.jpg)'
- en: Figure 8.4 – The code map of the Bookmarkr application
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – Bookmarkr应用程序的代码图
- en: Okay, now that we have a clearer view of the moving parts in our application,
    what should we do next?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们已经对我们的应用程序中的运动部件有了更清晰的了解，下一步该做什么呢？
- en: Step 2 – deciding where to start
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2步 – 决定从哪里开始
- en: It’s now time to decide what to refactor first.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候决定先重构什么了。
- en: I would recommend not to start with the root command first, but rather with
    the subcommands of that root command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要首先从根命令开始，而是从该根命令的子命令开始。
- en: There is no right or wrong decision from there. You can pick up any subcommand
    you would like to start with. We will take the `export` command as an example
    in the remainder of this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，没有对或错的决策。你可以选择你想要的任何子命令开始。在本章的剩余部分，我们将以`export`命令为例。
- en: 'Although the `export` command does not have a subcommand, it will still help
    us lay out the foundation of the refactored version of *Bookmarkr*. More specifically,
    it will help us do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`export`命令没有子命令，但它仍然有助于我们为*Bookmarkr*的重构版本奠定基础。更具体地说，它将帮助我们完成以下工作：
- en: Define the project structure to support our refactoring
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义项目结构以支持我们的重构
- en: Refactor it and hide its “complexity” (aka moving parts to the root command)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构它并隐藏其“复杂性”（即移动部件到根命令）
- en: Refactor the `Program` class and make it leaner, cleaner, and more concise
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构`Program`类，使其更精简、更干净、更简洁
- en: Set up dependency injection for interacting between commands and external services
    (such as `BookmarkService`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置依赖注入以在命令和外部服务（如`BookmarkService`）之间进行交互
- en: Let’s start with designing the project structure that will support our refactoring
    activities.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设计支持我们重构活动的项目结构开始。
- en: Step 3 – designing the project structure
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步 – 设计项目结构
- en: Although one can design their project structure according to their tastes, I
    design mine in a way that makes it easy for whoever looks at my project to understand
    what it does and where each moving part is located.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个人可以根据他们的喜好设计他们的项目结构，但我设计我的项目结构是为了让任何查看我的项目的人都能理解它做什么以及每个运动部件在哪里。
- en: Following this principle, all commands will be grouped in a folder named `Commands`.
    This folder will be created at the root of the project structure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个原则，所有命令都将被分组在一个名为`Commands`的文件夹中。这个文件夹将位于项目结构的根目录。
- en: Since we will be refactoring the `export` command, let’s create a subfolder
    named `Export` where all the code artifacts involved in the `export` command will
    be located.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将重构`export`命令，让我们创建一个名为`Export`的子文件夹，其中将包含所有涉及`export`命令的代码工件。
- en: Once we start refactoring another command, we will create a specific folder
    for it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始重构另一个命令，我们将为它创建一个特定的文件夹。
- en: What about subcommands of a command?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的子命令怎么办？
- en: Following the principle of **encapsulation** in object-oriented programming,
    and since a subcommand can only be invoked through its parent command, I recommend
    locating subcommands in the same folder as their parent command.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循面向对象编程中的**封装**原则，并且由于子命令只能通过其父命令调用，我建议将子命令放在与其父命令相同的文件夹中。
- en: An example of that is the `link add` command. The `add` subcommand can only
    be called through its parent (`link`) command. Hence, their life cycles are closely
    related to each other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`link add`命令。`add`子命令只能通过其父命令（`link`）来调用。因此，它们的生命周期紧密相关。
- en: For that matter, the code artifact of the `add` command will be located close
    to the code artifact of its parent command (`link`), within the `Link` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，`add`命令的代码工件将位于其父命令（`link`）的代码工件附近，在`Link`文件夹中。
- en: Step 4 – refactoring the export command
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 – 重构导出命令
- en: Within the `Export` folder, let’s create a new C# file named `ExportCommand.cs`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Export`文件夹中，让我们创建一个名为`ExportCommand.cs`的新C#文件。
- en: Every command class (including `RootCommand`) derives from the `Command` base
    class. Furthermore, that base class provides an `AddCommand` method that takes
    a parameter of the `Command` type, which also means any class that derives from
    the `Command` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令类（包括`RootCommand`）都继承自`Command`基类。此外，该基类提供了一个接受`Command`类型参数的`AddCommand`方法，这意味着任何继承自`Command`类的类。
- en: Armed with this, we can start refactoring the `export` command by making the
    `ExportCommand` class derive from `Command`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个认识，我们可以开始重构`export`命令，通过使`ExportCommand`类继承自`Command`类。
- en: 'After importing the required `using` statement, specifying the `namespace`
    name, and adding the required class constructor, the first iteration of our class
    looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入所需的`using`语句、指定`namespace`名称和添加所需的类构造函数之后，我们类的第一次迭代看起来如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first things to move into this class are the options. The `export` command
    has only one option, `outputfileOption`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要移动到这个类中的是选项。`export`命令只有一个选项，即`outputfileOption`。
- en: I like the fact that every component of my class is well-segmented. That’s why
    I am a fan of regions. For that reason, let’s add a region dedicated to options
    and move the code for the `outputfileOption` option within this region.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢我的类中的每个组件都很好地分割开。这就是为什么我是区域（regions）的粉丝。因此，让我们添加一个专门用于选项的区域，并将`outputfileOption`选项的代码移动到这个区域中。
- en: 'The code looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来如下所示：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then need to associate this option with the command. We will do this by
    calling the `AddOption` method from within the constructor body, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将此选项与命令关联起来。我们将在构造函数体内部调用`AddOption`方法来完成此操作，如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next thing to move is the call to the `SetHandler` method, which connects
    the command to its handler method. So, the updated version of the constructor
    looks like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要移动的是对`SetHandler`方法的调用，它将命令连接到其处理方法。因此，构造函数的更新版本如下所示：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the last piece of code to move into the new class is the command handler
    method. Once again, we will create a new region for that and move that final piece
    of code. We will also change the `static` modifier to `private`. The reason is
    that the class is not static (hence the removal of the `static` keyword) and the
    command handler method is private to that class (hence the use of the `private`
    keyword):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要移动到新类中的最后一部分代码是命令处理方法。我们再次将创建一个新的区域来存放这部分代码，并将最后的代码移动过去。我们还将`static`修饰符更改为`private`。原因是类不是静态的（因此移除了`static`关键字），命令处理方法是私有的（因此使用了`private`关键字）：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you are typing (or copying and pasting 😉) the code along the way, you can
    see at this point that the code does not compile because of two errors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个过程中正在键入（或复制粘贴 😉）代码，你可以在这一点上看到代码因为两个错误而无法编译。
- en: 'The first one is straightforward to solve. It suffices to add the following
    statement at the top of the C# file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题很容易解决。只需在C#文件顶部添加以下语句即可：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The second one is less obvious to solve. It indicates that the class can’t find
    an instance of the `BookmarkService` class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题不太明显，它表明类找不到`BookmarkService`类的实例。
- en: Of course, we could simply create an instance of that service within the current
    class. However, since `BookmarkService` is an external dependency to the `ExportCommand`
    class, doing so will break the principle of **dependency inversion** advocated
    by object-oriented programming.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在当前类中简单地创建该服务的实例。然而，由于`BookmarkService`是`ExportCommand`类的外部依赖，这样做将违反面向对象编程所倡导的**依赖倒置**原则。
- en: As a reminder, the principle of dependency inversion is one of the five SOLID
    principles of object-oriented programming and design. It states that high-level
    modules should not depend on low-level modules; both should depend on abstractions.
    Additionally, abstractions should not depend on details; details should depend
    on abstractions. This principle helps to decouple software modules, making the
    system more modular, flexible, and easier to maintain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，依赖倒置原则是面向对象编程和设计的五个 SOLID 原则之一。它指出，高级模块不应该依赖于低级模块；两者都应依赖于抽象。此外，抽象不应该依赖于细节；细节应该依赖于抽象。这个原则有助于解耦软件模块，使系统更加模块化、灵活，并且更容易维护。
- en: What does that practically mean? It means that we should inject an instance
    of `BookmarkService` into the `ExportCommand` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着什么？这意味着我们应该将 `BookmarkService` 实例注入到 `ExportCommand` 类中。
- en: Let’s do this!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始做吧！
- en: Step 5 – applying the dependency inversion principle
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5步 – 应用依赖倒置原则
- en: If you are familiar with the dependency inversion principle, you will certainly
    have already noticed that the `BookmarkService` class does not implement any interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉依赖倒置原则，你肯定会已经注意到 `BookmarkService` 类没有实现任何接口。
- en: Let’s start by fixing this.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解决这个问题。
- en: I am not familiar with the dependency inversion principle!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我对依赖倒置原则不太熟悉！
- en: If you are not, there are plenty of great resources to explore this principle.
    It is not a complicated principle to understand, and quite frankly, after you
    learn about it, it will seem so obvious to you that you will be wondering why
    you did not know about it earlier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，有很多优秀的资源可以探索这个原则。这并不是一个难以理解的原则，坦白说，在你了解它之后，它将显得如此明显，以至于你会 wonder 为什么你之前不知道它。
- en: A great explanation of that principle can be found at [https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/](https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 [https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/](https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/)
    找到该原则的出色解释。
- en: I highly encourage you to go and review the implementation of the `BookmarkService`
    service before and after applying the dependency inversion principle in order
    to have a clear understanding of the benefits.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你在应用依赖倒置原则之前和之后审查 `BookmarkService` 服务的实现，以便对它的好处有清晰的理解。
- en: Back to our project structure discussion, we will start by creating a new folder
    called `Services` that will group all our services classes. Within that folder,
    let’s create a specific folder for every service. In our case, we only have one
    service, so let’s create the `BookmarkService` folder. This folder will contain
    both the interface and the concrete implementation of our service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们关于项目结构讨论的话题，我们首先将创建一个名为 `Services` 的新文件夹，用于组织我们所有的服务类。在这个文件夹内，为每个服务创建一个特定的文件夹。在我们的例子中，我们只有一个服务，所以让我们创建
    `BookmarkService` 文件夹。这个文件夹将包含我们服务的接口和具体实现。
- en: 'The folder structure for our service will then look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们服务的文件夹结构将如下所示：
- en: '![Figure 8.5 – The folder structure for the BookmarkService service](img/B22400_08_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – `BookmarkService` 服务的文件夹结构](img/B22400_08_05.jpg)'
- en: Figure 8.5 – The folder structure for the BookmarkService service
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – `BookmarkService` 服务的文件夹结构
- en: 'Next, let’s extract the `IBookmarkService` interface out of the `BookmarkService`
    class. The code for that interface looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 `IBookmarkService` 接口从 `BookmarkService` 类中提取出来。该接口的代码如下：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s make the `BookmarkService` class implement the `IBookmarkService`
    interface:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让 `BookmarkService` 类实现 `IBookmarkService` 接口：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we changed the namespace name for these artifacts in order to better
    convey their intention.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为了更好地传达它们的意图，已经更改了这些实体的命名空间名称。
- en: 'All that is left to do now is to inject that service into the `ExportCommand`
    class. This means two things:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的工作就是将该服务注入到 `ExportCommand` 类中。这意味着两件事：
- en: We will add a `private` property of the `IBookmarkService` type in the `ExportCommand`
    class that will allow us to invoke the methods of that service from within the
    command class (more specifically, from within the `OnExportCommand` method).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在 `ExportCommand` 类中添加一个 `private` 类型的 `IBookmarkService` 属性，这将允许我们在命令类内部（更具体地说，在
    `OnExportCommand` 方法内部）调用该服务的方法。
- en: We will inject an instance of that service through a constructor parameter.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过构造函数参数注入该服务的实例。
- en: 'The updated code of the `ExportCommand` class looks like this now:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExportCommand`类的更新代码现在看起来是这样的：'
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code is very straightforward to understand and does not require any particular
    explanation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常容易理解，不需要任何特别的解释。
- en: The dependency inversion principle may introduce complexity!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则可能会引入复杂性！
- en: Dependency injection can introduce some overhead in simple applications by requiring
    additional setup and configuration, such as adding extra interfaces, classes,
    and indirection, which can be unnecessary for straightforward projects with few
    dependencies.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入可能会通过需要额外的设置和配置（例如添加额外的接口、类和间接引用）在简单应用中引入一些开销，这对于依赖较少的简单项目可能是多余的。
- en: Therefore, it is important to find a balance between applying this principle
    without adding too much complexity to the code base.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，找到在不给代码库增加太多复杂性的情况下应用此原则的平衡是很重要的。
- en: That is wonderful. We have come a long way since we started our refactoring
    journey!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太好了。自从我们开始重构之旅以来，我们已经走了很长的路！
- en: 'There is one last piece of code we haven’t refactored yet. It is the one for
    which we started this journey in the first place: the `Program` class.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还有最后一段代码我们没有重构，这就是我们最初开始这段旅程的原因：`Program`类。
- en: Let’s turn our attention to this class now…
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在将注意力转向这个类…
- en: Step 6 – refactoring the Program class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6步 - 重构`Program`类
- en: By refactoring the commands into their dedicated classes, the code to create
    and handle these commands will be removed from the `Program` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将命令重构到它们各自的类中，创建和处理这些命令的代码将从`Program`类中移除。
- en: 'Hence, the `Program` class will now only be used to compose our application.
    More specifically, the `Program` class will do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Program`类现在将仅用于组合我们的应用程序。更具体地说，`Program`类将执行以下操作：
- en: Instantiate the root command and register its subcommands.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化根命令并注册其子命令。
- en: Instantiate and configure the `CommandLineBuilder` class and start the program.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化和配置`CommandLineBuilder`类，并启动程序。
- en: Configure logging.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置日志。
- en: Configure dependency injection of the `BookmarkService` service.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`BookmarkService`服务的依赖注入。
- en: 'Here is the refactored code for the `Program` class (note that some parts of
    the code, including `using` statements, are not listed here for brevity and clarity):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Program`类的重构代码（请注意，为了简洁和清晰，这里没有列出代码的部分，包括`using`语句）：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code is mostly straightforward to understand.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码主要很容易理解。
- en: 'The only part that is worth an explanation is how we perform dependency injection
    of services (here, with `BookmarkService`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 值得解释的唯一部分是我们如何执行服务的依赖注入（这里使用`BookmarkService`）：
- en: We declare a variable of the `IBookmarkService` type that will be used to retrieve
    an instance of the injected service.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明了一个`IBookmarkService`类型的变量，该变量将用于检索注入的服务实例。
- en: We configure the dependency injection by leveraging the `HostBuilder` class
    provided by .NET and registering services to the `IServiceCollection` collection.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过利用.NET提供的`HostBuilder`类并注册服务到`IServiceCollection`集合来配置依赖注入。
- en: We retrieve the instance of the registered services by calling `GetRequiredService`
    on the `IServiceCollection` collection and store a reference to the retrieved
    service into the variable we declared earlier.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过在`IServiceCollection`集合上调用`GetRequiredService`来检索已注册的服务实例，并将检索到的服务引用存储到我们之前声明的变量中。
- en: When creating an instance of a new command, we pass that variable as a parameter
    to the command’s constructor so that the new command receives an instance of the
    service.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建新命令的实例时，我们将该变量作为参数传递给命令的构造函数，以便新命令接收服务实例。
- en: And voila! The service is automatically instantiated and injected into the various
    commands that require it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！服务被自动实例化并注入到需要它的各种命令中。
- en: What’s great about this approach is that if we need to change the service implementation,
    all we need to do is modify the service registration to `IServiceCollection` and
    the rest will be magically taken care of.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，如果我们需要更改服务实现，我们只需修改服务注册到`IServiceCollection`，其余的将神奇地得到处理。
- en: Note how the `Program.cs` file has shrunk from 479 lines of code to 115 lines
    of code!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`Program.cs`文件从479行代码缩减到了115行代码！
- en: 'And the best part? Registering a new command to the root command is a matter
    of one extra line of code (aka, calling `AddCommand` on the root command and passing
    an instance of the new command to be registered), while injecting a new service
    is a matter of two lines of code: one for adding the service into the services
    collection and the other for getting a reference to that service in order to pass
    it to classes that require it.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是？将新命令注册到根命令只需要一行额外的代码（即，在根命令上调用`AddCommand`并传递要注册的新命令的实例），而注入新服务只需要两行代码：一行用于将服务添加到服务集合中，另一行用于获取该服务的引用以便传递给需要它的类。
- en: Beware of the pitfalls!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 小心陷阱！
- en: Common pitfalls in dependency injection include circular dependencies, where
    classes depend on each other, and unintended singleton behavior, which can arise
    from improper service lifetimes. Over-injection of dependencies can violate the
    Single-Responsibility Principle, while excessive reliance on service locators
    complicates testing. To avoid these issues, it’s crucial to manage service lifetimes
    carefully and follow best practices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的常见陷阱包括循环依赖，其中类相互依赖，以及由于服务生命周期不当而可能出现的意外单例行为。过度注入依赖项可能会违反单一职责原则，而过度依赖服务定位器会复杂化测试。为了避免这些问题，仔细管理服务生命周期并遵循最佳实践至关重要。
- en: I highly recommend that you check out the reading recommendations in [*Chapter
    14*](B22400_14.xhtml#_idTextAnchor236) in order to explore this topic more deeply
    when necessary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您查看[第 14 章](B22400_14.xhtml#_idTextAnchor236)中的阅读推荐，以便在需要时更深入地探索这个主题。
- en: Step 7 – running the program
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 步 – 运行程序
- en: Perfect! We have completed the refactoring of the `export` command. Let’s run
    the code to ensure that it still works as expected.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！我们已经完成了`export`命令的重构。让我们运行代码以确保它仍然按预期工作。
- en: 'The syntax to invoke the `export` command hasn’t changed. So, let’s invoke
    it the same way as before by typing the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`export`命令的语法没有变化。所以，让我们像以前一样通过输入以下内容来调用它：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will get the following results:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下结果：
- en: '![Figure 8.6 – Invoking the export command after refactoring](img/B22400_08_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 修改后调用导出命令](img/B22400_08_06.jpg)'
- en: Figure 8.6 – Invoking the export command after refactoring
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 修改后调用导出命令
- en: Wonderful! The application still works as expected.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！应用程序仍然按预期工作。
- en: We have done a lot of refactoring to our application so far. But is that all?
    Or can we take it to another level?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对我们的应用程序进行了大量的重构。但这就是全部吗？或者我们可以将其提升到另一个层次？
- en: Taking refactoring to new heights
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将重构提升到新的高度
- en: You may have been wondering why we didn’t extract options and handler methods
    into their own code artifacts (such as classes).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们没有将选项和处理器方法提取到它们自己的代码工件（如类）中。
- en: The reason is that options and handler methods (and also arguments) are usually
    unique to a specific command. For this reason, they are defined in the command
    class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是选项和处理器方法（以及参数）通常对特定命令是唯一的。因此，它们在命令类中定义。
- en: However, in situations where they would need to be used by more than one command,
    we would have extracted them into their own code artifact. This reasoning is important
    to keep in mind in order to avoid over-complexifying our design by over-abstracting
    it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在它们需要被多个命令使用的情况下，我们会将它们提取到它们自己的代码工件中。记住这个推理很重要，以避免通过过度抽象而使我们的设计过于复杂化。
- en: 'In the case of an option, we would have created a dedicated class. Here’s an
    example of `outputfileOption` we used in our `ExportCommand` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项的情况下，我们会创建一个专用类。以下是我们`ExportCommand`类中使用的`outputfileOption`的示例：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We could then use this option in any command by creating an instance of it,
    as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此选项在任何命令中，通过创建其实例，如下所示：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is how it would have looked for `ExportCommand`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`ExportCommand`可能看起来像的样子：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Pay special attention to how the `outputfileOption` property is declared (in
    the `Options` region) and how it is instantiated and initialized in the constructor.
    Its usage is no different from before.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意`outputfileOption`属性是如何声明的（在`Options`区域）以及它如何在构造函数中实例化和初始化。它的使用方式与之前没有不同。
- en: In the case of a handler method, we would have created a base class that derives
    from `Command` (let’s call it `CommandWithBaseHandler`), add the handler method
    to it (allowing it to be overridden), and make our command classes derive from
    that `CommandWithBaseHandler` class rather than from the `Command` class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理方法的情况下，我们会创建一个从`Command`派生的基类（让我们称它为`CommandWithBaseHandler`），向其中添加处理方法（允许它被覆盖），并使我们的命令类从那个`CommandWithBaseHandler`类派生，而不是从`Command`类派生。
- en: 'The `CommandWithBaseHandler` class could have looked like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`CommandWithBaseHandler`类可能看起来是这样的：'
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `OnExportCommand` method has been marked as `virtual`. This
    means that it provides a default implementation in the `CommandWithBaseHandler`
    class but allows that implementation to be overridden if needed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`OnExportCommand`方法已被标记为`virtual`。这意味着它提供了`CommandWithBaseHandler`类中的默认实现，但如果需要，允许该实现被覆盖。
- en: 'We could then have modified the `ExportCommand` class as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照以下方式修改`ExportCommand`类：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Perfect! But where would these new code artifacts fit into our project structure?
    Great question!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！但这些新的代码组件将如何融入我们的项目结构中？这是一个很好的问题！
- en: Let’s update our project structure to accommodate these new artifacts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的项目结构以适应这些新的组件。
- en: Updating the project structure
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新项目结构
- en: 'Following the same principle regarding project structure that we applied so
    far, I suggest the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照迄今为止应用的项目结构原则，我建议以下做法：
- en: '![Figure 8.7 – The project structure for commands](img/B22400_08_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 命令的项目结构](img/B22400_08_07.jpg)'
- en: Figure 8.7 – The project structure for commands
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 命令的项目结构
- en: Awesome! We now have an application that is more modular and easily extensible.
    Everything has its own place so it’s easier to read and navigate the application’s
    code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有一个更加模块化和易于扩展的应用程序。一切都有其合适的位置，这使得阅读和导航应用程序的代码变得更加容易。
- en: Wait, extensible?!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，可扩展？！
- en: You may not have noticed, but the refactoring exercise we have done throughout
    this chapter not only enhanced our application from a modularity standpoint but
    also from an extensibility standpoint.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有注意到，但我们在这章中进行的重构不仅从模块化的角度增强了我们的应用程序，还从可扩展性的角度进行了增强。
- en: 'Think about it: we can now easily involve other teammates in the development
    of our application, making delivering new features to our users even faster.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：我们现在可以轻松地让其他团队成员参与到我们应用程序的开发中，使得向用户交付新特性变得更加迅速。
- en: Every team member can focus on their very own command, impacting only a small
    subset of code artifacts and, in most cases, they won’t modify the same files,
    reducing the number of merge conflicts that may occur when pushing their code
    into the source control.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每个团队成员都可以专注于他们自己的命令，这只会影响一小部分代码组件，在大多数情况下，他们不会修改相同的文件，这减少了在将代码推送到源代码控制时可能发生的合并冲突的数量。
- en: This refactoring also allows to speed up the onboarding process of new team
    members. Since every code artifact has its proper place, the code is easier to
    understand and to own. If you are looking for contributors to your application,
    this is a very important point to keep in mind!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这次重构还允许加快新团队成员的入职流程。由于每个代码组件都有其合适的位置，代码更容易理解和掌握。如果你正在寻找为你的应用程序贡献者，这是一个非常重要的点需要记住！
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we refactored *Bookmarkr* to make it more modular. Each command
    is now described in its own code file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重构了*Bookmarkr*使其更加模块化。现在每个命令都有其自己的代码文件进行描述。
- en: By taking the time to refactor our CLI application, we have greatly enhanced
    its readability, maintainability, testability, and extensibility. It is now easier
    to add new capabilities, such as new commands (of course) as well as new features
    to existing commands.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过花时间重构我们的命令行应用程序，我们极大地提高了其可读性、可维护性、可测试性和可扩展性。现在添加新功能，例如新的命令（当然）以及现有命令的新特性，都变得更加容易。
- en: Speaking about that, in the next chapter, we will see how to call external services
    and APIs to extend the capabilities of our application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，在下一章中，我们将看到如何调用外部服务和API来扩展我们应用程序的功能。
- en: Your turn!
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮到你了！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过跟随提供的代码进行实践是一种很好的学习方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下特性来改进*Bookmarkr*应用程序。
- en: 'Task #1 – refactor the remaining commands'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务#1 – 重构剩余的命令
- en: Even though this chapter proposes only one challenge, it will require effort
    on your side!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章只提出了一个挑战，但它将需要你付出努力！
- en: Throughout the pages of this chapter, we have refactored the `export` command.
    You are now tasked with refactoring the other commands of the *Bookmarkr* application.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的每一页中，我们都重构了`export`命令。现在，你被要求重构*Bookmarkr*应用程序的其他命令。
- en: For that matter, you can follow the same strategy and steps we used in our previous
    refactoring activity. By practicing it again and again, you will gain mastery
    of this process.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，你可以遵循我们在之前的重构活动中使用的相同策略和步骤。通过反复练习，你将掌握这一过程。
- en: You will find the version of the code that hasn’t been refactored in the `Program.Unrefactored.cs`
    file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Program.Unrefactored.cs`文件中找到尚未重构的代码版本。
- en: Let’s do this!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
