<html><head></head><body>
<div id="_idContainer011">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Introduction to Microservices – the Big Picture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Microservices are being featured in every avenue of software development. </span><span class="koboSpan" id="kobo.3.2">Microservices are a software development style that has been touted to increase development speed and efficiency while improving software scalability and delivery. </span><span class="koboSpan" id="kobo.3.3">This development technique is not unique to any stack and has become extremely popular in Java, .NET, and JavaScript (Node JS) development. </span><span class="koboSpan" id="kobo.3.4">While the use of microservices is seen as a pattern, there are several subpatterns that are employed to ensure that the code base is as effective as possible.</span></p>
<p><span class="koboSpan" id="kobo.4.1">This chapter is the first of this 15-chapter book, which will cover design patterns used in microservices. </span><span class="koboSpan" id="kobo.4.2">We will be focusing on implementing them using the .NET Core development stack, and you will learn how code can be written and deployed. </span><span class="koboSpan" id="kobo.4.3">You will learn about design and coding patterns, third-party tools and environments, and best practices for handling certain scenarios in application development with microservices.</span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we are going to cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.6.1">A deep dive into microservices and its key elements</span></li>
<li><span class="koboSpan" id="kobo.7.1">Assessing the business need for microservices</span></li>
<li><span class="koboSpan" id="kobo.8.1">Determining the feasibility of implementing microservices</span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.9.1">A deep dive into microservices and its key elements</span></h1>
<p><span class="koboSpan" id="kobo.10.1">Traditionally, in </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.11.1">software</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.12.1"> development, applications have developed as a single unit or </span><em class="italic"><span class="koboSpan" id="kobo.13.1">monolith</span></em><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">All of the components are tightly coupled, and a change to one component threatens to have rippling effects throughout the code base and functionality. </span><span class="koboSpan" id="kobo.14.3">This makes long-term maintenance a major concern and can hinder developers from rolling out updates quickly.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Microservices will have you assess that monolith, break it into smaller and more perceivable applications. </span><span class="koboSpan" id="kobo.15.2">Each application will relate to a subsection of the larger project, which is a called </span><em class="italic"><span class="koboSpan" id="kobo.16.1">domain</span></em><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">We will then develop and maintain the code base per application as independent units. </span><span class="koboSpan" id="kobo.17.3">Typically, microservices are developed as APIs and may or may not interact with each other to complete operations being carried by users through a unifying user interface. </span><span class="koboSpan" id="kobo.17.4">Typically, the microservice architecture comprises a suite of small independent services, which communicate via </span><strong class="bold"><span class="koboSpan" id="kobo.18.1">HTTP</span></strong><span class="koboSpan" id="kobo.19.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.20.1">REST APIs</span></strong><span class="koboSpan" id="kobo.21.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.22.1">gRPC</span></strong><span class="koboSpan" id="kobo.23.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Google Remote Procedure Call</span></strong><span class="koboSpan" id="kobo.25.1">). </span><span class="koboSpan" id="kobo.25.2">The </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.26.1">general notion is that each microservice</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.27.1"> is </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.28.1">autonomous, has a limited scope, and aids in a collectively loosely coupled application.</span></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.29.1">Building a monolith</span></h2>
<p><span class="koboSpan" id="kobo.30.1">Let’s imagine </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.31.1">that we need to build a health facility management web application. </span><span class="koboSpan" id="kobo.31.2">We need to manage customer information, book appointments, generate invoices, and deliver test results to customers. </span><span class="koboSpan" id="kobo.31.3">If we were to itemize all the steps needed to build such an application, key development and scoping activities would include the following:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.32.1">Model the application, and scope the requirements for our customer onboarding, user profiles, and basic documents.</span></li>
<li><span class="koboSpan" id="kobo.33.1">Scope the requirements surrounding the process of booking an appointment with a particular doctor. </span><span class="koboSpan" id="kobo.33.2">Doctors have schedules and specialties, so we have to present the booking slots accordingly.</span></li>
<li><span class="koboSpan" id="kobo.34.1">Create a process flow for when a match is found between a customer and a doctor. </span><span class="koboSpan" id="kobo.34.2">Once a match is found, we need to do the following:</span><ol><li><span class="koboSpan" id="kobo.35.1">Book the doctor’s calendar slot</span></li><li><span class="koboSpan" id="kobo.36.1">Generate an invoice</span></li><li><span class="koboSpan" id="kobo.37.1">Potentially collect a payment for the visit</span></li><li><span class="koboSpan" id="kobo.38.1">Send email notifications to the customer, doctor, and other relevant personnel</span></li></ol></li>
<li><span class="koboSpan" id="kobo.39.1">Model a database (probably relational) to store all this information.</span></li>
<li><span class="koboSpan" id="kobo.40.1">Create user interfaces for each screen that both customers and the medical staff will use.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.41.1">All of this is developed as one application, with one frontend talking to one backend, one database, and one deployment environment. </span><span class="koboSpan" id="kobo.41.2">Additionally, we might throw in a few third-party API integrations for payment and email services. </span><span class="koboSpan" id="kobo.41.3">This can be load balanced and hosted across multiple servers to mitigate against downtime and increase responsiveness:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.42.1"><img alt="Figure 1.1 – Application building" src="image/Figure_1.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.43.1">Figure 1.1 – Application building</span></p>
<p><span class="koboSpan" id="kobo.44.1">However, this</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.45.1"> monolithic architecture introduces a few challenges:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.46.1">Attempts to extend functionality might have ripple effects through multiple modules and introduce new database and security needs.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.47.1">Potential solution</span></em><span class="koboSpan" id="kobo.48.1">: Perform thorough unit and integration testing.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.49.1">The development team runs the risk of becoming very dependent on a particular stack, making it more difficult to keep the code base modern.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.50.1">Potential solution</span></em><span class="koboSpan" id="kobo.51.1">: Implement proper versioning strategies and increment them as the technology changes.</span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">As the code base expands, it becomes more difficult to account for all of the moving parts.</span></li>
</ul>
<p><em class="italic"><span class="koboSpan" id="kobo.53.1">Potential solution</span></em><span class="koboSpan" id="kobo.54.1">: Use </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.55.1">clean architectural methods to keep the code base loosely coupled and modular.</span></p>
<p><span class="koboSpan" id="kobo.56.1">The reality is that we can overcome some of these challenges with certain architectural decisions. </span><span class="koboSpan" id="kobo.56.2">This all-in-one architecture has been the de facto standard, and frankly, it works. </span><span class="koboSpan" id="kobo.56.3">This project</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.57.1"> architecture is simple, easy enough to scope and develop, and is supported by most, if not all, development stacks and databases. </span><span class="koboSpan" id="kobo.57.2">We have been building them for so long that perhaps we have become oblivious to the real challenges that prevail as we try to extend and maintain them in the long term.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.58.1">Figure 1.2</span></em><span class="koboSpan" id="kobo.59.1"> shows the typical architecture of a monolithic application:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.60.1"><img alt="Figure 1.2 – One user interface is served by an API or code library with business logic and is serviced by one database" src="image/Figure_1.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.61.1">Figure 1.2 – One user interface is served by an API or code library with business logic and is serviced by one database</span></p>
<p><span class="koboSpan" id="kobo.62.1">Now that we have </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.63.1">explored the monolithic approach and its potential flaws, let us review a similar application built using microservices.</span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.64.1">Building microservices</span></h2>
<p><span class="koboSpan" id="kobo.65.1">Now, let us</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.66.1"> take the same application and conceptualize how it could be architected using microservices. </span><span class="koboSpan" id="kobo.66.2">During the design phase, we seek to identify the specific functionalities for each tranche of the application. </span><span class="koboSpan" id="kobo.66.3">This is where we identify our domains and subdomains; then, we begin to scope standalone services for each. </span><span class="koboSpan" id="kobo.66.4">For example, one domain could be customer management. </span><span class="koboSpan" id="kobo.66.5">This service will solely handle the user account and demographic information. </span><span class="koboSpan" id="kobo.66.6">Additionally, we could scope bookings and appointments, document management, and finally, payments. </span><span class="koboSpan" id="kobo.66.7">This then brings another issue to the foreground: we have dependencies between these three subdomains when we need service independence instead. </span><span class="koboSpan" id="kobo.66.8">Using </span><em class="italic"><span class="koboSpan" id="kobo.67.1">domain-driven design</span></em><span class="koboSpan" id="kobo.68.1">, we then scope out where there are dependencies and identify where we might need to duplicate certain entities. </span><span class="koboSpan" id="kobo.68.2">For instance, a customer needs representation in the booking and appointments database as well as payments. </span><span class="koboSpan" id="kobo.68.3">This duplication is required if we are using separate databases per service (which is strongly encouraged).</span></p>
<p><span class="koboSpan" id="kobo.69.1">The microservices require us to properly scope the flow of operations </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.70.1">that involve multiple services playing a part. </span><span class="koboSpan" id="kobo.70.2">For instance, when making a booking, we need to do the following:</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.71.1">Retrieve the customer making the booking.</span></li>
<li><span class="koboSpan" id="kobo.72.1">Ensure that the preferred time slot is available.</span></li>
<li><span class="koboSpan" id="kobo.73.1">If available, generate an invoice.</span></li>
<li><span class="koboSpan" id="kobo.74.1">Collect the payment.</span></li>
<li><span class="koboSpan" id="kobo.75.1">Confirm the appointment.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.76.1">That process alone has some back-and-forth processing between the services. </span><span class="koboSpan" id="kobo.76.2">Properly orchestrating these </span><em class="italic"><span class="koboSpan" id="kobo.77.1">service conversations</span></em><span class="koboSpan" id="kobo.78.1"> is very critical to having a seamless system and adequately replacing a monolithic approach. </span><span class="koboSpan" id="kobo.78.2">Therefore, we introduce various design patterns and approaches to implementing our code and infrastructure. </span><span class="koboSpan" id="kobo.78.3">Even though we break potentially complex operations and workflows into smaller and more perceivable chunks, we end up in the same position where the application needs to carry out a specific operation and carry out the original requirements as a whole.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.79.1">Figure 1.3</span></em><span class="koboSpan" id="kobo.80.1"> shows the typical architecture of a microservices application:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.81.1"><img alt="Figure 1.3 – Each microservice is standalone and unifies in a single user interface for user interactions" src="image/Figure_1.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.82.1">Figure 1.3 – Each microservice is standalone and unifies in a single user interface for user interactions</span></p>
<p><span class="koboSpan" id="kobo.83.1">Now that you are </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.84.1">familiar with the differences between the monolithic and microservices approaches, we can explore the pros and cons of using the microservices design pattern.</span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.85.1">Assessing the business need for microservices</span></h1>
<p><span class="koboSpan" id="kobo.86.1">As we have seen</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.87.1"> so far, microservices are not easy to author, and they come with many cross-cutting concerns and challenges. </span><span class="koboSpan" id="kobo.87.2">It is always important to ask yourself </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Why?</span></em><span class="koboSpan" id="kobo.89.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.90.1">Do I really need it?</span></em><span class="koboSpan" id="kobo.91.1"> before implementing any design patterns.</span></p>
<p><span class="koboSpan" id="kobo.92.1">At a high level, some benefits of this approach are listed as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.93.1">Scalability</span></li>
<li><span class="koboSpan" id="kobo.94.1">Availability</span></li>
<li><span class="koboSpan" id="kobo.95.1">Development speed</span></li>
<li><span class="koboSpan" id="kobo.96.1">Improved data storage</span></li>
<li><span class="koboSpan" id="kobo.97.1">Monitoring</span></li>
<li><span class="koboSpan" id="kobo.98.1">Deployment</span></li>
</ul>
<p><span class="koboSpan" id="kobo.99.1">In the following sections, we will dive into the details of each.</span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.100.1">Scalability</span></h2>
<p><span class="koboSpan" id="kobo.101.1">In the monolithic </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.102.1">approach, you scale all or nothing. </span><span class="koboSpan" id="kobo.102.2">In microservices, it is easier to scale individual parts of the application and address specific performance gaps as they arise. </span><span class="koboSpan" id="kobo.102.3">If a vaccine becomes widely available and customers are encouraged to book an appointment online, then we are sure to experience a large load during the first few weeks. </span><span class="koboSpan" id="kobo.102.4">Our customer microservice might not be too affected by that, but we will need to scale our booking and appointments and payments services.</span></p>
<p><span class="koboSpan" id="kobo.103.1">We can scale horizontally, which means that we can allocate more CPU and RAM when the load increases. </span><span class="koboSpan" id="kobo.103.2">Alternatively, we can scale vertically by spawning more instances of the service to be load balanced. </span><span class="koboSpan" id="kobo.103.3">The better method is relative to the service’s needs. </span><span class="koboSpan" id="kobo.103.4">Using the right hosting platforms and infrastructure allows us to automate this process.</span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.104.1">Availability</span></h2>
<p><span class="koboSpan" id="kobo.105.1">Availability means the </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.106.1">probability of a system being operational at a given time. </span><span class="koboSpan" id="kobo.106.2">This metric goes hand in hand with the ability to scale, but it also addresses the reliability of the underlying code base and hosting platform. </span><span class="koboSpan" id="kobo.106.3">The code base plays a big part in that, so we want to avoid, as much as possible, a single point of failure. </span><span class="koboSpan" id="kobo.106.4">A single point of failure affects the entire system if it fails at any point. </span><span class="koboSpan" id="kobo.106.5">For example, we will be </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.107.1">exploring the </span><em class="italic"><span class="koboSpan" id="kobo.108.1">gateway pattern</span></em><span class="koboSpan" id="kobo.109.1">, where we will aggregate all services behind one point of entry. </span><span class="koboSpan" id="kobo.109.2">For our distributed services to remain available, this gateway must be always online.</span></p>
<p><span class="koboSpan" id="kobo.110.1">This can be achieved by having vertical instances that balance the load and distribute the expected </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.111.1">responsiveness of the gateway and, by extension, the underlying services.</span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.112.1">Development speed</span></h2>
<p><span class="koboSpan" id="kobo.113.1">Given that the </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.114.1">application has been broken into domains, developers can focus their efforts on ensuring that their set of features is being developed efficiently. </span><span class="koboSpan" id="kobo.114.2">This also contributes to how quickly features can be added, tested, and deployed. </span><span class="koboSpan" id="kobo.114.3">It will now become a practical approach to have one team per subdomain. </span><span class="koboSpan" id="kobo.114.4">Additionally, it becomes much easier to scope the requirements for a domain and focus on fewer functional requirements for a piece of work. </span><span class="koboSpan" id="kobo.114.5">Each team can now be independent and own the service from development to deployment.</span></p>
<p><span class="koboSpan" id="kobo.115.1">This allows </span><em class="italic"><span class="koboSpan" id="kobo.116.1">Agile and DevOps</span></em><span class="koboSpan" id="kobo.117.1"> methodologies to be easier to implement, and it is easier to scope resource requirements per team. </span><span class="koboSpan" id="kobo.117.2">Of course, we have seen that services will still need to communicate, so we will still have to orchestrate the integration between the teams. </span><span class="koboSpan" id="kobo.117.3">So, while each team is independent, they will still need to make their code and documentation available and easy enough to access. </span><span class="koboSpan" id="kobo.117.4">Version control also becomes important since the services will be updated over time, but this must be a managed process.</span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.118.1">Improved data storage</span></h2>
<p><span class="koboSpan" id="kobo.119.1">Our monolithic </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.120.1">application uses one database for the entire application. </span><span class="koboSpan" id="kobo.120.2">There are situations where you might end up using one database for multiple microservices, but this is generally discouraged, and </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.121.1">a </span><em class="italic"><span class="koboSpan" id="kobo.122.1">database-per-service</span></em><span class="koboSpan" id="kobo.123.1"> approach is preferred. </span><span class="koboSpan" id="kobo.123.2">Services must be autonomous and independently developed, deployed, and scaled. </span><span class="koboSpan" id="kobo.123.3">This is best accomplished if each service has its own data storage. </span><span class="koboSpan" id="kobo.123.4">It makes even more sense when you consider that the type of data being stored might influence the type of data storage that is used. </span><span class="koboSpan" id="kobo.123.5">Each service might require a different type of data store, ranging from relational database </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.124.1">storage such as </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Microsoft SQL Server</span></strong><span class="koboSpan" id="kobo.126.1"> to document-based database storage such as </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">Azure Cosmos DB</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">We </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.129.1">want to ensure that changes to a data store will only affect the associated microservice.</span></p>
<p><span class="koboSpan" id="kobo.130.1">Of course, this will bring its own challenges where data will need to be synchronized across the services. </span><span class="koboSpan" id="kobo.130.2">In the monolith, we could wrap all steps inside one transaction, which might lead to performance issues for potentially long-running processes. </span><span class="koboSpan" id="kobo.130.3">With microservices, we face the challenge of orchestrating distributed transactions, which also introduces performance risks and threatens the immediate consistency of our data. </span><span class="koboSpan" id="kobo.130.4">At this point, we must turn to the</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.131.1"> concept of </span><em class="italic"><span class="koboSpan" id="kobo.132.1">eventual consistency</span></em><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">This means that a service publishes an event when its data changes and subscribing services use that event as a signal to update their own data. </span><span class="koboSpan" id="kobo.133.3">This approach is made possible through event-sourcing patterns. </span><span class="koboSpan" id="kobo.133.4">We accept the risk that, for a period, data might be inconsistent across subdomains. </span><span class="koboSpan" id="kobo.133.5">Message</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.134.1"> queue </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.135.1">systems</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.136.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Kafka</span></strong><span class="koboSpan" id="kobo.138.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.139.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.140.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.142.1"> are</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.143.1"> generally used to accomplish this.</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.144.1">Monitoring</span></h2>
<p><span class="koboSpan" id="kobo.145.1">One of the most important </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.146.1">aspects of a distributed system is monitoring. </span><span class="koboSpan" id="kobo.146.2">This allows us to proactively ensure uptime and mitigate against failures. </span><span class="koboSpan" id="kobo.146.3">We need to be able to view the health of our service instances. </span><span class="koboSpan" id="kobo.146.4">We also begin to think about how we can centralize logs and performance metrics in a unified manner, sparing us the task of going to each environment manually. </span><span class="koboSpan" id="kobo.146.5">Tools </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.147.1">such</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.148.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Kibana</span></strong><span class="koboSpan" id="kobo.150.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Grafana</span></strong><span class="koboSpan" id="kobo.152.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Splunk</span></strong><span class="koboSpan" id="kobo.154.1"> allow us to</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.155.1"> create a rich dashboard and visualize all sorts of information about our services.</span></p>
<p><span class="koboSpan" id="kobo.156.1">One very important bit of information is a </span><em class="italic"><span class="koboSpan" id="kobo.157.1">health check</span></em><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">Sometimes, a microservice instance can be running but is failing to handle requests. </span><span class="koboSpan" id="kobo.158.3">For example, it might have run out of database connections. </span><span class="koboSpan" id="kobo.158.4">With health checks, we can see a quick snapshot of the service’s health and have that data point returned to the dashboard.</span></p>
<p><span class="koboSpan" id="kobo.159.1">Logging is also a crucial tool for monitoring and troubleshooting. </span><span class="koboSpan" id="kobo.159.2">Typically, each microservice would write its own logs to files in its environment. </span><span class="koboSpan" id="kobo.159.3">From these logs, we can see information about errors, warnings, information, and debug messages. </span><span class="koboSpan" id="kobo.159.4">However, this is not efficient for a distributed system. </span><span class="koboSpan" id="kobo.159.5">At this point, we use a log aggregator. </span><span class="koboSpan" id="kobo.159.6">This gives us a central area to search and analyze the logs from the dashboards. </span><span class="koboSpan" id="kobo.159.7">There are a few log aggregators you</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.160.1"> can </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.161.1">choose from such as </span><strong class="bold"><span class="koboSpan" id="kobo.162.1">LogStash</span></strong><span class="koboSpan" id="kobo.163.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.164.1">Splunk</span></strong><span class="koboSpan" id="kobo.165.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.166.1">PaperTrail</span></strong><span class="koboSpan" id="kobo.167.1">.</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.168.1">Deployment</span></h2>
<p><span class="koboSpan" id="kobo.169.1">Each microservice </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.170.1">needs to be independently deployable and scalable. </span><span class="koboSpan" id="kobo.170.2">This includes all the security, data storage, and additional assets that our services use. </span><span class="koboSpan" id="kobo.170.3">They must all live on physical or virtual servers, whether on-premises or in the cloud. </span><span class="koboSpan" id="kobo.170.4">Ideally, each physical server will have its own memory, network, processing, and storage. </span><span class="koboSpan" id="kobo.170.5">A virtual infrastructure might have the same physical server with the appropriate resource allocations per service. </span><span class="koboSpan" id="kobo.170.6">Here, the idea is that each microservice instance is isolated from the other and will not compete for resources.</span></p>
<p><span class="koboSpan" id="kobo.171.1">Now, each microservice will need its own set of packages and supporting libraries. </span><span class="koboSpan" id="kobo.171.2">This then becomes another challenge when provisioning different machines (physical or virtual) and their operating systems. </span><span class="koboSpan" id="kobo.171.3">We then seek to simplify this by packaging each microservice as a container image and deploying it as a container. </span><span class="koboSpan" id="kobo.171.4">The container will then encapsulate the details of the technology used to build a service and provide all the CPU, memory, and microservice dependencies needed for operation. </span><span class="koboSpan" id="kobo.171.5">This makes the microservice easy to move between testing and production environments and provides environment consistency.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.172.1">Docker</span></strong><span class="koboSpan" id="kobo.173.1"> is the </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.174.1">go-to container management system and works hand in hand with container orchestration services. </span><span class="koboSpan" id="kobo.174.2">Orchestration becomes necessary to run multiple containers across multiple machines. </span><span class="koboSpan" id="kobo.174.3">We need to start the correct containers at the correct time, handle storage considerations, and address potential container failures. </span><span class="koboSpan" id="kobo.174.4">All of these tasks are not practical to handle manually, so we enlist the services of </span><strong class="bold"><span class="koboSpan" id="kobo.175.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.176.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.177.1">Docker Swarm</span></strong><span class="koboSpan" id="kobo.178.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.179.1">Marathon</span></strong><span class="koboSpan" id="kobo.180.1"> to automate these tasks. </span><span class="koboSpan" id="kobo.180.2">It is best to have all</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.181.1"> the </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.182.1">deployment </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.183.1">steps automated and be as cost-effective as possible.</span></p>
<p><span class="koboSpan" id="kobo.184.1">Then, we look to implement an integrated pipeline that can handle the continuous delivery of our services, with as minimal effort as possible, while maintaining the highest level of consistency possible.</span></p>
<p><span class="koboSpan" id="kobo.185.1">We have explored quite a bit in this section. </span><span class="koboSpan" id="kobo.185.2">We reviewed why we might consider using a microservices approach in our development efforts. </span><span class="koboSpan" id="kobo.185.3">Also, we investigated some of the most used technologies for this approach. </span><span class="koboSpan" id="kobo.185.4">Now, let us turn our attention to justifying our use of microservices.</span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.186.1">Determining the feasibility of implementing microservices</span></h1>
<p><span class="koboSpan" id="kobo.187.1">As we explore</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.188.1"> the microservices approach, we see where it does address certain things, while introducing a few more concerns. </span><span class="koboSpan" id="kobo.188.2">The microservices approach is certainly not a savior for your architectural challenges, and it introduces quite a few complexities. </span><span class="koboSpan" id="kobo.188.3">These concerns and complexities are generally addressed using design patterns, and using these patterns can save time and energy.</span></p>
<p><span class="koboSpan" id="kobo.189.1">Throughout this book, we will explore the most common problems we face and look at the design pattern concepts that help us to address these concerns. </span><span class="koboSpan" id="kobo.189.2">These patterns can be categorized as follows.</span></p>
<p><span class="koboSpan" id="kobo.190.1">Let us explore what each </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.191.1">pattern entails:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.192.1">Integration patterns</span></strong><span class="koboSpan" id="kobo.193.1">: We have </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.194.1">already discussed that microservices will need to communicate. </span><span class="koboSpan" id="kobo.194.2">Integration patterns serve to bring consistency to how we accomplish this. </span><span class="koboSpan" id="kobo.194.3">Integration patterns govern the technology and techniques that we use to accomplish cross-service communications.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.195.1">Database and storage design patterns</span></strong><span class="koboSpan" id="kobo.196.1">: We know that we are in for a challenge </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.197.1">when it comes to managing data across our </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.198.1">distributed services. </span><span class="koboSpan" id="kobo.198.2">Giving each service its own database seems easy until we need to ensure that data is kept consistent across the different data stores. </span><span class="koboSpan" id="kobo.198.3">There are certain patterns that are pivotal to us maintaining a level of confidence in what we see after each operation.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.199.1">Resiliency, security, and infrastructure patterns</span></strong><span class="koboSpan" id="kobo.200.1">: These patterns seek to bring</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.201.1"> calm </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.202.1">and </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.203.1">comfort to a brewing storm. </span><span class="koboSpan" id="kobo.203.2">With all the moving parts that we have identified, it is important to ensure that as many things as possible are automated and consistent in the deployment. </span><span class="koboSpan" id="kobo.203.3">Additionally, we want to ensure that security is adequately balanced between the system needs and a good user experience. </span><span class="koboSpan" id="kobo.203.4">These patterns help us to ensure that our systems are always performing at peak efficiency.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.204.1">Next, let us discuss using .NET Core as our development stack for microservices.</span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.205.1">Microservices and .NET Core</span></h2>
<p><span class="koboSpan" id="kobo.206.1">This book</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.207.1"> addresses implementing </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.208.1">microservices and design patterns using .NET Core. </span><span class="koboSpan" id="kobo.208.2">We have mentioned that this architectural style is platform agnostic and has been implemented using several frameworks. </span><span class="koboSpan" id="kobo.208.3">Comparably, however, ASP.NET Core makes microservices development very easy and offers many benefits, including cloud integrations, rapid development, and cross-platform support:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.209.1">Excellent tooling</span></strong><span class="koboSpan" id="kobo.210.1">: The SDK</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.211.1"> required for .NET development can be installed on any operating system. </span><span class="koboSpan" id="kobo.211.2">This is further complemented by their lightweight and open source development tool, </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">Visual Studio Code</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">You</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.214.1"> can easily create an API project by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">dotnet new webapi</span></strong><span class="koboSpan" id="kobo.216.1"> on your computer. </span><span class="koboSpan" id="kobo.216.2">If you prefer the fully powered Visual Studio IDE, then you might be limited to Windows and macOS. </span><span class="koboSpan" id="kobo.216.3">You will have all the tools you need to be successful regardless of the operating system.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.217.1">Stability</span></strong><span class="koboSpan" id="kobo.218.1">: At the time of writing this book, the latest stable version is </span><em class="italic"><span class="koboSpan" id="kobo.219.1">.NET 7</span></em><span class="koboSpan" id="kobo.220.1">, with standard term support. </span><span class="koboSpan" id="kobo.220.2">The .NET development team is always pushing the envelope and ensuring that reverse compatibility is maintained with each major version release. </span><span class="koboSpan" id="kobo.220.3">This makes updating to the next version much less difficult, and you need not worry about too many breaking changes all at once.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.221.1">Containerization and scaling</span></strong><span class="koboSpan" id="kobo.222.1">: ASP.NET Core applications can easily be mounted on a </span><em class="italic"><span class="koboSpan" id="kobo.223.1">Docker</span></em><span class="koboSpan" id="kobo.224.1"> container, and while this is not necessarily new, we can all appreciate a guaranteed render speed and quality. </span><span class="koboSpan" id="kobo.224.2">We can also leverage Kubernetes and easily scale our microservices using all the features of K8s.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.225.1">.NET development</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.226.1"> has come a long way, and</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.227.1"> these are exciting times to push the boundaries of what we can build, using their tools and services.</span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.228.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.229.1">By now, I hope you have a better idea of what microservices are, why you may or may not end up using this architectural style, and the importance of using design patterns. </span><span class="koboSpan" id="kobo.229.2">In each of the chapters of this book, we will explore how to use design patterns to develop a </span><em class="italic"><span class="koboSpan" id="kobo.230.1">solid</span></em><span class="koboSpan" id="kobo.231.1"> and reliable system based on microservices, using .NET Core and various supporting technologies.</span></p>
<p><span class="koboSpan" id="kobo.232.1">We will remain realistic and explore the pros and cons of each of our design decisions and explore how various technologies play integral parts in helping us to tie it all together.</span></p>
<p><span class="koboSpan" id="kobo.233.1">In this chapter, we explored the differences between designing a monolith and microservices, assessed the feasibility of building microservices, and explored why .NET Core is an excellent choice for building microservices</span></p>
<p><span class="koboSpan" id="kobo.234.1">In the next chapter, we will look at implementing the </span><strong class="bold"><span class="koboSpan" id="kobo.235.1">Aggregator Pattern</span></strong><span class="koboSpan" id="kobo.236.1"> in our microservices application.</span></p>
</div>
</body></html>