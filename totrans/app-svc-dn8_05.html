<html><head></head><body>
  <div><h1 class="chapterNumber">5</h1>
    <h1 class="chapterTitle" id="_idParaDest-195">Multitasking and Concurrency</h1>
    <p class="normal">This chapter is about allowing multiple actions to occur at the same time to improve performance, scalability, and user productivity for the applications that you build.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bulletList">Understanding processes, threads, and tasks</li>
      <li class="bulletList">Running tasks asynchronously</li>
      <li class="bulletList">Synchronizing access to shared resources</li>
      <li class="bulletList">Understanding <code class="inlineCode">async</code> and <code class="inlineCode">await</code></li>
    </ul>
    <h1 class="heading-1" id="_idParaDest-196">Understanding processes, threads, and tasks</h1>
    <p class="normal">A <strong class="keyWord">process</strong>, with<a id="_idIndexMarker411"/> one example being each of the console applications we have created, has resources like memory and threads allocated to it.</p>
    <p class="normal">A <strong class="keyWord">thread</strong> executes <a id="_idIndexMarker412"/>your code statement by statement. By default, each process only has one thread, and this can cause problems when we need to do more than one task at the same time. Threads are also responsible for keeping track of things like the currently authenticated user and any internationalization rules that should be followed for the current language and region.</p>
    <p class="normal">Windows and most other modern operating systems <a id="_idIndexMarker413"/>use <strong class="keyWord">preemptive multitasking</strong>, which simulates the parallel execution of tasks. It divides the processor time among the threads, allocating a <strong class="keyWord">time slice</strong> to<a id="_idIndexMarker414"/> each thread one after another. The current thread is suspended when its time slice finishes. The processor then allows another thread to run for a time slice.</p>
    <p class="normal">When Windows switches from one thread to another, it saves the context of the thread and reloads the previously saved context of the next thread in the thread queue. This takes both time and resources to complete.</p>
    <p class="normal">As a developer, if <a id="_idIndexMarker415"/>you have a small number of complex pieces of work and you want complete control over them, then you could create and manage individual <code class="inlineCode">Thread</code> instances. If you have one main thread and multiple small pieces of work that can be executed in the background, then you can use the <code class="inlineCode">ThreadPool</code> class to add delegate instances that point to those pieces of work implemented as methods to a queue, and they will be automatically allocated to threads in the thread pool.</p>
    <p class="normal">In this chapter, we will use the <code class="inlineCode">Task</code> type to manage threads at a higher abstraction level.</p>
    <p class="normal">Threads may have to compete for and wait for access to shared resources, such as variables, files, and database objects. There are types for managing this that you will see in action later in this chapter.</p>
    <p class="normal">Depending on the task, doubling the number of threads (workers) to perform a task does not halve the number of seconds that it will take to complete that task. In fact, it can increase the duration of the task due to resource contention, as shown in <em class="italic">Figure 5.1</em>:</p>
    <figure class="mediaobject"><img alt="" src="img/B19587_05_01.png"/></figure>
    <p class="packt_figref">Figure 5.1: A tweet about tasks in the real world</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Never assume that more threads will improve performance! Run performance tests on a baseline code implementation without multiple threads, and then again on a code implementation with multiple threads. You should also perform performance tests in a staging environment that is as close as possible to the production environment.</p>
    </div>
    <h1 class="heading-1" id="_idParaDest-197">Running tasks asynchronously</h1>
    <p class="normal">To understand <a id="_idIndexMarker416"/>how multiple tasks can be run <strong class="keyWord">simultaneously</strong> (at the same time), we will create a console app that needs to execute three methods.</p>
    <p class="normal">There will be three methods that need to be executed: the first takes 3 seconds, the second takes 2 seconds, and the third takes 1 second. To simulate that work, we can use the <code class="inlineCode">Thread</code> class to tell the current thread to go to sleep for a specified number of milliseconds.</p>
    <h2 class="heading-2" id="_idParaDest-198">Running multiple actions synchronously</h2>
    <p class="normal">Before <a id="_idIndexMarker417"/>we make the tasks run simultaneously, we will run them <strong class="keyWord">synchronously</strong>, that is, one after the other:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use your preferred code editor to add a console app project, as defined in the following list:<ul>
          <li class="bulletList">Project template: <strong class="screenText">Console App</strong> / <code class="inlineCode">console</code></li>
          <li class="bulletList">Solution file and folder: <code class="inlineCode">Chapter05</code></li>
          <li class="bulletList">Project file and folder: <code class="inlineCode">WorkingWithTasks</code></li>
          <li class="bulletList"><strong class="screenText">Do not use top-level statements</strong>: Cleared.</li>
          <li class="bulletList"><strong class="screenText">Enable native AOT publish</strong>: Cleared.</li>
        </ul>
      </li>
      <li class="numberedList">In the <code class="inlineCode">WorkingWithTasks</code> project, globally and statically import the <code class="inlineCode">System.Console</code> class and treat warnings as errors.</li>
      <li class="numberedList">In the <code class="inlineCode">WorkingWithTasks</code> project, add a new class file named <code class="inlineCode">Program.Helpers.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.Helpers.cs</code>, delete any existing statements, and then define a partial <code class="inlineCode">Program</code> class with methods to output a section title and a task title, and to <a id="_idIndexMarker418"/>output information about the current thread, each in different colors to make them easier to identify in output, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">partial class Program
{
  private static void SectionTitle(string title)
  {
    ConsoleColor previousColor = ForegroundColor;
    ForegroundColor = ConsoleColor.DarkYellow;
    WriteLine($"*** {title}");
    ForegroundColor = previousColor;
  }
  private static void TaskTitle(string title)
  {
    ConsoleColor previousColor = ForegroundColor;
    ForegroundColor = ConsoleColor.Green;
    WriteLine($"{title}");
    ForegroundColor = previousColor;
  }
  private static void OutputThreadInfo()
  {
    Thread t = Thread.CurrentThread;
    ConsoleColor previousColor = ForegroundColor;
    ForegroundColor = ConsoleColor.DarkCyan;
    WriteLine(
      "Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}",
      t.ManagedThreadId, t.Priority, t.IsBackground, t.Name ?? "null");
    ForegroundColor = previousColor;
  }
}
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">WorkingWithTasks</code> project, add a new class file named <code class="inlineCode">Program.Methods.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.Methods.cs</code>, delete any existing statements, and then add three methods that simulate work, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">partial class Program
{
  private static void MethodA()
  {
    TaskTitle("Starting Method A...");
    OutputThreadInfo();
    Thread.Sleep(3000); // Simulate three seconds of work.
    TaskTitle("Finished Method A.");
  }
  private static void MethodB()
  {
    TaskTitle("Starting Method B...");
    OutputThreadInfo();
    Thread.Sleep(2000); // Simulate two seconds of work.
    TaskTitle("Finished Method B.");
  }
  private static void MethodC()
  {
    TaskTitle("Starting Method C...");
    OutputThreadInfo();
    Thread.Sleep(1000); // Simulate one second of work.
    TaskTitle("Finished Method C.");
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete<a id="_idIndexMarker419"/> the existing statements and then add statements to call the helper method to output information about the thread, define and start a stopwatch, call the three simulated work methods, and then output the milliseconds elapsed, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">using System.Diagnostics; // To use Stopwatch.
OutputThreadInfo();
Stopwatch timer = Stopwatch.StartNew();
SectionTitle("Running methods synchronously on one thread."); 
MethodA();
MethodB();
MethodC();
WriteLine($"{timer.ElapsedMilliseconds:#,##0}ms elapsed.");
</code></pre>
      </li>
      <li class="numberedList">Run <a id="_idIndexMarker420"/>the code, wait for all three methods to finish executing, and then review the result, noting that when there is only one unnamed foreground thread doing the work, the total time required is just over 6 seconds, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Thread Id: 1, Priority: Normal, Background: False, Name: null
*** Running methods synchronously on one thread.
Starting Method A...
Thread Id: 1, Priority: Normal, Background: False, Name: null
Finished Method A.
Starting Method B...
Thread Id: 1, Priority: Normal, Background: False, Name: null
Finished Method B.
Starting Method C...
Thread Id: 1, Priority: Normal, Background: False, Name: null
Finished Method C.
6,028ms elapsed.
</code></pre>
      </li>
    </ol>
    <h2 class="heading-2" id="_idParaDest-199">Running multiple actions asynchronously using tasks</h2>
    <p class="normal">The <code class="inlineCode">Thread</code> class<a id="_idIndexMarker421"/> has been available since the first version of .NET in 2002 and can be used to create new threads and manage them, but it can be tricky to work with directly.</p>
    <p class="normal">.NET Framework 4.0 introduced the <code class="inlineCode">Task</code> class in 2010, which represents an asynchronous operation. A task is a high-level abstraction around the operating system thread that performs the operation, and the <code class="inlineCode">Task</code> class enables easier creation and management of any underlying threads. Managing multiple threads wrapped in tasks will allow our code to execute at the same time, aka <strong class="keyWord">asynchronously</strong>.</p>
    <p class="normal">Each <code class="inlineCode">Task</code> has a <code class="inlineCode">Status</code> property and a <code class="inlineCode">CreationOptions</code> property. A <code class="inlineCode">Task</code> has a <code class="inlineCode">ContinueWith</code> method that can be customized with the <code class="inlineCode">TaskContinuationOptions</code> enum, and it can be managed with the <code class="inlineCode">TaskFactory</code> class.</p>
    <h2 class="heading-2" id="_idParaDest-200">Starting tasks</h2>
    <p class="normal">We will look at<a id="_idIndexMarker422"/> three ways to start the methods using <code class="inlineCode">Task</code> instances. There are links in the GitHub repository to articles that discuss the pros and cons. Each has a slightly different syntax, but they all define a <code class="inlineCode">Task</code> and start it:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, comment out the previous statements that call methods A to C, and then add statements to create and start three tasks, one for each method, as shown highlighted in the following code:
        <pre class="programlisting code"><code class="hljs-code">Stopwatch timer = Stopwatch.StartNew();
<strong class="hljs-comment-slc">/*</strong>
SectionTitle("Running methods synchronously on one thread.");
MethodA();
MethodB();
MethodC();
<strong class="hljs-comment-slc">*/</strong>
<strong class="hljs-slc">SectionTitle(</strong><strong class="hljs-string-slc">"Running methods asynchronously on multiple threads."</strong><strong class="hljs-slc">); </strong>
<strong class="hljs-slc">Task taskA = </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc">(MethodA);</strong>
<strong class="hljs-slc">taskA.Start();</strong>
<strong class="hljs-slc">Task taskB = Task.Factory.StartNew(MethodB); </strong>
<strong class="hljs-slc">Task taskC = Task.Run(MethodC);</strong>
WriteLine($"{timer.ElapsedMilliseconds:#,##0}ms elapsed.");
</code></pre>
      
    <div><p class="normal">Instead of commenting out the previous statements, you could let them run, but then make sure to call the <code class="inlineCode">timer.Restart()</code> method after outputting a new section title to reset the timings for each section.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Run the code, view the result, and note that the elapsed milliseconds appear almost immediately. This is because each of the three methods is now being executed by three new background worker threads allocated from<a id="_idIndexMarker423"/> the <strong class="keyWord">thread pool (TP)</strong>, as shown<a id="_idIndexMarker424"/> in the following output:
        <pre class="programlisting con"><code class="hljs-con">*** Running methods asynchronously on multiple threads.
Starting Method A...
Thread Id: 4, Priority: Normal, Background: True, Name: .NET TP Worker
Starting Method C...
Thread Id: 7, Priority: Normal, Background: True, Name: .NET TP Worker
Starting Method B...
Thread Id: 6, Priority: Normal, Background: True, Name: .NET TP Worker
6ms elapsed.
</code></pre>
      </li>
    </ol>
    <div><p class="normal">It is even likely that the console app will end before one or even all the tasks have a chance to start and write to the console!</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-201">Waiting for tasks</h2>
    <p class="normal">Sometimes, you <a id="_idIndexMarker425"/>need to wait for a task to complete before continuing. To do this, you can use the <code class="inlineCode">Wait</code> method on a <code class="inlineCode">Task</code> instance, or the <code class="inlineCode">WaitAll</code> or <code class="inlineCode">WaitAny</code> static methods on an array of tasks, as described in <em class="italic">Table 5.1</em>:</p>
    <table class="table-container" id="table001-3">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Method</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">t.Wait()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This waits for the task instance named <code class="inlineCode">t</code> to complete execution.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Task.WaitAny(Task[])</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This waits for any of the tasks in the array to complete execution.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Task.WaitAll(Task[])</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">This waits for all the tasks in the array to complete execution.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.1: Task class Wait methods</p>
    <h2 class="heading-2" id="_idParaDest-202">Using wait methods with tasks</h2>
    <p class="normal">Let’s see <a id="_idIndexMarker426"/>how we can use these wait methods to fix the problem with our console app:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">Program.cs</code>, after creating the three tasks and before outputting the elapsed time, add statements to combine references to the three tasks into an array and pass them to the <code class="inlineCode">WaitAll</code> method, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">Task[] tasks = { taskA, taskB, taskC };
Task.WaitAll(tasks);
</code></pre>
      </li>
      <li class="numberedList">Run <a id="_idIndexMarker427"/>the code and view the result, and note the original thread will pause on the call to <code class="inlineCode">WaitAll</code>, waiting for all three tasks to finish before outputting the elapsed time, which is a little over 3 seconds, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Starting Method A...
Starting Method B...
Thread Id: 4, Priority: Normal, Background: True, Name: .NET TP Worker
Thread Id: 6, Priority: Normal, Background: True, Name: .NET TP Worker
Starting Method C...
Thread Id: 7, Priority: Normal, Background: True, Name: .NET TP Worker
Finished Method C.
Finished Method B.
Finished Method A.
3,013ms elapsed.
</code></pre>
      </li>
    </ol>
    <p class="normal">The three new threads execute their code simultaneously, and they can potentially start in any order. <code class="inlineCode">MethodC</code> should finish first because it takes only 1 second, then <code class="inlineCode">MethodB</code>, which takes 2 seconds, and finally, <code class="inlineCode">MethodA</code>, because it takes 3 seconds.</p>
    <p class="normal">However, the actual CPU used has a big effect on the results. It is the CPU that allocates time slices to each process to allow them to execute their threads. You have no control over when the methods run.</p>
    <h2 class="heading-2" id="_idParaDest-203">Continuing with another task</h2>
    <p class="normal">If all three <a id="_idIndexMarker428"/>tasks can be performed at the same time, then waiting for<a id="_idIndexMarker429"/> all tasks to finish will be all we need to do. However, often, a task is dependent on the output from another task. To handle this scenario, we need to define <strong class="keyWord">continuation tasks</strong>.</p>
    <p class="normal">We will create some methods to simulate a call to a web service that returns a monetary amount, which then needs to be used to retrieve how many products cost more than that amount in a database. The result returned from the first method needs to be fed into the input <a id="_idIndexMarker430"/>of the second method. This time, instead of waiting for fixed amounts of time, we will use the <code class="inlineCode">Random</code> class to wait for a random interval between 2 and 4 seconds for each method call to simulate the work:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">Program.Methods.cs</code>, add two methods that simulate calling a web service and a database-stored procedure, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">private static decimal CallWebService()
{
  TaskTitle("Starting call to web service...");
  OutputThreadInfo();
  Thread.Sleep(Random.Shared.Next(2000, 4000));
  TaskTitle("Finished call to web service.");
  return 89.99M;
}
private static string CallStoredProcedure(decimal amount)
{
  TaskTitle("Starting call to stored procedure...");
  OutputThreadInfo();
  Thread.Sleep((Random.Shared.Next(2000, 4000));
  TaskTitle("Finished call to stored procedure.");
  return $"12 products cost more than {amount:C}.";
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, comment out the statements for the previous three tasks, and then add statements to start a task to call the web service and then pass its return value to a task that starts the database-stored procedure, as shown highlighted in the following code:
        <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-slc">SectionTitle(</strong><strong class="hljs-string-slc">"Passing the result of one task as an input into another."</strong><strong class="hljs-slc">); </strong>
<strong class="hljs-slc">Task&lt;</strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-slc">&gt; taskServiceThenSProc = Task.Factory</strong>
<strong class="hljs-slc">  .StartNew(CallWebService) </strong><strong class="hljs-comment-slc">// returns Task&lt;decimal&gt;</strong>
<strong class="hljs-slc">  .ContinueWith(previousTask =&gt; </strong><strong class="hljs-comment-slc">// returns Task&lt;string&gt;</strong>
<strong class="hljs-slc">    CallStoredProcedure(previousTask.Result));</strong>
<strong class="hljs-slc">WriteLine(</strong><strong class="hljs-string-slc">$"Result: </strong><strong class="hljs-subst-slc">{taskServiceThenSProc.Result}</strong><strong class="hljs-string-slc">"</strong><strong class="hljs-slc">);</strong>
WriteLine($"{timer.ElapsedMilliseconds:#,##0}ms elapsed.");
</code></pre>
      </li>
      <li class="numberedList">Run the code and view the result, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Starting call to web service...
Thread Id: 4, Priority: Normal, Background: True, Name: .NET TP Worker
Finished call to web service.
Starting call to stored procedure...
Thread Id: 6, Priority: Normal, Background: True, Name: .NET TP Worker
Finished call to stored procedure.
Result: 12 products cost more than £89.99.
5,463ms elapsed.
</code></pre>
      </li>
    </ol>
    <div><p class="normal">The currency symbol is culture-specific so on my computer it uses a £. On your computer it will use your culture. You will learn how to control cultures in <em class="chapterRef">Chapter 7</em>, <em class="italic">Handling Dates, Times, and Internationalization</em>.</p>
    </div>
    <p class="normal">You might see <a id="_idIndexMarker431"/>two different threads running the web service and stored procedure calls as in the output above (for example, threads 4 and 6), or the same thread might be reused since it is no longer busy.</p>
    <h2 class="heading-2" id="_idParaDest-204">Nested and child tasks</h2>
    <p class="normal">As well as defining <a id="_idIndexMarker432"/>dependencies between tasks, you can define nested and child tasks. A <strong class="keyWord">nested task</strong> is a <a id="_idIndexMarker433"/>task that is created inside another task. A <strong class="keyWord">child task</strong> is a <a id="_idIndexMarker434"/>nested task that must finish before its <a id="_idIndexMarker435"/>parent task is allowed to finish.</p>
    <p class="normal">Let’s explore how these types of tasks work:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">Program.Methods.cs</code>, add two methods, one of which starts a task to run the other, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">private static void OuterMethod()
{
  TaskTitle("Outer method starting...");
  Task innerTask = Task.Factory.StartNew(InnerMethod);
  TaskTitle("Outer method finished.");
}
private static void InnerMethod()
{
  TaskTitle("Inner method starting...");
  Thread.Sleep(2000);
  TaskTitle("Inner method finished.");
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, add statements to start a task to run the outer method and wait for it to finish before stopping, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">SectionTitle("Nested and child tasks");
Task outerTask = Task.Factory.StartNew(OuterMethod);
outerTask.Wait();
WriteLine("Console app is stopping.");
</code></pre>
      </li>
      <li class="numberedList">Run the <a id="_idIndexMarker436"/>code<a id="_idIndexMarker437"/> and view the result, as shown in <a id="_idIndexMarker438"/>the following<a id="_idIndexMarker439"/> output:
        <pre class="programlisting con"><code class="hljs-con">Outer method starting...
Inner method starting...
Outer method finished.
Console app is stopping.
</code></pre>
      
    <div><p class="normal">Although we wait for the outer task to finish, its inner task does not have to finish as well. In fact, the outer task might finish, and the console app could end before the inner task even starts, as shown in the following output:</p>
      <pre class="programlisting con"><code class="hljs-con">Outer method starting...
Outer method finished.
Console app is stopping.
</code></pre>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">To link these nested tasks as parent and child, we must use a special option. In <code class="inlineCode">Program.Methods.cs</code>, modify the existing code to add a <code class="inlineCode">TaskCreationOption</code> value of <code class="inlineCode">AttachedToParent</code>, as shown highlighted in the following code:
        <pre class="programlisting code"><code class="hljs-code">private static void OuterMethod()
{
  TaskTitle("Outer method starting...");
  Task innerTask = Task.Factory.StartNew(InnerMethod<strong class="hljs-slc">,</strong>
<strong class="hljs-slc">    TaskCreationOptions.AttachedToParent</strong>);
  TaskTitle("Outer method finished.");
}
</code></pre>
      </li>
      <li class="numberedList">Run the code, view the result, and note that the inner task must finish before the outer task can, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Outer method starting...
Inner method starting...
Outer method finished.
Inner method finished.
Console app is stopping.
</code></pre>
      </li>
      <li class="numberedList">Alternatively, the outer method could finish before the inner method starts, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Outer method starting...
Outer method finished.
Inner method starting...
Inner method finished.
Console app is stopping.
</code></pre>
      </li>
    </ol>
    <div><p class="normal">The <code class="inlineCode">OuterMethod</code> can finish its work before the <code class="inlineCode">InnerMethod</code>, as shown by what it writes to the console, but its task must wait, as shown by the console not stopping until both the outer and inner tasks finish.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-205">Wrapping tasks around other objects</h2>
    <p class="normal">Sometimes <a id="_idIndexMarker440"/>you might have a method that you want to be asynchronous, but the result to be returned is not itself a task. You can wrap the return value in a successfully completed task, return an exception, or indicate that the task was canceled by using one of the <code class="inlineCode">Task</code> static methods, as shown in <em class="italic">Table 5.2</em>:</p>
    <table class="table-container" id="table002-3">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Method</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">FromResult&lt;TResult&gt;(TResult)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Creates a <code class="inlineCode">Task&lt;TResult&gt;</code> object whose <code class="inlineCode">Result</code> property is the non-task result and whose <code class="inlineCode">Status</code> property is <code class="inlineCode">RanToCompletion</code>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">FromException&lt;TResult&gt;(Exception)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Creates a <code class="inlineCode">Task&lt;TResult&gt;</code> that’s completed with a specified exception.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">FromCanceled&lt;TResult&gt;(CancellationToken)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Creates a <code class="inlineCode">Task&lt;TResult&gt;</code> that’s completed due to cancellation with a specified cancellation token.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.2: Methods to create a Task in various scenarios </p>
    <p class="normal">These methods are useful when you need to:</p>
    <ul>
      <li class="bulletList">Implement an interface that has asynchronous methods, but your implementation is synchronous. This is common for websites and services.</li>
      <li class="bulletList">Mock asynchronous implementations during unit testing.</li>
    </ul>
    <p class="normal">Imagine that you need to create a method to validate XML input and the method must conform to an<a id="_idIndexMarker441"/> interface that requires a <code class="inlineCode">Task&lt;T&gt;</code> to be returned, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public interface IValidation
{
  Task&lt;bool&gt; IsValidXmlTagAsync(this string input);
}
</code></pre>
    <div><p class="normal">The code in this section is for illustration only. You do not need to enter it in your project.</p>
    </div>
    <p class="normal">We could use these helpful <code class="inlineCode">FromX</code> methods to return the results wrapped in a task, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">using System.Text.RegularExpressions;
namespace Packt.Shared;
public static class StringExtensions : IValidation
{
  public static Task&lt;bool&gt; IsValidXmlTagAsync(this string input)
  {
    if (input == null)
    {
      return Task.FromException&lt;bool&gt;(
        new ArgumentNullException($"Missing {nameof(input)} parameter"));
    }
    if (input.Length == 0)
    {
      return Task.FromException&lt;bool&gt;(
        new ArgumentException($"{nameof(input)} parameter is empty."));
    }
    return Task.FromResult(Regex.IsMatch(input,
      @"^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$"));
  }
}
</code></pre>
    <p class="normal">If the method you need to implement returns a <code class="inlineCode">Task</code> (equivalent to <code class="inlineCode">void</code> in a synchronous method), then<a id="_idIndexMarker442"/> you can return a predefined completed <code class="inlineCode">Task</code> object, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">public Task DeleteCustomerAsync()
{
  // ...
  return Task.CompletedTask;
}
</code></pre>
    <p class="normal">When running tasks in parallel, the code will often need to access resources, and those resources are sometimes shared between tasks and threads. We, therefore, need to learn how to safely access those shared resources.</p>
    <h1 class="heading-1" id="_idParaDest-206">Synchronizing access to shared resources</h1>
    <p class="normal">When you <a id="_idIndexMarker443"/>have multiple threads executing at the same time, there is a possibility that two or more of the threads may access the same variable or another resource at the same time, and as a result, may cause a problem. For this reason, you should carefully consider how to make your code <strong class="keyWord">thread-safe</strong>.</p>
    <p class="normal">The simplest mechanism for implementing thread safety is to use an object variable as a flag or traffic light to indicate when a shared resource has an exclusive lock applied.</p>
    <p class="normal">In William Golding’s <em class="italic">Lord of the Flies</em>, Piggy and Ralph find a conch shell and use it to call a meeting. The boys impose a “rule of the conch” on themselves, deciding that no one can speak unless they’re holding the conch.</p>
    <p class="normal">I like to name the object variable I use for implementing thread-safe code the “conch.” When a thread has the conch, no other thread should access the shared resource(s) represented by that conch. Note that I say <em class="italic">should</em>. Only code that respects the conch enables synchronized access. A conch is <em class="italic">not</em> a lock.</p>
    <p class="normal">We will explore a couple of types that can be used to synchronize access to shared resources:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">Monitor</code>: An object that can be used by multiple threads to check if they should access a shared resource within the same process.</li>
      <li class="bulletList"><code class="inlineCode">Interlocked</code>: An object for manipulating simple numeric types at the CPU level.</li>
    </ul>
    <h2 class="heading-2" id="_idParaDest-207">Accessing a resource from multiple threads</h2>
    <p class="normal">Let’s create a <a id="_idIndexMarker444"/>console app to explore sharing resources between multiple threads:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use your preferred code editor to add a new <strong class="screenText">Console App</strong> / <code class="inlineCode">console</code> project to the <code class="inlineCode">Chapter05</code> solution named <code class="inlineCode">SynchronizingResourceAccess</code>.</li>
      <li class="numberedList">Globally and statically import the <code class="inlineCode">System.Console</code> class and treat warnings as errors.</li>
      <li class="numberedList">Add a new class file named <code class="inlineCode">SharedObjects.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">SharedObjects.cs</code>, delete any existing statements and then define a static class with a field to store a message that is a shared resource, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">public static class SharedObjects
{
  public static string? Message; // a shared resource
}
</code></pre>
      </li>
      <li class="numberedList">Add a new class file named <code class="inlineCode">Program.Methods.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.Methods.cs</code>, delete any existing statements and then define two methods that both loop five times, waiting for a random interval of up to two seconds and appending either <code class="inlineCode">A</code> or <code class="inlineCode">B</code> to the shared message resource, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">partial class Program
{
  private static void MethodA()
  {
    for (int i = 0; i &lt; 5; i++)
    {
      // Simulate two seconds of work on the current thread.
      Thread.Sleep(Random.Shared.Next(2000));
      // Concatenate the letter "A" to the shared message.
      SharedObjects.Message += "A";
      // Show some activity in the console output.
      Write(".");
    }
  }
  private static void MethodB()
  {
    for (int i = 0; i &lt; 5; i++)
    {
      Thread.Sleep(Random.Shared.Next(2000));
      SharedObjects.Message += "B";
      Write(".");
    }
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete<a id="_idIndexMarker445"/> the existing statements. Add statements to import the namespace for diagnostic types like <code class="inlineCode">Stopwatch</code>, and statements to execute both methods on separate threads using a pair of tasks, and wait for them to complete before outputting the elapsed milliseconds, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">using System.Diagnostics; // To use Stopwatch.
WriteLine("Please wait for the tasks to complete.");
Stopwatch watch = Stopwatch.StartNew();
Task a = Task.Factory.StartNew(MethodA);
Task b = Task.Factory.StartNew(MethodB);
 
Task.WaitAll(new Task[] { a, b });
WriteLine();
WriteLine($"Results: {SharedObjects.Message}.");
WriteLine($"{watch.ElapsedMilliseconds:N0} elapsed milliseconds.");
</code></pre>
      </li>
      <li class="numberedList">Run the code and view the result, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Please wait for the tasks to complete.
..........
Results: BABABAABBA.
5,753 elapsed milliseconds.
</code></pre>
      </li>
    </ol>
    <p class="normal">This shows that both threads were modifying the message concurrently. In an actual application, this could be a problem. But we can prevent concurrent access by applying a mutually exclusive lock to a conch object, as well as adding code to the two methods to voluntarily check the conch before modifying the shared resource, which we will do in the following section.</p>
    <h2 class="heading-2" id="_idParaDest-208">Applying a mutually exclusive lock to a conch</h2>
    <p class="normal">Now, let’s <a id="_idIndexMarker446"/>use a conch to ensure that only one thread accesses the shared resource at a time:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">SharedObjects.cs</code>, declare and instantiate an <code class="inlineCode">object</code> variable to act as a conch, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">public static object Conch = new(); // A shared object to lock.
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.Methods.cs</code>, in both <code class="inlineCode">MethodA</code> and <code class="inlineCode">MethodB</code>, add a <code class="inlineCode">lock</code> statement for the conch around the <code class="inlineCode">for</code> statements, as shown highlighted in the following code for <code class="inlineCode">MethodB</code>:
        <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">lock</strong><strong class="hljs-slc"> (SharedObjects.Conch)</strong>
<strong class="hljs-slc">{</strong>
  for (int i = 0; i &lt; 5; i++)
  {
    Thread.Sleep(Random.Shared.Next(2000));
    SharedObjects.Message += "B";
    Write(".");
  }
<strong class="hljs-slc">}</strong>
</code></pre>
        <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Note that since checking the conch is voluntary, if you only use the <code class="inlineCode">lock</code> statement in one of the two methods, the shared resource will continue to be accessed by both methods. Make sure that all methods that access a shared resource respect the conch by calling <code class="inlineCode">lock</code> on it before trying to use any shared resources.</p>
        </div>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Run the code and view the result, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Please wait for the tasks to complete.
..........
Results: BBBBBAAAAA.
10,345 elapsed milliseconds.
</code></pre>
      </li>
    </ol>
    <p class="normal">Although the time elapsed was longer, only one method at a time could access the shared resource. Either <code class="inlineCode">MethodA</code> or <code class="inlineCode">MethodB</code> can start first. Once a method has finished its work on<a id="_idIndexMarker447"/> the shared resource, then the conch gets released, and the other method has the chance to do its work.</p>
    <h2 class="heading-2" id="_idParaDest-209">Understanding the lock statement</h2>
    <p class="normal">You might <a id="_idIndexMarker448"/>wonder what the <code class="inlineCode">lock</code> statement does when it “locks” an object variable (hint: it does not lock the object!), as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">lock (SharedObjects.Conch)
{
  // Work with a shared resource.
}
</code></pre>
    <p class="normal">The C# compiler changes the <code class="inlineCode">lock</code> statement into a <code class="inlineCode">try</code>-<code class="inlineCode">finally</code> statement that uses the <code class="inlineCode">Monitor</code> class to <em class="italic">enter</em> and <em class="italic">exit</em> the conch object (I like to think of it as <em class="italic">take</em> and <em class="italic">release</em> the conch object), as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">try
{
  Monitor.Enter(SharedObjects.Conch);
  // Work with a shared resource.
}
finally
{
  Monitor.Exit(SharedObjects.Conch);
}
</code></pre>
    <p class="normal">When a thread calls <code class="inlineCode">Monitor.Enter</code> on a reference type, it checks to see if some other thread has already taken the conch. If it has, the thread waits. If it has not, the thread takes the conch and gets on with its work on the shared resource. Once the thread has finished its work, it calls <code class="inlineCode">Monitor.Exit</code>, releasing the conch. </p>
    <p class="normal">If another thread was waiting, it could now take the conch and do its work. This requires all threads to respect the conch by calling <code class="inlineCode">Monitor.Enter</code> and <code class="inlineCode">Monitor.Exit</code> appropriately.</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: You cannot use value types (<code class="inlineCode">struct</code> types) as a conch. <code class="inlineCode">Monitor.Enter</code> requires a reference type because it locks the memory address. Any internal data structures for that object are <em class="italic">not</em> locked.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-210">Avoiding deadlocks</h2>
    <p class="normal">Knowing <a id="_idIndexMarker449"/>how the <code class="inlineCode">lock</code> statement is translated by the compiler to method calls on the <code class="inlineCode">Monitor</code> class is also important because using the <code class="inlineCode">lock</code> statement can cause a deadlock.</p>
    <p class="normal">Deadlocks can occur when there are two or more shared resources (each with a conch to monitor which thread is currently doing work on each shared resource), and the following sequence of events happens:</p>
    <ul>
      <li class="bulletList">Thread X “locks” conch A and starts working on shared resource A.</li>
      <li class="bulletList">Thread Y “locks” conch B and starts working on shared resource B.</li>
      <li class="bulletList">While still working on resource A, thread X needs to also work with resource B, and so it attempts to “lock” conch B but is blocked because thread Y already has conch B.</li>
      <li class="bulletList">While still working on resource B, thread Y needs to also work with resource A, and so it attempts to “lock” conch A but is blocked because thread X already has conch A.</li>
    </ul>
    <p class="normal">One way to prevent deadlocks is to specify a timeout when attempting to get a lock. To do this, you must manually use the <code class="inlineCode">Monitor</code> class instead of using the <code class="inlineCode">lock</code> statement. Let’s see how:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">In <code class="inlineCode">Program.Methods.cs</code>, modify your code to replace the <code class="inlineCode">lock</code> statements with code that tries to enter the conch with a timeout, outputs an error, and then exits the monitor, allowing other threads to enter the monitor, as shown highlighted in the following code for <code class="inlineCode">MethodB</code>:
        <pre class="programlisting code"><code class="hljs-code"><strong class="hljs-keyword-slc">try</strong>
<strong class="hljs-slc">{</strong>
<strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(</strong><strong class="hljs-number-slc">15</strong><strong class="hljs-slc">)))</strong>
<strong class="hljs-slc">  {</strong>
    for (int i = 0; i &lt; 5; i++)
    {
      Thread.Sleep(Random.Shared.Next(2000));
      SharedObjects.Message += "B";
      Write(".");
    }
<strong class="hljs-slc">  }</strong>
<strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">else</strong>
<strong class="hljs-slc">  {</strong>
<strong class="hljs-slc">    WriteLine(</strong><strong class="hljs-string-slc">"Method B timed out when entering a monitor on conch."</strong><strong class="hljs-slc">);</strong>
<strong class="hljs-slc">  }</strong>
<strong class="hljs-slc">}</strong>
<strong class="hljs-keyword-slc">finally</strong>
<strong class="hljs-slc">{</strong>
<strong class="hljs-slc">  Monitor.Exit(SharedObjects.Conch);</strong>
<strong class="hljs-slc">}</strong>
</code></pre>
      </li>
      <li class="numberedList">Run the<a id="_idIndexMarker450"/> code and view the result, which should return the same results as before (although either A or B could grab the conch first) but is better code because it will prevent potential deadlocks.</li>
    </ol>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Only use the <code class="inlineCode">lock</code> keyword if you can write your code such that it avoids potential deadlocks. If you cannot avoid potential deadlocks, then always use the <code class="inlineCode">Monitor.TryEnter</code> method instead of <code class="inlineCode">lock</code>, in combination with a <code class="inlineCode">try</code>-<code class="inlineCode">finally</code> statement, so that you can supply a timeout and one of the threads will back out of a deadlock if it occurs. You can read more about good threading practices at the following link: <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices">https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-best-practices</a>.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-211">Synchronizing events</h2>
    <p class="normal">.NET events <a id="_idIndexMarker451"/>are not thread-safe, so you should avoid using them in multi-threaded scenarios.</p>
    <p class="normal">After learning that .NET events are not thread-safe, some developers attempt to use exclusive locks when adding and removing event handlers or when raising an event, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">// event delegate field
public event EventHandler? Shout;
// conch
private object eventConch = new();
// method
public void Poke()
{
  lock (eventConch) // bad idea
  {
    // If something is listening...
    if (Shout != null)
    {
      // ...then call the delegate to raise the event.
      Shout(this, EventArgs.Empty);
    }
  }
}
</code></pre>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Is it good or bad that some developers use locks in event handling? Well, it is complicated. It depends on complex factors so I cannot give a value judgement. You can read more about events and thread safety at the following link: <a href="https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful">https://learn.microsoft.com/en-us/archive/blogs/cburrows/field-like-events-considered-harmful</a>. But it is complicated, as explained by Stephen Cleary in the following blog post: <a href="https://blog.stephencleary.com/2009/06/threadsafe-events.html">https://blog.stephencleary.com/2009/06/threadsafe-events.html</a>.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-212">Making CPU operations atomic</h2>
    <p class="normal">Atomic is <a id="_idIndexMarker452"/>from the Greek word <strong class="keyWord">atomos</strong>, which means <em class="italic">undividable</em>. It is important to understand <a id="_idIndexMarker453"/>which operations are atomic in multithreading because if they are not atomic, then they could be interrupted by another thread partway through their operation. Is the C# increment operator atomic, as shown in the following code?</p>
    <pre class="programlisting code"><code class="hljs-code">int x = 3;
x++; // is this an atomic CPU operation?
</code></pre>
    <p class="normal"><em class="italic">It is not atomic!</em> Incrementing an integer requires the following three CPU operations:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Load a value from an instance variable into a register.</li>
      <li class="numberedList">Increment the value.</li>
      <li class="numberedList">Store the value in the instance variable.</li>
    </ol>
    <p class="normal">A thread could be interrupted after executing the first two steps. A second thread could then execute all three steps. When the first thread resumes execution, it will overwrite the<a id="_idIndexMarker454"/> value in the variable, and the effect of the increment or decrement performed by the second thread will be lost!</p>
    <p class="normal">There is a type named <code class="inlineCode">Interlocked</code> that can perform atomic actions like <code class="inlineCode">Add</code>, <code class="inlineCode">Increment</code>, <code class="inlineCode">Decrement</code>, <code class="inlineCode">Exchange</code>, <code class="inlineCode">CompareExchange</code>, <code class="inlineCode">And</code>, <code class="inlineCode">Or</code>, and <code class="inlineCode">Read</code> on the integer types in the following list:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">System.Int32</code> (<code class="inlineCode">int</code>), <code class="inlineCode">System.UInt32</code> (<code class="inlineCode">uint</code>)</li>
      <li class="bulletList"><code class="inlineCode">System.Int64</code> (<code class="inlineCode">long</code>), <code class="inlineCode">System.UInt64</code> (<code class="inlineCode">ulong</code>)</li>
    </ul>
    <p class="normal"><code class="inlineCode">Interlocked</code> does not work on numeric types like <code class="inlineCode">byte</code>, <code class="inlineCode">sbyte</code>, <code class="inlineCode">short</code>, <code class="inlineCode">ushort</code>, and <code class="inlineCode">decimal</code>.</p>
    <p class="normal"><code class="inlineCode">Interlocked</code> can perform atomic operations like <code class="inlineCode">Exchange</code> and <code class="inlineCode">CompareExchange</code> that swap values in memory on the following types:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">System.Single</code> (<code class="inlineCode">float</code>), <code class="inlineCode">System.Double</code> (<code class="inlineCode">double</code>)</li>
      <li class="bulletList"><code class="inlineCode">nint</code>, <code class="inlineCode">nuint</code></li>
      <li class="bulletList"><code class="inlineCode">System.Object</code> (<code class="inlineCode">object</code>)</li>
    </ul>
    <p class="normal">Let’s see it in action:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Declare another field in the <code class="inlineCode">SharedObjects</code> class that will count how many operations have occurred, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">public static int Counter; // Another shared resource.
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.Methods.cs</code>, in both methods A and B, inside the <code class="inlineCode">for</code> statement and after modifying the <code class="inlineCode">string</code> value, add a statement to safely increment the counter, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">Interlocked.Increment(ref SharedObjects.Counter);
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, before outputting the elapsed time, write the current value of the counter to the console, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">WriteLine($"{SharedObjects.Counter} string modifications.");
</code></pre>
      </li>
      <li class="numberedList">Run the code and view the result, as shown highlighted in the following output:
        <pre class="programlisting con"><code class="hljs-con">Please wait for the tasks to complete.
..........
Results: BBBBBAAAAA.
10 string modifications.
13,531 elapsed milliseconds.
</code></pre>
      </li>
    </ol>
    <p class="normal">Observant <a id="_idIndexMarker455"/>readers will realize that the existing conch object protects all shared resources accessed within a block of code locked by the conch, and therefore, it is unnecessary to use <code class="inlineCode">Interlocked</code> in this specific example. But if we had not already been protecting another shared resource like <code class="inlineCode">Message</code>, then using <code class="inlineCode">Interlocked</code> would be necessary.</p>
    <h2 class="heading-2" id="_idParaDest-213">Applying other types of synchronization</h2>
    <p class="normal"><code class="inlineCode">Monitor</code> and <code class="inlineCode">Interlocked</code> are <a id="_idIndexMarker456"/>mutually exclusive locks that are simple and effective, but sometimes, you need more advanced options to synchronize access to shared resources, as shown in <em class="italic">Table 5.3</em>:</p>
    <table class="table-container" id="table003-3">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Type</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Description</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ReaderWriterLock</code>, <code class="inlineCode">ReaderWriterLockSlim</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">These allow multiple threads to be in <strong class="keyWord">read mode</strong>, one thread to be in <strong class="keyWord">write mode</strong> with exclusive ownership of the write lock, and one thread that has read access to be in <strong class="keyWord">upgradeable read mode</strong>, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Mutex</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Like <code class="inlineCode">Monitor</code>, this provides exclusive access to a shared resource, except it is used for inter-process synchronization.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Semaphore</code>, <code class="inlineCode">SemaphoreSlim</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">These limit the number of threads that can access a resource or pool of resources concurrently by defining slots. This is known as <strong class="keyWord">resource throttling</strong> rather than <strong class="keyWord">resource locking</strong>.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">AutoResetEvent</code>,<code class="inlineCode"> ManualResetEvent</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Event wait handles allow threads to synchronize activities by signaling each other and by waiting for each other’s signals.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.3: Synchronization types</p>
    <p class="normal">Now that we’ve explored the importance of synchronizing access to shared resources in multi-threaded applications, it’s time to delve into how some new keywords introduced in C# 5 make writing asynchronous code easier.</p>
    <h1 class="heading-1" id="_idParaDest-214">Understanding async and await</h1>
    <p class="normal">C# 5 introduced two C# keywords when <a id="_idIndexMarker457"/>working with the <code class="inlineCode">Task</code> type. They <a id="_idIndexMarker458"/>are especially useful for the following:</p>
    <ul>
      <li class="bulletList">Implementing multitasking for a <strong class="keyWord">graphical user interface</strong> (<strong class="keyWord">GUI</strong>)</li>
      <li class="bulletList">Improving the scalability of web applications and web services</li>
    </ul>
    <p class="normal">In <em class="chapterRef">Chapter 16</em>, <em class="italic">Building Mobile and Desktop Apps Using .NET MAUI</em>, we will see how the <code class="inlineCode">async</code> and <code class="inlineCode">await</code> keywords can implement multitasking for a GUI.</p>
    <p class="normal">But for now, let’s learn the theory of why these two C# keywords were introduced, and then later, you will see them used in practice.</p>
    <h2 class="heading-2" id="_idParaDest-215">Improving responsiveness for console apps</h2>
    <p class="normal">One of the<a id="_idIndexMarker459"/> limitations with console apps is that you can only use the <code class="inlineCode">await</code> keyword inside methods that are marked as <code class="inlineCode">async</code>, but C# 7 and earlier do not allow the <code class="inlineCode">Main</code> method to be marked as <code class="inlineCode">async</code>! Luckily, a new feature introduced in C# 7.1 was support for <code class="inlineCode">async</code> in <code class="inlineCode">Main</code>:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use your preferred code editor to add a new <strong class="screenText">Console App</strong> / <code class="inlineCode">console</code> project to the <code class="inlineCode">Chapter05</code> solution named <code class="inlineCode">AsyncConsole</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete the existing statements, statically import <code class="inlineCode">Console</code>, and then add statements to create an <code class="inlineCode">HttpClient</code> instance, make a request for Apple’s home page, and output how many bytes it has, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">using static System.Console;
HttpClient client = new();
HttpResponseMessage response =
  await client.GetAsync("http://www.apple.com/");
WriteLine("Apple's home page has {0:N0} bytes.",
  response.Content.Headers.ContentLength);
</code></pre>
      </li>
      <li class="numberedList">Build the project and note that it builds successfully. In .NET 5 and earlier, the project template created an explicit <code class="inlineCode">Program</code> class with a non-async <code class="inlineCode">Main</code> method, so you would have seen an error message, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Program.cs(14,9): error CS4033: The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'. [/Users/markjprice/apps-services-net7/Chapter04/AsyncConsole/AsyncConsole.csproj]
</code></pre>
      </li>
      <li class="numberedList">You <a id="_idIndexMarker460"/>would have had to add the <code class="inlineCode">async</code> keyword to the <code class="inlineCode">Main</code> method and change its return type to <code class="inlineCode">Task</code>. With .NET 6 and later, the console app project template uses the top-level program feature to automatically define the <code class="inlineCode">Program</code> class with an asynchronous <code class="inlineCode">&lt;Main&gt;$</code> method for you.</li>
      <li class="numberedList">Run the code and view the result, which is likely to have a different number of bytes since Apple changes its home page frequently, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Apple's home page has 40,252 bytes.
</code></pre>
      </li>
    </ol>
    <h2 class="heading-2" id="_idParaDest-216">Working with async streams</h2>
    <p class="normal">With .NET Core 3, Microsoft<a id="_idIndexMarker461"/> introduced the asynchronous processing of streams.</p>
    <div><p class="normal">You can complete <a id="_idIndexMarker462"/>a tutorial about async streams at the following link: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream">https://learn.microsoft.com/en-us/dotnet/csharp/tutorials/generate-consume-asynchronous-stream</a>.</p>
    </div>
    <p class="normal">Before C# 8 and .NET Core 3, the <code class="inlineCode">await</code> keyword only worked with tasks that return scalar values. Async stream support in .NET Standard 2.1 allows an <code class="inlineCode">async</code> method to return one value after another asynchronously.</p>
    <p class="normal">Let’s see a simulated example that returns three random integers as an async stream:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Use your preferred code editor to add a new <strong class="screenText">Console App</strong> / <code class="inlineCode">console</code> project to the <code class="inlineCode">Chapter05</code> solution named <code class="inlineCode">AsyncEnumerable</code>.</li>
      <li class="numberedList">Globally and statically import the <code class="inlineCode">System.Console</code> class and treat warnings as errors.</li>
      <li class="numberedList">Add a <a id="_idIndexMarker463"/>new file named <code class="inlineCode">Program.Methods.cs</code>.</li>
      <li class="numberedList">In <code class="inlineCode">Program.Methods.cs</code>, delete any existing statements and then define a method that uses the <code class="inlineCode">yield</code> keyword to return a random sequence of three numbers asynchronously, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">partial class Program
{
  private static async IAsyncEnumerable&lt;int&gt; GetNumbersAsync()
  {
    Random r = Random.Shared;
    // Simulate some work that takes 1.5 to 3 seconds.
    await Task.Delay(r.Next(1500, 3000));
    // Return a random number between 1 and 1000.
    yield return r.Next(1, 1001);
    await Task.Delay(r.Next(1500, 3000));
    yield return r.Next(1, 1001);
    await Task.Delay(r.Next(1500, 3000));
    yield return r.Next(1, 1001);
  }
}
</code></pre>
      </li>
      <li class="numberedList">In <code class="inlineCode">Program.cs</code>, delete the existing statements and then add statements to enumerate the sequence of numbers, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">// Use async streams to iterate over a collection asynchronously.
await foreach (int number in GetNumbersAsync())
{
  WriteLine($"Number: {number}");
}
</code></pre>
      </li>
      <li class="numberedList">Run the code and view the result, as shown in the following output:
        <pre class="programlisting con"><code class="hljs-con">Number: 509
Number: 813
Number: 307
</code></pre>
      </li>
    </ol>
    <h2 class="heading-2" id="_idParaDest-217">Improving responsiveness for GUI apps</h2>
    <p class="normal">So far in<a id="_idIndexMarker464"/> this book, we have only built console apps. Life for a programmer gets more complicated when building web applications, web services, and apps with GUIs such as Windows desktop and mobile apps.</p>
    <p class="normal">One reason for this is that for a GUI app, there is a special thread: the <strong class="keyWord">user interface</strong> (<strong class="keyWord">UI</strong>) thread.</p>
    <p class="normal">There are two rules for working in GUIs:</p>
    <ul>
      <li class="bulletList">Do not perform long-running tasks on the UI thread.</li>
      <li class="bulletList">Do not access UI elements on any thread except the UI thread.</li>
    </ul>
    <p class="normal">To handle these rules, programmers used to have to write complex code to ensure that long-running tasks were executed by a non-UI thread, but once complete, the results of the task were safely passed to the UI thread to present to the user. It could quickly get messy!</p>
    <p class="normal">Luckily, with C# 5 and later, you have the use of <code class="inlineCode">async</code> and <code class="inlineCode">await</code>. They allow you to continue to write your code as if it is synchronous, which keeps your code clean and easy to understand, but underneath, the C# compiler creates a complex state machine and keeps track of running threads. It’s kind of magical! The combination of these two keywords makes the asynchronous method run on a worker thread and, when it’s complete, return the results on the UI thread.</p>
    <p class="normal">Let’s see an example. We will build a Windows desktop app using <strong class="keyWord">Windows Presentation Foundation</strong> (<strong class="keyWord">WPF</strong>) that gets employees from the Northwind database in a SQL Server database using low-level types like <code class="inlineCode">SqlConnection</code>, <code class="inlineCode">SqlCommand</code>, and <code class="inlineCode">SqlDataReader</code>.</p>
    <div><p class="normal">The Northwind database has medium complexity and a decent number of sample records. You used it extensively in <em class="chapterRef">Chapter 2</em>,<em class="chapterRef"> </em><em class="italic">Managing Relational Data Using SQL Server</em>, where it was introduced and set up.</p>
    </div>
    <div><p class="normal"><strong class="keyWord">Warning! </strong>You will only be able to complete this task if you have Microsoft Windows and the Northwind database stored in Microsoft SQL Server. This is the only section in this book that is not cross-platform and modern (WPF is 17 years old!). You can use either Visual Studio 2022 or Visual Studio Code.</p>
    </div>
    <p class="normal">At this point, we<a id="_idIndexMarker465"/> are focusing on making a GUI app responsive. You will learn about XAML and building cross-platform GUI apps in <em class="chapterRef">Chapter 16</em>, <em class="italic">Building Mobile and Desktop Apps Using .NET MAUI</em>. Since this book does not cover WPF elsewhere, I thought this task would be a good opportunity to at least see an example app built using WPF even if we do not look at it in detail. Let’s go!</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">If you are using Visual Studio 2022, add a new <strong class="keyWord">WPF Application [C#]</strong> project named <code class="inlineCode">WpfResponsive</code> to the <code class="inlineCode">Chapter05</code> solution. If you are using Visual Studio Code, use the following command: <code class="inlineCode">dotnet new wpf</code>. If you are using JetBrains Rider, select <strong class="screenText">Desktop Application</strong> and then select a <strong class="screenText">Type</strong> of <strong class="screenText">WPF Application</strong>.</li>
      <li class="numberedList">Add a package reference for <code class="inlineCode">Microsoft.Data.SqlClient</code> to the project.</li>
      <li class="numberedList">In the project file, note the output type is a Windows EXE, the target framework is .NET for Windows (it will not run on other platforms, like macOS and Linux), and the project uses WPF, as shown in the following markup:
        <pre class="programlisting code"><code class="hljs-code">&lt;Project Sdk="Microsoft.NET.Sdk"&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0-windows&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;UseWPF&gt;true&lt;/UseWPF&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.Data.SqlClient" Version="5.2.0" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
      </li>
      <li class="numberedList">Build the <code class="inlineCode">WpfResponsive</code> project to restore packages.</li>
      <li class="numberedList">In <code class="inlineCode">MainWindow.xaml</code>, in the <code class="inlineCode">&lt;Grid&gt;</code> element, add elements to define two buttons, a text box and a list box, laid out vertically in a stack panel, as shown in the following markup:
        <pre class="programlisting code"><code class="hljs-code">&lt;StackPanel&gt;
  &lt;Button Name="GetEmployeesSyncButton" 
          Click="GetEmployeesSyncButton_Click"&gt;
    Get Employees Synchronously&lt;/Button&gt;
  &lt;Button Name="GetEmployeesAsyncButton" 
          Click="GetEmployeesAsyncButton_Click"&gt;
    Get Employees Asynchronously&lt;/Button&gt;
  &lt;TextBox HorizontalAlignment="Stretch" Text="Type in here" /&gt;
  &lt;ListBox Name="EmployeesListBox" Height="400" /&gt;
&lt;/StackPanel&gt;
</code></pre>
      
    <div><p class="normal">Visual Studio 2022 has good support for building WPF apps and will provide IntelliSense as you edit code and XAML markup. Visual Studio Code does not.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">In <code class="inlineCode">MainWindow.xaml.cs</code>, import<a id="_idIndexMarker466"/> namespaces to work with ADO.NET and the stopwatch, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">using Microsoft.Data.SqlClient; // To use SqlConnection and so on.
using System.Diagnostics; // To use Stopwatch.
</code></pre>
      </li>
      <li class="numberedList">In the <code class="inlineCode">MainWindow</code> class, in the constructor, define two <code class="inlineCode">string</code> fields for the database connection string and SQL statement, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">private string connectionString;
private string sql = "WAITFOR DELAY '00:00:05';" +
  "SELECT EmployeeId, FirstName, LastName FROM Employees";
</code></pre>
      
    <div><p class="normal">The SQL has two statements. The first waits for five seconds to simulate a long-running query.</p>
    </div></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">In the <code class="inlineCode">MainWindow</code> class, in the constructor, after the call to <code class="inlineCode">InitializeComponent</code>, use an <code class="inlineCode">SqlConnectionStringBuilder</code> to set the database connection string, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">public MainWindow()
{
  InitializeComponent();
  // Change as needed to work with your Northwind database.
  SqlConnectionStringBuilder builder = new();
  builder.DataSource = ".";
  builder.InitialCatalog = "Northwind";
  builder.Encrypt = false;
  builder.MultipleActiveResultSets = true;
  builder.ConnectTimeout = 5;
  // To use Windows Integrated authentication.
  builder.IntegratedSecurity = true;
  // To use SQL Server authentication.
  // builder.UserID = Environment.GetEnvironmentVariable("MY_SQL_USR");
  // builder.Password = Environment.GetEnvironmentVariable("MY_SQL_PWD");
  connectionString = builder.ConnectionString;
}
</code></pre>
      </li>
      <li class="numberedList">Create event<a id="_idIndexMarker467"/> handlers for clicking on the two buttons. They must use the <code class="inlineCode">string</code> constants to open a connection to the Northwind database and then populate the list box with the IDs and names of all employees, as shown in the following code:
        <pre class="programlisting code"><code class="hljs-code">private void GetEmployeesSyncButton_Click(object sender, RoutedEventArgs e)
{
  Stopwatch timer = Stopwatch.StartNew();
  using (SqlConnection connection = new(connectionString))
  {
    try
    {
      connection.Open();
      SqlCommand command = new(sql, connection);
      SqlDataReader reader = command.ExecuteReader();
      while (reader.Read())
      {
        string employee = string.Format("{0}: {1} {2}",
          reader.GetInt32(0), reader.GetString(1),
          reader.GetString(2));
        EmployeesListBox.Items.Add(employee);
      }
      reader.Close();
      connection.Close();
    }
    catch (Exception ex)
    {
      MessageBox.Show(ex.Message);
    }
  }
  EmployeesListBox.Items.Add(
    $"Sync: {timer.ElapsedMilliseconds:N0}ms");
}
private async void GetEmployeesAsyncButton_Click(
  object sender, RoutedEventArgs e)
{
  Stopwatch timer = Stopwatch.StartNew();
  using (SqlConnection connection = new(connectionString))
  {
    try
    {
      await connection.OpenAsync();
      SqlCommand command = new(sql, connection);
      SqlDataReader reader = await command.ExecuteReaderAsync();
      while (await reader.ReadAsync())
      {
        string employee = string.Format("{0}: {1} {2}",
          await reader.GetFieldValueAsync&lt;int&gt;(0), 
          await reader.GetFieldValueAsync&lt;string&gt;(1), 
          await reader.GetFieldValueAsync&lt;string&gt;(2));
        EmployeesListBox.Items.Add(employee);
      }
      await reader.CloseAsync();
      await connection.CloseAsync();
    }
    catch (Exception ex)
    {
      MessageBox.Show(ex.Message);
    }
  }
  EmployeesListBox.Items.Add(
    $"Async: {timer.ElapsedMilliseconds:N0}ms");
}
</code></pre>
      
    <p class="normal">Note the following:</p>
    <ul>
      <li class="bulletList">Defining<a id="_idIndexMarker468"/> an <code class="inlineCode">async void</code> method is generally bad practice because it is “fire and forget.” You will not be notified when it is completed and there is no way to cancel it because it does not return a <code class="inlineCode">Task</code> or <code class="inlineCode">Task&lt;T&gt;</code> that can be used to control it.</li>
      <li class="bulletList">The SQL statement uses the SQL Server <code class="inlineCode">WAITFOR DELAY</code> command to simulate processing that takes five seconds. It then selects three columns from the <code class="inlineCode">Employees</code> table.</li>
      <li class="bulletList">The <code class="inlineCode">GetEmployeesSyncButton_Click</code> event handler uses synchronous methods to open a connection and fetch the employee rows.</li>
      <li class="bulletList">The <code class="inlineCode">GetEmployeesAsyncButton_Click</code> event handler is marked as <code class="inlineCode">async</code> and uses asynchronous methods with the <code class="inlineCode">await</code> keyword to open a connection and fetch the employee rows.</li>
      <li class="bulletList">Both event handlers use a stopwatch to record the number of milliseconds the operation takes and add it to the list box.</li>
    </ul></li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">Start the WPF app without debugging.</li>
      <li class="numberedList">Click in the text box, enter some text, and note that the GUI is responsive.</li>
      <li class="numberedList">Click the <strong class="screenText">Get Employees Synchronously</strong> button.</li>
      <li class="numberedList">Try to click in the text box, and note the GUI is not responsive.</li>
      <li class="numberedList">Wait for at least five seconds until the list box is filled with employees.</li>
      <li class="numberedList">Click in the text box, enter some text, and note the GUI is responsive again.</li>
      <li class="numberedList">Click the <strong class="screenText">Get Employees Asynchronously</strong> button.</li>
      <li class="numberedList">Click in <a id="_idIndexMarker469"/>the text box, enter some text, and note that the GUI is still responsive while it performs the operation. Continue typing until the list box is filled with the employees, as shown in <em class="italic">Figure 5.2</em>:</li>
    </ol>
    <figure class="mediaobject"><img alt="" src="img/B19587_05_02.png"/></figure>
    <p class="packt_figref">Figure 5.2: Loading employees into a WPF app synchronously and asynchronously</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="18">Note the difference in timings for the two operations. The UI is blocked when fetching data synchronously, while the UI remains responsive when fetching data asynchronously.</li>
      <li class="numberedList">Close the WPF app.</li>
    </ol>
    <h2 class="heading-2" id="_idParaDest-218">Improving scalability for web applications and web services</h2>
    <p class="normal">The <code class="inlineCode">async</code> and <code class="inlineCode">await</code> keywords<a id="_idIndexMarker470"/> can also be applied on the server side when building websites, applications, and services. From the client application’s point of view, nothing changes (or they might even notice a small increase in the time taken for a request to return). So, from a single client’s point of view, the use of <code class="inlineCode">async</code> and <code class="inlineCode">await</code> to implement multitasking on the server side makes their experience worse!</p>
    <p class="normal">On the server side, additional, cheaper worker threads are created to wait for long-running tasks to finish so that expensive I/O threads can handle other client requests instead of being blocked. This improves the overall scalability of a web application or service. More clients can be supported simultaneously.</p>
    <h2 class="heading-2" id="_idParaDest-219">Common types that support multitasking</h2>
    <p class="normal">There are <a id="_idIndexMarker471"/>many common types that have asynchronous methods that you can await, as shown in <em class="italic">Table 5.4</em>:</p>
    <table class="table-container" id="table004-3">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Type</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Methods</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">DbContext&lt;T&gt;</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">AddAsync</code>, <code class="inlineCode">AddRangeAsync</code>, <code class="inlineCode">FindAsync</code>, and <code class="inlineCode">SaveChangesAsync</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">DbSet&lt;T&gt;</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">AddAsync</code>, <code class="inlineCode">AddRangeAsync</code>, <code class="inlineCode">ForEachAsync</code>, <code class="inlineCode">SumAsync</code>, <code class="inlineCode">ToListAsync ToDictionaryAsync</code>, <code class="inlineCode">AverageAsync</code>, and <code class="inlineCode">CountAsync</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">HttpClient</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">GetAsync</code>, <code class="inlineCode">PostAsync</code>, <code class="inlineCode">PutAsync</code>, <code class="inlineCode">DeleteAsync</code>, and <code class="inlineCode">SendAsync</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">StreamReader</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">ReadAsync</code>, <code class="inlineCode">ReadLineAsync</code>, and <code class="inlineCode">ReadToEndAsync</code></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">StreamWriter</code></p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">WriteAsync</code>, <code class="inlineCode">WriteLineAsync</code>, and <code class="inlineCode">FlushAsync</code></p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.4: Common types with asynchronous methods</p>
    <div><p class="normal"><strong class="keyWord">Good Practice</strong>: Any time you see a method that ends in the <code class="inlineCode">Async</code> suffix, check to see whether it returns <code class="inlineCode">Task</code> or <code class="inlineCode">Task&lt;T&gt;</code>. If it does return <code class="inlineCode">Task</code> or <code class="inlineCode">Task&lt;T&gt;</code>, then you could use it instead of the synchronous non-<code class="inlineCode">Async</code> suffixed method. Remember to call it using <code class="inlineCode">await</code> and decorate your method with <code class="inlineCode">async</code>.</p>
    </div>
    <h2 class="heading-2" id="_idParaDest-220">Using await in catch blocks</h2>
    <p class="normal">When <code class="inlineCode">async</code> and <code class="inlineCode">await</code> were<a id="_idIndexMarker472"/> first introduced in C# 5, it was only possible to use the <code class="inlineCode">await</code> keyword in a <code class="inlineCode">try</code> block, but not in a <code class="inlineCode">catch</code> block. In C# 6 and later, it is now possible to use <code class="inlineCode">await</code> in both <code class="inlineCode">try</code> and <code class="inlineCode">catch</code> blocks.</p>
    <h1 class="heading-1" id="_idParaDest-221">Practicing and exploring</h1>
    <p class="normal">Test your knowledge and understanding by answering some questions, getting some hands-on practice, and exploring this chapter’s topics with deeper research.</p>
    <h2 class="heading-2" id="_idParaDest-222">Exercise 5.1 – Test your knowledge</h2>
    <p class="normal">Answer the following questions:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">What information can you find out about a process?</li>
      <li class="numberedList">How accurate is the <code class="inlineCode">Stopwatch</code> class?</li>
      <li class="numberedList">By convention, what suffix should be applied to a method that returns <code class="inlineCode">Task</code> or <code class="inlineCode">Task&lt;T&gt;</code>?</li>
      <li class="numberedList">To use the <code class="inlineCode">await</code> keyword inside a method, what keyword must be applied to the method declaration?</li>
      <li class="numberedList">How do you create a child task?</li>
      <li class="numberedList">Why should you avoid the <code class="inlineCode">lock</code> keyword?</li>
      <li class="numberedList">When should you use the <code class="inlineCode">Interlocked</code> class?</li>
      <li class="numberedList">When should you use the <code class="inlineCode">Mutex</code> class instead of the <code class="inlineCode">Monitor</code> class?</li>
      <li class="numberedList">What is the benefit of using <code class="inlineCode">async</code> and <code class="inlineCode">await</code> in a website or web service?</li>
      <li class="numberedList">Can you cancel a task? If so, how?</li>
    </ol>
    <h2 class="heading-2" id="_idParaDest-223">Exercise 5.2 – Explore topics</h2>
    <p class="normal">Use the links on the following web page to learn more about the topics covered in this chapter:</p>
    <p class="normal"><a href="https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency">https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-5---multitasking-and-concurrency</a></p>
    <h2 class="heading-2" id="_idParaDest-224">Exercise 5.3 – Read more about parallel programming</h2>
    <p class="normal">Packt has a book that goes deeper into the topics in this chapter, <em class="italic">Parallel Programming and Concurrency with C# 10 and .NET 6: A modern approach to building faster, more responsive, and asynchronous .NET applications using C#</em>, by Alvin Ashcroft:</p>
    <p class="normal"><a href="https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672">https://www.packtpub.com/product/parallel-programming-and-concurrency-with-c-10-and-net-6/9781803243672</a></p>
    <h1 class="heading-1" id="_idParaDest-225">Summary</h1>
    <p class="normal">In this chapter, you learned: </p>
    <ul>
      <li class="bulletList">How to define and start a task.</li>
      <li class="bulletList">How to wait for one or more tasks to finish.</li>
      <li class="bulletList">How to control task completion order. </li>
      <li class="bulletList">How to synchronize access to shared resources.</li>
      <li class="bulletList">The magic behind <code class="inlineCode">async</code> and <code class="inlineCode">await</code>.</li>
    </ul>
    <p class="normal">In the next chapter, you will learn how to use some popular third-party libraries.</p>
  </div>
</body></html>