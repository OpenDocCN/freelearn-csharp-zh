- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Exploring Unity’s Scripting Anatomy
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Unity的脚本结构
- en: Building on your foundational knowledge of C# programming within Unity, where
    we covered syntax, variables, control structures, and basic debugging, we’ll now
    transition into Unity’s scripting capabilities. This foundation is crucial as
    we delve deeper into MonoBehaviour, Unity’s primary class for attaching scripts
    to GameObjects. MonoBehaviour brings C# scripts to life within the Unity engine,
    controlling everything from initial setup to real-time game responses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中构建你的C#编程基础之上，其中我们涵盖了语法、变量、控制结构和基本调试，我们现在将过渡到Unity的脚本功能。这个基础对于深入理解MonoBehaviour至关重要，它是Unity中用于将脚本附加到GameObject的主要类。MonoBehaviour使C#脚本在Unity引擎中生动起来，控制从初始设置到实时游戏响应的一切。
- en: We’ll explore how MonoBehaviour integrates with GameObjects, its commonly used
    methods, such as `Awake()`, `Start()`, and `OnEnable()`, and its role in defining
    game behavior. Understanding the Unity script life cycle, including the execution
    order of events such as `Update()` and `FixedUpdate()`, is essential for animating
    GameObjects and implementing game logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨MonoBehaviour如何与GameObject集成，其常用方法，如`Awake()`、`Start()`和`OnEnable()`，以及它在定义游戏行为中的作用。理解Unity脚本的生命周期，包括`Update()`和`FixedUpdate()`等事件的执行顺序，对于动画GameObject和实现游戏逻辑至关重要。
- en: We’ll also expand on handling player inputs, exploring Unity’s input system
    in detail to capture and respond to player actions, enhancing game interactivity.
    Additionally, we’ll address inter-script communication, building on modular coding
    practices to manage interactions between various game components effectively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将扩展处理玩家输入的内容，详细探讨Unity的输入系统以捕获和响应玩家动作，增强游戏交互性。此外，我们将解决脚本间的通信问题，基于模块化编码实践来有效管理各种游戏组件之间的交互。
- en: In summary, this chapter enhances your ability to control game behavior and
    dynamics within Unity, equipping you with advanced skills for complex game development
    projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，本章增强了你在Unity中控制游戏行为和动态的能力，为你提供复杂游戏开发项目的先进技能。
- en: After establishing a foundation in C# programming for Unity, covering syntax,
    variables, control structures, and basic debugging, we advance into the deeper
    realms of Unity’s scripting capabilities. This journey begins with an understanding
    of MonoBehaviour, Unity’s essential class for scripting game behavior. MonoBehaviour
    serves as the vital link between your C# scripts and the Unity engine, enabling
    scripts to dictate GameObject behavior from setup to real-time interactions. We’ll
    explore how it integrates with GameObjects and delve into its key methods for
    initializing variables, configuring game states, and handling gameplay events.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的C#编程基础，包括语法、变量、控制结构和基本调试建立之后，我们进一步深入Unity的脚本功能领域。这次旅程从理解MonoBehaviour开始，它是Unity中用于脚本化游戏行为的基本类。MonoBehaviour作为你C#脚本和Unity引擎之间的关键链接，使脚本能够从设置到实时交互来控制GameObject的行为。我们将探讨它是如何与GameObject集成的，并深入研究其初始化变量、配置游戏状态和处理游戏事件的关键方法。
- en: Building on this, we’ll shift focus to the Unity script life cycle, emphasizing
    the execution sequence of events such as `Update()` and `FixedUpdate()`, crucial
    for animating objects and implementing logic. We’ll also expand on handling player
    inputs, providing a nuanced view of Unity’s input system for capturing and responding
    to player actions, thereby enhancing game interactivity. Furthermore, we’ll address
    inter-script communication, essential for coordinating interactions among game
    components. This chapter aims to deepen your skills in controlling game dynamics
    and developing complex functionalities, setting a robust stage for advanced game
    development.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们将重点转向Unity脚本的生命周期，强调`Update()`和`FixedUpdate()`等事件的执行顺序，这对于动画对象和实现逻辑至关重要。我们还将进一步探讨处理玩家输入，提供对Unity输入系统的深入理解，以捕获和响应玩家动作，从而增强游戏交互性。此外，我们将解决脚本间的通信问题，这对于协调游戏组件之间的交互至关重要。本章旨在加深你在控制游戏动态和开发复杂功能方面的技能，为高级游戏开发奠定坚实的基础。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Grasping the role and use of MonoBehaviour in Unity scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MonoBehaviour在Unity脚本中的作用和使用
- en: Mastering Unity’s script life cycle methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握Unity脚本生命周期方法
- en: Handling user inputs through scripts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过脚本处理用户输入
- en: Implementing communication between different scripts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不同脚本之间的通信
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you start, ensure your development environment is set up as described
    in [*Chapter 1*](B22128_01.xhtml#_idTextAnchor015). This includes having the latest
    recommended version of Unity and a suitable code editor installed on your system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保您的开发环境已按照[*第1章*](B22128_01.xhtml#_idTextAnchor015)中描述的设置。这包括拥有最新推荐的Unity版本以及安装了合适的代码编辑器。
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter04)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到与本章节相关的示例/文件：[https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter04)
- en: Hardware requirements
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件要求
- en: Ensure your computer meets Unity’s minimum hardware specifications, especially
    a graphics card that supports at least DX10 (shader model 4.0) and a minimum of
    8 GB RAM for optimal performance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的计算机满足Unity的最低硬件规格，特别是至少支持DX10（着色器模型4.0）的显卡，以及至少8 GB RAM以实现最佳性能。
- en: Software requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件要求
- en: 'Here are the software requirements for the chapter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章的软件要求：
- en: '**Unity Editor**: Utilize the version of the Unity Editor installed in [*Chapter
    1*](B22128_01.xhtml#_idTextAnchor015), ideally the latest **Long-Term Support**
    (**LTS**) version.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity编辑器**：使用安装在[*第1章*](B22128_01.xhtml#_idTextAnchor015)中的Unity编辑器版本，最好是最新**长期支持**（**LTS**）版本。'
- en: '**Code editor**: Visual Studio or Visual Studio Code, with Unity development
    tools, should already be integrated as per the initial setup.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码编辑器**：Visual Studio或Visual Studio Code，应已根据初始设置集成Unity开发工具。'
- en: Understanding MonoBehaviour
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MonoBehaviour
- en: '**MonoBehaviorMonoBehaviour** is a foundational concept within the Unity game
    engine, serving as the base class for nearly all scripts developed within this
    versatile platform. It is a default class in Unity that allows developers to attach
    their C# scripts to GameObjects, thereby infusing them with unique behaviors and
    interactive capabilities. Understanding MonoBehaviour is essential for anyone
    looking to harness the full power of Unity in game development or any interactive
    3D applications.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**MonoBehaviorMonoBehaviour**是Unity游戏引擎中的一个基础概念，作为几乎所有在此多功能平台中开发的脚本的基类。它是Unity中的一个默认类，允许开发者将他们的C#脚本附加到GameObject上，从而赋予它们独特的行为和交互能力。理解MonoBehaviour对于希望充分利用Unity在游戏开发或任何交互式3D应用程序中的全部功能的人来说至关重要。'
- en: Understanding MonoBehaviour – the core of Unity scripting
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解MonoBehaviour – Unity脚本的核心
- en: The role of MonoBehaviour in Unity is multifaceted. It acts as a bridge between
    the Unity engine and the custom scripts that developers write in C#. By inheriting
    from MonoBehaviour, a script gains the ability to respond to a wide array of game
    events through specific functions, such as when a game starts, when objects collide,
    or when user input is detected. This enables developers to create complex game
    logic and interactions, from controlling character movements to managing game
    states.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MonoBehaviour在Unity中的作用是多方面的。它充当Unity引擎和开发者在C#中编写的自定义脚本之间的桥梁。通过从MonoBehaviour继承，脚本获得了通过特定功能响应广泛游戏事件的能力，例如游戏开始时、物体碰撞时或检测到用户输入时。这使得开发者能够创建复杂的游戏逻辑和交互，从控制角色移动到管理游戏状态。
- en: MonoBehaviour provides a structured way to implement game logic by overriding
    its predefined methods, which Unity calls at specific points during the game’s
    life cycle. For example, the `Start()` method is called before the first frame
    update, making it an ideal place to initialize variables or set up game elements.
    Similarly, the `Update()` method is called once per frame, making it suitable
    for handling continuous checks or inputs within the game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MonoBehaviour通过覆盖其预定义的方法提供了一种结构化的方式来实现游戏逻辑，这些方法在游戏生命周期中的特定时刻由Unity调用。例如，`Start()`方法在第一次帧更新之前被调用，这使得它是一个初始化变量或设置游戏元素的理想位置。同样，`Update()`方法每帧调用一次，适合处理游戏中的连续检查或输入。
- en: 'Here’s a simple example of a MonoBehaviour script in C# that moves a GameObject:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的MonoBehaviour脚本示例，使用C#移动GameObject：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the `Mover` class is based on `MonoBehaviour`, allowing it
    to be attached to a GameObject in Unity. Inside the `Update()` method, which Unity
    calls once per frame, the GameObject’s position is updated to move forward. The
    movement’s speed is controlled by the `speed` variable, and `Time.deltaTime` ensures
    the movement is smooth and frame rate independent.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Mover` 类基于 `MonoBehaviour`，这使得它能够被附加到 Unity 中的 GameObject 上。在 Unity
    调用一次每帧的 `Update()` 方法内部，GameObject 的位置被更新以向前移动。移动的速度由 `speed` 变量控制，而 `Time.deltaTime`
    确保了移动的平滑性和帧率独立性。
- en: In essence, MonoBehaviorMonoBehaviour is the cornerstone of scripting in Unity,
    providing the essential structure and life cycle hooks needed to implement game
    behavior. Its comprehensive set of event functions offers developers the flexibility
    to create rich, interactive, and responsive game experiences. By mastering MonoBehaviour
    and its functions, developers can effectively bring their game ideas to life within
    the Unity3D engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`MonoBehaviour` 是 Unity 中脚本的基础，提供了实现游戏行为所需的必要结构和生命周期钩子。它全面的事件函数集为开发者提供了创建丰富、交互式和响应式游戏体验的灵活性。通过掌握
    `MonoBehaviour` 和其函数，开发者可以在 Unity3D 引擎中有效地将他们的游戏想法变为现实。
- en: MonoBehaviorMonoBehaviour serves as the crucial link between the Unity game
    engine and the custom C# scripts that developers craft, enabling the creation
    of dynamic and interactive game elements. Through its predefined methods, such
    as `Update()` and `Start()`, MonoBehaviour allows for the seamless integration
    of scripted behaviors into GameObjects, making it an indispensable tool in the
    Unity ecosystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour` 作为 Unity 游戏引擎和开发者编写的自定义 C# 脚本之间的关键链接，使得创建动态和交互式游戏元素成为可能。通过其预定义的方法，如
    `Update()` 和 `Start()`，`MonoBehaviour` 允许将脚本行为无缝集成到 GameObjects 中，使其成为 Unity 生态系统中的不可或缺的工具。'
- en: The provided `Mover` script example illustrates how effortlessly a MonoBehaviorMonoBehaviour-derived
    script can dictate the continuous movement of a GameObject, showcasing the practical
    application of MonoBehaviour’s functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 `Mover` 脚本示例展示了派生自 `MonoBehaviour` 的脚本如何轻松地控制 GameObject 的持续移动，展示了 `MonoBehaviour`
    函数的实际应用。
- en: As we delve deeper into the relationship between MonoBehaviour and GameObjects,
    we’ll explore how these scripts are not just attached but are fundamentally intertwined
    with GameObjects to define and refine their behavior, bringing the virtual world
    to life with intricate interactions and functionalities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们深入探讨 `MonoBehaviour` 和 GameObjects 之间的关系，我们将探讨这些脚本不仅被附加，而且与 GameObjects
    基本上交织在一起，以定义和细化它们的行为，通过复杂的交互和功能使虚拟世界生动起来。
- en: Attaching MonoBehaviour scripts to define GameObject behavior
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加 `MonoBehaviour` 脚本来定义 GameObject 行为
- en: In the realm of Unity development, the symbiotic relationship between MonoBehaviour
    scripts and GameObjects is foundational to crafting the interactive and dynamic
    worlds that define modern games.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 开发领域，`MonoBehaviour` 脚本和 GameObjects 之间的共生关系是构建现代游戏定义的交互式和动态世界的基础。
- en: This section delves into the intricacies of how MonoBehaviour scripts are intricately
    attached to GameObjects, effectively becoming the lifeblood that animates and
    dictates their behavior within the game environment. By understanding this crucial
    linkage, developers unlock the ability to manipulate GameObjects in nuanced ways,
    from simple movements to complex interactive systems, paving the way for limitless
    creativity in game design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了 `MonoBehaviour` 脚本如何巧妙地附加到 GameObjects 上，有效地成为在游戏环境中赋予 GameObjects 生命和行为的生命线。通过理解这个关键联系，开发者可以解锁以细微方式操纵
    GameObjects 的能力，从简单的移动到复杂的交互系统，为游戏设计开辟了无限创意的空间。
- en: In Unity, the interaction between MonoBehaviour and GameObjects is a fundamental
    concept that every developer must grasp to effectively bring their game ideas
    to life. MonoBehaviour scripts serve as the blueprint for behavior, which, when
    attached to GameObjects, dictate how these objects act, react, and interact within
    the game world. This attachment is what transforms static models and textures
    into dynamic, interactive elements that are essential for creating engaging gameplay.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，`MonoBehaviour` 和 GameObjects 之间的交互是一个每个开发者都必须掌握的基本概念，以便有效地将他们的游戏想法变为现实。`MonoBehaviour`
    脚本作为行为的蓝图，当附加到 GameObjects 上时，决定了这些对象在游戏世界中的行为、反应和交互。这种附加关系将静态模型和纹理转换成动态的、交互式元素，这对于创建引人入胜的游戏体验至关重要。
- en: Attaching a MonoBehaviour script to a GameObject in Unity is straightforward.
    In the Unity Editor, this can be done by simply dragging and dropping the script
    onto the desired GameObject in the **Hierarchy** or the scene view. Alternatively,
    developers can use the **Add Component** button in the **Inspector** window when
    a GameObject is selected, searching for and adding the script as a new component.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中将 MonoBehaviour 脚本附加到 GameObject 上非常简单。在 Unity 编辑器中，这可以通过简单地拖放脚本到所需的
    GameObject 上完成，无论是**层次结构**还是场景视图。或者，当选择 GameObject 时，开发者可以在**检查器**窗口中使用**添加组件**按钮，搜索并添加脚本作为新的组件。
- en: '![Figure 4.1 – The Hierarchy window displays objects in the scene. The Inspector
    window displays the properties of a selected object](img/B22128_04_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 层次结构窗口显示场景中的对象。检查器窗口显示所选对象的属性](img/B22128_04_01.jpg)'
- en: Figure 4.1 – The Hierarchy window displays objects in the scene. The Inspector
    window displays the properties of a selected object
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 层次结构窗口显示场景中的对象。检查器窗口显示所选对象的属性
- en: To add a script to a GameObject, select the GameObject in the **Hierarchy**
    window. In the **Inspector** window, scroll to the bottom to find the **Add Component**
    button. Clicking this button will call up a pop-up menu with a listing of available
    scripts/ components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要将脚本添加到 GameObject，请在**层次结构**窗口中选择 GameObject。在**检查器**窗口中，滚动到最底部以找到**添加组件**按钮。点击此按钮将弹出一个包含可用脚本/组件列表的弹出菜单。
- en: '![Figure 4.2 – The Add Component pop-up menu in the Inspector window](img/B22128_04_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 检查器窗口中的“添加组件”弹出菜单](img/B22128_04_2.jpg)'
- en: Figure 4.2 – The Add Component pop-up menu in the Inspector window
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 检查器窗口中的“添加组件”弹出菜单
- en: In the **Add Component** pop-up menu, there is a search field. Start typing
    the name of the component. It is a responsive search. It will return results instantly.
    Double-click or click and press *Enter* to add the selected component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在**添加组件**弹出菜单中，有一个搜索字段。开始键入组件的名称。这是一个响应式搜索。它会立即返回结果。双击或单击并按 *Enter* 键以添加所选组件。
- en: Once attached, the script’s life cycle methods, such as `Start()` and `Update()`,
    are automatically called by the Unity engine at specific points, allowing the
    script to initialize variables, handle input, and modify the GameObject’s properties
    over time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦附加，脚本的生命周期方法，如 `Start()` 和 `Update()`，将在特定点由 Unity 引擎自动调用，允许脚本初始化变量、处理输入并在一段时间内修改
    GameObject 的属性。
- en: 'Consider a simple example where we want a GameObject to continuously rotate.
    The MonoBehaviour script might look something like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的例子，我们希望一个GameObject能够持续旋转。MonoBehaviour 脚本可能看起来像这样：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this `Rotator` script, the `Update()` method utilizes the `Transform.Rotate`
    method to apply a rotation to the GameObject it’s attached to. The rotation is
    dependent on the `rotationSpeed` variable, which can be adjusted in the Unity
    Editor to achieve the desired effect. The use of `Time.deltaTime` ensures that
    the rotation is smooth and frame rate independent, maintaining consistent behavior
    across different hardware.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `Rotator` 脚本中，`Update()` 方法利用 `Transform.Rotate` 方法对其附加的 GameObject 应用旋转。旋转取决于
    `rotationSpeed` 变量，该变量可以在 Unity 编辑器中调整以实现所需效果。使用 `Time.deltaTime` 确保旋转平滑且不受帧率影响，在不同硬件上保持一致的行为。
- en: This seamless integration of MonoBehaviour scripts with GameObjects exemplifies
    Unity’s design philosophy, where game behavior is modular, reusable, and easily
    adjustable. Scripts can be attached to multiple GameObjects, and the same GameObject
    can have multiple scripts attached, allowing for complex behaviors to be built
    up from simpler, more manageable components. This modular approach not only facilitates
    a more organized and efficient workflow but also encourages experimentation and
    creativity in the game development process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MonoBehaviour 脚本与 GameObject 的这种无缝集成体现了 Unity 的设计理念，其中游戏行为是模块化、可重用且易于调整的。脚本可以附加到多个
    GameObject 上，同一个 GameObject 也可以附加多个脚本，从而允许从更简单、更易于管理的组件构建复杂的行为。这种模块化方法不仅促进了更组织化和高效的流程，而且鼓励在游戏开发过程中的实验和创造力。
- en: The intricate dance between MonoBehaviour scripts and GameObjects in Unity forms
    the backbone of interactive and dynamic gameplay, enabling developers to infuse
    static assets with life through code. By attaching scripts such as the illustrated
    `Rotator` to GameObjects, behaviors become customizable and easy to manipulate
    within the Unity Editor, showcasing the engine’s powerful and flexible design.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，MonoBehaviour 脚本和 GameObject 之间的复杂交互构成了交互式和动态游戏玩法的基础，使开发者能够通过代码赋予静态资产生命。通过将如图所示的
    `Rotator` 脚本附加到 GameObject 上，行为变得可定制且易于在 Unity 编辑器中操作，展示了引擎强大而灵活的设计。
- en: As we pivot toward exploring common MonoBehaviour methods such as `Awake()`,
    `Start()`, and `OnEnable()`, it’s essential to understand how these methods further
    enrich the scripting landscape, providing developers with essential hooks into
    the Unity life cycle for initializing variables, preparing GameObjects, and responding
    to game events effectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向探索常见的 MonoBehaviour 方法，如 `Awake()`、`Start()` 和 `OnEnable()` 时，了解这些方法如何进一步丰富脚本环境，为开发者提供进入
    Unity 生命周期的基本钩子，以初始化变量、准备 GameObject 以及有效地响应游戏事件，这一点至关重要。
- en: Exploring common MonoBehaviour methods
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索常见的 MonoBehaviour 方法
- en: Diving deeper into the essence of Unity’s scripting framework, we encounter
    the pivotal MonoBehaviour methods that are instrumental in defining the life cycle
    and behavior of GameObjects. Methods such as `Awake()`, `Start()`, and `OnEnable()`
    serve as the cornerstone for initializing and preparing GameObjects. `Awake()`
    is called when the script instance is being loaded, `Start()` runs just before
    any of the update methods, and `OnEnable()` is invoked when the object becomes
    active. These methods ensure GameObjects are primed and ready for action as soon
    as the game begins.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探索 Unity 脚本框架的精髓，我们会遇到在定义 GameObject 生命周期和行为方面至关重要的 MonoBehaviour 方法。例如 `Awake()`、`Start()`
    和 `OnEnable()` 方法是初始化和准备 GameObject 的基石。`Awake()` 在脚本实例被加载时调用，`Start()` 在任何更新方法之前运行，而
    `OnEnable()` 在对象变为活动状态时被调用。这些方法确保 GameObject 在游戏开始时就已经准备好并随时可以行动。
- en: In addition to the fundamental MonoBehaviour methods, such as `Awake()`, `Start()`,
    and `OnEnable()`, Unity provides a plethora of other methods that offer granular
    control over various aspects of a GameObject’s life cycle and behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 MonoBehaviour 方法，如 `Awake()`、`Start()` 和 `OnEnable()` 之外，Unity 还提供了一系列其他方法，这些方法可以提供对
    GameObject 生命周期和行为各个方面的细粒度控制。
- en: 'Here’s an overview of some additional MonoBehaviour methods and functionalities
    within Unity’s scripting ecosystem:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Unity 脚本生态系统中的某些附加 MonoBehaviour 方法及其功能的概述：
- en: '`OnDisable()`: This method is invoked when the object becomes disabled or inactive.
    It is commonly used for cleanup tasks or to unregister the object from events
    or services it was previously listening to, ensuring that deactivated objects
    do not continue to consume resources or process events.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable()`：当对象变为禁用或非活动状态时，将调用此方法。它通常用于清理任务或从对象之前监听的事件或服务中注销对象，确保已停用的对象不会继续消耗资源或处理事件。'
- en: 'In the following code, the `OnDisable()` method logs a message to the console
    when the object is disabled. In the following example, the GameObject attached
    to this script is destroyed. That is, it is completely removed from the gameplay:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码中，当对象被禁用时，`OnDisable()` 方法会在控制台记录一条消息。在下面的示例中，附加到此脚本的 GameObject 被销毁。也就是说，它被完全从游戏玩法中移除：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`LateUpdate()`: This is called once per frame, after all `Update()` functions
    have been called. This is useful for actions that need to happen after all other
    regular updates, such as character animation adjustments, where the animation
    needs to synchronize with the final positions and states of characters after they
    have completed their movements for the frame. This code defines the `OnDisable`
    method, which Unity automatically calls when a GameObject or its component becomes
    inactive. Inside this method, a message, `"OnDisable called."`, is logged to the
    console, serving as a simple notification or debugging tool to indicate when the
    method is triggered. The following example updates the attached game component,
    `CharacterAnimator`. It supplies a new value for `Speed`, which, for this example,
    we assume is being supplied by another method.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LateUpdate()`: 每帧调用所有 `Update()` 函数之后，会调用一次。这对于需要在所有其他常规更新之后发生的操作很有用，例如角色动画调整，动画需要与角色完成该帧动作后的最终位置和状态同步。此代码定义了
    `OnDisable` 方法，当 GameObject 或其组件变为非活动状态时，Unity 会自动调用此方法。在此方法内部，将消息 `"OnDisable
    called."` 记录到控制台，作为简单的通知或调试工具，以指示何时触发该方法。以下示例更新了附加的游戏组件 `CharacterAnimator`。它为
    `Speed` 提供了一个新值，在这个例子中，我们假设这个值是由另一个方法提供的。'
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`FixedUpdate()`: Unlike `Update()`, which is called once per frame and can
    have varying intervals between calls, `FixedUpdate()` runs at consistent intervals.
    This makes it ideal for physics-related updates where a consistent time step is
    crucial for stable and predictable simulations. This code snippet defines the
    `FixedUpdate` method in Unity, which is called at a consistent rate, independent
    of the game’s frame rate. It logs the message `"FixedUpdate called."` to the console
    every time it executes, and is typically used for physics calculations and consistent
    updates. In the following example, Gravity and the Rigidbody’s (`rb`) mass is
    applied to the GameObject:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate()`: 与 `Update()` 不同，`Update()` 每帧调用一次，调用之间可能有不同的间隔，而 `FixedUpdate()`
    以一致的间隔运行。这使得它非常适合与物理相关的更新，其中一致的时间步对于稳定和可预测的模拟至关重要。此代码片段在 Unity 中定义了 `FixedUpdate`
    方法，它以一致的速率调用，独立于游戏的帧率。每次执行时，它都会将消息 `"FixedUpdate called."` 记录到控制台，通常用于物理计算和一致更新。在以下示例中，将重力以及刚体（`rb`）的质量应用于
    GameObject：'
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`OnBecameVisible()` and `OnBecameInvisible()`: These methods are called when
    the GameObject becomes either visible or invisible to any camera. They are handy
    for optimizing performance by enabling or disabling processing or rendering tasks
    based on the visibility of the object.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnBecameVisible()` 和 `OnBecameInvisible()`: 当 GameObject 对任何相机可见或不可见时，会调用这些方法。这些方法很方便，可以根据对象的可见性来启用或禁用处理或渲染任务，从而优化性能。'
- en: 'The following code snippets are Unity event methods that detect the visibility
    of a GameObject. `OnBecameVisible()` is called when the GameObject becomes visible
    to any camera, logging `"Object is now visible."`. Similarly, `OnBecameInvisible()`
    is triggered when the GameObject is no longer visible to any camera, logging `"Object
    is now invisible."`. These methods are useful for managing behavior based on visibility,
    such as optimizing performance by disabling off-screen processes. In the following
    example, a particle system, such as a magic effect, is toggled on and off when
    the game object is made visible or invisible:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段是 Unity 事件方法，用于检测 GameObject 的可见性。当 GameObject 对任何相机可见时，会调用 `OnBecameVisible()`，记录
    `"Object is now visible."`。同样，当 GameObject 对任何相机不再可见时，会触发 `OnBecameInvisible()`，记录
    `"Object is now invisible."`。这些方法对于基于可见性管理行为很有用，例如通过禁用屏幕外进程来优化性能。在以下示例中，当游戏对象变为可见或不可见时，会切换粒子系统（如魔法效果）的开启和关闭：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`OnDestroy()`: This method is called when a MonoBehaviour instance is destroyed,
    either because its GameObject is being destroyed or because the MonoBehaviour
    is being removed from the GameObject. It’s an appropriate place to perform any
    final cleanup, such as saving state or gracefully disconnecting from services
    or networks.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy()`: 当 MonoBehaviour 实例被销毁时，会调用此方法，无论是其 GameObject 被销毁，还是 MonoBehaviour
    被从 GameObject 中移除。这是一个执行任何最终清理的合适位置，例如保存状态或优雅地断开与服务或网络的连接。'
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Mathf`: While not a MonoBehaviour method, `Mathf` is a class provided by Unity
    that contains static methods and constants useful for mathematical operations,
    especially those related to floating-point numbers. It includes functions for
    trigonometric operations, logarithms, and other common mathematical calculations.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mathf`：虽然不是MonoBehaviour方法，但`Mathf`是Unity提供的一个包含静态方法和常量的类，这些方法和常量对于数学运算非常有用，尤其是与浮点数相关的运算。它包括三角运算、对数和其他常见数学计算的功能。'
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of these methods and functionalities plays a specific role in the life
    cycle and behavior management of GameObjects within Unity. By understanding and
    effectively using these methods, developers can create more dynamic, efficient,
    and responsive game experiences.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法和功能中的每一个都在Unity中GameObject的生命周期和行为管理中扮演着特定的角色。通过理解和有效使用这些方法，开发者可以创建更动态、高效和响应的游戏体验。
- en: Through the exploration of MonoBehaviour and its interaction with GameObjects
    in Unity, we’ve delved into the pivotal methods that empower developers to define
    and refine game behavior dynamically. From the initialization powerhouses of `Awake()`,
    `Start()`, and `OnEnable()` to the event-driven responses of `OnDisable()`, `OnBecameVisible()`,
    and `OnBecameInvisible()`, we’ve uncovered the layers that make Unity scripts
    versatile tools in game development.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对MonoBehaviour及其与Unity中GameObject的交互的探索，我们深入研究了赋予开发者动态定义和细化游戏行为的关键方法。从初始化的强大功能`Awake()`、`Start()`和`OnEnable()`到事件驱动的响应`OnDisable()`、`OnBecameVisible()`和`OnBecameInvisible()`，我们揭示了使Unity脚本成为游戏开发中多才多艺工具的层次。
- en: As we transition from understanding these foundational aspects, we venture into
    the broader scope of the Unity script lifecycle. This next section will provide
    a detailed examination of the life cycle’s phases, from initialization through
    to cleanup, offering a comprehensive understanding of how and when different MonoBehaviour
    methods are invoked by Unity. This knowledge is crucial for orchestrating the
    complex symphony of interactions and behaviors that bring a game to life, ensuring
    developers can harness the full potential of Unity’s scripting engine for efficient
    and effective game design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从理解这些基础方面过渡，我们进入了Unity脚本生命周期的更广泛范围。接下来的这一节将详细检查生命周期的各个阶段，从初始化到清理，全面了解Unity如何以及何时调用不同的MonoBehaviour方法。这种知识对于编排游戏互动和行为的复杂交响曲至关重要，确保开发者能够充分利用Unity脚本引擎的潜力，进行高效和有效的游戏设计。
- en: Exploring Unity’s script life cycle and event order
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Unity的脚本生命周期和事件顺序
- en: Embarking on a detailed exploration of the Unity script life cycle unveils the
    orchestrated sequence and execution order of events that are fundamental to the
    dynamic and responsive nature of GameObjects within the Unity environment. The
    Unity script life cycle is a meticulously designed framework that ensures scripts
    react appropriately at various stages of a game’s runtime, from initialization
    to the final cleanup.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨Unity脚本生命周期，揭示了在Unity环境中GameObject动态和响应性本质的基本事件序列和执行顺序。Unity脚本生命周期是一个精心设计的框架，确保脚本在游戏运行的不同阶段能够适当地做出反应，从初始化到最终的清理。
- en: Understanding this life cycle is pivotal for developers, as it influences every
    aspect of script execution and interaction within a game. By delving into the
    intricacies of this life cycle, from the very first awakening of a script to its
    last act before destruction, we gain invaluable insights into the mechanics of
    Unity’s scripting backbone. This sets the stage for optimized and coherent game
    behavior programming.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，理解这个生命周期至关重要，因为它影响游戏中脚本执行的各个方面和交互。通过深入研究这个生命周期的复杂性，从脚本最初的唤醒到其毁灭前的最后一刻，我们获得了Unity脚本骨架机制的宝贵见解。这为优化和连贯的游戏行为编程奠定了基础。
- en: The Unity script life cycle is a well-defined sequence of events that dictates
    how and when scripts attached to GameObjects are executed. This life cycle is
    crucial for game development in Unity, as it determines the behavior of GameObjects
    from the moment they are instantiated until they are destroyed. A thorough understanding
    of this life cycle and the order of method calls within a single frame of gameplay
    is essential for creating efficient, responsive, and well-organized games.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 脚本的生命周期是一系列定义良好的事件序列，它决定了附加到 GameObject 的脚本如何以及何时执行。这个生命周期对于 Unity 中的游戏开发至关重要，因为它决定了
    GameObject 从实例化到销毁期间的行为。对这一生命周期以及单个游戏帧内方法调用顺序的深入了解对于创建高效、响应迅速且组织良好的游戏至关重要。
- en: 'At the start of a GameObject’s life, before any gameplay begins, Unity calls
    a series of initialization methods to set up the scene and its objects:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GameObject 生命周期的开始，在游戏开始之前，Unity 会调用一系列初始化方法来设置场景及其对象：
- en: '`Awake()`: This method is called when a script instance is loaded, even before
    the game starts. It’s used to initialize variables or game state before the game
    begins. All `Awake()` calls are completed before any `Start()` calls begin.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Awake()`: 当脚本实例被加载时调用此方法，甚至在游戏开始之前。它用于在游戏开始之前初始化变量或游戏状态。所有 `Awake()` 调用都将在任何
    `Start()` 调用开始之前完成。'
- en: '`OnEnable()`: If a GameObject is active, `OnEnable()` is called after `Awake()`.
    This method is invoked every time the object is enabled, making it suitable for
    resetting or initializing the state when objects become active again after being
    disabled.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnEnable()`: 如果一个 GameObject 是活动的，`OnEnable()` 会在 `Awake()` 之后被调用。此方法在对象每次启用时都会被调用，因此适合在对象在被禁用后再次变为活动状态时重置或初始化状态。'
- en: '`Start()`: Called before the first frame update but after all `Awake()` methods
    have been executed, `Start()` is ideal for initialization that depends on other
    objects having been set up by their `Awake()` methods.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Start()`: 在第一次帧更新之前调用，但在所有 `Awake()` 方法执行之后，`Start()` 是进行依赖于其他对象通过其 `Awake()`
    方法设置的初始化的理想时机。'
- en: 'During each frame of gameplay, Unity processes input, runs game logic, and
    renders the frame in a specific order:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个游戏帧中，Unity 按特定顺序处理输入、运行游戏逻辑并渲染帧：
- en: '**Input events**: At the beginning of a frame, Unity first processes input
    events such as keyboard, mouse, or touch inputs.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**输入事件**：在帧的开始，Unity 首先处理输入事件，如键盘、鼠标或触摸输入。'
- en: '`Update()`, is called once per frame and is where most of your game’s logic
    will reside, from movement to reaction to input.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update()` 在每一帧被调用一次，并且是大多数游戏逻辑所在的地方，从移动到对输入的反应。'
- en: '`Update()` methods have been executed, `LateUpdate()` is useful for actions
    that need to happen after other updates have occurred, such as character animations,
    AI behaviors, and physics-based calculations.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Update()` 方法执行后，`LateUpdate()` 对于需要在其他更新之后发生的操作非常有用，例如角色动画、AI 行为和基于物理的计算。'
- en: '`FixedUpdate()` is called at fixed intervals and is where physics calculations
    and updates should occur.'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FixedUpdate()` 以固定间隔被调用，并且是进行物理计算和更新的地方。'
- en: '**Rendering**: Finally, the frame is rendered, and any visual updates appear
    on the screen.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**渲染**：最后，帧被渲染，任何视觉更新都会出现在屏幕上。'
- en: 'At the end of an object’s life cycle or when the gameplay scenario changes,
    cleanup methods are invoked:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的生命周期结束时或当游戏场景发生变化时，会调用清理方法：
- en: '`OnDisable()`: When a GameObject is disabled, `OnDisable()` is called, providing
    an opportunity to stop animations or sounds.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable()`: 当 GameObject 被禁用时，`OnDisable()` 被调用，提供了停止动画或声音的机会。'
- en: '`OnDestroy()`: Right before the object is destroyed, `OnDestroy()` allows for
    final cleanup, such as disabling UI elements.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy()`: 在对象销毁之前，`OnDestroy()` 允许进行最后的清理，例如禁用 UI 元素。'
- en: The following chart illustrates the execution order of Unity’s lifecycle methods,
    from Awake to OnDestroy, providing a clear overview of when each function is called.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了 Unity 生命周期方法的执行顺序，从 `Awake` 到 `OnDestroy`，提供了每个函数被调用时的清晰概述。
- en: '| **Initialization** |  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **初始化** |  |'
- en: '|  | `Awake()``OnEnable()``Start()` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  | `Awake()``OnEnable()``Start()` |'
- en: '| **Per frame** |  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **每帧** |  |'
- en: '|  | `Input Events` (an internal Unity process)`Update()``LateUpdate()``FixedUpdate()*[Physics
    Update]``Rendering` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  | `输入事件`（Unity 的内部过程）`Update()``LateUpdate()``FixedUpdate()`*[物理更新]*`渲染`
    |'
- en: '| **Cleanup** |  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **清理** |  |'
- en: '|  | `OnDisable()``OnDestroy()` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  | `OnDisable()``OnDestroy()` |'
- en: Table 4.1 – Unity’s order of events
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – Unity 的事件顺序
- en: Note
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Physics updates occur on a separate set schedule, approximately 1/60th of a
    second. This may or may not match the frame rate of the game. This means that
    `FixedUpdate()` and `Update()` rarely occur at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 物理更新在单独的时序上发生，大约每秒60分之一秒。这可能与游戏的帧率不匹配。这意味着`FixedUpdate()`和`Update()`很少同时发生。
- en: Understanding this sequence is critical for optimizing game performance and
    behavior. By aligning game logic with the life cycle’s phases, developers can
    ensure smooth gameplay, with each script operating cohesively within Unity’s meticulously
    orchestrated environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这个顺序对于优化游戏性能和行为至关重要。通过将游戏逻辑与生命周期的阶段相匹配，开发者可以确保流畅的游戏体验，每个脚本都在Unity精心编排的环境中协同工作。
- en: The Unity script life cycle orchestrates the sequence in which GameObject behaviors
    are initiated, updated, and eventually terminated within a single frame, ensuring
    a coherent flow of gameplay. This life cycle begins with crucial initialization
    methods such as `Awake()`, `OnEnable()`, and `Start()`, setting the stage for
    GameObjects to be prepared and responsive at the onset of the game.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Unity脚本生命周期协调了GameObject行为在单个帧内被启动、更新和最终终止的顺序，确保了游戏流程的连贯性。这个生命周期从关键的初始化方法开始，如`Awake()`、`OnEnable()`和`Start()`，为GameObject在游戏开始时做好准备和响应奠定了基础。
- en: As we transition to a more granular examination of the initialization phase,
    we’ll delve into the specific roles and use cases of these foundational methods.
    Understanding how to effectively leverage `Awake()` for setting up initial states,
    `OnEnable()` for managing object activation, and `Start()` for dependent initializations
    is paramount for crafting well-structured and efficient Unity scripts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们转向对初始化阶段的更细致考察，我们将深入探讨这些基础方法的具体角色和用例。理解如何有效地利用`Awake()`来设置初始状态，`OnEnable()`来管理对象激活，以及`Start()`来进行依赖初始化，对于编写结构良好且高效的Unity脚本至关重要。
- en: Exploring Unity’s initialization methods
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Unity的初始化方法
- en: The `Awake()`, `OnEnable()`, and `Start()`—each serving a distinct purpose in
    the life cycle of a script.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Awake()`、`OnEnable()`和`Start()`——在脚本的生命周期中各自发挥着独特的作用。'
- en: 'Now, let us explore some of the use cases associated with each of these methods:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索与这些方法相关的用例：
- en: 'Use cases for `Awake()`:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake()`的用例：'
- en: Setting up component references within the same GameObject.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一GameObject内设置组件引用。
- en: Initializing non-dependent data structures or variables, such as setting initial
    health values or configuring base speeds.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化非依赖的数据结构或变量，例如设置初始生命值或配置基础速度。
- en: 'Use cases for `OnEnable()`:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnEnable()`的用例：'
- en: Subscribing to game events or notifications, ensuring the object only listens
    or reacts when it’s active in the scene.
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅游戏事件或通知，确保对象仅在场景中激活时才监听或做出反应。
- en: Resetting object states or counters, which is useful in scenarios where GameObjects
    are frequently reused, such as in object pooling systems for projectiles or enemies.
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置对象状态或计数器，这在GameObject频繁重用的场景中很有用，例如在用于投射物或敌人的对象池系统中。
- en: 'Use cases for `Start()`:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`的用例：'
- en: Establishing links with other GameObjects that need to be present and initialized
    beforehand, such as setting up a player character to follow a target that is guaranteed
    to be initialized.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立与其他需要先存在和初始化的GameObject的链接，例如设置玩家角色跟随一个保证已初始化的目标。
- en: Delayed initialization tasks that benefit from ensuring the entire scene’s `Awake()`
    methods have been completed, providing a clean setup for interconnected systems.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟初始化任务，这些任务从确保整个场景的`Awake()`方法已经完成中受益，为相互连接的系统提供了一个干净的设置。
- en: By understanding and leveraging these methods appropriately, developers can
    ensure that GameObjects not only are initialized efficiently but also maintain
    a clean and orderly state throughout the game’s runtime. Each method offers unique
    opportunities for setting up GameObjects in a way that aligns with the broader
    architecture and flow of the game, contributing to a more manageable and scalable
    code base.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解和适当利用这些方法，开发者可以确保GameObject不仅初始化高效，而且在游戏运行期间保持干净和有序的状态。每种方法都提供了设置GameObject的独特机会，使其与游戏更广泛的架构和流程相一致，从而有助于代码库更易于管理和扩展。
- en: The initialization phase in Unity meticulously prepares GameObjects for the
    journey ahead, employing `Awake()`, `OnEnable()`, and `Start()` methods to establish
    a solid foundation. Through setting component references, subscribing to events,
    and inter-object communication, these methods collectively ensure that each GameObject
    is optimally configured and intertwined with the game environment from the outset.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的初始化阶段精心准备 GameObject 以进行未来的旅程，使用 `Awake()`、`OnEnable()` 和 `Start()`
    方法建立坚实的基础。通过设置组件引用、订阅事件和对象间通信，这些方法共同确保每个 GameObject 从一开始就得到最佳配置并与游戏环境紧密结合。
- en: As we transition from this crucial setup stage into the game loop phase, our
    focus shifts to the continuous cycle of gameplay. Here, we delve into the core
    methods that drive game dynamics frame by frame—`Update()`, `FixedUpdate()`, and
    `LateUpdate()`. This exploration will highlight the distinctions between these
    methods and guide on their effective application, ensuring a smooth and responsive
    gaming experience that aligns with Unity’s real-time rendering and physics systems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从这个关键设置阶段过渡到游戏循环阶段时，我们的焦点转向游戏连续循环。在这里，我们深入探讨驱动游戏动态帧帧的核心方法——`Update()`、`FixedUpdate()`
    和 `LateUpdate()`。这次探索将突出这些方法之间的区别，并指导它们的有效应用，确保游戏体验流畅且响应迅速，与 Unity 的实时渲染和物理系统相一致。
- en: Understanding Unity’s game loop
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Unity 的游戏循环
- en: 'Transitioning from the foundational initialization phase, where GameObjects
    are meticulously prepared and set up for action, we venture into the heart of
    Unity’s scripting life cycle: the **game** **loop phase**.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础初始化阶段过渡，在这个阶段，GameObject 被精心准备和设置以进行行动，我们进入 Unity 脚本生命周期的心脏：**游戏循环阶段**。
- en: This phase is characterized by the continuous cycle of methods such as `Update()`,
    `FixedUpdate()`, and `LateUpdate()`, each playing a critical role in driving game
    dynamics and interactions frame by frame. An in-depth examination of these methods
    reveals their unique functions and timing within the game loop, highlighting the
    nuances that dictate their most effective usage. Understanding the distinctions
    and appropriate applications of these methods is crucial for optimizing game performance
    and ensuring smooth, responsive gameplay experiences.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的特点是 `Update()`、`FixedUpdate()` 和 `LateUpdate()` 等方法的连续循环，每个方法在驱动游戏动态和交互帧帧中扮演着关键角色。对这些方法的深入分析揭示了它们在游戏循环中的独特功能和时机，突出了指导它们最有效使用的细微差别。理解这些方法的区别和适当的应用对于优化游戏性能和确保流畅、响应迅速的游戏体验至关重要。
- en: 'The game loop phase in Unity is where the magic happens, bringing GameObjects
    to life through continuous updates and interactions. Central to this phase are
    three pivotal methods: `Update()`, `FixedUpdate()`, and `LateUpdate()`. Each plays
    a distinct role in the game’s execution cycle, affecting everything from physics
    calculations to rendering.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的游戏循环阶段是魔法发生的地方，通过连续的更新和交互使 GameObject 活起来。这个阶段的核心是三个关键方法：`Update()`、`FixedUpdate()`
    和 `LateUpdate()`。每个方法在游戏的执行周期中扮演着独特的角色，影响着从物理计算到渲染的各个方面。
- en: 'Diving into the Unity game loop, here’s a breakdown of key methods and their
    applications:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 深入 Unity 游戏循环，以下是关键方法和它们的应用分析：
- en: 'Use cases for `Update()`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()` 的用例：'
- en: '`Time.deltaTime` to decrement the timer value.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Time.deltaTime` 来减少计时器值。
- en: 'Use cases for `FixedUpdate()`:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixedUpdate()` 的用例：'
- en: '`Rigidbody` components, ensuring consistent physics simulation.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rigidbody` 组件，确保一致的物理模拟。'
- en: '**Physics-based animations**: Animating objects that rely on physics calculations,
    such as a swinging pendulum, to maintain realistic behavior.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于物理的动画**：动画化依赖于物理计算的物体，例如摆动的摆锤，以保持逼真的行为。'
- en: '**Repeating actions with precision**: Executing actions that require precise
    timing, unaffected by frame rate variability, such as firing projectiles at regular
    intervals.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精确重复动作**：执行需要精确时间且不受帧率变化影响的动作，例如以固定间隔发射弹丸。'
- en: 'Use cases for `LateUpdate()`:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LateUpdate()` 的用例：'
- en: '`Update()`.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`。'
- en: '`Update()`, ensuring that the response occurs after all other updates.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update()`，确保响应发生在所有其他更新之后。'
- en: Understanding the nuances of `Update()`, `FixedUpdate()`, and `LateUpdate()`—and
    their respective use cases—allows developers to effectively orchestrate GameObject
    behaviors, physics interactions, and camera controls. By aligning specific tasks
    with the most appropriate method, developers can optimize game performance, ensure
    smooth gameplay, and create a more polished and responsive game experience.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Update()`、`FixedUpdate()`和`LateUpdate()`的细微差别及其相应的使用场景，使开发者能够有效地编排GameObject的行为、物理交互和相机控制。通过将特定任务与最合适的方法对齐，开发者可以优化游戏性能，确保流畅的游戏体验，并创建更精致和响应的游戏体验。
- en: Within the rhythmic flow of Unity’s game loop phase, the strategic use of the
    `Update()`, `FixedUpdate()`, and `LateUpdate()` methods breathes life into GameObjects,
    dictating their behaviors, movements, and interactions. From the frame-by-frame
    logic handling in `Update()` to the precision of physics calculations in `FixedUpdate()`,
    and the final adjustments in `LateUpdate()`, each method serves a unique purpose
    in crafting a seamless gaming experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏循环阶段的节奏性流程中，战略性地使用`Update()`、`FixedUpdate()`和`LateUpdate()`方法为GameObject注入活力，规定其行为、移动和交互。从`Update()`中的帧帧逻辑处理到`FixedUpdate()`中的物理计算精度，再到`LateUpdate()`中的最终调整，每种方法在打造无缝游戏体验中都有其独特的作用。
- en: As we transition from the vibrant activity of the game loop to the concluding
    cleanup phase, the focus shifts toward ensuring graceful termination and resource
    management. Understanding `OnDisable()` and `OnDestroy()` becomes essential, as
    these methods facilitate the tidy release of resources and the clean removal of
    GameObjects, preventing memory leaks and ensuring that your game remains efficient
    and responsive over time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从游戏循环的活跃活动过渡到清理阶段时，重点转向确保优雅的终止和资源管理。理解`OnDisable()`和`OnDestroy()`变得至关重要，因为这些方法促进了资源的整洁释放和GameObject的干净移除，防止内存泄漏并确保游戏在长时间内保持高效和响应。
- en: Navigating Unity’s cleanup cycle
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航Unity的清理周期
- en: The `OnDisable()` and `OnDestroy()`. These methods are instrumental in the proper
    management and cleanup of resources, ensuring that GameObjects are gracefully
    deactivated and destroyed without leaving behind a trail of unused assets or memory
    leaks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDisable()`和`OnDestroy()`。这些方法在资源适当管理和清理中起着关键作用，确保GameObject能够优雅地停用和销毁，不会留下未使用的资产或内存泄漏的痕迹。'
- en: While `OnDisable()` allows for the tidy suspension of activities and event listeners
    when objects are no longer in use, `OnDestroy()` provides a final checkpoint for
    releasing resources and cleaning up before an object is permanently removed. Mastering
    these cleanup functions is essential for developing efficient, sustainable games
    that manage system resources wisely, contributing to an overall smoother gaming
    experience.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`OnDisable()`允许在对象不再使用时整洁地暂停活动和事件监听器，但`OnDestroy()`提供了一个释放资源并在对象永久移除前的最后检查点。掌握这些清理函数对于开发高效、可持续的游戏至关重要，这些游戏明智地管理系统资源，从而为整体更流畅的游戏体验做出贡献。
- en: The cleanup phase in Unity’s game development process is critical for ensuring
    that resources are managed efficiently, preventing memory leaks, and maintaining
    optimal performance throughout the life cycle of a game. This phase prominently
    features two MonoBehaviorMonoBehaviour methods, `OnDisable()` and `OnDestroy()`,
    each serving a specific purpose in the resource management and cleanup process.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Unity游戏开发过程中的清理阶段对于确保资源高效管理、防止内存泄漏并在游戏生命周期内保持最佳性能至关重要。这一阶段突出显示了两个MonoBehaviour方法，`OnDisable()`和`OnDestroy()`，每个方法在资源管理和清理过程中都发挥着特定的作用。
- en: 'Exploring the Unity cleanup cycle, the following are some of the key methods
    and their applications:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 探索Unity清理周期，以下是一些关键方法和它们的应用：
- en: 'Use cases for `OnDisable()`:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable()`的使用场景：'
- en: '`OnDisable()` should be used to unsubscribe from these events to avoid null
    reference errors or unwanted behavior when the object is not active.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用`OnDisable()`来取消订阅这些事件，以避免在对象不活跃时出现空引用错误或不受欢迎的行为。
- en: '`OnDisable()` is a suitable place to stop them, especially if they’re not relevant
    when the object is inactive.'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable()`是一个停止它们的合适位置，尤其是如果它们在对象不活跃时不相关。'
- en: '`OnDisable()` can signal the need to inform other players or the server that
    a particular object is no longer active, ensuring a consistent game state across
    the network.'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDisable()`可以表示需要通知其他玩家或服务器，特定对象不再活跃，确保网络上的游戏状态一致。'
- en: 'Use cases for `OnDestroy()`:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy()`的使用场景：'
- en: '`OnDestroy()` can trigger saving this data to disk or player preferences, ensuring
    no progress is lost.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnDestroy()`可以触发将数据保存到磁盘或玩家偏好设置，确保不会丢失任何进度。'
- en: '**Cleanup notifications**: Informing other parts of the game that an object
    is about to be destroyed, which might be necessary for updating UI elements, leaderboards,
    or player stats.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理通知**：通知游戏的其他部分一个对象即将被销毁，这可能对于更新UI元素、排行榜或玩家统计信息是必要的。'
- en: Understanding and effectively utilizing `OnDisable()` and `OnDestroy()` allows
    developers to maintain control over their game’s resource management and cleanup
    processes, ensuring that the game remains efficient and stable over time. Implementing
    thoughtful cleanup logic in these methods helps prevent performance degradation,
    especially in long-running or resource-intensive games, contributing to a smoother
    and more enjoyable player experience.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并有效地利用`OnDisable()`和`OnDestroy()`，允许开发者保持对其游戏资源管理和清理过程的控制，确保游戏在长时间运行或资源密集型游戏中保持高效和稳定。在这些方法中实施深思熟虑的清理逻辑有助于防止性能下降，特别是在长时间运行或资源密集型游戏中，有助于提供更流畅和愉悦的玩家体验。
- en: As we transition from the crucial aspects of resource management and cleanup
    in the cleanup phase, we delve into the dynamic realm of responding to player
    input. This next section explores Unity’s versatile input system, guiding you
    through the essentials of capturing and responding to player interactions. From
    crafting scripts for fundamental player movements to accommodating advanced input
    methods such as touch and mouse controls, we’ll cover the spectrum of input handling.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从清理阶段的关键方面——资源管理和清理过渡时，我们深入到响应玩家输入的动态领域。接下来的这一节探讨了Unity的多功能输入系统，指导你掌握捕捉和响应玩家交互的基本要素。从编写用于基本玩家移动的脚本到适应高级输入方法，如触摸和鼠标控制，我们将涵盖输入处理的整个范围。
- en: Additionally, we’ll share best practices for efficient input management, ensuring
    your game not only responds intuitively to player actions but does so with clean,
    maintainable code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将分享高效输入管理的最佳实践，确保你的游戏不仅能够直观地响应玩家操作，而且使用的是干净、可维护的代码。
- en: Responding to player input
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应玩家输入
- en: In the realm of game development with Unity and C#, responding adeptly to player
    input is a cornerstone of immersive gameplay. This section delves into the intricacies
    of Unity’s input system, laying the groundwork for developers to harness scripts
    for capturing and interpreting player interactions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Unity和C#进行游戏开发的过程中，熟练地响应玩家输入是沉浸式游戏体验的基础。本节深入探讨了Unity输入系统的复杂性，为开发者提供了利用脚本捕捉和解释玩家交互的基础。
- en: From the fundamentals of scripting basic player movements, such as navigating
    a camera in a 3D space, to integrating advanced input methods such as touch and
    mouse controls, we’ll explore a spectrum of techniques to accommodate a wide array
    of devices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本编写基本玩家移动的基础，例如在3D空间中导航摄像机，到集成高级输入方法，如触摸和鼠标控制，我们将探索一系列技术以适应广泛的设备。
- en: Moreover, we’ll share best practices for input handling, including strategies
    such as debouncing and input abstraction, to ensure your code remains efficient
    and manageable. Whether you’re building an action-packed adventure or a serene
    exploration game, mastering input handling is key to crafting responsive and engaging
    player experiences.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将分享输入处理的最佳实践，包括诸如防抖动和输入抽象等策略，以确保你的代码保持高效和可管理。无论你是在构建充满动作的冒险游戏还是宁静的探索游戏，掌握输入处理是制作响应和吸引人的玩家体验的关键。
- en: Introducing Unity’ss input system
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Unity的输入系统
- en: Navigating the dynamic world of Unity and C#, the ability to respond to player
    input is what breathes life into a game, transforming it from a static scene into
    an interactive experience. This section introduces Unity’s versatile **input system**,
    a pivotal tool for game developers aiming to create responsive and intuitive gameplay.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity和C#的动态世界中导航，响应玩家输入的能力是赋予游戏生命力的关键，它将游戏从静态场景转变为互动体验。本节介绍了Unity的多功能**输入系统**，这是游戏开发者创建响应和直观游戏体验的关键工具。
- en: Through an exploration of how scripts can be designed to capture and react to
    a myriad of player interactions, from the simplest button presses to complex gesture
    recognitions, we’ll lay the foundation for building immersive worlds that players
    can truly engage with. Whether you’re crafting a fast-paced action game or a strategic
    puzzle, understanding the mechanics of input handling in Unity is the first step
    toward bringing your game to life. Unity’s input system is designed to be flexible
    and easy to use, allowing developers to capture a wide range of player interactions
    and movements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探讨如何设计脚本以捕捉和响应各种玩家交互，从最简单的按钮按下到复杂的手势识别，我们将为构建玩家真正能参与的沉浸式世界奠定基础。无论你是在制作快节奏的动作游戏还是策略解谜游戏，理解
    Unity 中输入处理机制是让你的游戏栩栩如生的第一步。Unity 的输入系统旨在灵活且易于使用，允许开发者捕捉广泛的玩家交互和动作。
- en: At the heart of Unity’s input handling is the `Input` class, which provides
    access to the keyboard, mouse, joystick, and touch devices. Through this class,
    developers can check for user input in various forms, such as whether a specific
    key is being pressed or the mouse has been moved. Unity’s input system also supports
    more advanced features, such as touch and accelerometer inputs, making it well
    suited for mobile game development.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 输入处理的核心是 `Input` 类，它提供了对键盘、鼠标、游戏手柄和触摸设备的访问。通过这个类，开发者可以检查各种形式的用户输入，例如是否按下了特定的键或鼠标是否被移动。Unity
    的输入系统还支持更高级的功能，如触摸和加速度计输入，使其非常适合移动游戏开发。
- en: 'To illustrate how Unity’s input system can be utilized, consider a basic example
    where we move a character left or right based on keyboard input. The following
    C# script demonstrates this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何利用 Unity 的输入系统，考虑一个基本示例，其中我们根据键盘输入移动角色左右。以下 C# 脚本展示了这一点：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this script, `Input.GetAxis("Horizontal")` is used to capture horizontal
    movement inputs (left and right arrow keys or *A* and *D* keys on a keyboard).
    This value is then used to create a movement vector, which is applied to the player’s
    position, thus moving the character left or right.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`Input.GetAxis("Horizontal")` 用于捕捉水平移动输入（左右箭头键或键盘上的 *A* 和 *D* 键）。然后，这个值被用来创建一个移动向量，并将其应用于玩家的位置，从而将角色向左或向右移动。
- en: Unity’s input system is not just limited to handling keyboard and mouse inputs;
    it is also capable of processing inputs from gamepads, touchscreens, and other
    input devices. This makes it an incredibly powerful tool for developers looking
    to create games across different platforms.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的输入系统不仅限于处理键盘和鼠标输入；它还能处理来自游戏手柄、触摸屏和其他输入设备的输入。这使得它成为开发者创建跨平台游戏时一个极其强大的工具。
- en: Furthermore, Unity offers the **Input Manager**, which allows developers to
    define and customize input axes and buttons, providing a higher level of abstraction
    and flexibility. This means that game controls can be easily adjusted or remapped
    without having to change the code, enhancing the game’s accessibility and user
    experience.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Unity 提供了 **Input Manager**，它允许开发者定义和自定义输入轴和按钮，提供更高层次的抽象和灵活性。这意味着游戏控制可以轻松调整或重新映射，而无需更改代码，从而提高了游戏的可访问性和用户体验。
- en: By leveraging Unity’s comprehensive input system, developers can craft responsive
    gameplay that reacts to every action a player takes, making the game world feel
    alive and interactive. Whether it’s navigating through a 3D landscape, battling
    enemies in a fast-paced shooter, or solving puzzles in a point-and-click adventure,
    the ability to effectively respond to player input is what makes a game truly
    immersive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 Unity 的全面输入系统，开发者可以制作出对玩家采取的每个动作都有反应的响应式游戏玩法，使游戏世界感觉生动且互动。无论是导航 3D 地形、在快节奏的射击游戏中与敌人战斗，还是在点击式冒险游戏中解决谜题，有效响应玩家输入的能力才是使游戏真正沉浸式的关键。
- en: Unity's input system serves as the cornerstone for player interaction, enabling
    developers to seamlessly capture and process a wide range of inputs for dynamic
    gameplay. Through the use of the `Input` class, it facilitates the creation of
    intuitive and responsive controls, paving the way for immersive experiences across
    various platforms.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 的输入系统是玩家交互的基石，它使开发者能够无缝地捕捉和处理各种输入，以实现动态的游戏玩法。通过使用 `Input` 类，它促进了直观和响应式控制器的创建，为跨平台提供沉浸式体验铺平了道路。
- en: Unity’s input system is pivotal in crafting responsive and immersive gameplay,
    allowing developers to harness a variety of player actions to enrich the game
    world. This system not only facilitates the creation of intuitive controls across
    different game genres but also ensures seamless interaction, making every move
    and decision impactful and engaging for players.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的输入系统在制作响应性和沉浸式游戏体验中起着关键作用，它允许开发者利用各种玩家动作来丰富游戏世界。该系统不仅促进了不同游戏类型直观控制的创建，还确保了无缝的交互，使每个动作和决策对玩家都具有影响力和吸引力。
- en: As we transition from understanding this versatile input handling to implementing
    movement, we’ll explore how to effectively translate these inputs into fluid and
    coherent player movements, which is essential for crafting engaging 3D environments
    and ensuring a smooth gameplay experience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从理解这种多功能的输入处理过渡到实现移动时，我们将探讨如何有效地将这些输入转换为流畅且连贯的玩家移动，这对于制作引人入胜的3D环境和确保流畅的游戏体验至关重要。
- en: Crafting movement – building basic player navigation
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建移动——建立基本的玩家导航
- en: In the realm of game development with Unity, implementing responsive and intuitive
    player movement stands as a pivotal aspect of creating an immersive gameplay experience.
    Whether it’s guiding a character through a labyrinthine landscape or navigating
    a camera through a vividly rendered 3D space, the fluidity and precision of movement
    play a critical role in engaging the player. This section delves into the foundational
    steps of crafting a basic movement script using C#, offering a hands-on approach
    to bringing motion mechanics to life.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Unity进行游戏开发的过程中，实现响应性和直观的玩家移动是创建沉浸式游戏体验的关键方面。无论是引导角色穿越迷宫般的景观，还是通过生动渲染的3D空间导航摄像机，移动的流畅性和精确性在吸引玩家方面发挥着至关重要的作用。本节深入探讨了使用C#制作基本移动脚本的初步步骤，提供了一种将运动机制付诸实践的方法。
- en: We’ll start by outlining the essentials of a movement script, then proceed to
    a practical example where we apply these principles to enable a camera or character
    to traverse a 3D environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先概述移动脚本的要点，然后通过一个实际示例来应用这些原则，使摄像机或角色能够在3D环境中穿越。
- en: 'Here’s a glimpse of a simple script that could be used to move an object in
    Unity:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的脚本示例，可用于在Unity中移动对象：
- en: '[PRE11]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This basic script captures horizontal and vertical inputs from the player (typically
    through keyboard arrows or a joystick). It translates them into movement along
    the game world’s *x* and *z* axes, with `Time.deltaTime` ensuring smooth motion
    across different frame rates. As we explore this topic further in chapters *5*
    and *8*, we’ll dissect the components of this script and expand on how to refine
    and adapt it to suit various gameplay mechanics and styles.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本脚本捕获玩家的水平和垂直输入（通常通过键盘箭头或操纵杆），并将它们转换为沿游戏世界*x*和*z*轴的运动，`Time.deltaTime`确保了在不同帧率下的平滑运动。在我们进一步探讨这一主题，并在第5章和第8章中深入剖析这个脚本的组件时，我们将扩展如何根据各种游戏玩法机制和风格对其进行优化和调整。
- en: Mastering the fundamentals of player movement within the Unity engine is an
    essential skill for game developers, providing the backbone for a vast array of
    gameplay mechanics. We’ve examined how to harness C# to script basic yet fluid
    movement controls, enabling characters or cameras to navigate seamlessly through
    a 3D environment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity引擎中掌握玩家移动的基本原理是游戏开发者必备的技能，它为各种游戏玩法机制提供了基础。我们已经探讨了如何利用C#编写基本的、流畅的移动控制脚本，使角色或摄像机能够无缝地穿越3D环境。
- en: This foundation not only enhances the player’s immersion and interaction with
    the game world but also sets the stage for more complex and nuanced input methods.
    As we transition from the basics of keyboard and joystick inputs, the next frontier
    involves integrating advanced input methods such as touch and mouse controls.
    These advanced techniques broaden the scope of device compatibility, from mobile
    touchscreens to desktop gaming, ensuring that games can reach a wider audience
    with diverse interaction preferences.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基础不仅增强了玩家对游戏世界的沉浸感和互动性，还为更复杂和细致的输入方法奠定了基础。随着我们从键盘和操纵杆输入的基本操作过渡到更高级的输入方法，如触摸和鼠标控制，这些高级技术扩大了设备兼容性的范围，从移动触摸屏到桌面游戏，确保游戏能够触及具有不同交互偏好的更广泛的受众。
- en: This evolution from basic movement implementation to sophisticated input handling
    marks a pivotal step in crafting responsive and accessible games in Unity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本的移动实现到复杂的输入处理这一演变，标志着在Unity中制作响应式和可访问游戏的关键一步。
- en: Enhancing compatibility – integrating touch and mouse inputs
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强兼容性 - 集成触摸和鼠标输入
- en: In the ever-evolving landscape of game development, accommodating a diverse
    array of player inputs stands as a cornerstone of creating accessible and engaging
    experiences. As we delve deeper into the realm of player interaction within Unity,
    the focus shifts toward **advanced input methods**, including **touch input**
    and **mouse controls**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发不断发展的领域中，适应各种玩家输入是创建可访问和吸引人的体验的基石。随着我们更深入地探索Unity中的玩家交互，重点转向 **高级输入方法**，包括
    **触摸输入** 和 **鼠标控制**。
- en: This section of the chapter, delves into the integration of advanced input methods
    such as touch and mouse controls, emphasizing their importance in enhancing game
    versatility and inclusivity across devices. Leveraging Unity’s powerful engine
    and C# programming, it offers insights into effectively capturing diverse inputs,
    ensuring games deliver immersive experiences adaptable to a wide array of player
    preferences and device capabilities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分深入探讨了触摸和鼠标控制等高级输入方法的集成，强调了它们在增强游戏跨设备多样性和包容性方面的重要性。利用Unity强大的引擎和C#编程，它提供了有效捕获各种输入的见解，确保游戏能够提供适应广泛玩家偏好和设备功能的沉浸式体验。
- en: Touch inputs are fundamental in mobile gaming, where the screen doubles as the
    primary interface for player interaction. Unity simplifies the capture of touch
    gestures through its `Input` class, allowing developers to detect touch positions,
    counts, and phases (such as `Began`, `Moved`, `Stationary`, and `Ended`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸输入在移动游戏中至关重要，因为屏幕充当玩家交互的主要界面。Unity通过其 `Input` 类简化了触摸手势的捕获，允许开发者检测触摸位置、数量和阶段（如
    `Began`、`Moved`、`Stationary` 和 `Ended`）。
- en: 'A simple example of implementing touch input can be seen in the following code
    snippet, which detects a touch and moves an object to the touched position:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实现触摸输入的一个简单示例可以在以下代码片段中看到，它检测触摸并将对象移动到触摸位置：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This C# code snippet for Unity detects the beginning of a touch on the screen.
    When a touch is detected, it gets the touch position and converts it from screen
    coordinates to world coordinates using the camera’s perspective. The *z* coordinate
    is set to `0` to keep the touch in a specific plane. Then, it moves the GameObject
    to where the screen was touched, making the object follow the touch position in
    the game world.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下C#代码片段用于Unity，用于检测屏幕上触摸的开始。当检测到触摸时，它获取触摸位置并将其从屏幕坐标转换为使用相机视角的世界坐标。将 *z* 坐标设置为
    `0` 以保持触摸在特定平面上。然后，它将GameObject移动到屏幕被触摸的位置，使对象在游戏世界中跟随触摸位置。
- en: On the other hand, mouse inputs are predominant in PC gaming, offering precision
    and a different set of challenges for developers. Unity handles mouse inputs through
    the same `Input` class, with methods such as `Input.GetMouseButton()` for button
    clicks and `Input.mousePosition` for tracking the cursor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，鼠标输入在PC游戏中占主导地位，为开发者提供了精确性和一系列不同的挑战。Unity通过相同的 `Input` 类处理鼠标输入，例如使用 `Input.GetMouseButton()`
    方法来检测按钮点击，以及 `Input.mousePosition` 来跟踪光标。
- en: 'Implementing a *drag-and-move* functionality with mouse input could look something
    like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标输入实现 *拖拽移动* 功能可能看起来像这样：
- en: '[PRE13]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code snippet detects when the left mouse button is pressed and converts
    the mouse’s current screen position to a position in the game world using the
    camera’s perspective. It sets the *z* coordinate to `0` to keep the object within
    a specific game plane, then moves the GameObject to the mouse’s position, allowing
    for direct interaction with game elements using the mouse.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段检测鼠标左键何时被按下，并使用相机的视角将鼠标的当前屏幕位置转换为游戏世界中的位置。将 *z* 坐标设置为 `0` 以保持对象在特定游戏平面上，然后将GameObject移动到鼠标的位置，允许使用鼠标直接与游戏元素进行交互。
- en: When dealing with multiple input types, it’s crucial to ensure your game logic
    seamlessly transitions between touch and mouse inputs without compromising gameplay.
    This often involves setting up input detection that dynamically adjusts based
    on the device being used, ensuring a smooth and intuitive player experience.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理多种输入类型时，确保游戏逻辑在触摸和鼠标输入之间无缝过渡，而不影响游戏体验至关重要。这通常涉及设置动态调整的输入检测，根据所使用的设备确保流畅直观的玩家体验。
- en: Harnessing Unity’s advanced input methods, developers can create deeply interactive
    and responsive games, catering to a diverse audience across various devices. The
    integration of Unity’s dynamic input system with C# enables the crafting of immersive
    gameplay that fluidly responds to both touch and mouse inputs, enriching the player
    experience and broadening accessibility.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Unity的高级输入方法，开发者可以创建深度交互和响应的游戏，满足各种设备上的不同受众。Unity的动态输入系统与C#的集成使得制作沉浸式游戏成为可能，这些游戏流畅地响应触摸和鼠标输入，丰富了玩家体验并扩大了可访问性。
- en: The preceding sample code snippets illustrate just the beginning of what’s possible,
    highlighting the adaptability of Unity and C# in catering to diverse input types.
    As we transition from the implementation of these advanced inputs to refining
    our approach, it becomes imperative to embrace best practices in input handling.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例代码片段仅展示了可能性的开始，突出了Unity和C#在满足不同输入类型方面的适应性。随着我们从实现这些高级输入过渡到改进我们的方法，采纳最佳实践进行输入处理变得至关重要。
- en: This includes techniques such as debouncing, which helps prevent input overload,
    and input abstraction, which simplifies the code base and enhances its maintainability.
    By adhering to these principles, developers can ensure not only the responsiveness
    of their games but also the clarity and efficiency of their code, setting the
    stage for more sophisticated and user-friendly gaming experiences.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括诸如防抖动等技术，它有助于防止输入过载，以及输入抽象，它简化了代码库并增强了其可维护性。通过遵循这些原则，开发者可以确保他们的游戏不仅具有响应性，而且代码清晰高效，为更复杂和用户友好的游戏体验奠定基础。
- en: Strategies for effective handling and code optimization
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的处理和代码优化策略
- en: In the intricate dance of game development within Unity, responding adeptly
    to player input is paramount to crafting immersive and dynamic experiences. As
    we delve into the realm of implementing movement, focusing on efficient and elegant
    input handling becomes crucial. Techniques such as debouncing and input abstraction
    play key roles in ensuring smooth, responsive controls and effective management
    of complex input scenarios.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中复杂的游戏开发舞蹈中，敏捷地响应用户输入对于制作沉浸式和动态体验至关重要。当我们深入研究实现移动性的领域时，关注高效和优雅的输入处理变得至关重要。防抖动和输入抽象等技术在此确保了平滑、响应的控制和复杂输入场景的有效管理。
- en: This section explores **debouncing** and **input abstraction**, which are essential
    for crafting clean, maintainable code. These practices ensure precise game responses
    and a scalable, understandable code base. Delving into Unity's input management
    reveals key strategies for responsive gameplay and streamlined code, enhancing
    both player experience and code maintenance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了**防抖动**和**输入抽象**，这对于编写干净、可维护的代码至关重要。这些实践确保了精确的游戏响应和可扩展、易于理解的代码库。深入了解Unity的输入管理揭示了响应式游戏和代码简化的关键策略，增强了玩家体验和代码维护。
- en: 'Here are some key strategies for effective input management:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有效的输入管理关键策略：
- en: '**Debouncing input**: One common challenge in game development is handling
    rapid, repeated inputs, such as a player pressing a button multiple times in quick
    succession. Debouncing is a technique used to ensure that only one input is registered
    within a specified time frame, preventing unintended multiple actions from being
    triggered. This is especially useful in scenarios such as firing a weapon or jumping,
    where precise control is paramount.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防抖动输入**：在游戏开发中，处理快速、重复的输入是一个常见挑战，例如玩家连续多次按下按钮。防抖动是一种确保在指定时间范围内只注册一个输入的技术，防止意外触发多次动作。这在需要精确控制的情况下特别有用，例如开火或跳跃。'
- en: '**Input abstraction**: Rather than hardcoding specific keys or buttons within
    your game’s logic, abstracting input allows for a more flexible and adaptable
    control scheme. By mapping actions to abstract inputs, you can easily reassign
    keys or buttons without altering the underlying gameplay logic. This approach
    not only makes your game more accessible across different devices but also simplifies
    the process of customizing controls to suit individual player preferences.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入抽象**：而不是在游戏逻辑中硬编码特定的键或按钮，抽象输入允许更灵活和适应性强的控制方案。通过将动作映射到抽象输入，您可以轻松重新分配键或按钮，而无需更改底层游戏逻辑。这种方法不仅使游戏在不同设备上更具可访问性，而且简化了根据个人玩家偏好定制控制的过程。'
- en: '**Using Unity’s Input Manager**: Unity’s built-in Input Manager offers a robust
    framework for managing input from various sources, including keyboards, gamepads,
    and touch devices. Leveraging this system enables developers to define and manage
    complex input configurations with ease, ensuring compatibility across a wide range
    of devices.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用Unity的输入管理器**：Unity内置的输入管理器提供了一个强大的框架来管理来自各种来源的输入，包括键盘、游戏手柄和触摸设备。利用这个系统，开发者可以轻松定义和管理复杂的输入配置，确保跨广泛设备兼容。'
- en: '**Handling touch and mouse inputs**: In today’s gaming landscape, accommodating
    both touch and mouse inputs is essential for reaching a broader audience. Implementing
    multi-touch gestures and mouse controls in a cohesive manner can significantly
    enhance the gameplay experience, particularly in genres that require precision
    and finesse.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理触摸和鼠标输入**：在当今的游戏环境中，适应触摸和鼠标输入对于吸引更广泛的受众至关重要。以统一的方式实现多点触控手势和鼠标控制可以显著提升游戏体验，尤其是在需要精确和技巧的流派中。'
- en: '**Utilizing Event Systems**: Unity’s Event System can be a powerful tool for
    managing input in more complex UI-driven games. By using event listeners and event
    triggers, you can create a responsive and interactive interface that reacts intuitively
    to player actions.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用事件系统**：Unity的事件系统可以是一个强大的工具，用于管理更复杂UI驱动游戏的输入。通过使用事件监听器和事件触发器，你可以创建一个对玩家动作反应直观的响应式和交互式界面。'
- en: '`Update`, `FixedUpdate`, or `LateUpdate`), ensures that your game remains smooth
    and responsive without taxing the system unnecessarily.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`、`FixedUpdate`或`LateUpdate`等函数确保了你的游戏在不过度消耗系统资源的情况下保持流畅和响应。'
- en: By adhering to these best practices, developers can craft an input-handling
    system that not only responds accurately to player actions but also maintains
    the integrity and readability of the code. As we transition from the nuances of
    input handling to broader aspects of game development, these foundational principles
    will continue to underpin the creation of compelling and player-friendly games.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，开发者可以构建一个输入处理系统，它不仅能够准确响应玩家动作，而且还能保持代码的完整性和可读性。随着我们从输入处理的细微差别过渡到游戏开发的更广泛方面，这些基础原则将继续支撑着引人入胜且玩家友好的游戏创作。
- en: Navigating through the intricacies of player input within Unity unveils the
    depth and versatility of the engine’s input system, enabling developers to craft
    responsive and dynamic gameplay experiences. From the foundational steps of capturing
    basic movements to integrating advanced touch and mouse inputs, Unity empowers
    developers with the tools to bring their game visions to life across a multitude
    of devices.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中导航玩家输入的复杂性揭示了引擎输入系统的深度和多功能性，使开发者能够轻松定义和管理复杂的输入配置，确保跨多种设备兼容。
- en: The journey from understanding Unity’s input system to implementing movement
    and adopting best practices such as debouncing and input abstraction illustrates
    a path toward writing cleaner, more efficient code. As we transition from the
    realm of responding to player inputs to the equally critical domain of script
    communication, we delve into the backbone of complex game architectures.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从理解Unity的输入系统到实现移动和采用最佳实践，如防抖动和输入抽象，这一过程展示了编写更干净、更高效代码的途径。随着我们从响应玩家输入的领域过渡到同样关键的脚本通信领域，我们深入到复杂游戏架构的核心。
- en: Exploring the nuances of direct script references, Unity’s `SendMessage` and
    `BroadcastMessage` functions, and the power of events and delegates, this next
    section lays the groundwork for robust and scalable inter-script communication.
    Understanding these concepts is pivotal for orchestrating sophisticated interactions
    between game components, ensuring seamless gameplay mechanics, and enhancing the
    overall structure of game projects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 探索直接脚本引用的细微差别、Unity的`SendMessage`和`BroadcastMessage`函数以及事件和代理的强大功能，下一部分为构建强大和可扩展的脚本间通信奠定了基础。理解这些概念对于协调游戏组件之间的复杂交互、确保流畅的游戏机制和提升游戏项目的整体结构至关重要。
- en: Script communication
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本通信
- en: In the multifaceted world of game development within the Unity engine, the ability
    for scripts to communicate effectively stands as a cornerstone of complex game
    architectures. This section delves into the various methodologies and patterns
    essential for fostering robust **script interactions**, each serving a unique
    role in the orchestration of game elements.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity引擎的游戏开发多面世界中，脚本有效通信的能力是复杂游戏架构的基石。本节深入探讨了培养强大**脚本交互**的各种方法和模式，每个都在游戏元素编排中扮演着独特的角色。
- en: From leveraging direct references for straightforward script access to employing
    Unity’s built-in `SendMessage` and `BroadcastMessage` methods for dynamic component
    communication, the strategies outlined here offer a spectrum of options for developers.
    Furthermore, the adoption of C# events and delegates introduces a decoupled approach,
    enhancing flexibility and maintainability in game code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从利用直接引用进行简单的脚本访问，到使用Unity内置的`SendMessage`和`BroadcastMessage`方法进行动态组件通信，这里概述的策略为开发者提供了多种选择。此外，采用C#事件和委托引入了一种解耦的方法，增强了游戏代码的灵活性和可维护性。
- en: The exploration extends to the **Singleton pattern**, a pivotal design strategy
    for providing global access to indispensable game services or managers, ensuring
    cohesive and efficient game operation. Together, these communication strategies
    form the backbone of script interaction within Unity, enabling developers to construct
    rich, interactive, and scalable game environments.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 探索扩展到了**单例模式**，这是一种关键的设计策略，用于提供对不可或缺的游戏服务或管理器的全局访问，确保游戏操作的协调和高效。这些通信策略共同构成了Unity中脚本交互的骨架，使开发者能够构建丰富、交互性强且可扩展的游戏环境。
- en: Scripting interactions – essential for game design
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本交互——游戏设计的关键
- en: In the realm of game development using Unity and C#, mastering the art of script
    communication is fundamental to constructing intricate and dynamic game architectures.
    This section introduces the core principles and necessities of inter-script communication,
    a critical component in building cohesive and complex gameplay experiences.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Unity和C#进行游戏开发领域，掌握脚本通信的艺术是构建复杂和动态游戏架构的基础。本节介绍了脚本间通信的核心原则和必要性，这是构建统一和复杂游戏体验的关键组成部分。
- en: As games evolve into more sophisticated systems, the ability for individual
    scripts to interact, share data, and coordinate actions becomes imperative. Understanding
    these communication basics not only facilitates the seamless integration of disparate
    game components but also underpins the development of rich, interactive environments
    where elements respond and adapt in concert, elevating the overall game design.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏演变成更复杂的系统，单个脚本之间的交互、数据共享和动作协调的能力变得至关重要。理解这些通信基础不仅促进了不同游戏组件的无缝集成，而且为构建元素协同响应和适应的丰富、交互式环境奠定了基础，从而提升了整体游戏设计。
- en: Effective script communication is vital in Unity for creating dynamic game structures,
    enabling seamless component interaction for the desired gameplay. It necessitates
    scripts efficiently exchanging information and synchronizing actions across game
    elements, preventing development chaos and bugs. Unity equips developers with
    tools such as Unity Events and ScriptableObjects for robust communication, enhancing
    workflow efficiency, code organization, and project maintainability.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，有效的脚本通信对于创建动态游戏结构至关重要，它能够实现所需游戏玩法中组件的无缝交互。这要求脚本能够高效地交换信息并同步游戏元素的动作，以防止开发混乱和错误。Unity为开发者提供了诸如Unity事件和ScriptableObjects等工具，以实现强大的通信，提高工作流程效率、代码组织和项目可维护性。
- en: In summary, script communication is not just a technical necessity but a fundamental
    aspect of game development. By understanding the importance of inter-script communication
    and mastering the various communication techniques available in Unity, developers
    can unlock new possibilities for creating immersive and engaging gaming experiences.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，脚本通信不仅是一项技术需求，而且是游戏开发的基本方面。通过理解脚本间通信的重要性并掌握Unity中可用的各种通信技术，开发者可以解锁创建沉浸式和引人入胜游戏体验的新可能性。
- en: Understanding the necessity of inter-script communication is paramount for developers
    aiming to create dynamic and engaging gaming experiences. Transitioning to the
    discussion of direct references, developers can employ techniques such as public
    variables or getters/setters to access other scripts directly, enabling efficient
    data exchange and streamlined interactions within their Unity projects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望创建动态和引人入胜的游戏体验的开发者来说，理解脚本间通信的必要性至关重要。在讨论直接引用时，开发者可以使用公共变量或获取器/设置器等技术直接访问其他脚本，从而在Unity项目中实现高效的数据交换和简化的交互。
- en: Linking scripts – utilizing public variables and accessors
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接脚本 – 利用公共变量和访问器
- en: Direct references simplify script communication, allowing for straightforward
    access and manipulation of variables and methods between scripts. By establishing
    connections through public variables or getters and setters, developers ensure
    the seamless integration of game components, enhancing both the flow of data and
    the execution of commands within the game environment.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 直接引用简化了脚本之间的通信，使得脚本之间对变量和方法进行直接访问和操作变得简单。通过通过公共变量或获取器和设置器建立连接，开发者确保游戏组件的无缝集成，增强游戏环境中的数据流和命令执行。
- en: One common technique for implementing direct references is through **public
    variables**. In this method, developers declare a public variable in a script,
    allowing other scripts to access and modify its value.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 实现直接引用的一种常见技术是通过**公共变量**。在这种方法中，开发者在一个脚本中声明一个公共变量，允许其他脚本访问和修改其值。
- en: For example, consider a scenario where a `Player` script needs to access a `Health`
    script to update the player’s health status. The `Player` script could declare
    a public variable of type `Health` and assign the reference to the `Health` script
    in the Unity Editor. This enables the `Player` script to directly access the methods
    and variables of the `Health` script, such as updating the player’s health points
    after taking damage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，其中`Player`脚本需要访问`Health`脚本以更新玩家的健康状态。`Player`脚本可以声明一个类型为`Health`的公共变量，并在Unity编辑器中将`Health`脚本的引用分配给该变量。这使得`Player`脚本可以直接访问`Health`脚本的方法和变量，例如在受到伤害后更新玩家的生命值。
- en: 'The `Player.cs` script demonstrates how to invoke the `TakeDamage()` method
    from the `Health` class, showcasing inter-class method access in Unity:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player.cs`脚本展示了如何在Unity中调用`Health`类中的`TakeDamage()`方法，展示了类间方法访问：'
- en: '[PRE14]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the `Player.cs` script, the `Player` class starts by establishing a reference
    to the `Health` script. When the game begins, the `Start` function is invoked,
    and it utilizes this reference to call the `TakeDamage` method from the `Health`
    script, applying 10 points of damage. This illustrates how scripts can interact
    and modify each other’s states in Unity.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Player.cs`脚本中，`Player`类首先建立对`Health`脚本的引用。当游戏开始时，`Start`函数被调用，并使用这个引用来调用`Health`脚本中的`TakeDamage`方法，应用10点伤害。这说明了脚本如何在Unity中相互交互和修改彼此的状态。
- en: Another approach involves using getters and setters to access variables indirectly.
    **Getters** are methods that return the value of a private variable, while **setters**
    are methods used to modify the value of a private variable.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过获取器和设置器间接访问变量。**获取器**是返回私有变量值的函数，而**设置器**是用于修改私有变量值的函数。
- en: By encapsulating variables within getter and setter methods, developers can
    control access to those variables and perform additional logic if needed. This
    encapsulation helps maintain data integrity and facilitates more controlled interactions
    between scripts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装变量在获取器和设置器方法中，开发者可以控制对这些变量的访问，并在需要时执行额外的逻辑。这种封装有助于维护数据完整性，并促进脚本之间更受控的交互。
- en: 'The `Health.cs` script outlines the structure and functionality for managing
    health points within a game character or object, including methods for getting
    and setting health, as well as applying damage:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health.cs`脚本概述了在游戏角色或对象中管理生命值的结构和功能，包括获取和设置生命值以及应用伤害的方法：'
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Health.cs` script features a variable for storing health points and three
    main methods: `GetHealth` returns the current health points, `SetHealth` assigns
    a new value to the health points, and `TakeDamage` decreases health points by
    a specified damage amount, also logging the damage taken and current health to
    the console. This setup provides a fundamental health management system for game
    entities.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health.cs` 脚本包含一个用于存储生命值的变量和三个主要方法：`GetHealth` 返回当前的生命值，`SetHealth` 为生命值分配新的值，`TakeDamage`
    通过指定的伤害量减少生命值，并将受到的伤害和当前生命值记录到控制台。这种设置为游戏实体提供了一个基本的健康管理系统。'
- en: By leveraging direct references through public variables or getters/setters,
    developers can establish efficient communication channels between scripts, enabling
    them to create more cohesive and interactive gameplay experiences in Unity.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用公共变量或getter/setter的直接引用，开发者可以在脚本之间建立高效的通信渠道，从而在Unity中创建更加紧密和互动的游戏体验。
- en: Direct references, employing public variables or getters/setters to access other
    scripts directly, represent a fundamental approach to script communication in
    Unity. This method provides developers with a straightforward means of exchanging
    data and coordinating behavior between different components of a game.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 直接引用，通过公共变量或getter/setter直接访问其他脚本，是Unity中脚本通信的基本方法。这种方法为开发者提供了一种直接交换数据并在游戏的不同组件之间协调行为的方法。
- en: Transitioning to the discussion of Unity’s built-in messaging methods, `SendMessage`
    and `BroadcastMessage`, developers can explore alternative techniques for sending
    messages between GameObjects and components. These built-in methods offer additional
    flexibility and convenience, allowing developers to propagate messages throughout
    the game hierarchy without the need for explicit references.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Unity内置的消息方法`SendMessage`和`BroadcastMessage`的过渡中，开发者可以探索在GameObject和组件之间发送消息的替代技术。这些内置方法提供了额外的灵活性和便利性，允许开发者无需显式引用即可在整个游戏层次结构中传播消息。
- en: In the following sections, we delve into the intricacies of `SendMessage` and
    `BroadcastMessage`, uncovering their potential applications and best practices
    for leveraging them effectively in Unity projects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨`SendMessage`和`BroadcastMessage`的复杂性，揭示它们的潜在应用和最佳实践，以在Unity项目中有效地利用它们。
- en: Mastering SendMessage and BroadcastMessage in Unity
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掌握Unity中的SendMessage和BroadcastMessage
- en: In the realm of Unity game development, effective script communication lies
    at the heart of creating immersive and interactive gaming experiences. One powerful
    tool in a developer’s arsenal is Unity’s built-in messaging system, consisting
    of methods such as `SendMessage` and `BroadcastMessage`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity游戏开发领域，有效的脚本通信是创造沉浸式和互动游戏体验的核心。开发者工具箱中的一个强大工具是Unity的内置消息系统，包括`SendMessage`和`BroadcastMessage`等方法。
- en: We’ll dive into Unity’s `SendMessage` and `BroadcastMessage` by examining their
    roles, uses, and best practices through practical examples. This exploration aims
    to deepen your understanding of these methods for enhancing game functionality.
    Unity’s methods facilitate script communication across GameObjects and components,
    providing a dynamic approach to method invocation within GameObject hierarchies
    or specific targets, enriching your game development toolkit.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查它们的作用、用途和最佳实践，通过实际示例深入了解Unity的`SendMessage`和`BroadcastMessage`。这次探索旨在加深你对这些方法的理解，以增强游戏功能。Unity的方法促进了GameObject和组件之间的脚本通信，提供了一种在GameObject层次结构或特定目标内调用方法的动态方法，丰富了你的游戏开发工具箱。
- en: 'Let’s understand these methods in greater depth:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这些方法：
- en: '`SendMessage`: This allows developers to invoke a method by name on the target
    GameObject or its components. This method takes the name of the method to be called
    as a string parameter, along with optional parameters to pass to the method.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SendMessage`：这允许开发者通过名称在目标GameObject或其组件上调用方法。此方法将调用方法的名称作为字符串参数，并带有可选参数传递给方法。'
- en: 'For example, consider a scenario where a player object needs to take damage
    when colliding with an enemy. By using `SendMessage`, the enemy object can trigger
    the `TakeDamage` method on the player object upon collision. The `Enemy.cs` script
    showcases how an enemy object can detect collisions with a player and trigger
    a damage response using Unity’s `SendMessage` method:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，当一个玩家对象与敌人碰撞时需要受到伤害。通过使用`SendMessage`，敌人对象可以在碰撞时触发玩家对象的`TakeDamage`方法。`Enemy.cs`脚本展示了敌人对象如何检测与玩家的碰撞并使用Unity的`SendMessage`方法触发伤害响应：
- en: '[PRE16]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the `Enemy.cs` script, when an enemy collides with an object tagged as `Player`,
    it uses Unity’s `SendMessage` to call the `TakeDamage` method on the player object,
    applying 10 damage points. This demonstrates an interaction between GameObjects
    upon collision.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`Enemy.cs`脚本中，当敌人与标记为`Player`的对象碰撞时，它使用Unity的`SendMessage`调用玩家对象的`TakeDamage`方法，施加10点伤害。这展示了在碰撞时GameObject之间的交互。
- en: '`BroadcastMessage`: On the other hand, while `BroadcastMessage` functions similarly
    to `SendMessage`, it sends the message to all components on the target GameObject
    and its children. This can be useful for triggering actions across multiple components
    within a GameObject hierarchy.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BroadcastMessage`：另一方面，虽然`BroadcastMessage`的功能与`SendMessage`类似，但它将消息发送到目标GameObject及其子对象上的所有组件。这可以在GameObject层次结构中的多个组件内触发动作。'
- en: 'For instance, if a GameObject contains multiple components that need to react
    to a specific event, `BroadcastMessage` can efficiently propagate the message
    to all relevant components. The `GameController.cs` script demonstrates initiating
    a broadcast message to initialize all components within the GameController object
    and its children at the start of the game:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果一个GameObject包含多个需要响应特定事件的组件，`BroadcastMessage`可以有效地将消息传播到所有相关的组件。`GameController.cs`脚本展示了在游戏开始时启动一个广播消息，初始化GameController对象及其子对象内的所有组件：
- en: '[PRE17]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `GameController.cs` script, during the `Start` method, a broadcast message
    titled `Initialize` is sent to all components within the GameController object
    and its child objects. This message requires a receiver, meaning it will only
    be sent to components that have a method named `Initialize`, ensuring targeted
    and efficient communication to set up or reset game elements at the start.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`GameController.cs`脚本中，在`Start`方法期间，发送一个名为`Initialize`的广播消息到GameController对象及其子对象内的所有组件。这个消息需要一个接收者，这意味着它只会发送到具有名为`Initialize`的方法的组件，确保在游戏开始时对设置或重置游戏元素进行有针对性的高效通信。
- en: While `SendMessage` and `BroadcastMessage` provide convenient ways to send messages
    between GameObjects and components, it’s essential to use them judiciously and
    consider potential performance implications, especially in scenarios with a large
    number of objects or frequent message calls. By understanding how to effectively
    utilize these built-in methods, developers can enhance the interactivity and functionality
    of their Unity games while maintaining optimal performance.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`SendMessage`和`BroadcastMessage`提供了在GameObject和组件之间发送消息的便捷方式，但使用它们时必须谨慎，并考虑潜在的性能影响，尤其是在有大量对象或频繁调用消息的场景中。通过理解如何有效地利用这些内置方法，开发者可以在保持最佳性能的同时，增强Unity游戏的交互性和功能性。
- en: In exploring Unity’s built-in methods for script communication, `SendMessage`
    and `BroadcastMessage` emerge as powerful tools for sending messages between GameObjects
    and components. These methods offer developers a convenient means to trigger actions
    and exchange data within their Unity projects. By understanding how to utilize
    `SendMessage` and `BroadcastMessage` effectively, developers can streamline interactions
    between game elements and enhance the overall functionality of their games.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索Unity内置的脚本通信方法时，`SendMessage`和`BroadcastMessage`成为在GameObject和组件之间发送消息的强大工具。这些方法为开发者提供了方便的方式来触发动作和交换Unity项目中的数据。通过理解如何有效地利用`SendMessage`和`BroadcastMessage`，开发者可以简化游戏元素之间的交互，并增强游戏的整体功能。
- en: However, by transitioning to a more decoupled and flexible approach, developers
    can delve into the realm of events and delegates in C#. This transition allows
    for a more structured and loosely coupled system of script communication, enabling
    greater flexibility and scalability in Unity projects.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过转向更解耦和灵活的方法，开发者可以深入到C#中的事件和委托领域。这种过渡允许脚本通信更加结构化和松散耦合的系统，使得Unity项目具有更大的灵活性和可扩展性。
- en: In the following section, we’ll delve into the implementation of events and
    delegates, exploring their benefits and demonstrating how they can be leveraged
    to achieve more modular and extensible script communication in Unity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨事件和委托的实现，探讨它们的优点，并展示如何利用它们在Unity中实现更模块化和可扩展的脚本通信。
- en: Utilizing events and delegates for Unity scripts
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用事件和委托进行Unity脚本
- en: As developers seek to build more modular and extensible game architectures,
    the implementation of a decoupled approach becomes increasingly crucial. Enter
    events and delegates in C#—powerful mechanisms that offer a more flexible and
    scalable solution for script communication in Unity projects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者寻求构建更模块化和可扩展的游戏架构，实现解耦方法变得越来越关键。进入C#中的事件和委托——这些强大的机制为Unity项目中的脚本通信提供了更灵活和可扩展的解决方案。
- en: Events and delegates in C# offer a powerful and flexible mechanism for implementing
    a decoupled approach to script communication in Unity. By decoupling components
    through events and delegates, developers can create more modular and maintainable
    code bases, allowing for easier scalability and extensibility of their projects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的事件和委托提供了一种强大且灵活的机制，用于在Unity中实现解耦的脚本通信方法。通过通过事件和委托解耦组件，开发者可以创建更模块化和可维护的代码库，从而使得项目的可扩展性和可扩展性更加容易。
- en: At the core of this approach are **delegates**, which serve as function pointers
    that can reference methods with compatible signatures. They provide a way to encapsulate
    and invoke methods dynamically, enabling components to communicate without direct
    dependencies on each other. **Events**, on the other hand, provide a higher-level
    abstraction built on top of delegates, allowing components to subscribe to and
    receive notifications when specific actions occur.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的核心是**委托**，它们作为函数指针，可以引用具有兼容签名的函数。它们提供了一种封装和动态调用方法的方式，使得组件能够相互通信，而无需直接依赖对方。另一方面，**事件**提供了基于委托的高级抽象，允许组件在特定动作发生时订阅并接收通知。
- en: 'In this setup, the `Player` object utilizes an event-driven approach to communicate
    with other GameObjects in Unity. When it collects a power-up, an event, defined
    through a delegate, is broadcasted, allowing subscribed objects to react accordingly,
    enhancing gameplay dynamics:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，`Player` 对象使用事件驱动的方法与Unity中的其他GameObject进行通信。当它收集到能量提升物品时，通过委托定义的事件被广播，允许已订阅的对象相应地做出反应，增强游戏动态：
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Player.cs` script defines an event for when the player collects a power-up,
    using a delegate to broadcast this event. When the player collides with a power-up
    object, the event is triggered, notifying subscribed objects to react, and the
    power-up is then destroyed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player.cs` 脚本定义了一个事件，用于当玩家收集到能量提升物品时触发，使用委托来广播此事件。当玩家与能量提升物品发生碰撞时，事件被触发，通知已订阅的对象做出反应，然后能量提升物品被销毁。'
- en: 'The `GameManager.cs` script demonstrates how to subscribe to the `PowerUpCollected`
    event from a `Player` instance, allowing the `GameManager` to execute specific
    actions, such as logging a message, when the event is triggered:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager.cs` 脚本演示了如何从 `Player` 实例订阅 `PowerUpCollected` 事件，允许 `GameManager`
    在事件被触发时执行特定操作，例如记录一条消息：'
- en: '[PRE19]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `GameManager.cs` script finds a `Player` instance at the start of the game
    and subscribes to its `PowerUpCollected` event. When this event is triggered—indicating
    the player has collected a power-up—the `GameManager` script responds by executing
    the `HandlePowerUpCollected` method, which logs a message and can perform additional
    actions as needed. This setup illustrates event-driven communication between GameObjects.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager.cs` 脚本在游戏开始时找到一个 `Player` 实例，并订阅其 `PowerUpCollected` 事件。当此事件被触发——表示玩家收集了能量提升物品时——`GameManager`
    脚本通过执行 `HandlePowerUpCollected` 方法做出响应，该方法记录一条消息并可以执行所需的额外操作。这种设置说明了GameObject之间的事件驱动通信。'
- en: Through the strategic use of events and delegates, Unity developers can achieve
    a decoupled script communication framework, significantly enhancing project modularity,
    flexibility, and maintainability. This approach not only streamlines interactions
    between disparate game components, minimizing direct dependencies, but also contributes
    to a more organized and adaptable code base, paving the way for scalable game
    development practices.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过战略性地使用事件和委托，Unity 开发者可以实现解耦的脚本通信框架，显著提高项目的模块化、灵活性和可维护性。这种方法不仅简化了不同游戏组件之间的交互，减少了直接依赖，而且有助于创建更有序和可适应的代码库，为可扩展的游戏开发实践铺平道路。
- en: However, transitioning to another critical design pattern, the Singleton pattern
    offers developers a complementary strategy for managing global access points to
    essential game services or managers. Singleton instances ensure that only one
    instance of a class exists throughout the game, providing centralized access to
    critical functionalities.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过渡到另一个关键的设计模式，单例模式为开发者提供了一种管理对关键游戏服务或管理器的全局访问点的补充策略。单例实例确保在整个游戏过程中只存在一个类的实例，提供对关键功能的集中访问。
- en: In the following section, we explore the Singleton pattern in depth, uncovering
    its applications and best practices in Unity game development, while also acknowledging
    its relationship with the flexible script communication facilitated by events
    and delegates.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨单例模式，揭示其在 Unity 游戏开发中的应用和最佳实践，同时承认其与通过事件和委托促进的灵活脚本通信之间的关系。
- en: Utilizing the singleton pattern
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用单例模式
- en: An indispensable tool in a developer’s toolkit is the **Singleton pattern**,
    a design pattern that facilitates the creation of global access points to critical
    game services or managers. By ensuring that only one instance of a class exists
    throughout the game’s life cycle, singletons provide centralized access to essential
    functionalities, promoting efficient and organized script communication.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者工具箱中不可或缺的工具是**单例模式**，这是一种设计模式，它促进了创建对关键游戏服务或管理器的全局访问点的实现。通过确保在整个游戏生命周期中只存在一个类的实例，单例提供了对关键功能的集中访问，促进了高效和有序的脚本通信。
- en: In Unity game development, the Singleton pattern serves as a fundamental design
    principle for managing critical game services or managers. By ensuring that only
    one instance of a class exists throughout the game’s runtime, singletons provide
    a centralized access point for essential functionalities, such as audio managers,
    game controllers, or resource managers. This pattern promotes efficient communication
    between various components of a game, as any script can easily access the singleton
    instance without the need for direct dependencies or complex instantiation logic.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 游戏开发中，单例模式作为管理关键游戏服务或管理器的基本设计原则。通过确保在整个游戏运行时只存在一个类的实例，单例提供了一个对关键功能的集中访问点，例如音频管理器、游戏控制器或资源管理器。这种模式促进了游戏各个组件之间的有效通信，因为任何脚本都可以轻松访问单例实例，而无需直接依赖或复杂的实例化逻辑。
- en: 'The `AudioManager.cs` script outlines the implementation of a singleton pattern,
    ensuring only one instance of `AudioManager` exists throughout the game, with
    a method to play sound effects:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioManager.cs` 脚本概述了单例模式的实现，确保在整个游戏过程中只存在一个 `AudioManager` 实例，并提供了一个播放音效的方法：'
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `AudioManager.cs` script, the singleton pattern is applied to ensure
    there is a single `AudioManager` instance across the game. The `Instance` property
    checks whether `_instance` exists, creating one if not, even adding it to a new
    GameObject if needed. The private constructor prevents creating additional instances.
    `PlaySound` exemplifies how to use this singleton, encapsulating audio playback
    logic, allowing sound effects to be played through a centralized manager, ensuring
    consistent audio management and avoiding duplicate instances or conflicting audio
    commands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AudioManager.cs` 脚本中，单例模式被应用于确保整个游戏过程中只有一个 `AudioManager` 实例。`Instance` 属性检查
    `_instance` 是否存在，如果不存在则创建一个，甚至在需要时将其添加到一个新的 GameObject 中。私有构造函数防止创建额外的实例。`PlaySound`
    举例说明了如何使用这个单例，封装了音频播放逻辑，允许通过集中管理器播放音效，确保一致的音频管理并避免重复的实例或冲突的音频命令。
- en: By utilizing the Singleton pattern, developers can ensure that critical game
    services or managers are easily accessible from any part of the game, promoting
    a more organized and modular code base. This approach enhances code maintainability,
    as changes or updates to the singleton instance are reflected universally throughout
    the project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用单例模式，开发者可以确保关键游戏服务或管理器可以从游戏的任何部分轻松访问，从而促进代码库的更佳组织和模块化。这种方法提高了代码的可维护性，因为对单例实例的更改或更新会在整个项目中普遍反映。
- en: However, it’s essential to exercise caution when using singletons, as they can
    introduce potential pitfalls such as tight coupling and global state. Tight coupling
    occurs when components are highly dependent on each other, making the system less
    modular and harder to maintain. Global state refers to data that is accessible
    from anywhere in the application, which can lead to issues with data consistency
    and debugging complexity. Therefore, developers should carefully consider the
    design and usage of singletons in their Unity projects to maximize their benefits
    while minimizing drawbacks.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用单例时必须谨慎，因为它们可能会引入潜在的陷阱，如紧密耦合和全局状态。紧密耦合发生在组件高度相互依赖时，使得系统更少模块化且更难维护。全局状态是指可以在应用程序的任何地方访问的数据，这可能导致数据一致性和调试复杂性的问题。因此，开发者应仔细考虑他们在
    Unity 项目中单例的设计和使用，以最大化其好处并最小化缺点。
- en: 'Here’s a brief code sample demonstrating how another script can access the
    `AudioManager` Singleton:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简短的代码示例，展示了另一个脚本如何访问 `AudioManager` 单例：
- en: '[PRE21]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, `ExampleScript` accesses the `AudioManager` Singleton instance
    by calling the static Instance property. Once the `AudioManager` instance is obtained,
    the script can utilize its public methods, such as `PlaySound`, to perform desired
    actions, such as playing a sound effect. This demonstrates how the Singleton pattern
    facilitates global access to critical game services or managers from any part
    of the game.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ExampleScript` 通过调用静态的 `Instance` 属性来访问 `AudioManager` 单例实例。一旦获得 `AudioManager`
    实例，脚本就可以利用其公共方法，例如 `PlaySound`，来执行所需操作，比如播放音效。这展示了单例模式如何促进从游戏的任何部分对关键游戏服务或管理器的全局访问。
- en: In Unity game development, the Singleton pattern serves as a valuable tool for
    facilitating efficient script communication by providing global access points
    to critical game services or managers. By ensuring that only one instance of a
    class exists throughout the game’s life cycle, singletons streamline communication
    between various components, promoting code organization and maintainability. Through
    the Singleton pattern, developers can centralize essential functionalities such
    as audio management, resource handling, or game state management, enhancing the
    scalability and flexibility of their Unity projects.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 游戏开发中，单例模式作为促进高效脚本通信的有价值工具，通过提供对关键游戏服务或管理器的全局访问点。通过确保在整个游戏生命周期中只有一个类的实例存在，单例简化了各种组件之间的通信，促进了代码的组织和维护。通过单例模式，开发者可以将音频管理、资源处理或游戏状态管理等基本功能集中化，增强他们
    Unity 项目的可扩展性和灵活性。
- en: However, while singletons offer significant benefits in promoting global access
    and code consistency, developers must exercise caution to avoid potential pitfalls
    that can impact maintainability and scalability. By understanding the principles
    and best practices of utilizing singletons, developers can leverage this pattern
    effectively to optimize script communication and enhance the overall quality of
    their Unity games.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管单例在促进全局访问和代码一致性方面提供了显著的好处，开发者必须谨慎行事，以避免可能影响可维护性和可扩展性的潜在陷阱。通过理解使用单例的原则和最佳实践，开发者可以有效地利用这种模式来优化脚本通信并提高他们
    Unity 游戏的整体质量。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we’ve explored several key concepts essential to understanding
    Unity game development. We’ve discussed the role of MonoBehaviorMonoBehaviour
    as the base class for Unity scripts, governing the behavior of GameObjects. Understanding
    the script life cycle, from initialization to destruction, is crucial for effective
    scripting. We’ve delved into handling user inputs, showcasing techniques to capture
    player interactions and control game behavior accordingly. Additionally, we’ve
    examined various script communication strategies, including direct references,
    events, and delegates, and the Singleton pattern, which enable seamless interactions
    between game components.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了理解Unity游戏开发所必需的几个关键概念。我们讨论了MonoBehavior作为Unity脚本的基类的作用，它控制着GameObject的行为。理解脚本的生命周期，从初始化到销毁，对于有效的脚本编写至关重要。我们深入探讨了处理用户输入，展示了捕获玩家交互并相应控制游戏行为的技巧。此外，我们还考察了各种脚本通信策略，包括直接引用、事件、委托以及Singleton模式，这些策略使得游戏组件之间的交互更加流畅。
- en: As you continue your journey in Unity development, I encourage you to experiment
    with these concepts in your personal projects. Take the time to apply what you’ve
    learned about MonoBehaviorMonoBehaviour, script life cycles, user input handling,
    and script communication strategies in practical scenarios. By incorporating these
    techniques into your projects, you’ll reinforce your understanding of Unity’s
    scripting capabilities and gain valuable hands-on experience. Don’t hesitate to
    explore, iterate, and push the boundaries of your creativity. With persistence
    and experimentation, you’ll unlock new possibilities and enhance your proficiency
    as a Unity developer.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续在Unity开发中的旅程，我鼓励你在个人项目中尝试这些概念。花时间将你关于MonoBehavior、脚本生命周期、用户输入处理和脚本通信策略的知识应用到实际场景中。通过将这些技术融入你的项目中，你将加强你对Unity脚本能力的理解，并获得宝贵的实践经验。不要犹豫去探索、迭代，并拓展你的创造力边界。通过坚持和实验，你将解锁新的可能性，并提高作为Unity开发者的熟练度。
- en: Transitioning to mastering Unity’s API in the next chapter, you will delve into
    accessing components and leveraging Unity’s event methods to interact with the
    game environment effectively. This will entail understanding physics, collisions,
    and environment interactions, empowering you to create immersive and dynamic gaming
    experiences through precise control and manipulation of GameObjects and their
    interactions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将过渡到精通Unity的API，深入访问组件并利用Unity的事件方法有效地与游戏环境交互。这包括理解物理、碰撞和环境交互，使你能够通过精确控制和操作GameObject及其交互来创建沉浸式和动态的游戏体验。
- en: Join our community on Discord
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers: [https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：[https://packt.link/gamedevelopment](https://discord.com/invite/NnJesrUJbu?link_from_packtlink=yes)
- en: '![](img/Disclaimer_QR1.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Disclaimer_QR1.jpg)'
- en: 'Part 2: Intermediate Concepts'
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：中级概念
- en: In this part, you will advance your Unity and C# skills by accessing and manipulating
    game components through the API, implementing physics-based interactions, and
    controlling scene transitions and environmental settings. You will leverage advanced
    functionalities within Unity’s API, work with data structures such as arrays,
    lists, dictionaries, and HashSets, and create custom data structures to develop
    complex game mechanics. Additionally, you will craft and style UI components,
    handle various input methods, assemble interactive menus, and script custom interaction
    behaviors. This section also covers the basics of Unity physics, animating game
    characters, scripting environmental interactions, and employing advanced animation
    techniques for complex movements, equipping you with the knowledge to create more
    sophisticated and dynamic game experiences.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分，你将通过API访问和操作游戏组件，实现基于物理的交互，并控制场景转换和环境设置来提升你的Unity和C#技能。你将利用Unity API的高级功能，与数组、列表、字典和HashSet等数据结构一起工作，并创建自定义数据结构以开发复杂游戏机制。此外，你将设计和样式化UI组件，处理各种输入方法，组装交互式菜单，并编写自定义交互行为。本节还涵盖了Unity物理的基础知识，动画游戏角色，脚本化环境交互，以及使用高级动画技术进行复杂动作，为你提供创建更复杂和动态游戏体验的知识。
- en: 'This part includes the following chapters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B22128_05.xhtml#_idTextAnchor120), *Mastering Unity’s API* *–
    Physics, Collisions, and Environment Interaction Techniques*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B22128_05.xhtml#_idTextAnchor120), *精通Unity的API* *–* *物理、碰撞和环境交互技术*'
- en: '[*Chapter 6*](B22128_06.xhtml#_idTextAnchor142), *Data Structures in Unity*
    *–* *Arrays, Lists, Dictionaries, HashSets, and Game Logic*'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B22128_06.xhtml#_idTextAnchor142), *Unity中的数据结构* *–* *数组、列表、字典、HashSet以及游戏逻辑*'
- en: '[*Chapter 7*](B22128_07.xhtml#_idTextAnchor162), *Designing Interactive UI
    Elements* *–* *Menus and Player Interactions in Unity*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B22128_07.xhtml#_idTextAnchor162), *设计交互式UI元素* *–* *Unity中的菜单和玩家交互*'
- en: '[*Chapter 8*](B22128_08.xhtml#_idTextAnchor180), *Mastering Physics and Animation
    in Unity Game Development*'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B22128_08.xhtml#_idTextAnchor180), *掌握Unity游戏开发中的物理和动画*'
