- en: Dependency Injection in Other JavaScript Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他 JavaScript 框架中的依赖注入
- en: In [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, we covered the most important anti-patterns
    when using Dependency Injection, together with some typical misconceptions when
    it comes to how to use it. In this chapter, we're going to deal with Dependency
    Injection in other framework, specifically in TypeScript 2.3 and Angular 4+.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 9 章](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml)，*依赖注入的反模式和误解*中，我们讨论了使用依赖注入时最重要的反模式，以及在使用它时的一些典型误解。在本章中，我们将处理其他框架中的依赖注入，特别是
    TypeScript 2.3 和 Angular 4+。
- en: The reason for reviewing the very basics of TypeScript is that Angular 2+ uses
    this language, so we need some understanding of how class creation and module
    management is undertaken to really grasp the main concepts behind this architecture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾 TypeScript 的基础知识的原因是 Angular 2+ 使用了这种语言，因此我们需要了解如何进行类创建和模块管理，才能真正掌握这种架构背后的主要概念。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Class creation and module management in TypeScript 2.3+
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript 2.3+ 中的类创建和模块管理
- en: Native implementation and usage of DI techniques in AngularJS (version 1.x)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS（版本 1.x）中 DI 技术的原生实现和使用
- en: Native implementation and customizable options to use DI in Angular 4+
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Angular 4+ 中使用 DI 的原生实现和可定制选项
- en: TypeScript
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript
- en: You probably already know the role that TypeScript plays in the development
    of modern JavaScript frameworks, and even by itself as an improved replacement
    for JavaScript.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道 TypeScript 在现代 JavaScript 框架开发中的作用，甚至作为 JavaScript 的改进替代品本身。
- en: 'TypeScript has many times been defined as a strongly typed superset of JavaScript.
    It is a superset because it includes everything JavaScript has (and that extends
    to versions 3, 5, and 6, also called ES2015), plus a number of features to allow
    programmers to code in an object-oriented paradigm. At the time of writing, the
    latest version available is 2.3:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 多次被定义为 JavaScript 的强类型超集。它是一个超集，因为它包括了 JavaScript 所有的内容（这扩展到版本 3、5
    和 6，也称为 ES2015），以及一些特性，允许程序员以面向对象的方式编程。在撰写本文时，可用的最新版本是 2.3：
- en: '![](img/4c4122d3-ea45-48e1-b556-b0fd41235c5d.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c4122d3-ea45-48e1-b556-b0fd41235c5d.png)'
- en: (Image courtesy: [http://blog.soat.fr/2016/08/feedback-typescript/](http://blog.soat.fr/2016/08/feedback-typescript/))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：[http://blog.soat.fr/2016/08/feedback-typescript/](http://blog.soat.fr/2016/08/feedback-typescript/)）
- en: Consequently, we find many syntactical benefits while it still lets you write
    normal JavaScript if you want to (an important point is that any valid JavaScript
    is valid TypeScript).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在保持可以编写正常 JavaScript 的同时（一个重要的点是任何有效的 JavaScript 都是有效的 TypeScript），仍然发现许多语法上的好处。
- en: In this way, TypeScript fosters a more declarative style of programming by using
    interfaces and static typing, it offers the concepts of modules and classes, and
    it's capable of integrating well with most existing JavaScript libraries and code.
    We can see it as a strongly static layer over JavaScript with a bunch of features
    to make the programmer's work (especially debugging) much more manageable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，TypeScript 通过使用接口和静态类型来促进更声明式的编程风格，它提供了模块和类的概念，并且能够很好地与大多数现有的 JavaScript
    库和代码集成。我们可以将其视为一个强静态层，覆盖在 JavaScript 之上，并附带许多功能，使程序员的（尤其是调试）工作变得更加易于管理。
- en: If you want to get a nice introduction to the TypeScript language, you can read
    *Introducing Object-Oriented Programming with TypeScript*, by Remo H. Jansen,
    (see [https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript](https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript))
    and, if you prefer to delve deeply into the language and its possibilities, take
    a look at the excellent *Mastering TypeScript* by Nathan Rozentals, available
    at [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对 TypeScript 语言有一个好的介绍，你可以阅读 Remo H. Jansen 的 *Introducing Object-Oriented
    Programming with TypeScript*（见 [https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript](https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript)），如果你更喜欢深入语言及其可能性，可以查看
    Nathan Rozentals 的优秀作品 *Mastering TypeScript*（可在 [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript)
    购买）。
- en: 'The main goals of Anders Hejlsberg (the TypeScript Chief Architect) when creating
    the language were:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建语言时，Anders Hejlsberg（TypeScript 的首席架构师）的主要目标是：
- en: Creating a totally object-oriented language that would convert into JavaScript
    at compilation time (it's called **transpilation** since it just produces another
    language and not a compiled module), allowing the final JavaScript generated to
    be executed in any browser (or Web platform).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完全面向对象的编程语言，在编译时转换为JavaScript（由于它只是产生另一种语言而不是编译模块，因此称为**transpilation**），允许最终生成的JavaScript在任何浏览器（或Web平台）中执行。
- en: 'Make the language statically typed, so the tools could offer modern development
    technologies in any editor: Intellisense, Code Completion, Intelligent Refactoring,
    and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使语言静态类型化，这样工具就可以在任何编辑器中提供现代开发技术：Intellisense、代码补全、智能重构等。
- en: Engage the community in the project by making the language completely open source.
    You can see the current state of the project and collaborate on its website at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使语言完全开源来让社区参与到项目中。你可以在其网站上看到项目的当前状态并协作，网址为[http://www.typescriptlang.org/](http://www.typescriptlang.org/)。
- en: Actually, TypeScript has been so successful that the Angular development team
    adopted it for the creation of Angular 2 and keeps on working with the language
    for coming versions (the most recent being Angular 4.1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，TypeScript已经非常成功，以至于Angular开发团队采用了它来创建Angular 2，并且继续为未来的版本（最新的是Angular 4.1）与该语言合作。
- en: Architectural changes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构变化
- en: Understanding some architectural changes is fundamental to realize how you can
    implement DI in a language that, once transpiled, is not object-oriented, except
    if you are doing that transpilation into ES2015.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一些架构变化对于实现DI（依赖注入）在编译后不是面向对象的编程语言中是基本的，除非你是在将其转换为ES2015。
- en: One of the biggest changes in ES2015 (or ES6, for short) is the presence of
    modules. A module is, basically, a piece of JavaScript code stored into a file.
    Once written, you can say that you have one file per module and one module per
    file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015（或简称ES6）中最大的变化之一是模块的存在。基本上，模块就是存储在文件中的JavaScript代码。一旦编写，你可以说每个模块对应一个文件，每个文件对应一个模块。
- en: Modules in TypeScript
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的模块
- en: 'TypeScript defines two different types of modules--internal and external. Moreover,
    we could still differentiate internal ones into two more categories: those that
    have a name and those that don''t (you could call them implicit). The difference,
    in this case, is in the way you define them and use them.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript定义了两种不同类型的模块——内部和外部。此外，我们还可以将内部模块进一步区分成两类：那些有名称的和那些没有名称的（你可以称它们为隐式的）。在这种情况下，区别在于你定义和使用它们的方式。
- en: 'Say you have a TypeScript file including the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含以下内容的TypeScript文件：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code by itself is an implicit module. It becomes a part of the global namespace
    and you can find it inside the `window` object at runtime. You could also consider
    the global namespace as the implicit (default) module.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身就是一个隐式模块。它成为全局命名空间的一部分，你可以在运行时在`window`对象中找到它。你也可以将全局命名空间视为隐式（默认）模块。
- en: Of course, we have better solutions than polluting the global namespace. The
    most obvious one is the `module` keyword which allows defining a private code
    section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一些比污染全局命名空间更好的解决方案。最明显的一个是`module`关键字，它允许定义一个私有代码区域。
- en: By definition, everything declared inside a module is private to that module.
    Therefore, the new reserved words `import` and `export` are used to allow access
    to a piece of code inside a named module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，模块内部声明的所有内容对该模块都是私有的。因此，新的保留字`import`和`export`被用来允许访问命名模块内的代码片段。
- en: 'If we wrap the previous class inside a module definition, any attempt to reference
    a module''s member outside the module is not recognized (see the following screenshot,
    inside the Visual Studio 2017 editor):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前的类包裹在一个模块定义中，那么在模块外部尝试引用模块成员将不被识别（请参阅以下截图，位于Visual Studio 2017编辑器内）：
- en: '![](img/0ff8b7b8-20d9-4ff5-9cae-58563dc37040.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ff8b7b8-20d9-4ff5-9cae-58563dc37040.png)'
- en: 'To make a module''s members available outside the module you should use the
    `export` keyword. Change the previous declaration into this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使模块的成员在模块外部可用，你应该使用`export`关键字。将之前的声明改为如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can use the module''s name to access its public members:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用模块的名称来访问其公共成员：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that the `ClassA.x` member is not accessible either due to its private
    declaration. In this manner, we have a convenient way to keep things tied to the
    namespace they should belong to.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`ClassA.x`成员的私有声明，它也无法访问。这样，我们就有了将事物与其应属于的命名空间关联起来的便捷方式。
- en: External modules
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部模块
- en: However, the most useful approach when you're dealing with large applications
    is the use of external modules. Actually, as John Papa suggests ([https://johnpapa.net/typescriptpost4/](https://johnpapa.net/typescriptpost4/)),
    it may be useful to organize the functionality of an application in terms of the
    modules you'll need.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你处理大型应用程序时，最有用的方法就是使用外部模块。实际上，正如John Papa建议的([https://johnpapa.net/typescriptpost4/](https://johnpapa.net/typescriptpost4/))，按你需要的模块来组织应用程序的功能可能是有用的。
- en: 'Let''s say we have a module definition inside the `ES6Code.ts` file. To export
    the `foo()`function and `Timer` class, you declare them as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在`ES6Code.ts`文件中有一个模块定义。要导出`foo()`函数和`Timer`类，你可以这样声明：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, in a distinct module or script section we can access that functionality
    using a slightly different reference:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在单独的模块或脚本部分，我们可以使用稍微不同的引用来访问该功能：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The same goes for the `Timer` class, except that we can also adopt another
    approach to reference the class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Timer`类也是如此，只不过我们还可以采用另一种方法来引用这个类：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the module's name is used as a prefix to the class instantiation,
    in a similar way to what you find in C# code when dealing with namespaces.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模块的名称用作类实例化的前缀，这与在处理C#代码时找到的命名空间方式类似。
- en: 'To test this code, we just have to include references to the corresponding
    transpiled files (`.js` extension), inside an HTML page, or test it inside the
    Node console. For instance, if you use a blank HTML page, you could include the
    files in this manner:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这段代码，我们只需在HTML页面中包含对应编译后的文件（`.js`扩展名）的引用，或者在内置的Node控制台中测试它。例如，如果你使用一个空白HTML页面，你可以这样包含文件：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note: The `<link>` tag is a fake favicon to prevent Chrome from presenting
    a File Not Found error in the console, next to the output.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`<link>`标签是一个假favicon，用于防止Chrome在控制台输出“文件未找到”错误。
- en: 'In both cases, the reference is correct, and the code is executed as expected,
    as we can see in the following screenshot (remember: `F12/Console` inside the
    developer''s tools of any modern browser. I''m using Chrome here):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，引用都是正确的，代码按预期执行，正如我们可以在下面的屏幕截图中看到（记住：在任何现代浏览器的开发者工具中的`F12/Console`。这里我使用的是Chrome）：
- en: '![](img/4efb9134-695c-4612-b276-7070d1815d10.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4efb9134-695c-4612-b276-7070d1815d10.png)'
- en: This is possible because, once the files are referenced inside a page, their
    members become accessible as long as they are marked as `export`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，一旦文件在页面内部被引用，只要它们被标记为`export`，它们的成员就可以访问。
- en: Actually, we can reference several files, and they'll be loaded and executed
    in sequence. Notice also that the console window indicates which code is responsible
    for the execution of which entry in the console.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以引用多个文件，并且它们将按顺序加载和执行。注意，控制台窗口还指示了哪些代码负责执行控制台中的哪个条目。
- en: 'In the initial example, `MyClasses` was stored inside the `app1.ts` file. So,
    now, we could also reference it, before the `</head>` tag, and check how a third
    source origin shows up in the console, which outputs the number 4, in the last
    position (check it in the following screenshot):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始示例中，`MyClasses`存储在`app1.ts`文件中。因此，现在我们也可以在`</head>`标签之前引用它，并检查第三个源在控制台中的显示，输出数字4在最后一个位置（如下面的屏幕截图所示）：
- en: '![](img/4ac5e5ae-8c88-4016-b656-f93411c52070.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4ac5e5ae-8c88-4016-b656-f93411c52070.png)'
- en: 'Also, you''ll notice that Chrome is smart enough to reference the original
    `.ts` files and not the transpiled ones, allowing you to debug any of these files,
    setting breakpoints, and so on. In the following screenshot, I''m showing the
    debugging window inside Chrome after setting a breakpoint before printing the
    date and time values:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你会发现Chrome足够智能，能够引用原始的`.ts`文件而不是编译后的文件，这允许你调试这些文件中的任何一个，设置断点等。在下面的屏幕截图中，我展示了在打印日期和时间值之前设置断点后的Chrome调试窗口：
- en: '![](img/fcc46658-0505-44bf-821b-3009b34a7095.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fcc46658-0505-44bf-821b-3009b34a7095.png)'
- en: Besides these options, now it's possible to debug within Visual Studio 2017
    using Chrome as default browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些选项之外，现在还可以使用Chrome作为默认浏览器在Visual Studio 2017中进行调试。
- en: This module separation is important because, as you'll see later, that implies
    file separation, which becomes crucial in the way TypeScript and, especially,
    Angular organize the distinct components of an application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块分离很重要，因为，正如你稍后将会看到的，这意味着文件分离，这对于TypeScript和，尤其是Angular组织应用程序的不同组件的方式变得至关重要。
- en: Dependency Injection in TypeScript
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript中的依赖注入
- en: All that said, TypeScript itself doesn't have a DI container. However, you could
    use some of the third-party options available. Some of the most popular are `Infuse.js`
    (available at [https://github.com/soundstep/infuse.js](https://github.com/soundstep/infuse.js))
    and TypeScript IoC, which you can find on the NPMJS site ([https://www.npmjs.com/package/typescript-ioc](https://www.npmjs.com/package/typescript-ioc)),
    both of which work in a very similar way to what we've already seen in .NET Core.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些说完，TypeScript 本身并没有 DI 容器。然而，你可以使用一些可用的第三方选项。其中一些最受欢迎的是 `Infuse.js`（可在 [https://github.com/soundstep/infuse.js](https://github.com/soundstep/infuse.js)
    获取）和 TypeScript IoC，你可以在 NPMJS 网站上找到它（[https://www.npmjs.com/package/typescript-ioc](https://www.npmjs.com/package/typescript-ioc)），两者都以与我们已经在
    .NET Core 中看到的方式非常相似的方式工作。
- en: That is, you have to make definitions that map an interface to a class or even
    a descriptor to a class and then register those options. Later on, you can make
    a reference to the type required and expect the DI container to provide you with
    the corresponding type.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你必须做出定义，将接口映射到类，甚至将描述符映射到类，然后注册这些选项。之后，你可以引用所需的类型，并期望 DI 容器为你提供相应的类型。
- en: Let's review the way TypeScript IoC works to define a simple injection scenario,
    the way it's shown on its official page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 TypeScript IoC 的工作方式，以定义一个简单的注入场景，就像它在官方页面上展示的那样。
- en: 'First, assuming you have TypeScript installed, you should also install TypeScript
    IoC, with a typical `npm` command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设你已经安装了 TypeScript，你还应该使用典型的 `npm` 命令安装 TypeScript IoC：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Besides that, some modern options are also required inside the configuration
    file (the `tsconfig.json` file):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置文件（`tsconfig.json` 文件）中还需要一些现代选项：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once that is configured, you use one of the `import` syntax variants to put
    it to work:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，你就可以使用 `import` 语法的一种变体来投入使用：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the `restProxy` property, which is of another type (`PersonRestProxy`),
    is marked with an `@Inject` decorator (a new feature in the latest versions of
    JavaScript and available in TypeScript), to indicate that it can be injected later
    on inside other code).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`restProxy` 属性（属于另一种类型 `PersonRestProxy`）被标记为 `@Inject` 装饰器（JavaScript
    最新版本中的新功能，并在 TypeScript 中可用），以表明它可以在其他代码中稍后注入）。
- en: 'Somewhere else in the code, you''ll be able to use these definitions with a
    very simple syntax:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的另一个地方，你将能够使用这些定义，语法非常简单：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `restProxy` property will be provided by the container, resolving the dependencies.
    Parameter injection is also provided, using a class with a constructor, as we
    can see in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`restProxy` 属性将由容器提供，解决依赖关系。参数注入也通过一个具有构造函数的类提供，如下面的代码所示：'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If, later on, you have another class that uses `PersonService` as a property,
    you mark that property with `@Inject`, like in this code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后来你有一个使用 `PersonService` 作为属性的另一个类，你可以在该属性上标记 `@Inject`，就像以下代码中所示：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can rely on the chain of dependencies being managed by the container, which
    will go through all references previously marked as `@Inject`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以依赖容器管理的依赖关系链，它将通过所有之前标记为 `@Inject` 的引用。
- en: However, in practice, it's rare to see applications in TypeScript itself and
    the most common use of this language is to provide other frameworks, such as Angular
    or Ionic, with a consistent development language.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，很少看到 TypeScript 本身的应用程序，这种语言最常见的用途是向其他框架，如 Angular 或 Ionic，提供一致的开发语言。
- en: Angular
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular
- en: As mentioned in [Chapter 2](9b8972f9-fedb-457b-a60a-8f62098bfa00.xhtml), *Dependency
    Injection and IoC Containers*, Angular is a development framework created by a
    team at Google (led by MiskoHevery), that has become very popular now (you can
    access the official information at [http://angularjs.org](http://angularjs.org)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 2 章](9b8972f9-fedb-457b-a60a-8f62098bfa00.xhtml) 中提到的，*依赖注入和 IoC 容器*，Angular
    是由 Google 团队（由 MiskoHevery 领导）创建的一个开发框架，现在已经成为非常流行的框架（你可以在 [http://angularjs.org](http://angularjs.org)
    访问官方信息）。
- en: 'Nowadays, Angular is available in two flavors that follow different release
    paths or branches:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Angular 以两种不同的风味提供，遵循不同的发布路径或分支：
- en: '**Version 1.x**:  Also called **AngularJS**. It''s recommended for small/medium
    applications and uses the MVC model to implement a suitable separation of concerns,
    from the beginning:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 1.x**：也称为 **AngularJS**。它适用于小型/中型应用程序，并使用 MVC 模型从开始就实现适当的关注点分离：'
- en: It's composed of a set of JavaScript libraries, each one supplying a part of
    the functionality required. However, all libraries depend on the basic AngularJS library.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它由一组 JavaScript 库组成，每个库提供所需功能的一部分。然而，所有库都依赖于基本的 AngularJS 库。
- en: At the time of writing, the latest version is 1.6.4, and the team guarantees
    support and future updates. It can also be downloaded via CDN at [https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js](https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js).
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本是 1.6.4，团队保证提供支持和未来的更新。它也可以通过 CDN 在 [https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js](https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js)
    下载。
- en: '**Version 2+**: It''s just named **Angular** and it follows a semantic versioning
    path, which means no breaking changes are allowed in minor revisions, only in
    new versions. There was a version number jump that avoided 3.0, so the latest
    version is Angular 4 (4.1, to be precise). It has a dedicated website apart from
    AngularJS at [https://angular.io/](https://angular.io/):'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本 2+**：它被称为 **Angular**，遵循语义版本控制路径，这意味着在次要修订中不允许有破坏性变化，只有在新的版本中才允许。为了避免
    3.0，版本号跳过了 3.0，所以最新版本是 Angular 4（确切地说，是 4.1）。它除了 AngularJS 之外还有一个专门的网站 [https://angular.io/](https://angular.io/)：'
- en: Perhaps the biggest change is that Angular is not backward-compatible with AngularJS
    since it embraces a number of changes that appeared in ES6 and directly affects
    the way modules are managed.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能最大的变化是 Angular 不与 AngularJS 兼容，因为它采用了 ES6 中出现的一些变化，这直接影响了模块的管理方式。
- en: Its main features are cross-compatibility, improved speed and performance, excellent
    tooling, and an increasing adoption by the community all over the world.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的主要特性包括跨兼容性、改进的速度和性能、优秀的工具支持，以及全球社区日益增长的采用率。
- en: 'Angular is built in TypeScript thanks to a joint venture with Microsoft''s
    TypeScript team, which actively collaborates in the project. Recently, one of
    the lead members of the team announced: *TypeScript has become allowed for unrestricted
    client development as of March 2017\. TypeScript and Angular on TypeScript are
    used in Google Analytics, Firebase, and Google Cloud Platform and critical internal
    tools such as bug tracking, employee reviews, and product approval and launch
    tools*.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular 是通过与微软 TypeScript 团队的合作在 TypeScript 中构建的，该团队积极参与项目。最近，团队的一位主要成员宣布：“自
    2017 年 3 月起，TypeScript 已被允许用于不受限制的客户端开发。TypeScript 和 TypeScript 上的 Angular 在 Google
    Analytics、Firebase 和 Google Cloud Platform 以及关键内部工具（如错误跟踪、员工评审和产品审批及发布工具）中使用。”
- en: Both versions have some points in common from an architectural point of view.
    They foster SOLID principles, and especially SRP and DIP, so they both rely on
    Dependency Injection containers. Furthermore, the adoption of the MVC model helps
    to structure the separation of concerns.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构角度来看，这两个版本有一些共同点。它们促进 SOLID 原则，特别是 SRP 和 DIP，因此它们都依赖于依赖注入容器。此外，采用 MVC 模型有助于结构化关注点的分离。
- en: Let's see how these two popular architectures implement Dependency Injection
    (although in different ways).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这两大流行架构如何实现依赖注入（尽管方式不同）。
- en: AngularJS
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AngularJS
- en: 'Creating a very basic Angular application is easy, once the basic principles
    of the MVC are clear. The MVC model proposes a foundational separation of application
    components into three parts (see the following figure):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清楚 MVC 的基本原理，创建一个非常基础的 Angular 应用程序就很容易了。MVC 模型建议将应用程序组件的基本分离为三个部分（见以下图示）：
- en: '![](img/dabe33e4-815f-4207-adb1-a5d71c704cb4.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dabe33e4-815f-4207-adb1-a5d71c704cb4.png)'
- en: '(Image courtesy: Wikipedia: [https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller))'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: （图片来源：维基百科：[https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller)）
- en: 'The user''s interaction generates a circuit in which the three pillars of MVC
    are present:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用户的交互生成一个电路，其中包含 MVC 的三个支柱：
- en: The **MODEL** is created automatically in the loading process of the AngularJS
    library.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**（MODEL）在加载 AngularJS 库的过程中自动创建。'
- en: The **VIEW** corresponds to the HTML side, which is marked with custom attributes
    (all starting with ***ng-***) to indicate the distinct functionality required.
    Views also use a syntax called **mustache** to indicate which parts are subject
    to data-binding.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**（VIEW）对应于 HTML 部分，通过自定义属性（所有以 ***ng-*** 开头）来标记所需的特定功能。视图还使用一种称为 **mustache**
    的语法来指示哪些部分受数据绑定的影响。'
- en: The **CONTROLLERS** are JavaScript fragments, coded to reflect any changes requested
    by the user, and manipulate the Model if required.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**是 JavaScript 片段，编码以反映用户请求的任何更改，并在需要时操作模型。'
- en: When the user interacts with a UI element in the page, a controller takes care
    of the corresponding action, modifies the model if it is necessary, and Angular
    updates the view reflecting the changes. Finally, the view is received by the
    user and this cycle continues uninterruptedly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与页面中的 UI 元素交互时，控制器会处理相应的操作，如果需要则修改模型，Angular 会更新视图以反映这些变化。最后，用户接收到的视图继续不间断地循环。
- en: Examples using Visual Studio 2017
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2017 的示例
- en: Once you have an HTML page that loads the AngularJS library, you should mark
    one DOM element with a special attribute (ng-app) to notify Angular of its working
    scope. This defines the area of action for AngularJS inside the page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有一个加载了 AngularJS 库的 HTML 页面，你应该用一个特殊的属性（ng-app）标记一个 DOM 元素，以通知 Angular 其工作作用域。这定义了
    AngularJS 在页面内的作用区域。
- en: 'Let''s see all this in a very simple example. We can use Visual Studio 2017
    as well, for example creating a new website (notice that we don''t need a project
    since we don''t need any compiled code on the server: it all happens on the client
    side).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常简单的例子来看一下所有这些。我们也可以使用 Visual Studio 2017，例如创建一个新的网站（请注意，我们不需要项目，因为我们不需要在服务器上编译任何代码：所有操作都在客户端进行）。
- en: So, I suggest choosing an ASP.NET Empty Website for this initial demo. That
    will create a folder to hold the solution and will include a `Web.config` file
    just in case you want to instruct the server about some behavior or require some
    compiled code as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议选择 ASP.NET 空网站来进行这个初始演示。这将创建一个文件夹来保存解决方案，并且会包含一个 `Web.config` 文件，以防你需要指导服务器关于某些行为或需要一些编译后的代码。
- en: 'Next, we add an HTML page and save the solution to be able to use the Manage
    NuGet packages option and search for the AngularJS.Core library. Make sure you''re
    selecting AngularJS.Core and not just angularjs if you don''t want to be overloaded
    with all available libraries for this framework (see the following screenshot):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个 HTML 页面并将解决方案保存，以便能够使用管理 NuGet 包选项并搜索 AngularJS.Core 库。确保如果你不想被这个框架的所有可用库所淹没，你选择的是
    AngularJS.Core 而不是 just angularjs（参见以下截图）：
- en: '![](img/b2496a17-6026-47f4-9948-4c2e58998b24.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2496a17-6026-47f4-9948-4c2e58998b24.png)'
- en: Once installed, a new Scripts folder will show up in the Solution Explorer,
    including a few libraries. You just need to drag and drop the angular.js library
    inside the `<head>` tag, to let Visual Studio create a `<script>` tag pointing
    to the library and you're ready to go!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，解决方案资源管理器中会出现一个新的 `Scripts` 文件夹，包括一些库。你只需要将 angular.js 库拖放到 `<head>` 标签内，让
    Visual Studio 创建一个指向库的 `<script>` 标签，然后你就可以开始了！
- en: The next step is adding the `ng-app` attribute (for example, to the `<body>`
    tag) and giving it a valid name, such as `app`. Currently, we have a page, the
    angular library loaded, and a scope defined.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加 `ng-app` 属性（例如，到 `<body>` 标签）并给它一个有效的名称，比如 `app`。目前，我们有一个页面，加载了 angular
    库，并且定义了一个作用域。
- en: 'How can we see some AngularJS in action with this? We can create an HTML tag,
    such as `<h2>`, `<h3>`, `<div>`, `<article>,` and so on, and include a moustache
    link inside (they''re called AngularJS binding expressions) that should be resolved
    at runtime, for example, a `<h2>` tag that will show the current time. In all,
    up to this point, we should have a page like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个来看到一些 AngularJS 的实际应用？我们可以创建一个 HTML 标签，如 `<h2>`、`<h3>`、`<div>`、`<article>`
    等，并在其中包含一个莫斯塔奇链接（它们被称为 AngularJS 绑定表达式），这些链接应该在运行时解析，例如，一个显示当前时间的 `<h2>` 标签。总的来说，到目前为止，我们应该有一个像这样的页面：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Observe the two identifiers (`app` and `time`) that are not defined yet. That
    will be our JavaScript section of this page. So, before the closing `</body>`
    tag, we will include an `<script>` tag with the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 观察两个尚未定义的标识符（`app` 和 `time`）。这将是我们这个页面的 JavaScript 部分。因此，在关闭 `</body>` 标签之前，我们将包含一个
    `<script>` 标签，其中包含以下代码：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This needs some explanation: first, we create a `module` named `app`. That
    is an object managed by AngularJS to establish the DOM area of interest, and it
    is created by calling the `method` module on the `angular` object that the library
    created at loading time. We cache the return value in a variable of the same name
    just to make the following code a bit clearer.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些解释：首先，我们创建一个名为 `app` 的 `module`。这是一个由 AngularJS 管理的对象，用于建立感兴趣的 DOM 区域，并且它是在加载时通过在
    `angular` 对象上调用 `method` module 创建的。我们只是将返回值缓存到同名变量中，以便使接下来的代码更清晰。
- en: The next step is crucial. Here we create a controller called `TimeController` and
    assign a callback function to it. Well, that function is using Dependency Injection
    by default! If you notice the function's definition, there's a `$scope` variable
    defined. Where does it come from?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步至关重要。在这里，我们创建一个名为 `TimeController` 的控制器，并给它分配一个回调函数。嗯，这个函数默认使用依赖注入！如果你注意到函数的定义，其中定义了一个
    `$scope` 变量。它从哪里来？
- en: The explanation is that, in several angular's constructions, when you define
    a callback function and declare a recognizable service as a parameter (such as
    `$scope`), a singleton instance of that service is provided by the `$injector`
    object to you with no intervention on our own.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解释是，在几个Angular构造中，当你定义一个回调函数并声明一个可识别的服务作为参数（如 `$scope`）时，`$injector` 对象会提供该服务的单例实例给你，而无需我们自己的干预。
- en: And it is precisely that `$injector` object that provides DI container services
    in AngularJS. Every object managed by a module has its own instance of that service
    and takes care of resolving all dependencies.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正是那个 `$injector` 对象提供了AngularJS中的DI容器服务。每个由模块管理的对象都有该服务的实例，并负责解决所有依赖。
- en: 'The official AngularJS documentation defines its implementation in this way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的AngularJS文档以这种方式定义了其实现：
- en: The AngularJS injector subsystem is in charge of creating components, resolving
    their dependencies, and providing them to other components as requested.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: AngularJS的注入子系统负责创建组件，解决它们的依赖关系，并在请求时将它们提供给其他组件。
- en: Understanding the structure of AngularJS bootstrap
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AngularJS引导结构
- en: 'The following diagram shows the structure of the bootstrap process that takes
    place when loading an Angular app:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了加载Angular应用时发生的引导过程的结构：
- en: '![](img/fbb8428a-d617-418a-b24f-52f42df59c2f.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbb8428a-d617-418a-b24f-52f42df59c2f.png)'
- en: 'The detailed explanation is this: HTML elements marked with attributes starting
    with `ng-` denote a part of the DOM called Dynamic DOM (where no `ng-` attributes
    are present, considered to be static DOM).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 详细解释如下：带有以 `ng-` 开头的属性的HTML元素表示DOM的一部分，称为动态DOM（没有 `ng-` 属性的，被认为是静态DOM）。
- en: 'Let''s briefly reproduce the steps used:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地重现所使用的步骤：
- en: When the DOM is loaded, AngularJS searches for a `ng-app`-marked element and
    defines a `$injector` linked to it.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当DOM加载时，AngularJS会寻找带有 `ng-app` 标记的元素，并定义一个与它关联的 `$injector`。
- en: 'In turn, that injector defines a `$compile` service that teaches the HTML interpreter
    some new syntax. To be precise, the documentation explains this point by stating
    that:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反过来，该注入器定义了一个 `$compile` 服务，它教会HTML解释器一些新的语法。更准确地说，文档通过以下方式解释这一点：
- en: '*The compiler allows you to attach behavior to any HTML element or attribute
    and even create new HTML elements or attributes with custom behavior. AngularJS
    calls these behavior extensions directives.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*编译器允许你将行为附加到任何HTML元素或属性，甚至可以创建具有自定义行为的新的HTML元素或属性。AngularJS将这些行为扩展称为指令。*'
- en: With all that in memory, AngularJS also creates a special service called `$rootScope`,
    which serves as the root model for the module. Of course, you can use it as well
    in your own code.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住所有这些，AngularJS还创建了一个特殊的服务，称为 `$rootScope`，它作为模块的根模型。当然，你可以在自己的代码中使用它。
- en: 'Now, every controller that you create has a child of that `$rootScope`, called
    simply `$scope`: that''s the section of the model that such a controller manages.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，你创建的每个控制器都有一个 `$rootScope` 的子控制器，简单地称为 `$scope`：这就是该控制器管理的模型部分。
- en: As the last step, the `$compile` object traverses the module, searching for
    elements that have `ng-*` attributes, here called directives, or AngularJS expressions
    (`{{moustache}}` annotations), and substitutes those elements with the required
    data or code.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一步，`$compile` 对象遍历模块，寻找具有 `ng-*` 属性的元素，这里称为指令，或者AngularJS表达式（`{{moustache}}`
    注释），并用所需的数据或代码替换这些元素。
- en: 'Consequently, the final aspect of our HTML code will be (I''m including only
    the contents of the `<body>` element):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们HTML代码的最后一个方面将是（我只包括 `<body>` 元素的內容）：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So, what I'm doing here is creating a model's variable (`time`) assigned to
    the controller named `TimeController`. Its value is equal to a string representing
    the current's system time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我在这里所做的是创建一个名为 `TimeController` 的控制器变量（`time`），其值等于表示当前系统时间的字符串。
- en: 'Finally, we need to indicate which AngularJS element is managed by which controller:
    in this case, it is the `<h2>` element containing the `time` variable defined
    in the model. At runtime, AngularJS substitutes the variable''s value for the
    `{{time}}` expression.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要指出哪个AngularJS元素由哪个控制器管理：在这种情况下，是包含在模型中定义的`time`变量的`<h2>`元素。在运行时，AngularJS将变量的值替换为`{{time}}`表达式。
- en: 'The output in the browser changes every time you refresh the page (see the
    following screenshot):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的输出每次刷新页面时都会改变（请参阅以下截图）：
- en: '![](img/85b8713d-4c16-4128-9c84-59c529808163.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85b8713d-4c16-4128-9c84-59c529808163.png)'
- en: This is a very simple demo, but it illustrates the basics of AngularJS and how
    DI is pervasive throughout the framework since you'll find it all over.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，但它说明了AngularJS的基础以及DI如何在整个框架中无处不在，因为你会发现它无处不在。
- en: Data access and Dependency Injection
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据访问和依赖注入
- en: Actually, we can see a better implementation of a controller and how to use
    the `$injector` object if we access some real data using another AngularJS service,
    called `$http`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们使用另一个名为`$http`的AngularJS服务访问一些真实数据，我们可以看到控制器的一个更好的实现以及如何使用`$injector`对象。
- en: 'The following code reads all data from the `BookStore2.json` file that we used
    in [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, demos and creates a list of its elements.
    I''ll show you the code first, and then we''ll move to the explanation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码读取了我们在第9章中使用的`BookStore2.json`文件的所有数据，*依赖注入的反模式和误解*演示，并创建了一个元素列表。我将首先展示代码，然后我们将进行解释：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Before commenting this out, let us note that I'm also using the BootStrap library,
    but that's only for presentation purposes; it has nothing to do with DI.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在取消注释之前，让我们注意，我还在使用BootStrap库，但这只是为了展示目的；它与DI无关。
- en: 'If you look at the previous code in any browser, it will present an output
    very similar to the one that''s shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在任何浏览器中查看之前的代码，它将呈现一个与以下截图非常相似的输出：
- en: '![](img/8780a472-7196-42ea-973a-e4bcdc67b170.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8780a472-7196-42ea-973a-e4bcdc67b170.png)'
- en: 'Let''s review the most important changes in this code. On the JavaScript side:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这段代码中最重要的一些更改。在JavaScript方面：
- en: Module creation is not cached into a variable (this avoids unnecessary variables
    in the global space).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块创建不会缓存在变量中（这避免了在全局空间中不必要的变量）。
- en: 'The controller is created using a function expression assigned to a variable
    of the same name. It declares two variables to be injected later on:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器是通过将一个函数表达式赋值给同名的变量来创建的。它声明了两个稍后将要注入的变量：
- en: '`$scope`: The reference to the model linked to the controller'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$scope`：与控制器链接的模型引用'
- en: '`$http`: A service that facilitates request/response actions with HTTP servers,
    either using the `XmlHttpRequest` object (AJAX) or JSONP inside AngularJS'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$http`：一个服务，它通过使用AngularJS中的`XmlHttpRequest`对象（AJAX）或JSONP与HTTP服务器进行请求/响应操作'
- en: 'Inside the function, `$http` is used to get data by calling its `get` method
    and passing it the URL of the resource to recover. That call returns a promise,
    which is resolved asynchronously:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，使用`$http`通过调用其`get`方法并传递要恢复的资源URL来获取数据。该调用返回一个承诺，该承诺异步解决：
- en: 'When the promise is resolved, it returns the expected information, and the
    callback functions linked to it will receive an object with the following properties,
    according to the official site''s documentation:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当承诺解决时，它返回预期的信息，并且与之链接的回调函数将接收到一个对象，该对象具有以下属性，根据官方网站的文档：
- en: '`data{string|Object}`: The response body transformed with the transform functions'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data{string|Object}`: 使用转换函数转换后的响应体'
- en: '`status{number}`: HTTP status code of the response'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status{number}`: 响应的HTTP状态码'
- en: '`headers{function([headerName])}`: Header getter function'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers{function([headerName])}`: 获取头部的函数'
- en: '`config{Object)`: The configuration object that was used to generate the request'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config{Object}`: 生成请求时使用的配置对象'
- en: '`statusText{string}`: HTTP status text of the response'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statusText{string}`: 响应的HTTP状态文本'
- en: If the status code is a number between 200 and 299, the process is successful,
    and a subsequent call to `.then()` receives the information inside its `[parameter].data`
    property
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态码是200到299之间的数字，则过程成功，并且后续调用`.then()`将接收其`[parameter].data`属性内的信息
- en: Otherwise (if you get a different status code) there's an error and you should
    catch it with an extra call to `.catch(),` just as we do in the preceding code
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则（如果你得到不同的状态码），将出现错误，你应该通过额外的`.catch()`调用来捕获它，就像我们在前面的代码中所做的那样
- en: 'The `$injector` object is able to resolve the names of the variables as singleton
    instances of the services they represent, but what happens when you package your
    application and the *minifiers* change the name of those variables? This is where
    the `$inject` array comes in:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$injector`对象能够解析变量的名称，作为它们所代表服务的单例实例，但当你打包应用程序并且**minifiers**更改这些变量的名称时会发生什么？这就是`$inject`数组发挥作用的地方：'
- en: It allows the *minifiers* to rename the function's parameters and still be able
    to inject the referred services. Notice that it is an array linked to the controller,
    and it can grow or shrink at will.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许**minifiers**重命名函数的参数，同时仍然能够注入引用的服务。请注意，这是一个与控制器链接的数组，它可以随意增长或缩小。
- en: 'The final step is to define the controller itself inside the module. That''s
    why we use the `angular.module("app")` syntax, which accesses the module and invokes
    the required methods inside (notice this time we don''t pass the second argument:
    that means to access, not creation).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是在模块内部定义控制器本身。这就是为什么我们使用`angular.module("app")`语法，它访问模块并在其中调用所需的方法（注意这次我们没有传递第二个参数：这意味着访问，而不是创建）。
- en: Of course, there is much more to AngularJS using DI and the framework itself,
    but I hope now have some idea of how Dependency Injection is implemented here.
    Let's summarize and complete the most important points about this pattern inside
    AngularJS.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，AngularJS使用DI和框架本身还有很多其他功能，但我希望现在对依赖注入在这里是如何实现的有一个大致的了解。让我们总结并完成AngularJS中这个模式最重要的要点。
- en: Summing up Dependency Injection features inside AngularJS
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结AngularJS中的依赖注入功能
- en: Dependency creation in AngularJS is the responsibility of the `injector` object.
    This object, by the way, uses the constructor injection paradigm. Actually, the
    injector behaves as a service locator that takes care of construction and look
    up for dependencies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在AngularJS中，依赖项的创建是`injector`对象的责任。顺便说一下，该对象使用构造函数注入范式。实际上，注入器表现得像一个服务定位器，负责构造和查找依赖项。
- en: This is achieved using the declarative notation in HTML templates. When the
    HTML is processed (parsed), it passes the responsibility for component creation
    to the injector, thus avoiding the need to pass the injector throughout the application.
    All that work is done "behind the scenes".
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在HTML模板中使用声明性记号来实现的。当HTML被处理（解析）时，它将组件创建的责任传递给注入器，从而避免了在整个应用程序中传递注入器的需要。所有这些工作都是在幕后完成的。
- en: As the documentation states, working in this manner *t**he application code
    simply declares the dependencies it needs, without having to deal with the injector.
    This setup does not break the Law of Demeter*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如文档所述，以这种方式工作，应用程序代码只需声明它需要的依赖项，无需处理注入器。这种设置不会违反迪米特法则*。
- en: Let's now focus on the latest versions of Angular (versions 2.0+), that are,
    in several ways, based on many of these principles but change its implementation
    quite a bit since they embrace ES6 and related technologies.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注Angular的最新版本（版本2.0+），它们在许多方面基于这些原则，但它们的实现方式有很大的不同，因为它们采用了ES6和相关技术。
- en: Angular 2+
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 2+
- en: Since the release of AngularJS (version 1.x) in 2009, the web has changed immensely.
    We now have a multitude of build systems, modular loading capabilities, and Web
    components available to use. JavaScript development has also come on in leaps
    and bounds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自从2009年AngularJS（版本1.x）发布以来，网络发生了巨大的变化。我们现在有各种各样的构建系统、模块化加载能力和可用的Web组件。JavaScript开发也取得了飞跃性的进步。
- en: Those changes were not reflected in AngularJS, so it was not as performant as
    the team wanted, mainly due to the digest cycles (related to the DOM parsing that
    we mentioned previously), and directly related to change detection.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改在AngularJS中没有反映出来，因此它的性能不如团队所希望的那样，主要由于消化周期（与我们之前提到的DOM解析相关），以及直接与变更检测相关。
- en: Change detection in Angular can be imagined as a tree working in one direction
    from the root to its leaves so that it's both faster and more predictable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，变更检测可以想象成从根到叶子的单向工作树，这样既快又可预测。
- en: The name of any version higher than 1.x is just Angular, without the `JS` suffix
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任何高于1.x版本的名称只是Angular，没有`JS`后缀
- en: Angular has observable and immutable objects that greatly speed up how many
    properties are checked.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 有可观察和不可变对象，这大大加快了检查多少个属性的速度。
- en: Besides, observable objects are triggered only if an input that they rely on
    emits an event. Immutable objects are only checked if one of their input properties
    has changed. In most cases though, these two types of object don't have to be
    checked, meaning that your whole application will be speeded up.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可观察对象仅在它们依赖的输入发出事件时才会触发。不可变对象仅在它们的输入属性之一发生变化时才会检查。然而，在大多数情况下，这两种类型的对象不需要检查，这意味着你的整个应用程序将会加速。
- en: Microsoft's TypeScript is the preferred language in Angular 2+
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft 的 TypeScript 是 Angular 2+ 中的首选语言
- en: Another big change is the use of TypeScript as the preferred language (the Angular
    team also uses TypeScript language services and Visual Studio Code, to detect
    failures and inconsistencies in code, as Brad Green declared recently).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重大变化是使用 TypeScript 作为首选语言（Angular 团队也使用 TypeScript 语言服务和 Visual Studio Code，以检测代码中的失败和不一致性，正如布拉德·格林最近所宣布的）。
- en: TypeScript has great support in editors such as Visual Studio Code and WebStorm
    and it behaves as a permanent assistant when you are importing modules and autocompleting
    intelligent suggestions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 在 Visual Studio Code 和 WebStorm 等编辑器中得到了很好的支持，并且当你导入模块和自动完成智能建议时，它表现得像一个永久的助手。
- en: Moreover, since it is a typed language, hints provided are far more in-depth
    than JavaScript's Intellisense. Additionally, any JavaScript is valid TypeScript,
    so you can use as much or as little of it as you're comfortable with. Many areas
    help Angular, such as interfaces, constructors, public variables, classes, typed
    arguments, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于它是一种类型化语言，提供的提示比 JavaScript 的 Intellisense 深得多。此外，任何有效的 JavaScript 都是 TypeScript，因此你可以根据你的舒适度使用尽可能多或尽可能少的
    TypeScript。许多区域有助于 Angular，例如接口、构造函数、公共变量、类、类型化参数等等。
- en: But perhaps the biggest change in Angular is that its architecture is based
    on the concept of the component. And those components are defined using class
    annotations or decorators, a feature that allows adding metadata to a class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许 Angular 中最大的变化是其架构基于组件的概念。这些组件是通过类注解或装饰器定义的，这是一个允许向类添加元数据的特性。
- en: Before delving into it, let's first remind ourselves of the required tooling
    to work with Angular.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨之前，让我们首先提醒自己与 Angular 一起工作所需的工具。
- en: Angular tools
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 工具
- en: To work with the latest versions of Angular you can certainly choose from a
    variety of tools, but I'm going to use those that the official site recommends,
    plus those you need as a requirement.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Angular 的最新版本，你可以当然从各种工具中选择，但我将使用官方站点推荐的工具，以及你作为需求所需的工具。
- en: 'First, you need a recent version of Node.js installed. At the time of writing,
    two versions are available on its website ([https://nodejs.org/es/](https://nodejs.org/es/)):
    6.10.3 and 7.10.0\. Either one will be fine, although I have installed 7.10.0\.
    This installation provides two basic tools to work with Angular: Node and **NPM**
    (**Node Package Manager**).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装一个较新的 Node.js 版本。在撰写本文时，其网站上提供了两个版本（[https://nodejs.org/es/](https://nodejs.org/es/)）：6.10.3
    和 7.10.0。任何一个都可以，尽管我安装了 7.10.0。这个安装提供了两个基本工具来与 Angular 一起工作：Node 和 **NPM**（**Node
    包管理器**）。
- en: 'Once you have completed the installation, make sure the versions are correct
    by typing the following in a console window:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请确保版本正确，通过在控制台窗口中输入以下内容：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And by typing the following too:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并且通过输入以下内容：
- en: '[PRE18]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With that in place, there are a number of editors suitable for Angular, but
    you could try the free cross-platform Visual Studio Code, which has debugging
    capabilities and works fine in Windows, Linux, and OSX.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，有许多适合 Angular 的编辑器，但你可以尝试免费的跨平台 Visual Studio Code，它具有调试功能，在 Windows、Linux
    和 OSX 上运行良好。
- en: Working with Angular
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Angular
- en: Let's install Angular CLI, a command line interface to work with Angular, which
    helps a lot in the initial steps with this framework. We will be able to create
    the early application very easily and understand how the architecture changes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装 Angular CLI，这是一个用于与 Angular 一起工作的命令行界面，它在这个框架的初始步骤中非常有帮助。我们将能够非常容易地创建早期应用程序，并了解架构的变化。
- en: 'Angular CLI has a dedicated website ([https://cli.angular.io/](https://cli.angular.io/)),
    where you''ll find the installation process, downloads, and the related documentation.
    However, the easiest way to install it is via NPM. You just have to type the following
    in a Command Prompt:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI有一个专门的网站([https://cli.angular.io/](https://cli.angular.io/))，在那里你可以找到安装过程、下载和相关文档。然而，最简单的方法是通过NPM安装它。你只需在命令提示符中输入以下命令：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This installs the Angular-CLI tools globally, so it is available all over the
    filesystem.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在全局范围内安装Angular-CLI工具，因此它在整个文件系统中都是可用的。
- en: 'Once again, it''s a good practice to check the final state of the installation,
    which you can do by typing the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，检查安装的最终状态是一个好习惯，你可以通过输入以下命令来完成：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output should show the following information:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应显示以下信息：
- en: '![](img/1b2a8589-50ea-4255-ad24-903883c1ac12.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b2a8589-50ea-4255-ad24-903883c1ac12.png)'
- en: And we're all set! If you want to take a look at the list of commands that Angular
    CLI holds, just type `ng --help`. A long list will show up, so you can have an
    idea of how powerful this tool is in current versions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪！如果你想查看Angular CLI所持有的命令列表，只需输入`ng --help`。会出现一个长长的列表，这样你就可以了解这个工具在当前版本中的强大之处。
- en: 'To create the first application, open a Command Prompt (you can use the Developer
    Command Prompt link that Visual Studio installs), go to the directory where you
    want your demos to be located, create a new directory, and type the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建第一个应用程序，打开命令提示符（你可以使用Visual Studio安装的开发者命令提示符链接），转到你想要放置演示的目录，创建一个新的目录，并输入以下命令：
- en: '[PRE21]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In my case, I typed `ng new ng4-demo` and then you wait until the bunch of libraries
    from NPM is downloaded and installed in the directory of your choice.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我输入了`ng new ng4-demo`，然后你等待NPM的一堆库在你的选择目录中下载和安装。
- en: 'Inside the new directory, you can now see the list of files and directories
    created by the tool, and ready to launch. Notice that there are three new directories:
    `e2e`, `node_modules,` and `src`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在新目录中，你现在可以看到由工具创建的文件和目录列表，并准备好启动。请注意，有三个新的目录：`e2e`、`node_modules`和`src`。
- en: The first one contains end-to-end tests for the application. That's done by
    default and you should modify those definitions further on to suit your needs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含应用程序的端到端测试。这是默认设置的，你应该进一步修改这些定义以满足你的需求。
- en: 'The second and largest one holds the large list of JavaScript libraries required
    for almost any Angular application. Don''t get scared by its length: they''re
    downloaded and installed locally to provide programmers with the tools they might
    need, but at deploying time only those required will be included in the bundling
    and minifying process prior to deployment (it is called **tree-shaking**).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个最大的目录包含了几乎任何Angular应用程序所需的JavaScript库列表。不要因为它的长度而感到害怕：它们被下载并本地安装，为程序员提供他们可能需要的工具，但在部署时，只有那些必需的库会被包含在部署前的打包和压缩过程中（这被称为**tree-shaking**）。
- en: Finally, in the `src` directory, you'll find all the files required for this
    initial demo. The rest are files used by Angular CLI and other tools (such as
    the editors) to manage the project (especially, `package.json`, `tsconfig.json`,
    and `angular-cli.json`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`src`目录中，你会找到这个初始演示所需的全部文件。其余的是Angular CLI和其他工具（如编辑器）用于管理项目的文件（特别是`package.json`、`tsconfig.json`和`angular-cli.json`）。
- en: 'You should end up with a list like the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终会得到以下列表：
- en: '![](img/ef11a241-5f06-4ac6-8ae3-1f6dee9c8b01.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef11a241-5f06-4ac6-8ae3-1f6dee9c8b01.png)'
- en: To see it in action, just type `ng serve`. That will run the Webpack tool to
    get everything ready and launch a server on port 4200 (by default).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到它的实际效果，只需输入`ng serve`。这将运行Webpack工具准备一切，并在默认情况下在4200端口启动一个服务器。
- en: The final step will be to open any browser with the URL `http://localhost:4200`
    and see the very simple page saying `app works` (I omit the output; it is pretty
    obvious).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是打开任何浏览器，输入URL `http://localhost:4200`，并查看显示“app works”的非常简单的页面（我省略了输出；这很显然）。
- en: Editing the initial project
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑初始项目
- en: Now that we know everything works, let's view the project inside Visual Studio
    Code (or the editor of your choice), and try to understand the architecture behind
    this.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道一切正常，让我们在Visual Studio Code（或你选择的编辑器）中查看项目，并尝试理解其背后的架构。
- en: So, I'll open the editor from the Command Prompt, just by typing `code .` on
    the main project's directory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将从命令提示符打开编辑器，只需在主项目目录中输入`code .`即可。
- en: For more information about the VSCode, visit [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于VSCode的信息，请访问[https://code.visualstudio.com/](https://code.visualstudio.com/)。
- en: 'Perhaps, the most amazing thing about this initial demo (especially if you
    compare it to our previous demos in Angular 1.6) is the lack of references and
    directives inside the main HTML page of this app:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，这个初始演示最令人惊奇的事情（尤其是如果你将其与我们之前在Angular 1.6中的演示进行比较）是这个应用程序主HTML页面内缺少引用和指令：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only non-static HTML is marked in bold: `<app-root>`. Angular resolves
    this customized element into the real page you saw in the browser through a complex
    process of component-related architectures, in which every component defines its
    behavior, its visual elements (if it has any), and the way it communicates with
    the rest of the application.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的非静态HTML用粗体标出：`<app-root>`。Angular通过一个复杂的组件相关架构过程将这个自定义元素解析成你在浏览器中看到的真实页面，在这个过程中，每个组件定义其行为、其视觉元素（如果有），以及它与应用程序其余部分的通信方式。
- en: If you look inside the `src` directory, you'll see several TypeScript files.
    The module responsible for instructing the browser what to do when `http://localhost:4200`
    is invoked appears inside the `angular-cli.json` file. This file contains a bunch
    of definitions about editor and server behaviors, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`src`目录，你会看到几个TypeScript文件。负责在调用`http://localhost:4200`时指导浏览器做什么的模块位于`angular-cli.json`文件中。此文件包含有关编辑器和服务器行为等的大量定义。
- en: 'It holds an app''s entry containing that `main` property and also the entry
    point of the application, which is linked to an `index` field (see the following
    screenshot):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个应用程序的入口，包含那个`main`属性，以及应用程序的入口点，它与一个`index`字段相关联（见以下截图）：
- en: '![](img/40ec42a2-507e-4a5c-a169-569022036138.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40ec42a2-507e-4a5c-a169-569022036138.png)'
- en: 'With those definitions, the browser knows which page to launch, and the server
    which components should be resolved: whatever the `main` module indicates. And
    what it shows is a basic environment configuration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些定义，浏览器知道要启动哪个页面，服务器知道应该解析哪些组件：无论`main`模块指示什么。它显示的是一个基本的环境配置：
- en: '![](img/afc0ddac-9403-43ff-b497-80fd1711ff66.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afc0ddac-9403-43ff-b497-80fd1711ff66.png)'
- en: So, this is how Angular manages the initialization of the app. Whatever is inside
    `AppModule` will be loaded and resolved.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是Angular管理应用程序初始化的方式。无论`AppModule`内部有什么，都将被加载和解析。
- en: The structure of the main module
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主模块的结构
- en: 'However, as it turns out that every angular application must consist of at
    least one module, the `app.module.ts` becomes the one that sets up the application.
    It''s mandatory to understand how it works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于每个Angular应用程序都必须至少包含一个模块，`app.module.ts`就成为了设置应用程序的那个模块。理解它是如何工作的至关重要：
- en: '![](img/4f8c1e04-cc51-44f4-be70-e0b82eed4403.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f8c1e04-cc51-44f4-be70-e0b82eed4403.png)'
- en: First, we find `import` statements that load some previously exported components
    inside the Angular libraries, such as `platform-browser`, `core`, `forms`, and
    `http`. Some of these libraries are not needed in this basic demo, however.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找到`import`语句，这些语句加载了Angular库中之前导出的某些组件，例如`platform-browser`、`core`、`forms`和`http`。然而，这些库中的一些在这个基本演示中并不需要。
- en: The last `import` statement is the one that links this module with the rest
    of the functionality, loading `app.component`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个`import`语句是连接此模块与剩余功能，加载`app.component`的那个。
- en: The way you define a module is by means of a class (here named `AppModule`),
    marked with a `@NgModule` decorator. There are no functionalities or definitions
    inside. Only the decorator provides the correct link with the rest of the app's
    elements.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 定义模块的方式是通过一个类（这里命名为`AppModule`），并用`@NgModule`装饰器标记。里面没有功能或定义。只有装饰器提供了与应用程序其余元素的正确链接。
- en: Actually, the `bootstrap` property indicates which component will be in charge
    of launching the application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`bootstrap`属性指示哪个组件将负责启动应用程序。
- en: 'Let''s see how that component is made up:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个组件是如何构成的：
- en: '![](img/1282f3d2-3cd8-4bc5-be35-6163ed34f975.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1282f3d2-3cd8-4bc5-be35-6163ed34f975.png)'
- en: Now we have the `AppComponent` class marked with the `@Component` decorator.
    Inside, we find the HTML part that we see in the browser. It's the title field
    of the class.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个带有`@Component`装饰器的`AppComponent`类。在里面，我们找到了在浏览器中看到的HTML部分。它是类的标题字段。
- en: 'But, inside the decorator, we have some clues:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在装饰器内部，我们有一些线索：
- en: '`selector`: Indicates the customized piece of dynamic DOM that will be translated
    into a real fragment of HTML at runtime. Remember, the only foreign part of HTML
    inside `Index.html` is that reference to the `<app-root>` element.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selector`：指示将被转换为运行时真实 HTML 片段的定制动态 DOM 部分。记住，`Index.html` 内部的 HTML 的唯一外部部分是对
    `<app-root>` 元素的引用。'
- en: '`templateUrl` (optionally just template, if indicated next): The file containing
    the HTML fragments that will replace the selector. They admit `{{moustache}}`
    syntax, as it happens here.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateUrl`（可选，如果指示的话）：包含将替换选择器的 HTML 片段的文件。它们接受 `{{moustache}}` 语法，就像这里发生的那样。'
- en: '`styleUrls`: An array of CSS files that will be loaded at runtime for presentation
    purposes. They will only affect the component that defines them, and not the whole
    page.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleUrls`：一个 CSS 文件数组，将在运行时加载用于展示目的。它们只会影响定义它们的组件，而不会影响整个页面。'
- en: 'Finally, the `app works` sentence that we saw in the browser''s initial page
    is just the `title` property of the `AppComponent` class. And, yes, it is linked
    via data-binding to the HTML inside the template, which is just a `<h1>` element:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在浏览器初始页面中看到的 `app works` 句子只是 `AppComponent` 类的 `title` 属性。是的，它是通过数据绑定链接到模板内的
    HTML 的，而模板只是一个 `<h1>` 元素：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So, let''s make a couple of changes, to see how it goes. Instead of `app works`,
    I''ll change the `title` property to `First demo in Angular 4`, and the CSS file,
    which is empty, will also hold some formatting rules:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们做一些更改，看看效果如何。我将 `app works` 改为 `title` 属性的 `First demo in Angular 4`，而空的
    CSS 文件也将包含一些格式化规则：
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, we can also add any static content to the `**index.html**` itself
    (an image, for example, next to the selector):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以将任何静态内容添加到 `**index.html**` 本身（例如，一个图像，位于选择器旁边）：
- en: '[PRE25]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The environment will take care of every change in the application and incrementally
    recompile those changes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 环境将负责处理应用中的每一个变化，并增量地重新编译这些变化。
- en: Notice that, at the end, the text we see is the class' `title` property, which
    is evaluated and managed by the component architecture of the Angular framework,
    and it is this component architecture that facilitates the implementation of Dependency
    Injection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后我们看到的是类的 `title` 属性，它由 Angular 框架的组件架构评估和管理，正是这个组件架构促进了依赖注入的实现。
- en: 'So, we should see those changes without any more intervention:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该看到这些变化，而无需任何更多干预：
- en: '![](img/d7fd9cc0-f66b-4eaa-aa72-46f81c7eb9fa.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7fd9cc0-f66b-4eaa-aa72-46f81c7eb9fa.png)'
- en: Some of the procedures implied in this model use types of dependencies that
    are solved at compile time and runtime. But how can we see the DI in action?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模型中隐含的一些过程使用在编译时间和运行时解决的依赖类型。但我们如何看到 DI 的实际应用呢？
- en: DI in Angular 4
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular 4 中的依赖注入（DI）
- en: Well, DI in Angular follows the construction injection pattern; thus, since
    we are dealing with classes (components) here, most of the injection is required
    in the constructor's parameter definitions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Angular 中的 DI 遵循构造函数注入模式；因此，由于我们在这里处理的是类（组件），大多数注入都需要在构造函数参数定义中进行。
- en: A dedicated page on the official Angular documentation site supplies more information
    about Dependency Injection at [https://angular.io/docs/ts/latest/guide/dependency-injection.html](https://angular.io/docs/ts/latest/guide/dependency-injection.html).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Angular 文档网站上有一个专门的页面提供了有关依赖注入的更多信息，请参阅[https://angular.io/docs/ts/latest/guide/dependency-injection.html](https://angular.io/docs/ts/latest/guide/dependency-injection.html)。
- en: As with AngularJS, Angular creates an injector object in the bootstrap process,
    so you don't have to do it by yourself (remember, the `platformBrowserDynamic().bootstrapModule(AppModule)`sentence
    inside `main.ts`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AngularJS 一样，Angular 在引导过程中创建了一个注入器对象，因此您不需要自己创建它（记住，`main.ts` 中的 `platformBrowserDynamic().bootstrapModule(AppModule)`
    语句）。
- en: The concept of a provider
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者的概念
- en: With that in mind, the programmer's responsibility is to register those classes
    that will be served via DI later on. You can do that, either in the `NgModule`,
    or inside any `Component`, but, in either case, the way to declare an injectable
    class is by adding its name to the `provider's` collection of a component or module.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，程序员的职责是注册那些将通过 DI 服务的类。您可以在 `NgModule` 中或任何 `Component` 内完成此操作，但无论如何，声明可注入类的途径是将它的名称添加到组件或模块的
    `provider` 集合中。
- en: The difference will be that, when declared inside a `@**NgModule**`, those services
    will be available alongside the entire application. In the remaining cases, it
    will be limited to the component's hierarchy.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于，当在`@**NgModule**`内部声明时，这些服务将与整个应用程序一起可用。在其他情况下，它将限制在组件的层次结构内。
- en: Let's modify the previous example, so you can see this technique in action.
    Actually, it is quite simple.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的例子，这样你就可以看到这个技术的实际应用。实际上，这相当简单。
- en: The first step is to create a class that provides the injected information required
    (I'll call it `DIClass`). Let's imagine we want an extra text property and a picture.
    Since we only need the picture's URL, we'll define two string properties.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个提供所需注入信息的类（我将称之为`DIClass`）。让我们假设我们想要一个额外的文本属性和一张图片。由于我们只需要图片的URL，我们将定义两个字符串属性。
- en: 'But to make the class injectable, we need to mark it as such. We do that by
    importing the "`Injectable`" definition from `@angular/core` and decorating the
    class with that annotation. The final aspect of this class'' code will be:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了使这个类可注入，我们需要将其标记为可注入。我们通过从`@angular/core`导入`"Injectable"`定义，并用该注解装饰类来实现这一点。这个类的代码的最后一个方面将是：
- en: '![](img/b4d6086e-6d07-4c26-a03f-42a807a00f45.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b4d6086e-6d07-4c26-a03f-42a807a00f45.png)'
- en: Now, we can get rid of the `<img>` element we inserted in `index.html` and pass
    the task of inserting the image to the component.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从`index.html`中移除我们插入的`<img>`元素，并将插入图片的任务交给组件。
- en: Besides that, and only for presentation purposes, I've modified the `app.component.css`
    code to mark the injected information inside a border, so those fragments become
    clearly visible.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仅为了展示目的，我已经修改了`app.component.css`代码，用边框标记注入的信息，这样这些片段就变得清晰可见。
- en: With the class ready, we now define the scope of this service. Since we only
    need it for our `AppComponent`, we'll add a new definition of `providers` in the
    `@Component` decorator's class; this will make our `DIClass` content available
    inside the component.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 类准备好了，我们现在定义这个服务的范围。由于我们只需要在`AppComponent`中使用它，我们将在`@Component`装饰器的类中添加一个新的`providers`定义；这将使`DIClass`的内容在组件内部可用。
- en: Finally, we can modify our class to hold two extra properties (`subtitle` and
    `fotosource`), whose values are received by injection. In practice, this injected
    class will often be data access services or any other type of resource that might
    be needed in more than one application's component.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以修改我们的类以包含两个额外的属性（`subtitle`和`fotosource`），它们的值是通过注入获得的。在实践中，这个注入的类通常会是被多个应用程序的组件所需的数据访问服务或其他类型的资源。
- en: 'Since the way those values are received is by declaring the injected class
    (or values) in the constructor, the final version will be:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些值是通过在构造函数中声明注入的类（或值）来接收的，最终的版本将是：
- en: '![](img/bb1b2adb-1090-4c00-8933-c3ae394459b7.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb1b2adb-1090-4c00-8933-c3ae394459b7.png)'
- en: 'Now, if you keep the server running and take a look at the new aspect of the
    page, next to the initial message, we should see those injected elements, formatted
    according to the CSS rules inside the `**app.component.css**` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你保持服务器运行并查看页面的新方面，在初始消息旁边，我们应该看到那些注入的元素，格式化根据`**app.component.css**`文件内的CSS规则：
- en: And that's it. We can inject as many items as needed as long as we have previously
    declared those values with the `**@Injectable**` decorator; however, if you need
    more customizable services or data, I recommend reading the documentation's reference
    I mentioned previously.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。只要我们之前用`**@Injectable**`装饰器声明了这些值，我们就可以注入所需数量的项目；然而，如果您需要更多可定制的服务或数据，我建议阅读我之前提到的文档参考。
- en: Wrapping it up
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: These techniques make your code more maintainable and scalable, and also less
    dependent on further changes. Since you only have to reference the required services,
    a change in the implementation of one doesn't necessarily mean a change in the
    high-level classes that use those services.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术使你的代码更易于维护和扩展，并且也减少了对外部变化的依赖。由于你只需要引用所需的服务，一个服务的实现变化并不一定意味着使用这些服务的高级类也会发生变化。
- en: Of course, there is much more in DI in Angular 4 than the basic information
    included in this chapter. By now I hope you have a better understanding of how
    DI is present in these frameworks, and why it is becoming universally popular
    implementation design pattern.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Angular 4中的依赖注入（DI）远不止本章所包含的基本信息。到现在为止，我希望你已经更好地理解了DI在这些框架中的存在方式，以及为什么它正成为普遍流行的实现设计模式。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered DI in other frameworks, with a special focus
    on Angular in its two current branches.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了其他框架中的DI，特别关注了Angular的两个当前分支。
- en: First, we've seen the very basics of TypeScript on which Angular 2+ is based
    and how its capabilities for class definitions and module loading allow the construction
    of JavaScript-based applications with a more object-oriented, modular approach.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们了解了TypeScript的基础知识，它是Angular 2+的基础，以及它的类定义和模块加载能力如何允许以更面向对象、模块化的方式构建基于JavaScript的应用程序。
- en: Next, we went through the implementation of DI inside AngularJS (the legacy
    branch of Angular), still in use in more than 70 percent of Angular projects worldwide.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们探讨了AngularJS（Angular的遗留分支）内部的DI实现，该实现仍在全球超过70%的Angular项目中使用。
- en: Finally, we explored the basics of Angular 4 (the latest version available at
    thetime of writing this), and how the aforementioned object orientation and its
    component architecture (based on annotations) allow the implementation of Dependency
    Injection in a very easy way.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了Angular 4（撰写本文时的最新版本）的基础知识，以及上述面向对象及其基于注解的组件架构如何使得依赖注入的实现变得非常简单。
- en: In [Chapter 11](a437ff1b-c4af-41ac-b502-8718dc132272.xhtml), *Best Practices
    and Other Related Techniques*, we'll cover some of the most common best practices
    in DI and other related techniques.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](a437ff1b-c4af-41ac-b502-8718dc132272.xhtml)，“最佳实践与其他相关技术”，我们将介绍DI和其他相关技术中最常见的最佳实践。
