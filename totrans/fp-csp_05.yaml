- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Error Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Welcome to [*Chapter 5*](B21069_05.xhtml#_idTextAnchor221)! You are doing great!
    In this chapter, we will discuss a new approach provided by functional programming
    to handle errors. We will do so through the help of the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到[*第五章*](B21069_05.xhtml#_idTextAnchor221)！您做得很好！在本章中，我们将讨论函数式编程提供的新方法来处理错误。我们将通过以下部分来实现这一点：
- en: Traditional error handling in C#
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#中的传统错误处理
- en: The Result type
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果类型
- en: Railway-Oriented Programming (ROP)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向铁路编程（ROP）
- en: Designing your own error-handling mechanisms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计自己的错误处理机制
- en: Practical tips for functional error handling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性错误处理的实用技巧
- en: Traditional versus functional error handling comparison
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统与函数式错误处理比较
- en: Patterns and anti-patterns in functional error handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能性错误处理中的模式和反模式
- en: Steve is really upset today because he spent the last three days fixing errors
    and didn’t have time to write even a single line of new code. Moreover, benchmark
    tests showed that the code with try-catch blocks works much slower than the one
    without them and that there are a lot of these blocks in his code. So he decided
    to ask Julia whether there was a way to handle errors better with a functional
    approach. She sent Steve a big article about error handling using functional programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫今天真的很沮丧，因为他花了过去三天的时间修复错误，以至于没有时间写哪怕一行新的代码。此外，基准测试显示，带有try-catch块的代码比没有它们的代码运行速度慢得多，而且他的代码中有很多这样的块。因此，他决定问茱莉亚是否有更好的方法来使用函数式方法处理错误。她给史蒂夫发了一篇关于使用函数式编程进行错误处理的详细文章。
- en: As you can see, this chapter delves into the functional techniques, which will
    help you not just handle errors but do so in a manner that’s clean, efficient,
    and maintainable. And before we dig in, let’s look at these three self-assessment
    tasks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，本章深入探讨了函数式技术，这将帮助您不仅处理错误，而且以干净、高效和可维护的方式进行错误处理。在我们深入探讨之前，让我们看看这三个自我评估任务。
- en: Task 1 – Custom error types and result usage
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务1 – 自定义错误类型和结果使用
- en: 'Here’s a function in Steve’s tower defense game that upgrades a tower and returns
    a boolean. Refactor it to return a `Result` type instead, with a custom error
    when the upgrade fails:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是史蒂夫的塔防游戏中一个升级塔并返回布尔值的函数。将其重构为返回`Result`类型，当升级失败时返回自定义错误：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Utilizing ROP for validation and processing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务2 – 利用ROP进行验证和处理
- en: 'Steve has a workflow that involves parsing, validating, and processing an enemy
    spawn. Refactor it using **Railway-Oriented Programming** (**ROP**) to improve
    the error-handling flow:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫有一个涉及解析、验证和处理敌人生成的流程。使用**面向铁路编程**（**ROP**）重构它以改进错误处理流程：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Implementing a Retry mechanism using functional techniques
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务3 – 使用函数式技术实现重试机制
- en: 'Write a function that implements a retry mechanism for a flaky tower firing
    operation and returns a `Result` type. The function should retry the operation
    a specified number of times before returning an error:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，实现一个用于故障塔射击操作的重试机制，并返回`Result`类型。该函数应在返回错误之前重试操作指定次数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If these tasks are easy for you, you are free to skip this chapter for now and
    return later when you have read all the others or have any questions about error
    handling.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些任务对您来说很容易，您现在可以自由地跳过这一章，稍后再回来，当您阅读了所有其他章节或对错误处理有任何疑问时。
- en: Traditional error handling in C#
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的传统错误处理
- en: Every C# developer, whether a novice or an expert, has come across the try-catch
    block. It’s been the main protection against unexpected behaviors and system failures.
    Let’s revisit this conventional mechanism before understanding what the functional
    paradigm offers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C#开发者，无论是新手还是专家，都遇到过try-catch块。它一直是防止意外行为和系统故障的主要保护措施。在我们了解函数式范式提供的内容之前，让我们回顾一下这种传统机制。
- en: try-catch blocks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try-catch块
- en: 'The try-catch block attempts an operation, and if it fails, the control is
    transferred to the catch block, ensuring the application doesn’t crash. For instance,
    let’s say we’re working with a simple file-reading operation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: try-catch块尝试执行操作，如果失败，控制权将转移到catch块，确保应用程序不会崩溃。例如，假设我们正在进行一个简单的文件读取操作：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we log different messages depending on the type of the raised exception.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据抛出的异常类型记录不同的消息。
- en: Exceptions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'C# offers two primary categories of exception types:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了两种主要的异常类型类别：
- en: '`NullReferenceException`, `IndexOutOfRangeException`, or the ones we just encountered:
    `FileNot` **FoundException** and `IOException`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullReferenceException`、`IndexOutOfRangeException`，或者我们刚刚遇到的：`FileNotFoundException`和`IOException`。'
- en: '**Application exceptions**: These are custom exceptions created for specific
    application needs. Let’s say you’re developing an e-commerce platform, and you
    need an exception for an out-of-stock item. Here’s how you might design it:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序异常**：这些是为特定应用程序需求创建的自定义异常。比如说，你正在开发一个电子商务平台，你需要一个库存不足的异常。下面是如何设计它的示例：'
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Later, check the item’s stock:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，检查项目的库存：
- en: '[PRE5]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Custom exceptions empower developers to communicate specific error scenarios,
    ensuring that error handling is informative.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义异常使开发者能够传达特定的错误场景，确保错误处理具有信息性。
- en: Steve slumped in his chair, frustration etched on his face. He’d spent the last
    three days battling bugs in his tower defense game, and the codebase was becoming
    a maze of try-catch blocks. Just then, his phone buzzed. It was a message from
    Julia.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫坐在椅子上，脸上写满了挫败感。他花了过去三天的时间在与他的塔防游戏中的虫子作斗争，代码库正变成一个try-catch块的迷宫。就在这时，他的手机响了。是朱莉娅发来的消息。
- en: 'Julia: *How’s the game* *coming along?*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*游戏进展得怎么样了？*
- en: 'Steve: *Not great. I’m drowning in error handling. Got any functional programming
    wisdom* *for me?*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*不太好。我在错误处理中感到窒息。你有什么功能编程的智慧可以分享吗？*
- en: 'Julia: *As a matter of fact, I do. Let me tell you about a more elegant way
    to* *handle errors...*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*事实上，我确实如此。让我告诉你一种更优雅的错误处理方式...*
- en: The Result type
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果类型
- en: Instead of dealing with exceptions after they occur, what if we designed our
    code to anticipate and elegantly communicate errors? Please welcome the `Result`
    type, a cornerstone of functional error handling.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与在异常发生后处理异常相比，如果我们设计代码来预测并优雅地传达错误会怎样？请欢迎`Result`类型，这是功能错误处理的基石。
- en: 'At its core, the `Result` type encapsulates either a successful value or an
    error. It might sound similar to exceptions, but there’s a key difference: errors
    become first-class citizens, directly influencing your application’s flow.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`Result`类型封装了成功值或错误。这听起来可能和异常相似，但有一个关键的区别：错误成为了一等公民，直接影响应用程序的流程。
- en: In contrast to the `Option` type that can only distinguish existing values from
    non-existing, the `Result` type describes the error that happened and, more importantly,
    can be used to chain methods application. We will discuss that technique later
    in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与只能区分现有值和非现有值的`Option`类型相比，`Result`类型描述了发生的错误，更重要的是，它可以用于链式方法应用。我们将在本章后面讨论这项技术。
- en: 'For instance, traditionally, a method might return a value or throw an exception:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，传统上，一个方法可能会返回一个值或抛出一个异常：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In contrast, with the `Result` type, the method communicates both its intention
    and possible failure more explicitly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，使用`Result`类型，方法更明确地传达了其意图和可能的失败：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code is more explicit. No hidden exceptions. No unexpected behaviors. Just
    clear, honest communication.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更明确。没有隐藏的异常。没有意外的行为。只有清晰、坦诚的沟通。
- en: Implementing the Result type
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现结果类型
- en: 'Let’s dive a bit deeper and see what a general implementation of the `Result`
    type looks like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入，看看`Result`类型的通用实现是什么样的：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the Result type
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Result`类型
- en: 'Usage of the `Result` type leads to a more systematic approach to error handling:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Result`类型导致了一种更系统化的错误处理方法：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: No more scattered try-catch blocks. Now errors become just another path your
    code can take, leading to more predictable and maintainable systems.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的分散的try-catch块。现在错误只是代码可以采取的另一种路径，导致更可预测和可维护的系统。
- en: 'The `Result` type fundamentally shifts how we view errors: not as sudden interruptions,
    but as anticipated outcomes. As we go further, you’ll see how this functional
    tool integrates with other advanced techniques, creating a new approach to error
    management.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类型从根本上改变了我们看待错误的方式：不是作为突然的中断，而是作为预期的结果。随着我们进一步探讨，你将看到这个功能工具如何与其他高级技术集成，从而创造一种新的错误管理方法。'
- en: Railway-Oriented Programming (ROP)
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向铁路编程（ROP）
- en: Steve was intrigued by the Result type, but he still had questions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫对`Result`类型很感兴趣，但他仍然有疑问。
- en: 'Steve: *This is great for individual operations, but what about when I have
    a series of steps that all need* *to succeed?*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫：*这对单个操作来说很棒，但当我有一系列步骤都需要* *成功时怎么办呢？*
- en: 'Julia: *I’m glad you asked. Let me introduce you to* *Railway-Oriented Programming.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 朱莉娅：*我很高兴你问了。让我向你介绍* *面向铁路编程（Railway-Oriented Programming）*。
- en: At the heart of functional programming is the drive for predictability and clarity.
    Although traditional error-handling techniques are powerful, they often scatter
    the error-handling logic across the codebase. ROP, inspired by this railway track-switching
    analogy, offers a cohesive, structured approach to error handling, keeping your
    code both expressive and streamlined.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的核心是追求可预测性和清晰性。尽管传统的错误处理技术很强大，但它们通常会将错误处理逻辑分散在代码库中。受铁路道岔切换比喻的启发，ROP 提供了一种连贯、结构化的错误处理方法，使代码既具有表现力又简洁。
- en: 'ROP provides a systematic way to manage errors in a sequence of operations.
    Think of it as managing two parallel tracks: the success track (happy path) and
    the error track. Operations run sequentially on the happy path. However, as soon
    as an error is encountered, the flow is diverted to the error track, bypassing
    subsequent operations.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 提供了一种管理一系列操作中错误的方法。将其视为管理两条并行轨道：成功轨道（快乐路径）和错误轨道。操作在快乐路径上顺序运行。然而，一旦遇到错误，流程就会转移到错误轨道，跳过后续操作。
- en: The essence of Bind
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bind 的本质
- en: 'Central to ROP is the Bind function. It takes an operation and a subsequent
    operation to execute if the first one succeeds. However, if an error occurs, it
    bypasses the second operation, and the error is immediately propagated:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 的核心是 Bind 函数。它接受一个操作和一个后续操作，如果第一个操作成功，则执行后续操作。然而，如果发生错误，它将跳过第二个操作，并立即传播错误：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Chaining operations with Bind
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bind 连接操作
- en: 'Imagine a series of steps where we do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一系列步骤，我们做以下操作：
- en: Parse input
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析输入
- en: Validate parsed data
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证解析后的数据
- en: Transform validated data
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换验证后的数据
- en: Store transformed data
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储转换后的数据
- en: 'ROP lets us express these steps as a cohesive chain:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 允许我们将这些步骤表达为一个连贯的链：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Composable error handling with ROP
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ROP 组合错误处理
- en: A strength of ROP is that it fosters composable error handling. Each component
    of your application can define its own error scenarios, and when these components
    are chained together, the combined operation can handle a broader spectrum of
    errors without losing granularity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 的一个优势是它促进了可组合的错误处理。你的应用程序的每个组件都可以定义自己的错误场景，当这些组件连接在一起时，组合操作可以处理更广泛的错误范围，而不会失去粒度。
- en: Consider having separate components for user input, business logic, and database
    operations. Each component can have its own error definitions. When operations
    from these components are chained together, the system can seamlessly handle errors
    from any component, creating a unified error-handling strategy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为用户输入、业务逻辑和数据库操作分别创建独立的组件。每个组件可以有自己的错误定义。当这些组件的操作连接在一起时，系统可以无缝地处理来自任何组件的错误，从而创建一个统一的错误处理策略。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `CompositeError` might encapsulate errors from input validation, business
    logic violations, and database failures.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CompositeError` 可能会封装来自输入验证、业务逻辑违规和数据库故障的错误。
- en: Handling diverse error types
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多种错误类型
- en: 'One challenge with a straightforward ROP implementation is that it assumes
    a unified error type throughout the chain. However, real-world scenarios often
    involve diverse error types. To manage this, you can introduce a mechanism to
    convert or map error types:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 直接的 ROP 实现的一个挑战是它假设整个链中有一个统一的错误类型。然而，现实场景往往涉及多种错误类型。为了管理这一点，你可以引入一种机制来转换或映射错误类型：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This enhanced `Bind` function maps one error type to another, enabling more
    complex and varied error-handling scenarios.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此增强的 `Bind` 函数将一种错误类型映射到另一种类型，从而实现更复杂和多样化的错误处理场景。
- en: Benefits of isolation
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离的优势
- en: ROP isolates error handling, ensuring that your main business logic remains
    uncluttered. When reading through the core operations, one can focus purely on
    the main logic without being distracted by error-handling intricacies.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 隔离了错误处理，确保你的主要业务逻辑保持整洁。在阅读核心操作时，可以专注于主要逻辑，而不会被错误处理的复杂性所分散。
- en: For developers, this isolation simplifies cognitive load. They can trust the
    system to handle errors and focus on crafting the primary logic. When debugging,
    the structured nature of ROP makes it crystal clear where things might have gone
    off the rails, thus, simplifying the troubleshooting process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，这种隔离简化了认知负荷。他们可以信任系统处理错误，并专注于构建主要逻辑。在调试时，ROP 的结构化特性使得问题可能偏离轨道的地方一目了然，从而简化了故障排除过程。
- en: Extending ROP for asynchronous operations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展 ROP 以支持异步操作
- en: 'In modern applications, a lot of methods are asynchronous. ROP can be adapted
    to asynchronous operations using techniques such as `BindAsync`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代应用程序中，许多方法都是异步的。可以使用 `BindAsync` 等技术将ROP适应异步操作：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With `BindAsync`, you can now chain asynchronous operations just as easily,
    making ROP versatile in both synchronous and asynchronous contexts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `BindAsync`，你现在可以像同步操作一样轻松地链式调用异步操作，使ROP在同步和异步环境中都变得灵活。
- en: Having delved deep into ROP, we witness a paradigm shift in how we perceive
    and handle errors. Instead of treating errors as exceptional events, ROP integrates
    them into the very logic of our application, resulting in more robust, readable,
    and maintainable code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 深入研究ROP后，我们见证了我们在感知和处理错误方面的范式转变。我们不再将错误视为异常事件，而是将它们整合到我们应用程序的逻辑中，从而产生更健壮、可读性和可维护的代码。
- en: Designing your own error-handling mechanisms
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计你自己的错误处理机制
- en: As Steve began refactoring his code, he realized that the pre-built solutions
    didn’t quite fit all his game’s unique scenarios.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当Steve开始重构他的代码时，他意识到预构建的解决方案并不完全适合他游戏的所有独特场景。
- en: 'Steve: *Julia, I think I need to create some custom error types for my game.
    Is* *that okay?*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'Steve: *Julia，我认为我需要为我的游戏创建一些自定义的错误类型。这样可以吗？*'
- en: 'Julia: *More than okay. In fact, let’s talk about how you can design your own
    error-handling mechanisms tailored to your* *game’s needs.*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'Julia: *非常好。事实上，让我们谈谈你如何设计适合你* *游戏需求* *的自定义错误处理机制。*'
- en: 'When creating your own functional error handling, a `Result` type is a prime
    starting point. Let it be generic enough to cater to different scenarios:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自己的功能性错误处理时，`Result` 类型是一个很好的起点。让它足够通用，以适应不同的场景：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use factory methods for creation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂方法进行创建
- en: 'Factory methods provide clarity and ease of use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法提供清晰性和易用性：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The usage is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Extend with Bind
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Bind扩展
- en: 'Use the `Bind` method to add more fluency:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Bind` 方法来增加流畅性：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Customize error types
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义错误类型
- en: 'Rather than just using strings, create specific error types to convey detailed
    information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅使用字符串，创建特定的错误类型来传达详细的信息：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, use them as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按如下方式使用它们：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Leverage extension methods
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用扩展方法
- en: 'Extension methods can offer enhanced readability:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法可以提供增强的可读性：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use them as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式使用它们：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Integration with existing code
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与现有代码集成
- en: 'By wrapping legacy methods, we can seamlessly integrate with non-functional
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过封装旧方法，我们可以无缝地与非功能性代码集成：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Always iterate and refine
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总是迭代和改进
- en: Custom error mechanisms are living entities. As your application grows, keep
    iterating and refining based on feedback and new requirements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义错误机制是活生生的实体。随着你的应用程序增长，根据反馈和新要求不断迭代和改进。
- en: Designing your own error-handling mechanisms not only empowers you with tailor-fit
    solutions but also deepens your understanding of the functional paradigm. Dive
    in, get hands-on, and watch as your applications become models of robustness and
    clarity.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 设计你自己的错误处理机制不仅赋予你量身定制的解决方案，而且加深了你对于函数式范式的理解。深入其中，动手实践，看看你的应用程序如何成为健壮性和清晰性的典范。
- en: Practical tips for functional error handling
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性错误处理的实用技巧
- en: A week into refactoring, Steve was making progress, but he felt overwhelmed
    by all the new concepts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 改进了一周后，Steve取得了一些进展，但他感到所有这些新概念让他感到不知所措。
- en: 'Steve: *I’m not sure I’m doing* *this right…*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Steve: *我不确定我是否* *做对了…*'
- en: 'Julia: *Don’t worry, it’s normal to feel that way when learning a new paradigm.
    Let me share some practical tips that’ll help you navigate this* *new territory.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'Julia: *别担心，在学习新的范式时感到这样很正常。让我分享一些实用的技巧，帮助你在这个* *新领域* *中导航。*'
- en: Avoid null with options
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选项避免null
- en: 'Try to never return null. It sounds simple, yet it’s a pitfall waiting to trip
    up the unwary. Why? Because nulls are very easy to get, however, it is much harder
    to handle them properly and if you don’t do it well, it can lead to cascading
    failures:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 努力不要返回null。听起来很简单，然而这是一个等待绊倒粗心大意的用户的陷阱。为什么？因为null很容易获得，然而，正确处理它们要困难得多，如果你做得不好，可能会导致级联失败：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Turn this around:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 转换如下：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Logging errors
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录错误
- en: 'Logging is vital, but try to avoid side effects that ruin the functional approach.
    A good idea here is to delegate the act of logging, keeping functions pure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是至关重要的，但尽量避免破坏功能性方法的副作用。一个好的想法是将记录行为委托出去，保持函数的纯洁性：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Two strategies To replace exceptions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 两种替换异常的策略
- en: I know that in some cases your first instinct might be to use a try-catch. Resist.
    Use these strategies to stick to the functional paradigm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道在某些情况下，你的第一反应可能是使用try-catch。抵制。使用这些策略来坚持函数式范式。
- en: Safe execution
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全执行
- en: 'Create a method that will execute any code in an exception-free way:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以无异常方式执行任何代码的方法：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The usage is as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Fallback
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回退
- en: 'For some operations, you can provide a fallback result:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些操作，你可以提供一个回退结果：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Anticipate errors – make it predictable
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预测错误 - 使其可预测
- en: 'Instead of waiting for errors, anticipate them. Validate your data before using
    it in processing. You can do it manually or with the help of guard clauses:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是等待错误，预测它们。在使用之前验证你的数据。你可以手动完成或借助守卫子句：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Embrace composition
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拥抱组合
- en: 'Use function composition for cleaner error handling:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数组合进行更清晰的错误处理：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Educate your team
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 教育你的团队
- en: Lastly, ensure everyone’s on board. A consistent approach to error handling
    ensures clarity and reliability.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保每个人都同意。一致的错误处理方法确保了清晰性和可靠性。
- en: Traditional versus functional error handling comparison
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统与函数式错误处理比较
- en: 'Every developer experiences it sooner or later: running into an error while
    coding. But as the coding world has changed, so has the way we deal with these
    problems. Let’s look at the clear differences between the old and new ways of
    handling errors in C# and understand why this new approach is becoming more popular.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者迟早都会遇到：编码时遇到错误。但随着编码世界的改变，我们处理这些问题的方法也在改变。让我们看看C#中处理错误的老旧和新旧方法之间的明显差异，并了解为什么这种新方法越来越受欢迎。
- en: The traditional way
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统方式
- en: 'In traditional OOP, exceptions are the go-to mechanism:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的面向对象编程中，异常是首选机制：
- en: '**Throwing exceptions**: We rely on system or custom exceptions when things
    go wrong:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出异常**：当事情出错时，我们依赖于系统或自定义异常：'
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Catching exceptions**: Use try-catch blocks to handle and possibly recover
    from errors:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获异常**：使用try-catch块来处理和可能恢复错误：'
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The benefits of the traditional way are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 传统方式的优点如下：
- en: Most developers are accustomed to using exceptions, making it a well-understood
    approach
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数开发者习惯于使用异常，使其成为一个被广泛理解的方法
- en: Fine-grained error handling is possible with different exception types
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用不同的异常类型进行细粒度错误处理
- en: 'However, there are also some drawbacks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些缺点：
- en: Exceptions can disrupt the natural flow of code execution
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常可能会打断代码执行的正常流程
- en: Exception handling introduces a performance overhead
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理引入了性能开销
- en: It can be hard to reason about and can lead to “exception hell”
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能很难推理，可能导致“异常地狱”
- en: The functional way
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式方式
- en: 'Functional programming prefers a more graceful form of error handling:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程更喜欢一种更优雅的错误处理形式：
- en: '**Use constructs such as** **Result types**:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用如下结构**：**结果类型**'
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Consuming the preceding function becomes straightforward:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 消费前面的函数变得简单：
- en: '[PRE35]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**ROP**:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROP**：'
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The benefits of the functional way are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式方式的优点如下：
- en: Clearer intent and flow
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更清晰的意图和流程
- en: Avoids the exception performance overhead
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免异常性能开销
- en: Easier chaining of operations
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易的操作链
- en: 'There are also a couple of drawbacks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样也有一些缺点：
- en: Developers may be required to learn new concepts
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发者可能需要学习新的概念
- en: Less granularity compared to traditional exceptions
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与传统异常相比，粒度更少
- en: Comparative analysis
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较分析
- en: 'Let’s take a closer look at the differences between traditional exception handling
    and functional programming when it comes to performance, readability, and maintainability:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看在性能、可读性和可维护性方面，传统异常处理与函数式编程之间的差异：
- en: '**Performance**: Traditional exception handling can be slower due to the overhead
    of creating exception objects and unwinding the stack. FP offers a more predictable
    performance profile.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：由于创建异常对象和回滚堆栈的开销，传统的异常处理可能会较慢。函数式编程提供了一个更可预测的性能配置文件。'
- en: '**Readability**: try-catch blocks can clutter code, making it less readable.
    Often these blocks contain also code that cannot throw exceptions. FP encapsulates
    errors within data, making code flow apparent.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：try-catch块可能会使代码杂乱无章，使其可读性降低。通常这些块还包含无法抛出异常的代码。函数式编程将错误封装在数据中，使代码流程明显。'
- en: '**Maintainability**: Traditional methods spread error handling, making maintenance
    complex. FP encourages isolated, pure functions, which simplifies debugging and
    testing.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：传统方法分散错误处理，使维护变得复杂。函数式编程鼓励隔离的、纯函数，这简化了调试和测试。'
- en: Making the shift
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转变
- en: 'Starting with FP error handling might seem odd, especially if you’ve lived
    all your life in the traditional paradigm. But once you make the switch, the benefits
    are profound. Remember:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数式错误处理开始可能看起来很奇怪，尤其是如果你一直生活在传统范式下。但一旦你做出改变，好处是深远的。记住：
- en: Start small. Refactor a section of your codebase and observe the difference.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从小开始。重构你的代码库的一部分，并观察差异。
- en: Embrace pure functions. They’ll simplify your error-handling story.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥抱纯函数。它们将简化你的错误处理故事。
- en: Educate your team. A shared understanding is pivotal.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育你的团队。共同的理解至关重要。
- en: In conclusion, while traditional error handling has served us well for years,
    the functional paradigm offers a fresher, more systematic approach. By representing
    errors as first-class citizens within our data types, we write more maintainable
    code. The choice between the two often boils down to the problem domain, team
    familiarity, and project requirements. But if you want clarity and expressiveness,
    the functional route is the way.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，虽然传统的错误处理多年来一直为我们服务得很好，但函数式范式提供了一种更清新、更系统的方法。通过在我们的数据类型中将错误表示为一等公民，我们编写了更易于维护的代码。两者之间的选择通常取决于问题域、团队熟悉度和项目需求。但如果你想要清晰和表述性，函数式路径是正确的。
- en: Patterns and anti-patterns in functional error handling
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式错误处理中的模式和反模式
- en: Functional programming has redefined our approach to error handling. By bringing
    errors into the realm of data, we ensure safer, more predictable code. But as
    with any paradigm, there are right ways and pitfalls. Let’s look at the patterns
    that can help you and also the anti-patterns.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程重新定义了我们对错误处理的方法。通过将错误引入数据领域，我们确保了更安全、更可预测的代码。但与任何范式一样，有正确的方法和陷阱。让我们看看可以帮助你的模式以及反模式。
- en: 'There are several patterns that can help you handle errors in a more functional
    way. These patterns are designed to enhance the quality, readability, and maintainability
    of your code. Here are some of the key patterns to consider:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种模式可以帮助你以更函数式的方式处理错误。这些模式旨在提高代码的质量、可读性和可维护性。以下是一些需要考虑的关键模式：
- en: '**Rich custom** **error types**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**丰富的自定义** **错误类型**'
- en: 'Instead of generic strings or codes, use detailed types to describe errors:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是使用通用的字符串或代码，使用详细的数据类型来描述错误：
- en: '[PRE37]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Leveraging composition**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用组合**'
- en: 'Chain multiple functions seamlessly to maintain clear logic flow:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无缝地链式调用多个函数以保持清晰的逻辑流程：
- en: '[PRE38]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**Pattern matching** **with errors**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式匹配** **与错误**'
- en: 'This ensures every error scenario is addressed:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了每个错误场景都得到了处理：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Isolating** **side effects**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离** **副作用**'
- en: 'Keep your core logic pure and handle side effects, such as logging or I/O,
    separately:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保持你的核心逻辑纯净，并单独处理副作用，如日志记录或I/O：
- en: '[PRE40]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The usage is as follows:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE41]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are also some anti-patterns that can make your error handling more complex
    and error-prone:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 同时也有一些反模式可能会使你的错误处理更加复杂和容易出错：
- en: '`Result` types can confuse other software developers:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Result` 类型可能会让其他软件开发者感到困惑：'
- en: '[PRE42]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Unclear errors**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不明确的错误**'
- en: 'Returning vague errors eliminates the value of FP’s expressive error handling:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回模糊的错误消除了函数式编程的表述性错误处理的价值：
- en: '[PRE43]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '**Ignoring errors**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略错误**'
- en: 'Just getting the value without addressing potential failures breaks the idea
    of FP error handling. An example is when you have a Result type as a method output,
    but don’t check it:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只获取值而不处理潜在的错误破坏了函数式编程错误处理的概念。一个例子是当你有一个Result类型作为方法输出，但没有检查它：
- en: '[PRE44]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Overcomplicating with** **custom types**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自定义类型** **过度复杂化**'
- en: 'While detailed error types are beneficial, creating one for every minor deviation
    can overcomplicate things. Please don’t do errors like these:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然详细的错误类型是有益的，但为每个微小的偏差创建一个可能会使事情过于复杂。请不要这样做错误：
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Exercises
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Steve was eager to apply his newfound knowledge of functional error handling
    to his tower defense game. Julia, impressed by his enthusiasm, presented him with
    three challenges to test his understanding and improve his code.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫渴望将他对函数式错误处理的新知识应用到他的塔防游戏中。朱莉娅对他的热情印象深刻，向他提出了三个挑战来测试他的理解并改进他的代码。
- en: Exercise 1
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Here’s the function that upgrades a tower and returns a boolean. Refactor it
    to return a `Result` type instead, with a custom error when the payment fails:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是升级塔并返回布尔值的函数。将其重构为返回一个`Result`类型，当支付失败时返回自定义错误：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Exercise 2
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Steve has a workflow that involves parsing, validating, and processing an enemy
    spawn. Refactor it using Railway-Oriented Programming to improve the error-handling
    flow:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫有一个涉及解析、验证和处理敌人生成的流程。使用面向铁路编程重构它，以改进错误处理流程：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exercise 3
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'Write a function that implements a retry mechanism for a flaky operation and
    returns a `Result` type. The function should retry the operation a specified number
    of times before returning an error:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，实现一个用于故障操作的重试机制，并返回一个`Result`类型。该函数应在返回错误之前重试操作指定次数：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Try to do these exercises yourself, and when finished, you can check your work
    with the following solutions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己完成这些练习，完成后，你可以用以下解决方案来检查你的工作。
- en: Solutions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Exercise 1
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Refactor the method to use a `Result` type with a custom error that encapsulates
    failure details:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法重构为使用带有自定义错误的`Result`类型，封装失败详情：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Exercise 2
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: 'Steve refactored his enemy spawning system using ROP, creating a clean pipeline
    for processing enemy data:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫使用面向铁路编程重构了他的敌人生成系统，创建了一个处理敌人数据的清晰管道：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Exercise 3
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: 'For the flaky tower firing mechanism, Steve implemented a retry function that
    attempts the operation multiple times before giving up:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障的塔发射机制，史蒂夫实现了一个重试函数，在放弃之前尝试多次操作：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These exercises take you from understanding to applying functional principles
    in practical coding scenarios. They encourage you to think and code functionally,
    recognizing error handling not as an afterthought but as an integral part of the
    coding process.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将带你从理解到在实际编码场景中应用函数式原则。它们鼓励你以函数式的方式思考和编码，将错误处理视为编码过程的一个组成部分，而不是事后考虑：
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we progressed from traditional methods of error handling to
    functional approaches. We identified the strengths, challenges, patterns, and
    anti-patterns of the FP way.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从传统的错误处理方法进步到函数式方法。我们确定了函数式编程的优势、挑战、模式和反模式。
- en: Functional programming offers not just a way to code, but a mindset shift. By
    treating errors as data, we benefit from type safety, expressiveness, and predictability.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程不仅提供了一种编码方式，而且是一种思维方式的转变。通过将错误视为数据，我们受益于类型安全、表达性和可预测性。
- en: However, our goal is not to get rid of all exceptions and nulls but to create
    more readable and resilient software. Luckily, with the development of C#, functional
    error handling is becoming easier and more integrated.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的目标不是消除所有异常和空值，而是创建更易于阅读和健壮的软件。幸运的是，随着C#的发展，函数式错误处理正变得更容易和更集成。
- en: Like all paradigms, functional programming is not a silver bullet. While errors
    as data can be powerful, you have to remember the real world where your code runs.
    Networking failures, database outages, and hardware malfunctions are realities.
    Striking a balance between functional purity and real-world pragmatism is key.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有范式一样，函数式编程不是万能的。虽然将错误视为数据可能很强大，但你必须记住代码运行的实际情况。网络故障、数据库中断和硬件故障是现实。在函数式纯度和现实世界实用主义之间取得平衡是关键。
- en: A couple of times in this chapter, we used delegates, and in order to get a
    better understanding of them and their role in functional programming, in the
    next chapter we will delve into the concepts of higher-order functions and delegates.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们几次使用了委托，为了更好地理解它们以及在函数式编程中的作用，在下一章中我们将深入探讨高阶函数和委托的概念。
