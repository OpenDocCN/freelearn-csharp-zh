<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer089">
<h1 class="chapter-number" id="_idParaDest-203"><a id="_idTextAnchor223"/>13</h1>
<h1 id="_idParaDest-204"><a id="_idTextAnchor224"/>Unit Testing</h1>
<p>Let’s dive into something critical: <strong class="bold">unit testing</strong>. Think of it as your safety net. It’s not just about knowing your app runs smoothly now, but ensuring that after every tweak, update, or overhaul, your app keeps on ticking without hiccups or unexpected surprises. Regression bugs? We’re looking at you! With MVVM and the right testing practices, we can effectively guard against these <span class="No-Break">potential issues.</span></p>
<p>In this chapter, we’re going to tackle <span class="No-Break">the following:</span></p>
<ul>
<li>The importance of <span class="No-Break">unit testing</span></li>
<li>Setting up a unit <span class="No-Break">test project</span></li>
<li>Generating data <span class="No-Break">with Bogus</span></li>
<li>Mocking dependencies <span class="No-Break">with Moq</span></li>
<li>Testing <span class="No-Break">MAUI-specific code</span></li>
</ul>
<p>While we won’t be diving deep into the weeds (after all, the intricacies can vary widely depending on the tools you use), I’ll guide you using a set of tools I’m familiar with: <strong class="bold">xUnit</strong>, <strong class="bold">Bogus</strong>, <strong class="bold">AutoBogus</strong>, and <strong class="bold">Moq</strong>. These are my go-to building blocks, but let’s remember: the .NET ecosystem is vast and versatile. There are several other fantastic frameworks and libraries out there, such as <strong class="bold">NUnit</strong>, <strong class="bold">AutoFixture</strong>, <strong class="bold">NSubstitute</strong>, and more. The principles we cover will largely remain the same; it’s just a matter of which tools resonate with your workflow. At the end of the day, it’s all about <span class="No-Break">personal preference.</span></p>
<p>By the end of this chapter, you should be firmly convinced of the immense value unit tests offer. Additionally, you’ll have a clear view of how to effectively use tools and techniques for writing <span class="No-Break">unit tests.</span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor225"/>Technical requirements</h1>
<p>To ensure you’re in sync with the upcoming content, make your way to our GitHub repository: <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13</a>. Kick off with the materials in the <strong class="source-inline">Start</strong> folder. And remember – if you’re ever in need of a consolidated reference, the <strong class="source-inline">Finish</strong> folder holds the final, refined code at the <span class="No-Break">chapter’s close.</span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor226"/>The importance of unit testing</h1>
<p>A lesson I learned the hard way forever transformed my stance on software development: <em class="italic">never underestimate </em><span class="No-Break"><em class="italic">unit testing</em></span><span class="No-Break">.</span></p>
<p>Years ago, I was part of a <a id="_idIndexMarker872"/>dedicated team crafting an ambitious app. Our expertise in C# and the platform was undeniable. Yet, we overlooked unit tests, placing our faith in manual testing and our <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) team. The end product was highly recognized and praised, but the journey was a tumultuous one. Feedback from QA often revealed bugs, making each code adjustment <span class="No-Break">feel risky.</span></p>
<p>Nearing deadlines was synonymous with sleepless nights, hasty bug fixes, and a looming fear of regressions. Post-project, I collaborated with diverse developers and encountered a colleague profoundly <a id="_idIndexMarker873"/>devoted to <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>). It was a true eye-opener, not just for the essence of unit testing but also for the flaws in our previous <span class="No-Break">design choices.</span></p>
<p>My evolving journey underscored the <a id="_idIndexMarker874"/>real benefits of <span class="No-Break">unit tests:</span></p>
<ul>
<li><strong class="bold">Efficiency</strong>: No more long-lasting deployments before manual verifications. Unit tests swiftly validate my code, <span class="No-Break">streamlining development.</span></li>
<li><strong class="bold">Quality and confidence</strong>: With each test, the software’s quality rises, as does my confidence. It becomes a safety net, allowing explorative coding without the fear of <span class="No-Break">unintended consequences.</span></li>
<li><strong class="bold">Guarding against regressions</strong>: Unit tests ensure alterations don’t unintentionally break <span class="No-Break">existing features.</span></li>
</ul>
<p>With time, I’ve also observed that unit tests serve as an evolving documentation. New team members can determine the expected behavior and logic from these tests, facilitating quicker integration and more confident <span class="No-Break">code modifications.</span></p>
<p>My old teammates and I still meet up from time to time. We chat about the old days and our shared experiences. In our conversations, a shared realization stands out: after our time together, each of us matured in our individual projects. This often leads us to a mutual reflection: if we had embraced unit testing in that project we did years ago, our work lived might have been a lot smoother. Don’t get me wrong; our clients were happy with what we delivered. But for all of us, on a personal level, having tests from the get-go could have saved many stressful nights, health issues, <span class="No-Break">and uncertainties.</span></p>
<p>While unit testing enjoys acclaim in many developer circles, I still witness hesitancy, especially in parts of the .NET world. My advocacy isn’t about achieving a coverage metric or TDD fanaticism. It’s about recognizing unit tests for their benefits, from ensuring code reliability to uplifting <span class="No-Break">team morale.</span></p>
<p>Unit testing is not<a id="_idIndexMarker875"/> about achieving an abstract notion of perfection. It’s about having a safety net, allowing for code acrobatics without fearing a misstep. Do I write tests for every single line of code I have? In all honesty: no. Is all my code easy to test? Not always. But the tests I write really do help. They let me know quickly if things work, if I broke something, or if I fixed a bug the right way. And that gives me confidence in my work. When a bug is being reported, the first thing I do is write a failing test, exposing this bug. I can then go ahead and work on this bug, and as soon as the test passes, I know I’ve fixed it. And not only is the bug now fixed, but with the additional test (or tests), the code has become even more robust and protected against <span class="No-Break">future regressions.</span></p>
<p>As software continuously evolves in our fast-paced world, unit testing is not just best practice; it’s a lifeline. The peace of mind it offers is unparalleled, ensuring that the software not only functions but is robust against <span class="No-Break">inevitable change.</span></p>
<p>To those beginning their developer journey or reevaluating unit tests: don’t mimic my initial oversight. See tests not as a chore but as a <span class="No-Break">trusty companion.</span></p>
<p>Having said that, it’s time to pivot from the <em class="italic">why</em> to the <em class="italic">how</em>. For those still with me, let’s delve into the details: setting up unit tests for ViewModels. Believe me, it’s simpler than <span class="No-Break">it seems!</span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor227"/>Setting up a unit test project</h1>
<p>In this section, we will be <a id="_idIndexMarker876"/>walking through the steps of setting up a unit test project and creating a first test. We’ll be using xUnit in this section. We’re not going to get all tangled up in the tiny details of this specific library because there are tons of other awesome ones. No matter what you choose, the big takeaways should stick with you. So, without further ado, let’s dive in and start setting the stage for effective <span class="No-Break">ViewModel testing!</span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor228"/>Creating a unit test project</h2>
<p>Let’s start by creating an xUnit Test project. In xUnit, one of the things I appreciate is its simplicity. Test classes and <a id="_idIndexMarker877"/>methods are just normal classes and methods, without the need for special base classes or complex setups. <span class="No-Break">Here’s how:</span></p>
<ol>
<li>In the <strong class="bold">Solution Explorer</strong> in <strong class="bold">Visual Studio</strong>, right-click <strong class="bold">Solution ‘Recipes App’</strong> and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Project…</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Add a new project</strong> dialog, type <strong class="source-inline">xunit</strong> in the search box and select <strong class="bold">xUnit Test Project</strong> from the list (<span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="Figure 13.1: Creating a new xUnit test project" height="1150" src="image/B20941_13_01.jpg" width="1648"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1: Creating a new xUnit test project</p>
<ol>
<li value="3">Click the <strong class="bold">Next</strong> button and enter <strong class="source-inline">Recipes.Client.Core.UnitTests</strong> as the project name. <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
<li>When prompted, select <strong class="bold">.NET 8.0 (Long Term Support)</strong> from the <strong class="bold">Framework</strong> list and hit the <span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break"> button.</span></li>
<li>Once the project is generated, right-click on it, select <strong class="bold">Add</strong> | <strong class="bold">Project Reference…</strong>, and select the <strong class="source-inline">Recipes.Client.Core</strong> project from <span class="No-Break">the list.</span></li>
</ol>
<p>With the project and its reference to the <strong class="source-inline">Recipes.Client.Core</strong> project in place, we can start writing our unit tests. Let’s go ahead and write our <span class="No-Break">first one!</span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor229"/>Creating unit tests</h2>
<p>Let’s start by testing something<a id="_idIndexMarker878"/> pretty straightforward: testing the initialization of the <strong class="source-inline">RecipeListItemViewModel</strong>. <span class="No-Break">Here’s how:</span></p>
<ol>
<li>Delete the generated <span class="No-Break"><strong class="source-inline">UnitTest1.cs</strong></span><span class="No-Break"> file.</span></li>
<li>Add a new C# class called <strong class="source-inline">RecipeListItemViewModelTests</strong> to <span class="No-Break">the project.</span></li>
<li>Make the class public and add a public method called <strong class="source-inline">ViewModel_Initialized_PropertiesSetCorrectly</strong>, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
<strong class="bold">[Fact]</strong>
public void
  ViewModel_Initialized_PropertiesSetCorrectly()
{
}</pre><p class="list-inset">Note how the <strong class="source-inline">Fact</strong> attribute is added to this method. This attribute signals that this is a test method. Without it, the method won’t be identified as a test and therefore won’t be executed as one during <span class="No-Break">test runs.</span></p></li> <li>Add the following code to <span class="No-Break">this method:</span><pre class="source-code">
<strong class="bold">//Arrange</strong>
string id = "id1";
string title = "title1";
bool isFavorite = false;
string image = "image1";
<strong class="bold">//Act</strong>
var sut = new RecipeListItemViewModel(id, title,
    isFavorite, image);
<strong class="bold">//Assert</strong>
Assert.Equal(id, sut.Id);
Assert.Equal(title, sut.Title);
Assert.Equal(isFavorite, sut.IsFavorite);
Assert.Equal(image, sut.Image);</pre></li> </ol>
<p>This creates and validates a <strong class="source-inline">RecipeListItemViewModel</strong> instance. This code block first creates an instance of the <strong class="source-inline">RecipeListItemViewModel</strong> class using sample data. It then calls a <a id="_idIndexMarker879"/>series of assertions to confirm that the object’s properties were initialized <span class="No-Break">as expected.</span></p>
<p>In unit testing jargon, our instantiated <a id="_idIndexMarker880"/>object is named <strong class="source-inline">sut</strong>, which stands for <strong class="bold">system under test</strong>. This is a name commonly used in <span class="No-Break">unit tests.</span></p>
<p>Lastly, the role of the <strong class="source-inline">Assert</strong> statements, inherent to the xUnit framework, deserves special mention. <strong class="source-inline">Assert</strong> methods play a pivotal role in validating object states to ensure they meet our expectations. <strong class="source-inline">Assert.True</strong>, <strong class="source-inline">Assert.Empty</strong>, <strong class="source-inline">Assert.Contains</strong>, and many more are at our disposal. The <strong class="source-inline">Assert.Equal</strong> method, as shown in this example, evaluates if the expected value matches the object’s actual value. In this context, it ensures that properties of our <strong class="source-inline">sut</strong> object, such as <strong class="source-inline">Id</strong>, <strong class="source-inline">Title</strong>, <strong class="source-inline">IsFavorite</strong>, and <strong class="source-inline">Image</strong>, were initialized <span class="No-Break">as expected.</span></p>
<p>In the previous code snippet, you may notice the clear structure, which is guided by comments: <strong class="source-inline">//Arrange</strong>, <strong class="source-inline">//Act</strong>, and <strong class="source-inline">//Assert</strong>. This corresponds to a fundamental pattern in unit testing known as <strong class="bold">Arrange-Act-Assert</strong> (<strong class="bold">AAA</strong>). Let’s<a id="_idIndexMarker881"/> delve briefly into what each <span class="No-Break">stage signifies:</span></p>
<ul>
<li><strong class="source-inline">Arrange</strong>: This stage involves setting up any prerequisites for a test. We establish the conditions our test operates under. This might include initializing variables, creating mock objects, or setting up resources. In our example, this is where we define our sample data: <strong class="source-inline">id</strong>, <strong class="source-inline">title</strong>, <strong class="source-inline">isFavorite</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">image</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">Act</strong>: Here, we perform the action that we intend to test. This is where the <strong class="source-inline">sut</strong> object is invoked, and it’s typically a single action. In our context, it’s the instantiation of <strong class="source-inline">RecipeListItemViewModel</strong> with the sample data <span class="No-Break">we arranged.</span></li>
<li><strong class="source-inline">Assert</strong>: This final stage is where we verify if the test has passed or failed by checking the outcome against the expected results. In our example, this is done using the <strong class="source-inline">Assert.Equal</strong> method to ensure that our <strong class="source-inline">RecipeListItemViewModel</strong> object’s properties match the values we initialized <span class="No-Break">them with.</span></li>
</ul>
<p>Following the AAA pattern ensures that tests are organized and readable, making it easier for you, or anyone reviewing your code, to understand the purpose and behavior of <span class="No-Break">each test.</span></p>
<p>Go ahead and run the <a id="_idIndexMarker882"/>test! This can be done by right-clicking inside the test method you want to test and selecting <strong class="bold">Run Tests</strong>. Alternatively, you can choose <strong class="bold">Debug Tests</strong>, which runs your test and breaks on any breakpoints you have added, allowing you to step through the unit test. Test methods are also visible in the <strong class="bold">Test Explorer</strong> in <strong class="bold">Visual Studio</strong>. From there, you can easily run multiple tests. This pane also shows the current status of your tests: which ran successfully and which failed, alongside other relevant info, as shown in <span class="No-Break"><em class="italic">Figure 13</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt="Figure 13.2: Visual Studio’s Test Explorer" height="366" src="image/B20941_13_02.jpg" width="1242"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2: Visual Studio’s Test Explorer</p>
<p>Let’s add a couple more tests! Each instance of a <strong class="source-inline">RecipeListItemViewModel</strong> should listen for a <strong class="source-inline">FavoriteUpdateMessage</strong> and when such a message arrives, its <strong class="source-inline">IsFavorite</strong> property should be updated accordingly. So, let’s first write a test that validates that a newly instantiated <strong class="source-inline">RecipeListItemViewModel</strong> is registered as a recipient for a <strong class="source-inline">FavoriteUpdateMessage</strong> message. Secondly, in separate tests, we can check if the class reacts as expected to such <span class="No-Break">a message:</span></p>
<ol>
<li>Let’s start off by <a id="_idIndexMarker883"/>adding the following test to the <span class="No-Break"><strong class="source-inline">RecipeListItemViewModelTests</strong></span><span class="No-Break"> class:</span><pre class="source-code">
[Fact]
public void
  VM_Initialized_SubscribedToFavoriteUpdateMessage()
{
    //Arrange, Act
    var sut = new RecipeListItemViewModel(
        "id", "title", true, "image");
    //Assert
    Assert.True(WeakReferenceMessenger.Default
        .IsRegistered&lt;FavoriteUpdateMessage&gt;(sut));
}</pre><p class="list-inset">The <strong class="source-inline">WeakReferenceMessenger.Default.IsRegistered</strong> method allows us to check whether a particular object is registered for a particular message. We expect our <strong class="source-inline">sut</strong> to be registered for the <strong class="source-inline">FavoriteUpdateMessage</strong>, so we can call this method and validate the outcome to be true <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Assert.True</strong></span><span class="No-Break">.</span></p></li> <li>We should also validate that when a <strong class="source-inline">FavoriteUpdateMessage</strong> is received by the <strong class="source-inline">sut</strong>, the <strong class="source-inline">IsFavorite</strong> property is updated accordingly – only, of course, when the id sent by the message matches the id of the <strong class="source-inline">sut</strong>. Take <span class="No-Break">a look:</span><pre class="source-code">
[Fact]
public void
  FavoriteUpdateMsgReceived_SameId_FavoriteUpdated()
{
    //Arrange
    var id = "id";
    var originalValue = false;
    var updateToValue= !originalValue;
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
            id, updatedFavorite));
    //Assert
    Assert.Equal(updatedFavorite, sut.IsFavorite);
}</pre><p class="list-inset">The <strong class="source-inline">FavoriteUpdateMessage</strong> sends <a id="_idIndexMarker884"/>the inverse of the <strong class="source-inline">originalValue</strong> value that is used to instantiate the sut. After sending the message, which contains the same <strong class="source-inline">RecipeId</strong> as the sut, we can check whether the value of the <strong class="source-inline">IsFavorite</strong> property equals the value <span class="No-Break">we’ve sent.</span></p></li> <li>As a last test, we might want to validate that a <strong class="source-inline">RecipeListItemViewModel</strong> doesn’t react to a <strong class="source-inline">FavoriteMessage</strong> with a different <strong class="source-inline">RecipeId</strong>. This is very similar to our previous test, as you can <span class="No-Break">see here:</span><pre class="source-code">
[Fact]
public void FavoriteUpdateMsgReceived_DifferentId
  _FavoriteNotUpdated()
{
    //Arrange
    var originalValue = false;
    var updateToValue= !originalValue;
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
            "otherid", updatedFavorite));
    //Assert
    Assert.Equal(originalValue, sut.IsFavorite);
}</pre><p class="list-inset">Because the message sends a different <strong class="source-inline">RecipeId</strong> than the ID on the <strong class="source-inline">RecipeListItemViewModel</strong>, we want to validate that the <strong class="source-inline">IsFavorite</strong> property on the<a id="_idIndexMarker885"/> sut is still the same as the originally <span class="No-Break">set value.</span></p></li> </ol>
<p class="callout-heading">The “unit” in unit tests</p>
<p class="callout">When we talk <a id="_idIndexMarker886"/>about <em class="italic">unit tests</em>, that <em class="italic">unit</em> part is crucial. It’s all about keeping things small and focused. Take a peek at the tests we just created. The first one ensures the ViewModel is registered for incoming <strong class="source-inline">FavoriteUpdateMessage</strong>s, while the other one checks how the ViewModel responds to an incoming message. Sure – the latter indirectly verifies the message listener too, but that doesn’t mean we can skip the first test. Each <em class="italic">unit</em> test should stick to checking one tiny piece of the puzzle to make sure every bit is working as <span class="No-Break">it should.</span></p>
<p>With our first test passing, let’s see how we can make them <span class="No-Break">more data-driven.</span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor230"/>Looking at data-driven tests</h2>
<p><strong class="bold">Data-driven tests</strong> are a concept in<a id="_idIndexMarker887"/> software testing that refers to the strategy of creating test methods that can be executed with multiple sets of input data. Instead of writing individual tests for every possible input value or scenario, data-driven testing allows you to define a single test method and then feed it multiple different inputs. Notice in the first test that we wrote earlier how we are explicitly passing <strong class="source-inline">false</strong> as the third parameter. Now, if we were to remove <strong class="source-inline">IsFavorite = isFavorite;</strong> from the <strong class="source-inline">RecipeListItemViewModel</strong> class’s constructor, our test would deceptively still pass – a classic example of a false positive in testing. This is because, by coincidence, the default value of <strong class="source-inline">IsFavorite</strong> is <strong class="source-inline">false</strong>, but in fact, it is never assigned the value we passed in as a parameter. We could create another test method with different values in the <strong class="bold">Arrange</strong> step to address this. But we don’t like code duplication, do we? A more elegant solution is to utilize xUnit’s <strong class="source-inline">Theory</strong> and <strong class="source-inline">InlineData</strong> attributes to leverage <span class="No-Break">data-driven tests.</span></p>
<p>In xUnit, while the <strong class="source-inline">Fact</strong> attribute denotes a straightforward unit test that runs once, there’s another powerful feature: the <strong class="source-inline">Theory</strong> attribute. Paired with the <strong class="source-inline">InlineData</strong> attribute, <strong class="source-inline">Theory</strong> allows us to create parameterized tests. This means we can run the same test logic with different input values, ensuring our code is robust against a variety of scenarios without duplicating our test methods. Let’s dive in and refactor our earlier test to take advantage of <span class="No-Break">this capability:</span></p>
<ol>
<li>Modify the <strong class="source-inline">ViewModel_Initialized_PropertiesSetCorrectly</strong> method to include the <span class="No-Break">following parameters:</span><pre class="source-code">
public void
  ViewModel_Initialized_PropertiesSetCorrectly(
<strong class="bold">    string id, string title, bool isFavorite,</strong>
<strong class="bold">    string image</strong>)</pre></li> <li>Within the method, we can skip the entire <strong class="source-inline">Arrange</strong> phase and use the provided parameters directly to instantiate <span class="No-Break">our ViewModel:</span><pre class="source-code">
//Arrange, Act
var sut = new RecipeListItemViewModel(id, title,
    isFavorite, image);
//Assert
Assert.Equal(id, sut.Id);
Assert.Equal(title, sut.Title);
Assert.Equal(isFavorite, sut.IsFavorite);
Assert.Equal(image, sut.Image);</pre></li> <li>Let’s now remove the <strong class="source-inline">Fact</strong> attribute and add a <strong class="source-inline">Theory</strong> attribute and some <strong class="source-inline">InlineData</strong> attributes <a id="_idIndexMarker888"/>to <span class="No-Break">this method:</span><pre class="source-code">
[Theory]
[InlineData("id1", "title1", false, "image1")]
[InlineData("id2", "title2", true, "image2")]
[InlineData("foo", "bar", true, null)]
[InlineData(null, null, false, null)]</pre></li> </ol>
<p>The <strong class="source-inline">Theory</strong> attribute is used to mark a test method as being a data-driven test. This means that the test method will be executed once for each set of data values specified using the <strong class="source-inline">InlineData</strong> attribute. Each of those runs of the test will have access to the data values provided by <strong class="source-inline">InlineData</strong>. When the <strong class="source-inline">Theory</strong> method is executed, xUnit will create a new instance of the test class for each set of data values specified in the <strong class="source-inline">InlineData</strong> attribute, and then execute the test method using those data values. The values provided in the <strong class="source-inline">InlineData</strong> attribute should exactly match the number and types of parameters on the method that is <span class="No-Break">being tested.</span></p>
<p>Here’s how we can update the <strong class="source-inline">FavoriteUpdateMsgReceived_SameId_FavoriteUpdated</strong> method to turn it into a data-driven<a id="_idIndexMarker889"/> <span class="No-Break">test method:</span></p>
<pre class="source-code">
[Theory]
[InlineData(true, false)]
[InlineData(false, true)]
[InlineData(true, true)]
[InlineData(false, false)]
public void
    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(
    bool originalValue, bool updateToValue)
{
    //Arrange
    var id = "id";
    var sut = new RecipeListItemViewModel(
        id, "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(id, updateToValue));
    //Assert
    Assert.Equal(updateToValue, sut.IsFavorite);
}</pre> <p>The <strong class="source-inline">FavoriteUpdateMsgReceived_DifferentId_FavoriteNotUpdated</strong> can be updated similarly, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
[Theory]
[InlineData(true, false)]
[InlineData(false, true)]
[InlineData(true, true)]
[InlineData(false, false)]
public void FavoriteUpdateMsgReceived_
  DifferentId_FavoriteNotUpdated(
bool originalValue, bool updateToValue)
{
    //Arrange
    var sut = new RecipeListItemViewModel(
        "someid", "title", originalValue, "image");
    //Act
    WeakReferenceMessenger.Default.Send(
        new FavoriteUpdateMessage(
        "otherid", updateToValue));
    //Assert
    Assert.Equal(originalValue, sut.IsFavorite);
}</pre> <p>By adopting the <strong class="source-inline">Theory</strong> and <strong class="source-inline">InlineData</strong> attributes, we’ve enhanced our testing capability significantly. These <a id="_idIndexMarker890"/>updated test methods can now validate across a diverse set of values, ensuring that our ViewModel behaves consistently in varied scenarios. It’s an elegant way to increase test coverage without adding <span class="No-Break">redundant code.</span></p>
<p>Sometimes, it’s beneficial to have test data generated for us, especially when we’re more concerned about the logic than the specific values. That’s where tools such as Bogus and AutoBogus come into play, helping us effortlessly generate diverse test values without manual<a id="_idIndexMarker891"/> intervention. Let’s have <span class="No-Break">a look!</span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor231"/>Generating data with Bogus</h1>
<p>While handpicked data has<a id="_idIndexMarker892"/> its place in unit tests, it often comes with inherent bias: because we’ve written the functionality that we want to test, we have a certain expectation about the format of the values being used. To combat this, many tests benefit from randomized or generated data, especially when the specific input matters less than the resulting outcome. Bogus is a powerful tool tailored for those moments when you need reliable, unbiased test data without the <span class="No-Break">manual labor.</span></p>
<p>In this section, we’ll introduce Bogus and AutoBogus and explore some of its basic capabilities. However, it’s worth noting that we’re merely scratching the surface here. These tools offer many features, but for the sake of brevity and focus, we’ll keep our discussion high-level, touching only upon a few fundamental <span class="No-Break">use cases.</span></p>
<p>Let’s start off by adding AutoBogus (and thus also Bogus) to <span class="No-Break">our project:</span></p>
<ol>
<li>In <strong class="bold">Visual Studio</strong>, right-click the <strong class="source-inline">Recipes.Client.Core.UnitTests</strong> project and select <strong class="bold">Manage </strong><span class="No-Break"><strong class="bold">NuGet Packages…</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">NuGet Package Manager</strong>, search for <strong class="source-inline">autobogus</strong> and install the <span class="No-Break"><strong class="bold">AutoBogus</strong></span><span class="No-Break"> package:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="Figure 13.3: AutoBogus NuGet Package" height="339" src="image/B20941_13_03.jpg" width="1032"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3: AutoBogus NuGet Package</p>
<p>Now that we have installed these packages, let’s put this library into practice by testing the <span class="No-Break"><strong class="source-inline">EmptyOrWithinRangeAttribute</strong></span><span class="No-Break"> class:</span></p>
<ol>
<li>Create a new class <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">EmptyOrWithinRangeAttributeTests</strong></span><span class="No-Break">.</span></li>
<li>Place the following<a id="_idIndexMarker893"/> member variables into the <span class="No-Break">new class:</span><pre class="source-code">
const int MinValueStart = 5;
const int MinValueEnd = 10;
const int MaxValueStart = 11;
const int MaxValueEnd = 15;
readonly EmptyOrWithinRangeAttribute sut;</pre><p class="list-inset">In this class, we’ll be putting our <strong class="source-inline">sut</strong> object as a class member. This allows us to write the instantiation code of the <strong class="source-inline">sut</strong> object once in the constructor (or inline), preventing repeatable code in each test for setting everything up. As each test method runs in a separate instance of the <strong class="source-inline">EmptyOrWithinRangeAttributeTests</strong> class, this also has no side effects on <span class="No-Break">other tests.</span></p></li> <li>Add a constructor to the class and add the <span class="No-Break">following code:</span><pre class="source-code">
sut = new Faker&lt;EmptyOrWithinRangeAttribute&gt;()
    .RuleFor(r =&gt; r.MinLength, f =&gt;
        f.Random.Int(MinValueStart, MinValueEnd))
    .RuleFor(r =&gt; r.MaxLength, f =&gt;
        f.Random.Int(MaxValueStart, MaxValueEnd))
    .Generate();</pre></li> </ol>
<p>Instead of manually creating an instance of the <strong class="source-inline">EmptyOrWithinRangeAttribute</strong> class, we are delegating this to the Bogus framework. We do this by instantiating a new <strong class="source-inline">Faker</strong> class, passing in the type we want it to generate. With the <strong class="source-inline">RuleFor</strong> methods of the <strong class="source-inline">Faker</strong> class, we can configure the values for the <span class="No-Break">individual properties.</span></p>
<p>In a <strong class="source-inline">RuleFor</strong> method, we first need to point to the property we want to configure. The next parameter of this method is a function with a <strong class="source-inline">Faker</strong> class as a parameter that allows us to define the value<a id="_idIndexMarker894"/> of the property. In this case, we use the <strong class="source-inline">Faker</strong>’s <strong class="source-inline">Random.Int</strong> method to indicate we want it to be a generated int value between <span class="No-Break">two values.</span></p>
<p>By calling the <strong class="source-inline">Generate</strong> method, the Bogus framework will generate an instance of the type we want, adhering to the rules we’ve defined. This gives back the instance of the <strong class="source-inline">EmptyOrWithinRangeAttribute</strong> we want to <span class="No-Break">work with.</span></p>
<p>Let’s go ahead and implement a test that checks if <strong class="source-inline">EmptyOrWithinRangeAttribute</strong> validates <span class="No-Break">input correctly:</span></p>
<ol>
<li>Add the <strong class="source-inline">Value_WithinRange_IsValid</strong> to this class, as <span class="No-Break">shown here:</span><pre class="source-code">
[Fact]
public void Value_WithinRange_IsValid()
{
    //Arrange
    var input = new Faker().Random.String2(
        sut.MinLength, sut.MaxLength);
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.True(isValid);
}</pre><p class="list-inset">In the <strong class="source-inline">Arrange</strong> step, we’re using Bogus’ <strong class="source-inline">Faker</strong> class to generate a random string with a length that falls between the <strong class="source-inline">MinLength</strong> and <strong class="source-inline">MaxLength</strong> properties of the <strong class="source-inline">sut</strong>. Remember – these <strong class="source-inline">MinLength</strong> and <strong class="source-inline">MaxLength</strong> properties are values generated by Bogus. This generated string value can now be used to check whether the <strong class="source-inline">IsValid</strong> method of the <strong class="source-inline">EmptyOrWithingRangeAttribute</strong> does what we expect it to do. The returned value <a id="_idIndexMarker895"/>should be <strong class="source-inline">true</strong>, which we can easily check with the <span class="No-Break"><strong class="source-inline">Assert.True</strong></span><span class="No-Break"> method.</span></p></li> <li>Similarly, we can add a <strong class="source-inline">Value_TooShort_IsNotValid</strong> method that checks that the <strong class="source-inline">IsValid</strong> method returns <strong class="source-inline">false</strong> when the provided value <span class="No-Break">isn’t correct:</span><pre class="source-code">
[Fact]
public void Value_TooShort_IsNotValid()
{
    //Arrange
    var input = new Faker().Random.String2(
        1, MinValueStart - 1);
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.False(isValid);
}</pre></li> <li>While we’re at it, let’s also add a check to see if an empty string is returned as being valid. This is shown in the following <span class="No-Break">code block:</span><pre class="source-code">
[Fact]
public void Value_Empty_IsValid()
{
    //Arrange
    var input = string.Empty;
    //Act
    var isValid = sut.IsValid(input);
    //Assert
    Assert.True(isValid);
}</pre></li> </ol>
<p>Notice how short and straightforward these test methods are! Adding extra checks for input values being too long or <a id="_idIndexMarker896"/>null really isn’t hard labor. And because we are not working with hardcoded data, we can be pretty confident the <strong class="source-inline">IsValid</strong> method of the <strong class="source-inline">EmptyOrWithingRangeAttributes</strong> class works as expected in many different scenarios. On top of that, think about the speed and efficiency with which we’re validating this <strong class="source-inline">ValidationAttribute</strong> class. We haven’t deployed our app or clicked through its interface. Still, we’re already certain about the correctness of our code. That’s a significant boost in <span class="No-Break">development efficiency!</span></p>
<p>Remember the <strong class="source-inline">VM_Initialized_SubscribedToFavoriteUpdateMessage</strong> method in the <strong class="source-inline">RecipeListItemViewModelTests</strong> class we wrote earlier? This method checks whether an instance of the <strong class="source-inline">RecipeListItemViewModel</strong> is registered as a receiver for the <strong class="source-inline">FavoriteUpdateMessage</strong>. In this test method, we had to initialize our sut. However, the values that were used to create it aren’t of any value inside the test: whichever values are used, the instance should listen for the <strong class="source-inline">FavoriteUpdateMessage</strong>. This is an ideal scenario to introduce AutoBogus. Just take a look at the updated code of the <span class="No-Break"><strong class="source-inline">VM_Initialized_SubscribedToFavoriteUpdateMessage</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
//Arrange, Act
var sut = AutoFaker.Generate&lt;RecipeListItemViewModel&gt;();
//Assert
Assert.True(WeakReferenceMessenger.Default
    .IsRegistered&lt;FavoriteUpdateMessage&gt;(sut));</pre> <p>With the static <strong class="source-inline">Generate</strong> method of the <strong class="source-inline">AutoFaker</strong> class, we can generate an instance of <strong class="source-inline">RecipeListItemViewModel</strong>. The <strong class="source-inline">Faker</strong> class typically requires a default constructor for the object type we want to instantiate. The <strong class="source-inline">RecipeListItemViewModel</strong> doesn’t have a default constructor and that’s where <strong class="source-inline">AutoFaker</strong> comes into play: it will automatically provide fake values for the parameters. We basically don’t care <a id="_idIndexMarker897"/>which values are used to create this class. All that we are interested in in this test, is the fact the instantiated class is registered for <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">FavoriteUpdateMessage</strong></span><span class="No-Break">.</span></p>
<p>In other test methods, such as those in <strong class="source-inline">RecipeListItemViewModelTests</strong>, we’ve relied on hardcoded dummy data. We can use AutoBogus to get rid of these hardcoded values as well. Take a look at the updated <span class="No-Break"><strong class="source-inline">FavoriteUpdateMsgReceived_SameId_FavoriteUpdated</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
public void
    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(
    bool originalValue, bool updateToValue)
{
    //Arrange
    var id = <strong class="bold">AutoFaker.Generate&lt;string&gt;();</strong>
    var sut = new RecipeListItemViewModel(id,
        <strong class="bold">AutoFaker.Generate&lt;string&gt;()</strong>,
        originalValue,
        <strong class="bold">AutoFaker.Generate&lt;string&gt;()</strong>);
    //Act
    WeakReferenceMessenger.Default.Send(new
        FavoriteUpdateMessage(id, updateToValue));
    //Assert
    Assert.Equal(updateToValue, sut.IsFavorite);
}</pre> <p>In this previous code block, we’re leveraging AutoBogus’ <strong class="source-inline">Generate</strong> method to generate random data <span class="No-Break">for us.</span></p>
<p>Bogus and AutoBogus automate .NET testing by generating unbiased, randomized test data, eliminating manual and potentially <span class="No-Break">biased inputs.</span></p>
<p>Instead of merely <a id="_idIndexMarker898"/>providing fake data, we often need to mock entire components or behavior. This is where a dedicated mocking framework, such as Moq, becomes invaluable. Let’s delve into how Moq empowers us to effectively mock dependencies and streamline our <span class="No-Break">testing process.</span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor232"/>Mocking dependencies with Moq</h1>
<p>Testing frequently<a id="_idIndexMarker899"/> involves scenarios where our system under test interacts with external dependencies, whether they are databases, APIs, or other services. Running tests <a id="_idIndexMarker900"/>against these real dependencies can lead to slow, unpredictable outcomes and potentially unwanted side effects. Mocking provides a solution by simulating these dependencies, ensuring our tests focus purely on the component at hand. Through mocking, we gain control over external interactions, ensuring our tests are swift, reliable, and free from <span class="No-Break">external influences.</span></p>
<p class="callout-heading">Integration tests</p>
<p class="callout">When writing unit tests, we typically want to mock external dependencies as much as possible. However, it is often valuable to also test the integration of different components to ensure they work together <a id="_idIndexMarker901"/>seamlessly. This is where integration tests come in. Unlike unit tests, which focus heavily on mocking to test units in isolation, integration tests often involve fewer mocks. This ensures that components interact with each other in the exact manner we expect, verifying that they behave correctly as a <span class="No-Break">unified whole.</span></p>
<p>The principles of DI and separation of concerns accentuate this approach. When we design our components to be decoupled and inject their dependencies, it becomes seamless to replace real dependencies with mock versions during testing. Think of DI, SoC, and mocking as<a id="_idIndexMarker902"/> interlocking puzzle pieces, each complementing the other, leading to a comprehensive <a id="_idIndexMarker903"/>and maintainable testing strategy. Now, let’s dive into how Moq assists us in achieving <span class="No-Break">this goal.</span></p>
<p>When we inspect the <strong class="source-inline">RecipeDetailViewModel</strong>’s constructor, it’s evident that it depends on <span class="No-Break">several services:</span></p>
<pre class="source-code">
public RecipeDetailViewModel(
    IRecipeService recipeService,
    IFavoritesService favoritesService,
    IRatingsService ratingsService,
    INavigationService navigationService,
    IDialogService dialogService)
{
...
}</pre> <p>To effectively test this ViewModel, we need to abstract away its external dependencies. Mocking the <strong class="source-inline">recipeService</strong> parameter can be achieved <span class="No-Break">like this:</span></p>
<pre class="source-code">
var recipeServiceMock = new Mock&lt;IRecipeService&gt;();</pre> <p>The mocked value can then be passed-in the <strong class="source-inline">RecipeDetailViewModel</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
var sut = new RecipeDetailViewModel
  (<strong class="bold">recipeServiceMock.Object</strong>, ...);</pre> <p>This is where it gets interesting: we can provide <strong class="source-inline">recipeServiceMock</strong> with fake method implementations. We can configure our mock object with specific method behaviors. Consider the <strong class="source-inline">LoadRecipe</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">IRecipeService</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
Task&lt;Result&lt;RecipeDetail&gt;&gt; LoadRecipe(string id);</pre> <p>Here’s how to instruct Moq to mimic <span class="No-Break">this method:</span></p>
<pre class="source-code">
recipeServiceMock
    .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
    .ReturnsAsync(
    Result&lt;RecipeDetail&gt;.Success(new RecipeDetail(...));</pre> <p>With the <strong class="source-inline">Setup</strong> method, we can tell Moq which method we want to simulate. In our example, we’re targeting the <strong class="source-inline">LoadRecipe</strong> method. <strong class="source-inline">It.IsAny&lt;string&gt;</strong> is a matcher, which signifies that we’re indifferent to the exact value passed into the method. In simpler<a id="_idIndexMarker904"/> terms, any string value will trigger the behavior we’re <a id="_idIndexMarker905"/>defining here. Speaking of which, <strong class="source-inline">ReturnsAsync</strong> specifies the result our mock method should produce. For example, we’re returning a successful result containing dummy <strong class="source-inline">RecipeDetail</strong> data. In essence, this code configures <strong class="source-inline">recipeServiceMock</strong> to always produce a specific result for any call to <strong class="source-inline">LoadRecipe</strong>, ensuring our tests are predictable and not reliant on real implementations. Let’s see how we can add a set of <span class="No-Break">new tests.</span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor233"/>Applying mocking in our ViewModel tests</h2>
<p>To start testing <strong class="source-inline">RecipeDetailViewModel</strong>, let’s add a new class named <strong class="source-inline">RecipeDetailViewModelTests</strong> to the test<a id="_idIndexMarker906"/> project and follow <span class="No-Break">these steps:</span></p>
<ol>
<li>Add the following fields to the <span class="No-Break"><strong class="source-inline">RecipeDetailViewModelTests</strong></span><span class="No-Break"> class:</span><pre class="source-code">
readonly Mock&lt;IRecipeService&gt; _recipeServiceMock;
readonly Mock&lt;IFavoritesService&gt;
    _favoritesServiceMock;
readonly Mock&lt;IRatingsService&gt; _ratingsServiceMock;
readonly Mock&lt;INavigationService&gt;
    _navigationServiceMock;
readonly Mock&lt;IDialogService&gt; _dialogServiceMock;
readonly RecipeDetailViewModel sut;</pre></li> <li>Instantiate these<a id="_idIndexMarker907"/> fields in the class’s constructor, as <span class="No-Break">shown here:</span><pre class="source-code">
public RecipeDetailViewModelTests()
{
    _recipeServiceMock = new();
    _favoritesServiceMock = new();
    _ratingsServiceMock = new();
    _navigationServiceMock = new();
    _dialogServiceMock = new();
    _ratingsServiceMock
        .Setup(m =&gt;
            m.LoadRatingsSummary(It.IsAny&lt;string&gt;()))
        .ReturnsAsync(Result&lt;RatingsSummary&gt;.Success(
            AutoFaker.Generate&lt;RatingsSummary&gt;()));
    sut = new RecipeDetailViewModel(
        _recipeServiceMock.Object,
        _favoritesServiceMock.Object,
        _ratingsServiceMock.Object,
        _navigationServiceMock.Object,
        _dialogServiceMock.Object);
}</pre><p class="list-inset">In this previous code block, we’re instantiating all of our mock classes and using them to instantiate the <strong class="source-inline">sut</strong> object. By putting this in the constructor, we don’t have to repeat this code in every unit test. We can even already provide some default mock implementations, as shown with <strong class="source-inline">_ratingServiceMock</strong>. If, for a specific test, we need a different behavior for <strong class="source-inline">_ratingServiceMock</strong>, we can easily override the default behavior set in the constructor in the test itself. When we specify a<a id="_idIndexMarker908"/> new behavior in the test method, Moq will use the most recent setup, ensuring flexibility in <span class="No-Break">our tests.</span></p></li> <li>In the first test, we want to validate that the parameter that is being used to navigate to the detail page, is effectively being passed to the injected <strong class="source-inline">IRecipeService</strong>’s <strong class="source-inline">LoadRecipe</strong> method to retrieve the detail information. Start by adding the following method to <span class="No-Break">this class:</span><pre class="source-code">
[Fact]
public async Task OnNavigatedTo_Should_Load_Recipe()
{
...
}</pre></li> <li>Let’s have a look at this test’s <span class="No-Break"><strong class="source-inline">Arrange</strong></span><span class="No-Break"> step:</span><pre class="source-code">
//Arrange
var recipeId = AutoFaker.Generate&lt;string&gt;();
var parameters = new Dictionary&lt;string, object&gt; {
    { "id", recipeId }
};
_recipeServiceMock
    .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
    .ReturnsAsync(Result&lt;RecipeDetail&gt;
    .Success(AutoFaker.Generate&lt;RecipeDetail&gt;()));</pre><p class="list-inset">In the <strong class="source-inline">Arrange</strong> step, we’re generating a <strong class="source-inline">recipeId</strong> using <strong class="source-inline">AutoFaker</strong>. This value is put in a Dictionary named parameters which we’ll use in the next step. We’re also configuring <a id="_idIndexMarker909"/>the behavior of the <strong class="source-inline">_recipeServiceMock</strong>’s <strong class="source-inline">LoadRecipe</strong> method. As we’re not interested in what exactly is being returned in this test, we’ll leave it to <strong class="source-inline">AutoFaker</strong> to generate a <span class="No-Break"><strong class="source-inline">RecipeDetail</strong></span><span class="No-Break"> instance.</span></p></li> <li>Add the following code below the <span class="No-Break"><strong class="source-inline">Arrange</strong></span><span class="No-Break"> steps:</span><pre class="source-code">
//Act
await sut.OnNavigatedTo(parameters);</pre><p class="list-inset">By calling the ViewModel’s <strong class="source-inline">OnNavigatedTo</strong> method and passing a dictionary, we can mimic navigating to the ViewModel. This should trigger the load of the recipe’s detail information, using the passed-in <strong class="source-inline">"id"</strong> item from <span class="No-Break">the dictionary.</span></p></li> <li>Validating whether the <strong class="source-inline">LoadRecipe</strong> method of the injected <strong class="source-inline">IRecipeService</strong> is correctly called can be achieved <span class="No-Break">like this:</span><pre class="source-code">
//Assert
_recipeServiceMock.Verify(
    m =&gt; m.LoadRecipe(recipeId), Times.Once);</pre><p class="list-inset">The <strong class="source-inline">Verify</strong> method on a <strong class="source-inline">Mock</strong> object allows us to check whether a specific method was invoked or not. Note that we’re explicitly specifying that the <strong class="source-inline">LoadRecipe</strong> should have been called with the <strong class="source-inline">recipeId</strong> parameter. Also, with <strong class="source-inline">Times.Once</strong> we define that the method, with the given parameter, should have been called exactly once. If that isn’t the case, an exception will be thrown that will fail <span class="No-Break">the test.</span></p></li> </ol>
<p>This powerful feature of Moq ensures that certain interactions (method calls) take place as expected. But by using Moq, we can also make our tests predictable, allowing us to check for particular output values. The following test shows how we can validate whether the data<a id="_idIndexMarker910"/> returned by the <strong class="source-inline">IRecipeService</strong>’s <strong class="source-inline">LoadRecipe</strong> method is correctly mapped on to <span class="No-Break">the ViewModel:</span></p>
<pre class="source-code">
[Fact]
public async Task OnNavigatedTo_Should_Map_RecipeDetail()
{
    //Arrange
    <strong class="bold">var recipeDetail = AutoFaker.Generate&lt;RecipeDetail&gt;();</strong>
    var parameters = new Dictionary&lt;string, object&gt; {
        { "id", AutoFaker.Generate&lt;string&gt;() }
    };
    _recipeServiceMock
        .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
        .<strong class="bold">ReturnsAsync(Result&lt;RecipeDetail&gt;</strong>
<strong class="bold">        .Success(recipeDetail));</strong>
    //Act
    await sut.OnNavigatedTo(parameters);
    //Assert
    <strong class="bold">Assert.Equal(recipeDetail.Name, sut.Title);</strong>
<strong class="bold">    Assert.Equal(recipeDetail.Author, sut.Author);</strong>
}</pre> <p>A generated <strong class="source-inline">recipeDetail</strong> is what the <strong class="source-inline">_recipeServiceMock</strong>’s <strong class="source-inline">LoadRecipe</strong> method returns. After navigating to the ViewModel, we can check whether the properties match the<a id="_idIndexMarker911"/> value of the returned <strong class="source-inline">recipeDetail</strong> variable, assuring us the values are <span class="No-Break">correctly mapped.</span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor234"/>Thin UI, deep tests</h2>
<p>One of the pinnacle benefits of the MVVM pattern, especially when coupled with DI, is the depth of our unit testing capability. Let’s look at an <a id="_idIndexMarker912"/>example that demonstrates this. Traditionally, interactions such as dialog prompts or navigation might be considered to be UI testing. But here, we’ll see how we can validate these interactions through simple unit tests. The <strong class="source-inline">IDialogService</strong> and <strong class="source-inline">INavigationService</strong>, while seeming intrinsically linked to UI, are injected as platform-independent dependencies. This abstraction ensures that our tests remain agnostic to the final UI layer, whether it’s a mobile app, a web interface, or desktop software. As a result, the UI layer remains incredibly thin, and our confidence in the bulk of our application logic – verified through these tests — remains high. Let’s dive into an example: when the <strong class="source-inline">RecipeDetailViewModel</strong> is unable to load the recipe detail, a prompt should be shown asking the user to retry. If the user selects <strong class="bold">No</strong>, the app should automatically navigate back to the previous page. Here’s what this test <span class="No-Break">looks like:</span></p>
<pre class="source-code">
[Fact]
public async Task FailedLoad_Should_ShowDialog()
{
    //Arrange
    var parameters = new Dictionary&lt;string, object&gt; {
        { "id", AutoFaker.Generate&lt;string&gt;() }
    };
    _recipeServiceMock
        .Setup(m =&gt; m.LoadRecipe(It.IsAny&lt;string&gt;()))
        <strong class="bold">.ReturnsAsync(Result&lt;RecipeDetail&gt;</strong>
<strong class="bold">        .Fail(AutoFaker.Generate&lt;string&gt;())</strong>);
<strong class="bold">    _dialogServiceMock</strong>
<strong class="bold">        .Setup(m =&gt; m.AskYesNo(It.IsAny&lt;string&gt;(), ...))</strong>
<strong class="bold">        .ReturnsAsync(false);</strong>
    //Act
    await sut.OnNavigatedTo(parameters);
    //Assert
<strong class="bold">    _dialogServiceMock.Verify(m =&gt;       m.AskYesNo </strong><strong class="bold">(It.IsAny&lt;string&gt;(), ...), Times.Once);</strong>
<strong class="bold">    _navigationServiceMock.Verify(m =&gt; m.GoBack(),</strong>
<strong class="bold">      Times.Once);</strong>
}</pre> <p>In the previous code block, we’re configuring <strong class="source-inline">_recipeServiceMock</strong> so that it returns a <strong class="source-inline">Fail</strong> result every time the <strong class="source-inline">LoadRecipe</strong> method is called. <strong class="source-inline">_dialogServiceMock</strong> is configured so that when the <strong class="source-inline">AskYesNo</strong> method is invoked, a <strong class="source-inline">false</strong> value is returned. This mimics the user selecting <strong class="source-inline">No</strong> in the presented dialog. With all this in place, we can <a id="_idIndexMarker913"/>check that the dialog is being shown and that back navigation is triggered as a result of the user selecting <strong class="source-inline">No</strong> in the <span class="No-Break">retry dialog.</span></p>
<p>This demonstrates how, with the right architecture and tools, even intricate interactions that touch upon UI elements can be captured, controlled, and tested – all without direct dependency on platform-specific components. This platform-independent unit testing not only ensures that our application remains both maintainable and reliable but also hardens its adaptability across various platforms. It underscores the power of the <span class="No-Break">MVVM pattern!</span></p>
<p>However, there is still some code to<a id="_idIndexMarker914"/> be tested that is platform-specific. Let’s have a look at that before we end <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor235"/>Testing MAUI-specific code</h1>
<p>As shown in the previous <a id="_idIndexMarker915"/>examples, the majority of our code can be tested independently of the platform. But let’s not forget that there is code in our MAUI project as well that could benefit from some <span class="No-Break">unit tests.</span></p>
<p>Let’s start by adding a new project to hold our tests for the <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project:</span></p>
<ol>
<li>Add a new <strong class="bold">xUnit Test Project</strong> type, just as we did at the beginning of this chapter. Name this <span class="No-Break">project </span><span class="No-Break"><strong class="source-inline">Recipes.Mobile.UnitTests</strong></span><span class="No-Break">.</span></li>
<li>Once the project has been created, add a reference to the <span class="No-Break"><strong class="source-inline">Recipes.Mobile</strong></span><span class="No-Break"> project.</span></li>
<li>Add the <strong class="bold">AutoBogus</strong> NuGet package to <span class="No-Break">this project.</span></li>
</ol>
<p>The <strong class="source-inline">Recipes.Mobile.UnitTests</strong> project doesn’t target any specific frameworks other than <strong class="source-inline">net8.0</strong>. Because of that, we need to make sure <strong class="source-inline">net8.0</strong> is on the list of target frameworks of the MAUI project as well. Also, we need to make sure that when the <strong class="source-inline">Recipes.Mobile</strong> project targets this additional <strong class="source-inline">net8.0</strong> framework, it doesn’t output an EXE file. Let’s see how to properly <span class="No-Break">configure this:</span></p>
<ol>
<li>Open the <strong class="source-inline">Recipes.Mobile.csproj</strong> file by clicking on the project name in the <strong class="bold">Solution Explorer</strong> in <strong class="bold">Visual Studio</strong> or by right-clicking the project and selecting <strong class="bold">Edit </strong><span class="No-Break"><strong class="bold">Project File</strong></span><span class="No-Break">.</span></li>
<li>Add <strong class="source-inline">net8.0</strong> to the <strong class="source-inline">TargetFrameworks</strong> tag, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;TargetFrameworks&gt;<strong class="bold">net8.0;</strong>net8.0-android;net8.0-
  ios;net8.0-maccatalyst&lt;/TargetFrameworks&gt;</pre></li> <li>Find the <strong class="source-inline">OutputType</strong> tag in the <strong class="source-inline">.csproj</strong> file and update <span class="No-Break">the following:</span><pre class="source-code">
&lt;OutputType <strong class="bold">Condition="'$(TargetFramework)' !=</strong>
<strong class="bold">  'net8.0'"</strong>&gt;Exe&lt;/OutputType&gt;</pre></li> <li>In the <strong class="bold">Solution Explorer</strong>, right-click the <strong class="source-inline">Recipes.Mobile</strong> project and select <strong class="bold">Unload Project</strong>. Once unloaded, right-click it again and select <span class="No-Break"><strong class="bold">Reload Project</strong></span><span class="No-Break">.</span></li>
</ol>
<p>Once the <strong class="source-inline">Recipes.Mobile</strong> project is configured, we also need to add one thing to the <strong class="source-inline">Recipes.Mobile.UnitTests</strong> project. In its <strong class="source-inline">.csproj</strong> file, find the first <strong class="source-inline">PropertyGroup</strong> tag and <a id="_idIndexMarker916"/>add the <span class="No-Break">following: </span><span class="No-Break"><strong class="source-inline">&lt;UseMaui&gt;true&lt;/UseMaui&gt;</strong></span><span class="No-Break">.</span></p>
<p>With all of this in place, writing tests for functionality in the <strong class="source-inline">Recipes.Mobile</strong> project isn’t any different from the tests we’ve written so far. Let’s have a look at how to test the <span class="No-Break"><strong class="source-inline">RatingToStarsConverter</strong></span><span class="No-Break"> class:</span></p>
<ol>
<li>Start by creating a new class <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">RatingToStarsConverterTests</strong></span><span class="No-Break">.</span></li>
<li>This converter makes for a good data-driven test. We can specify the input and expected output through method parameters, as shown in the following <span class="No-Break">code block:</span><pre class="source-code">
public void Convert_Should_Return_ExpectedOutput(
    object input, string expectedOutput)
{
    //Arrange
    var sut = new Converters.RatingToStarsConverter();
    //Act
    var result = sut.Convert(input,
        null, null, null);
    //Assert
    Assert.Equal(expectedOutput, result);
}</pre><p class="list-inset">The passed-in input value is the value we want our converter to convert. The result is compared to the converted value by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Assert.Equal</strong></span><span class="No-Break">.</span></p></li> <li>Add the <strong class="source-inline">Theory</strong> attribute and the following <strong class="source-inline">InlineData</strong> attributes for different – edge-case – scenarios to <span class="No-Break">this method:</span><pre class="source-code">
[InlineData("foo", "")]
[InlineData(-1d, "")]
[InlineData(6d, "")]
[InlineData(1d, "\ue838")]
[InlineData(2d, "\ue838\ue838")]
[InlineData(2.2d, "\ue838\ue838")]
[InlineData(2.5d, "\ue838\ue838\ue839")]
[InlineData(2.9d, "\ue838\ue838\ue839")]</pre></li> </ol>
<p>This test method successfully validates if the <strong class="source-inline">RatingToStarsConverter</strong> converts a given value to a string representing star-icons. Not only are happy paths tested, but also the expected behavior when passing in <span class="No-Break">invalid data.</span></p>
<p>One other thing we can<a id="_idIndexMarker917"/> test is the <strong class="source-inline">InstructionsDataTemplateSelector</strong> class. The following steps show you how this can <span class="No-Break">be done:</span></p>
<ol>
<li>Add a new class <strong class="source-inline">InstructionsDataTemplateSelectorTests</strong> to the <span class="No-Break"><strong class="source-inline">Recipes.Mobile.UnitTests</strong></span><span class="No-Break"> project.</span></li>
<li>Here’s what a test for this <strong class="source-inline">TemplateSelector</strong> could <span class="No-Break">look like:</span><pre class="source-code">
[Fact]
public void SelectTemplate_NoteVM_Should_Return
  _NoteTemplate()
{
    //Arrange
    var template = new DataTemplate();
    var sut = new InstructionsDataTemplateSelector();
    sut.NoteTemplate = template;
    sut.InstructionTemplate = new DataTemplate();
    //Act
    var result = sut.SelectTemplate(
        AutoFaker.Generate&lt;NoteViewModel&gt;(), null);
    //Assert
    Assert.Equal(template, result);
}</pre><p class="list-inset">In this test, we’re <a id="_idIndexMarker918"/>creating a template that gets assigned to the <strong class="source-inline">NoteTemplate</strong> property of the sut. The <strong class="source-inline">SelectTemplate</strong> method of the sut gets invoked, passing in a generated <strong class="source-inline">NoteViewModel</strong>. We expect the returned <strong class="source-inline">DataTemplate</strong> to be the one we created and assigned to the <span class="No-Break"><strong class="source-inline">NoteTemplate</strong></span><span class="No-Break"> property.</span></p></li> </ol>
<p>With simple tests like these, we can easily validate the behavior of a <strong class="source-inline">TemplateSelector</strong> without deploying and running our app once! Testing if the <strong class="source-inline">InstructionsDataTemplateSelector</strong> works as expected for an <strong class="source-inline">InstructionViewModel</strong> or an unsupported ViewModel, should be <span class="No-Break">pretty straightforward.</span></p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor236"/>Summary</h1>
<p>In this chapter, we delved into unit testing within the MAUI framework, specifically focusing on testing ViewModels and some MAUI components. It’s worth noting that while we focused on these areas, the tools and techniques discussed are equally effective for testing services, repositories, and other integral parts of your application. Beyond just validating the code’s functionality, unit testing acts as a safety net, ensuring maintainability and robustness by reducing the chances of regression bugs. This powerful approach empowers us to iterate faster, removing the constant need for cumbersome deployments or manual checks. Leveraging mock implementations, we can seamlessly mimic and validate countless scenarios, and this validation remains ingrained in our code base. As we add or modify features, this ensures every intricate use case remains covered. A key takeaway is the significant portion of our app that can be tested independently of platform-specific details. This not only enhances adaptability but solidifies the effectiveness of the MVVM pattern. In conclusion, unit testing in MAUI isn’t just a checkbox; it’s a foundational element that drives us to build robust applications with agility and confidence. In the next and final chapter of this book, we’ll be looking at some troubleshooting and debugging tips that might come in handy when building an MVVM app with .<span class="No-Break">NET MAUI.</span></p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor237"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li><span class="No-Break">xUnit: </span><a href="https://xunit.net/"><span class="No-Break">https://xunit.net/</span></a></li>
<li>Bogus for .<span class="No-Break">NET: </span><a href="https://github.com/bchavez/Bogus"><span class="No-Break">https://github.com/bchavez/Bogus</span></a></li>
<li><span class="No-Break">AutoBogus: </span><a href="https://github.com/nickdodd79/AutoBogus"><span class="No-Break">https://github.com/nickdodd79/AutoBogus</span></a></li>
<li><span class="No-Break">Moq: </span><a href="https://github.com/devlooped/moq"><span class="No-Break">https://github.com/devlooped/moq</span></a></li>
<li><em class="italic">Unit testing C# in .NET Core using dotnet test and </em><span class="No-Break"><em class="italic">xUnit</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test"><span class="No-Break">https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test</span></a></li>
</ul>
</div>
</div></body></html>