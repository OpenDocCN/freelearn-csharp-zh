<html><head></head><body>
  <div><h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-183" class="chapterTitle">Immersive Realism: Achieving Fullscreen Effects with Post-Processing</h1>
    <p class="normal">So far, we have created different objects, such as meshes, particles, and lights, to alter the visuals of our scene. But if we really want to get that slick, modern game look, it’s time to try our hand at some post-processing magic. We can tweak the settings of our objects here and there to improve our scene quality, but you will always feel that something is missing when comparing it with modern game scenes, and the thing that is missing is post-processing effects, that is, any effects applied after all the processing of the scene has been completed to enhance its visual results. In this chapter, you will learn how to apply effects to the final rendered frame, which will alter the look of the overall scene we have been creating in previous chapters.</p>
    <p class="normal">In this chapter, we will examine the following image effect concepts:</p>
    <ul>
      <li class="bulletList">Using post-processing</li>
      <li class="bulletList">Using advanced effects</li>
    </ul>
    <p class="normal">Let’s start by seeing how we can apply post-processing to our scene.</p>
    <h1 id="_idParaDest-184" class="heading-1">Using post-processing</h1>
    <p class="normal"><strong class="keyWord">Post-processing</strong> is a<a id="_idIndexMarker860"/> Unity feature that allows us to apply a stack of effects (several effects) one on top of the other to alter the final look of an image. Each one will affect<a id="_idIndexMarker861"/> the finished frame, changing the final image the user sees. In <em class="italic">Figure 13.1</em>, you can see a scene before and after applying image effects. You will notice a dramatic difference, but that scene doesn’t have any changes in its objects, including lights, particles, and meshes.</p>
    <p class="normal">The effects <a id="_idIndexMarker862"/>applied are based on a per-pixel level. Have a look at both the scenes here:</p>
    <figure class="mediaobject"><img src="img/B21361_13_01_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.1: A scene without image effects (left) and the same scene with effects (right)</p>
    <p class="normal">In this section, we will discuss the following URP post-processing concepts:</p>
    <ul>
      <li class="bulletList">Setting up a profile</li>
      <li class="bulletList">Using basic effects</li>
    </ul>
    <p class="normal">By mastering these URP post-processing concepts, you’ll be able to transform your scenes from the ordinary to the extraordinary. Let’s start preparing our scene to apply effects, for which we need to set up a profile.</p>
    <h2 id="_idParaDest-185" class="heading-2">Setting up a profile</h2>
    <p class="normal">To start <a id="_idIndexMarker863"/>applying effects, we need to create a <strong class="keyWord">profile</strong>, which is an asset containing all the effects and settings we want to apply. This is a separate asset because we can share the same post-processing profile across different scenes and parts of scenes, as we do for the materials. When we refer to parts of scenes, we are referring to volumes, which are zones, regions, or areas of the game that have certain effects applied. We can define a global area that applies effects regardless of the position of the player, or we can apply different effects—for example, when we are outdoors or indoors.</p>
    <p class="normal">In this case, we will use a global volume, one that we will use to apply a profile with our first effect, by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create a new empty GameObject (<strong class="screenText">GameObject | Create Empty</strong>) named <code class="inlineCode">PP Volume </code>(Post-Processing Volume).</li>
      <li class="numberedList">Add the <strong class="screenText">Volume</strong> component to it and make sure <strong class="screenText">Mode</strong> is set to <strong class="screenText">Global</strong>.</li>
      <li class="numberedList">Click<a id="_idIndexMarker864"/> on the <strong class="screenText">New</strong> button at the right of the <strong class="screenText">Profile</strong> setting, which will generate a new <code class="inlineCode">Profile</code> asset with the same name as the GameObject that was selected when clicking the button (<strong class="screenText">PP Volume</strong> <strong class="screenText">Profile</strong>). Move that asset to its own folder, which is recommended for asset organization purposes. The final settings are illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_02.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.2: Volume component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">To test whether the volume is working, let’s add an effect. To do so, click the <strong class="screenText">Add Override</strong> button and select the <strong class="screenText">Post-Processing | Chromatic Aberration</strong> option.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox in the <strong class="screenText">Chromatic Aberration</strong> effect and set the intensity to <code class="inlineCode">0.25</code>, as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_03_PE.png" alt="A picture containing text, screenshot, font, number  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 13.3: Chromatic aberration effect</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Now, watch as the aberration effect subtly tweaks the corners of your image, adding a dynamic edge to the scene. Remember to look at this in the <strong class="screenText">Scene</strong> panel; we will make the effect applied to the <strong class="screenText">Game</strong> view in the next step. This<a id="_idIndexMarker865"/> is illustrated in the following figure:
    <figure class="mediaobject"><img src="img/B21361_13_04_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.4: Chromatic aberration applied to the scene</p>
    <p class="normal">If you don’t see the effect, make sure that the toggle effects button is on, as seen in the following image.</p>
    <figure class="mediaobject"><img src="img/B21361_13_05.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.5: Scene view effects toggle</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Now, if you hit <strong class="screenText">Play</strong> and see the game from the view of the Main Camera, you will see that the effect is not being applied, and that’s because we need to check the <strong class="screenText">Post Processing</strong> checkbox in the <strong class="screenText">Rendering</strong> section of our Main Camera, as illustrated in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.6: Enabling post-processing</p>
    <p class="normal">With our global <a id="_idIndexMarker866"/>volume set up, we’ve just unlocked the ability to consistently apply effects across the entire scene, no matter where our player roams.</p>
    <p class="normal">Now that we have prepared our scene to use post-processing, we can start experimenting with different effects. Let’s start with the simplest ones in the next section.</p>
    <h2 id="_idParaDest-186" class="heading-2">Using basic effects</h2>
    <p class="normal">Now that<a id="_idIndexMarker867"/> we have post-processing in our scene, the only thing needed is to start adding effects and set them up until we have the desired look and feel. In order to do that, let’s explore several simple effects included in the system.</p>
    <p class="normal">Let’s start with <strong class="keyWord">Chromatic Aberration</strong>, the<a id="_idIndexMarker868"/> one we just used, which, as with most image effects, tries to replicate a particular real-life effect. All game engine rendering systems use a simple mathematical approximation of how human vision really works, and because of that, we don’t have some effects that occur in the human eye or camera lenses. A real camera lens works by bending light rays to point them toward the camera sensors, but that bending is not perfect in some lenses (sometimes intentionally), and, hence, you<a id="_idIndexMarker869"/> can see distortion, as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B21361_13_07_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.7: Image without chromatic aberration (top) and the same image with chromatic aberration (bottom)</p>
    <p class="normal">This effect will be one of several that we will add to generate a cinematic feeling in our game, simulating the usage of real-life cameras. Of course, this effect won’t look nice in every kind of game; maybe a simplistic cartoonish style won’t benefit from this one, but you never know: art is subjective, so it’s a matter of trial and error.</p>
    <p class="normal">Also, we have exaggerated the intensity a little bit in the previous example to make the effect more noticeable, but I would recommend using an intensity of <code class="inlineCode">0.25</code> in this scenario. It is usually recommended to be gentle with the intensity of the effects; it’s tempting to have intense effects, but as you will be adding lots of them, after a while, the image will become bloated with too many distortions. So, try to add several subtle effects instead of a few intense ones. But, again, this depends on the target style you are looking for; there are no absolute truths here (but common sense still applies).</p>
    <p class="normal">Finally, before<a id="_idIndexMarker870"/> moving on to discuss other effects, if you are used to using other kinds of post-processing effects frameworks, you will notice that this version of <strong class="keyWord">Chromatic Aberration</strong> has fewer settings, and that’s because the URP version seeks performance, so it will be as simple as possible.</p>
    <p class="normal">The next effect we are going to<a id="_idIndexMarker871"/> discuss is <strong class="keyWord">Vignette</strong>. This is another camera lens imperfection where the image intensity is lost at the edges of the lens. This can be applied not only to simulate older cameras but also to draw the attention of the user toward the center of the camera—for example, during cinematics.</p>
    <p class="normal">Also, if you are <a id="_idIndexMarker872"/>developing <strong class="keyWord">virtual reality</strong> (<strong class="keyWord">VR</strong>) applications, this can be used to reduce motion sickness by reducing the peripheral vision of the player. In the following screenshot, you can see an example of vignetting on an old camera:</p>
    <figure class="mediaobject"><img src="img/B21361_13_08_PE.png" alt="Image result for vignetting"/></figure>
    <p class="packt_figref">Figure 13.8: Photo taken with an old camera, with vignetting over the edges</p>
    <p class="normal">Just to try it, let’s<a id="_idIndexMarker873"/> apply some vignetting to our scene by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select the <code class="inlineCode">PP Volume</code> GameObject.</li>
      <li class="numberedList">Add the <strong class="screenText">Postprocessing | Vignette</strong> effect by clicking on the <strong class="screenText">Add Override </strong>button.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox and set it to <code class="inlineCode">0.3</code>, increasing the effect.</li>
      <li class="numberedList">Check the <strong class="screenText">Smoothness </strong>checkbox and set it to <code class="inlineCode">0.5</code>; this will increase the spread of the effect. You can see the result in the following figure:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_09_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.9: Vignette effect</p>
    <p class="normal">If you want, you <a id="_idIndexMarker874"/>can change the color by checking the <strong class="keyWord">Color</strong> checkbox and setting it to another value; in our case, black is okay to reinforce the rainy-day environment. Here, I invite you to check other properties, such as <strong class="keyWord">Center</strong> and <strong class="keyWord">Rounded</strong>. You can create nice effects just by playing with the values.</p>
    <p class="normal">Another effect we are going to <a id="_idIndexMarker875"/>see is <strong class="keyWord">Motion Blur</strong>, and again, it simulates the way the cameras work. A real camera has an exposure time: the time it needs to capture photons in an image. When an object moves fast enough, the same object is placed in different positions during that brief exposure time, so it will appear blurred. In the following screenshot, you can see the effect applied to our scene. </p>
    <p class="normal">In the case of this image, we are moving the camera up and down fast, with the following result:</p>
    <figure class="mediaobject"><img src="img/B21361_13_10_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.10: Motion Blur being applied to our scene</p>
    <p class="normal">One thing to<a id="_idIndexMarker876"/> consider is that this blur will only be applied to the camera movement and not the movement of the objects (still camera, moving objects), due to the fact that this URP doesn’t support motion vectors yet.</p>
    <p class="normal">In order to use this effect, follow these next steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add the <strong class="screenText">Post-processing | Motion Blur</strong> override with the <strong class="screenText">Add override</strong> button.</li>
      <li class="numberedList">Check the <strong class="screenText">Intensity</strong> checkbox and set it to <code class="inlineCode">0.25</code>.</li>
      <li class="numberedList">Rotate the camera while looking at the <strong class="screenText">Game</strong> view (not the <strong class="screenText">Scene</strong> view). You can click and drag the <strong class="screenText">X</strong> property of <strong class="screenText">Transform</strong> of the camera (not the value—the <strong class="screenText">X</strong> label), as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_11_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.11: Changing rotation</p>
    <p class="normal">As you can see, this effect cannot be seen in the <strong class="screenText">Scene</strong> view, as well as other effects, so take that into account before concluding the effect is not working. Unity does this because it <a id="_idIndexMarker877"/>would be very annoying to have that effect while working in the scene.</p>
    <p class="normal">Finally, we are<a id="_idIndexMarker878"/> going to briefly discuss two <a id="_idIndexMarker879"/>simple effects, <strong class="keyWord">Film Grain</strong> and <strong class="keyWord">White Balance</strong>:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">The first is pretty simple: add it, set the intensity to <code class="inlineCode">1</code>, and you will get the famous grain effect from old movies. You can set <strong class="screenText">Type</strong> with a different number of sizes to make it more subtle or harsh.</li>
      <li class="numberedList">The second one, <strong class="screenText">White Balance</strong> allows you to change the color temperature, making colors warmer or cooler depending on how you configure it. In our case, we are working in a cold, dark scene, so you can add it and set the temperature to <code class="inlineCode">-20</code> to adjust the appearance just slightly and improve the look and feel in this kind of scene.</li>
    </ol>
    <div><p class="normal">When I was learning how to make my own post-processing effects, I remember experimenting with a dream-like transition distortion effect. To do so, I used the sine mathematical function to calculate the amount of horizontal distortion to apply based on the vertical position of the pixels. After doing so, I saw my framerate drop heavily, and that was the moment I realized post-processing can be expensive. To be fair, it was an old PC, but still, the point holds. Be careful about the number of postprocessing effects you add, and learn about each one to see how to configure it properly. You can analyze the cost of the GPU with tools like PIX, which analyzes the GPU performance of your application: <a href="https://devblogs.microsoft.com/pix/download/">https://devblogs.microsoft.com/pix/download/</a></p>
    </div>
    <p class="normal">Now that we have seen a few of the simple effects, let’s check out a few of the remaining ones that are affected by some advanced rendering features.</p>
    <h1 id="_idParaDest-187" class="heading-1">Using advanced effects</h1>
    <p class="normal">Now we’re stepping <a id="_idIndexMarker880"/>up our game with some advanced effects. They’re a notch above what we’ve seen before, and a bit trickier, but don’t worry—we’ll guide you through them. In this section, we are going to see the following advanced effect concepts:</p>
    <ul>
      <li class="bulletList">High Dynamic Range (HDR) and Depth Map</li>
      <li class="bulletList">Applying advanced effects</li>
    </ul>
    <p class="normal">Let’s start by discussing some requirements for some of these effects to work properly.</p>
    <h2 id="_idParaDest-188" class="heading-2">High Dynamic Range (HDR) and depth map</h2>
    <p class="normal">Remember the <a id="_idIndexMarker881"/>Depth Map from our last chapter? Some effects need more than just the rendered image; they require extra data like this to really shine. Some effects not only work with the rendered image but also need additional data. We can first discuss the Depth Map, a concept we discussed in previous chapters.</p>
    <p class="normal">A Depth Map is <a id="_idIndexMarker882"/>an image rendered from the point of view of the camera, but instead of generating a final image of the scene, it renders the scene objects’ depth, rendering the objects in shades of gray. In a Depth Map, the rule is simple: the darker the shade, the further away the pixel is from the camera, and the lighter it is, the closer it is. </p>
    <p class="normal">In the following screenshot, you can see an example of a Depth Map:</p>
    <figure class="mediaobject"><img src="img/B21361_13_12_PE.png" alt="Image result for depth buffer"/></figure>
    <p class="packt_figref">Figure 13.12: Notice how the varying shades of gray depict the distance from the camera</p>
    <p class="normal">We will see some <a id="_idIndexMarker883"/>effects<a id="_idIndexMarker884"/> such as <strong class="keyWord">Depth of Field</strong>, which will blur some parts of the image based on the distance of the camera, but it can be used for several purposes on custom effects (not in the base URP package).</p>
    <p class="normal">Another concept to<a id="_idIndexMarker885"/> discuss here that will alter how colors are treated and, hence, how some effects work is <strong class="keyWord">High Dynamic Range</strong> (<strong class="keyWord">HDR</strong>). In<a id="_idIndexMarker886"/> older hardware, color channels (red, green, and blue) were encoded in a 0 to 1 range, 0 representing no intensity and 1 representing full intensity (per channel), so all lighting and color calculations were done in that range. That seems okay but doesn’t reflect how light actually works. You can see full white (all channels set to 1) in a piece of paper being lit by sunlight, and you can see full white when you look directly at a light bulb, but even if both light and paper are of the same color, the latter will, firstly, irritate the eye after a while and, secondly, have some overglow due to an excess of light. The problem here is that the maximum value (1) is not enough to represent the most intense color, so if you have a high-intensity light and another with even more intensity, both will generate the same color (1 in each channel) because calculations cannot go further than 1. To overcome these limitations and capture light more <a id="_idIndexMarker887"/>realistically, <strong class="keyWord">HDR Rendering</strong> was created.</p>
    <p class="normal">HDR is a way for colors to exceed the 0 to 1 range, so lighting and effects that work based on color intensity have better accuracy in this mode. Unity will do the calculations in HDR but the final image will still work using the previous color space (0 to 1, or <strong class="keyWord">Low Dynamic Range (LDR</strong>)), so don’t confuse Unity’s hdr rendering with the display’s hdr.</p>
    <div><p class="normal">For more information about HDR, check this link: <a href="https://docs.unity3d.com/Manual/HDR.html">https://docs.unity3d.com/Manual/HDR.html</a></p>
    </div>
    <p class="normal">To convert the HDR calculations back to LDR, Unity (and also TVs) uses a concept called <strong class="keyWord">tonemapping</strong>. You <a id="_idIndexMarker888"/>can see an example of an LDR-rendered scene and tonemapping being used in an HDR scene in the following screenshots:</p>
    <figure class="mediaobject"><img src="img/B21361_13_13_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.13: An LDR-rendered scene (left) and an HDR scene with corrected overbrights using tonemapping (right)</p>
    <p class="normal">Tonemapping is a <a id="_idIndexMarker889"/>way to convert colors outside the 0-1 light intensity<a id="_idIndexMarker890"/> range back inside this range to render them on LDR screens. It basically uses curves to determine how each color channel should be mapped back.</p>
    <p class="normal">Picture this: you’re <a id="_idIndexMarker891"/>stepping out from a dimly lit room into the glaring afternoon sun. That momentary blinding effect and gradual adjustment is HDR at work. It’s like stepping out into bright sunlight from a dark room; at first, everything is too bright, but gradually, your eyes adjust—that’s tonemapping in action. The idea here is that calculations are not different when you are inside or outside the building; a white wall inside the building will have a color close to 1 intensity, while the same white wall outside will have a higher value (due to sunlight). The difference is that tonemapping will take the higher-than-1 color back to 1 when you are outside the building, and maybe it will increase the lighting of the wall inside if the whole scene is darker, depending <a id="_idIndexMarker892"/>on how you set it. That feature is called <strong class="keyWord">auto-exposure</strong>.</p>
    <p class="normal">Even if HDR is enabled by default, let’s just see how we can verify if it is by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong>.</li>
      <li class="numberedList">Click on the <strong class="screenText">Graphics</strong> section in the left panel.</li>
      <li class="numberedList">Click the asset referenced under the <strong class="screenText">Scriptable Render Pipeline Settings</strong> property.</li>
      <li class="numberedList">Click on the highlighted asset in the <strong class="screenText">Project</strong> panel. Ensure that this panel is visible before clicking the property in the <strong class="screenText">Graphics</strong> settings. Alternatively, you can double-click the asset reference in the <strong class="screenText">Graphics</strong> settings to select it.</li>
      <li class="numberedList">Under the <strong class="screenText">Quality</strong> section, ensure that <strong class="screenText">HDR</strong> is checked, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_14_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.14: Enabling HDR</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Ensure<a id="_idIndexMarker893"/> that the <strong class="screenText">HDR Rendering </strong>property of the <strong class="screenText">Camera</strong> component in the <strong class="screenText">Main Camera</strong> GameObject is set to <strong class="screenText">Use settings from Render Pipeline</strong> to ensure the change in the previous steps is respected.</li>
    </ol>
    <p class="normal">Of course, the fact that <a id="_idIndexMarker894"/>HDR is togglable means that there are scenarios where you don’t want to use it. As you can guess, not all hardware supports HDR, and using it incurs a performance overhead, so take that into account. Luckily, most effects work with both HDR and LDR color ranges, so if you have HDR enabled but the user device doesn’t support it, you won’t get any errors, just different results depending on the effect, such as brighter or darker images, or exaggerated effects, as we will see in the next section, <em class="italic">Applying advanced effects</em>.</p>
    <p class="normal">Now that we are sure we have HDR enabled, let’s explore some advanced effects that use this and depth mapping.</p>
    <h2 id="_idParaDest-189" class="heading-2">Applying advanced effects</h2>
    <p class="normal">Let’s see certain <a id="_idIndexMarker895"/>effects that use the previously described techniques, starting with the commonly <a id="_idIndexMarker896"/>used <strong class="keyWord">Bloom</strong>. This effect emulates the overglow that happens around a heavily lit object on a camera lens or even the human eye. In <em class="italic">Figure 13.15</em>, you can see the difference between the default version of our scene and an exaggerated Bloom version.</p>
    <p class="normal">You can observe how the effect is only applied to the brightest areas of our scene. Have a look at both effects here:</p>
    <figure class="mediaobject"><img src="img/B21361_13_15_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.15: The default scene (left) and the same scene with a high-intensity Bloom (right)</p>
    <p class="normal">This <a id="_idIndexMarker897"/>effect is actually very common and simple, but I consider it advanced because the results are drastically affected by HDR. This effect relies on calculating the intensity of each pixel’s color to detect areas where it can be applied. In LDR, we can have a white object that isn’t overbright, but due to the limitations in this color range, Bloom may cause an overglow over it. In HDR, due to its increased color range, we can detect if an object is white or if the object is maybe light blue but just overbright, generating the illusion that it is white (such as objects near a high-intensity lamp). In <em class="italic">Figure 13.16,</em> you can see the difference between our scene with HDR and without it. You will notice that the LDR version will have overglow in areas that are not necessarily overbright. The difference may be very subtle, but pay attention to the little details to note the difference. And remember, I exaggerated the effect here. Have a look at both scenes here:</p>
    <figure class="mediaobject"><img src="img/B21361_13_16_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.16: Bloom in an LDR scene (left) and Bloom in an HDR scene (right). Notice that the Bloom settings were changed to try to approximate them as much as possible</p>
    <p class="normal">For now, let’s stick<a id="_idIndexMarker898"/> with the HDR version of the scene. In order to enable Bloom, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add the <strong class="screenText">Bloom</strong> override to the profile, as usual.</li>
      <li class="numberedList">Enable the <strong class="screenText">Intensity</strong> checkbox by checking it, and set the value to <code class="inlineCode">0.2</code>. This controls how much overglow will be applied.</li>
      <li class="numberedList">Enable <strong class="screenText">Threshold</strong> and set it to <code class="inlineCode">0.7</code>. This value indicates the minimum intensity a color needs to have to be considered for overglow. In our case, our scene is somewhat dark, so we need to reduce this value in the <strong class="screenText">Bloom</strong> effect settings to have more pixels included. As usual, those values need to be adjusted to your specific scenario.</li>
    </ol>
    <p class="normal">You will notice that the difference is very subtle, but again, remember that you will have several effects, so all those little differences will add up. You can see both effects in the following screenshots:</p>
    <figure class="mediaobject"><img src="img/B21361_13_17_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.17: Bloom effect</p>
    <p class="normal">As usual, it is<a id="_idIndexMarker899"/> recommended that you fiddle with other values. Some interesting settings I recommend you test are the <strong class="keyWord">Dirt Texture</strong> and <strong class="keyWord">Dirt Intensity</strong> values, which will simulate dirty lenses in the overglow area.</p>
    <p class="normal">Building on our understanding of Depth Maps, let’s explore another popular effect, <strong class="keyWord">Depth of Field</strong>. This one relies on the Depth Map we discussed earlier. It is not that obvious to the naked eye, but when you focus on an object within your sight, the surrounding objects become blurred because they are out of focus. We can use this to focus the attention of the player in key moments of gameplay. Think of this effect like a camera’s autofocus – it samples the Depth Map to decide what should be crisp and what should be blurred, much like focusing on an object in photography.</p>
    <p class="normal">In order to use it, do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Put the camera near a column to try to focus on a specific object, as illustrated in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_18_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.18: Camera positioning</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Add <a id="_idIndexMarker900"/>the <strong class="screenText">Depth of Field</strong> override.</li>
      <li class="numberedList">Enable and set the <strong class="screenText">Mode</strong> setting to <strong class="screenText">Gaussian</strong>: the cheapest one in terms of performance used.</li>
      <li class="numberedList">In my case, I have set <strong class="screenText">Start</strong> to <code class="inlineCode">10</code> and <strong class="screenText">End</strong> to <code class="inlineCode">20</code>, which will make the effect start at a distance behind the target object. The <strong class="screenText">End</strong> setting will control how the blur’s intensity will increase, reaching its maximum at a distance of <code class="inlineCode">20</code> meters. Remember to tweak these values to your case.</li>
      <li class="numberedList">If you want to exaggerate the effect a little bit, set <strong class="screenText">Max Radius</strong> to <code class="inlineCode">1.5</code>. The result is shown in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_19_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.19: Exaggerated effect</p>
    <p class="normal">Something to consider<a id="_idIndexMarker901"/> here is that our game will have a top-down perspective, and unlike the first-person camera where you can see distant objects, here, we will have objects near enough to not notice the effect, so we can limit the use of this effect just for cutscenes in our scenario.</p>
    <p class="normal">Now, most of the remaining effects are different ways to alter the actual colors of the scene. The idea is that the real color sometimes doesn’t give you the exact look and feel you are seeking. You may need the dark zones to be darker to reinforce the sensation of a horror ambiance, or you may want to do the opposite: increase the dark areas to represent an open scene. It could also be that you want to tint the highlights a little bit to get a neon effect if you are creating a futuristic game, or perhaps you want a sepia effect temporarily to do a flashback. We have a myriad of ways to do this, and in this case, I will use a simple but powerful effect<a id="_idIndexMarker902"/> called <strong class="keyWord">Shadows Midtones Highlights</strong>.</p>
    <p class="normal">This effect will apply different color corrections to—well—shadows, midtones, and highlights, meaning that we can modify darker, lighter, and medium areas separately. Let’s try it by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add the <strong class="screenText">Shadow Midtones Highlights</strong> override.</li>
      <li class="numberedList">Let’s start doing some testing. Check the three <strong class="screenText">Shadows</strong>, <strong class="screenText">Midtones</strong>, and <strong class="screenText">Highlights</strong> checkboxes.</li>
      <li class="numberedList">Move the <strong class="screenText">Shadows</strong> and <strong class="screenText">Midtones</strong> sliders all the way to the left and the one for <strong class="screenText">Highlights</strong> to the right. This will reduce the intensity of shadows and midtones and increase the intensity of highlights. We did this so that you can see the areas that <strong class="screenText">Highlights</strong> will alter, based on the intensity. You can do the same with the other sliders to check the other two areas. You can see the result in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_20_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.20: Isolating highlights</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Also, test<a id="_idIndexMarker903"/> moving the white circle at the center of the colored circle to apply a little bit of tinting to those areas. Reduce the intensity of the highlights by moving the slider a little bit to the left to make the tinting more noticeable. You can see the result in the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_21_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.21: Tinting highlights</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">By doing this, you can explore how those controls work, but of course, those extreme values are useful for some edge cases. In our scene, the settings you can see in the<a id="_idIndexMarker904"/> following screenshot worked best for me. As always, it is better to use subtler values to not distort the original result too much, as illustrated here:</li>
    </ol>
    <figure class="mediaobject"><img src="img/B21361_13_22.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.22: Subtle changes</p>
    <p class="normal">You can see the before-and-after effects in the following screenshots:</p>
    <figure class="mediaobject"><img src="img/B21361_13_23_PE.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 13.23: Before-and-after effects</p>
    <p class="normal">If you’re looking for something less complex than HDR, <strong class="keyWord">Split Toning</strong> offers <a id="_idIndexMarker905"/>a simpler yet effective way to play with shadows and highlights, or <strong class="keyWord">Color Curves</strong>, which give you advanced control of how each color channel of the scene will be mapped, but the idea is the same: to alter the actual color of the resulting scene to apply a specific color ambiance to your scene. If you remember the movie series <em class="italic">The Matrix</em>, when the characters were in the Matrix, everything had subtle green tinting, and while outside it, the tinting was blue.</p>
    <p class="normal">Remember that the <a id="_idIndexMarker906"/>results of using HDR and not using it regarding these effects are important, so it is better to decide sooner rather than later whether to use HDR, excluding certain target platforms (which may not be important to your target audience), or not to use it (using LDR) and have less control over your scene lighting levels.</p>
    <p class="normal">Also, take into account that maybe you will need to tweak some objects’ settings, such as light intensities and material properties, because sometimes we use post-processing to fix graphics errors that may be caused by wrongly set objects, and that’s not okay. For example, increasing the <code class="inlineCode">ambient lighting</code> in our scene will drastically change the output of the effects, and we can use that to increase the overall brightness instead of using an effect if we find the scene too dark.</p>
    <p class="normal">We’ve now covered a range of image effects. Remember, the idea is not to use every single one but to use the ones that you feel are contributing to your scene; they are not free in terms of performance (although not that resource-intensive), so use them wisely. Also, you can check for <a id="_idIndexMarker907"/>the already created profiles to apply them to your game and see how little changes can make a huge difference.</p>
    <h1 id="_idParaDest-190" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed basic and advanced full screen effects to apply in our scene, making it look more realistic in terms of camera lens effects and more stylish in terms of color distortions. We also discussed the internals of HDR and Depth Maps and how they are important when using those effects, which can immediately increase your game’s graphic quality with minimal effort.</p>
    <p class="normal">Now that we have covered most of the common graphics found in Unity systems, let’s start looking at how to increase the immersion of our scene by using sounds in the next chapter.</p>
  </div>
  <div><h1 id="_idParaDest-191" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev">https://packt.link/unitydev</a></p>
    <p class="normal"><img src="img/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>