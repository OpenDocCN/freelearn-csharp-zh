<html><head></head><body>
        

                            
                    <h1 class="header-title">Introduction to Reactive Microservices</h1>
                
            
            
                
<p class="mce-root">We have now gained a clear understanding of microservices-based architecture and how to harness its power. Up until now, we've discussed various aspects of this architecture, such as communication, deployment, and security, in detail. We also looked at how microservices collaborate when required. Now let's take the effectiveness of microservices to the next level by introducing the reactive programming aspect within them. We will cover the following topics:<br/></p>
<ul>
<li>Understanding reactive microservices</li>
<li>Mapping processes</li>
<li>Communication in reactive microservices</li>
<li>Handling security</li>
<li>Managing data</li>
<li>The microservice ecosystem</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding reactive microservices</h1>
                
            
            
                
<p>Before we dive into reactive microservices, let's see what the word <em>reactive</em> means. There are certain fundamental attributes that a piece of software must possess in order to be considered reactive. These attributes are responsiveness, resilience, elasticity, and above all, being message-driven. We'll discuss these attributes in detail and look at how they can make microservices stronger candidates for most enterprise requirements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Responsiveness</h1>
                
            
            
                
<p>It wasn't long ago when one of the key requirements of business sponsors, discussed in requirement gathering sessions, was a guaranteed response time of a few seconds. For example, a T-shirt custom print e-shop where you could upload images and then have it rendered onto the chosen piece of apparel. Move forward a few years and—I can vouch for this myself—we will close the browser window if any web page takes longer than a couple of seconds to load.</p>
<p>Users today expect near instantaneous response. But this is not possible unless the code that you write follows certain standards to deliver the expected performance. There will always be so many different components cooperating and coordinating to solve some business problem. The time that each component is expected to return the results in has therefore reduced to milliseconds today. Also, the system has to exhibit consistency along with performance when it comes to response time. If you have a service that exhibits variable response times over a defined period, then it is a sign of an impending problem in your system. You will have to, sooner or later, deal with this baggage. And there is no doubt that in most cases, you will manage to solve it.</p>
<p>However, the challenge is much bigger than what is visible on the surface. Any such trait needs to be probed for the possibility of an issue in the design. It could be some kind of dependency on another service, too many functions performing at the same time within the service, or synchronous communication blocking the workflow at some point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Resilience</h1>
                
            
            
                
<p>With all the buzz around distributed computing, what does a user expect from such a system in the event of the failure of one or more components? Does a single failure result in a catastrophic domino effect, resulting in the failure of the entire system? Or does the system bounce back from such an event with grace and within expected timelines? The end user shouldn't be affected at all in such scenarios, or the system should at least minimize the impact to an extent, ensuring that user experience is not affected.</p>
<p>Reactive microservices take the concept of microservices to the next level. As the number of microservices grows, so does the need for communication between them. It won't be very long before the task of tracking a list of a dozen other services, orchestrating a cascading transaction between them, or just generating a notification across a set of services, becomes a challenge. In the scope of this chapter, the concept of cascading is more important than the transaction itself. Instead of the transaction, it could very well be just the need to notify some external system based on some filtering criteria.</p>
<p>The challenge arises as an enterprise-level microservice-based system would always extend far beyond a handful of microservices. The sheer size and complexity of this cannot be pictured fully here in a chapter. In such a scenario, the need to track a set of microservices and communicate with them can quickly become nightmarish.</p>
<p>What if we could take away the responsibility of communicating an event to other microservices from individual microservices? The other aspect of this could very well be freedom for the services in the ecosystem from being tracked. To do this, you will have to keep track of their whereabouts. Just add authentication to this and you could very easily be tangled in a mess you never signed up for.</p>
<p>The solution lies in a design change, where the responsibility of tracking microservices for an event or communicating an event to others is taken away from individual microservices.</p>
<p>While transitioning from a monolithic application to a microservice-style architecture, we learned that they are isolated. Using seam identification, we isolated modules into independent sets of services that own their data and don't allow other microservices/processes to access them directly. We achieved autonomy by catering to a single business functionality and taking care of aspects such as its data and encapsulated business functionality. Asynchronous was another characteristic that we achieved for our microservices in order to make non-blocking calls to them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Autonomous</h1>
                
            
            
                
<p>All along, we have been strongly advocating the correct isolation of microservices. Seam identification was a concept we briefly touched on in Chapter 2, <em>Implementing Microservices</em>. There were numerous benefits that we derived while successfully implementing the microservice-style architecture. We can safely state that isolation is one of the fundamental requirements here. However, the benefits of successful implementation of isolation go far beyond that.</p>
<p>It is very important for microservices to be autonomous, or else our work will be incomplete. Even after implementing the microservice architecture, if one microservice failure results in a delay for other services or a domino effect, it means we missed something in our design. However, if microservice isolation is done right, along with the right breakdown of the functionality to be performed by this particular microservice, it would mean that the rest of the design would fall into place itself to handle any kind of resolution conflict, communication, or coordination.</p>
<p>The information required to perform such an orchestration would depend primarily on the well-defined behavior of the service itself. So, the consumer of a microservice that is well-defined doesn't need to worry about the microservice failing or throwing an exception. If there is no response within the stipulated period of time, just try again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message-driven: a core of reactive microservices</h1>
                
            
            
                
<p>Being message-driven is the core of reactive microservices. All reactive microservices define, as part of their behavior, any event that they might be generating. These events may or may not have additional information payloads within them, depending on the design of the individual event. The microservice that is the generator of this event would not be bothered about whether the event generated was acted upon or not. Within the scope of this specific service, there is no behavioral definition for the action beyond the generation of this event. The scope ends there. It is now, in terms of the rest of the system, comprising other microservices to act upon this information based on their individual scope.</p>
<p>The difference here is that all these events being generated could be captured asynchronously by listening to them. No other service is waiting in blocking mode for any of these services. Anyone listening to these events is called a subscriber, and the action of listening for the events is called subscribing. The services that subscribe to these events are called <strong>observers</strong>, and the source service of the events generated is called <strong>observable</strong>. This pattern is known as the <strong>Observer Design Pattern</strong>.</p>
<p>However, the very exercise of a concrete implementation on each of the observers is somewhat inconsistent with our motto of designing loosely coupled microservices. If this is what you are thinking, then you have the right thinking cap on and we are on the right track. In a short while, when mapping our processes as reactive microservices, we will see how we can achieve this purpose in the world of reactive microservices.</p>
<p>Before we go on with mapping our processes, it is important that we briefly discuss the pattern with respect to our topic here. In order to act upon a message, you first need to show your intent to watch the message of that type. At the same time, the originator of the message must have an intent to publish such a message to the interested observers. So there would be at least one observable to be observed by one or more observers. To add some spice to it, the observable can publish more than one type of message, and the observers can observe one or more of the messages they intend to act upon.</p>
<p>The pattern doesn't restrict observers from unsubscribing when they want to stop listening for these messages. So, it sounds pretty, but is it as easily implemented? Let's move ahead and look at this for ourselves.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Let's make code reactive</h1>
                
            
            
                
<p>Let's examine our application and see how it would look with the reactive style of programming. The following diagram depicts the flow of the application that is reactive in nature and is completely event-driven. In this diagram, services are depicted by hexagons, and events are represented by square boxes. Here's the entire flow in detail:</p>
<div><img class="image-border" height="264" src="img/d6ac2cf0-9c5d-4f19-b41c-08ee4fc70e68.png" width="263"/></div>
<p>The flow depicted in the diagram describes the scenario of a customer placing an order after having searched for the items he/she is looking for. The <strong>Place order</strong> event is raised to <strong>Order service</strong>. In response to this event, our service analyzes arguments, such as order item and quantity, and raises the <strong>Item </strong>available event to <strong>Product service</strong>. From here on, there are two possible outcomes: either the requested product is available and has the required quantity or it is not available or doesn't have the required quantity. If the items are available, <strong>Product service</strong> raises an event called generate invoice to <strong>Invoice service</strong>. Since raising the invoice means confirming the order, the items on the invoice would no longer be available in stock; we need to take care of this and update the stock accordingly. To handle this, our invoice service further raises an event called <strong>Update Product Quantity</strong> to <strong>Product service</strong> and takes care of this requirement. For the sake of simplicity, we will not go into the details of who will handle the event of <strong>Mail invoice</strong>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Event communication</h1>
                
            
            
                
<p>The preceding discussion may have left you thinking about how the event being raised maps the call of the respective microservice perfectly; let's discuss this in further detail. Think of all the events being raised as being stored in an event store. The event stored has an associated delegate function that is called to cater to the respective event. Although it is shown that the store has just two columns, it stores much more information, such as details of the publisher, subscriber, and so on. Each event contains the complete information that is required to trigger the corresponding service. So event delegation might be a service to be called or a function within the application itself. It doesn't matter to this architecture:</p>
<div><img height="141" src="img/29962310-822b-4399-9140-311aacc3da72.jpg" width="176"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Security</h1>
                
            
            
                
<p>There are numerous ways in which security can be handled while implementing reactive microservices. However, given the limited scope that we have here, we will restrict our discussion to one type only. Let's go on and discuss message-level security here and see how it is done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Message-level security</h1>
                
            
            
                
<p>Message-level security is the most fundamental method available to secure your individual request messages. After the initial authentication is performed, the request message itself may contain the OAuth bearer token or the JWTs, based on the implementation. This way, each and every request is authenticated, and the information related to the user can be embedded within these tokens. The information could be as simple as a username along with an expiration timestamp indicating token validity. After all, we don't want to allow a token to be utilized beyond a certain time frame.</p>
<p>However, it is important to note here that you are free to implement it in such a manner so that a lot more information can be embedded and utilized for different uses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scalability</h1>
                
            
            
                
<p>There is another aspect you need to consider here as well. Within this token, we could also embed authorization information apart from authentication information. Note that having all of this information within a token that is being passed around frequently could soon become an overhead. We can make the necessary changes to ensure that the information pertaining to the authorization is a one-time activity and is later persisted with the services as required.</p>
<p>When we decide to persist authorization-related information with individual services, we make them elastic in a way. The task of persisting authorization information with individual services does away with the requirement of reaching out to the authentication service each time for authorization-related data. This means we can scale our services quite easily.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication resilience</h1>
                
            
            
                
<p>What would happen if the authentication service that contains all the user authentication data and authorization data became unavailable? Does this mean that the entire microservice ecosystem would come down to its knees, as all the actions—or a big percentage of them—would need to be authorized for the user attempting the action? This does not fit in the domain of the microservice architecture. Let's see how we could deal with this.</p>
<p>One way would be to replicate user authorization data within each service that requires it. When the authorization data is already available with the respective services, it will reduce the data being transferred through the JWTs being moved around. What this would achieve is that in the event our Auth service becomes unavailable, the users who are authenticated and have accessed the system would not be affected. With all of the authorization data already available within the individual services that need to verify it, the business can continue as usual without any hindrances.</p>
<p>However, this approach comes with a price of its own. It will become a challenge to maintain this data, as it is updated all the time with all the services. The replication required for each service would be an exercise in itself. There is a way out of this specific challenge as well, though.</p>
<p>Instead of making this data available in all the microservices, we could simply store it in a central store and have the services validate/access authorization-related data from this central store. This would enable us to build resilience beyond the authentication service.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing data</h1>
                
            
            
                
<p>Tracking a single order being placed is easy. However, multiply that number with the million orders being placed and canceled every hour; it could quickly become a challenge in the reactive microservices domain. The challenge is how you would perform a transaction across multiple services. Not only is it difficult to track such a transaction, but it poses other challenges, such as persisting such a transaction that spans the database and message broker. The task of reversing such an operation in the likelihood of the transaction breaking somewhere in the middle due to a service failure could be even more daunting.</p>
<p>In such a scenario, we can utilize the event sourcing pattern. This is a strong candidate, especially since we are not looking for a two-phase commit, generally referred to as 2PC. Instead of storing a transaction, we persist all the state-changing events of our entities. In other words, we store all the events that change their states in the form of entities, such as order and product. When a client places an order, then under regular circumstances, we would persist the order to the order table as a row. However, here we will persist the entire sequence of events, up to the final stage of the order being accepted or rejected.</p>
<p>Refer to the preceding diagram, where we analyzed the sequence of events that are generated while creating an order. Look at how those events will be stored in this pattern and how a transaction would be deduced from that set of events. First, let's see how the data will be stored. As seen in the following diagram, individual records are saved as rows. Data consistency is confirmed after the transaction:</p>
<div><img class="image-border" height="229" src="img/ca2d4397-ca55-4e7f-885a-13b3b13361e1.png" width="228"/></div>
<p>As seen in the preceding diagram, the <strong>Product service</strong> can subscribe to the order events and update itself accordingly. There are numerous benefits to be derived from this approach, such as:</p>
<ul>
<li>Since the events are being persisted, the challenge of recognizing a transaction is separated from the task of maintaining database integrity</li>
<li>It is possible to find the exact state of the system at any given point in time</li>
<li>It is easier to migrate a monolith with this approach</li>
<li>It is possible to move back in time to a specific set of events and identify any possible problems</li>
</ul>
<p>The following image is depicting our <strong>Order</strong> and <strong>Order Details</strong> table(s) in view of <strong>Order service</strong>:</p>
<div><img height="167" src="img/8cc3dc4a-12d7-43fe-9d19-86f35c3706be.png" width="253"/></div>
<p>Apart from all the benefits, it has some drawbacks as well. The most important one is how to query the event store. To reconstruct the state of a given business entity at a given point in time would require some complex queries. Apart from this, there would be a learning curve involved to grasp the concept of an event store replacing the database and then deducing the state of an entity. Query complexity can be handled with the help of the CQRS pattern easily. However, this will be outside the scope of this chapter. It is worthwhile to note that the event sourcing pattern and CQRS deserve separate chapters in the wake of reactive microservices.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The microservice ecosystem</h1>
                
            
            
                
<p>As discussed in the initial chapters, we need to get ready for big changes when embracing microservices. The discussions we've presented on deployment, security, and testing so far would have had you thinking by now about accepting this fact. Unlike monoliths, the adoption of microservices requires you to prepare beforehand so that you start building the infrastructure along with it and not after it. In a way, microservices thrive in a complete ecosystem where everything is worked out, from deployment to testing, security, and monitoring. The returns associated with embracing such a change are huge. There is definitely a cost involved to make all these changes. However, instead of having a product that doesn't get on the market, it is better to incur some costs and design and develop something that thrives and does not die out after the first few rollouts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coding reactive microservices</h1>
                
            
            
                
<p>Now, let's try to sum up everything and see how it actually looks in the code. We will use Visual Studio 2017 for this. The first step is to create a reactive microservice, and then we will move onto creating a client for consuming the service created by us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the project</h1>
                
            
            
                
<p>We will now go ahead and create our reactive microservice example. In order to do this, we need to create a project of the ASP.NET web application type. Just follow these steps and you should be able to see your first reactive microservice in action:</p>
<ol>
<li>Start Visual Studio.</li>
<li>Create a new project by navigating to File | New | Project.</li>
<li>From the installed templates, select .NET Core | ASP.NET Core Web Application.</li>
<li>Name it <kbd>FlixOne.BookStore.ProductService</kbd> and click on OK:</li>
</ol>
<div><img height="436" src="img/b057fc3c-85ba-40a0-b9f7-51641480ac89.png" width="714"/></div>
<ol start="5">
<li>From the New ASP.NET Core Web Application screen, select .NET Core and ASP.NET Core 2.0 and then select Web Application (Model-View-Controller) and click on OK:</li>
</ol>
<div><img height="409" src="img/8cf49cfa-2873-4e9f-b57f-01422029d466.png" width="625"/></div>
<p>You can enable Docker support for Windows if you enable the container.</p>
<ol start="6">
<li>Make sure you have selected C#7.1; to do so, right-click on the project from the solution explorer and click on Properties. From the project properties screen, click on the Build tab and then scroll down to Advance. Click on Advance, and then select C# 7.1:</li>
</ol>
<div><img src="img/fbc7aaf8-5dc7-4167-965c-ebf0b885a8b7.png"/></div>
<ol start="7">
<li>Open NuGet Manager and add the System.Reactive.Core NuGet package to the project. Make sure you select Include prerelease on the screen:</li>
</ol>
<div><img src="img/fad91898-4d26-4241-bd49-8e5f128706c0.png"/></div>
<p>You are also required to add a package for EF core; to do so, refer to the <em>EF Core migrations</em> section in Chapter 2, <em>Implementing Microservices</em>.</p>
<ol start="8">
<li>Add the <kbd>Product.cs</kbd> model to the <kbd>Models</kbd> folder with the following code:</li>
</ol>
<pre style="padding-left: 60px">namespace FlixOne.BookStore.ProductService.Models<br/>{<br/>  public class Product<br/>  {<br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public string Image { get; set; }<br/>    public decimal Price { get; set; }<br/>    public Guid CategoryId { get; set; }<br/>    public virtual Category Category { get; set; }<br/>  }<br/>}</pre>
<ol start="9">
<li>Add the <kbd>Category.cs</kbd> model to the <kbd>Models</kbd> folder with the following code:</li>
</ol>
<pre style="padding-left: 60px">namespace FlixOne.BookStore.ProductService.Models<br/>{<br/>  public class Category<br/>  {<br/>    public Category() =&gt; Products = new List&lt;Product&gt;();<br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public IEnumerable&lt;Product&gt; Products { get; set; }<br/>  }<br/>}</pre>
<ol start="10">
<li>Add <kbd>context</kbd> and <kbd>persistence</kbd> folders to the project. Add <kbd>ProductContext</kbd> to the <kbd>context</kbd> folder, and add the <kbd>IProductRepository</kbd> interface and the <kbd>ProductRepository</kbd> class to the <kbd>persistence</kbd> folder.</li>
</ol>
<p>Consider the following code snippet, showing our context and persistence classes:</p>
<pre>namespace FlixOne.BookStore.ProductService.Contexts<br/>{<br/>  public class ProductContext : DbContext<br/>  {<br/>    public ProductContext(DbContextOptions&lt;ProductContext&gt; options)<br/>    : base(options)<br/>    { }<br/>    public ProductContext()<br/>    { }<br/>    public DbSet&lt;Product&gt; Products { get; set; }<br/>    public DbSet&lt;Category&gt; Categories { get; set; }<br/>  }<br/>}<br/>//Persistence or repositories, following is the interface<br/>namespace FlixOne.BookStore.ProductService.Persistence<br/>{<br/>  public interface IProductRepository<br/>  {<br/>    IObservable&lt;IEnumerable&lt;Product&gt;&gt; GetAll();<br/>    IObservable&lt;IEnumerable&lt;Product&gt;&gt; GetAll(IScheduler scheduler);<br/>    IObservable&lt;Unit&gt; Remove(Guid productId);<br/>    IObservable&lt;Unit&gt; Remove(Guid productId, IScheduler scheduler);<br/>  }<br/>}<br/>//ProductRepository class that implements the IProductRepository interface<br/>namespace FlixOne.BookStore.ProductService.Persistence<br/>{<br/>  public class ProductRepository : IProductRepository<br/>  {<br/>    private readonly ProductContext _context;<br/>    public ProductRepository(ProductContext context)<br/>    =&gt; _context = context;<br/>    public IObservable&lt;IEnumerable&lt;Product&gt;&gt; <br/>    GetAll() =&gt; Observable.Return(GetProducts());<br/>    public IObservable&lt;IEnumerable&lt;Product&gt;&gt;<br/>    GetAll(IScheduler scheduler) =&gt; <br/>    Observable.Return(GetProducts(), scheduler);<br/>    public IObservable&lt;Unit&gt; Remove(Guid productId) =&gt;<br/>    Remove(productId, null);<br/>    public IObservable&lt;Unit&gt; Remove(Guid productId,<br/>    IScheduler scheduler)<br/>    {<br/>      DeleteProduct(productId);<br/>      return scheduler != null<br/>      ? Observable.Return(new Unit(), scheduler)<br/>      : Observable.Return(new Unit());<br/>    }<br/>    private IEnumerable&lt;Product&gt; GetProducts()<br/>    {<br/>      var products = (from p in _context.Products.<br/>      Include(p =&gt; p.Category)<br/>      orderby p.Name<br/>      select p).ToList();<br/>      return products;<br/>    }<br/>    private Product GetBy(Guid id) =&gt; GetProducts().<br/>    FirstOrDefault(x =&gt; x.Id == id);<br/>    private void DeleteProduct(Guid productId)<br/>    {<br/>      var product = GetBy(productId);<br/>      _context.Entry(product).State = EntityState.Deleted;<br/>      _context.SaveChanges();<br/>    }<br/>  }<br/>}</pre>
<p>We have created our models. Our next step is to add the code for interacting with the database. These models help us project data from a data source into our models.</p>
<p>For database interaction, we have already created a context, namely <kbd>ProductContext</kbd>, deriving it from <kbd>DbContext</kbd>. In one of the preceding steps, we created a folder named <kbd>Context</kbd>.</p>
<p>The Entity Framework Core context helps query the database. Also, it helps us collate all the changes that we perform on our data and execute them on the database in one go. We will not go into detail about Entity Framework Core or the contexts here, because they are not part of the scope of this chapter.</p>
<p>The context picks the connection string from the <kbd>appsettings.json</kbd> file in the <kbd>connectionStrings</kbd> section—a key named <kbd>ProductConnectionString</kbd>. </p>
<p>You are required to update the <kbd>startup.cs</kbd> file to make sure you're using a correct database. We have already discussed modifying the <kbd>appsettings.json</kbd> and <kbd>Statrup.cs</kbd> files in <a href="047f5d0b-a008-48e2-9c7f-c57c16e671f9.xhtml">Chapter 2</a>, <em>Implement Microservices</em>. You need to add the <kbd>Swashbuckle.AspNetCore</kbd> NuGet package for Swagger support in the project while updating the <kbd>Startup.cs</kbd> class.</p>
<p>You could name it anything shown in the following code snippet:</p>
<pre> "ConnectionStrings": <br/> {<br/>   "ProductConnection": "Data Source=.;Initial<br/>   Catalog=ProductsDB;Integrated  <br/>   Security=True;MultipleActiveResultSets=True"<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication between the application and the database</h1>
                
            
            
                
<p>With our context in place, and taking care of the communication between our application and the database, let's go ahead and add a repository for facilitating interaction between our data models and our database. Please refer to the code for our repository, as discussed in step 10 of the <em>Creating the project</em> section.</p>
<p>Marking our result from <kbd>GetAll</kbd> as <kbd>IObservable</kbd> adds the reactive functionality we are looking for. Also, pay special attention to the return statement.</p>
<p>With this observable model, it becomes possible for us to handle streams of asynchronous events with the same ease we are used to when handling other, simpler collections:</p>
<pre> return Observable.Return(GetProducts());</pre>
<p>We are now ready to expose the functionality through our controllers. Right-click on the folder controller, click on Add New Item, and then select ASP.NET Core, Web API Controller class. Name it <kbd>ProductController</kbd>:</p>
<div><img height="411" src="img/247eb9fe-30fa-454b-9f67-d32fb4b55410.png" width="670"/></div>
<p>Here is what our controller will look like:</p>
<pre style="padding-left: 30px">namespace FlixOne.BookStore.ProductService.Controllers<br/>{<br/>  [Route("api/[controller]")]<br/>  public class ProductController : Controller<br/>  {<br/>    private readonly IProductRepository _productRepository;<br/>    public ProductController() =&gt; _productRepository =<br/>    new ProductRepository(new ProductContext());<br/>    public ProductController(IProductRepository <br/>    productRepository) =&gt; _productRepository = <br/>    productRepository;<br/>    [HttpGet]<br/>    public async Task&lt;IEnumerable&lt;Product&gt;&gt; Get() =&gt;<br/>    await _productRepository.GetAll().SelectMany(p =&gt; p).ToArray();<br/>  }<br/>}</pre>
<p>The final structure looks similar to the following screenshot of the Solution explorer:</p>
<div><img height="369" src="img/96684d1a-efe5-41b0-96b2-e6c1984d3245.png" width="286"/></div>
<p>To create the database, you can refer to the <em>EF Core migrations</em> section in Chapter 2, <em>Implementing Microservices</em>, or simply call the Get API of our newly deployed service. When the service finds out that the database doesn't exist, the entity framework core code-first approach, in this case, will ensure that the database is created.</p>
<p>We can now go ahead and deploy this service to our client. With our reactive microservice deployed, we now need a client to call it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Client – coding it down</h1>
                
            
            
                
<p>We will create a web client for consuming our newly deployed reactive microservice with the help of AutoRest. Let's create a console application for it and add these NuGet packages: <kbd>Reactive.Core</kbd>, <kbd>WebApi.Client</kbd>, <kbd>Microsoft.Rest.ClientRuntime</kbd>, and <kbd>Newtonsoft.Json</kbd>:</p>
<ol>
<li>AutoRest will add a folder named <kbd>Models</kbd> to the main project and create copies of the model's product and category, as in the service that we just created. It will have the necessary deserialization support built into it.</li>
<li><kbd>ProductOperations.cs</kbd> and <kbd>ProductServiceClient.cs</kbd> contain the main plumbing required for all the calling.</li>
<li>In the <kbd>Main</kbd> function of the <kbd>Program.cs</kbd> file, change the <kbd>Main</kbd> function as follows:</li>
</ol>
<pre style="padding-left: 60px"> static void Main(string[] args)<br/> {<br/>   var client = new ProductServiceClient {BaseUri = <br/>   new Uri("http://localhost:22651/")};<br/>   var products = client.Product.Get();<br/>   Console.WriteLine($"Total count {products.Count}");<br/>   foreach (var product in products)<br/>   {<br/>     Console.WriteLine($"ProductId:{product.Id},Name:<br/>     {product.Name}");<br/>   }<br/>   Console.Write("Press any key to continue ....");<br/>   Console.ReadLine();<br/> }  </pre>
<p>At this point, if the database is not created, then it will be created as required by the Entity Framework.</p>
<p>We need to know how this list, which is returned from our microservice, differs from the regular list. The answer is that if this were a non-reactive scenario and you were to make any changes to the list, it would not be reflected in the server. In the case of reactive microservices, changes that are made to such a list would be persisted to the server without having to go through the process of tracking and updating the changes manually.</p>
<p>You can use any other client to make the Web API call (for example, RestSharp, or HttpClient).</p>
<p>You may have noticed that we had to do very little or no work at all when it came to messy callbacks. This helps keep our code clean and easier to maintain. With an observable, it is the producer that pushes the values when they are available. Also, there is a difference here that the client is not aware of: whether your implementation is blocking or non-blocking. To the client, it all seems asynchronous.</p>
<p>You can now focus on important tasks rather than figuring out what calls to make next or which ones you missed altogether.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we added the aspect of reactive programming to our microservice-based architecture. There are trade-offs with this message-driven approach of microservices communicating with each other. However, at the same time, this approach tends to solve some of the fundamental problems when we advance our microservice architecture further. The event sourcing pattern comes to our rescue and lets us get past the limitation of an ACID transaction or a two-phase commit option. This topic requires a separate book altogether, and restricting it to a single chapter does not do it justice. We used our sample application to understand how to restructure our initial microservice in a reactive way.</p>
<p>In the next chapter, we will have the entire application ready for us to explore, and we will put together everything that we have discussed so far in this book.</p>


            

            
        
    </body></html>