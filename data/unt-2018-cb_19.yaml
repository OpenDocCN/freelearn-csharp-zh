- en: Automated Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Generating and running a default test script class
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和运行默认测试脚本类
- en: Performing a simple unit test
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个简单的单元测试
- en: Parameterizing tests with a data provider method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据提供者方法参数化测试
- en: Unit testing a simple health script class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试一个简单的健康脚本类
- en: Creating and executing a unit test in PlayMode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PlayMode中创建和执行单元测试
- en: PlayMode testing a door animation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PlayMode中测试门动画
- en: PlayMode and unit testing a player health bar with events, logging, and exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件、日志和异常在PlayMode测试玩家健康条
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'For a very simple computer program, we can write code, then run it, entering
    a variety of valid and invalid data, and see whether the program behaves as we
    expect it to. This is known as a code-then-test approach. However, this approach
    has several significant weaknesses:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常简单的计算机程序，我们可以编写代码，然后运行它，输入各种有效和无效的数据，看看程序是否按预期运行。这被称为先编码后测试的方法。然而，这种方法有几个显著的弱点：
- en: Each time we change the code, as well as running new tests relating to the code
    we are improving, we have to run all the old tests to ensure that no unexpected
    modified behaviors have been introduced (in other words, our new code has not
    **broken** another part of our program)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们更改代码，以及运行与我们要改进的代码相关的新测试时，我们必须运行所有旧测试，以确保没有引入意外的修改行为（换句话说，我们的新代码没有**破坏**程序的其他部分）
- en: Running tests manually is time consuming
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动运行测试很耗时
- en: We are relying on a human to rerun the test each time, and this test may be
    run using different data, or some data may be omitted, or different team members
    may take a different approach to running tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们依赖于人类在每次重新运行测试，而这个测试可能使用不同的数据，或者可能省略某些数据，或者不同的团队成员可能采取不同的测试方法
- en: Therefore, even for simple programs (and most are not simple), some kind of
    fast, automated testing system makes a lot of sense.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使是简单的程序（大多数都不是简单的），某种快速、自动化的测试系统也很有意义。
- en: The big picture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体图景
- en: There is an approach to software development called **Test-Driven Development**
    (**TDD**), whereby code is **only** written until all tests pass. So, if we want
    to add or improve the behavior of our game program, we must specify what we want
    in terms of tests, and then the programmers write code to pass the tests. This
    avoids a situation whereby programmers write code and features that are not needed,
    or spend time over-optimizing things that would have been fine, and so on. It
    means that the game development team directs its work toward agreed goals understood
    by all, since they have been specified as tests.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种软件开发方法称为**测试驱动开发**（**TDD**），其中代码只有在所有测试通过后才会编写。因此，如果我们想添加或改进游戏程序的行为，我们必须以测试的形式指定我们想要的内容，然后程序员编写代码以通过测试。这避免了程序员编写不需要的代码或特征，或者花费时间过度优化本来可以过得去的事情等情况。这意味着游戏开发团队将工作方向指向所有成员都理解的目标，因为这些目标已经被指定为测试。
- en: 'The following diagram illustrates basic TDD in that we only write code until
    all tests pass. Then it''s time to write more tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了基本的TDD，即我们只编写代码直到所有测试通过。然后是编写更多测试的时间：
- en: '![](img/c9ca918d-641c-4ed7-adae-842e174b6676.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9ca918d-641c-4ed7-adae-842e174b6676.png)'
- en: 'Another way that TDD is often summarized is as red-green-refactor:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）经常被总结为红-绿-重构：
- en: '**red:** We write code that fails the test (in other words, for the new feature/improved
    behavior we wish to add to our system)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：我们编写会失败测试的代码（换句话说，对于我们希望添加到系统中或改进的新功能/行为）'
- en: '**green:** We write code that passes the new test (and all the existing ones)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：我们编写通过新测试（以及所有现有测试）的代码'
- en: '**refactor:** We (may) choose to improve the code (and ensure that the improved
    code passes all the tests)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：我们（可能）选择改进代码（并确保改进后的代码通过所有测试）'
- en: 'Two kinds of software test are the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种软件测试类型如下：
- en: '**Unit tests**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**'
- en: '**Integration tests**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**'
- en: Unit tests
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: A **Unit Test** tests a "unit" of code, which can be a single method, but which
    may include some other computer work being executed between the method being tested
    and the end result(s) being checked.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**测试代码的“单元”，这可能是一个单独的方法，但也可能包括在测试的方法和检查最终结果之间执行的一些其他计算机工作。'
- en: '*"A unit test is a piece of code that invokes a unit of work and checks one
    specific end result of that unit of work. If the assumptions on the end result
    turn out to be wrong, the unit test has failed*."'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “单元测试是一段代码，它调用一个工作单元并检查该工作单元的一个特定结果。如果对最终结果的假设被证明是错误的，则单元测试失败。”
- en: —Roy Oshergrove (p. 5, *The Art of Unit Testing* (Second edition).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ——罗伊·奥舍格罗夫（第5页，《单元测试的艺术》（第二版）。
- en: 'Unit tests should be as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该是这样的：
- en: automated (runnable at the "push of a button")
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化（一键运行）
- en: fast
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速
- en: easy to implement
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易实现
- en: easy to read
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易阅读
- en: executed in isolation (tests should be independent from one another)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立执行（测试应相互独立）
- en: assessed as either having being passed or failed
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被评估为通过或失败
- en: relevant tomorrow
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关内容将在明天
- en: consistent (the same results each time!)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致（每次都得到相同的结果！）
- en: able to easily pinpoint what was at fault for each test that fails
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易确定每个失败的测试中出了什么问题
- en: 'Most computer languages have an xUnit unit testing system available, for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机语言都提供了 xUnit 单元测试系统，例如：
- en: 'C#: NUnit'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'C#: NUnit'
- en: Java: JUnit
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Java: JUnit'
- en: 'PHP: PHPUnit'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'PHP: PHPUnit'
- en: Unity offers an easy way to write and execute NUnit tests in its editor (and
    at the command line).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一种简单的方法在编辑器中（以及在命令行）编写和执行 NUnit 测试。
- en: 'Typically, each unit test will be written in three sections, a sequence of:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个单元测试都会分为三个部分，一个序列：
- en: '**Arrange**: Set any initial values needed (sometimes, we are just giving a
    value to a variable in order to improve code readability)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：设置任何需要的初始值（有时，我们只是给一个变量赋值以提高代码可读性）'
- en: '**Act**: Invoke some code (and, if appropriate, store the results)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行动**：调用一些代码（如果适当，存储结果）'
- en: '**Assert**: Make assertions for what should be true about the code invoked
    (and any stored results)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：对被调用的代码（以及任何存储的结果）进行断言'
- en: Observe that the naming of a unit test method (by convention) is quite verbose—it
    is made up of lots of words that describe what it does. For example, you might
    have a unit test method named `TestHealthNotGoAboveOne()`. The idea is that if
    a test fails, the name of the test should give a programmer a very good idea of
    what behavior is being tested and, therefore, how to quickly establish whether
    the test is correct and, if so, where to look in your program code for what was
    being tested. Another part of the convention of naming unit tests is that numerals
    are not used—ust words—so we write "one", "two", and so on, in the name of the
    test method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到单元测试方法的命名（按照惯例）相当冗长——它由许多描述其功能的单词组成。例如，你可能有一个名为`TestHealthNotGoAboveOne()`的单元测试方法。其理念是，如果测试失败，测试的名称应该给程序员一个非常好的关于正在测试的行为的想法，因此可以快速确定测试是否正确，如果正确，则在程序代码中查找被测试的内容。单元测试命名的另一个惯例是不使用数字——只使用单词——因此我们在测试方法的名称中写“一”、“二”等等。
- en: Integration tests (PlayMode tests in Unity)
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试（Unity 中的 PlayMode 测试）
- en: An **Integration Test** involves checking the behavior of interacting software
    components, for example, ones that use real time, or a real filesystem, or that
    communicate with the web or other applications running on the computer. Integration
    tests are usually not as fast as unit tests, and may not produce consistent results
    (since the components may interact in different ways at different times).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**涉及检查交互式软件组件的行为，例如，使用实时、真实文件系统或与网络或其他在计算机上运行的应用程序通信的组件。集成测试通常不如单元测试快，并且可能不会产生一致的结果（因为组件可能在不同的时间以不同的方式交互）。'
- en: Both **Unit** and **Integration Test** are important, but they are different
    and should be treated differently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**和**集成测试**都很重要，但它们是不同的，应该被不同地对待。'
- en: Unity offers **Play Mode** testing, allowing integration testing as Unity scenes
    execute with testing code in them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了**Play Mode**测试，允许在 Unity 场景执行时进行集成测试。
- en: 'Places where you can learn more about Unity Testing include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以了解更多关于 Unity 测试的地方包括以下：
- en: 'Unity Test Runner and PlayMode documentation pages:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Test Runner 和 PlayMode 文档页面：
- en: '[https://docs.unity3d.com/Manual/testing-editortestsrunner.html](https://docs.unity3d.com/Manual/testing-editortestsrunner.html)'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/testing-editortestsrunner.html](https://docs.unity3d.com/Manual/testing-editortestsrunner.html)'
- en: '[https://docs.unity3d.com/Manual/PlaymodeTestFramework.html](https://docs.unity3d.com/Manual/PlaymodeTestFramework.html)'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/Manual/PlaymodeTestFramework.html](https://docs.unity3d.com/Manual/PlaymodeTestFramework.html)'
- en: 'A website for the book "The Art of Unit Testing" (and lots of other learning
    resources associated with testing): [http://artofunittesting.com/](http://artofunittesting.com/)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “单元测试的艺术”书籍的网站（以及与测试相关的许多其他学习资源）：[http://artofunittesting.com/](http://artofunittesting.com/)
- en: 'A great dual article tutorial about Unity testing by Tomek Paszek of Unity
    (talking about the old Unity test tools, but most of the content is still very
    relevant): [https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/](https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇关于Unity测试的精彩双篇文章教程，由Unity的Tomek Paszek撰写（讨论的是旧的Unity测试工具，但大部分内容仍然非常相关）：[https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/](https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/)
- en: 'YouTube, where you can learn lots about Unity testing (and other topics) from
    Infalliblecode: [https://www.youtube.com/infalliblecode](https://www.youtube.com/infalliblecode)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YouTube，你可以从Infalliblecode那里学到很多关于Unity测试（以及其他主题）的知识：[https://www.youtube.com/infalliblecode](https://www.youtube.com/infalliblecode)
- en: 'CodeProject.com''s introduction to TDD and NUnit: [https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD](https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeProject.com对TDD和NUnit的介绍：[https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD](https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD)
- en: Generating a default test script class
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成默认测试脚本类
- en: 'Unity can create a default C# test script for you, thereby enabling you to
    quickly start creating and executing tests on your project:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Unity可以为你创建一个默认的C#测试脚本，从而让你能够快速开始创建和执行项目中的测试：
- en: '![](img/ae577c7a-a58a-4000-9eda-6f93e1110c47.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ae577c7a-a58a-4000-9eda-6f93e1110c47.png)'
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To generate a default test script class, follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成默认测试脚本类，请按照以下步骤操作：
- en: In the Project panel, create a folder called Editor
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为“Editor”的文件夹
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单显示测试运行器面板：窗口 | 通用 | 测试运行器
- en: Ensure that the EditMode button is selected in the Test Runner panel
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选中了“编辑模式”按钮
- en: Ensure that your new Editor folder is selected in the Project panel
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选中了你的新编辑器文件夹
- en: In the Test Runner panel, click the Create Test Script in the current folder button
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击当前文件夹中的“创建测试脚本”按钮
- en: You should now have a new C# script added to your Editor folder
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该在编辑器文件夹中添加了一个新的C#脚本
- en: To run the tests in your script class, click the Run All button in the Test
    Running panel
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在脚本类中运行测试，请点击测试运行面板中的“运行所有”按钮
- en: You should now see all green ticks (check marks) in the panel
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在应该能在面板中看到所有的绿色勾号（勾选）
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Unity checks that you have a folder named Editor selected in the Project panel,
    and then creates a C# NewTestScript script class for you containing the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Unity会检查你在项目面板中是否选中了名为“编辑器”的文件夹，然后为你创建一个包含以下内容的C# NewTestScript脚本类：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the Test Runner panel, you should see the script class and its two methods
    listed. Note that the first line in the Test Runner panel is the Unity project
    name, the second line will say `Assembly-CSharp-Editor.dll`, followed by your
    script class name, and then each of the test methods:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，你应该能看到脚本类及其两个方法列出。注意，测试运行器面板的第一行是Unity项目名称，第二行将显示`Assembly-CSharp-Editor.dll`，然后是你的脚本类名称，然后是每个测试方法：
- en: '![](img/f7fcf6a3-c7ad-4c50-849a-b3f16d5e0203.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7fcf6a3-c7ad-4c50-849a-b3f16d5e0203.png)'
- en: 'There are three symbols to indicate the status of each test/class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试/类的状态都有三个符号表示：
- en: '**Empty circle**: Test not executed since the script class was last changed'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空圆圈**：自脚本类上次更改以来未执行测试'
- en: '**Green tick** (check mark): The test was passed successfully'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色勾号**（勾选）：测试成功通过'
- en: '**Red cross**: The test was failed'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红十字会**：测试未通过'
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some details that you won't want to miss.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你不想错过的细节。
- en: Create a default test script from the Project panel's Create menu
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从项目面板的创建菜单创建默认测试脚本
- en: 'Another way of creating a default Unit Test script is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建默认单元测试脚本的其他方法如下：
- en: 'From the Project panel, chose the following menu: Create | Testing | C# Test
    Script'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从项目面板中选择以下菜单：创建 | 测试 | C# 测试脚本
- en: Edit mode minimum skeleton unit test script
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑模式最小单元测试脚本框架
- en: 'Be aware that if you are only going to use this script class for testing in
    EditMode, you can delete the second method and some of the using statements as
    follows, so as to give you a minimal skeleton to work from:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您只打算使用此脚本类在 EditMode 中进行测试，您可以删除第二个方法和一些使用语句，如下所示，以便为您提供一个最小的工作框架：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A simple unit test
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的单元测试
- en: 'In the same way as printing "hello world" is most programmers first program
    statement, asserting that 1 + 1 = 2 is perhaps the most common first test executed
    for those learning unit testing. That''s what we''ll create in this recipe:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像打印 "hello world" 是大多数程序员的第一条程序语句一样，断言 1 + 1 = 2 可能是那些学习单元测试的人执行的最常见的第一个测试。这就是我们在本食谱中要创建的内容：
- en: '![](img/d6ba1b96-51a1-42fc-9439-6619d61ecd02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6ba1b96-51a1-42fc-9439-6619d61ecd02.png)'
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create and execute a simple unit test, follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和执行一个简单的单元测试，请按照以下步骤操作：
- en: In the Project panel, create a folder called Editor.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为 Editor 的文件夹。
- en: 'Inside your Editor folder, create a new C# `SimpleTester.cs` script class containing
    the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器文件夹中，创建一个新的C# `SimpleTester.cs` 脚本类，包含以下内容：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单显示测试运行器面板：窗口 | 通用 | 测试运行器。
- en: Ensure that the `EditMode` button is selected in the Test Runner panel.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保测试运行器面板中的 `EditMode` 按钮被选中。
- en: Click Run All.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行所有。
- en: You should see the results of your Unit Test being executed – if the test was
    concluded successfully, it should have a green 'tick' next to it.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到您的单元测试执行的结果——如果测试成功完成，它旁边应该有一个绿色的勾号。
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You have declared that the `TestOnePlusOneEqualsTwo()` method in the C# `SimpleTester.cs`
    script class is a test method. When executing this test method, the Unity Test
    Runner executes each statement in sequence, so variables `n1`, `n2`, and `expectedResult`
    are set, then the calculation of 1 + 1 is stored in the variable result, and finally
    (the most important bit), we make an assertion of what should be true after executing
    that code. Our assertion states that the value of the `expectedResult` variable should
    be equal to the value of the variable result.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您已声明 C# `SimpleTester.cs` 脚本类中的 `TestOnePlusOneEqualsTwo()` 方法是一个测试方法。当执行此测试方法时，Unity
    测试运行器会按顺序执行每个语句，因此变量 `n1`、`n2` 和 `expectedResult` 被设置，然后计算 1 + 1 的结果存储在变量 result
    中，最后（最重要的一点），我们断言执行该代码后应该为真的值。我们的断言表明 `expectedResult` 变量的值应该等于变量 result 的值。
- en: If the assertion is true, the test is passed, otherwise it is failed. Generally,
    as programmers, we expect our code to pass, so we inspect each fail very carefully,
    first to see whether we have an obvious error, then perhaps to check whether the
    test itself is correct (especially if it's a new test), and then to begin to debug
    and understand why our code behaved in such a way that it did not yield the anticipated
    result.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言为真，则测试通过，否则失败。通常，作为程序员，我们期望我们的代码通过，因此我们会非常仔细地检查每个失败，首先看看是否有明显的错误，然后可能检查测试本身是否正确（特别是如果它是一个新测试），然后开始调试并理解为什么我们的代码以这种方式表现，没有产生预期的结果。
- en: There's more...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Here are some details that you won't want to miss.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您不想错过的细节。
- en: Shorter tests with values in the assertion
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简短的测试，其中包含断言的值
- en: 'For simple calculations, some programmers prefer to write less test code by
    putting the values directly into the assertion. So, as shown below, our 1 + 1
    = 2 test could be expressed in a single assertion, where the expected value of
    2, and the expression 1 + 1, are entered directly into an `AreEqual(...)` method
    invocation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的计算，一些程序员更喜欢通过直接将值放入断言中来编写更少的测试代码。所以，如下所示，我们的 1 + 1 = 2 测试可以表达为一个单一的断言，其中预期的值
    2 和表达式 1 + 1 直接输入到 `AreEqual(...)` 方法调用中：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, if you are new to testing, you may prefer the previous approach, whereby
    the preparation, code execution, and storage of results, and the assertion of
    properties about those results, are structured clearly in a sequence of **Arrange/Act/Assert**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您是测试的新手，您可能更喜欢先前的方法，其中准备、代码执行、结果存储以及关于这些结果的属性断言都清晰地按顺序排列在 **Arrange/Act/Assert**
    序列中。
- en: Expected value followed by the actual value
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期值后跟实际值
- en: 'When comparing values with assertions, it is customary for the expected (correct)
    value to be given first, followed by the actual value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用断言比较值时，通常先给出预期的（正确）值，然后是实际值：
- en: '[PRE4]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While it makes no difference to the true or false nature of equality, and so
    on, it can make a difference to messages when tests fail with some testing frameworks
    (for example, "got 2 but expected 3" has a very different meaning to "got 3 but
    expected 2"). Hence, the following assertion would output a message that would
    be confusing, since 2 was our expected result:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它对等式的真伪性质没有影响，等等，但在某些测试框架中测试失败时的消息可能会有所不同（例如，“得到2但期望3”与“得到3但期望2”有非常不同的含义）。因此，以下断言会输出一个可能会令人困惑的消息，因为2是我们期望的结果：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Refer to the following screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图：
- en: '![](img/69dd1664-2b61-4de9-b131-5c3bf8b392de.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69dd1664-2b61-4de9-b131-5c3bf8b392de.png)'
- en: Parameterizing tests with a data provider method
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据提供程序方法参数化测试
- en: 'If we are testing our code using a range of test data, then sometimes there
    is little difference between each test apart from the the values. Rather than
    duplicating our Arrange/Act/Assert statements, we can re-use a single method,
    and the Unity Test Runner will loop through a collection of test data, running
    the test method for each set of test data. The special method that provides multiple
    sets of test data to a test method is known as a DataProvider, and we''ll create
    one in this recipe:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一系列测试数据来测试我们的代码，那么除了值之外，每个测试之间可能几乎没有区别。我们不必重复我们的Arrange/Act/Assert语句，可以重用单个方法，Unity测试运行器将遍历测试数据集合，为每组测试数据运行测试方法。向测试方法提供多组测试数据的方法称为数据提供程序，我们将在本食谱中创建一个：
- en: '![](img/23878553-e5bf-44f1-9f9d-fb3714659e72.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23878553-e5bf-44f1-9f9d-fb3714659e72.png)'
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To parameterize tests with a data provider method, follow these steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用数据提供程序方法参数化测试，请按照以下步骤操作：
- en: In the Project panel, create a folder called Editor.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个名为Editor的文件夹。
- en: 'Inside your Editor folder, create a new C# `DataProviderTester.cs` script class containing
    the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的编辑器文件夹中，创建一个新的C# `DataProviderTester.cs` 脚本类，包含以下内容：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单显示测试运行器面板：窗口 | 通用 | 测试运行器。
- en: Ensure that the EditMode button is selected in the Test Runner panel.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选择EditMode按钮。
- en: Click Run All.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行全部。
- en: You should see the results of your Unit Test being executed. You should see
    four sets of results for the `TestAdd(...)` test method, one for each of the datasets
    provided by the `AdditionProvider` method.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到单元测试的执行结果。您应该看到`TestAdd(...)`测试方法的四组结果，每组对应于`AdditionProvider`方法提供的每个数据集。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have indicated that the `TestAdd(...)` method is a test method with a compiler
    attribute [Test]. However, in this case, we have added additional information
    to state that the data source for this method is the `AdditionProvider` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经指出`TestAdd(...)`方法是一个具有编译器属性[Test]的测试方法。然而，在这种情况下，我们添加了额外的信息来声明此方法的数据源是`AdditionProvider`方法。
- en: This means that the Unity Test Runner will retrieve the data objects from the
    additional provider, and create multiple tests for the `TestAdd(...)` method,
    one for each set of data from the `AdditionProvider()` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Unity测试运行器将从附加提供程序中检索数据对象，并为`TestAdd(...)`方法创建多个测试，每个测试对应于`AdditionProvider()`方法中的每组数据。
- en: 'In the Test Runner panel, we can see a line for each of these tests:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，我们可以看到每个测试的行：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unit testing a simple health script class
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试简单的健康脚本类
- en: Let's create something that might be used in a game, and that can easily be
    unit tested. Classes that do **not** subclass from Monobehavior are much easier
    to unit test, since instance objects can be created using the keyword new. If
    the class is carefully designed with private data and public methods with clearly
    declared dependencies as parameters, it becomes easy to write a set of tests to
    make us confident that objects of this class will behave as expected in terms
    of default values, as well as valid and invalid data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些可能在游戏中使用，并且可以轻松进行单元测试的东西。不继承自Monobehavior的类更容易进行单元测试，因为可以使用关键字new创建实例对象。如果类经过精心设计，具有私有数据和具有明确声明依赖性参数的公共方法，那么编写一组测试来让我们有信心，这个类的对象在默认值以及有效和无效数据方面将按预期行为就变得容易了。
- en: 'In this recipe, we will create a health script class, and a set of tests for
    this class. This kind of class can be reused for both the health of human players,
    and also Artificial Intelligence (AI)-controlled enemies in a game:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个健康脚本类，以及对这个类的一系列测试。这种类可以用于游戏中的玩家健康，也可以用于人工智能（AI）控制的敌人：
- en: '![](img/1db24c0c-d5e6-4c17-a24c-153834a86a78.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db24c0c-d5e6-4c17-a24c-153834a86a78.png)'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To unit test a health script class, follow these steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要对健康脚本类进行单元测试，请按照以下步骤操作：
- en: In the Project panel, create a _Scripts folder.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个_Scripts文件夹。
- en: 'Inside your `_Scripts` folder, create a new C# `Health.cs` script class containing
    the following:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的_Scripts文件夹中，创建一个新的C# `Health.cs`脚本类，包含以下内容：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Inside your _Scripts folder, create a new folder named Editor.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的_Scripts文件夹中，创建一个名为Editor的新文件夹。
- en: 'Inside your Editor folder, create a new C# `TestHealth.cs` script class containing
    the following:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器文件夹中，创建一个新的C# `TestHealth.cs`脚本类，包含以下内容：
- en: '[PRE9]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Display the Test Runner panel by choosing the following menu: Window | Debug
    | Test Runner.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单来显示测试运行器面板：窗口 | 调试 | 测试运行器。
- en: Ensure that the EditMode button is selected in the Test Runner panel.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选择了EditMode按钮。
- en: Click Run All.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行全部。
- en: You should see the results of your unit tests being executed.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到你的单元测试执行的结果。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each of the C# script-classes is described below.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面将描述每个C#脚本类。
- en: Script-class Health.cs
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类 Health.cs
- en: 'This script class has one private property; as it is private, it can only be
    changed by methods. Its initial value is 1.0, in other words, 100% health:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本类有一个私有属性；由于它是私有的，只能通过方法来更改。它的初始值是1.0，换句话说，100%的健康值：
- en: '`health` (float): The valid range is from 0 (dead!) to 1.0 (100% health)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`health` (float): 有效范围是从0（死亡！）到1.0（100%健康）'
- en: 'There are 3 public methods:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有3个公共方法：
- en: '`GetHealth()`: This returns the current value of the health float number (which
    should be between 0 and 1.0)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetHealth()`: 这个方法返回当前健康浮点数的值（应该在0和1.0之间）'
- en: '`AddHealth(float)`: This takes as input a float (the amount to add to the health),
    and returns a Boolean true/false, as to whether the value was valid. Note the
    logic of this method is that it accepts values of 0 or more (and will return true),
    but it will ensure that the value of health is never more than 1'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddHealth(float)`: 这个方法接受一个浮点数（要添加到健康值中的数量），并返回一个布尔值true/false，表示值是否有效。注意这个方法的逻辑是接受0或更多的值（并将返回true），但它将确保健康值的值永远不会超过1'
- en: '`KillCharacter()`: This method sets health to zero, and returns true, since
    it is always successful in this action'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KillCharacter()`: 这个方法将健康值设置为0，并返回true，因为在这个动作中总是成功的'
- en: Script-class TestHealth.cs
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本类 TestHealth.cs
- en: 'This script class has five methods:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本类有五个方法：
- en: '`TestReturnsOneWhenCreated()`: This tests that the initial value of health
    is 1, when a new Health object is created.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestReturnsOneWhenCreated()`: 这个测试检查当创建一个新的Health对象时，健康值的初始值是1。'
- en: '`TestPointTwoAfterAddPointOneTwiceAfterKill()`: This tests that after a kill
    (health set to zero), and then adding 0.1 on two occasions, the health should
    be 0.2.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestPointTwoAfterAddPointOneTwiceAfterKill()`: 这个测试检查在杀死（健康值设置为0）后，两次添加0.1，健康值应该是0.2。'
- en: '`TestReturnsZeroWhenKilled()`: This tests that the health value is set to zero
    immediately after the `KillCharacter()` method has been called.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestReturnsZeroWhenKilled()`: 这个测试检查在调用`KillCharacter()`方法后，健康值应立即设置为0。'
- en: '`TestNoChangeAndReturnsFalseWhenAddNegativeValue()`: This tests that attempting
    to add a negative value to health should return false and that the value of health
    should not have changed. This method is an example of a test with more than one
    assertion (but both are related to the actions.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestNoChangeAndReturnsFalseWhenAddNegativeValue()`: 这个测试检查尝试向健康值添加负数时应该返回false，并且健康值不应该发生变化。这个方法是一个具有多个断言（但都与操作相关）的测试示例。'
- en: '`TestHealthNotGoAboveOne()`: This test verifies that even when lots of values
    are added to health, totaling more than 1.0, the value returned from `GetHealth()`
    is one.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestHealthNotGoAboveOne()`: 这个测试验证即使向健康值添加了很多值，总数超过1.0，`GetHealth()`返回的值也是1。'
- en: Hopefully, all the tests pass when you run them, giving some confidence that
    the logic implementation in the `Health.cs` script class does behave as intended.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 希望当你运行它们时，所有的测试都能通过，这会让你对`Health.cs`脚本类中的逻辑实现是否按预期工作有一定的信心。
- en: Creating and executing a unit test in Play mode
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏模式中创建和执行单元测试
- en: It's a good idea to write as much of the logic for a game as isolated, non-Monobehavior
    classes, that are easy to unit test in Edit mode. However, some of the logic in
    a game relates to things that happen when the game is running. Examples include
    physics, collisions, and timing-based events. We test these parts of our games
    in Play Mode.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将游戏的大部分逻辑编写为隔离的、非Monobehavior类，这些类在编辑模式下易于单元测试。然而，游戏中的某些逻辑与游戏运行时发生的事情有关。例如，包括物理、碰撞和基于时间的活动。我们在Play
    Mode测试这些游戏的部分。
- en: 'In this recipe, we''ll create one very simple Play Mode test, to check that
    physics affects a RigidBody (based on an example from the Unity documentation):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个非常简单的Play Mode测试，以检查物理对RigidBody的影响（基于Unity文档中的示例）：
- en: '![](img/7d7fe717-66e1-4c2b-bbdb-6b312ea5e15f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d7fe717-66e1-4c2b-bbdb-6b312ea5e15f.png)'
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create and execute a unit test in **Play** mode, follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**Play**模式下创建和执行单元测试，请按照以下步骤操作：
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单显示测试运行器面板：窗口 | 通用 | 测试运行器
- en: 'Enable PlayMode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and then selecting Enable
    playmode tests for all assemblies (click OK to any message concerned with restarting
    the editor):'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有汇编启用PlayMode测试。通过显示测试运行器面板右上角的下拉菜单，然后选择为所有汇编启用Playmode测试（对任何有关重新启动编辑器的消息点击确定）：
- en: '![](img/6abcb454-93c1-4ec8-be54-22864a5f354f.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6abcb454-93c1-4ec8-be54-22864a5f354f.png)'
- en: Now, restart the Unity Editor (just close the application and then reopen it
    with your project).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新启动Unity编辑器（只需关闭应用程序，然后使用项目重新打开它）。
- en: It is very important that you restart the Unity Editor application after enabling
    PlayMode. If you fail to do this, then you may not be able to locate your PlayMode
    test script classes where they can see (and refer to) your Monobehavior classes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用PlayMode后重新启动Unity编辑器应用程序非常重要。如果你没有这样做，那么你可能无法找到你的PlayMode测试脚本类，它们可以看到（并引用）你的Monobehavior类。
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选择了PlayMode按钮。
- en: In the Test Runner panel, click the Create PlayMode Test Assembly Folder button.
    A new folder, named Tests, should have been created.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击创建PlayMode测试汇编文件夹按钮。应该已经创建了一个名为Tests的新文件夹。
- en: In the Project panel, open the `Tests` folder. It should contain an assembly
    definition file Tests.asmdef.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，打开`Tests`文件夹。它应该包含一个汇编定义文件Tests.asmdef。
- en: In the Test Runner panel, click the Create Test Script in the current folder
    button – you may wish to rename this script from the default name, `NewTestScript`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击当前文件夹中创建测试脚本按钮 – 你可能希望将此脚本重命名为默认名称，`NewTestScript`。
- en: 'Edit your new test script, replacing the content with the following:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑你的新测试脚本，将内容替换为以下内容：
- en: '[PRE10]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Click Run All.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行全部。
- en: In the Hierarchy, you'll see that a temporary scene is created (named something
    along the lines of InitTestScene6623462364), and that a GameObject named Code
    Based Test Runner is created.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，你会看到创建了一个临时场景（命名为类似于InitTestScene6623462364的东西），并且创建了一个名为基于代码的测试运行器的GameObject。
- en: In the Game panel, you will briefly see the message Display 1 No Cameras Rendering.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏面板中，你会短暂地看到消息 显示 1 无相机渲染。
- en: You should see the results of your unit test being executed – if the test is
    concluded successfully, it should have a green tick next to it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到你的单元测试执行的结果——如果测试成功完成，它旁边应该有一个绿色的勾号。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Methods marked with the `[UnityTest]` attribute are run as coroutines. A coroutine
    has the ability to pause execution (when it meets a yield statement) and return
    control to Unity, but then to continue where it left off when called again (for
    example, the next frame, second, or whatever). The yield statement indicates the
    statement after which, and for how long, execution of the method is to be paused.
    Examples of different types of yield include:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`[UnityTest]`属性的函数作为协程运行。协程有暂停执行（当遇到yield语句时）并将控制权返回给Unity的能力，但然后在再次调用时从上次离开的地方继续（例如，下一帧、第二帧或任何其他）。yield语句表示在哪个语句之后以及暂停执行多长时间。不同类型的yield的例子包括：
- en: 'Waiting until until the next frame: `null`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待直到下一帧：`null`
- en: 'Waiting for a given length of time: `WaitForSeconds(<seconds>)`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待给定的时间长度：`WaitForSeconds(<seconds>)`
- en: 'Waiting until the next fixed-update time period (physics is not applied each
    frame (since the framerate varies), but after a fixed period of time): `WaitForFixedUpdate()`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待下一个固定更新时间周期（由于帧率不同，物理不会在每一帧应用）：`WaitForFixedUpdate()`
- en: Method `GameObject_WithRigidBody_WillBeAffectedByPhysics()` creates a new GameObject
    and attaches to it a RigidBody. It also stores the original Y position. The yield
    statement makes the PlayMode Test Runner wait until physics has begun at the next
    fixed update period. Finally, an assertion is made that the original Y position
    is not equal to the new Y position (after the physics fixed update). Since the
    defaults for a RigidBody are that gravity will be applied, this is a good test
    that physics is being applied to the new object (in other words, it should have
    started falling down once physics had been applied).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`GameObject_WithRigidBody_WillBeAffectedByPhysics()`创建一个新的GameObject，并将其附加一个RigidBody。它还存储了原始的Y位置。yield语句使PlayMode测试运行器等待下一个固定更新周期开始时物理开始。最后，断言原始Y位置不等于新的Y位置（在物理固定更新之后）。由于RigidBody的默认设置是应用重力，这是一个很好的测试，以验证物理是否被应用于新对象（换句话说，一旦应用了物理，它应该已经开始下落）。
- en: PlayMode testing a door animation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试门动画的PlayMode
- en: Having learned the basics of PlayMode testing in the previous recipe, now let's
    test something non-trivial that we might find in a game. In this recipe, we'll
    create a PlayMode test to ensure that a door opening animation plays when the
    player's sphere object enters a collider.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中学习了PlayMode测试的基础知识后，现在让我们测试一下在游戏中可能会遇到的不平凡内容。在这个食谱中，我们将创建一个PlayMode测试，以确保当玩家的球体对象进入碰撞体时，门开启动画能够播放。
- en: 'A scene has been provided with the player''s sphere initialized to roll toward
    a red door. When the sphere hits the collider (`OnTriggerEnter` event), some code
    sets the door''s Animator Controller Opening variable to true, which transitions
    the door from its closed state to its open state, as can be seen in the following
    screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个场景，玩家的球体初始化为向红色门滚动。当球体击中碰撞体（`OnTriggerEnter`事件）时，一些代码将门的Animator Controller
    Opening变量设置为true，从而将门从关闭状态过渡到开启状态，如以下截图所示：
- en: '![](img/27a33dc2-b393-4ed7-aa36-9cb6807b6c2b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27a33dc2-b393-4ed7-aa36-9cb6807b6c2b.png)'
- en: Thanks should go to the creator of the ground texture; it was designed by Starline,
    and published at [Freepik.com](http://Freepik.com).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应感谢地面纹理的创作者；它由Starline设计，并在[Freepik.com](http://Freepik.com)发布。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, a Unity Package has been provided `(doorScene.unitypackage)`
    in the `19_06` folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，已经在`19_06`文件夹中提供了一个Unity包 `(doorScene.unitypackage)`。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To PlayMode test a door animation, follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试门动画的PlayMode，请按照以下步骤操作：
- en: Create a new Unity project, and delete the default folder Scenes.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity项目，并删除默认的Scenes文件夹。
- en: Import the Unity package provided (doorScene.unitypackage).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的Unity包 (doorScene.unitypackage)。
- en: Add the following scenes – doorScene and menuScene – to the project Build (the
    sequence doesn't matter).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下场景 doorScene和menuScene 添加到项目构建中（顺序无关紧要）。
- en: Ensure that the scene currently open is menuScene.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保当前打开的场景是menuScene。
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单显示测试运行器面板：窗口 | 通用 | 测试运行器
- en: Enable playmode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and selecting Enable playmode
    tests for all assemblies (click OK to any message concerned with restarting the
    editor).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有程序集启用Playmode测试。通过在测试运行器面板右上角显示下拉菜单，并选择“为所有程序集启用Playmode测试”（点击OK以确认任何有关重启编辑器的消息）。
- en: Now restart the Unity Editor (just close the application and then reopen it
    with your project).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新启动Unity编辑器（只需关闭应用程序，然后使用项目重新打开它）。
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选择了PlayMode按钮。
- en: In the Project panel, select the top-level folder Assets.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，选择顶级文件夹Assets。
- en: In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button.
    A new folder, named Tests, should have been created.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击“创建PlayMode测试程序集文件夹”按钮。应该创建了一个名为Tests的新文件夹。
- en: In the Project panel, open the `Tests` folder. It should contain an assembly
    definition file `Tests.asmdef`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，打开`Tests`文件夹。它应该包含一个程序集定义文件`Tests.asmdef`。
- en: In the Test Runner panel, click the "Create Test Script in the current folder"
    button. Rename this script class `DoorTest`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击“在当前文件夹中创建测试脚本”按钮。将此脚本类重命名为`DoorTest`。
- en: 'Edit the `DoorTest.cs` script class, replacing the content with the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`DoorTest.cs`脚本类，将内容替换为以下：
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following test method to `DoorTest.cs`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`DoorTest.cs`中：
- en: '[PRE12]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following test method to `DoorTest.cs`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`DoorTest.cs`中：
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following test method to `DoorTest.cs`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`DoorTest.cs`中：
- en: '[PRE14]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Click Run All.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“运行全部”。
- en: As the tests run, you will see first in the Hierarchy, Game and Scene panels
    that a temporary scene is created, then the doorScene running, with the sphere
    rolling toward the red door.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试运行时，你首先会在层次结构、游戏和场景面板中看到创建了一个临时场景，然后是门场景正在运行，球体正滚向红色的门。
- en: You should see the results of your unit test being executed – if all tests are
    concluded successfully, there should be green ticks (check marks) next to each
    test.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能看到你的单元测试执行的结果——如果所有测试都成功完成，每个测试旁边应该有绿色的勾号（检查标记）。
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added two scenes to the build, so they can be selected in our scripts using
    the SceneManager during PlayMode testing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加了两个场景到构建中，因此它们可以在PlayMode测试期间使用SceneManager在我们的脚本中选择。
- en: We opened the menuScene so that we can clearly see when Unity runs different
    scenes during our PlayMode testing – and we'll see the menu scene reopened after
    testing takes place.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了menuScene，以便在PlayMode测试期间清楚地看到Unity运行不同的场景——测试完成后，我们会看到menu场景被重新打开。
- en: 'There is a `SetUp()` method that is executed before each test. SetUp and TearDown
    methods are very useful for preparing things before each test, and resetting things
    back to how they were before the test took place. Unfortunately, aspects such
    as loading our door scene before running each test, and then reloading the menu
    after each test, involve waiting until the scene load process has completed. We
    can''t place yield statements in our `SetUp()` and `TearDown()` methods, so you''ll
    see each test has repeated scene loading at the beginning and end of each test:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个在每次测试之前执行的`SetUp()`方法。SetUp和TearDown方法在每次测试前准备事情和测试后重置事物回原状非常有用。不幸的是，例如在每次测试前加载我们的门场景，然后在测试后重新加载菜单，需要等待场景加载过程完成。我们无法在`SetUp()`和`TearDown()`方法中放置yield语句，所以你会看到每个测试在每个测试的开始和结束时都会重复场景加载：
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For each test, we wait, either for a single frame (yield `null`), or for a few
    seconds (yield `return new WaitForSeconds(...)`). This ensures that all objects
    have been created and physics is started before our test starts running. The first
    two tests check the initial conditions, in other words, that the door begins in
    the DoorClosed animation state, and that the Animation Controller's `isOpening`
    variable is false.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个测试，我们等待，要么是单个帧（返回`null`），要么是几秒钟（返回`return new WaitForSeconds(...)`）。这确保了在测试开始运行之前，所有对象都已创建并且物理引擎已启动。前两个测试检查初始条件，换句话说，门开始于DoorClosed动画状态，并且Animation
    Controller的`isOpening`变量为false。
- en: The final test waits for a few seconds (which is enough time for the sphere
    to roll up to the door and trigger the opening animation), and tests that the
    door is entering/has entered the DoorOpen animation state, and that the Animation
    Controller's `isOpening` variable is true.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试等待几秒钟（这足以让球体滚到门前并触发开启动画），并测试门是否进入/已进入DoorOpen动画状态，以及Animation Controller的`isOpening`变量是否为true。
- en: As can be seen, there is quite a bit more to PlayMode testing than Unit Testing,
    but it means that we have a way to test actual GameObject interactions when features
    such as timers and physics are running. As this recipe demonstrates, we can also
    load our own scenes for PlayMode testing, be they special scenes created just
    to test interactions, or actual scenes that are to be included in our final game
    build.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，PlayMode测试比单元测试要复杂得多，但它意味着我们有一种方法来测试实际的游戏对象交互，当计时器和物理引擎运行时。正如这个示例所示，我们还可以为PlayMode测试加载自己的场景，无论是专门创建来测试交互的特殊场景，还是最终游戏构建中要包含的实际场景。
- en: PlayMode and Unit Testing a player health bar with events, logging, and exceptions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件、日志和异常进行PlayMode和单元测试玩家生命条
- en: In this recipe, we combine many different kinds of tests on a feature of many
    games – a visual health bar representing the player's numeric health value (in
    this case, a float number from 0.0 - 1.0). Although far from comprehensively testing
    all aspects of the health bar, this recipe gives a good sample of how we can go
    about testing many different parts of a game using the Unity Testing tools.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将许多不同类型的测试组合到许多游戏的一个功能上——一个表示玩家数值生命值的视觉生命条（在这种情况下，一个从0.0到1.0的浮点数）。尽管这个菜谱并没有全面测试生命条的各个方面，但它提供了一个很好的示例，说明我们可以如何使用Unity测试工具来测试游戏的不同部分。
- en: 'A Unity Package is provided that contains the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一个包含以下内容的Unity包：
- en: '`Player.cs`: a player script class, managing values for player health, and
    using delegates-and-events to publish health changes to any listening **View**
    classes'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player.cs`：一个玩家脚本类，管理玩家生命值，并使用委托和事件将健康变化发布到任何监听的**视图**类'
- en: 'Two **View** classes that register to listen for player health change events:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个**视图**类，它们注册以监听玩家生命值变化事件：
- en: '`HealthBarDisplay.cs`: this updates the fillAmount for a UI image for each
    new player health value received'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthBarDisplay.cs`：这个脚本更新UI图像的填充量，以反映每个新收到的玩家生命值'
- en: '`HealthChangeLogger.cs`: this prints messages about the new player health value
    received to the Debug.Log file'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthChangeLogger.cs`：这个脚本将关于接收到的新的玩家生命值的消息打印到Debug.Log文件中'
- en: '`PlayerManager.cs`: a manager script, which initializes player and HealthChangeLogger
    objects, and also allows the user to change the health of the player by pressing
    the Up and Down arrow keys (simulating healing/damage during a game)'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerManager.cs`：一个管理脚本，它初始化玩家和HealthChangeLogger对象，并允许用户通过按上箭头键和下箭头键来改变玩家的生命值（模拟游戏中的治疗/伤害）'
- en: A scene that has 2 UI images – one is a health bar outline (red heart and a
    black outline), the second is the filler image – showing dark blue to light blue
    to green, for weak to strong health values)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含2个UI图像的场景——一个是生命条轮廓（红色心形和黑色轮廓），另一个是填充图像——显示从深蓝色到浅蓝色再到绿色，表示从弱到强的生命值）
- en: 'This recipe allows several different kinds of testing to be demonstrated:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱允许展示几种不同类型的测试：
- en: PlayMode testing, to check that the actual `fillAmount` of the UI image displayed matches
    the 0.0 ... 1.0 range of the player's health
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行PlayMode测试，以检查显示的UI图像的实际`fillAmount`是否与玩家生命值的0.0到1.0范围相匹配
- en: Unit Testing, to check that player health starts with the correct default value,
    and correctly increases and decreases after calls to the `AddHealth(...)` and `ReduceHealth(...)`
    methods
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，以检查玩家生命值是否以正确的默认值开始，并在调用`AddHealth(...)`和`ReduceHealth(...)`方法后正确增加和减少
- en: Unit testing, to check that health change events are published by the player
    object
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，以检查玩家对象是否发布了健康变化事件
- en: Unit testing, to check that expected messages are logged in the `Debug.Log`
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，以检查预期的消息是否记录在`Debug.Log`中
- en: 'Unit testing, to check that argument out-of-range exceptions are thrown if
    negative values are passed to the player''s `AddHealth(...)` or `ReduceHealth(...)`
    methods. This is demonstrated in the following screenshot:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试，以检查如果将负值传递给玩家的`AddHealth(...)`或`ReduceHealth(...)`方法，是否会抛出参数范围异常。这在上面的屏幕截图中得到了演示：
- en: '![](img/f66aebf7-313f-4a0a-88bd-41d1a7b04dae.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f66aebf7-313f-4a0a-88bd-41d1a7b04dae.png)'
- en: 'Thanks to Pixel Art Maker for the health bar image: [http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Pixel Art Maker提供的生命条图像：[http://pixelartmaker.com/art/49e2498a414f221](http://pixelartmaker.com/art/49e2498a414f221)
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, a Unity Package has been provided (`healthBarScene.unitypackage`)
    in the `19_07` folder.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，在`19_07`文件夹中提供了一个Unity包（`healthBarScene.unitypackage`）。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To PlayMode and Unit Test a player health bar, follow these steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要对玩家生命条进行PlayMode和单元测试，请按照以下步骤操作：
- en: Create a new Unity project, create a new empty scene, and delete the default
    folder Scenes.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Unity项目，创建一个新的空场景，并删除默认的Scenes文件夹。
- en: Import the Unity package provided (`healthBarScene.unitypackage`).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入提供的Unity包（`healthBarScene.unitypackage`）。
- en: Open the HealthBarScene scene.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开HealthBarScene场景。
- en: 'Add HealthBarScene to the project Build (menu: File | Build Settings ...).'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将HealthBarScene添加到项目构建中（菜单：文件 | 构建设置 ...）。
- en: 'Display the Test Runner panel by choosing the following menu: Window | General
    | Test Runner.'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择以下菜单来显示测试运行器面板：窗口 | 通用 | 测试运行器。
- en: Enable PlayMode tests for all assemblies. Do this by displaying the drop-down
    menu in the top-right corner of the Test Runner panel, and selecting Enable playmode
    tests for all assemblies (click OK to any message concerned with restarting the
    editor).
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有程序集启用测试模式。通过在测试运行器面板右上角显示下拉菜单，并选择“为所有程序集启用测试模式（点击OK以确认重启编辑器）”来完成此操作。
- en: Now restart the Unity Editor (just close the application and then reopen it
    with your project).
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新启动Unity编辑器（只需关闭应用程序，然后使用项目重新打开它）。
- en: Ensure that the PlayMode button is selected in the Test Runner panel.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在测试运行器面板中选择了“测试模式”按钮。
- en: In the Project panel, select the top-level folder Assets.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，选择顶级文件夹“Assets”。
- en: In the Test Runner panel, click the "Create PlayMode Test Assembly Folder" button.
    A new folder, named Tests, should have been created.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试运行器面板中，点击“创建测试模式测试程序集文件夹”按钮。应该已经创建了一个名为Tests的新文件夹。
- en: Ensure that the Assets folder is selected in the Project panel. Create a new
    folder named PlayModeTests (this should now appear in the Assets folder).
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择了“Assets”文件夹。创建一个名为PlayModeTests的新文件夹（现在它应该出现在“Assets”文件夹中）。
- en: Ensure that the PlayModeTests folder is selected in the Project panel. In the
    Test Runner panel, click the "Create Test Script in the current folder" button.
    Rename this script class `HealthBarPlayModeTests`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择了“PlayModeTests”文件夹。在测试运行器面板中，点击“在当前文件夹中创建测试脚本”按钮。将此脚本类重命名为`HealthBarPlayModeTests`。
- en: 'Edit the `HealthBarPlayModeTests.cs` script class, replacing the content with
    the following:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`HealthBarPlayModeTests.cs`脚本类，将内容替换为以下：
- en: '[PRE16]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following test in `HealthBarPlayModeTests.cs`:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HealthBarPlayModeTests.cs`中添加以下测试：
- en: '[PRE17]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Click Run All.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“运行所有”。
- en: As the tests run, you will see first in the Hierarchy, Game and Scene panels
    that a temporary scene is created, then the HealthBarScene running, with the visual
    health bar.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当测试运行时，你首先会在“层次结构”、“游戏”和“场景”面板中看到创建了一个临时场景，然后运行带有可视健康条的HealthBarScene。
- en: You should see the results of your PlayMode Test being executed – if the test
    is concluded successfully, there should be a green tick (check mark).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该看到你的测试模式测试执行的结果——如果测试成功完成，应该有一个绿色的勾号（勾选标记）。
- en: Ensure that the Assets folder is selected in the Project panel. Create a new
    folder named Editor (this should now appear in the Assets folder).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择了“Assets”文件夹。创建一个名为Editor的新文件夹（现在它应该出现在“Assets”文件夹中）。
- en: Ensure that the Editor folder is selected in the Project panel. In the Test
    Runner panel, click the "Create Test Script in the current folder" button. Rename
    this script class `EditModeUnitTests`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在项目面板中选择了“Editor”文件夹。在测试运行器面板中，点击“在当前文件夹中创建测试脚本”按钮。将此脚本类重命名为`EditModeUnitTests`。
- en: 'Edit the `EditModeUnitTests.cs` script class, replacing the content with the
    following:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`EditModeUnitTests.cs`脚本类，将内容替换为以下：
- en: '[PRE18]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following class and basic tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditModeUnitTests.cs`中的`EditModeUnitTests`类内部添加以下类和基本测试：
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following class and limit test inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditModeUnitTests.cs`中的`EditModeUnitTests`类内部添加以下类和限制测试：
- en: '[PRE20]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following class and event tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditModeUnitTests.cs`中的`EditModeUnitTests`类内部添加以下类和事件测试：
- en: '[PRE21]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following class and exception tests inside the `EditModeUnitTests`
    class in `EditModeUnitTests.cs`:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditModeUnitTests.cs`中的`EditModeUnitTests`类内部添加以下类和异常测试：
- en: '[PRE22]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following class and logging tests inside the `EditModeUnitTests` class
    in `EditModeUnitTests.cs`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditModeUnitTests.cs`中的`EditModeUnitTests`类内部添加以下类和日志测试：
- en: '[PRE23]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that the inner classes allow grouping of the unit tests visually
    in the Test Runner panel
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，内部类允许在测试运行器面板中视觉上对单元测试进行分组。
- en: '![](img/640546ed-4ddc-44c9-9a49-5638af8a756c.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/640546ed-4ddc-44c9-9a49-5638af8a756c.png)'
- en: How it works...
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's take a look at how it works in detail.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它是如何工作的。
- en: PlayMode testing
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模式测试
- en: The PlayMode test `TestHealthBarImageMatchesPlayerHealth()` loads the `HealthBar`
    scene, gets a reference to the instance-object of PlayerManager, which is a component
    of the GameObject tagged PlayerManager, and invokes the `ReduceHealth()` method.
    This method reduces the player's health by 0.1, so from its starting value of
    1.0, it becomes 0.9.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模式测试`TestHealthBarImageMatchesPlayerHealth()`加载`HealthBar`场景，获取PlayerManager实例对象的引用，PlayerManager是标记为PlayerManager的GameObject的组件，并调用`ReduceHealth()`方法。此方法将玩家的健康值减少0.1，因此从其起始值1.0变为0.9。
- en: The PlayerManager GameObject also has as a component an instance object of the
    C# `HealthBarDisplay` script class. This object registers to listen to published
    events from the player class. It also has a public UI Image variable that has
    been linked to the UI Image of the health bar filler image in the scene.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: PlayerManager GameObject 还有一个组件，是一个 C# `HealthBarDisplay` 脚本类的实例对象。此对象注册监听来自玩家类的发布事件。它还有一个公共
    UI Image 变量，该变量已链接到场景中生命值填充图像的 UI Image。
- en: When the player's health is reduced to 0.9, it publishes the `OnChangeHealth(0.9)`
    event. This event is received by the `HealthBarDisplay` object instance, which
    then sets the fillAmount property of the linked health bar filler image in the
    scene.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家的生命值减少到0.9时，它发布 `OnChangeHealth(0.9)` 事件。此事件被 `HealthBarDisplay` 对象实例接收，然后设置场景中链接的生命值填充图像的
    fillAmount 属性。
- en: 'The `TestHealthBarImageMatchesPlayerHealth(`) PlayMode test gets a reference
    to the object instance named image-health-bar-filler, storing this reference in
    the `healthBarFiller` variable. The test assertion made is that the expectedResult
    value of 0.9 matches that actual fillAmount property of the UI Image in the scene:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHealthBarImageMatchesPlayerHealth(`) PlayMode 测试获取名为 image-health-bar-filler
    的对象实例的引用，将此引用存储在 `healthBarFiller` 变量中。测试断言是，expectedResult 值为 0.9 与场景中 UI Image
    的实际 fillAmount 属性相匹配：'
- en: '[PRE24]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unit tests
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: There are several unit tests, grouped by placing them inside their own classes,
    inside the `EditModeUnitTests` script class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个单元测试，通过将它们放在自己的类中，放在 `EditModeUnitTests` 脚本类中，进行分组。
- en: '`TestCorrectValues` class:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestCorrectValues` 类:'
- en: '`DefaultHealthOne()`: this tests that the default (initial value) of the player''s
    health is 1'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultHealthOne()`: 这个测试验证玩家的生命值的默认（初始值）是1'
- en: '`HealthCorrectAfterReducedByPointOne()`: this tests that when the player''s
    health is reduced by 0.1, it becomes 0.9'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthCorrectAfterReducedByPointOne()`: 这个测试验证当玩家的生命值减少到0.1时，它变成了0.9'
- en: '`HealthCorrectAfterReducedByHalf()`: this tests that when the player''s health
    is reduced by 0.5 it becomes 0.5'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthCorrectAfterReducedByHalf()`: 这个测试验证当玩家的生命值减少到0.5时，它确实变成了0.5'
- en: 'class `TestLimitNotExceeded`:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'class `TestLimitNotExceeded`:'
- en: '`HealthNotExceedMaximumOfOne()`: this tests that the value of the player''s
    health does not exceed 1, even after attempts to add 1, 0.5, and 0.1 to its initial
    value of 1'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthNotExceedMaximumOfOne()`: 这个测试验证玩家的生命值不会超过1，即使尝试将其初始值1增加1、0.5和0.1'
- en: 'class `TestEvents`:'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'class `TestEvents`:'
- en: '`CheckEventFiredWhenAddHealth()`: this tests that an OnChangeHealth() event
    is published when the player''s health is increased'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckEventFiredWhenAddHealth()`: 这个测试验证当玩家的生命值增加时，会发布 OnChangeHealth() 事件'
- en: '`CheckEventFiredWhenReduceHealth()`: this tests that an OnChangeHealth() event
    is published when the player''s health is decreased'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckEventFiredWhenReduceHealth()`: 这个测试验证当玩家的生命值减少时，会发布 OnChangeHealth()
    事件'
- en: 'class `TestLogging`:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'class `TestLogging`:'
- en: '`CorrectDebugLogMessageAfterHealthReduced()`: this tests that a Debug.Log message
    is correctly logged after the player''s heath is reduced by 0.1 to 0.9'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CorrectDebugLogMessageAfterHealthReduced()`: 这个测试验证在玩家的生命值减少到0.1到0.9之后，Debug.Log
    消息被正确记录'
- en: 'class `TestExceptions`:'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'class `TestExceptions`:'
- en: '`Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()`: this tests that
    an ArgumentOutOfRangeException is thrown when a negative value is passed to the
    AddHealth(...) player method'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()`: 这个测试验证当将负值传递给 AddHealth(...)
    玩家方法时，会抛出 ArgumentOutOfRangeException'
- en: '`Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()`: this tests that
    an ArgumentOutOfRangeException is thrown when a negative value is passed to the
    ReduceHealth(...) player method'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()`: 这个测试验证当将负值传递给
    ReduceHealth(...) 玩家方法时，会抛出 ArgumentOutOfRangeException'
- en: These two tests illustrate one convention of naming tests that adds an underscore
    _ character between each word in the method name in order to improve readability.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试说明了命名测试的一个约定，即在方法名中的每个单词之间添加一个下划线 _ 字符，以提高可读性。
- en: See also
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Learn more about the LogAssert Unity Script reference in the Unity documentation:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 文档中了解更多关于 LogAssert Unity 脚本引用的信息：
- en: '[https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html](https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html](https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html)'
- en: 'The method for unit testing C# events is adapted from a post on philosophicalgeek.com:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试 C# 事件的方法是借鉴自 philosophicalgeek.com 上的一个帖子：
- en: '[http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/](http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/](http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/)'
- en: The delegate-event publishing of health change events in this health bar feature
    is an example of the Publisher-Subscriber design pattern. Learn more about design
    patterns and their implementations for Unity games in `Chapter 17`, Extra Features
    and Design Patterns.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个健康条功能中，健康变化事件的委托-事件发布是一个发布者-订阅者设计模式的例子。在《第17章》中了解更多关于设计模式和它们在Unity游戏中的实现，章节名为“额外功能和设计模式”。
