- en: Chapter 6. Networking and Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters you learned how to use Unity's interface, manipulate objects,
    and add components and behaviors to them. You created gameplay using Playmaker
    actions and Unity scripting. We also looked at making custom actions from C# scripts.
    You made a fully playable air hockey game with an AI opponent using all these
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about networking. You will make a multiplayer
    mode for the game using **Photon Unity Networking** (**PUN**), which is a helpful
    plugin that comes with Playmaker and lets you make multiplayer games almost effortlessly.
    We will also talk about the theory of networking in games and discuss Unity native
    networking as an alternative to Photon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding networking and multiplayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Photon Unity Networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a multiplayer game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding networking and multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explaining things like TCP/IP and other low-level networking concepts is beyond
    the scope of this book, and we are going to try and keep everything as close to
    practical application as possible. On the other hand, it will be much easier for
    you to build multiplayer if you are familiar with at least some theory.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that you need to know is what servers and clients are. In simple
    terms, a server is a computer that responds to network requests from other computers,
    or more precisely, a system that responds to network requests from other systems,
    because you may have multiple servers and multiple clients on the same computer.
    This means that clients communicate with each other through a server. Typically,
    player systems are clients in multiplayer games, while servers are on computers
    that are accessed remotely. Sometimes, a player can *host* a game, in which case
    the player either acts as a server or simply tells the server to reserve its resources
    for the game.
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard about network architectures before. In games, the most popular
    architectures are arguably client-server and peer-to-peer. The former means that
    all the clients subscribe to a single server. The server hosts most of the important
    information about the game and distributes it between the players. The latter
    is about peers (players) connecting to one another directly, so all the clients
    are connected to each other, and the network workload is distributed evenly.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of client-server is that it allows creating a more stable system
    that ensures that cheating is either impossible or very hard, as well as makes
    it easier for the developer to monitor everything and make changes to the game
    on the fly. This method, however, is generally expensive and relatively hard to
    implement yourself if you are just a solo developer who is learning to make his/her
    first multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer does not require having a powerful server hosting multiple game
    sessions at the same time, allowing players to connect to each other, distributing
    the network workload between them. The drawback of peer-to-peer is that it tends
    to be less stable, and it is relatively hard to monitor. On top of that, you still
    need a server if you want to keep track of game sessions, perform matchmaking,
    and let your players play on the Internet instead of just a local network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is hard to connect to the Internet without having a server, because of something
    called **Native Address Translation** (**NAT**). Without getting into much detail,
    it should be noted that it is something that network routers do, and most of us
    have routers these days. A process commonly called **NAT punchthrough** is used
    in order to connect one computer to another, and this process requires a server
    acting as a mediator for the first connection between two computers.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, it is relatively easy to set up a **Local Area Network** (**LAN**),
    peer-to-peer connection, or client-server connection with one of the players hosting
    the game without using any external plugins. A LAN connection means that all the
    players are connected to the same local computer network. Unfortunately, whatever
    you do, you will need a server to make sure that players can always connect to
    each other over the Internet, which is what we want to do. Photon takes client-server
    and wraps it in an extremely easy to use interface that allows anyone to create
    multiplayer games without any prior experience. On top of that, it is very affordable
    for what it is.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Photon services allow players to host their own servers, but those
    take some time to set up. What we are going to use in this book is Photon Cloud.
    As the name implies, all the game sessions happen in the cloud, thus on remote
    Photon servers. All you need to do is synchronize your game's data through them
    and make sure that players can find each other. You do not need to set up a server,
    and you do not have to worry about the problems involved in making peer-to-peer
    multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: The way the synchronization works is that there is something called **Network
    View** (**Photon View** in Photon), which is a component that makes one or more
    game object's properties synchronized over the network. When such a property changes
    in one client, it changes in all the clients, with the server keeping track of
    everything and sending commands to clients. For example, mallet's position can
    be such a property. This way, when player 1 moves their mallet, player 2 sees
    them move it and vice versa. The same goes for almost any other property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we will show in this chapter's example, synchronizing positions can be okay
    for player objects (such as mallets in air hockey or characters in first person
    shooters), but objects that have physical behaviors (such as the puck), can experience
    serious network delays on remote computers. There is currently no easy solution
    for this problem apart from using Unity native networking.
  prefs: []
  type: TYPE_NORMAL
- en: There are objects that can belong to the scene (like the walls and the background)
    and so are exactly the same and unchangeable throughout all clients, and then
    there are objects that belong to different clients, such as the mallets. Generally,
    you want to synchronize as little data over the network as possible in order to
    avoid high response times. Scene objects do not have to get synchronized since
    they do not change. Moreover, this way each player's mallet responds only to that
    player's input, which makes perfect sense gameplay-wise.
  prefs: []
  type: TYPE_NORMAL
- en: You are now ready to start setting up Photon. All this theory may sound complicated,
    but it really comes down to synchronizing variables over the network using a special
    Photon component called Photon View.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Photon Unity Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Photon Unity Networking is a free Unity plugin with an optional paid subscription
    that allows you to outsource most of the heavy lifting for building multiplayer
    games. The free version has full functionality but is limited by the number of
    players that can be online at the same time. This is not a problem, because all
    you need for testing is to be able to connect as many players as your game requires
    for being playable (so two for air hockey).
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will need to set up PUN. In the main menu, navigate to **PlayMaker**
    | **Addons** | **Photon Networking** | **Set up Photon Networking**. This should
    open the **Photon Setup Wizard** window. Click on the orange **Setup** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is the first time you are using Photon, you are going to need an account,
    so enter your e-mail in the appropriate field and click on the **Send** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that you can finish the registration process by clicking on the link that
    you will have received by e-mail. Sign in to your account on [http://cloud.exitgames.com/](http://cloud.exitgames.com/),
    click on the **New App** button on your account page, enter the game's name and
    description, and then click on **Create**. You should be redirected back to your
    account page. In the **Details** section, copy the code under **AppID** and go
    back to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Photon Setup Wizard**, click on the **Setup** button, paste your AppID
    into the **Your AppId** text field, and choose your region by pressing one of
    the **Cloud Region** buttons. Make sure you choose the region that is closer to
    you geographically as this will affect the connection speed of your game's multiplayer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have pasted the AppID and chosen the region, click on the **Save**
    button below. A window should pop up saying that your settings have been saved.
    Click on **OK**. The following screenshot shows what the setup window is supposed
    to look like once you do:![Setting up Photon Unity Networking](img/8108OT_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure that the green label saying **Photon server is set up properly** appears
    near the top of the window. Press the **Main Menu** button right below it. It
    should take you back to the first screen of **Photon Setup Wizard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of your main game scene and call it `Multiplayer`, load it by double-clicking
    it in the **Project** panel, and then go back to **Photon Setup Wizard** window
    and click on **Add Photon System to the scene**. The button should disappear,
    and you should see the second green label saying **The scene is set up properly**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point Photon Cloud is set up, and you can feel free to close the wizard
    window. Save the **Multiplayer** scene, making sure that the **PlayMaker Photon
    Proxy** game object was added to **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can modify the settings any time you want. You can also change your AppID
    if you choose to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added Photon to the project and made a scene dedicated to multiplayer,
    it is time to synchronize objects over the network and set up matchmaking.
  prefs: []
  type: TYPE_NORMAL
- en: Making multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few game objects that have to be synchronized in our game, including
    the goals, the puck, and the mallets. We also need to make a few adjustments to
    the scene and set up matchmaking.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the Photon Playmaker example as a template for our game,
    using the scenes from there and modifying them to suit our purposes. This is generally
    a good idea if you want to set up multiplayer quickly, because these examples
    feature numerous and complex FSMs that would take quite a lot of time to set up,
    while most of the things you will need have already been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the demo scenes here: [http://www.hutonggames.com/samples.php](http://www.hutonggames.com/samples.php).
    Simply click on the link **Download PlayMaker Photon Demo** (requires Unity 3.5+
    Playmaker 1.6.1+). Then you will need to find the downloaded `unitypackage` file
    on your computer and double-click on it. This will prompt the import window. Click
    on the **Import** button in the bottom-right corner of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The warning on the example download page advises against importing the example
    into existing projects. We can ignore this warning, because none of our files
    are named in the same way the ones in the example are. As a general rule, you
    should always make sure that this is the case before importing new packages into
    new empty projects. Otherwise you might find yourself losing important assets
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Save the **Multiplayer** scene, and let us add the demo scenes to our project.
    They should be under `Photon Unity Networking/PlayMaker/Demo/Separated Scenes
    Demo`. Open the **demo_lobby** scene by double-clicking on its file.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is add the new scenes to our project. Open **Build
    Settings** by pressing *Shift* + *command* + *B* (*Shift* + *Ctrl* + *B* in Windows),
    then click on the **Add Current** button shown in the following screenshot. This
    will add the currently open scene to the project. Do this for **demo_lobby** and
    **demo_room**. Then close **Build Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making multiplayer](img/8108OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These two scenes are going to be responsible for two states of the game: the
    matchmaking state where players can find and create servers and the match state
    where the game itself takes place. You can test how it works by opening two instances
    of your game at once: one in the Unity Editor, one in your web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: To make a browser build, select **File** | **Build & Run** from the main menu
    and save the build files wherever you want on your computer when the file browser
    appears. You might want to create a special `Build` folder to make sure that you
    can always find your build. This should automatically open the game in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that your platform has to be set to Web Player as described in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Unity and Playmaker"), *Getting
    Started with Unity and Playmaker*. If it is not, open **Build Settings**, select
    **Web Player** from the list on the left, and click on the **Switch Platform**
    button. Then close the **Build Settings** window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Specify your nickname, and the name of the room next to **CREATE ROOM**, then
    click on **GO** on the right from the room name text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new scene should load, where you control a construction worker that can walk
    around on a plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keeping the game open in your web browser, go back to the Unity Editor; make
    sure that **demo_scene** is open and click on play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **GO** button next to **EXISTING ROOMS**. This will join a random
    exiting room. Since we only created one room, both of the game instances will
    now be connected to the same game session. This way you can test how networking
    works by looking at your scene from the points of view of two players.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have seen how multiplayer works in the example project, it is time
    to modify its scenes to work with our game. We are going to keep the matchmaking
    intact (in fact, it can be kept this way for almost any multiplayer game). The
    only thing that needs changing is the maximum number of players that can join
    a single room. You may have noticed that the example project allows for 100 players.
    We need to change it to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: In the **demo_lobby** scene, select the **Menu** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Create Room** FSM from the second drop-down list from the left in
    the menu on top of the **playMaker** FSM view.![Making multiplayer](img/8108OT_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Photon Network **Create Room** action of the create room state, set the
    **Max Number Of Players** property to `2`. Now up to two players will be able
    to join one room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the lobby is all set, it is time to set up the game itself to work
    via the network.
  prefs: []
  type: TYPE_NORMAL
- en: Make a copy of the **demo_room** scene as backup to be able to go back to if
    something goes wrong. Open the original **demo_room** scene. You should have an
    unnamed game object with four children as well as **Chat**, **Game**, and the
    **PlayMaker Photon Proxy** game objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can delete everything except the **Game** game object. This is where most
    of the initial multiplayer logic (such as instantiating players) takes place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene and go back to the **Multiplayer** scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select all the objects in this scene's **Hierarchy** by either pressing *command*
    + *A* (*Ctrl* + *A* in Windows) or clicking on the first item in the list and
    then *Shift*-clicking on the last one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the selected objects by pressing *command* + *C* (*Ctrl* + *C* in Windows),
    then open the **demo_room** scene again and press *command* + *V* (*Ctrl* + *V*
    in Windows) to paste them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create empty prefabs called `Goal`, `Mallet`, and `Puck` under **Prefabs**/**Resources**.
    Create the folders if you don't have them yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **GoalLeft** game object into the `Goal` prefab, **MalletLeft** game
    object into the `Mallet` prefab, and **Puck** game object into the `Puck` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the following objects from the scene: **MalletLeft**, **MalletRight**,
    and **Puck**. They are going to be instantiated from prefabs that you just created
    when players join the room.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make **GoalLeft** and **GoalRight** invisible by deactivating their **Mesh Renderer**
    components. These objects will be instantiated from prefabs as well, but not right
    away, so we need to keep them in the scene for their colliders to make sure that
    no mallets can get out of the table. You can also rename both of them `Blocker`,
    since they are needed to block the mallets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Game** game object and open its **Game Manager** FSM in the **playMaker**
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Variables** tab, make sure you have three **GameObject** variables:
    **goalRef**, **player prefab**, and **puck prefab**, as well as an **Int** variable
    **player count**. Drag the `Mallet` prefab into the **GameObject** slot of **player
    prefab** and the `Puck` into the the **GameObject** slot of **puck prefab**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Events** tab, create a new event called `Two Players`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Photon Network Instantiate** action of the **instantiate player** state,
    make sure that **Rotation** is set to (`0`, `0`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another **Photon Network Instantiate** action to the same state. Set its
    **Game Object** property to **Goal** by dragging the `Goal` prefab from the **Project**
    panel. Set the **Position** property to `(-7.98`, `2`, `0`) and the **Rotation**
    property to (`0`, `90`, `0`). Set **Store Object** to **goalRef**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new state called `How many players?` and add **Photon Network Get Room
    Properties** and the **Int Compare** actions to it. Make sure the former is before
    the latter in the list. If an error saying that PlayMakerPhotonGameObjectProxy
    component is required appears, click on it, and the component in question will
    be added automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Player Count** property of the **Photon Network Get Room Properties**
    action to the **player count** variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Int Compare** action, set the **Integer 1** property to the **player
    count** variable and the **Integer 2** property to `2`. Set **Equal** to **Two
    Players**. Check the **Every Frame** box. If you see an error about an event,
    ignore it for now; it will be fixed later on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new state called `Create Puck`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **FINISHED** event to the **instantiate player** state. Drag a transition
    from it to **How many players?**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Two Players** event to **How many players?** and drag a transition from
    it to **Create Puck**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Create Puck** state, add two actions: **Photon Network Instantiate**
    and **Set Position**. Make sure that **Set Position** is the last in the list.
    If an error saying that a PlayMakerPhotonGameObjectProxy component is required
    appears, click on it, and the component in question will be added automatically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Game Object** property of **Photon Network Instantiate** to the `Puck`
    prefab variable. Set **Position** to (`0`, `0.3`, `0`) and **Rotation** to (`0`,
    `0`, `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Set Position** action, set **Game Object** to **Specify Game Object**
    and select the **goalRef** variable from the drop-down list. Make sure that **Vector**
    is **None**, **X** is `7.98`, and **Y** and **Z** are **None**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This state machine is responsible for spawning objects that should be unique
    to different players: players'' mallets and goals are spawned as soon as the players
    connect to the room, while the puck is spawned once the second player connects
    to make sure that player 1 does not win while alone in the room.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to set the individual parameters and synchronization of each
    of the prefabs we created, starting with `Goal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `Goal` prefab in the **Project** panel and add three components
    to it using the **Inspector** panel: **PlayMaker FSM** (**Script**), **Photon
    View**, and **Play Maker Photon Game Object Proxy**. You can find these components
    by clicking on the **Add Component** button in **Inspector** and typing their
    names in the search field.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Transform** component of `Goal` prefab into the **Photon View** component's
    **Observe** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the state machine `ColorSync` using the **FSM** tab of the **playMaker**
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename the starting state to `is mine?` and add two events to it: **YES** and
    **NO**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create two new states: **Green** and **Red**. Then make transitions from **YES**
    to **Green** and from **NO** to **Red**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **is mine?** state, add a **Photon View Get Is Mine** action. Set **Is
    Mine Event** to **YES** and **Is Not Mine Event** to **NO**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Green** state, add a **Set Material** action. Set **Material** to the
    material you created for the green goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do the same for the **Red** state, but choose the red material instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This state machine makes sure that goals change color in the beginning of the
    game. Verify that you still have the **PlayMaker Photon Proxy** game object in
    the scene. If you don't copy it from the **Multiplayer** scene. At this point
    you may want to build and launch two instances of the game to test that everything
    works well.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us change the color of the mallets to match the goals' colors. We will
    also make sure that only the owner of the Mallet can move it.
  prefs: []
  type: TYPE_NORMAL
- en: Find the `Fsm Photon player` prefab under `Photon Unity Networking/PlayMaker/Demo/Resources`
    in the **Project** panel and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy **Play Maker Photon Game Object Proxy** and the **Photon View** components
    over to the `Mallet` prefab by right-clicking the components' headers of `Fsm
    Photon player` and selecting **Copy Component** from the drop-down menu and then
    right-clicking one of the components' headers in the `Mallet` prefab and selecting
    **Paste Component As New** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for three of the `Fsm Photon player` prefab''s **Play Maker FSM**
    components: the ones called **GameObject naming**, **Position synch**, and **variable
    synch repository**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the Mallet should have four FSMs. Rename the one called **FSM** to `Movement`
    to make sure we remember what it does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Play Maker FSM** called **variable synch repository** into the **Observe**
    slot of **Photon View**. Set the **Observe option** property to **Reliable Data
    Compressed**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **playMaker** panel, open the **Movement** FSM and add a `Bool` variable
    to it called **isMine**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the FSM as shown in the following screenshot, making sure that both the
    **Move** and **Push Puck** states stay unchanged. If you don't have the **Push
    Puck** state (you probably have it) confirm that the **Move** state has the **Push
    Puck** action attached to it. In order to set a state as a start state, right
    click on it and select **Set as Start State** from the contextual menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Is mine?** state and add the **Photon View Get Is Mine** action
    to it. Set its parameters as shown in the following screenshot, then add a transition
    from the **Yes** event to the **Move** state:![Making multiplayer](img/8108OT_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **GameObject naming** FSM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **add "me" to the gameObject name** state, add a **Set Material** action
    and set its **Material** property to the green material you created for one of
    the mallets. Don't worry if it is no longer green, just make sure that each player's
    **Goal** material matches his/her **Mallet** material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **add player to gameObject name** state, add a **SetMaterial** action
    as well. This time set the **Material** property to the material that matches
    the red goal's material.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **Position synch** FSM, and select the **Set player position with
    lerp** state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Set Position** action, set **X** to **None**, **Y** to `0.85`, and
    **Z** to **None**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the mallets should be good to go, their positions synched over the network
    and colors set on startup. Save your scene and confirm that mallets' positions
    are synced by building the game and launching two instances of it while connecting
    to the same match.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left is to sync the Puck's position over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Puck` prefab and add the **Photon View** and **Play Maker Photon
    Game Object Proxy** components to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the **Position synch** and **variable synch repository** FSMs to it from
    the `Fsm Photon player` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **variable synch repository** component of **Play Maker FSM** into
    the **Observe** slot of **Photon View** and set its **Observer** option to **Reliable
    Data Compressed**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the **Position synch** FSM and select the **Set player position with
    lerp** state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Set Position** action, set **X** to **None**, **Y** to `0.3`, and **Z**
    to **None**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing that you need to do is make sure that one of the players leaves
    the room instead of just reloading the level once the puck hits a goal. To do
    that, select the **GoalTriggerLeft** game object and, in the **LoadLevel** state
    of its FSM, replace the **Load Level** action with **Photon Network Leave Room**.
    Do the same for **GoalTriggerRight**.
  prefs: []
  type: TYPE_NORMAL
- en: Now your multiplayer should be set up. Before testing everything, confirm that
    you have copied all of the files over from the **Multiplayer** scene correctly.
    Make sure that there is a game object called **PlayMakerPhotonProxy** in both
    **demo_lobby** and **demo_room** scenes. If it is missing in one of the scenes,
    add it by going to **PlayMaker** | **Addons** | **Photon Networking** | **Components**
    | **Add Photon proxy to scene** from the main menu, then save the scene.
  prefs: []
  type: TYPE_NORMAL
- en: You can test it by making a build and opening it in your browser while launching
    the game in the Editor. Make sure you always start from the **demo_lobby** scene,
    because otherwise the matchmaking will not work.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that the mallets' and the puck's positions are synched over the
    network. That is, they move simultaneously in both Editor and web browser. You
    will also notice that the movement of the remote object is somewhat jerky and
    imprecise (especially the puck on the host's client). This is due to the inevitable
    network delay and physics data being calculated more often than Photon packages
    are being sent. At the moment the only real solution to this problem is switching
    to Unity native networking, which, however, requires that you have your own server
    if you want the game to work over the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: The place where the objects' movement is smoothed out is the **Position synch**
    FSM of `Puck` and `Mallet` prefabs. If you look at the **get player position**
    and **Set player position with lerp states** of these state machines, you will
    see that, if the object was first created on the local machine, its position gets
    saved in a variable every frame and synched over the network. If the object does
    not belong to the player's client, the variable is read, and then the position
    of the local copy of the object is interpolated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You could try changing the **Amount** property of the **Vector3 Lerp 2** action
    in the **Set player position with lerp** state. This variable determines the precision
    of the interpolation. If you want to know more about the way PUN works under the
    hood, make sure you consult its online documentation that explains every state
    machine in the demo scenes in great detail: [https://hutonggames.fogbugz.com/default.asp?W927](https://hutonggames.fogbugz.com/default.asp?W927)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, Photon networking is quite easy to set up, but is not a very
    good solution for games that require physics simulation. This is mostly due to
    cloud server limitations and limited integration with the Unity engine. Most simple
    games that don''t rely on physics so heavily can benefit from Photon greatly.
    In other cases, Unity native networking should be used. More information about
    it can be found in the Network Reference Guide section of the Unity documentation:
    [http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html](http://docs.unity3d.com/Documentation/Components/NetworkReferenceGuide.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Playmaker is capable of working with native Unity networking as well. You can
    check the **Network** section of the **Actions** panel for the list of available
    Playmaker actions and compare them with the actions described in the reference
    material.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of networking in games, set up the Photon
    Unity Networking plugin to work with Playmaker, and added PUN multiplayer to your
    game. We also examined the advantages and disadvantages of Photon and showed that
    it may not be suitable for physics games such as air hockey, because of the network
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will show how to put your game on the Web and add Kongregate
    API to save game scores in an online leaderboard.
  prefs: []
  type: TYPE_NORMAL
