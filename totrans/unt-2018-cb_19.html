<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Automated Testing</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Generating and running a default test script class</li>
<li>Performing a simple unit test</li>
<li>Parameterizing tests with a data provider method</li>
<li>Unit testing a simple health script class</li>
<li>Creating and executing a unit test in PlayMode</li>
<li>PlayMode testing a door animation</li>
<li>PlayMode and unit testing a player health bar with events, logging, and exceptions</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>For a very simple computer program, we can write code, then run it, entering a variety of valid and invalid data, and see whether the program behaves as we expect it to. This is known as a code-then-test approach. However, this approach has several significant weaknesses:</p>
<ul>
<li>Each time we change the code, as well as running new tests relating to the code we are improving, we have to run all the old tests to ensure that no unexpected modified behaviors have been introduced (in other words, our new code has not <strong>broken</strong> another part of our program)</li>
<li>Running tests manually is time consuming</li>
<li>We are relying on a human to rerun the test each time, and this test may be run using different data, or some data may be omitted, or different team members may take a different approach to running tests</li>
</ul>
<p>Therefore, even for simple programs (and most are not simple), some kind of fast, automated testing system makes a lot of sense.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The big picture</h1>
                </header>
            
            <article>
                
<p>There is an approach to software development called <strong>Test-Driven Development</strong> (<strong>TDD</strong>), whereby code is <strong>only</strong> written until all tests pass. So, if we want to add or improve the behavior of our game program, we must specify what we want in terms of tests, and then the programmers write code to pass the tests. This avoids a situation whereby programmers write code and features that are not needed, or spend time over-optimizing things that would have been fine, and so on. It means that the game development team directs its work toward agreed goals understood by all, since they have been specified as tests.</p>
<p>The following diagram illustrates basic TDD in that we only write code until all tests pass. Then it's time to write more tests:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c9ca918d-641c-4ed7-adae-842e174b6676.png"/></div>
<p>Another way that TDD is often summarized is as <span>red-green-refactor:</span></p>
<ul>
<li><strong><span class="KeyWordPACKT">red:</span></strong> We write code that fails the test (in other words, for the new feature/improved behavior we wish to add to our system)</li>
<li><strong><span class="KeyWordPACKT">green:</span></strong><span> W</span>e write code that passes the new test (and all the existing ones)</li>
<li><strong><span class="KeyWordPACKT">refactor:</span></strong><span> W</span>e (may) choose to improve the code (and ensure that the improved code passes all the tests)</li>
</ul>
<p>Two kinds of software test are the following:</p>
<ul>
<li><strong><span class="KeyWordPACKT">Unit tests</span></strong></li>
<li><strong><span class="KeyWordPACKT">Integration tests</span></strong></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>A <strong>U<span class="KeyWordPACKT">nit Test</span></strong> tests a "unit" of code, which can be a single method, but which may include some other computer work being executed between the method being tested and the end result(s) being checked.</p>
<div class="packt_quote CDPAlignLeft CDPAlign"><em>"A unit test is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. If the assumptions on the end result turn out to be wrong, the unit test has failed</em>."<br/>
                               —Roy Oshergrove (p. 5, <em>The Art of Unit Testing</em> (Second edition).</div>
<p>Unit tests should be as follows:</p>
<ul>
<li>automated (runnable at the "push of a button")</li>
<li>fast</li>
<li>easy to implement</li>
<li>easy to read</li>
<li>executed in isolation (tests should be independent from one another)</li>
<li>assessed as either having being passed or failed</li>
<li>relevant tomorrow</li>
<li>consistent (the same results each time!)</li>
<li>able to easily pinpoint what was at fault for each test that fails</li>
</ul>
<p>Most computer languages have an xUnit unit testing system available, for example:</p>
<ul>
<li>C#: NUnit</li>
<li>Java: JUnit</li>
<li>PHP: PHPUnit</li>
</ul>
<p>Unity offers an easy way to write and execute NUnit tests in its editor (and at the command line).</p>
<p>Typically, each unit test will be written in three sections, a sequence of:</p>
<ul>
<li><strong><span class="KeyWordPACKT">Arrange</span></strong>: Set any initial values needed (sometimes, we are just giving a value to a variable in order to improve code readability)</li>
<li><strong><span class="KeyWordPACKT">Act</span></strong>: Invoke some code (and, if appropriate, store the results)</li>
<li><strong><span class="KeyWordPACKT">Assert</span></strong>: Make assertions for what should be true about the code invoked (and any stored results)</li>
</ul>
<p>Observe that the naming of a unit test method (by convention) is quite verbose—it is made up of lots of words that describe what it does. For example, you might have a unit test method <span class="CodeInTextPACKT">named <kbd>TestHealthNotGoAboveOne()</kbd></span>. The idea is that if a test fails, the name of the test should give a programmer a very good idea of what behavior is being tested and, therefore, how to quickly establish whether the test is correct and, if so, where to look in your program code for what was being tested. Another part of the convention of naming unit tests is that numerals are not used—ust words—so we write "one", "two", and so on, in the name of the test method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integration tests (PlayMode tests in Unity)</h1>
                </header>
            
            <article>
                
<p>An <strong>I<span class="KeyWordPACKT">ntegration Test</span></strong> involves checking the behavior of interacting software components, for example, ones that use real time, or a real filesystem, or that communicate with the web or other applications running on the computer. Integration tests are usually not as fast as unit tests, and may not produce consistent results (since the components may interact in different ways at different times).</p>
<p>Both <strong>U<span class="KeyWordPACKT">nit</span></strong> and <strong>I<span class="KeyWordPACKT">ntegration Test</span></strong> are important, but they are different and should be treated differently.</p>
<p>Unity offers <strong><span class="KeyWordPACKT">Play Mode</span></strong> testing, allowing integration testing as Unity scenes execute with testing code in them.</p>
<p>Places where you can learn more about Unity Testing include the following:</p>
<ul>
<li>Unity Test Runner and PlayMode documentation pages:
<ul>
<li><span class="URLPACKT"><a href="https://docs.unity3d.com/Manual/testing-editortestsrunner.html">https://docs.unity3d.com/Manual/testing-editortestsrunner.html</a></span></li>
<li><a href="https://docs.unity3d.com/Manual/PlaymodeTestFramework.html"><span class="URLPACKT">https://docs.unity3d.com/Manual/PlaymodeTestFramework.html</span></a></li>
</ul>
</li>
<li>A website for the book "The Art of Unit Testing" (and lots of other learning resources associated with testing): <a href="http://artofunittesting.com/"><span class="URLPACKT">http://artofunittesting.com/</span></a></li>
<li>A great dual article tutorial about Unity testing by Tomek Paszek of Unity (talking about the old Unity test tools, but most of the content is still very relevant): <a href="https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/"><span class="URLPACKT">https://blogs.unity3d.com/2014/06/03/unit-testing-part-2-unit-testing-monobehaviours/</span></a></li>
<li>YouTube, where you can l<span>earn lots about Unity testing (and other topics) from Infalliblecode</span>: <a href="https://www.youtube.com/infalliblecode"><span class="URLPACKT">https://www.youtube.com/infalliblecode</span></a></li>
<li>CodeProject.com's introduction to TDD and NUnit: <a href="https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD"><span class="URLPACKT">https://www.codeproject.com/Articles/162041/Introduction-to-NUnit-and-TDD</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a default test script class</h1>
                </header>
            
            <article>
                
<p>Unity can create a default C# test script for you, thereby enabling you to quickly start creating and executing tests on your project:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/ae577c7a-a58a-4000-9eda-6f93e1110c47.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To generate a default test script class, follow these steps:</p>
<ol>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Project</span></span> panel, create a folder called <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span></li>
<li>Display the <span class="ScreenTextPACKT">Test Runner</span> panel by choosing the following menu: <span class="packt_screen">Window</span> <span class="packt_screen"><span class="ScreenTextPACKT">|</span></span> <span class="packt_screen">General</span> <span class="packt_screen"><span class="ScreenTextPACKT">|</span></span> <span class="packt_screen">Test Runner</span></li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">EditMode</span></span> button is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel</li>
<li>Ensure that your new <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> folder is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the <span class="packt_screen"><span class="ScreenTextPACKT">Create Test Script in the current folder</span></span> <span>button</span></li>
<li>You should now have a new C# script added to your <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span> <span>folder</span></span></li>
<li>To run the tests in your script class, click the <span class="ScreenTextPACKT"><span class="packt_screen">Run All</span></span> button in the <span class="packt_screen"><span class="ScreenTextPACKT">Test Running</span> panel</span></li>
<li>You should now see all green ticks (check marks) in the panel</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Unity checks that you have a folder named <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span> selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, and then creates a C# <span class="CodeInTextPACKT">NewTestScript</span> <span>script class </span>for you containing the following:</p>
<pre>    using UnityEngine;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/> <br/>     public class NewTestScript {<br/>         [Test]<br/>         public void NewTestScriptSimplePasses() {<br/>             // Use the Assert class to test conditions.<br/>         }<br/> <br/>         // A UnityTest behaves like a coroutine in PlayMode<br/>         // and allows you to yield null to skip a frame in EditMode<br/>         [UnityTest]<br/>         public IEnumerator NewTestScriptWithEnumeratorPasses() {<br/>             // Use the Assert class to test conditions.<br/>             // yield to skip a frame<br/>             yield return null;<br/>         }<br/>     } </pre>
<p>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, you should see the script class and its two methods listed. Note that the first line in the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel is the Unity project name, the second line will say <kbd><span class="CodeInTextPACKT">Assembly-CSharp-Editor.dll</span></kbd>, followed by your script class name, and then each of the test methods:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f7fcf6a3-c7ad-4c50-849a-b3f16d5e0203.png"/></div>
<p>There are three symbols to indicate the status of each test/class:</p>
<ul>
<li><strong>Empty circle</strong>: Test not executed since the script class was last changed</li>
<li><strong>Green tick</strong> (check mark): The test was passed <span>successfully</span></li>
<li><strong>Red cross</strong>: The test was failed</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Create a default test script from the Project panel's Create menu</h1>
                </header>
            
            <article>
                
<p>Another way of creating a default <span class="packt_screen">U<span class="ScreenTextPACKT">nit Test</span></span> script is as follows:</p>
<ul>
<li>From the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, chose the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Create</span> | <span class="packt_screen">Testing</span> | <span class="packt_screen">C# Test Script</span></span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Edit mode minimum skeleton unit test script</h1>
                </header>
            
            <article>
                
<p>Be aware that if you are only going to use this script class for testing in <span class="packt_screen">EditMode</span>, you can delete the second method and some of the using statements as follows, so as to give you a minimal skeleton to work from:</p>
<pre>    using NUnit.Framework;<br/> <br/>     public class UnitTestSkeleton<br/>     {<br/>         [Test]<br/>         public void NewTestScriptSimplePasses()<br/>         {<br/>             // write your assertion(s) here<br/>         }<br/>     } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple unit test</h1>
                </header>
            
            <article>
                
<p>In the same way as printing "hello world" is most programmers first program statement, asserting that 1 + 1 = 2 is perhaps the most common first test executed for those learning unit testing. That's what we'll create in this recipe:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d6ba1b96-51a1-42fc-9439-6619d61ecd02.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create and execute a simple unit test, follow these steps:</p>
<ol>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, create a <span class="ScreenTextPACKT"><span>folder called <span class="packt_screen">Editor</span></span></span>.</li>
<li>Inside your <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span> folder, create a new C# <span class="CodeInTextPACKT"><kbd>SimpleTester.cs</kbd> <span>script class </span></span>containing the following:</li>
</ol>
<pre>    using NUnit.Framework;<br/> <br/>     class SimpleTester<br/>     {<br/>         [Test]<br/>         public void TestOnePlusOneEqualsTwo()<br/>         {<br/>             // Arrange<br/>             int n1 = 1;<br/>             int n2 = 1;<br/>             int expectedResult = 2;<br/> <br/>             // Act<br/>             int result = n1 + n2;<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="3">
<li>Display the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel by choosing the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Window</span> | <span class="packt_screen">General</span> | <span class="packt_screen">Test Runner</span>.</span></li>
<li>Ensure that the <kbd><span class="ScreenTextPACKT">EditMode</span></kbd> button is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel.</li>
<li>Click <span class="packt_screen">Run All</span><span class="ScreenTextPACKT">.</span></li>
<li>You should see the results of your <span class="packt_screen">U<span class="ScreenTextPACKT">nit Test</span></span> being executed – if the test was concluded successfully, it should have a green 'tick' next to it.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have declared that the <kbd><span class="CodeInTextPACKT">TestOnePlusOneEqualsTwo()</span></kbd> <span>method </span>in the C# <kbd>SimpleTester.cs</kbd> <span>script class </span>is a test method. When executing this test method, the <span class="ScreenTextPACKT"><span class="packt_screen">Unity Test Runner</span></span> executes each statement in sequence, so variables <kbd><span class="CodeInTextPACKT">n1</span></kbd>, <span class="CodeInTextPACKT"><kbd>n2</kbd>,</span> and <kbd><span class="CodeInTextPACKT">expectedResult</span></kbd> are set, then the calculation of 1 + 1 is stored in the variable result, and finally (the most important bit), we make an assertion of what should be true after executing that code. Our assertion states that the value of the <kbd><span class="CodeInTextPACKT">expectedResult</span></kbd> <span>variable </span>should be equal to the value of the variable result.</p>
<p>If the assertion is true, the test is passed, otherwise it is failed. Generally, as programmers, we expect our code to pass, so we inspect each fail very carefully, first to see whether we have an obvious error, then perhaps to check whether the test itself is correct (especially if it's a new test), and then to begin to debug and understand why our code behaved in such a way that it did not yield the anticipated result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>Here are some details that you won't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Shorter tests with values in the assertion</h1>
                </header>
            
            <article>
                
<p>For simple calculations, some programmers prefer to write less test code by putting the values directly into the assertion. So, as shown below, our 1 + 1 = 2 test could be expressed in a single assertion, where the expected value of 2, and the expression 1 + 1, are entered <span>directly </span>into an <kbd><span class="CodeInTextPACKT">AreEqual(...)</span></kbd> method invocation:</p>
<pre>    using NUnit.Framework;<br/> <br/>     class SimpleTester<br/>     {<br/>         [Test]<br/>         public void TestOnePlusOneEqualsTwo()<br/>         {<br/>             // Assert<br/>             Assert.AreEqual(2, 1 + 1);<br/>         }<br/>     } </pre>
<p>However, if you are new to testing, you may prefer the previous approach, whereby the preparation, code execution, and storage of results, and the assertion of properties about those results, are structured clearly in a sequence of <strong>Arrange/Act/Assert</strong>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Expected value followed by the actual value</h1>
                </header>
            
            <article>
                
<p>When comparing values with assertions, it is customary for the expected (correct) value to be given first, followed by the actual value:</p>
<pre>    Assert.AreEqual( &lt;expectedValue&gt;, &lt;actualValue&gt; ); </pre>
<p>While it makes no difference to the true or false nature of equality, and so on, it can make a difference to messages when tests fail with some testing frameworks (for example, "got 2 but expected 3" has a very different meaning to "got 3 but expected 2"). Hence, the following assertion <span>would output a message that would be confusing, since 2 was our expected result</span><span>:</span></p>
<p> </p>
<pre>    public void TestTwoEqualsThreeShouldFail() {<br/>         // Arrange<br/>         int expectedResult = 2;<br/> <br/>         // Act<br/>         int result = 1 + 2; // 3 !!!<br/> <br/>         // Assert<br/>         Assert.AreEqual(result, expectedResult);<br/>     } </pre>
<p>Refer to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/69dd1664-2b61-4de9-b131-5c3bf8b392de.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parameterizing tests with a data provider method</h1>
                </header>
            
            <article>
                
<p>If we are testing our code using a range of test data, then sometimes there is little difference between each test apart from the the values. Rather than duplicating our Arrange/Act/Assert statements, we can re-use a single method, and the Unity Test Runner will loop through a collection of test data, running the test method for each set of test data. The special method that provides multiple sets of test data to a test method is known as a <span class="packt_screen">D<span class="ScreenTextPACKT">ataProvider</span></span>, and we'll create one in this recipe:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/23878553-e5bf-44f1-9f9d-fb3714659e72.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To parameterize tests with a data provider method, follow these steps:</p>
<ol>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, create a folder called <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>Inside your <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span> folder, create a new C# <span class="CodeInTextPACKT"><kbd>DataProviderTester.cs</kbd> <span>script class </span></span>containing the following:</li>
</ol>
<pre>    using NUnit.Framework;<br/> <br/>     class DataProviderTester<br/>     {<br/>         [Test, TestCaseSource("AdditionProvider")]<br/>         public void TestAdd(int num1, int num2, int expectedResult)<br/>         {<br/>             // Arrange<br/>             // (not needed - since values coming as arguments)<br/> <br/>             // Act<br/>             int result = num1 + num2;<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         // the data provider<br/>         static object[] AdditionProvider =<br/>         {<br/>             new object[] { 0, 0, 0 },<br/>             new object[] { 1, 0, 1 },<br/>             new object[] { 0, 1, 1 },<br/>             new object[] { 1, 1, 2 }<br/>         };<br/>     } </pre>
<ol start="3">
<li>Display the <span class="packt_screen">Test Runner</span> panel by choosing the following menu: <span class="packt_screen">Window</span> | <span class="packt_screen">General</span> | <span class="packt_screen">Test Runner</span>.</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">EditMode</span></span> button is selected in the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel.</li>
<li>Click <span class="ScreenTextPACKT"><span class="packt_screen">Run All</span>.</span></li>
<li>You should see the results of your <span class="packt_screen">U<span class="ScreenTextPACKT">nit Test</span></span> being executed. You should see four sets of results for the <span class="CodeInTextPACKT"><kbd>TestAdd(...)</kbd> <span>test method</span></span>, one for each of the datasets provided by the <kbd>AdditionProvider</kbd> <span>method</span>.</li>
</ol>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We have indicated that the <kbd><span class="CodeInTextPACKT">TestAdd(...)</span></kbd> <span>method </span>is a test method with a compiler attribute [Test]. However, in this case, we have added additional information to state that the data source for this method is the <span class="CodeInTextPACKT"><kbd>AdditionProvider</kbd> <span>method</span></span>.</p>
<p>This means that the <span class="packt_screen"><span class="ScreenTextPACKT">Unity Test Runner</span></span> will retrieve the data objects from the additional provider, and create multiple tests for the <span class="CodeInTextPACKT"><kbd>TestAdd(...)</kbd> <span>method</span></span>, one for each set of data from the <kbd><span class="CodeInTextPACKT">AdditionProvider()</span></kbd> method.</p>
<p>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, we can see a line for each of these tests:</p>
<pre>    TestAdd(0,0,0)<br/>     TestAdd(1,0,1)<br/>     TestAdd(0,1,1)<br/>     TestAdd(1,1,2) </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit testing a simple health script class</h1>
                </header>
            
            <article>
                
<p>Let's create something that might be used in a game, and that can easily be unit tested. Classes that do <strong>not</strong> subclass from <span class="CodeInTextPACKT">Monobehavior</span> are much easier to unit test, since instance objects can be created using the keyword <span class="ScreenTextPACKT"><span class="packt_screen">new</span></span>. If the class is carefully designed with private data and public methods with clearly declared dependencies as parameters, it becomes easy to write a set of tests to make us confident that objects of this class will behave as expected in terms of default values, as well as valid and invalid data.</p>
<p>In this recipe, we will create a health script class, and a set of tests for this class. This kind of class can be reused for both the health of human players, and also Artificial Intelligence (<span>AI)</span>-controlled enemies in a game:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1db24c0c-d5e6-4c17-a24c-153834a86a78.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To unit test a health script class, follow these steps:</p>
<ol>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, create a <span class="ScreenTextPACKT"><span class="packt_screen">_Scripts</span> <span>folder</span></span>.</li>
<li>Inside your <kbd><span class="ScreenTextPACKT">_Scripts</span></kbd> folder, create a new C# <span class="CodeInTextPACKT"><kbd>Health.cs</kbd> <span>script class</span></span> containing the following:</li>
</ol>
<pre>    using UnityEngine;<br/>     using System.Collections;<br/> <br/>     public class Health<br/>     {<br/>         private float health = 1;<br/> <br/>         public float GetHealth()<br/>         {<br/>             return health;<br/>         }<br/> <br/>         public bool AddHealth(float heathPlus)<br/>         {<br/>             if(heathPlus &gt; 0){<br/>                 health += heathPlus;<br/>                 return true;<br/>             } else {<br/>                 return false;<br/>             }<br/>         }<br/> <br/>         public bool KillCharacter()<br/>         {<br/>             health = 0;<br/>             return true;<br/>         }<br/>     } </pre>
<ol start="3">
<li>Inside your <span class="ScreenTextPACKT"><span class="packt_screen">_Scripts</span></span> folder, create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span>.</li>
<li>Inside your <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span> folder, create a new C# <span class="CodeInTextPACKT"><kbd>TestHealth.cs</kbd> <span>script class </span></span>containing the following:</li>
</ol>
<pre style="padding-left: 60px"><span>using </span>NUnit.Framework<span>;<br/></span><span><br/></span><span>class </span>TestHealth <span>{</span><span><br/></span><span>   </span>[Test]<br/>   <span>public void </span><span>TestReturnsOneWhenCreated</span>()   {<br/>      <span>// Arrange<br/></span><span>      </span>Health h = <span>new </span>Health ()<span>;<br/></span><span>      </span><span>float </span>expectedResult = <span>1</span><span>;<br/></span><span><br/></span><span>      </span><span>// Act<br/></span><span>      </span><span>float </span>result = h.GetHealth ()<span>;<br/></span><span><br/></span><span>      </span><span>// Assert<br/></span><span>      </span>Assert.AreEqual (expectedResult<span>, </span>result)<span>;<br/></span><span>   </span>}     <br/><br/>    [Test]<br/>    <span>public void </span><span>TestPointTwoAfterAddPointOneTwiceAfterKill</span>()    {<br/>        <span>// Arrange<br/></span><span>        </span>Health h = <span>new </span>Health()<span>;<br/></span><span>        </span><span>float </span>healthToAdd = <span>0.1f</span><span>;<br/></span><span>        </span><span>float </span>expectedResult = <span>0.2f</span><span>;<br/></span><span><br/></span><span>        </span><span>// Act<br/></span><span>        </span>h.KillCharacter()<span>;<br/></span><span>        </span>h.AddHealth(healthToAdd)<span>;<br/></span><span>        </span>h.AddHealth(healthToAdd)<span>;<br/></span><span>        </span><span>float </span>result = h.GetHealth()<span>;<br/></span><span><br/></span><span><br/></span><span>        </span><span>// Assert<br/></span><span>        </span>Assert.AreEqual(expectedResult<span>, </span>result)<span>;<br/></span><span>    </span>}<br/><br/>    [Test]<br/>    <span>public void </span><span>TestNoChangeAndReturnsFalseWhenAddNegativeValue</span>()     {<br/>        <span>// Arrange<br/></span><span>        </span>Health h = <span>new </span>Health()<span>;<br/></span><span>        </span><span>float </span>healthToAdd = -<span>1</span><span>;<br/></span><span>        </span><span>bool </span>expectedResultBool = <span>false</span><span>;<br/></span><span>        </span><span>float </span>expectedResultFloat = <span>1</span><span>;<br/></span><span><br/></span><span>        </span><span>// Act<br/></span><span>        </span><span>bool </span>resultBool = h.AddHealth(healthToAdd)<span>;<br/></span><span>        </span><span>float </span>resultFloat = h.GetHealth()<span>;<br/></span><span><br/></span><span>        </span><span>// Assert<br/></span><span>        </span>Assert.AreEqual(expectedResultBool<span>, </span>resultBool)<span>;<br/></span><span>        </span>Assert.AreEqual(expectedResultFloat<span>, </span>resultFloat)<span>;<br/></span><span>    </span>}<br/><br/>    [Test]<br/>    <span>public void </span><span>TestReturnsZeroWhenKilled</span>()    {<br/>        <span>// Arrange<br/></span><span>        </span>Health h = <span>new </span>Health()<span>;<br/></span><span>        </span><span>float </span>expectedResult = <span>0</span><span>;<br/></span><span><br/></span><span>        </span><span>// Act<br/></span><span>        </span>h.KillCharacter()<span>;<br/></span><span>        </span><span>float </span>result = h.GetHealth()<span>;<br/></span><span><br/></span><span>        </span><span>// Assert<br/></span><span>        </span>Assert.AreEqual(expectedResult<span>, </span>result)<span>;<br/></span><span>    </span>}<br/><br/><br/>    [Test]<br/>    <span>public void </span><span>TestHealthNotGoAboveOne</span>()    {<br/>        <span>// Arrange<br/></span><span>        </span>Health h = <span>new </span>Health()<span>;<br/></span><span>        </span><span>float </span>expectedResult = <span>1</span><span>;<br/></span><span><br/></span><span>        </span><span>// Act<br/></span><span>        </span>h.AddHealth(<span>0.1f</span>)<span>;<br/></span><span>        </span>h.AddHealth(<span>0.5f</span>)<span>;<br/></span><span>        </span>h.AddHealth(<span>1</span>)<span>;<br/></span><span>        </span>h.AddHealth(<span>5</span>)<span>;<br/></span><span>        </span><span>float </span>result = h.GetHealth()<span>;<br/></span><span><br/></span><span>        </span><span>// Assert<br/></span><span>        </span>Assert.AreEqual(expectedResult<span>, </span>result)<span>;<br/></span><span>    </span>}<br/><span>}</span></pre>
<ol start="5">
<li>Display the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel by choosing the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Window</span> | <span class="packt_screen">Debug</span> | <span class="packt_screen">Test Runner</span>.</span></li>
<li>Ensure that the <span class="packt_screen"><span class="ScreenTextPACKT">EditMode</span></span> button is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel.</li>
<li>Click <span class="ScreenTextPACKT"><span class="packt_screen">Run All</span>.</span></li>
<li>You should see the results of your unit tests being executed.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Each of the C# script-classes is described below.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class Health.cs</h1>
                </header>
            
            <article>
                
<p>This script class has one private property; as it is private, it can only be changed by methods. Its initial value is 1.0, in other words, 100% health:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">health</span></kbd> (float): The valid range is from 0 (dead!) to 1.0 (100% health)</li>
</ul>
<p>There are 3 public methods:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">GetHealth()</span></kbd>: This returns the current value of the health float number (which should be between 0 and 1.0)</li>
<li><kbd><span class="CodeInTextPACKT">AddHealth(float)</span></kbd>: This takes as input a float (the amount to add to the health), and returns a Boolean true/false, as to whether the value was valid. Note the logic of this method is that it accepts values of 0 or more (and will return true), but it will ensure that the value of health is never more than 1</li>
<li><kbd><span class="CodeInTextPACKT">KillCharacter()</span></kbd>: This method sets health to zero, and returns true, since it is always successful in this action</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Script-class TestHealth.cs</h1>
                </header>
            
            <article>
                
<p>This script class has five methods:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">TestReturnsOneWhenCreated()</span></kbd>: This tests that the initial value of health is 1, when a new Health object is created.</li>
<li><kbd><span class="CodeInTextPACKT">TestPointTwoAfterAddPointOneTwiceAfterKill()</span></kbd>: This tests that after a kill (health set to zero), and then adding 0.1 on two occasions, the health should be 0.2.</li>
<li><kbd><span class="CodeInTextPACKT">TestReturnsZeroWhenKilled()</span></kbd>: This tests that the health value is set to zero immediately after the <kbd>KillCharacter()</kbd> method has been called.</li>
<li><kbd><span class="CodeInTextPACKT">TestNoChangeAndReturnsFalseWhenAddNegativeValue()</span></kbd>: This tests that attempting to add a negative value to health should return false and that the value of health should not have changed. This method is an example of a test with more than one assertion (but both are related to the actions.</li>
<li><kbd>TestHealthNotGoAboveOne()</kbd>: This test verifies that even when lots of values are added to health, totaling more than 1.0, the value returned from <kbd>GetHealth()</kbd> is one.</li>
</ul>
<p>Hopefully, all the tests pass when you run them, giving some confidence that the logic implementation in the <kbd><span class="CodeInTextPACKT">Health.cs</span></kbd> script class does behave as intended.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and executing a unit test in Play mode</h1>
                </header>
            
            <article>
                
<p>It's a good idea to write as much of the logic for a game as isolated, non-Monobehavior classes, that are easy to unit test in Edit mode. However, some of the logic in a game relates to things that happen when the game is running. Examples include physics, collisions, and timing-based events. We test these parts of our games in Play Mode.</p>
<p>In this recipe, we'll create one very simple Play Mode test, to check that physics affects a RigidBody (based on an example from the Unity documentation):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7d7fe717-66e1-4c2b-bbdb-6b312ea5e15f.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create and execute a unit test in <strong>Play</strong> mode, follow these steps:</p>
<ol>
<li>Display the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel by choosing the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Window</span> | <span class="packt_screen">General</span> | <span class="packt_screen">Test Runner</span></span></li>
<li>Enable PlayMode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, and then selecting <span class="ScreenTextPACKT"><span class="packt_screen">Enable playmode</span> <span class="packt_screen">tests</span> <span class="packt_screen">for all assemblies</span></span> (click OK to any message concerned with restarting the editor):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6abcb454-93c1-4ec8-be54-22864a5f354f.png"/></div>
<ol start="3">
<li>Now, restart the Unity Editor (just close the application and then reopen it with your project).</li>
</ol>
<div class="packt_infobox">It is very important that you restart the Unity Editor application after enabling <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span>. If you fail to do this, then you may not be able to locate your <span class="packt_screen"><span class="ScreenTextPACKT">PlayMode</span></span> test script classes where they can see (and refer to) your Monobehavior classes.</div>
<ol start="4">
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> button is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the <span class="ScreenTextPACKT"><span class="packt_screen">Create PlayMode Test Assembly Folder</span> button</span>. A new folder, named <span class="ScreenTextPACKT"><span class="packt_screen">Tests</span>,</span> should have been created.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, open the <span class="ScreenTextPACKT"><kbd>Tests</kbd> <span>folder</span></span>. It should contain an assembly definition file <span class="packt_screen">Tests.asmdef</span>.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the <span class="ScreenTextPACKT"><span class="packt_screen">Create Test Script in the current folder</span> button</span> – you may wish to rename this script from the default name, <kbd><span class="CodeInTextPACKT">NewTestScript</span></kbd>.</li>
<li>Edit your new test script, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/> <br/>     public class NewTestScript<br/>     {<br/>         [UnityTest]<br/>         public IEnumerator GameObject_WithRigidBody_WillBeAffectedByPhysics()<br/>         {<br/>             // Arrange<br/>             var go = new GameObject();<br/>             go.AddComponent&lt;Rigidbody&gt;();<br/>             var originalPosition = go.transform.position.y;<br/> <br/>             // Act<br/>             yield return new WaitForFixedUpdate();<br/> <br/>             // Assert<br/>             Assert.AreNotEqual(originalPosition, go.transform.position.y);<br/>         }<br/>     } </pre>
<ol start="9">
<li>Click <span class="ScreenTextPACKT"><span class="packt_screen">Run All</span>.</span></li>
<li>In the Hierarchy, you'll see that a temporary scene is created (named something along the lines of InitTestScene6623462364), and that a <span class="packt_screen"><span class="ScreenTextPACKT">GameObject</span></span> named <span class="ScreenTextPACKT"><span class="packt_screen">Code Based Test Runner</span> is created</span>.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Game</span></span> panel, you will briefly see the message <span class="ScreenTextPACKT"><span class="packt_screen">Display 1 No Cameras Rendering</span>.</span></li>
<li>You should see the results of your unit test being executed – if the test is concluded successfully, it should have a green tick next to it.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Methods marked with the <kbd><span class="CodeInTextPACKT">[UnityTest]</span></kbd> attribute are run as coroutines. A coroutine has the ability to pause execution (when it meets a yield statement) and return control to Unity, but then to continue where it left off when called again (for example, the next frame, second, or whatever). The yield statement indicates the statement after which, and for how long, execution of the method is to be paused. Examples of different types of yield include:</p>
<ul>
<li>Waiting until until the next frame: <kbd><span class="CodeInTextPACKT">null</span></kbd></li>
<li>Waiting for a given length of time: <kbd><span class="CodeInTextPACKT">WaitForSeconds(&lt;seconds&gt;)</span></kbd></li>
<li>Waiting until the next fixed-update time period (physics is not applied each frame (since the framerate varies), but after a fixed period of time): <kbd><span class="CodeInTextPACKT">WaitForFixedUpdate()</span></kbd></li>
</ul>
<p>Method <kbd><span class="CodeInTextPACKT">GameObject_WithRigidBody_WillBeAffectedByPhysics()</span></kbd> creates a new GameObject and attaches to it a RigidBody. It also stores the original Y position. The yield statement makes the <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode Test Runner</span></span> wait until physics has begun at the next fixed update period. Finally, an assertion is made that the original Y position is not equal to the new Y position (after the physics fixed update). Since the defaults for a RigidBody are that gravity will be applied, this is a good test that physics is being applied to the new object (in other words, it should have started falling down once physics had been applied).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayMode testing a door animation</h1>
                </header>
            
            <article>
                
<p>Having learned the basics of <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> testing in the previous recipe, now let's test something non-trivial that we might find in a game. In this recipe, we'll create a <span class="packt_screen">PlayMode</span> test to ensure that a door opening animation plays when the player's sphere object enters a collider.</p>
<p>A scene has been provided with the player's sphere initialized to roll toward a red door. When the sphere hits the collider (<kbd><span class="CodeInTextPACKT">OnTriggerEnter</span></kbd> event), some code sets the door's <span class="ScreenTextPACKT"><span class="packt_screen">Animator Controller Opening</span></span> variable to true, which transitions the door from its closed state to its open state, as can be seen in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/27a33dc2-b393-4ed7-aa36-9cb6807b6c2b.png"/></div>
<p>Thanks should go to the creator of the ground texture; it was designed by Starline, and published at <a href="http://Freepik.com"><span class="URLPACKT">Freepik.com</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, a Unity Package has been provided <kbd>(<span class="CodeInTextPACKT">doorScene.unitypackage</span>)</kbd> in the <kbd>19_06</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> test a door animation, follow these steps:</p>
<ol>
<li>Create a new Unity project, and delete the default folder <span class="packt_screen"><span class="ScreenTextPACKT">Scenes</span></span>.</li>
<li>Import the Unity package <span>provided </span>(<span class="CodeInTextPACKT">doorScene.unitypackage</span>).</li>
<li>Add the following scenes – <span class="ScreenTextPACKT"><span class="packt_screen">doorScene</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">menuScene</span></span> – to the project Build (the sequence doesn't matter).</li>
<li>Ensure that the scene <span>currently open </span>is <span class="packt_screen">menuScene</span>.</li>
<li>Display the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel by choosing the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Window</span> | <span class="packt_screen">General</span> | <span class="packt_screen">Test Runner</span></span></li>
<li>Enable playmode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, and selecting <span class="packt_screen"><span class="ScreenTextPACKT">Enable playmode tests for all assemblies</span></span> (click OK to any message concerned with restarting the editor).</li>
<li>Now restart the Unity Editor (just close the application and then reopen it with your project).</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> button is selected in the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, select the top-level folder <span class="ScreenTextPACKT"><span class="packt_screen">Assets</span></span>.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the "<span class="ScreenTextPACKT"><span class="packt_screen">Create PlayMode Test Assembly Folder</span></span>" button. A new folder, named Tests, should have been created.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, open the <span class="ScreenTextPACKT"><kbd>Tests</kbd> <span>folder</span></span>. It should contain an assembly definition file <kbd><span class="ScreenTextPACKT">Tests.asmdef</span></kbd>.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the "<span class="ScreenTextPACKT"><span class="packt_screen">Create Test Script in the current folder</span></span>" button. Rename this script class <kbd>DoorTest</kbd>.</li>
<li>Edit the <kbd><span class="CodeInTextPACKT">DoorTest.cs</span></kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using System.Collections;<br/>     using NUnit.Framework;<br/>     using UnityEngine;<br/>     using UnityEngine.SceneManagement;<br/>     using UnityEngine.TestTools;<br/> <br/>     public class DoorTest<br/>     {<br/>         const int BASE_LAYER = 0;<br/>         private string initialScenePath;<br/>         private Animator doorAnimator;<br/>         private Scene tempTestScene;<br/> <br/>         // name of scene being tested by this class<br/>         private string sceneToTest = "doorScene";<br/> <br/>         [SetUp]<br/>         public void Setup()<br/>         {<br/>             // setup - load the scene<br/>             tempTestScene = SceneManager.GetActiveScene();<br/>         }<br/>     } </pre>
<ol start="14">
<li>Add the following test method to <kbd><span class="CodeInTextPACKT">DoorTest.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestDoorAnimationStateStartsClosed()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/>         string expectedDoorAnimationState = "DoorClosed";<br/> <br/>         // immediate next frame<br/>         yield return null;<br/> <br/>         // Act<br/>         AnimatorClipInfo[] currentClipInfo = doorAnimator.GetCurrentAnimatorClipInfo(BASE_LAYER);<br/>         string doorAnimationState = currentClipInfo[0].clip.name;<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedDoorAnimationState, doorAnimationState);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="15">
<li>Add the following test method to <kbd><span class="CodeInTextPACKT">DoorTest.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestIsOpeningStartsFalse()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/> <br/>         // immediate next frame<br/>         yield return null;<br/> <br/>         // Act<br/>         bool isOpening = doorAnimator.GetBool("Opening");<br/> <br/>         // Assert<br/>         Assert.IsFalse(isOpening);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="16">
<li>Add the following test method to <kbd><span class="CodeInTextPACKT">DoorTest.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    [UnityTest]<br/>     public IEnumerator TestDoorAnimationStateOpenAfterAFewSeconds()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // wait a few seconds<br/>         int secondsToWait = 3;<br/>         yield return new WaitForSeconds(secondsToWait);<br/> <br/>         // Arrange<br/>         doorAnimator = GameObject.FindWithTag("Door").GetComponent&lt;Animator&gt;();<br/>         string expectedDoorAnimationState = "DoorOpen";<br/> <br/> <br/>         // Act<br/>         AnimatorClipInfo[] currentClipInfo = doorAnimator.GetCurrentAnimatorClipInfo(BASE_LAYER);<br/>         string doorAnimationState = currentClipInfo[0].clip.name;<br/>         bool isOpening = doorAnimator.GetBool("Opening");<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedDoorAnimationState, doorAnimationState);<br/>         Assert.IsTrue(isOpening);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="17">
<li>Click <span class="ScreenTextPACKT"><span class="packt_screen">Run All</span></span>.</li>
<li>As the tests run, you will see first in the <span class="packt_screen"><span class="ScreenTextPACKT">Hierarchy</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Game</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">Scene</span></span> panels that a temporary scene is created, then the <span class="ScreenTextPACKT"><span class="packt_screen">doorScene</span></span> running, with the sphere rolling toward the red door.</li>
<li>You should see the results of your unit test being executed – if all tests are concluded successfully, there should be green ticks (check marks) next to each test.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You added two scenes to the build, so they can be selected in our scripts using the <span class="ScreenTextPACKT"><span class="packt_screen">SceneManager</span></span> during <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> testing.</p>
<p>We opened the <span class="ScreenTextPACKT"><span class="packt_screen">menuScene</span></span> so that we can clearly see when Unity runs different scenes during our <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> testing – and we'll see the menu scene reopened after testing takes place.</p>
<p>There is a <kbd><span class="CodeInTextPACKT">SetUp()</span></kbd> method that is executed before each test. SetUp and TearDown methods are very useful for preparing things before each test, and resetting things back to how they were before the test took place. Unfortunately, aspects such as loading our door scene before running each test, and then reloading the menu after each test, involve waiting until the scene load process has completed. We can't place yield statements in our <kbd><span class="CodeInTextPACKT">SetUp()</span></kbd> and <kbd><span class="CodeInTextPACKT">TearDown()</span></kbd> methods, so you'll see each test has repeated scene loading at the beginning and end of each test:</p>
<pre>// load scene to be tested<br/> yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>     SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/> // Arrange-Act-Assert goes here<br/> <br/> // teardown - reload original temp test scene<br/> SceneManager.SetActiveScene(tempTestScene);<br/> yield return SceneManager.UnloadSceneAsync(sceneToTest); </pre>
<p>For each test, we wait, either for a single frame (yield <kbd>null</kbd>), or for a few seconds (<span class="CodeInTextPACKT">yield</span> <kbd><span class="CodeInTextPACKT">return new WaitForSeconds(...)</span></kbd>). This ensures that all objects have been created and physics is started before our test starts running. The first two tests check the initial conditions, in other words, that the door begins in the DoorClosed <span>animation state</span>, and that the <span class="packt_screen"><span class="ScreenTextPACKT">Animation Controller's</span></span> <kbd>isOpening</kbd> variable is false.</p>
<p>The final test waits for a few seconds (which is enough time for the sphere to roll up to the door and trigger the opening animation), and tests that the door is entering/has entered the <span class="ScreenTextPACKT"><span class="packt_screen">DoorOpen</span> <span>animation state</span></span>, and that the Animation Controller's <kbd><span class="CodeInTextPACKT">isOpening</span></kbd> variable is true.</p>
<p>As can be seen, there is quite a bit more to <span class="packt_screen">PlayMode</span> testing than Unit Testing, but it means that we have a way to test actual <span class="packt_screen">GameObject</span> interactions when features such as timers and physics are running. As this recipe demonstrates, we can also load our own scenes for <span class="packt_screen">PlayMode</span> testing, be they special scenes created just to test interactions, or actual scenes that are to be included in our final game build.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayMode and Unit Testing a player health bar with events, logging, and exceptions</h1>
                </header>
            
            <article>
                
<p>In this recipe, we combine many different kinds of tests on a feature of many games – a visual health bar representing the player's numeric health value (in this case, a float number from 0.0 - 1.0). Although far from comprehensively testing all aspects of the health bar, this recipe gives a good sample of how we can go about testing many different parts of a game using the Unity Testing tools.</p>
<p>A Unity Package is provided that contains the following:</p>
<ul>
<li><kbd><span class="CodeInTextPACKT">Player.cs</span></kbd>: a player script class, managing values for player health, and using delegates-and-events to publish health changes to any listening <strong>View</strong> classes</li>
<li>Two <strong>View</strong> classes that register to listen for player health change events:
<ul>
<li><kbd><span class="CodeInTextPACKT">HealthBarDisplay.cs</span></kbd>: this updates the fillAmount for a UI image for each new player health value received</li>
<li><kbd><span class="CodeInTextPACKT">HealthChangeLogger.cs</span></kbd>: this prints messages about the new player health value received to the Debug.Log file</li>
</ul>
</li>
<li><kbd><span class="CodeInTextPACKT">PlayerManager.cs</span></kbd>: a manager script, which initializes player and HealthChangeLogger objects, and also allows the user to change the health of the player by pressing the Up and Down arrow keys (simulating healing/damage during a game)</li>
<li>A scene that has 2 UI images – one is a health bar outline (red heart and a black outline), the second is the filler image – showing dark blue to light blue to green, for weak to strong health values)</li>
</ul>
<p>This recipe allows several different kinds of testing to be demonstrated:</p>
<ul>
<li><span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> testing, to check that the actual <kbd><span class="CodeInTextPACKT">fillAmount</span></kbd> of the UI image <span>displayed </span>matches the 0.0 ... 1.0 range of the player's health</li>
<li><span class="ScreenTextPACKT"><span class="packt_screen">Unit Testing</span>, to check</span> that player health starts with the correct default value, and correctly increases and decreases after calls to the <kbd><span class="CodeInTextPACKT">AddHealth(...)</span></kbd> and <kbd>ReduceHealth(...)</kbd> <span class="CodeInTextPACKT">methods</span></li>
<li>Unit testing, to check that health change events are published by the player object</li>
<li>Unit testing, to check that expected messages are logged in the <kbd><span class="CodeInTextPACKT">Debug.Log</span></kbd></li>
<li>Unit testing, to check that argument out-of-range exceptions are thrown if negative values are passed to the player's <kbd><span class="CodeInTextPACKT">AddHealth(...)</span></kbd> or <kbd><span class="CodeInTextPACKT">ReduceHealth(...)</span></kbd> methods. This is demonstrated in the following screenshot: </li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f66aebf7-313f-4a0a-88bd-41d1a7b04dae.png"/></div>
<p>Thanks to Pixel Art Maker for the health bar image: <a href="http://pixelartmaker.com/art/49e2498a414f221">h<span class="URLPACKT">ttp://pixelartmaker.com/art/49e2498a414f221</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, a Unity Package has been provided (<kbd><span class="CodeInTextPACKT">healthBarScene.unitypackage</span></kbd>) in the <kbd>19_07</kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> <span class="ScreenTextPACKT">and <span class="packt_screen">Unit Test</span></span> a player health bar, follow these steps:</p>
<ol>
<li>Create a new Unity project, create a new empty scene, and delete the default folder Scenes.</li>
<li>Import the Unity package <span>provided</span> (<kbd><span class="CodeInTextPACKT">healthBarScene.unitypackage</span></kbd>).</li>
<li>Open the <span class="ScreenTextPACKT"><span class="packt_screen">HealthBarScene</span> scene</span>.</li>
<li>Add <span class="ScreenTextPACKT"><span class="packt_screen">HealthBarScene</span></span> to the project Build (menu: <span class="ScreenTextPACKT"><span class="packt_screen">File</span> |</span> <span class="packt_screen"><span class="ScreenTextPACKT">Build Settings ...</span></span>).</li>
<li>Display the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel by choosing the following menu: <span class="ScreenTextPACKT"><span class="packt_screen">Window</span> | <span class="packt_screen">General</span> | <span class="packt_screen">Test Runner</span>.</span></li>
<li>Enable PlayMode tests for all assemblies. Do this by displaying the drop-down menu in the top-right corner of the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, and selecting <span class="ScreenTextPACKT"><span class="packt_screen">Enable playmode tests for all assemblies</span></span> (click OK to any message concerned with restarting the editor).</li>
<li>Now restart the Unity Editor (just close the application and then reopen it with your project).</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">PlayMode</span></span> button is selected in the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel.</li>
<li>In the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel, select the top-level folder <span class="ScreenTextPACKT"><span class="packt_screen">Assets</span></span>.</li>
<li>In the <span class="packt_screen"><span class="ScreenTextPACKT">Test Runner</span></span> panel, click the "<span class="ScreenTextPACKT"><span class="packt_screen">Create PlayMode Test Assembly Folder</span></span>" button. A new folder, named <span class="ScreenTextPACKT"><span class="packt_screen">Tests</span>,</span> should have been created.</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">Assets</span></span> folder is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel. Create a new folder named <span class="ScreenTextPACKT"><span class="packt_screen">PlayModeTests</span></span> (this should now appear in the Assets <span>folder</span>).</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">PlayModeTests</span></span> folder is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel. In the <span class="ScreenTextPACKT"><span class="packt_screen">Test Runner</span></span> panel, click the "<span class="ScreenTextPACKT"><span class="packt_screen">Create Test Script in the current folder</span></span>" button. Rename this script class <kbd><span class="CodeInTextPACKT">HealthBarPlayModeTests</span></kbd>.</li>
<li>Edit the <kbd><span class="CodeInTextPACKT">HealthBarPlayModeTests.cs</span></kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using UnityEngine;<br/>     using UnityEngine.UI;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using System.Collections;<br/>     using UnityEngine.SceneManagement;<br/> <br/> <br/>     [TestFixture]<br/>     public class HealthBarPlayModeTests<br/>     {<br/>         private Scene tempTestScene;<br/> <br/>         // name of scene being tested by this class<br/>         private string sceneToTest = "HealthBar";<br/> <br/>         [SetUp]<br/>         public void Setup()<br/>         {<br/>             // setup - load the scene<br/>             tempTestScene = SceneManager.GetActiveScene();<br/>         }<br/>     } </pre>
<ol start="14">
<li>Add the following test in <kbd><span class="CodeInTextPACKT">HealthBarPlayModeTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">   [UnityTest]<br/>     public IEnumerator TestHealthBarImageMatchesPlayerHealth()<br/>     {<br/>         // load scene to be tested<br/>         yield return SceneManager.LoadSceneAsync(sceneToTest, LoadSceneMode.Additive);<br/>         SceneManager.SetActiveScene(SceneManager.GetSceneByName(sceneToTest));<br/> <br/>         // wait for one frame<br/>         yield return null;<br/> <br/>         // Arrange<br/>         Image healthBarFiller = GameObject.Find("image-health-bar-filler").GetComponent&lt;Image&gt;();<br/>         PlayerManager playerManager = GameObject.FindWithTag("PlayerManager").GetComponent&lt;PlayerManager&gt;();<br/>         float expectedResult = 0.9f;<br/> <br/>         // Act<br/>         playerManager.ReduceHealth();<br/> <br/>         // Assert<br/>         Assert.AreEqual(expectedResult, healthBarFiller.fillAmount);<br/> <br/>         // teardown - reload original temp test scene<br/>         SceneManager.SetActiveScene(tempTestScene);<br/>         yield return SceneManager.UnloadSceneAsync(sceneToTest);<br/>     } </pre>
<ol start="15">
<li>Click <span class="packt_screen">Run All</span>.</li>
<li><span>As the tests run, you will see first in the </span><span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span><span>, </span><span class="ScreenTextPACKT"><span class="packt_screen">Game</span></span><span> and </span><span class="ScreenTextPACKT"><span class="packt_screen">Scene</span></span><span> panels that a temporary scene is created</span>, then the <span class="ScreenTextPACKT"><span class="packt_screen">HealthBarScene</span></span> running, with the visual health bar.</li>
<li>You should see the results of your <span class="packt_screen"><span class="ScreenTextPACKT">PlayMode</span></span> Test being executed – if the test is concluded successfully, there should be a green tick (check mark).</li>
<li>Ensure that the <span class="packt_screen"><span class="ScreenTextPACKT">Assets</span></span> <span>folder </span>is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel. Create a new folder named <span class="packt_screen"><span class="ScreenTextPACKT">Editor</span></span> (this should now appear in the <span class="ScreenTextPACKT"><span class="packt_screen">Assets</span> <span>folder</span></span>).</li>
<li>Ensure that the <span class="ScreenTextPACKT"><span class="packt_screen">Editor</span></span> <span>folder </span>is selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Project</span></span> panel. In the <span class="ScreenTextPACKT">Test Runner</span> panel, click the "<span class="ScreenTextPACKT"><span class="packt_screen">Create Test Script in the current folder</span></span>" button. Rename this script class <kbd><span class="CodeInTextPACKT">EditModeUnitTests</span></kbd>.</li>
<li>Edit the <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd> script class, replacing the content with the following:</li>
</ol>
<pre style="padding-left: 60px">    using System;<br/>     using UnityEngine.TestTools;<br/>     using NUnit.Framework;<br/>     using UnityEngine;<br/> <br/>     public class EditModeUnitTests<br/>     {<br/> <br/>         // inner unit test classes go here<br/> <br/>     } </pre>
<ol start="21">
<li>Add the following class and basic tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestCorrectValues<br/>     {<br/>         [Test]<br/>         public void DefaultHealthOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 1;<br/> <br/>             // Act<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         [Test]<br/>         public void HealthCorrectAfterReducedByPointOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 0.9f;<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/> <br/>         [Test]<br/>         public void HealthCorrectAfterReducedByHalf()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 0.5f;<br/> <br/>             // Act<br/>             player.ReduceHealth(0.5f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="22">
<li>Add the following class and limit test inside the <kbd>EditModeUnitTests</kbd> class in <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestLimitNotExceeded<br/>     {<br/>         [Test]<br/>         public void HealthNotExceedMaximumOfOne()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             float expectedResult = 1;<br/> <br/>             // Act<br/>             player.AddHealth(1);<br/>             player.AddHealth(1);<br/>             player.AddHealth(0.5f);<br/>             player.AddHealth(0.1f);<br/>             float result = player.GetHealth();<br/> <br/>             // Assert<br/>             Assert.AreEqual(expectedResult, result);<br/>         }<br/>     } </pre>
<ol start="23">
<li>Add the following class and event tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestEvents<br/>     {<br/>         [Test]<br/>         public void CheckEventFiredWhenAddHealth()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             bool eventFired = false;<br/> <br/>             Player.OnHealthChange += delegate<br/>             {<br/>                 eventFired = true;<br/>             };<br/> <br/>             // Act<br/>             player.AddHealth(0.1f);<br/> <br/>             // Assert<br/>             Assert.IsTrue(eventFired);<br/>         }<br/> <br/>         [Test]<br/>         public void CheckEventFiredWhenReduceHealth()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/>             bool eventFired = false;<br/> <br/>             Player.OnHealthChange += delegate<br/>             {<br/>                 eventFired = true;<br/>             };<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/> <br/>             // Assert<br/>             Assert.IsTrue(eventFired);<br/>         }<br/>     } </pre>
<ol start="24">
<li>Add the following class and exception tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestExceptions<br/>     {<br/>         [Test]<br/>         public void Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/> <br/>             // Act<br/> <br/>             // Assert<br/>             Assert.Throws&lt;ArgumentOutOfRangeException&gt;(<br/>                 delegate<br/>                 {<br/>                     player.AddHealth(-1);<br/>                 }<br/>             );<br/>         }<br/> <br/>         [Test]<br/>         public void Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()<br/>         {<br/>             // Arrange<br/>             Player player = new Player();<br/> <br/>             // Act<br/> <br/>             // Assert<br/>             Assert.Throws&lt;ArgumentOutOfRangeException&gt;(<br/>                 () =&gt; player.ReduceHealth(-1)<br/>             );<br/>         }<br/>   } </pre>
<ol start="25">
<li>Add the following class and logging tests inside the <kbd>EditModeUnitTests</kbd> class in <kbd><span class="CodeInTextPACKT">EditModeUnitTests.cs</span></kbd>:</li>
</ol>
<pre style="padding-left: 60px">    public class TestLogging<br/>     {<br/>         [Test]<br/>         public void Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()<br/>         {<br/>             Debug.unityLogger.logEnabled = true;<br/> <br/>             // Arrange<br/>             Player player = new Player();<br/>             HealthChangeLogger healthChangeLogger = new HealthChangeLogger();<br/>             string expectedResult = "health = 0.9";<br/> <br/>             // Act<br/>             player.ReduceHealth(0.1f);<br/> <br/>             // Assert<br/>             LogAssert.Expect(LogType.Log, expectedResult);<br/>         }<br/>     } </pre>
<div class="packt_infobox">You can see that the inner classes allow grouping of the u<span class="ScreenTextPACKT">nit tests</span> visually in the <span class="ScreenTextPACKT">Test Runner</span> panel</div>
<div class="CDPAlignCenter CDPAlign"><img src="assets/640546ed-4ddc-44c9-9a49-5638af8a756c.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's take a look at how it works in detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PlayMode testing</h1>
                </header>
            
            <article>
                
<p>The PlayMode test <kbd><span class="CodeInTextPACKT">TestHealthBarImageMatchesPlayerHealth()</span></kbd> loads the <kbd><span class="CodeInTextPACKT">HealthBar</span></kbd> scene, gets a reference to the instance-object of <span class="ScreenTextPACKT"><span class="packt_screen">PlayerManager</span>,</span> which is a component of the <span class="ScreenTextPACKT"><span class="packt_screen">GameObject</span></span> tagged <span class="packt_screen">PlayerManager</span>, and invokes the <kbd><span class="CodeInTextPACKT">ReduceHealth()</span></kbd> method. This method reduces the player's health by 0.1, so from its starting value of 1.0, it becomes 0.9.</p>
<p>The <span class="ScreenTextPACKT"><span class="packt_screen">PlayerManager GameObject</span></span> also has as a component an instance object of the C# <span class="CodeInTextPACKT"><kbd>HealthBarDisplay</kbd> script class</span>. This object registers to listen to published events from the player class. It also has a public <span class="ScreenTextPACKT"><span class="packt_screen">UI Image</span></span> variable that has been linked to the <span class="ScreenTextPACKT"><span class="packt_screen">UI Image</span></span> of the health bar filler image in the scene.</p>
<p>When the player's health is reduced to 0.9, it publishes the <span class="CodeInTextPACKT"><kbd>OnChangeHealth(0.9)</kbd> <span>event</span>.</span> This event is received by the <kbd><span class="CodeInTextPACKT">HealthBarDisplay</span></kbd> object instance, which then sets the fillAmount property of the linked health bar filler image in the scene.</p>
<p>The <span class="CodeInTextPACKT"><kbd>TestHealthBarImageMatchesPlayerHealth(</kbd>)</span> <span>PlayMode test </span>gets a reference to the object instance named image-health-bar-filler, storing this reference in the <span class="CodeInTextPACKT"><kbd>healthBarFiller</kbd> <span>variable</span></span>. The test assertion made is that the expectedResult value of 0.9 matches that actual fillAmount property of the <span class="ScreenTextPACKT"><span class="packt_screen">UI Image</span></span> in the scene:</p>
<pre>Assert.AreEqual(expectedResult, healthBarFiller.fillAmount); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unit tests</h1>
                </header>
            
            <article>
                
<p>There are several unit tests, grouped by placing them inside their own classes, inside the <span class="CodeInTextPACKT"><kbd>EditModeUnitTests</kbd> <span>script class</span></span>.</p>
<ul>
<li><span class="CodeInTextPACKT"><kbd>TestCorrectValues</kbd> <span>class</span></span>:
<ul>
<li><span class="CodeInTextPACKT"><kbd>DefaultHealthOne()</kbd>:</span> this tests that the default (initial value) of the player's health is 1</li>
<li><span class="CodeInTextPACKT"><kbd>HealthCorrectAfterReducedByPointOne()</kbd>:</span> this tests that when the player's health is reduced by 0.1, it becomes 0.9</li>
<li><span class="CodeInTextPACKT"><kbd>HealthCorrectAfterReducedByHalf()</kbd>:</span> this tests that when the player's health is reduced by 0.5 it becomes 0.5</li>
</ul>
</li>
<li>class <kbd><span class="CodeInTextPACKT">TestLimitNotExceeded</span></kbd>:
<ul>
<li><span class="CodeInTextPACKT"><kbd>HealthNotExceedMaximumOfOne()</kbd>:</span> this tests that the value of the player's health does not exceed 1, even after attempts to add 1, 0.5, and 0.1 to its initial value of 1</li>
</ul>
</li>
<li>class <kbd><span class="CodeInTextPACKT">TestEvents</span></kbd>:
<ul>
<li><span class="CodeInTextPACKT"><kbd>CheckEventFiredWhenAddHealth()</kbd>:</span> this tests that an OnChangeHealth() event is published when the player's health is increased</li>
<li><span class="CodeInTextPACKT"><kbd>CheckEventFiredWhenReduceHealth()</kbd>:</span> this tests that an OnChangeHealth() event is published when the player's health is decreased</li>
</ul>
</li>
<li>class <kbd><span class="CodeInTextPACKT">TestLogging</span></kbd>:
<ul>
<li><span class="CodeInTextPACKT"><kbd>CorrectDebugLogMessageAfterHealthReduced()</kbd>:</span> this tests that a Debug.Log message is correctly logged after the player's heath is reduced by 0.1 to 0.9</li>
</ul>
</li>
<li>class <kbd><span class="CodeInTextPACKT">TestExceptions</span></kbd>:
<ul>
<li><span class="CodeInTextPACKT"><kbd>Throws_Exception_When_Add_Health_Passed_Less_Than_Zero()</kbd>:</span> this tests that an ArgumentOutOfRangeException is thrown when a negative value is passed to the AddHealth(...) p<span>layer method </span></li>
<li><span class="CodeInTextPACKT"><kbd>Throws_Exception_When_Reduce_Health_Passed_Less_Than_Zero()</kbd>:</span> this tests that an ArgumentOutOfRangeException is thrown when a negative value is passed to the ReduceHealth(...) <span>player method</span></li>
</ul>
</li>
</ul>
<div class="packt_infobox">These two tests illustrate one convention of naming tests that adds an underscore _ character between each word in the method name in order to improve readability.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Learn more about the LogAssert Unity Script reference in the Unity documentation:</p>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html"><span class="URLPACKT">https://docs.unity3d.com/ScriptReference/TestTools.LogAssert.html</span></a></li>
</ul>
<p>The method for unit testing C# events is adapted from a post on philosophicalgeek.com:</p>
<ul>
<li><a href="http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/"><span class="URLPACKT">http://www.philosophicalgeek.com/2007/12/27/easily-unit-testing-event-handlers/</span></a></li>
</ul>
<p>The delegate-event publishing of health change events in this health bar feature is an example of the Publisher-Subscriber design pattern. Learn more about design patterns and their implementations for Unity games in <kbd>Chapter 17</kbd>, Extra Features and Design Patterns.</p>


            </article>

            
        </section>
    </body></html>