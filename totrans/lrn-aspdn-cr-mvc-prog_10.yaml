- en: Chapter 10. Building HTTP-based Web Services Using ASP.NET Web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to create web applications using ASP.NET Core. But
    there are times when simply creating a web application is not enough. Let's assume
    you are using ASP.NET Core to create a web application that provides weather information
    for all the cities across the world. People access your web application to find
    out weather information, and they are satisfied with the service. But this weather
    information may be needed by many other websites or web applications, such as
    tourism websites, news websites, and many other mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing the code all over again for their websites, you can create
    and publish the web services and the websites can consume the required web services
    whenever they need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you are going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What an HTTP-based service is and how it is useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Fiddler is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compose an HTTP request using Fiddler and fire the same in order to get
    an HTTP response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design and implement the HTTP service using Web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft provides ASP.NET Web API for programmers to build HTTP-based services.
    But HTTP is not just used to serve the webpages. You can use HTTP as a platform.
    This brings several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: As web services built using ASP.NET Web API use HTTP for communication, these
    web services can be consumed from all kinds of applications from console applications
    to web applications, and from WCF services to mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever there is any change in the logic/code of the web services, the clients
    (the websites that consume the services) do not need to change anything. They
    can consume the web services just as they were consuming them earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a powerful platform for building services. You can use the existing
    HTTP verbs to build services. For example, you can use the existing HTTP verb
    GET to get the list of products or POST to update information about the product.
    Let's take a quick look at how HTTP works with respect to building the services.
  prefs: []
  type: TYPE_NORMAL
- en: There is no difference in the underlying mechanism between serving the HTML
    pages in ASP.NET MVC and serving the data in the context of HTTP services. Both
    follow a request-response pattern and the same routing mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP request can be sent from any client (desktop, laptop, tablet, mobile,
    and so on) to the server and the server will respond back with an HTTP response.
    An HTTP response can be sent to the client in any format such as JSON or XML.
    This is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP basics](img/Image00194.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, a request is sent from the desktop computer (it could
    equally be sent from a mobile or tablet; it makes no difference) and the server
    sends back the HTTP response for the request. As HTTP is supported in most of
    the devices, it is ubiquitous.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP verbs describe how the request has to be sent. These are the methods defined
    in HTTP that dictate how the HTTP requests are sent from the client to the server
  prefs: []
  type: TYPE_NORMAL
- en: GET method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we use an HTTP GET request, the information is passed through the URL
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `GET` request gets the employee information based on the passed ID. The
    advantage of using the `GET` request is that it is lightweight, and all the required
    information will be passed in the URL or header itself, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![GET method](img/Image00195.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PUT method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `PUT`  method is used to create a resource or to update it. `PUT` is an
    idempotent operation, meaning that the expected behavior would not change even
    if it is executed multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PUT method](img/Image00196.jpg)'
  prefs: []
  type: TYPE_IMG
- en: POST method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use POST to create or update the resource. Usually, POST is used to
    create the resource rather than update it. As per HTTP standards, whenever you
    create a new resource, you should return a **201 HTTP** status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![POST method](img/Image00197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: DELETE method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The DELETE method is used to delete the resource. Usually, when you delete
    a resource, you would be passing the ID as a parameter, and you would not be passing
    anything in the body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![DELETE method](img/Image00198.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Usually, HTTP services would be consumed by other applications and services.
    Applications that consume services are referred to as clients. One of the options
    to test HTTP services is to build the clients. But this would be time-consuming,
    and we may throw away the client code once we test the HTTP services.
  prefs: []
  type: TYPE_NORMAL
- en: Another option, which is widely used, is to use applications that enable us
    to fire HTTP requests and monitor the responses. There are many applications available,
    Fiddler being one such widely used application.
  prefs: []
  type: TYPE_NORMAL
- en: Fiddler tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fiddler is the proxy server application used to monitor the HTTP and HTTPS traffic.
    You can monitor the requests that are being sent to the server from the client,
    the responses that are sent to the client, and the responses that are being received
    from the server. It is like seeing the traffic in the pipe between the server
    and the client. You can even compose a request, fire it, and analyze the response
    received without ever needing to write the client for the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download Fiddler at [http://www.telerik.com/fiddler](http://www.telerik.com/fiddler)
    . You''ll see the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enough theory. Let us create a simple web service using ASP.NET Web API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fire up Visual Studio 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you click **OK** , a Web API solution will be created. Just as the ASP.NET
    Core application controller inherits from the Controller class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00201.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Web API class will also inherit from the same Controller class. This is
    the difference between ASP.NET Core and earlier versions of ASP.NET MVC. In earlier
    versions, all Web API controller classes inherited from the `ApiController` class.
    In ASP.NET 5, it has been unified, and the same base Controller class is being
    used for both building web applications and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `ValuesController` class that will be created by default
    when you choose the **Web API** template option when creating the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00202.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we create our own custom Controller, let's analyze the default API Controller.
    In the `ValuesController` file, several API methods are already defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are two overloaded `GET` methods—one with a parameter and another without
    a parameter. The `GET` method without a parameter returns all the resources of
    the type. In this case, we are returning just a couple of strings. In the real
    world, we would be returning the metadata of the resources. For example, if we
    fire the `GET` request on the movies API Controller, it would return information
    about all the movies. The `GET` method with an `id` parameter returns the resource
    whose ID matches with the passed ID. For example, if you pass a movie ID, it would
    return the information about that movie. The body of the other methods, such as
    `PUT` , `POST` , and `DELETE` , are empty in this Controller, and we will talk
    about these methods later.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, it fires a request to `api/values` , and the values are displayed
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to fire an HTTP request from the Fiddler application. Open
    the Fiddler application. In the bottom left-hand corner, select the **Web Browsers**
    option in the red box. Choosing this option will enable us to view the traffic
    coming from the **Web Browsers** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00204.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the **Composer** tab, enter the URL `http://localhost:49933/api/values`
    , as shown in the following screenshot, and click the **Execute** button in the
    top right-hand corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00205.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you click the **Execute** button, an HTTP session will be created, visible
    on the left-hand side pane (highlighted in the blue box). Click on the session
    and select the **Inspectors** tab on the top right-hand side pane. Select the
    JSON tab in the bottom right-hand side pane (highlighted by the purple-bordered
    box in the following screenshot).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the JSON data returned from the HTTP request— **value1** and **value2**
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00206.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now it's our turn to write a custom API.
  prefs: []
  type: TYPE_NORMAL
- en: In this custom API, we are going to provide API methods to create an employee
    object, list all the employee objects, and delete an employee object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us create a model for the employee. We need to create a folder to
    hold these models. Right-click on the project, select **Add**  | **New folder**
    , and name the folder as `Models` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fiddler tool](img/Image00207.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the `Models` folder and select **Add** |  **New Item…**  to
    create an employee model class. This employee model class is just a POCO class.
    See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the repository interface to handle the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the interface for this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few things to be noted in the implementation class:'
  prefs: []
  type: TYPE_NORMAL
- en: We have decided not to use the database as our objective is to create an HTTP
    service using Web API, and not to write the data access code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using an in-memory list to hold the data. All the operations will be
    performed on this list. As a matter of fact, the data could be in any form, ranging
    from relational databases to a simple in-memory list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the constructor method, we are adding an object to the list. This list will
    be acting as the database for our HTTP service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetAllEmployees` API method will return all the employees as the `IEnumerable`
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AddEmployee`  method will add the employee (passed as a parameter) to the
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetEmployee`  method will return the employee whose ID matches that of
    the parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RemoveEmployee`  method will remove the employee from the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UpdateEmployee`  method will update the employee information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetNextRandomId` method will return the next available random integer.
    This integer value is being used to generate the employee ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most real-world projects, we do not instantiate any objects using the `new`
    instance in any of the Controllers, the reason being that we don't want to have
    tight coupling between the dependent components (between the Controller and the
    repository). Instead, we pass an interface to the Controller, and the Dependency
    Injection container (such as **Unity** ) will create an object for us when it
    is needed for the Controller. This design pattern is commonly referred to as **Inversion
    of Control** .
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that a class by the name of *ClassA* uses another class, *ClassB*
    . In this case, it is enough for *ClassA* to know about the behavior, methods,
    and properties of *ClassB* , and it doesn't need the internal implementation details
    of *ClassB* . So, we can abstract *ClassB* and make an interface out of the class,
    and then have that interface as the parameter instead of the concrete class. The
    advantage of this approach is that we can pass any class at runtime as long as
    it implements a commonly agreed contract (interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET 5 (including ASP.NET Core and Web API), we have inbuilt support
    for Dependency Injection. In the `ConfigureServices` method, we have added the
    line (highlighted in bold) that performs the Dependency Injection. We instruct
    the inbuilt Dependency Injection container to create the `EmployeeRepository`
     class wherever we are referring to the `IEmployeeRepository`  interface and we
    also instruct it to be a singleton; meaning that the same object (which is to
    be created by the Dependency Injection container) is to be shared for the entire
    lifecycle of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have used the Singleton pattern for the Dependency
    Injection, which creates services only the first time they are requested. There
    are other types of lifetime services such as **Transient** and **Scoped** . Transient
    lifetime services are created each time they are requested and Scoped lifetime
    services are created once per request. The following are code snippets created
    when you use such lifetimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to get into the meat of the action creating the API controller.
    Right-click on the **Controllers** folder and select **Add |**   **New Item**
    . Then select **Web API Controller Class** from the list, as shown in the following
    screenshot. Name your Controller, and click the **Add** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00208.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Remove the generated code in the Controller and add the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding constructor, we are injecting the dependency. At the time of
    calling this constructor, the `EmployeeRepository` object will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us implement a couple of `GET` methods—the first one will return all the
    employees'' details and the second `GET` method will return the employee based
    on the passed employee ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let us call these HTTP methods from Fiddler.
  prefs: []
  type: TYPE_NORMAL
- en: Run the solution, open the Fiddler application, and click on the **Composer**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: Select the HTTP method (we have chosen the `GET` method as we have a GET API
    method) and enter the URL `http://localhost:49933/api/employee` .
  prefs: []
  type: TYPE_NORMAL
- en: Please note that when I run my application, it runs on port `49933` ; the port
    number will be different in your case, so construct your URL accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you enter the URL and the method is selected, click the **Execute** button
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00209.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you click the **Execute** button, an HTTP session will be created, and
    the request will be fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the session on the left-hand side pane (as shown in the following
    screenshot) and select the **Inspectors** tab in the right-hand side pane. You
    can view the result in the **JSON** tab in the bottom right-hand side pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00210.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let us fire another HTTP request to get a particular employee''s information,
    say the employee whose ID is 2\. We would construct the URL by appending the ID `http://localhost:49933/api/employee/2`
     as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00211.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the recently created HTTP session and click on it:'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the result in JSON format in the right-hand side pane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to add `Create` , `Update` , and `Delete` operations to our
    service. To start with, we are going to provide the Create functionality to add
    employees'' to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following points should be considered when following the preceding `Add`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are passing the `Employee` object as a parameter. We are instructing the
    `Add` method to take that object from the body of the request by specifying a
    `[FromBody]` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no employee object is passed, we would be returning the bad request to the
    calling client
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not null, we would be calling the repository method to add the employee
    to our list (in the real world, we would be adding it to the database)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have added the employee, we are returning the *201 status code* (as
    per the HTTP standards) when a new resource is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Fiddler application and follow these steps to add the employee:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the HTTP method as `POST` and enter the URL `http://localhost:54504/api/employee/`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need to specify the content type as `application/json`  in the request
    header. Please see the following screenshot, where we have added `Content-Type:
    application/json` to the request header.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As mentioned in the code, we have to pass the employee object in the form of
    JSON in the body of the request. In the following request, we have formed a JSON
    that contains the properties of the `Employee` object with the values in the brackets
    { "FirstName" : "James", "LastName" : "Anderson","Department" : "IT"}:![Dependency
    Injection](img/Image00212.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have composed the request, you can click the **Execute** button to
    fire the request. This will return the *201 HTTP status code* , which is the standard
    HTTP response for creating a new resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00213.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As soon as we have created the resource in the server, we are redirecting the
    response to get the newly created resource. This occurs when we call the `CreatedAtRoute`
    method with the newly created employee ID passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the session on the left-hand side and select the **Inspector** tab
    in the right-hand side pane. Now you can see the response of the request. The
    response contains the `Employee` object which was newly created in the server.
    We have to note that the ID of the `Employee` object is generated at the server,
    and is available in the following response. In this case, the ID generated for
    the employee is `1771082655` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the bottom right-hand side panel in the preceding Fiddler window, we can
    see the complete JSON response of the newly created resource.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to add a Web API method to update the resource. The method
    for updating the resource is very similar to that used to create the resource,
    with only a few differences. When we created the resource, we used the `HTTP POST`
    method, whereas when we updated the resource, we used the `HTTP PUT` method.
  prefs: []
  type: TYPE_NORMAL
- en: If the passed employee ID could not be found in the repository, we return a
    *404 error* response, the HTTP standard error response for a resource that has
    not been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Web API controller method code for updating the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the repository layer code for updating the employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Fiddler application, and compose a request of `HTTP PUT` . As we are
    going to pass the `Employee` object in the body of the request, we need to mention
    the content type as `application/json` . In the body of the request, we need to
    supply the `Employee` object in JSON format, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00215.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click the **Execute** button, the `HTTP PUT` request will be fired
    and our Web API method will get called. Once it succeeds, the  *HTTP 204* response
    will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dependency Injection](img/Image00216.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Delete method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `HTTP DELETE` method should be used when deleting a resource. There is no
    need to pass anything in the body of the request.
  prefs: []
  type: TYPE_NORMAL
- en: The Web API method for deleting a resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Delete` Web API method has a `void` return type, which will return an
    *HTTP 200* response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Web Repository layer code for deleting the employee data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the following repository layer method, we are removing the employee (whose
    ID matches with that of the parameter passed) from the internal list of employees.
    But in the real world, we would be interacting with the database to delete that
    particular employee. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Fiddler application, select the `DELETE` HTTP method, pass the URL
    with the parameter, and click on the **Execute** button. Please note that we are
    not passing the content type in the request header as we are not passing any employee
    object in the body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Web Repository layer code for deleting the employee data](img/Image00217.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we are returning void, the Web API `DELETE` method returns an *HTTP 200*
    status, as you can see in the left-hand side pane of the Fiddler application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Web Repository layer code for deleting the employee data](img/Image00218.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the HTTP service and its purpose. We discussed
    how to design and implement the HTTP service using Web API. We used the Fiddler
    tool to construct the HTTP request and get the response back. We also learned
    how to write the Web API method to perform CRUD operations end to end, from writing
    the Web API methods to firing the requests and getting the responses back.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
