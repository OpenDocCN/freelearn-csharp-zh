- en: Chapter 4. Parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic parallel query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving order in parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing parallel execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting parallelism in a query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing query results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying merge options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range projection with parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling exceptions in parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a parallel LINQ query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing reduction operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom partitioner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Language Integrated Query** (**LINQ**) offers developers syntax for performing
    queries on collection of data. Using LINQ you can traverse, filter, sort, and
    return projected sets of items. When you use LINQ to objects, all of the items
    in your data collection are processed sequentially by a single thread.'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel LINQ is a parallel implementation of LINQ to objects, which can turn
    your sequential queries into parallel queries, potentially improving performance.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, parallel LINQ uses tasks queued to default `TaskScheduler` to extend
    the processing of the source collection's items across available processors, so
    that multiple items are processed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to see how parallel LINQ can potentially improve
    query performance for large collections of items, or for long compute-bound processing
    of items.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic parallel query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at creating a basic parallel query by using
    the `AsParallel` method of the `System.Linq.ParallelEnumerable` class.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a `Console` application that initializes a collection
    of employees, and then queries the employee collection looking for a specific
    job title.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's go to Visual Studio and start creating some parallel LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `SimplePLINQ` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we need to create an `Employee` class just below the `Program` Class.
    Create an `Employee` class definition with `Id`, `Title`, `FirstName`, and `LastName`
    properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method of the `Program` class, let's create and initialize
    an array of `employees`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will create a parallel LINQ query that selects all employees where
    their title is `Developer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_04_01.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The small collection of employees we created for this example is too small to
    benefit from parallelizing the query, but the key thing to notice in the example
    is the use of the `AsParallel extension` method which binds the query to parallel
    LINQ, and specifies that the rest of the query should be parallelized if possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `System.Linq.ParallelEnumerable` class implements all of the parallel LINQ
    functionality, and exposes parallel versions of `Select`, `Single`, `Skip`, `OrderBy`,
    and so on. All of these methods are extension methods that extend `ParallelQuery<TSource>`.
    The `AsParallel` extension method converts your sequential query based on `IEnumerable<T>`
    to a parallel query based on `ParallelQuery<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving order in parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, PLINQ does not preserve the order out of a source collection. Because
    PLINQ processes items in a data collection concurrently using multiple threads,
    the items are returned unordered. This is by design, because maintaining the original
    ordering of a sequence adds overhead, and in most cases, that overhead may not
    be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you need to preserve order, PLINQ provides a simple way to accomplish
    it. In this recipe, we are going to create a `Console` application that creates
    two collections of numbers, performs an ordered query on one collection, and the
    default unordered query on the other collection, and looks at the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's open up Visual Studio and see how to preserve order on parallel LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `PreserveOrder` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start off by creating a `UnorderedQuery` method just below the `Main`
    method of the `Program` class. This method will query a large range of integers
    for numbers that are evenly divisible by 5, and will take the first 10 of those
    numbers as the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we need to create our `OrderedQuery` method which will perform the same
    query as the previous step, except it will use the `AsOrdered` extension method
    to preserve the original order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's add some code to the `Main` method of the `Program` class to create
    your source lists of numbers and to call each of the methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_02.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to have parallel LINQ, preserve the order of items as they are processed,
    then you can call the `AsOrdered` method of the `ParallelEnumerable` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you call this method, the threads spawned for the query will process the
    items of a collection in groups, then the groups are merged back together preserving
    order but hurting performance.
  prefs: []
  type: TYPE_NORMAL
- en: The operators `Distinct`, `Intersect`, `Union`, `Join`, `Except`, `GroupBy`,
    `GroupJoin`, and `ToLookup` produce unordered operations. If you need to enforce
    ordering after one of these operations, you just need to call the `AsOrdered`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the operators `OrderBy`, `OrderByDescending`, `ThenBy`, and `ThenByDescending`
    produce ordered operations. If you need to go back to unordered processing and
    improve performance, PLINQ provides a `AsUnordered` method you can call.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing parallel execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel LINQ looks for opportunities to parallelize a query, but not all queries
    run faster in parallel. For example, a query that contains a single delegate that
    does only a little bit of work will usually run faster sequentially, because the
    overhead of parallelizing outweighs the benefits gained from parallelizing it.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, parallel LINQ does a really good job of determining what
    should be parallelized and what should run sequentially, based on its examination
    of the shape of the query. However, the algorithm it uses is not perfect, and
    you might need to instruct PLINQ to run your query in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will build a `Console` application that creates a query which
    PLINQ will determine whether it needs to be executed sequentially. We will then
    force the query to run in parallel using the `WithExecutionMode` method. Finally,
    we will capture the time it takes for both queries to run and compare the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to force a PLINQ query to execute in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `ForceParallelism` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create a method in your `Program` class called `NoForcedParallelism`
    that creates a PLINQ query with a small delegate of work that PLINQ will evaluate
    and determine what needs to be executed sequentially.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a method in the `Program` class called `ForcedParallism`
    which runs the same query, but forces PLINQ to execute it in parallel by calling
    the `WithExecutionMode` method and passing it a `ParallelExecutionMode.ForceParallelism`
    enumeration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will finish up by adding some code to the `Main` method to create `stopWatch`
    to capture the timing of the two methods, then run the methods and compare the
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_03.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we can see that PLINQ wrongly decided that the query would run
    faster sequentially. When we forced the query to run in parallel, the performance
    improvement was significant.
  prefs: []
  type: TYPE_NORMAL
- en: We instructed PLINQ not to fall back to sequential execution when it detects
    certain query shapes by calling the `WithExecutionMode` method of `System.Linq.ParallelQuery`,
    and passing it `ParallelExecutionMode.ForceParallelism` enumeration value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why did PLINQ determine that the query should be executed sequentially in the
    first place? It is mainly a factor to determine the shape of the query which has
    a single delegate of work. It also has to do with this query using the `positional
    Select` operator. Positional-related operators may require `ForceParallelism`
    in PLINQ that includes `positional Select`, `positional Where`, `positional SelectMany`,
    `Take`, `Skip`, `TakeWhile`, and `SkipWhile`.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting parallelism in a query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, parallel LINQ will try to take advantage of all of the processor
    cores offered by your CPU. Usually, this is what you want. However, there could
    be situations where you want to limit the number of threads used to run queries
    and keep some cores available for other work.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a query that uses the `WithDegreeOfParallelism`
    method to explicitly set the number of threads that a parallel query uses.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to limit the degree of parallelism of a query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `LimitParallelism` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's add a PLINQ query to the `Main` method of the `Program` class that works
    the processors. For now, we will use the `WithExecutionMode` method to force the
    query to run in parallel, but will not set a limit on the parallelization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have a multi-core processor on your machine, start up the **Task Manager**,
    click on the **Performance** tab, and watch CPU usage. In Visual Studio 2012,
    press *F5* to run the project. You should see processor usage as shown in the
    following screenshot:![How to do it…](img/0225OT_04_04.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's edit the PLINQ query to call the `WithDegreeOfParallelism` method
    to limit the number of processor cores used. You might want to change the value
    you pass into the method to be a number that is relevant to the number of processor
    cores available to you. You can specify a number greater than the number of processor
    cores available on your machine, but this will likely lead to more context switching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now start up the **Task Manager** again, click on the **Performance** tab, and
    watch CPU usage. In Visual Studio 2012, press *F5* to run the project. You should
    see reduced processor usage. Note that the threads created will not necessarily
    spend all of their time on a single core, but the overall usage will go down.![How
    to do it…](img/0225OT_04_05.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WithDegreeOfParallelism` method probably isn't something that you will
    use very often. You might want to use it in situations where you need to leave
    some CPU time available to perform other tasks. You could also pass a number that
    is greater than the number of cores on your machine, in cases where the query
    will be performing synchronous I/O, because the threads will be blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the degree of parallelism is simply a matter of calling the method and
    passing in the number of threads you want PLINQ to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The default value of the `WithDegreeOfParallism` method is the processor count
    of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Processing query results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the nice features of parallel LINQ is that it collates the results from
    a parallelized query into a single output sequence. Often though, all your program
    does with the query's output data is run a function over each element using a
    `foreach` loop or similar. In such cases, particularly in cases where you don't
    care about the order in which elements are processed, you can improve performance
    by using the ParallelEnumerable's `ForAll` method to process the results in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will perform a query on a range of numbers, and then use
    `ParallelForAll` to iterate over the results in parallel, calculating the square
    of each number.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's open up Visual Studio and see how to process the results of a parallel
    query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `ProcessResults` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method of the `Program` class, let's create a concurrent
    collection of integers to hold the result of our calculation, and generate a range
    of numbers for the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, just below the previous lines, create a PLINQ query that queries the first
    100 numbers that are evenly divisible by 5 out of the source range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's call the `ParallelEnumerable.ForAll` method to process our query results
    in parallel. We are just going to calculate the square of each number and add
    the result to our collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's loop through the collection and print the results to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_06.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are using `ParallelEnumerable.ForAll<TSource>` to iterate
    through and process the results of our query in parallel. The `ForAll` method
    runs a delegate over every output element of a `ParallelQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `ForAll` method hooks right into parallel LINQ's internals, bypassing the
    steps of collating, and enumerating the results which can save considerable processing
    time.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we used the `ForAll` method to calculate the square of
    our results and add them to the collection; just to use a sequential `foreach`
    loop to write the results to `Console`. Besides the obvious answer that this is
    just a simple example, you wouldn't want to write to `Console` inside a `ForAll`
    method because .NET serializes all access to `Console`, and would force the whole
    thing to run sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying merge options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When parallel LINQ executes a query, it partitions the source data and assigns
    each partition to a separate thread. If the results are consumed by a single thread,
    such as a `foreach` loop, then the results from each partition must be merged
    back into one result set. The kind of merge that is performed depends on the operators
    used in the query. For operators that produce ordered results, the results from
    all the threads are completely buffered before being merged back together. Your
    application's consuming thread might have to wait for a while before seeing the
    final result. If you don't care about order, or want to use a different buffering
    scheme to improve results, your query can use the `WithMergeOptions` extension
    method to provide a hint to PLINQ about how you would like the results to be buffered.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will query some numbers out of a range, and loop through
    the results using a couple of different buffering options, and observe the effects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at how to specify the merge option of a PLINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `MergeOptions` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating our source number range in the `Main` method of the
    `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a PLINQ query to select the numbers in the range that are evenly
    divisible by 5, and use the `WithMergeOption` method to specify fully buffered
    merging of the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's use a `foreach` loop to iterate through the results and print them
    to `Console`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Notice the **Ordered Results**
    shown in the following screenshot:![How to do it…](img/0225OT_04_07.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's use the `WithMergeOption` method to specify no buffering for the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Notice the unordered results
    in the following screenshot:![How to do it…](img/0225OT_04_08.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `WithMergeOptions` method takes the `ParallelMergeOptions` enumeration
    as a parameter. You can specify one of the following options for how the query
    output is yielded and when the results can be consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Not Buffered**: Each processed element of the query is returned from each
    thread as soon as it is produced. If the `AsOrdered` operator is present, ordering
    is preserved, but if `AsOrdered` is not present, then the results are yielded
    as soon as they are available. This option yields the fastest results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Buffered**: The elements are collected into a buffer and periodically
    yielded to the consuming thread. This is a middle ground approach to buffering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fully Buffered**: All of the elements are collected in a buffer before any
    elements are yielded to the consuming thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you use `WithMergeOptions`, you are giving PLINQ a hint about the buffering
    scheme you want it to use. If a particular query cannot support the requested
    option, your request will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Range projection with parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using sequential LINQ, it is very common to use range projection to obtain
    a range of values. Parallel LINQ provides us with a way to do this too. If you
    need to generate a very large range of numbers which do not necessarily need to
    be in sequence, you can use the `Range` method of `ParallelEnumerable` to create
    the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In this short recipe, we will use `ParallelEnumerable.Range` to generate some
    numbers over a very large range.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's go to Visual Studio and see how to use parallel LINQ to generate
    a range of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `RangeProjection` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, in the `Main` method, let's use `ParallelEnumerable.Range` to create
    a range of numbers between 1 and 1000 that are divisible by 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's just loop through the results to display them to the `Console` and
    wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_09.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this recipe is fairly easy to understand. One important point to
    note is that the implicit cast to `ParallelQuery<int>` creates a parallel execution
    instead of a sequential one, and there is no particular ordering of the numbers
    in the result.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, order can be preserved by calling `AsOrdered` on the query, but if
    ordering is important to you, just generate the range using sequential LINQ projection,
    and avoid the overhead of parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions in parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling exceptions in parallel LINQ is not much different from handling exceptions
    in tasks, continuation, or anywhere else in your parallel code. You need to use
    `try`/`catch` and make sure to catch `AggregateException`. With parallel LINQ,
    the really important part is to use the try/catch around where you enumerate or
    use your results.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a simple parallel LINQ query that returns
    a list of employees and throws `InvalidOperationException`, which we will handle
    when we iterate through the results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown, and
    intercepts the `Exception` before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and click on **Exception**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_04_10.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at how to handle exceptions in a parallel LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `HandleExceptions` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, let''s create an `Employee` class. Add the following class definition
    to your `Program.cs` file, just below the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the `Main` method of the `Program` class, let's create and initialize
    an array of `employees`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create a PLINQ query that selects all employees and throws `InvalidOperationException`
    when it encounters an `employee Id` that is greater than `15`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create a `try`/`catch` block. In the `try` block, create a `foreach`
    loop to iterate through the results. In the `catch` block, you need to handle
    `AggregateException` and display the `Exception` to `Console`. Finish up by waiting
    for user input before exiting the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_11.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, the steps for handling exceptions that occur in a parallel LINQ
    query are very consistent with handling exceptions that occur in other parts of
    our parallel code. Any `Exception` that occurs will be added to the `InnerExceptions`
    collection of an `AggregateException`. So, we need to be ready to catch `AggregateException`
    and examine the individual `Exception` items in the `InnerExceptions` collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we just placed a `try`/`catch` block around the loop that iterates
    through our results, and handled `AggregateException` in the `catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling a parallel LINQ query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like tasks and continuations, parallel LINQ queries are cancelled by using `CancellationToken`
    which you obtain from `CancellationTokenSource`. A minor difference in cancelling
    a parallel LINQ query is in how you register a `CancellationToken` with the `WithCancellation(tokenSource.Token)`
    extension method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a cancellable parallel query that selects
    the square of numbers from a large range of random numbers. We are then going
    to create a separate task to cancel the query from.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime `Exception` is thrown and intercepts
    the `Exception` before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exception**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_04_10.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's take a look at how to cancel a parallel LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template and
    assign `CancelQuery` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's add some code to the `Main` method of the `Program` class to create
    our `CancellationTokenSource` object. We also need to initialize a large range
    of random numbers that will be the source for the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a parallel LINQ query that uses the `WithCancellation` extension
    method to accept a cancellation token and uses the `Math.Pow` method to select
    the square of each number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a task that will sleep for 1 second to give the query time
    to start, and then it will call the `CancellationTokenSource.Cancel` method to
    cancel the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create a `try` block and a couple of `catch` blocks. The `try`
    block will just contain a `foreach` loop, to loop through the results of the query.
    The first `catch` block needs to catch `OperationCancelledException` and display
    a message to `Console`. The second `catch` block needs to catch `AggregateException`
    and display all `InnerException` messages to the `Console`. Lastly, let's wait
    for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_12.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used two separate `catch` blocks in this recipe because the parallel LINQ
    framework does not roll `OperationCanceledExceptions` into `AggregateException`;
    the `OperationCanceledException` must be handled in a separate `catch` block or
    it will be left unhandled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have one or more delegates, throw `OperationCanceledException` by using
    `CancellationToken`, but don''t throw any other exception. Then, parallel LINQ
    will just throw a single `OperationCanceledException` rather than `System.AggregateException`.
    However, if a delegate throws `OperationCanceledException` and another delegate
    throws another `Exception` type, then both exceptions will be rolled into `AggregateException`.
    So, whenever you create a PLINQ query using the `WithCancellation` extension method,
    it is recommended that you create two `catch` blocks: one for `OperationCancelledException`
    and one for `AggregateException`.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing reduction operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like sequential LINQ, parallel LINQ provides many common aggregation operations
    such as sum, average, min, and max. It is pretty easy to perform aggregate operations
    by using one of LINQs extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, we need to perform a custom aggregation of our source data,
    either because we need to perform a calculation that isn't provided in one of
    the standard aggregation extension methods, or because we need to apply custom
    logic to the calculation.
  prefs: []
  type: TYPE_NORMAL
- en: For such cases, parallel LINQ provides us with a `aggregate` method which can
    apply a custom accumulator function in parallel over a sequence of data.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a custom aggregation operation that calculates
    the average of a large range of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how to perform custom aggregation with PLINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `Average` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's add some code to the `Main` method to create a range of random
    numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a PLINQ query that calls the `Aggregate` extension method of
    `ParallelEnumerable` passing delegate to calculate the average to the `intermediateReduceFunc`,
    `finalReduceFunc`, and `resultSelector` parameters. Display the results to `Console`
    and wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up by displaying the results to the `Console` and waiting for the user
    input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_13.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An aggregation operation is an operation that iterates over a sequence of input
    data elements, maintaining an accumulator that contains an intermediate result.
    At each step, a reduction function takes the current element and accumulator value
    as inputs, and yields a value that will overwrite the accumulator. The final accumulator
    value is the result of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ParallelEnumerable` class provides several overloads of the `aggregate`
    extension method. We are using the following overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `seedFactory` function returns the initial accumulator value. The `updateAccumularorFunc`
    parameter is an `accumulator` function to be invoked on each element in a partition.
    The `combineAccumulatorsFunc` parameter is an `accumulator` function to be invoked
    on the yielded accumulator result from each partition. Finally, the `resultSelector`
    parameter is a function to transform the final accumulator value into the result
    value.
  prefs: []
  type: TYPE_NORMAL
- en: We have provided our own delegate for each of these function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Creating a custom partitioner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To parallelize an operation on a data source, one of the essential steps is
    to partition the source into multiple sections that can be accessed concurrently
    by multiple threads. Parallel LINQ provides default partitioners that work quite
    well for most parallel queries. However, for more advanced scenarios, you can
    also create your own partitioner.
  prefs: []
  type: TYPE_NORMAL
- en: For the recipe, we will create a custom static partitioner which will split
    our data source into a variable number of partitioned chunks. The exact number
    of partitions will be specified by TPL itself, and will be made available to our
    custom partitioner by overriding the `Partitioner<T>` method. We will then test
    the performance of a query that uses default partitioning against the performance
    of a query using our custom partitioner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how to partition data for a parallel query.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **C# Console Application** project template, and
    assign `CustomPartitioner` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class the project and name it `CustomPartitioner.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `CustomPartitioner`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apply a generic type parameter to the `CustomPartitioner` class, and declare
    `Partitioner<T>` as its base class. Optionally, mark the class visibility as internal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a private source field of type array of `T` and initialize the source
    data with the `Class` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Override the `SupportsDynamicPartitions` property of the base class to return
    `false`. This partitioner can only allocate partitions statically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a `GetItems` method that returns `IEnumerator<T>` for the items in the source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finish up the `CustomPartitioner` class by overriding the `GetPartitions` method
    of the base class. This method will return `List<IEnumerable<T>>` which is a list
    of our partitioned data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it for the `CustomPartitioner` class. Now let''s go to the `Program`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class add some code to create a large
    array of random numbers that we will use for the source of our query. Also, create
    a `stopWatch` object, which we will use to capture our performance numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's start `stopWatch` and run a query against the source data to select
    the square of each number. This query uses default partitioning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's reset `stopWatch`, run the query with our custom partitioner,
    display the results, and wait for user input before exiting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_04_14.png.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, it might be worthwhile to create your own partitioner, but for
    the most part, the default partitioning works pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: To create a basic custom partitioner, derive a class from `Partitioner<TSource>`
    which is located in `System.Collections.Concurrent`, and override a couple of
    virtual methods and a virtual property getter.
  prefs: []
  type: TYPE_NORMAL
- en: We provided an override for the `SupportsDynamicPartitions` property to indicate
    that our simple custom partitioner only supports static partitions by returning
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If we had indicated that this partitioner does support dynamic partitions, we
    would want to provide an override for the `GetDynamicPartitions` method, which
    can be called instead of `GetPartitions` for dynamic partitioners.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we just had to provide an override for `GetPartitions`. This method
    returns `IList(IEnumerator(TSource))` which represents our actual partitioned
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we provided a `GetItems` method which is a helper that `GetPartitions`
    uses to get an enumerator for the items in our source data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
