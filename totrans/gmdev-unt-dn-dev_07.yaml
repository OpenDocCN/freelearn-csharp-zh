- en: '*Chapter 5*: Working with the Unity Physics System'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*: 使用Unity物理系统'
- en: A physics simulation in a game is not only an indispensable function for implementing
    the realism in the game. Adding a physics simulation to your game can usually
    improve the fun and playability of the game. Generally speaking, it determines
    how objects move and how they collide with one another, such as the collision
    between a player and a wall and the effect of gravity. As a popular game engine,
    Unity provides developers with a variety of tools, allowing developers to integrate
    physics simulation functions in their games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的物理模拟不仅是为了实现游戏的现实感而不可或缺的功能。将物理模拟添加到您的游戏中通常可以提高游戏的趣味性和可玩性。一般来说，它决定了物体如何移动以及它们如何相互碰撞，例如玩家与墙壁之间的碰撞和重力的影响。作为一个流行的游戏引擎，Unity为开发者提供了各种工具，允许开发者将物理模拟功能集成到他们的游戏中。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下关键主题：
- en: Concepts in the Unity Physics system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity物理系统中的概念
- en: Scripting with the Physics system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理系统进行脚本编写
- en: Creating a simple game based on the Physics system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于物理系统创建简单游戏
- en: Increasing the performance of the Physics system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高物理系统的性能
- en: By the end of this chapter, you will be able to apply the physics simulation
    correctly and efficiently in Unity to add more realism or fun to your game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够正确且高效地在Unity中应用物理模拟，为你的游戏添加更多真实感或趣味性。
- en: Now, let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find complete code examples on GitHub under the following repository: 
    [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上的以下存储库中找到完整的代码示例：[https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers)。
- en: Concepts in the Unity Physics system
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity物理系统中的概念
- en: A simulation is a useful function of a game. Unity provides different tools
    for different purposes. For example, if we want to develop a 3D game, then we
    can use the built-in 3D physics integrated with the **Nvidia PhysX engine**. If
    we want to add a physics simulation to a 2D game, then we can choose the built-in
    2D physics integrated with the **Box2D engine**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟是游戏中的一个有用功能。Unity为不同的目的提供了不同的工具。例如，如果我们想开发一个3D游戏，那么我们可以使用与**Nvidia PhysX引擎**集成的内置3D物理。如果我们想为2D游戏添加物理模拟，那么我们可以选择与**Box2D引擎**集成的内置2D物理。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**PhysX** is an open source, real-time physics engine middleware SDK developed
    by Nvidia as a part of the Nvidia GameWorks software suite. **Box2D** is a free,
    open source 2D physics simulator engine.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**PhysX**是由Nvidia作为Nvidia GameWorks软件套件的一部分开发的开源实时物理引擎中间件SDK。**Box2D**是一个免费的开源2D物理模拟引擎。'
- en: In addition to these built-in Physics solutions, Unity also provides Physics
    engine packages. These are the `Unity Physics` package and the `Havok Physics
    for Unity``Unity's Package Manager`, and they are used in projects with Unity's
    **Data-Oriented Technology Stack (DOTS)**. We will introduce DOTS in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些内置的物理解决方案之外，Unity还提供了物理引擎包。这些是`Unity Physics`包和`Havok Physics for Unity`包，以及它们用于Unity的**数据导向技术堆栈（DOTS）**项目。我们将在后面的章节中介绍DOTS。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Havok Physics** is designed primarily for video games and allows for the
    real-time collision and dynamics of Rigidbodies in 3D.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Havok Physics**主要设计用于视频游戏，允许在3D中实时进行刚体的碰撞和动力学。'
- en: In this chapter, we will focus on the built-in physics and will first learn
    the basic concepts of the Unity Physics system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注内置的物理知识，并首先学习Unity物理系统的基本概念。
- en: Collider
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collider
- en: Similar to the rendering function, a physics engine also needs to understand
    the shape of `GameObjects` in a game scene in order to perform physics simulation
    correctly. When developing a Unity project, we can use the **Collider** component
    to define the shape of a GameObject for physical collision calculations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与渲染功能类似，物理引擎也需要了解游戏场景中`GameObjects`的形状，以便正确执行物理模拟。在开发Unity项目时，我们可以使用**Collider**组件来定义GameObject的形状，以便进行物理碰撞计算。
- en: It should be noted that the shape defined by a collider does not have to be
    exactly the same as the shape of the model. We can even create a collider without
    a model display. For example, we can create a new cube in the scene, and a collider
    component will be created and attached to this cube automatically. Then, the shape
    of the collider can be modified from the Inspector window, as shown in the following
    image; its shape is different from the shape of the model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，由碰撞体定义的形状不必与模型的形状完全相同。我们甚至可以创建一个没有模型显示的碰撞体。例如，我们可以在场景中创建一个新的立方体，并且一个碰撞体组件将自动创建并附加到这个立方体上。然后，可以从以下图像中修改碰撞体的形状；其形状与模型的形状不同。
- en: '![Figure 5.1 – Modifying the shape of the Collider (green frame)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 修改碰撞体的形状（绿色框架）'
- en: '](img/Figure_5.01_B17146.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.01_B17146.jpg)'
- en: Figure 5.1 – Modifying the shape of the Collider (green frame)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 修改碰撞体的形状（绿色框架）
- en: In order to reduce the complexity of physics simulation and improve the performance
    of the game, we often use some rough shapes, such as the **Box Collider** and
    the **Sphere Collider**. Next, we will explore one of the most commonly used colliders,
    namely, the Box Collider.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少物理模拟的复杂性并提高游戏性能，我们经常使用一些粗糙的形状，例如**盒子碰撞体**和**球体碰撞体**。接下来，我们将探讨最常用的碰撞体之一，即盒子碰撞体。
- en: Primitive colliders
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始碰撞体
- en: 'Unity provides a set of primitive colliders for game developers, including
    the Sphere Collider and the Box Collider. The Box Collider is one of the most
    commonly used colliders in Unity. It will be automatically created and assigned
    to the Cube object in a scene, as we see in *Figure 5.1*. We can also add a new
    Box Collider to a GameObject manually, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为游戏开发者提供了一套原始碰撞体，包括球体碰撞体和盒子碰撞体。盒子碰撞体是Unity中最常用的碰撞体之一。它将自动创建并分配到场景中的立方体对象上，正如我们在*图5.1*中看到的那样。我们还可以手动将一个新的盒子碰撞体添加到GameObject中，如下所示：
- en: Create a new GameObject in the scene by clicking the **Create Empty** button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**创建空对象**按钮在场景中创建一个新的GameObject。
- en: '![Figure 5.2 – Creating a new GameObject'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 – 创建新的GameObject'
- en: '](img/Figure_5.02_B17146.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.02_B17146.jpg)'
- en: Figure 5.2 – Creating a new GameObject
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 创建新的GameObject
- en: Select this newly created GameObject and click the **Add Component** button
    in the Inspector window.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新创建的GameObject，并在检查器窗口中点击**添加组件**按钮。
- en: '![Figure 5.3 – Add Component'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 添加组件'
- en: '](img/Figure_5.03_B17146.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.03_B17146.jpg)'
- en: Figure 5.3 – Add Component
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 添加组件
- en: Here, we can select the `Box Collider` in the search box to add the Box Collider
    component to this GameObject.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以在搜索框中选择`盒子碰撞体`以将盒子碰撞体组件添加到这个GameObject中。
- en: '![Figure 5.4 – Adding the Box Collider'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 – 添加盒子碰撞体'
- en: '](img/Figure_5.04_B17146.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.04_B17146.jpg)'
- en: Figure 5.4 – Adding the Box Collider
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 添加盒子碰撞体
- en: 'Now we have added a new **Box Collider** component, and the properties of this
    Box Collider are shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个新的**盒子碰撞体**组件，这个盒子碰撞体的属性如下截图所示：
- en: '![Figure 5.5 – Properties of the Box Collider'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 – 盒子碰撞体的属性'
- en: '](img/Figure_5.05_B17146.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.05_B17146.jpg)'
- en: Figure 5.5 – Properties of the Box Collider
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 盒子碰撞体的属性
- en: The **Edit Collider** button at the top allows us to edit the shape of this
    box in the scene. Below this button, there is an **Is Trigger** checkbox which,
    if enabled, means this collider will be used as a trigger. We will introduce more
    details about triggers later. The third property of this collider is the **Material**
    property, for referring to a **Physics Material** instance. The default value
    of the **Material** property is null, and we can assign an instance of Physics
    Material to adjust the friction and bouncing effects of colliding objects. The
    last two properties, **Center** and **Size**, are used to modify the position
    and size of this box.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的**编辑碰撞体**按钮允许我们编辑场景中这个盒子的形状。在此按钮下方，有一个**是否触发**复选框，如果启用，则表示此碰撞体将用作触发器。我们将在稍后介绍更多关于触发器的细节。此碰撞体的第三个属性是**材质**属性，用于引用**物理材质**实例。**材质**属性的默认值是null，我们可以分配一个物理材质实例来调整碰撞对象的摩擦和弹跳效果。最后两个属性，**中心**和**大小**，用于修改这个盒子的位置和大小。
- en: As we mentioned earlier, similar to the Box Collider, Unity also provides other
    colliders with primitive shapes, such as the Sphere Collider.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，类似于盒子碰撞体，Unity还提供了其他具有原始形状的碰撞体，例如球体碰撞体。
- en: We use them in cases where the accuracy of physical collision simulations is
    not high, but if the game requires accurate physical collision simulations, then
    we can also use another collider, namely, **Mesh Collider**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在物理碰撞模拟精度要求不高的情况下使用它们，但如果游戏需要精确的物理碰撞模拟，我们也可以使用另一个碰撞体，即**网格碰撞体**。
- en: Mesh Collider
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网格碰撞体
- en: Sometimes, we need to develop some game projects that require high physical
    simulation accuracy. In this case, the physical shape of the GameObject is often
    required to be consistent with the shape of the model mesh of the GameObject.
    This is why we need a Mesh Collider.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要开发一些需要高物理模拟精度的游戏项目。在这种情况下，游戏对象的物理形状通常需要与游戏对象的模型网格形状一致。这就是为什么我们需要网格碰撞体的原因。
- en: 'There are different ways to create and add a Mesh Collider to a GameObject.
    Because the Mesh Collider needs the information of the mesh, so, the first way
    to create a Mesh Collider is by importing the model into the Unity Editor. You
    can check the **Generate Colliders** checkbox to import the mesh that automatically
    attaches mesh colliders, as shown in *Figure 5.6*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并添加网格碰撞体到游戏对象的方法有很多。因为网格碰撞体需要网格的信息，所以，创建网格碰撞体的第一种方法是将模型导入Unity编辑器。您可以通过勾选**生成碰撞体**复选框来导入自动附加网格碰撞体的网格，如图*图5.6*所示：
- en: '![Figure 5.6 – Generate Colliders'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 – 生成碰撞体'
- en: '](img/Figure_5.06_B17146.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.06 – B17146.jpg'
- en: Figure 5.6 – Generate Colliders
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 – 生成碰撞体
- en: 'Unity also allows us to add a **Mesh Collider** component to a GameObject manually.
    The steps for adding a Mesh Collider are similar to the steps for adding a Box
    Collider in the previous section. After selecting the target GameObject, click
    the **Add Component** button, and then select **Physics > Mesh Collider** to add
    it to the GameObject, as shown in *Figure 5.7*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还允许我们手动将**网格碰撞体**组件添加到游戏对象。添加网格碰撞体的步骤与上一节中添加箱形碰撞体的步骤类似。选择目标游戏对象后，点击**添加组件**按钮，然后选择**物理
    > 网格碰撞体**将其添加到游戏对象，如图*图5.7*所示：
- en: '![Figure 5.7 – Adding a Mesh Collider to a GameObject'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7 – 将网格碰撞体添加到游戏对象'
- en: '](img/Figure_5.07_B17146.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.07 – B17146.jpg]'
- en: Figure 5.7 – Adding a Mesh Collider to a GameObject
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7 – 将网格碰撞体添加到游戏对象
- en: Since the mesh of a model may consist of many vertices and triangles, and the
    Mesh Collider will be generated based on the mesh, the computational cost of a
    Mesh Collider is much larger than that of the colliders introduced before. Even
    by default, Unity does not calculate the collision between mesh colliders, but
    only calculates the collision between a Mesh Collider and primitive colliders,
    such as a Box Collider and a Sphere Collider.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型网格可能由许多顶点和三角形组成，并且网格碰撞体将基于网格生成，因此网格碰撞体的计算成本远大于之前介绍过的碰撞体。即使默认情况下，Unity也不会计算网格碰撞体之间的碰撞，而只计算网格碰撞体与原始碰撞体（如箱形碰撞体和球形碰撞体）之间的碰撞。
- en: 'In order to enable collision detection between mesh colliders, we need to reduce
    their complexity by checking the **Convex** checkbox of the Mesh Collider component,
    as you can see in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用网格碰撞体之间的碰撞检测，我们需要通过检查网格碰撞体组件的**凸形**复选框来降低它们的复杂性，如下截图所示：
- en: '![Figure 5.8 – Properties of a Mesh Collider'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 网格碰撞体的属性'
- en: '](img/Figure_5.08_B17146.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.08 – B17146.jpg'
- en: Figure 5.8 – Properties of a Mesh Collider
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 网格碰撞体的属性
- en: By enabling this checkbox, **Mesh Collider** is limited to 255 triangles. If
    we look at the GameObject in the scene at the same time, we can see that the Mesh
    Collider is only roughly consistent with the model's mesh, and that the complexity
    has been greatly reduced.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过勾选此复选框，**网格碰撞体**将被限制为255个三角形。如果我们同时查看场景中的游戏对象，我们可以看到网格碰撞体仅大致与模型的网格一致，并且复杂性已经大大降低。
- en: '![Figure 5.9 – A convex Mesh Collider'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – 凸形网格碰撞体'
- en: '](img/Figure_5.09_B17146.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.09_B17146.jpg)'
- en: Figure 5.9 – A convex Mesh Collider
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 凸形网格碰撞体
- en: However, if we run the game now, we will find that no physical effects are applied
    to the game; for example, objects will not fall due to gravity. This is because
    our game still lacks an important component. Let's explore this next!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们现在运行游戏，我们会发现没有任何物理效果应用于游戏；例如，物体不会因为重力而落下。这是因为我们的游戏仍然缺少一个重要的组件。让我们接下来探索这个问题！
- en: Rigidbody
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体
- en: The **Rigidbody** component is an indispensable component for applying physical
    effects in Unity. By adding Rigidbody to a GameObject, physics will control the
    GameObject, such as applying gravity to it. Rigidbodies are usually used with
    colliders; if two Rigidbodies collide with one another, unless the two GameObjects
    have colliders attached, they will not have a collision effect between them but
    will pass through each other.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**刚体**组件是Unity中应用物理效果的必备组件。通过将刚体添加到GameObject，物理将控制该GameObject，例如对其应用重力。刚体通常与碰撞体一起使用；如果两个刚体相互碰撞，除非两个GameObject都附加了碰撞体，否则它们之间不会有碰撞效果，而是会相互穿过。'
- en: 'Now, let''s add a **Rigidbody** component to a GameObject in the scene:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在场景中的GameObject上添加一个**刚体**组件：
- en: Create a new cube in the scene by clicking the **3D Object > Cube** button.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**3D对象 > 立方体**按钮在场景中创建一个新的立方体。
- en: '![Figure 5.10 – Creating a new cube'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.10 – 创建一个新的立方体'
- en: '](img/Figure_5.10_B17146.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.10_B17146.jpg]'
- en: Figure 5.10 – Creating a new cube
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 创建一个新的立方体
- en: 'Select this newly created cube and click the **Add Component** button in the
    Inspector window. And as you can see in *Figure 5.11*, a Box Collider has been
    attached to the cube:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这个新创建的立方体，并在检查器窗口中点击**添加组件**按钮。正如*图5.11*所示，一个盒子碰撞体已经被附加到立方体上：
- en: '![Figure 5.11 – Add Component'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.11 – 添加组件'
- en: '](img/Figure_5.11_B17146.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.11_B17146.jpg]'
- en: Figure 5.11 – Add Component
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 添加组件
- en: Here, we can select the **Physics > Rigidbody** button to add a **Rigidbody**
    component to this cube.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以选择**物理 > 刚体**按钮来向这个立方体添加一个**刚体**组件。
- en: '![Figure 5.12 – Adding the Box Collider'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.12 – 添加盒子碰撞体'
- en: '](img/Figure_5.12_B17146.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.12_B17146.jpg]'
- en: Figure 5.12 – Adding the Box Collider
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 添加盒子碰撞体
- en: 'Now we have added a new **Rigidbody** component, and the properties of this
    Rigidbody are shown in *Figure 5.13*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一个新的**刚体**组件，这个刚体的属性在*图5.13*中展示：
- en: '![Figure 5.13 – Properties of a Rigidbody'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.13 – 刚体的属性'
- en: '](img/Figure_5.13_B17146.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_5.13_B17146.jpg]'
- en: Figure 5.13 – Properties of a Rigidbody
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13 – 刚体的属性
- en: As we can see in *Figure 5.13*, the **Use Gravity** property of the Rigidbody
    is checked by default, which means that this Rigidbody will apply gravity to the
    cube. If we run the game at this time, we will find that the cube will fall down
    under the influence of gravity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图5.13*所示，刚体的**使用重力**属性默认是勾选的，这意味着这个刚体将对立方体应用重力。如果我们此时运行游戏，我们会发现立方体会在重力作用下向下坠落。
- en: In addition to the **Use Gravity** property, the Rigidbody has other properties,
    and we will introduce these properties below.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**使用重力**属性外，刚体还有其他属性，我们将在下面介绍这些属性。
- en: The first property of a Rigidbody component is **Mass**, which determines how
    Rigidbodies react when they collide with each other. Next is the **Drag** property,
    which determines how much air resistance the object is affected by when it is
    moving under force. By default, the value is **zero**, which means there is no
    air resistance when the cube is moving by force. The **Angular Drag** property
    is similar to the **Drag** property, the difference being that it determines how
    much air resistance affects the object when rotating from torque.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体组件的第一个属性是**质量**，它决定了刚体在相互碰撞时的反应。接下来是**阻力**属性，它决定了当物体在力的作用下移动时受到的空气阻力有多大。默认值是**零**，这意味着当立方体受到力移动时没有空气阻力。**角阻力**属性与**阻力**属性类似，区别在于它决定了空气阻力在物体由于扭矩旋转时对物体的影响程度。
- en: 'The **Is Kinematic** property is important because it determines whether this
    GameObject will be controlled by the Physics system in Unity. By default, it''s
    disabled. If we enable it, this GameObject will no longer be driven by physics.
    The **Interpolate** property is useful when you find that the Rigidbody''s movement
    is jerky. The default value of **Interpolate** is **None**, but Unity allows us
    to select different options for this property, such as **Interpolate** or **Extrapolate**,
    which, respectively, indicate that the transform is based on the transform of
    the previous frame for smoothing, or that the transform is smoothed based on the
    estimated transform of the next frame, as shown in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**Is Kinematic** 属性很重要，因为它决定了这个 GameObject 是否将由 Unity 的物理系统控制。默认情况下，它是禁用的。如果我们启用它，这个
    GameObject 将不再由物理驱动。当您发现 Rigidbody 的运动很颠簸时，**Interpolate** 属性很有用。**Interpolate**
    的默认值是 **None**，但 Unity 允许我们为这个属性选择不同的选项，例如 **Interpolate** 或 **Extrapolate**，分别表示变换基于前一帧的变换进行平滑，或者变换基于下一帧的估计变换进行平滑，如下面的截图所示：'
- en: '![Figure 5.14 – Options of the Interpolate property'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.14 – Interpolate 属性的选项'
- en: '](img/Figure_5.14_B17146.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.14_B17146.jpg)'
- en: Figure 5.14 – Options of the Interpolate property
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – Interpolate 属性的选项
- en: Next is the **Collision Detection** property. Sometimes, if a Rigidbody is moving
    too fast, causing the physics engine to not detect the collision in time, then
    maybe adjusting this property is a good idea. Unity also provides us with different
    options for **Collision****Detection**; these are **Discrete**, **Continuous**,
    **Continuous Dynamic**, and **Continuous Speculative**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 **Collision Detection** 属性。有时，如果 Rigidbody 移动得太快，导致物理引擎没有及时检测到碰撞，那么调整这个属性可能是一个好主意。Unity
    也为我们提供了不同的 **Collision Detection** 选项；这些是 **Discrete**、**Continuous**、**Continuous
    Dynamic** 和 **Continuous Speculative**。
- en: '![Figure 5.15 – Options of the Collision Detection property'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.15 – Collision Detection 属性的选项'
- en: '](img/Figure_5.15_B17146.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.15_B17146.jpg)'
- en: Figure 5.15 – Options of the Collision Detection property
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – Collision Detection 属性的选项
- en: The **Discrete** option is the default value and is used for detecting normal
    collisions. If you encountered issues with fast object collisions, then **Continuous**
    is a good choice, but you should remember that **Continuous** will impact performance
    compared to **Discrete**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**Discrete** 选项是默认值，用于检测正常碰撞。如果您遇到了快速对象碰撞的问题，那么 **Continuous** 是一个好的选择，但您应该记住，**Continuous**
    与 **Discrete** 相比会影响性能。'
- en: If you want to restrict a Rigidbody's motion, such as restricting the Rigidbody
    from moving in a certain direction or not being able to rotate on a certain axis,
    then you can do so by modifying the **Constraints** property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想限制 Rigidbody 的运动，例如限制 Rigidbody 在某个方向上移动或不能在某个轴上旋转，那么您可以通过修改 **Constraints**
    属性来实现。
- en: '![Figure 5.16 – The Constraints property'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.16 – Constraints 属性'
- en: '](img/Figure_5.16_B17146.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.16_B17146.jpg)'
- en: Figure 5.16 – The Constraints property
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – Constraints 属性
- en: As shown in *Figure 5.16*, you can select an axis to prevent the Rigidbody from
    moving along it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 5.16* 所示，您可以选择一个轴来防止 Rigidbody 沿着该轴移动。
- en: Through a Rigidbody component, we add physical effects to a GameObject, but
    sometimes we don't want the GameObject to move according to the results of the
    physics simulation, but just want to be able to detect the collision between two
    objects and trigger some events. This is a common function in games; for example,
    the player triggers the corresponding logic after entering a certain area. Next,
    we will introduce another feature provided by Unity to implement such requirements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Rigidbody 组件，我们为 GameObject 添加物理效果，但有时我们不想让 GameObject 根据物理模拟的结果移动，而只想能够检测两个对象之间的碰撞并触发某些事件。这在游戏中是一个常见的功能；例如，玩家进入某个区域后触发相应的逻辑。接下来，我们将介绍
    Unity 提供的另一个功能来实现这样的要求。
- en: Trigger
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器
- en: In addition to providing collision effects, colliders can also be used as triggers.
    However, unlike being used as a normal collider, when a trigger is enabled, there
    is no collision effect when Rigidbodies collide. However, the physical effect
    will still take effect; for example, a trigger can still fall under the influence
    of gravity, but it will not collide with other Rigidbodies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供碰撞效果外，碰撞体还可以用作触发器。然而，与用作普通碰撞体不同，当触发器启用时，Rigidbody 碰撞时没有碰撞效果。但是，物理效果仍然有效；例如，触发器仍然会受到重力的影响，但它不会与其他
    Rigidbody 发生碰撞。
- en: 'When developing a Unity project, triggers are used to detect external interactions
    from other GameObjects and execute the code in the `OnTriggerEnter`, `OnTriggerStay`,
    or `OnTriggerExit` functions in the script. These three functions represent three
    different stages of interactions, namely, entering, staying, and exiting. We will
    introduce more details about those functions in the next section. For the moment,
    let''s create a trigger by performing the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发Unity项目时，触发器用于检测来自其他GameObject的外部交互，并在脚本中的`OnTriggerEnter`、`OnTriggerStay`或`OnTriggerExit`函数中执行代码。这三个函数代表交互的三个不同阶段，即进入、停留和退出。我们将在下一节中详细介绍这些函数。目前，让我们通过以下步骤创建一个触发器：
- en: Select the Cube object we created earlier to open Inspector window.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的立方体对象以打开检查器窗口。
- en: 'Enable the **Is Trigger** property of the Box Collider component attached to
    this Cube object, as shown in the following screenshot:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用附加到这个立方体对象上的Box Collider组件的**Is Trigger**属性，如图下所示：
- en: '![Figure 5.17 – Enabling the Is Trigger property'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.17 – 启用Is Trigger属性'
- en: '](img/Figure_5.17_B17146.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.17_B17146.jpg)'
- en: Figure 5.17 – Enabling the Is Trigger property
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17 – 启用Is Trigger属性
- en: Now, this cube is set as a trigger, and it will no longer block other Rigidbodies.
    Since it is now a trigger, we can use it to create game levels. For example, when
    the player touches this cube, it will trigger a trap.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个立方体被设置为触发器，它将不再阻止其他刚体。由于它现在是一个触发器，我们可以用它来创建游戏关卡。例如，当玩家触摸这个立方体时，它将触发一个陷阱。
- en: As a reminder, Unity also provides physical components used for 2D. If you want
    to develop a 2D game and need to apply physical effects to your game, then you
    can easily add 2D versions of these physical components in the same way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，Unity还提供了用于2D的物理组件。如果您想开发2D游戏并需要在游戏中应用物理效果，那么您可以轻松地以相同的方式添加这些物理组件的2D版本。
- en: By reading this section, we have learned some concepts of Unity's Physics system,
    such as colliders, Rigidbodies, and triggers. Next, we will continue to explore
    how to use C# scripts to interact with the Physics system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本节，我们已经学习了Unity物理系统的一些概念，例如碰撞体、刚体和触发器。接下来，我们将继续探讨如何使用C#脚本与物理系统交互。
- en: Scripting with the Physics system
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用物理系统进行脚本编写
- en: In this section, we will explore how to interact with the Physics system via
    C# scripts. Similar to the previous section, we will also introduce the C# methods
    for colliders, triggers, and Rigidbodies, respectively. We will start with the
    C# methods for colliders.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何通过C#脚本与物理系统交互。类似于上一节，我们也将分别介绍碰撞体、触发器和刚体的C#方法。我们将从碰撞体的C#方法开始。
- en: Collision methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞方法
- en: When a collider is not used as a trigger, collisions between Rigidbodies still
    occur. These three methods are called when a collision occurs, and the parameter
    type is the **Collision** class, which provides some information to describe the
    collision, such as the contact point and the impact velocity of the collision.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当碰撞体不被用作触发器时，刚体之间的碰撞仍然会发生。当发生碰撞时，会调用这三个方法，参数类型是**Collision**类，它提供了一些描述碰撞的信息，例如接触点和碰撞的冲击速度。
- en: OnCollisionEnter
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OnCollisionEnter
- en: 'The first method is `OnCollisionEnter`, which is called when this collider
    begins to touch another collider. It is useful when you want to make this object
    be affected by a physical collision, but also want to perform some game logic
    when the collision occurs. For example, when a bullet hits the target in a game,
    a corresponding explosion effect can be generated for it, as the following C#
    code snippet demonstrates:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是`OnCollisionEnter`，当这个碰撞体开始接触另一个碰撞体时被调用。当您希望这个对象受到物理碰撞的影响，同时在碰撞发生时执行一些游戏逻辑时，它非常有用。例如，当子弹击中游戏中的目标时，可以为其生成相应的爆炸效果，如下面的C#代码片段所示：
- en: '[PRE0]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the code snippet, we accessed the contact point data provided by the collision
    object and instantiated the explosion asset at that point.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们访问了由碰撞对象提供的接触点数据，并在该点实例化了爆炸资产。
- en: OnCollisionStay
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OnCollisionStay
- en: '`OnCollisionStay` is the second method we will explore here. As long as two
    objects collide, `OnCollisionStay` will be called once per frame. Since this method
    will be called during the collision of objects, it is suitable to be used to implement
    some logic that will last for a period of time. An interesting example of this
    is as follows: Suppose you are developing a helicopter game, and you want the
    helicopter''s engine to run at 60% of its maximum strength when the skid touches
    the ground. In this case, we can use the following code snippet to implement this
    function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnCollisionStay` 是我们将要探索的第二个方法。只要两个物体发生碰撞，`OnCollisionStay` 就会在每一帧被调用一次。由于这个方法将在物体碰撞期间被调用，因此它适合用来实现一些需要持续一段时间的逻辑。一个有趣的例子如下：假设你正在开发一款直升机游戏，并且当你想要直升机在接触地面时以最大强度的60%运行引擎。在这种情况下，我们可以使用以下代码片段来实现这个功能：'
- en: '[PRE1]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: OnCollisionExit
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`OnCollisionExit`'
- en: 'The last method I want to introduce here is `OnCollisionExit`. As the name
    of this method implies, it will be called when this collider stops touching another
    collider. If some content is generated at the beginning of the object collision
    via `OnCollisionEnter`, and you want to destroy them when the object collision
    ends, then you should consider using `OnCollisionExit`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我要在这里介绍的最后一种方法是 `OnCollisionExit`。正如这个方法的名字所暗示的，当这个碰撞体停止接触另一个碰撞体时，它将被调用。如果在物体碰撞的开始通过
    `OnCollisionEnter` 生成了一些内容，并且你希望在物体碰撞结束时销毁它们，那么你应该考虑使用 `OnCollisionExit`：
- en: '[PRE2]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code snippet demonstrates how to use `OnCollisionExit` to reset
    the `_isGrounded` field.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段展示了如何使用 `OnCollisionExit` 来重置 `_isGrounded` 字段。
- en: We have covered typical methods used in colliders. Now, we'll look at how to
    use triggers in a Unity project.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在碰撞体中使用的典型方法。现在，我们将看看如何在 Unity 项目中使用触发器。
- en: Trigger methods
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触发器方法
- en: In fact, we still use colliders to implement triggers, and just need to check
    the **Is Trigger** option of the **Collider** component. At this time, the collider
    will no longer produce the physical collision effect, but activate trigger events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们仍然使用碰撞体来实现触发器，只需要检查**碰撞体**组件的**触发器**选项。此时，碰撞体将不再产生物理碰撞效果，但会激活触发器事件。
- en: There are three events commonly used to implement a trigger, namely, `OnTriggerEnter`,
    `OnTriggerStay`, and `OnTriggerExit`. These three methods are called when two
    GameObjects collide, and the parameter type is the `Collider` class, which provides
    information about other colliders involved in this collision.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 常用来实现触发器的三个事件分别是 `OnTriggerEnter`、`OnTriggerStay` 和 `OnTriggerExit`。这三个方法在两个
    GameObject 发生碰撞时被调用，参数类型是 `Collider` 类，它提供了关于参与此碰撞的其他碰撞体的信息。
- en: OnTriggerEnter
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter`'
- en: The first method is `OnTriggerEnter`, which is called when this collider begins
    touching another collider. The **Is Trigger** option should be enabled in this
    case. This method is useful when you want to trigger some operations on surrounding
    elements but don't want to produce physical collision effects. For example, you
    could use this to implement a trap in your game.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是 `OnTriggerEnter`，它在碰撞体开始接触另一个碰撞体时被调用。在这种情况下，应该启用**触发器**选项。当你想在周围元素上触发一些操作但不想产生物理碰撞效果时，这个方法很有用。例如，你可以用它来实现游戏中的陷阱。
- en: 'It is also very simple to use. We only need to include the game logic that
    will be triggered in the definition of this method, as shown in the following
    code snippet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用也非常简单。我们只需要在方法的定义中包含将被触发的游戏逻辑，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When this GameObject collides with another GameObject, the string by means of
    which this GameObject enters the other GameObject will be printed in the Console
    window.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个 GameObject 与另一个 GameObject 发生碰撞时，通过这个 GameObject 进入另一个 GameObject 的字符串将在控制台窗口中打印出来。
- en: OnTriggerStay
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`OnTriggerStay`'
- en: '`OnTriggerStay` is the second method we will explore here. Similar to the `OnCollisionStay`
    method we discussed before, `OnTriggerStay` will be called in all frames when
    other colliders touch this trigger. This method is also suitable for implementing
    trap-like gameplay in a game; for example, the player enters a poisonous fog and
    will continue to be hurt:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnTriggerStay` 是我们将要探索的第二个方法。与之前讨论的 `OnCollisionStay` 方法类似，`OnTriggerStay`
    将在其他碰撞体接触此触发器时在所有帧中被调用。这种方法也适合在游戏中实现类似陷阱的游戏玩法；例如，玩家进入有毒迷雾后将继续受到伤害：'
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we also only need to put the game logic that will be triggered in the
    definition of the `OnTriggerStay` method, as shown in the preceding code snippet.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需要在`OnTriggerStay`方法的定义中放置将被触发的游戏逻辑，如前面的代码片段所示。
- en: OnTriggerExit
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OnTriggerExit
- en: 'The last method I want to introduce here is `OnTriggerExit`. This method will
    be called when other colliders leave the trigger. This method is suitable for
    some tasks, such as destroying the GameObjects created when other colliders enter
    this trigger, resetting the state, and so on. The following code snippet shows
    how to destroy a GameObject in `OnTriggerExit`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里要介绍的最后一种方法是`OnTriggerExit`。当其他碰撞体离开触发器时，将调用此方法。此方法适用于一些任务，例如销毁其他碰撞体进入此触发器时创建的GameObject，重置状态等。以下代码片段展示了如何在`OnTriggerExit`中销毁一个GameObject：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Methods of Rigidbody
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rigidbody的方法
- en: The **Rigidbody** component provides us with the ability to directly interact
    with the Physics system in Unity. We can use the methods provided by the **Rigidbody**
    component in the C# script to apply a force to this Rigidbody, and we can also
    apply a force to a Rigidbody that simulates explosion effects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rigidbody**组件为我们提供了直接与Unity中的物理系统交互的能力。我们可以使用C#脚本中**Rigidbody**组件提供的方法来对此Rigidbody施加力，我们还可以对模拟爆炸效果的Rigidbody施加力。'
- en: It should be noted that, as we mentioned in [*Chapter 2*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025),
    *Scripting Concepts in Unity*, in a script, it is recommended to use the `FixedUpdate`
    function for a physical update, so we should call Rigidbody methods in the `FixedUpdate`
    function to apply the physical effect. Now, let's explore some commonly used methods.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，正如我们在[*第2章*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025)中提到的，*Unity中的脚本概念*，在脚本中，建议使用`FixedUpdate`函数进行物理更新，因此我们应该在`FixedUpdate`函数中调用Rigidbody方法以应用物理效果。现在，让我们探索一些常用的方法。
- en: AddForce
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AddForce
- en: 'The `AddForce` method is one of the most commonly used methods related to physics.
    As its name implies, we can call this method to apply a force to the Rigidbody.
    The function signature of `AddForce` is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddForce`方法是与物理相关的最常用的方法之一。正如其名称所暗示的，我们可以调用此方法向Rigidbody施加力。`AddForce`函数的签名如下：'
- en: '[PRE6]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this method requires two parameters, namely, the force vector
    in world coordinates and the type of force to apply. `AddForce` allows us to define
    a force vector and choose how to apply this force to the GameObject to affect
    how our GameObject moves.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此方法需要两个参数，即世界坐标系中的力矢量和要应用的力类型。`AddForce`允许我们定义一个力矢量并选择如何将此力应用到GameObject上，以影响我们的GameObject的运动方式。
- en: The first parameter, `force`, is a vector type that specifies the direction
    in which the force is applied to this object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，`force`，是一个矢量类型，指定了施加到该对象上的力的方向。
- en: On the other hand, the `ForceMode` type parameter, `mode`, determines the type
    of force applied. `ForceMode` is an `enum` type, which defines four different
    types of force. By default, the `AddForce` method will add a continuous force
    to the Rigidbody, using its mass. In the following section, I will introduce the
    different types of force modes in detail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ForceMode`类型参数`mode`决定了应用的力类型。`ForceMode`是一个`enum`类型，它定义了四种不同的力类型。默认情况下，`AddForce`方法将使用其质量向Rigidbody添加持续的力量。在下一节中，我将详细介绍不同类型的力模式。
- en: ForceMode
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ForceMode
- en: '`ForceMode` is defined in the `UnityEngine` namespace, and we can see its definition
    in the following code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForceMode`定义在`UnityEngine`命名空间中，我们可以在以下代码片段中看到其定义：'
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As the preceding code snippet shows, there are four types of force mode, namely,
    `Force`, `Impulse`, `VelocityChange`, and `Acceleration`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，有四种类型的力模式，即`Force`、`Impulse`、`VelocityChange`和`Acceleration`。
- en: '`Force` is the default mode and in this mode, more force must be applied to
    push or distort objects with larger masses because it depends on the mass of the
    Rigidbody. It will add a continuous force to the Rigidbody.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`力`是默认模式，在此模式下，需要施加更大的力来推动或扭曲质量较大的物体，因为这与Rigidbody的质量有关。它将为Rigidbody添加持续的力量。'
- en: If we choose `Impulse` mode as the argument, then the `AddForce` method will
    apply an instant force impulse to the Rigidbody. This mode is suitable for simulating
    forces from explosions or collisions. As with the `Force` mode, the `Impulse`
    mode also depends on the mass of the Rigidbody.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Impulse`模式作为参数，那么`AddForce`方法将向Rigidbody应用一个瞬时的力脉冲。此模式适用于模拟爆炸或碰撞产生的力。与`Force`模式一样，`Impulse`模式也取决于Rigidbody的质量。
- en: '`VelocityChange` is the third mode here. If we select this mode, then Unity
    will apply the velocity change instantly with a single function call. It should
    be noted that the `VelocityChange` mode is different from the `Impulse` mode and
    the `Force` mode. The `VelocityChange` mode does not depend on the mass of the
    Rigidbody, which means that `VelocityChange` will change the velocity of each
    Rigidbody in the same way.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`VelocityChange`是这里的第三种模式。如果我们选择此模式，则Unity将使用单个函数调用立即应用速度变化。需要注意的是，`VelocityChange`模式与`冲量`模式和`力`模式不同。`VelocityChange`模式不依赖于Rigidbody的质量，这意味着`VelocityChange`将以相同的方式改变每个Rigidbody的速度。'
- en: The last mode is `Acceleration` mode. If this mode is selected, then Unity will
    add a continuous acceleration to the Rigidbody. Like the `VelocityChange` mode,
    `Acceleration` mode also ignores the mass of the Rigidbody, which means `AddForce`
    will move every Rigidbody the same way.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的模式是`加速度`模式。如果选择此模式，则Unity将为Rigidbody添加持续加速度。与`速度变化`模式一样，`加速度`模式也忽略Rigidbody的质量，这意味着`AddForce`将以相同的方式移动每个Rigidbody。
- en: 'So far, we have learned the different force modes available for the `AddForce`
    method. Next, let''s create a new C# script and apply a force to the cube by calling
    `AddForce`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了`AddForce`方法可用的不同力模式。接下来，让我们创建一个新的C#脚本，并通过调用`AddForce`对立方体施加力：
- en: '[PRE8]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the code, we can apply a continuous force to the Rigidbody by pressing
    the *F* key on the keyboard and applying a continuous acceleration to the Rigidbody
    by pressing the *A* key on the keyboard.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，我们可以通过按键盘上的*F*键对Rigidbody施加持续力，并通过按键盘上的*A*键对Rigidbody施加持续加速度。
- en: MovePosition
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MovePosition
- en: Sometimes, we just want to move our GameObjects and don't want to deal with
    forces. The `MovePosition` method of Rigidbody can help us to achieve this goal.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们只想移动我们的GameObject，而不想处理力。Rigidbody的`MovePosition`方法可以帮助我们实现这个目标。
- en: 'The function signature of `MovePosition` is as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`MovePosition`函数的签名如下：'
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we need a parameter position to provide the new position for the Rigidbody
    object to move to. To make the Rigidbody move smoothly, we often use interpolation
    to achieve a smooth transition between frames. Since `MovePosition` is still a
    method of Rigidbody, we still call it in the `FixedUpdate` function, as shown
    in the following code snippet:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要一个参数位置来提供Rigidbody对象移动到的新位置。为了使Rigidbody平滑移动，我们通常使用插值来实现帧之间的平滑过渡。由于`MovePosition`仍然是Rigidbody的方法，我们仍然在`FixedUpdate`函数中调用它，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we get user input as the direction of movement and apply the movement
    to the current position. You can also see that the movement vector is multiplied
    by `deltaTime` and `speed`, which is for smooth movement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取用户输入作为移动方向，并将移动应用到当前位置。您还可以看到，移动向量乘以`deltaTime`和`speed`，这是为了实现平滑移动。
- en: After reading this section, we learned how to interact with the Physics system
    through C# scripts. But it's best if we implement a simple game ourselves using
    the physics system, and that's what we'll do in the next section! Let's move on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本节之后，我们学习了如何通过C#脚本与物理系统交互。但最好是我们自己使用物理系统实现一个简单的游戏，这就是我们在下一节要做的事情！让我们继续。
- en: Creating a simple game based on the Physics system
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物理系统创建一个简单的游戏
- en: We have learned the concepts of Unity's Physics system and discussed how to
    use C# code to interact with the Physics system. Next, we will use the knowledge
    we have learned to create a simple physics-based ping-pong game in Unity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了Unity物理系统的概念，并讨论了如何使用C#代码与物理系统交互。接下来，我们将使用我们所学到的知识在Unity中创建一个简单的基于物理的乒乓球游戏。
- en: 'First, let''s perform the following steps to create a **Plane** object as a
    ping-pong table:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们执行以下步骤来创建一个**平面**对象作为乒乓球桌：
- en: Right-click on the **Hierarchy** window to open the menu.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Hierarchy**窗口打开菜单。
- en: Select **3D Object > Plane** to create a new **Plane** object in the editor.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**3D Object > Plane**在编辑器中创建一个新的**平面**对象。
- en: '![Figure 5.18 – Creating a Plane object'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18 – 创建平面对象'
- en: '](img/Figure_5.18_B17146.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.18_B17146.jpg)'
- en: Figure 5.18 – Creating a Plane object
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18 – 创建平面对象
- en: Rename the `Table`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名`Table`。
- en: Select `2`, and we can see that a Mesh Collider has been added to this object
    by default.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`2`，我们可以看到默认情况下已经为这个对象添加了一个Mesh Collider。
- en: '![Figure 5.19 – The Inspector window of "Table"'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19 – “Table”的检查器窗口'
- en: '](img/Figure_5.19_B17146.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.19_B17146.jpg)'
- en: Figure 5.19 – The Inspector window of "Table"
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19 – “Table”的检查器窗口
- en: Let's create four Cube objects as walls on the table by selecting **3D Object
    > Cube**, which is similar to the process of creating a **Plane** object. By default,
    a Box Collider has been added to every Cube object.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**3D Object > Cube**创建四个立方体对象作为桌子上的墙壁，这个过程与创建**平面**对象的过程类似。默认情况下，每个立方体对象都添加了一个Box
    Collider。
- en: We can easily adjust the position, size, and rotation of these four Cube objects
    by using the tools in the editor to create the walls on the table.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用编辑器中的工具轻松调整这四个立方体对象的位置、大小和旋转，以创建桌子上的墙壁。
- en: '![Figure 5.20 – Creating walls on the table'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20 – 在桌子上创建墙壁'
- en: '](img/Figure_5.20_B17146.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.20_B17146.jpg)'
- en: Figure 5.20 – Creating walls on the table
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20 – 在桌子上创建墙壁
- en: 'In order to make the table look less boring, we can apply different materials
    to the walls and the table. Now we have set up the ping-pong table, as shown in
    the following image:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让桌子看起来不那么无聊，我们可以将不同的材质应用到墙壁和桌子上。现在我们已经设置了乒乓球桌，如下面的图片所示：
- en: '![Figure 5.21 – The ping-pong table'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21 – 乒乓球桌'
- en: '](img/Figure_5.21_B17146.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.21_B17146.jpg)'
- en: Figure 5.21 – The ping-pong table
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21 – 乒乓球桌
- en: 'Next, we need to create two players, namely, **Player1** and **Player2**. To
    keep it simple, we still use two Cube objects as players:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建两个玩家，即**Player1**和**Player2**。为了保持简单，我们仍然使用两个立方体对象作为玩家：
- en: Select **3D Object > Cube** to create a new Cube object in the scene.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**3D Object > Cube**在场景中创建一个新的立方体对象。
- en: Rename the Cube object to `Player1`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将立方体对象重命名为`Player1`。
- en: Adjust the position and size of `3`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`3`的位置和大小。
- en: '![Figure 5.22 – The Inspector window of Player1'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.22 – Player1的检查器窗口'
- en: '](img/Figure_5.22_B17146.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.22_B17146.jpg)'
- en: Figure 5.22 – The Inspector window of Player1
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22 – Player1的检查器窗口
- en: Let's repeat the preceding steps to create another player.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重复前面的步骤来创建另一个玩家。
- en: 'We can use different colors to identify **Player1** and **Player2** to distinguish
    them, as the following figure shows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用不同的颜色来识别**Player1**和**Player2**，以便区分它们，如下面的图所示：
- en: '![Figure 5.23 – Player1 and Player2'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23 – Player1和Player2'
- en: '](img/Figure_5.23_B17146.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.23_B17146.jpg)'
- en: Figure 5.23 – Player1 and Player2
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23 – Player1和Player2
- en: 'Now we have the **Player** objects in our simple game. Next, we will add a
    ping-pong ball to our game:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的简单游戏中有了**Player**对象。接下来，我们将向我们的游戏中添加一个乒乓球：
- en: Select **3D Object > Sphere** to create a new **Sphere** object in the scene.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**3D Object > Sphere**在场景中创建一个新的**Sphere**对象。
- en: Rename the `Ball`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Ball`重命名。
- en: Select **Ball** to open its Inspector window. We can see that a Sphere Collider
    has been added to the ball by default.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Ball**打开其检查器窗口。我们可以看到，默认情况下已经为球添加了一个Sphere Collider。
- en: '![Figure 5.24 – The Sphere Collider component'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24 – 球形Collider组件'
- en: '](img/Figure_5.24_B17146.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.24_B17146.jpg)'
- en: Figure 5.24 – The Sphere Collider component
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24 – 球形Collider组件
- en: Then, we need to add a **Rigidbody** component to this ball by clicking the
    **Add Component** button and selecting **Physics > Rigidbody**.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要通过点击**Add Component**按钮并选择**Physics > Rigidbody**来向这个球添加一个**Rigidbody**组件。
- en: '![Figure 5.25 – Adding a Rigidbody component'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25 – 添加Rigidbody组件'
- en: '](img/Figure_5.25_B17146.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.25_B17146.jpg)'
- en: Figure 5.25 – Adding a Rigidbody component
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25 – 添加Rigidbody组件
- en: Then, we change the **Interpolate** option of this **Rigidbody** component from
    **None** to **Interpolate** to make the transformation smooth based on the transformation
    of the previous frame.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将这个**Rigidbody**组件的**Interpolate**选项从**None**更改为**Interpolate**，以便根据前一帧的变换使变换平滑。
- en: '![Figure 5.26 – Changing the Interpolate option'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26 – 更改Interpolate选项'
- en: '](img/Figure_5.26_B17146.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.26_B17146.jpg)'
- en: Figure 5.26 – Changing the Interpolate option
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26 – 更改Interpolate选项
- en: Then, we also change the **Collision Detection** option of this **Rigidbody**
    component from **Discrete** to **Continuous Dynamic** so that we can handle the
    fast-moving ping-pong ball correctly.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将这个**Rigidbody**组件的**Collision Detection**选项从**Discrete**更改为**Continuous
    Dynamic**，以便正确处理快速移动的乒乓球。
- en: '![Figure 5.27 – Changing the Collision Detection option'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.27 – 更改Collision Detection选项'
- en: '](img/Figure_5.27_B17146.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.27_B17146.jpg)'
- en: Figure 5.27 – Changing the Collision Detection option
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.27 – 更改Collision Detection选项
- en: Since the real-world ping-pong ball will bounce back when it hits an obstacle,
    in order to simulate this bounce effect, we need to create a physic material by
    clicking **Create > Physic Material** in the Project window.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于现实世界的乒乓球在撞击障碍物时会弹回，为了模拟这种弹跳效果，我们需要通过在项目窗口中点击 **创建 > 物理材质** 来创建一个物理材质。
- en: '![Figure 5.28 – Creating a physic material'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.28 – 创建物理材质'
- en: '](img/Figure_5.28_B17146.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.28_B17146.jpg)'
- en: Figure 5.28 – Creating a physic material
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.28 – 创建物理材质
- en: 'Let''s select the newly created physic material to open the Inspector window
    and change both `0.4` to `0`, and `0` to `1`. Also, set the `Multiply` and the
    `Maximum`, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们选择新创建的物理材质，打开检查器窗口，将 `0.4` 更改为 `0`，将 `0` 更改为 `1`。同时，设置 `Multiply` 和 `Maximum`，如下截图所示：
- en: '![Figure 5.29 – Physic Material settings'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.29 – 物理材质设置'
- en: '](img/Figure_5.29_B17146.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.29_B17146.jpg)'
- en: Figure 5.29 – Physic Material settings
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.29 – 物理材质设置
- en: Then, assign this physic material to the **Material** option of the Sphere Collider.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将此物理材质分配给球体碰撞器的 **材质** 选项。
- en: '![Figure 5.30 – Assigning the physic material to the Sphere Collider'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.30 – 将物理材质分配给球体碰撞器'
- en: '](img/Figure_5.30_B17146.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.30_B17146.jpg)'
- en: Figure 5.30 – Assigning the physic material to the Sphere Collider
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.30 – 将物理材质分配给球体碰撞器
- en: 'Now we have set up the ping-pong ball that will be used in our game. Next,
    let''s create a new C# script to apply force to the ball to move it:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了将在我们的游戏中使用的乒乓球。接下来，让我们创建一个新的 C# 脚本来对球施加力以移动它：
- en: '[PRE11]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this script, we are using the `AddForce` method and `Impulse` force mode
    that we learned about previously to apply an impulse force to the ball. The direction
    and magnitude of the force are provided by the `_initialImpulse` variable. This
    can be set in the editor.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用之前学到的 `AddForce` 方法以及 `Impulse` 力模式来对球施加脉冲力。力的方向和大小由 `_initialImpulse`
    变量提供。这可以在编辑器中设置。
- en: Let's now attach this script to the ball and provide a value for the `_initialImpulse`
    variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将这个脚本附加到球上，并为 `_initialImpulse` 变量提供一个值。
- en: '![Figure 5.31 – Ping Pong Ball (Script)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.31 – 乒乓球（脚本）'
- en: '](img/Figure_5.31_B17146.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.31_B17146.jpg)'
- en: Figure 5.31 – Ping Pong Ball (Script)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.31 – 乒乓球（脚本）
- en: As the preceding screenshot demonstrates, the value of the `_initialImpulse`
    variable is (`8`, `0`, `8`), which means we add an instant force impulse pointing
    to the lower-right corner of the table to the Rigidbody.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，`_initialImpulse` 变量的值为 (`8`, `0`, `8`)，这意味着我们向 Rigidbody 添加了一个指向桌面右下角的即时力脉冲。
- en: Let's play the game and see what happens.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩游戏并看看会发生什么。
- en: '![Figure 5.32 – The ball is bounced'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.32 – 球被弹起'
- en: '](img/Figure_5.32_B17146.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.32_B17146.jpg)'
- en: Figure 5.32 – The ball is bounced
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.32 – 球被弹起
- en: From the picture, we can see that the ping-pong ball in the game hit the wall
    and bounced. Next, we will add more logic to the player objects so that we can
    control them in the game.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从图片中，我们可以看到游戏中的乒乓球撞击墙壁并弹起。接下来，我们将向玩家对象添加更多逻辑，以便我们可以在游戏中控制它们。
- en: 'However, before we start to write C# code for our player objects, we should
    first add a **Rigidbody** component to each of them, and set the **Rigidbody**
    component settings as shown in the following screenshot:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始为玩家对象编写 C# 代码之前，我们应该首先为它们中的每一个添加一个 **Rigidbody** 组件，并将 **Rigidbody**
    组件设置调整为以下截图所示：
- en: '![Figure 5.33 – Settings of the player''s Rigidbody component'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.33 – 玩家 Rigidbody 组件设置'
- en: '](img/Figure_5.33_B17146.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_5.33_B17146.jpg)'
- en: Figure 5.33 – Settings of the player's Rigidbody component
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.33 – 玩家 Rigidbody 组件设置
- en: As you can see from the screenshot, we first set the mass of the `1000` and
    disabled the effect of gravity by unchecking the **Use Gravity** option.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从截图中所见，我们首先将质量设置为 `1000` 并通过取消选中 **使用重力** 选项来禁用重力效果。
- en: Then, it is worth your attention that we have restricted the movement of the
    Rigidbody. Since the player object will only move along the x axis and will not
    rotate, we only keep the Rigidbody moving along the x axis without constraint.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，请注意，我们已经限制了 Rigidbody 的运动。由于玩家对象将仅沿 x 轴移动而不会旋转，我们只保留 Rigidbody 沿 x 轴的运动而不加约束。
- en: 'Next, we also need to configure the controls for these two different players,
    as shown in the following steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要配置这两个不同玩家的控制，如下步骤所示：
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在编辑器中选择 **Edit > Project Settings** 来打开 **项目设置** 窗口。
- en: '![Figure 5.34 – Opening the Project Settings window'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.34 – 打开项目设置窗口'
- en: '](img/Figure_5.34_B17146.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.34_B17146.jpg)'
- en: Figure 5.34 – Opening the Project Settings window
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.34 – 打开项目设置窗口
- en: Select **Input Manager** from the navigation on the left to open the **Input
    Manager** window.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的导航中选择 **输入管理器** 以打开 **输入管理器** 窗口。
- en: '![Figure 5.35 – Opening the Input Manager window'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.35 – 打开输入管理器窗口'
- en: '](img/Figure_5.35_B17146.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.35_B17146.jpg)'
- en: Figure 5.35 – Opening the Input Manager window
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.35 – 打开输入管理器窗口
- en: 'We will define the input axis and related actions of player 1 and player 2
    in this window to allow us to use the up and down arrow keys and the w and s keys
    to control the movement of these two player objects, respectively, as shown in
    the following screenshot:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在本窗口中定义玩家 1 和玩家 2 的输入轴和相关动作，以便我们可以使用上箭头键和下箭头键以及 w 键和 s 键来分别控制这两个玩家对象的移动，如下面的截图所示：
- en: '![Figure 5.36 – Setting up the input controls for players'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.36 – 设置玩家的输入控制'
- en: '](img/Figure_5.36_B17146.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.36_B17146.jpg)'
- en: Figure 5.36 – Setting up the input controls for players
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.36 – 设置玩家的输入控制
- en: So far, we have set up the Rigidbody components and the input control needed
    by the player objects, and then we can write a C# script to control the player
    objects in our game.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了玩家对象所需的 Rigidbody 组件和输入控制，然后我们可以编写一个 C# 脚本来控制我们游戏中的玩家对象。
- en: 'Remember the `MovePosition` method we introduced before? Here, we will use
    this method to move the player objects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前介绍的 `MovePosition` 方法吗？这里，我们将使用这个方法来移动玩家对象：
- en: '[PRE12]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in the preceding code, this script will first determine which player
    the object is, get the corresponding input settings, and then determine the direction
    of the object's movement based on the player's input.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，此脚本将首先确定对象是哪个玩家，获取相应的输入设置，然后根据玩家的输入确定对象的移动方向。
- en: Now, let's attach this script to these two player objects and start the game!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此脚本附加到这两个玩家对象上并开始游戏！
- en: '![Figure 5.37 – The ping-pong game'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.37 – 乒乓球游戏'
- en: '](img/Figure_5.37_B17146.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.37_B17146.jpg)'
- en: Figure 5.37 – The ping-pong game
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.37 – 乒乓球游戏
- en: As shown in the preceding image, we can now use the *w* and *s* keys and the
    *up* and *down* keys to control the movement of player 1 and player 2 and, as
    expected, the ping-pong ball will bounce when it hits the players.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述图像所示，我们现在可以使用 *w* 和 *s* 键以及 *上* 和 *下* 键来控制玩家 1 和玩家 2 的移动，并且正如预期的那样，当乒乓球击中玩家时，它会弹跳。
- en: In this section, we made a simple physics-based game, and now we will introduce
    how to optimize the performance of the Physics system when developing a game in
    Unity.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们制作了一个简单的基于物理的游戏，现在我们将介绍如何在 Unity 中开发游戏时优化物理系统的性能。
- en: Increasing the performance of the Physics system
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高物理系统的性能
- en: Physical simulation requires a lot of calculations, especially in the case of
    high physical accuracy requirements. Therefore, it is very important to understand
    how to use Unity's Physics system correctly and reduce unnecessary computing overhead.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 物理模拟需要大量的计算，尤其是在高物理精度要求的情况下。因此，正确理解如何使用 Unity 的物理系统并减少不必要的计算开销非常重要。
- en: The Unity Profiler
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity 性能分析器
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    caused by the Physics system in Unity.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该学习如何使用工具来查看和定位由 Unity 中的物理系统引起的性能瓶颈。
- en: The **Profiler** tool in the Unity Editor is our recommended tool, which allows
    us to easily view various performance data and locate performance issues related
    to the Physics system.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 编辑器中的 **Profiler** 工具是我们推荐的工具，它允许我们轻松查看各种性能数据并定位与物理系统相关的性能问题。
- en: 'Taking the ping-pong game we just made as an example, we can perform the following
    steps to view the performance data of this game:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们刚刚制作的乒乓球游戏为例，我们可以执行以下步骤来查看此游戏的性能数据：
- en: Start the game in the editor by clicking the **Play** button.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **Play** 按钮在编辑器中启动游戏。
- en: '![Figure 5.38 – Playing the game in the editor'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.38 – 在编辑器中玩游戏'
- en: '](img/Figure_5.38_B17146.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.38_B17146.jpg)'
- en: Figure 5.38 – Playing the game in the editor
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.38 – 在编辑器中玩游戏
- en: Click **Window > Analysis > Profiler** or use the keyboard shortcut *Ctrl +
    7* (*Command + 7* on macOS) to open the **Profiler** window.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Window > Analysis > Profiler** 或使用键盘快捷键 *Ctrl + 7* (*Command + 7* 在 macOS
    上) 打开 **性能分析器** 窗口。
- en: 'Click the **CPU Usage** module area in the **Profiler** window to view the
    performance data of CPU overheads, such as the CPU time consumed by **FixedUpdate.PhysicsFixedUpdate**,
    as shown here:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Profiler** 窗口中点击 **CPU 使用率** 模块区域以查看 CPU 负载的性能数据，例如 **FixedUpdate.PhysicsFixedUpdate**
    消耗的 CPU 时间，如下所示：
- en: '![Figure 5.39 – The Unity Profiler'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.39 – Unity Profiler'
- en: '](img/Figure_5.39_B17146.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.39_B17146.jpg)'
- en: Figure 5.39 – The Unity Profiler
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.39 – Unity Profiler
- en: 'In addition to the **CPU Usage** module, we can also view the detailed information
    of the Physics system, such as the number of Rigidbodies and the number of contacts
    at a specific moment, as shown in the following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 **CPU 使用率** 模块外，我们还可以查看物理系统的详细信息，例如在特定时刻的刚体数量和接触数量，如下面的截图所示：
- en: '![Figure 5.40 – The Physics data in the profiler'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.40 – 分析器中的物理数据'
- en: '](img/Figure_5.40_B17146.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.40_B17146.jpg)'
- en: Figure 5.40 – The Physics data in the profiler
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.40 – 分析器中的物理数据
- en: Next, we will introduce some tips for improving the performance of the Physics
    system.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一些提高物理系统性能的技巧。
- en: Increasing the fixed timestep
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加固定时间步长
- en: 'One idea to reduce the cost of physics computing is to reduce the number of
    updates per second of the Physics system. We can perform the following steps to
    increase this **Fixed Timestep** setting to achieve this goal:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 减少物理计算成本的一个想法是减少物理系统每秒的更新次数。我们可以执行以下步骤来增加这个 **固定时间步长** 设置以实现这一目标：
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在编辑器中选择 **编辑 > 项目设置** 来打开 **项目设置** 窗口。
- en: Select **Time** from the navigation on the left to open the **Time** window.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的导航中选择 **时间** 以打开 **时间** 窗口。
- en: '![Figure 5.41 – Time settings'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.41 – 时间设置'
- en: '](img/Figure_5.41_B17146.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.41_B17146.jpg)'
- en: Figure 5.41 – Time settings
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.41 – 时间设置
- en: The default value of **Fixed Timestep** is **0.02**, which means the Physics
    system will be updated 50 times per second. To reduce the number of updates per
    second, we can increase this value.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**固定时间步长** 的默认值是 **0.02**，这意味着物理系统每秒将更新 50 次。为了减少每秒的更新次数，我们可以增加这个值。'
- en: Reducing unnecessary layer-based collision detections
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少不必要的基于层的碰撞检测
- en: 'Unity uses a rather inefficient physical collision detection mode by default;
    that is, collision detection is performed on all GameObjects. We can reduce the
    number of collision detections by modifying the **Layer Collision Matrix** field
    in the **Physics** settings of Unity and setting different layers for different
    GameObjects. The following steps demonstrate how to modify it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 默认使用一种相当低效的物理碰撞检测模式；也就是说，碰撞检测是在所有 GameObject 上进行的。我们可以通过修改 Unity 的 **物理设置**
    中的 **层碰撞矩阵** 字段，并为不同的 GameObject 设置不同的层来减少碰撞检测的数量。以下步骤演示了如何修改它：
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在编辑器中选择 **编辑 > 项目设置** 来打开 **项目设置** 窗口。
- en: Select **Physics** from the navigation on the left to open the **Physics** window.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧的导航中选择 **物理** 以打开 **物理** 窗口。
- en: You can find **Layer Collision Matrix** at the bottom of the **Physics** window,
    and you can see in *Figure 5.42* that everything collides with everything by default.
    We should only enable the layers that require collision detection in this matrix.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在 **物理** 窗口的底部找到 **层碰撞矩阵**，您可以在 *图 5.42* 中看到默认情况下一切都是相互碰撞的。我们应该只启用需要碰撞检测的层。
- en: '![Figure 5.42 – Layer Collision Matrix'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.42 – 层碰撞矩阵'
- en: '](img/Figure_5.42_B17146.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.42_B17146.jpg)'
- en: Figure 5.42 – Layer Collision Matrix
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.42 – 层碰撞矩阵
- en: In this section, we introduced how to use Unity's Profiler tool to view the
    performance data of the Physics system and explored how to optimize the performance
    of the latter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何使用 Unity 的 Profiler 工具查看物理系统的性能数据，并探讨了如何优化物理系统的性能。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by introducing the physics solutions provided by
    Unity, including two built-in physics solutions, **Nvidia PhysX engine** and **Box2D
    engine**, and Unity also provides Physics engine packages, namely, the **Unity
    Physics package** and the **Havok Physics for Unity package**. Then, we explored
    some of the most important concepts in Unity's Physics system, such as the **Collider**
    component, the **Rigidbody** component, and **Triggers**. We also discussed how
    to create a new script in Unity to interact with Unity's Physics system.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先介绍了Unity提供的物理解决方案，包括两个内置的物理解决方案，**Nvidia PhysX引擎**和**Box2D引擎**，Unity还提供了物理引擎包，即**Unity
    Physics包**和**Havok Physics for Unity包**。然后，我们探讨了Unity物理系统中的一些最重要的概念，例如**Collider组件**、**Rigidbody组件**和**Triggers**。我们还讨论了如何在Unity中创建一个新的脚本以与Unity的物理系统交互。
- en: Then, we demonstrated how to implement a physics-based ping-pong game in Unity.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示了如何在Unity中实现基于物理的乒乓球游戏。
- en: Finally, we explored some best practices for applying a physics simulation in
    Unity to optimize the performance problems caused by the Physics system.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了在Unity中应用物理模拟的一些最佳实践，以优化由物理系统引起的性能问题。
- en: In the next chapter, we will be discussing how to implement video and audio
    features in Unity.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何在Unity中实现视频和音频功能。
