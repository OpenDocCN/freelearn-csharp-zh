<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer085">
<h1 class="chapter-number" id="_idParaDest-186"><a id="_idTextAnchor196"/>12</h1>
<h1 id="_idParaDest-187"><a id="_idTextAnchor197"/>Localization with MVVM</h1>
<p>So, we’ve built this fantastic <em class="italic">Recipes!</em> app, and we’re quite pleased with its design and features. However, as it stands, the app is entirely in English. What about culinary enthusiasts from different parts of the world? The answer is localization, specifically focusing on translating all aspects of our app to make it accessible and user-friendly to a <span class="No-Break">global audience.</span></p>
<p>In this chapter, we’ll tackle localization through the lens of MVVM. We’ll be looking at translating the hardcoded <strong class="source-inline">copy</strong> labels that are baked into the app, but also at effectively fetching language-specific data from the API. To accomplish this, we’ll delve into the <span class="No-Break">following topics:</span></p>
<ul>
<li>Working with cultures, resource files, <span class="No-Break">and localization</span></li>
<li>Looking at a localization solution <span class="No-Break">for MVVM</span></li>
<li>Using a custom <strong class="source-inline">Translate</strong> <span class="No-Break">markup extension</span></li>
<li>Fetching localized data <span class="No-Break">from APIs</span></li>
</ul>
<p>As we dive into this chapter, remember that our journey through localization also showcases thoughtful app design with MVVM principles. By the end, not only will we have the tools and knowledge to extend the reach of our app to a diverse, global audience through the UI, but we’ll also see how the right design choices ensure that every layer of our app, down to the data we present, is coherent <span class="No-Break">and organized.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor198"/>Technical requirements</h1>
<p>As always, for hands-on experience and to keep pace with the content, head over to our GitHub repository at <a href="https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12">https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter12</a>. Begin with the code in the <strong class="source-inline">Start</strong> folder, and, for a comprehensive view, you can always refer to the <strong class="source-inline">Finish</strong> folder, which houses the polished, <span class="No-Break">end-of-chapter code.</span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor199"/>Working with cultures, resource files, and localization</h1>
<p>Before we jump into the actual coding bits and look at how we can integrate localization in MVVM, let’s make <a id="_idIndexMarker806"/>sure we’re all on the same page about what we mean by <em class="italic">culture</em> in the .NET MAUI context. Culture, in this case, refers to the settings that determine the language to be used and the display format for items such as dates, times, currency, and <span class="No-Break">so on.</span></p>
<p>Let’s start with how to retrieve the user’s culture in .<span class="No-Break">NET MAUI.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Getting the user’s culture</h2>
<p>The <strong class="source-inline">CultureInfo</strong> class is part of the <strong class="source-inline">System.Globalization</strong> namespace in .NET and <a id="_idIndexMarker807"/>serves as a central point for obtaining culture-specific information, such as language, country, date formats, number formats, and more. It also contains <strong class="source-inline">CurrentCulture</strong> and <strong class="source-inline">CurrentUICulture</strong> properties that can be used to get or set the user’s current culture and “<span class="No-Break">UI culture.”</span></p>
<p class="callout-heading">CurrentCulture versus CurrentUICulture</p>
<p class="callout"><strong class="source-inline">CurrentCulture</strong> defines <a id="_idIndexMarker808"/>how data types such as dates, numbers, and <a id="_idIndexMarker809"/>currencies should be formatted <a id="_idIndexMarker810"/>in the application. This ensures that the look and feel of the data aligns with the user’s cultural context. On the other hand, <strong class="source-inline">CurrentUICulture</strong> dictates the <a id="_idIndexMarker811"/>language used for the UI elements and text resources. <strong class="source-inline">CurrentCulture</strong> determines <em class="italic">how things look</em> (formatting), while <strong class="source-inline">CurrentUICulture</strong> controls <em class="italic">which language is being </em><span class="No-Break"><em class="italic">used</em></span><span class="No-Break"> (localization).</span></p>
<p>The user’s current culture settings can be easily obtained with the following lines <span class="No-Break">of code:</span></p>
<pre class="source-code">
var currentCulture = CultureInfo.CurrentCulture;
var currentUICulture = CultureInfo.CurrentUICulture;</pre> <p>This will get the device’s culture settings, which the user has set up in their system settings. Let’s see how we can set a <span class="No-Break">different culture.</span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor201"/>Setting a different culture</h2>
<p>Setting a <a id="_idIndexMarker812"/>particular culture is as easy as assigning it to the relevant properties on the <span class="No-Break"><strong class="source-inline">CultureInfo</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
var cultureInfo = new CultureInfo("fr-FR");
CultureInfo.CurrentCulture = cultureInfo;
CultureInfo.CurrentUICulture = cultureInfo;
CultureInfo.DefaultThreadCurrentCulture = cultureInfo;
CultureInfo.DefaultThreadCurrentUICulture = cultureInfo;</pre> <p>The <strong class="source-inline">DefaultThreadCurrentCulture</strong> and <strong class="source-inline">DefaultThreadCurrentUICulture</strong> properties are used to set the default culture settings for all threads in a .NET application, including background threads that you may spin up for <span class="No-Break">various tasks.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">For the sake of simplicity and to keep our focus on the overall process of localization, throughout this chapter we won’t be making a distinction between <strong class="source-inline">CurrentCulture</strong> and <strong class="source-inline">CurrentUICulture</strong> unless explicitly mentioned. When we talk about updating the culture settings, we’ll be updating both <strong class="source-inline">CurrentCulture</strong> and <strong class="source-inline">CurrentUICulture</strong>, as well as their <span class="No-Break"><strong class="source-inline">DefaultThread</strong></span><span class="No-Break"> counterparts.</span></p>
<p>If we want, we can allow users to select a culture from a list of supported cultures and save it for future sessions. Here’s a simplified example using <strong class="source-inline">Microsoft.Maui.Storage.Preferences</strong> to store the <span class="No-Break">chosen culture:</span></p>
<pre class="source-code">
Preferences.Set("SelectedCulture", "fr-FR");</pre> <p>Retrieving and assigning the previously stored selected culture can be done <span class="No-Break">like this:</span></p>
<pre class="source-code">
var storedCulture = Preferences.Get("SelectedCulture", 
"en-US");</pre> <p>The <strong class="source-inline">Preferences</strong>’s <strong class="source-inline">Get</strong> method accepts a second parameter that serves as a default value to return when no existing value for the given key exists. The string value that we retrieved can now be used to instantiate a new <strong class="source-inline">CultureInfo</strong> object, which we can then use to set the application’s culture. Take <span class="No-Break">a look:</span></p>
<pre class="source-code">
var cultureInfo = new CultureInfo(storedCulture);
CultureInfo.CurrentCulture = cultureInfo;</pre> <p>As mentioned <a id="_idIndexMarker813"/>earlier, the <strong class="source-inline">CurrentCulture</strong> property defines how particular data types are being displayed. So, let’s have a quick look at what we mean <span class="No-Break">by that.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/>Displaying formatted data</h2>
<p>Culture settings have a direct impact on how data types such as dates and numbers are formatted <a id="_idIndexMarker814"/>when they are displayed in the UI. When you set <strong class="source-inline">CultureInfo.CurrentCulture</strong>, it will also influence the formatting in data-binding scenarios. This means that <strong class="source-inline">DateTime</strong> values, for instance, will be displayed according to the format rules of the <span class="No-Break">set culture.</span></p>
<p>Let’s say we have a <strong class="source-inline">DateTime</strong> property in <span class="No-Break">our ViewModel:</span></p>
<pre class="source-code">
public DateTime LastUpdated { get; set; } = new
DateTime(2020, 7, 3);</pre> <p>And we are binding this property to a <strong class="source-inline">Label</strong> <span class="No-Break">in XAML:</span></p>
<pre class="source-code">
&lt;Label Text="{Binding LastUpdated}" /&gt;</pre> <p>Because we are not specifying how the data should be formatted, the <strong class="source-inline">ToString</strong> method will be called on the <strong class="source-inline">DateTime</strong> object, and that result will be shown on the screen. The <strong class="source-inline">ToString</strong> method will take the current culture settings into account. As a result, if the culture is set to US English (<strong class="source-inline">en-US</strong>), the date will be formatted as <strong class="source-inline">7/3/2020 12:00:00 AM</strong>, whereas if the culture is set to French (<strong class="source-inline">fr-FR</strong>), the date will appear as <span class="No-Break"><strong class="source-inline">03/07/2020 00:00:00</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">StringFormat</strong> property in XAML binding expressions allows us to define custom formatting for data types such as <strong class="source-inline">DateTime</strong>. What’s great is that <strong class="source-inline">StringFormat</strong> will also respect the current culture settings, so it’s a fantastic way to combine customization with localization. For instance, we could use <strong class="source-inline">StringFormat</strong> in XAML to specify how you’d like that date <span class="No-Break">to appear:</span></p>
<pre class="source-code">
&lt;Label Text="{Binding LastUpdated, StringFormat='{0:MMMM d,
  yyyy}'}" /&gt;</pre> <p>In this example, <strong class="source-inline">StringFormat</strong> is set to display the full month name, the day, and the full year. In US English, it will be displayed as <strong class="source-inline">July 3, 2020</strong>, whereas when the app’s culture is set to French, the date will automatically adjust to <strong class="source-inline">juillet 3, 2020</strong>. The format specified in <strong class="source-inline">StringFormat</strong> remains consistent, but the actual string values for the day and month adapt to the <span class="No-Break">set culture.</span></p>
<p>The same <a id="_idIndexMarker815"/>principles apply to number formatting. Different cultures have various ways of representing numbers, particularly when it comes to separating thousands and decimal points. By being mindful of the culture settings, we ensure that our application displays numbers in a format that is both familiar and understandable to <span class="No-Break">the user.</span></p>
<p>In contrast to the <strong class="source-inline">CurrentCulture</strong> property, the <strong class="source-inline">CurrentUICulture</strong> property determines the language that is being used in the app. So, let’s have a look at how this can be managed through <span class="No-Break">resource files.</span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/>What are Resources Files?</h2>
<p>Resources Files are a core feature of the .NET ecosystem, used to facilitate localization across a wide <a id="_idIndexMarker816"/>array of application types. Typically named with a <strong class="source-inline">.resx</strong> extension, these XML-based files allow you to define key-value pairs where the key represents a specific piece of text or asset in your application, and the value represents its localized equivalent. Visual Studio even provides an editor for <strong class="source-inline">.resx</strong> files, allowing developers to easily define keys and their value (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 12.1: Visual Studio .resx designer" height="332" src="image/B20941_12_01.jpg" width="1292"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Visual Studio .resx designer</p>
<p>What’s particularly handy is that a strongly typed class is automatically generated when you create a <strong class="source-inline">.resx</strong> file. This class allows us to access localized resources programmatically in a type-safe manner, eliminating the need to manually look up resource keys in your code. The name of this autogenerated class is derived from the name of the <strong class="source-inline">resx</strong> file itself. For example, if the resource file is named <strong class="source-inline">AppResources.resx</strong>, the generated class will be <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">AppResources</strong></span><span class="No-Break">.</span></p>
<p>By suffixing the name of the file, we can specify which culture a specific resource file belongs to – for example, <strong class="source-inline">AppResources.resx</strong> for the default culture of the app (let’s say English), <strong class="source-inline">AppResources.fr-FR.resx</strong> for French, <strong class="source-inline">AppResources.es-ES.resx</strong> for Spanish, and <span class="No-Break">so on.</span></p>
<p>.NET MAUI will look in the <strong class="source-inline">.resx</strong> file that corresponds with the set culture for the requested value. Fetching a localized string can be done as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
var s1 = AppResources.
    ResourceManager.GetString("AddAsFavorite");</pre> <p>If the current <a id="_idIndexMarker817"/>UI culture is set to French (<strong class="source-inline">fr-FR</strong>), .NET MAUI will automatically look for <strong class="source-inline">AddAsFavorite</strong> in the <strong class="source-inline">AppResources.fr-FR.resx</strong> file. If there is no resource file matching the current UI culture, the default file (the one without a suffix) will <span class="No-Break">be used.</span></p>
<p>Alternatively, retrieving a value for the <strong class="source-inline">AddAsFavorite</strong> key can also be done <span class="No-Break">as follows:</span></p>
<pre class="source-code">
var s2 = AppResources.AddAsFavorite;</pre> <p>A static property will be generated in the <strong class="source-inline">AppResources</strong> class for every key in the <strong class="source-inline">.resx</strong> file. These properties utilize <strong class="source-inline">ResourceManager</strong>’s <strong class="source-inline">GetString</strong> method to retrieve the <span class="No-Break">corresponding value.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to note that the generated class will only be based on the default resource file. This means that only properties will be generated for the keys in the default file. So, it is very important to have the same keys in each of the different culture-specific files! Resolving a value for a key that is not present in the resource file of the current UI culture will result in <span class="No-Break">an exception!</span></p>
<p>Let’s add some resource files to <span class="No-Break">our solution:</span></p>
<ol>
<li>Right-click the <strong class="source-inline">Resources</strong> folder in the <strong class="source-inline">Recipes.Mobile</strong> project and select <strong class="bold">Add</strong> | <strong class="bold">New Folder</strong>. Name this <span class="No-Break">folder </span><span class="No-Break"><strong class="source-inline">Strings</strong></span><span class="No-Break">.</span></li>
<li>Right-click this folder and select <strong class="bold">Add</strong> | <span class="No-Break"><strong class="bold">New Item…</strong></span><span class="No-Break">.</span></li>
<li>In the <strong class="bold">Add New Item</strong> popup, search for <strong class="source-inline">resources</strong>, select the <strong class="bold">Resources File</strong> template, and enter <strong class="source-inline">AppResources.resx</strong> as the name (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 12.2: Creating a new Resources File" height="709" src="image/B20941_12_02.jpg" width="1298"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: Creating a new Resources File</p>
<ol>
<li value="4">Double-check <a id="_idIndexMarker818"/>the newly created file’s properties in the <strong class="bold">Properties</strong> window. The <strong class="bold">Build Action</strong> property should be set to <strong class="bold">Embedded resource</strong>, and the <strong class="bold">Custom Tool</strong> property should be set to <strong class="bold">ResXFileCodeGenerator</strong>, as <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">12</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break"> shows:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 12.3: Properties of the AppResources.resx file" height="316" src="image/B20941_12_03.jpg" width="738"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Properties of the AppResources.resx file</p>
<ol>
<li value="5">Add a second <strong class="bold">Resources File</strong> and name it <strong class="source-inline">AppResources.fr-FR.resx</strong>. Note that only the default resource file has its <strong class="bold">Custom Tool</strong> property set to <strong class="bold">ResXFileCodeGenerator</strong>. Other resource files will not have this property set, but their <strong class="bold">Build Action</strong> property does have to be set to <strong class="bold">Embedded resource</strong> <span class="No-Break">as well.</span></li>
<li>In the <span class="No-Break"><strong class="source-inline">Chapter 12</strong></span><strong class="source-inline">/Resources</strong> folder, you will find an <strong class="source-inline">AppResources.resx</strong> file and an <strong class="source-inline">AppResources.fr-FR.resx</strong> file containing the <a id="_idIndexMarker819"/>English and French resources respectively. Copy them over to the <strong class="source-inline">Strings</strong> folder in Visual Studio and override the files you <span class="No-Break">just created.</span></li>
</ol>
<p>With this in place, let’s have a look at how we can get those values on <span class="No-Break">the screen.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor204"/>Getting localized resources on the screen</h2>
<p>In its simplest form, we can use the <strong class="source-inline">x:Static</strong> markup extension. This markup extension is <a id="_idIndexMarker820"/>used to reference static fields or properties from a specified class. As mentioned earlier, the generated <strong class="source-inline">AppResources</strong> class has a static property for each of the keys in the <strong class="bold">Resources File</strong>. This allows us to leverage the <strong class="source-inline">x:Static</strong> markup extension to reference the localized values. Let’s see how we can <span class="No-Break">add this:</span></p>
<ol>
<li>Add the following code to the <strong class="source-inline">CreateMauiApp</strong> method of the <span class="No-Break"><strong class="source-inline">MauiProgram</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public static MauiApp CreateMauiApp()
{
    var builder = MauiApp.CreateBuilder();
    ...
    <strong class="bold">var french = new CultureInfo("fr-FR");</strong>
<strong class="bold">    CultureInfo.CurrentCulture = french;</strong>
<strong class="bold">    CultureInfo.CurrentUICulture = french;</strong>
...
}</pre><p class="list-inset">This will force the app’s culture <span class="No-Break">to French.</span></p></li> <li>Go to <strong class="source-inline">AppShell.xaml</strong> and add an XML namespace pointing to the namespace of the <span class="No-Break"><strong class="source-inline">AppResources</strong></span><span class="No-Break"> class:</span><pre class="source-code">
</pre></li> <li>Next, update the <strong class="source-inline">Title</strong> property of the first <strong class="source-inline">Tab</strong> element to <span class="No-Break">the following:</span><pre class="source-code">
Title="{x:Static strings:AppResources.Tab1Title}"</pre><p class="list-inset">By leveraging the <strong class="source-inline">x:Static</strong> markup extension, we are pointing to the static <strong class="source-inline">Tab1Title</strong> property of the <span class="No-Break"><strong class="source-inline">AppResources</strong></span><span class="No-Break"> class.</span></p></li> <li>The <strong class="source-inline">Title</strong> property of the second <strong class="source-inline">Tab</strong> element should point to the <strong class="source-inline">Tab2Title</strong> property as <span class="No-Break">shown here:</span><pre class="source-code">
Title="{x:Static strings:AppResources.Tab2Title}"</pre></li> <li>And finally, for this <a id="_idIndexMarker821"/>first example, head over to <strong class="source-inline">RecipeDetailPage</strong> and find the <strong class="source-inline">MultiBinding</strong> on the label that shows the <strong class="source-inline">LastUpdated</strong> and <strong class="source-inline">Author</strong> properties. The <strong class="source-inline">x:Static</strong> markup extension can also be used on the <strong class="source-inline">StringFormat</strong> property on a binding statement, as <span class="No-Break">shown here:</span><pre class="source-code">
&lt;MultiBinding <strong class="bold">StringFormat="{x:Static</strong>
<strong class="bold">    strings:AppResources.ModifiedDateAuthorFormat}"</strong>&gt;
    &lt;Binding Path="LastUpdated" /&gt;
    &lt;Binding Path="Author" /&gt;
&lt;/MultiBinding&gt;</pre><p class="list-inset">It’s worth mentioning that <strong class="source-inline">ModifiedDateAuthorFormat</strong> contains a <strong class="source-inline">D</strong> format specifier that represents a long date pattern. As a result, the notation of the date will be different depending on the selected culture. For example, when <strong class="source-inline">CurrentCulture</strong> is set to French (<strong class="source-inline">fr-FR</strong>), July 3, 2020, will be shown as <strong class="source-inline">vendredi 3 </strong><span class="No-Break"><strong class="source-inline">juillet 2020</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>If we now run the app, we should immediately see that the titles of the two main tabs are now in French, as <span class="No-Break"><em class="italic">Figure </em></span><span class="No-Break"><em class="italic">12</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break"> shows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 12.4: Localized tab titles" height="75" src="image/B20941_12_04.jpg" width="530"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: Localized tab titles</p>
<p>When navigating to <strong class="source-inline">RecipeDetailPage</strong>, the label showing the <strong class="source-inline">LastUpdated</strong> and <strong class="source-inline">Author</strong> properties is now also translated. Now, go ahead and change the culture in the <strong class="source-inline">CreateMauiApp</strong> method to <strong class="source-inline">nl-BE</strong>. Run the app, and you should see the localized labels in English. That’s because there is no resource file for this culture, so the default one is used. Do note <a id="_idIndexMarker822"/>that the date is being formatted according to the Dutch (Belgium) notation: <strong class="source-inline">vrijdag 3 </strong><span class="No-Break"><strong class="source-inline">juli 2020</strong></span><span class="No-Break">.</span></p>
<p>As said, this approach is the simplest form of getting the localized resources on the screen. This is a perfectly valid approach, but it’s not very MVVM-friendly, and it has <span class="No-Break">its limitations:</span></p>
<ul>
<li>The biggest limitation is that <strong class="source-inline">x:Static</strong> doesn’t react to changes. If you change the value of the static property at runtime, the UI will not update to reflect the new value. This makes it unsuitable for scenarios where the localized text might change dynamically, such as when a user switches languages in-app. Only when navigating to a new page will the <strong class="source-inline">x:Static</strong> markup extension load the required values for the newly selected culture. When navigating (back) to pages that are in memory, the values of the previous culture will still <span class="No-Break">be there.</span></li>
<li>There is no way to access these resources from within our ViewModels. This can be an issue if we want to show dialogs or alerts from <span class="No-Break">a ViewModel.</span></li>
</ul>
<p>So far, we’ve laid down the essential groundwork for understanding localization in .NET MAUI, including the role of resource files, the <strong class="source-inline">CultureInfo</strong> class, and the <strong class="source-inline">x:Static</strong> markup extension. While the methods and concepts we’ve discussed so far form the essential backbone of localization in .NET MAUI, our next section will explore how to seamlessly integrate them into MVVM. Ultimately, our goal is to make use of data binding to <a id="_idIndexMarker823"/>connect our UI to localized values. This enables dynamic updates: if the user switches languages or cultures during runtime, the displayed text will automatically reflect <span class="No-Break">these changes.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The properties on a binding statement such as <strong class="source-inline">StringFormat</strong>, <strong class="source-inline">FallbackValue</strong>, and <strong class="source-inline">TargetNullValue</strong> aren’t bindable properties. This means that the only way to assign values from a resource file to these properties is by leveraging the <strong class="source-inline">x:Static</strong> markup extension, with <span class="No-Break">its limitations.</span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor205"/>Looking at a localization solution for MVVM</h1>
<p>In this section, we’ll look at a solution that’s not just functional but also fits well with the MVVM architectural pattern. Whether you need to localize text within your ViewModels or dynamically <a id="_idIndexMarker824"/>update language in your UI, this approach has you covered. It’s a solution that I’ve personally implemented in numerous projects over the years. While I’ve made some refinements along the way, the core concept has stood the test of time and proven its effectiveness in <span class="No-Break">real-world applications.</span></p>
<p class="callout-heading">Warning – culture settings are thread-specific</p>
<p class="callout">When allowing the user to switch cultures inside the app, we should be wary of the fact that when updating <strong class="source-inline">CultureInfo</strong> inside <strong class="source-inline">async</strong> operations, those changes will not automatically propagate to the parent thread. A localization strategy needs to be designed with this in mind to <span class="No-Break">avoid inconsistencies.</span></p>
<p>In the code accompanying this chapter, two new projects have been added: <strong class="source-inline">Localization</strong> and <strong class="source-inline">Localization.Maui</strong>. The primary objective of the <strong class="source-inline">Localization</strong> project is to provide a framework-agnostic approach to manage and access localization settings and resources. By encapsulating this localization logic within its own project, we facilitate easy code sharing across different projects, paving the way<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/> for potential packaging and reuse in <span class="No-Break">other projects.</span></p>
<p>On the other hand, the <strong class="source-inline">Localization.Maui</strong> project is tailored specifically for .NET MAUI. It houses <a id="_idIndexMarker825"/>the code responsible for storing and retrieving localization information. Putting this logic separately from the rest of our <em class="italic">Recipes!</em> app code allows us to ensure that it remains modular and reusable for other .NET MAUI applications. Let’s discuss the <strong class="source-inline">Localization</strong> <span class="No-Break">project first.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor208"/>The Localization project</h2>
<p>Let’s take <a id="_idIndexMarker826"/>a look at the <strong class="source-inline">ILocalizationManager</strong> interface in the <span class="No-Break"><strong class="source-inline">Localization</strong></span><span class="No-Break"> project:</span></p>
<pre class="source-code">
public interface ILocalizationManager
{
    void RestorePreviousCulture(
        CultureInfo defaultCulture = null);
    void UpdateUserCulture(CultureInfo cultureInfo);
    CultureInfo GetUserCulture(
        CultureInfo defaultCulture = null);
}</pre> <p>The <strong class="source-inline">ILocalizationManager</strong> interface defines three methods for managing <span class="No-Break">localization settings:</span></p>
<ul>
<li><strong class="source-inline">RestorePreviousCulture</strong> is a method that can be used to restore the previous <a id="_idIndexMarker827"/>culture used by the user. The <strong class="source-inline">defaultCulture</strong> parameter can be used to specify a fallback culture in case there is no previous <span class="No-Break">culture set.</span></li>
<li><strong class="source-inline">UpdateUserCulture</strong> updates <a id="_idIndexMarker828"/>and stores the culture settings for the current user. The <strong class="source-inline">cultureInfo</strong> parameter specifies the new culture <span class="No-Break">to use.</span></li>
<li>The <strong class="source-inline">GetUserCulture</strong> method <a id="_idIndexMarker829"/>retrieves the stored culture settings. The <strong class="source-inline">defaultCulture</strong> parameter can be used to specify a fallback culture in case there is no <span class="No-Break">culture set.</span></li>
</ul>
<p>The primary intent behind this interface is to abstract tasks related to the persistence and retrieval <a id="_idIndexMarker830"/>of user-specified cultures. In the context of a .NET MAUI-specific implementation, we might, for instance, opt to save the most recently chosen <strong class="source-inline">CultureInfo</strong> within <strong class="source-inline">Preferences</strong>, ensuring it’s available the next time the app launches so that it can be restored. We’ll delve deeper into this specific <span class="No-Break">approach shortly.</span></p>
<p>The second interface in the <strong class="source-inline">Localization</strong> project is the <strong class="source-inline">ILocalizedResourcesProvider</strong> interface. Let’s see what this <span class="No-Break">looks like:</span></p>
<pre class="source-code">
public interface ILocalizedResourcesProvider
{
    string this[string key]
    {
        get;
    }
    void UpdateCulture(CultureInfo cultureInfo);
}</pre> <p>At its core, this interface facilitates the retrieval of localized string values that align with the user’s chosen <strong class="source-inline">CultureInfo</strong>. It provides a read-only indexer to fetch the localized string corresponding to a specified key. Additionally, the <strong class="source-inline">UpdateCulture</strong> method lets you modify the current <strong class="source-inline">CultureInfo</strong>, ensuring that subsequent localized string retrievals reflect the updated <span class="No-Break">cultural context.</span></p>
<p>Next, we’ll explore the <strong class="source-inline">Localization</strong> project’s concrete implementation of the <strong class="source-inline">ILocalizedResourceProvider</strong> interface – namely,  <strong class="source-inline">LocalizedResourcesProvider</strong>. Let’s start by looking at <span class="No-Break">its constructor:</span></p>
<pre class="source-code">
ResourceManager resourceManager;
CultureInfo currentCulture;
public static LocalizedResourcesProvider Instance
{
    get;
    private set;
}
public LocalizedResourcesProvider(
    ResourceManager resourceManager)
{
    this.resourceManager = resourceManager;
    currentCulture = CultureInfo.CurrentUICulture;
    Instance = this;
}</pre> <p>The constructor <a id="_idIndexMarker831"/>takes a single parameter, <strong class="source-inline">resourceManager</strong>. This is the <strong class="source-inline">ResourceManager</strong> that needs to be used to retrieve the localized values. The <strong class="source-inline">currentCulture</strong> field is initialized with a default value, being the current UI culture. Within the constructor, the current instance is assigned to the static <strong class="source-inline">Instance</strong> property. This allows us to access this <strong class="source-inline">LocalizedResourcesProvider</strong> implementation through a static property, which will be handy in data-binding scenarios, as we’ll see <span class="No-Break">later on.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Assigning the current instance of <strong class="source-inline">LocalizedResourcesProvider</strong> to the static <strong class="source-inline">Instance</strong> property means there can only be one <strong class="source-inline">LocalizedResourcesProvider</strong> implementation throughout the app. While this is a limitation to be wary of, it should not pose a <span class="No-Break">significant problem.</span></p>
<p>The indexer of this class allows us to get the localized string value for a given key. Here’s how this <span class="No-Break">is implemented:</span></p>
<pre class="source-code">
public string this[string key]
    =&gt; resourceManager.GetString(key, currentCulture)
    ?? key;</pre> <p>When the <a id="_idIndexMarker832"/>key exists within our resources, the method fetches the corresponding localized string using the <strong class="source-inline">currentCulture</strong>. However, if the provided key doesn’t match any resource key, the key itself is returned as a fallback. It’s crucial to observe that we’re passing the <strong class="source-inline">currentCulture</strong> explicitly when calling <strong class="source-inline">GetString</strong>. This ensures that the <strong class="source-inline">resourceManager</strong> fetches values specific to the provided <strong class="source-inline">currentCulture</strong>, rather than defaulting to the <strong class="source-inline">CultureInfo</strong> of the currently executing thread. This design choice addresses potential challenges arising from culture settings <span class="No-Break">being thread-specific.</span></p>
<p>Now, let’s look at the <strong class="source-inline">UpdateCulture</strong> method within <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">LocalizedResourcesProvider</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
public void UpdateCulture(CultureInfo cultureInfo)
{
    currentCulture = cultureInfo;
    OnPropertyChanged("Item");
}</pre> <p>This method updates the <strong class="source-inline">currentCulture</strong> field. As a result, any subsequent calls to the class’s indexer will retrieve the localized string value for the given key, based on the updated <strong class="source-inline">currentCulture</strong>. Additionally, the method calls the <strong class="source-inline">OnPropertyChanged</strong> method, sending <strong class="source-inline">Item</strong> as its argument. In scenarios involving data binding, this prompts a re-evaluation of all bindings linked to the indexer. Consequently, any values that are data-bound to this indexer will refresh, returning the localized strings of the updated <strong class="source-inline">CultureInfo</strong>. Let’s transition our focus to the <span class="No-Break"><strong class="source-inline">Localization.Maui</strong></span><span class="No-Break"> project.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor209"/>The Localization.Maui project</h2>
<p>The <strong class="source-inline">LocalizationManager</strong> class in the <strong class="source-inline">Localization.Maui</strong> project is an implementation <a id="_idIndexMarker833"/>of the <strong class="source-inline">ILocaliazationManager</strong>. It has <a id="_idIndexMarker834"/>a dependency on <strong class="source-inline">ILocalizedResourcesProvider</strong>, as yo<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>u can <span class="No-Break">see here:</span></p>
<pre class="source-code">
readonly ILocalizedResourcesProvider _resourceProvider;
public LocalizationManager(
    ILocalizedResourcesProvider resoureProvider)
{
    _resourceProvider = resoureProvider;
}</pre> <p>By having this reference, we can, later on, call its <strong class="source-inline">UpdateCulture</strong> method, keeping the updated culture in sync with <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">ILocalizedResourcesProvider</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">LocalizationManager</strong> class should also store the selected <strong class="source-inline">CultureInfo</strong> so that it can be retrieved on subsequent app launches and restore the previous <strong class="source-inline">CultureInfo</strong>. The following code block shows how the <strong class="source-inline">UpdateUserCulture</strong> uses the <strong class="source-inline">Preferences</strong> API to store the given <strong class="source-inline">CultureInfo</strong>, assigns the updated value to the <strong class="source-inline">currentCulture</strong> field, updates the static properties on the <strong class="source-inline">CultureInfo</strong> object, and calls the <strong class="source-inline">ILocalizedResourcesProvider</strong>’s <span class="No-Break"><strong class="source-inline">UpdateCulture</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
public void UpdateUserCulture(CultureInfo cultureInfo)
{
    Preferences.Default.Set("UserCulture",
        cultureInfo.Name);
    SetCulture(cultureInfo);
}
private void SetCulture(CultureInfo cultureInfo)
{
    currentCulture = cultureInfo;
    Application.Current.Dispatcher.Dispatch(() =&gt;
    {
        CultureInfo.CurrentCulture = cultureInfo;
        CultureInfo.CurrentUICulture = cultureInfo;
        CultureInfo.DefaultThreadCurrentCulture =
            cultureInfo;
        CultureInfo.DefaultThreadCurrentUICulture =
            cultureInfo;
    });
    _resourceProvider.UpdateCulture(cultureInfo);
}</pre> <p>Notice how <a id="_idIndexMarker835"/>the updates on the <strong class="source-inline">CultureInfo</strong> object are dispatched to the main thread. Remember the note about <strong class="source-inline">CultureInfo</strong> being bound to <a id="_idIndexMarker836"/>the current thread? We want to ensure that the main thread’s <strong class="source-inline">CultureInfo</strong> is updated to maintain consistency. Failing to apply these changes to the main thread could result in data binding using the outdated or previous <strong class="source-inline">CultureInfo</strong>. This misalignment can lead to inaccuracies when formatting data, such as displaying <span class="No-Break"><strong class="source-inline">DateTime</strong></span><span class="No-Break"> objects.</span></p>
<p>The <strong class="source-inline">GetUserCulture</strong> method first checks if its <strong class="source-inline">currentCulture</strong> field is set. If it is, that value is returned directly. If not, the method tries to retrieve the culture based on the <strong class="source-inline">UserCulture</strong> key from <strong class="source-inline">Preferences</strong>. If no value is found there, it either resorts to the provided <strong class="source-inline">defaultCulture</strong> parameter or, in its absence, the current system culture. Once determined, this culture is assigned to the <strong class="source-inline">currentCulture</strong> field, which is then returned. Take <span class="No-Break">a look:</span></p>
<pre class="source-code">
public CultureInfo GetUserCulture(
    CultureInfo defaultCulture = null)
{
    if (currentCulture is null)
    {
        var culture = Preferences.Default.Get(
            "UserCulture", string.Empty);
        if (string.IsNullOrEmpty(culture))
        {
            currentCulture = defaultCulture
                ?? CultureInfo.CurrentCulture;
        }
        else
        {
            currentCulture = new CultureInfo(culture);
        }
    }
    return currentCulture;
}</pre> <p>Finally, the <strong class="source-inline">RestorePreviousCulture</strong> method uses the <strong class="source-inline">GetUserCutlure</strong> method to retrieve the <a id="_idIndexMarker837"/>previously used <a id="_idIndexMarker838"/>culture and passes this on to the <strong class="source-inline">SetCulture</strong> method, as you can <span class="No-Break">see here:</span></p>
<pre class="source-code">
public void RestorePreviousCulture(
    CultureInfo defaultCulture = null)
    =&gt; SetCulture(GetUserCulture(defaultCulture));</pre> <p>This method can be used when the app starts to set the current culture to the culture that t<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/>he user <span class="No-Break">selected previously.</span></p>
<p>Now that <a id="_idIndexMarker839"/>we’re familiar with the roles and workings of these classes, let’s integrate them into the <em class="italic">Recipes!</em> app. This will enable us to handle localization <a id="_idIndexMarker840"/>in a manner that complements the MVVM architectural pattern. Here’s a <span class="No-Break">step-by-step guide:</span></p>
<ol>
<li>Go to <strong class="source-inline">MauiProgram.cs</strong> and add the following line of code to the <span class="No-Break"><strong class="source-inline">CreateMauiApp</strong></span><span class="No-Break"> method:</span><pre class="source-code">
builder.Services.AddSingleton&lt;ILocalizationManager,
  LocalizationManager&gt;();</pre><p class="list-inset">This registers an instance of <strong class="source-inline">LocalizationManager</strong> to the <span class="No-Break">DI container.</span></p></li> <li>Create an instance of <strong class="source-inline">LocalizedResourcesProvider</strong>. Pass the <strong class="source-inline">ResourceManager</strong> of <strong class="source-inline">AppResources</strong> to its constructor, allowing <strong class="source-inline">LocalizedResourceProvider</strong> to access the resources defined <a id="_idTextAnchor214"/><a id="_idTextAnchor215"/>in the <span class="No-Break"><strong class="source-inline">AppResources</strong></span><span class="No-Break"> files:</span><pre class="source-code">
var resources = new LocalizedResourcesProvider(
    <a id="_idTextAnchor216"/><a id="_idTextAnchor217"/>AppResources.ResourceManager);</pre></li> <li>Let’s register this <strong class="source-inline">LocalizedResourcesProvider</strong> as <strong class="source-inline">Singleton</strong> to the DI container, as <span class="No-Break">shown here:</span><pre class="source-code">
builder.Services
    .AddSingleton&lt;ILocalizedResourcesProvider&gt;(
    resources);</pre><p class="list-inset">By doing this, we’re ensuring a single instance of the <strong class="source-inline">LocalizedResourcesProvider</strong> class is used throughout the app. Any time this instance is resolved through DI, it’s guaranteed to be the same as that referred to by the <strong class="source-inline">LocalizedResourcesProvider</strong>’s static <strong class="source-inline">Instance</strong> property. This is essential for accessing localized resources consistently across <span class="No-Break">the application.</span></p></li> </ol>
<p>This sets <a id="_idIndexMarker841"/>the foundation for a solid <a id="_idIndexMarker842"/>localization solution that is ready to be used in our app. Let’s see how we can integrate the <strong class="source-inline">LocalizedResourcesProvider</strong> and <strong class="source-inline">LocalizationManager</strong> in <span class="No-Break">our app.</span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor218"/>Using the LocalizedResourcesProvider and LocalizationManager</h2>
<p>Let’s <a id="_idIndexMarker843"/>take a look at how <a id="_idIndexMarker844"/>we can use the <strong class="source-inline">LocalizedResourcesProvider</strong> and <strong class="source-inline">LocalizationManager</strong> to access localized <a id="_idIndexMarker845"/>resources from within a ViewModel. On the <strong class="source-inline">SettingsPage</strong>, the user can select a new language through the <strong class="source-inline">PickLanguagePage</strong>. When selecting a language, a prompt should ask, in the current language, whether <a id="_idIndexMarker846"/>the user wants to switch. After switching, an alert in the updated language should confirm the update. Here’s how we can <span class="No-Break">do this:</span></p>
<ol>
<li>First, let’s add the following two fields <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SettingsViewModel</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">readonly ILocalizedResourcesProvider _resources;</strong>
<strong class="bold">readonly ILocalizationManager _localizationManager;</strong>
<strong class="bold">readonly IDialogService _dialogService</strong>
...
public PickLanguageViewModel(
    INavigationService navigationService
    <strong class="bold">IDialogService dialogService,</strong>
    <strong class="bold">ILocalizedResourcesProvider resourcesProvider,</strong>
<strong class="bold">    ILocalizationManager localizationManager</strong>)
{
    <strong class="bold">_dialogService = dialogService;</strong>
    <strong class="bold">_resources = resourcesProvider;</strong>
<strong class="bold">    _localizationManager = localizationManager;</strong>
    ...
}
...</pre><p class="list-inset">The <a id="_idIndexMarker847"/>DI container <a id="_idIndexMarker848"/>will automatically inject these additional <a id="_idIndexMarker849"/>dependencies into <span class="No-Break">the constructor.</span></p></li> <li>Next, we <a id="_idIndexMarker850"/>can update the <strong class="source-inline">ConfirmSwitchLanguage</strong> method <span class="No-Break">to this:</span><pre class="source-code">
private Task&lt;bool&gt; ConfirmSwitchLanguage()
    =&gt; _dialogService.AskYesNo(
        _resources["SwitchLanguageDialogTitle"],
        _resources["SwitchLanguageDialogText"],
        _resources["YesDialogButton"],
        _resources["NoDialogButton"]);</pre><p class="list-inset">See how we use the <strong class="source-inline">_resources</strong> field to fetch localized strings, which are then passed to the <strong class="source-inline">IDialogService</strong>’s <strong class="source-inline">AskYesNo</strong> method. The keys exactly match the keys present in the <span class="No-Break"><strong class="source-inline">AppResources</strong></span><span class="No-Break"> files.</span></p></li> <li>Likewise, we can also update the <strong class="source-inline">NotifySwitch</strong> method, as <span class="No-Break">shown here:</span><pre class="source-code">
private Task NotifySwitch()
    =&gt; _dialogService.Notify(
        _resources["LanguageSwitchedTitle"],
        _resources["LanguageSwitchedText"],
        _resources["OKDialogButton"]);</pre></li> <li>Lastly, we <a id="_idIndexMarker851"/>need to <a id="_idIndexMarker852"/>add the following line of code to the <span class="No-Break"><strong class="source-inline">SwitchLanguage</strong></span><span class="No-Break"> method:</span><pre class="source-code">
private void SwitchLanguage()
{
    CurrentLanguage = newLanguage;
    <strong class="bold">_localizationManager</strong>
<strong class="bold">        .UpdateUserCulture(</strong>
<strong class="bold">        new CultureInfo(SelectedLanguage));</strong>
}</pre><p class="list-inset">This <a id="_idIndexMarker853"/>method is called when the user has confirmed <a id="_idIndexMarker854"/>switching to the new language. By calling the <strong class="source-inline">_localizationManager</strong>’s <strong class="source-inline">UpdateUserCulture</strong>, we’ll be persisting the selected culture, updating the <strong class="source-inline">CultureInfo</strong> properties, and notifying the <strong class="source-inline">ILocalizedResourcesProvider</strong> about the updated culture. As a result, subsequential calls to the <strong class="source-inline">_resources</strong> field will retrieve the localized values for the <span class="No-Break">updated </span><span class="No-Break"><strong class="source-inline">CultureInfo</strong></span><span class="No-Break">.</span></p></li> </ol>
<p>We can now run the app, go to the <strong class="source-inline">SettingsPage</strong>, and click through to the <strong class="source-inline">PickLanguagePage</strong>, where we can change the language of the app. Once a new language is chosen, we automatically navigate back to the <strong class="source-inline">SettingsPage</strong>, where we’ll get a prompt in the current language of the app (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 12.5: Prompt in English" height="377" src="image/B20941_12_05.jpg" width="805"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: Prompt in English</p>
<p>After <a id="_idIndexMarker855"/>confirmation, the language will be updated, and we’ll <a id="_idIndexMarker856"/>see an alert in the new language (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 12.6: Alert in French" height="358" src="image/B20941_12_06.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: Alert in French</p>
<p>The fact that we can switch cultures from within our ViewModels and retrieve localized string values for the currently set culture is already very exciting! But how do we handle the localization in our Views if we want them to update to the newly selected culture as well? Let’s have <span class="No-Break">a look!</span></p>
<ol>
<li>Go to <strong class="source-inline">SettingsPage.xml</strong> and add the following <span class="No-Break">XML namespace:</span><pre class="source-code">
xmlns:localization="clr-namespace:
  Localization;assembly=Localization"</pre><p class="list-inset">This namespace points to the <strong class="source-inline">Localization</strong> namespace of the <span class="No-Break"><strong class="source-inline">Localization</strong></span><span class="No-Break"> project.</span></p></li> <li>Update the <strong class="source-inline">Text</strong> property of the <strong class="bold">Select Language</strong> button to <span class="No-Break">the following:</span><pre class="source-code">
Text="{Binding Path=[ChooseLanguage], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"</pre><p class="list-inset">This binding statement might seem complex at first glance. Let’s break it down. The <strong class="source-inline">Source</strong> property is set to the <strong class="source-inline">LocalizedResourcesProvider.Instance</strong> static property, leveraging the <strong class="source-inline">x:Static</strong> markup extension. The <strong class="source-inline">Path</strong> property is set to <strong class="source-inline">[ChooseLanguage</strong>]. What this basically means is that we want to access the indexer on the source object and pass <strong class="source-inline">ChooseLanguage</strong> as the key. Effectively, this binding statement binds to <span class="No-Break">the following:</span></p><pre class="source-code">LocalizedResourcesProvider.Instance["ChooseLanguage"]</pre><p class="list-inset">As we <a id="_idIndexMarker857"/>saw in the <strong class="source-inline">LocalizedResourcesProvider</strong>’s implementation, the indexer takes a provided <a id="_idIndexMarker858"/>key and fetches the corresponding localized string using the configured <span class="No-Break"><strong class="source-inline">ResourceManager</strong></span><span class="No-Break">.</span></p></li> <li>Let’s also update the text of the <strong class="bold">About</strong> button to make use of the <strong class="source-inline">LocalizedResourcesProvider</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
{Binding Path=[About], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"</pre><p class="list-inset">And while we’re at it, let’s also update the page’s title <span class="No-Break">as well:</span></p><pre class="source-code">Title="{Binding Path=[SettingsTitle], Source={x:Static
localization:LocalizedResourcesProvider.Instance}}"</pre></li> <li>Take a look at the <strong class="source-inline">Text</strong> property of the label that shows the current <span class="No-Break">selected language:</span><pre class="source-code">
Text="{Binding CurrentLanguage, StringFormat=
  'Language: {0}'}"</pre><p class="list-inset">In order to localize this label, we will need to use multi-binding, as shown in the <span class="No-Break">following snippet:</span></p><pre class="source-code">&lt;Label FontSize="14" HorizontalOptions="Center"&gt;
    &lt;Label.Text&gt;
        &lt;MultiBinding StringFormat="{}{0}: {1}"&gt;
            &lt;Binding Path="[Language]"
                     Source="{x:Static localization:
                       LocalizedResourcesProvider
                         .Instance}" /&gt;
            &lt;Binding Path="CurrentLanguage" /&gt;
        &lt;/MultiBinding&gt;
    &lt;/Label.Text&gt;
&lt;/Label&gt;</pre><p class="list-inset">We’ve <a id="_idIndexMarker859"/>extracted the hardcoded <strong class="source-inline">Language</strong> part from the <strong class="source-inline">StringFormat</strong> property and defined two placeholders. By leveraging <a id="_idIndexMarker860"/>multi-binding, we can indicate the first placeholder should get the value associated with <strong class="source-inline">Language</strong> in the <strong class="source-inline">AppResources</strong>. The second placeholder is bound to the <strong class="source-inline">CurrentLanguage</strong> property on <span class="No-Break">the ViewModel.</span></p><p class="list-inset">Note that the <strong class="source-inline">StringFormat</strong> property starts with <strong class="source-inline">{}</strong>. Putting just <strong class="source-inline">{0}: {1}</strong> in there is not allowed, because the  <strong class="source-inline">{</strong> curly brace is a special character in XAML, often signaling the start of a markup extension. <strong class="source-inline">{}</strong> is an escape sequence to <span class="No-Break">handle this.</span></p></li> </ol>
<p>With these changes in place, run the app again. Go to the <strong class="source-inline">SettingsPage</strong> and select a different language. After confirming to switch the language of the app, you should not only see the alert in the updated language appearing but also see that the labels on the <strong class="source-inline">SettingsPage</strong> instantly update (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">)!</span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 12.7: The Settings page before (left) and after (right) switching to French" height="388" src="image/B20941_12_07.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: The Settings page before (left) and after (right) switching to French</p>
<p>The magic <a id="_idIndexMarker861"/>happens because our bindings target the indexer <a id="_idIndexMarker862"/>of the <strong class="source-inline">LocalizedResourcesProvider</strong> class. Thus, any trigger of the <strong class="source-inline">PropertyChanged</strong> event (with <strong class="source-inline">Item</strong> as the property name) will prompt a re-evaluation of these bindings. Triggering the <strong class="source-inline">PropertyChanged</strong> event is done because the <strong class="source-inline">LocalizationManager</strong> calls the <strong class="source-inline">UpdateCulture</strong> method on its <span class="No-Break"><strong class="source-inline">_resourceProvider</strong></span><span class="No-Break"> field.</span></p>
<p>Currently, the selected culture isn’t persisted across app launches. To be exact: the selected culture does get stored, but it is not being restored when the application starts. We can easily add that functionality by updating the constructor of the <span class="No-Break"><strong class="source-inline">App</strong></span><span class="No-Break"> class:</span></p>
<pre class="source-code">
public App(INavigationInterceptor navigationInterceptor<strong class="bold">,</strong>
<strong class="bold">    ILocalizationManager manager)</strong>
{
    <strong class="bold">manager.RestorePreviousCulture();</strong>
...
}</pre> <p>By calling the <strong class="source-inline">RestorePreviousCulture</strong> on the injected <strong class="source-inline">ILocalizationManager</strong> interface, the previously set culture is being restored. It’s done in the constructor of the <strong class="source-inline">App</strong> class so that it is applied early on in the application’s <span class="No-Break">life cycle.</span></p>
<p>Personally, I think this is a beautiful and very MVVM-friendly solution to localization; well, except for the rather complex data-binding statements we have to put in place. In the next section, we’ll see how we can improve <span class="No-Break">on that.</span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor219"/>Using a custom Translate markup extension</h1>
<p>We previously set up a localization solution for our app. While it works effectively, the data-binding <a id="_idIndexMarker863"/>statements were a bit verbose and would have to be repeated for each string. Building on that foundation, in this section, we’ll introduce a streamlined approach: a custom markup extension designed specifically <span class="No-Break">for translations.</span></p>
<p>But before we <a id="_idIndexMarker864"/>proceed, let’s briefly revisit what markup extensions are. <strong class="bold">Markup extensions</strong> provide a way to compute or retrieve property values at runtime rather than just setting them to static values. This functionality makes them particularly handy for tasks such as resource lookups, data binding, or, in our case, simplifying <span class="No-Break">translation retrieval.</span></p>
<p>It’s important to note that we’re not changing how we leverage data binding to bind to our resources. Instead, we’re just making the XAML code easier to write and read. The actual data-binding process stays the same. This is essentially what the <strong class="source-inline">Translate</strong> markup extension will look like <span class="No-Break">in XAML:</span></p>
<pre class="source-code">
Title="{mauiloc:Translate SettingsTitle}"</pre> <p>This is synonymous with <span class="No-Break">the following:</span></p>
<pre class="source-code">
Title="{Binding Path=[SettingsTitle], Source={x:Static
  localization:LocalizedResourcesProvider.Instance},
    Mode=OneWay}"</pre> <p>The <strong class="source-inline">Translate</strong> markup extension is a wrapper around a conventional data-binding statement. Let’s take a look at the <strong class="source-inline">TranslateExtension</strong> class in the <strong class="source-inline">Localization.Maui</strong> project. This class implements the generic <strong class="source-inline">IMarkupExtension</strong> interface, and as a result, it needs to implement the <span class="No-Break">following methods:</span></p>
<pre class="source-code">
object IMarkupExtension.ProvideValue(IServiceProvider
  serviceProvider);
T ProvideValue(IServiceProvider serviceProvider);</pre> <p>The non-generic <strong class="source-inline">ProvideValue</strong> method will be called at runtime and must return the value we <a id="_idIndexMarker865"/>want to be using in our XAML. In this case, we want to return a <strong class="source-inline">Binding</strong>. Here’s how <span class="No-Break">it’s implemented:</span></p>
<pre class="source-code">
[ContentProperty(nameof(<strong class="bold">Key</strong>))]
public class TranslateExtension :
    IMarkupExtension&lt;<strong class="bold">Binding</strong>&gt;
{
    <strong class="bold">public string Key { get; set; }</strong>
    object IMarkupExtension.ProvideValue(
        IServiceProvider serviceProvider)
        =&gt; ProvideValue(serviceProvider);
    public <strong class="bold">Binding</strong> ProvideValue(
        IServiceProvider serviceProvider)
        =&gt; ...
}</pre> <p>The non-generic <strong class="source-inline">ProvideValue</strong> method calls its generic version, which returns a <strong class="source-inline">Binding</strong>. The class has a property named <strong class="source-inline">Key</strong>, which represents the key used to fetch the localized value. This <strong class="source-inline">Key</strong> property can be assigned in the markup extension, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
Title="{mauiloc:Translate <strong class="bold">Key=SettingsTitle</strong>}"</pre> <p>Thanks to the <strong class="source-inline">ContentProperty</strong> attribute applied to this class, we can omit the <strong class="source-inline">Key=</strong> segment, simplifying our markup extension’s use even more. <strong class="source-inline">ContentProperty</strong> specifies the default property that is to be used when no identifier is specified in XAML. Remember how we don’t need to explicitly state <strong class="source-inline">Path=</strong> in a data-binding statement and can simply write the path? This <strong class="source-inline">ContentProperty</strong> attribute is exactly what drives that! Let’s finally see what the generic <strong class="source-inline">ProvideValue</strong> <span class="No-Break">method returns:</span></p>
<pre class="source-code">
public Binding ProvideValue(
    IServiceProvider serviceProvider)
    =&gt; new Binding
    {
        Mode = BindingMode.OneWay,
        Path = $"[{Key}]",
        Source = LocalizedResourcesProvider.Instance
    };</pre> <p>The <strong class="source-inline">ProvideValue</strong> method returns a <strong class="source-inline">Binding</strong> object. Its <strong class="source-inline">Source</strong> value is set to the <a id="_idIndexMarker866"/>static <strong class="source-inline">Instance</strong> property of <strong class="source-inline">LocalizedResourcesProvider</strong>, equivalent <span class="No-Break">to this:</span></p>
<pre class="source-code">
{x:Static localization:LocalizedResourcesProvider.Instance}</pre> <p>For the <strong class="source-inline">Path</strong> property, when the <strong class="source-inline">Key</strong> value is <strong class="source-inline">SettingsTitle</strong>, it translates to <strong class="source-inline">Path=[SettingsTitle]</strong>. The <strong class="source-inline">Binding</strong>’s <strong class="source-inline">Mode</strong> is set to <strong class="source-inline">OneWay</strong> to ensure it listens for the <strong class="source-inline">PropertyChanged</strong> event and updates the bound value <span class="No-Break">when needed.</span></p>
<p>The <strong class="source-inline">Translate</strong> markup extension provides a convenient way to define the exact same binding statements we had earlier. Let’s go ahead and update some of our Views so that they leverage this <strong class="source-inline">Translate</strong> <span class="No-Break">markup extension:</span></p>
<ol>
<li>Go to <strong class="source-inline">SettingsPage</strong> and add the following XML namespace, which points to the <strong class="source-inline">Localization.Maui</strong> namespace of the <span class="No-Break"><strong class="source-inline">Localization.Maui</strong></span><span class="No-Break"> project:</span><pre class="source-code">
xmlns:mauiloc="clr-namespace:Localization.Maui;
  assembly=Localization.Maui"</pre></li> <li>Update the binding statements on the <strong class="source-inline">SettingsPage</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
...
Title="{mauiloc:Translate SettingsTitle}"
...
Text="{mauiloc:Translate ChooseLanguage}"
...
Text="{mauiloc:Translate About}"
...</pre></li> <li>In <strong class="source-inline">AppShell.xaml</strong>, add the same XML namespace that we previously added to <strong class="source-inline">SettingsPage</strong> in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
<li>Now, update <a id="_idIndexMarker867"/>the binding statements on <strong class="source-inline">AppShell.xaml</strong>, as shown in the <span class="No-Break">following snippet:</span><pre class="source-code">
&lt;Tab Title="<strong class="bold">{mauiloc:Translate Tab1Title}</strong>"&gt;
    ...
&lt;/Tab&gt;
&lt;Tab Title="<strong class="bold">{mauiloc:Translate Tab2Title}</strong>"&gt;
    ...
&lt;/Tab&gt;</pre></li> </ol>
<p>The <strong class="source-inline">Translate</strong> markup extension offers an elegant approach to what is typically considered a complex task. Everywhere hardcoded text is used, we can very simply replace it with this <strong class="source-inline">TranslateExtension</strong>. Note that the <strong class="source-inline">TranslateExtension</strong> can still be improved: all the typical data-binding properties such as <strong class="source-inline">Converter</strong>, <strong class="source-inline">ConverterParameter</strong>, and so on can be added to this class as well and be used in the <strong class="source-inline">Binding</strong> object that is <span class="No-Break">being returned.</span></p>
<p>Now that we know how to localize hardcoded <strong class="source-inline">copy</strong> labels, let’s have a look at how we can fetch localized data <span class="No-Break">from APIs.</span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor220"/>Fetching localized data from APIs</h1>
<p>Before we wrap up this chapter, let’s have a quick look at how we could pass the user’s language to <a id="_idIndexMarker868"/>the API so that it can return localized data. One approach is to include a language parameter in every service and repository method, allowing the ViewModel to pass the user’s current language. However, I believe adding such parameters can clutter the code. A cleaner alternative is to handle this within the repositories. Let’s <span class="No-Break">see how:</span></p>
<ol>
<li>First, let’s update the <strong class="source-inline">IRecipeAPI</strong> interface by adding a <strong class="source-inline">language</strong> parameter of type <strong class="source-inline">string</strong> to the <strong class="source-inline">GetRecipes</strong> method. The following snippet shows how we can configure Refit to pass this additional parameter as an <strong class="source-inline">Accept-Language</strong> request header when executing the <span class="No-Break">API call:</span><pre class="source-code">
Task&lt;ApiResponse&lt;RecipeOverviewItemsDto&gt;&gt;
  GetRecipes(<strong class="bold">[Header("Accept-Language")] string</strong>
<strong class="bold">    language</strong>, int pageSize = 7, int pageIndex = 0);</pre><p class="list-inset">We could pass this language parameter as a query string parameter as well by leaving out the <strong class="source-inline">Header</strong> attribute, but I think this approach is a <span class="No-Break">lot cleaner.</span></p></li> <li>It’s the <strong class="source-inline">RecipeApiGateway</strong> class that invokes the updated <strong class="source-inline">GetRecipes</strong> method. In order for it to access the current culture, let’s inject an instance of the <strong class="source-inline">ILocalizationManager</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
readonly ILocalizationManager _localizationManager;
...
public RecipeApiGateway(IRecipeApi api,
    ILocalizationManager localizationManager)
{
    _api = api;
    _localizationManager = localizationManager;
}</pre></li> <li>The next code block shows how we can now use the <strong class="source-inline">_localizationManager</strong> field to access the current user culture and pass its <strong class="source-inline">Name</strong> property to the <span class="No-Break"><strong class="source-inline">GetRecipes</strong></span><span class="No-Break"> method:</span><pre class="source-code">
public Task&lt;Result&lt;LoadRecipesResponse&gt;&gt;
  LoadRecipes(int pageSize, int page)
    =&gt; InvokeAndMap(_api.GetRecipes(
        <strong class="bold">_localizationManager.GetUserCulture().Name</strong>,
         pageSize, page), MapRecipesOverview);</pre><p class="list-inset">While directly using <strong class="source-inline">CultureInfo.CurrentCulture.Name</strong> might seem straightforward, accessing the culture via our <strong class="source-inline">ILocalizationManager</strong> ensures <a id="_idIndexMarker869"/>greater consistency, as <span class="No-Break">mentioned earlier.</span></p></li> <li>Accessing the <strong class="source-inline">Accept-Language</strong> that’s now being sent with this API call can be achieved by updating the <strong class="source-inline">GetRecipes</strong> endpoint in the <strong class="source-inline">Program.cs</strong> file inside the <strong class="source-inline">Recipes.Web.Api</strong> project. Here’s what the updated code <span class="No-Break">looks like:</span><pre class="source-code">
app.MapGet("/recipes", (int pageSize, int pageIndex,
    <strong class="bold">[FromHeader(Name = "Accept-Language")] string</strong>
<strong class="bold">       language</strong>) =&gt;
    {
        //use language to retrieve recipes
        return new RecipeService()
            .LoadRecipes(pageSize, pageIndex);
})
.WithName("GetRecipes")
.WithOpenApi();</pre></li> </ol>
<p>In contrast to the data-bound values on the screen, changing the app’s language won’t automatically fetch any localized data coming from the API anew. So, how can we tackle this? In <a href="B20941_07.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Dependency Injection, Services, and Messaging</em>, we already discussed thoroughly <a id="_idIndexMarker870"/>how ViewModels can communicate with each other in a loosely coupled manner through <strong class="source-inline">Messaging</strong>. <strong class="source-inline">Messaging</strong> offers a solution to this challenge: <strong class="source-inline">SettingsViewModel</strong> can send a message notifying other ViewModels about the updated language. ViewModels can react to this and re-fetch their data. Let’s <span class="No-Break">implement this:</span></p>
<ol>
<li>Add a new class called <strong class="source-inline">CultureChangedMessage</strong> to the <strong class="source-inline">Messages</strong> folder of the <strong class="source-inline">Recipes.Client.Core</strong> project. Here’s what it <span class="No-Break">looks like:</span><pre class="source-code">
public class CultureChangedMessage :
    ValueChangedMessage&lt;CultureInfo&gt;
{
    public CultureChangedMessage(CultureInfo value) :
        base(value)
    { }
}</pre></li> <li>Update the <strong class="source-inline">SwitchLanguage</strong> method on <strong class="source-inline">SettingsViewModel</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
private void SwitchLanguage(string newLanguage)
{
    CurrentLanguage = newLanguage;
    var newCulture = new CultureInfo(newLanguage);
    _localizationManager
        .UpdateUserCulture(newCulture);
    <strong class="bold">WeakReferenceMessenger.Default.Send(</strong>
<strong class="bold">        </strong><strong class="bold">new CultureChangedMessage(newCulture));</strong>
}</pre></li> <li>Finally, in the constructor of the <strong class="source-inline">RecipesOverviewViewModel</strong>, we can add the following code that listens for the <strong class="source-inline">CultureChangedMessage</strong> to arrive so that we can reload the list <span class="No-Break">of recipes:</span><pre class="source-code">
WeakReferenceMessenger.Default
    .Register&lt;CultureChangedMessage&gt;(this, (r, m) =&gt;
{
    Recipes.Clear();
    (r as RecipesOverviewViewModel).LoadRecipes(7, 0);
});</pre><p class="list-inset">We don’t need <a id="_idIndexMarker871"/>to bother with passing the updated culture or language around. Once the message is received, the <strong class="source-inline">LocalizationManager</strong> is already updated to the selected culture and will return the newly selected culture. This ensures that any new recipe fetch will use the <span class="No-Break">updated culture.</span></p></li> </ol>
<p>When running the app and changing the language on the <strong class="source-inline">SettingsPage</strong>, the <strong class="source-inline">RecipesOverviewViewModel</strong> will reload its recipes. If you debug and set a breakpoint in the API, you’ll observe that the language parameter consistently matches the newly <span class="No-Break">selected language.</span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor221"/>Summary</h1>
<p>We kicked off this chapter with an introduction to localization, understanding its importance in ensuring our app resonates with users globally. Before diving deep, we explored the basics of how localizable values can be statically bound, offering a <span class="No-Break">foundational approach.</span></p>
<p>Building on this, we introduced a more dynamic localization framework. This allowed for more flexible updates and interactions. Following this, we delved into simplifying our XAML through the <strong class="source-inline">Translate</strong> markup extension. While it made our data-binding statements sleeker, the underlying mechanism <span class="No-Break">remained unchanged.</span></p>
<p>Next, we discussed getting localized data from our APIs. We found a neat way to tell the API about the user’s language choice without making our code messy. By using the <strong class="source-inline">ILocalizationManager</strong>, we kept our approach consistent. And, with <strong class="source-inline">Messaging</strong>, our app knows when to fetch new data if a user changes <span class="No-Break">their language.</span></p>
<p>The big takeaway? All our steps respected the key MVVM idea of “separation of concerns.” Each part of our app has its job, making things organized and easier <span class="No-Break">to manage.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Be aware that what we’ve seen throughout this chapter doesn’t completely cover everything there is to localizing your apps, such as localizing the app’s name or localizing images. Take a look at <a href="https://learn.microsoft.com/dotnet/maui/fundamentals/localization">https://learn.microsoft.com/dotnet/maui/fundamentals/localization</a> to find <span class="No-Break">out more!</span></p>
<p>As we wrap up this chapter, we’ve truly come a long way in building the <em class="italic">Recipes!</em> app, while adhering to the MVVM principles. But, of course, no app development journey is complete without ensuring its robustness. And that’s where the next chapter comes in. We’ll dive into how MVVM isn’t just about structuring our app effectively, but also about setting the stage for thorough and effective <span class="No-Break">unit testing.</span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor222"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
<ul>
<li>The <strong class="source-inline">ResourceManager</strong> <span class="No-Break">class: </span><a href="https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0"><span class="No-Break">https://learn.microsoft.com/dotnet/api/system.resources.resourcemanager?view=net-8.0</span></a></li>
<li><em class="italic">XAML markup </em><span class="No-Break"><em class="italic">extensions</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/xaml/fundamentals/markup-extensions</span></a></li>
<li><em class="italic">Create XAML markup </em><span class="No-Break"><em class="italic">extensions</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create"><span class="No-Break">https://learn.microsoft.com/dotnet/maui/xaml/markup-extensions/create</span></a></li>
</ul>
</div>
</div></body></html>