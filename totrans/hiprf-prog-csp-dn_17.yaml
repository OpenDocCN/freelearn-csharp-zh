- en: '*Chapter 14*: Multi-Threaded Programming'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about **multi-threaded programming**. You will
    learn what threads are and about background and foreground threads. Then, you
    will learn how to pass data into threads before you run them. You will also learn
    how to pause, interrupt, destroy, schedule, and cancel threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding threads and threading**: This section covers the life cycle
    of threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating threads with and without parameters**: This section provides examples
    of thread creation with and without parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pausing and interrupting threads**: This section covers how to pause and
    interrupt threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destroying and canceling threads**: This section covers destroying and canceling
    threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling threads**: This section covers how to schedule threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread synchronization and locks**: This section covers how to synchronize
    threads, protect resources, and prevent deadlocks and race conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have gained the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: You will understand threads and threading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to create threads with and without parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to pause and interrupt threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to destroy and cancel threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to schedule threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To ensure that you benefit from this chapter, you should have the following
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The book’s source code from the following link: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH14).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding threads and threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will understand the life cycle of threads. Threads in C#
    have a life cycle as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The thread life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_14.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – The thread life cycle
  prefs: []
  type: TYPE_NORMAL
- en: When started, threads enter the `Suspend` method, and calling the `Resume` method
    resumes a thread.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Monitor.Wait(object obj)` method is called, the thread enters the
    `wait` state. A waiting thread will continue when the `Monitor.Pulse(object obj)`
    method is called, and you can make threads sleep by calling the `Thread.Sleep(int
    millisecondsTimeout)` method.
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `Thread.Join()` method, it causes the thread to enter the
    `wait` state. The waiting thread will then continue once the dependent threads
    have completed running. If any dependent threads are canceled, the thread is aborted
    and enters the `stop` state. Once a thread has been completed or canceled, you
    cannot restart it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `SYSLIB0006` compile-time warning will be raised by projects that target
    .NET 5 or higher if they call any of the `Thread.Abort` APIs. Microsoft recommends
    that you abort the `running` unit of work using `CancellationToken` instead. The
    `Thread.Abort` APIs are now obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at creating background and foreground threads
    with and without parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating threads and using parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we look at the creation of threads. First, we will see how
    to create parameterless threads in the foreground and the background. Let’s define
    both foreground and background threads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Main` method be complete and the foreground thread is still running, the process
    will remain active until the foreground thread terminates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background threads**: Background threads are created in the same way as foreground
    threads. The main difference is that you must explicitly set the thread to run
    in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to create and run a foreground thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To create and run a background thread, you run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both versions of the code that generates foreground and background threads,
    that you have just seen, create threads without using parameters. The following
    code shows you how to create a thread using parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, the thread is used to sum two numbers
    and return the result. The thread calls the `Add` method and passes the two integers
    to be added. Both the method call and the result are placed within an anonymous
    function passed into the thread’s constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple threads can be costly on performance. The performance of multiple-thread
    creation can be improved by using thread pools. Thread pools improve performance
    in multi-threaded applications by limiting the number of threads that should be
    created and managed.
  prefs: []
  type: TYPE_NORMAL
- en: When a new thread is created using a thread pool, it is kept there until it
    is needed. When required, the thread will run and complete its task. Once the
    task is completed, the thread will return to the thread pool for later reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a thread in a thread pool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing to note when using a thread pool is that when first used, they have
    no history, but over time, they tune themselves to improve thread pool performance.
    For applications that use a large number of threads and put a heavy load on the
    CPU, it is possible that they will encounter a high startup cost. Threads have
    to be created and made available to the thread pool. This can cause the thread
    pool to have to wait until those threads are made available. A performance tweak
    you can make at startup is to set the minimum number of threads. The following
    code shows how to set the minimum number of threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `WorkerThreads` value is the minimum number of worker threads created on
    demand by the `ThreadPool`. The `CompletionPortThreads` value is the number of
    asynchronous I/O threads created on demand by the `ThreadPool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting the minimum number of threads, you can set the maximum
    number of threads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In order for these settings to help with application performance, you need to
    set them correctly. Otherwise, you can end up creating too many threads and overscheduling
    tasks. This will reduce performance by increasing context switching, which will
    put more load on the CPU. The `ThreadPool` is intelligent enough to switch to
    an algorithm that will reduce the amount of work the CPU has to do once it gathers
    a history.
  prefs: []
  type: TYPE_NORMAL
- en: Before settings these values, it is a good idea to use performance monitoring
    to monitor the thread usage and context switching of your application. You can
    use performance counters tracing using the Contextual Visualizer, which is discussed
    in the following chapter. You can also use the `ThreadPool.GetMaxThreads` and
    `ThreadPool.GetMinThreads` methods to help you analyze the optimal values for
    setting the minimum and maximum numbers of worker threads and completion port
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a thread’s priority. However, you have to be very careful about
    setting a thread priority as it can have a negative impact on other threads and
    other applications. Setting threads to a higher priority can starve lower priority
    threads, resulting in them rarely running.
  prefs: []
  type: TYPE_NORMAL
- en: Only when a fast response is required for an event, such as an exception, should
    you consider changing thread priority to a high value. When race conditions are
    encountered, you can legitimately lower a thread’s priority. Threads that do not
    run for a while because of their lower priority will run at some point. This is
    because the dynamic priority of a thread is increased by Windows the longer it
    goes without running.
  prefs: []
  type: TYPE_NORMAL
- en: If you do change the priority of a thread, its priority will be reset on entry
    back into the pool. However, a thread may be used for several tasks. In this case,
    the thread will not return to the pool until these tasks are completed. If the
    priority is set incorrectly, then this can degrade both application performance
    and system-wide performance.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how to create and run threads. Let’s turn our attention to
    pausing and interrupting threads.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing and interrupting threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at pausing and interrupting threads. An example
    of why you would need to pause or interrupt a thread is if the code running is
    a debugger. If a thread is executing and it hits a breakpoint, it would need to
    be paused.
  prefs: []
  type: TYPE_NORMAL
- en: The most common way to pause/delay a thread is to call `Thread.Sleep(millisecondsDuration)`,
    but this may freeze the main thread and your users may think your program has
    stopped working, leading them to terminate it.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to delay a thread is to let `Task.Delay(TimeSpan)` run in the background.
    This will allow the thread to work in the background and prevent the delayed thread
    from stopping the main thread from doing its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to delay a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We create the task with a time delay of five seconds. The loop keeps running
    until the time delay has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: The `Interrupt` method is called to interrupt a thread that is in a blocked
    state of `wait`, `sleep`, or `join`. When the method is called, `ThreadInterruptedException`
    is raised. This exception is not raised when calling the `Interrupt` method on
    a thread not in a blocked state.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying and canceling threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aborting threads is not a good idea as you don’t always know the state of a
    thread. It can be made worse if the thread is part of a static constructor. Using
    `Thread.Abort` to abort a thread is one of the main reasons for application crashes.
    The `Thread.Abort` APIs are now obsolete. So, you are encouraged to use the cooperative
    cancellation pattern to periodically check for cancellations using `CancellationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under normal circumstances, when a thread is aborted, it is destroyed. The
    cancellation of a thread also destroys the thread. Let’s write some sample code
    that demonstrates the usage of `CancellationToken` to cancel a synchronous operation
    when it times out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6 console application and call it CH14_Multithreading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the *Program.cs* file of the *CH14_Multithreading* project, add the following
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method receives a method to execute over a specified timeout period and
    returns a result. `SleepyMethod` is executed, but if it exceeds the timeout value,
    then `TaskCanceledException` is raised and then `CancellationTokenSource` is disposed
    of.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `SleepyMethod` code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `SleepMethod` accepts `CancellationToken` as a parameter. It then loops
    ten times. During each iteration, it sleeps for half a second. Then, it checks
    to see whether cancellation has been requested. If cancellation has been requested,
    then `TaskCanceledException` is raised. Otherwise, the value of the method is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `SynchronousThreadCancelation` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method creates a timeout value of three-quarters of a second. It then
    calls the `TryCallWithTimeout` method, which returns a Boolean value. The parameters
    passed into the `TryCallWithTimeout` method are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SleepyMethod`: The name of the method to be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timoutTimeSpan`: The duration the method is to run for before it times out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result`: Contains the result of `CancellationToken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the call has been made, the name of the called method and its call result
    are sent to the console. In this code, we are not writing the result to the console
    window, but you can modify the code to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the class, update the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code calls our method and is an example of the cancellation of
    a synchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the preceding code and the result should look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Console output for our program showing that the thread was
    canceled'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_14.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Console output for our program showing that the thread was canceled
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the topic of canceling and destroying threads. Let’s now look
    at scheduling threads.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Thread.Start` method schedules a `Thread` to start. You can overload this
    method with different parameters. We will look at two examples in this section.
    The first example will call the `Thread.Start()` method without passing any parameters,
    and the second will call `Thread.Start(object)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a class called `Job` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class provides two methods that will be used in our `Thread` scheduling
    examples. The `Execute` method is used with the parameterless `Thread.Start` method,
    and the `PrintMessage` function is used with the `Thread.Start` method that takes
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program.cs` class, add the `SheduleThreadWithoutParameters` method
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we create a new instance of the `Job` class. Then, we
    create a new `Thread` passing a new `ThreadStart` instance into its constructor.
    Into the `ThreadStart` constructor, we pass `object.method` that we wish to execute,
    and then we start the thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ScheduleThreadWithParameters` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we created a new `Job` instance and two threads by calling
    the `ParameterizedThreadStart` class for each thread to execute a parameterized
    method on an object. We then start each of the threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to each of the methods at the top of the class and then run the
    preceding code. Your console should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![14.3 – Our parameterized thread output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_14.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 – Our parameterized thread output
  prefs: []
  type: TYPE_NORMAL
- en: Thread synchronization and locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using multiple threads in an application, you have to consider thread synchronization
    and locking. If you don’t, you can end up with race conditions and deadlocks.
    There are several ways to synchronize threads. You can use interlocked methods
    and synchronization objects, such as `Monitor`, `Semaphore`, and `ManualResetEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152), *Threading
    and Concurrency*, in the *Clean Code in C#* book, we provide a detailed discussion
    on threads covering using threads, thread safety, parallel threads using semaphores,
    thread synchronization and preventing deadlocks, and race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To synchronize your code, you can use a lock object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When the locked code is entered, all of the other threads are barred from accessing
    the locked code. The only downside to this is that you can end up with a deadlock.
    This can be overcome by using a mutex as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code declares a `Mutex` class-level variable. The code that needs
    protecting is then wrapped in a `try/catch` block. The current thread is blocked
    by the `WaitOne()` method until the wait handle receives a signal. `True` is then
    returned from the `WaitOne()` method upon a `Mutex` being signaled. The `Mutex`
    is then owned by the calling thread that can access protected resources. Once
    the protected resources are finished, the `Mutex` is released by calling `ReleaseMutext()`.
    Always call the `ReleaseMutext()` method in the final block to prevent resources
    from remaining locked if an exception is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Race conditions happen when the same resource is accessed by multiple threads
    that produce different outcomes based on their timings. A race condition can be
    avoided by using code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `Task` runs `Method1()` and then continues with `Method2()`. We then `Wait()`
    for the `Task` to complete its execution of `Method1()` and `Method2()` before
    continuing.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at multi-threaded programming. As you can see, there
    is not much to scheduling threads. Let’s summarize what we have learned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have come to an understanding of threads and the thread
    life cycle. We built some sample code that shows how to create threads with and
    without parameters. We also looked at running threads in the foreground and background.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at pausing and interrupting threads. Then, we moved on to destroying
    and canceling threads. You no longer use `Thread.Abort` in your code. `Thread.Abort`
    has been responsible for applications crashing at runtime. Instead, you use cancellation
    tokens. Canceling threads also destroys them.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at scheduling threads with and without parameters. In the next chapter,
    we will be looking at parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at thread synchronization and locking using lock objects
    and mutexes and learned how to avoid deadlocks and race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to answer some questions to see how well you have retained the
    knowledge in this chapter. Once you have completed the questions, the *Further
    reading* section provides some external sources to further your knowledge on threads
    and multi-threaded programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What states can a thread be in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which part of the `Thread.Abort` API do you use to terminate a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which two locations can a thread be executed in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the correct way to terminate a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method is used to schedule a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing and implementing multi-threading: [https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Pausing and interrupting threads: [https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'How to terminate a thread in C#: [https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/](https://www.geeksforgeeks.org/how-to-terminate-a-thread-in-c-sharp/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'How to destroy threads in C#: [https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash](https://www.tutorialspoint.com/How-to-destroy-threads-in-Chash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to schedule threads in C#: [https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20](https://www.geeksforgeeks.org/how-to-schedule-a-thread-for-execution-in-c-sharp/#:~:text=%20How%20to%20schedule%20a%20thread%20for%20execution,1%20Start%20%28%29%202%20Start%20%28Object%29%20More%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding threads and the threading process: [https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process](https://subscription.packtpub.com/book/programming/9781789536577/6/ch06lvl1sec52/understanding-threads-and-the-threading-process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'How to pause code execution in C#: [https://csharpsage.com/c-delay/](https://csharpsage.com/c-delay/
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pausing and interrupting threads: [https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads](https://docs.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
