- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure for Hosting Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating Docker images with the previous chapters, and running the complete
    application using Docker containers locally, let’s move over to run the solution
    with Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to push Docker images to an Azure container
    registry, run Docker containers with Azure Container Apps, access a database using
    Azure Cosmos DB, and configure environment variables and secrets with Azure Container
    Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bicep scripts, you learn how to create multiple Azure resources at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Experiencing Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing images to the **Azure Container Registry** (**ACR**) instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure container apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Azure resources using .NET Aspire and the **Azure Developer** **CLI**
    (**azd**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to have Docker Desktop installed. You also need a
    Microsoft Azure subscription. You can activate Microsoft Azure for free at [https://azure.microsoft.com/free](https://azure.microsoft.com/free),
    which gives you an amount of about USD 200, Azure credits that are available for
    the first 30 days, and several services that can be used for free for the time
    after.
  prefs: []
  type: TYPE_NORMAL
- en: 'What many developers miss: if you have a Visual Studio Professional or Enterprise
    subscription, you also have a free amount of Azure resources every month. You
    just need to activate this with your Visual Studio subscription: [https://visualstudio.microsoft.com/subscriptions/](https://visualstudio.microsoft.com/subscriptions/).'
  prefs: []
  type: TYPE_NORMAL
- en: To work through the samples of this chapter, besides Docker Desktop, the Azure
    CLI and `azd` are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and manage resources, install the Azure CLI and `azd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These tools are available on Mac and Linux as well. To install the Azure CLI
    on different platforms, see [https://learn.microsoft.com/cli/azure/install-azure-cli](https://learn.microsoft.com/cli/azure/install-azure-cli),
    and for `azd`, see [https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd](https://learn.microsoft.com/azure/developer/azure-developer-cli/install-azd).
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to use the Azure Cloud Shell is from a web browser. As you log in
    to the Azure portal at [https://portal.azure.com](https://portal.azure.com) using
    your Microsoft Azure account, on the top button bar, you’ll see an icon for *Cloud
    Shell*. Clicking on this button, a terminal opens. Here, the Azure CLI is already
    installed – along with many other tools such as `wget` to download files, `git`
    to work with repositories, `docker`, the .NET CLI, and more. You can also use
    a Visual Studio Code editor (just run `code` from the terminal) to edit files.
    All the files you create and change are persisted within an Azure Storage account
    that is automatically created when you start the Cloud Shell. For a fullscreen
    Cloud Shell, you can open [https://shell.azure.com](https://shell.azure.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ch06` folder, these are the important projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs` – The `gamesAPI` project we used in the previous chapter.
    There’s one change: instead of including the projects with the database access
    code and the models, NuGet packages are referenced.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot` – The bot service calling the game APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – This project contains important changes in this chapter
    to define the app model with Azure resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – This project is unchanged in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can start with the results from the previous chapter to work on your own
    through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Experiencing Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft Azure offers cloud services from many different categories. You can
    create **virtual machines** (**VMs**), which belong to the **Infrastructure as
    a Service** (**IaaS**) category, where you are in control of the machines but
    also need to manage them as you do in on-premises environments, up to ready-to-use
    software such as Office 365 from the **Software as a Service** (**SaaS**) category.
    Something in between is **Platform as a Service** (**PaaS**), where you don’t
    have full control over the VMs but instead get many functionalities out of the
    box.
  prefs: []
  type: TYPE_NORMAL
- en: The focus here is on PaaS services. With the PaaS category, there’s also a category
    named **serverless**. This category allows for easy scaling, starting from zero,
    where no or low costs are associated, up to a maximum amount of automatic scaling
    based on the needs. Many Azure services have offerings in this category.
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating resources in a cloud environment, there’s always a question about
    the cost. Many are afraid of the need to pay unexpected amounts, but this fear
    is not necessary. Some subscriptions (such as a Visual Studio subscription) are
    limited to the amount available every month. If this amount is reached, resources
    are automatically stopped (unless you explicitly allow the cost to go above the
    limits), so no additional cost applies.
  prefs: []
  type: TYPE_NORMAL
- en: 'With subscriptions and also just with resource groups, you can specify a budget
    to specify the amount that’s planned to be spent. To do this, open the Azure portal
    and select a resource group. Within a resource group, you’ll see the **Cost Management**
    category with the **Budgets** option. By creating a budget (see *Figure 6**.1*),
    you can define limits month by month. Before this limit is reached, you specify
    alerts where you can be informed. With an alert, you can specify to receive a
    notification via email, SMS, push, or voice notification, and in addition to that,
    you can define an action that should be invoked to call an Azure function, a logic
    app, an Automation runbook, or other Azure resources where custom functionality
    can be implemented. Based on usage and requirements, stopping services could be
    an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Specifying budgets](img/B21217_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Specifying budgets
  prefs: []
  type: TYPE_NORMAL
- en: To get price information about services, at [https://azure.microsoft.com](https://azure.microsoft.com),
    you can select **Azure pricing**, search for products, or select a product from
    a category to get details of different offerings available. You will also see
    a pricing calculator where you select multiple products and get complete price
    information based on selections made.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions and more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating resources within Azure, we should think about some important
    foundations to easily find resources based on the needs of IT but also based on
    the needs of business organizations. Which resources are for production, and which
    are for testing environments? Which resources are used by different organizations
    in the company? Which resources are used by one product? What are the resources
    potentially being impacted by a technical issue? For all these scenarios, these
    features help:'
  prefs: []
  type: TYPE_NORMAL
- en: Every resource needs to be put into one `codebreaker` solution, resource groups
    will be created for the test and production environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should also be easy to find multiple resources across resource groups. **Resource
    tags** can be used here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a convention for how you name your resources. The number of resources
    will grow over time! You might create multiple instances for scaling, run the
    same services around the globe in different regions for better latency, run services
    in different environments… there are many reasons the number of resources grows.
    To deal with this, a good naming strategy used from the start can help a lot!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `codebreaker` application, we can use `rg-codebreaker-dev`, `rg-codebreaker-test`,
    and `rg-codebreaker-prod` resource groups for *development*, *test*, and *production*
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Besides separating the environments with different resource groups, it’s a good
    practice to separate the development and production environments into different
    subscriptions. As there’s an Azure subscription with some free amount available
    with a Visual Studio subscription, this subscription can be used with the development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Some resources are used across different resource groups. For example, you might
    use a central Azure DNS resource. You might also share resources across different
    applications. You can share an Azure app service that hosts many small websites.
    With every Azure resource, you can add custom tags and search for resources using
    different tags and their values. For example, you can specify a tag named `cc`
    (for cost center), and the value specifies the cost center.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a naming convention for resources, Microsoft not only has a guideline
    (available at [https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming](https://learn.microsoft.com/azure/cloud-adoption-framework/ready/azure-best-practices/resource-naming)),
    but also an Excel template you can use (available at https://raw.githubusercontent.com/microsoft/CloudAdoptionFramework/master/ready/naming-and-tagging-conventions-tracking-template.xlsx),
    and even a Blazor application that you can host on-premises (or in the cloud)
    for your administrators to manage naming conventions with a simple user interface:
    https://github.com/mspnp/AzureNamingTool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Components that can be part of the name of resources include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The *resource type*. Microsoft has a list of proposed abbreviations; for example,
    `rg` for resource group, `cosmos` for an Azure Cosmos DB database, `cr` for ACR,
    `ca` for container apps, and `cae` for Container Apps environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project, application, or service name. We’ll use `codebreaker` for the application
    name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment where the resource is used; for example, `prod` for production,
    `dev` for development, and `test` for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location of the Azure resource; for example, `eastus2` for the second East
    US region, and `westeu` for West Europe. Creating resources in multiple regions
    can be useful for failover scenarios, for better performance for customers around
    the globe, and because of data regulations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are ready to create Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Microsoft Azure, there are different ways to create and manage Azure resources.
    Azure resources are accessible via a REST API. You can send `GET` requests to
    read information about resources and `POST` requests to create new resources,
    but of course, there’s an easier way to do it. The Azure portal ([https://portal.azure.com](https://portal.azure.com))
    is a great way to learn and see the different options you have. To automatically
    create Azure resources, you can use the Azure CLI, PowerShell scripts, and many
    more options to use. In this book, we’ll use the Azure portal, Bicep scripts,
    .NET Aspire, and `azd`. Bicep scripts give you a simple syntax from Microsoft
    to easily recreate Azure resources. .NET Aspire offers to define Azure resources
    using .NET code and directly create the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Within company environments, there are different ways Azure resources are created
    and how teams are organized. .NET Aspire, together with `azd`, offers great functionality
    for creating Azure resources, but this might not (yet?) fit into your environment.
    You can also decide to use parts of .NET Aspire that fit into your company environment,
    or use all that .NET Aspire and `azd` offer. The second option is the easiest
    one. To better understand the options, and for you to map it into your environment,
    we’ll start using the Azure CLI and the Azure portal. With this, you can easily
    see what options a resource offers for configuration. Later in this chapter, we’ll
    use .NET Aspire and `azd`. Specifying Azure resources with .NET code just needs
    a few statements to create all the resources needed with the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the resources we create? In this section, we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a resource group that groups all Azure resources together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Azure Cosmos DB database that is added to the previously created resource
    group and used by the EF Core context we created in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Azure container registry to publish the Docker images we created in
    [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two Azure container apps to run the `gamesAPI` service and the bot service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a resource group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource groups are used to manage Azure resources together. With a resource
    group, you can specify permissions for who is allowed to create or manage resources
    within the resource group. From a price standpoint, you easily can see the cost
    of the complete resource group and which resources of this resource group were
    responsible for which cost. You can also delete a resource group, which deletes
    all resources within the group.
  prefs: []
  type: TYPE_NORMAL
- en: To create a resource group, let’s use the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in to Azure, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command opens the default browser to authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple Azure subscriptions, you can check these with `az account
    list`. The current active subscription where you create resources is shown with
    `az` `account show`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a resource group, use the `az` `group` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `create` subcommand creates a resource group. With `-l`, we specify the
    location of this Azure resource. Here, I’m using `westeurope` because this region
    is near my location. With the `-n` value, the name of the resource group is set.
  prefs: []
  type: TYPE_NORMAL
- en: The location of the resource group is independent of the location of the resources
    within the resource group. Resources within the resource group can have other
    regions. A resource group is just metadata. The location for the resource group
    specifies the primary location for the resource group. In a fatal case where the
    location is not available, you cannot make changes to the resource group.
  prefs: []
  type: TYPE_NORMAL
- en: To get the regions available with your subscription, you can use `az account
    list-locations -``o table`.
  prefs: []
  type: TYPE_NORMAL
- en: After the resource group is created, we can create resources within this resource
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos DB account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we used the Azure Cosmos
    DB emulator to store games and moves. Now, let’s change this to the real database
    in the Azure cloud. First, we’ll use the Azure portal to create an Azure Cosmos
    DB account.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Azure portal, by clicking on `Azure Cosmos DB`. When you click **Create**
    with the Azure Cosmos DB resource, this does not immediately create the resource.
    Instead, you need to do some configuration beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Azure Cosmos DB resource, you first need to select one of the APIs
    available. Read back to [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063) for the
    different APIs available and what they offer. Now, select **Azure Cosmos DB for
    NoSQL**, and click the **Create** button. This opens the configuration, as shown
    in *Figure 6**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Creating an Azure Cosmos DB account](img/B21217_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Creating an Azure Cosmos DB account
  prefs: []
  type: TYPE_NORMAL
- en: You have some pages for configuration before you can click the `cosmos-codebreaker-test`
    for the test environment, but be aware this name needs to be globally unique),
    and the capacity. Azure Cosmos DB offers one free tier with a subscription. In
    case you haven’t used this yet with your subscription, you can choose this option.
    This gives you 1,000 **request units per second** (**RU/s**) and 25 GB of storage
    for free. Using provisioned throughput, you define a RU/s limit by database or
    by database container, at least 400 RU/s. The serverless option starts with a
    higher minimum limit but automatically scales to the RU/s needed. With serverless,
    you need to be aware of some limits. With serverless, the maximum database container
    size is 1 TB; there’s no limit with the provisioned configuration. Serverless
    also doesn’t support geo-distribution, which is available with the provisioned
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos DB account registers a DNS name, thus the name needs
    to be globally unique. For your account, you can add a number following the account
    name, and check by clicking **Review + create** if your selected name is available.
  prefs: []
  type: TYPE_NORMAL
- en: With the next configurations, you can configure the global distribution of a
    database, networking, a policy to automatically create backups, encryption with
    a service-managed key or a customer-managed key, and tags (which are available
    with every resource). You can use the default values with all the settings other
    than the basic configuration. Upon clicking on the **Review + create** button,
    final checks are made, and you can click the final **Create** button. Now, you
    just need to wait for a few minutes until the database account is created.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure CLI, you can use the `az cosmosdb` `create` command.
  prefs: []
  type: TYPE_NORMAL
- en: The database account is created! Next, we’ll create an Azure container registry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063), we not only created a library
    to write to Azure Cosmos DB but also to SQL Server. With Microsoft Azure, you
    can also configure Azure SQL Database. Just be aware of the low cost in the development
    environment; select a **Database Transaction Unit** (**DTU**) tier instead of
    the vCore tier. With 5 Basic DTUs, there’s just a cost lower than USD 5, for a
    month for 2 GB storage (at the time of this writing) compared to USD 400,- where
    a VM with 2 vCores is allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure container registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we created Docker images and used them locally. You
    can publish Docker images to the Docker hub, or any container registry. ACR offers
    a registry for Docker images that greatly integrates with Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'While creating an ACR instance, three different tiers are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`codebreaker` application, the Basic tier (SKU) fits the purpose and is a lot
    cheaper than the other options. You just need to be aware of the limits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard**: The Standard tier offers more storage (the Basic tier is limited
    to 10 GB storage) and image throughput.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Premium**: The Premium tier adds some features, such as geo-replication replicates
    images across different regions and private access points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 6**.3* shows how to create an ACR instance via the portal. Clicking
    on `Container Registry` in the search box. Selecting the **Azure services only**
    checkbox doesn’t show the many third-party offerings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Creating a container registry](img/B21217_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Creating a container registry
  prefs: []
  type: TYPE_NORMAL
- en: With the configuration, we just need the name of the resource group, the name
    of the registry, the location, and the SKU. Availability zones, where the images
    are stored in different data centers in the same region, are only available with
    the Premium tier. Other configurations to change the networking and encryption
    require the Premium tier as well.
  prefs: []
  type: TYPE_NORMAL
- en: Filling out this form, after clicking **Review + create**, you still can verify
    all the options before clicking **Create** to create the resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The name of the registry is a globally available DNS name (with the `azurecr.io`
    extension) and thus needs to be unique. Choose your own name where creating the
    resource succeeds with an available name.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a database and a registry for container images running. With the
    first resources created, all we need to run the application in the cloud is a
    compute service where we can run the Docker images. We will use Azure Container
    Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Container Apps environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Azure has several compute offerings to run Docker containers. You
    can publish a Docker image to an **Azure app service**, and use a Windows or Linux
    server to run your APIs. Another option is to use **Azure Container Instances**
    (**ACI**), which allows you to host a group of Docker containers, including one
    frontend container (the API service) and multiple backend containers. While Azure
    app services offer automatic scaling to create multiple instances based on rules,
    this feature is not available with ACI. ACI is great with a fast startup – you
    spin up a VM where just the smaller Docker image needs to be uploaded, but it
    doesn’t offer orchestration and scaling features.
  prefs: []
  type: TYPE_NORMAL
- en: For full-blown orchestration and scaling of Docker containers, Azure offers
    `kubectl`. To remove the complexity of Kubernetes, defining an Ingress controller
    is just a matter of changing some settings; **Azure Container Apps** instances
    are available. This service makes use of Kubernetes behind the scenes but removes
    a lot of its complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get into creating an Azure container app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Log Analytics workspace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating an Azure container app, having space for logging is a good idea.
    With previous versions of Azure Container Apps, it was a requirement to have a
    **Log Analytics workspace**. This is no longer a requirement, as you can also
    use Azure Monitor to log to an Azure storage account, an Azure event hub, or a
    third-party monitoring solution. Azure Monitor can also be configured to route
    logs to Log Analytics.
  prefs: []
  type: TYPE_NORMAL
- en: A Log Analytics workspace is a storage unit for log data to analyze data and
    metrics. In [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239), *Logging*, we’ll
    dive into logging and metrics with microservices, and make use of Log Analytics,
    Azure Monitor, and Application Insights to get information about running services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Log Analytics workspace, we will use the Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Log Analytics belongs to Azure Monitor, thus the `az monitor log-analytics`
    command is used to create and manage Log Analytics. With the `workspace create`
    subcommand, a Log Analytics workspace is created. This command requires the resource
    group and the name of the workspace. If the location is not supplied with the
    command, the workspace uses the same location as the resource group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container app environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a container app environment uses a Kubernetes cluster behind the scenes.
    You can create this environment to create a Log Analytics workspace automatically.
    Using an existing workspace (we created one in the previous step), we need the
    customer ID and a key from the workspace. Get the customer ID using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Without supplying `--query customerId`, you get more complete information about
    the workspace, including the `customerId` value. Using the `--query` command,
    we can supply a `customerId` with the query, just the unique identifier of this
    id (a GUID) is returned. Copy this GUID as well as the key from the next command
    as we’ll need these values when creating the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command returns keys to connect to the log workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output returns primary and secondary shared keys. Copy the primary shared
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the customer ID as well as the key from the Log Analytics workspace,
    we can create a container app environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To create the environment, you need to specify the resource group, the name
    of the environment, information to connect log analytics, as well as the location
    of the newly created resource. This command does not use the location of the resource
    group if the location is not supplied. Be aware that this command might take several
    minutes. But think about how many minutes you would need to create a Kubernetes
    cluster manually.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hello container app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After creating the environment, let’s create our first app within this environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using the `create` command creates a new app. The name of this app is specified
    with the `-n` parameter. The environment is specified with the resource group
    (`-g`) and the `--environment` parameter. The image referenced with the `--image`
    parameter is a sample Docker image from Microsoft that hosts a web server with
    a static page. To access the web server running on port 80 within the container,
    the Ingress service is configured with the `--ingress` and `--target-port` parameters.
    Using the `--min-replicas` and `--max-replicas` parameters, scaling is defined
    to scale from 0 up to 2 instances. With 0 instances, the first user accessing
    the service needs to wait until the container is started. With the supplied configuration,
    the application scales up to 2 running containers. One container allocates 0.5
    CPUs and 1.0 Gi memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapters 9* to *11* will give you information about scaling services. In [*Chapter
    9*](B21217_09.xhtml#_idTextAnchor216), you’ll create load tests to stress-test
    services, in [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239), we’ll use these
    load tests to monitor metrics information, and in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263),
    we’ll configure scaling with information learned in the previous two chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the app is created, a link for the app service is shown. You can also
    get the URL using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `containerapp show` command shows properties of the Azure container app.
    Using the `properties.configuration.ingress.fqdn` JMESPath query returns the `https://`
    instance shows the running application (see *Figure 6**.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Accessing the hello Azure container app](img/B21217_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Accessing the hello Azure container app
  prefs: []
  type: TYPE_NORMAL
- en: Now, opening the `rg-codebreaker-test` resource group with the Azure portal,
    we can see the Azure Cosmos DB, ACR, and Azure Container Apps environments, the
    Log Analytics workspace, and the container app, as shown in *Figure 6**.5*. Just
    check the options you have with the categories on the left side of the **Resource
    group** view. The **Overview** view shows the resources, as shown here. Clicking
    on **Access control**, you can configure who has access to the resources of this
    group. The *activity log* shows who created, updated, and deleted resources within
    this group. The *resource visualizer* gives a graphical view of resources and
    how they relate to each other. The **Cost Management** category might also be
    of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might need to wait for a day before seeing the detailed cost of each resource.
    With the tiers we used, the cost will be within a few cents. But you can also
    click on **Recommendations** to see what should be changed and configured with
    a production environment. Some of these recommendations require different tiers
    where you need to check into the cost changes. In case your company already experienced
    hacking into the company’s site, the cost of turning security features on with
    Microsoft Azure is really low compared to the cost of a hacking attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Resource group with Azure resources](img/B21217_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Resource group with Azure resources
  prefs: []
  type: TYPE_NORMAL
- en: Now, as the Azure resources are created, let’s publish the `codebreaker` services
    to Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with creating an Azure Cosmos database within an Azure Cosmos DB
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Cosmos database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Azure portal, you can open the page for your Azure Cosmos DB account,
    open **Data Explorer**, and from there, click on **New Database** to create a
    new database, and **New Container** to create a container within the database.
    Here, we’ll use the Azure CLI instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a database named `codebreaker` in the existing account.
    Setting the throughput option with this command defines the scale of the database.
    Here, all containers within this database share the 400 RU/s throughput. 400 is
    the smallest value that can be set. Instead of supplying this value when creating
    the database, scaling can also be configured with every container. In case some
    containers should not take away scaling from other containers, configure the RU/s
    with every container – but here, the minimum value to be used with each container
    is 400 as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the database, let’s create a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `gamesAPI` service uses a container named `GamesV3`.
    This container is created within the previously created database, using the `/PartitionKey`
    partition key, as was specified with the EF Core context in [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this command is completed, check **Data Explorer** in the Azure portal,
    as shown in *Figure 6**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Data Explorer](img/B21217_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Data Explorer
  prefs: []
  type: TYPE_NORMAL
- en: You can see the database, the container, and, with the container, the configured
    partition key.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring replication with Azure Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A great feature of Azure Cosmos DB is global data replication. Within the Azure
    portal, in the **Settings** category, click on **Replicate data globally**. *Figure
    6**.7* shows the replication view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Replication with Azure Cosmos DB](img/B21217_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Replication with Azure Cosmos DB
  prefs: []
  type: TYPE_NORMAL
- en: You just need to click on the Azure regions that are available with your subscription
    to replicate data within the selected regions. You can also configure it to write
    to multiple regions.
  prefs: []
  type: TYPE_NORMAL
- en: With the `codebreaker` application where users around the world can play, for
    faster performance for users in the US, Europe, Asia, and Africa, writing to multiple
    regions can be configured. For this option to be available, automatic scaling
    cannot be configured. For the best scalability across the globe, we also need
    to think about the partition key. By using different partition key values for
    every game that’s stored, games can be stored within different partitions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring consistency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the **Settings** category in the Azure portal of Azure Cosmos DB, we can
    configure the default consistency level. The outcomes are shown using music notes,
    reading, and writing from multiple regions, as shown in *Figure 6**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Outcome shown using music notes](img/B21217_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Outcome shown using music notes
  prefs: []
  type: TYPE_NORMAL
- en: The default setting is **Session consistency** – the data is consistent within
    the same session. With this setting, write latencies, availability, and read throughput
    are comparable to **Eventual consistency**. Using the Azure Cosmos DB API, a session
    can be created and distributed within the application.
  prefs: []
  type: TYPE_NORMAL
- en: The **Strong consistency** option is not available if multiple regions are configured.
    With multiple regions, **Bounded staleness** can be configured, which specifies
    a maximum lag time and a number of maximum lag operations before the data is consistently
    replicated.
  prefs: []
  type: TYPE_NORMAL
- en: The database is now ready to use, so let’s publish Docker images to the registry!
  prefs: []
  type: TYPE_NORMAL
- en: Pushing images to the ACR instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ACR instance is ready, and we created Docker images in the previous chapter
    – now, let’s publish the images to this registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve logged in to Microsoft Azure (using `az login`), to log in to
    the ACR instance, you can use `az acr login`. Make sure to use the name you defined
    with the ACR instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command needs to have Docker Desktop installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the ACR instance using the Azure CLI, just the name of the registry
    is needed (such as `codebreakertest`). The `docker` and `dotnet` commands support
    different registries, thus with these commands, the complete domain name is needed,
    such as `codebreakertest.azurecr.io`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s build the images. With the game APIs, we created a Dockerfile in
    the previous chapter. With the Windows terminal, make sure to set the current
    directory to the `ch06` folder and build the game image locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command – as in the previous chapter – builds the Docker image locally,
    referencing the Dockerfile, setting the context for `docker build`, and setting
    the tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish the image to ACR, we need to tag the local images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The images are tagged with a link to the ACR instance. The same image is tagged
    with the version number as well as the `latest` tag. The `latest` tag is a convention
    where the newest version is stored and is always overridden in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, push the image to the registry with `docker push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you are already logged in to the ACR instance; otherwise, the push
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a successful push, you can see the images in the Azure portal within the
    **Repositories** menu, as shown in *Figure 6**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Repositories in ACR](img/B21217_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Repositories in ACR
  prefs: []
  type: TYPE_NORMAL
- en: 'With the bot service, we didn’t create a Dockerfile in the previous chapter
    and used the dotnet CLI instead. Using `dotnet publish`, we just need to add this
    `PropertyGroup` instance to the project file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Bot/Codebreaker.Bot.csproj project file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `dotnet publish` command uses `ContainerRegistry`, `ContainerRepository`,
    and `ContainerImageTags` elements to create the image and publish it to the registry.
    Pay attention to configuring your own registry with the `ContainerRegistry` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that needs to be done with the current directory is to set the directory
    of the project file of the bot and run `dotnet publish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command builds the image and directly publishes it to the registry, as
    specified with the `ContainerRegistry` element. Just make sure to enter the link
    to your registry, and be logged in using `docker login`.
  prefs: []
  type: TYPE_NORMAL
- en: As the images are ready, let’s continue using them with Azure container apps!
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure container apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a `gamesAPI` service running with an Azure container app. This
    one needs a configuration containing a secret to the Azure Cosmos database.
  prefs: []
  type: TYPE_NORMAL
- en: With the Azure Cosmos database, in the Azure portal, go to the **Settings**
    category and open **Keys**. From this page, copy the primary or the secondary
    connection string.
  prefs: []
  type: TYPE_NORMAL
- en: With such keys, it’s useful to regenerate them from time to time – that’s why
    pairs are available. When you use the primary key from apps, regenerate the secondary
    key. After the regeneration, use the secondary key from within the apps, and regenerate
    the primary key. With this, you have some time to configure all the apps for the
    new key.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an Azure container app for game APIs, there are quite some values
    to configure. While you can pass all the configuration values to the `az containerapp
    create` command, let’s start creating this with the Azure portal. Opening the
    resource of the Azure container app environment, click on **Apps**, and create
    a new app. *Figure 6**.10* shows the basic settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Basic settings for the Azure container app](img/B21217_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Basic settings for the Azure container app
  prefs: []
  type: TYPE_NORMAL
- en: 'With the basic settings, these values need to be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: The subscription for the resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource group (`rg-codebreaker-test`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the container app. We use `cae-codebreaker-gamesapi-3`. The suffix
    3 names version 3 of this API. You can run different versions of this app in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The region – select the region that best fits your location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container app environment. Select the environment created earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration screen for the container app is shown in *Figure 6**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Container settings for the Azure container app](img/B21217_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Container settings for the Azure container app
  prefs: []
  type: TYPE_NORMAL
- en: Here, we select the image that will be published by selecting the ACR instance
    and the image name and tag, the CPU and memory resources that should be allocated
    for one running instance, and environment variables. Setting the `DataStorage`
    environment variable to `Cosmos` overrides the values defined in the `appsettings.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.12* shows the **Ingress** configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Ingress settings for the Azure container app](img/B21217_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Ingress settings for the Azure container app
  prefs: []
  type: TYPE_NORMAL
- en: We need to enable `8080`, as defined by the .NET 8 images.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on **Create** creates the Azure container app by getting the image
    from the ACR instance. Be aware that starting the app will fail, as the connection
    string to the Cosmos database still needs to be configured. We will do this after
    creating the app for the bot service.
  prefs: []
  type: TYPE_NORMAL
- en: To create the app for the bot service, open the newly created container app
    in the Azure portal, and copy the *application URL* from the **Overview** view.
    This URL is needed for the configuration of the bot.
  prefs: []
  type: TYPE_NORMAL
- en: When creating an app for the bot service, you can configure it similarly to
    the game APIs. The `codebreaker/bot` image. Create an environment variable with
    the name `ApiBase`, and the value with the application URL from the game APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to add some configuration values, which we’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring secrets and environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining secrets for the application is not directly possible with the portal
    when creating the app. This would be possible directly using the `az containerapp`
    `create` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the portal, the secret can be configured afterward. When opening the container
    app within the Azure portal, in the `cosmosconnectionstring`, as shown in *Figure
    6**.13*, and copy the connection string you copied from Azure Cosmos DB to the
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot in *Figure 6**.13* shows another option where secrets can be
    stored: a Key Vault reference. In [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162),
    we’ll discuss using other options to use configurations, which include **Azure**
    **Key Vault**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Secret configuration with the Azure container app](img/B21217_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Secret configuration with the Azure container app
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an environment variable that references the secret, we can use the
    Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the `az containerapp update` command, we need to reference the container
    app and the resource group and set environment variables using `--set-env-vars`.
    Contrary to passing hierarchical configuration values to the command line where
    `:` is used as a separator, such as `ConnectionStrings:GamesCosmosConnection`,
    with environment variables, using `:` is not possible. Instead, here, `__` maps
    values. The key that’s specified for the connection to the Azure Cosmos DB instance
    is `ConnectionStrings__GamesCosmosConnection`. The value for this is stored in
    a secret. A secret is referenced with `secretref`, followed by the secret key.
  prefs: []
  type: TYPE_NORMAL
- en: The application should be running now, but let’s make sure to configure scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring scaling with Azure Container Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default scaling configured with Azure Container Apps is scaling from 0 to
    10\. If no load is on the app, it scales down to 0 where CPU and memory costs
    are reduced to zero. However, scaling to 0 also means that the first user accessing
    the service needs to wait for a few seconds before the service returns results.
    With the bot service that’s running in the background and doesn’t need some user
    interaction after the first invocation, this can be fast enough. With app jobs
    that are triggered from messages or events, this is also OK. However, with the
    `gamesAPI` service, this should be responsive for the first user accessing the
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the minimum scale to 1 has a reduced price for the CPU if there’s
    no load. With idle pricing, the memory doesn’t have a price difference, but the
    CPU is about 10% of the cost compared to a running service.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure the `gamesAPI` service to scale from 1 to 3 replicas, and the
    bot service to scale from 0 to 3\. Within the Azure portal, select the container
    app, the **Applications** category, and the **Scale and replicas** menu. Click
    the **Edit and deploy** menu, select **Scale**, and change the replicas to 1 to
    3 and to 0 to 3 depending on the app. In case the UI elements are not easily movable
    to change the values accordingly, you can use the arrow keys to change the values
    one by one. The maximum scale count (at the time of this writing) is 300.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on **Create** does a redeploy and creates a new revision of the app.
    By default, only one revision is active at a time. As soon as the new revision
    successfully starts up, the load balancer moves 100% of the traffic to the new
    revision. With the **Applications** | **Revisions** menu, you can see active and
    inactive revisions. There, you also can configure the revision mode. The default
    revision mode is **Single**, where just one revision is active. You can change
    this to **Multiple**, where several revisions are running concurrently, and you
    can configure how much percentage of the traffic should be distributed to which
    revision. This can be useful to test different versions running on a user load.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, let’s try to run the application. You can open the Swagger
    page of the bot to let the bot play some games. You can also use a client you
    created in [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092), configure the address
    with the Container App game API’s URL, and play a game. Check into the **Data
    Explorer** section of Cosmos DB to see the games stored.
  prefs: []
  type: TYPE_NORMAL
- en: As you now know all the Azure services used in the first place, you can delete
    Azure resources and recreate them easily in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure resources with .NET Aspire and azd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we’ll look into how to easily create Azure resources from the development
    system. First, we use some resources from the Azure cloud, while most of the projects
    are running locally on the development system, before we publish the complete
    solution to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning Azure resources while debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating API services and using databases, you might not need any Azure
    resources when debugging the application locally. The API can run locally; even
    building Docker images is not required here. To run the database, a Docker image
    can be used easily, as you’ve already seen in [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110).
    However, for some Azure resources that you might also use during development,
    creating and connecting Azure resources is required. One example is Azure Application
    Insights (which is covered in detail in [*Chapter 8*](B21217_08.xhtml#_idTextAnchor183)).
  prefs: []
  type: TYPE_NORMAL
- en: To use Azure resources with the application map in the `AppHost` project, you
    need to add the `A``spire.Hosting.Azure.* packages`. To use Azure resources to
    define the app model, packages such as `Aspire.Hosting.Azure` and `Aspire.Hosting.Azure.cosmosDB`
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provisioning of Azure resources happens automatically when the Azure resources
    are specified with the app model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddAzureProvisioning` method creates Azure resources or retrieves the
    connection string when starting the application. Before this can successfully
    run, you need to specify your subscription ID and the location where the resources
    are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This information should not be part of the source code repository, thus add
    it to the user secrets. The `SubscriptionId` and `Location` keys need to be specified
    within the `Azure` category. Adding a *CredentialSource* is optional. The user
    to create the resources is selected using the DefaultAzureCredential (see [*Chapter
    7*](B21217_07.xhtml#_idTextAnchor162) for details). In case this is not working
    in your environment, you can configure AzureCli which uses the account you are
    logged in with the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the subscription ID, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You need to be logged in to your subscription not only to see the subscription
    ID but also to deploy the resources automatically. After running the application,
    you can see the deployed resources are written to the user secrets as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This app model defines provisioning and using the Azure Cosmos DB database
    without using the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To avoid the need to install and run the local Azure Cosmos DB emulator, and
    to get rid of some issues using Azure Cosmos DB in the Docker image, we can use
    Azure Cosmos DB in the cloud. Not using the `RunAsEmulator` method with `AddAzureCosmosDB`,
    we use the resource running in Azure. The `AddDatabase` method adds the `codebreaker`
    database to the account. The `Codebreaker.CosmosCreate` project is used to run
    once, invoking the `EnsureCreatedAsync` method of the EF Core context to create
    a container with the partition key. The `WithReference` method used both with
    the `gamesAPI` service and the `CosmosCreate` project passes the newly created
    Azure Cosmos DB connection string to these resources. The `WithExternalEndpoints`
    method configures the Ingress controller of the Azure App Configuration to make
    this service external available.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6**.14* shows the .NET Aspire dashboard with the application running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – .NET Aspire dashboard with deployed Azure resources](img/B21217_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – .NET Aspire dashboard with deployed Azure resources
  prefs: []
  type: TYPE_NORMAL
- en: The `codebreakercosmos` resource shows an endpoint with the `deployment` link
    text. This is a resource deployed to Azure. Clicking this link, you are directly
    navigated to this cloud resource and can check the database and container name
    are created. The `cosmoscreate` reference is in the **Finished** state, thus the
    creation of the container is done.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s start the bot and let it run some games, then open **Data Explorer**
    with Azure Cosmos DB, and you’ll see the games created. You can debug the solution
    locally while using some of the resources in the cloud, just by adding one API
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The resource group created here uses the name `rg-aspire-{yourhost}-codebreaker.apphost`.
    If multiple developers use the same Azure subscription, resources are created
    independently of each other to not get into conflicts. Make sure to delete resources
    when not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create the complete solution to run with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning the complete solution with azd up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this, we use `azd`. First, in the directory of the solution, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This initializes an application to be used with `azd`. You can use a template
    to create a new solution or analyze an existing application. As we already have
    a running application, select `Use code in the current directory` to analyze the
    application. The application needs to be stopped because `azd` also starts the
    compilation. With a successful scan, `azd` informs to host the app using `bot`
    and `gamesAPI` services. Then, define an environment (for example, `codebreaker-06`)
    using a chapter suffix.
  prefs: []
  type: TYPE_NORMAL
- en: What happened? This command created a `.azure` folder and `azure.yaml` and `next-steps.md`
    files. `next-steps.md` gives information about what you can do next. `azure.yaml`
    is a short file containing information that references the `AppHost` project running
    with a `containerapp`. The most interesting generated information can be found
    in the `.azure` folder. This folder is excluded from the source code repository
    as it can contain secrets. In this folder, you can see the environments that are
    configured, as well as the configuration about which services should be public.
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish the complete solution to Azure, just use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the first run, you need to select the Azure subscription to deploy the
    resources to, and the location for the Azure region. Next, you just need to wait
    several minutes until all the resources have been deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the provisioning phase, these resources are deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: A resource group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Log Analytics workspace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Container Apps environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the provisioning phase, the deployment phase starts with these actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing Docker images to the ACR instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating container apps in the Container Apps environment using the images from
    the ACR instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you make any changes to the source code or the configuration, you just need
    to use `azd up` again to deploy the updates. As the created environment is no
    longer needed, use `azd down` to delete all the resources again. Make sure to
    wait until you are asked for verification as to whether the number of resources
    should really be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the resource group within the Azure portal, you can see all resources
    created, as shown in *Figure 6**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Resources created from azd up](img/B21217_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Resources created from azd up
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can check the resources deployed, the images published to the container
    registry, the applications published to the container apps environment, the key
    vault containing a secret, and the Azure Cosmos DB account with the database and
    the configured container. Let the bot play games and verify if everything is running.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s get into the details of what happened with `azd up`.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into azd up stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the `AppHost` project, command-line arguments can be passed to create
    a manifest file describing all the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When using `dotnet run`, command-line arguments can be passed to the application
    by using `--` to differentiate from the arguments of `dotnet run`. Using the -`–publisher
    manifest` option creates an Aspire manifest describing the app model of the application.
    This manifest specifies all resources with the resource type, bindings, environment
    variables, and paths to the projects. This information is used by `azd` to create
    Azure resources and can be used from other tools to, for example, deploy the solution
    to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `azd provision` is used. In case you just want to provision Azure resources
    without pushing Docker images and deploying the Azure container apps, use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`azd provision` uses the manifest file to create Bicep files in memory and
    creates Azure resources.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use this command when any Azure resources are added to the app model,
    then just these resources are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`azd deploy` pushes the container images to the ACR instance using `dotnet
    publish`, and then creates or updates Azure resources using these images.'
  prefs: []
  type: TYPE_NORMAL
- en: '`azd up` creates Bicep scripts in memory. It’s also possible to create Bicep
    scripts on disk to use them to create Azure resources, as we’ll do next.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Bicep files using azd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bicep is a domain-specific language using declarative syntax. Before Bicep was
    available, we created **Azure Resource Manager** (**ARM**) templates to create
    Azure resources. ARM templates are defined using JSON. Bicep is simpler to write
    than ARM templates. During deployment, Bicep files are converted to ARM templates.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `azd infra` to create Bicep files for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, `azd infra` is in an early stage. Check the README
    file of this chapter for updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start this command from the directory of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates an `infra` folder with these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main.bicep` – The main bicep file that creates a resource group and references
    modules to create more resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main.parameters.json` – A parameters file that is used to pass parameters
    such as the environment name and the location to the `main.bicep` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.bicep` – This file is referenced by `main.bicep` and contains resources
    such as the ACR instance, the Log Analytics workspace, the Container Apps environment,
    and the Azure key vault that are created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`codebreakercosmos/codebreakercosmos.bicep` – This file is referenced from
    `main.bicep` as well and contains resource information for Azure Cosmos DB, as
    well as an Azure Key Vault secret that’s written to the Azure key vault. The secret
    itself is not part of this file; the secret is retrieved dynamically from the
    Azure Cosmos DB account when creating this resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you customize these generated Bicep files, the customized files are
    used by `azd up` or `azd provision` on creating the Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: With the `bot` and `gamesAPI` projects, `azd infra` also creates an infra folder
    with template files in the AppHost project; for example `gameapis.tmpl.yaml`.
    With these files, the Azure Container Apps instances can be customized; for example,
    by changing CPU and memory sizes or changing the number of replicas that should
    be used. Changing these values, `azd up` or `azd deploy` makes use of these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open the resource group you previously created with `azd up`, open
    **Deployments** in the **Settings** category. This shows deployments of the resource
    group, as shown in *Figure 6**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Deployments](img/B21217_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Deployments
  prefs: []
  type: TYPE_NORMAL
- en: The deployments match the Bicep files used. When you open **Related events**,
    you can see all the steps that have been done with these deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you don’t need the resources anymore, use this command to delete all
    the resources again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This tool retrieves the number of Azure resources to delete and asks if this
    should be done – thus, make sure to wait until you can answer yes. After the deletion
    of the resources is complete, which usually takes more than 10 minutes, another
    question is asked if the data from the key vault should be purged. If you don’t
    answer yes to this question, this data can be recovered for 90 days, and during
    that time you cannot create the resource with the same name again until the end
    of this recovery time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned to create Microsoft Azure resources using the Azure
    CLI, the Azure portal, and .NET Aspire with `azd`. The `gamesAPI` service is now
    running with Microsoft Azure resources using ACR, Azure Container Apps, and the
    Azure Cosmos DB database. When using `azd` together with .NET Aspire, just one
    command was needed to deploy all the services.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the next chapter, let’s configure the client application
    you used in previous chapters to now use the URL from the Azure container app
    instead of the local services, and play some games.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the Azure key vault was already created. In the next chapter,
    we look into the configuration of the backend services, which includes Azure Key
    Vault, and use Azure App Configuration as a central place for the configuration
    of all `codebreaker` services.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure round-trip latency statistics with Azure regions: [https://learn.microsoft.com/azure/networking/azure-network-latency](https://learn.microsoft.com/azure/networking/azure-network-latency)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB – databases, containers, and items: [https://learn.microsoft.com/azure/cosmos-db/resource-model](https://learn.microsoft.com/azure/cosmos-db/resource-model)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stored procedures, triggers, and user-defined functions: https://learn.microsoft.com/azure/cosmos-db/nosql/how-to-write-stored-procedures-triggers-udfs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Apps: [https://learn.microsoft.com/azure/container-apps/](https://learn.microsoft.com/azure/container-apps/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bicep: https://learn.microsoft.com/azure/azure-resource-manager/bicep'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azd` reference: [https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference](https://learn.microsoft.com/en-gb/azure/developer/azure-developer-cli/reference)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
