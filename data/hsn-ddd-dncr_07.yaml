- en: Consistency Boundary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致性边界
- en: In monolithic systems, everything seems to be fully consistent. To achieve consistency,
    a lot of logic is **outsourced** to the database engine and becomes implicit,
    hard to figure out at a glance, and hard to test. Database transactions are frequently
    used to ensure that multiple-state mutations are executed at once. If the data
    becomes inconsistent, that usually means failure, and that requires an extensive
    investigation to fix the issue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体系统中，一切似乎都是完全一致的。为了实现一致性，大量的逻辑被**外包**给数据库引擎，变得隐含，一眼难以看出，难以测试。数据库事务经常被用来确保一次执行多个状态变更。如果数据变得不一致，通常意味着失败，这需要广泛的调查来解决问题。
- en: '**Domain-Driven Design** (**DDD**) means avoiding complex graphs of entities.
    Instead, developers need to find a minimal logical set of entities that belong
    together and therefore need to be updated together to ensure consistency. Such
    a group of entities is called an **aggregate**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）意味着避免实体复杂图。相反，开发者需要找到一组最小逻辑实体，这些实体属于一起，因此需要一起更新以确保一致性。这样一组实体被称为**聚合**。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Command handling as a unit of work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令处理作为工作单元
- en: Consistency and transactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性和事务
- en: Aggregates and aggregate root patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合和聚合根模式
- en: Constraints and invariants
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约束和不变性
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the `Chapter07` folder of the book
    repository on GitHub. Since we aren't using any infrastructure components yet
    (we will start using some in the next chapter), you still need nothing other than
    the IDE or code editor. The code in the repository represents the final version
    for the chapter, and if you want to follow along, you can use the previous chapter
    code as a starting point.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上书籍仓库的`Chapter07`文件夹中找到。由于我们还没有使用任何基础设施组件（我们将在下一章开始使用一些），你仍然只需要IDE或代码编辑器。仓库中的代码代表章节的最终版本，如果你想跟上，你可以使用上一章的代码作为起点。
- en: Domain model consistency
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域模型一致性
- en: 'When it comes to modeling, we often hear that data models need to be at the
    center of any system. *If you want a good system, you need a good data model*.I
    have heard that saying countless times in my career as a software engineer. One
    of my colleagues once said this, and then added: "*I participated in a large project
    where we started with defining the data model, and, after eighteen months, the
    project was shut down because the model wasn''t complete*." Strangely, these two
    statements created no causal relationship for him, since the first statement was
    an axiom, and the project failure seemed to be caused by numerous reasons, but
    not by the fact that designing a single data model for complex systems is always
    a death march—many tables, directly and indirectly, connected to one another by
    foreign keys, an endless push for the third normal form to avoid data duplication
    that results in heavy queries to retrieve a meaningful set of data—these are the
    realities of taking this approach.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到建模时，我们经常听到数据模型需要成为任何系统的中心。*如果你想有一个好的系统，你需要一个好的数据模型*。我在作为软件工程师的职业生涯中无数次听到这句话。我的一个同事曾经说过这句话，然后补充说：*我参与了一个大型项目，我们一开始就定义了数据模型，经过十八个月后，项目被关闭，因为模型不完整*。奇怪的是，这两句话对他来说没有造成任何因果关系，因为第一句话是一个公理，而项目失败似乎是由许多原因造成的，而不是因为为复杂系统设计单个数据模型总是死亡行军——许多表，通过外键直接和间接地连接在一起，无尽地追求第三范式以避免数据重复，导致检索有意义数据集的查询变得非常复杂——这些都是采取这种方法的现实。
- en: If we create a data model first and then try to create our code around it, it
    is very hard to understand why some rules are being enforced, why those columns
    in that table are mandatory, and why one table has a many-to-many relationship
    with another table. These relationships are also hard to test, and even if we
    have tests, we can only run them if we have a properly configured database with
    a pre-populated set of data, so our tests are also becoming database-oriented.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先创建数据模型，然后尝试围绕它创建代码，那么很难理解为什么某些规则被强制执行，为什么那些表中的列是强制性的，以及为什么一个表与另一个表之间存在多对多关系。这些关系也很难测试，即使我们有测试，我们也只能在有一个正确配置的数据库和预填充数据集的情况下运行它们，因此我们的测试也变得以数据库为中心。
- en: DDD advocates a different approach when the domain model is essentially detached
    from the persistence, and it is primarily designed to serve specific business
    rules. When we deal with domain models, we pursue different goals with the design.
    We need to encapsulate just enough information in our classes so we can ensure
    that our model keeps being consistent after any state transition. The kind of
    consistency we mean there is not the relational database consistency that can
    be **outsourced **to the database engine. Instead, we want to ensure that our
    objects cannot violate the rules that are defined by the business, and these rules
    need to be explicitly defined in code. Let's look at what kind of principles we
    can apply, and how we can define different types of consistency boundaries in
    a domain model-centric design approach.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当领域模型本质上与持久化分离，并且主要设计用于服务特定的业务规则时，DDD 倡导一种不同的方法。当我们处理领域模型时，我们的设计目标是不同的。我们需要在我们的类中封装足够的信息，以确保我们的模型在任何状态转换后都能保持一致性。我们这里所说的这种一致性不是可以**外包**给数据库引擎的关系数据库一致性。相反，我们希望确保我们的对象不会违反由业务定义的规则，并且这些规则需要显式地在代码中定义。让我们看看我们可以应用哪些原则，以及我们如何在以领域模型为中心的设计方法中定义不同类型的边界。
- en: Transaction boundaries
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务边界
- en: As we discussed before, commands express the intent of a user to do something
    with the system. It could be the case that command comes from another system or
    even from a timer, but it still expresses some intent. Before the command is handled,
    our domain model finds itself in a valid state. When the command is handled, the
    domain model should also be in a valid state. This can be a new state if the command
    handling resulted in an operation being executed, or the same state as before,
    if the command handling has failed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，命令表达了用户对系统进行某种操作的意图。可能命令来自另一个系统，甚至来自计时器，但它仍然表达了某种意图。在处理命令之前，我们的领域模型处于一个有效状态。当命令被处理时，领域模型也应该处于一个有效状态。这可能是一个新状态，如果命令处理导致执行了操作，或者与之前相同的状态，如果命令处理失败。
- en: 'Let''s look at the code for handling commands that we created in the previous
    chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在上一章中创建的命令处理代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a generic handler for any operation that does not create a new instance
    of the `ClassifiedAd` entity and doesn''t remove an existing instance. The only
    reason we were able to generalize the command handling like this was because all
    the commands are handled in a similar fashion:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个针对任何不创建 `ClassifiedAd` 实例的新实例且不删除现有实例的操作的通用处理程序。我们之所以能够这样泛化命令处理，仅仅是因为所有命令都是以类似的方式处理的：
- en: Retrieve an entity from the store by means of the entity ID
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实体 ID 从存储中检索实体
- en: Execute an operation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个操作
- en: Commit changes back to the store
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改提交回存储
- en: If the operation fails, or the store cannot find anything by a given ID, the
    handler will throw an exception.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作失败，或者存储无法通过给定的 ID 找到任何内容，处理程序将抛出异常。
- en: For this chapter, the most important thing in the preceding code and in this
    list of steps that are performed when our application service is handling commands
    is that we execute an operation on *one single entity* only.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，前述代码和在我们应用程序服务处理命令时执行的一系列步骤中，最重要的是我们只对**单个实体**执行操作。
- en: Let's look at why this is so, and, for this purpose, we need to reflect on a
    very common way of implementing business applications, where the database is the
    center of everything that the application does. We will use the e-commerce domain
    as an example since it is reasonably complex and the code won't interfere with
    our ongoing work with the `Marketplace` application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么会有这种情况，为此，我们需要反思一种非常常见的实现业务应用的方式，即数据库是应用所做的一切的中心。我们将以电子商务领域为例，因为它相对复杂，代码不会干扰我们与
    `Marketplace` 应用当前的工作。
- en: 'If you have several year''s experience of developing software in .NET, you
    might have seen many codebases with methods such as this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多年的 .NET 软件开发经验，你可能见过许多包含此类方法的代码库：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the controller seems to be completing a single logical operation, and
    it might look like a command handling directly in the HTTP endpoint request-handling
    method. The operation seems to be isolated and concise. To be honest, during my
    career, I have seen much worse code, where one request of a user results in many
    unrelated database operations, but let's stick to this example since it seems
    quite reasonable at first. So, this code uses the **unit of work** pattern, and
    `DbContext` of the entity framework wrapped in the `using` block implements this
    pattern perfectly because it accumulates all changes in the database elements
    and commits those changes all at once when we call `context.SaveChangesAsync()`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，控制器似乎在完成一个单一的逻辑操作，它可能看起来就像直接在HTTP端点请求处理方法中处理命令。操作似乎是隔离和简洁的。说实话，在我的职业生涯中，我见过很多更糟糕的代码，其中用户的单个请求会导致许多无关的数据库操作，但让我们坚持这个例子，因为它一开始看起来相当合理。所以，这段代码使用了**工作单元**模式，并且封装在`using`块中的`DbContext`实现了这个模式，因为它将所有更改累积在数据库元素中，并在我们调用`context.SaveChangesAsync()`时一次性提交这些更改。
- en: 'Let''s look at the data model that is associated with this code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与这段代码相关的数据模型：
- en: '![](img/1aeaf441-0fd5-4dda-b8d3-14f356eecca4.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1aeaf441-0fd5-4dda-b8d3-14f356eecca4.png)'
- en: Simplified eCommerce data model
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的电子商务数据模型
- en: 'Of course, we could expect a lot more tables in the overall model. It could
    include things such as `Product`, `Supplier`, and `Shipment`. For our purposes,
    it is enough to have these four tables only. These tables all have relations to
    other tables, and those relations are all one-to-many (or zero-to-many). Our Entity
    Framework model uses an object reference between `Order` and `Customer`. This
    kind of reference is very popular when using ORM frameworks because it brings
    convenience to developers. We can access the `Customer` object that is associated
    with a particular order just by using the `order.Customer` property and modify
    any of the `Customer` properties as we wish, and this is exactly what the code
    does. It changes properties for both the order and the customer in one logical
    operation. This operation needs to either complete entirely, or fail. We cannot
    tolerate the fact that the customer''s credit amount gets decreased but the order
    remains unpaid. Such behavior is typically associated with database transactions.
    A transaction is characterized by four principles, known as **ACID**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可能期望在整体模型中有更多的表。它可能包括像`Product`、`Supplier`和`Shipment`这样的东西。对于我们来说，只有这四个表就足够了。这些表都与其他表有关，而这些关系都是一对一（或零对多）。我们的Entity
    Framework模型使用`Order`和`Customer`之间的对象引用。这种引用在ORM框架中使用时非常流行，因为它给开发者带来了便利。我们可以通过使用`order.Customer`属性来访问与特定订单关联的`Customer`对象，并按我们的意愿修改任何`Customer`属性，这正是代码所做的。它在一个逻辑操作中更改订单和客户的属性。这个操作需要完全完成，或者失败。我们不能容忍客户信用金额减少但订单未支付的情况。这种行为通常与数据库事务相关。事务以四个原则为特征，被称为**ACID**：
- en: Atomicity
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子性
- en: Consistency
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Isolation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离性
- en: Durability
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性
- en: For now, let's concentrate on atomicity. This characteristic means that all
    operations within a transaction must be complete or nothing happens at all, and
    it is often referred to as an **all-or-nothing** proposition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于原子性。这个特性意味着事务内的所有操作必须全部完成，或者根本不发生，这通常被称为**全有或全无**命题。
- en: 'In the preceding code, we can see that the transaction is wrapping the whole
    operation for paying an order using customer credit. This is correct, and what
    we are dealing with here is a** transactional boundary**. For that particular
    method, `TakeOnCustomerCredit`, the transactional boundary would include two tables—`Customer` and `Order`.
    If we imagine another operation on the same model, that could be something such
    as this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到事务正在封装整个使用客户信用支付订单的整个操作。这是正确的，我们在这里处理的是**事务边界**。对于那个特定的方法`TakeOnCustomerCredit`，事务边界将包括两个表——`Customer`和`Order`。如果我们想象在同一个模型上的另一个操作，那可能就像这样：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method still uses the same model, and it has a few worrying concerns. But,
    for now, let's see what transaction boundary we are dealing with here. In this
    unit of work, we have records in `Order` and `OrderLine` tables changed in one
    transaction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法仍然使用相同的模型，并且有几个令人担忧的问题。但是，现在，让我们看看我们在这里处理的是哪种事务边界。在这个工作单元中，我们在`Order`和`OrderLine`表中有一个事务中更改的记录。
- en: 'These two code snippets show that in *traditional* layered architecture, with
    no real domain model in place, transactional boundaries are being deliberately
    decided by any piece of code that performs changes in the database. The model
    itself does not enforce any kind of boundary. Two methods, which could even be
    located in one controller class, operate on two different transactional boundaries,
    although the `Order` table that both methods change will be a part of both transactions.
    It is quite easy to imagine that processing the remaining order payment on a customer''s
    credit by calling the `TakeOnCustomerCredit` method could happen in parallel,
    with one order line being marked as shipped by the `ShipOrderLine` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段显示了在*传统*分层架构中，由于没有真正的领域模型，事务边界是由任何执行数据库更改的代码片段故意决定的。模型本身并不强制执行任何类型的边界。两种方法，甚至可能位于一个控制器类中，操作两个不同的事务边界，尽管这两个方法都更改的`Order`表将是两个事务的一部分。很容易想象，通过调用`TakeOnCustomerCredit`方法在客户信用上处理剩余订单支付可能会并行发生，其中一条订单行通过`ShipOrderLine`方法标记为已装运：
- en: '![](img/92515a7b-5908-4033-9423-cb2462af3047.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/92515a7b-5908-4033-9423-cb2462af3047.png)'
- en: Updates for different reasons cause unjustified conflicting transactions
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同原因的更新导致不合理的冲突事务
- en: From the business logic point of view, these are two different operations, but
    because of the *consistency* part of ACID, one of these methods will fail. It
    would be very weird for users of this system to know that credit and payment processing
    is somehow related to shipment and delivery.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从业务逻辑的角度来看，这两个操作是不同的，但由于ACID的*一致性*部分，其中一种方法将会失败。对于这个系统的用户来说，了解到信用和支付处理与装运和交付以某种方式相关是非常奇怪的。
- en: The reason for the appearance of this kind of model is quite clear. The very
    definition of the object-oriented approach in programming declares that objects
    in software programs represent objects in the real world.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型出现的原因非常清楚。编程中面向对象方法的定义本身就声明，软件程序中的对象代表现实世界中的对象。
- en: Data models follow a similar approach. Very often, we see a system with one
    global data model that closely represents the model of the real world, covering
    all aspects of the domain that the system implements. It naturally results in
    large object graphs in code that reflect such a holistic data model. Nevertheless,
    DDD advocates another approach when we need to concentrate on modeling; only those
    aspects of the real-world models that are absolutely required to implement a set
    of use cases for the system. We already touched upon this essential aspect of
    the modeling in [Chapter 4](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml), *Designing
    the Model*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型遵循类似的方法。非常常见的是，我们看到一个系统有一个全局数据模型，它紧密地代表了现实世界的模型，涵盖了系统实现的领域所有方面。这自然导致代码中出现了反映这种整体数据模型的大型对象图。尽管如此，领域驱动设计（DDD）在需要集中建模时倡导另一种方法；只需要实现系统的一组用例所必需的现实世界模型方面。我们已经在[第4章](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml)，*设计模型*中提到了建模的这个基本方面。
- en: Let's see what we can do to build our model in a way that we can define transactional
    boundaries such that different use cases will not conflict with one another when
    our software needs to execute operations on the same real-world objects that,
    however, can be represented by different objects in the software model, or even
    belong to different models.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何构建我们的模型，以便我们可以定义事务边界，这样当我们的软件需要执行操作于同一现实世界对象时，不同的用例将不会相互冲突，尽管这些对象在软件模型中可以由不同的对象表示，甚至属于不同的模型。
- en: Aggregate pattern
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合模式
- en: 'In the case of the data model that we were dealing with earlier in this chapter,
    we have one composition—`Order` is a composition of the `OrderLine` elements.
    You probably know how this model would look if we moved from a data model to a
    class diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们处理的数据模型的情况下，我们有一个组合——`Order`是`OrderLine`元素的组合。你可能知道如果我们从数据模型移动到类图，这个模型会是什么样子：
- en: '![](img/5b8187e0-a6ca-4f64-bcf4-d8f4cb04c4a1.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b8187e0-a6ca-4f64-bcf4-d8f4cb04c4a1.png)'
- en: Aggregation in UML
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UML中的聚合
- en: In UML, composition implies that child elements cannot exist without their parent
    element. Indeed, having order lines that aren't linked to any order makes no sense.
    Such a composition as a whole forms a logical indivisible structure, although,
    inside this structure, we can find individual elements. For the outside world,
    an order includes its order lines and is seen as one thing, although the order
    can have many order lines. In DDD, such constructs are known as **aggregates**.
    Since we were using UML for a short while, it can create some confusion, because,
    in UML, aggregation means something else, and the closest analogy to a DDD aggregate is
    the UML concept of composition. Aggregates share the same propositions as UML
    compositions that the parent object consists of or owns all child objects, and
    when the parent object is removed, all child objects must be removed too, because
    it doesn't make sense for those objects to exist anymore. The parent object of
    an aggregate is called an **aggregate root**. Complex object graphs with a single
    parent could be visualized like a tree, where the parent object is where all the tree
    branches are growing from, so the root analogy makes perfect sense.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，组合意味着子元素不能在没有其父元素的情况下存在。确实，拥有没有与任何订单关联的订单行是没有意义的。这样的组合作为一个整体形成一个逻辑上不可分割的结构，尽管在这个结构内部，我们可以找到单个元素。对于外部世界来说，一个订单包括其订单行，被视为一个整体，尽管订单可以有多个订单行。在DDD中，这样的结构被称为**聚合体**。由于我们之前使用了一段时间的UML，可能会造成一些混淆，因为在UML中，聚合意味着其他含义，而DDD聚合体最接近的类比是UML的概念组合。聚合体与UML组合共享相同的命题，即父对象由或拥有所有子对象，当父对象被移除时，所有子对象也必须被移除，因为这些对象的存在就没有意义了。聚合体的父对象被称为**聚合根**。具有单个父对象的复杂对象图可以像一棵树一样可视化，其中父对象是所有树枝生长的地方，因此根的类比非常合理。
- en: However, an aggregate is more than just a composition of classes. Aggregate
    boundaries also serve as transaction boundaries. For the purpose of this chapter,
    we will concentrate on two aspects of it—**atomicity** and **consistency**. As
    mentioned before, transactions imply the all-or-nothing principle of operations.
    An aggregate changes its state as a whole, no matter how the aggregate is persisted.
    If we use an ORM tool and our aggregate spans multiple database tables, all operations
    on those tables need to be wrapped in a database transaction. Furthermore, the
    consistency aspect requires an aggregate to ensure that the aggregate state is
    being validated across all operations that are executed on that aggregate. Hence,
    it is not a database or a code that is not part of the aggregate itself, such
    as an API controller or an application service. Unlike the preceding code, all
    these validity checks need to be a part of the aggregate code, and therefore they
    need to be implemented inside the domain model.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，聚合体不仅仅是类的组合。聚合边界还充当事务边界。为了本章的目的，我们将集中讨论其两个方面——**原子性**和**一致性**。正如之前提到的，事务意味着操作的全有或全无原则。无论聚合体如何持久化，聚合体都会作为一个整体改变其状态。如果我们使用ORM工具，并且我们的聚合体跨越多个数据库表，那么对这些表的所有操作都需要被包含在一个数据库事务中。此外，一致性方面要求聚合体确保在执行在该聚合体上的所有操作时，聚合体的状态正在被验证。因此，它不是数据库或代码，这些代码不是聚合体本身的一部分，例如API控制器或应用程序服务。与前面的代码不同，所有这些有效性检查都需要是聚合体代码的一部分，因此它们需要在领域模型内部实现。
- en: We already have quite a few characteristics of aggregates, so we can see how
    this pattern would apply to our preceding sample. If we start looking from the
    data model, we could suspect that `Order` and `OrderLine` form some sort of composition,
    since `OrderLine` records cannot exist without a parent `Order`. It applies both
    to atomicity and consistency. If we change the order status because one line of
    that order is marked as shipped—these changes need to be executed together; otherwise,
    the order state would become invalid—we might get an order with the status *pending*
    when one order line has already been marked as shipped. So, we would expect such
    an order to have a *partially delivered* status, and if that isn't the case, then
    our order state is not valid. Since we know that an order line is a child object,
    we don't really want to expose any operations on order lines directly from outside
    the domain model. It would make much more sense if the order lines are manipulated
    by the `Order` class itself. In this case, the `Order` class becomes our aggregate
    root, and it will have methods that change the state of its lines.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有很多聚合体的特性，所以我们可以看到这个模式是如何应用到我们前面的示例中的。如果我们从数据模型开始看，我们可能会怀疑`Order`和`OrderLine`形成某种组合，因为`OrderLine`记录不能在没有父`Order`的情况下存在。这适用于原子性和一致性。如果我们因为订单中的一行被标记为已发货而更改订单状态——这些更改需要一起执行；否则，订单状态将变得无效——我们可能会得到一个状态为*待处理*的订单，而其中一个订单行已经被标记为已发货。因此，我们预计这样的订单将有一个*部分交付*的状态，如果这不是情况，那么我们的订单状态就不有效。由于我们知道订单行是一个子对象，我们并不真的希望从域模型外部直接暴露任何关于订单行的操作。如果订单行由`Order`类本身操作，那就更有意义了。在这种情况下，`Order`类成为我们的聚合根，它将拥有改变其行状态的方法。
- en: At the same time, an aggregate does not guarantee any consistency constraints
    that are external to the aggregate. For the relational data model, it would mean
    that we cannot have referential integrity between the table that is used to persist
    our aggregate root (`Order`) and anything that is outside the aggregate boundary.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，聚合体不保证任何外部于聚合体的一致性约束。对于关系数据模型来说，这意味着我们无法在用于持久化我们的聚合根（`Order`）的表和聚合边界之外的东西之间有引用完整性。
- en: 'If we make some changes in the data model to reflect the new insight, it would
    look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对数据模型进行一些修改以反映新的洞察，它看起来会是这样：
- en: '![](img/648435b5-247f-492a-9454-da3944bdd6d7.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/648435b5-247f-492a-9454-da3944bdd6d7.png)'
- en: Removing references create explicit boundaries
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 移除引用创建显式边界
- en: Note that relations between `Order` and `Customer` tables and `OrderLine` and
    `Product` table are now gone, but we kept the reference fields—`CustomerId` and
    `ProductId`. We still need to know whether the customer has placed the order and
    what products we are selling. However, as regards the normal operation of our
    system, we don't need object references in ORM, and a lack of referential integrity
    that some developers might perceive as a negative side-effect of isolating the
    aggregate, in fact, gives us a new degree of freedom. For example, order lines
    need to stay intact if the product that was used for those lines goes out of sales
    and is then removed from the `Product` table. We won't discuss flags and other
    soft-delete methods since I am making a point of keeping these things separate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在`Order`和`Customer`表以及`OrderLine`和`Product`表之间的关系已经不存在了，但我们保留了引用字段——`CustomerId`和`ProductId`。我们仍然需要知道客户是否下过订单以及我们正在销售哪些产品。然而，就我们系统的正常操作而言，我们不需要对象引用在对象关系映射（ORM）中，一些开发者可能认为这是隔离聚合体的负面副作用，但实际上，这给了我们一个新的自由度。例如，如果用于这些行号的产品停止销售并被从`Product`表中删除，订单行需要保持完整。我们不会讨论标志和其他软删除方法，因为我正在努力将这些事情分开。
- en: 'Let''s now take a look at how the code for the API controller would look:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看API控制器代码会是什么样子：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s quite a change, isn''t it? Of course, the logic has not disappeared;
    it has moved to the `Order` class itself:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个很大的变化，不是吗？当然，逻辑并没有消失；它已经移动到了`Order`类本身：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the accidental complexity of two-way object reference for order
    lines can now be removed. On the other hand, we have to change the API because
    we cannot just ask for an order line's ID. We need to know the order ID as well,
    because the order line's ID is internal to a given order, and we are using our
    aggregate root to access its child elements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，现在可以移除双向对象引用对于订单行的意外复杂性。另一方面，我们必须更改API，因为我们不能仅仅请求订单行的ID。我们需要知道订单ID，因为订单行的ID是特定订单内部的，而我们正在使用我们的聚合根来访问其子元素。
- en: Of course, more complex operations would now require more work. How would we
    perform something such as what the `TakeOnCustomerCredit` method does? Since we
    do not have object relations between our `Customer` and `Order` objects, and we
    have decided that our aggregate is wrapping all about the `order` handling, but
    not `Customer`, we cannot complete one transaction on these two distinct objects.
    This might sound like an impossible task, and often, such dilemmas lead to workaround
    and shortcuts, and then the aggregate pattern is seen as something that gets in
    the way and needs to be ignored in one or two specific cases. In fact, we need
    to do quite the opposite. We have to go back to the modeling space to find out
    more about this problem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，更复杂的操作现在需要更多的工作。我们如何执行像`TakeOnCustomerCredit`方法所做的那样的事情？由于我们之间没有`Customer`和`Order`对象之间的对象关系，并且我们已经决定我们的聚合包含所有关于`order`处理的方面，但不包括`Customer`，我们不能在这两个不同的对象上完成一个事务。这听起来可能是一个不可能的任务，而且通常，这样的困境会导致权宜之计和捷径，然后聚合模式被视为一种阻碍，需要在某些特定情况下被忽略。实际上，我们需要做的是相反的。我们必须回到建模空间，以了解更多关于这个问题。
- en: 'Looking back at the method code, we can see that it does the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾方法代码，我们可以看到它执行以下操作：
- en: Checks whether the customer has enough credit to cover what remains unpaid in
    relation to an order
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查客户是否有足够的信用来支付与订单相关的未支付金额
- en: Decreases the customer's credit amount for the unpaid amount of the order
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少订单未支付金额的客户信用金额
- en: Increases the order's paid amount
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加订单的已支付金额
- en: Decreases the order's unpaid amount
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少订单的未支付金额
- en: Sets the order status to *paid* if the unpaid amount is zero (for that code,
    it will always be true)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未支付金额为零（对于该代码，它始终为真），则将订单状态设置为*paid*
- en: Increases the customer's total spent amount by the payment amount
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过支付金额增加客户的总支出金额
- en: Upgrades the customer to *preferred* status if this customer has spent over
    a certain threshold
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这位客户的花费超过某个阈值，则将客户升级到*首选*状态
- en: That's quite a lot, and now we are going to use the power of aggregates to make
    more sense of the whole flow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当多，现在我们将利用聚合的力量来使整个流程更有意义。
- en: 'First, we need to check what does not belong here. The first candidate would
    be to evaluate the last two actions on the list: updating the total spent amount
    and upgrading the customer. It seems as if something has happened not only after
    taking a credit payment but also for the credit card, cash, and any other sorts
    of payments. Keeping the code here means that we need to either copy and paste
    it or have some shared code. None of these alternatives are really appealing.
    Most importantly, these two actions have no relation to the order processing.
    Imagine one of these actions failing. Such a failure should have no effect on
    the order processing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要检查哪些内容不属于这里。第一个候选方案是对列表中的最后两个动作进行评估：更新总支出金额和升级客户。看起来似乎在采取信用支付之后，不仅对信用卡，对现金和任何其他类型的支付也发生了某些事情。保留这段代码意味着我们需要复制粘贴它或者有一些共享代码。这些替代方案中没有一个真正吸引人。最重要的是，这两个动作与订单处理顺序无关。想象一下其中任何一个动作失败。这种失败不应该对订单处理有任何影响。
- en: Then, we need to check what we have to know and do in order to complete the
    operation. In our case, we must ensure that the remaining credit limit is higher
    or equal to the order unpaid amount. For our code to make a decision regarding
    whether to proceed with the payment on credit, we need to have the information
    about the available credit limit for the ordering customer. But these details
    are now out of our aggregate scope, so what can we do about it to ensure that
    an order cannot violate the consistency rule?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检查为了完成操作我们需要知道和做什么。在我们的情况下，我们必须确保剩余的信用额度高于或等于订单的未支付金额。为了我们的代码就是否进行信用支付做出决定，我们需要有订购客户的可用信用额度信息。但是，这些细节现在超出了我们的聚合范围，所以我们能做些什么来确保订单不会违反一致性规则呢？
- en: 'Here comes another aspect of emerging aggregate boundaries, where we need to
    evaluate the speed of change in objects that our system works with. The `Customer`
    object now contains some information that forms a customer profile—name, address,
    and so on. At the same time, it contains some financial details that potentially
    change for every order that we process. It is clear from our code that when we
    process orders, we do not have any rules that give a discount for customers that
    have their name starting with *A*, or their location in Belgium. We could imagine
    such a requirement due to logistics reasons, but it is not relevant to our example.
    Our conclusion should be that the customer profile information changes very rarely,
    while the remaining customer credit limit changes quite often. At the same time,
    information about the total allowed credit limit might still belong to the customer
    profile, and it changes rarely too. This means that we are dealing with two different
    aspects of customer details:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看另一个关于新兴聚合边界方面的方面，我们需要评估我们系统所处理的对象变化的速度。`Customer` 对象现在包含一些构成客户档案的信息——姓名、地址等。同时，它包含一些可能随每个我们处理的订单而变化的财务细节。从我们的代码中可以看出，当我们处理订单时，我们没有任何规则为那些姓名以
    *A* 开头或位于比利时的客户提供折扣。我们可能会因为物流原因想象这样的要求，但这与我们的例子无关。我们的结论应该是，客户档案信息很少改变，而剩余的客户信用额度则相当频繁地改变。同时，关于总允许信用额度的信息可能仍然属于客户档案，并且也很少改变。这意味着我们正在处理客户细节的两个不同方面：
- en: '| Customer profile | Customer running credit |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 客户档案 | 客户信用额度 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Name, address, total credit limit | Available credit limit |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 姓名、地址、总信用额度 | 可用信用额度 |'
- en: '| Changes now and then | Changes for each credit order |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 有时改变 | 每个信用订单改变 |'
- en: '| No rules for order processing | Required for the consistency of order processing
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 无订单处理规则 | 保持订单处理一致性所必需 |'
- en: 'We finally come to the conclusion that our *holistic* `Customer` object is
    not suitable for these different use cases. The solution for our model would be
    to move the information that is required to ensure order processing consistency
    and that the business rules need to be moved closer to the order processing logic.
    We can do this by splitting our `Customer` entity into two, each of which is responsible
    for its own set of use cases. We can even give the new entity a more explicit
    name: `CustomerCredit`, to express the specific use of this information. Our diagram
    would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得出结论，我们的*整体* `Customer` 对象不适合这些不同的用例。我们模型的解决方案是将确保订单处理一致性所需的信息以及需要移动的业务规则移得更接近订单处理逻辑。我们可以通过将我们的
    `Customer` 实体分成两个，每个都负责其自己的用例集来实现这一点。我们甚至可以给新的实体一个更明确的名称：`CustomerCredit`，以表达此信息的特定用途。我们的图表将看起来像这样：
- en: '![](img/b6e2409f-849a-48c0-a98a-e6d4879fff07.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6e2409f-849a-48c0-a98a-e6d4879fff07.png)'
- en: Moving all related concerns to one boundary
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有相关关注点移动到一个边界
- en: In fact, what we did here belongs more to finding linguistic and contextual
    boundaries, and this topic will be covered in more detail in [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side*. For now, we will continue discussing the aggregate boundaries
    only.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，我们在这里所做的工作更属于寻找语言和上下文边界，这个主题将在第9章[6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml]，*CQRS
    - 读取侧*中更详细地介绍。现在，我们将继续只讨论聚合边界。 '
- en: Our new model looks better, but it has one issue—the aggregation has now shifted
    to the `CustomerCredit` entity, and it seems to become our aggregate root. From
    the relational consistency point of view, this is perfectly fine. From another
    point of view, it looks weird to process all orders by calling methods on the
    `CustomerCredit` entity. Another negative aspect is that the ownership of objects
    has also changed. Before, we had `Order`, which is responsible for its `OrderLine`.
    Now, we have `CustomerCredit`, which is responsible for everything. It looks as
    though if we remove the `CustomerCredit` object from the system, we also need
    to remove all of its orders. This is definitely not what we need. Customers come
    and go, but we definitely need to keep track of all our orders, including the
    completed ones, and not remove them. In this case, we clearly see the downside
    of having a larger aggregate with the dubious responsibility of the supportive
    entity.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新模型看起来更好，但它有一个问题——聚合现在已转移到`CustomerCredit`实体，并且它似乎变成了我们的聚合根。从关系一致性角度来看，这是完全正常的。从另一个角度来看，通过在`CustomerCredit`实体上调用方法来处理所有订单看起来很奇怪。另一个负面方面是对象的所有权也发生了变化。以前，我们有`Order`，它负责其`OrderLine`。现在，我们有`CustomerCredit`，它负责一切。看起来如果我们从系统中删除`CustomerCredit`对象，我们也需要删除所有相关的订单。这绝对不是我们需要的。客户来来去去，但我们绝对需要跟踪所有订单，包括完成的订单，并且不能删除它们。在这种情况下，我们可以清楚地看到拥有一个较大的、具有可疑支持实体责任的聚合的缺点。
- en: 'It is also important to remember that despite having a constraint, we need
    to have enough credit to cover the order total before we can proceed with it,
    as the order itself can be valid even if this constraint is violated. The order
    has its own invariants—a set of unbreakable rules that guarantee the consistency
    of each order. Let''s see what invariants the `Order` aggregate has:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要记住，尽管存在约束，但在我们可以继续处理订单之前，我们需要有足够的信用来覆盖订单总额，因为即使违反了此约束，订单本身也可能是有效的。订单有其自己的不变量——一组不可打破的规则，保证了每个订单的一致性。让我们看看`Order`聚合有哪些不变量：
- en: The sum of `PaidAmount` and `UnpaidAmount` should be equal to `TotalAmount`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PaidAmount`和`UnpaidAmount`的总和应等于`TotalAmount`。'
- en: '`DeliveryStatus` of an order can only be set to `Delivered` if, for all order
    lines of the `IsShipped` property, this is set to `true`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对于所有具有`IsShipped`属性的订单行，此属性设置为`true`，则订单的`DeliveryStatus`才能设置为`Delivered`。
- en: The `TotalAmount` of an order must be equal to the sum of the `LineTotal` of
    all the order lines.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的`TotalAmount`必须等于所有订单行的`LineTotal`之和。
- en: For each order line, `LineTotal` must equal the `ProductPrice` multiplied by
    `Quantity`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个订单行，`LineTotal`必须等于`ProductPrice`乘以`Quantity`。
- en: As you can see, there is nothing in these invariants that requires us to know
    the customer's available credit or any information about the product, and so on.
    So, for us to decide whether an order is consistent, it is sufficient to have
    the details pertaining to the order itself and all of its lines.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这些不变量中没有任何内容要求我们知道客户的可用信用或有关产品的任何信息等。因此，为了决定一个订单是否一致，我们只需要有关订单及其所有行的详细信息就足够了。
- en: As regards ownership, it is also obvious that individual order lines cannot
    exist without the order they belong to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所有权，很明显，单个订单行不能脱离其所属的订单而存在。
- en: 'Therefore, our final move would be to break the relationship between orders
    and customers, even for the more explicit `CustomerCredit` entity, while keeping
    the aggregation between `Order` and the `OrderLine` entities:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的最终举措将是断开订单和客户之间的关系，即使对于更明确的`CustomerCredit`实体也是如此，同时保持`Order`和`OrderLine`实体之间的聚合：
- en: '![](img/5b1c5fc1-92f4-40ee-8d9c-260eaad67fc8.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b1c5fc1-92f4-40ee-8d9c-260eaad67fc8.png)'
- en: Making the boundaries smaller decrease transaction scopes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小边界可以减少事务范围
- en: In this model, we have two aggregates inside an isolated part of the system.
    We know that these aggregates need to be inside the same contextual boundaries,
    but they need to be separated and form different transactional and consistency
    boundaries for the reason we discussed previously. Now, the question arises of
    how can we enforce our constraints if orders have no information about the available
    credit for the ordering customer, from inside the aggregate object graph. We will
    use the power of domain services to perform this check.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模型中，我们有两个聚合在系统的一个隔离部分。我们知道这些聚合需要位于相同的上下文边界内，但它们需要分离，并形成不同的事务和一致性边界，原因是我们之前讨论过的。现在，问题出现了，如果订单没有关于订购客户可用信用的信息，我们如何从聚合对象图中强制执行我们的约束。我们将利用领域服务的力量来执行此检查。
- en: 'Inside our domain project, we can define an interface for such a domain service:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的领域项目中，我们可以为这样的领域服务定义一个接口：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that we have the `EnsureEnoughCredit` method that returns a Boolean value,
    instead of returning the available credit limit itself. By doing this, we enforce
    the utilization of the ubiquitous language and shift the credit limit check logic
    to the domain service. The service might, for example, decide that for preferred
    customers, we can allow an overdraft above the available limit. Of course, in
    such an instance, we'd also need to move the `Preferred` attribute to the `CustomerCredit`
    entity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有一个返回布尔值的`EnsureEnoughCredit`方法，而不是直接返回可用的信用额度。通过这样做，我们强制使用通用语言，并将信用额度检查逻辑转移到领域服务。例如，服务可能会决定对于优先客户，我们可以允许超过可用额度的透支。当然，在这种情况下，我们还需要将`Preferred`属性移动到`CustomerCredit`实体。
- en: 'Then, we can use our application service to handle the `TakeOnCustomerCredit`
    command, where it will use the domain service to check whether this command can
    be processed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们的应用程序服务来处理`TakeOnCustomerCredit`命令，其中它将使用领域服务来检查此命令是否可以处理：
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I have to mention that moving the customer credit to a separate entity can cause
    situations when the credit amount goes below zero due to race conditions. When
    applying the credit limit change in a separate transaction, you might want to
    check if the operation results in the negative value and then decide what to do
    if the result is negative. One possible technique is to inform the account manager
    by email about the situation and let them resolve it with the customer. From a
    technical side, it is possible to create a compensating action to put the order
    on hold until the issue is resolved. Overall, those decisions should never be
    seen as technical. Talk to domain experts and ask them what solution would they
    prefer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须提到，将客户信用移至单独的实体可能会因为竞争条件而导致信用金额低于零的情况。在单独的事务中应用信用额度变更时，您可能想要检查操作结果是否为负值，然后决定如果结果为负值时应该做什么。一种可能的技术是通过电子邮件通知账户经理这种情况，并让他们与客户解决。从技术角度来看，可以创建一个补偿操作，将订单挂起，直到问题解决。总的来说，这些决策永远不应该被视为技术问题。与领域专家交谈，并询问他们更喜欢哪种解决方案。
- en: 'This approach moves some domain logic to the application service, and that
    might not be desirable in some cases. To solve this, we could use the double dispatch
    pattern and let the `Order` aggregate decide on the constraint. If we decide to
    use double dispatch, it would look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将一些领域逻辑移动到应用程序服务，而在某些情况下这可能不是所希望的。为了解决这个问题，我们可以使用双重分派模式，并让`Order`聚合决定约束。如果我们决定使用双重分派，它将看起来像这样：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the application service will pass the dependency when calling the aggregate
    root method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序服务在调用聚合根方法时将传递依赖项：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It might look as if we are creating a dependency between our domain model and
    the infrastructure since it is clear that the domain service needs to fetch the
    `CustomerCredit` entity to get the data. However, our `Order` aggregate root only
    gets the interface dependency, and, as you remember, the interface itself is defined
    inside the domain project. Its implementation is indeed located inside the application
    itself, but this is perfectly normal.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来我们正在创建领域模型和基础设施之间的依赖关系，因为很明显领域服务需要获取`CustomerCredit`实体以获取数据。然而，我们的`Order`聚合根只获取接口依赖，如您所记得的，该接口本身是在领域项目中定义的。其实施确实位于应用程序内部，但这完全正常。
- en: We have still not seen how our aggregate is protecting its invariants, but now
    it is time to get back to our `Marketplace` application and add some code there,
    based on what we have learned about aggregates so far. We also need to cover the
    aggregate persistence, since we already used the `IOrderRepository` interface
    that is responsible for getting the aggregate state from the database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到我们的聚合是如何保护其不变量的，但现在是我们回到我们的“Marketplace”应用并添加一些代码的时候了，基于我们迄今为止对聚合的了解。我们还需要涵盖聚合持久化，因为我们已经使用了负责从数据库获取聚合状态的`IOrderRepository`接口。
- en: Protecting invariants
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护不变量
- en: In [Chapter 5](034423e8-8080-4073-bd08-b98a129384a4.xhtml), *Implementing the
    Model*, we went through using value objects to protect invalid values from even
    being used as parameters for entity constructors and methods. This technique allows
    us to move a lot of checks to value objects, provides nice encapsulation, and
    enables type safety. Then, when we create a new entity or execute some behavior
    using entity methods, we need to execute further checks. Since we can be quite
    sure that all parameters already contain valid individual values, we need to ensure
    that a given combination of parameters, the current entity state, and the executed
    behavior are not going to bring the entity to an invalid state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](034423e8-8080-4073-bd08-b98a129384a4.xhtml)“实现模型”中，我们讨论了使用值对象来防止无效值甚至被用作实体构造函数和方法参数。这项技术允许我们将许多检查移动到值对象中，提供了良好的封装，并实现了类型安全。然后，当我们创建一个新的实体或使用实体方法执行某些行为时，我们需要执行进一步的检查。由于我们可以相当肯定所有参数已经包含有效的单个值，我们需要确保给定的参数组合、当前实体状态和执行的行为不会使实体进入一个无效状态。
- en: Protecting the internal state from being invalid and, as a result, bringing
    the model into an inconsistent state, is one of the most important characteristics
    of aggregates. Aggregate invariants must be satisfied for each operation that
    triggers a state change; thus, we need to ensure that we control the aggregate
    state when calling any command method on the aggregate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 保护内部状态不被无效，从而防止模型进入不一致状态，是聚合最重要的特性之一。聚合的不变量必须在触发状态变化的每个操作中满足；因此，我们需要确保在调用聚合上的任何命令方法时控制聚合状态。
- en: 'Let''s look at what complex rules we have for our classified ad entity. To
    find such rules, we can use some sticky notes from our detailed EventStorming
    session in [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming*,
    and put them on a chart, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们为我们的分类广告实体制定了哪些复杂规则。为了找到这些规则，我们可以使用我们在[第3章](07ee37fb-0189-467c-865d-18e72868b137.xhtml)“事件风暴”中详细的事件风暴会议的一些便签，并将它们放在图表上，如下所示：
- en: '![](img/b6384d06-e912-4801-8f1b-eae2c188752c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6384d06-e912-4801-8f1b-eae2c188752c.png)'
- en: Business rules can prevent the command execution
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则可以防止命令执行
- en: Analyzing constraints for a command
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析命令的约束
- en: We put the command to the left side, the event to the right side, and try to
    find out what could prevent our command from being executed in a way that it produces
    the desired outcome (the event). In our case here, we need to ensure that before
    an ad can be put to the review queue, it must have a non-empty title, text, and
    price.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命令放在左边，事件放在右边，并试图找出什么可能阻止我们的命令以产生预期结果（事件）的方式执行。在我们的案例中，我们需要确保在广告被放入审查队列之前，它必须有一个非空的标题、文本和价格。
- en: We cannot put these checks combined with the value object, since before the
    ad is sent to review, it can have an empty title and text, and it can have no
    price. Only when a given command is being executed do we need to check whether
    these constraints are satisfied. It is what we can call an invariant for this
    entity—an ad that is in a pending review cannot have an empty title, empty text,
    or zero price.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将这些检查与值对象结合使用，因为广告在发送到审查之前可以有一个空的标题和文本，并且可以没有价格。只有当给定命令正在执行时，我们才需要检查这些约束是否得到满足。这就是我们所说的这个实体的不变量——一个处于待审查状态的广告不能有一个空的标题、空的文本或零价格。
- en: 'There are at least two ways of ensuring that our entity never gets to an invalid
    state. The first and most obvious way is to add checks to the operation code.
    There is no way of requesting that the ad be published, so let''s add it and make
    some changes related to the fact of using value objects for the entity state as
    well:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们的实体永远不会进入一个无效状态至少有两种方法。第一种也是最明显的方法是在操作代码中添加检查。无法请求发布广告，所以让我们添加它，并做一些与使用值对象来表示实体状态的事实相关的更改：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the new entity code, we enforce the constraints that became visible from
    our detailed model, so the operation is only executed if all constraints are satisfied.
    To let the caller know if our entity is not ready to be published when some of
    those checks fail, we use our custom exception, which is implemented like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的实体代码中，我们强制实施从我们的详细模型中显现出来的约束，因此只有在所有约束都得到满足的情况下才会执行操作。为了让调用者知道，如果其中一些检查失败，我们的实体尚未准备好发布，我们使用自定义异常，其实现方式如下：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method of checking constraints before executing the operation, in the operation
    method itself, has one disadvantage. If, now, we change the price to zero, it
    will go through, because the `UpdatePrice` method is not checking the price value.
    We could, of course, copy the price check to the `UpdatePrice` method too, but
    there might be more methods that need the same tests and we will keep copying
    the control blocks. This will lead to a situation where, if we need to change
    any of those rules, we need to go to numerous places to replace all of the checks.
    This approach is very error prone.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作方法本身之前检查约束的方法有一个缺点。如果我们现在将价格更改为零，它将通过，因为`UpdatePrice`方法没有检查价格值。当然，我们可以将价格检查复制到`UpdatePrice`方法中，但也可能有更多需要相同测试的方法，我们将继续复制控制块。这将导致一种情况，即如果我们需要更改这些规则中的任何一个，我们需要去许多地方替换所有的检查。这种方法非常容易出错。
- en: To combine rules in one place, we can use contract programming techniques. Part
    of contract programming can be seen in value objects, since we evaluate pre-conditions
    for each parameter of the operation method. When we execute the operation without
    doing any additional checks, we will need to do a combined test (post-condition
    control). This check can be implemented in one place for the whole entity, and
    each operation will need to call it at the last line in the method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在一个地方组合规则，我们可以使用合同编程技术。合同编程的一部分可以在值对象中看到，因为我们评估操作方法每个参数的先决条件。当我们执行操作而不进行任何额外的检查时，我们需要进行组合测试（后置条件控制）。这个检查可以在整个实体的一个地方实现，并且每个操作都需要在方法的最后一行调用它。
- en: 'For our classified ad entity, it could look like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的分类广告实体，它可能看起来像这样：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we have added a method called `EnsureValidState`, which checks
    that in any situation, the entity state is valid, and if it is not valid, an exception
    will be thrown. When we call this method from any operation method, we can be
    sure that no matter what we are trying to do, our entity will always be in a valid
    state or the caller will get an exception.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们添加了一个名为`EnsureValidState`的方法，它检查在任何情况下，实体状态都是有效的，如果不是有效，将抛出异常。当我们从任何操作方法调用此方法时，我们可以确信无论我们试图做什么，我们的实体都将始终处于有效状态，或者调用者将得到异常。
- en: Throwing an exception when the entity becomes invalid is the easiest way to
    prevent inconsistencies, but it has its downsides. The whole application needs
    to be able to handle such exceptions gracefully so the user gets properly informed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体变得无效时抛出异常是防止不一致性最简单的方法，但它有其缺点。整个应用程序需要能够优雅地处理此类异常，以便用户得到适当的告知。
- en: The web API code for this chapter, for example, doesn't do it and expects all
    operations to be successfully executed. As a result, when we try executing commands
    that bring the entity to some incorrect state, will crash the API method and return
    the exception via HTTP.  The web API code will be improved as we move along and
    we will start returning proper errors results from the API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，本章的Web API代码没有这样做，并期望所有操作都成功执行。因此，当我们尝试执行将实体带到某些错误状态的命令时，将使API方法崩溃，并通过HTTP返回异常。随着我们的进展，我们将改进Web
    API代码，并开始从API返回适当的错误结果。
- en: When using Event Sourcing one of the techniques to expose incorrect operations
    is to emit domain events like `PriceChangeDenied`, which include all values that
    the application tried to apply to an entity but failed. Using this method gives
    developers a powerful tool to find out why certain commands weren't executed and
    even potentially discover malicious behavior of the user.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用事件溯源时，暴露不正确操作的一种技术是发出领域事件，如`PriceChangeDenied`，它包括应用程序尝试应用于实体的所有值，但失败了。使用这种方法为开发者提供了一个强大的工具，可以找出为什么某些命令没有执行，甚至可能发现用户的恶意行为。
- en: Also, we converted all private fields to public read-only properties. We need
    public properties to write tests, although we don't necessarily need to expose
    the internal entity state. To prevent setting values of these properties outside
    operation methods, all properties have private setters, or no setters for properties
    that are set in the constructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将所有私有字段转换为公共只读属性。我们需要公共属性来编写测试，尽管我们不一定需要公开内部实体状态。为了防止在操作方法之外设置这些属性的值，所有属性都有私有设置器，或者对于在构造函数中设置的属性没有设置器。
- en: 'Now, let''s write some tests to ensure that our constraints work:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些测试来确保我们的约束起作用：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This spec contains several tests for one operation (publish, or submit for review)
    with different pre-conditions. Here, we test a happy path when all necessary details
    are correctly set before the ad can be sent for review; we also test several negative
    cases when publishing is not allowed due to missing mandatory information. Perhaps
    testing negative scenarios is even more essential, since it is straightforward
    to find out when the happy path does not work—your users will immediately complain.
    Testing negative scenarios prevents bugs in controlling entity invariants, which,
    in turn, prevent entities from becoming invalid.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此规范包含针对一个操作（发布或提交审查）的多个测试，具有不同的前提条件。在这里，我们测试在广告可以提交审查之前，所有必要的细节都正确设置时的愉快路径；我们还测试了几个不允许发布的情况，因为缺少必要的信息。也许测试负面场景甚至更为重要，因为当愉快路径不起作用时，很容易发现——您的用户会立即抱怨。测试负面场景可以防止在控制实体不变性时出现错误，这反过来又防止实体变得无效。
- en: When we moved the entity state checks to one method, we effectively set up a
    holistic set of rules that need to be executed for each operation. This means
    that those rules aren't command-specific any more, and our `EnsureValidState`
    method has become a guardian for the entire object. It protects the invariants
    of our `ClassifiedAd` entity so it can never become invalid. The ability to protect
    its own invariants is one of the main aspects of the aggregate pattern. By executing
    each command for the `ClassifiedAd` entity within individual transactions, and
    by establishing invariant protection, we created our first aggregate.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将实体状态检查移动到一个方法中时，我们实际上建立了一套需要为每个操作执行的全面规则。这意味着这些规则不再是命令特定的，我们的`EnsureValidState`方法已经成为整个对象的守护者。它保护了`ClassifiedAd`实体的不变性，使其永远不会变得无效。能够保护其自身的不变性是聚合模式的主要方面之一。通过在单个事务中为`ClassifiedAd`实体执行每个命令，并通过建立不变性保护，我们创建了我们的第一个聚合。
- en: Now, we have learned how to protect our entity from becoming invalid. But we
    expect more entities to appear in our application, and the code of the `ClassifiedAd`
    entity becomes quite verbose because we have to call the `EnsureValidState` method
    in each operation. Also, it is certainly possible to forget to put the call in
    an entity method and then get a chance to get the entity in an invalid state without
    getting any exceptions. However, this cannot possibly happen if we want to have
    a true aggregate, so let's see how we can use the power of events to ensure the
    state validity for all operations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何保护我们的实体免于变得无效。但是，我们预计我们的应用程序中会出现更多的实体，`ClassifiedAd`实体的代码变得相当冗长，因为我们必须在每个操作中调用`EnsureValidState`方法。此外，确实有可能忘记在实体方法中放置调用，然后有机会在不抛出任何异常的情况下将实体置于无效状态。然而，如果我们想要一个真正的聚合，这种情况是不可能发生的，所以让我们看看我们如何利用事件的力量来确保所有操作的状态有效性。
- en: Enforcing the rules
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制执行规则
- en: 'Let''s now examine how we execute operations on the entity:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查我们如何在实体上执行操作：
- en: Call the entity method for operation (the CQS command)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用实体方法进行操作（CQS命令）
- en: The method emits an event
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法发出一个事件
- en: An event is then applied to the entity state to perform the state transition
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后将事件应用于实体状态以执行状态转换
- en: 'So, if we want to ensure that all state transitions do not break our invariants,
    we can move the call to `EnsureValidState` to the `Apply` method. The need to
    protect its state only applies to the aggregate root entity because it must ensure
    that the whole aggregate state is correct, and not just its own state validity.
    Therefore, we can make a new base class for this special type of entity:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想确保所有状态转换都不会破坏我们的不变性，我们可以将调用`EnsureValidState`的方法移动到`Apply`方法中。需要保护其状态仅适用于聚合根实体，因为它必须确保整个聚合状态是正确的，而不仅仅是其自身状态的有效性。因此，我们可以为这种特殊类型的实体创建一个新的基类：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have renamed the `_events` collection to `_changes` to make the naming
    more explicit. We also added a call to `EnsureValidState` to the `Apply` method.
    This means that whenever we execute an operation that is supposed to change the
    aggregate root entity state, we apply a new event and the state changes in the
    `When` method. However, before adding the new event to the list of changes, we
    check whether the new state is valid and that no invariants are broken. If the
    new state violates the invariants, we throw an exception.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `_events` 集合重命名为 `_changes`，以使命名更加明确。我们还向 `Apply` 方法中添加了对 `EnsureValidState`
    的调用。这意味着每次我们执行旨在更改聚合根实体状态的操作时，我们都会在 `When` 方法中应用一个新的事件，并改变状态。然而，在将新事件添加到更改列表之前，我们会检查新状态是否有效，以及是否没有违反任何不变性。如果新状态违反了不变性，我们会抛出一个异常。
- en: 'After we refactor our `ClassifiedAd` class to use the new base class, the code
    becomes simpler:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将 `ClassifiedAd` 类重构为使用新的基类之后，代码变得更加简单：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, all the conditions are now consolidated in one place, and no
    matter what we do, we cannot publish an ad that has no price or no text. Also,
    it is impossible to have a hidden bug in any other places of the application that
    could make an ad active and visible without being approved first. This technique
    to ensure the validity of the state is consistently very powerful, and it also
    improves the readability of our code by giving developers a clue as to where they
    can look when trying to figure out all the rules that an entity must adhere to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有条件现在都集中在一个地方，无论我们做什么，我们都无法发布一个没有价格或没有文本的广告。同样，在应用程序的任何其他地方也不可能存在隐藏的bug，这可能会在没有首先获得批准的情况下使广告变得活跃并可见。这种确保状态有效性的技术始终非常强大，它还通过给开发者提供线索，告诉他们在试图找出实体必须遵守的所有规则时可以查看哪些地方，从而提高了我们代码的可读性。
- en: Entities inside an aggregate
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合内的实体
- en: It might seem weird that we just added a base class called `AggregateRoot` and
    used it instead of the `Entity` class that we already had before. We could have
    just added new code to the `Entity` base class. However, this was done on purpose,
    because, as you might remember, aggregates can potentially form larger object
    graphs, and, in addition to the root entity, we might have several entities that
    will be the children of the root. We already discussed the ownership strategy,
    so when an aggregate is removed, the aggregate root and all its children are also
    removed from the system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来有些奇怪，我们刚刚添加了一个名为 `AggregateRoot` 的基类，并用它来代替我们之前已有的 `Entity` 类。我们本可以直接向
    `Entity` 基类中添加新代码。然而，这样做是有意为之的，因为，正如你可能记得的，聚合可以潜在地形成更大的对象图，除了根实体之外，我们还可能有几个实体将成为根的子实体。我们已经讨论了所有权策略，所以当一个聚合被移除时，聚合根及其所有子实体也会从系统中移除。
- en: For all the child objects, we would be talking about value objects or entities,
    as the rule of the aggregate pattern is strict. None of those child objects should
    be referenced, accessed, or manipulated outside the aggregate boundary. All operations
    on an aggregate need to be performed by calling methods on the aggregate root.
    Also, accessing any child objects inside the aggregate needs to go via the aggregate
    root as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有子对象，我们将讨论值对象或实体，因为聚合模式的规则非常严格。这些子对象中的任何一个都不应该在聚合边界之外被引用、访问或操作。对聚合的所有操作都需要通过调用聚合根的方法来执行。同样，访问聚合内部任何子对象也需要通过聚合根进行。
- en: Let's illustrate this principle by adding an entity to our `ClassifiedAd` aggregate.
    One of our EventStorming sessions helped us to discover that we need pictures
    to be added to ads since, without pictures, people are really hesitant to buy
    anything. An ad can have multiple pictures, and we could think of these pictures
    as value objects because users cannot *change* images. They can either upload
    new ones or remove existing ones. However, it seems as if users need to be able
    to choose in what order those images appear and what image is shown in the search
    results, as the *main* image. We can solve this issue by using a value object
    called `ImageOrder`, which will be replaced each time the user changes the order
    of the pictures. But, even in this case, we would need to reference images somehow,
    using some sort of identity. It makes us certain that our future `Picture` objects
    will be entities so we can reference them by an identity inside the aggregate.
    If we do that, we do not need to have an `ImageOrder` object, since we can keep
    the ordering attribute inside the `Picture` object itself. So, our entity will
    have the option of a state change, and we need to handle that too.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向我们的 `ClassifiedAd` 聚合添加一个实体来阐述这个原则。我们的一次 EventStorming 会话帮助我们发现，我们需要将图片添加到广告中，因为没有图片，人们真的会犹豫是否购买任何东西。一个广告可以有多个图片，我们可以将这些图片视为值对象，因为用户不能
    *更改* 图片。他们可以上传新的图片或删除现有的图片。然而，似乎用户需要能够选择图片的顺序以及搜索结果中显示的图片，即 *主要* 图片。我们可以通过使用一个名为
    `ImageOrder` 的值对象来解决这个问题，每次用户更改图片顺序时，它都会被替换。但是，即使在在这种情况下，我们也需要以某种方式引用图片，使用某种形式的标识符。这让我们确信我们的未来
    `Picture` 对象将是实体，这样我们就可以在聚合内部通过标识符来引用它们。如果我们这样做，我们就不需要有一个 `ImageOrder` 对象，因为我们可以在
    `Picture` 对象本身内部保持排序属性。因此，我们的实体将具有状态变化的选择，我们也需要处理这一点。
- en: 'We can use the `Entity` base class to create our new `Picture` class in the
    `Domain` project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Entity` 基类在 `Domain` 项目中创建我们的新 `Picture` 类：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we do not expect to hold the image itself inside the entity as a byte
    array. The physical image itself is not a concern for our domain. Within the domain
    model, we assume that all images are stored somewhere and we just need to have
    an image location (a URL to an external resource) to be connected to the classified
    ad.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们并不期望在实体内部以字节数组的形式保存图像本身。物理图像本身不是我们领域的问题。在领域模型中，我们假设所有图像都存储在某个地方，我们只需要有一个图像位置（一个指向外部资源的
    URL）与分类广告连接。
- en: 'We still need to remember that all operations are executed by calling the aggregate
    root, so we add an operation to the `ClassifiedAd` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要记住，所有操作都是通过调用聚合根来执行的，所以我们向 `ClassifiedAd` 类添加了一个操作：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, we need to create a class for the `PictureAddedToAClassifiedAd`
    event as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要为 `PictureAddedToAClassifiedAd` 事件创建一个类：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the event class, `ClassifiedAdId` is the ID of our aggregate root. The picture
    ID is externally generated, and it will be sent to the application service by
    the client, but we will never use this ID to directly reference the picture from
    outside the aggregate boundaries. Also, we assume that pictures are always added
    to the end of the list, so we don't need to send the order number since it will
    be assigned by the aggregate logic.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件类中，`ClassifiedAdId` 是我们的聚合根的 ID。图片 ID 是外部生成的，它将由客户端发送到应用服务，但我们永远不会使用这个 ID
    直接从聚合边界之外引用图片。此外，我们假设图片总是添加到列表的末尾，因此我们不需要发送顺序号，因为顺序号将由聚合逻辑分配。
- en: 'We used two value objects as parameters for the `AddPicture` method. The `System.Uri`
    type is a .NET framework standard type, and we only need to define the `PictureSize`
    value object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `AddPicture` 方法使用了两个值对象作为参数。`System.Uri` 类型是 .NET 框架的标准类型，我们只需要定义 `PictureSize`
    值对象：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, we use the power of value objects and ensure the validity of input values
    inside it, so we don't need to spread this logic everywhere. We still need an
    internal constructor that will allow us to create this object without validating
    values because we need to be able to unconditionally retrieve the existing object
    from the database, and we cannot rely on the idea that validation rules will not
    change over time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用值对象的力量并确保其内部的输入值的有效性，因此我们不需要将此逻辑传播到每个地方。我们仍然需要一个内部构造函数，它将允许我们创建此对象而不验证值，因为我们需要能够无条件地从数据库检索现有对象，并且我们不能依赖于验证规则不会随时间变化的想法。
- en: Also here, throwing an exception is not the only way you can use to protect
    value objects from becoming invalid. One alternative way is to create a property
    `IsValid` for the value object but then you need to check it everywhere when using
    the value, probably in the application service. Another alternative is to create
    a special static object instance that would indicate an incorrect value. You can
    then check if the value you are trying to apply is valid or not. Although you'd
    need more code to implement both of those methods, you will avoid throwing exceptions.
    Remember that unlike Java, C# has no way to explicitly inform those who call your
    objects that the method can throw an exception.  Therefore, some callers won't
    be considering wrapping the call in a try-catch block and the application can
    blow up at runtime.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在这里，抛出异常并不是保护值对象免于无效的唯一方法。一种替代方法是为值对象创建一个`IsValid`属性，但随后你需要在使用值时到处检查它，可能是在应用程序服务中。另一种替代方法是创建一个特殊的静态对象实例，用来指示不正确的值。然后你可以检查你试图应用的价值是否有效。虽然实现这两个方法可能需要更多的代码，但你将避免抛出异常。记住，与Java不同，C#没有明确通知调用你的对象该方法可以抛出异常的方法。因此，一些调用者可能不会考虑在调用时包裹try-catch块，应用程序可能在运行时崩溃。
- en: 'Now, we have to change the aggregate state after we apply the new event to
    the aggregate root. We do this by adding a new case to our pattern matching `case`
    in the `When` method of the `ClassifiedAd` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在将新事件应用到聚合根之后，必须更改聚合状态。我们通过向`ClassifiedAd`类的`When`方法中的模式匹配`case`添加一个新的情况来完成此操作：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you might have noticed, we referenced a new property called `Pictures`.
    It is the list of entities that are held inside the aggregate, so they are child
    objects of our aggregate root. We declare it as a list. We also need to initialize
    the list in the aggregate root constructor, so we don''t get a null reference
    exception when we don''t have any pictures and try to add one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所注意到的，我们引用了一个名为`Pictures`的新属性。它是包含在聚合内的实体列表，因此它们是聚合根的子对象。我们将其声明为一个列表。我们还需要在聚合根构造函数中初始化这个列表，这样当我们没有图片而尝试添加一个时，就不会得到空引用异常：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This all seems fine, except it isn't. Our aggregate root performs the logic
    that belongs to the `Picture` entity itself. For now, it is just one operation,
    but we definitely expect at least the re-ordering functionality. The entity needs
    to be responsible for updating its own state, and since we do it using events,
    it needs to get the events that concern that entity. Notice that our `Picture`
    class implements the `When` method from the base class, but it is completely empty.
    We need to find a way to empower our entities to handle their own events. In addition,
    entities can have their own methods, so the aggregate root doesn't contain the
    logic that belongs to entities, and instead calls entity methods. When we add
    methods to an entity class, it will produce events to change the entity state.
    But those events can be of interest for the aggregate root as well, so we need
    to have some code that will traverse events from the entity level to the aggregate
    root level. Finally, we need events that are raised on the entity level to be
    added to the list of changes for the whole aggregate, and this list is maintained
    by the aggregate root. All those things require us to change the base classes,
    and that is what we are going to do now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来似乎没问题，但实际上并不是。我们的聚合根执行属于`Picture`实体本身的逻辑。目前，它只是一个操作，但我们确实期望至少有重新排序功能。实体需要负责更新其自身状态，并且由于我们使用事件来执行此操作，它需要获取与该实体相关的所有事件。请注意，我们的`Picture`类实现了基类的`When`方法，但它完全是空的。我们需要找到一种方法来赋予我们的实体处理它们自己的事件的能力。此外，实体可以有自己的方法，因此聚合根不包含属于实体的逻辑，而是调用实体方法。当我们向实体类添加方法时，它将产生事件以更改实体状态。但那些事件也可能对聚合根有利益，因此我们需要一些代码来遍历从实体级别到聚合根级别的所有事件。最后，我们需要将实体级别上引发的事件添加到整个聚合的更改列表中，而这个列表由聚合根维护。所有这些都需要我们更改基类，这正是我们现在要做的。
- en: 'First, we add a new interface that both our entity base classes will implement.
    This interface has one method that applies domain events to an entity state (currently,
    we use the `When` method):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的实体基类添加一个新的接口。这个接口有一个方法，将域事件应用于实体状态（目前，我们使用`When`方法）：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we make a number of changes to the `AggregateRoot` base class. This will
    implement the new interface using a private explicit method. In addition, we add
    the `ApplyToEntity` method, which will allow us to push domain events to entities.
    This method does nothing when we pass `null` as the entity parameter because we
    plan to call it from the `When` method of the aggregate root and it should *never*
    fail. We will elaborate on why that is so in [Chapter 8](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml), *Aggregate
    Persistence*, when we''ll talk about Event Sourcing. For now, we shall assume
    that our action method in the aggregate root will ensure that the child entity
    is present before producing an event that we will be propagating to the entity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对`AggregateRoot`基类进行了一些修改。这将通过一个私有的显式方法实现新的接口。此外，我们添加了`ApplyToEntity`方法，这将允许我们将领域事件推送到实体。当我们将实体参数传递为`null`时，此方法不做任何事情，因为我们计划从聚合根的`When`方法中调用它，并且它应该*永远不会失败*。我们将在第8章[4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml]中详细说明这一点，即*聚合持久化*，届时我们将讨论事件溯源。现在，我们假设聚合根中的操作方法将确保在产生我们将传播到实体的事件之前，子实体是存在的：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we need to change the `Entity` base class code in a way that it implements
    the new interface as well:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要以实现新接口的方式修改`Entity`基类代码：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also added a constructor to this class that will accept an `applier` delegate.
    Since we always instantiate entities from the aggregate root, we will pass the
    `Apply` method of the root to all entities. Then, an entity will use double dispatch
    to inform the aggregate root of events that the entity will be producing. By doing
    this, we'll make sure that the aggregate root can also handle events from its
    child entities, that it calls the `EnsureValidState` method to ensure that there
    is no consistency violation within the aggregate boundaries, and that it adds
    new events to the single list of changes for the whole aggregate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向这个类添加了一个构造函数，它将接受一个`applier`代理。由于我们总是从聚合根实例化实体，我们将根的`Apply`方法传递给所有实体。然后，一个实体将使用双重分派来通知聚合根它将产生的事件。通过这样做，我们将确保聚合根也可以处理来自其子实体的事件，它调用`EnsureValidState`方法来确保聚合边界内没有一致性违规，并且它将新事件添加到整个聚合的单个更改列表中。
- en: We use private methods to implement the new interface, so these methods will
    not be exposed when we use a class that is inherited from the `AggregateRoot`
    or `Entity` base classes, and this is exactly what we want.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用私有方法来实现新接口，因此当使用从`AggregateRoot`或`Entity`基类继承的类时，这些方法不会被暴露，这正是我们想要的。
- en: 'So, our `Picture` entity now requires a little refactoring:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`Picture`实体现在需要进行一点重构：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We changed two things:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改了两件事：
- en: We added the constructor that accepts a reference to the `applier` delegate.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个接受`applier`代理引用的构造函数。
- en: We changed the `When` method, so it can now handle the creation of new pictures.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们更改了`When`方法，使其现在可以处理新图片的创建。
- en: You perhaps noticed that the order is now coming from the event, so we need
    to add a new property to the event class. Currently, we don't use the `applier`
    delegate, because we have not added any operations to the entity yet, but we will
    be using it in the future. Also, it is important to stress that we are not using
    the public constructor for our `PictureSize` value object in the `When` method
    because the public constructor always applies business rules and can potentially
    fail, but it happens when we construct the value object in our application service
    before it even reaches the aggregate. In the `When` method, we need to process
    the event without checking those rules, because the `When` method should never
    fail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，顺序现在来自事件，因此我们需要在事件类中添加一个新属性。目前，我们没有使用`applier`代理，因为我们还没有向实体添加任何操作，但我们将会在未来使用它。此外，重要的是强调，我们在`When`方法中不使用`PictureSize`值对象的公共构造函数，因为公共构造函数始终应用业务规则，并且可能失败，但这发生在我们在应用程序服务中构建值对象之前，甚至还没有达到聚合。在`When`方法中，我们需要在不检查这些规则的情况下处理事件，因为`When`方法不应该失败。
- en: 'Then, we can change the aggregate root code. First, we change the `AddPicture`
    method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更改聚合根代码。首先，我们更改了`AddPicture`方法：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we change the event handling in the `When` method (only changes are shown):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更改了`When`方法中的事件处理（仅显示更改）：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's now demonstrate how can we add some logic to the `Picture` entity and
    make sense of the `applier` delegate. One thing that can happen with an image
    is that it could be resized and we get new sizes. Out page, cannot be smaller
    than 800 x 600 pixels.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们演示如何向`Picture`实体添加一些逻辑，并理解`applier`委托的含义。一件可能发生的事情是图像可以被调整大小，我们得到新的尺寸。我们的页面不能小于800
    x 600像素。
- en: 'Again, we need to add a new event to our `Events` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要向我们的`Events`类添加一个新的事件：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to add a `ResizePicture` method to the aggregate root. Since
    the command will get a picture `id`, we need to be able to find this picture in
    the list. To avoid spreading LINQ queries, we can add the following method to
    the `ClassifiedAd` class:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在聚合根中添加一个`ResizePicture`方法。由于命令将获取一个图片`id`，我们需要能够在列表中找到这张图片。为了避免传播LINQ查询，我们可以在`ClassifiedAd`类中添加以下方法：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we can add the action method to the same class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在同一个类中添加动作方法：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When this is done, we can add a new `Resize` method to the `Picture` entity:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当这完成时，我们可以在`Picture`实体中添加一个新的`Resize`方法：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we add some code to change the `Picture` state when the event is raised
    to the `When` method of the entity:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一些代码来在事件被提升到实体的`When`方法时更改`Picture`的状态：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we are done with these changes, we can add an additional invariant to
    our aggregate. We can define the picture size rule directly in each check inside
    the `EnsureValidState` method, but it will be quite verbose and not very clear
    from the language perspective. Instead, let''s create a new extension method for
    the `Picture` entity, using a new `PictureRules` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这些更改后，我们可以在我们的聚合中添加一个额外的不变量。我们可以在`EnsureValidState`方法中的每个检查中直接定义图片大小规则，但这将会非常冗长，并且从语言角度来看并不清晰。相反，让我们为`Picture`实体创建一个新的扩展方法，使用一个新的`PictureRules`类：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use an extension method instead of putting this logic inside the entity itself
    because it is not really a rule for the entity. Perhaps the class name `PictureRules`
    is not very good and we need to fix it. On the other hand, we will never use the
    class name itself because it will only contain extension methods.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用扩展方法而不是将此逻辑放在实体内部，因为它并不是实体的规则。也许类名`PictureRules`并不很好，我们需要修复它。另一方面，我们永远不会使用类名本身，因为它只会包含扩展方法。
- en: 'Let''s change the invariant check code to include a new rule:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将不变量检查代码更改为包括一条新规则：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can see that we need one more piece of code to make things more explicit.
    Instead of using a LINQ expression in every call to find the *first* picture (we
    might need a better domain name for that too), we will use the `FirstPicture`
    property of the aggregate root. Now the check became less technical and more explicit
    in terms of the domain language. We might also create some more methods to enforce
    the language for other rules as well, and we will do this later throughout the
    course of this book.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们需要更多的代码来使事情更加明确。我们不会在每次调用时使用LINQ表达式来查找第一个图片（我们可能也需要为它找到一个更好的领域名称），我们将使用聚合根的`FirstPicture`属性。现在检查变得更加技术化，并且在领域语言方面更加明确。我们可能还会创建更多方法来强制执行其他规则的领域语言，我们将在本书的整个过程中这样做。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we composed a few aggregates and performed operations on them
    via the aggregate root. We also evaluated possible persistence methods for aggregates
    and learned about the concept of the repository—a place where the aggregate state
    is stored.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们组合了一些聚合，并通过聚合根对它们进行了操作。我们还评估了聚合的可能持久化方法，并了解了存储聚合状态的仓库概念。
- en: Now, it is time to find a way to store our domain objects in a database and
    see our application working for the first time. In the next chapter, we will take
    a deep dive into the topic of aggregate persistence.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候找到一种方法来将我们的领域对象存储在数据库中，并看到我们的应用程序第一次运行。在下一章中，我们将深入探讨聚合持久化的主题。
