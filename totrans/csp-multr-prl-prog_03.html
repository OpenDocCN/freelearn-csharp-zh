<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Thread Class – Heavyweight Concurrency in C#</h1></div></div></div><p>In the previous chapter, we examined the <code class="literal">BackgroundWorker</code> component and how to use it to achieve performance gains by multithreading our application. This component is useful but has many limitations. In order to have very precise control over the concurrently running threads in our applications, we can use the <code class="literal">Thread</code> class instead.</p><p>In this chapter, we will study this class in detail and develop more complex multithreaded applications that take full advantage of the multiprocessing capabilities of today's hardware.</p><p>We will use the terms <strong>heavyweight concurrency</strong><a id="id130" class="indexterm"/> and <strong>lightweight concurrency</strong><a id="id131" class="indexterm"/> throughout this book. Let's take a minute to reflect on what we mean by this. When we use the <code class="literal">Thread</code> class, as we will see in this and the next chapter, we will develop multithreaded applications through heavyweight concurrency. This means that it is up to us to create, coordinate, and manage the different threads in our application. It will also be up to us to know how many processing cores the hardware has that runs our application in order to maximize the multithreading efficiency of our application. We use the term heavyweight concurrency to describe this kind of multithreaded development because it takes extra code and work on the developer's part to achieve maximum benefits. We have to create the threads, coordinate the interaction of the threads, manage when threads have completed, and so on.</p><p>Later in the book, we will study the <code class="literal">Task</code> class and<a id="id132" class="indexterm"/> <strong>Task Parallel Library</strong> (<strong>TPL</strong>). This library is a recent addition to the .NET framework and takes multithreading application development to the next level. Using these classes allows the developer to achieve the maximum benefits of multithreading an application with much less effort. </p><p>TPL handles thread creation, coordination, and management for you. Developing using the TPL classes is referred to as lightweight concurrency because it takes less effort by the developer. There are some downsides, as we will see, to using these classes because much of the multithreaded work is handled for you and may not be done exactly how you want it to be.</p><p>So, depending on your application and expertise, there are times when both heavyweight concurrency and lightweight concurrency are the right solution. The key is to understand both and know when to use each.</p><p>For now, we will focus on heavyweight concurrency and the <code class="literal">Thread</code> class. After reading this chapter and following the exercises, we shall be able to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop applications with great control over multiple running threads, offering exciting performance enhancements</li><li class="listitem" style="list-style-type: disc">Learn how to create independent and very flexible threads using a very powerful class</li><li class="listitem" style="list-style-type: disc">Find out how to start, control, and coordinate multiple threads</li><li class="listitem" style="list-style-type: disc">Discover how to send parameters to and retrieve data from threads</li><li class="listitem" style="list-style-type: disc">Learn how to share data between many threads</li><li class="listitem" style="list-style-type: disc">Find out how to combine asynchronous and synchronous execution in order to have exhaustive control over the running threads and their tasks</li><li class="listitem" style="list-style-type: disc">Develop applications capable of launching multiple threads when necessary</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Creating threads with the Thread class</h1></div></div></div><p>So far, we have used <a id="id133" class="indexterm"/>the <code class="literal">BackgroundWorker</code> component to create new <a id="id134" class="indexterm"/>threads independent of the main application thread. The applications can respond to UI events while processing continues and take full advantage of multiple cores, thus running faster. However, there are some restrictions when we must control and coordinate the execution of many threads that are not intended to just run in the background. Now, let's learn how to use the <code class="literal">Thread</code> class to make an application capable of taking full control of the synchronous and asynchronous execution of concurrent threads. The <code class="literal">Thread</code> class is just what it sounds like, a class that allows you to create separate threads of execution for your process to run.</p><p>We can work with many instances of the <code class="literal">Thread</code> class (<code class="literal">System.Threading.Thread</code>) in order to run many concurrent threads with more control capabilities than the ones created using the <code class="literal">BackgroundWorker</code> component. As we learned in the previous chapter, the performance results will depend upon the number of cores or processors available in the computer on which we run the application. However, the <code class="literal">Thread</code> class offers many fine-tuning capabilities to help us achieve the desired performance using multithreading.</p><p>The <code class="literal">Thread</code> class does a great job of offering great flexibility while offering a simple way to initialize, coordinate, run, stop, and free multiple threads.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Let's get started with an encryption program</h2></div></div></div><p>To demonstrate how to use the<a id="id135" class="indexterm"/> <code class="literal">Thread</code> class, we are going to create a simple WPF application that takes text messages and encrypts and decrypts them. The customers of this application are working with a new cellular phone capable of sending SMS (text messages) with access to the complete Unicode character set. The cellular phone is a single-core device. The application has to work in a very fast and efficient encryption engine capable of encrypting the incoming text messages and leaving them in an output queue. This engine is going to run on a huge server with many multi-core processors. They want it to use a very fine-tuned multithreading application capable of working with as many threads as there are available cores in the computer on which the engine is being executed. So, the application will have to be smart enough to detect the number of cores and create that many threads. In this way, it uses the full capabilities of the hardware, but doesn't create extra threads that will not further enhance performance.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>How to do it</h2></div></div></div><p>First, we are going to<a id="id136" class="indexterm"/> build a new C# WPF application, and we will <a id="id137" class="indexterm"/>define and test the methods to encrypt and decrypt a string:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new C# project using the WPF application template in Visual Studio. Use <code class="literal">SMSEncryption</code> as the project's name.</li><li class="listitem">Open <code class="literal">MainWindow.xaml</code> in the designer mode, add the following controls, and align them as shown in the following screenshot:<div><img src="img/8321EN_03_01.jpg" alt="How to do it"/></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One <a id="id138" class="indexterm"/>image showing a text message <a id="id139" class="indexterm"/>graphic called <code class="literal">imgTextMessage</code>.</li><li class="listitem" style="list-style-type: disc">Three textboxes with their <code class="literal">Text</code> property set to <code class="literal">SMS Encryption Engine</code>, <code class="literal">Original Messages</code>, and <code class="literal">Encrypted Messages</code>.</li><li class="listitem" style="list-style-type: disc">Two textboxes with their <code class="literal">Names</code> property set to <code class="literal">txtOriginalSMS</code> and <code class="literal">txtEncryptedSMS</code>, and their <code class="literal">AcceptsReturn</code> property set to <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc">One button control named <code class="literal">butTest</code> with its <code class="literal">Text</code> property set to <code class="literal">Test</code>. This is the button that will test the encryption and decryption methods.</li></ul></div></li><li class="listitem">Next, add a class file called <code class="literal">EncryptionProcedures</code> that has two static methods, one called <code class="literal">Encrypt</code> and the other called <code class="literal">Decrypt</code>.</li><li class="listitem">The <code class="literal">Encrypt</code> method <a id="id140" class="indexterm"/>will encrypt the string received as a parameter and return a string containing the resulting encoded message<a id="id141" class="indexterm"/> with unrecognizable characters. Add the following code for this method:<div><pre class="programlisting">    public static string Encrypt(string psText)
  {
            string lsEncryptedText;
            string lsEncryptedTextWithFinalXOR;
            // A Random number generator
            Random loRandom = new Random();

            // The char position being encrypted
            int i;
            char loRandomChar;

            // Debug
            // Show the original text in the Immediate Window
            System.Diagnostics.Debug.Print("Original text:" + psText);

            lsEncryptedText = "";
            for (i = 0; i &lt;= (psText.Length - 1); i++)
            {
                loRandomChar = (char)(loRandom.Next(65535));
                // Current char XOR random generated char

                // Debug
                // Show the random char code (in numbers) generated in the Immediate Window
                System.Diagnostics.Debug.Print("Random char generated:" + ((int)loRandomChar).ToString());

                lsEncryptedText += ((char)(psText[i] ^ loRandomChar)).ToString();
                // Random generated char XOR 65535 - i
                // It is saved because we need it later for the decryption process
                lsEncryptedText += ((char)(loRandomChar ^ (65535 - i))).ToString();
                // Another random generated char but just to add garbage to confuse the hackers
                loRandomChar = (char)(loRandom.Next(65535));
                lsEncryptedText += loRandomChar.ToString();

                // Debug
                // Show how the encrypted text is being generated in the Immediate Window
                System.Diagnostics.Debug.Print("Partial encryption result char number: " + i.ToString() + ": " + lsEncryptedText);

            }

            lsEncryptedTextWithFinalXOR = "";
            // Now, every character XOR 125
            for (i = 0; i &lt;= (lsEncryptedText.Length - 1); i++)
            {
                lsEncryptedTextWithFinalXOR += ((char)(lsEncryptedText[i] ^ 125)).ToString();
            }

            // Debug
            // Show how the encrypted text is being generated in the Immediate Window
            System.Diagnostics.Debug.Print("Final encryption result with XOR: " + lsEncryptedTextWithFinalXOR);

            return lsEncryptedTextWithFinalXOR;
        
}</pre></div></li><li class="listitem">The <code class="literal">Decrypt</code> method <a id="id142" class="indexterm"/>will decrypt the encrypted string<a id="id143" class="indexterm"/> received as a parameter and return a string with the resulting decoded message:<div><pre class="programlisting">        public static string Decrypt(string psText)
        {
            // The decrypted text to return
            string lsDecryptedText;

            // The char position being decrypted
            int i;
            // The random char
            char loRandomChar;

            lsDecryptedText = "";
            for (i = 0; i &lt;= (psText.Length - 1); i += 3)
            {
                // Retrieve the previously random generated char XOR 125 XOR 65535 - i (but previous i)
                loRandomChar = (char)(psText[i + 1] ^ 125 ^ (65535 - (i / 3)));
                // Char XOR random generated char
                lsDecryptedText += ((char)(psText[i] ^ 125 ^ loRandomChar)).ToString();
            }

            return lsDecryptedText;
    }</pre></div></li><li class="listitem">Open the <code class="literal">Click</code> event <a id="id144" class="indexterm"/>handler method for the button, <code class="literal">butTest</code>, and <a id="id145" class="indexterm"/>enter the following code:<div><pre class="programlisting">           private void butTest_Click(object sender, RoutedEventArgs e)
   {
            // The encrypted text
            string lsEncryptedText;

            // For each line in txtOriginalSMS TextBox
            int lineCount = txtOriginalSMS.LineCount;
            for (int line = 0; line &lt; lineCount; line++)
            {
                lsEncryptedText = EncryptProcedures.Encrypt(txtOriginalSMS.GetLineText(line));
                // Append a line with the Encrypted text
                txtEncryptedSMS.AppendText(lsEncryptedText + Environment.NewLine);
                // Append a line with the Encrypted text decrypted to test everything is as expected
                txtEncryptedSMS.AppendText(EncryptProcedures.Decrypt(lsEncryptedText) + Environment.NewLine);
            }
        }</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Enter a short text in the textbox labeled <code class="literal">Original SMS Messages</code>, and click on the <strong>Test</strong> button. The encrypted message will appear in the textbox labeled <code class="literal">Encrypted SMS Messages</code>. The decrypted message will also become visible in the bottom textbox, but this will be the result of decrypting the encrypted message to test the algorithm.</li><li class="listitem">The results will look <a id="id146" class="indexterm"/>similar to the following <a id="id147" class="indexterm"/>screenshot:<div><img src="img/8321EN_03_02.jpg" alt="How to do it"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>How it works</h2></div></div></div><p>In this program, we <a id="id148" class="indexterm"/>have created the <code class="literal">Encrypt</code> and <code class="literal">Decrypt</code> methods<a id="id149" class="indexterm"/> that take a <code class="literal">String</code> value and encrypt and decrypt it, respectively. The encryption algorithm uses a random number generator and many <a id="id150" class="indexterm"/>
<strong>Exclusive OR</strong> (<strong>XOR</strong>) operations. It also adds garbage in the text in order to confuse potential hackers.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Remember that in C#, the XOR operation is specified by the <code class="literal">^</code> operator and can be applied to numbers. Thus, we needed many typecastings to <code class="literal">char</code> type, and then we called the <code class="literal">ToString()</code> method.</p></div></div><p>One of the most exciting properties of the XOR operation is the possibility of returning to the original value when it is applied twice. For example, consider the following lines of code:</p><div><pre class="programlisting">int liOriginalValue = 120;
int liFirstXOR = liOriginalValue ^ 250;
int liSecondXOR = liFirstXOR ^ 250;</pre></div><p>The value assigned to <code class="literal">liSecondXOR</code> will be the same as is in <code class="literal">liOriginalValue</code>, that is, <code class="literal">120</code>.</p><p>As the encryption algorithms use the complete Unicode character set, with 65,536 possible characters, the resulting text is unreadable and very confusing, as it is not limited to the classic 256-character set.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Creating an application with threads</h1></div></div></div><p>As we have tested the decryption <a id="id151" class="indexterm"/>of the previously encrypted message, we are <a id="id152" class="indexterm"/>sure it is working fine. We are now going to run the encryption algorithm in a new thread created using the <code class="literal">Thread</code> class.</p><p>We want to use the <code class="literal">Thread</code> class to have tight control over the execution of the different processing threads in our application. First, we need to make the encryption function run in just one thread. Later, we will align the threads with the number of cores in our hardware to ensure maximum efficiency. So, for now, we will change the application we previously built so that the encryption logic runs in a separate thread from the main application. This will begin to give us control over when and how we encrypt the text messages.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>How to do it</h2></div></div></div><p>Now, we are going to make some changes to the application, and we will encrypt the messages in a new independent thread created and configured using the <code class="literal">Thread</code> class:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SMSEncryption</code> project.</li><li class="listitem">Add a button control (<code class="literal">butRunInThread</code>). Set its <code class="literal">Text</code> property to <code class="literal">Run in a Thread</code>.</li><li class="listitem">Since we are going to use the <code class="literal">Thread</code> class, we need to add a <code class="literal">Using</code> statement so that our application can find this class from the .NET framework. Add the following line of code at the beginning (as we are going to use the <code class="literal">System.Threading.Thread</code> class):<div><pre class="programlisting">    using System.Threading;</pre></div></li><li class="listitem">Add the following<a id="id153" class="indexterm"/> line in the <code class="literal">MainWindow</code> code-behind <a id="id154" class="indexterm"/>file, <code class="literal">MainWindow.xaml.cs</code> class definition to declare three new private variables:<div><pre class="programlisting">    // The thread
    private Thread proThreadEncryption;
    // The string list with SMS messages to encrypt (input)
    private List&lt;string&gt; prlsSMSToEncrypt;
    // The string list with SMS messages encrypted (output)
    private List&lt;List&lt;string&gt;&gt; prlsEncryptedSMS;</pre></div></li><li class="listitem">Add one button control named <code class="literal">butRunInThread</code> with its <code class="literal">Text</code> property set to <code class="literal">Run in a Thread</code>. This is the button that will test the encryption and decryption methods running in a separate thread from the main thread.</li><li class="listitem">Open the <code class="literal">Click</code> event method for the <code class="literal">butRunInThread</code> button and enter the following code to run the encryption process in a new thread created using the <code class="literal">Thread</code> class:<div><pre class="programlisting">private void butRunInThread_Click(object sender, RoutedEventArgs e)
        {
            // Prepare everything the thread needs from the UI
            // For each line in txtOriginalSMS TextBox
            prlsSMSToEncrypt = new List&lt;string&gt;(txtOriginalSMS.LineCount);

            // Add the lines in txtOriginalSMS TextBox
            int lineCount = txtOriginalSMS.LineCount;
            for (int line = 0; line &lt; lineCount; line++)
            {
                prlsSMSToEncrypt.Add(txtOriginalSMS.GetLineText(line));
            }
            // Create the new Thread and use the ThreadEncryptProcedure method
            proThreadEncryption = new Thread(new ThreadStart(ThreadEncryptProcedure));

            // Start running the thread
            proThreadEncryption.Start();

            // Join the independent thread to this thread to wait until ThreadProc ends
            proThreadEncryption.Join();

            // When the thread finishes running this is the next line that is going to be executed
            // Copy the string List generated by the thread
            foreach (string lsEncryptedText in prlsEncryptedSMS)
            {
                // Append a line with the Encrypted text
                txtEncryptedSMS.AppendText(lsEncryptedText +
                 Environment.NewLine);
            }
   }</pre></div></li><li class="listitem">Now, we need to<a id="id155" class="indexterm"/> create the <code class="literal">ThreadEncryptProcedure</code> that <a id="id156" class="indexterm"/>will run in a separate thread and encrypt the text message. Enter the following code to create this procedure.<div><pre class="programlisting">    private void ThreadEncryptProcedure()
        {
            string lsEncryptedText;

            //Initialize the encrypted array to the size of the array to encrypt.
            prlsEncryptedSMS = new List&lt;string&gt;(prlsSMSToEncrypt.Count);

            // Line of text message to encrypt
            string lsText;

            // Iterate through each string in the prlsSMSToEncrypt string
            for (int i = 0; i &lt; prlsSMSToEncrypt.Count; i++)
            {
                lsText = prlsSMSToEncrypt[i];
                lsEncryptedText = EncryptProcedures.Encrypt(lsText);
                
                // Add the encrypted string to the List of encrypted strings
                prlsEncryptedSMS.Add(lsEncryptedText);
            }
   }</pre></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Enter or copy<a id="id157" class="indexterm"/> and paste a long text in the <code class="literal">Textbox</code> labeled <code class="literal">Original SMS Messages</code> and click on the <strong>Run in a Thread</strong> button. The <a id="id158" class="indexterm"/>encrypted message will appear in the <code class="literal">Textbox</code> labeled <code class="literal">Encrypted Messages</code>. However, the code runs in a different thread. The results will be similar to what is shown in the following screenshot:<div><img src="img/8321EN_03_03.jpg" alt="How to do it"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>How it works</h2></div></div></div><p>Now, when the <a id="id159" class="indexterm"/>user clicks the <strong>Run in a Thread</strong> button, the encryption<a id="id160" class="indexterm"/> runs in a new thread, but with synchronous execution. We create the thread and then we start the thread with the <code class="literal">proThreadEncryption.Start();</code> command. Since it is a synchronous operation, we then wait on the thread to complete operation with the <code class="literal">proThreadEncryption.Join();</code> command. So, in a separate thread, the <code class="literal">ThreadEncryptProcedure</code> runs and encrypts the text message string into a list of strings.</p><p>When the thread running the <code class="literal">ThreadEncryptProcedure</code> completes, the main thread, which was waiting on the thread to complete by executing the <code class="literal">Join</code> command, continues and takes the encrypted list of strings and displays them in the bottom textbox.</p><p>The <code class="literal">Thread.Join</code> method tells the issuing thread to wait here until the thread completes. As we are not using a <code class="literal">BackgroundWorker</code> component, which simplified UI decoupling, we must do that work in code.</p><p>The following lines declare the two private string lists that will work as an input (<code class="literal">prlsSMSToEncrypt</code>) and as an output (<code class="literal">prlsEncryptedSMS</code>) for the new independent thread:</p><div><pre class="programlisting">private List&lt;string&gt; prlsSMSToEncrypt;
private List&lt;List&lt;string&gt;&gt; prlsEncryptedSMS;</pre></div><p>When started, the <a id="id161" class="indexterm"/>thread will execute the code in the <code class="literal">ThreadEncryptProcedure</code> (without parameters). This procedure is private and resides in the same class<a id="id162" class="indexterm"/> as the two aforementioned private string lists. Thus, the code in the <code class="literal">ThreadEncryptProcedure</code> can access these two variables to take the input strings, encrypt them, and add them to the output string list. Instead of working against the UI controls, we decouple the UI and avoid the problems related to multithreading with the UI.</p><p>
<code class="literal">ThreadEncryptProcedure</code> does a very simple task without touching the UI controls. For each string in the input string list (<code class="literal">prlsSMSToEncrypt</code>), it encrypts the string and adds it to the output string list (<code class="literal">prlsEncryptedSMS</code>).</p><p>When the user clicks on the <strong>Run in a Thread</strong> button, the following lines prepare everything the thread needs from the UI:</p><div><pre class="programlisting">            prlsSMSToEncrypt = new List&lt;string&gt;(txtOriginalSMS.LineCount);

            // Add the lines in txtOriginalSMS TextBox
            int lineCount = txtOriginalSMS.LineCount;
            for (int line = 0; line &lt; lineCount; line++)
            {
                prlsSMSToEncrypt.Add(txtOriginalSMS.GetLineText(line));
            }</pre></div><p>First, we create a new instance of <code class="literal">List&lt;string&gt;</code>. As mentioned earlier, we pass the number of items (capacity) as a parameter in order to optimize the execution, using the <code class="literal">LineCount</code> property for the lines in the <code class="literal">txtOriginalSMS</code> textbox.</p><p>Then, we use the <code class="literal">Add</code> method to add all the strings to our new <code class="literal">List&lt;string&gt;</code> instance. Now, we have everything the thread needs as an input in a private <code class="literal">List&lt;string&gt;</code>, which it can access without problems.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Mastering the use of lists, arrays, and collections is a must when working with multithreading.</p></div></div><p>This is a very simple<a id="id163" class="indexterm"/> way to share data with a new independent thread <a id="id164" class="indexterm"/>without complications. However, we must be very careful, as we must learn more things in order to change data in the same variables accessed from many threads.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>When we access variables from multiple threads, they must be of thread safety types. <strong>Thread safety types</strong><a id="id165" class="indexterm"/> are those that are safe for multithreaded operations. If you have any doubt about a type, you can check whether it is of a thread safety type or not in the C# documentation. It offers a section describing the thread safety, as shown in the following screenshot for the <code class="literal">Int32</code> type:</p><div><img src="img/8321EN_03_04.jpg" alt="How it works"/></div></div></div><p>The following line declared the <code class="literal">proThreadEncryption</code> variable with the <code class="literal">Thread</code> type:</p><div><pre class="programlisting">private Thread proThreadEncryption;</pre></div><p>When the user clicks on the <strong>Run in a Thread</strong> button, the following lines create an instance of the <code class="literal">Thread</code> class specifying the method it must execute in the new thread when it is started. In order to accomplish this, we use the <code class="literal">ThreadStart</code> delegate because we do not need to send parameters or other data to the thread for initialization purposes:</p><div><pre class="programlisting">proThreadEncryption = new  Thread(newThreadStart(ThreadEncryptProcedure));</pre></div><p>Once the thread is created, it does not start running the code in the specified <code class="literal">ThreadEncryptProcedure</code> until we call the <code class="literal">Start()</code> method. Since we do not want to send parameters to the procedure, we use the <code class="literal">Start()</code> method:</p><div><pre class="programlisting">proThreadEncryption.Start();</pre></div><p>This method tells<a id="id166" class="indexterm"/> the scheduler to start running the code in the new<a id="id167" class="indexterm"/> independent thread with an asynchronous execution. However, as it is executed asynchronously, we lose control over the time when the code in the thread begins running. It can be 100 milliseconds, 200 milliseconds, or 2 seconds.</p><p>In this case, we do not want to start an independent thread and lose control over its execution time, but we want to start it with a synchronous execution and wait, in the main thread, until it finishes. In order to do so, we call the <code class="literal">Join</code> method in the next line:</p><div><pre class="programlisting">proThreadEncryption.Join();</pre></div><p>It makes the new thread run the <code class="literal">ThreadEncryptProcedure</code> code. Once it finishes its execution, it returns control to the main thread and goes on with the next statement.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>It works as if we were calling a classic method, but in another thread.</p></div></div><p>Separating the code in a new thread using the <code class="literal">Thread</code> class is easy if we follow this simple code pattern.</p><p>Since it was joined with the main thread, the statements after the call to the <code class="literal">Join</code> method are executed as soon as the thread finishes its execution. These lines collect the encrypted strings generated in the <code class="literal">prlsEncryptedSMS</code> string list and append them, one per line, in the <code class="literal">txtEncryptedSMS</code> textbox:</p><div><pre class="programlisting">foreach (string lsEncryptedText in prlsEncryptedSMS)
{
    txtEncryptedSMS.AppendText(lsEncryptedText + Environment.NewLine);
}</pre></div><p>As the thread stores the results of its processing in a private variable, which is also accessible from the main thread, we can use it to show the results in the UI controls.</p><p>This is a very <a id="id168" class="indexterm"/>simple way to retrieve data from threads, leaving the<a id="id169" class="indexterm"/> results in a variable, accessible from both the main and the secondary threads.</p><p>This is one of the main advantages of threads over processes. It is very easy to share data between threads without much effort.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Sharing data between threads</h1></div></div></div><p>So far, we have <a id="id170" class="indexterm"/>used the <code class="literal">BackgroundWorker</code> component and the <code class="literal">Thread</code> class to <a id="id171" class="indexterm"/>execute code in independent threads. The <code class="literal">Thread</code> class allows us to have great control over the thread while the <code class="literal">BackgroundWorker</code> component offers a very simple way to update the UI without using complicated delegates or callbacks. How can we combine this component and this class in an application to make it faster to complete while keeping the UI responsive?</p><p>If we want to work with a <code class="literal">BackgroundWorker</code> component to show some feedback or progress to the UI controls, while one or more threads created using the <code class="literal">Thread</code> class is running, we must find a way to share data between threads.</p><p>We made something like that in our last example. However, we must use some techniques in order to avoid confusion between the different ways in which this useful component, <code class="literal">BackgroundWorker</code>, and this flexible and powerful class, <code class="literal">Thread</code>, work.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>We can do it using the <code class="literal">Thread</code> class, but there is a <code class="literal">BackgroundWorker</code> component ready to help us. Thus, let's be pragmatic and use the best of both worlds.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>How to do it</h2></div></div></div><p>Now, we are going to make some changes to the application, adding a <code class="literal">BackgroundWorker</code> component to display progress. In order to accomplish that, we must share data between two threads:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SMSEncryption</code> project.</li><li class="listitem">Add a label control (<code class="literal">lblNumberOfSMSEncrypted</code>). Set its <code class="literal">Text</code> property to <code class="literal">0</code>. Add another label control, and set its <code class="literal">Text</code> property to <code class="literal">Number of Messages Encrypted</code>.</li><li class="listitem">Add a <code class="literal">BackgroundWorker</code> component (<code class="literal">bakShowEncryptedStrings</code>) to create a new independent thread capable of talking to the UI, as we learned in the previous chapter. Declare the following variable in the <code class="literal">MainWindow.xaml.cs</code> file:<div><pre class="programlisting">private BackgroundWorker bakShowEncryptedStrings = new BackgroundWorker();</pre></div></li><li class="listitem">In order for the <a id="id172" class="indexterm"/>program to recognize the <code class="literal">BackgroundWorker</code> class, you <a id="id173" class="indexterm"/>will also need to add the following:<div><pre class="programlisting">using System.ComponentModel;</pre></div></li><li class="listitem">Set the following properties of the <code class="literal">BackgroundWorker</code> component in the <code class="literal">MainWindow</code> constructor.</li><li class="listitem">Add the following lines in the <code class="literal">MainWindow</code> class definition to declare three new private variables:<div><pre class="programlisting">    // The number of the last encrypted string
       private int priLastEncryptedString;
    // The number of the last encrypted string shown in the UI
    private int priLastEncryptedStringShown;
    // The number of the previous last encrypted string shown in the UI
    private int priOldLastEncryptedStringShown;</pre></div></li><li class="listitem">Add the following line of code at the beginning of <code class="literal">ThreadEncryptProcedure</code>:<div><pre class="programlisting">    priLastEncryptedString = 0;</pre></div></li><li class="listitem">Add the following line of code after the line <code class="literal">prlsEncryptedSMS.Add(lsEncryptedText);</code> in <code class="literal">ThreadEncryptProcedure</code>:<div><pre class="programlisting">    priLastEncryptedString++;</pre></div></li><li class="listitem">Register the <code class="literal">DoWork</code> event handler in the <code class="literal">MainWindow</code> constructor for the <code class="literal">BackgroundWorker</code> component <code class="literal">bakShowEncryptedStrings</code>:<div><pre class="programlisting">            //Register the DoWork  event handler.
            bakShowEncryptedStrings.DoWork += bakShowEncryptedStrings_DoWork;</pre></div></li><li class="listitem">Now, enter the following code in the <code class="literal">bakShowEncryptedStrings_DoWork</code> method:<div><pre class="programlisting">    // Initialize the last encrypted string shown
    priLastEncryptedStringShown = 0;
    // Initialize the last encrypted string shown before
    priOldLastEncryptedStringShown = 0;
    // The iteration
    int i;
    // The last encrypted string (saved locally to avoid changes in the middle of the iteration)
    int liLast;
    // Wait until proThreadEncryption begins
    while ((priLastEncryptedString &lt; 1))
    {
        // Sleep the thread for 10 milliseconds)
        Thread.Sleep(10);
    }

    while (proThreadEncryption.IsAlive || (priLastEncryptedString &gt; priLastEncryptedStringShown))
    {
        liLast = priLastEncryptedString;
        if (liLast != priLastEncryptedStringShown)
        {
            ((BackgroundWorker)sender).ReportProgress(liLast);
            priLastEncryptedStringShown = liLast;
        }

// Sleep the thread for 1 second (1000 milliseconds)
        Thread.Sleep(1000);
    }</pre></div></li><li class="listitem">Register <a id="id174" class="indexterm"/>the <code class="literal">ProgressChanged</code> event handler in the <code class="literal">MainWindow</code> constructor <a id="id175" class="indexterm"/>for the <code class="literal">BackgroundWorker</code> component <code class="literal">bakShowEncryptedStrings</code>:<div><pre class="programlisting">            //Register the DoWork  event handler.
            bakShowEncryptedStrings.ProgressChanged += bakShowEncryptedStrings_ProgressChanged;</pre></div></li><li class="listitem">Open the <code class="literal">ProgressChanged</code> event in the <code class="literal">BackgroundWorker bakShowEncryptedStrings</code>, and enter the following code:<div><pre class="programlisting">            // The iteration
            int i;
            // Show the number of SMS messages encrypted by the concurrent proThreadEncryption thread.
            lblNumberOfSMSEncrypted.Content = priLastEncryptedString.ToString();
            // Append each new string, from priOldLastEncryptedStringShown to the received parameter in e.ProgressPercentage - 1.
            for (i = priOldLastEncryptedStringShown;
                 i &lt; (int)e.ProgressPercentage; i++)
            {
                // Append the string to the txtEncryptedSMS TextBox
                txtEncryptedSMS.AppendText(prlsEncryptedSMS[i]
                 + Environment.NewLine);

            }
            // Update the old last encrypted string shown
            priOldLastEncryptedStringShown = priLastEncryptedStringShown;</pre></div></li><li class="listitem">Open <a id="id176" class="indexterm"/>the <code class="literal">Click</code> event in the <code class="literal">butRunInThread</code> button and enter the <a id="id177" class="indexterm"/>following code before the line <code class="literal">proThreadEncryption.Start();</code> (we must start the <code class="literal">BackgroundWorker</code> component before we start the encryption thread):<div><pre class="programlisting">    // Start the BackgroundWorker with an asynchronous execution
    bakShowEncryptedStrings.RunWorkerAsync();</pre></div></li><li class="listitem">Next, we need to comment out the <code class="literal">proThreadEncryption.Join();</code> line because we do not want the main thread to wait on the encryption routine to finish. We will also comment out lines after this that display the encrypted text message once the encryption thread finishes. We will be doing this through the <code class="literal">BackgroundWorker</code> processing and will explain this in the following code snippet:<div><pre class="programlisting">            // Join the independent thread to this thread to wait until ThreadProc ends
            //proThreadEncryption.Join();

            // When the thread finishes running this is the next line that is going to be executed
            // Copy the string List generated by the thread
            //foreach (string lsEncryptedText in prlsEncryptedSMS)
            //{
            //    Append a line with the Encrypted text
            //    txtEncryptedSMS.AppendText(lsEncryptedText +
            //     Environment.NewLine);
        //   }</pre></div></li><li class="listitem">Try <a id="id178" class="indexterm"/>running the application before commenting out these lines<a id="id179" class="indexterm"/> after the <code class="literal">Join</code> method but leave the <code class="literal">proThreadEncryption.Join();</code> command uncommented. You will create a race condition that may throw a null exception error for the variable, <code class="literal">prlsEncryptedSMS</code>. If the main thread tries to use this variable to display the encrypted text message before the encryption thread finishes the first line, then this variable will still be null. Since both the main thread and the encryption thread are running in parallel, we cannot ensure this will not happen.<div><img src="img/8321EN_03_05.jpg" alt="How to do it"/></div></li><li class="listitem">Now, let's <a id="id180" class="indexterm"/>build and run the application with those <a id="id181" class="indexterm"/>lines commented out.</li><li class="listitem">Enter or copy and paste a very long text (with more than 5,000 lines) in the textbox labeled <code class="literal">Original Messages</code>, and click on the <strong>Run in a Thread</strong> button. You will see the strings representing the messages encrypted appearing in the textbox labeled <strong>Encrypted Messages</strong> as the number of messages that are encrypted increases. The application will look something like the following screenshot:<div><img src="img/8321EN_03_06.jpg" alt="How to do it"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>How it works</h2></div></div></div><p>Now, when the<a id="id182" class="indexterm"/> user clicks on the <strong>Run in a Thread</strong> button, the encryption runs <a id="id183" class="indexterm"/>in a new thread, but with an asynchronous execution because we no longer tell the main thread to wait on it with the <code class="literal">Thread.Join()</code> method. At the same time, the <code class="literal">BackgroundWorker</code> component creates a new thread to give some feedback to the UI and also runs asynchronously. Thus, we have two concurrent threads with an asynchronous execution, doing completely different tasks in parallel.</p><p>This is why we added the following lines:</p><div><pre class="programlisting">bakShowEncryptedStrings.RunWorkerAsync();
proThreadEncryption.Start();</pre></div><p>First, we start the <code class="literal">BackgroundWorker</code> thread, and then the encryption thread that is created with the <code class="literal">Thread</code> class.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>With these examples, we have learned and seen the differences between executing a thread in a synchronous and an asynchronous way. We must master this in order to have complete control over many concurrent threads.</p></div></div><p>We are using the <code class="literal">BackgroundWorker</code> component in order to give some feedback to the UI controls. In order to do so, the encryption thread must share data with the <code class="literal">BackgroundWorker</code> thread.</p><p>We use the same technique that we used in the previous example. However, this time, our application is operating concurrently. While the encryption thread is adding encrypted strings to the <code class="literal">prlsEncryptedSMS</code> string list, the <code class="literal">BackgroundWorker</code> thread looks at the number of the last encrypted string and calls the <code class="literal">ReportProgress</code> method, sending it as a parameter.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Remember that too many calls to the <code class="literal">ReportProgress</code> method can generate a stack overflow exception. Because this method runs code that upgrades the textbox adding lines, it takes a lot more time than encrypting. If we have 100,000 messages to encrypt, and we make 100,000 calls to the <code class="literal">ReportProgress</code> method; it is highly probable that a stack overflow will be generated. The code in this method runs in the main thread, and for this reason, we must sacrifice some UI feedback to achieve a better overall performance and avoid exceptions.</p></div></div><p>The code in<a id="id184" class="indexterm"/> the <code class="literal">DoWork</code> and the <code class="literal">ReportProgress</code> event handlers is a little complex<a id="id185" class="indexterm"/> to account for this and not send updates for every single line encrypted.</p><p>Now, we define three new private variables:</p><div><pre class="programlisting">private int priLastEncryptedString;
private int priLastEncryptedStringShown;
private int priOldLastEncryptedStringShown;</pre></div><p>The encryption thread initializes <code class="literal">priLastEncryptedString</code> and then increments its value each time it adds an encrypted string to the <code class="literal">prlsEncryptedSMS</code> string list. This value is useful for the <code class="literal">BackgroundWorker</code> thread.</p><p>The code executed in the <code class="literal">DoWork</code> event handler by the <code class="literal">BackgroundWorker</code> thread concurrently with the encryption thread initializes <code class="literal">priLastEncryptedStringShown</code> and <code class="literal">priOldLastEncryptedStringShown</code>.</p><p>Then, it waits until the encryption thread has some results. This is necessary because both the threads are launched asynchronously, at nearly the same time. It is a <code class="literal">while</code> loop, but with a call to the <code class="literal">Thread.Sleep</code> method, with 10 milliseconds of inactivity for the thread:</p><div><pre class="programlisting">while ((priLastEncryptedString &lt; 1))
{
    Thread.Sleep(10);
}</pre></div><p>Since the <code class="literal">priLastEncryptedString</code> variable has a value less than <code class="literal">1</code>, the encryption thread has not added any value yet.</p><p>The <code class="literal">Thread.Sleep</code> method suspends the current thread (the thread in the actual context) for a specified time in milliseconds (0.001 seconds). As it suspends the thread execution, it does not consume CPU cycles. Hence, it does not waste processing power.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Never use loops without instructions to wait for some time in a thread, because you will be wasting processing power. Instead, use the <code class="literal">Thread.Sleep</code> method when you have to pause a thread.</p></div></div><p>When the<a id="id186" class="indexterm"/> encryption thread finishes encrypting the first string, adding it to the <a id="id187" class="indexterm"/>encrypted string list, and incrementing the value of <code class="literal">priLastEncryptedString</code>, the <code class="literal">BackgroundWorker</code> thread will move on to the next part of the code in the <code class="literal">DoWork</code> event handler method. Now, it will enter in the other loop:</p><div><pre class="programlisting">while (proThreadEncryption.IsAlive || (priLastEncryptedString &gt; priLastEncryptedStringShown))
{
    liLast = priLastEncryptedString;
    if (liLast != priLastEncryptedStringShown)
    {
        ((BackgroundWorker)sender).ReportProgress(liLast);
        priLastEncryptedStringShown = liLast;
    }
    Thread.Sleep(2000);
}</pre></div><p>The loop (and the <code class="literal">DoWork</code> thread) will go on running while the encryption thread is running, or while there are encrypted strings to be shown. We know when the <code class="literal">proThreadEncryption</code> thread is not running, or is not calling its <code class="literal">IsAlive</code> method. The <code class="literal">IsAlive</code> method returns either <code class="literal">true</code> or <code class="literal">false</code>.</p><p>The first line in the loop saves the value of <code class="literal">priLastEncryptedString</code> in <code class="literal">liLast</code>. This is necessary because the value is changing concurrently on another thread (the encryption thread)—we are not alone (the joys of multithreaded logic!). We must save the value to work with the captured value in the rest of the comparisons and assignments. We do not want to work with a moving target within one iteration of the loop.</p><p>If the last encrypted string is not the last string shown, we use the <code class="literal">sender</code> parameter typecast to a <code class="literal">BackgroundWorker</code> component to call the <code class="literal">ReportProgress</code> method with the last string shown as a parameter.</p><p>Once the <code class="literal">ReportProgress</code> method returns with an asynchronous event triggered to update the UI, we save the last string shown and make the thread suspend its execution for 1 second (1,000 milliseconds). This is necessary in order to avoid a probable stack overflow. Because the execution of the <code class="literal">DoWork</code> code is faster than the code programmed in the <code class="literal">ProgressChanged</code> event handler, we must give some time to the UI controls to get updated.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>When we call the <code class="literal">Thread.Sleep</code> method, the current thread suspends its execution for a specified time, though the other threads keep running. That is the reason why the counter shows big steps when we run the application with several text lines. The encryption thread works without suspensions.</p></div></div><p>Thus, the <code class="literal">BackgroundWorker</code> component helps the <code class="literal">Thread</code> class to update the UI controls. The <code class="literal">ProgressChanged</code> event handler does the rest of the job.</p><p>First, it updates<a id="id188" class="indexterm"/> the number <a id="id189" class="indexterm"/>of SMS messages encrypted with the line of code:</p><div><pre class="programlisting">lblNumberOfSMSEncrypted.Content = priLastEncryptedString.ToString();</pre></div><p>It then casts the <code class="literal">e.ProgressPercentage</code> property received as a parameter to an integer in order to obtain the last encrypted string, instead of a progress percentage.</p><p>Then, it appends each new string with a loop from <code class="literal">priOldLastEncryptedStringShown</code> (the previous last encrypted string shown) to the last encrypted string received (in the <code class="literal">e.ProgressPercentage</code> property). We access the <code class="literal">prlsEncryptedSMS</code> string list in an element number that the encryption thread is not modifying (because it is already encrypted). Therefore, we can append the string to the textbox without problems:</p><div><pre class="programlisting">for (i = priOldLastEncryptedStringShown; i &lt; (int)e.ProgressPercentage; i++)
{
    txtEncryptedSMS.AppendText(prlsEncryptedSMS[i]+ Environment.NewLine);
}</pre></div><p>Finally, the string previous to the last encrypted string is now the last encrypted string shown:</p><div><pre class="programlisting">priOldLastEncryptedStringShown = priLastEncryptedStringShown;</pre></div><p>By using a <code class="literal">BackgroundWorker</code> component with some threads created using the <code class="literal">Thread</code> class, we can easily give feedback to the UI and achieve better performance with a responsive application.</p><p>At this point, we should mention that the <code class="literal">BackgroundWorker</code> component is a little like the black sheep of the family. In the .NET framework, with the advent of the <code class="literal">Thread</code> class and now the Task Parallel Library and <code class="literal">Async</code> methods (to be covered later in the book), some .NET developers consider use of <code class="literal">BackgroundWorker</code> a little passé. While it might not be the latest cool feature of .NET, it is still a very easy-to-use, helpful, and powerful component. According to me all multithreaded options in .NET have their place and the <code class="literal">BackgroundWorker</code> component is still relevant.</p><p>When we call<a id="id190" class="indexterm"/> the <code class="literal">Start</code> method, the thread is sent to the scheduler for execution. As mentioned earlier, it does<a id="id191" class="indexterm"/> not mean an immediate execution.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>When we call the <code class="literal">Start</code> method for many threads, one after the other, or when combined with a <code class="literal">BackgroundWorker</code> thread as in our example, we are not sure which one is going to run faster. We cannot assume one of them will reach some statement first, because the execution speed will depend upon the processor or the core it is assigned to and its capabilities. If it needs more context switches than the other thread, it will take longer to reach the same statement.</p></div></div><p>This is one of the most important issues with concurrency. It all depends on something that we do not know how to predict sometimes. Therefore, we must consider every possible situation the code that will be executed concurrently might experience.</p><p>When we call the <code class="literal">Join</code> method, the thread is attached to the thread that calls the <code class="literal">Join</code> method and it will not execute anything else until the thread method finishes its execution. This is one of the most difficult things to achieve for programmers used to traditional linear code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Passing parameters to threads</h1></div></div></div><p>We have used the <code class="literal">BackgroundWorker</code> component<a id="id192" class="indexterm"/> combined with the <code class="literal">Thread</code> class to provide fast execution and UI feedback. Now, we will combine multiple <code class="literal">Thread</code> class instances with many <code class="literal">BackgroundWorker</code> components to create an application that runs as fast as possible on modern computer architectures. In fact, it will inspect the computer it is running on and create an encryption thread for each processing core the computer has. This will maximize the performance without creating extra threads that will not further improve performance.</p><p>We will work with dynamic lists and the <code class="literal">Environment.ProcessorCount</code> property to create threads on the fly according to the number of cores on the machine. However, we need some technique to distribute the SMS messages that must be encrypted to the many encrypting threads. At the same time, we must provide feedback through many <code class="literal">BackgroundWorker</code> components. It sounds complex, and it is indeed complex.</p><p>To achieve this goal, we must pass specific parameters to the common procedure that the many threads will run. We want to reuse the procedure because we want it to be dynamically organized according to the number of available cores at runtime.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>How to do it</h2></div></div></div><p>Now, we are going to make some big changes to the application, modifying variables to be lists, or lists of lists, so they can be accessed by multiple threads created dynamically. In order to accomplish that, we must share data between the many threads:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SMSEncryption</code> project.</li><li class="listitem">Add the following line in the <code class="literal">MainWindow</code> class definition to declare a new private variable that will tell us the number of cores on the machine:<div><pre class="programlisting">    // The number of processors or cores available in the computer for this application
    private int priProcessorCount = Environment.ProcessorCount;</pre></div></li><li class="listitem">Change the definition for the following private variables in the <code class="literal">MainWindow</code> class definition to make them lists:<div><pre class="programlisting">    // The string list with SMS messages encrypted (output)
    private List&lt;List&lt;string&gt;&gt; prlsEncryptedSMS;
    // The number of the last encrypted string
    private List&lt;int&gt; priLastEncryptedString;</pre></div></li><li class="listitem">Add the following line in the <code class="literal">MainWindow</code> class definition to declare a new private variable that will hold the list of the <code class="literal">Thread</code> class instances:<div><pre class="programlisting">    // The threads list
    private List&lt;Thread&gt; prloThreadList;</pre></div></li><li class="listitem">The variables required to grow dynamically, according to the number of cores found in the computer, have been added to the application.<div><div><h3 class="title"><a id="note22"/>Note</h3><p>One potential problem of manually assigning a value greater than the number of available cores to the <code class="literal">priProcessorCount</code> variable is that the increasing context switches needed by the operating system scheduler will degrade performance. Therefore, you must be wary of wrong fine-tuning.</p></div></div></li></ol></div><p>Now, let's change the different methods to allow multiple threads to encrypt the strings as fast as possible.</p><p>It is going to be<a id="id193" class="indexterm"/> easier rewriting these than making the changes, as <a id="id194" class="indexterm"/>we are replacing single variables by lists. In order to accomplish this, we must create a thread with a parameter indicating its number:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">SMSEncryption</code> project.</li><li class="listitem">Replace the definition for <code class="literal">ThreadEncryptProcedure</code> with the following (now it receives a parameter):<div><pre class="programlisting">    private void ThreadEncryptProcedure(object poThreadParameter)</pre></div></li><li class="listitem">Change the text in the labels from <code class="literal">Encrypted Message</code> to <code class="literal">Encrypted Message(by thread 1)</code> and <code class="literal">Number of Messages Encrypted</code> to <code class="literal">Number of Messages Encrypted(by thread 1)</code>.</li><li class="listitem">Replace the code in the <code class="literal">ThreadEncryptProcedure</code> procedure with the following:<div><pre class="programlisting">    string lsEncryptedText;
    // Retrieve the thread number received in object poThreadParameter
    int liThreadNumber = (int) poThreadParameter;
    // ThreadNumber + 1
    int liStringNumber;

    // Create a new string list for the prlsSMSToEncrypt corresponding to the thread
    prlsEncryptedSMS[liThreadNumber] = new List&lt;string&gt;((prlsSMSToEncrypt.Count / priProcessorCount));
    priLastEncryptedString[liThreadNumber] = 0;

    liStringNumber = 0;
    int i;
    // steps the thread number
    string lsText;
    // Iterate through each string in the prlsSMSToEncrypt string list stepping by priProcessorCount
    // To distribute the work among each concurrent thread
    for (i = liThreadNumber; i &lt; prlsSMSToEncrypt.Count; i +=priProcessorCount)
    {
        lsText = prlsSMSToEncrypt[i];
        lsEncryptedText = Encrypt(lsText);
        // Append a string with the Encrypted text
        prlsEncryptedSMS[liThreadNumber].Add(lsEncryptedText);

        priLastEncryptedString[liThreadNumber]++;
        liStringNumber++;
    }</pre></div></li><li class="listitem">Replace the<a id="id195" class="indexterm"/> code where the threads were initialized and<a id="id196" class="indexterm"/> started in the <code class="literal">Click</code> event handler in the <code class="literal">butRunInThread</code> button, after the line <code class="literal">prlsSMSToEncrypt.AddRange(txtOriginalSMS.Lines);</code>, with the following:<div><pre class="programlisting">    // Thread number
    int liThreadNumber;
    // Create the thread list and string lists
    prloThreadList = new List&lt;Thread&gt;(priProcessorCount);
    prlsEncryptedSMS = new List&lt;List&lt;string&gt;&gt;(priProcessorCount);
    priLastEncryptedString = new List&lt;int&gt;(priProcessorCount);

    // Initialize the threads
    for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount;liThreadNumber++)
    {
        // Just to occupy the number
        prlsEncryptedSMS.Add(new List&lt;string&gt;());
        // Just to occupy the number
        priLastEncryptedString.Add(0);
        // Add the new thread, with a parameterized start (to allow parameters)
        prloThreadList.Add(new Thread(new ParameterizedThreadStart(ThreadEncryptProcedure)));
    }

    // Now, start the threads
    for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount;liThreadNumber++)
    {
        prloThreadList[liThreadNumber].Start(liThreadNumber);
    }

    // Start the BackgroundWorker with an asynchronous execution
    bakShowEncryptedStrings.RunWorkerAsync();</pre></div></li><li class="listitem">Open the<a id="id197" class="indexterm"/> <code class="literal">DoWork</code> event <a id="id198" class="indexterm"/>in the <code class="literal">BackgroundWorker bakShowEncryptedStrings</code> and make the following code replacements to the existing code:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replace <code class="literal">priLastEncryptedString</code> with <code class="literal">priLastEncryptedString[0]</code></li><li class="listitem" style="list-style-type: disc">Replace <code class="literal">proThreadEncryption</code> with <code class="literal">prloThreadList[0]</code></li></ul></div></li><li class="listitem">Open the <code class="literal">ProgressChanged</code> event in the <code class="literal">BackgroundWorker bakShowEncryptedStrings</code> and make the following code replacements to the existing code:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Replace <code class="literal">priLastEncryptedString</code> with <code class="literal">priLastEncryptedString[0]</code></li><li class="listitem" style="list-style-type: disc">Replace <code class="literal">prlsEncryptedSMS[i]</code> with <code class="literal">prlsEncryptedSMS[0][i]</code></li></ul></div></li><li class="listitem">Build and run the application.</li><li class="listitem">Enter or copy and paste a very long text (with more than 20,000 lines) in the textbox labeled <strong>Original Messages</strong> and click on the <strong>Run in a Thread</strong> button. You will see the strings representing the messages encrypted by thread 1 appearing in the textbox labeled <strong>Encrypted Messages (by thread 1)</strong>, while the number of messages <a id="id199" class="indexterm"/>encrypted by thread 1 increases. In this example, there were <a id="id200" class="indexterm"/>119 lines in the text message with a <code class="literal">ProcessorCount</code> of <code class="literal">4</code>:<div><img src="img/8321EN_03_07.jpg" alt="How to do it"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>How it works</h2></div></div></div><p>The code has become more <a id="id201" class="indexterm"/>complex. However, running this application in a <a id="id202" class="indexterm"/>quad-core computer improves the performance by almost a factor of four. We do not realize the full 4x performance gain because of the overhead of multithreading that we discussed in <a class="link" href="ch01.html" title="Chapter 1. Understanding Multiprocessing and Multiple Cores">Chapter 1</a>, <em>Understanding Multiprocessing and Multiple Cores</em>.</p><p>Now, when the user clicks on the <strong>Run in a Thread</strong> button, the encryption runs in as many threads as there are available cores in the computer with an asynchronous execution. At the same time, the <code class="literal">BackgroundWorker</code> component starts running concurrently displaying the results just for the first thread.</p><p>The private <a id="id203" class="indexterm"/>string list that works as an input for the many threads is the<a id="id204" class="indexterm"/> same as in the previous examples (<code class="literal">prlsSMSToEncrypt</code>), but is accessed in a different way by each thread.</p><p>The private string list that works as an output (<code class="literal">prlsEncryptedSMS</code>) is now a list of string lists. Thus, each thread can work in its own output.</p><div><pre class="programlisting">private List&lt;List&lt;string&gt;&gt; prlsEncryptedSMS;</pre></div><p>There is a new thread list that will be aligned with the value in the <code class="literal">priProcessorCount</code> variable:</p><div><pre class="programlisting">private List&lt;Thread&gt; prloThreadList;</pre></div><p>This replaces the line that declared the <code class="literal">proThreadEncryption</code> variable with the <code class="literal">Thread</code> type.</p><p>When the user clicks on the <strong>Run in a Thread</strong> button, the following lines create an instance of the <code class="literal">Thread</code> class specifying the method it must execute in the new thread when started. In order to accomplish this, we use the <code class="literal">ParameterizedThreadStart</code> delegate because we need to send a parameter with the number of threads to identify each thread in the method it runs. This is an important change to note. Earlier, we just called the <code class="literal">ThreadStart</code> method. This new method allows us to start a thread that has a delegate method that takes a parameter:</p><div><pre class="programlisting">for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount;liThreadNumber++)
{
    prlsEncryptedSMS.Add(new List&lt;string&gt;());
    priLastEncryptedString.Add(0);
    prloThreadList.Add(new Thread(new ParameterizedThreadStart(ThreadEncryptProcedure)));
}</pre></div><p>Once each thread is created, it does not start running the code in the specified <code class="literal">ThreadEncryptProcedure</code> procedure until we call the <code class="literal">Start</code> method. But first we initialize the threads, and then we call the <code class="literal">Start</code> method for each one. We want to send a parameter (the thread number) to the method. Therefore, we use the <code class="literal">Start</code> method with one parameter. Take a moment to make sure you understand how these methods operate.</p><div><pre class="programlisting">for (liThreadNumber = 0; liThreadNumber &lt; priProcessorCount; liThreadNumber++)
{
    prloThreadList[liThreadNumber].Start(liThreadNumber);
}</pre></div><p>This <a id="id205" class="indexterm"/>method tells the scheduler to start running the code in the new threads (one per available core). Then, we want to run the <code class="literal">BackgroundWorker</code> thread concurrently to report the UI with feedback from the first created thread (thread number <code class="literal">0</code>):</p><div><pre class="programlisting">bakShowEncryptedStrings.RunWorkerAsync();</pre></div><p>In a dual-core or dual-processor computer, we will have two encrypting threads and one <code class="literal">BackgroundWorker</code> thread. In a quad-core computer, we will have four encrypting threads and one <code class="literal">BackgroundWorker</code> thread.</p><p>It makes the new threads run the <code class="literal">ThreadEncryptProcedure</code> method code (with the thread number as a parameter), and when they finish their execution, it returns the control to the main thread and goes on with the next statement.</p><p>Separating the code into many concurrent threads using the <code class="literal">Thread</code> class and sending parameters to them is easy if we follow this simple code pattern and we have a good knowledge of working with lists or dynamic arrays.</p><p>We did not want to use <a id="id206" class="indexterm"/>many methods, one for each new thread. We wanted to share the same method and differentiate among the threads using a parameter with a number that identifies each.</p><p>There are many ways to distribute the work in many concurrent threads working on the same algorithm, taking the same input and producing almost the same output. We used one of them, and we will learn more in the following chapters using both the <code class="literal">Thread</code> and <code class="literal">Task</code> classes and the <code class="literal">Parallel</code> library.</p><p>The parameter that is sent when calling the <code class="literal">Start</code> method for the thread instance is received in the <code class="literal">object</code> parameter, <code class="literal">poThreadParameter</code>, as shown in the following declaration:</p><div><pre class="programlisting">private void ThreadEncryptProcedure(object poThreadParameter)</pre></div><p>Therefore, we must use typecasting to convert it to an integer:</p><div><pre class="programlisting">int liThreadNumber = (int) poThreadParameter;</pre></div><p>With the thread number and the total number of threads (the value in the <code class="literal">priProcessorCount</code> variable) that will be sharing the work to be done, we can easily distribute the work of a list to be processed (encrypted). A simple way to do this is to make each thread take the input it must process and leave the rest untouched.</p><p>This is done in the iteration, which goes through the string list from the thread number (hence, each thread will begin in a different number) to the total number of strings to encrypt, stepping up the value in the <code class="literal">priProcessorCount</code> variable (the total number of threads):</p><div><pre class="programlisting">for (i = liThreadNumber; i &lt; prlsSMSToEncrypt.Count;i += priProcessorCount)</pre></div><p>For example, let's suppose that there are four threads. They will work on the following strings from the list:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Thread #1: 0; 4; 8; 12; 16; 20; …</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread #2: 1; 5; 9; 13; 17; 21; …</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread #3: 2; 6; 10; 14; 18; 22; …</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread #4: 3; 7; 11; 15; 19; 23; …</code></li></ul></div><p>Here, we<a id="id207" class="indexterm"/> will consider them running concurrently.</p><p>The string list capacity for <code class="literal">prlsEncryptedSMS[liThreadNumber]</code> is determined by the total number of strings to be encrypted divided by the total number of threads (the value in the <code class="literal">priProcessorCount</code> variable):</p><div><pre class="programlisting">prlsEncryptedSMS[liThreadNumber] = new List&lt;string&gt;((prlsSMSToEncrypt.Count / priProcessorCount));</pre></div><p>It can be wrong by <code class="literal">1</code>, but<a id="id208" class="indexterm"/> it does not matter in this case (reserving capacity is better), because the thread increments a variable with the number of processed strings:</p><div><pre class="programlisting">priLastEncryptedString[liThreadNumber]++;</pre></div><p>The code in the <code class="literal">BackgroundWorker</code> component was modified to show only the progress of the first thread. This can be changed or additional <code class="literal">BackgroundWorker</code> components added to display the progress of all encryption threads.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Have a go hero – concurrent UI feedback</h2></div></div></div><p>As mentioned earlier, there is <a id="id209" class="indexterm"/>still some work to be done. The FBI wants to see all the code being encrypted and not just the work done by the first thread. Remember, they have a computer with 16 quad-core microprocessors (64 cores).</p><p>Using everything we have learned, develop a new version of this application that shows the progress for each dynamically created thread. Show the progress in numbers, in a progress bar, and in textboxes (adding the encrypted SMS messages). For all these controls, as many concurrent threads as the number of available cores are running in the application.</p><p>Then, use the control procedures of the <code class="literal">Thread</code> class instances we learned in order to create a final collection procedure that takes the results of all the running threads and shows the complete list of encrypted messages.</p><p>Enhance the application changing the string lists with instances of a new class, using the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Caller ID</li><li class="listitem" style="list-style-type: disc">Destination number</li><li class="listitem" style="list-style-type: disc">SMS message</li></ul></div><p>Encrypt all the fields and<a id="id210" class="indexterm"/> compute the total number of characters sent.</p><p>Show the incoming and outgoing SMS messages with their information in a grid with many columns, instead of using textboxes.</p><p>Switch off the webcam. The FBI is looking for you for a new mission!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about working with threads and the <code class="literal">Thread</code> class. We learned how to create threads, coordinate them synchronously and asynchronously, and pass parameters to them.</p><p>In this chapter, we learned about the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Developing applications that are able to provide greater control over multiple running threads, created using the <code class="literal">Thread</code> class</li><li class="listitem" style="list-style-type: disc">Programming the code to be executed by the <code class="literal">Thread</code> class instance when started</li><li class="listitem" style="list-style-type: disc">Creating independent and flexible threads using the powerful <code class="literal">Thread</code> class</li><li class="listitem" style="list-style-type: disc">Starting, controlling, and coordinating multiple threads with great flexibility</li><li class="listitem" style="list-style-type: disc">Sending parameters and retrieving data from independently running threads</li><li class="listitem" style="list-style-type: disc">Sharing data between many threads</li><li class="listitem" style="list-style-type: disc">Combining asynchronous and synchronous execution</li><li class="listitem" style="list-style-type: disc">Matching the number of available cores with the number of concurrent threads to take full advantage of parallel processing capabilities in modern computers</li></ul></div><p>In the next chapter, we will take an even deeper dive into the <code class="literal">Thread</code> class.</p></div></body></html>