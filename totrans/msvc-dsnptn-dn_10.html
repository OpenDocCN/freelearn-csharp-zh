<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-146"><a id="_idTextAnchor156"/>10</h1>
<h1 id="_idParaDest-147"><a id="_idTextAnchor157"/>Performing Health Checks on Your Services</h1>
<p>Maintaining maximum uptime is an important aspect of any system. In the previous chapter, we saw where we can write code in a fault-tolerant manner that will reduce the prevalence of outages in our infrastructure and network. <a id="_idTextAnchor158"/>This, however, is not a long-term solution, and things fail regardless of these measures. It then leads to the notion that we need to know when there are failures.</p>
<p>This is where we start thinking about health checks. Health checks exist as a mechanism to inform us of outages in our services and supporting databases and connections in our application. Generally, this can be accomplished with a simple ping request to a resource. The resource is available and operating as expected if we get a response. In the absence of a response, we assume that the resource is down and trigger an alert.</p>
<p>There are statuses between the service’s up and down status, and we will discover those options in this chapter. We will also explore some of the functionality that .NET Core provides to implement these checks.</p>
<p>In this chapter, we will look at various scenarios and countermeasures that we can implement when navigating possible failures in our microservices architecture.</p>
<p>After reading this chapter, we will be able to do the following:</p>
<ul>
<li>Understand why health checks are necessary</li>
<li>Understand how to implement health checks in ASP.NET Core</li>
<li>Understand how orchestrators monitor and respond to failures</li>
</ul>
<h1 id="_idParaDest-148"><a id="_idTextAnchor159"/>Technical requirements</h1>
<p>Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: <a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch10</a>.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor160"/>Health checks and microservices</h1>
<p>A health check allows us to monitor<a id="_idIndexMarker464"/> the health of our services. Frankly, another service<a id="_idIndexMarker465"/> or resource that exposes an HTTP endpoint becomes a capable candidate for health checks. We can simply make a request to this endpoint and hope for a response that indicates a successful response. The simplest form of a health check can come from implementing a simple <code>GET</code> request, which returns a <code>200OK</code> HTTP response. We can add further intelligence to such an endpoint, check connectivity to other key services, and use those to influence the response code returned.</p>
<p>Health checks are useful mechanisms for both monolithic and microservices applications. In the context of microservices, however, we have an increased challenge of monitoring and maintaining several services. Even more so if they are configured to scale on individual levels. Health checks can be used to monitor the health and uptime of interdependent services and carry out some form of corrective action when a service is down.</p>
<p>Using .NET Core, we can return a successful response and include additional information that gives some details on the health of the service. In this case, we cannot simply go by the <code>200OK</code> response, but we need to interrogate the actual response body to check whether the service is healthy, degraded, or unhealthy.</p>
<p><em class="italic">Figure 10.1</em> shows a typical health check:</p>
<div><div><img alt="Figure 10.1 – Shows a health check request and healthy response after verifying that all services are available" src="img/Figure_10.1_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Shows a health check request and healthy response after verifying that all services are available</p>
<p>Let’s break down<a id="_idIndexMarker466"/> what each state entails:</p>
<ul>
<li><strong class="bold">Healthy</strong>: This indicates that the service<a id="_idIndexMarker467"/> is healthy and the application is operating as expected</li>
<li><strong class="bold">Degraded</strong>: This indicates that the service<a id="_idIndexMarker468"/> is live, but some functionality may be unavailable</li>
<li><strong class="bold">Unhealthy</strong>: This indicates that the service<a id="_idIndexMarker469"/> is failing and is not operating as expected</li>
</ul>
<p><em class="italic">Figure 10.2</em> shows a failed health check:</p>
<div><div><img alt="Figure 10.2 – Shows a health check that sent a failure response since one of the services was not available" src="img/Figure_10.2_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – Shows a health check that sent a failure response since one of the services was not available</p>
<p>The health of a service depends on several things, including correct configuration, access to keys and dependencies, the status of the hosting platform and infrastructure, and the connection to the database. They may also be used for external application monitoring and overall application health.</p>
<p>A common deployment model<a id="_idIndexMarker470"/> for microservices is using container orchestrators, such as <em class="italic">Kubernetes</em>, to deploy<a id="_idIndexMarker471"/> and run our services in production. Most orchestrators perform periodical <em class="italic">liveness health checks</em> on their pods during runtime and <em class="italic">readiness health checks</em> during deployments. Health checks help the orchestrator determine which pods are in a ready state and are capable of handling traffic. It is important to understand the differences between the liveness health check and the readiness health check and when which one is most suitable. The easier one to implement is the liveness health check; we will discuss this next.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor161"/>The liveness health check</h2>
<p>The liveness health check <a id="_idIndexMarker472"/>endpoint is a specific endpoint<a id="_idIndexMarker473"/> that is implemented for the sole purpose of the health check. In this health probe, the service is considered healthy when it responds to the <em class="italic">liveness health check</em>. A failure to respond to this endpoint indicates a serious issue with the application. This issue could be caused by a range of reasons, such as a crash or unplanned application restart. For this reason, restarting an application that has failed this check is a common course of action.</p>
<p>Applications that monitor the infrastructure, such as <em class="italic">Kubernetes</em> monitoring Docker containers, use <em class="italic">liveness health checks</em> to determine the health of pods and trigger restarts as needed. Cloud providers also offer health probe functionality with load balancers, which can check the availability of the deployed application by periodically sending a request to the liveness check endpoint. This approach is generally sufficient for web applications and services as we do not need a complicated liveness check endpoint. If the service can accept the request and return a response, then we consider it healthy.</p>
<p>Checking whether the application<a id="_idIndexMarker474"/> or services is alive is simple enough, but we may<a id="_idIndexMarker475"/> also need to mitigate false positives after application deployments and/or upgrades. This can occur when the application might not be completely ready for usage, yet we are getting positive responses from the liveness checks. At this point, we need to consider implementing <em class="italic">readiness health checks</em>.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor162"/>Readiness health checks</h2>
<p><em class="italic">Readiness health checks</em> are used in situations<a id="_idIndexMarker476"/> where we need to verify more<a id="_idIndexMarker477"/> than just an HTTP response. An application with several third-party dependencies might take longer to be ready for use. So, while it is operational and able to respond to a simple HTTP request, the databases or message bus services, for instance, might not yet be ready. We want to ensure that we have a full picture of the status of the application from a startup perspective before proceeding to use it or continuing with the deployment activity.</p>
<p>A <em class="italic">readiness health check</em> will generally only return a healthy status once the startup task has been completed. These checks will then take a bit longer to return a healthy status than a <em class="italic">liveness health check</em> will. With readiness health checks in place, an orchestrator will not attempt to restart the application, but it will not route request traffic. <em class="italic">Kubernetes</em> can perform readiness probes periodically during the application’s runtime, but it can also be configured to only perform this probe during the startup of the application. Once the application reports that it is healthy, then this probe will not be executed again for the lifetime of the application.</p>
<p>This <em class="italic">readiness health check</em> is best used for applications where there are long-running tasks that must finish before the application can be considered ready and operational. Recall that with microservices, we introduce several additional infrastructure dependencies, and we need to monitor and confirm the overall health of the system to ensure that only the healthiest pods get traffic directed to them. Therefore, properly configuring health checks is essential to ensuring that we have the best representation of our application’s health.</p>
<p>Now that we have explored how health<a id="_idIndexMarker478"/> checks work and how<a id="_idIndexMarker479"/> orchestrators and monitoring systems use them, we can explore implementing health checks in our ASP.NET Core API.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor163"/>Implementing ASP.NET Core health checks</h1>
<p>ASP.NET Core has a built-in health check<a id="_idIndexMarker480"/> middleware that allows us to natively implement very robust health checks. This middleware is not limited to API projects, and it comes in handy to help us to monitor the health of our application. Both readiness and liveness health checks can be created natively, and there is support for a UI dashboard. Using the liveness health check, which is relatively simple to implement, we can implement a simple API endpoint that returns a simple response, as expected. We can also check on the health of the dependencies of the app using a more comprehensive readiness health check.</p>
<p>For this example, we will be adding liveness and readiness health checks to our appointment booking service. This service has several dependencies and is integral to several operations in our application. We need to ensure that it is always healthy and react quickly if it degrades.</p>
<p>Let us start off by exploring how we can outfit an ASP.NET Core API with a liveness health check.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor164"/>Adding liveness health checks</h2>
<p>As discussed, a liveness check<a id="_idIndexMarker481"/> is the most basic health<a id="_idIndexMarker482"/> check that can be implemented. The basic configuration needed for this in our ASP.NET Core application is to register the <code>AddHealthChecks</code> service and the addition of the health check middleware, where we define a URL.</p>
<p>We make the following changes to the <code>Program.cs</code> file:</p>
<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// code omitted for brevity
builder.Services.AddHealthChecks();
var app = builder.Build();
// code omitted for brevity
app.MapHealthChecks("/healthcheck ");
app.Run();</pre>
<p>Any attempt to navigate to the <code>/healthcheck</code> endpoint will yield a simple plain text response as <code>HealthStatus</code>. The possible <code>HealthStatus</code> values are <code>HealthStatus.Healthy</code>, <code>HealthStatus.Degraded</code>, or <code>HealthStatus.Unhealthy</code>.</p>
<p>Health checks<a id="_idIndexMarker483"/> are created using the <code>IHeathCheck</code> interface. This<a id="_idIndexMarker484"/> interface allows us to extend the default health checks and add more logic to our health check and further customize the possible response values. We can create a health check extension using the following code block:</p>
<pre class="source-code">
 public class HealthCheck : IHealthCheck
{
    public Task&lt;HealthCheckResult&gt; CheckHealthAsync(
        HealthCheckContext context, CancellationToken =
            default)
    {
        var healthy = true;
        if (healthy)
        {
            // additional custom logic when the health is
            confirmed.
            return Task.FromResult(
                HealthCheckResult.Healthy("Service is
                    healthy"));
        }
        // additional custom logic when the api is not
           healthy
        return Task.FromResult(
            new HealthCheckResult(
                context.Registration.FailureStatus,
                    "Service is unhealthy"));
    }
}</pre>
<p>This inheriting from <code>IHeathCheck</code> forces us to implement the <code>CheckHealthAsync</code> method. This method gets called<a id="_idIndexMarker485"/> when a health check<a id="_idIndexMarker486"/> is triggered, and we can include additional code to check other factors and determine whether we deem our application to be healthy or not. Based on the value of <code>healthy</code>, we can return a custom message.</p>
<p>Now to add <code>HealthCheack</code> to our services, we modify the <code>AddHealthChecks</code> service registration like this:</p>
<pre class="source-code">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth");</pre>
<p>Here, we add our new health check logic and give it a name for a specific reference in other parts of the application. This <code>AddCheck</code> method allows us to define a name for the health check, a default failure status value, tags to map to custom health check endpoints, and a default timeout value.</p>
<p>Now building on the notion<a id="_idIndexMarker487"/> that our orchestrators and load balancers<a id="_idIndexMarker488"/> that are performing health checks will also prefer to see appropriate responses relative to the health status, we can extend the <code>app.MapHealthChecks</code> middleware code to return a specific HTTP response relative to the health status. While we are at it, we can also disable cached responses:</p>
<pre class="source-code">
app.MapHealthChecks("/healthcheck", new HealthCheckOptions
{
    AllowCachingRepsonses = false,
    ResultStatusCodes =
    {
          [HealthStatus.Unhealthy] =
                 StatusCodes.Status503ServiceUnavailable,
        [HealthStatus.Healthy] = StatusCodes.Status200OK,
        [HealthStatus.Degraded] = StatusCodes.Status200OK,
    }
});</pre>
<p>The next thing we may want to investigate is returning details in our response. As it stands, we are only returning the plain text response with the status. We can use methods found in the <code>System.Text.Json</code> library to create a custom delegate method that can be implemented as follows.</p>
<p>We first need to indicate to the middleware that we have a custom <code>ResponseWriter</code> called <code>WriteJsonResponse</code>. We need to add this to the list of <code>HealthCheckOptions</code>, using the following:</p>
<pre class="source-code">
app.MapHealthChecks("/healthcheck", new HealthCheckOptions
{
    // code omitted for brevity
    ResponseWriter = JsonResponse
});</pre>
<p>We then define<a id="_idIndexMarker489"/> the <code>WriteJsonResponse</code> writer with<a id="_idIndexMarker490"/> the following:</p>
<pre class="source-code">
private static Task JsonResponse(HttpContext context,
    HealthReport healthReport)
{
    context.Response.ContentType = "application/json;
        charset=utf-8";
   var options = new JsonWriterOptions { Indented = true };
    using var memoryStream = new MemoryStream();
    using (var jsonWriter = new Utf8JsonWriter
        (memoryStream, options))
    {
        jsonWriter.WriteStartObject();
        jsonWriter.WriteString("status",
            healthReport.Status.ToString());
        jsonWriter.WriteStartObject("results");
        foreach (var healthReportEntry in
           healthReport.Entries)
        {
            jsonWriter.WriteStartObject
                (healthReportEntry.Key);
            jsonWriter.WriteString("status",
                healthReportEntry.Value.Status.ToString());
            jsonWriter.WriteString("description",
                healthReportEntry.Value.Description);
            jsonWriter.WriteStartObject("data");
            foreach (var item in
                healthReportEntry.Value.Data)
            {
                jsonWriter.WritePropertyName(item.Key);
                JsonSerializer.Serialize(jsonWriter,
                    item.Value,
                    item.Value?.GetType() ??
                        typeof(object));
            }
            jsonWriter.WriteEndObject();
            jsonWriter.WriteEndObject();
        }
        jsonWriter.WriteEndObject();
        jsonWriter.WriteEndObject();
    }
    return context.Response.WriteAsync(
        Encoding.UTF8.GetString(memoryStream.ToArray()));
}</pre>
<p><em class="italic">Figure 10.3</em> shows the results<a id="_idIndexMarker491"/> of a health<a id="_idIndexMarker492"/> check:</p>
<div><div><img alt="Figure 10.3 – Shows a health check response where both the service and database are available and in good health" src="img/Figure_10.3_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Shows a health check response where both the service and database are available and in good health</p>
<p>Now we can include details about the health status if the API reports an unhealthy or degraded status. Furthermore, when we add more health checks, the content of this JSON response will be populated with each check’s details.</p>
<p><em class="italic">Figure 10.4</em> shows the results of an unhealthy check:</p>
<div><div><img alt="Figure 10.4 – Shows a health check response where the database is not available" src="img/Figure_10.4_B19100.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – Shows a health check response where the database is not available</p>
<p>Now that we have more detailed<a id="_idIndexMarker493"/> responses, we can add<a id="_idIndexMarker494"/> more detailed checks, such as a database probe. This will serve as a check to verify that the API can communicate with the database through the configured database. By extension, since we are using Entity Framework for this connection, we can implement a <code>DbContext</code> check. We start with the <code>Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore</code> NuGet package. We then modify the <code>AddHealthChecks</code> method registration using the following piece of code:</p>
<pre class="source-code">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth")
      .AddDbContextCheck&lt;ApplicationDbContext&gt;
        ("DatabaseHealth");</pre>
<p>This context health calls Entity Framework Core’s built-in <code>CanConnectAsync</code> method and uses that response to infer the database connectivity health.</p>
<p>Now that we can check<a id="_idIndexMarker495"/> on the health of our service<a id="_idIndexMarker496"/> and its connectivity to our database let us configure it for readiness checks.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor165"/>Adding readiness health checks</h2>
<p>As we have discussed, the readiness<a id="_idIndexMarker497"/> check indicates when the application<a id="_idIndexMarker498"/> and its dependencies have started successfully and are ready to begin receiving requests. We can define a separate endpoint for the readiness check and further customize the checks that should be performed based on the URL used.</p>
<p>To implement liveness and readiness checks on different URLs, we can add a <code>tags</code> parameter to the extensions to the <code>AddHealthChecks</code> method. This allows us to pass in an array of tag names. We can tag our health checks like this:</p>
<pre class="source-code">
builder.Services.AddHealthChecks()
    .AddCheck&lt;HealthCheack&gt;("ApiHealth", tags: new[] {
      "live"})
 .AddDbContextCheck&lt;ApplicationDbContext&gt;("DatabaseHealth",
    tags: new[] { "ready" });</pre>
<p>Now that we have tagged our health checks, we can proceed to create our specific check endpoints and associate them with the tags:</p>
<pre class="source-code">
app.MapHealthChecks("/healthcheck/ready", new
    HealthCheckOptions
{
    Predicate = healthCheck =&gt;
        healthCheck.Tags.Contains("ready"),
    // code omitted for brevity
});
app.MapHealthChecks("/healthcheck/live", new
    HealthCheckOptions
{
    Predicate = healthCheck =&gt; false;
    // code omitted for brevity
});</pre>
<p>With this new code, the <code>/healthcheck/ready</code> endpoint will filter only health checks that are tagged as <code>ready</code>. In the <code>/health/live</code> endpoint, we set the predicate value to <code>false</code> to ignore all tags and conduct all health checks.</p>
<p>While we will not be<a id="_idIndexMarker499"/> exploring Kubernetes or other<a id="_idIndexMarker500"/> orchestrators in detail, we want to look at how orchestrators interact with our health check endpoints.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor166"/>Configuring health probes in orchestrators</h1>
<p>Monitoring is not unique<a id="_idIndexMarker501"/> to orchestrators, as we have already<a id="_idIndexMarker502"/> established. There are services that offer monitoring services for our applications and allow us to configure probes into our applications. These services generally allow us to add alerts and configure response time thresholds. These alerts can come in handy in helping us to respond to failures or situations of concern based on our configured thresholds.</p>
<p>In a microservices application, we need a way of monitoring many services as efficiently as possible. The fewer unique configurations we need to do, the better. We have several deployment models that can be used, and most predominantly, containers managed by orchestrators. Microsoft<a id="_idIndexMarker503"/> Azure has several<a id="_idIndexMarker504"/> web application<a id="_idIndexMarker505"/> deployment models, including <strong class="bold">Web App for Containers</strong> (<strong class="bold">WAC</strong>), <strong class="bold">Azure Container Instances</strong> (<strong class="bold">ACI</strong>), and <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>).</p>
<p>WAC is a part of App Service, so the health check works the same way as it would for an Azure web app. It allows you to specify a health check endpoint that will return a response within the 2xx and 3xx HTTP response range. It should also return this health check response within a minute for the service to be considered healthy.</p>
<p>The next option<a id="_idIndexMarker506"/> is the ACI, where health checks<a id="_idIndexMarker507"/> are called health probes. These probes are configured with a check period, which determines the frequency with which checks are made. When the health check is completed successfully, then the container is considered healthy, and if not, then it is unhealthy or just unavailable. With the ACI, we can configure both liveness and readiness health checks. Our probes can either execute a command on the container or perform an HTTP <code>GET</code> request. When we perform a liveness probe, we verify that our container is healthy, and if not, the ACI might proceed to shut down the container and spin up a new instance. The readiness probe is designed to confirm whether a container is available for request processing, which, as we discussed, is more important during the application startup process.</p>
<p>In the Azure Kubernetes Service of AKS, we have a very similar approach to health checks and probes, as we saw in the ACI. Out of the box, Kubernetes supports both liveness and readiness probes; as seen before, the major difference is that Kubernetes suggests that you have a separate probe for checking the application’s health at startup, separate from the readiness probe that is continuous during the application runtime. We can also implement HTTP <code>GET</code> request probes as well as TCP probes to check on our containers.</p>
<p>Kubernetes is configured<a id="_idIndexMarker508"/> using a markup language called <code>spec.template</code> field of the YAML configuration.</p>
<p>The following is an example of a YAML configuration that creates a deployment object that performs startup, liveness, and readiness health checks on a container:</p>
<pre class="source-code">
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness-api
  name: liveness-http
spec:
  ports:
  - name: api-port
    containerPort: 8080
    hostPort: 8080
  containers:
  - name: liveness-api
    image: registry.k8s.io/liveness
    args:
    - /server
    livenessProbe:
      httpGet:
        path: /healthcheck/live
        port: api-port
      initialDelaySeconds: 3
      failureThreshold: 1
      periodSeconds: 3
    startupProbe:
      httpGet:
        path: /healthcheck/ready
        port: api-port
      failureThreshold: 30
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /healthcheck/ready
        port: api-port
      failureThreshold: 30
      periodSeconds: 10</pre>
<p>The sections of the YAML file that outline the health checks are <code>livenessProbe</code>, <code>startupProbe</code>, and <code>readinessProbe</code>. The probe definition with the major difference is the readiness<a id="_idIndexMarker510"/> probe, which executes a command<a id="_idIndexMarker511"/> as opposed to making a call to an endpoint.</p>
<p>With this, we have gained some fundamental knowledge of health checks, how they work, and why we need them.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor167"/>Summary</h1>
<p>Health checks are simple yet powerful constructs that aid us in ensuring that our applications are running at maximum efficiency. We see where it is important for us to not only monitor and report on the uptime of the service but also the dependencies, such as the database and other services that may be needed for the application to operate properly.</p>
<p>Using ASP.NET Core, we have access to a built-in health check mechanism that can be customized and extended to implement specific checks and associate them with different endpoints. This is especially useful when we need to separate the types of tests that are conducted relative to the endpoint being called.</p>
<p>We have also explored how orchestrators can be configured to poll our health check endpoints. Orchestrators make monitoring and responding to failures easier since they will handle the routing of traffic to healthy instances and restart instances as needed.</p>
<p>Health checks help us not only monitor the target web service, but we can also configure health checks to report on downstream services as well. This will come in handy, especially when we implement dependencies between our microservices through patterns like the API gateway pattern. We will investigate implementing this pattern in the next chapter.</p>
</div>
</body></html>