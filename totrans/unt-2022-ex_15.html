<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-202"><a id="_idTextAnchor212" class="pcalibre1 pcalibre calibre6"/>11</h1>
<h1 id="_idParaDest-203" class="calibre5"><a id="_idTextAnchor213" class="pcalibre1 pcalibre calibre6"/>Continuing the FPS Game</h1>
<p class="calibre3">In <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, we made some updates to our GDD for our new 3D FPS game. We added specific details about the level design, which helped us to create the habitat’s interior-level environment using a grayboxing kit of modular parts that <em class="italic">snap</em> together. We also used Unity <strong class="bold">ProBuilder</strong> to draw out a level map.</p>
<p class="calibre3">We finished by learning how to quickly add an FPS player character to our game by utilizing the <strong class="bold">Unity Starter Assets First Person Character Controller</strong>. We added the health system and healing pickups to engage the player’s abilities by reusing previous systems and code. We also refactored to 3D API method counterparts to make an animated door that opens when the player triggers it.</p>
<p class="calibre3">In this chapter, we will update and finalize the 3D environment with polished assets, scatter objects to increase realism, and incorporate wear-and-tear effects. Additionally, we will improve the lighting to create an immersive experience for the player and ensure optimal game performance.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre17">
<li class="calibre15">Decorating the 3D environment</li>
<li class="calibre15">Immersing the player using Polybrush and Decals</li>
<li class="calibre15">Lighting design – Probes, Decals, light baking, and performance</li>
</ul>
<p class="calibre3">By the end of this chapter, you will have the skills to enhance a 3D environment by replacing <strong class="bold">Prefabs</strong> and materials, increase realism and immerse the player by decorating the environment using Unity artist tools such as <strong class="bold">Polybrush</strong> and <strong class="bold">Decals</strong>, and bake lighting along with techniques to overcome limitations for lighting and shadows of dynamic objects in the scene. Additionally, you will gain knowledge on performance considerations related to lighting.</p>
<h1 id="_idParaDest-204" class="calibre5"><a id="_idTextAnchor214" class="pcalibre1 pcalibre calibre6"/>Technical requirements</h1>
<p class="calibre3"><a id="_idTextAnchor215" class="pcalibre1 pcalibre calibre6"/>To follow along with the same artwork that was created for the project in this book, download the assets from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets</a>.</p>
<p class="calibre3">You can download the complete project from GitHub at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example</a>.</p>
<p class="calibre3">To follow along with your own 3D artwork, you’ll need to create similar artwork using 3D modeling and texturing software (for example, Blender, Maya, 3ds Max, Cinema 4D, ZBrush, Silo, Substance 3D Painter, Quixel Mixer, or 3DCoat).</p>
<h1 id="_idParaDest-205" class="calibre5"><a id="_idTextAnchor216" class="pcalibre1 pcalibre calibre6"/>Decorating the 3D environment</h1>
<p class="calibre3">Our 3D FPS game is<a id="_idIndexMarker1076" class="pcalibre1 pcalibre calibre6"/> well on its way to becoming something of a real game, but it must graduate from its graybox environment first if we want it to be attractive to potential players. This section will explore Unity 2022 features for replacing the graybox kit module’s Prefabs with polished and textured 3D mesh Prefabs that properly represent our habitat’s interior environment.</p>
<p class="calibre3">We’ll not only replace the existing graybox Prefabs but also introduce new assets to decorate the environment to make it feel more complete and lived-in. This will be a combination of both 3D models and textures that we’ll apply in different ways, again, using Unity’s artist feature<a id="_idIndexMarker1077" class="pcalibre1 pcalibre calibre6"/> tooling (specific to <strong class="bold">Universal RP</strong>).</p>
<p class="calibre3">Here is an example of what our interior habitat environment – which has gone through the processes outlined in this chapter – will look like:</p>
<div><div><img alt="Figure 11.1 – Habitat interior scene lighting" src="img/B18347_11_1.jpg" class="calibre127"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Habitat interior scene lighting</p>
<p class="calibre3">Our first order <a id="_idIndexMarker1078" class="pcalibre1 pcalibre calibre6"/>of business is to replace those boring graybox Prefabs. Having the environment look correct will help with the following steps as we decorate and detail it.</p>
<h2 id="_idParaDest-206" class="calibre8"><a id="_idTextAnchor217" class="pcalibre1 pcalibre calibre6"/>Updating and replacing Prefabs</h2>
<p class="calibre3">Replacing Prefabs is <a id="_idIndexMarker1079" class="pcalibre1 pcalibre calibre6"/>more of a structured <a id="_idIndexMarker1080" class="pcalibre1 pcalibre calibre6"/>approach to dealing with the art assets; since we’re working with fixed modular parts, the art is in creating polished 3D assets. In this case, we’re going to be using 3D assets produced by my friends over at Polypix <a id="_idIndexMarker1081" class="pcalibre1 pcalibre calibre6"/>Studios (<a href="https://polypixstudios.com/" class="pcalibre1 pcalibre calibre6">https://polypixstudios.com/</a>).</p>
<p class="callout-heading">Note of gratitude</p>
<p class="callout">Miguel Dumars was kind enough to provide select assets from their <em class="italic">Neon Street</em> and <em class="italic">Stylized Scifi Modular Corridor</em> Unreal kits for use in this Unity project, and I’m very excited to be working with these assets!</p>
<p class="calibre3">Polypix Studios has permitted the use of the provided game art for learning purposes only; commercial use is strictly prohibited. Polypix Studio’s portfolios can be viewed on ArtStation<a id="_idIndexMarker1082" class="pcalibre1 pcalibre calibre6"/> at <a href="https://www.artstation.com/polypixcc" class="pcalibre1 pcalibre calibre6">https://www.artstation.com/polypixcc</a> and Unreal Marketplace at <a href="https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios" class="pcalibre1 pcalibre calibre6">https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios</a>.</p>
<p class="calibre3">To get started, let’s import the Polypix artwork.</p>
<h3 class="calibre10">Importing and reviewing the assets</h3>
<p class="calibre3">You should be a<a id="_idIndexMarker1083" class="pcalibre1 pcalibre calibre6"/> pro in the process of importing assets into Unity projects by now, so we won’t waste any time detailing each little step. Download the 3D art assets file, <code>3DArtwork.zip</code>, from this book’s GitHub repository (link in the <em class="italic">Technical requirements</em> section) to a temporary directory, then import the <code>.unitypackage</code> files into your current 3D FPS project.</p>
<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.2</em>, we can see the new modular kit parts in the <strong class="bold">Polypix Modular Kit</strong> scene provided in the package:</p>
<div><div><img alt="Figure 11.2 – Polypix Studios modular kit" src="img/B18347_11_2.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Polypix Studios modular kit</p>
<p class="calibre3">Since this is the first time we’re working with third-party 3D assets, let’s have a look at the files that were imported into the <code>Assets/Polypix 3D Assets/Modular Kit</code> folder (also shown in <em class="italic">Figure 11</em><em class="italic">.2</em>):</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Materials</strong>: These materials are applied and shared across 3D models of the same category (walls, doorways, and so on). The same material is shared across several models to keep things more optimized as this reduces draw calls for the renderer (that is, it’s less work, resulting in higher FPS).</li>
<li class="calibre15"><strong class="bold">Models</strong>: These are the optimized polygon meshes (vertices, edges, and faces) that make up the 3D geometry representing the shape of the objects.</li>
<li class="calibre15"><strong class="bold">Prefabs </strong>(yes, I know you know what Prefabs are): These are the Polypix models with the materials applied and colliders added as finished objects we can use directly in our game.</li>
<li class="calibre15"><strong class="bold">Textures</strong>: Textures are the image files that are mapped onto the 3D geometry via assignment to the material that’s applied to 3D geometry to give it color and details.</li>
</ul>
<p class="calibre3">We’ll mainly be concerned with the Prefabs since we’ll use them to replace the initial graybox kit modular parts we made to build the level. In the <code>/Prefabs</code> folder, we have the same graybox wall assets but all textured and fancy.</p>
<p class="calibre3">Now, let’s see how<a id="_idIndexMarker1084" class="pcalibre1 pcalibre calibre6"/> we can rapidly replace the modular graybox kit Prefabs with this new artwork.</p>
<h3 class="calibre10">Replacing Prefab instances</h3>
<p class="calibre3">With the replacement <a id="_idIndexMarker1085" class="pcalibre1 pcalibre calibre6"/>art assets imported into the project, we can go ahead and start replacing Prefabs. Unity 2022 has introduced some new Prefab workflow features and <strong class="bold">Search</strong>, which will greatly help us in this endeavor.</p>
<p class="callout-heading">Additional reading | Unity Blog</p>
<p class="callout">Unity’s new Prefab workflow features go far beyond simple Prefab replacement, transfer overrides, reconnecting Prefabs, and inspecting Prefab Variant relationships. You can read about these additional features in the following Unity Blog article: <em class="italic">What’s new for Prefabs in </em><em class="italic">2022.2?</em> <a href="https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2" class="pcalibre1 pcalibre calibre6">https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2</a>.</p>
<p class="callout">Unity Blog is a fantastic resource for learning content! I highly recommend regularly consuming Unity’s blog articles to rapidly broaden your knowledge and elevate your understanding of what Unity is capable of.</p>
<p class="calibre3">We will use the following process as much as possible to mass-replace the Prefabs in our level. However, we’ll no doubt still have to make some manual adjustments to some of the layout’s finer details – due to some changes in the art direction (that may or may not have been my fault).</p>
<p class="calibre3">Some of the Prefabs that we’ve added behavior to already are examples of Prefabs that we must manually update and cannot simply replace in the scene with new art, but we’ll still be able to merely replace the art within the Prefab because we’ve maintained keeping the <em class="italic">graphics</em> as separate child objects in the Prefab (as you may recall, we’ve been using this practice throughout this book thus far, and this is just another example of the benefit of being consistent in terms of our approach).</p>
<p class="calibre3">Let’s get to it and make our first Prefab replacement. We’ll replace the <code>Wall 1</code> graybox Prefab in the scene with the <code>Wall 1</code> Prefab from the Polypix <code>/Prefabs</code> folder. We’ll use both the<a id="_idIndexMarker1086" class="pcalibre1 pcalibre calibre6"/> new <strong class="bold">Search</strong> feature as<a id="_idIndexMarker1087" class="pcalibre1 pcalibre calibre6"/> well as<a id="_idIndexMarker1088" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Prefab Replace</strong> workflow by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Search</strong> by going to <strong class="bold">Window</strong> | <strong class="bold">Search</strong> | <strong class="bold">New Window</strong>, clicking the <strong class="bold">Open in Search</strong> button at the top of the <strong class="bold">Hierarchy</strong> window, or pressing <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">K</em>.</li>
<li class="calibre15">In the <code>Wall 1</code> with quotes to search explicitly for this string (removing the quotes will search for all occurrences; note that <strong class="bold">Search</strong> is not case sensitive).</li>
<li class="calibre15">Select the <strong class="bold">Hierarchy</strong> tab to filter the search to only objects in the open scene <strong class="bold">Hierarchy</strong>.</li>
<li class="calibre15">Now, select all the items in the results list by clicking on the first item, then scroll to the bottom and hold <em class="italic">Shift</em> and click the last item.</li>
<li class="calibre15">Right-click and click <strong class="bold">Select</strong> (or hit the <em class="italic">Enter</em> key):</li>
</ol>
<div><div><img alt="Figure 11.3 – Unity Search for easy scene Prefab selection" src="img/B18347_11_3.jpg" class="calibre128"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Unity Search for easy scene Prefab selection</p>
<p class="calibre3">With all of the <code>Wall 1</code> Prefabs in the scene now selected, we can easily replace them with <strong class="bold">Prefab Replace</strong> – which<a id="_idIndexMarker1089" class="pcalibre1 pcalibre calibre6"/> is only a two-step process:</p>
<ol class="calibre14">
<li class="calibre15">Right-click one of the selected <code>Wall 1</code> Prefabs in the <strong class="bold">Hierarchy</strong> area, then select <strong class="bold">Prefab | </strong><strong class="bold">Replace…</strong>:</li>
</ol>
<div><div><img alt="Figure 11.4 – Prefab – replace instance selection" src="img/B18347_11_4.jpg" class="calibre129"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Prefab – replace instance selection</p>
<ol class="calibre14">
<li value="2" class="calibre15">Select the replacement Prefab in the <code>Assets/Polypix 3D Assets/Modular Kit/Prefabs</code> folder (using <em class="italic">Table 11.1</em> as a reference):</li>
</ol>
<div><div><img alt="Figure 11.5 – Selecting the replacement Prefab" src="img/B18347_11_5.jpg" class="calibre130"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Selecting the replacement Prefab</p>
<p class="calibre3">You can use the <a id="_idIndexMarker1090" class="pcalibre1 pcalibre calibre6"/>replacements indicated in the following table for the graybox kit Prefab and corresponding Polypix imported Prefab as a guide:</p>
<table class="no-table-style" id="table001-7">
<colgroup class="calibre11">
<col class="calibre12"/>
<col class="calibre12"/>
</colgroup>
<thead class="calibre131">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Greybox Prefab</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Polypix Prefab</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre13">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>Wall 1</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>Wall_01 Variant</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>Wall 2</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>Wall_02 Variant</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>Wall 4</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>Wall_04 Variant</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>Doorway 1</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>Doorway_01 Variant</code></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 11.1 – Replacement graybox Prefabs</p>
<p class="callout-heading">New to Unity 2022 – 3D models are Prefabs</p>
<p class="callout">You might be wondering why the Polypix replacement Prefabs listed in <em class="italic">Table 11.1</em> all have <em class="italic">Variant</em> in their naming. Well, that’s because you can no longer make original Prefabs from 3D models (for example, FBX files). Unity now imports 3D models as <strong class="bold">Model Prefabs</strong>, so when <a id="_idIndexMarker1091" class="pcalibre1 pcalibre calibre6"/>you create a Prefab out of a 3D model, it must be a <strong class="bold">Prefab Variant</strong>. This <a id="_idIndexMarker1092" class="pcalibre1 pcalibre calibre6"/>change goes a long way to help ensure we don’t break Prefab content for our 3D model assets.</p>
<p class="callout">Since all of the Polypix assets have been pre-produced in Unity for immediate use in our scene with the proper materials, textures, scale, and so on and re-saved, they become variants of the original 3D Model Prefabs.</p>
<p class="calibre3"><em class="italic">Figure 11</em><em class="italic">.6</em> shows the results of my efforts in doing these simple Prefab replacement steps for the walls<a id="_idIndexMarker1093" class="pcalibre1 pcalibre calibre6"/> and doorway listed in <em class="italic">Table 11.1</em>. The job of updating the artwork is already more than halfway done! Easy-peasy:</p>
<div><div><img alt="Figure 11.6 – Wall Prefabs replaced in the scene" src="img/B18347_11_6.jpg" class="calibre129"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Wall Prefabs replaced in the scene</p>
<p class="callout-heading">Tip</p>
<p class="callout">Note that in my level design, I found that I could not use all the replacements directly with the finished artwork and instead changed some of the wall modules out for different ones. So, your mileage may vary as well. It’s all part of the design process; much like coding, it’s an iterative process.</p>
<p class="calibre3">Just repeat the preceding steps to replace all the static graybox modular parts – <em class="italic">static</em> means these are structural and don’t contain any behavior, interactivity, or animation. We’ll address the <code>Door_Triggered</code> Prefab next since it has animation and won’t be directly replaced.</p>
<p class="calibre3">These additional <a id="_idIndexMarker1094" class="pcalibre1 pcalibre calibre6"/>updates on the graybox kit parts will occur in <strong class="bold">Prefab Edit Mode</strong>, but we’ll still simply replace the <em class="italic">graphics</em> with the updated artwork.</p>
<h3 class="calibre10">Updating the existing modular Prefabs</h3>
<p class="calibre3">Some Prefabs, such as <code>Doorway_Trigger</code>, cannot just be replaced because they have the behavior<a id="_idIndexMarker1095" class="pcalibre1 pcalibre calibre6"/> we added in the form of a collider-triggered animation. Using this as an example workflow, let’s update <code>Doorway_Trigger</code> by performing the following steps:</p>
<ol class="calibre14">
<li class="calibre15">Open the <code>Door_Triggered</code> Prefab in <strong class="bold">Prefab Edit Mode</strong> for direct editing.</li>
<li class="calibre15">Add the <code>Door_Trigger</code> <code>/</code><code>Prefabs</code> folder.</li>
<li class="calibre15">Reconnect the animation for the new <code>Sliding_Door_01</code> object that replaced the <code>Door</code> object’s animation – ensure you disable or delete the <code>Door</code> object since we’re replacing it and don’t need it anymore.</li>
<li class="calibre15">Update <code>TriggeredEvent.OnTriggered()</code> <code>Animator.Play(string)</code> to reference the new <code>Sliding_Door_01</code> object that replaced the <code>Door</code> object so that our <code>Door-open</code> animation will still be functional on the new door mesh. Remember that the string value for the <code>Animator.Play()</code> function is the same as the animation’s name: <em class="italic">Door-open</em>.</li>
</ol>
<p class="calibre3"><em class="italic">Figure 11</em><em class="italic">.7</em> illustrates the refactored setup:</p>
<div><div><img alt="Figure 11.7 – Updating the door trigger Prefab" src="img/B18347_11_7.jpg" class="calibre129"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Updating the door trigger Prefab</p>
<p class="calibre3">I believe this leaves only the <strong class="bold">connector</strong> Prefabs that need updating. The Polypix assets don’t include direct replacement Prefabs for connectors, so just make them yourself! You can create a new connector Prefab by duplicating the original graybox asset and then replacing the child graphics – as <strong class="bold">nested Prefabs</strong> – to create the replacement connector<a id="_idIndexMarker1096" class="pcalibre1 pcalibre calibre6"/> Prefabs.</p>
<p class="calibre3">I won’t provide the steps for this process since you have all the required knowledge to accomplish this now. Still, if you get stuck, you can always reference the new connector Prefabs in the<a id="_idIndexMarker1097" class="pcalibre1 pcalibre calibre6"/> completed project files in this book’s GitHub repository. You’ve got this!</p>
<p class="calibre3">With that, we have replacement Prefabs from Polypix and some new material textures we can apply.</p>
<h2 id="_idParaDest-207" class="calibre8"><a id="_idTextAnchor218" class="pcalibre1 pcalibre calibre6"/>Applying new materials</h2>
<p class="calibre3">While we’re doing<a id="_idIndexMarker1098" class="pcalibre1 pcalibre calibre6"/> some art updates, we also have some new materials we can use to update our floor planes’ appearance (our <code>/Materials</code> folder, we have a <strong class="bold">FloorPlate</strong> material, so let’s assign that to our map to have it become our textured floor.</p>
<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.8</em>, you can see that I have renamed the <strong class="bold">Map</strong> root’s GameObject in the <strong class="bold">Hierarchy</strong> area to <strong class="bold">Floors</strong>. With <strong class="bold">Floors</strong> selected, pressing <em class="italic">Shift</em> + <em class="italic">H</em> will enter <strong class="bold">Isolation View</strong> (<em class="italic">A</em>) – temporarily <a id="_idIndexMarker1099" class="pcalibre1 pcalibre calibre6"/>hiding all the other objects in the <strong class="bold">Hierarchy</strong> area, which makes it easy for us to assign a new material to the selected object by clicking and dragging the <strong class="bold">FloorPlate</strong> material (<em class="italic">B</em>) onto a plane in the <strong class="bold">Scene</strong> view area:</p>
<div><div><img alt="Figure 11.8 – Updating the floor material" src="img/B18347_11_8.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Updating the floor material</p>
<p class="callout-heading">Toggle visibility shortcut</p>
<p class="callout">Note that you can also use <em class="italic">Alt/Option</em> + <em class="italic">Shift</em> + <em class="italic">A</em> to toggle the visibility of the currently selected object.</p>
<p class="calibre3">Alternatively, since <a id="_idIndexMarker1100" class="pcalibre1 pcalibre calibre6"/>these planes are ProBuilder objects, we can open the <strong class="bold">ProBuilder Window</strong> area (<strong class="bold">Tools</strong> | <strong class="bold">ProBuilder</strong> | <strong class="bold">ProBuilder Window</strong>), select <strong class="bold">Material Editor</strong> from the toolbar, and assign the <strong class="bold">FloorPlate</strong> material to the next available slot (see <em class="italic">Figure 11</em><em class="italic">.9</em>):</p>
<div><div><img alt="Figure 11.9 – ProBuilder Material Editor assignment" src="img/B18347_11_9.jpg" class="calibre132"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.9 – ProBuilder Material Editor assignment</p>
<p class="calibre3">With the material assigned, you can now select all the floor planes in the <strong class="bold">Hierarchy</strong> area and press<a id="_idIndexMarker1101" class="pcalibre1 pcalibre calibre6"/> the shortcut key assigned to the <strong class="bold">FloorPlate</strong> material in one shot – in our case, that’s <em class="italic">Alt</em> + <em class="italic">3</em>. Simple!</p>
<p class="calibre3">While we’re at it with the floor, let’s add a ceiling to our habitat interior too! This is quite simple for us now:</p>
<ol class="calibre14">
<li class="calibre15">Use <strong class="bold">ProBuilder</strong> and create a new plane.</li>
<li class="calibre15">Scale it to contain all of the rooms in our level, then position its height at the top of the wall Prefabs – just where a ceiling should be (in my level, this comes out to a Y transform position value of <code>4</code>).</li>
<li class="calibre15">From the Polypix <code>/Materials</code> folder, assign the <strong class="bold">CeilingPlate</strong> material to the ceiling plane.</li>
<li class="calibre15">Lastly, for the texture to be visible from the bottom of the plane, not the top, as is the default and not what we want since our player is below the ceiling and looking up at it, in the <strong class="bold">ProBuilder</strong> window, click <strong class="bold">Flip Normals</strong>.</li>
</ol>
<p class="callout-heading">Surface normals</p>
<p class="callout"><strong class="bold">Normals</strong> – or <strong class="bold">surface normals</strong> – depict the direction a polygon’s surface faces (that is, its visible side):</p>
<div><div><img alt="" role="presentation" src="img/B18347_11_Collout-Image.jpg" class="calibre133"/>
</div>
</div>
<p class="callout">The surface on the left has its normals (the orange lines) pointing up, facing the camera so that we can see the texture. In contrast, the surface on the right has its normals pointing down and away from the camera, so we cannot see the texture.</p>
<p class="calibre3">And with that, we have our graybox level all updated with polished artwork!</p>
<p class="calibre3">In this section, we saw how to replace graybox assets used for prototyping with imported polished artwork using Unity’s <a id="_idIndexMarker1102" class="pcalibre1 pcalibre calibre6"/>new <strong class="bold">Prefab Workflow</strong> and <strong class="bold">Search</strong>. We then finished up the<a id="_idIndexMarker1103" class="pcalibre1 pcalibre calibre6"/> interior 3D habitat environment refresh by applying some new materials.</p>
<p class="calibre3">Next, since our 3D habitat environment still looks a bit boring, we can quickly fix that by scattering some Prefabs about the place.</p>
<h1 id="_idParaDest-208" class="calibre5"><a id="_idTextAnchor219" class="pcalibre1 pcalibre calibre6"/>Immersing the player using Polybrush and Decals</h1>
<p class="calibre3">In contrast to <a id="_idIndexMarker1104" class="pcalibre1 pcalibre calibre6"/>the <a id="_idIndexMarker1105" class="pcalibre1 pcalibre calibre6"/>previous<a id="_idIndexMarker1106" class="pcalibre1 pcalibre calibre6"/> structured method of using fixed, modular parts such as Prefab replacements, a more freeform method offers a different perspective to the artistic approach. So, instead of relying on prefabricated objects, we’ll create dynamic, spontaneous pieces from scratch (well, randomization) using Polybrush.</p>
<h2 id="_idParaDest-209" class="calibre8"><a id="_idTextAnchor220" class="pcalibre1 pcalibre calibre6"/>Painting objects with Polybrush</h2>
<p class="calibre3"><strong class="bold">Polybrush</strong> offers <a id="_idIndexMarker1107" class="pcalibre1 pcalibre calibre6"/>us an unconstrained way to decorate the <a id="_idIndexMarker1108" class="pcalibre1 pcalibre calibre6"/>environment and randomly scatter Prefabs for their placement – so, not modular at all. Considering this, we’re only going to <a id="_idIndexMarker1109" class="pcalibre1 pcalibre calibre6"/>cover the <strong class="bold">Scatter Objects</strong> feature of Polybrush, but know that it has more capabilities than that.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about Polybrush here: <a href="https://unity.com/features/polybrush" class="pcalibre1 pcalibre calibre6">https://unity.com/features/polybrush</a>.</p>
<p class="calibre3">While preparing for writing, I experienced some issues using Polybrush to paint objects onto ProBuilder’ized meshes, so while waiting for Unity to respond to my bug report concerning this, we’ll continue with a workaround, which is simply to enable <strong class="bold">Use Additional Vertex Streams</strong> in <strong class="bold">Preferences</strong> | <strong class="bold">Polybrush</strong>. Remember this should you run into any problems with ProBuilder objects! As an alternative, you can mesh’ify the ProBuilder objects by selecting them and going to <strong class="bold">Tools</strong> | <strong class="bold">ProBuilder</strong> | <strong class="bold">Actions</strong> | <strong class="bold">Strip ProBuilder Scripts in Selection</strong>, but this also means you will no longer be able to edit <a id="_idIndexMarker1110" class="pcalibre1 pcalibre calibre6"/>the <a id="_idIndexMarker1111" class="pcalibre1 pcalibre calibre6"/>mesh with ProBuilder.</p>
<p class="calibre3">Now that we’ve learned how to avoid issues while painting on specific object meshes, let’s paint!</p>
<h2 id="_idParaDest-210" class="calibre8"><a id="_idTextAnchor221" class="pcalibre1 pcalibre calibre6"/>Painting/scattering objects</h2>
<p class="calibre3">We’ll need some <a id="_idIndexMarker1112" class="pcalibre1 pcalibre calibre6"/>objects to scatter throughout our environment, so if you haven’t already, import <code>Sci_Fi_Assets.unitypackage</code> from the GitHub artwork download. You’ll want to do it now, if not earlier.</p>
<p class="calibre3">Now, while referencing <em class="italic">Figure 11</em><em class="italic">.10</em>, follow these steps to set up the Prefab painting:</p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Polybrush</strong> by going to <strong class="bold">Tools</strong> | <strong class="bold">Polybrush</strong> | <strong class="bold">Polybrush Window</strong>.</li>
<li class="calibre15">Click the <strong class="bold">Scatter Prefabs on meshes</strong> button (<em class="italic">A</em> in <em class="italic">Figure 11</em><em class="italic">.10</em>).</li>
<li class="calibre15">Drag the <code>Barrels</code> and <code>Trashcan</code> Prefabs from the <code>Assets/Polypix 3D Assets/Prefabs</code> folder from the <strong class="bold">Project</strong> window to the <strong class="bold">Current Palette</strong> section (<em class="italic">B</em> in <em class="italic">Figure 11</em><em class="italic">.10</em>):</li>
</ol>
<div><div><img alt="Figure 11.10 – Polybrush Prefab painting setup" src="img/B18347_11_10.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Polybrush Prefab painting setup</p>
<p class="calibre3">By default, <strong class="bold">Hit Surface is Parent</strong> is enabled in the <strong class="bold">Polybrush Window</strong> area, making all the painted Prefabs a child of the mesh being painted on. In <em class="italic">Figure 11</em><em class="italic">.10</em>, you can see that I have disabled <strong class="bold">Hit Surface is Parent</strong> so that all the painted objects can be collected into a <a id="_idIndexMarker1113" class="pcalibre1 pcalibre calibre6"/>single parent <strong class="bold">GameObject</strong> in the <strong class="bold">Hierarchy</strong> area (this is my preference, but you may prefer to have the painted objects as children of the mesh they were painted on). If you’re keeping this option disabled, once you’ve painted objects throughout the environment, ensure you select all the painted objects from the root of the <strong class="bold">Hierarchy</strong> area and move them into a new, empty <em class="italic">Scattered Objects</em> root GameObject.</p>
<p class="calibre3">We can now proceed to decorate the environment by using the assets that were added to the <strong class="bold">Current Palette</strong> area (wearing our <em class="italic">interior designer</em> hat?). First, add the Prefabs for our brush from the <strong class="bold">Current Palette</strong> area to the <strong class="bold">Brush Loadout</strong> selection (as seen in <em class="italic">B</em> in <em class="italic">Figure 11</em><em class="italic">.10</em>) by checking off the item (selecting the item in the <strong class="bold">Current Palette</strong> area will also produce a drop-down section below it where you can adjust settings for how the item should be considered for painting).</p>
<p class="calibre3">Painting Prefab objects in the environment is now as simple as hovering the mouse cursor over the floor mesh in the <strong class="bold">Scene</strong> view and holding the left mouse button down while dragging in the area you want to have objects scattered – as seen in <em class="italic">C</em> in <em class="italic">Figure 11</em><em class="italic">.10</em>. Holding down <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> while painting will work as an eraser and remove objects should you dislike any placements. Have fun!</p>
<p class="callout-heading">Tip</p>
<p class="callout">Polybrush works on vertical surfaces too, so you can scatter Prefabs on the walls (just know that you may need to re-orient or position the Prefab’s anchor for the objects to paint as intended; I have provided an example Prefab for this with <strong class="source-inline1">Exhaust_01 Pb</strong>).</p>
<p class="calibre3">Scattering objects to break up the environment is one part of environment design that can lead to the better immersion of the player, while another is also breaking up visually repeating patterns. We<a id="_idIndexMarker1114" class="pcalibre1 pcalibre calibre6"/> can solve the latter with another Unity artist tool that recently got some love in version 2022.</p>
<h2 id="_idParaDest-211" class="calibre8"><a id="_idTextAnchor222" class="pcalibre1 pcalibre calibre6"/>Surface story with Decals</h2>
<p class="calibre3">As my friend Miguel, over <a id="_idIndexMarker1115" class="pcalibre1 pcalibre calibre6"/>at Polypix Studios, would say, <em class="italic">surface story matters</em>, and I wholeheartedly agree! Unless you’re going for a super-pristine futuristic-clean look, you’ll want to ensure your environments are grounded in the real world. This means that these environments will communicate their history of usage – wear and tear – through their texture details. Let’s say our habitat station’s maintenance robots are not very good at janitorial duties, so the environment should be indicated as such. Plus, you know that there should be some indication of the plant entity’s effect on the environment!</p>
<p class="calibre3">This is a great opportunity to either refer back to the GDD or expand upon the details that support the story we’re telling through the environmental design.</p>
<p class="calibre3">As designers (or developers wearing the hat of a designer), we don’t need much in the way of 3D artistic skills to leverage surface story in our environment design. We can use tooling that Unity provides (surprised?) to add surface details to the environment, and we do that with <strong class="bold">Decals</strong>.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">You can read more about the Decal renderer feature (URP) here: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml</a>.</p>
<p class="calibre3">Before we can <a id="_idIndexMarker1116" class="pcalibre1 pcalibre calibre6"/>use Decals in our project, we have to enable the feature.</p>
<h3 class="calibre10">Enabling the Decal feature in URP</h3>
<p class="calibre3">To<a id="_idIndexMarker1117" class="pcalibre1 pcalibre calibre6"/> enable <strong class="bold">Decals</strong> in the <strong class="bold">Universal RP</strong> settings, while<a id="_idIndexMarker1118" class="pcalibre1 pcalibre calibre6"/> referring to <em class="italic">Figure 11</em><em class="italic">.11</em>, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Settings</code> folder, select the <strong class="bold">URP-HighFidelity-Renderer</strong> asset (<em class="italic">A</em> in <em class="italic">Figure 11</em><em class="italic">.11</em>). Note that this is the default setting unless you’ve changed the default <strong class="bold">Quality</strong> value in the <strong class="bold">Project </strong><strong class="bold">Settings</strong> area.</li>
<li class="calibre15">Click the <strong class="bold">Add Renderer Feature</strong> button (<em class="italic">B</em> in <em class="italic">Figure 11</em><em class="italic">.11</em>) in the <strong class="bold">Inspector</strong> area, then select <strong class="bold">Decal</strong> from the list:</li>
</ol>
<div><div><img alt="Figure 11.11 – Enabling Decal for Universal RP" src="img/B18347_11_11.jpg" class="calibre134"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Enabling Decal for Universal RP</p>
<p class="calibre3">Now, we need some decal textures to use for our Decals!</p>
<h3 class="calibre10">Decal textures</h3>
<p class="calibre3">First, we’ll need to<a id="_idIndexMarker1119" class="pcalibre1 pcalibre calibre6"/> get some detailed textures into our environment via textures files. I’ve already sourced some royalty-free textures we can use in our project. Download the <code>cgtrader_2048986_Damage.zip</code> file from this chapter’s GitHub repository at <a href="https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets" class="pcalibre1 pcalibre calibre6">https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets</a>.</p>
<p class="callout-heading">Free decal textures | cgtrader</p>
<p class="callout">The decal textures we’re <a id="_idIndexMarker1120" class="pcalibre1 pcalibre calibre6"/>using in the project are from the <em class="italic">Decals Damage 48 Texture</em> files (royalty-free license) at cgtrader, available at <a href="https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture" class="pcalibre1 pcalibre calibre6">https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture</a>.</p>
<p class="calibre3">Unzip the file and import the images to a new <code>Assets/Textures/Decals</code> folder. While you’re creating folders, go ahead and create a new <code>Assets/Materials/Decals</code> folder too, since we’ll need that for creating decal materials in the next step.</p>
<h3 class="calibre10">Creating decal materials</h3>
<p class="calibre3">The Decal feature<a id="_idIndexMarker1121" class="pcalibre1 pcalibre calibre6"/> is based on materials that are assigned to a <code>Shader </code><code>Graphs/Decal</code> shader.</p>
<p class="calibre3">Let’s create our first Decal material by following these steps:</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Materials/Decals</code> folder in the <strong class="bold">Project</strong> window, create a new <strong class="bold">Material</strong> (by going to <strong class="bold">Create</strong> | <strong class="bold">Material</strong>).</li>
<li class="calibre15">Name the new material with the same name as the damage texture we’ll be using; for this first example, we’ll use <code>DecalsDamage0032_1_S</code>.</li>
<li class="calibre15">With the new material selected, in the <code>Shader Graphs/Decal</code> shader from the <strong class="bold">Shader</strong> drop-down list at the top.</li>
<li class="calibre15">From the <code>Assets/Textures/Decals</code> folder, drag the <code>DecalsDamage0032_1_S</code> image to the <strong class="bold">Base </strong><strong class="bold">Map</strong> field.<p class="calibre3">Note that if we have a Normal Map image included with our damaged textures, then assign that to the <strong class="bold">Normal Map</strong> field (I suggest using normal maps for greater detail in your Decals; we just don’t, however, have one included in the provided textures).</p></li>
</ol>
<p class="calibre3">With that, our first damage Decal material is ready to go! We’re almost ready to start applying damage<a id="_idIndexMarker1122" class="pcalibre1 pcalibre calibre6"/> to our environment with the Decal projector component.</p>
<h3 class="calibre10">Rendering Layers for Decals</h3>
<p class="calibre3">Decals are <a id="_idIndexMarker1123" class="pcalibre1 pcalibre calibre6"/>projectors! Due to the nature of a projection in the<a id="_idIndexMarker1124" class="pcalibre1 pcalibre calibre6"/> scene, some objects may pass between the projector and the target mesh(es) and get hit by the projection, producing an undesirable result. So, although we can take a more freeform approach to the art direction here – since we aren’t limited to where we can place Decals in the environment – we may still have to control how Decals are projected and protect some objects from receiving the decal texture. Fortunately, using <strong class="bold">Rendering Layers</strong>, we can limit what meshes the decal affects.</p>
<p class="callout-heading">New to Unity 2022</p>
<p class="callout">Rendering Layers | How to use Rendering Layers with Decals: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals</a>.</p>
<p class="calibre3">For example, we will want to have our Decals affect the walls but not the objects we’ve scattered throughout the environment from our painting with Polybrush! Let’s ensure we have Rendering Layers for Decals enabled now. So, let’s revisit the <strong class="bold">URP-HighFidelity-Renderer</strong> asset (refer to <em class="italic">Figure 11</em><em class="italic">.11</em>) and enable <strong class="bold">Use Rendering Layers</strong> (it’s turned off by default):</p>
<div><div><img alt="Figure 11.12 – Use Rendering Layers enabled" src="img/B18347_11_12.jpg" class="calibre135"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Use Rendering Layers enabled</p>
<p class="calibre3">The next requirement for a functional Decals <strong class="bold">Rendering Layers</strong> setup is to ensure a layer is specified<a id="_idIndexMarker1125" class="pcalibre1 pcalibre calibre6"/> for <a id="_idIndexMarker1126" class="pcalibre1 pcalibre calibre6"/>our Decals case. We can do that by editing the <strong class="bold">Rendering Layers (3D)</strong> list of layers:</p>
<ol class="calibre14">
<li class="calibre15">Select the <code>Assets/</code> folder.</li>
<li class="calibre15">As shown in <em class="italic">Figure 11</em><em class="italic">.13</em>, we’ll create our Decal layer by renaming the <code>Receive Decals</code>:</li>
</ol>
<div><div><img alt="Figure 11.13 – Decal Rendering Layers" src="img/B18347_11_13.jpg" class="calibre136"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Decal Rendering Layers</p>
<p class="calibre3">Now that we have an assignable layer, we’ll go back and modify all of the Prefabs we want to be able to receive decal projections on – ensuring that only objects that have the <em class="italic">Receive Decals</em> layer selected will show our damage textures. Working with the setup is straightforward – that is, once you wrap your head around the layers being the glue that binds all the parts together.</p>
<p class="calibre3">As shown in <em class="italic">Figure 11</em><em class="italic">.14</em>, we’ll modify the <code>Wall_02 Variant</code> Prefab (in <code>Assets/Polypix 3D Assets/Modular Kit/Prefabs</code> folder so that it includes the <em class="italic">Receive Decals</em> layer in the <code>Mesh </code><code>Renderer</code> component:</p>
<div><div><img alt="Figure 11.14 – Assigning a decal rendering layer to Prefabs" src="img/B18347_11_14.jpg" class="calibre137"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Assigning a decal rendering layer to Prefabs</p>
<p class="calibre3">You’ll want to update all the Prefabs you intend to project Decals onto with the <em class="italic">Receive Decals</em> layer. If your Decals aren’t showing where you believe they should be, you’ll want to double-check the layer assignments (and, of course, that Decals are enabled in<a id="_idIndexMarker1127" class="pcalibre1 pcalibre calibre6"/> the<a id="_idIndexMarker1128" class="pcalibre1 pcalibre calibre6"/> renderer settings).</p>
<p class="calibre3">Now, we can create our first <strong class="bold">Decal Projector</strong> in the scene and start fleshing out the environment’s story. Yay!</p>
<h3 class="calibre10">Using the Decal Projector component</h3>
<p class="calibre3">To add a Decal, you <a id="_idIndexMarker1129" class="pcalibre1 pcalibre calibre6"/>can either create a new <code>Decal Projector</code> GameObject or add a <code>Decal Projector</code> component to an existing object in the scene. Since we don’t have any objects in the scene that are appropriate for adding a <code>Decal Projector</code> component, we’ll create a new one: in the <strong class="bold">Hierarchy</strong> window, go to <strong class="bold">Create</strong> | <strong class="bold">Rendering</strong> | <strong class="bold">URP </strong><strong class="bold">Decal Projector</strong>.</p>
<p class="calibre3">As shown in <em class="italic">Figure 11</em><em class="italic">.15</em>, we must assign the Decal material we previously made for the <code>DecalsDamage0032_1_S</code> texture to the <strong class="bold">Material</strong> field and select the <em class="italic">Receive Decals</em> layer in the <strong class="bold">Rendering </strong><strong class="bold">Layers</strong> field:</p>
<div><div><img alt="Figure 11.15 – Decal projected onto the wall Prefab" src="img/B18347_11_15.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Decal projected onto the wall Prefab</p>
<p class="calibre3">As shown in <em class="italic">Figure 11</em><em class="italic">.15</em>, I’ve positioned and rotated the <strong class="bold">Decal Projector</strong> <em class="italic">cube gizmo</em> (which shows its bounds) using the <strong class="bold">Transform</strong> tool. The base of the gizmo has a thicker line, and the projection direction is indicated by the white arrow emanating from the pivot point anchor (on the Z-axis).</p>
<p class="calibre3">You can get away with using the <strong class="bold">Transform</strong> tool for the initial positioning and rotation of the projection. Still, you’ll likely want to use the <strong class="bold">Scene</strong> view editing tools to fine-tune the decal further – this requires further exploration and experimentation on your part, so I recommend additional reading.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Decal Projector component: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component</a>.</p>
<p class="calibre3">Continue to decorate – ah – design the level environment further and add <em class="italic">surface story</em> details to sell your environment to the player by utilizing the varying damage textures we have at our disposal. Again, playtesting and feedback are essential here to help guide the art direction.</p>
<p class="calibre3">As you start <a id="_idIndexMarker1130" class="pcalibre1 pcalibre calibre6"/>projecting textures everywhere, you may be thinking, what is this doing to my game’s performance?</p>
<h3 class="calibre10">Decal performance</h3>
<p class="calibre3">Well, Unity has<a id="_idIndexMarker1131" class="pcalibre1 pcalibre calibre6"/> got us covered for performance optimization too. If we ensure that the Decals in the scene with the same damage texture use the same <em class="italic">Material</em>, and if we turn on <strong class="bold">Enable GPU Instancing</strong> for the <em class="italic">Material</em>, Unity will use a technique <a id="_idIndexMarker1132" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">instancing</strong> to make rendering more efficient. Instancing on the GPU can minimize the work Unity has to do by reducing the number of draw calls (which is like drawing all the Decals at once instead of each decal individually).</p>
<p class="calibre3">Furthermore, to reduce the different number of materials we need for Decals (because, again, each <em class="italic">Material</em> is grouped to draw at once), we can put many damage texture images into one larger image (that is, a texture atlas). Then, the <strong class="bold">Decal Projector</strong> component allows us to <a id="_idIndexMarker1133" class="pcalibre1 pcalibre calibre6"/>use <strong class="bold">UV offset</strong> properties to select which part of the texture atlas we want to show – our selected individual texture image. This way, we can manage all the decal images more efficiently and keep our games running smoothly.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Decal Renderer Feature | Performance: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance</a>.</p>
<p class="calibre3">In this section, we learned how to polish our 3D environment by replacing graybox Prefabs with finished art assets using Unity’s new Prefab workflow and manually updating Prefabs with new graphics while maintaining their existing behavior in Prefab Mode. We continued by polishing the environment design by painting scattered objects with Polybrush and <a id="_idIndexMarker1134" class="pcalibre1 pcalibre calibre6"/>immersing the player in <em class="italic">surface story</em> by adding Decal textures.</p>
<p class="calibre3">In the next section, we’ll continue to add polish to the habitat’s interior environment with lighting.</p>
<h1 id="_idParaDest-212" class="calibre5"><a id="_idTextAnchor223" class="pcalibre1 pcalibre calibre6"/>Lighting design – Probes, Decals, light baking, and performance</h1>
<p class="calibre3">Let me immediately<a id="_idIndexMarker1135" class="pcalibre1 pcalibre calibre6"/> set some expectations for this section – we won’t spend much time on lighting design. It’s a subject worthy of an entire book all on its own. So, what we will be covering are some basics any game developer should be familiar with when working with lighting 3D scenes in Unity.</p>
<p class="calibre3">The first thing I would like to address is that Unity has released a new rendering path for <strong class="bold">Universal RP</strong> (<strong class="bold">URP</strong>) with <a id="_idIndexMarker1136" class="pcalibre1 pcalibre calibre6"/>the 2022.3 LTS version<a id="_idIndexMarker1137" class="pcalibre1 pcalibre calibre6"/> called <strong class="bold">Forward+ Rending</strong>.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Forward+ Rendering Path: <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml</a>.</p>
<p class="calibre3">The <strong class="bold">Forward+ Rendering Path</strong> (Forward+) gives <a id="_idIndexMarker1138" class="pcalibre1 pcalibre calibre6"/>several advantages over the previous <strong class="bold">Forward Rendering Path</strong> (Forward), but it primarily overcomes the per-object limit on the number of lights that can affect GameObjects in the scene (note that the per-camera limitation does still apply). Let’s see how we can update our project URP settings to use <strong class="bold">Forward+</strong>.</p>
<h2 id="_idParaDest-213" class="calibre8"><a id="_idTextAnchor224" class="pcalibre1 pcalibre calibre6"/>Setting the URP Forward+ Rendering Path</h2>
<p class="calibre3">Now, let’s change our <a id="_idIndexMarker1139" class="pcalibre1 pcalibre calibre6"/>URP <strong class="bold">Rendering Path</strong> setting to use the <strong class="bold">Forward+ Rendering Path</strong>. We can do that in the <strong class="bold">Universal RP settings</strong> area (the same asset we added to the <strong class="bold">Decal</strong> feature in <em class="italic">Figure 11</em><em class="italic">.11</em>):</p>
<ol class="calibre14">
<li class="calibre15">In the <code>Assets/Settings</code> folder, select the <strong class="bold">URP-HighFidelity-Renderer</strong> asset.</li>
<li class="calibre15">Under the <strong class="bold">Rendering</strong> section, select <strong class="bold">Forward+</strong> in the <strong class="bold">Rendering </strong><strong class="bold">Path</strong> dropdown:</li>
</ol>
<div><div><img alt="Figure 11.16 – Setting the Forward+ Rendering Path" src="img/B18347_11_16.jpg" class="calibre138"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Setting the Forward+ Rendering Path</p>
<p class="calibre3">As with most <a id="_idIndexMarker1140" class="pcalibre1 pcalibre calibre6"/>decisions about the tech stack that you’ll be making for your Unity projects, you’ll have to experiment and test to see what fits best for the project’s direction or target platform (mobile, we’re looking at you), and the renderer pipeline choice is no exception. It’s pretty important. So, we will be changing this project to the <strong class="bold">Forward+ Rendering Path</strong> now. Just know that we may end up reverting this decision in the future should we need to change our lighting approach (for example, from real time to baked lighting; more on this in the <em class="italic">Bake that </em><em class="italic">lighting?</em> section).</p>
<p class="calibre3">The consensus with performance – concerning <strong class="bold">Forward+</strong> over <strong class="bold">Forward</strong> – is that gains are realized with greater than six real-time lights due to the overhead <strong class="bold">Forward+</strong> introduces when clustering lights (<strong class="bold">Forward+</strong> gathers light data into clusters computed in the fragment shader rather than individual light data). That’s excellent news for lighting designers because <strong class="bold">Forward+ Rendering</strong> gives us precisely what we may need – more real-time lights in a scene!</p>
<p class="calibre3">Speaking of lights, we<a id="_idIndexMarker1141" class="pcalibre1 pcalibre calibre6"/> can get away with adding lighting effects to our scenes, and not touch a single light – this is accomplished with proxy lighting.</p>
<h2 id="_idParaDest-214" class="calibre8"><a id="_idTextAnchor225" class="pcalibre1 pcalibre calibre6"/>Proxy lighting with Decals (yes, Decals)</h2>
<p class="calibre3">Decals here<a id="_idIndexMarker1142" class="pcalibre1 pcalibre calibre6"/> refer to <em class="italic">lighting decals</em> (that is, proxy lighting) and <a id="_idIndexMarker1143" class="pcalibre1 pcalibre calibre6"/>not <em class="italic">texture decals</em>, which we’re already familiar with. To accomplish this effect, <strong class="bold">Decal Projector</strong> uses a special shader to modify the emissive color of affected surfaces without any real-time lights being involved.</p>
<p class="calibre3">The <em class="italic">Material</em> we’ll be using for the proxy lighting <strong class="bold">Decal Projector</strong> in our scene is based on a <strong class="bold">Shader Graph</strong> shader, <strong class="bold">Spotlight</strong>, that comes from the <strong class="bold">Universal </strong><strong class="bold">RP</strong> samples.</p>
<p class="callout-heading">Additional reading | Unity Blog</p>
<p class="callout">You can explore the latest package samples for the Universal Render Pipeline here: <a href="https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline" class="pcalibre1 pcalibre calibre6">https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline</a>.</p>
<p class="callout">These are not just for <strong class="bold">Universal RP</strong>! You should always check the Unity package content to see what samples are provided as examples that supplement the Unity documentation for learning the feature and can give a jump start on implementation.</p>
<p class="calibre3">To import the <strong class="bold">Universal RP</strong> samples, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Open <strong class="bold">Package Manager</strong> by going to <strong class="bold">Window</strong> | <strong class="bold">Package Manager</strong>.</li>
<li class="calibre15">Ensure you have <strong class="bold">In Project</strong> selected in the <strong class="bold">Packages</strong> dropdown.</li>
<li class="calibre15">Find and select <strong class="bold">Universal RP</strong> from the list (left-hand side).</li>
<li class="calibre15">On the right-hand side of the window, click the <strong class="bold">Samples</strong> tab.</li>
<li class="calibre15">For <code>Assets/Samples/Universal RP/14.x.x/URP Package </code><code>Samples</code> folder.</li>
</ol>
<p class="calibre3">Once the samples have been imported, find and open the <code>/URP Package </code><code>Samples/Decals/ProxyLighting</code> folder:</p>
<div><div><img alt="Figure 11.17 – Unity Universal RP ProxyLighting sample" src="img/B18347_11_17.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Unity Universal RP ProxyLighting sample</p>
<p class="calibre3">Now, go ahead and<a id="_idIndexMarker1144" class="pcalibre1 pcalibre calibre6"/> find the <code>Assets/Prefabs</code> folder. Name it <code>Decal Spotlight</code> so that we can use it as a <em class="italic">lighting Decal spotlight</em> in our habitat interior scene. It’s already pre-configured with the <strong class="bold">Spotlight</strong> material (and the default <strong class="bold">Rendering Layer</strong> so that it will affect any object in the scene), so we’re all set!</p>
<p class="calibre3">Now, go back to our interior habitat scene and place a <strong class="bold">Decal Spotlight</strong> material into a wall overhang (as pictured in <em class="italic">Figure 11</em><em class="italic">.18</em>), adjust the <strong class="bold">Decal Projector</strong> component’s <strong class="bold">Opacity</strong> setting (refer to <em class="italic">Figure 11</em><em class="italic">.17</em>) to a lovely lighting value, then duplicate it several times (three times in this example; four in total). Don’t worry that they’re all sitting on top of each other at the moment.</p>
<p class="calibre3">We could manually place the spotlights further along the wall, or, to make things easier on ourselves, we can use a bit of math in the <code>cos(a)</code> and <code>sin(a)</code> too!</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Editing Properties | Numeric field expressions: <a href="https://docs.unity3d.com/Manual/EditingValueProperties.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/EditingValueProperties.xhtml</a>.</p>
<p class="calibre3">Select all the spotlights we just added to the <code>L(-5.4,-17.3)</code> in the <code>L(a,b)</code> is a linear ramp expression where the selected objects are distributed between the values.</p>
<p class="calibre3">While you have the expression in the field, you can play around with the values until you have the spotlights<a id="_idIndexMarker1146" class="pcalibre1 pcalibre calibre6"/> positioned where you want (your values may <a id="_idIndexMarker1147" class="pcalibre1 pcalibre calibre6"/>differ from mine based on your wall position and so on).</p>
<p class="calibre3">You should end up with something like this:</p>
<div><div><img alt="Figure 11.18 – Decal spotlights array on the wall" src="img/B18347_11_18.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Decal spotlights array on the wall</p>
<p class="calibre3">Pretty cool, right? And remember, no real-time lights are involved! We can save on lighting resources while still enjoying additional lighting effects in our environment design. Just note that <strong class="bold">Decal Material</strong> performance considerations are still applicable.</p>
<p class="calibre3">Speaking of <a id="_idIndexMarker1148" class="pcalibre1 pcalibre calibre6"/>performance, we have another approach to lighting that<a id="_idIndexMarker1149" class="pcalibre1 pcalibre calibre6"/> we can consider besides the use of real-time lighting, and that’s baked lighting.</p>
<h2 id="_idParaDest-215" class="calibre8"><a id="_idTextAnchor226" class="pcalibre1 pcalibre calibre6"/>Bake that lighting?</h2>
<p class="calibre3">350° F (175° C) for 45 minutes… sure!</p>
<p class="calibre3">Using baked<a id="_idIndexMarker1150" class="pcalibre1 pcalibre calibre6"/> lighting in Unity can have several benefits over real-time lighting in your game, but deciding to use one or the other depends greatly on the target platform and the target framerate you’ve determined the game needs to hit on specific hardware specs (you may have already been introduced to this type of information related to games you’d like to play on your PC or mobile device – system requirements: minimum and recommended).</p>
<p class="calibre3">Let’s look at the three main benefits of baked lighting:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Performance</strong>: Baking the <a id="_idIndexMarker1151" class="pcalibre1 pcalibre calibre6"/>lighting means all of the light interactions in the scene regarding objects’ surfaces are computed ahead of time (in the editor) and saved into lightmap textures files. During runtime, the lightmaps are used to determine the light that’s received by the objects’ surfaces in the scene, which is much faster than real-time calculations.</li>
<li class="calibre15"><strong class="bold">Quality</strong>: Baked lighting usually produces better lighting fidelity, especially when it comes to indirect bounced light, soft shadows, and more complex light diffusion effects.</li>
<li class="calibre15"><strong class="bold">Lighting complexity</strong>: Baked lighting can handle higher levels of lighting complexity with lots of lights and complex shadow interactions (just be prepared for longer bake times!).</li>
</ul>
<p class="calibre3">Now, let’s consider some disadvantages of baked lighting:</p>
<ul class="calibre17">
<li class="calibre15"><strong class="bold">Lightmaps</strong>: The size <a id="_idIndexMarker1152" class="pcalibre1 pcalibre calibre6"/>of the generated lightmap texture files can be of concern for both memory usage at runtime and the size of the game on disk (that is, mobile and lower-end platforms). Optimizing lightmaps is generally a balancing act between performance and quality (which, of course, takes time; see <em class="italic">Long </em><em class="italic">iteration time</em>).</li>
<li class="calibre15"><strong class="bold">Static</strong>: The baked lightmaps only work for objects that don’t move in the scene (that is, static objects; they are assigned as such in the <strong class="bold">Inspector</strong> area). Dynamic lights and moving objects are more suitable for real-time lighting. Unity does, however, provide a solution for dynamic objects with baked lighting via <strong class="bold">Light Probes</strong>, but they come with their own limitations (such as area lights and volumetric lighting not being supported, not working well with some materials, and no real-time reflections), so often, a combination of techniques applied with real-time direct lighting and shadow casting is necessary to obtain the desired results.</li>
<li class="calibre15"><strong class="bold">Additional work</strong>: Additional work must be done in the form of setting objects as static, setting<a id="_idIndexMarker1153" class="pcalibre1 pcalibre calibre6"/> up <strong class="bold">Light Probes</strong> for dynamic objects in the scene, a solution for basic shadow needs, and balancing the generated lightmap quality, for starters.</li>
<li class="calibre15"><strong class="bold">Long iteration time</strong>: The process of baking lightmaps can be resource-intensive and, therefore, time-consuming on lower-end development system CPU/GPU hardware, which <a id="_idIndexMarker1154" class="pcalibre1 pcalibre calibre6"/>can cause a significant slowdown in the environment design iteration process.</li>
</ul>
<p class="calibre3">There’s no doubt that lighting an environment with real-time lighting is more accessible. Still, you may not have a choice if you’re going to target mobile or lower-end hardware specs (for example, the Nintendo Switch). Baked lighting is generally more performant across devices and platforms compared to real-time lighting.</p>
<p class="calibre3">Our approach so<a id="_idIndexMarker1155" class="pcalibre1 pcalibre calibre6"/> far has been to use the default lighting setup with the <strong class="bold">Directional Light</strong> property provided by the <strong class="bold">Standard (URP) Scene Template</strong> and <a id="_idIndexMarker1156" class="pcalibre1 pcalibre calibre6"/>create additional lights in the scene – which are <em class="italic">Realtime</em> by default. Now, we must change our approach because we will target a lower-end platform but still want to target 60 FPS. So, we’re going to need baked lighting.</p>
<h3 class="calibre10">Setting up baked lighting</h3>
<p class="calibre3">To set up our baked lighting, let’s <a id="_idIndexMarker1157" class="pcalibre1 pcalibre calibre6"/>duplicate our current habitat interior scene with real-time lighting so that we can non-destructively experiment with converting it into baked lighting.</p>
<p class="calibre3">Select your <code>Assets/Scenes</code> folder in the <strong class="bold">Project</strong> window, press <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em> to duplicate, and rename it with a (<em class="italic">baked</em>) suffix. Let’s open the duplicate scene and start the setup:</p>
<ol class="calibre14">
<li class="calibre15">Select <code>Light</code> component’s <strong class="bold">General</strong> section, select <strong class="bold">Baked</strong> in the <strong class="bold">Mode</strong> field dropdown instead of <strong class="bold">Realtime</strong>.<p class="calibre3">Please do the same for any additional lights you may have added to the scene that we want Unity to include in the baking. Note that we won’t have to change the <strong class="bold">Decal</strong> spotlights we added in the <em class="italic">Proxy lighting with Decals (yes, Decals)</em> section – remember, these are not lights!</p></li>
<li class="calibre15">We need to let Unity know what objects won’t move so that their lighting can be baked. So, for all of the modular Prefabs that make up the walls, the floors, the doorway, and scattered Prefab objects in the scene, select them in the <strong class="bold">Hierarchy</strong> area. Then, in the <strong class="bold">Inspector</strong> area, enable <strong class="bold">Static</strong> (the top right of the window):</li>
</ol>
<div><div><img alt="Figure 11.19 – Marking a GameObject as static" src="img/B18347_11_19.jpg" class="calibre139"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.19 – Marking a GameObject as static</p>
<ol class="calibre14">
<li value="3" class="calibre15">When you’re asked whether you want to mark the child objects as static too, click the <strong class="bold">Yes, change </strong><strong class="bold">children</strong> button.</li>
</ol>
<p class="calibre3">Now that the objects in <a id="_idIndexMarker1158" class="pcalibre1 pcalibre calibre6"/>the scene have been set up, we will configure <strong class="bold">Lightmapping Settings</strong> just before baking.</p>
<h3 class="calibre10">Lighting settings</h3>
<p class="calibre3"><strong class="bold">Lightmapping Settings</strong> configure <a id="_idIndexMarker1159" class="pcalibre1 pcalibre calibre6"/>the light baking calculation and how it applies to the scene. We need to use the <strong class="bold">Lighting</strong> window to create a new <strong class="bold">Lighting Settings Asset</strong> to store our configuration. Unity will use default read-only light settings to bake the scene lighting until we create an asset.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">The Lighting window: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml</a>.</p>
<p class="calibre3">To create a new <strong class="bold">Lighting Settings Asset</strong>, follow these steps:</p>
<ol class="calibre14">
<li class="calibre15">Open the <strong class="bold">Lighting</strong> window by going to <strong class="bold">Window</strong> | <strong class="bold">Rendering</strong> | <strong class="bold">Lighting</strong>.</li>
<li class="calibre15">At the top of the <strong class="bold">Lighting</strong> window, under the <strong class="bold">Lighting Settings</strong> section, click the <strong class="bold">New</strong> button to the right of the <strong class="bold">Lighting Settings Asset</strong> field to create a new <strong class="bold">Lighting Settings Asset</strong> in the <strong class="bold">Project</strong> window; it will be assigned immediately:</li>
</ol>
<div><div><img alt="Figure 11.20 – New Lighting Settings Asset" src="img/B18347_11_20.jpg" class="calibre140"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.20 – New Lighting Settings Asset</p>
<ol class="calibre14">
<li value="3" class="calibre15">Name the<a id="_idIndexMarker1160" class="pcalibre1 pcalibre calibre6"/> asset the same as the scene name so that it’s easy to keep track of – for reference, in <a href="B18347_10.xhtml#_idTextAnchor187" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, we created a new scene named <code>Habitat Interior 1</code>; but use the current scene name you’re using here.</li>
</ol>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Lighting Settings Asset: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml</a>.</p>
<p class="calibre3">We’ll work in the <strong class="bold">Scene</strong> tab to optimize our settings for the desired balance of quality, lightmap texture size, and bake time. Using the default values is a good starting baseline for your baking.</p>
<p class="calibre3">Okay, click that <strong class="bold">Bake</strong> button! Sadly, no. The actual button to click for baking the lighting is the <strong class="bold">Generate Lighting</strong> button, located at the bottom of the <strong class="bold">Lighting</strong> window. When started, the lighting process will display a progress indicator at the bottom right of the <strong class="bold">Editor</strong> window with an estimated time for completion.</p>
<p class="calibre3">After some time – depending on the power of your system hardware – the generated lighting process will finish, and the <strong class="bold">Scene</strong> view will update with the new baked lighting. Inspect the result of the baked lighting in your scene, and, if it’s not to your satisfaction, adjust <strong class="bold">Lightmapping Settings</strong> and/or both the settings and position or rotation of light sources in the scene and bake again; repeat as needed.</p>
<p class="calibre3">Let’s have a gander at the results of our labor by comparing screenshots of the same view with baked and<a id="_idIndexMarker1161" class="pcalibre1 pcalibre calibre6"/> real-time lighting:</p>
<div><div><img alt="Figure 11.21 – Baked versus Realtime renders" src="img/B18347_11_21.jpg" class="calibre141"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.21 – Baked versus Realtime renders</p>
<p class="callout-heading">Tip</p>
<p class="callout">You’ll also want to compare the results of the baked lighting to the real-time lighting. Analyze the quality of the light, the lighting features, memory usage, and, most importantly, the FPS the game is running at compared to your target framerate on the desired platform(s).</p>
<p class="callout">You can get some performance gauge while running in <strong class="bold">Play</strong> mode in <strong class="bold">Unity Editor</strong>, but you’ll want to build and test on the target device(s) for the best results. Graphy – Ultimate Stats Monitor &amp; Debugger (<a href="https://github.com/Tayx94/graphy" class="pcalibre1 pcalibre calibre6">https://github.com/Tayx94/graphy</a>) is a free tool that is greatly helpful in analyzing your game’s performance. Output from Graphy can be seen in the game screenshots in the top-right corner in <em class="italic">Figure 11</em><em class="italic">.21</em>, where the baked lighting shows a slight FPS benefit over real time (this is in the <strong class="bold">Editor</strong> window, so I expect greater gains in a build).</p>
<p class="calibre3">You may not be happy at all with how long the baked lighting generation took with the default <strong class="bold">Lightmapper</strong> setting <a id="_idIndexMarker1162" class="pcalibre1 pcalibre calibre6"/>set to <strong class="bold">Progressive CPU</strong>. Fortunately, if your hardware supports it, we can improve the calculation time using the GPU-based lightmapper.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you notice graphical artifacts appearing on models in your baked lighting, then imported model UVs for baked lightmaps may not be provided. In that case, you can tell Unity to generate them automatically to fix their appearance.</p>
<p class="callout">To have Unity generate lightmap UVs, select the offending model in the <strong class="bold">Project</strong> window to view <strong class="bold">Model Import Settings</strong> in the <strong class="bold">Inspector</strong> area. Once you’ve done this, ensure the <strong class="bold">Model</strong> tab is selected, and then, in the <strong class="bold">Geometry</strong> section, <em class="italic">enable</em> the <strong class="bold">Generate Lightmap </strong><strong class="bold">UVs</strong> option.</p>
<p class="callout">Unity Documentation | Generating lightmap UVs: <a href="https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml</a>.</p>
<p class="calibre3">Now, about that iteration time.</p>
<h3 class="calibre10">Improving iteration time</h3>
<p class="calibre3"><strong class="bold">Lightmapping Settings</strong> allows us<a id="_idIndexMarker1163" class="pcalibre1 pcalibre calibre6"/> to choose between<a id="_idIndexMarker1164" class="pcalibre1 pcalibre calibre6"/> the <strong class="bold">Progressive CPU</strong> and <strong class="bold">Progressive GPU</strong> lightmappers (the <a id="_idIndexMarker1165" class="pcalibre1 pcalibre calibre6"/>latter still being in preview for 2022.3.1f1). <strong class="bold">Progressive GPU</strong> may be much, much, quicker to generate lighting, but it all depends on what GPU (that is, what graphics card) you have installed in your system running Unity. In my example, <strong class="bold">Progressive CPU</strong> is estimated to take 3+ hours, whereas <strong class="bold">Progressive GPU</strong> (on modest GPU hardware) is estimated to take 40+ minutes.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">The Progressive Lightmapper: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml</a>.</p>
<p class="calibre3">Now that we’ve covered baked lighting for static objects in the scene (that is, objects we marked as <em class="italic">Static</em> because they don’t move), we just need to cover a bit about how dynamic or moving objects in the scene can be affected by light when there is no real-time lighting!</p>
<h2 id="_idParaDest-216" class="calibre8"><a id="_idTextAnchor227" class="pcalibre1 pcalibre calibre6"/>Light Probes</h2>
<p class="calibre3">Again, Unity has us <a id="_idIndexMarker1166" class="pcalibre1 pcalibre calibre6"/>covered for dynamic object lighting. We can use <strong class="bold">Light Probes</strong> to apply our baked lighting to moving objects – as mentioned previously; however, this is additional work compared to real-time lighting (as indicated in the <em class="italic">Additional work</em> bullet point in the <em class="italic">Bake that lighting?</em> section). Note that light probes will not affect the objects we marked as <strong class="bold">Static</strong> – moving objects should never be marked <strong class="bold">Static</strong>.</p>
<p class="calibre3"><strong class="bold">Light Probes</strong> are placed throughout the environment, not only where the moving objects will be but also in areas where lighting changes (especially dramatic changes). The light probes we put in the scene will capture the light information when baking and then use that data to light the moving objects based on their relative position to the probes.</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Light Probes: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml</a>.</p>
<p class="calibre3">Let’s place our<a id="_idIndexMarker1167" class="pcalibre1 pcalibre calibre6"/> first <strong class="bold">Light Probe Group</strong> in our scene by going to <strong class="bold">Create</strong> | <strong class="bold">Light</strong> | <strong class="bold">Light Probe Group</strong>. Then, using the <strong class="bold">Transform</strong> tool, move the new <strong class="bold">Group</strong> to the center of a room in the level. Light changes occur primarily along the walls in these rooms since the lighting is pretty uniform, so we’ll spread out the probes to cover a wider area.</p>
<p class="calibre3">In <em class="italic">Figure 11</em><em class="italic">.22</em>, you can see that I first used the toggle pickability feature (<em class="italic">A</em> in <em class="italic">Figure 11</em><em class="italic">.22</em>) in the <strong class="bold">Hierarchy</strong> area to turn off the selection of the wall, floor, and ceiling so that we can work with the probes and not accidentally select anything else in the scene (that would be not very pleasant, after all).</p>
<p class="calibre3">You can now enable <strong class="bold">Light Probe Editing</strong> (<em class="italic">B</em> in <em class="italic">Figure 11</em><em class="italic">.22</em>) and drag a selection window (<em class="italic">C</em> in <em class="italic">Figure 11</em><em class="italic">.22</em>) in the <strong class="bold">Scene</strong> view to select the probes on the right-hand side of the group. Use the <strong class="bold">Duplicate Selected</strong> button – or the tried-and-true <em class="italic">Ctrl</em>/<em class="italic">Cmd</em> + <em class="italic">D</em> shortcut – to duplicate the selected probes, then use the <strong class="bold">transform move</strong> tool to position<a id="_idIndexMarker1168" class="pcalibre1 pcalibre calibre6"/> the duplicated probes near the wall:</p>
<div><div><img alt="Figure 11.22 – Editing Light Probes in the scene" src="img/B18347_11_22.jpg" class="calibre39"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.22 – Editing Light Probes in the scene</p>
<p class="callout-heading">Additional reading | Unity documentation</p>
<p class="callout">Pick and select GameObjects: <a href="https://docs.unity3d.com/Manual/ScenePicking.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/ScenePicking.xhtml</a>.</p>
<p class="callout">Scene visibility: <a href="https://docs.unity3d.com/Manual/SceneVisibility.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/Manual/SceneVisibility.xhtml</a>.</p>
<p class="calibre3">Repeat the process of selecting, duplicating, and positioning probes until you have something similar to <a id="_idIndexMarker1169" class="pcalibre1 pcalibre calibre6"/>the probe group setup shown in <em class="italic">Figure 11</em><em class="italic">.23</em>:</p>
<div><div><img alt="Figure 11.23 – Light Probes placement example" src="img/B18347_11_23.jpg" class="calibre129"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.23 – Light Probes placement example</p>
<p class="callout-heading">Tip</p>
<p class="callout">Remember, in <em class="italic">Figure 11</em><em class="italic">.23</em>, as uniform as the probes grouping looks in this scene, you won’t always have it set up this way because you’ll want to position probes where the light changes (again, especially where the light changes dramatically) for the best results.</p>
<p class="calibre3">Once you have the <strong class="bold">Light Probe Groups</strong> set up in your level, you’ll have to bake (err, generate) the lighting <a id="_idIndexMarker1170" class="pcalibre1 pcalibre calibre6"/>again so that the probes have all the lighting information stored. The probe lighting data will then be used at runtime to light dynamic objects.</p>
<p class="calibre3">You can visualize the effect light probes have on dynamic objects by using the <strong class="bold">Light Probe Visualization</strong> setting in the <strong class="bold">Lighting</strong> window. When you have a dynamic object selected in the scene, the probes that influence the object will be shown when set to <strong class="bold">Only Probes Used By Selection</strong>, with<a id="_idIndexMarker1171" class="pcalibre1 pcalibre calibre6"/> the selected <strong class="bold">Sphere</strong> (temporarily added to the scene for the sole purpose of visualizing the Light Probes), as shown in <em class="italic">Figure 11</em><em class="italic">.24</em>:</p>
<div><div><img alt="Figure 11.24 – Light Probes visualization selection" src="img/B18347_11_24.jpg" class="calibre142"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 11.24 – Light Probes visualization selection</p>
<p class="callout-heading">Tip</p>
<p class="callout">Unity has another useful lighting tool called <strong class="bold">Reflection Probes</strong>. Their use can significantly enhance the visual fidelity of scenes by contributing to the quality of both baked and real-time lighting – that is, these probes work with both static and dynamic objects.</p>
<p class="callout">As the name indicates, reflection probes add the effect of reflections of shiny things in the environment. I recommend <a id="_idIndexMarker1172" class="pcalibre1 pcalibre calibre6"/>exploring <strong class="bold">Reflection Probes</strong> further to enhance the quality of your game’s visuals!</p>
<p class="callout">Unity documentation | Reflection Probes: <a href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml" class="pcalibre1 pcalibre calibre6">https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml</a>.</p>
<p class="calibre3">There is one additional subject we need to cover regarding baked lighting, and that is shadows for dynamic objects. Baked shadows are a part of baked lighting for static objects – the shadows were baked into the lightmaps. Our lights in the scene were also set to <em class="italic">Baked</em>, so that doesn’t leave any means for providing shadows to our dynamic objects.</p>
<p class="calibre3">We can achieve a <a id="_idIndexMarker1173" class="pcalibre1 pcalibre calibre6"/>semi-dynamic shadow effect for baked lighting in a few different ways. We’ll cover two in the following section.</p>
<h2 id="_idParaDest-217" class="calibre8"><a id="_idTextAnchor228" class="pcalibre1 pcalibre calibre6"/>Baked lighting dynamic shadows</h2>
<p class="calibre3">The first thing we can <a id="_idIndexMarker1174" class="pcalibre1 pcalibre calibre6"/>do for dynamic object shadows is use <strong class="bold">Mixed</strong> mode for lights. <strong class="bold">Mixed</strong> mode will bake shadows (just like the <strong class="bold">Baked</strong> mode setting) for static objects <em class="italic">and</em> compute real-time shadows for dynamic objects (just like the <strong class="bold">Realtime</strong> mode setting).</p>
<p class="calibre3"><strong class="bold">Light Probes</strong> don’t solve this problem because they don’t represent any direct lighting and don’t produce shadows; they only influence the lighting applied to dynamic objects, so we’ll use them in combination with this mixed lighting mode technique.</p>
<p class="calibre3">So, to implement it, simply set <strong class="bold">Directional Light</strong> to <strong class="bold">Mixed</strong> mode and bake. Done.</p>
<p class="calibre3">The second thing we can do is fake it (yes, fake it – often, the game developer must resort to creative techniques that produce the desired results visually or close to it, but in clever and creative ways behind the scenes). No worries – Unity still has us covered.</p>
<h2 id="_idParaDest-218" class="calibre8"><a id="_idTextAnchor229" class="pcalibre1 pcalibre calibre6"/>Blob shadows</h2>
<p class="calibre3">A shadow projector can be used as a more optimized way to represent a simple <em class="italic">blob</em> <em class="italic">shadow</em> on the <a id="_idIndexMarker1175" class="pcalibre1 pcalibre calibre6"/>ground<a id="_idIndexMarker1176" class="pcalibre1 pcalibre calibre6"/> under objects. This technique benefits performance-constrained platforms (for example, mobile games and low-end hardware) where real-time shadow casting can be too performance-heavy.</p>
<p class="calibre3">To use a blob shadow projector, we don’t need to look further than <a id="_idIndexMarker1177" class="pcalibre1 pcalibre calibre6"/>the <code>Assets/Samples/Universal RP/14.0.8/URP Package </code><code>Samples/Decals/BlobShadow</code> folder.</p>
<p class="calibre3">With the scene open, find the <strong class="bold">Capsule</strong> object in the <strong class="bold">Hierarchy</strong> area. The <strong class="bold">BlobShadow</strong> child object contains the <strong class="bold">URP Decal Projector</strong> component (this should be familiar to you) with the provided <strong class="bold">BlobShadow_Mat</strong> material assigned.</p>
<p class="calibre3">Create a Prefab of it and use it for dynamic objects in your scene that require dynamic shadows in a baked lighting setup. It couldn’t be easier!</p>
<p class="calibre3">In this section, we learned how to light an interior environment scene with both real-time and baked lighting and weighed the visual differences and the performance tradeoffs between these approaches. We also learned some techniques to overcome lighting limitations.</p>
<p class="calibre3">With that and the knowledge and technique learned in this chapter, take the time to finish your level’s interior environment design to make it appear lived-in – immersive and engaging for <a id="_idIndexMarker1179" class="pcalibre1 pcalibre calibre6"/>the<a id="_idIndexMarker1180" class="pcalibre1 pcalibre calibre6"/> player. Tell a story. Iterate as necessary with feedback <a id="_idTextAnchor230" class="pcalibre1 pcalibre calibre6"/>from your playtesting group. Most importantly, just have fun!</p>
<h1 id="_idParaDest-219" class="calibre5"><a id="_idTextAnchor231" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we covered the process of transforming a grayboxed prototype environment by importing and replacing modular Prefabs with high-quality 3D model assets using Unity’s new 2022 Prefab workflow, preserved Prefabs with additional behavior using Prefab Mode, and applied new materials to finish up the level’s structural visuals.</p>
<p class="calibre3">We continued to decorate the environment by painting scattered Prefabs with <strong class="bold">Polybrush</strong>, strategically placing wear-and-tear <strong class="bold">Decal</strong> projectors for an additional layer of uniqueness and detail, and finalizing our artistic vision with technical implementations of both real-time and baked lighting setups, where we addressed additional considerations for lighting and shadows for dynamics objects while using baked lightmaps.</p>
<p class="calibre3">In the next chapter, we’re going to continue enhancing the player experience by adding some much-needed sound design (so far, audio is something we haven’t spent any time on). We’ll code <code>AudioManager</code> and create reusable <em class="italic">audio </em><em class="italic">player</em> components to make adding music, <strong class="bold">sound effects</strong> (<strong class="bold">SFX</strong>), and ambient sounds simple and straightforward (even for artists and designers).</p>
</div>
</div></body></html>