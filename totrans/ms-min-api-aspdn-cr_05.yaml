- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Logging to Identify Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will begin to learn about the logging tools that .NET provides
    us with. A logger is one of the tools that developers must use to debug an application
    or understand its failure in production. The log library has been built into ASP.NET
    with several features enabled by design. The purpose of this chapter is to delve
    into the things we take for granted and add more information as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The themes we will touch on in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring logging in .NET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging the logging framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing a structured log with Serilog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As reported in the previous chapters, it will be necessary to have the .NET
    6 development framework.
  prefs: []
  type: TYPE_NORMAL
- en: There are no special requirements in this chapter for beginning to test the
    examples described.
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring logging in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ASP.NET Core** templates create a **WebApplicationBuilder** and a **WebApplication**,
    which provide a simplified way to configure and run web applications without a
    startup class.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, with .NET 6, the `Startup.cs` file is eliminated in
    favor of the existing `Program.cs` file. All startup configurations are placed
    in this file, and in the case of **minimal APIs**, endpoint implementations are
    also placed.
  prefs: []
  type: TYPE_NORMAL
- en: What we have just described is the starting point of every .NET application
    and its various configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Logging into an application means tracking the evidence in different points
    of the code to check whether it is running as expected. The purpose of logging
    is to track over time all the conditions that led to an unexpected result or event
    in the application. Logging in an application can be useful both during development
    and while the application is in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for logging, as many as four providers are added for tracking application
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Console**: The Console provider logs output to the console. This log is unusable
    in production because the console of a web application is usually not visible.
    This kind of log is useful during development to make logging fast when you are
    running your app under Kestrel on your desktop machine in the app console window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Diagnostics.Debug` class. When we develop, we are used to seeing this
    section in the *Visual Studio* output window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under the Linux operating system, information is tracked depending on the distribution
    in the following locations: `/var/log/message` and `/var/log/syslog`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EventSource**: On Windows, this information can be viewed in the **EventTracing**
    window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventLog** (only when running on Windows): This information is displayed
    in the native Windows window, so you can only see it if you run the application
    on the Windows operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new feature in the latest .NET release
  prefs: []
  type: TYPE_NORMAL
- en: New logging providers have been added in the latest versions of .NET. However,
    these providers are not enabled within the framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these extensions to enable new logging scenarios: `AddSystemdConsole`,
    `AddJsonConsole`, and `AddSimpleConsole`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more details on how to configure the log and what the basic ASP.NET
    settings are at this link: [https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host](https://docs.microsoft.com/aspnet/core/fundamentals/host/generic-host).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve started to see what the framework gives us; now we need to understand
    how to leverage it within our applications. Before proceeding, we need to understand
    what a logging layer is. It is a fundamental concept that will help us break down
    information into different layers and enable them as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1 – Log levels ](img/B17902_Table1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 5.1 – Log levels
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 5.1* shows the most verbose levels down to the least verbose level.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more, you can read the article titled *Logging in .NET Core and ASP.NET
    Core*, which explains the logging process in detail here: [https://docs.microsoft.com/aspnet/core/fundamentals/logging](https://docs.microsoft.com/aspnet/core/fundamentals/logging/)/.'
  prefs: []
  type: TYPE_NORMAL
- en: If we select our log level as `Information`, everything at this level will be
    tracked down to the `Critical` level, skipping `Debug` and `Trace`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to take advantage of the log layers; now, let’s move on to writing
    a single statement that will log information and can allow us to insert valuable
    content into the tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start using the logging component, you need to know a couple of pieces of
    information to start tracking data. Each logger object (`ILogger<T>`) must have
    an associated category. The log category allows you to segment the tracking layer
    with a high definition. For example, if we want to track everything that happens
    in a certain class or in an ASP.NET controller, without having to rewrite all
    our code, we need to enable the category or categories of our interest.
  prefs: []
  type: TYPE_NORMAL
- en: A category is a `T` class. Nothing could be simpler. You can reuse typed objects
    of the class where the log method is injected. For example, if we’re implementing
    `MyService`, and we want to track everything that happens in the service with
    the same category, we just need to request an `ILogger<MyService>` object instance
    from the dependency injection engine.
  prefs: []
  type: TYPE_NORMAL
- en: Once the log categories are defined, we need to call the `ILogger<T>` object
    and take advantage of the object’s public methods. In the previous section, we
    looked at the log layers. Each log layer has its own method for tracking information.
    For example, `LogDebug` is the method specified to track information with a `Debug`
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at an example. I created a record in the `Program.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This record is used to define a particular category of logs that I want to track
    only when necessary. To do this, it is advisable to define a class or a record
    as an end in itself and enable the necessary trace level.
  prefs: []
  type: TYPE_NORMAL
- en: A record that is defined in the `Program.cs` file has no namespace; we must
    remember this when we define the `appsettings` file with all the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the log category is within a namespace, we must consider the full name of
    the class. In this case, it is `LoggingSamples.Categories.MyCategoryAlert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not specify the category, as in the following example, the selected
    log level is the default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Anything that comprises infrastructure logs, such as Microsoft logs, stays in
    special categories such as `Microsoft.AspNetCore` or `Microsoft.EntityFrameworkCore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of Microsoft log categories can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories](https://docs.microsoft.com/aspnet/core/fundamentals/logging/#aspnet-core-and-ef-core-categories)'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to define certain log levels depending on the tracking provider.
    For example, during development, we want to see all the information in the log
    console, but we only want to see errors in the log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we don’t need to change the configuration code but just define
    its level for each provider. The following is an example that shows how everything
    that is tracked in the Microsoft categories is shown from the `Information` layer
    to the ones below it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve figured out how to enable logging and how to filter the various
    categories, all that’s left is to apply this information to a minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we inject two `ILogger` instances with different categories.
    This is not a common practice, but we did it to make the example more concrete
    and show how the logger works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we inject two instances of the logger with different
    categories; each category tracks a single piece of information. The information
    is written according to a template that we will describe shortly. The effect of
    this example is that based on the level, we can show or disable the information
    displayed for a single category, without changing the code.
  prefs: []
  type: TYPE_NORMAL
- en: We started filtering the logo by levels and categories. Now, we want to show
    you how to define a template that will allow us to define a message and make it
    dynamic in some of its parts.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing log message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The message field that is asked by the log methods is a simple string object
    that we can enrich and serialize through the logging frameworks in proper structures.
    The message is therefore essential to identify malfunctions and errors, and inserting
    objects in it can significantly help us to identify the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The message template contains placeholders that interpolate content into the
    textual message.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the text, it is necessary to pass the arguments to replace the
    placeholders. Therefore, the order of the parameters is valid but not the name
    of the placeholders for the substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result then considers the positional parameters and not the placeholder
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to customize log messages. Next, let us learn about infrastructure
    logging, which is essential while working in more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we want to tell you about a little-known and little-used theme
    within ASP.NET applications: the **W3C log**.'
  prefs: []
  type: TYPE_NORMAL
- en: This log is a standard that is used by all web servers, not only **Internet
    Information Services** (**IIS**). It also works on NGINX and many other web servers
    and can be used on Linux, too. It is also used to trace various requests. However,
    the log cannot understand what happened inside the call.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, this feature focuses on the infrastructure, that is, how many calls are
    made and to which endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to enable tracking, which, by default, is stored
    on a file. The functionality takes a little time to find but enables more complex
    scenarios that must be managed with appropriate practices and tools, such as **OpenTelemetry**.
  prefs: []
  type: TYPE_NORMAL
- en: OpenTelemetry
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenTelemetry is a collection of tools, APIs, and SDKs. We use it to instrument,
    generate, collect, and export telemetry data (metrics, logs, and traces) to help
    analyze software performance and behavior. You can learn more at the OpenTelemetry
    official website: [https://opentelemetry.io/](https://opentelemetry.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: To configure W3C logging, you need to register the `AddW3CLogging` method and
    configure all available options.
  prefs: []
  type: TYPE_NORMAL
- en: To enable logging, you only need to add `UseW3CLogging`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The writing of the log does not change; the two methods enable the scenario
    just described and start writing data to the W3C log standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We report the header of the file that is created (the headers of the information
    will be tracked later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen how to track information about the infrastructure hosting our application;
    now, we want to increase log performance with new features in .NET 6 that help
    us set up standard log messages and avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Source generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the novelties of .NET 6 is the source generators; they are performance
    optimization tools that generate executable code at compile time. The creation
    of executable code at compile time, therefore, generates an increase in performance.
    During the execution phase of the program, all structures are comparable to code
    written by the programmer before compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'String interpolation using `$””` is generally great, and it makes for much
    more readable code than `string.Format()`, but you should almost *never* use it
    when writing log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this method to the Console will be the same when using string
    interpolation or structural logging, but there are several problems:'
  prefs: []
  type: TYPE_NORMAL
- en: You lose the *structured* logs and you won’t be able to filter by the format
    values or archive the log message in the custom field of NoSQL products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, you no longer have a constant *message template* to find all identical
    logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serialization of the person is done ahead of time before the string is passed
    into `LogInformation`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serialization is done even though the log filter is not enabled. To avoid
    processing the log, it is necessary to check whether the layer is active, which
    would make the code much less readable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us say you decide to update the log message to include `Age` to clarify
    why the log is being written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, I added `Age` in the message template but not
    in the method signature. At compile time, there is no compile-time error, but
    when this line is executed, an exception is thrown due to the lack of a third
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoggerMessage` in .NET 6 comes to our rescue, automatically generating the
    code to log the necessary data. The methods will require the correct number of
    parameters and the text will be formatted in a standard way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `LoggerMessage` syntax, you can take advantage of a partial class
    or a static class. Inside the class, it will be possible to define the method
    or methods with all the various log cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we created a partial class, injected the logger and
    its category, and implemented two methods. The methods are used in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the second method, we also have the possibility to define the
    log level at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind the scenes, the `[LoggerMessage]` source generator generates the `LoggerMessage.Define()` code
    to optimize your method call. The following output shows the generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this section, you have learned about some logging providers, different log
    levels, how to configure them, what parts of the message template to modify, enabling
    logging, and the benefits of source generators. In the next section, we will focus
    more on logging providers.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the logging framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logging framework, as mentioned at the beginning of the chapter, already
    has by design a series of providers that do not require adding any additional
    packages. Now, let us explore how to work with these providers and how to build
    custom ones. We will analyze only the Console log provider because it has all
    the sufficient elements to replicate the same reasoning on other log providers.
  prefs: []
  type: TYPE_NORMAL
- en: Console log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Console` log provider is the most used one because, during the development,
    it gives us a lot of information and collects all the application errors.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 6, this provider has been joined by the `AddJsonConsole` provider,
    which, besides tracing the errors like the console, serializes them in a JSON
    object readable by the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we show how to configure the `JsonConsole` provider
    and also add indentation when writing the JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ve seen in the previous examples, we’re going to track the information
    with the message template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, an important note: the `Console` and `JsonConsole` providers do not
    serialize objects passed via the message template but only write the class name.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is definitely a limitation of providers. Thus, we suggest using structured
    logging tools such as **NLog**, **log4net**, and **Serilog**, which we will talk
    about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We present the outputs of the previous lines with the two providers just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – AddJsonConsole output ](img/Figure_5.1_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – AddJsonConsole output
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.1* shows the log formatted as JSON, with several additional details
    compared to the traditional console log.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Default logging provider Console output ](img/Figure_5.2_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Default logging provider Console output
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.2* shows the default logging provider Console output.'
  prefs: []
  type: TYPE_NORMAL
- en: Given the default providers, we want to show you how you can create a custom
    one that fits the needs of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logging framework designed by Microsoft can be customized with little effort.
    Thus, let us learn how to create a **custom provider**.
  prefs: []
  type: TYPE_NORMAL
- en: Why create a custom provider? Well, put simply, to not have dependencies with
    logging libraries and to better manage the performance of the application. Finally,
    it also encapsulates some custom logic of your specific scenario and makes your
    code more manageable and readable.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we have simplified the usage scenario to show you
    the minimum components needed to create a working logging provider for profit.
  prefs: []
  type: TYPE_NORMAL
- en: One of the fundamental parts of a provider is the ability to configure its behavior.
    Let us create a class that can be customized at application startup or retrieve
    information from `appsettings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we define a fixed `EventId` to verify a daily rolling file
    logic and a path of where to write the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The custom provider we are writing will be responsible for writing the log information
    to a text file. We achieve this by implementing the log class, which we call `FileLogger`,
    which implements the `ILogger` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the class logic, all we do is implement the log method and check which file
    to put the information in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We put the directory verification in the next file, but it’s more correct to
    put all the control logic in this method. We also need to make sure that the log
    method does not throw exceptions at the application level. The logger should never
    affect the stability of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to implement the `ILoggerProvider` interface, which is intended
    to create one or more instances of the logger class just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this class, we check the directory we mentioned in the previous paragraph,
    but we also check whether the settings in the `appsettings` file change, via `IOptionsMonitor<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to simplify its use and configuration during the application startup
    phase, we also define an extension method for registering the various classes
    just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddFile` method will register `ILoggerProvider` and couple it to its configuration
    (very simple as an example, but it encapsulates several aspects of configuring
    and using a custom provider):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We record everything seen in the `Program.cs` file with the `AddFile` extension
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in *Figure 5.3*, where we can see both Microsoft log categories
    in the first five lines (this is the classic application startup information):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – File log provider output ](img/Figure_5.3_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – File log provider output
  prefs: []
  type: TYPE_NORMAL
- en: Then, the handler of the minimal APIs that we reported in the previous sections
    is called. As you can see, no exception data or data passed to the logger is serialized.
  prefs: []
  type: TYPE_NORMAL
- en: To add this functionality as well, it is necessary to rewrite `ILogger formatter`
    and support serialization of the object. This will give you everything you need
    to have in a useful logging framework for production scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen how to configure the log and how to customize the provider object
    to create a structured log to send to a service or storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we want to describe the Azure Application Insights service,
    which is very useful for both logging and application monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the already seen providers, one of the most used ones is **Azure
    Application Insights**. This provider allows you to send every single log event
    in the Azure service. In order to insert the provider into our project, all we
    would have to do is install the following NuGet package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Registering the provider is very easy.
  prefs: []
  type: TYPE_NORMAL
- en: We first register the Application Insights framework, `AddApplicationInsightsTelemetry`,
    and then register its extension on the `AddApplicationInsights` logging framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the NuGet package previously described, the one for logging the component
    to the logging framework is also present as a reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To register the instrumentation key, which is the key that is issued after
    registering the service on Azure, you will need to pass this information to the
    registration method. We can avoid hardcoding this information by placing it in
    the `appsettings.json` file using the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This process is also described in the documentation ([https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio](https://docs.microsoft.com/it-it/azure/azure-monitor/app/asp-net-core#enable-application-insights-server-side-telemetry-no-visual-studio)).
  prefs: []
  type: TYPE_NORMAL
- en: By launching the method already discussed in the previous sections, we have
    all the information hooked into Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights groups the logs under a particular trace. A trace is a
    call to an API, so everything that happens in that call is logically grouped together.
    This feature takes advantage of the `WebServer` information and, in particular,
    `TraceParentId` issued by the W3C standard for each call.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, Application Insights can bind calls between various minimal APIs,
    should we be in a microservice application or with multiple services collaborating
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Application Insights with a standard log provider ](img/Figure_5.4_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Application Insights with a standard log provider
  prefs: []
  type: TYPE_NORMAL
- en: We notice how the default formatter of the logging framework does not serialize
    the `PayloadData` object but only writes the text of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In the applications that we will bring into production, it will be necessary
    to also trace the serialization of the objects. Understanding the state of the
    object on time is fundamental to analyzing the errors that occurred during a particular
    call while running queries in the database or reading the data read from the same.
  prefs: []
  type: TYPE_NORMAL
- en: Storing a structured log with Serilog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we just discussed, tracking structured objects in the log helps us tremendously
    in understanding errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, therefore, suggest one of the many logging frameworks: **Serilog**.'
  prefs: []
  type: TYPE_NORMAL
- en: Serilog is a comprehensive library that has many **sinks** already written that
    allow you to store log data and search it later.
  prefs: []
  type: TYPE_NORMAL
- en: Serilog is a logging library that allows you to track information on multiple
    data sources. In Serilog, these sources are called sinks, and they allow you to
    write structured data inside the log applying a serialization of the data passed
    to the logging system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to get started using Serilog for a minimal API application. Let’s
    install these NuGet packages. Our goal will be to track the same information we’ve
    been using so far, specifically `Console` and `ApplicationInsights`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first package is the one needed for the `ApplicationInsights` SDK in the
    application. The second package allows us to register Serilog in the ASP.NET pipeline
    and to be able to exploit Serilog. The third package allows us to configure the
    framework in the `appsettings` file and not have to rewrite the application to
    change a parameter or code. Finally, we have the package to add the `ApplicationInsights`
    sink.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `appsettings` file, we create a new `Serilog` section, in which we should
    register the various sinks in the `Using` section. We register the log level,
    the sinks, the enrichers that enrich the information for each event, and the properties,
    such as the application name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just have to register `Serilog` in the ASP.NET pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With the `builder.Logging.AddSerilog()` statement, we register Serilog with
    the logging framework to which all logged events will be passed with the usual
    `ILogger` interface. Since the framework needs to register the `TelemetryConfiguration`
    class to register `ApplicationInsights`, we are forced to hook the configuration
    to the static `Logger` object of Serilog. This is all because Serilog will turn
    the information from the Microsoft logging framework over to the Serilog framework
    and add all the necessary information.
  prefs: []
  type: TYPE_NORMAL
- en: The usage is very similar to the previous one, but this time, we add an `@`
    (at) to the message template that will tell Serilog to serialize the sent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this very simple `{@Person}` wording, we will be able to achieve the goal
    of serializing the object and sending it to the `ApplicationInsights` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to find the complete data, serialized with the JSON format,
    in the Application Insights service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Application Insights with structured data ](img/Figure_5.5_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Application Insights with structured data
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen several logging aspects of the implementation
    of minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We started to appreciate the ASP.NET churned logging framework, and we understood
    how to configure and customize it. We focused on how to define a message template
    and how to avoid errors with the source generator.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use the new provider to serialize logs with the JSON format and
    create a custom provider. These elements turned out to be very important for mastering
    the logging tool and customizing it to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Not only was the application log mentioned but also the infrastructure log,
    which together with Application Insights becomes a key element to monitoring your
    application. Finally, we understood that there are ready-made tools, such as Serilog,
    that help us to have ready-to-use functionalities with a few steps thanks to some
    packages installed by NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will present the mechanisms for validating an input
    object to the API. This is a fundamental feature to return a correct error to
    the calls and discard inaccurate requests or those promoted by illicit activities
    such as spam and attacks, aimed at generating load on our servers.
  prefs: []
  type: TYPE_NORMAL
