- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a News App Using .NET MAUI Shell
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a news app that leverages the **Shell** navigation
    functionality provided to us by the .NET MAUI team at Microsoft. The old way of
    doing this, which involved using **ContentPage**, **FlyoutPage**, **TabbedPage**,
    or **NavigationPage** as the main page, as we did in *Chapter 2*, still works,
    but we are sure that you will enjoy the new way of defining the structure of your
    app. Also, you can mix and match the old and new.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to define an app structure
    using Shell, consume data from a REST API, configure navigation, and pass data
    between views using query-style routes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: So, what is Shell, then? In Shell, you define the structure of your app using
    **Extensible Application Markup Language** (**XAML**) instead of hiding it in
    spread-out pieces of code in your app. You can also navigate using routes, just
    like those fancy web developers are doing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Shell navigation page
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a flyout
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a navigation bar
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating using routes and passing data in query strings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming data from a public **representational state transfer** (**REST**)
    **application programming** **interface** (**API**)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding content in the form of a `CollectionView` control
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to complete this project, you will need to have Visual Studio for
    Mac or Windows installed, as well as the necessary .NET MAUI workload components.
    See *Chapter 1*, *Introduction to .NET MAUI*, for more details on how to set up
    your environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter at [https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a .NET MAUI project using the **single-project** feature as
    the code-sharing strategy. It will contain two parts, detailed as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In the first part, we will create views and make them navigable using Shell
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second part, we will add some content by consuming a **REST API** for
    news
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part is not needed to learn about Shell, but it will take you a bit
    further down the road to a complete app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 1.5 hours.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Building the news app
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be all about building a news app from the beginning. It will
    guide you through every step, but it will not go into every detail. For that,
    we recommend *Chapter 2*, *Building Our First .NET MAUI App*, which goes into
    more detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Happy coding!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This project, like all the rest, is a **File** | **New** | **Project...**-style
    project. This means that we will not be importing any code at all. So, this first
    section is all about creating the project and setting up the basic project structure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step is to create a new .NET MAUI project:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio 2022 and select **Create a** **new project**:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2022 并选择 **创建一个** **新项目**：
- en: '![Figure 4.1 – Visual Studio 2022](img/Figure_4.1_B19214.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Visual Studio 2022](img/Figure_4.1_B19214.jpg)'
- en: Figure 4.1 – Visual Studio 2022
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Visual Studio 2022
- en: This will open the **Create a new** **project** wizard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **创建一个新项目** 向导。
- en: 'In the search field, type in `maui` and select the **.NET MAUI App** item from
    the list:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `maui` 并从列表中选择 **.NET MAUI 应用** 项：
- en: '![Figure 4.2 – Create a new project](img/Figure_4.2_B19214.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 创建一个新项目](img/Figure_4.2_B19214.jpg)'
- en: Figure 4.2 – Create a new project
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 创建一个新项目
- en: Click **Next**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'Enter `News` as the name of the app, as shown in the following screenshot:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下截图所示，输入 `News` 作为应用程序的名称：
- en: '![Figure 4.3 – Configure your new project](img/Figure_4.3_B19214.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 配置您的新的项目](img/Figure_4.3_B19214.jpg)'
- en: Figure 4.3 – Configure your new project
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 配置您的新的项目
- en: Click **Next**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将提示您选择要支持的 .NET Core 版本。在撰写本文时，.NET 6 可用作为 **长期支持**（**LTS**），而 .NET 7 可用作为
    **标准期限支持**。对于本书，我们假设您将使用 .NET 7：
- en: '![Figure 4.4 – Additional information](img/Figure_4.4_B19214.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 其他信息](img/Figure_4.4_B19214.jpg)'
- en: Figure 4.4 – Additional information
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 其他信息
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **创建** 并等待 Visual Studio 创建项目来完成设置。
- en: That’s it for project creation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建到此结束。
- en: Let’s continue by setting up the structure of the app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续设置应用程序的结构。
- en: Creating the structure of the app
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序的结构
- en: In this section, we will start to build the **Views** and **ViewModels** of
    the app. The *Using MVVM – creating views and ViewModels* section in *Chapter
    2* contains more details on **Model-View-ViewModel** (**MVVM**) as a design pattern.
    It’s recommended that you read that first if you don’t know what MVVM is.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始构建应用程序的 **视图** 和 **ViewModel**。*第二章* 中的 *使用 MVVM – 创建视图和 ViewModel*
    部分包含有关 **模型-视图-ViewModel**（**MVVM**）作为设计模式的更多详细信息。如果您不知道 MVVM 是什么，建议您先阅读。
- en: Creating the ViewModel base class
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 ViewModel 基类
- en: '`ViewModel` is the mediator between `View` and `Model`. Let’s create a base
    class for `ViewModels` with common functionality that we can reuse. In practice,
    `ViewModel` must implement an interface called `INotifyPropertyChanged` for MVVM
    to function. We will do so in the base class and will also add a little handy
    helper tool called **CommunityToolkit.Mvvm** that will save us a lot of time.
    Again, please check out *Chapter 2*, *Building Our First .NET MAUI App*, if you
    are feeling unsure about MVVM.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 是 `View` 和 `Model` 之间的中介。让我们创建一个具有常见功能的基础类 `ViewModels`，我们可以重用它。在实践中，`ViewModel`
    必须实现一个名为 `INotifyPropertyChanged` 的接口，以便 MVVM 能够运行。我们将在基类中这样做，并添加一个名为 **CommunityToolkit.Mvvm**
    的小巧助手工具，这将为我们节省大量时间。如果您对 MVVM 感到不确定，请再次查看 *第二章*，*构建我们的第一个 .NET MAUI 应用*。'
- en: 'The first step is to create a base class. Proceed as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个基类。按照以下步骤操作：
- en: In the `News` project, create a folder called `ViewModels`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，创建一个名为 `ViewModels` 的文件夹。
- en: In the `ViewModels` folder, create a class called `ViewModel`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中，创建一个名为 `ViewModel` 的类。
- en: 'Change the existing class so that it looks as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将现有类更改为以下样子：
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Excellent! Let’s implement `INotifyPropertyChanged` in the base `ViewModel`
    class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们在基 `ViewModel` 类中实现 `INotifyPropertyChanged`。
- en: A quick recap of CommunityToolkit.Mvvm
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CommunityToolkit.Mvvm 快速回顾
- en: CommunityToolkit.Mvvm is a NuGet package that contains a few source generators
    that can automatically generate the necessary implementation details for `INotifyPropertyChanged`.
    More specifically, it will inject a call that will raise the `PropertyChanged`
    event whenever a setter is called. It also takes care of property dependencies;
    if I change the `FirstName` property, the `FullName` read-only property will also
    get a `PropertyChanged` event. Before CommunityToolkit.Mvvm, you would have had
    to write this code manually.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CommunityToolkit.Mvvm 是一个包含几个源生成器的 NuGet 包，这些生成器可以自动生成 `INotifyPropertyChanged`
    所需的实现细节。更具体地说，它将注入一个调用，每当调用设置器时都会引发 `PropertyChanged` 事件。它还负责属性依赖关系；如果更改 `FirstName`
    属性，只读属性 `FullName` 也会收到一个 `PropertyChanged` 事件。在 CommunityToolkit.Mvvm 之前，您将不得不手动编写此代码。
- en: It’s all explained in more detail in *Chapter 2*, *Building Our First .NET MAUI
    App*. Have you read it yet?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的内容请参阅 *第 2 章*，*构建我们的第一个 .NET MAUI 应用程序*。你读过它了吗？
- en: Adding a reference to CommunityToolkit.Mvvm
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加对 CommunityToolkit.Mvvm 的引用
- en: 'CommunityToolkit.Mvvm and its dependencies are installed using NuGet. So, let’s
    install the NuGet package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CommunityToolkit.Mvvm 及其依赖项使用 NuGet 安装。因此，让我们安装 NuGet 包：
- en: In the `News` project, install the CommunityToolkit.Mvvm NuGet package, version
    8.0.0.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，安装 CommunityToolkit.Mvvm NuGet 包，版本 8.0.0。
- en: Accept any license dialog boxes.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受任何许可对话框。
- en: This will install the relevant NuGet packages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装相关的 NuGet 包。
- en: Implementing INotifyPropertyChanged
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 INotifyPropertyChanged
- en: '`ViewModel` sits between `View` and `Model`. When a change in `ViewModel` occurs,
    `View` must be notified. The mechanism for this is the `INotifyPropertyChanged`
    interface, which defines an event that the controls in `View` subscribe to. The
    `ObservableObject` attribute is the magic that will generate the `INotifyPropertyChanged`
    implementation for us. Follow these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 位于 `View` 和 `Model` 之间。当 `ViewModel` 发生变化时，`View` 必须被通知。这种机制的实现是
    `INotifyPropertyChanged` 接口，它定义了一个 `View` 控件订阅的事件。`ObservableObject` 属性是生成我们 `INotifyPropertyChanged`
    实现的魔法。按照以下步骤进行：'
- en: In the `News` project, open up `ViewModels.cs`.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `ViewModels.cs`。
- en: 'Add the following code in bold:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粗体中添加以下代码：
- en: '[PRE1]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This instructs CommunityToolkit.Mvvm to implement the `INotifyPropertyChanged`
    interface. The next step is all about reducing the number of lines of code that
    we will have to write. Normally, you would have to manually raise the `PropertyChanged`
    event from your code, but thanks to source generators, which write code at build
    time, we simply have to create normal properties and let CommunityToolkit.Mvvm
    do the magic.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 CommunityToolkit.Mvvm 实现了 `INotifyPropertyChanged` 接口。下一步是减少我们将要编写的代码行数。通常，您需要手动从您的代码中引发
    `PropertyChanged` 事件，但多亏了在构建时编写代码的源生成器，我们只需创建常规属性，让 CommunityToolkit.Mvvm 做出魔法。
- en: Let’s move on and create our first `ViewModel`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，创建我们的第一个 `ViewModel`。
- en: Creating the HeadlinesViewModel class
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 HeadlinesViewModel 类
- en: We will now start to create some `View` and `ViewModel` placeholders that we
    will expand on during this chapter. We will not directly implement all graphical
    features; instead, we’ll keep it simple and think of all these pages as placeholders
    for what’s to come next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始创建一些 `View` 和 `ViewModel` 占位符，我们将在本章中对其进行扩展。我们不会直接实现所有图形功能；相反，我们将保持简单，并将所有这些页面视为未来内容的占位符。
- en: 'The first one is the `HeadlinesViewModel` class, which will serve as the `ViewModel`
    for `HeadlinesView`. Proceed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 `HeadlinesViewModel` 类，它将作为 `HeadlinesView` 的 `ViewModel`。按照以下步骤进行：
- en: In the `News` project, under the `ViewModels` folder, create a new class called
    `Head``linesViewModel`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，在 `ViewModels` 文件夹下，创建一个名为 `HeadlinesViewModel` 的新类。
- en: 'Edit the class so that it inherits from the `ViewModel` base class, as shown
    in bold in the following code snippet:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑类，使其从以下粗体代码片段中的 `ViewModel` 基类继承：
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: OK – not bad. It doesn’t do much yet, but we’ll just leave it for now. Let’s
    create the matching view.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 – 不坏。它现在还没有做什么，但我们先这样吧。让我们创建匹配的视图。
- en: Creating HeadlinesView
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 HeadlinesView
- en: 'This view will eventually show a list of news, but for now, it will be kept
    simple. Follow these steps to create the page:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图最终将显示新闻列表，但到目前为止，它将保持简单。按照以下步骤创建页面：
- en: In the `News` project, create a folder named `Views`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，创建一个名为 `Views` 的文件夹。
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Views` 文件夹，选择 **添加**，然后点击 **新建项...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用的是 Visual Studio 17.7 或更高版本，请点击弹出的对话框中的 **显示所有模板** 按钮。否则，继续下一步。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **C# 项** 节点下，选择 **.NET MAUI**。
- en: Select `HeadlinesView`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `HeadlinesView`。
- en: Click **Add** to create the page.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 创建页面。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 4.5 – Add New Item](img/Figure_4.5_B19214.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 添加新项](img/Figure_4.5_B19214.jpg)'
- en: Figure 4.5 – Add New Item
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 添加新项
- en: 'Let’s add some placeholder code to `HeadlinesView`, just to have something
    to navigate to and from. We will replace it with something hotter later on in
    this chapter, but to keep things simple, let’s add a label. To do so, proceed
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`HeadlinesView`中添加一些占位符代码，以便有东西可以导航到和从。我们将在本章稍后用更热的东西替换它，但为了保持简单，让我们添加一个标签。要这样做，请按照以下步骤进行：
- en: In the `News` project, under the `Views` folder, open `HeadlinesView.xaml`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，在`Views`文件夹下，打开`HeadlinesView.xaml`。
- en: 'Edit the XAML code by adding the following code marked in bold:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下加粗代码来编辑XAML代码：
- en: '[PRE3]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will set the title of the page and add a label with the text `HeadlinesView`
    centered in the middle of the page. Let’s move on and create some additional view
    placeholders.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置页面的标题并在页面中间添加一个带有文本`HeadlinesView`的标签。让我们继续并创建一些额外的视图占位符。
- en: Creating ArticleItem
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建ArticleItem
- en: The app will eventually display a list of articles where each article will be
    rendered using a reusable component. We will call this reusable component `ArticleItem`.
    In .NET MAUI, a reusable component is called a **ContentView**. Please don’t confuse
    this with an MVVM View, which is represented by a page in .NET MAUI. We know that
    this is confusing, but the rule is that a .NET MAUI page is an MVVM View and a
    .NET MAUI ContentView is essentially a reusable control.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序最终将显示一系列文章，其中每篇文章都将使用一个可重用组件进行渲染。我们将把这个可重用组件称为`ArticleItem`。在.NET MAUI中，一个可重用组件被称为**ContentView**。请不要将其与表示为.NET
    MAUI中页面的MVVM View混淆。我们知道这很令人困惑，但规则是.NET MAUI页面是一个MVVM View，而.NET MAUI ContentView基本上是一个可重用控件。
- en: 'That said, let’s create the `ArticleItem` class, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们创建`ArticleItem`类，如下所示：
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，右键单击`Views`文件夹，选择**添加**，然后点击**新建项...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio 17.7或更高版本，请点击弹出对话框中的**显示所有模板**按钮。否则，继续下一步。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的**C# Items**节点下，选择**.NET MAUI**。
- en: '*Important*: Make sure that you select the **ContentView** template in the
    next step and *not* the **ContentPage** template.'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*重要*：确保在下一步中选择**ContentView**模板，而不是**ContentPage**模板。'
- en: Select `ArticleItem`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ArticleItem`。
- en: Click **Add** to create the view.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**来创建视图。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 4.6 – Add New Item – ArticleItem.xaml](img/Figure_4.6_B19214.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6 – 添加新项 – ArticleItem.xaml](img/Figure_4.6_B19214.jpg)'
- en: Figure 4.6 – Add New Item – ArticleItem.xaml
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 添加新项 – ArticleItem.xaml
- en: We don’t need to alter the XAML code that’s been generated at this point, so
    we’ll simply leave it as is.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们不需要修改生成的XAML代码，所以我们将其保持原样。
- en: Creating ArticleView
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建ArticleView
- en: 'In the previous section, we created the `ArticleItem` content view. This view
    (`ArticleView`) will contain `WebView` to display each article. But for the moment,
    let’s just add `ArticleView` as a placeholder. Follow these steps to do so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了`ArticleItem`内容视图。这个视图（`ArticleView`）将包含`WebView`以显示每篇文章。但到目前为止，我们只需将`ArticleView`作为一个占位符添加。按照以下步骤进行操作：
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，右键单击`Views`文件夹，选择**添加**，然后点击**新建项...**。
- en: If you are using Visual Studio 17.7 or later, click the **Show all Templates**
    button in the dialog that pops up. Otherwise, move on to the next step.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用的是Visual Studio 17.7或更高版本，请点击弹出对话框中的**显示所有模板**按钮。否则，继续下一步。
- en: Select **.NET MAUI** under the **C# Items** node on the left.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的**C# Items**节点下选择**.NET MAUI**。
- en: Select `ArticleView`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`ArticleView`。
- en: Click **Add** to create the page.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**来创建页面。
- en: 'Since this view is also a placeholder view at the moment, we’ll just add a
    label to indicate the type of page. Edit the content by following these steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个视图目前也是一个占位符视图，我们只需添加一个标签来指示页面的类型。按照以下步骤编辑内容：
- en: In the `News` project, open `ArticleView.xaml`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，打开`ArticleView.xaml`。
- en: 'Edit the XAML code by adding the following code marked in bold:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下加粗代码来编辑XAML代码：
- en: '[PRE4]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Alright – just one more view to mock before we can start to wire things up.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好的 – 在我们开始连接东西之前，还有一个视图需要模拟。
- en: Creating AboutView
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建AboutView
- en: 'The last view will be created in the same way as all the others. Proceed as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个视图将以与其他所有视图相同的方式进行创建。按照以下步骤进行：
- en: In the `News` project, right-click the `Views` folder, select **Add**, and then
    click **New Item...**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，右键单击`Views`文件夹，选择**添加**，然后点击**新建项...**。
- en: Under the **C# Items** node on the left, select **.****NET MAUI**.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的**C# 项目**节点下，选择**.****NET MAUI**。
- en: Select `AboutView`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`AboutView`。
- en: Click **Add** to create the page.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**以创建页面。
- en: 'This view is the only view that will stay a placeholder view. It’s up to you
    to do something with it if you choose to build something cool out of this project
    later. So, we will only add a label that states that this is `AboutView`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种视图是唯一会保留为占位符视图的视图。如果你选择在以后从这个项目中构建一些酷炫的东西，那么就需要你来处理它。因此，我们只会添加一个标签来声明这是一个`AboutView`：
- en: In the `News` project, open `AboutView.xaml`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，打开`AboutView.xaml`。
- en: 'Edit the XAML code by adding the following code marked in bold:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下加粗代码来编辑XAML代码：
- en: '[PRE5]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With that, we have all the views we need to start wiring the app up. The first
    step is to configure dependency injection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了开始连接应用所需的所有视图。第一步是配置依赖注入。
- en: Wiring up dependency injection
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接依赖注入
- en: By using dependency injection as a pattern, we can keep our code cleaner and
    more testable. This app will use constructor injection, which means that all dependencies
    that a class has must be passed through its constructor. The container then constructs
    objects for you, so you don’t have to care too much about the dependency chain.
    Since .NET MAUI already includes a dependency injection framework, called Microsoft.Extensions.DependencyInjection,
    there is nothing extra to install.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用依赖注入作为模式，我们可以使我们的代码更干净、更易于测试。这个应用将使用构造函数注入，这意味着一个类所拥有的所有依赖都必须通过其构造函数传递。容器随后为你构建对象，因此你不需要过多关注依赖链。由于.NET
    MAUI已经包含了一个名为Microsoft.Extensions.DependencyInjection的依赖注入框架，因此不需要安装任何额外的东西。
- en: Confused about dependency injection?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对依赖注入感到困惑？
- en: Check out the *Wiring up a dependency injection* section in *Chapter 2*, *Building
    Our First .NET MAUI App*, for more details on dependency injection.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*，*构建我们的第一个.NET MAUI应用*中查看*连接依赖注入*部分，以获取有关依赖注入的更多详细信息。
- en: Registering Views and ViewModels with dependency injection
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用依赖注入注册视图和ViewModel
- en: 'When registering classes with the container, it is recommended to use extension
    methods to group the types. The extension methods will take a single parameter
    and return a single value, the `MauiAppBuilder` instance. This is how the `CreateMauiApp`
    method. For this app, we have `Views` and `ViewModels` to register for now. Let’s
    create the method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用容器注册类时，建议使用扩展方法来分组类型。扩展方法将接受一个参数并返回一个值，即`MauiAppBuilder`实例。这就是`CreateMauiApp`方法的工作方式。对于这个应用，我们现在需要注册`Views`和`ViewModels`。让我们创建这个方法：
- en: In the `News` project, open the `MauiProgram.cs` file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，打开`MauiProgram.cs`文件。
- en: 'Make the following changes to the `MauiProgram` class; the changes are highlighted
    in the code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`MauiProgram`类进行以下更改；更改已在代码中突出显示：
- en: '[PRE6]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The .NET MAUI `MauiAppBuilder` class exposes the `Services` property, which
    is the dependency injection container. We simply need to add the types we want
    dependency injection to know about; the container will do the rest for us. Think
    of a builder as something that collects a lot of information on what needs to
    be done, and then finally builds the object we need. It’s a very useful pattern
    on its own, by the way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI的`MauiAppBuilder`类公开了`Services`属性，它是依赖注入容器。我们只需要添加我们想要依赖注入了解的类型；容器会为我们完成剩下的工作。顺便说一句，将构建器想象成收集了大量需要完成的信息的东西，然后最终构建我们需要的对象。它本身就是一个非常有用的模式。
- en: We're only using the builder for one thing at the moment. Later on, we will
    use it to register any class in the assembly that inherits from our abstract `ViewModel`
    class. The container is now prepared for us to ask for these types.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只使用构建器来做一件事。稍后，我们将使用它来注册任何从我们的抽象`ViewModel`类继承的类。容器现在已为我们准备好请求这些类型。
- en: Now, we need to make some graphical touches to our app. We will rely on **Font
    Awesome** to do the magic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对我们的应用做一些图形上的调整。我们将依靠**Font Awesome**来完成魔法。
- en: Downloading and configuring Font Awesome
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载和配置Font Awesome
- en: Font Awesome is a free collection of images packaged into a font. .NET MAUI
    has excellent support for using Font Awesome in toolbars, navigation bars, and
    all over the place. It’s not strictly needed to make this app, but we think that
    it’s worth the extra round trip since you are most likely going to need something
    like this in your new killer app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to download the font.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Font Awesome
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Downloading the font is straightforward. Please note the renaming of the file
    – it’s not needed but it’s easier to edit configuration files and such if they
    have simpler names. Follow these steps to acquire and copy the font to each project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [https://fontawesome.com/download](https://fontawesome.com/download).
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Free for Desktop** button to download Font Awesome.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the downloaded file, then locate the `otfs` folder.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Font Awesome 5 Free-Solid-900.otf` file to `FontAwesome.otf` (you
    can keep the original name, but it’s just less to type if you rename it). Your
    filename may be different since Font Awesome is continually updating but it should
    be similar.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy `FontAwesome.otf` to the `Resources/Fonts` folder in the `News` project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alright – now, we need to register Font Awesome with .NET MAUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Configuring .NET MAUI to use Font Awesome
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It would be nice if all we needed to do was to copy the font file into the
    project folders. A lot does happen with just that action. The default .NET MAUI
    template includes all the fonts in the `Resources/Fonts` folder with the following
    item definition in the `News.csproj` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This ensures that the font files are processed and included in the app package
    automatically. What is left is to register the font with the .NET MAUI runtime
    so that it is available to our XAML resources. To do that, add the following highlighted
    line to the `MauiProgram.cs` file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This line adds an alias that we can use in the next section to create static
    resources. The first parameter is the filename for the font file, while the second
    is the alias for the font that we can use in the `FontFamily` attribute.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: All that is left is to define some icons in a resource dictionary.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Deﬁning some icons in the resource dictionary
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have defined the font, we will put that to use and define five icons
    to use in our app. We’ll add the XAML first; then, we’ll examine one of the `FontImage`
    tags.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: In the `News` project, open `App.xaml`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code marked in bold under the existing `ResourceDictionary.MergedDictionaries`
    tag:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`FontImage` is a class that can be used anywhere in .NET MAUI that expects
    an `ImageSource` object. It’s designed to render one character (or glyph) into
    an image. The `FontImage` class needs a few attributes to work, detailed as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: A key for reference that will be used by other views in the application.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `FontFamily` resource that uses the alias reference back to the `Font` resource
    that we defined in the preceding section.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Glyph` object, which represents the image to be shown. To find which image
    these cryptic values refer to, check out [fontawesome.com](http://fontawesome.com),
    click on **Icons**, select **free and open-source icons**, and start browsing.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Glyph` 对象，代表要显示的图像。要找出这些神秘值引用的是哪个图像，请访问 [fontawesome.com](http://fontawesome.com)，点击
    **图标**，选择 **免费和开源图标**，并开始浏览。'
- en: '`Size` and `Color`. These are not strictly needed but they’re nice to define.
    They are used for a few of the icons in this app so that they render properly
    for light themes.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size` 和 `Color`。这些不是严格必需的，但定义它们是好的。它们用于此应用中的一些图标，以便它们在浅色主题中正确渲染。'
- en: Font Awesome is now installed and configured. We’ve done a lot of work to get
    to the actual topic of this chapter. It’s time to define the shell!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome 现已安装并配置。我们已经做了很多工作，才到达本章的实际主题。现在是定义壳的时候了！
- en: Defining the shell
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义壳
- en: As stated earlier, .NET MAUI Shell is the newest way of defining the structure
    of your app. The different projects in this book use alternate ways of defining
    the overall structure of the app, but .NET MAUI Shell is, in our opinion, the
    best way of defining the UI structure. We hope you find it as exciting as we do!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，.NET MAUI Shell 是定义您应用结构的新方法。本书中的不同项目使用不同的方法来定义应用的整体结构，但根据我们的观点，.NET MAUI
    Shell 是定义 UI 结构的最佳方式。我们希望您觉得它和我们都一样令人兴奋！
- en: Deﬁning the basic structure
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义基本结构
- en: 'We’re going to start by defining a basic structure for the app without really
    adding any of our defined views to it. After that, we’ll add the actual views
    one by one. But let’s start by adding some content and creating `ContentPage`
    objects using XAML directly. Follow these two steps to do so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为应用定义一个基本结构，而不真正添加我们定义的任何视图。之后，我们将逐个添加实际视图。但让我们先添加一些内容，并使用 XAML 直接创建 `ContentPage`
    对象。按照以下两个步骤操作：
- en: In the `News` project, open the `AppShell.xaml` file.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `AppShell.xaml` 文件。
- en: 'Alter the file so that it looks like the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改文件，使其看起来像以下代码：
- en: '[PRE10]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s break this down. First, by default, the .NET MAUI Shell template disables
    the flyout menu. Since we want to use it in this app, you must remove the line
    that disables it. The direct children of Shell itself are two `FlyoutItem` objects
    and one `ShellContent` object. All three of these have `Title` and `Icon` properties
    defined, as shown in the following screenshot. The icons are referenced to the
    Font Awesome resources we created earlier. This will render a flyout, as shown
    in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。首先，默认情况下，.NET MAUI Shell 模板禁用了飞出菜单。由于我们想在应用中使用它，您必须删除禁用它的那一行。Shell 本身的直接子对象是两个
    `FlyoutItem` 对象和一个 `ShellContent` 对象。这三个对象都有定义的 `Title` 和 `Icon` 属性，如下面的截图所示。图标引用了我们之前创建的
    Font Awesome 资源。这将渲染一个飞出菜单，如下面的截图所示：
- en: '![Figure 4.7 – The app flyout](img/Figure_4.7_B19214.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 应用飞出菜单](img/Figure_4.7_B19214.jpg)'
- en: Figure 4.7 – The app flyout
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 应用飞出菜单
- en: The flyout is accessible by swiping in from the left. `Flyout` objects can have
    multiple children, while the `ShellContent` element can only have a single child.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从左侧滑动可以访问飞出菜单。`Flyout` 对象可以有多个子对象，而 `ShellContent` 元素只能有一个子对象。
- en: 'The `ShellContent` with a page with the title **Headlines** and a tab that
    defines two child pages on its own. The first level of children will render the
    tab bar at the bottom of the app, as shown in the following screenshot. The second
    level of children, under the **Tab** element with the **News** title, will be
    rendered as a tab bar directly under the title of the navigation bar at the top:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShellContent` 包含一个标题为 **Headlines** 的页面和一个定义其自身两个子页面的标签页。第一级子页面将在应用的底部渲染标签栏，如下面的截图所示。在具有
    **News** 标题的 **Tab** 元素下的第二级子页面将直接在顶部导航栏的标题下方渲染为一个标签栏：'
- en: '![Figure 4.8 – The Shell tabs and pages](img/Figure_4.8_B19214.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – Shell 标签和页面](img/Figure_4.8_B19214.jpg)'
- en: Figure 4.8 – The Shell tabs and pages
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – Shell 标签和页面
- en: The **Settings** and **About** flyouts will simply render the pages that they
    define.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置** 和 **关于** 飞出菜单将简单地渲染它们定义的页面。'
- en: Making the app run
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使应用运行
- en: It’s time to try the app out and see whether it looks like the screenshots shown
    throughout this chapter. The app should now run. If not, stay calm and simply
    go through the code again. Once you are done navigating around the app, we can
    create a news service to fetch news from, and extend all those views that we’ve
    created.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试这个应用并看看它是否看起来像本章中展示的截图了。现在应用应该可以运行了。如果不行，保持冷静，只需再次检查代码即可。一旦你完成了对应用的导航，我们就可以创建一个新闻服务来获取新闻，并扩展我们创建的所有视图。
- en: Creating the news service
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新闻服务
- en: To find cool content, we’ll consume an already existing `News` API provided
    by [newsapi.org](http://newsapi.org). To do so, we must register for an API key
    that we can use to request the news. If you aren’t comfortable with doing so,
    you can mock the news service if you would like, instead of using the API.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到有趣的内容，我们将使用由[newsapi.org](http://newsapi.org)提供的现有`News` API。为此，我们必须注册一个API密钥，我们可以用它来请求新闻。如果你不习惯这样做，你可以模拟新闻服务，而不是使用API。
- en: The first thing we must do is obtain an API key.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是获取一个API密钥。
- en: Obtaining an API key
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: The process of registering is pretty straightforward. Be aware, however, that
    the UI of [newsapi.org](http://newsapi.org) might have changed by the time you
    read this.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注册过程相当简单。然而，请注意，[newsapi.org](http://newsapi.org)的UI在你阅读此内容时可能已经改变。
- en: 'OK – let’s get that key:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——让我们获取这个密钥：
- en: Browse to [https://newsapi.org/](https://newsapi.org/).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到[https://newsapi.org/](https://newsapi.org/)。
- en: Click **Get** **API key**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**获取** **API密钥**。
- en: 'Fill out the form, as illustrated in the following screenshot:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示填写表格：
- en: "![Figure 4.9 – Register for API \uFEFFkey](img/Figure_4.9_B19214.jpg)"
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9 – 注册API密钥](img/Figure_4.9_B19214.jpg)'
- en: Figure 4.9 – Register for API key
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 – 注册API密钥
- en: 'Copy the API key provided on the next page, as illustrated in the following
    screenshot:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制下一页上提供的API密钥，如图所示：
- en: '![Figure 4.10 – Registration complete](img/Figure_4.10_B19214.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10 – 注册完成](img/Figure_4.10_B19214.jpg)'
- en: Figure 4.10 – Registration complete
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 – 注册完成](img/Figure_4.10_B19214.jpg)'
- en: 'Now, we need a place to store the key for easy access. We’ll create a static
    class that will hold the key for us. Proceed as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个地方来存储密钥以便于访问。我们将创建一个静态类来为我们保存密钥。按照以下步骤操作：
- en: In the `News` project, create a new class called `Settings` in the root folder.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目的根文件夹中创建一个名为`Settings`的新类。
- en: 'Add the code shown in the following snippet, replacing the placeholder text
    with the API key you obtained in the preceding steps:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码片段中的代码，将前面的步骤中获得的API密钥替换占位文本：
- en: '[PRE11]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The important thing here is that you copy and paste the key into the file. Now,
    we need models.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是将密钥复制并粘贴到文件中。现在，我们需要模型。
- en: A note on tokens and other secrets
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 关于令牌和其他秘密的说明
- en: This is not a recommended way to store an API key or any other token that should
    be secured in your app. To securely store tokens and other data, you should use
    **secure storage** (see [https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage))
    and obtain the data from a secure server, preferably gated by some form of user
    authentication. You could also require the user to provide the API key through
    a settings page – hint, hint.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是存储API密钥或其他应安全存储在应用中的令牌的推荐方式。为了安全地存储令牌和其他数据，你应该使用**安全存储**（见[https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage)）并从安全服务器获取数据，最好是通过某种形式的用户身份验证。你也可以要求用户通过设置页面提供API密钥——提示，提示。
- en: Creating the models
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'The data returned from the API needs to go somewhere, and the most convenient
    way of accessing it would be to deserialize the data into `Models`. Let’s create
    our models:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 从API返回的数据需要存储在某个地方，最方便的访问方式是将数据反序列化到`Models`中。让我们创建我们的模型：
- en: In the `News` project, create a new folder called `Models`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，创建一个名为`Models`的新文件夹。
- en: In the `Models` folder, add a new class called `NewsApiModels`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Models`文件夹中，添加一个名为`NewsApiModels`的新类。
- en: 'Add the following code to the class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE12]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `JsonPropertyName` attributes on each property allow the `System.Text.Json`
    deserializer to map the name from the JSON received from the web API into the
    C# object. When we call the API, the API will return a `NewsResult` object that
    will, in turn, contain a list of articles. The next step is to create a service
    that will wrap the API and allow us to access the latest news.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性的 `JsonPropertyName` 特性允许 `System.Text.Json` 反序列化器将来自Web API的JSON接收到的名称映射到C#对象中。当我们调用API时，API将返回一个
    `NewsResult` 对象，该对象将包含一系列文章。下一步是创建一个封装API并允许我们访问最新新闻的服务。
- en: Tip for creating POCO classes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 POCO 类的技巧
- en: If you ever need to create a class model out of a bunch of **JavaScript Object
    Notation** (**JSON**), you can use the **Paste JSON as Classes** tool in Visual
    Studio for Windows (**Edit** | **Paste Special** | **Paste JSON** **as Classes**).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从一大堆 **JavaScript Object Notation** (**JSON**) 创建一个类模型，你可以使用Windows Visual
    Studio中的 **Paste JSON as Classes** 工具（**编辑** | **粘贴特殊** | **粘贴JSON** **为类**）。
- en: Creating a service class
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务类
- en: The service class will wrap the API so that we can access it in a nice .NET-ish
    kind of way.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 服务类将封装API，以便我们可以以类似.NET的方式访问它。
- en: But we’ll start by defining an enum that will define the scope of the news that
    we request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们首先定义一个枚举，它将定义我们请求的新闻范围。
- en: Creating the NewsScope enum
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 NewsScope 枚举
- en: 'The `NewsScope` enum defines the different kinds of news that our service supports.
    Let’s add it by following these few steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewsScope` 枚举定义了我们服务支持的不同类型的新闻。让我们按照以下几个步骤添加它：'
- en: In the `News` project, create a new folder called `Services`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，创建一个新的文件夹，名为 `Services`。
- en: In the `Services` folder, add a new file called `NewsScope.cs`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中，添加一个名为 `NewsScope.cs` 的新文件。
- en: 'Add the following code to that file:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到该文件中：
- en: '[PRE13]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next step is to create the `NewsService` class that will wrap the call to
    the `News` API.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建将封装对 `News` API 调用的 `NewsService` 类。
- en: Creating the NewsService class
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 NewsService 类
- en: The purpose of the `NewsService` class is to wrap the HTTP calls to the news
    REST API and make them easily accessible to our code in the form of regular .NET
    method calls. To make it easier to replace the source of the news – for example,
    to use a mock in tests – we will use an interface.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewsService` 类的目的是封装对新闻REST API的HTTP调用，并使其以常规.NET方法调用的形式轻松访问我们的代码。为了更容易替换新闻的来源——例如，在测试中使用模拟——我们将使用一个接口。'
- en: 'To create the `INewsService` interface, follow these steps:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `INewsService` 接口，按照以下步骤操作：
- en: In the `Services` folder, create a new interface called `INewsService`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中，创建一个新的接口，名为 `INewsService`。
- en: 'Edit the interface so that it looks like this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑接口，使其看起来像这样：
- en: '[PRE14]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Creating the `NewsService` class is now quite straightforward. Follow these
    steps:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `NewsService` 类现在相当直接。按照以下步骤操作：
- en: In the `Services` folder, create a new class called `NewsService`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Services` 文件夹中，创建一个新的类，名为 `NewsService`。
- en: 'Edit the class so that it looks like this:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑类，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `NewsService` class is composed of five methods; I know there are technically
    eight, but we will get to that in a moment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewsService` 类由五个方法组成；我知道技术上应该有八个，但我们会稍后讨论这一点。'
- en: The first method, `GetNews`, is the method that we will eventually call from
    our app. It takes one parameter, `scope`, which is the enum that we created earlier.
    Depending on the value of this parameter, we will get different types of news.
    The first thing this method does is resolve the URL to call, and it does so by
    calling the `GetUrl` method with the scope.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法 `GetNews` 是我们将最终从我们的应用程序中调用的方法。它接受一个参数 `scope`，这是我们之前创建的枚举。根据此参数的值，我们将获得不同类型的新闻。此方法的第一件事是解析要调用的URL，它是通过调用带有范围的
    `GetUrl` 方法来完成的。
- en: The `GetUrl` method uses a switch expression to resolve the URL and, depending
    on the value of the scope parameter passed, returns one of three URLs. The URL
    points to the REST API of the `News` API with some predefined query parameters
    and the API key that we registered for.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetUrl` 方法使用 switch 表达式解析URL，并根据传递的 `scope` 参数的值返回三个URL之一。该URL指向 `News` API的REST
    API，其中包含一些预定义的查询参数和为我们注册的API密钥。'
- en: When we’ve resolved the correct URL, we are ready to make the HTTP request and
    download the news in the form of JSON. The built-in `HttpClient` class in .NET
    does a fine job of fetching the JSON for us. All that is left after acquiring
    the data is to deserialize it into the news models that we defined earlier.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解决了正确的URL后，我们就准备好发起HTTP请求并以JSON形式下载新闻。.NET内置的`HttpClient`类为我们很好地获取了JSON。在获取数据后，剩下的就是将其反序列化为我们之前定义的新闻模型。
- en: Let’s say a word or two about the remainder of the methods and the `HttpClient`
    class. `HttpClient` is now the recommended class to use when requesting data from
    the web. It is a much safer implementation than was previously available. It has
    been shipping with .NET 5+ and is available as a separate NuGet package for previous
    versions. With that, there are a few peculiarities when using `HttpClient`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简单谈谈剩余的方法和`HttpClient`类。`HttpClient`现在是请求网络数据时推荐的类。它是一个比之前可用的实现更安全的实现。它随.NET
    5+一起发货，并且可以作为单独的NuGet包用于旧版本。有了这个，使用`HttpClient`时有一些特殊之处。
- en: First, `HttpClient` can hold onto native resources, so it must be properly disposed
    of. To properly dispose of `HttpClient`, we need to derive from and implement
    `IDisposable`. This is the reason for the extra methods that are in the class,
    `Dispose(bool)` and `Dispose()`. All they do is make sure that the instance of
    `HttpClient` is disposed of properly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`HttpClient`会保留原生资源，因此必须正确地释放。为了正确地释放`HttpClient`，我们需要从`IDisposable`派生并实现它。这就是为什么在类中有额外的`Dispose(bool)`和`Dispose()`方法的原因。它们所做的只是确保`HttpClient`的实例被正确地释放。
- en: Second, `HttpClient` will pool those native resources, so it is recommended
    that you reuse an instance of `HttpClient` as much as possible. This is the reason
    for creating the `HttpClient` instance in the `NewsService` constructor.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`HttpClient`会池化这些原生资源，因此建议尽可能多地重用`HttpClient`的实例。这就是为什么在`NewsService`构造函数中创建`HttpClient`实例的原因。
- en: Final word – since the `GetFromJsonAsync` call can throw an exception and it
    is called from an `async` method, you must handle the exception; otherwise, it
    will be lost on the executing thread and your only indication that something is
    wrong will be the fact that you have no items. For this app, we are just going
    to create a `NewsResult` object that contains one `Article` that has the exception
    in it so that something is displayed. There are much better ways of handling errors,
    but this will do for this app.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的话 - 由于`GetFromJsonAsync`调用可能会抛出异常，并且它是在一个`async`方法中调用的，因此你必须处理这个异常；否则，它将在执行线程上丢失，而你唯一能意识到有问题的情况就是你没有项目。对于这个应用，我们只是创建一个包含一个有异常的`Article`的`NewsResult`对象，以便显示一些内容。处理错误有更好的方法，但这对这个应用来说已经足够了。
- en: The next step is to wire up the `NewsService` class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是连接`NewsService`类。
- en: Wiring up the NewsService class
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接`NewsService`类
- en: We are now ready to wire up the `NewsService` class in our app and integrate
    it with a real news source. We will extend all the existing `ViewModels` that
    we have and define the UI elements to be able to render the news in the `Views`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好在我们的应用中连接`NewsService`类，并将其与真实的新闻源集成。我们将扩展所有现有的`ViewModels`，并定义UI元素以在`Views`中渲染新闻。
- en: Extending the HeadlinesViewModel class
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展`HeadlinesViewModel`类
- en: 'In MVVM, `ViewModel` is the place to handle the logic of the app. The model
    is the news data that we will get from our `NewsService` class. We will now extend
    the `HeadlinesViewModel` class so that it uses `NewsService` to fetch news:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM中，`ViewModel`是处理应用逻辑的地方。模型是我们将从`NewsService`类中获取的新闻数据。我们现在将扩展`HeadlinesViewModel`类，使其使用`NewsService`来获取新闻：
- en: In the `News` project, expand the `ViewModels` folder and open the `HeadlinesViewModel.cs`
    file.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`News`项目中，展开`ViewModels`文件夹并打开`HeadlinesViewModel.cs`文件。
- en: 'Add the following code marked in bold and resolve the references:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下加粗的代码并解决引用：
- en: '[PRE16]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we are using (constructor) dependency injection, we need to inject our
    dependencies into the constructor. The only dependency this `ViewModel` has is
    `NewsService`, and we store it internally in the class as a field.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用（构造函数）依赖注入，我们需要将依赖注入到构造函数中。这个`ViewModel`唯一的依赖是`NewsService`，我们将其内部存储在类的字段中。
- en: The `CurrentNews` property is defined to get something to bind the UI to.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentNews`属性被定义为获取绑定UI的内容。'
- en: Then, we have two `Initialize` methods – one that takes `scope` as an enum and
    one that takes `scope` as a string. The string overload of the `Initialize` method
    will be used in XAML. It simply translates the string into the enum representation
    of `scope` and then calls the other `Initialize` method, which, in turn, calls
    the `GetNews(...)` method on the news service.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有两个 `Initialize` 方法——一个接受 `scope` 作为枚举，另一个接受 `scope` 作为字符串。字符串重载的 `Initialize`
    方法将在 XAML 中使用。它只是将字符串转换为 `scope` 的枚举表示形式，然后调用另一个 `Initialize` 方法，该方法反过来调用新闻服务上的
    `GetNews(...)` 方法。
- en: The property at the end, `ItemSelected`, returns a .NET MAUI command that we
    will wire up to respond to when the user of the app selects an item. Half of the
    method is implemented from the start. The selected item will be passed into the
    method. Then, we encode the URL to the article since we will be passing it as
    a query parameter when we navigate within the app. We will get back to the navigation
    part in a while.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个属性 `ItemSelected` 返回一个 .NET MAUI 命令，我们将将其连接到当应用程序用户选择一个项目时响应的事件。方法的一半从一开始就实现了。所选的项目将被传递到方法中。然后，我们编码文章的
    URL，因为我们将在应用程序内导航时将其作为查询参数传递。我们稍后会回到导航部分。
- en: If you are curious about the `ObservableProperty` and `RelayCommand` attributes,
    refresh your memory by reviewing *Chapter 2*, *Building Our First .NET* *MAUI
    App*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇关于 `ObservableProperty` 和 `RelayCommand` 属性，可以通过回顾 *第2章*，*构建我们的第一个 .NET*
    *MAUI 应用程序* 来刷新你的记忆。
- en: Now that we have the code to fetch the data, we’ll move on to defining the UI
    to display it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了获取数据的代码，接下来我们将转向定义用于显示数据的用户界面。
- en: Extending HeadlinesView
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 `HeadlinesView`
- en: '`HeadlinesView` is a shared view that will be used in several places in the
    app. The purpose of this view is to display a list of articles and to allow for
    navigation from one article into a web browser that will display the entire article.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadlinesView` 是一个共享视图，将在应用程序的几个地方使用。这个视图的目的是显示文章列表，并允许用户从一个文章导航到显示整个文章的网页浏览器。'
- en: 'To extend `HeadlinesView` we must do two things – first, must we edit the XAML
    and define the UI; then, we need to add some code to initialize it. Proceed as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展 `HeadlinesView`，我们必须做两件事——首先，我们必须编辑 XAML 并定义 UI；然后，我们需要添加一些代码来初始化它。按照以下步骤进行：
- en: In the `News` project, expand the `Views` folder and open the `HeadlinesView.xaml`
    file.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，展开 `Views` 文件夹并打开 `HeadlinesView.xaml` 文件。
- en: 'Edit the XAML, as shown in the following code block:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 XAML，如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`HeadlinesView` uses `CollectionView` to display the list of articles. The
    `ItemsSource` property is set to the `CurrentNews.Articles` property of `ViewModel`,
    which, after loading news, should contain a list of news. While the list is empty
    or loading, we display a loading label, defined within the `CollectionView.EmptyView`
    element. You could, of course, create any valid UI inside of that tag to create
    a cooler loading screen.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`HeadlinesView` 使用 `CollectionView` 来显示文章列表。`ItemsSource` 属性设置为 `ViewModel`
    的 `CurrentNews.Articles` 属性，在加载新闻后，应该包含一个新闻列表。当列表为空或正在加载时，我们将在 `CollectionView.EmptyView`
    元素内显示一个加载标签。当然，你可以在该标签内创建任何有效的 UI 来创建一个更酷的加载界面。'
- en: Each article in the `CurrentNews.Articles` list will be rendered using whatever
    is inside the `CollectionView.ItemTemplate` element, and it’s what’s inside of
    the `ContentView` element that will represent the actual item. The article will
    be rendered using an `ArticleItem` view, which is a custom control that we defined
    earlier. We will define this view after we are done with this view.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`CurrentNews.Articles` 列表中的每一篇文章都将使用 `CollectionView.ItemTemplate` 元素内部的内容进行渲染，而
    `ContentView` 元素内部的内容将代表实际的项目。文章将通过一个 `ArticleItem` 视图进行渲染，这是一个我们之前定义的自定义控件。我们将在完成这个视图后定义这个视图。'
- en: To enable navigation from the view, we need to detect when a user clicks on
    a specific article. We can do so by adding `TapGestureRecognizer` and binding
    it to the `ItemSelectedCommand` property of the root `ViewModel`. The `Source={x:Reference
    headlinesview}}` snippet is what references the current context back to the root
    of the page, not the current article in the list that we are iterating. If we
    didn’t specify the source, the binding engine would try to bind the `ItemSelectedCommand`
    property to a property defined in the current article of the `CurrentNews.Articles`
    property.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用从视图的导航，我们需要检测用户何时点击特定的文章。我们可以通过添加 `TapGestureRecognizer` 并将其绑定到根 `ViewModel`
    的 `ItemSelectedCommand` 属性来实现。`Source={x:Reference headlinesview}}` 这段代码是引用当前上下文回到页面的根，而不是我们正在迭代的列表中的当前文章。如果我们没有指定源，绑定引擎将尝试将
    `ItemSelectedCommand` 属性绑定到在 `CurrentNews.Articles` 属性中定义的当前文章的属性。
- en: 'That’s all for the GUI part. Now, we need to alter the code-behind to enable
    initialization based on data that we will pass from the XAML itself. Follow these
    steps to make it happen:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 部分就到这里。现在，我们需要修改代码背后的部分，以便根据我们从 XAML 本身传递的数据进行初始化。按照以下步骤进行操作以实现这一点：
- en: In the `News` project, open the `HeadlinesView.xaml.cs` code-behind file.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `HeadlinesView.xaml.cs` 代码背后的文件。
- en: 'Add the following code marked in bold to the file:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗的代码添加到文件中：
- en: '[PRE18]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Usually, we don’t want to add code to the code-behind of a view directly, but
    we need to make an exception so that arguments can be passed from XAML to our
    `ViewModel`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不想直接在视图的代码背后添加代码，但我们需要做出例外，以便可以将参数从 XAML 传递到我们的 `ViewModel`。
- en: Based on the routing information that was used to create the view, we will initialize
    `ViewModel` differently. The `GetScopeFromRoute` method will parse the location
    information from `Shell` to determine which scope is used to query the news service.
    Then, we can call a private method that creates an instance of `HeadlinesViewModel`
    for us, sets it as the binding context of the view, and calls the `Initialize()`
    method on `ViewModel`, which makes the REST call to the `News` API. We will define
    the routes when we edit the shell file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 根据创建视图所使用的路由信息，我们将以不同的方式初始化 `ViewModel`。`GetScopeFromRoute` 方法将解析 `Shell` 中的位置信息以确定用于查询新闻服务的范围。然后，我们可以调用一个私有方法为我们创建
    `HeadlinesViewModel` 的实例，将其设置为视图的绑定上下文，并在 `ViewModel` 上调用 `Initialize()` 方法，这会向
    `News` API 发起 REST 调用。我们将在编辑 shell 文件时定义路由。
- en: But first, we need to extend `ContentView` of `ArticleItem` so that it displays
    a single-row item in the news lists.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要扩展 `ArticleItem` 的 `ContentView` 以显示新闻列表中的单行项。
- en: Extending ContentView of ArticleItem
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 ArticleItem 的 ContentView
- en: '`ContentView` of `ArticleItem` represents one item in a list of news, as shown
    in the following screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArticleItem` 的 `ContentView` 代表新闻列表中的一个条目，如图中所示：'
- en: '![Figure 4.11 – A sample news item](img/Figure_4.11_B19214.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 一个示例新闻条目](img/Figure_4.11_B19214.jpg)'
- en: Figure 4.11 – A sample news item
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 一个示例新闻条目
- en: 'To create the layout shown in *Figure 4**.11*, we will use a `Grid` control.
    Follow these steps to create the layout:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建如图 *图 4*.11 所示的布局，我们将使用 `Grid` 控件。按照以下步骤创建布局：
- en: In the `News` project, expand the `Views` folder and open the `ArticleItem.xaml`
    file.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，展开 `Views` 文件夹并打开 `ArticleItem.xaml` 文件。
- en: 'Edit the XAML code, as shown in the following code block:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑以下代码块中的 XAML 代码：
- en: '[PRE19]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding XAML code defines a grid layout with two columns and five rows.
    The `Grid.Row` and `Grid.Column` attributes position child elements into the grid,
    while the `Grid.ColumnSpan` attribute allows for a control to span multiple columns.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 XAML 代码定义了一个具有两列和五行的网格布局。`Grid.Row` 和 `Grid.Column` 属性将子元素定位到网格中，而 `Grid.ColumnSpan`
    属性允许控件跨越多个列。
- en: A rounded image can be achieved using a `Border` element with `StrokeShape="RoundRectangle
    15,15,15,15"` specified in conjunction with the `Image` `Aspect` attribute set
    to `AspectFill`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有 `StrokeShape="RoundRectangle 15,15,15,15"` 的 `Border` 元素，并设置 `Image` 的
    `Aspect` 属性为 `AspectFill`，可以创建一个圆形图像。
- en: Strings in labels can be formatted directly in the binding statement. Check
    out the `Text="{Binding PublishedAt, StringFormat='{0:MMMM d, yyyy}'}"` line of
    code, which formats a date into a specific string format.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 标签中的字符串可以直接在绑定语句中格式化。查看 `Text="{Binding PublishedAt, StringFormat='{0:MMMM d,
    yyyy}'}"` 这行代码，它将日期格式化为特定的字符串格式。
- en: Lastly, the gray divider line is `BoxView` at the end of the XAML code.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，灰色分隔线是 XAML 代码末尾的 `BoxView`。
- en: Now that we have created `NewsService` and fixed all its related views, it’s
    time to make use of them.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了 `NewsService` 并修复了所有相关视图，是时候使用它们了。
- en: Adding to dependency injection
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到依赖注入
- en: 'Since `HeadlinesViewModel` depends on `INewsService`, we need to register it
    in our dependency injection container (please see the *Wiring up dependency injection*
    section in *Chapter 2* for more details on dependency injection in .NET MAUI).
    Follow these steps to do so:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `HeadlinesViewModel` 依赖于 `INewsService`，我们需要在我们的依赖注入容器中注册它（请参阅 *第 2 章* 中的
    *连接依赖注入* 部分，了解更多关于 .NET MAUI 中依赖注入的细节）。按照以下步骤进行操作：
- en: In the `News` project, open the `MauiProgram.cs` file.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `MauiProgram.cs` 文件。
- en: 'Locate the `RegisterAppTypes()` method and add the following line marked in
    bold:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 `RegisterAppTypes()` 方法并添加以下加粗的行：
- en: '[PRE20]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will allow for the dependency injection of `NewsService`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许进行 `NewsService` 的依赖注入。
- en: Adding a ContentTemplate attribute
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 `ContentTemplate` 属性
- en: 'So far, we only have placeholder code in our `AppShell` file. Let’s replace
    this with actual content, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的 `AppShell` 文件中只有占位符代码。让我们用实际内容替换它，如下所示：
- en: In the `News` project, open `AppShell.xaml`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `AppShell.xaml`。
- en: Locate the `FlyoutItem` element with the title set to `Home`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到标题设置为 `Home` 的 `FlyoutItem` 元素。
- en: 'Edit the XAML so that the `ShellContent` element becomes self-closing, add
    the following `ContentTemplate` attribute marked in bold, and replace the contents
    of the `Tab` element:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 XAML，使 `ShellContent` 元素成为自闭合的，添加以下加粗的 `ContentTemplate` 属性，并替换 `Tab` 元素的全部内容：
- en: '[PRE21]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Two things are going on here. The first is that we specify the content of `ShellContent`
    using the `ContentTemplate` attribute. This means that we point to the type of
    view that we want to have created when the shell becomes visible. Usually, you
    want to defer the creation of a view until right before it is going to be displayed,
    and the `ContentTemplate` attribute gives you that. Notice that the `Route` attribute
    for that `FlyoutItem` is set to `headlines`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事情在进行。第一件事是我们使用 `ContentTemplate` 属性指定 `ShellContent` 的内容。这意味着我们指向当壳可见时要创建的视图类型。通常，你希望在即将显示之前才创建视图，而
    `ContentTemplate` 属性就提供了这个功能。注意，那个 `FlyoutItem` 的 `Route` 属性被设置为 `headlines`。
- en: The second thing is that we have the same thing going on below for the `Local`
    and `Global` news but instead using the `local` and `global` routes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事是对于 `Local` 和 `Global` 新闻，我们在下面做同样的事情，但使用的是 `local` 和 `global` 路由。
- en: 'If you run the app at this point, you should end up with something that looks
    like the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个应用，你应该得到以下截图所示的内容：
- en: '![Figure 4.12 – The main list view](img/Figure_4.12_B19214.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 主要列表视图](img/Figure_4.12_B19214.jpg)'
- en: Figure 4.12 – The main list view
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 主要列表视图
- en: The last thing we need to implement is how we can view the articles when we
    tap on the item in the list.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一件事是在我们点击列表中的项目时如何查看文章。
- en: Handling navigation
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理导航
- en: We are on the home stretch now for this app. The only thing we need to do is
    implement navigation to the article view, which will display the entire article
    in a web view. Since we are using Shell, we will be navigating using routes. Routes
    can be registered directly in the Shell markup – for example, in the `AppShell.xaml`
    file. We can do this by using `Route` attributes on the `ShellContent` elements,
    as we did in the previous section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在离这个应用完成只剩下最后一步了。我们唯一需要做的是实现导航到文章视图，该视图将在网页中显示整个文章。由于我们使用 Shell，我们将使用路由进行导航。路由可以直接在
    Shell 标记中注册 – 例如，在 `AppShell.xaml` 文件中。我们可以通过在 `ShellContent` 元素上使用 `Route` 属性来实现，就像我们在上一节中所做的那样。
- en: In the following code, we will add a route programmatically and register a view
    to handle it for us. We will also create a navigation service to abstract the
    concept of navigation a bit.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将以编程方式添加一个路由并注册一个视图来为我们处理它。我们还将创建一个导航服务来抽象化导航的概念。
- en: So, buckle up, and let’s finish this app!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，系好安全带，让我们完成这个应用！
- en: Creating the navigation service
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建导航服务
- en: The first step is to define an interface that will wrap .NET MAUI navigation.
    Why do we do this? Well, it’s a good practice to separate the interfaces from
    the implementation; it makes unit testing easier, and so on.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义一个将包装 .NET MAUI 导航的接口。我们为什么要这样做呢？因为将接口与实现分离是一种良好的实践；这使得单元测试更容易，等等。
- en: Creating the INavigation interface
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 `INavigation` 接口
- en: The `INavigation` interface is simple, and we will overshoot the target a little
    bit. We are only interested in the `NavigateTo` method, but we will add the `PushModal()`
    and `PopModal()` methods since it is likely that you will use them if you continue
    extending the app.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`INavigation` 接口很简单，我们可能会稍微超出目标。我们只对 `NavigateTo` 方法感兴趣，但我们会添加 `PushModal()`
    和 `PopModal()` 方法，因为如果你继续扩展应用程序，你可能会用到它们。'
- en: 'Adding the navigation interface is simple, as the following steps illustrate:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 添加导航接口很简单，以下步骤将说明：
- en: In the `News` project, expand the `ViewModels` folder and add a new file called
    `INavigate.cs`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，展开 `ViewModels` 文件夹，并添加一个名为 `INavigate.cs` 的新文件。
- en: 'Add the following code to the file:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中：
- en: '[PRE22]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `NavigateTo()` method declaration takes the route we want to navigate to.
    This is the method that we will be calling. The `PushModal()` method adds a new
    page on top of the navigation stack as a modal page, forcing the user only to
    interact with this specific page. The `PopModal()` method removes it from the
    navigation stack. So, if you use the `PushModal()` method, make sure that you
    give the user a way to pop it off the stack.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavigateTo()` 方法的声明接受我们想要导航到的路由。这是我们将会调用的方法。`PushModal()` 方法在导航堆栈顶部添加一个新的页面作为模态页面，强制用户只能与这个特定的页面进行交互。`PopModal()`
    方法将其从导航堆栈中移除。所以，如果你使用 `PushModal()` 方法，确保你给用户一个方法来将其从堆栈中移除。'
- en: Otherwise, you will be stuck viewing the modal page forever.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你将永远卡在查看模态页面。
- en: That’s all for the interface. Let’s create an implementation using .NET MAUI
    Shell.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接口部分就到这里。让我们使用 .NET MAUI Shell 创建一个实现。
- en: Implementing the INavigate interface using .NET MAUI Shell
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI Shell 实现 `INavigate` 接口
- en: The implementation is very straightforward since each method is only calling
    .NET MAUI static methods provided by the Shell API.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实现非常直接，因为每个方法都只是调用由 Shell API 提供的 .NET MAUI 静态方法。
- en: 'Create the `Navigator` class, as shown in the following steps:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建 `Navigator` 类：
- en: In the `News` project, add a new class called `Navigator`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，添加一个名为 `Navigator` 的新类。
- en: 'Add the following code to the class:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE23]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is simply pass-through code that calls already existing methods. Now, we
    need to register the type with our dependency injection container so that it can
    be consumed by the `ViewModel` class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单的透传代码，调用已经存在的方法。现在，我们需要将类型注册到我们的依赖注入容器中，以便它可以被 `ViewModel` 类消费。
- en: Registering the Navigator class with dependency injection
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用依赖注入注册 `Navigator` 类
- en: 'For the `ViewModel` class and its descendants to have access to the `Navigator`
    instance, we will have to register it with the container, just like we did with
    `NewService`; just follow these steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 `ViewModel` 类及其派生类能够访问 `Navigator` 实例，我们必须将其注册到容器中，就像我们之前对 `NewService`
    所做的那样；只需按照以下步骤操作：
- en: In the `News` project, open the `MauiProgram.cs` file.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `MauiProgram.cs` 文件。
- en: 'Find the `RegisterAppTypes` method and add the following highlighted code:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `RegisterAppTypes` 方法，并添加以下突出显示的代码：
- en: '[PRE24]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we can add the `INavigate` interface to the `ViewModel` class and its descendants.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将 `INavigate` 接口添加到 `ViewModel` 类及其派生类中。
- en: Adding the INavigate interface to the ViewModel class
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 INavigate 接口添加到 ViewModel 类
- en: 'To be able to access `Navigator`, we must extend the `ViewModel` base class,
    making it available to all `ViewModels`. Proceed as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问 `Navigator`，我们必须扩展 `ViewModel` 基类，使其对所有 `ViewModels` 可用。按照以下步骤操作：
- en: In the `News` project, open the `ViewModels` folder, and then open the `ViewModel.cs`
    file.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `News` 项目中，打开 `ViewModels` 文件夹，然后打开 `ViewModel.cs` 文件。
- en: 'Add the following highlighted code to the class:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到类中：
- en: '[PRE25]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open the `HeadlinesViewModel.cs` file and make the highlighted changes to the
    constructor:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `HeadlinesViewModel.cs` 文件，并对构造函数进行突出显示的更改：
- en: '[PRE26]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The base `ViewModel` now exposes the `Navigator` property through the `INavigate`
    interface. At this point, we are ready to wire up the navigation to our `Article`
    view.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 `ViewModel` 现在通过 `INavigate` 接口公开了 `Navigator` 属性。到这一点，我们就准备好将导航连接到我们的 `Article`
    视图了。
- en: Navigating using routes
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用路由进行导航
- en: Routes are a very handy way to navigate since they abstract the creation of
    the page away. All we need to know is the route to the view we want to navigate
    to – .NET MAUI Shell takes care of the rest for us. If you are familiar with how
    web navigation works, you might recognize the way that we pass arguments in routes.
    They are passed as query parameters.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是导航的一个非常方便的方法，因为它们抽象了页面创建的过程。我们只需要知道我们想要导航到的视图的路由 - .NET MAUI Shell 会为我们处理其余的事情。如果你熟悉网络导航的工作方式，你可能会认出我们在路由中传递参数的方式。它们作为查询参数传递。
- en: Finalizing the ItemSelected command
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成ItemSelected命令
- en: 'Previously, we defined the `ItemSelected` method in the `HeadlinesViewModel`
    class. Now, it’s time to add code that will perform the navigation to `ArticleView`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在 `HeadlinesViewModel` 类中定义了 `ItemSelected` 方法。现在，是时候添加将执行导航到 `ArticleView`
    的代码了：
- en: In the `News` project, expand the `ViewModels` folder and open `HeadlinesViewModel.cs`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新闻` 项目中，展开 `ViewModels` 文件夹并打开 `HeadlinesViewModel.cs`。
- en: 'Locate the `ItemSelected` method and add the following line marked in bold:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 `ItemSelected` 方法并添加以下加粗的行：
- en: '[PRE27]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we define a route called `articleview` that takes a query-line parameter
    called `url` that points to the URL of the article itself. It will look something
    like this: `articleview?url=www.mypage.com`. Only the data passed after the `url=`
    argument must be `HttpUtility.UrlEncode()` method, which is defined in `System.Web`
    for us.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `articleview` 的路由，它接受一个名为 `url` 的查询行参数，该参数指向文章本身的 URL。它看起来可能像这样：`articleview?url=www.mypage.com`。只有传递给
    `url=` 参数之后的数据必须使用 `HttpUtility.UrlEncode()` 方法进行编码，该方法由 `System.Web` 为我们定义。
- en: The preceding `NavigateTo()` method call uses this encoded data in the query
    parameter. On the recipient side of the navigation call, we need to handle the
    incoming `url` parameter.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `NavigateTo()` 方法调用使用查询参数中的此编码数据。在导航调用的接收端，我们需要处理传入的 `url` 参数。
- en: Extending ArticleView so that it receives query data
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扩展 ArticleView 以接收查询数据
- en: '`ArticleView` is responsible for rendering the article for us. To keep things
    simple (and also illustrate that you don’t always need `ViewModel`), we will not
    define `ViewModel` for this class; instead, we will define `BindingContext` as
    an instance of the `UrlWebViewSource` class.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArticleView` 负责为我们渲染文章。为了保持简单（并且说明你并不总是需要 `ViewModel`），我们不会为这个类定义 `ViewModel`；相反，我们将定义
    `BindingContext` 为 `UrlWebViewSource` 类的一个实例。'
- en: 'Add the following code to the `ArticleView.xaml.cs` file:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `ArticleView.xaml.cs` 文件中：
- en: In the `News` project, expand the `Views` folder and open the `ArticleView.xaml.cs`
    file.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新闻` 项目中，展开 `视图` 文件夹并打开 `ArticleView.xaml.cs` 文件。
- en: 'Add the following code marked in bold to the file:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗的代码添加到文件中：
- en: '[PRE28]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`ArticleView` is dependent on a URL being set, and we do so by defining a set-only
    property called `Url`. When this property is set, it creates a new instance of
    `UrlWebViewSource` with the value of the property and assigns it to the page’s
    `BindingContext`. This setter is called by the Shell framework since we added
    an attribute called `QueryProperty` to the class itself. It takes two arguments
    – the first is which property to set, while the second is the name of the `url`
    query parameter.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArticleView` 依赖于一个已设置的 URL，我们通过定义一个只读属性 `Url` 来实现这一点。当此属性被设置时，它将创建一个新的 `UrlWebViewSource`
    实例，并将属性值赋给它，然后将其分配给页面的 `BindingContext`。这个设置器是由 Shell 框架调用的，因为我们向类本身添加了一个名为 `QueryProperty`
    的属性。它接受两个参数 - 第一个是设置哪个属性，第二个是 `url` 查询参数的名称。'
- en: Since the data comes URL encoded, we need to decode it using the `HttpUtility.UrlDecode()`
    method.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是 URL 编码的，我们需要使用 `HttpUtility.UrlDecode()` 方法对其进行解码。
- en: With that, we have a binding context that points to the web page we want to
    display. Now, we just need to define `WebView` in the XAML.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有一个指向我们想要显示的网页的绑定上下文。现在，我们只需要在 XAML 中定义 `WebView`。
- en: Extending ArticleView with WebView
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过 WebView 扩展 ArticleView
- en: 'This page only has one purpose, and that is to display the web page from the
    URL that we passed to it. Let’s add a `WebView` control to the page, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面只有一个目的，那就是显示我们传递给它的 URL 中的网页。让我们在页面上添加一个 `WebView` 控件，如下所示：
- en: In the `News` project, expand the `Views` folder and open `ArticleView.xaml`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新闻` 项目中，展开 `视图` 文件夹并打开 `ArticleView.xaml`。
- en: 'Add the following highlighted XAML:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下突出显示的 XAML：
- en: '[PRE29]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `WebView` control will take up all available space in the view. The source
    will be set to `.`, meaning that it will be the same as the `BindingContext` property
    of `ViewModel`. In this case, the `BindingContext` property is a `UrlWebViewSource`
    instance, which is exactly what `WebView` needs to navigate and display the content.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebView` 控件将占据视图中的所有可用空间。源设置为 `.`，这意味着它与 `ViewModel` 的 `BindingContext` 属性相同。在这种情况下，`BindingContext`
    属性是一个 `UrlWebViewSource` 实例，这正是 `WebView` 需要导航和显示内容所需的。'
- en: We’ve only got one step left – our app needs to know about the `ArticleView`
    route and what to do with it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一步了——我们的应用需要了解 `ArticleView` 路由以及如何处理它。
- en: Registering the route
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册路由
- en: 'As mentioned previously, routes can be added declaratively in the XAML (`Route="MyDucks"`)
    or code, as shown here:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，路由可以在 XAML 中声明性添加（`Route="MyDucks"`）或通过代码添加，如下所示：
- en: In the `News` project, open the `AppShell.xaml.cs` file.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `新闻` 项目中，打开 `AppShell.xaml.cs` 文件。
- en: 'Add the following lines of code marked in bold:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下加粗的代码行：
- en: '[PRE30]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `RegisterRoute()` method takes two arguments – the first is the route we
    want to use, and it’s the one that we specify in the `NavigateTo()` calls. The
    second is the type of page (view) that we want to create – in our case, we want
    to create `ArticleView`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterRoute()` 方法接受两个参数——第一个是我们想要使用的路由，这是我们指定在 `NavigateTo()` 调用中的路由。第二个是我们想要创建的页面（视图）的类型——在我们的例子中，我们想要创建
    `ArticleView`。'
- en: Cool! That wraps it up. The app should now run, and you should be able to navigate
    to the article from any of your `CollectionViews`. Good work!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这就完成了。应用现在应该可以运行，你应该能够从你的 `CollectionViews` 中导航到文章。干得好！
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to define a navigation structure using .NET
    MAUI Shell, how to navigate to views using routes, and how to pass arguments between
    views in the form of a query string. There is a lot more to Shell, but this should
    get you started and confident enough to start exploring the Shell APIs. Also,
    keep in mind that the Shell APIs are constantly evolving, so make sure you check
    out the latest features available.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 .NET MAUI Shell 定义导航结构，如何使用路由导航到视图，以及如何以查询字符串的形式在视图之间传递参数。Shell还有很多内容，但这应该能让你开始并足够自信地探索
    Shell API。此外，请记住，Shell API 正在不断发展，确保查看最新的功能。
- en: We also learned how to create an API client for an arbitrary REST API, which
    always comes in handy since most of the apps you will write need to communicate
    with a server at some point. There is a very good chance that the server will
    expose its data and functionality through a REST API.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何为任意 REST API 创建 API 客户端，这在编写大多数应用时非常有用，因为大多数应用都需要在某个时候与服务器通信。有很大可能性，服务器将通过
    REST API 公开其数据和功能。
- en: If you are interested in extending the app even further, try designing your
    own `News` API key to be set through the settings.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，想进一步扩展应用，尝试设计自己的 `News` API 密钥，并通过设置进行设置。
- en: The next project will be about creating a match-making app, and how to create
    a swiping-enabled yes/no image selector app using nothing but .NET MAUI to render
    and animate cross-platform UI controls.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个项目将关于创建一个匹配应用，以及如何仅使用 .NET MAUI 渲染和动画跨平台 UI 控件来创建一个带有滑动功能的是/否图片选择应用。
