- en: 18 Request-EndPoint-Response (REPR) and Minimal APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 请求-端点-响应 (REPR) 和最小 API
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开始之前：加入我们的 Discord 书籍社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的 Discord 服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，位于“EARLY
    ACCESS SUBSCRIPTION”下）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file120.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file120.png)'
- en: This chapter introduces the **Request-EndPoint-Response (REPR)** pattern, which
    builds on top of Vertical Slice Architecture and CQS. We continue to simplify
    our codebase to make it even more readable, maintainable, and less abstract, yet
    still testable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 **请求-端点-响应 (REPR)** 模式，该模式建立在垂直切片架构和 CQS 之上。我们继续简化我们的代码库，使其更加易于阅读、维护，并且更少抽象，同时仍然可测试。
- en: We pronounce REPR like “reaper”, which sounds way better than “rer” or “reper”.
    I must credit Steve "ardalis" Smith for this outstanding pattern name. I left
    a link to his article in the *Further reading* section.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将 REPR 发音为“reaper”，这比“rer”或“reper”听起来要好得多。我必须感谢 Steve "ardalis" Smith 为这个出色的模式名称。我在
    *进一步阅读* 部分留下了一个链接到他的文章。
- en: We leveraged this pattern already, possibly without you knowing about its name.
    Now it is time to formally introduce it, then assemble a technology stack to make
    it scalable for a real-world application.We build that solution, then improve
    it during the chapter to make it better by exploring manual techniques, existing
    tools, and open-source libraries. The result is not perfect, but we are not done
    improving this new e-commerce-inspired solution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了这个模式，可能你并不知道它的名字。现在是时候正式介绍它了，然后组装一个技术栈，使其适用于现实世界的应用。我们构建了这个解决方案，然后在章节中通过探索手动技术、现有工具和开源库来改进它。结果并不完美，但我们还没有完成对这个新的受电子商务启发的解决方案的改进。
- en: The key to this approach is learning to think about architecture and improve
    your design skills, so you have the tools to overcome the unique challenges the
    real world will throw at you!
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个方法的关键是学习如何思考架构并提高你的设计技能，这样你就有工具来克服现实世界将向你抛出的独特挑战！
- en: 'In this chapter, we cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Request-EndPoint-Response (REPR) pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求-端点-响应 (REPR) 模式
- en: Project – REPR—A slice of the real-world
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 – REPR—现实世界的一块
- en: Let's explore the pattern before jumping into a more hands-on example.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究更实际的示例之前，让我们先探索这个模式。
- en: Request-EndPoint-Response (REPR) pattern
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求-端点-响应 (REPR) 模式
- en: The Request-EndPoint-Response (REPR) pattern offers a simple approach similar
    to what we explored in Vertical Slice Architecture which deviates from the traditional
    Model-View-Controller (MVC) pattern. As we explored in the MVC Chapter, REST APIs
    don't have views, so we have to distort the concept to make it work. REPR is more
    appropriate than MVC for building REST APIs in the context of HTTP since each
    URL is a way to describe how to reach an endpoint (execute an operation), not
    a controller.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请求-端点-响应 (REPR) 模式提供了一种简单的方法，类似于我们在垂直切片架构中探索的方法，它与传统模型-视图-控制器 (MVC) 模式不同。正如我们在
    MVC 章节中探讨的那样，REST API 没有视图，因此我们必须扭曲这个概念才能使其工作。由于每个 URL 都是一种描述如何到达端点（执行操作）的方式，而不是控制器，因此
    REPR 在 HTTP 上下文中构建 REST API 比 MVC 更为合适。
- en: Goal
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: REPR aims to align our REST APIs to HTTP and treat the inherent request-response
    concept being the web as a first-class citizen in our application design.On top
    of this, the REPR pattern using Minimal APIs is well-aligned with Vertical Slice
    Architecture and facilitates building feature-oriented software instead of layer-heavy
    applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: REPR 的目标是使我们的 REST API 与 HTTP 对齐，并将固有的请求-响应概念作为我们应用程序设计中的第一公民。在此基础上，使用最小 API
    的 REPR 模式与垂直切片架构很好地对齐，并有助于构建面向功能的软件而不是层状应用。
- en: Design
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计
- en: 'REPR has three components:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: REPR 有三个组件：
- en: A request that contains the required information for the endpoint to do its
    work and plays the role of an input DTO.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含端点执行工作所需信息的请求，并扮演输入 DTO 的角色。
- en: An endpoint handler containing the business logic to execute, which is the central
    piece of this pattern.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含要执行的业务逻辑的端点处理器，这是这个模式的核心部分。
- en: A response that the endpoint returns to the client and plays the role of an
    output DTO.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个端点返回给客户端的响应，并扮演输出 DTO 的角色。
- en: 'You can treat each request as a *Query* or a *Command* as we explore in the
    CQS and Vertical Slice Architecture chapters.Here''s a diagram that represents
    this concept:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将每个请求视为我们在CQS和垂直切片架构章节中探索的*查询*或*命令*。以下是一个表示此概念的图表：
- en: '![Figure 18.1: a diagram representing the logical flow and the REPR pattern.](img/file121.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图18.1：表示逻辑流程和REPR模式的图。](img/file121.png)'
- en: 'Figure 18.1: a diagram representing the logical flow and the REPR pattern.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：表示逻辑流程和REPR模式的图。
- en: The preceding diagram should sound familiar since it resembles what we explored
    in the Vertical Slice Architecture. However, instead of Request-Handler-Result,
    we use Request-Endpoint-Response (a.k.a. REPR).Bottom line, a request can be a
    Query or a Command, then it hits the endpoint that executes the logic and finally
    returns a response.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表应该听起来很熟悉，因为它与我们探索的垂直切片架构相似。然而，我们使用的是请求-处理程序-结果（即REPR），而不是请求-处理程序-结果。简而言之，一个请求可以是查询或命令，然后它击中执行逻辑的端点，最后返回一个响应。
- en: The server returns an HTTP response even when the response’s body is empty.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使响应体为空，服务器也会返回HTTP响应。
- en: Let’s explore an example using Minimal API.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用Minimal API来探索一个示例。
- en: Project – SimpleEndpoint
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目 – SimpleEndpoint
- en: The SimpleEndpoint project showcases a few simple features and patterns to organize
    our REPR features without dependencies on external libraries.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleEndpoint项目展示了几个简单的功能和模式，用于组织我们的REPR功能，而不依赖于外部库。
- en: 'Feature: ShuffleText'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能：ShuffleText
- en: 'The first feature gets a string as input, shuffles its content, and returns
    it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个功能接收一个字符串作为输入，打乱其内容，然后返回它：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code leverages the `Random` API and shuffles the `request.Text`
    property then returns the results wrapped in a `Response` object.Before executing
    our feature, we must create a minimal API map and register our handler with the
    container. Here’s the Program.cs class that achieves this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码利用`Random` API打乱`request.Text`属性，然后返回封装在`Response`对象中的结果。在执行我们的功能之前，我们必须创建一个最小的API映射，并将我们的处理程序注册到容器中。以下是实现此功能的`Program.cs`类：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code registers the `ShuffleText.Endpoint` as a singleton so we
    can inject it in the delegate. The delegate leverages the `[AsParameters]` attribute
    to bind the route parameter to the `ShuffleText.Request` property. Finally, the
    logic is straightforward; the endpoint delegate sends the request to the injected
    endpoint handler and returns the result, which ASP.NET Core serializes to JSON.When
    we send the following HTTP request:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`ShuffleText.Endpoint`注册为单例，这样我们就可以将其注入到委托中。委托利用`[AsParameters]`属性将路由参数绑定到`ShuffleText.Request`属性。最后，逻辑很简单；端点委托将请求发送到注入的端点处理程序，并返回结果，ASP.NET
    Core将其序列化为JSON。当我们发送以下HTTP请求时：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We receive some gibberish results similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一些类似以下内容的乱码结果：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This pattern is close to the simplest we can get out of the box. Next, we encapsulate
    the endpoint itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式是我们能从盒子里得到的简单模式之一。接下来，我们将端点本身封装起来。
- en: 'Feature: RandomNumber'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能：RandomNumber
- en: 'This feature generates a number of random numbers between a minimum and a maximum.The
    first pattern divided the code between the `Program.cs` file and the feature itself.
    In this pattern, we encapsulate the endpoint delegate into the feature (same file
    in this case):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在最小值和最大值之间生成多个随机数。第一个模式将代码在`Program.cs`文件和功能本身之间划分。在这个模式中，我们将端点委托封装到功能中（在这种情况下是同一文件）：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code is very similar to the first feature. However, the delegate
    we named `Endpoint` is now part of the feature class (highlighted code). The class
    that contains the logic is now called `Handler` instead of `Endpoint`. This change
    makes the full feature live closer together.Nonetheless, we still need to register
    the dependency with the container and map the endpoint to our delegate like this
    in the `Program.cs` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与第一个功能非常相似。然而，我们命名为`Endpoint`的委托现在是功能类的一部分（突出显示的代码）。包含逻辑的类现在称为`Handler`而不是`Endpoint`。这种变化使得整个功能更紧密地聚集在一起。尽管如此，我们仍然需要将依赖项注册到容器中，并在`Program.cs`文件中将端点映射到我们的委托，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code is routing the request to the `RandomNumber.Endpoint` method.When
    we send the following HTTP request:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将请求路由到`RandomNumber.Endpoint`方法。当我们发送以下HTTP请求时：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We receive a result similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果类似于以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We moved more of our feature’s code together; however, our code is still divided
    into two files. Let’s explore a way to fix this next.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更多特性代码放在一起；然而，我们的代码仍然分为两个文件。让我们探索一种修复这个问题的方法。
- en: 'Feature: UpperCase'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特性：UpperCase
- en: 'This feature transforms the input text to uppercase and returns the result.Our
    objective is to centralize as much of the code as possible in the `UpperCase`
    feature class so we control it from a single place. To achieve this, we create
    the following extension methods (highlighted):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此特性将输入文本转换为大写并返回结果。我们的目标是尽可能地将代码集中到 `UpperCase` 特性类中，以便我们可以从单一位置控制它。为了实现这一点，我们创建了以下扩展方法（突出显示）：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, we changed the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，我们更改了以下内容：
- en: The `UpperCase` class is static to allow us to create extension methods. Turning
    the `UpperCase` class into a static class does not hinder our maintainability
    because we use it as an organizer and do not instantiate it.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpperCase` 类是静态的，这样我们可以创建扩展方法。将 `UpperCase` 类转换为静态类并不会妨碍我们的可维护性，因为我们将其用作组织者，并不实例化它。'
- en: We added the `AddUpperCase` method that registers the dependencies with the
    container.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `AddUpperCase` 方法，它将依赖项注册到容器中。
- en: We added the `MapUpperCase` method that creates the endpoint itself.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `MapUpperCase` 方法，它本身创建了端点。
- en: 'In the Program.cs file, we can now register our feature like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Program.cs 文件中，我们现在可以像这样注册我们的特性：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code calls our extension methods, which move all the related code
    into the `UpperCase` class but its connection with ASP.NET Core.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码调用了我们的扩展方法，这些方法将所有相关代码移动到 `UpperCase` 类中，但与 ASP.NET Core 的连接除外。
- en: I find this approach elegant and very clean for a no-dependency project. Of
    course, we could design this in a million different ways, use an existing library
    to help us, scan the assembly and auto-register our features, and more.
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为这种方法对于无依赖项项目来说既优雅又非常干净。当然，我们可以以百万种不同的方式设计它，使用现有的库来帮助我们，扫描程序集并自动注册我们的特性，等等。
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use this pattern to build a real-world application. I’d suggest creating
    an `AddFeatures` and a `MapFeatures` extension method that register all the features
    instead of cluttering the `Program.cs` file, but besides a few final organization
    touch, this is a robust enough pattern. We explore more of this in the next project.
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用此模式构建实际的应用程序。我建议创建一个 `AddFeatures` 和一个 `MapFeatures` 扩展方法来注册所有特性，而不是让 `Program.cs`
    文件杂乱无章，但除了少数最终的组织性触摸之外，这是一个足够健壮的模式。我们将在下一个项目中进一步探讨这一点。
- en: 'When we send the following HTTP request:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发送以下 HTTP 请求时：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We receive the following response:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到了以下响应：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we explored REPR and how to encapsulate our REPR features in several
    ways, we are almost ready to explore a larger project.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了 REPR 以及如何以几种不同的方式封装我们的 REPR 特性，我们几乎准备好探索一个更大的项目了。
- en: Conclusion
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Creating a feature-based design using Minimal APIs, the REPR pattern, and no
    external dependencies is possible and simple. We organized our project in different
    ways. Each feature comprises a request, a response, and a handler attached to
    an endpoint.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小 API、REPR 模式以及无外部依赖项创建基于特性的设计是可能的且简单的。我们以不同的方式组织了我们的项目。每个特性包括一个请求、一个响应和一个附加到端点的处理器。
- en: We can combine the handler and the endpoint to make it a three-component pattern.
    What I like about having a distinct handler is that we can reuse the handler in
    a non-HTTP context; say, we could create a CLI tool in front of the application
    and reuse the same logic. It all depends on what we are building.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以将处理器和端点结合起来，使其成为一个三组件模式。我喜欢有一个独立处理器的优点，因为我们可以在非 HTTP 上下文中重用处理器；比如说，我们可以在应用程序前面创建一个
    CLI 工具并重用相同的逻辑。这完全取决于我们正在构建的内容。
- en: 'Let’s see how the REPR pattern can help us follow the **SOLID** principles:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 REPR 模式如何帮助我们遵循 **SOLID** 原则：
- en: '**S**: Each piece has a single responsibility, and all pieces are centralized
    under a feature for ease of navigation, making this pattern a perfect SRP ally.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**：每个部分都有一个单一的责任，并且所有部分都集中在一个特性下，便于导航，使此模式成为完美的 SRP 协作者。'
- en: '**O**: Using an approach similar to what we did with the `UpperCase` feature,
    we can change the feature’s behavior without affecting the rest of the codebase.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**：使用与我们对 `UpperCase` 特性所采取的类似方法，我们可以更改特性的行为，而不会影响代码库的其余部分。'
- en: '**L**: N/A'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**：N/A'
- en: '**I**: The REPR pattern divides a feature into three smaller interfaces: the
    request, the endpoint, and the response.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**：REPR 模式将特性分为三个更小的接口：请求、端点和响应。'
- en: '**D**: N/A'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**：N/A'
- en: Now that we familiarized ourselves with the REPR pattern, it is time to explore
    a larger project, including exception handling and grey-box testing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 REPR 模式，是时候探索一个更大的项目了，包括异常处理和灰盒测试。
- en: Project – REPR—A slice of the real-world
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目 – REPR—现实世界的一块
- en: '**Context**: this project slightly differs from the previous ones about products
    and stocks. We remove the inventory from the product, add a unit price, and create
    a barebone shopping basket as a foundation for an e-commerce application. The
    inventory management became so complex that we had to extract and handle it separately
    (not included here).By using the REPR pattern, Minimal APIs, and what we learned
    with Vertical Slice Architecture, we analyzed that the application contains two
    major areas:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**：此项目与之前关于产品和库存的项目略有不同。我们从产品中移除了库存，添加了单价，并创建了一个基础性的购物篮作为电子商务应用程序的基础。库存管理变得如此复杂，以至于我们必须将其提取并单独处理（此处未包含）。通过使用
    REPR 模式、Minimal APIs 和我们学到的垂直切片架构，我们分析出应用程序包含两个主要区域：'
- en: A product catalog
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品目录
- en: A shopping cart
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车
- en: 'For this first iteration, we kept the management of the products away from
    the application, supporting only the following features:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个迭代，我们将产品的管理从应用程序中分离出来，只支持以下功能：
- en: Listing all products
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有产品
- en: Fetching the details of a product
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取产品的详细信息
- en: 'As for the shopping cart, we kept it to a minimum. The basket only persists
    the `Id` of the products in the cart and its quantity. The basket does not support
    any more advanced use cases. Here are the operations it supports:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于购物车，我们将其保持到最小。篮子只持久化购物车中商品的 `Id` 和其数量。篮子不支持任何更高级的使用案例。以下是它支持的运算：
- en: Add an item to the cart
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将商品添加到购物车
- en: Fetch the items that are in the cart
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取购物车中的商品
- en: Remove an item from the cart
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从购物车中移除商品
- en: Update the quantity of an item in the cart
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新购物车中商品的数量
- en: For now, the shopping cart is not aware of the product catalog.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，购物车还没有意识到产品目录的存在。
- en: We improve the application in *Chapter 19*, *Introduction to Microservices Architecture*,
    and *Chapter 20*, *Modular Monolith*.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第 19 章*，*微服务架构简介* 和 *第 20 章*，*模块化单体* 中改进了应用程序。
- en: Let’s assemble the stack we’ll build upon next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们组装我们将构建其上的堆栈。
- en: Assembling our stack
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组装我们的堆栈
- en: 'I want to keep the project as barebone as possible, using Minimal APIs, yet,
    we don’t have to struggle with manually implementing every single concern ourselves.
    Here are the tools we will use to build this project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我想尽可能保持项目的基础性，使用 Minimal APIs，但，我们不必手动实现每一个关注点。以下是我们将用于构建此项目的工具：
- en: '*ASP.NET Core Minimal API* as our backbone.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 *ASP.NET Core Minimal API* 作为我们的骨干。
- en: '*FluentValidation* as our validation framework.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FluentValidation* 作为我们的验证框架。'
- en: '*FluentValidation.AspNetCore.Http* connects FluentValidation into Minimal API.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FluentValidation.AspNetCore.Http* 将 FluentValidation 连接到 Minimal API。'
- en: '*Mapperly* is our mapping framework.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mapperly* 是我们的映射框架。'
- en: '*ExceptionMapper* helps us handle exceptions globally, shifting our pattern
    to error management.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ExceptionMapper* 帮助我们全局处理异常，将我们的模式转变为错误管理。'
- en: '*EF Core* (InMemory) as our ORM.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EF Core*（内存中）作为我们的 ORM。'
- en: 'From a terminal window, we can use the CLI to install the packages:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端窗口，我们可以使用 CLI 安装包：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We know most of those pieces and will dig deeper into the new ones in time.
    Meanwhile, let’s explore the structure of the project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了这些大部分组件，并将随着时间的推移深入探讨新的组件。同时，让我们探索项目的结构。
- en: Dissecting the code structure
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析代码结构
- en: 'The directory structure is very similar to what we explored in Vertical Slice
    Architecture. The root of the project contains the `Program.cs` file and a `Features`
    directory that holds the features or slices. The following diagram represents
    the features:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构与我们之前在垂直切片架构中探索的结构非常相似。项目的根目录包含 `Program.cs` 文件和一个 `Features` 目录，该目录包含功能或切片。以下图表表示功能：
- en: '![Figure 18.2: The project''s directory structure that represents the features''
    hierarchical relationships.](img/file122.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.2：表示功能分层关系的项目目录结构](img/file122.png)'
- en: 'Figure 18.2: The project''s directory structure that represents the features''
    hierarchical relationships.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2：表示功能分层关系的项目目录结构。
- en: 'The features inside each area share a cohesive bond and some pieces of code
    (coupling), while the two areas are entirely disconnected (loosely coupled).The
    `Program.cs` file is very light and only bootstraps the application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个区域内的特性共享紧密的联系和一些代码片段（耦合），而这两个区域是完全断开的（松耦合）。`Program.cs`文件非常轻量，仅用于启动应用程序：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The highlighted lines are extension methods defined in the `Features` class
    (located under the `Features` folder), which cascades the responsibility of registering
    the dependencies with the container, mapping the endpoints, and seeding the database
    to each area. Here’s the skeleton of the class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮行是在`Features`类（位于`Features`文件夹下）中定义的扩展方法，它将注册依赖项、映射端点和初始化数据库的责任级联到每个区域。以下是类的框架：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s now explore the `AddFeatures` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索`AddFeatures`方法：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `AddFeatures` method registers FluentValidation and the Minimal API filters
    to validate our endpoints (the highlighted line). Each slice defines its own configuration
    methods, like the `AddProductsFeature` and `AddBasketsFeature` methods. We will
    come back to those. Meanwhile, let’s explore the `MapFeatures` method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddFeatures`方法注册了FluentValidation和Minimal API过滤器来验证我们的端点（高亮行）。每个切片定义了自己的配置方法，如`AddProductsFeature`和`AddBasketsFeature`方法。我们稍后会回到这些方法。同时，让我们探索`MapFeatures`方法：'
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `MapFeatures` method creates a root route group, adds the *FluentValidation*
    filter to it so the validation applies to all endpoints in this group, then it
    calls the `MapProductsFeature` and `MapBasketsFeature` methods that map their
    features into the group. Finally, the `SeedFeaturesAsync` method seeds the database
    using the feature extension methods:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapFeatures`方法创建一个根路由组，向其中添加*FluentValidation*过滤器，以便验证该组中的所有端点，然后调用`MapProductsFeature`和`MapBasketsFeature`方法，将它们的特性映射到该组中。最后，`SeedFeaturesAsync`方法使用特性扩展方法对数据库进行初始化：'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With those building blocks in place, the program starts, adds features, and
    registers endpoints. Afterward, each category of features—products and baskets—cascades
    the calls, letting each feature registers its pieces. Next are a few diagrams
    representing the call hierarchy from the `Program.cs` file. Let’s start with the
    `AddFeatures` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些构建块就绪后，程序开始运行，添加特性并注册端点。之后，每个特性类别——产品和购物车——级联调用，让每个特性注册其部分。接下来是一些表示从`Program.cs`文件调用层次关系的图。让我们从`AddFeatures`方法开始：
- en: '![Figure 18.3: the call hierarchy of the AddFeatures method.](img/file123.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图18.3：AddFeatures方法的调用层次](img/file123.png)'
- en: 'Figure 18.3: the call hierarchy of the AddFeatures method.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3：AddFeatures方法的调用层次。
- en: 'The preceding diagram showcases the division of responsibilities where each
    piece aggregates its sub-parts or registers its dependencies.A similar flow happens
    from the `MapFeatures` method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图展示了责任划分，其中每个部分都会聚合其子部分或注册其依赖项。从`MapFeatures`方法中也有类似的流程：
- en: '![Figure 18.4: the call hierarchy of the MapFeatures method.](img/file124.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图18.4：MapFeatures方法的调用层次](img/file124.png)'
- en: 'Figure 18.4: the call hierarchy of the MapFeatures method.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：MapFeatures方法的调用层次。
- en: 'Finally, the `SeedFeaturesAsync` method utilizes a similar approach to seed
    the in-memory database:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SeedFeaturesAsync`方法使用类似的方法对内存数据库进行初始化：
- en: '![Figure 18.5: the call hierarchy of the SeedFeaturesAsync method.](img/file125.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图18.5：SeedFeaturesAsync方法的调用层次](img/file125.png)'
- en: 'Figure 18.5: the call hierarchy of the SeedFeaturesAsync method.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：SeedFeaturesAsync方法的调用层次。
- en: These diagrams showcase the entry point (`Program.cs`) sending a request to
    each feature so that every piece handles itself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图展示了入口点（`Program.cs`）向每个特性发送请求，以便每个部分都能自行处理。
- en: In a real project using an actual database, you do not want to seed the database
    this way. In this case, it works because each time we start the project, the database
    is empty because it only lives for the time the program runs—it lives in memory.
    There are numerous strategies to seed your data sources in real life, from executing
    a SQL script to deploying a Docker container that runs only once.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际项目中使用实际数据库时，你不想以这种方式初始化数据库。在这种情况下，它之所以可行，是因为每次启动项目时，数据库都是空的，因为它只存在于程序运行期间——它存在于内存中。在现实生活中，有无数种策略可以初始化你的数据源，从执行SQL脚本到部署只运行一次的Docker容器。
- en: Now that we explored the high-level view of the program, it is time to dig into
    a feature and explore how it works.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了程序的高级视图，是时候深入一个特性并了解它是如何工作的了。
- en: Exploring the shopping basket
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索购物车
- en: This section explores the `AddItem` and `FetchItems` features of the shopping
    basket slice. The slice is completely decoupled from the `Products` slice, and
    does not know the products themselves. All it knows is how to accumulate product
    identifiers and quantities and associate those with a customer. We address this
    problem later.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了购物车切片的`AddItem`和`FetchItems`功能。该切片完全与`Products`切片解耦，并且不知道产品本身。它只知道如何累积产品标识符和数量，并将这些与客户关联起来。我们稍后解决这个问题。
- en: There are no customer features and no authentication to keep the project simple.
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有客户功能也没有身份验证，以保持项目简单。
- en: 'The code of the `Features/Baskets/Baskets.cs` file powers the shopping basket
    features. Here’s the skeleton:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Features/Baskets/Baskets.cs`文件的代码为购物车功能提供动力。以下是框架：'
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The highlighted code of the preceding block contains the `BasketItem` data model
    and the `BasketContext` EF Core `DbContext`, which all basket features share.
    It also includes the three methods that register and make the features work (`AddBasketsFeature`,
    `MapBasketsFeature`, and `SeedBasketsAsync`). The other methods and classes are
    divided into several files. We explore a few of them in the chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码块中高亮的代码包含`BasketItem`数据模型和`BasketContext` EF Core `DbContext`，所有购物车功能都共享这些。它还包括三个注册和使功能工作的方法（`AddBasketsFeature`、`MapBasketsFeature`和`SeedBasketsAsync`）。其他方法和类被分到几个文件中。我们在本章中探索了其中的一些。
- en: We used the `partial` modifier to split the nested classes into multiple files.
    We made the class `static` to create extension methods in it.
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用了`partial`修饰符将嵌套类拆分到多个文件中。我们将类设置为`static`以在其中创建扩展方法。
- en: 'The `BasketItem` class allows us to persist a simple shopping cart to the database:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasketItem`类允许我们将简单的购物车持久化到数据库：'
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `BasketContext` class configures the primary key of the `BasketItem` class
    and exposes the `Items` property (highlighted):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasketContext`类配置了`BasketItem`类的主键并公开了`Items`属性（高亮显示）：'
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `AddBasketsFeature` method registers each feature and the `BasketContext`
    with the IoC container:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBasketsFeature`方法将每个功能和`BasketContext`注册到IoC容器中：'
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Besides the `AddDbContext` method, the `AddBasketsFeature` delegates the registration
    of dependencies to each feature. We explore the highlighted ones shortly. The
    EF Core code registers the in-memory provider that serves the `BasketContext`.Next,
    the `MapBasketsFeature` method maps the endpoints:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AddDbContext`方法外，`AddBasketsFeature`将依赖项注册委托给每个功能。我们很快就会探索高亮显示的部分。EF Core代码注册了服务于`BasketContext`的内存提供程序。接下来，`MapBasketsFeature`方法映射端点：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code creates a group, naming it `baskets`, making its endpoints
    accessible using the `/baskets` URL prefix. We also tag the group “Baskets” to
    leverage an OpenAPI generator in the future. Then the method uses a similar pattern
    to the `AddBasketsFeature` method and delegates the endpoint mapping to the features.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个名为`baskets`的组，使其端点可通过`/baskets` URL前缀访问。我们还标记了“Baskets”以利用未来的OpenAPI生成器。然后该方法使用与`AddBasketsFeature`方法类似的模式，并将端点映射委托给功能。
- en: Have you noticed that the method returns the `endpoints` object directly? This
    allows us to chain the feature mapping. In another scenario, we could return the
    `group` object (`RouteGroupBuilder` instance) to let the caller further configure
    the group. What we build is always about the needs and objectives.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你注意到该方法直接返回`endpoints`对象了吗？这允许我们链式调用特征映射。在另一种场景中，我们可以返回`group`对象（`RouteGroupBuilder`实例）以允许调用者进一步配置该组。我们所构建的始终关于需求和目标。
- en: 'Finally, the `SeedBasketsAsync` method does nothing; we do not create any shopping
    cart when starting the program, unlike the `Products` slice:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`SeedBasketsAsync`方法什么都不做；与`Products`切片不同，我们在程序启动时不会创建任何购物车。
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We could have omitted the preceding method. I left it so we follow a linear
    pattern between the features. Such a linear pattern makes it easier to understand
    and learn. It also allows identifying the recurring pieces we could work on to
    automate the registration process.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们本可以省略前面的方法。我留下它是为了我们在特征之间遵循线性模式。这样的线性模式使得理解和学习变得更加容易。它还允许我们识别可以工作的重复部分，以自动化注册过程。
- en: Now that we have covered the shared pieces, let’s add data to our shopping basket.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了共享部分，让我们向我们的购物车添加数据。
- en: AddItem feature
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加项目功能
- en: 'The role of the `AddItem` feature is to create a `BasketItem` object and persist
    it in the database. To achieve this, we leverage the REPR pattern. Inspired by
    the preceding few chapters, we name the request `Command` (CQS pattern), add a
    mapper object using Mapperly, and leverage FluentValidation to ensure the request
    is valid. Here’s the skeleton of the `AddItem` class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItem` 功能的作用是创建一个 `BasketItem` 对象并将其持久化到数据库中。为了实现这一点，我们利用了 REPR 模式。受到前几章的启发，我们将请求命名为
    `Command`（CQS 模式），使用 Mapperly 添加一个映射对象，并利用 FluentValidation 确保请求有效。以下是 `AddItem`
    类的骨架：'
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code contains all the necessary pieces of the feature:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含该功能所需的所有必要组件：
- en: The request (the `Command` class).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求（`Command` 类）。
- en: The response (the `Response` class).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应（`Response` 类）。
- en: The endpoint (the `MapAddItem` method pointing the requests to the `Handler`
    class).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点（指向 `Handler` 类的 `MapAddItem` 方法）。
- en: A mapper object that has Mapperly generate the mapping code for us.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由 Mapperly 为我们生成映射代码的映射对象。
- en: A validator class that ensures the input we receive is valid.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个验证器类，确保我们接收到的输入是有效的。
- en: The `AddAddItem` method registers its services with the IoC container.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddAddItem` 方法将其服务注册到 IoC 容器中。'
- en: 'Let’s start with the `AddAddItem` method that registers the feature’s services:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从注册功能服务的 `AddAddItem` 方法开始：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then the `MapAddItem` method routes the appropriate POST requests with a valid
    `Command` object in its body to the `Handler` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 `MapAddItem` 方法将具有有效 `Command` 对象的适当 POST 请求路由到 `Handler` 类：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Command` instance is a copy of the `BasketItem` class, while the response
    only returns the `ProductId` and `Quantity` properties. The highlighted lines
    represent the endpoint handing off the `Command` object to the use case `Handler`
    class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command` 实例是 `BasketItem` 类的一个副本，而响应仅返回 `ProductId` 和 `Quantity` 属性。下面高亮显示的行表示端点将
    `Command` 对象传递给用例 `Handler` 类。'
- en: We could write the `Handler` code in the delegate, which would make unit testing
    the delegate very hard.
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以在代理中编写 `Handler` 代码，这将使得对代理进行单元测试变得非常困难。
- en: 'The `Handler` class is the glue of the feature:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler` 类是该功能的粘合剂：'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code contains the business logic of the feature by ensuring the
    item is not already in the basket. If it is, it throws a `DuplicateBasketItemException`.
    Otherwise, it saves the item to the database. It then returns a `Response` object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含该功能的业务逻辑，通过确保商品不在购物车中。如果它在，则抛出 `DuplicateBasketItemException`。否则，它将商品保存到数据库中，然后返回一个
    `Response` 对象。
- en: Each customer (`CustomerId`) can have each product (`ProductId`) once in its
    cart (composite primary key), which is why we test for this condition.
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个客户（`CustomerId`）在其购物车中只能拥有每个产品（`ProductId`）一次（复合主键），这就是为什么我们要测试这个条件。
- en: 'The handler leveraged the `Mapper` class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器利用了 `Mapper` 类：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implicitly, the `Command` object was validated using the following `Validator`
    class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式地，使用以下 `Validator` 类对 `Command` 对象进行了验证：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As a reminder, in the `Features.cs` file, we called the `AddFluentValidationFilter`
    method on the root route group, letting the `FluentValidationEndpointFilter` class
    validate the inputs for us using the `Validator` class.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为提醒，在 `Features.cs` 文件中，我们在根路由组上调用 `AddFluentValidationFilter` 方法，让 `FluentValidationEndpointFilter`
    类使用 `Validator` 类为我们验证输入。
- en: 'With this in place, we can send the following HTTP request:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，我们可以发送以下 HTTP 请求：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The endpoint responds with the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 端点响应如下：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And has the following HTTP header:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并且具有以下 HTTP 头：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To recap, here’s what happens:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，以下是发生的情况：
- en: ASP.NET Core routes the request to the delegate we registered in the `MapAddItem`
    method.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 将请求路由到我们在 `MapAddItem` 方法中注册的代理。
- en: The validation middle runs an `AddItem.Validator` object against the `AddItem.Command`
    sent to the endpoint. The request is valid.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证中间件运行 `AddItem.Validator` 对象对发送到端点的 `AddItem.Command` 进行验证。请求是有效的。
- en: The `HandleAsync` method of the `AddItem.Handler` class is executed.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddItem.Handler` 类的 `HandleAsync` 方法被执行。'
- en: Assuming the item is not already in the customer’s basket, it is added to the
    database.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设该商品尚未在客户的购物车中，则将其添加到数据库中。
- en: The `HandleAsync` method returns a `Response` object to the delegate.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HandleAsync` 方法将 `Response` 对象返回给代理。'
- en: The delegate returns a `201 Create` status code with the `Location` header set
    to the URL of the product that got added.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代理返回一个 `201 Create` 状态码，并将 `Location` 头设置为添加的产品 URL。
- en: 'As the preceding list depicts, the process is quite simple; a request gets
    in, the business logic is executed (endpoint), then a response goes out: REPR.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的列表所示，过程相当简单；一个请求进来，执行业务逻辑（端点），然后输出响应：REPR。
- en: There are a few more pieces, but they save us the trouble of object mapping
    and validation. Those pieces are optional; you can conceive your own stack with
    more or less pieces in it.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有几个其他部分，但它们节省了我们进行对象映射和验证的麻烦。这些部分是可选的；你可以设想自己的堆栈，其中包含更多或更少的部分。
- en: On top of the feature code, we also have a few tests to assess that the business
    logic remains correct over time. We cover those under the *Grey-box testing* section.
    Meanwhile, let’s look at the `FetchItems` feature.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能代码之上，我们还有一些测试来评估业务逻辑随时间保持正确。我们将在*灰盒测试*部分中涵盖这些。同时，让我们看看`FetchItems`功能。
- en: FetchItems feature
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FetchItems功能
- en: 'Now that we know the pattern, this feature should be faster to cover. It allows
    a client to retrieve the shopping basket of the specified customer using the following
    request:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了模式，这个功能应该更快地覆盖。它允许客户端使用以下请求检索指定客户的购物车：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The client expects a collection of items in the response:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端期望在响应中收到商品集合：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since the client knows about the customer, it does not need the endpoint to
    return the `CustomerId` property, which is why the `Item` class only has two of
    the `BasketItem` properties.Here are the `Mapper` and the `Validator` classes,
    which should be self-explanatory at this point:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端了解客户信息，它不需要端点返回`CustomerId`属性，这就是为什么`Item`类只包含两个`BasketItem`属性。以下是`Mapper`和`Validator`类，在这个阶段应该很容易理解：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, a last piece of plumbing is the `AddFetchItems` method which registers
    the feature’s services with the containers:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后一块管道是`AddFetchItems`方法，它将功能的服务注册到容器中：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now to the endpoint itself, forwarding the `FetchItems.Query` object to a `FetchItems.Handler`
    instance:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到端点本身，将`FetchItems.Query`对象转发给一个`FetchItems.Handler`实例：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding code is simpler than the `AddItem` feature because it serializes
    the handler’s response directly as a 200 OK status code without transforming it.Finally,
    the `Handler` class itself:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码比`AddItem`功能简单，因为它直接将处理器的响应序列化为200 OK状态码，而不进行转换。最后，是`Handler`类本身：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code loads all the items associated with the specified customer
    from the database and returns them. If there are no items, the client receives
    an empty array.That’s it; we can now send the following HTTP request and hit the
    endpoint:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从数据库中加载与指定客户关联的所有商品并返回它们。如果没有商品，客户端会收到一个空数组。就这样；我们现在可以发送以下HTTP请求并调用端点：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Assuming we added an item to the basket, we should receive a response similar
    to the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们向购物车添加了一个商品，我们应该收到以下类似的响应：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We now have a working shopping basket!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的购物车了！
- en: You can explore the other features in the codebase available on GitHub ([https://adpg.link/ikAn](https://adpg.link/ikAn)).
    All features have tests and are functional.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以探索GitHub上可用的代码库中的其他功能（[https://adpg.link/ikAn](https://adpg.link/ikAn)）。所有功能都有测试并且是可用的。
- en: Next, we look at exception handling.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看异常处理。
- en: Managing exception handling
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理异常处理
- en: 'The `AddItem` feature throws a `DuplicateBasketItemException` when the product
    is already in the basket. However, when that happens, the server returns an error
    that resembles the following (partial output):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当产品已经在购物车中时，`AddItem`功能会抛出`DuplicateBasketItemException`异常。然而，当这种情况发生时，服务器返回一个类似于以下（部分输出）的错误：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That error is ugly and impractical for a client calling the API. To circumvent
    this, we can add a try-catch somewhere and treat each exception individually,
    or we can use a middleware to catch the exceptions and normalize their output.Managing
    exceptions one by one is tedious and error-prone. On the other hand, centralizing
    exception management and treating them as a cross-cutting concern transforms the
    tedious mechanism into a new tool to leverage. Moreover, it ensures that the API
    always returns the errors in the same format with no additional effort.Let’s program
    a basic middleware.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很丑陋，对于调用API的客户端来说不实用。为了解决这个问题，我们可以在某个地方添加try-catch并逐个处理每个异常，或者我们可以使用中间件来捕获异常并规范化它们的输出。逐个管理异常既麻烦又容易出错。另一方面，集中异常管理和将它们视为横切关注点将繁琐的机制转化为一个可以利用的新工具。此外，它确保API总是以相同的格式返回错误，无需额外努力。让我们编写一个基本的中间件。
- en: Creating an exception handler middleware
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建异常处理中间件
- en: 'A middleware in ASP.NET Core is executed as part of the pipeline and can run
    before and after the execution of an endpoint.When an exception occurs, the request
    is re-executed in a parallel pipeline, allowing different middleware to manage
    the error flow.To create a middleware, we must implement an `InvokeAsync` method.
    The easiest way to do this is by implementing the `IMiddleware` interface. You
    can add middleware types to the default or exception-handling alternate pipelines.The
    following code represents a basic exception-handling middleware:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中的中间件作为管道的一部分执行，可以在端点执行前后运行。当发生异常时，请求将在并行管道中重新执行，允许不同的中间件管理错误流。要创建中间件，我们必须实现一个`InvokeAsync`方法。最简单的方法是实现`IMiddleware`接口。您可以将中间件类型添加到默认或异常处理备用管道中。以下代码表示一个基本的异常处理中间件：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The middleware fetches the `IExceptionHandlerFeature` to access the error and
    outputs an object containing the error message (ASP.NET Core manages this feature).
    If the feature is unavailable, the middleware throws a `NotSupportedException`,
    which rethrows the original exception.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件获取`IExceptionHandlerFeature`以访问错误，并输出一个包含错误消息的对象（ASP.NET Core管理此功能）。如果该功能不可用，中间件将抛出`NotSupportedException`，这会重新抛出原始异常。
- en: Any type of exception a middleware of the alternate pipeline throws will rethrow
    the original exception.
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何备用管道的中间件抛出的异常类型都会重新抛出原始异常。
- en: 'If any, the highlighted code executes the next middleware in the pipeline.
    These pipelines are like a chain of responsibilities but with a different objective.To
    register the middleware, we must first add it to the container:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有，高亮显示的代码将执行管道中的下一个中间件。这些管道就像一个责任链，但具有不同的目标。要注册中间件，我们必须首先将其添加到容器中：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we must register it as part of the exception-handling alternate pipeline:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将其注册为异常处理备用管道的一部分：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We could also register more middleware or create them inline, like this:'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还可以注册更多的中间件或直接创建它们，如下所示：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The possibilities are vast.
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能性是无限的。
- en: 'Now, if we try to add a duplicated item to the basket, we get a *500 Internal
    Server Error* with the following body:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将重复的项目添加到购物车中，我们会收到一个带有以下正文的*500内部服务器错误*：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This response is more elegant than before and easier to handle for the clients.
    We could also alter the status code in the middleware. However, customizing this
    middleware would take many pages, so we leverage an existing library instead.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个响应比以前更优雅，更容易处理。我们还可以在中间件中更改状态码。然而，自定义这个中间件需要很多页面，所以我们利用现有的库。
- en: Exception handling using ExceptionMapper
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ExceptionMapper进行异常处理
- en: 'The `ForEvolve.ExceptionMapper` package is an ASP.NET Core middleware that
    allows us to map exceptions to different status codes. Out-of-the-box, it offers
    many exception types to get started, handles them, and allows easy mapping between
    a custom exception and a status code. By default, the library serializes the exceptions
    to a `ProblemDetails` object (based on RFC 7807) by leveraging as many ASP.NET
    Core components as possible, so we can customize parts of the library by customizing
    ASP.NET Core.To get started, in the `Program.cs` file, we must add the following
    lines:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEvolve.ExceptionMapper`包是一个ASP.NET Core中间件，允许我们将异常映射到不同的状态码。开箱即用，它提供了许多异常类型以供开始，处理它们，并允许轻松地将自定义异常与状态码映射。默认情况下，该库通过尽可能利用ASP.NET
    Core组件将异常序列化为`ProblemDetails`对象（基于RFC 7807），因此我们可以通过自定义ASP.NET Core来定制库的某些部分。要开始，在`Program.cs`文件中，我们必须添加以下行：'
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, if we try to add a duplicated product to the basket, we receive a response
    with a *409 Conflict* status code with the following body:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将重复的产品添加到购物车中，我们会收到一个带有以下正文的带有*409冲突*状态码的响应：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This output is starting to look like something!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出开始看起来像样了！
- en: The `debug` object (highlighted) only appears in development or as an opt-in
    option.
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （高亮显示的）`debug`对象仅在开发中或作为可选选项出现。
- en: 'How can the middleware know it’s a 409 Conflict and not a 500 Internal Server
    Error? Simple! The `DuplicateBasketItemException` inherits from the `ConflictException`
    that comes from the `ForEvolve.ExceptionMapper` namespace (highlighted):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件如何知道它是409冲突而不是500内部服务器错误？简单！`DuplicateBasketItemException`继承自来自`ForEvolve.ExceptionMapper`命名空间（高亮显示）的`ConflictException`：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this setup, we can leverage exceptions to return errors with different
    status codes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种设置，我们可以利用异常返回不同状态码的错误。
- en: I have used this methodology for many years, and it simplifies the program structure
    and developers' lives. The idea is to harness the power and simplicity of exceptions.
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我已经使用这种方法很多年了，它简化了程序结构和开发者的生活。这个想法是利用异常的强大和简单性。
- en: 'For example, we may want to map EF Core errors, `DbUpdateException` and `DbUpdateConcurrencyException`,
    to a *409 Conflict* as well, so in case we forget to catch a database error, the
    middleware will do it for us. To achieve this, we can customize the middleware
    this way:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望将 EF Core 错误，`DbUpdateException` 和 `DbUpdateConcurrencyException`，也映射到
    *409 冲突*，这样，如果我们忘记捕获数据库错误，中间件会为我们做这件事。为了实现这一点，我们可以这样自定义中间件：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With that in place, if a client hits an unhandled EF Core exception, the server
    will respond with something like the following (I omitted the stack trace for
    brevity reasons):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，如果客户端遇到未处理的 EF Core 异常，服务器将响应如下（为了简洁起见，我省略了堆栈跟踪）：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In an actual project, for security reasons, I recommend customizing the error
    handling further to hide the fact that we are using EF Core. We must give as little
    information as possible about our systems to malicious actors to keep them as
    secure and safe as possible. We won’t cover creating custom exception handlers
    here because it is out of the scope of the chapter.
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实际项目中，出于安全考虑，我建议进一步自定义错误处理以隐藏我们使用 EF Core 的事实。我们必须尽可能少地向恶意行为者提供关于我们系统的信息，以使它们尽可能安全和安全。在这里，我们不会涵盖创建自定义异常处理程序，因为这超出了本章的范围。
- en: 'As we can see, it is easy to register custom exceptions and associate them
    with a status code. We can do this with any custom exception or inherit from an
    existing one to make it work with customization.As of version 3.0.29, *ExceptionMapper*
    offers the following custom exception associations:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，注册自定义异常并将它们与状态码关联是很简单的。我们可以用任何自定义异常，或者从现有的异常继承以使其能够进行定制。截至版本 3.0.29，*ExceptionMapper*
    提供以下自定义异常关联：
- en: '| Exception Type | Status Code |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 异常类型 | 状态码 |'
- en: '| `BadRequestException` | `StatusCodes.Status400BadRequest` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `BadRequestException` | `StatusCodes.Status400BadRequest` |'
- en: '| `ConflictException` | `StatusCodes.Status409Conflict` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `ConflictException` | `StatusCodes.Status409Conflict` |'
- en: '| `ForbiddenException` | `StatusCodes.Status403Forbidden` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `ForbiddenException` | `StatusCodes.Status403Forbidden` |'
- en: '| `GoneException` | `StatusCodes.Status410Gone` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `GoneException` | `StatusCodes.Status410Gone` |'
- en: '| `NotFoundException` | `StatusCodes.Status404NotFound` |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `NotFoundException` | `StatusCodes.Status404NotFound` |'
- en: '| `ResourceNotFoundException` | `StatusCodes.Status404NotFound` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `ResourceNotFoundException` | `StatusCodes.Status404NotFound` |'
- en: '| `UnauthorizedException` | `StatusCodes.Status401Unauthorized` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `UnauthorizedException` | `StatusCodes.Status401Unauthorized` |'
- en: '| `GatewayTimeoutException` | `StatusCodes.Status504GatewayTimeout` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `GatewayTimeoutException` | `StatusCodes.Status504GatewayTimeout` |'
- en: '| `InternalServerErrorException` | `StatusCodes.Status500InternalServerError`
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `InternalServerErrorException` | `StatusCodes.Status500InternalServerError`
    |'
- en: '| `ServiceUnavailableException` | `StatusCodes.Status503ServiceUnavailable`
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceUnavailableException` | `StatusCodes.Status503ServiceUnavailable`
    |'
- en: 'Table 18.1: ExceptionMapper custom exception associations.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18.1：ExceptionMapper 自定义异常关联。
- en: 'You can inherit from those standard exceptions, and the middleware will associate
    them with the correct status code as we did with the `DuplicateBasketItemException`
    class.*ExceptionMapper* also maps the following .NET exceptions automatically:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这些标准异常继承，中间件会像我们对 `DuplicateBasketItemException` 类所做的那样，将它们与正确的状态码关联。*ExceptionMapper*
    还会自动映射以下 .NET 异常：
- en: '`BadHttpRequestException` to `StatusCodes.Status400BadRequest`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `BadHttpRequestException` 映射到 `StatusCodes.Status400BadRequest`
- en: '`NotImplementedException` to `StatusCodes.Status501NotImplemented`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotImplementedException` 映射到 `StatusCodes.Status501NotImplemented`'
- en: 'In the project, there are three custom exceptions that you can find on GitHub:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中，有三个自定义异常，你可以在 GitHub 上找到它们：
- en: '`BasketItemNotFoundException` that inherits from `NotFoundException`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承自 `NotFoundException` 的 `BasketItemNotFoundException`
- en: '`DuplicateBasketItemException` that inherits from `ConflictException`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承自 `ConflictException` 的 `DuplicateBasketItemException`
- en: '`ProductNotFoundException` that inherits from `NotFoundException`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承自 `NotFoundException` 的 `ProductNotFoundException`
- en: Next, we explore this way of thinking about error propagation a little more.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更深入地探讨这种关于错误传播的思考方式。
- en: Leveraging exceptions to propagate errors
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 利用异常来传播错误
- en: 'With the middleware of *ExceptionMapper* in place, we can treat exceptions
    as a simple tool to propagate errors to the clients. We can throw an existing
    exception, like a `NotFoundException`, or create a custom reusable one with a
    more precise preconfigured error message.When we want the server to return a specific
    error, all we must do is:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ExceptionMapper* 中间件到位的情况下，我们可以将异常视为传播错误到客户端的简单工具。我们可以抛出一个现有的异常，如 `NotFoundException`，或者创建一个具有更精确预配置错误消息的自定义可重用异常。当我们希望服务器返回特定错误时，我们只需做以下操作：
- en: Create a new exception type.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的异常类型。
- en: Inherit from an existing type from *ExceptionMapper* or register our custom
    exception with the middleware.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 *ExceptionMapper* 中继承现有类型或在我们的中间件中注册我们的自定义异常。
- en: Throw our custom exception anywhere in the REPR flow.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPR 流程中的任何地方抛出我们的自定义异常。
- en: Let the middleware do its job.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让中间件做它的工作。
- en: 'Here’s a simplified representation of this flow, using the `AddItem` endpoint
    as an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `AddItem` 端点作为示例的简化流程表示：
- en: '![Figure 18.6: a simplified view of an exception flow using ExceptionMapper.](img/file126.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 18.6：使用 ExceptionMapper 的异常流程的简化视图](img/file126.png)'
- en: 'Figure 18.6: a simplified view of an exception flow using ExceptionMapper.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.6：使用 ExceptionMapper 的异常流程的简化视图。
- en: With this in place, we have a simple way to return errors to the clients from
    anywhere in the REPR flow. Moreover, our errors are consistently formatted the
    same way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就有了一种简单的方法，可以从 REPR 流程中的任何地方向客户端返回错误。此外，我们的错误格式始终一致。
- en: The exception handling pattern and the *ExceptionMapper* library also work with
    MVC and allow customizing the error formatting process.
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 异常处理模式和 *ExceptionMapper* 库也与 MVC 一起工作，允许自定义错误格式化过程。
- en: Next, let’s explore a few test cases.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索几个测试用例。
- en: Grey-box testing
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 灰盒测试
- en: Using Vertical Slice Architecture or REPR makes writing grey-box tests very
    convenient. The test project mainly comprises integration tests that use the grey-box
    philosophy. Since we know the application under test's inner workings, we can
    manipulate the data from the EF Core `DbContext` objects, which allows us to write
    almost end-to-end tests very quickly. The confidence level we get from those tests
    is very high because they test the whole stack, including HTTP, not just some
    scattered pieces, leading to a very high level of code coverage per test case.
    Of course, integration tests are slower, yet not that slow. It is up to you to
    create the right balance of unit and integration tests. In this case, I focused
    on grey-box integration testing, which led to 13 tests covering 97.2% of the lines
    and 63.1% of the branches. The guard clauses represent most of the branches that
    we do not test. We could write a few unit tests to boost the numbers if we’d like.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用垂直切片架构或 REPR 使得编写灰盒测试非常方便。测试项目主要包含使用灰盒哲学的集成测试。由于我们知道正在测试的应用程序的内部工作原理，我们可以操纵来自
    EF Core `DbContext` 对象的数据，这使得我们可以非常快速地编写几乎端到端测试。从这些测试中获得的可信度水平非常高，因为它们测试了整个堆栈，包括
    HTTP，而不仅仅是零散的部分，导致每个测试用例的代码覆盖率非常高。当然，集成测试较慢，但并不慢。这取决于你如何创建单元和集成测试的正确平衡。在这种情况下，我专注于灰盒集成测试，这导致了
    13 个测试，覆盖了 97.2% 的行和 63.1% 的分支。守卫子句代表了大多数我们不测试的分支。如果我们想提高这些数字，我们可以编写一些单元测试。
- en: We explored white-, grey- and black-box testing in *Chapter 2*, *Automated Testing*.
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们在 *第 2 章*，*自动化测试* 中探讨了白盒、灰盒和黑盒测试。
- en: Let’s start by exploring the AddItem tests.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从探索 AddItem 测试开始。
- en: AddItemTest
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: AddItemTest
- en: The `AddItem` feature is the first use case we explored. We need three tests
    to cover all scenarios but the `Handler` class guard clauses.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddItem` 功能是我们探索的第一个用例。我们需要三个测试来覆盖所有场景，但 `Handler` 类的守卫子句除外。'
- en: First test method
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第一个测试方法
- en: 'The following grey-box integration test ensures an HTTP POST request adds the
    item to the database:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下灰色盒集成测试确保 HTTP POST 请求将项目添加到数据库中：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The *Arrange* block of the preceding test case creates a test application and
    an `HttpClient`. It then sends an `AddItem.Command` to the endpoint in its *Act*
    block.Afterward, it splits the *Assert* block in two: the HTTP response and the
    database itself. The first part ensures that the endpoint returns the expected
    data. The second part ensures that the database is in the correct state.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个测试用例的 *Arrange* 块创建了一个测试应用程序和一个 `HttpClient`。然后，它在 *Act* 块中将 `AddItem.Command`
    发送到其端点。之后，它将 *Assert* 块分为两部分：HTTP 响应和数据库本身。第一部分确保端点返回预期的数据。第二部分确保数据库处于正确的状态。
- en: It is a good habit to ensure the database is in the correct state, especially
    with EF Core or most Unit of Work implementations, because one could add an item
    and forget to save the changes leading to an incorrect database state. Yet, the
    data returned by the endpoint would have been correct.
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保数据库处于正确状态是一个好习惯，尤其是在使用 EF Core 或大多数工作单元实现时，因为有人可能会添加一个项目却忘记保存更改，从而导致数据库状态不正确。然而，端点返回的数据将是正确的。
- en: We could test more or less elements here. We could refactor the *Assert* block
    so it becomes more elegant. We can and should continuously improve all types of
    code, including tests. However, in this case, I wanted to keep as much of the
    logic in the test method to make it easier to understand.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试更多或更少的元素。我们可以重构 *断言*（Assert）块，使其更加优雅。我们能够也应该持续改进所有类型的代码，包括测试。然而，在这种情况下，我想要保留测试方法中的大部分逻辑，以便更容易理解。
- en: It is also a good practice to keep test methods as independent as possible.
    This does not mean that improving readability and encapsulating code into helper
    classes or methods is wrong; on the contrary.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同时，保持测试方法尽可能独立也是一个好的实践。这并不意味着提高可读性和将代码封装到辅助类或方法中是错误的；相反。
- en: The only opaque piece of the test method is the `C18WebApplication` class, which
    inherits from the `WebApplicationFactory<Program>` class and implements a few
    helper methods to simplify the configuration of the test application. You can
    treat it as an instance of the `WebApplicationFactory<Program>` class. Feel free
    to browse the code on GitHub and explore its inner workings.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法中唯一不透明的一部分是 `C18WebApplication` 类，它继承自 `WebApplicationFactory<Program>`
    类并实现了一些辅助方法以简化测试应用的配置。你可以将其视为 `WebApplicationFactory<Program>` 类的一个实例。请随意浏览 GitHub
    上的代码并探索其内部工作原理。
- en: Creating an `Application` class is a good reusability pattern. However, creating
    an application per test method is not the most performant because you are booting
    the entire program for every test.
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个 `Application` 类是一个好的重用模式。然而，为每个测试方法创建一个应用程序并不是最高效的，因为每次测试都需要启动整个程序。
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can use test fixtures to reuse and share an instance of the program between
    multiple tests. However, remember that the application's state and potentially
    the database are also shared between tests.
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以使用测试固定值（test fixtures）在多个测试之间重用和共享程序实例。然而，请记住，应用程序的状态以及可能的数据库也会在测试之间共享。
- en: To the second test, next.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向第二个测试。
- en: Second test method
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第二个测试方法
- en: 'This test ensures that the `Location` header contains a valid URL. This test
    is important since the `Baskets` and the `Products` features are loosely coupled
    and can change independently. Here’s the code:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试确保 `Location` 标头包含一个有效的 URL。这个测试很重要，因为 `Baskets` 和 `Products` 功能是松散耦合的，可以独立更改。以下是代码：
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding test method is similar to the first one. The *Arrange* block creates
    an application, seeds the database, and creates an `HttpClient`. The `SeedAsync`
    method is one of the helper methods of the `C18WebApplication` class.The *Act*
    block sends a request to create a basket item.The *Assert* block is divided in
    two. The first ensures that the HTTP response contains a `Location` header and
    that the status code is 201\. The second part (highlighted) takes the `Location`
    header and sends an HTTP request to validate the URL’s validity. This test ensures
    that if we change the URL of the `Products.FetchOne` endpoint, say we prefer `/catalog`
    over `/products`, this test will alert us.We explore the third test case next.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试方法与第一个类似。*安排*（Arrange）块创建了一个应用程序，初始化数据库，并创建了一个 `HttpClient`。`SeedAsync`
    方法是 `C18WebApplication` 类的辅助方法之一。*行动*（Act）块发送一个请求来创建一个篮子项。*断言*（Assert）块分为两部分。第一部分确保
    HTTP 响应包含一个 `Location` 标头，并且状态码是 201。第二部分（突出显示）使用 `Location` 标头发送一个 HTTP 请求来验证
    URL 的有效性。这个测试确保如果我们更改 `Products.FetchOne` 端点的 URL，比如说我们更喜欢 `/catalog` 而不是 `/products`，这个测试会提醒我们。我们接下来探索第三个测试案例。
- en: Third test method
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 第三个测试方法
- en: 'The last test method ensures that the endpoint responds with a 409 Conflict
    status when a consumer tries to add an existing item:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个测试方法确保当消费者尝试添加一个现有项目时，端点会返回 409 冲突状态。
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding test method is very similar to the other two.The *Arrange* block
    creates a test application, seeds the database, and creates an `HttpClient`.The
    *Act* block sends a request using the only item in the database, which we expect
    to result in a conflict.The first part of the *Assert* block ensures that the
    endpoint returns the expected `ProblemDetails` object. The second part validates
    that the endpoint has not changed the quantity in the database.With those three
    tests, we are covering the relevant code of the `AddItem` feature.The other test
    cases are similar, sending HTTP requests and validating the database content.
    Each feature has between one and three tests. We explore a test related to the
    `UpdateQuantity` feature next.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的测试方法与另外两个非常相似。在*安排*（Arrange）块中，创建了一个测试应用程序，初始化数据库，并创建了一个`HttpClient`。在*行动*（Act）块中，使用数据库中的唯一项目发送请求，我们预计这将导致冲突。在*断言*（Assert）块的第一部分确保端点返回预期的`ProblemDetails`对象。第二部分验证端点没有更改数据库中的数量。通过这三个测试，我们覆盖了`AddItem`功能的相应代码。其他测试用例类似，发送HTTP请求并验证数据库内容。每个功能之间有一个到三个测试。我们将在下一节探索与`UpdateQuantity`功能相关的测试。
- en: UpdateQuantityTest
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UpdateQuantityTest
- en: 'We did not cover the `UpdateQuantity` feature, but one of its branches is that
    if the current quantity and the new quantities are the same, the endpoint will
    not update the data. Here’s the snippet:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有涵盖`UpdateQuantity`功能，但其中一个分支是，如果当前数量和新数量相同，端点将不会更新数据。以下是代码片段：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To test this use case, we subscribe to the `SavedChanges` event on the EF Core
    `DbContext`, then ensure the code never calls it. This uses no mocks or stubs
    and tests the real code.This test stands out of the lot, so I considered it worth
    exploring before moving on. Here’s the code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个用例，我们订阅了EF Core `DbContext`上的`SavedChanges`事件，然后确保代码永远不会调用它。这个测试没有使用任何模拟或存根，测试了真实代码。这个测试在众多测试中脱颖而出，所以我考虑在继续之前先探索它。以下是代码：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding test method should sound very familiar by now. However, we use
    a different pattern here.In the *Arrange* block, we create a test application
    and seed the database, but we do not create an `HttpClient`. We use the `ServiceProvider`
    to create the dependencies instead. Then manually instantiate the `UpdateQuantity.Handler`
    class. This allows us to customize the `BasketContext` instance to assess whether
    the endpoint called its `SaveChange` method (highlighted code).The *Act* block
    invokes the `HandleAsync` method directly with a command that should not trigger
    the update because the item has the same quantity as the one we seeded. Unlike
    the other tests, we are not sending an HTTP request.The *Assert* block is simpler
    than the other tests we explored because we test the method, not the HTTP response
    or the database. In this case, we only care whether the `saved` variable is `true`
    or `false`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先前的测试方法应该已经很熟悉了。然而，我们在这里使用了一个不同的模式。在*安排*（Arrange）块中，我们创建了一个测试应用程序并初始化数据库，但我们没有创建`HttpClient`。我们使用`ServiceProvider`来创建依赖项，然后手动实例化`UpdateQuantity.Handler`类。这允许我们自定义`BasketContext`实例，以评估端点是否调用了它的`SaveChange`方法（高亮代码）。在*行动*（Act）块中，我们直接使用一个命令调用`HandleAsync`方法，该命令不会触发更新，因为项目数量与我们初始化的数量相同。与其它测试不同，我们并没有发送HTTP请求。在*断言*（Assert）块中，它比我们探索的其他测试要简单，因为我们测试的是方法，而不是HTTP响应或数据库。在这种情况下，我们只关心`saved`变量是`true`还是`false`。
- en: This test is much faster than the other because no HTTP is involved. When calling
    the `CreateClient` method of a `WebApplicationFactory<T>` object (the `C18WebApplication`
    class in this case), it starts the webserver and then creates the `HttpClient`,
    which has a significant performance overhead.
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个测试比其他测试快得多，因为它不涉及HTTP。当调用`WebApplicationFactory<T>`对象的`CreateClient`方法（在本例中是`C18WebApplication`类）时，它会启动web服务器然后创建`HttpClient`，这有显著的性能开销。
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember this tip when you have to optimize your test suites.
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你需要优化你的测试套件时，记得这个技巧。
- en: And we are done; the test knows whether or not the `DbContext`’s `SavedChanges`
    method was called. Let’s summarize what we learned before moving to the next chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了；测试可以知道`DbContext`的`SavedChanges`方法是否被调用。在进入下一章之前，让我们总结一下我们学到了什么。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We delved into the Request-EndPoint-Response (REPR) design pattern and learned
    that REPR follows the most foundational pattern of the web. The client sends a
    request to an endpoint, which processes it and returns a response. The pattern
    focuses on designing the backend code around the endpoint, making it faster to
    develop, easier to find your way around the project, and more focused on features
    than MVC and layers.We also took a CQS approach around the requests, making them
    queries or commands, depicting all that can happen in a program: read or write
    states.We explored ways to organize the code around such a pattern, from implementing
    trivial to more complex features. We built a technology stack to create an e-commerce
    web application that leverages the REPR pattern and a feature-oriented design.
    We learned how to leverage middleware to handle exceptions globally and how the
    *ExceptionMapper* library provides us with this capability. We also used grey-box
    testing to cover almost all of the project''s logic with just a few tests.Next,
    we explore microservices architecture.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了请求-端点-响应（REPR）设计模式，并了解到 REPR 遵循网络最基础的模式。客户端向端点发送请求，端点处理它并返回响应。该模式侧重于围绕端点设计后端代码，使其开发更快，更容易在项目中找到方向，并且比
    MVC 和层更专注于功能。我们还围绕请求采取了 CQS 方法，使它们成为查询或命令，描述程序中可能发生的一切：读取或写入状态。我们探讨了围绕这种模式组织代码的方法，从实现简单的到更复杂的功能。我们构建了一个技术堆栈，以创建一个利用
    REPR 模式和面向功能设计的电子商务 Web 应用程序。我们学习了如何利用中间件来全局处理异常，以及 *ExceptionMapper* 库如何提供这种能力。我们还使用了灰盒测试，仅用几个测试就覆盖了项目的大部分逻辑。接下来，我们将探索微服务架构。
- en: Questions
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个练习题：
- en: Must we use the *FluentValidation* and *ExceptionMapper* libraries when implementing
    the REPR pattern?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现 REPR 模式时，我们必须使用 *FluentValidation* 和 *ExceptionMapper* 库吗？
- en: What are the three components of the REPR pattern?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REPR 模式的三个组成部分是什么？
- en: Does the REPR pattern dictate that we use nested classes?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REPR 模式是否规定我们必须使用嵌套类？
- en: Why are grey-box integration tests provide much confidence?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么灰盒集成测试能提供很大的信心？
- en: Name an advantage of handling exceptions using middleware.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用中间件处理异常的一个优点是什么？
- en: Further reading
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are a few links to build upon what we learned in the chapter:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助我们巩固本章所学的内容：
- en: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FluentValidation: [https://adpg.link/xXgp](https://adpg.link/xXgp)'
- en: 'FluentValidation.AspNetCore.Http: [https://adpg.link/qsao](https://adpg.link/qsao)'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FluentValidation.AspNetCore.Http: [https://adpg.link/qsao](https://adpg.link/qsao)'
- en: 'ExceptionMapper: [https://adpg.link/ESDb](https://adpg.link/ESDb)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ExceptionMapper: [https://adpg.link/ESDb](https://adpg.link/ESDb)'
- en: 'Mapperly: [https://adpg.link/Dwcj](https://adpg.link/Dwcj)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mapperly: [https://adpg.link/Dwcj](https://adpg.link/Dwcj)'
- en: 'MVC Controllers are Dinosaurs - Embrace API Endpoints: [https://adpg.link/NGjm](https://adpg.link/NGjm)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 控制器是恐龙 - 拥抱 API 端点：[https://adpg.link/NGjm](https://adpg.link/NGjm)
- en: Answers
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 答案
- en: No. REPR does not dictate how to implement it. You can create your own stack
    or go barebone ASP.NET Core minimal API and implement everything by hand in the
    project.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不。REPR 并没有规定如何实现它。你可以创建自己的堆栈或使用裸骨 ASP.NET Core 最小 API，并在项目中手动实现一切。
- en: REPR consists of a request, an endpoint, and a response.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REPR 由请求、端点和响应组成。
- en: No. REPR does not prescribe any implementation details.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不。REPR 没有规定任何实现细节。
- en: Grey-box integration tests provide much confidence in their outcome because
    they test the feature almost end-to-end, ensuring all the pieces are there, from
    the services in the IoC container to the database.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 灰盒集成测试因其几乎端到端测试功能而提供了很大的信心，确保从 IoC 容器中的服务到数据库的所有部分都在。
- en: Handling exceptions using middleware allows for centralizing the management
    of exceptions, encapsulating that responsibility in a single place. It also provides
    for uniformizing the output, sending the clients a response in the same format
    for all errors. It removes the burden of handling each exception individually,
    eliminating `try`-`catch` boilerplate code.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用中间件处理异常允许集中管理异常，将这一责任封装在单个位置。它还提供了统一输出，对所有错误发送客户端以相同格式的响应。它消除了逐个处理每个异常的负担，消除了
    `try`-`catch` 炉边代码。
