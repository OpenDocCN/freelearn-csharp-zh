- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Crafting Web APIs for Service Delivery
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为服务交付构建Web API
- en: As part of ASP.NET Core 9, web APIs can be used to build HTTP services, which
    can be made available for both web page consumption and mobile applications. The
    structure provided by the .NET Core platform enables the development of APIs with
    high quality and performance. In this chapter, we will learn more about web APIs
    and the standards, conventions, and best practices for delivering solutions using
    them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为ASP.NET Core 9的一部分，Web API可以用来构建HTTP服务，这些服务可以提供给网页消费和移动应用程序。.NET Core平台提供的结构使得可以开发出高质量和性能的API。在本章中，我们将更多地了解Web
    API以及使用它们提供解决方案的标准、约定和最佳实践。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Delivering business as a service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务作为服务交付
- en: Exploring minimal APIs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索最小API
- en: Implementing APIs using the controller-based approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于控制器的方法实现API
- en: Working with documentation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与文档一起工作
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter uses the Postman tool, which will be used as a client for consuming
    APIs. This tool will also be used in other chapters of the book and its installation
    and use are free.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用Postman工具，该工具将用作消费API的客户端。此工具还将用于本书的其他章节，其安装和使用是免费的。
- en: 'You can download Postman on your operating system through the following link:
    [https://www.postman.com/downloads/](https://www.postman.com/downloads/) .'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接在您的操作系统上下载Postman：[https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    .
- en: 'The code examples used in this chapter can be found in the book’s GitHub repository:
    [https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/)
    .'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码示例可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/](https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/)
    .
- en: Delivering business as a service
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将业务作为服务交付
- en: As we have learned in the last chapters, ASP.NET Core 9 offers different frameworks
    for the development of rich web-based applications. Regardless of the chosen model,
    whether client-side or server-side, we must implement negotiation flows that are
    responsible for the operation of the applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中学到的，ASP.NET Core 9为开发丰富的基于Web的应用程序提供了不同的框架。无论选择哪种模型，无论是客户端还是服务器端，我们都必须实现负责应用程序操作的协商流程。
- en: Imagine a system for a digital bank where users can perform different types
    of operations in their checking account, such as transfers, analyzing extracts,
    checking the account balance, and even purchasing a new service package. Each
    of these operations has business requirements and rules. For example, it should
    not be possible to transfer 200 euros if the user’s account balance is 100 euros.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个数字银行的系统，用户可以在他们的支票账户中执行不同类型的操作，例如转账、分析摘要、检查账户余额，甚至购买新的服务套餐。这些操作中的每一个都有业务需求和规则。例如，如果用户的账户余额是100欧元，则不应允许转账200欧元。
- en: This negotiation flow can be implemented perfectly using Razor Pages, MVC, or
    a hybrid model, as we have learned. We can easily have a web-based application
    being performed on a server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学过，可以使用Razor Pages、MVC或混合模型完美地实现这种协商流程。我们可以轻松地将基于Web的应用程序在服务器上执行。
- en: However, imagine that users have requested a mobile application. It should offer
    the same features as the web version.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，想象一下，用户请求了一个移动应用程序。它应该提供与网页版本相同的特性。
- en: In this case, any technologies could be used for this purpose, either for native
    or hybrid development. But how would the business logic of the application be
    developed? What if there was a change to an application rule? Would it be necessary
    to update two distinct types of code to make the applications run correctly?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，可以用于此目的的技术可以是原生或混合开发。但是，应用程序的业务逻辑应该如何开发？如果应用程序规则发生了变化，是否需要更新两种不同的代码以使应用程序正确运行？
- en: The best practice, in this case, is to centrally manage all the code that concerns
    the business rules. This would allow different types of application interfaces,
    whether browsers, mobile applications, or even other applications, to interact
    with a business context.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最佳实践是对涉及业务规则的代码进行集中管理。这将允许不同类型的应用程序接口，无论是浏览器、移动应用程序，甚至是其他应用程序，都能与业务环境进行交互。
- en: This centralized application is made available in web API format, which is actually
    an application that is distributed through the internet. The **Representational
    State Transfer** ( **REST** ) protocol, which is based on the HTTP protocol commonly
    used in web application interactions, allows clients (browsers, mobile apps, and
    other applications) to consume resources independently in a controlled and centralized
    way.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个集中式应用程序以Web API格式提供，实际上是一个通过互联网分发的应用程序。基于在Web应用程序交互中常用HTTP协议的**表示状态转移**（**REST**）协议，允许客户端（浏览器、移动应用和其他应用程序）以受控和集中的方式独立消费资源。
- en: The model for providing business contexts over the internet is called **business
    as a service** ( **BaaS** ), allowing organizations to offer specific features
    or resources such as services that can be consumed by other companies or applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上提供业务上下文的模型称为**业务即服务**（**BaaS**），允许组织提供特定功能或资源，例如可以被其他公司或应用程序消费的服务。
- en: '![Figure 3.1 – BaaS](img/B21788_03_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – BaaS](img/B21788_03_1.jpg)'
- en: Figure 3.1 – BaaS
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – BaaS
- en: Fortunately, ASP.NET Core 9 offers us a powerful model for creating web APIs;
    however, we must understand some foundations before learning how to create BaaS
    resources. In the rest of this section, we look at some of the important foundational
    concepts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ASP.NET Core 9为我们提供了一个强大的模型来创建Web API；然而，在学习如何创建BaaS资源之前，我们必须了解一些基础知识。在本节的其余部分，我们将探讨一些重要的基础概念。
- en: HTTP verbs and conventions
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP动词和约定
- en: Communication with an API is done through the **HTTP** protocol, which has some
    operations called **HTTP verbs** .
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与API的通信是通过**HTTP**协议完成的，该协议有一些称为**HTTP动词**的操作。
- en: 'These verbs determine the type of intention in a given resource. The most common
    HTTP verbs are these:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动词确定了给定资源中的意图类型。最常见的HTTP动词如下：
- en: '**GET** : This method is used to request data in a feature, such as a read-only
    operation; when we type a URL in the browser, as a response, we receive an HTML
    page. GET can also be used to determine the intention to obtain a list of registered
    users, for example.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**：此方法用于请求功能中的数据，例如只读操作；当我们输入浏览器中的URL时，作为响应，我们收到一个HTML页面。GET也可以用来确定获取注册用户列表的意图，例如。'
- en: '**POST** : When you send a POST request, you are usually creating a new feature
    on the server. This method includes data in the body of the request.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**：当你发送POST请求时，你通常是在服务器上创建一个新的功能。此方法包括请求体中的数据。'
- en: '**PUT** : PUT requests are used to update a feature. In this case, any changes
    made to a resource’s attributes must be sent in the request body, and the server
    replaces the resource with the sent data.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**：PUT请求用于更新功能。在这种情况下，对资源属性所做的任何更改都必须在请求体中发送，并且服务器将用发送的数据替换资源。'
- en: '**DELETE** : DELETE requests are used to request the removal of a specified
    feature.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**：DELETE请求用于请求删除指定的功能。'
- en: '**PATCH** : PATCH requests are used to apply partial modifications to a feature.
    Unlike the PUT verb, which replaces the entire feature, PATCH updates only the
    specified parts of the feature.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**：PATCH请求用于对功能应用部分修改。与替换整个功能的PUT动词不同，PATCH只更新功能的指定部分。'
- en: '**HEAD** : This is often used to verify the availability and metadata of a
    feature without downloading its content.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**：这通常用于验证功能的存在性和元数据，而无需下载其内容。'
- en: '**OPTIONS** : An OPTION requirement is used to describe communication options
    for the destination feature. It can be used to consult the server about the supported
    methods and other information about the feature.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPTIONS**：OPTION请求用于描述目标功能的通信选项。它可以用来咨询服务器支持的方法和有关功能的其他信息。'
- en: Verbs are very important to determine which type of operation will be performed
    by an API. As we can see from the preceding list, there are some verbs that are
    similar to each other, such as POST and PUT. Both can be used to create and update
    resources. However, using the right verb means the integration process can always
    be easily understood. There is no strict rule for the use of certain verbs, but
    it is a good practice to use the right ones.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 动词对于确定API将执行哪种类型的操作非常重要。从上述列表中我们可以看到，有一些动词彼此相似，例如POST和PUT。两者都可以用来创建和更新资源。然而，使用正确的动词意味着集成过程始终可以轻松理解。对于某些动词的使用没有严格的规则，但使用正确的动词是一种良好的实践。
- en: REST
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST
- en: REST is an architectural style, a set of constraints and principles that encourage
    stateless, scalable, and easily maintainable web service design.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种架构风格，是一组约束和原则，鼓励无状态、可扩展和易于维护的Web服务设计。
- en: One of the characteristics of REST services is stateless communication, where
    each request from a client to a server must contain all the information necessary
    to understand and process the request. The server must not store any information
    about the client’s state between requests. This ensures that requests can be handled
    independently, making the system scalable and easy to maintain.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务的特点之一是无状态通信，即客户端向服务器发出的每个请求都必须包含理解和处理请求所需的所有信息。服务器不得在请求之间存储任何关于客户端状态的信息。这确保了请求可以独立处理，使系统可扩展且易于维护。
- en: There is also the concept of resources, be it a physical object, a conceptual
    entity, or a piece of data. Each resource is identified by a unique URL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的概念也存在，无论是物理对象、概念实体还是数据片段。每个资源都由一个唯一的URL标识。
- en: REST services use standard HTTP methods to perform **Create** , **Read** , **Update**
    , **Delete** ( **CRUD** ) operations on resources. Each HTTP method corresponds
    to a specific action on the resource. For example, GET is used to retrieve data,
    POST to create a new resource, PUT to update a resource, and DELETE to remove
    a resource. This approach provides a uniform and consistent interface for interacting
    with resources. This means that the same HTTP verbs and methods are used consistently
    across different resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务使用标准的HTTP方法来对资源执行**创建**、**读取**、**更新**、**删除**（**CRUD**）操作。每个HTTP方法对应于资源上的特定操作。例如，GET用于检索数据，POST用于创建新资源，PUT用于更新资源，DELETE用于删除资源。这种方法为与资源交互提供了一个统一和一致的接口。这意味着在不同的资源之间始终一致地使用相同的HTTP动词和方法。
- en: HTTP codes are important and enable easy integrations and use of APIs. HTTP
    status codes, in the same way, make API responses standardized and allow applications
    to handle different scenarios appropriately.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码非常重要，并使API的集成和使用变得容易。同样，HTTP状态码使API响应标准化，并允许应用程序适当地处理不同的场景。
- en: HTTP status codes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP状态码
- en: HTTP status codes indicate the result of an HTTP request and help clients understand
    the result of their actions. These status codes are essential for effective communication
    between clients and servers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码表示HTTP请求的结果，并帮助客户端理解其操作的结果。这些状态码对于客户端和服务器之间有效通信至关重要。
- en: 'HTTP status codes are grouped into five classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码被分为五类：
- en: Information responses (100-199)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息响应（100-199）
- en: Successful responses (200-299)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功响应（200-299）
- en: Redirection responses (300-399)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向响应（300-399）
- en: Client error responses (400-499)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端错误响应（400-499）
- en: Server error responses (500-599)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器错误响应（500-599）
- en: HTTP status code references
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码参考
- en: 'You can learn more about status codes here: [https://httpwg.org/specs/rfc9110.html#overview.of.status.codes](https://httpwg.org/specs/rfc9110.html#overview.of.status.codes)
    .'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于状态码的信息：[https://httpwg.org/specs/rfc9110.html#overview.of.status.codes](https://httpwg.org/specs/rfc9110.html#overview.of.status.codes)。
- en: Each status code has a return type that can be used by the client application
    or even the browser. When making an HTTP request, the response has a header, where
    the HTTP status code is located, and there may even be a body providing further
    details about the request response.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态码都有一个返回类型，可以被客户端应用程序或甚至浏览器使用。在发起HTTP请求时，响应有一个头部，其中包含HTTP状态码，甚至可能有一个主体提供关于请求响应的更多详细信息。
- en: 'In general, the main HTTP status codes used are these:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，主要使用的HTTP状态码如下：
- en: '**200 OK** : Indicates a successful request'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200 OK**：表示请求成功'
- en: '**201 Created** : Indicates that a resource was created successfully'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**201 已创建**：表示资源已成功创建'
- en: '**400 Bad Request** : Indicates an error in the client request'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400 错误请求**：表示客户端请求中存在错误'
- en: '**401 Unauthorized** : Indicates that the client does not have proper authentication'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**401 未授权**：表示客户端没有适当的认证'
- en: '**404 Not Found** : Indicates that the requested resource does not exist'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**404 未找到**：表示请求的资源不存在'
- en: '**500 Internal Server Error** : Indicates a server-side problem'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500 内部服务器错误**：表示服务器端存在问题'
- en: 'The following code represents an example of a successful response to an API
    request:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示对API请求的成功响应示例：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the status code (in the first line of code) is **200** , indicating
    that the request was successful. Furthermore, there is a body in the response
    containing more information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，状态码（在代码的第一行）是**200**，表示请求成功。此外，响应体中还包含更多信息。
- en: Using HTTP status codes appropriately allows APIs to be easily integrated into
    different types of systems. As we create our APIs using them, this will become
    clearer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用HTTP状态码可以使API轻松集成到不同类型的系统中。随着我们使用它们创建API，这一点将变得更加清晰。
- en: BaaS delivery offers several benefits for teams to segregate the responsibilities
    of each context into applications that can be easily integrated into different
    scenarios. We’ve learned enough about the fundamentals of APIs; it’s time to start
    creating APIs using the ASP.NET Core 9 minimal APIs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: BaaS交付为团队提供了将每个上下文的职责分离到可以轻松集成到不同场景中的应用程序的好处。我们已经足够了解API的基础知识；现在是时候开始使用ASP.NET
    Core 9最小API创建API了。
- en: Exploring minimal APIs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索最小API
- en: One of the ways to create web services in ASP.NET Core 9 is to use the minimal
    APIs approach, which offers a simple way to make APIs available and add features
    and configurations as needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core 9中创建Web服务的一种方法是通过使用最小API方法，这提供了一种简单的方式来提供API并按需添加功能和配置。
- en: The simple structure of minimal APIs allows developers and teams to provide
    REST-based functionalities in an agile manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API的简单结构允许开发者和团队以敏捷的方式提供基于REST的功能。
- en: There are many applicable scenarios for using this approach, and the one you
    choose will depend on the size of the project and the teams involved. The fact
    is that minimal APIs offer, in general, the same functionalities as the controller-based
    model, which we will discuss in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法有许多适用场景，你选择哪种将取决于项目的规模和涉及的团队。事实上，最小API通常提供与基于控制器的模型相同的功能，我们将在下一节讨论。
- en: 'To create a minimal API project, we will base ourselves on a product management
    model. To do this, we will provide an API according to the following table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建最小API项目，我们将基于产品管理模型。为此，我们将根据以下表格提供API：
- en: '| **Route** | **Description** | **Request Body** | **Response Body** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **描述** | **请求体** | **响应体** |'
- en: '| GET /Product | Get all products | None | Array of products |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| GET /Product | 获取所有产品 | 无 | 产品数组 |'
- en: '| GET /Product/{id} | Get a product by ID | None | A product object |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| GET /Product/{id} | 通过ID获取产品 | 无 | 产品对象 |'
- en: '| POST /Product | Add a new product | Product object | A product object |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| POST /Product | 添加新产品 | 产品对象 | 产品对象 |'
- en: '| PUT /Product/{id} | Update an existing product | Product Item | None |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| PUT /Product/{id} | 更新现有产品 | 产品项 | 无 |'
- en: '| DELETE /Product/{id} | Delete an existing product by ID | None | None |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| DELETE /Product/{id} | 通过ID删除现有产品 | 无 | 无 |'
- en: Table 3.1 - Product management actions
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 - 产品管理操作
- en: The Table 3.1 basically maps the routes that will be used in the product API,
    mapping the corresponding HTTP verbs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1基本上映射了将在产品API中使用的路由，映射相应的HTTP动词。
- en: We can also see in the table that some routes are similar, differing only by
    the HTTP verbs used. This is a convention used by the REST model, where HTTP verbs
    indicate the intention for a given resource.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在表中看到，一些路由是相似的，只是使用的HTTP动词不同。这是REST模型中使用的约定，其中HTTP动词表示对给定资源的意图。
- en: In this case, the resource is the product, defined by the **/Product** route.
    In some cases, the **/Product/{id}** route indicates that there will be a parameter
    added to the resource route. This parameter will be part of the resource URL and
    will be mapped as a parameter of the method to be executed in the API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，资源是产品，由**/Product**路由定义。在某些情况下，**/Product/{id}**路由表示将在资源路由中添加一个参数。该参数将是资源URL的一部分，并将映射为API中要执行的方法的参数。
- en: 'Now let’s create a minimal API project and implement product registration:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个最小的API项目并实现产品注册：
- en: 'Open your operating system’s command prompt, in a directory of your choice,
    and run the following line of code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您操作系统的命令提示符，在您选择的目录中，并运行以下代码行：
- en: '[PRE1]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The web project template is a shortcut for creating an empty ASP.NET Core project,
    which will be used as the minimal API.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web项目模板是创建空ASP.NET Core项目的快捷方式，它将被用作最小API。
- en: A folder called **ProductAPI** will be created containing all the files needed
    for the project. The main file is **Program.cs** .
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将创建一个名为**ProductAPI**的文件夹，其中包含项目所需的所有文件。主文件是**Program.cs**。
- en: 'Navigate to the **ProductAPI** directory and then type the following command
    and press *Enter* :'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**ProductAPI**目录，然后键入以下命令并按*Enter*：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Visual Studio Code editor will appear.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Visual Studio Code编辑器将出现。
- en: 'Then, open the **Program.cs** file, which will have the following structure:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开**Program.cs**文件，它将具有以下结构：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, there is no definition of a class. This is the main application
    file, the entry point that will be used to execute the API.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，没有类的定义。这是主要的应用程序文件，是用于执行API的入口点。
- en: In the first two lines of the file, we have the app definition, through the
    **web application** builder class. This definition was presented in [*Chapter
    2*](B21788_02.xhtml#_idTextAnchor031) , where we discussed the structure of a
    project in ASP.NET Core 9. However, it is important to note that the app will
    be created with some basic configurations, abstracted by the framework, such as
    filters and settings, among other aspects.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在文件的前两行中，我们有应用程序的定义，通过**Web应用程序**构建器类。这个定义在[*第二章*](B21788_02.xhtml#_idTextAnchor031)中已经介绍过，我们讨论了ASP.NET
    Core 9中项目的结构。然而，需要注意的是，应用程序将使用一些基本的配置被创建，这些配置由框架抽象化，例如过滤器和其他方面。
- en: Another important aspect of this file is the **MapGet** method of the **app**
    variable. This is a method that extends the previously created app, allowing the
    creation of a route that will be accessed via URL using the HTTP GET verb.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件的另一个重要方面是**app**变量的**MapGet**方法。这是一个扩展先前创建的应用程序的方法，允许创建一个将通过URL使用HTTP GET动词访问的路由。
- en: This method has a parameter that defines the route pattern; in this case, **/**
    is used, which means the root of the application. The second parameter is an action,
    which uses one of C#’s features. This action will be executed when this route
    is requested.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法有一个参数定义了路由模式；在这种情况下，使用**/**，这意味着应用程序的根。第二个参数是一个操作，它使用C#的一个特性。当请求此路由时，将执行此操作。
- en: Actions and methods
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 操作和方法
- en: 'Actions can be seen as methods defined inline and are composed of two main
    parts, just like methods:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以被视为内联定义的方法，由两个主要部分组成，就像方法一样：
- en: '**- Setting parameters** : Setting parameters if necessary'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 设置参数**：如有必要设置参数'
- en: '**- Action body** : The code that will be executed'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**- 操作体**：将要执行的代码'
- en: Actions can be replaced by methods, instead of being defined inline.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以被方法替代，而不是内联定义。
- en: 'To perform a test, just run the application by typing the following command
    at the prompt:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行测试，只需在提示符中键入以下命令运行应用程序：
- en: '[PRE4]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Logs containing the API URL will be displayed. Now, open **Postman** , select
    **File** | **New Tab** , enter the application address, and then click **Send**
    :'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将显示包含API URL的日志。现在，打开**Postman**，选择**文件** | **新建标签页**，输入应用程序地址，然后点击**发送**：
- en: '![Figure 3.2 – Getting an API resource using a minimal API](img/B21788_03_2.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 使用最小API获取API资源](img/B21788_03_2.jpg)'
- en: Figure 3.2 – Getting an API resource using a minimal API
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 使用最小API获取API资源
- en: As we can see, in just a few lines of code, it was possible to execute an API,
    even returning a simple **Hello** **World** string.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，仅仅几行代码，就实现了执行一个API，甚至返回一个简单的**Hello World**字符串。
- en: The minimal API offers the ability to quickly make APIs available in a simple
    way and allow other features and configurations to be added according to a project’s
    needs. This brings great agility to teams.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最小API提供了以简单方式快速使API可用，并允许根据项目的需求添加其他功能和配置的能力。这为团队带来了极大的敏捷性。
- en: 'Let’s add some features to the **ProductAPI** project. To do this, create a
    class called **Product.cs** in the root of the project. The class will be defined
    according to the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向**ProductAPI**项目添加一些功能。为此，在项目的根目录中创建一个名为**Product.cs**的类。该类将根据以下代码定义：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are just defining an object that will represent a product. Now you will need
    to change the **Program.cs** file; we will include the methods listed in the preceding
    table, mapping the API routes and adding functionality to the API methods.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是定义了一个将代表产品的对象。现在你需要更改**Program.cs**文件；我们将包括前面表格中列出的方法，映射API路由并添加到API方法的功能。
- en: 'The **Program.cs** file will contain some methods as shown in the following
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Program.cs**文件将包含一些方法，如下面的示例所示：'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we can see, the APIs were created similarly to the previously defined route
    table, respecting the HTTP verbs defined through the **MapGet** , **MapPost**
    , **MapPut** , and **MapDelete** methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，API 的创建方式与之前定义的路由表类似，遵循通过 **MapGet**、**MapPost**、**MapPut** 和 **MapDelete**
    方法定义的 HTTP 动词。
- en: The code in question is very simple, creating a simulation of a product register.
    To do this, a variable was defined using the code **List<Product> products = new
    List<Product>()** , which will contain the products available in the API at runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有关问题的代码非常简单，创建了一个产品注册的模拟。为此，使用以下代码定义了一个变量：**List<Product> products = new List<Product>()**，该变量将在运行时包含
    API 中可用的产品。
- en: Another important functionality described in the preceding code is the use of
    the utility class called **Results** . This class is used in all methods, encapsulating
    important functionalities for returning the request, such as defining the status
    code related to the request in the response header.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中还描述了另一个重要的功能，即使用名为 **Results** 的实用工具类。此类在所有方法中使用，封装了返回请求的重要功能，例如在响应头中定义与请求相关的状态码。
- en: Let’s look at the API for the POST verb in more detail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看 POST 动词的 API。
- en: The **MapPost** method defines the **/Products** string as a route and as an
    action; it expects a product as a parameter, adds it to the list, and returns
    **OK** (status code 200).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapPost** 方法将 **/Products** 字符串定义为路由和操作；它期望一个产品作为参数，将其添加到列表中，并返回 **OK**（状态码
    200）。'
- en: But how do we submit a product to the API? ASP.NET Core 9 has the concept of
    a **bind** , which processes the request and creates and maps an object according
    to the request’s needs. In this case, an object in JSON format must be sent, which
    will be mapped to a product object when the POST method is executed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何向 API 提交一个产品？ASP.NET Core 9 有一个名为 **bind** 的概念，它处理请求并根据请求的需求创建和映射一个对象。在这种情况下，必须发送一个
    JSON 格式的对象，当执行 POST 方法时，它将被映射到产品对象。
- en: This is an excellent feature of ASP.NET Core 9, which abstracts all the complexity
    and, during the execution of a route, resolves the parameters expected by the
    action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ASP.NET Core 9 的一个优秀功能，它抽象了所有复杂性，并在执行路由时解决动作期望的参数。
- en: 'Let’s add a product using the API with the following commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令通过 API 添加一个产品：
- en: 'Run the application with the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行应用程序：
- en: '[PRE7]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then open Postman and go to **File** | **New Tab** .
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后打开 Postman 并转到 **文件** | **新建标签页**。
- en: Set the method to **POST** and add the API address with the **/** **Product**
    suffix.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法设置为 **POST** 并添加带有 **/** **Product** 后缀的 API 地址。
- en: Then select the **Body** tab, as shown in *Figure 3* *.3* .
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择 *图 3.3* 中的 **Body** 选项卡。
- en: '![Figure 3.3 – Configuring a POST request](img/B21788_03_3.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – 配置 POST 请求](img/B21788_03_3.jpg)'
- en: Figure 3.3 – Configuring a POST request
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – 配置 POST 请求
- en: Select the **raw** option and then set the type to **JSON** , as shown in *Figure
    3* *.4* .
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **raw** 选项，然后将类型设置为 **JSON**，如 *图 3.4* 所示。
- en: '![Figure 3.4 – Defining the request body](img/B21788_03_4.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 定义请求体](img/B21788_03_4.jpg)'
- en: Figure 3.4 – Defining the request body
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 定义请求体
- en: 'Add the following JSON:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 JSON：
- en: '[PRE8]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code just represents a JSON object that has the properties of
    a product. These properties were defined in the **Product.cs** class that was
    added to the project. You can see the full code through the book’s source code
    link, provided in the *Technical* *requirements* section.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码仅表示一个具有产品属性的 JSON 对象。这些属性在添加到项目的 **Product.cs** 类中定义。您可以通过书中提供的源代码链接查看完整代码，该链接位于
    *技术要求* 部分。
- en: Click on the **Send** button.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **发送** 按钮。
- en: '![Figure 3.5 – POST request result](img/B21788_03_5.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – POST 请求结果](img/B21788_03_5.jpg)'
- en: Figure 3.5 – POST request result
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – POST 请求结果
- en: As a result, the registered product object was returned. Note the HTTP status
    code highlighted in *Figure 3* *.5* , with the value **200** and the description
    **OK** .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，返回了注册的产品对象。注意在 *图 3.5* 中突出显示的 HTTP 状态码，其值为 **200**，描述为 **OK**。
- en: When executing a POST call to the API, ASP.NET Core identified a route mapped
    to the HTTP verb. Then, it binds the JSON object, sent as the request body, to
    the product object, defined as the POST request parameter. After that, the action
    request is made, which finally registers a product in the memory list and returns
    it, again serialized in JSON.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行对API的POST调用时，ASP.NET Core识别了一个映射到HTTP动词的路由。然后，它将作为请求体发送的JSON对象绑定到定义为POST请求参数的产品对象上。之后，执行动作请求，最终在内存列表中注册一个产品并返回，再次序列化为JSON。
- en: As we learned, it is very simple to create an API using a minimal API. With
    just a few lines of code, it was possible to create a complete product register.
    Of course, as it is a .NET platform project, it is possible to define different
    classes to better structure your projects, since as the complexity increases,
    along with the number of APIs, it will become very difficult to manage all the
    routes in just one file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，使用最小API创建API非常简单。仅用几行代码，就创建了一个完整的产品注册。当然，作为一个.NET平台项目，可以定义不同的类来更好地组织项目，因为随着复杂性的增加，以及API数量的增加，仅在一个文件中管理所有路由将变得非常困难。
- en: However, even though a minimal API supports most ASP.NET Core 9 functionality
    for creating web APIs, using a more structured and prepared approach for large
    projects can be a great option, and this is the case for controller-based projects,
    which we will discuss in the next section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管最小API支持大多数ASP.NET Core 9用于创建Web API的功能，但使用更结构化和准备好的方法来处理大型项目可能是一个很好的选择，这就是基于控制器的项目的情况，我们将在下一节中讨论。
- en: Implementing APIs using the controller-based approach
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于控制器的方法实现API
- en: Controller-based projects are another way to deliver APIs using ASP.NET Core
    9. This project type also implements the **Model-View-Controller** ( **MVC** )
    pattern, which we learned about in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031)
    .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 基于控制器的项目是另一种使用ASP.NET Core 9提供API的方法。此项目类型也实现了我们在[*第2章*](B21788_02.xhtml#_idTextAnchor031)中学到的**模型-视图-控制器**（**MVC**）模式。
- en: The controller-based approach has a more complete and robust structure to deliver
    any type of API, so it supports different business contexts. In the same way as
    minimal APIs, it is possible to extend API functionalities by adding different
    types of configurations and customizations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基于控制器的方法具有更完整和健壮的结构来提供任何类型的API，因此它支持不同的业务上下文。与最小API一样，可以通过添加不同类型的配置和自定义来扩展API功能。
- en: Creating a controller-based API
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建基于控制器的API
- en: 'To create a controller-based API, you just need to type the following code
    in the terminal, in a directory of your choice:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建基于控制器的API，你只需要在终端中输入以下代码，在所选目录中：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command uses the **webapi** template, which by default creates a minimal
    API project. In this case, we are adding a **-controllers** argument to state
    that a web API should be created using the controller-based approach.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用**webapi**模板，默认情况下创建一个最小API项目。在这种情况下，我们添加了一个**-controllers**参数来指明应该使用基于控制器的方法创建Web
    API。
- en: As we can see in *Figure 3* *.6* , the structure of the controller-based API
    project is very similar to MVC, which we learned about in [*Chapter 2*](B21788_02.xhtml#_idTextAnchor031)
    .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图3.6*所示，基于控制器的API项目结构与我们在[*第2章*](B21788_02.xhtml#_idTextAnchor031)中学到的MVC非常相似。
- en: '![Figure 3.6 – Controller-based project structure](img/B21788_03_6.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 基于控制器的项目结构](img/B21788_03_6.jpg)'
- en: Figure 3.6 – Controller-based project structure
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 基于控制器的项目结构
- en: The difference between this project and minimal APIs is the segregation of responsibilities
    and organization of the project. Since each controller is related to a specific
    resource, there is no need to implement all the API code in the **Program.cs**
    file, in addition to bringing greater possibilities, especially in larger projects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与最小API相比，这种项目与责任分离和项目组织不同。由于每个控制器都与一个特定的资源相关联，因此不需要在**Program.cs**文件中实现所有API代码，这除了带来更大的可能性外，尤其是在大型项目中。
- en: However, the approach to configurations and extensions is similar to what we
    learned about in regard to minimal APIs; it is all done through the **Program.cs**
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，配置和扩展的方法与我们关于最小API所学的类似；所有这些都是在**Program.cs**文件中完成的。
- en: 'The default project has some settings already defined, which can be easily
    modified. The following code is from the **Program.cs** file, which is created
    automatically:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认项目已经定义了一些设置，这些设置可以很容易地进行修改。以下代码来自自动创建的**Program.cs**文件：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, we will focus on two main configurations added in the file,
    which concern the **AddEndpointsApiExplorer** and **MapControllers** methods.
    The rest of the methods will be discussed later:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将关注文件中添加的两个主要配置，它们与**AddEndpointsApiExplorer**和**MapControllers**方法有关。其他方法将在稍后讨论：
- en: '**AddEndpointsApiExplorer** : This is an extension method that aims to register
    services that are used to expose information about the application’s endpoints.
    This information is used by API documentation generation services, such as **Swagger**
    , which we will discuss in the next section.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AddEndpointsApiExplorer**：这是一个扩展方法，旨在注册用于公开应用程序端点信息的服务。这些信息被API文档生成服务（如**Swagger**）使用，我们将在下一节讨论。'
- en: '**MapControllers** : This is an application configuration responsible for mapping
    added attributes into controller classes and, therefore, automatically defining
    APIs and routes.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MapControllers**：这是一个应用程序配置，负责将添加的属性映射到控制器类中，因此自动定义API和路由。'
- en: These methods allow the application to adapt more easily to the need to expose
    services as APIs and enable the implementation of good practices, making any additions
    and modifications more dynamic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使应用程序更容易适应将服务公开为API的需求，并使实现良好实践变得更具动态性，使任何添加和修改都更加灵活。
- en: Using the same example of a product service previously created in the minimal
    API approach, let’s understand this implementation adapted for the controller
    model.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前在最小API方法中创建的产品服务示例，让我们理解这个针对控制器模型调整的实现。
- en: Understanding the product controller
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解产品控制器
- en: The implementation of the product API using the controller-based approach follows
    the class definition model. Therefore, each API must have a controller, which
    will be responsible for processing requests for each resource.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于控制器的产品API实现遵循类定义模型。因此，每个API都必须有一个控制器，该控制器将负责处理每个资源的请求。
- en: 'Based on the previous example, the product API will have the following definition:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的示例，产品API将具有以下定义：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Some code blocks have been omitted to make it easier to read and understand
    the most important points in this class definition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使阅读和理解这个类定义中最重要的点更加容易，一些代码块已被省略。
- en: The class represents a controller that will handle requests to the product API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该类代表一个控制器，用于处理对产品API的请求。
- en: 'Let’s analyze some details of the code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下代码的一些细节：
- en: '**ApiController** : This is an attribute that is added to a class, causing
    it to be mapped as an API controller. This way, when adding the **MapController**
    configuration to the **Program.cs** file, all classes marked as attributes will
    be responsible for processing requests from the respective APIs.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ApiController**：这是一个添加到类中的属性，导致它被映射为API控制器。这样，当将**MapController**配置添加到**Program.cs**文件时，所有标记为属性的类都将负责处理相应API的请求。'
- en: '**Route** : This attribute can be used either in a controller, represented
    by a class, or in an action, represented by a method. Its function is to define
    a URL pattern for the route. The **[controller]** parameter is a token that is
    automatically replaced, at runtime, by the class name, without the **controller**
    suffix. For the route to take the method name into account, in the case of annotating
    an action with the route attribute, the **[action]** token must be used.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Route**：这个属性可以在控制器（由一个类表示）或动作（由一个方法表示）中使用。它的功能是定义路由的URL模式。**[controller]**参数是一个在运行时自动替换的令牌，替换为不带**controller**后缀的类名。为了使路由考虑方法名，在用路由属性注解动作的情况下，必须使用**[action]**令牌。'
- en: '**ProductController** : This is the name of the class following the MVC convention.
    There is no obligation to use this suffix, but it is a good practice, as controllers
    do not need to be in the **Controllers** folder, making it easier for other members
    of a development team to read.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ProductController**：这是遵循MVC约定的类名。没有义务使用这个后缀，但这是一个好习惯，因为控制器不需要放在**Controllers**文件夹中，这样其他开发团队成员阅读起来更方便。'
- en: '**ControllerBase** : All controller classes should inherit from the **ControllerBase**
    class, which is appropriate for APIs. This class provides many properties and
    methods that are useful for handling HTTP requests.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ControllerBase**：所有控制器类都应该继承自**ControllerBase**类，这对于API来说是合适的。这个类提供了许多处理HTTP请求时有用的属性和方法。'
- en: '**HttpGet** : This attribute determines the HTTP verb that an action should
    respond to processing. For each verb, there is a different attribute. In the preceding
    example, there are two GET methods, but one is an overload, with one parameter.
    For the controller to know which GET method should be requested, a different route
    must be defined for methods with the same name. In this case, the second GET method
    has an **{id}** parameter, which will be included in the route, differentiating
    the actions. The ASP.NET Core 9 framework will take care of binding the method’s
    **id** parameter.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HttpGet**：此属性确定一个操作应该响应的HTTP动词。对于每个动词，都有一个不同的属性。在先前的示例中，有两个GET方法，但一个是重载，有一个参数。为了控制器知道应该请求哪个GET方法，必须为具有相同名称的方法定义不同的路由。在这种情况下，第二个GET方法有一个**{id}**参数，它将被包含在路由中，区分操作。ASP.NET
    Core 9框架将负责绑定方法中的**id**参数。'
- en: As we can see, a big difference in relation to the innovative approach of the
    minimal API is the ability to segregate responsibility into different controllers.
    Furthermore, the controller-based approach brings other features that are important
    in large projects, such as various types of utilities, both through the framework
    and other resources available in **ControllerBase** , such as bind resources and
    model validations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，与最小API的创新方法相比，一个很大的不同之处在于能够将责任分割到不同的控制器中。此外，基于控制器的方法还带来了在大项目中非常重要的其他功能，例如通过框架和其他在**ControllerBase**中可用的资源提供的各种类型的实用工具，例如绑定资源和模型验证。
- en: ControllerBase utilities
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ControllerBase实用工具
- en: As mentioned previously, the **ControllerBase** class has several properties
    and methods that are useful for handling HTTP requests, making the APIs capable
    of handling requests using REST API best practices and conventions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**ControllerBase** 类具有一些属性和方法，这些属性和方法对于处理HTTP请求非常有用，使得API能够使用REST API的最佳实践和约定来处理请求。
- en: The standard for communication between applications through HTTP is extensive,
    and a book entirely dedicated to this subject would be needed in order to cover
    it properly. However, let’s address some patterns used in the **ProductController**
    class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP进行应用程序间通信的标准非常广泛，为了正确地涵盖这个主题，可能需要一本完全致力于此主题的书。但是，让我们关注在**ProductController**类中使用的某些模式。
- en: As we learned at the beginning of the chapter, requests in APIs are made to
    a specific resource, and for each request, there is an intention associated with
    a verb. Each request has a set of information that is sent to the API, such as
    a body and headers. Likewise, after being processed, this request returns headers
    and, in addition, may contain a body. An HTTP status code is also defined in the
    response.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所学的，API中的请求是针对特定资源的，对于每个请求，都有一个与动词相关联的意图。每个请求都有一组信息发送到API，例如正文和头信息。同样，在处理之后，此请求返回头信息，并且除了头信息外，还可能包含正文。响应中还定义了一个HTTP状态码。
- en: This entire pattern is abstracted by the methods available in **ControllerBase**
    , which takes care of the return definitions for each request.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此整个模式被**ControllerBase**中可用的方法抽象化，它负责处理每个请求的返回定义。
- en: 'Let’s analyze the GET method for retrieving a product by **id** :'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析通过**id**检索产品的GET方法：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The purpose of this method is to return a product according to the ID, passed
    as a parameter to the method. This API could be used, for example, in a frontend,
    where the user clicks on a product link to see its details. Since the API consumer
    does not have access to the implementation details, the API needs to be consistent
    in returning appropriate responses.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的目的是根据作为方法参数传递的ID返回一个产品。例如，此API可以在前端使用，用户点击产品链接以查看其详细信息。由于API消费者无法访问实现细节，API需要保持一致性，以返回适当的响应。
- en: In the case of the preceding method, if the product is not found, a **NotFound**
    response is returned, using the HTTP status code 404. This is the same approach
    as when trying to access a non-existent URL through the browser, which generally
    displays a 404 message, stating that a resource was not found.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述方法的情况下，如果找不到产品，将返回一个**NotFound**响应，使用HTTP状态码404。这与通过浏览器尝试访问不存在的URL的方法相同，通常显示一个404消息，表明未找到资源。
- en: On the other hand, if the product is found, an **Ok** response is returned,
    using the HTTP status code 200. Note that the **Ok** method has one parameter,
    which is exactly the product found. In this case, this object will be serialized
    in JSON format and returned to the client. The **Ok** method is responsible for
    serializing the object and creating the response taking into account the body,
    the serialized product object, and the headers, including stating that **Content-Type**
    is **application/json** . This way, the client can process the message return
    correctly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果找到产品，将返回一个**Ok**响应，使用HTTP状态码200。请注意，**Ok**方法有一个参数，正好是找到的产品。在这种情况下，此对象将以JSON格式序列化并返回给客户端。**Ok**方法负责序列化对象并创建响应，考虑到正文、序列化的产品对象和头信息，包括声明**Content-Type**为**application/json**。这样，客户端可以正确处理返回的消息。
- en: The **ControllerBase** class has several other methods that abstract the complexity
    of interacting with the HTTP protocol in addition to implementing REST standards
    and conventions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现REST标准和约定外，**ControllerBase**类还有其他几个方法，这些方法抽象了与HTTP协议交互的复杂性。
- en: It is important to note that APIs serve different types of clients, whether
    they are web-ready frontends, operating systems, or mobile applications, and they
    even allow integration between systems. Each of these consumers does not have
    any details about the API implementations, having access only to the signatures
    of the required methods and parameters, as well as the possible returns.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，API服务于不同类型的客户端，无论是准备好的前端、操作系统还是移动应用程序，它们甚至允许系统之间的集成。每个消费者对API实现没有任何细节，只能访问所需方法及其参数的签名以及可能的返回值。
- en: Therefore, it is necessary to use standards and conventions correctly, making
    the API consistent and interoperable between consumers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正确使用标准和约定是必要的，这可以使API在消费者之间保持一致性和互操作性。
- en: More details
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情
- en: 'If you want to know more about the **ControllerBase** class, see the documentation
    at the following link: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0)
    .'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于**ControllerBase**类的信息，请参阅以下链接中的文档：[https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-9.0)。
- en: The ASP.NET Core 9 abstracts most of the complexity involved in this service
    delivery model by using APIs, in addition to providing other types of functionality
    such as a consistent validation model and object binding.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9通过使用API来简化这种服务交付模型中的大部分复杂性，同时还提供了其他类型的功能，例如一致的验证模型和对象绑定。
- en: Working with binding
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与绑定一起工作
- en: Binds are important features available in ASP.NET Core. Their main function
    is to translate or adapt the API request model to the actions that are performed
    in the controller.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是ASP.NET Core中可用的重要功能。它们的主要功能是将API请求模型转换为控制器中执行的操作。
- en: As we observed in our examples of the **ProductController** call, the methods
    receive as parameters these primitive types, such as **int** , or even complex
    types, such as objects of type **product** .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们观察到的**ProductController**调用示例中，方法接收的参数是这些原始类型，例如**int**，甚至是复杂类型，例如**product**类型的对象。
- en: Each method or action has a signature or interface, which describes the attributes
    required, if any, for the method or action to be processed. When you make a request
    for action and enter the attributes according to the action signature, these will
    be mapped by the ASP.NET Core pipeline execution flow, which will bind the information
    for each attribute entered, taking into account its type, attribute name, and
    value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法或操作都有一个签名或接口，它描述了方法或操作处理所需的属性（如果有）。当你对操作发出请求并按照操作签名输入属性时，这些属性将通过ASP.NET
    Core管道执行流程进行映射，它会绑定每个输入属性的信息，考虑到其类型、属性名称和值。
- en: 'For example, the **product** object has the following attributes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**product**对象具有以下属性：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This object represented in JSON format would be defined as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个以JSON格式表示的对象可以这样定义：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the objects are identical but represented differently. ASP.NET
    Core does the work of transforming the JSON **product** object into a C# **product**
    object, mapping the properties according to the name.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这些对象是相同的，但表示方式不同。ASP.NET Core负责将JSON格式的**product**对象转换为C#格式的**product**对象，并按照名称映射属性。
- en: This is a standard behavior of the framework, but there is the possibility of
    customizing and even binding different aspects of a request.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是框架的标准行为，但存在自定义和绑定请求不同方面的可能性。
- en: As we know, a request has a body, URL, query string parameters, and also parameters
    that are sent through forms. A request has an abstraction in a C# object called
    **HttpRequest** . You can easily access all the properties of a request through
    the **Request** property of the previously mentioned **ControllerBase** class.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，一个请求包含主体、URL、查询字符串参数，以及通过表单发送的参数。在C#中，请求有一个名为**HttpRequest**的对象抽象。你可以通过之前提到的**ControllerBase**类的**Request**属性轻松访问请求的所有属性。
- en: 'If it is necessary, for example, to obtain a value in a query string, the following
    code can be used:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有必要，例如，从查询字符串中获取一个值，可以使用以下代码：
- en: '[PRE15]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, this same value could be obtained from the query string, using the
    bind model provided by the **FromQuery** attribute:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个相同的值也可以通过使用**FromQuery**属性提供的绑定模型从查询字符串中获取：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the preceding code, **isCompleted** was annotated with the
    **FromQuery** attribute. This way, ASP.NET will be responsible for binding the
    query string to the action parameter. In this case, it is expected that the query
    string has the same name as the method parameter. But if this is not the case,
    just use an attribute overload and define the parameter name, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，**isCompleted**被注解为**FromQuery**属性。这样，ASP.NET将负责将查询字符串绑定到操作参数。在这种情况下，预期查询字符串的名称与方法参数相同。但如果不是这种情况，只需使用属性重载并定义参数名称，如下所示：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are other types of attributes that can be used to perform binding:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用其他类型的属性来执行绑定：
- en: '| **Attribute** | **HTTP verb** | **When** **to use** | **Data format** | **Example**
    **of use** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **Attribute** | **HTTP verb** | **When** **to use** | **Data format** | **Example**
    **of use** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **FromBody** | POST, PUT, PATH | Use to bind parameter data from the request
    body. It can only be used once per action method, as it assumes the entire request
    body is used to bind to the action’s parameter. | JSON, XML | **[** **HttpPost]****public
    IActionResult Create([FromBody] Product product) { ... }** |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **FromBody** | POST, PUT, PATH | 用于从请求主体绑定参数数据。它只能在每个操作方法中使用一次，因为它假设整个请求主体用于绑定到操作参数。
    | JSON, XML | **[** **HttpPost]****public IActionResult Create([FromBody] Product
    product) { ... }** |'
- en: '| **FromForm** | POST | Use to bind parameter data from form fields. | Form
    data ( key-value pairs) | **[** **HttpPost]****public IActionResult Update([FromForm]
    ProductUpdateDto dto) { ... }** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **FromForm** | POST | 用于从表单字段绑定参数数据。 | 表单数据（键值对） | **[** **HttpPost]****public
    IActionResult Update([FromForm] ProductUpdateDto dto) { ... }** |'
- en: '| **FromService** | Any | Use to inject services directly into action methods.
    This is useful for obtaining services without using constructor injection. | Depends
    on the service being injected | **public IActionResult Get([FromServices] IProductService
    productService) { ... }** |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **FromService** | Any | 用于直接将服务注入到操作方法中。这在无需构造函数注入的情况下获取服务时很有用。 | 依赖于注入的服务
    | **public IActionResult Get([FromServices] IProductService productService) {
    ... }** |'
- en: '| **FromHeader** | Any | Use when you need to retrieve data from HTTP headers.
    Useful for tokens or API versioning. | Simple string or comma-separated values
    in a single header | **public IActionResult Get([FromHeader(Name = "X-Custom-Header")]
    string value) { ... }** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **FromHeader** | Any | 当需要从HTTP头中检索数据时使用。对于令牌或API版本控制很有用。 | 简单字符串或单个头中的逗号分隔值
    | **public IActionResult Get([FromHeader(Name = "X-Custom-Header")] string value)
    { ... }** |'
- en: '| **FromQuery** | GET | Use to bind parameters from the query string of the
    URL. Ideal for filtering or pagination parameters in a RESTful API. | Simple types
    such as strings, integers, or custom string-convertible types | **public IActionResult
    Search([FromQuery] string keyword) { ... }** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **FromQuery** | GET | 用于从URL的查询字符串绑定参数。在RESTful API中，对于过滤或分页参数来说很理想。 | 如字符串、整数或自定义可转换为字符串的类型等简单类型
    | **public IActionResult Search([FromQuery] string keyword) { ... }** |'
- en: '| **FromRoute** | Any | Use when parameter values are embedded in the URL path.
    Typically used with REST URLs that include resource IDs. | Simple types compatible
    with URL segments | **[HttpGet("{id}")] public IActionResult GetById([FromRoute]
    int id) { ... }** |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **FromRoute** | Any | 当参数值嵌入在URL路径中时使用。通常与包含资源ID的REST URL一起使用。 | 与URL段兼容的简单类型
    | **[HttpGet("{id}")] public IActionResult GetById([FromRoute] int id) { ... }**
    |'
- en: Each of these parameters can be used as a means of customizing the bind model
    in each action of a controller.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数中的每一个都可以用作自定义控制器中每个操作的绑定模型的一种方式。
- en: Custom binds
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义绑定
- en: 'In some cases, the default bind model available in ASP.NET Core may be limited
    in relation to the needs of an application, which can often have other, more complex
    types. With this, it is possible to implement customized binds. This implementation
    is outside the scope of this book, but you can learn more here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0)
    .'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，ASP.NET Core 中可用的默认绑定模型可能相对于应用程序的需求有限，这通常会有其他更复杂的数据类型。因此，可以实现自定义绑定。这种实现超出了本书的范围，但您可以在以下链接中了解更多信息：[https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/mvc/advanced/custom-model-binding?view=aspnetcore-9.0)。
- en: The binds model available in ASP.NET Core abstracts much of the implementation
    complexity by taking care of filling in the values that each action requires.
    However, there is no guarantee that the parameters were filled in correctly in
    accordance with the application’s business rules. To do this, you need to perform
    validations, and ASP.NET Core offers a powerful validation model.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中可用的绑定模型通过处理每个操作所需值的填充，抽象了许多实现复杂性。然而，没有保证参数是否正确地根据应用程序的业务规则进行了填充。为此，您需要执行验证，而
    ASP.NET Core 提供了一个强大的验证模型。
- en: Performing validations
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行验证
- en: When it comes to creating robust APIs, model validation is one of the fundamental
    pillars. ASP.NET Core 9 makes this process easier and more powerful than ever,
    thanks to **ModelState** . Think of it as a border guard that checks and validates
    data before it enters the core of your application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到创建健壮的 API 时，模型验证是基本支柱之一。ASP.NET Core 9 通过 **ModelState** 使这一过程比以往任何时候都更容易、更强大，将其视为一个边境守卫，在数据进入应用程序核心之前进行检查和验证。
- en: '**ModelState** is a framework in ASP.NET Core that acts to verify that data
    complies with the rules defined in your models. If a piece of data does not meet
    the validation criteria, **ModelState** marks it as invalid.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**ModelState** 是 ASP.NET Core 中的一个框架，用于验证数据是否符合在模型中定义的规则。如果某条数据不符合验证标准，**ModelState**
    会将其标记为无效。'
- en: 'Let’s take a look at the product registration API:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看产品注册 API：
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see, there is a condition that evaluates the **ModelState.IsValid**
    property. If false, then an HTTP status code of 400 (for a bad request) is returned,
    containing a body that will represent the **ModelState** object:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有一个条件用于评估 **ModelState.IsValid** 属性。如果为假，则返回一个 HTTP 状态码 400（表示请求错误），其中包含一个表示
    **ModelState** 对象的正文：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**ModelState** is actually a dictionary, which, when serialized in JSON format,
    is represented by an object. Each object property represents a validated property.
    The value of each object property is represented by an array of strings that contains
    the validation results.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**ModelState** 实际上是一个字典，当以 JSON 格式序列化时，它表示为一个对象。每个对象属性代表一个已验证的属性。每个对象属性的值由包含验证结果的字符串数组表示。'
- en: In order for **ModelState** to consider the model valid or not, it is necessary
    to annotate the properties of the objects with validation attributes; otherwise,
    the validations will be disregarded.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 **ModelState** 考虑模型是否有效，有必要用验证属性注释对象的属性；否则，验证将被忽略。
- en: 'The product class was changed by adding validation to the **Name** attribute,
    as in the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 **Name** 属性添加验证，修改了产品类，如下代码所示：
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the **Name** property is considered mandatory and, in addition,
    must have at least three characters. This way, it is possible to combine validation
    attributes in the same property, and this is managed by **ModelState** through
    the execution flow of an action, provided by ASP.NET Core 9.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**Name** 属性被认为是必需的，并且还必须至少包含三个字符。这样，就可以在同一个属性中组合验证属性，并且这是由 ASP.NET Core
    9 提供的操作执行流程中的 **ModelState** 管理的。
- en: 'Validations are part of an API, whether through attributes added to models
    or even manually, in the body of an action, using the **ModelState.AddModelError**
    method, as shown in the following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是 API 的一部分，无论是通过添加到模型中的属性，还是通过在操作体中使用 **ModelState.AddModelError** 方法手动进行，如下例所示：
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Other attributes
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性
- en: 'ASP.NET Core also offers several other attributes that can be used as model
    validation: [https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes)
    .'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 还提供了其他一些可以用于模型验证的属性：[https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes](https://learn.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-9.0#built-in-attributes)。
- en: As we can see, ASP.NET Core 9 provides a great feature for managing the states
    of models used by APIs, with parameters or even objects, allowing us to have the
    ability to carry out validations in a rich way on the application’s endpoints,
    in addition to giving us a simple way to maintain the integrity of information.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，ASP.NET Core 9 为管理 API 使用的模型状态提供了一个出色的功能，无论是使用参数还是对象，都使我们能够在应用程序的端点上以丰富的方式进行验证，同时为我们提供了一个简单的方式来维护信息的完整性。
- en: These features become even more powerful with the use of approaches such as
    documentation, response formatting, and error management. Therefore, in the next
    section, we will see how to make APIs even more consistent for consumers.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能在使用文档、响应格式化和错误管理等方法的帮助下变得更加强大。因此，在下一节中，我们将看到如何使 API 对消费者更加一致。
- en: Working with documentation
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文档一起工作
- en: APIs are a powerful resource for delivering an application’s business model
    through services, and for an API project to be made available properly, it is
    important to add features that standardize the interaction model with customers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: API 是通过服务传递应用程序业务模型的有力资源，为了使 API 项目得到适当提供，添加标准化与客户交互模型的功能非常重要。
- en: To achieve this, every API must be documented, allowing customers to know which
    resources are available and how this documentation is done.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，每个 API 都必须进行文档化，使客户了解哪些资源可用以及如何进行此文档化。
- en: So, let’s learn how we can benefit from API feature documentation automatically
    using Swagger’s NuGet package, which implements the OpenAPI specification.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们学习如何通过 Swagger 的 NuGet 包自动从 API 功能文档中获益，该包实现了 OpenAPI 规范。
- en: Documenting APIs with Swagger
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Swagger 记录 API
- en: APIs are consumed by clients and other applications through the HTTP protocol,
    where there is a request and a response. For this communication to happen, it
    is necessary to have knowledge about what is provided by the API, in this case,
    which methods are available and which contracts are used to establish connections.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和其他应用程序通过 HTTP 协议使用 API，其中存在请求和响应。为了使这种通信发生，有必要了解 API 提供的内容，在这种情况下，哪些方法是可用的，以及使用哪些契约来建立连接。
- en: To do this, we have to establish a source of knowledge about the resources made
    available by APIs, such as methods, HTTP verbs, parameters, and bodies. To achieve
    this objective, it is necessary to have documentation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须建立一个关于 API 提供的资源（如方法、HTTP 动词、参数和主体）的知识来源。为了实现这一目标，有必要拥有文档。
- en: However, this documentation needs to be dynamic, since, especially during the
    development process, APIs can constantly change, adding functionalities or new
    features. It would be laborious to make changes to each bit of documentation and
    send it to all API consumers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种文档需要是动态的，因为在开发过程中，API 可以不断变化，增加功能或新特性。对每一部分文档进行更改并将其发送给所有 API 消费者将是劳动密集型的。
- en: ASP.NET Core 9 still supports Swagger for providing API documentation. However,
    Swagger is no longer part of the project template by default as it was in previous
    releases. New projects can now support OpenAPI document generation in controller-based
    and minimal API applications. The OpenAI specification provides a programming
    language-agnostic approach to API documentation. As such, ASP.NET Core 9 provides
    built-in support for generating endpoint information in an application through
    the **Microsoft.AspNetCore.OpenAI** package, avoiding dependencies on external
    libraries.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 9 仍然支持 Swagger 来提供 API 文档。然而，与之前的版本不同，Swagger 现在不再是项目模板的一部分。新项目现在可以支持基于控制器和最小
    API 应用程序的 OpenAPI 文档生成。OpenAI 规范提供了一种编程语言无关的 API 文档方法。因此，ASP.NET Core 9 通过 **Microsoft.AspNetCore.OpenAI**
    包内置了对生成应用程序中端点信息的支持，避免了对外部库的依赖。
- en: Therefore, in order to have documentation, as well as an experience of using
    a UI to test the APIs, we will integrate the API project with Swagger, which is
    easy-to-use suite of API developer tools, in addition to implementing the OpenAPI
    specification standards.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了拥有文档以及使用 UI 测试 API 的体验，我们将 API 项目与 Swagger 集成，Swagger 是一套易于使用的 API 开发者工具，除了实现
    OpenAPI 规范标准之外。
- en: OpenAPI Specification
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范
- en: The OpenAPI Specification is part of the Linux Foundation and aims to specify
    RESTFul interfaces to provide ease in the development and consumption of APIs.
    You can learn more about OpenAPI at [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html)
    .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范是 Linux 基金会的一部分，旨在指定 RESTful 接口，以简化 API 的开发和消费。您可以在 [https://spec.openapis.org/oas/latest.html](https://spec.openapis.org/oas/latest.html)
    了解更多关于 OpenAPI 的信息。
- en: 'To learn more about ASP.NET Core 9 OpenAPI, visit the following URL: [https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 ASP.NET Core 9 OpenAPI 的信息，请访问以下网址：[https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/overview?view=aspnetcore-9.0)
- en: 'When integrating it into your API solution, Swagger acts as a specification
    generator in the OpenAPI format, which is based on a JSON file, where all the
    APIs available in your application are described:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 Swagger 集成到您的 API 解决方案中时，Swagger 在 OpenAPI 格式下充当规范生成器，该格式基于 JSON 文件，其中描述了您应用程序中所有可用的
    API：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding JSON describes the resources available for an API, the response
    schema, and the available verbs, in addition to the prediction of objects used
    in the API.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 JSON 描述了 API 可用的资源、响应模式以及可用的动词，以及 API 中使用的对象预测。
- en: 'To integrate Swagger into a project, we must add the Nuget package by running
    the following command on the command line, in the project directory:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Swagger 集成到项目中，我们必须在项目目录中运行以下命令行命令，添加 Nuget 包：
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we must change the Program.cs file. We will perform this configuration
    for the Product MVC project, and you can analyze the changed code, adding Swagger,
    in the code below:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须更改 Program.cs 文件。我们将为此配置 Product MVC 项目，您可以在下面的代码中分析添加 Swagger 后的更改：
- en: '[PRE24]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The implementation consists of the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实现包括以下内容：
- en: Line 4 adds the Swagger generation services through the **builder.Services.AddSwaggerGen()**
    method.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 4 行通过 **builder.Services.AddSwaggerGen()** 方法添加了 Swagger 生成服务。
- en: Between lines 6 and 10, we have the addition of Swagger to the ASP.NET execution
    pipeline, through the **app.UseSwagger()** method, and also the provision of the
    UI through the **app.UseSwaggerUI()** method. These methods are only executed
    if the application is running in development mode, **if (app.Environment.IsDevelopment)**
    .
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 6 行和第 10 行之间，我们通过 **app.UseSwagger()** 方法将 Swagger 添加到 ASP.NET 执行管道中，并通过
    **app.UseSwaggerUI()** 方法提供 UI。这些方法仅在应用程序以开发模式运行时执行，**if (app.Environment.IsDevelopment)**。
- en: 'When running the application, simply access the API link with the swagger suffix,
    as shown in *Figure 3* *.7* :'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行应用程序时，只需通过带有 swagger 后缀的 API 链接访问，如图 *图 3.7* 所示：
- en: '![Figure 3.7 – Swagger UI for the Product MVC API](img/B21788_03_7.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 产品 MVC API 的 Swagger UI](img/B21788_03_7.jpg)'
- en: Figure 3.7 – Swagger UI for the Product MVC API
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 产品 MVC API 的 Swagger UI
- en: Looking at *Figure 3* *.7* , we can see that the methods available in the product
    API were listed in the UI, in addition to the specification of the objects worked
    on the API. No changes were required to the source code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *图 3.7* ，我们可以看到产品 API 中可用的方法在 UI 中列出，以及 API 上工作的对象规范。不需要对源代码进行任何更改。
- en: Swagger identifies the controllers and actions available in the source code,
    generates the specification, and consequently generates the UI. However, more
    details can be added to the documentation in order to enrich the API usage model.
    Let’s take a closer look at how to improve documentation using the features available
    in the Swagger package.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 识别源代码中可用的控制器和操作，生成规范，并随后生成 UI。然而，可以在文档中添加更多详细信息，以丰富 API 使用模型。让我们更详细地看看如何使用
    Swagger 包中提供的功能来改进文档。
- en: Improving the documentation
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进文档
- en: As we learned previously, Swagger is added by default in ASP.NET Core 9 API
    projects and automatically generates a UI containing a minimum version of the
    usage details of the API, inferring the data by reading the controllers and actions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所学的，Swagger 默认添加到 ASP.NET Core 9 API 项目中，并自动生成一个包含 API 使用详情的最小版本的 UI，通过读取控制器和操作来推断数据。
- en: As we can see in *Figure 3* *.8* , to add a product, it is necessary to provide
    JSON as the body of the request; in addition, we have a description of the response,
    containing the HTTP status code 200, which represents the success.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图 3.8*中可以看到的那样，要添加产品，必须提供作为请求体的 JSON；此外，我们还有一个包含 HTTP 状态码 200 的响应描述，该状态码表示成功。
- en: '![Figure 3.8 – Documentation details for an API](img/B21788_03_8.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – API 的文档详情](img/B21788_03_8.jpg)'
- en: Figure 3.8 – Documentation details for an API
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – API 的文档详情
- en: 'However, if we look at the POST method code (made available through the **ProductController**
    class available in the book repository mentioned in the *Technical requirements*
    section), which registers a product, there is no explicit definition of the HTTP
    status code 200:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们查看 POST 方法代码（通过书中提到的*技术要求*部分中可用的**ProductController**类提供），该代码用于注册产品，没有明确定义
    HTTP 状态码 200：
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The method returns two possible HTTP status codes, which are 400, represented
    by calling the **BadRequest** method, and 201, which is represented by the **CreatedAtAction**
    method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回两种可能的 HTTP 状态码，分别是 400，由调用**BadRequest**方法表示，以及 201，由**CreatedAtAction**方法表示。
- en: As we can see in *Figure 3* *.8* , there is a button labeled **Try it out**
    . Upon clicking this button, the UI will be prepared so that it is possible to
    add the request body, which in this case will be some JSON that represents a product
    and its respective properties. Modify the JSON to add a new product, defining
    the properties as in the example proposed in *Figure 3* *.9* .
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图 3.8*中可以看到的那样，有一个标记为**试一试**的按钮。点击此按钮后，UI 将准备就绪，以便可以添加请求体，在这种情况下，将是一些表示产品和其相应属性的
    JSON。修改 JSON 以添加新产品，定义属性如*图 3.9*中提出的示例。
- en: '![Figure 3.9 – Running an API request from the Swagger UI](img/B21788_03_9.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 从 Swagger UI 运行 API 请求](img/B21788_03_9.jpg)'
- en: Figure 3.9 – Running an API request from the Swagger UI
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 从 Swagger UI 运行 API 请求
- en: After defining the body of the request, click the **Execute** button. Just make
    sure your application is running.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义请求体之后，点击**执行**按钮。只需确保你的应用程序正在运行。
- en: At the end of the execution, the Swagger UI displays the API response, and as
    we can clearly see in *Figure 3* *.10* , we have an HTTP status code of 201, in
    addition to the JSON of the newly registered product and some information in the
    header.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结束后，Swagger UI 显示 API 响应，正如我们可以在*图 3.10*中清楚地看到的那样，我们有一个 HTTP 状态码 201，以及新注册产品的
    JSON 和一些头部信息。
- en: '![Figure 3.10 – Swagger API Response screen](img/B21788_03_10.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – Swagger API 响应屏幕](img/B21788_03_10.jpg)'
- en: Figure 3.10 – Swagger API Response screen
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – Swagger API 响应屏幕
- en: The **CreatedAtAction** method creates a response with HTTP status code 201
    and adds a link to the header to access the resource created using the GET method,
    as highlighted in the preceding figure using the address **http://localhost:5037/Product/1**
    . This address may vary depending on the execution address in your environment.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**CreatedAtAction**方法创建一个带有 HTTP 状态码 201 的响应，并在头部添加一个链接，用于通过 GET 方法访问创建的资源，如前图所示，地址为**http://localhost:5037/Product/1**。这个地址可能因你环境中的执行地址而异。'
- en: This type of return is good practice and follows the standards defined in the
    REST protocol. However, although it is not a major problem in the context in which
    we are presenting the examples, API consumers must be clear about how to consume
    and what to expect in return to properly deal with each response. In the case
    of the product registration method, there being no information means that this
    method would also return an error status, which could cause some non-compliance
    for the API consumer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的返回是良好的实践，遵循 REST 协议中定义的标准。然而，尽管在我们展示示例的上下文中这不是一个主要问题，API 消费者必须清楚如何消费以及期望得到什么，以便正确处理每个响应。在产品注册方法的情况下，没有信息意味着此方法也会返回错误状态，这可能会对
    API 消费者造成一些不合规。
- en: To adjust this behavior, we must add more information to the API methods using
    attributes provided by ASP.NET Core 9 such as **ProducesResponseType** and **Consumes**
    .
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整这种行为，我们必须使用 ASP.NET Core 9 提供的属性，如 **ProducesResponseType** 和 **Consumes**，向
    API 方法添加更多信息。
- en: The **ProducesResponseType** attribute is used to determine the type of HTTP
    status code that will be returned as a response and also the type of content that
    will be returned. This attribute can also be used in the generic version, typing
    the return.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProducesResponseType** 属性用于确定将作为响应返回的 HTTP 状态码的类型以及返回的内容类型。此属性还可以用于泛型版本，指定返回类型。'
- en: The **Consumes** attribute determines the type of content expected by the API.
    The content is defined as a media type and the complete list can be obtained through
    the **MediaTypeNames** class available in the **System.Net.Mime** namespace.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Consumes** 属性确定 API 期望的内容类型。内容被定义为媒体类型，完整的列表可以通过 **System.Net.Mime** 命名空间中可用的
    **MediaTypeNames** 类获得。'
- en: 'Let’s analyze the new implementation of the POST method with the addition of
    attributes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析通过添加属性的新实现的 POST 方法：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see in the preceding code, the **ProducesResponseType** attribute
    can be added as many times as necessary to represent different return types. In
    this example, the HTTP status code 201 is being reported, for created items, and
    one type of return with the HTTP status code 400.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，**ProducesResponseType** 属性可以根据需要添加多次，以表示不同的返回类型。在此示例中，报告了 HTTP 状态码
    201，用于创建的项目，以及一个带有 HTTP 状态码 400 的返回类型。
- en: 'When running the application again, we can observe the changes made to the
    code and automatically generated in the Swagger UI, according to *Figure 3* *.11*
    :'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当再次运行应用程序时，我们可以观察到对代码所做的更改以及根据 *图 3.11* 自动生成的 Swagger UI：
- en: '![Figure 3.11 – API response documentation](img/B21788_03_11.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – API 响应文档](img/B21788_03_11.jpg)'
- en: Figure 3.11 – API response documentation
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – API 响应文档
- en: We now have the correct documentation on the aspects involved in the product
    controller’s POST method, which enables the API to be consumed appropriately by
    taking into account alternative response flows.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了关于产品控制器 POST 方法所涉及方面的正确文档，这使得 API 能够通过考虑替代响应流程来适当消费。
- en: XML comments
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: XML 注释
- en: 'In addition to the attributes added to the API methods, it is also possible
    to use XML comments for each method as part of the Swagger UI documentation. To
    do this, it will be necessary to configure the project so that the documentation
    XML is generated during the compilation process and is obtained from the Swagger
    UI. You can find a complete explanation of this configuration at the following
    address: [https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments](https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments)
    .'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加到 API 方法的属性之外，还可以使用 XML 注释为每个方法提供作为 Swagger UI 文档的一部分。为此，需要配置项目，以便在编译过程中生成文档
    XML，并在 Swagger UI 中获取。您可以在以下地址找到此配置的完整说明：[https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments](https://learn.microsoft.com/en-us/aspnet/core/tutorials/getting-started-with-swashbuckle?view=aspnetcore-9.0&tabs=visual-studio#xml-comments)。
- en: In addition to having the ability to create quality APIs with ASP.NET Core 9,
    we also have the support of a rich API documentation interface, in addition to
    the option to execute requests and get more details about the request parameters
    and response.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够使用 ASP.NET Core 9 创建高质量的 API 之外，我们还拥有丰富的 API 文档界面支持，以及执行请求和获取有关请求参数和响应的更多细节的选项。
- en: Understanding this documentation approach will greatly help you to generate
    quality services that can be integrated into different systems and contexts. As
    we progress through the next few chapters, we will further study the use of APIs,
    documentation, and other technologies such as database connections.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这种文档方法将极大地帮助您生成可以集成到不同系统和环境中的高质量服务。随着我们进入接下来的几章，我们将进一步研究 API、文档以及其他技术，如数据库连接的使用。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dove deep into the world of HTTP-delivered APIs, discovering
    the power they have to provide services to a variety of clients. With the robust
    support of ASP.NET Core, we learned how to make the most of this potential, learning
    about approaches such as using minimal APIs to create HTTP APIs quickly and efficiently.
    We also explored the creation of robust APIs using controller-based projects.
    We looked at other aspects that involve APIs, such as documentation. In the next
    chapter, we will continue to explore the characteristics of ASP.NET Core 9, understanding
    how to develop real-time applications using SignalR.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了通过HTTP提供的API的世界，发现了它们为各种客户端提供服务的能力。在ASP.NET Core的强大支持下，我们学习了如何充分利用这一潜力，了解了诸如使用最小API快速高效地创建HTTP
    API等方法。我们还探讨了使用基于控制器的项目创建健壮API的过程。我们还考察了涉及API的其他方面，例如文档。在下一章中，我们将继续探索ASP.NET Core
    9的特性，了解如何使用SignalR开发实时应用程序。
