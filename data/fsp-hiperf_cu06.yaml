- en: Chapter 6. Optimizing Type Provider
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。优化类型提供者
- en: We now have a basic understanding of the basic and advanced concurrency features
    of F#. We also have enough tooling knowledge and hence, enough knowledge about
    tooling support in Visual Studio. Based on this knowledge, we can also enhance
    the performance optimizations when implementing and using other F# language features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对 F# 的基本和高级并发特性有了基本的了解。我们也拥有了足够的工具知识，因此对 Visual Studio 中的工具支持有了足够的了解。基于这些知识，我们还可以在实现和使用其他
    F# 语言特性时进行性能优化。
- en: In this chapter, we will focus on bringing the previous knowledge into optimizing
    type provider. Type provider is a unique feature of F#; it was introduced in F#
    3.0.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于将之前的知识应用于优化类型提供者。类型提供者是 F# 的一个独特特性；它在 F# 3.0 中被引入。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Type provider was introduced in F# 3.0 release, at the same time as Visual Studio
    2012 release. It is important to know that F# 3.0 is part of train releases of
    Visual Studio 2012, not Visual Studio 2013\. Many external articles (including
    some blogs) outside the MSDN blogs and MSDN Library mistakenly assume that F#
    3.0 has a type provider that comes with Visual Studio 2013\. The release of F#
    that comes with Visual Studio 2013 is F# 3.1, not F# 3.0.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者在 F# 3.0 版本发布时被引入，与 Visual Studio 2012 的发布同时进行。重要的是要知道 F# 3.0 是 Visual
    Studio 2012 的火车版本的一部分，而不是 Visual Studio 2013 的部分。许多外部文章（包括一些博客）错误地假设 F# 3.0 与
    Visual Studio 2013 一起提供了类型提供者。与 Visual Studio 2013 一起发布的 F# 版本是 F# 3.1，而不是 F#
    3.0。
- en: It is also important to first know what type provider is and the main goal or
    purposes of having or using it, before we optimize it. Knowing the concepts behind
    type provider will give us an insight of which part of optimizations are available
    for us when we use and implement type providers. This insight will also help us
    avoid pitfalls when dealing with type providers implementation in detail.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化之前，了解类型提供者是什么以及拥有或使用它的主要目标或目的也很重要。了解类型提供者背后的概念将使我们了解在使用和实现类型提供者时，哪些优化部分对我们是可用的。这种洞察力还将帮助我们避免在处理类型提供者实现时的陷阱。
- en: 'We now discuss these topics of optimizing type provider:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在讨论以下优化类型提供者的主题：
- en: Overview of F# type provider
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 类型提供者概述
- en: Best practices in implementing type provider
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现类型提供者的最佳实践
- en: Optimizing generative type provider
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化生成类型提供者
- en: Common pitfalls in type provider implementation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提供者实现中的常见陷阱
- en: Overview of F# type provider
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 类型提供者概述
- en: Before we go deeper into optimizing F# type providers, let's have a conceptual
    introduction to what a type provider is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入优化 F# 类型提供者之前，让我们先从概念上介绍什么是类型提供者。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From now on, F# type providers will be described as type providers, omitting
    the *F#* prefix. It is also common just to use type providers because type provider
    is a unique feature of F#.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们将描述 F# 类型提供者，省略 *F#* 前缀。仅使用类型提供者也很常见，因为类型提供者是 F# 的一个独特特性。
- en: Basically, type provider is a type of generators. It generates types (classes)
    to be used in code specific to special purposes. Some of the classes remain available
    in the runtime; some of them don't (get erased).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，类型提供者是一种生成器类型。它生成用于特定目的的代码中的类型（类）。其中一些类在运行时仍然可用；而另一些则不可用（被擦除）。
- en: 'The type provider feature begins with F# 3.0 release, and it is the main theme
    of F# 3.0 release: solving the data manipulation problem. The specific *problem*
    in data manipulation problem is how we handle the data''s metadata information
    while focusing on the correctness of syntaxes and type safety. The type safety,
    in this sense, does not have to be strict or even strong, it is also available
    as erased typed as object.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者特性始于 F# 3.0 版本发布，它是 F# 3.0 版本的主要主题：解决数据操作问题。在数据操作问题中具体的 *问题* 是在关注语法的正确性和类型安全的同时，如何处理数据的元数据信息。在这个意义上，类型安全不必是严格的或甚至强大的，它也可以作为擦除类型作为对象存在。
- en: Using type provider implementations, we expect that when we use data, the information
    about the data itself (metadata) is available as we are using it. For example,
    having a type provider for SQL Server database will give us the table and the
    name of the column metadata to be available for us when we are using the type
    provider. This metadata information is available at development type immediately
    as the type provider is translating the schema information of SQL Server database
    metadata into types and properties available immediately.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型提供者实现，我们期望当我们使用数据时，关于数据本身的信息（元数据）在我们使用它时即可获得。例如，拥有SQL Server数据库的类型提供者将使我们能够在使用类型提供者时获得表和列的元数据。这些元数据信息在开发类型时立即可用，因为类型提供者将SQL
    Server数据库元数据的模式信息转换为可立即使用的类型和属性。
- en: 'This is the starting point of F# type provider documentation on MSDN Library:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MSDN库中F#类型提供者文档的起点：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/index](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/index)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/index](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/index)'
- en: 'In a simple definition, *type provider is a combination of language and library
    features that describe the information to represent data, including the types
    and its properties*. This is also one of the unique selling points of type providers:
    the ability to present type metadata of a data into the language immediately.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单定义中，*类型提供者是一种结合了语言和库功能，用于描述表示数据的信息，包括类型及其属性*。这也是类型提供者的独特卖点之一：能够立即将数据的类型元数据呈现到语言中。
- en: Type providers will provide the type resolution at compile time immediately,
    and this is different from the implementation of other code generators that perform
    type generations as well. This is also unique in F# compared to other managed
    programming languages on.NET such as C#/VB.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者将在编译时立即提供类型解析，这与其他执行类型生成的代码生成器的实现不同。在F#与其他.NET托管编程语言（如C#和VB）相比，这也是其独特之处。
- en: In the long definition, type provider is a design-time component that provides
    a computed space of types. Therefore, Intellisense is available immediately. All
    of the types are strongly typed at design time, and it can be carried on at runtime
    if the generative type provider strategy is used instead of the erased strategy
    that treats all of the generated types as objects (`System.Object` in .NET BCL).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在长定义中，类型提供者是一个设计时组件，它提供了一个类型计算空间。因此，Intellisense可以立即使用。所有类型在设计时都是强类型的，如果使用生成类型提供者策略而不是擦除策略（将所有生成的类型视为对象，例如.NET
    BCL中的`System.Object`），则可以在运行时继续使用。
- en: 'Therefore, the following are the goals of type providers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下就是类型提供者的目标：
- en: To provide more information on the data accessed from external source.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供更多关于从外部源访问的数据的信息。
- en: To provide more metadata information to be available immediately as part of
    the language, as type with its properties.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了提供更多元数据信息，作为语言的一部分立即可用，就像具有属性的类型一样。
- en: To make the type provided available as strongly typed in order to be used in
    the editor. This is possible because before the type provided is available in
    the editor, it is processed and compiled first; hence it is also available to
    be inferred.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使提供的类型作为强类型可用，以便在编辑器中使用。这是可能的，因为提供的类型在编辑器中可用之前，首先被处理和编译；因此，它也可以被推断。
- en: To make the type provided to be explicitly available at compile time. This is
    crucial because a type provider must be available at compile time because the
    resulting type provided must be available immediately to be used when we type
    in the editor of Visual Studio, as related to point 3.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使提供的类型在编译时显式可用。这是至关重要的，因为类型提供者必须在编译时可用，因为结果类型提供者必须立即可用，以便我们在Visual Studio的编辑器中键入时使用，这与第3点相关。
- en: Point 3 is crucial because the type provider is doing its processing while in
    the editor as we type our code (as long as we compile our references and provide
    the type provider initialization first). This gives F# type provider strong and
    unique advantages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第3点至关重要，因为类型提供者在我们在编辑器中键入代码的同时进行其处理（只要我们首先编译我们的引用并提供类型提供者初始化）。这为F#类型提供者带来了强大而独特的优势。
- en: 'The following are the unique advantages of type providers:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型提供者的独特优势：
- en: Type resolved is immediately available in the editor when writing code (in the
    IDE editing session).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写代码时（在 IDE 编辑会话中），类型解析立即在编辑器中可用。
- en: 'Since type resolved is immediately available in the editor, type inference
    is also available immediately, and this gives us the availability of Visual Studio''s
    Intellisense of the resulting generated type (either using erased or generative).
    This is closely related to the third goal of type providers: the type provided
    is available strongly typed.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于类型解析在编辑器中立即可用，类型推断也立即可用，这使得我们可以使用 Visual Studio 的 Intellisense 来访问生成的类型（无论是使用擦除还是生成）。这与类型提供者的第三个目标密切相关：提供的类型是强类型的。
- en: The type provided includes not just properties but also additional necessary
    methods as well.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的类型不仅包括属性，还包括必要的额外方法。
- en: There is no code generation when providing type generation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提供类型生成时不会生成代码。
- en: The implemented type provider is compatible with other managed programming languages
    as well, although the implementation of a type provider itself cannot be done
    outside an F# project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现的类型提供者与其他托管编程语言兼容，尽管类型提供者的实现本身不能在 F# 项目之外完成。
- en: Point 2 is crucial because if the type resolved does not provide the properties
    and the methods correctly, and if the metadata provided does not match the intention
    of the type providers, the type provider is not a good type provider and the resulting
    type might not work as expected.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第2点至关重要，因为如果类型解析没有正确提供属性和方法，并且如果提供的元数据与类型提供者的意图不匹配，那么这个类型提供者不是一个好的类型提供者，生成的类型可能无法按预期工作。
- en: Point 3 is important because of the fact that the resulting type provided is
    available immediately, not requiring us to rebuild the whole project (or related
    generated code's project).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第3点很重要，因为生成的类型立即可用，无需我们重新构建整个项目（或相关生成的代码项目）。
- en: We may conclude that the F# type provider can be used to tame the sea of information
    into more meaningful data with the agreed schema and metadata directly into our
    experience of writing the code, and this is also often mentioned in the documentation
    of Microsoft's Visual F#, and it was introduced particularly from F# creator Don
    Syme in his Build 2011 conference presentation session of F# 3.0.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，F# 类型提供者可以用以将信息海洋驯服为更有意义的数据，通过直接在我们的代码编写体验中应用约定的模式和元数据，这也在 Microsoft
    Visual F# 的文档中经常提到，并且特别由 F# 创造者 Don Syme 在 Build 2011 会议演示会话中介绍。
- en: 'For more information on Don Syme''s Build 2011 F# 3.0 talk, this is the presentation''s
    landing page on Channel 9:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Don Syme 在 Build 2011 上的 F# 3.0 讲座的更多信息，这是 Channel 9 上的演示文稿着陆页：
- en: '[https://channel9.msdn.com/Events/Build/BUILD2011/SAC-904T](https://channel9.msdn.com/Events/Build/BUILD2011/SAC-904T)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://channel9.msdn.com/Events/Build/BUILD2011/SAC-904T](https://channel9.msdn.com/Events/Build/BUILD2011/SAC-904T)'
- en: 'The following diagram illustrates an abstract picture of F# type provider:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 F# 类型提供者的抽象图：
- en: '![Overview of F# type provider](img/image00309.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![F# 类型提供者概述](img/image00309.jpeg)'
- en: F# itself has type provider implementations built in since F# 3.0 under the
    `FSharp.Data.TypeProviders` namespace and the `FSharp.Data.TypeProviders.dll`
    assembly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自 F# 3.0 以来，F# 本身就内置了类型提供者实现，位于 `FSharp.Data.TypeProviders` 命名空间和 `FSharp.Data.TypeProviders.dll`
    集合中。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We must use the `Microsoft.FSharp.Data.TypeProviders` namespace if it is going
    to be used in outside F# projects, because the compiled name is `Microsoft.FSharp.Data.TypeProviders`.
    This namespace name is not related to the name of the `FSharp.Data.TypeProviders`
    as assembly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在 F# 以外的项目中使用，我们必须使用 `Microsoft.FSharp.Data.TypeProviders` 命名空间，因为编译后的名称是
    `Microsoft.FSharp.Data.TypeProviders`。此命名空间名称与 `FSharp.Data.TypeProviders` 作为集合的名称无关。
- en: There are other type providers as well, and most outside F# type providers are
    managed under the governance of F# Foundations as community projects. All of these
    community projects are hosted on GitHub and we all are encouraged to contribute
    as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型提供者，大多数 F# 以外的类型提供者都受 F# Foundations 的管理，作为社区项目。所有这些社区项目都托管在 GitHub 上，我们都被鼓励做出贡献。
- en: 'These are the ecosystems of F# type providers that we have in the first half
    of 2016:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们2016年上半年拥有的 F# 类型提供者生态系统：
- en: F# Data (for CSV, HTML, WorldBank)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 数据（用于CSV、HTML、世界银行）
- en: F# Data Toolbox (for Twitter and SAS)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 数据工具箱（用于Twitter和SAS）
- en: FSharp.Management (for WMI, Registry, Powershell, and Windows filesystem)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FSharp.Management（用于WMI、注册表、PowerShell 和 Windows 文件系统）
- en: Azure Storage type provider
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 存储类型提供者
- en: 'To keep up with the latest development of these community projects under F#
    Foundations, please visit: [http://fsprojects.github.io/](http://fsprojects.github.io/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解F# Foundations下这些社区项目的最新发展，请访问：[http://fsprojects.github.io/](http://fsprojects.github.io/)。
- en: 'We can conclude that there are some common scenarios where a type provider
    is the best fit:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得出结论，在某些常见场景中，类型提供者是最佳选择：
- en: Accessing data from an external source in the form of a strong type JSON returned
    from web API. For example, World Bank data.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以强类型JSON的形式从外部源访问数据，该JSON由Web API返回。例如，世界银行数据。
- en: Accessing data from predefined schema. For example, well-defined XML and its
    derivatives, such as XML DataSet (XSD) and XSL.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从预定义的模式访问数据。例如，定义良好的XML及其衍生品，如XML DataSet（XSD）和XSL。
- en: Accessing data with predefined data format defined and documented. The way to
    access the data has a predefined protocol and its own query dialect. For example,
    returning data from Windows Management Instrumentation query (often called WMI
    query) using WMI protocol with its own query language, WQL.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预定义的数据格式访问数据，该格式已定义和记录。访问数据的方式有一个预定义的协议和自己的查询方言。例如，使用WMI协议及其自己的查询语言WQL从Windows
    Management Instrumentation查询（通常称为WMI查询）返回数据。
- en: Let's dive into the details of why the third advantage of type providers is
    important and comparison with other type generators as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解为什么类型提供者的第三个优势很重要，以及与其他类型生成器的比较。
- en: Comparing the type provider with other type generators
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较类型提供者与其他类型生成器
- en: F# type provider is not the only sample of advanced type generator. Type generators
    are commonly found in modern software platform ecosystems (including the tooling),
    such as .NET/Visual Studio, Java/Eclipse, and Mono/Xamarin Studio.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: F#类型提供者不是高级类型生成器的唯一示例。类型生成器在现代软件平台生态系统中（包括工具）很常见，例如.NET/Visual Studio、Java/Eclipse和Mono/Xamarin
    Studio。
- en: Type generators in F# type providers do not employ a code generator as compared
    to other type generator models. They rely on the compiler and tooling infrastructure
    at compile time. The type provided is not just immediately available but is also
    flexible to outside changes by simply rebuilding the project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型生成器模型相比，F#类型提供者中的类型生成器不使用代码生成器。它们依赖于编译时编译器和工具基础设施。提供的类型不仅立即可用，而且通过简单地重新构建项目，对外部更改具有灵活性。
- en: This is in contrast to many type generators that employ code generation strategy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这与许多使用代码生成策略的类型生成器形成对比。
- en: 'The following diagram illustrates the abstract working of these two type generators:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这两个类型生成器的抽象工作原理：
- en: '![Comparing the type provider with other type generators](img/image00310.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![比较类型提供者与其他类型生成器](img/image00310.jpeg)'
- en: For example, Entity Framework 6 (using the database first and model first),
    `SqlMetal` in LINQ to SQL, `TLBIMP` to yield COM interop objects, and legacy web
    service reference (before Visual Studio 2010) are implemented using code generators.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Entity Framework 6（使用数据库优先和模型优先），LINQ to SQL中的`SqlMetal`，`TLBIMP`以生成COM互操作对象，以及旧版Web服务引用（在Visual
    Studio 2010之前）都是使用代码生成器实现的。
- en: Entity Framework 6's first database and model heavily rely on code generators
    to ensure the availability of the types mapped as classes from the underlying
    database, and this is normal and is intended as is because the mapping between
    database and the mapped object is manual, including the constructions of constraint
    mappings.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework 6的第一个数据库和模型严重依赖代码生成器来确保从底层数据库映射为类的类型可用性，这是正常且有意为之，因为数据库与映射对象之间的映射是手动的，包括约束映射的构造。
- en: The design mode model uses a combination of EDMX and CSDL/SSDL files, which
    is completely generated as code, and we should not modify the CSDL file directly
    because it will always be overridden with the changes in EDMX file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式模型使用EDMX和CSDL/SSDL文件的组合，这些文件完全作为代码生成，我们不应直接修改CSDL文件，因为它总会被EDMX文件中的更改覆盖。
- en: The same fact also applies with the WSDL/ASMX of the legacy web service in the
    previous version of Visual Studio before VS 2010\. The ASMX file generated is
    also employing code generations, and they have their own translations that map
    the C#/VB code to the SOAP header envelopes. The resulting mapping code of WSDL/ASMX
    is closely linked as tightly integrated, and we should not modify the ASMX directly
    as we usually focus on the code behind the `asmx.cs` or the `asmx.vb` file. The
    modifications on the references of the ASMX will always override the generated
    references of the WSDL file, and this is quite cumbersome and might be error-prone
    because the code generations of the web services depend on the project that has
    the original ASMX.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前版本 Visual Studio（在 VS 2010 之前）中遗留的 Web 服务的 WSDL/ASMX 也是同样的情况。生成的 ASMX 文件也使用了代码生成，它们有自己的翻译，将
    C#/VB 代码映射到 SOAP 报头封装中。生成的 WSDL/ASMX 映射代码紧密相连，并且高度集成，我们不应该直接修改 ASMX，因为我们通常关注 `asmx.cs`
    或 `asmx.vb` 文件背后的代码。对 ASMX 引用的修改将始终覆盖 WSDL 文件生成的引用，这相当繁琐，并且可能存在错误，因为 Web 服务的代码生成依赖于具有原始
    ASMX 的项目。
- en: Interoperability with other managed programming languages
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他托管编程语言的互操作性
- en: The type provider is fully compatible with other managed programming languages
    that run on top of .NET CLR. Not just because it's implemented as managed language
    on top of CLR, but it is essentially the same CLR-compliant assembly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者与在 .NET CLR 上运行的其它托管编程语言完全兼容。不仅因为它在 CLR 上作为托管语言实现，而且它本质上是一个 CLR 兼容的程序集。
- en: 'But there is a caveat: when the F# type provider is used in other managed languages
    directly, it will not yield the Intellisense feature. Why? Because the type provided
    by F# type provider is available based on the specific attribute of `[<assembly:TypeProviderAssembly>]`,
    and this attribute is handled by F# compiler in Visual Studio IDE when the project
    is rebuilt.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个注意事项：当直接在其他托管语言中使用 F# 类型提供者时，它将不会提供 Intellisense 功能。为什么？因为 F# 类型提供者提供的类型是基于特定的属性
    `[<assembly:TypeProviderAssembly>]`，而这个属性在 Visual Studio IDE 重建项目时由 F# 编译器处理。
- en: This attribute in this assembly scope is important because this attribute is
    telling the F# compiler that *the type provided by F# type provider is added at
    compile time*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序集范围内，这个属性很重要，因为它在告诉 F# 编译器，*由 F# 类型提供者提供的类型是在编译时添加的*。
- en: It is important to know that only the F# compiler has the capability of adding
    additional type metadata as part of the resulting type provided using the attribute
    of `TypeProviderAssembly`. This means that we cannot use the F# type provider
    directly in other managed languages because their compilers must have the capability
    to identify the type provider-related assembly, and the whole compiler infrastructure
    has to match F# compiler infrastructure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的是，只有 F# 编译器才有能力将额外的类型元数据作为使用 `TypeProviderAssembly` 属性提供的最终类型的一部分添加进来。这意味着我们无法直接在其他托管语言中使用
    F# 类型提供者，因为它们的编译器必须有能力识别类型提供者相关的程序集，并且整个编译器基础设施必须与 F# 编译器基础设施相匹配。
- en: We can simply add references by adding our F# code that use the type library
    as a library/assembly references to our C#/VB projects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将使用类型库作为库/程序集引用的 F# 代码添加到我们的 C#/VB 项目中，简单地添加引用。
- en: Understanding the type provider building blocks
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型提供者的构建块
- en: A predefined data source that has very good established documentations and strong
    conventions such as SQL Server database and **Windows Management Instrumentation**
    (**WMI**) is one of the best samples to have type provider implementations because
    all of the necessary descriptions of the data and the way to access it is documented
    extensively in detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有非常好的文档和强大约定的预定义数据源，如 SQL Server 数据库和 **Windows Management Instrumentation**（**WMI**），是具有类型提供者实现的最佳示例之一，因为所有必要的数据描述和访问方式都详细记录在文档中。
- en: For more information about WMI, consult the MSDN Library at
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WMI 的更多信息，请参阅 MSDN 库。
- en: '[https://msdn.microsoft.com/en-us/library/aa394572(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa394572(v=vs.85).aspx)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/aa394572(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/aa394572(v=vs.85).aspx)'
- en: Let's visit the minimum requirements of type provider implementation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类型提供者实现的最低要求。
- en: Minimum requirements of type providers
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提供者的最低要求
- en: We have discussed the importance of certain restrictions on how a type provider
    should get the data. Now let's wrap the minimum requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了类型提供者获取数据时某些限制的重要性。现在让我们总结一下最低要求。
- en: 'A successful type provider is expected to have the following traits:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个成功的类型提供者应具备以下特点：
- en: The type provided must not be statically coded, it should be able to adapt immediately
    based on the defined parameters. For example, a connection string of a database
    server, which is then used to provide configuration for the type provided by SQL
    tables and its columns.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的类型不得是静态编码的，它应该能够根据定义的参数立即适应。例如，数据库服务器的连接字符串，然后用于为 SQL 表及其列提供的类型提供配置。
- en: Related to point 1, the parameter to be used as base configuration must be specified.
    Therefore, there is no default parameterless constructor for any type provider
    because the configuration must be specified.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第一点相关，必须指定用作基本配置的参数。因此，任何类型提供者都没有默认的无参数构造函数，因为必须指定配置。
- en: The schema mapping or the type and property mapping must be defined to be strongly
    typed even though the resulting type provided does not have to be strongly typed.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使提供的类型不需要是强类型的，架构映射或类型和属性映射也必须定义为强类型的。
- en: The mapping has to be carefully designed not to add irrelevant type information
    because it will add overheads on type instantiation. However, for erased type
    providers, the mapping properties and methods might be optional.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射必须精心设计，以免添加无关的类型信息，因为这会给类型实例化添加开销。然而，对于擦除类型提供者，映射属性和方法可能是可选的。
- en: The provided type is always a type that has a setter and getter, and it is therefore
    not a standard F# type; it is actually a class. Related to the preceding point,
    the properties of the classes should be as simple as possible, and the class should
    only contain properties, not properties and methods.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的类型始终是一个具有设置器和获取器的类型，因此它不是一个标准的 F# 类型；它实际上是一个类。与前面的观点相关，类的属性应尽可能简单，并且类应只包含属性，而不是属性和方法。
- en: Point 2 is crucial and very important. Fortunately, F# requires us by default
    to always use type providers with a constructor that has a parameter to be supplied.
    The parameter itself cannot be `null`; otherwise, the type provider cannot produce
    a type with metadata successfully and will always yield a breaking exception and
    undesirable results.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点至关重要且非常重要。幸运的是，F# 默认要求我们始终使用具有参数的构造函数的类型提供者。参数本身不能为 `null`；否则，类型提供者无法成功生成具有元数据的类型，并且总是会引发破坏性异常和不良结果。
- en: Point 3 of schema mapping defines how we implement the resulting type provided
    by a type provider. This is also defined as a general strategy for implementing
    type providers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 架构映射的第三点定义了如何实现类型提供者提供的类型。这也被定义为实现类型提供者的一般策略。
- en: Strategies of type provider implementation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提供者实现策略
- en: 'The type provider implementation strategies fall into the following two conceptual
    strategies:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提供者实现策略分为以下两种概念策略：
- en: '**Generative type providers**: The generated type provided is also available
    at runtime; therefore, the type metadata information of the type provided is always
    available at runtime. The assembly can be referenced by other assemblies because
    the type information metadata is kept. The reference is also fully compatible
    with other managed programming languages as well because the type metadata of
    the provided type is fully resolved and the assembly itself is fully available
    to use on top of the normal .NET CLR-compliant.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成类型提供者**：生成的类型在运行时也是可用的；因此，提供的类型的类型元数据信息始终在运行时可用。程序集可以被其他程序集引用，因为类型信息元数据被保留。引用也与其他托管编程语言完全兼容，因为提供的类型的类型元数据被完全解析，并且程序集本身在正常的
    .NET CLR 兼容的之上完全可用。'
- en: '**Erased type providers**: The generated type provided metadata is erased at
    runtime. This means the type provided metadata information is not available at
    runtime. The consequence of erased type provider is quite obvious: all generated
    types will always be typed as an object type at runtime. This is useful when generating
    type providers for semi-unstructured data and when the focus of resulting type
    provided metadata is less than the resulting data. This erased type strategy is
    also a recommended strategy to implement type providers for types that focus on
    the object''s behaviors (the methods and the inherited methods) instead of the
    object''s properties. Focusing on the object''s behaviors means that we only care
    about what the object can do, instead of its properties and attributes.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已删除类型提供者**：提供的生成类型元数据在运行时被删除。这意味着提供的类型元数据信息在运行时不可用。已删除类型提供者的后果非常明显：所有生成的类型在运行时都将始终被类型化为对象类型。这在生成半结构化数据类型提供者时很有用，当结果类型提供者元数据的重点小于结果数据时。这种已删除类型策略也是实现专注于对象行为（方法和继承方法）而不是对象属性的类型提供者的推荐策略。专注于对象的行为意味着我们只关心对象能做什么，而不是它的属性和属性。'
- en: These two strategies are also defined as how you implement a type provider because
    it must be chosen at first, as it will affect the returning type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种策略也被定义为如何实现类型提供者，因为必须在首先选择它，因为它将影响返回的类型。
- en: All of the returning provided types result as assemblies. Erased type and generative
    type provider requires more work in the sense of implementations because they
    require more careful planning on how the generated type is returned.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有返回的提供类型都作为程序集结果。已删除类型和生成类型提供者需要更多的实现工作，因为它们需要更仔细地规划如何返回生成的类型。
- en: The next section will give us a deeper overview of choosing strategies.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将更深入地概述选择策略。
- en: Choosing strategies of type provider implementation
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择类型提供者实现策略
- en: Before we dive deeper and start planning the implementation of type providers,
    we should choose one of the two strategies. There is no strategy that has a combination
    of both of them because this will again define the resulting provided type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨并开始规划类型提供者的实现之前，我们应该选择这两种策略中的一种。没有结合这两种策略的策略，因为这又将定义返回的提供类型。
- en: 'The high-level overview of the reason for choosing between erased and generative
    type provider is already provided by Microsoft in this MSDN Library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此MSDN库中，微软已经提供了选择已删除和生成类型提供者之间原因的高级概述：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/type-providers/creating-a-type-provider)'
- en: 'But unfortunately, the explanation on the reason for choosing the erased type
    provider is not quite clear. Check out the following definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但不幸的是，关于选择已删除类型提供者的原因的解释并不十分清楚。查看以下定义：
- en: '*When you are writing a provider for an information space that is so large
    and interconnected that it isn''t technically feasible to generate real .NET types
    for the information space.*'
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当你正在编写一个为如此之大且相互连接的信息空间提供程序时，该信息空间在技术上无法生成真实.NET类型。*'
- en: This definition may look simple but it is not enough to quickly understand.
    The term *so large* should be more explained in detail, along with *interconnected*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义看起来很简单，但不足以快速理解。术语*如此之大*应该有更详细的解释，以及*相互连接*。
- en: 'Why? The definition might have ambiguous meanings/semantics. These are the
    ambiguous semantics:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？定义可能有模糊的含义/语义。这些是模糊的语义：
- en: In what sense is the data *so large*? The volume or the number of data?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据*如此之大*在什么意义上？是数据量还是数据数量？
- en: What is the meaning of interconnected? Is it connected by the data itself or
    does the data come from multiple sources?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相互连接的含义是什么？是数据本身连接还是数据来自多个来源？
- en: The term large data and interconnected will be explained as part of the detailed
    reasons why we decide to use erased type provider.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 术语大数据和相互连接将作为我们决定使用已删除类型提供者的详细原因的一部分进行解释。
- en: 'Erased type provider is best for the following cases:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 已删除类型提供者最适合以下情况：
- en: You don't care much about the format and the structure of the data returned.
    This also applies for unstructured data. Some common cases are if the metadata
    does not matter much and also if the data itself is unstructured. For example,
    having a type provider for Twitter feeds as it's mostly unstructured.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不必太关心返回数据的格式和结构。这也适用于非结构化数据。一些常见情况是，如果元数据不是很重要，或者数据本身是非结构化的。例如，为Twitter流提供类型提供者，因为它主要是非结构化的。
- en: 'The volume of data is too large: you don''t care about the type and the format
    of structure of the data because the volume of data to be mapped is so large,
    and it is not quite feasible or even efficient to try generating strong and strict
    type provided as the result. For example, the returning semi-structured data from
    World Bank or NASA Hubble images with metadata. This is a very huge dataset, and
    the volume for each data item for each row itself is already very large. From
    the perspective of NASA Hubble images, one image can have a size ranging from
    100 MB to more than 500 MB, and one stream of data can be hundreds of images.
    In this case, it is also related to point 1 because most images are unstructured;
    therefore, it fits in point 1 and this point 2\. This is also the same semantic
    in the term *so large*; it is so large in terms of the volume of data, *not in
    the number of data*.'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据量太大：你不必关心数据的类型和结构，因为要映射的数据量非常大，尝试生成强类型和严格类型提供的结果并不切实际，甚至可能不高效。例如，从世界银行或NASA哈勃图像中返回的半结构化数据，这些数据集非常大，每行数据项的体积本身就已经非常大。从NASA哈勃图像的角度来看，一张图片的大小可以从100
    MB到超过500 MB不等，一个数据流可以包含数百张图片。在这种情况下，这也与第1点相关，因为大多数图片都是非结构化的；因此，它符合第1点和第2点。这也与术语*非常大*具有相同的语义；在数据量上非常大，*不是数据数量*。
- en: You don't care about the format of the data because the format of the data itself
    often changes. This is common when getting data from querying social media. For
    example, querying data from Facebook using the Facebook API is quite challenging
    because Facebook keeps changing its API specifications almost once every year.
    Choosing a generative type provider is not fit for this because generative type
    provider implicitly requires us to have a tight coupling in the types and hence
    the assembly generated.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不必关心数据的格式，因为数据格式本身经常变化。这在从社交媒体查询数据时很常见。例如，使用Facebook API从Facebook查询数据相当具有挑战性，因为Facebook几乎每年都会更改其API规范。选择生成类型提供者不适合这种情况，因为生成类型提供者隐式地要求我们在类型上具有紧密耦合，从而生成相应的组件。
- en: The data that you query contains heavy relations that links to themselves not
    just with normal JOIN clauses or SQL EQUI JOIN clauses but may also contain a
    recursive relation to itself. This scenario is common when we are defining a structure
    inside an unstructured data by examining the content of the data and extracting
    some part of it. For example, a tweet from a stream of Twitter may contain hashtags
    that might be linked, and the link might be loosely linked or it can be categorized
    into a higher category. This is the same as *interconnected* as defined in the
    MSDN documentation in the type provider tutorial.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你查询的数据包含重关系，这些关系不仅通过正常的JOIN子句或SQL EQUI JOIN子句与自身链接，还可能包含递归关系。当我们通过检查数据内容并从中提取部分内容来定义非结构化数据中的结构时，这种情况很常见。例如，来自Twitter流的一条推文可能包含可能链接的标签，这些链接可能是松散链接，或者可以归类为更高级别的类别。这与MSDN文档中类型提供者教程中定义的*互联*相同。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we define large datasets, we can argue about the size. But even in today's
    age of ubiquitous cheap large storage and high speed Internet (broadband), having
    to analyze data larger than 100 MB for each row is still very large and takes
    a lot of time to process even just to read it. This is crucial because the speed
    of storage can't keep up with the memory and CPU speed as the size of data to
    be read takes long time to process before it is put into memory. Also, type providers
    usually work best to handle data to be represented in the code and this will increase
    CPU time or I/O overheads because of the activities of querying large data and
    subsequently processing it into types with properties mapped from the data source.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义大型数据集时，我们可以争论其大小。但在今天这个普遍存在廉价大容量存储和高速度互联网（宽带）的时代，每行数据超过100 MB的分析需求仍然非常大，即使仅仅是读取也需要花费大量时间。这一点至关重要，因为存储速度无法跟上内存和CPU的速度，因为读取的数据量很大，在将其放入内存之前需要花费很长时间来处理。此外，类型提供者通常在处理要在代码中表示的数据时表现最佳，这会增加CPU时间或I/O开销，因为查询大量数据并将其处理成具有从数据源映射过来的属性的类型的活动。
- en: 'For more definition on SQL EQUI JOIN clauses (including various SQL `LEFT`/`RIGHT
    JOIN`), visit MSDN Library at:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于SQL EQUI JOIN子句的定义（包括各种SQL `LEFT`/`RIGHT JOIN`），请访问MSDN库：
- en: '[https://msdn.microsoft.com/en-us/library/ms177634.aspx](https://msdn.microsoft.com/en-us/library/ms177634.aspx)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms177634.aspx](https://msdn.microsoft.com/en-us/library/ms177634.aspx)'
- en: Grasping the basic concept of type provider is quite hard because you have to
    understand the internal works on how the type is provided and also how the type
    is constructed. It is easier to understand the concept by simultaneously looking
    at the documentation and also trying the samples of type providers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 理解类型提供者的基本概念相当困难，因为你必须理解类型是如何提供的以及类型是如何构建的。通过同时查看文档和尝试类型提供者的示例，更容易理解这个概念。
- en: It is also strongly recommended for all of us that in order to use the samples
    of type providers, we should use the built-in type provider in F#, `FSharp.Data.TypeProvider`.
    This is also very useful because this built-in type provider is supported by Microsoft.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈推荐大家，为了使用类型提供者的示例，我们应该使用F#内置的类型提供者`FSharp.Data.TypeProvider`。这也非常有用，因为内置的类型提供者是微软支持的。
- en: 'The disadvantages of erased type provider are as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 擦除类型提供者的缺点如下：
- en: The returning type provider may be resolved as an object. This is intentional
    because of the erased nature of type provided.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的类型提供者可能被解析为一个对象。这是故意的，因为提供的类型具有擦除性质。
- en: The assembly generated from an erased type provider is available in the F# project
    environment. This means that you cannot reference the erased type provider to
    other non-F# projects such as C#/VB projects, unless you combine the property
    of the erased type to have generative properties using normal CLR objects instead
    of F# record type.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从擦除类型提供者生成的程序集在F#项目环境中可用。这意味着你不能将擦除类型提供者引用到其他非F#项目，如C#或VB项目，除非你结合擦除类型的属性，使用正常的CLR对象而不是F#记录类型来具有生成属性。
- en: A combination of erased and generative type providers is quite common in order
    to have an implementation of mixing the best advantages of both the strategies.
    We shall see that this is relevant in the next section of implementing our own
    custom type provider, later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '擦除和生成类型提供者的组合相当常见，以便实现混合两种策略最佳优势的实现。我们将看到，这在下一节实现我们自己的自定义类型提供者中是相关的，本章后面部分。 '
- en: A good sample of F# erased type provider implementation is the `FSharp.Extras`
    library provided by Forkmann.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: F#擦除类型提供者实现的一个好例子是Forkmann提供的`FSharp.Extras`库。
- en: 'The latest version of the library does not have the original type provider
    version included, but it is still there in the GitHub repo under the branch name
    of `VS2012`. This `VS2012` branch''s library has type provider supports for the
    following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该库的最新版本没有包含原始的类型提供者版本，但它仍然存在于GitHub仓库的`VS2012`分支下。这个`VS2012`分支的库支持以下类型提供者：
- en: Regex (the regex model is using .NET BCL regex)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regex（正则表达式模型使用.NET BCL正则表达式）
- en: XML
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML
- en: Excel
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel
- en: Registry
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表
- en: JSON
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: We have grasped the reasoning behind erased type providers; let's visit the
    reasoning behind generative type providers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经掌握了擦除类型提供者的推理；让我们来看看生成类型提供者的推理。
- en: 'Generative type providers are more powerful and this greater power comes with
    its own expenses: it requires more works to construct and it''s also stricter
    than the erased type provider.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成型类型提供器功能更强大，但这种更大的功能也带来了自己的代价：它需要更多的工作来构建，并且也比擦除类型提供器更严格。
- en: Now let's see the existing type provider (built-in) that F# has.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 F# 中现有的类型提供器（内置）。
- en: Sample usage of built-in type provider in F#
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 中内置类型提供器的示例用法
- en: Let's try the existing F# type provider and put it in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试现有的 F# 类型提供器并将其付诸实践。
- en: 'The following is the list of existing F# type provider supports in F# 4.0 `FSharp.Data.TypeProviders`
    (with the type that serves) :'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 F# 4.0 中 `FSharp.Data.TypeProviders` 支持的现有 F# 类型提供器的列表（包括提供服务的类型）：
- en: SQL Server database (`SqlDataConnection`)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 数据库 (`SqlDataConnection`)
- en: Entity Framework (`SqlEntityConnection`)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体框架 (`SqlEntityConnection`)
- en: OData (`ODataService`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OData (`ODataService`)
- en: WSDL service (`WsdlService`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WSDL 服务 (`WsdlService`)
- en: EDMX or the Entity Data Model design file (`EdmxFile`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDMX 或实体数据模型设计文件 (`EdmxFile`)
- en: Of all the built-in type provider supports, the easiest one to use is the SQL
    Server database support, using `SqlDataConnection`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有内置类型提供器支持中，最容易使用的是 SQL Server 数据库支持，使用 `SqlDataConnection`。
- en: Quick sample of using SqlDataConnection type provider
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SqlDataConnection 类型提供器的快速示例
- en: We are now going to use F# SQL Server database type provider using `SqlDataConnection`
    by referencing F# type provider's DLL assembly, `FSharp.Data.TypeProviders`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 F# SQL Server 数据库类型提供器通过引用 F# 类型提供器的 DLL 程序集 `FSharp.Data.TypeProviders`
    来使用 `SqlDataConnection`。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name of the SQL Server type provider is mentioned as SQL database provider,
    and this is misleading. This type provider can only be used for SQL Server database
    and not for other SQL-compliant databases such as Oracle, IBM DB2\. Throughout
    the rest of this book, existing F# type providers for SQL will always be mentioned
    as SQL Server database type providers for the sake of clarity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 类型提供器的名称被提及为 SQL 数据库提供器，这是误导性的。此类型提供器只能用于 SQL Server 数据库，而不能用于其他
    SQL 兼容数据库，如 Oracle、IBM DB2。在本书的其余部分，现有的 F# SQL 类型提供器将始终被称为 SQL Server 数据库类型提供器，以保持清晰。
- en: 'The following are the requirements before using `FSharp.Data.TypeProviders.SqlDataConnection`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `FSharp.Data.TypeProviders.SqlDataConnection` 之前，以下是一些要求：
- en: Ensure that we have SQL Server 2008 R2 (or later) installed. We need this because
    we are going to access SQL Server database data. It is recommended to install
    the instance on your machine.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已安装 SQL Server 2008 R2（或更高版本）。我们需要这个版本，因为我们将要访问 SQL Server 数据库。建议在您的机器上安装实例。
- en: Ensure that .NET 4.6 is installed correctly. This is important because the `FSharp.Data.TypeProviders`
    assembly in F# 4.0 depends on .NET 4.5 and above.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保正确安装了 .NET 4.6。这很重要，因为 F# 4.0 中的 `FSharp.Data.TypeProviders` 程序集依赖于 .NET 4.5
    或更高版本。
- en: Do not modify the F# target compiler without checking the .NET Framework target
    version. F# 4.0 in Visual Studio 2015 is recommended to work with .NET 4.6, not
    .NET 4.5.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在修改 F# 目标编译器之前，请检查 .NET Framework 目标版本。在 Visual Studio 2015 中，建议使用 F# 4.0 与
    .NET 4.6 一起工作，而不是 .NET 4.5。
- en: 'Point 3 is quite subtle but it is extremely important: `FSharp.Data.TypeProviders`,
    F# tooling, F# compiler infrastructure, .NET Framework version in Visual Studio
    2015 have a tight coupling. For example, `FSharp.Data.TypeProviders` has support
    for .NET 4.5 or later, but all of the F# projects in Visual Studio 2015 by default
    have a target for .NET 4.6 and so does the compiler of F# 4.0.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 点相当微妙，但非常重要：`FSharp.Data.TypeProviders`、F# 工具、F# 编译器基础设施、Visual Studio 2015
    中的 .NET Framework 版本紧密耦合。例如，`FSharp.Data.TypeProviders` 支持 .NET 4.5 或更高版本，但 Visual
    Studio 2015 中的所有 F# 项目默认情况下都针对 .NET 4.6，F# 4.0 编译器也是如此。
- en: Although `FSharp.Data.TypeProviders` can be used in F# 3.0 projects in Visual
    Studio 2013, backporting `FSharp.Data.TypeProviders` in Visual Studio 2015 for
    use in Visual Studio 2013 might yield compatibility issues when compiling.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `FSharp.Data.TypeProviders` 可以在 Visual Studio 2013 中的 F# 3.0 项目中使用，但将 `FSharp.Data.TypeProviders`
    返回到 Visual Studio 2015 以在 Visual Studio 2013 中使用可能会在编译时产生兼容性问题。
- en: The F# 4.0 compiler itself might yield different warnings compared to F# 3.0
    compiler. Using 4.0 version is highly recommended because it has bug fixes, especially
    bug fixes on very long time outstanding since version 2.0.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 F# 3.0 编译器相比，F# 4.0 编译器可能会产生不同的警告。强烈建议使用 4.0 版本，因为它有错误修复，特别是自 2.0 版本以来长期存在的问题的修复。
- en: Consult the F# 4.0 release notes at GitHub at [https://github.com/Microsoft/visualfsharp/blob/master/CHANGELOG.md](https://github.com/Microsoft/visualfsharp/blob/master/CHANGELOG.md).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上查看 F# 4.0 发布说明 [https://github.com/Microsoft/visualfsharp/blob/master/CHANGELOG.md](https://github.com/Microsoft/visualfsharp/blob/master/CHANGELOG.md)。
- en: 'To quickly get started, we need a sample database to be deployed on SQL Server.
    We can use the popular Northwind sample database that was originally created for
    SQL Server 2000\. Download the SQL Server 2000 sample database installer from
    this official Microsoft''s download link:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速开始，我们需要一个在 SQL Server 上部署的示例数据库。我们可以使用最初为 SQL Server 2000 创建的流行 Northwind
    示例数据库。从以下官方微软下载链接下载 SQL Server 2000 示例数据库安装程序：
- en: '[https://www.microsoft.com/en-us/download/details.aspx?id=23654](https://www.microsoft.com/en-us/download/details.aspx?id=23654)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.microsoft.com/en-us/download/details.aspx?id=23654](https://www.microsoft.com/en-us/download/details.aspx?id=23654)'
- en: Install the installer. Then, go to the installation path of the installer and
    open the file, `instnwnd.sql` in the SQL Server Management Studio and execute
    it by running the script.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装安装程序。然后，转到安装程序的安装路径，在 SQL Server Management Studio 中打开文件，`instnwnd.sql`，并运行脚本执行它。
- en: 'If the execution of database creation succeeds, then the Northwind database
    will be available on the left of Management Studio''s **Object Explorer**, as
    shown in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库创建执行成功，则 Northwind 数据库将在 Management Studio 的 **对象资源管理器** 左侧可用，如下面的截图所示：
- en: '![Quick sample of using SqlDataConnection type provider](img/image00311.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SqlDataConnection 类型提供程序的快速示例](img/image00311.jpeg)'
- en: 'These are the steps required in Visual Studio:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在 Visual Studio 中所需的步骤：
- en: Create a new F# class library project or console project. Do not create another
    type of F# project such as Silverlight or even Android, because it is not compatible
    with F# type provider target of .NET Framework 4.6.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 F# 类库项目或控制台项目。不要创建其他类型的 F# 项目，例如 Silverlight 或 Android，因为它们与 .NET Framework
    4.6 的 F# 类型提供程序不兼容。
- en: Add references to `System.Data`, `System.Data.Linq`, and `System.Linq`. The
    physical DLL assembly filename for `System.Linq` is `System.Core.dll`, and the
    `System.Data` object's filename is `System.Data.dll`. `System.Data.Linq` is available
    in `System.Data.Linq.dll`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `System.Data`、`System.Data.Linq` 和 `System.Linq` 的引用。`System.Linq` 的物理 DLL
    程序集文件名为 `System.Core.dll`，`System.Data` 对象的文件名为 `System.Data.dll`。`System.Data.Linq`
    可在 `System.Data.Linq.dll` 中找到。
- en: Add references to `FSharp.Data.TypeProviders`. If you want to focus on F# interactive
    (scripting), then register the DLL manually using the `#r` directive.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对 `FSharp.Data.TypeProviders` 的引用。如果你想要专注于 F# 交互式（脚本），则可以使用 `#r` 指令手动注册 DLL。
- en: Ensure that for built-in `System.Data`, `System`, and `Linq`, `System.Data.Linq`
    is properly referenced (as `System.Data.dll` and `System.Core.dll`).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保内置的 `System.Data`、`System` 和 `Linq`、`System.Data.Linq` 正确引用（作为 `System.Data.dll`
    和 `System.Core.dll`）。
- en: 'To ensure correct references, adding the references of `System.Core`, `System.Data`,
    `System.Data.Linq` is available in the **Framework** section under **Assemblies**:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保正确的引用，在 **Assemblies** 下的 **Framework** 部分添加 `System.Core`、`System.Data`、`System.Data.Linq`
    的引用：
- en: '![Quick sample of using SqlDataConnection type provider](img/image00312.jpeg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 SqlDataConnection 类型提供程序的快速示例](img/image00312.jpeg)'
- en: 'And adding reference to  `FSharp.Data.TypeProviders` is available in the **Extensions**
    section under **Assemblies**:'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **Assemblies** 下的 **Extensions** 部分添加对 `FSharp.Data.TypeProviders` 的引用：
- en: '![Quick sample of using SqlDataConnection type provider](img/image00313.jpeg)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![使用 SqlDataConnection 类型提供程序的快速示例](img/image00313.jpeg)'
- en: This is necessary because the F# built-in type provider assembly is not a part
    of .NET Framework 4.6 runtime distribution.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 F# 内置类型提供程序程序集不是 .NET Framework 4.6 运行时分布的一部分。
- en: Create a new F# source code file and name it `SampleFSharpData`. By default,
    F# will treat this as a new file, which has a module declaration with the same
    name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 F# 源代码文件，并将其命名为 `SampleFSharpData`。默认情况下，F# 会将其视为一个新文件，该文件具有与同一名称的模块声明。
- en: 'Type the following code after the module declaration:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块声明之后输入以下代码：
- en: '[PRE0]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the type declaration of `NorthwindSchema`, ensure that you have specified
    the connection string for the `SqlDataConnection`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NorthwindSchema` 的类型声明之后，确保你已经指定了 `SqlDataConnection` 的连接字符串。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This `SqlDataConnection` is not related to `SqlConnection`, which is a part
    of ADO.NET's `System.Data.SqlClient` namespace. `SqlDataConnection` is a part
    of F# built-in type provider.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `SqlDataConnection` 与 `SqlConnection` 无关，后者是 ADO.NET 的 `System.Data.SqlClient`
    命名空间的一部分。`SqlDataConnection` 是 F# 内置类型提供程序的一部分。
- en: 'In order to quickly see the type provider in action, build or rebuild the project.
    Type this on the new line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速看到类型提供器的效果，构建或重新构建项目。在新的一行上输入以下内容：
- en: '[PRE1]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At the time of typing *dot* after `nwdb`, Visual Studio will display the properties
    and methods of `nwdb`. The properties are actually the names of tables of the
    connected database, the Northwind.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入 `nwdb` 后的 `*dot*` 时刻，Visual Studio 将显示 `nwdb` 的属性和方法。这些属性实际上是连接的数据库 Northwind
    的表名。
- en: 'This is the display of Visual Studio Intellisense, displaying the properties:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Visual Studio Intellisense 的显示，显示属性：
- en: '![Quick sample of using SqlDataConnection type provider](img/image00314.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SqlDataConnection 类型提供器的快速示例](img/image00314.jpeg)'
- en: 'Now, let''s continue to harness the SQL Server type provider by querying customer
    data. Change the code into this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续利用 SQL Server 类型提供器通过查询客户数据。将代码修改如下：
- en: '[PRE2]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s call the `displayAllCustomerName` function. On the main `EntryPoint`,
    modify `EntryPoint` with the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用 `displayAllCustomerName` 函数。在主 `EntryPoint` 中，将 `EntryPoint` 修改为以下代码：
- en: '[PRE3]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the code of `customerNameData`, it contains an evaluation result of a LINQ
    query computation expression.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `customerNameData` 的代码中，它包含了一个 LINQ 查询计算表达式的评估结果。
- en: 'This LINQ query computation is essentially the same computation implementation
    of LINQ in F#. This query computation began with the release of F# 3.0 in Visual
    Studio 2012\. For more information about F# LINQ query computation, consult the
    following link:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 LINQ 查询计算实际上是 F# 中 LINQ 计算的实现。这个查询计算始于 F# 3.0 在 Visual Studio 2012 中的发布。有关
    F# LINQ 查询计算的信息，请参阅以下链接：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/query-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/query-expressions)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/query-expressions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/query-expressions)'
- en: 'Let''s rebuild the project to ensure that re-references are correct and the
    dependencies are checked again. Run the code without debugging, and we will have
    a display of all the customer names:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新构建项目以确保重新引用正确，并且再次检查依赖项。在不进行调试的情况下运行代码，我们将显示所有客户名称：
- en: '![Quick sample of using SqlDataConnection type provider](img/image00315.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SqlDataConnection 类型提供器的快速示例](img/image00315.jpeg)'
- en: 'We can also do additional queries such as adding the `WHERE` and `ORDER BY`
    clauses by translating them into LINQ in F#. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行额外的查询，例如通过将它们转换为 F# 中的 LINQ 来添加 `WHERE` 和 `ORDER BY` 子句。例如：
- en: '[PRE4]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `WHERE` clause is implemented as `where` and `ORDER BY` is implemented as
    `sortBy`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE` 子句实现为 `where`，而 `ORDER BY` 实现为 `sortBy`。'
- en: Now let's use our little sample in another project with a different language,
    such as C#. This sample is also very simple but it is quite powerful because we
    will use our library that uses F# type providers with C#, although we cannot see
    the Intellisense provided by F# Type Provider compilation addition directly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的另一个项目中使用不同的语言，例如 C#，来使用我们的示例。这个示例也很简单，但非常强大，因为我们将在 C# 中使用我们的库，该库使用
    F# 类型提供器，尽管我们无法直接看到 F# 类型提供器编译添加提供的 Intellisense。
- en: 'We need to perform the following steps before we use the F# sample type provider''s
    code with C#:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 F# 样例类型提供器的代码与 C# 一起使用之前，我们需要执行以下步骤：
- en: Create a C# console project.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 C# 控制台项目。
- en: Add a reference of the previous F# class library project that we created with
    the `SampleFSharpData` module.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们之前创建的包含 `SampleFSharpData` 模块的 F# 类库项目的引用。
- en: Add a reference of `System.Data.Linq` assembly.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `System.Data.Linq` 程序集的引用。
- en: Rebuild the project. This is important as you need to ensure that the added
    reference works well.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建项目。这很重要，因为您需要确保添加的引用可以正常工作。
- en: 'In the `main` method of `Program.cs`, add the calls to the `displayCustomerNameStartsWith`
    method. The `main` method should be coded as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 的 `main` 方法中，添加对 `displayCustomerNameStartsWith` 方法的调用。`main`
    方法应该编写如下：
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run it, and we will have the same result as the previous F# project.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，我们将得到与之前 F# 项目相同的结果。
- en: 'To check the inferred property of `NorthwindSchema` instances of `nwdb`, we
    can use the following code to test:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 `nwdb` 的 `NorthwindSchema` 实例推断出的属性，我们可以使用以下代码进行测试：
- en: '[PRE6]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we can see and prove that the F# type provider usages can be used in other
    managed programming languages as well, although it cannot be used directly. This
    interoperability sample is also a proof of point 5 of advantages of F# type provider.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到并证明 F# 类型提供程序的使用也可以在其他托管编程语言中使用，尽管不能直接使用。这个互操作性示例也是 F# 类型提供程序优势第 5
    点的证明。
- en: It is also important to understand the implementation of `SqlDataConnection`
    because `SqlDataConnection` is a sample of a generative type provider because
    the generated type can be used with the full metadata information available (properties
    and methods).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `SqlDataConnection` 的实现也很重要，因为 `SqlDataConnection` 是一个生成类型提供程序的示例，因为生成的类型可以使用可用的完整元数据信息（属性和方法）。
- en: 'For more information about using `FSharp.Data.TypeProviders.SqlDataConnection`,
    visit this MSDN Library:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于使用 `FSharp.Data.TypeProviders.SqlDataConnection` 的信息，请访问此 MSDN 图书馆：
- en: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/sqldataconnection-type-provider-%5bfsharp%5d)'
- en: '`SqlDataConnection` itself is open source and is available with the other `FSharp.Data.TypeProviders`
    features. The GitHub repository of `FSharp.Data.TypeProviders` is available at
    [https://github.com/fsprojects/FSharp.Data.TypeProviders](https://github.com/fsprojects/FSharp.Data.TypeProviders).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlDataConnection` 本身是开源的，并且与其他 `FSharp.Data.TypeProviders` 功能一起提供。`FSharp.Data.TypeProviders`
    的 GitHub 仓库可在 [https://github.com/fsprojects/FSharp.Data.TypeProviders](https://github.com/fsprojects/FSharp.Data.TypeProviders)
    找到。'
- en: Now let's go deeper into type providers by implementing our own type provider
    in various scenarios in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在下一节中实现自己的类型提供程序在各种场景中更深入地了解类型提供程序。
- en: Implementing your own type provider
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自己的类型提供程序
- en: We already have enough knowledge on what a type provider is, the building blocks,
    and the nature of type providers, also understanding the nature of type provider
    implementations, including the implementation strategies, as we went deeper.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对类型提供程序有了足够的了解，包括其构建块和类型提供程序的本质，以及随着我们深入理解类型提供程序实现的本质，包括实现策略。
- en: To ease the experience and our type provider building mindset, a real experience
    of quickly using it from existing samples has proven to be very useful. We have
    increased our intuition on how type provider works using samples from F# 4.0 built-in
    type provider features, `FSharp.Data.TypeProvider`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化体验和我们的类型提供程序构建思维模式，从现有示例中快速使用它的实际经验已被证明非常有用。我们通过使用 F# 4.0 内置类型提供程序功能 `FSharp.Data.TypeProvider`
    的示例，增加了我们对类型提供程序工作原理的直觉。
- en: Implementing your own type provider again is quite a bit tedious, especially
    when we are dealing with generative type providers as our choice of strategy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 再次实现自己的类型提供程序相当繁琐，尤其是当我们选择生成类型提供程序作为我们的策略时。
- en: 'The following are the common steps of implementing your own type provider:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是自己实现类型提供程序的一般步骤：
- en: Declare your type provider. The type provider must be `public`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明你的类型提供程序。类型提供程序必须是 `public`。
- en: Mark your type provider's type with `TypeProviderAttribute`. You can simply
    use the abbreviated `TypeProvider`. This attribute is available in `Microsoft.FSharp.Core.CompilerServices`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `TypeProviderAttribute` 标记你的类型提供程序。你可以简单地使用缩写 `TypeProvider`。此属性位于 `Microsoft.FSharp.Core.CompilerServices`。
- en: Implement the `ITypeProvider` interface. This interface is available in the
    `Microsoft.FSharp.Core.CompilerServices` namespace.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ITypeProvider` 接口。此接口位于 `Microsoft.FSharp.Core.CompilerServices` 命名空间中。
- en: Implement the `IProvidedNamespace` interface. This interface is available in
    the `Microsoft.FSharp.Core.CompilerServices` namespace.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `IProvidedNamespace` 接口。此接口位于 `Microsoft.FSharp.Core.CompilerServices` 命名空间中。
- en: Implement your own code to handle a static parameter for the type provider.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现自己的代码来处理类型提供程序的静态参数。
- en: Implement your own code to provide types, constructors, methods, properties,
    and fields, based on the static parameter used.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现自己的代码，根据使用的静态参数提供类型、构造函数、方法、属性和字段。
- en: The `TypeProviderAttribute` provides hints for F# compiler to look for the necessary
    class that is intended as a type provider.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeProviderAttribute` 为 F# 编译器提供提示，以便查找作为类型提供程序意图的必要类。'
- en: The `ITypeProvider` interface is essential and important because it provides
    the F# compiler the main entry point of the type provider implementation after
    having a hint of a type provider marked by `TypeProviderAttribute`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITypeProvider` 接口是基本且重要的，因为它在 `TypeProviderAttribute` 标记的类型提供程序提示之后，为 F# 编译器提供了类型提供程序实现的主要入口点。'
- en: 'Here are the `ITypeProvider` members and the added description (for clarification):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `ITypeProvider` 成员和添加的描述（以供澄清）：
- en: '| **Abstract method** | **Quick remark** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **抽象方法** | **简要说明** |'
- en: '| `ApplyStaticArguments` | Apply static parameters of this type provider to
    a provided type that accepts static arguments. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `ApplyStaticArguments` | 将此类型提供程序的静态参数应用于接受静态参数的提供类型。 |'
- en: '| `Invalidate` | An event that is triggered when a type resolution semantic
    changes as part of initial type resolution of the provided type. It has the `IEvent`
    type. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `Invalidate` | 当提供类型的初始类型解析中的类型解析语义发生变化时触发的事件。它具有 `IEvent` 类型。 |'
- en: '| `add_invalidate` | Add an event handler of `Invalidate`. It has the same
    semantic as the `+=` syntax of C# event handler addition. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `add_invalidate` | 添加 `Invalidate` 的事件处理程序。它与 C# 事件处理程序添加的 `+=` 语法具有相同的语义。
    |'
- en: '| `remove_invalidate` | Remove an event handler of `Invalidate`. It has the
    same semantic as `-=` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `remove_invalidate` | 移除 `Invalidate` 的事件处理程序。它与 `-=` 语法具有相同的语义。 |'
- en: '| `GetInvokerExpression` | Called by the compiler to ask for an expression
    tree to replace the given `System.Reflection.MethodBase` with. This is also important
    as `GetInvokerExpression` will be used as our entry point to provide reflection
    information of the methods that we are going to generate as part of the type that
    will be provided. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `GetInvokerExpression` | 由编译器调用，以请求一个表达式树来替换给定的 `System.Reflection.MethodBase`。这也很重要，因为
    `GetInvokerExpression` 将用作我们提供反射信息的入口点，这些信息是我们将作为提供类型的一部分生成的。 |'
- en: '| `GetGeneratedAssemblyContents` | Get the physical contents of the given logical
    assembly. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `GetGeneratedAssemblyContents` | 获取给定逻辑程序集的物理内容。 |'
- en: '| `GetNamespaces` | Return the namespace name that this type provider injects
    types into. This will be the namespace for all types provided. This is why it
    returns an array of `IProvidedNamespace`. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `GetNamespaces` | 返回此类型提供程序注入类型的命名空间名称。这将是所有提供类型的命名空间。这就是为什么它返回一个 `IProvidedNamespace`
    的数组。 |'
- en: '| `GetStaticParameters` | Get all static parameters for this type provider.
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `GetStaticParameters` | 获取此类型提供程序的所有静态参数。 |'
- en: 'To understand what the context of static parameters in type provider is, let''s
    go back to the sample of using `SqlDataConnection`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解类型提供程序中静态参数的上下文，让我们回到使用 `SqlDataConnection` 的示例：
- en: '[PRE7]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The string parameter in the `< >` brackets is the static parameter of the `SqlDataConnection`
    type provider. It is required in the case of `SqlDataConnection` because we need
    to apply the database connection string immediately when we are instantiating
    the `SqlDataConnection` type provider.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`< >` 括号中的字符串参数是 `SqlDataConnection` 类型提供程序的静态参数。在 `SqlDataConnection` 的情况下是必需的，因为我们需要在实例化
    `SqlDataConnection` 类型提供程序时立即应用数据库连接字符串。'
- en: An invalidate event will be used by F# to trigger type resolution validation,
    and we can add many event handlers as needed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: F# 将使用无效化事件来触发类型解析验证，我们可以根据需要添加许多事件处理程序。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Warning*: *It is highly recommended to add only F# event handlers within the
    F# syntax and semantics instead of C#/VB event handlers*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*警告*：强烈建议只使用 F# 事件处理程序和 F# 语法和语义，而不是 C#/VB 事件处理程序。'
- en: This is crucial because F# event handlers support implicit currying by default.
    Otherwise, undesirable results will occur, including unexpected memory leaks!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这至关重要，因为 F# 事件处理程序默认支持隐式柯里化。否则，可能会出现不希望的结果，包括意外的内存泄漏！
- en: The implementation of code to provide types, constructors, methods, properties,
    and fields is tedious, not just implementing all members of `ITypeProvider` and
    `IProvidedNamespace`. We have to dive deeper into the inner workings of API in
    the .NET namespaces of `System.Reflection` and `System.Reflection.Emit`. This
    is crucial and important because types, constructors, methods, properties, and
    fields are all related to the reflection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 提供类型、构造函数、方法、属性和字段的代码实现是繁琐的，不仅需要实现 `ITypeProvider` 和 `IProvidedNamespace` 的所有成员。我们必须深入了解
    `.NET` 命名空间中 `System.Reflection` 和 `System.Reflection.Emit` 的内部工作原理。这是至关重要的，因为类型、构造函数、方法、属性和字段都与反射相关。
- en: Fortunately, Microsoft and F# Foundation have provided a starter pack library
    to ease the creation of type providers from the start. The name of the NuGet package
    library is `FSharp.TypeProviders.StarterPack`, and we can simply use this library
    by adding it from NuGet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Microsoft 和 F# Foundation 已经提供了一个入门包库，以简化从开始创建类型提供者的过程。此 NuGet 包库的名称为 `FSharp.TypeProviders.StarterPack`，我们可以简单地通过从
    NuGet 添加它来使用此库。
- en: To ensure the validity of the starter pack, use the [http://www.nuget.org](http://www.nuget.org)
    feed because this is the official NuGet repository that contains the commonly
    used .NET NuGet packages.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保入门包的有效性，请使用 [http://www.nuget.org](http://www.nuget.org) 提供的源，因为这是包含常用 .NET
    NuGet 包的官方 NuGet 仓库。
- en: 'To use this NuGet, add this NuGet package on your project and accept the license
    agreement. If you have installed it successfully, Visual Studio will display the
    NuGet package under the **Installed** tab, as shown in the following screenshot:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此 NuGet，请在您的项目中添加此 NuGet 包并接受许可协议。如果您已成功安装，Visual Studio 将在**已安装**选项卡下显示
    NuGet 包，如下面的截图所示：
- en: '![Implementing your own type provider](img/image00316.jpeg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![实现自己的类型提供者](img/image00316.jpeg)'
- en: Now, let's dig deeper into building a type itself by looking at the internal
    working of this starter pack.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过查看此入门包的内部工作原理来更深入地探讨构建类型本身。
- en: Building the type's building blocks
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建类型的构建块
- en: A type or a class in C#/VB is basically a blueprint of any object instance.
    It contains definitions of methods, properties, constructors, and other metadata
    of a class, such as the attributes applied on the type and its properties, methods,
    and constructors.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: C# 或 VB 中的类型或类基本上是任何对象实例的蓝图。它包含类的定义，包括方法、属性、构造函数以及其他元数据，例如应用于类型及其属性、方法和构造函数的属性。
- en: The .NET BCL provides us reflection API in the `System.Reflection` and `System.Reflection.Emit`
    namespaces. We can create the type's building blocks by lining up the calls to
    reflection APIs, but these calls to reflection API must have enough knowledge
    not just of ordinary methods/properties but also of the F# delegate, `FSharpFunc`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: .NET BCL 在 `System.Reflection` 和 `System.Reflection.Emit` 命名空间中为我们提供了反射 API。我们可以通过排列对反射
    API 的调用来创建类型的构建块，但这些对反射 API 的调用必须具备足够的知识，不仅包括普通的方法/属性，还包括 F# 委托，`FSharpFunc`。
- en: Although the semantics are similar because of implementation in invoking the
    `Delegate` class of .NET BCL, the actual class used is different. Usually, to
    maintain high interoperability with other managed languages, we should use .NET's
    `Func` and `Action` instead of `FSharpFunc`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于在调用 .NET BCL 的 `Delegate` 类时的语义相似，实际使用的类不同。通常，为了与其他托管语言保持高互操作性，我们应该使用 .NET
    的 `Func` 和 `Action` 而不是 `FSharpFunc`。
- en: As a common rule of thumb, *it is highly recommended to use Func and Action
    instead of F# FSharpFunc to provide a high degree of compatibility for the user
    of the type provider*. Having a high compatibility bar is important; otherwise,
    the type provider used will always need conversions from `FSharpFunc` to ordinary
    `Func` and `Action`, and this conversion will add overhead in using the resulting
    type provided.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条普遍的规则，强烈建议使用 Func 和 Action 而不是 F# FSharpFunc，以提供对类型提供者用户的**高度兼容性**。保持高兼容性标准非常重要；否则，所使用的类型提供者将始终需要从
    `FSharpFunc` 转换为普通的 `Func` 和 `Action`，这种转换将在使用提供的类型时增加开销。
- en: 'By looking and examining the type provider starter pack, we see that it has
    organized the code into the following three files:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看和检查类型提供者入门包，我们发现它已将代码组织成以下三个文件：
- en: '`ProvidedTypes.fsi`: This file contains the type and function declarations'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProvidedTypes.fsi`：此文件包含类型和函数声明'
- en: '`ProvidedTypes.fs`: This file contains code implementations'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProvidedTypes.fs`：此文件包含代码实现'
- en: '`DebugProvidedTypes.fs`: This file contains helpers to simulate the running
    and debugging of type providers'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugProvidedTypes.fs`：此文件包含用于模拟类型提供者的运行和调试的辅助工具'
- en: We can further ease the development of our custom type provider by adding support
    for cross-targeting erased type provider or broader .NET **Portable Class Library**
    (**PCL**), while at the same time we focus on having a single entry of Factory
    method (based on Factory design pattern) of `ProvidedTypesContext.Create()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加对跨目标擦除类型提供者或更广泛的 .NET **可移植类库**（**PCL**）的支持来进一步简化我们自定义类型提供者的开发，同时我们专注于保持
    `ProvidedTypesContext.Create()` 的工厂方法（基于工厂设计模式）的单一点。
- en: 'To add support for this cross-targeting erased type provider, we add these
    three files from the GitHub repo:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种跨目标擦除类型提供程序，我们从 GitHub 仓库添加这三个文件：
- en: '`AssemblyReader.fs`: This file acts as a façade for reading .NET assemblies,
    including .NET PCL assemblies'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssemblyReader.fs`：此文件充当读取 .NET 汇编的代理，包括 .NET PCL 汇编'
- en: '`AssemblyReaderReflection.fs`: This file act as a library of helper functions
    to deal with assembly reflection'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssemblyReaderReflection.fs`：此文件充当处理汇编反射的辅助函数库'
- en: '`ProvidedTypesContext.fs`: This file contains the entry of Factory method of
    the type provider, including the starting point of the `ProvidedTypesContext.Create()`
    method'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProvidedTypesContext.fs`：此文件包含类型提供程序的工厂方法入口，包括 `ProvidedTypesContext.Create()`
    方法的起点'
- en: After adding the preceding prerequisite files, ensure that `Program.fs` is ordered
    at the last file in the project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加上述先决文件后，请确保 `Program.fs` 在项目中的最后文件位置。
- en: 'This neat library provides the basic blocks: type provider base class, reflection
    metadata type helpers, and helpers to interact with type provider strategy. This
    library of classes of functions is also used as the infrastructure of how we generate
    type metadata because we need to prepare the necessary metadata generation infrastructure
    before we can implement a type generator. This infrastructure planning is crucial
    because a type is constructed with building blocks of assembly, parameters, methods,
    constructors, and properties.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整洁的库提供了基本块：类型提供程序基类、反射元数据类型辅助工具，以及与类型提供程序策略交互的辅助工具。这个类和函数的库也用作我们生成类型元数据的基础设施，因为我们需要在实现类型生成器之前准备必要的元数据生成基础设施。这种基础设施规划至关重要，因为类型是由汇编块、参数、方法、构造函数和属性构建的。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, there were subtle but critical differences
    on the files of `FSharp.TypeProviders.StarterPack` distribution in the NuGet package
    and the current GitHub repo. If we only follow the NuGet package files, the current
    NuGet library requires us to manually wire the assembly reflection. The sample
    source code that complements this chapter is already correct to include the NuGet
    and the latest release on GitHub. It is strongly recommended to always use the
    prerequisite files from the source code, compared to using the files from the
    NuGet distribution.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，NuGet 包中 `FSharp.TypeProviders.StarterPack` 分发的文件和当前 GitHub 仓库中的文件存在微妙但关键的区别。如果我们只遵循
    NuGet 包文件，当前的 NuGet 库要求我们手动连接汇编反射。补充本章的示例源代码已经正确包含了 NuGet 和 GitHub 上的最新版本。强烈建议始终使用源代码中的先决文件，而不是使用
    NuGet 分发的文件。
- en: Building type metadata infrastructure
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建类型元数据基础设施
- en: Let's look at the type and function declarations first by focusing on the type
    provider base class. It is quite efficient because it has the implementations
    of `ITypeProvider` and `IProviderNamespace` for us to use.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先关注类型和函数声明，首先关注类型提供程序基类。它非常高效，因为它为我们提供了 `ITypeProvider` 和 `IProviderNamespace`
    的实现。
- en: The class name is `TypeProviderForNamespaces`. The type has checking for custom
    attributes as compiler directive. This is a must have because a type might have
    a custom attribute that may interfere with the F# compiler when it tries to process
    the type provider's type resolution.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 类名为 `TypeProviderForNamespaces`。该类型具有针对自定义属性的编译器指令检查。这是必需的，因为类型可能有一个可能会干扰 F#
    编译器在尝试处理类型提供程序类型解析的自定义属性。
- en: 'Let''s see the signature definition file (FSI) of `TypeProviderForNamespaces`
    (I have omitted the `FX_NO_LOCAL_FILESYSTEM` compiler constant check):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `TypeProviderForNamespaces` 的签名定义文件（FSI）（我已经省略了 `FX_NO_LOCAL_FILESYSTEM`
    编译器常量检查）：
- en: '[PRE8]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's take a look inside the `TypeProviderForNamespaces.fs` file implementation
    (based on the signature defined in the preceding FSI signature).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `TypeProviderForNamespaces.fs` 文件实现（基于前面 FSI 中定义的签名）。
- en: 'We now visit the constructor implementation. The constructor signature is marked
    in the FSI by the notion of these `new` functions:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看构造函数的实现。构造函数签名在 FSI 中通过这些 `new` 函数的概念进行标记：
- en: '[PRE9]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These constructor definitions are implemented as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造函数定义如下实现：
- en: '[PRE10]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The rest of the implementation code is strictly based on the signature convention.
    For example, the implementation of `Invalidate` is matched with the following
    signature:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的实现代码严格基于签名约定。例如，`Invalidate` 的实现与以下签名相匹配：
- en: '[PRE11]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`The Invalidate` is compliant with the signature of `unit -> unit`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invalidate` 符合 `unit -> unit` 的签名。'
- en: Now, let's discuss the details of the implementation of the `ITypeProvider`
    interface in `TypeProviderForNamespaces`. The F# language specification requires
    us to declare an interface implementation explicitly, and the implementation of
    interfaces used must be correctly indented.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 `TypeProviderForNamespaces` 中 `ITypeProvider` 接口实现的细节。F# 语言规范要求我们显式声明接口实现，并且必须正确缩进使用的接口实现。
- en: 'The following code denotes an implementation of the `ITypeProvider` interface:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示 `ITypeProvider` 接口的实现：
- en: '[PRE12]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The interesting part of the implementation of the `ITypeProvider` interface
    is the implementation of the `GetInvokerExpression` method. This method is implemented
    to traverse recursively (with a mutual recursive mechanism) to get the expression
    (as an expression tree of Abstract Syntax Tree) from the method that invoke it.
    Although the recursive is not required, using recursive in the implementation
    of this method is better.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ITypeProvider` 接口实现的有趣部分是 `GetInvokerExpression` 方法的实现。此方法实现为递归地（使用相互递归机制）从调用它的方法中获取表达式（作为抽象语法树的表达式树）。尽管递归不是必需的，但在该方法的实现中使用递归是更好的选择。'
- en: 'The following code is an implementation of `GetInvokerExpression`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `GetInvokerExpression` 的实现：
- en: '[PRE13]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The mutual recursive implementation of `GetInvokerExpression` is split into
    the following two parts:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInvokerExpression` 的相互递归实现分为以下两个部分：'
- en: The first part is for the recognition of the wrapped objects, such as `ProvidedMethod`
    and `ProvidedConstructor.`
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分是用于识别包装对象，例如 `ProvidedMethod` 和 `ProvidedConstructor`。
- en: The second part is for translating the expression from the first part into an
    actual invocation of the method or constructor.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分是将第一部分的表达式转换为实际的方法或构造函数调用。
- en: For the first part, recursive is needed because the `methodBase` parameter at
    first is typed as `ProvidedMethod` or `ProvidedContructor`, then it will invoke
    the underlying method or constructor with the parameters passed by `parameters`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一部分，需要递归，因为 `methodBase` 参数最初被类型化为 `ProvidedMethod` 或 `ProvidedContructor`，然后它将使用通过
    `parameters` 传递的参数调用底层方法或构造函数。
- en: This is important, and it is efficient because we do not have to loop through
    all the types of method implementation iteratively, and this recursive implementation
    means that it will give the desired method invoker information with the detailed
    granularity (either constructor, method, or lambda) as needed, without adding
    a break in the imperative `while` or `for` loop.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，而且效率很高，因为我们不需要迭代地遍历所有方法实现类型，这种递归实现意味着它将根据需要提供详细粒度的期望方法调用者信息（无论是构造函数、方法还是
    lambda），而不需要在命令式的 `while` 或 `for` 循环中添加断点。
- en: Then, let's look at the reflection metadata helper class's signature of the
    provided assembly, parameter, static parameter, constructor, and property in `ProvidedTypes.fsi`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们看看反射元数据辅助类提供的汇编、参数、静态参数、构造函数和属性在 `ProvidedTypes.fsi` 中的签名。
- en: Implementing assembly to provide base assembly
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现汇编以提供基本汇编
- en: 'First, we need to define the assembly. This is crucial as it is the first point
    we have to pay to attention because all of our types generated by type providers
    must have an assembly as the providers'' host. The declaration signature to handle
    assembly generation is implemented in `ProvidedAssembly`. The following is the
    signature of `ProvidedAssembly`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义汇编。这至关重要，因为这是我们首先要关注的地方，因为所有由类型提供者生成的类型都必须有一个汇编作为提供者的宿主。处理汇编生成的声明签名在
    `ProvidedAssembly` 中实现。以下是 `ProvidedAssembly` 的签名：
- en: '[PRE14]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The implementation of `ProvidedAssembly` is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProvidedAssembly` 的实现如下：'
- en: '[PRE15]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For more information on what is a .NET assembly, visit:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 .NET 汇编的信息，请访问：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/standard/assembly-format](https://docs.microsoft.com/en-us/dotnet/articles/standard/assembly-format)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/standard/assembly-format](https://docs.microsoft.com/en-us/dotnet/articles/standard/assembly-format)'
- en: Implementing parameters for methods and constructors
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现方法和构造函数的参数
- en: 'The next step after handling the assembly is to examine the implementation
    of `ProvidedParameter` (some comments removed):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 处理汇编之后的下一步是检查 `ProvidedParameter` 的实现（一些注释已被移除）：
- en: '[PRE16]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We discussed the parameter first because the parameter resolution has to be
    defined carefully, since the parameter is a part of the method and constructor.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论参数，因为参数解析必须仔细定义，因为参数是方法和构造函数的一部分。
- en: Implementing generated constructor
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现生成的构造函数
- en: To have constructor support for our type provider, we must handle the construction
    of the reflection type of `ConstructorInfo`. This handling is done by `ProvidedConstructor`,
    which is a wrapper for `ConstructorInfo` and also extends `ConstructorInfo`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的类型提供者支持构造函数，我们必须处理 `ConstructorInfo` 的反射类型构造。这种处理是通过 `ProvidedConstructor`
    实现的，它是 `ConstructorInfo` 的包装器，同时也扩展了 `ConstructorInfo`。
- en: The following code is the implementation of `ProvidedConstructor:`
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `ProvidedConstructor` 的实现：
- en: '[PRE17]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementing generated methods
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现生成的属性
- en: 'Now, we can use the same constructor handling technique to implement the handling
    of a method implemented as `ProvidedMethod`. The following code is the signature
    of `ProvidedMethod` implementation:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用相同的构造函数处理技术来实现作为 `ProvidedMethod` 实现的方法的处理。以下代码是 `ProvidedMethod` 实现的签名：
- en: '[PRE18]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implementing generated properties
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现生成的构造函数
- en: One of the natures of a type/class is the availability of properties (or attributes
    in the realm of OOP). Therefore, we need to handle the generation of properties
    as well, and the handling of properties is implemented in the `ProvidedProperty`
    class. This class extends `PropertyInfo`, and it also has additional functionalities
    that are quite similar to `ProvidedMethod`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 类型/类的性质之一是属性的可用性（或在面向对象领域中的属性）。因此，我们需要处理属性的生成，属性的处理是在 `ProvidedProperty` 类中实现的。这个类扩展了
    `PropertyInfo`，并且它还具有与 `ProvidedMethod` 非常相似的功能。
- en: 'The following code is the implementation of `ProvidedProperty`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是 `ProvidedProperty` 的实现：
- en: '[PRE19]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the implementation of `ProvidedProperty`, we must handle all the characteristic
    traits and semantics of a property:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ProvidedProperty` 的实现中，我们必须处理属性的所有特征特性和语义：
- en: Property setter.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性设置器。
- en: Property getter.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性获取器。
- en: 'Definition location of the property: This is very important, because the definition
    location of the property has the information of the type the property belongs
    to.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的定义位置：这一点非常重要，因为属性的定义位置包含了属性所属类型的详细信息。
- en: 'The visibility of a property and its setter and getter methods are handled
    further in the following override methods of `ProvidedProperty` in the `ProvidedTypes.fs`
    file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 属性及其设置器和获取器方法的可见性在 `ProvidedTypes.fs` 文件中的以下重写方法中进一步处理：
- en: '[PRE20]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The methods, `hasGetter()` and `hasSetter()`, actually act as mini helper functions.
    These functions are implemented to check for the availability of the getter and
    setter in the property.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 `hasGetter()` 和 `hasSetter()` 实际上充当着迷你辅助函数。这些函数的实现是为了检查属性中 getter 和 setter
    的可用性。
- en: Again, the `ProvidedTypes.fsi` signature file is important, because it will
    give more meaningful information later when we are designing class libraries for
    others to use.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`ProvidedTypes.fsi` 签名文件非常重要，因为它在我们为他人设计类库时，将提供更有意义的信息。
- en: 'For more information about this FSI''s signature file, visit:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关此 FSI 签名文件的更多信息，请访问：
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/signatures](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/signatures)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/signatures](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/signatures)'
- en: We shall describe the significance of F# FSI more in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimization*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](fsp-hiperf_cu07.html#aid-1ENBI1 "第7章。语言特性和构造优化")中更详细地描述 F# FSI 的意义，*语言特性和构造优化*。
- en: Now, let's look at the implementation of the method provider, `ProvidedMethod`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看方法提供者 `ProvidedMethod` 的实现。
- en: 'Basically, the `ProvidedMethod` class extends the `MethodInfo` class. Therefore,
    all of the operations and properties of `MethodInfo` are also available in `ProviderMethod`.
    The additional functionalities of `ProviderMethod` are implemented with the following
    design considerations:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`ProvidedMethod` 类扩展了 `MethodInfo` 类。因此，`MethodInfo` 的所有操作和属性在 `ProviderMethod`
    中也都是可用的。`ProviderMethod` 的附加功能是通过以下设计考虑实现的：
- en: 'Handling of XML comment documentation of the method: This is implemented in
    the `AddXmlDoc`, `AddXmlDocDelayed`, and `AddXmlDocComputed` methods.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理方法的 XML 注释文档：这是在 `AddXmlDoc`、`AddXmlDocDelayed` 和 `AddXmlDocComputed` 方法中实现的。
- en: 'Handling of special method attribute, the `ObsoleteAttribute`: This is not
    just a very useful feature, but it is also a necessary feature to warn the consumer
    of the method that the method should not be used anymore. This obsolete method
    handling is implemented in `AddObsoleteAttribute`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊方法属性的处理，`ObsoleteAttribute`：这不仅是一个非常实用的功能，而且是一个必要的功能，用于警告方法的消费者该方法不应再使用。这种废弃方法处理是在`AddObsoleteAttribute`中实现的。
- en: 'Handling the detection of `static` modifier on the method declaration: This
    is quite important, because the generation of a static method is different from
    a normal method and the handling should be explicit. The static detection is implemented
    in `IsStaticMethod`.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理方法声明上的`static`修饰符检测：这非常重要，因为静态方法的生成与普通方法不同，处理应该是明确的。静态检测是在`IsStaticMethod`中实现的。
- en: If we look back at the implementation of `ProvidedProperty` and `ProvidedConstructor`,
    the previous design considerations are also applied to `ProvidedProperty` and
    `ProvidedConstructor`, including the handling of the static modifier of a constructor,
    although F# does not support static constructors as part of F# language constructs
    specification directly.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾`ProvidedProperty`和`ProvidedConstructor`的实现，前面的设计考虑也适用于`ProvidedProperty`和`ProvidedConstructor`，包括构造函数的静态修饰符的处理，尽管F#不支持直接作为F#语言结构规范一部分的静态构造函数。
- en: '`ObsoleteAttribute` can also be tuned further to enforce compile errors when
    the method is used. This attribute is useful and also strongly recommended to
    mark a feature that should not be used anymore, especially if the method has bugs.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObsoleteAttribute`还可以进一步调整，以在方法使用时强制编译错误。这个属性很有用，并且强烈建议标记不应再使用的功能，特别是如果该方法有错误。'
- en: For more information on the detailed usage of `ObsoleteAttribute`, visit MSDN
    Library at [https://msdn.microsoft.com/en-us/library/system.obsoleteattribute(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.obsoleteattribute(v=vs.110).aspx).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ObsoleteAttribute`的详细用法信息，请访问MSDN库中的[https://msdn.microsoft.com/en-us/library/system.obsoleteattribute(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.obsoleteattribute(v=vs.110).aspx)。
- en: We are not going to dig deeper into the full implementation of this `ProviderMethod`
    type. We can add optimization to some methods. For example, we can optimize the
    `GetInvokeCodeInternal` method, a part of `ProviderMethod` methods operations.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨`ProviderMethod`类型的完整实现。我们可以对某些方法进行优化。例如，我们可以优化`GetInvokeCodeInternal`方法，这是`ProviderMethod`方法操作的一部分。
- en: 'The following is the original implementation of `GetInvokeCodeInternal`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`GetInvokeCodeInternal`的原始实现：
- en: '[PRE21]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can further optimize the preceding code of `GetInvokeCodeInternal` to use
    PLINQ instead of non-parallel mapping of F#'s `List.map`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步优化`GetInvokeCodeInternal`的前置代码，以使用PLINQ而不是F#的`List.map`的非并行映射。
- en: 'To use PLINQ in our code, we must add a reference to `System.Linq` to tell
    the F# compiler to recognize classes within `System.Linq` namespace. We can insert
    the import of `System.Linq` namespace in the beginning of the open namespace declaration,
    so the namespace declarations in `ProvidedTypes.fs` file become like the following
    code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的代码中使用PLINQ，我们必须添加对`System.Linq`的引用，以便告诉F#编译器识别`System.Linq`命名空间内的类。我们可以在公开命名空间声明的开头插入`System.Linq`命名空间的导入，因此`ProvidedTypes.fs`文件中的命名空间声明将类似于以下代码：
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now use parallel support in PLINQ at our disposal. To optimize the mapping
    using PLINQ, change the method body code of `GetInvokeCodeInternal` to the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用PLINQ提供的并行支持。为了优化使用PLINQ的映射，将`GetInvokeCodeInternal`的方法体代码更改为以下内容：
- en: '[PRE23]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have optimized the method provider to use PLINQ, to make the mapping of parameter
    to parameter name run faster because we do not care for the order of the parameter
    names. The call of `AsParallel` is actually an extension method. This extension
    method belongs to the `ParallelQuery` class.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经优化了方法提供者以使用PLINQ，使参数到参数名称的映射运行更快，因为我们不关心参数名称的顺序。`AsParallel`的调用实际上是一个扩展方法。这个扩展方法属于`ParallelQuery`类。
- en: The conversion of parameters (as F# list) into a sequence will add a small overhead
    but this overhead is highly compensated when we change the original map of `List.map`
    to use the PLINQ `Select` query because the `Select` method has the same semantic
    as the map in `List` and now the mapping is executed in parallel.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数（作为F#列表）转换为序列将增加一点开销，但当我们将原始的`List.map`映射更改为使用PLINQ的`Select`查询时，这种开销得到了高度补偿，因为`Select`方法与`List`中的映射具有相同的语义，现在映射是并行执行的。
- en: 'For more information about the `ParallelQuery` class, visit: [https://msdn.microsoft.com/en-us/library/system.linq.parallelquery(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.linq.parallelquery(v=vs.110).aspx).'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ParallelQuery`类的更多信息，请访问：[https://msdn.microsoft.com/en-us/library/system.linq.parallelquery(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.linq.parallelquery(v=vs.110).aspx)。
- en: 'For the generic parameterized version of `ParallelQuery`, visit:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`ParallelQuery`的泛型参数化版本，请访问：
- en: '[https://msdn.microsoft.com/en-us/library/dd383736(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd383736(v=vs.110).aspx)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/dd383736(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd383736(v=vs.110).aspx)'
- en: Although the generic type is not specified, the `ParallelQuery` class we used
    when calling the preceding `AsParallel` is inferred as calling a generic version
    of `ParallelQuery.AsParallel`. The type inference plays heavy lifting of the necessary
    flow of type information here.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有指定泛型类型，但我们调用前面的`AsParallel`时使用的`ParallelQuery`类被推断为调用`ParallelQuery.AsParallel`的泛型版本。类型推断在这里承担了必要的类型信息流的繁重工作。
- en: It is highly recommended to always start from having the implementation of infrastructure
    of the type provider first, starting from preparing the assembly, parameters,
    methods, constructors, and properties, including other CLR type metadata information,
    such as adding supports for attributes and debug symbols.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议始终从实现类型提供程序的基础设施开始，从准备程序集、参数、方法、构造函数和属性开始，包括其他CLR类型元数据信息，例如添加对属性和调试符号的支持。
- en: The heavy lifting for reflection should be done carefully. In the next section,
    we can start implementing the basic custom type provider with minimum metadata
    supports.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的繁重工作应该谨慎进行。在下一节中，我们可以开始实现具有最小元数据支持的简单自定义类型提供程序。
- en: Basic minimal implementation of type provider
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型提供程序的基本最小实现
- en: Now, let's create a very simple type provider after we have done implementing
    all the necessary infrastructure of type metadata supports.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们完成所有必要的类型元数据支持的基础设施实现之后，让我们创建一个非常简单的类型提供程序。
- en: The easiest one is to create an erased type provider as a fundamental sample.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个擦除类型提供程序作为基本示例。
- en: 'Let''s create this sample named `BasicProvider`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`BasicProvider`的示例：
- en: '[PRE24]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's dive deeper into `BasicProvider`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解`BasicProvider`。
- en: 'The following are the traits and reflection metadata of `BasicProvider`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`BasicProvider`的特性以及反射元数据：
- en: '`BasicProvider` type declaration has `TypeProviderAttribute` mark, as identified
    by using the abbreviated name of just `TypeProvider`.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasicProvider`类型声明带有`TypeProviderAttribute`标记，这是通过使用仅`TypeProvider`的缩写名称来识别的。'
- en: '`BasicProvider` inherits from `TypeProviderNamespaces`. This class is available
    in the starter pack''s helper of `ProvidedType.fs` file.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BasicProvider`类继承自`TypeProviderNamespaces`。这个类在启动包的`ProvidedType.fs`文件的帮助程序中可用。'
- en: The provided type has one property called `MyProperty` typed as `String`, and
    it has a static modifier. This means that this is a static property. We can also
    set this property to not static by setting `IsStatic` to `false`.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的类型有一个名为`MyProperty`的属性，其类型为`String`，并且具有静态修饰符。这意味着这是一个静态属性。我们也可以通过将`IsStatic`设置为`false`来将此属性设置为非静态。
- en: The attribute's assembly scope declaration of `TypeProviderAssembly` means that
    this type's assembly is a part of `TypeProviderAssembly` and so is the project.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeProviderAssembly`的属性集作用域声明意味着这个类型的程序集是`TypeProviderAssembly`的一部分，因此项目也是如此。'
- en: All these traits are matched with the requirements of the type provider implementation
    that we described in the previous section, *Minimum requirements of type providers*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性都与我们在上一节中描述的类型提供程序实现的要求相匹配，即类型提供程序的最小要求。
- en: We have implemented a very simple custom type provider. It is quite simple in
    the sense that it has a basic support for namespace, assembly, public properties,
    and public methods.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了一个非常简单的自定义类型提供程序。从本质上讲，它对命名空间、程序集、公共属性和公共方法有基本的支持。
- en: Common pitfalls in implementing type provider
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现类型提供程序时常见的陷阱
- en: We now have enough knowledge of type provider, not just the concept of using
    a sample type provider and implementing a custom type provider but also that there
    might be pitfalls as well. In this section, the common pitfalls in type providers
    are wrapped as a simplified list with a simple explanation as well.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对类型提供程序有了足够的了解，不仅包括使用示例类型提供程序和实现自定义类型提供程序的概念，还包括可能存在的陷阱。在本节中，类型提供程序中的常见陷阱被简化为带有简单解释的列表。
- en: 'Common pitfalls in implementing type providers are quite subtle but these are
    important:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类型提供器时的常见陷阱相当微妙，但这些都是重要的：
- en: Type provider strategy has to be planned first. The planning must also include
    the infrastructure to ease the metadata generation, whether it employs erased
    or generative strategy. *Do not* always assume that we can always provide generative
    type providers instantly. Failing to provide type resolution with the namespace
    will yield undesirable results, including erased type metadata.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提供器策略必须首先规划。规划还应包括基础设施，以简化元数据生成，无论它采用擦除或生成策略。*不要* 总是假设我们总能立即提供生成类型提供器。未能使用命名空间提供类型解析将导致不理想的结果，包括擦除类型元数据。
- en: Reflection should use lazy implementation instead of an eager one. This lazy
    evaluation should not be combined with asynchronous reflection because cross-thread
    exception will occur and it can also lead to a deadlock as there is no guarantee
    that the reflection will return a CLR type that is fully CLS-compliant, from the
    type to the members (properties and methods).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射应使用懒实现而不是急实现。这种懒评估不应与异步反射结合，因为可能会发生跨线程异常，并且也可能导致死锁，因为没有保证反射将返回一个完全 CLS 兼容的
    CLR 类型，从类型到成员（属性和方法）。
- en: The use of any kind of TPL or PLINQ is encouraged when we are processing to
    give results as properties and members for each type provided, especially if we
    have to map a type to other types, such as the names of the properties.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要为每个提供的类型提供属性和成员作为结果时，鼓励使用任何类型的 TPL 或 PLINQ，特别是如果我们必须将类型映射到其他类型，例如属性的名称。
- en: The implementation of type provider is not recommended for non CLI-compliant
    type, such as COM+ related types or types that are generated via `TLBIMP` of .NET
    SDK. An exception of cross-thread or even invalid object reference might occur,
    although the type generated may not be null.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议对非 CLI 兼容类型实现类型提供器，例如与 COM+ 相关的类型或通过 .NET SDK 的 `TLBIMP` 生成的类型。尽管生成的类型可能不为空，但可能会出现跨线程异常或甚至无效对象引用。
- en: '*Do not* use TPL/PLINQ when we are processing delegates. It might yield a memory
    leak because the delegate resolution is best handled as synchronous. This is quite
    subtle but important because there is no guarantee that the delegate is either
    unicast (normal delegate) or multicast.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不要* 在处理委托时使用 TPL/PLINQ。因为这可能会导致内存泄漏，因为委托解析最好以同步方式处理。这一点相当微妙但很重要，因为没有保证委托是单播（普通委托）还是多播。'
- en: We should avoid F# units of measure implementation when a type with unit of
    measure is used as a type of the properties and parameters of the generated methods.
    Because in F#, any type that has *unit of measure is always erased at runtime*.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用具有度量单位的类型作为生成方法的属性和参数的类型时，应避免 F# 单位度量实现。因为在 F# 中，任何具有 *度量单位* 的类型在运行时总是被擦除。
- en: The last point about the use of unit of measurement is quite subtle because
    many F# developers tend to forget that the F# unit of measurement is an erased
    generic type.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用单位度量的最后一点相当微妙，因为许多 F# 开发者往往会忘记 F# 单位度量是一个擦除的泛型类型。
- en: Summary
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have the knowledge of type providers and insights of the internal working,
    while at the same time optimizing and avoiding the pitfalls of type provider implementations.
    We now have enough knowledge of the strategy behind choosing the erased and generative
    type providers at our disposal. It is quite important that we can optimize all
    of the internal language constructs, and not just know the functional programming
    style.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对类型提供器有了解，对内部工作原理有洞察，同时优化并避免类型提供器实现的陷阱。我们现在已经掌握了选择擦除和生成类型提供器背后的策略。我们能够优化所有内部语言结构，而不仅仅是了解函数式编程风格，这一点非常重要。
- en: This is why we will now visit the optimization of the language syntaxes and
    semantics in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们现在将访问 [第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化") 语言特性和结构优化中的语言语法和语义优化。
