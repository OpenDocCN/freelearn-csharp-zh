- en: Vertex Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term shader originates from the fact that Cg has been used mainly to simulate
    realistic lighting conditions (shadows) on 3D models. Despite this, shaders are
    now much more than that. They not only define the way the objects are going to
    look, they can also redefine their shapes entirely. If you want to learn how to
    manipulate the geometry of a 3D object via shaders, this is the chapter for you.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a vertex color in a Surface Shader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating vertices in a Surface Shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extruding your models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a snow shader
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a volumetric explosion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0046.html#1BRPS0-e8c76c858d514bc3b1668fda96f8fa08), *Creating
    Your First Shader*, we explained that 3D models are not just a collection of triangles.
    Each vertex can contain data that is essential to render the model itself correctly.
    This chapter will explore how to access this information in order to use it in
    a shader. We will also explore in detail how the geometry of an object can be
    deformed simply using Cg code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a vertex color in a Surface Shader
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin this chapter by taking a look at how we can access the information
    of a model's vertex using the vertex function in a Surface Shader. This will arm
    us with the knowledge to start utilizing the elements contained within a model's vertex in
    order to create really useful and visually appealing effects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: A vertex in a vertex function can return information about itself that we need
    to be aware of. You can actually retrieve the vertices' normal directions as a
    float3 value and the position of the vertex as float3, and you can even store
    color values in each vertex and return that color as float4\. This is what we
    will take a look at in this recipe. We need to see how to store color information
    and retrieve this stored color information inside each vertex of a Surface Shader.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write this shader, we need to prepare a few assets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: In order to view the colors of a vertex, we need to have a model that has had
    color applied to its vertices. While you could use Unity to apply colors, you
    would have to write a tool to allow an individual to apply the colors or write
    some scripts to achieve the color application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In the case of this recipe, you can use a 3D modeling tool such as Maya or Blender to
    apply the colors to our model. There is a model available in the example code
    provided with the book in the `Chapter 06 `| `Models` folder (`VertexColorObject.fbx`)
    that you can obtain at the book's *Support* page at [https://www.packtpub.com/books/content/support](https://www.packtpub.com/books/content/support).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will set us up to create this Vertex Shader:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and place the imported model (`VertexColorObject`) in the
    scene.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Shader (`SimpleVertexColor`) and Material (`SimpleVertexColorMat`).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When completed, assign the shader to the material and then the material to the
    imported model.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your scene should now look similar to the following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our scene, shader, and material created and ready to go, we can begin
    to write the code for our shader. Launch the shader by double-clicking on it in
    the Project tab in the Unity editor. Perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are creating a very simple shader, we will not need to include any properties
    in our `Properties` block. We will still include a `Global Color Tint`, just to
    stay consistent with the other shaders in this book. Enter the following code
    in the `Properties` block of your shader:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This next step tells Unity that we will be including a vertex function in our
    shader:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As usual, if we have included properties in our `Properties` block, we must
    make sure to create a corresponding variable in our `CGPROGRAM` statement. Enter
    the following code just below the `#pragma` statement:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now turn our attention to the `Input struct`. We need to add a new variable
    in order for our `surf()` function to access the data given to us by our `vert()`
    function:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can write our simple `vert()` function to gain access to the colors
    stored in each vertex of our mesh:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can use the vertex color data from our `Input struct` to be assigned
    to the `o.Albedo` parameters in the built-in `SurfaceOutput` struct:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With our code completed, we can now re-enter the Unity editor and let the shader
    compile. If all goes well, you should see something similar to the following screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity provides us with a way to access the vertex information of the model to
    which a shader is attached. This gives us the power to modify things such as the
    vertices' position and color. With this recipe, we have imported a mesh from Maya
    (though just about any 3D software application can be used), where vertex colors
    were added to `Verts`. You'll notice that by importing the model, the default
    material will not display the vertex colors. We actually have to write a shader
    to extract the vertex color and display it on the surface of the model. Unity
    provides us with a lot of built-in functionality when using Surface Shaders, which
    makes the process of extracting this vertex information quick and efficient.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to tell Unity that we will be using a vertex function when
    creating our shader. We do this by adding the `vertex:vert` parameter to the `#pragma`
    statement of `CGPROGRAM`. This automatically makes Unity look for a vertex function
    named `vert()` when it goes to compile the shader. If it doesn't find one, Unity
    will throw a compiling error and ask you to add a `vert()` function to your shader.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to our next step. We have to actually code the `vert()` function,
    as seen in *step 5*. We first use a built-in macro to make sure that the `0` variable
    is initialized to 0 if it doesn't have anything that is a requirement if you are
    targeting DirectX 11 or above.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the macro, as well as all of the other macros that ShaderLab
    has to offer, check out: [https://docs.unity3d.com/Manual/SL-BuiltinMacros.html](https://docs.unity3d.com/Manual/SL-BuiltinMacros.html).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: By having this function, we can access the built-in data struct called `appdata_full`.
    This built-in struct is where the vertex information is stored. So, we then extract
    the vertex color information by passing it to our `Input struct` by adding the
    code, `o.vertColor = v.color`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The `o` variable represents our `Input struct` and the v variable is our `appdata_full
    vertex` data. In this case, we are simply taking the color information from the
    `appdata_full` struct and putting it in our `Input struct`. Once the vertex color
    is in our Input struct, we can use it in our `surf()` function. In the case of
    this recipe, we simply apply the color to the o.Albedo parameter to the built-in
    `SurfaceOutput` struct.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also access the fourth component from the `vert` color data. If you
    notice, the `vertColor` variable we declared in the `Input struct` is of the `float4`
    type. This means that we are also passing the alpha value of the vertex colors.
    Knowing this, you can use it to your advantage for the purpose of storing a fourth
    vertex color to perform effects such as transparency or giving yourself one more
    mask to blend two textures. It's really up to you and your production to determine
    if you really need to use the fourth component, but it is worth mentioning here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Animating vertices in a Surface Shader
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to access data on a per-vertex basis, let's expand our
    knowledge set to include other types of data and the position of a vertex.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Using a vertex function, we can access the position of each vertex in a mesh.
    This allows us to actually modify each individual vertex while the shader does
    the processing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a shader that will allow us to modify the positions
    of each vertex on a mesh with a sine wave. This technique can be used to create
    animations for objects such as flags or waves on an ocean.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s gather our assets together so that we can create the code for our Vertex
    Shader:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and place a plane mesh in the center of the scene (GameObject | 3D
    Objects | Plane).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Plane` object created may seem to be a single quad but, in fact, has 121
    verts, which we are going to be moving. Using a quad would provide unexpected
    results. To check for yourself, select the `Plane` object and, under the Plane
    (Mesh Filter) component, double-click on the Mesh property.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader (`VertexAnimation`) and material (`VertexAnimationMat`).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, assign the shader to the material and the material to the plane mesh.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将着色器分配给材质，并将材质分配给平面网格。
- en: 'Your scene should look similar to the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景应该看起来类似于以下截图：
- en: '![](img/00139.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00139.jpeg)'
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'With our scene ready to go, let''s double-click on our newly created shader
    to open it in the code editor:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景准备就绪后，让我们双击我们新创建的着色器，在代码编辑器中打开它：
- en: 'Let''s begin with our shader and populate the `Properties` block:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从着色器开始，并填充`Properties`块：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We now need to tell Unity that we are going to be using a vertex function by
    adding the following to the `#pragma` statement:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要告诉Unity我们将要使用顶点函数，通过在`#pragma`语句中添加以下内容来实现：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to access the values that have been given to us by our properties,
    we need to declare a corresponding variable in our `CGPROGRAM` block:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了访问我们属性给出的值，我们需要在`CGPROGRAM`块中声明一个相应的变量：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be using the vertex position modification as a `vert` color as well.
    This will allow us to tint our object:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用顶点位置修改作为`vert`颜色，这将允许我们为对象上色：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, we can perform our vertex modification using a sine wave and
    vertex function. Enter the following code after the `Input struct`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用正弦波和顶点函数来执行顶点修改。在`Input struct`之后输入以下代码：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we complete our shader by performing a `lerp()` function between two
    colors so that we can tint the peaks and valleys of our new mesh, modified by
    our vertex function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过在两个颜色之间执行一个`lerp()`函数来完成我们的着色器，这样我们就可以为经过顶点函数修改后的新网格的峰值和谷值上色：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After completing the code for your shader, switch back to Unity and let the
    shader compile. Once compiled, select the Material and assign the Base (RGB) Texture
    to the `UV Checker` material that is included in `Chapter 6 `| `Textures` folder
    of this book's example code.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成你的着色器代码后，切换回Unity并让着色器编译。一旦编译完成，选择材质并将基础（RGB）纹理分配给包含在本书示例代码`第6章`|`纹理`文件夹中的`UV
    Checker`材质。
- en: 'From there, assign Color A and Color B to different colors. After the changes, you
    should see something similar to the following screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，将颜色A和颜色B分配给不同的颜色。更改后，你应该看到以下截图类似的内容：
- en: '![](img/00140.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This particular shader uses the same concept from the last recipe, except that
    this time, we are modifying the positions of the vertices in the mesh. This is
    really useful if you don't want to rig up simple objects, such as a flag, and
    then animate them using a skeleton structure or hierarchy of transforms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的着色器使用了上一个配方中的相同概念，但这次我们正在修改网格中顶点的位置。如果你不想为简单的对象，如旗帜，设置骨架并使用骨架结构或变换层次结构来动画它们，这将非常有用。
- en: We simply create a sine wave value using the `sin()` function that is built
    into the Cg language. After calculating this value, we add it to the *y* value
    of each vertex position, creating a wave-like effect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地使用Cg语言内置的`sin()`函数创建一个正弦波值。计算这个值后，我们将其添加到每个顶点位置的*y*值，从而创建出波浪状的效果。
- en: We also modified the normal on the mesh just to give it more realistic shading
    based on the sine wave value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了网格上的法线，以便根据正弦波值提供更逼真的着色。
- en: You will see how easy it is to perform more complex vertex effects by utilizing
    the built-in vertex parameters that Surface Shaders give us.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到通过利用表面着色器给我们提供的内置顶点参数，执行更复杂的顶点效果是多么容易。
- en: Extruding your models
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挤出你的模型
- en: 'One of the biggest problems in games is repetition. Creating new content is
    a time-consuming task, and when you have to face thousands of enemies, chances
    are that they will all look the same. A relatively cheap technique to add variation
    to your models is using a shader that alters its basic geometry. This recipe will
    show you a technique called **normal extrusion**, which can be used to create
    a chubbier or skinnier version of a model, as shown in the following screenshot
    of a soldier from the Unity camp demo:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中最大的问题之一是重复。创建新内容是一项耗时的工作，当你必须面对成千上万的敌人时，他们很可能看起来都一样。为了给你的模型添加变化，使用一个改变其基本几何形状的着色器是一种相对便宜的技术。这个配方将向你展示一种称为**法线挤出**的技术，它可以用来创建一个更胖或更瘦的模型版本，如以下Unity
    camp演示中的士兵截图所示：
- en: '![](img/00141.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: For ease of use, I have provided a prefab of the solider in the example code
    for this book under the `Chapter 6 `| `Prefabs` folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我在本书的示例代码中提供了士兵的预制件，位于`第6章`|`预制件`文件夹下。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, you need to have access to the shader used by the model that
    you want to alter. Once you have it, we duplicate it so that we can edit it safely.
    It can be done as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Find the shader your model is using and, once selected, duplicate it by pressing
    *Ctrl *+ *D*. If it is just using the Standard Shader, as in this example, it
    is also possible to just create a new Standard Material such as normal, and the
    Albedo map will automatically transfer over. Either way, rename this new shader `NormalExtrusion`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the original material of the model and assign the cloned shader to
    it.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the new material to your model (`NormalExtrusionMat`) and start editing
    it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order for this effect to work, your model should have **normals**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create this effect, start by modifying the duplicated shader:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding a property to our shader, which will be used to modulate
    its extrusion. The range presented here goes from `-0.0001` to `0.0001`, but you
    might have to adjust this according to your own needs:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Couple the property with its respective variable:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Change the `#pragma` directive so that it now uses a vertex modifier. You can
    do this by adding `vertex:function_name` at the end of it. In our case, we have
    called the `vert:` function:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following vertex modifier:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The shader is now ready; you can use the Extrusion Amount slider in the material''s
    Inspector tab to make your model skinnier or chubbier. Also, feel free to create
    a clone of the material in order to have different extrusion amounts for each
    character:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00142.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Surface Shaders work in two steps. In all the previous chapters, we only explored
    its last one: the surface function. There is another function that can be used:
    the vertex modifier. It takes the data structure of a vertex (which is usually
    called `appdata_full`) and applies a transformation to it. This gives us the freedom
    to do virtually anything with the geometry of our model. We signal to the GPU that
    such a function exists by adding `vertex:vert` to the `#pragma` directive of the
    Surface Shader. You can refer to [Chapter 7](part0188.html#5J99O0-e8c76c858d514bc3b1668fda96f8fa08),
    *Fragment Shaders and Grab Passes*, to learn how vertex modifiers can be defined
    in a Vertex and Fragment Shader instead.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most simple yet effective techniques that can be used to alter the
    geometry of a model is called normal extrusion. It works by projecting a vertex
    along its normal direction. This is done by the following line of code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The position of a vertex is displaced by `_Amount` units toward the vertex normal.
    If `_Amount` gets too high, the results can be quite unpleasant. With smaller
    values, however, you can add a lot of variation to your models.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have multiple enemies and want each one to have its own weight, you
    have to create a different material for each one of them. This is necessary as
    materials are normally shared between models and changing one will change all
    of them. There are several ways in which you can do this; the quickest one is
    to create a script that automatically does it for you. The following script, once
    attached to an object with a `Renderer`, will duplicate its first material and
    set the `_Amount` property automatically:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多名敌人，并且希望每个敌人都有自己的权重，你必须为它们中的每一个创建不同的材质。这是必要的，因为材质通常在模型之间共享，更改一个会改变所有模型。你可以通过几种方式来完成这项工作；最快的方法是创建一个脚本，它会自动为你完成这项工作。以下脚本一旦附加到具有
    `Renderer` 的对象上，就会自动复制其第一个材质并设置 `_Amount` 属性：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding extrusion maps
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加挤出图
- en: 'This technique can actually be improved even further. We can add an extra texture
    (or use the alpha channel of the main one) to indicate the amount of extrusion.
    This allows for much better control over which parts are raised or lowered. The
    following code shows you how it is possible to achieve such an effect (the main
    difference from what we''ve done before is in bold):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种技术还可以进一步改进。我们可以添加一个额外的纹理（或使用主纹理的 alpha 通道）来指示挤出量。这允许对哪些部分被抬起或降低有更好的控制。以下代码展示了如何实现这种效果（与之前所做的主要区别用粗体表示）：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The red channel of `_ExtrusionTex` is used as a multiplying coefficient for
    normal extrusion. A value of `0.5` leaves the model unaffected; darker or lighter
    shades are used to extrude vertices inward or outward, respectively. You should
    note that in order to sample a texture within a vertex modifier, `tex2Dlod` should
    be used instead of `tex2D`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ExtrusionTex` 的红色通道被用作正常挤出时的乘法系数。值为 `0.5` 会使模型不受影响；较暗或较亮的色调分别用于向内或向外挤出顶点。你应该注意，为了在顶点修改器内采样纹理，应使用
    `tex2Dlod` 而不是 `tex2D`。'
- en: In shaders, color channels go from zero to one, although sometimes you need
    to represent negative values as well (such as inward extrusion). When this is
    the case, treat `0.5` as zero; consider having smaller values as negative and
    higher values as positive. This is exactly what happens with normals, which are
    usually encoded in RGB textures. The `UnpackNormal()` function is used to map
    a value in the range (0,1) on the range (-1,+1). Mathematically speaking, this
    is equivalent to `tex.r * 2 -1`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中，颜色通道从零到一，尽管有时你需要表示负值（例如向内挤出）。在这种情况下，将 `0.5` 视为零；较小的值视为负值，较大的值视为正值。这与法线的情况完全相同，法线通常编码在
    RGB 纹理中。`UnpackNormal()` 函数用于将范围 (0,1) 的值映射到范围 (-1,+1)。从数学上讲，这相当于 `tex.r * 2 -1`。
- en: 'Extrusion maps are perfect for zombifying characters by shrinking the skin
    to highlight the shape of the bones underneath. The following screenshot shows
    you how a healthy soldier can be transformed into a corpse using just a shader
    and extrusion map. Compared to the previous example, you may notice how the clothing
    is unaffected. The shader used in the following screenshot also darkens the extruded
    regions to give an even more emaciated look to the soldier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 挤出图非常适合通过缩小皮肤来突出显示下面骨骼的形状，将角色僵尸化。以下屏幕截图展示了如何仅使用着色器和挤出图将一个健康的士兵变成尸体。与前面的例子相比，你可能注意到衣服没有受到影响。以下屏幕截图中所使用的着色器还将挤出区域变暗，使士兵看起来更加消瘦：
- en: '![](img/00143.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00143.jpeg)'
- en: Implementing a snow shader
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现雪着色器
- en: The simulation of snow has always been a challenge in games. The vast majority
    of games simply include snow directly in the model's texture so that their tops
    look white. However, what if one of these objects starts rotating? Snow is not
    just a lick of paint on a surface; it is a proper accumulation of material and
    should be treated as such. This recipe shows you how to give a snowy look to your
    models using just a shader.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，雪的模拟一直是一个挑战。绝大多数游戏只是直接将雪包含在模型的纹理中，使其顶部看起来是白色的。然而，如果这些物体中的任何一个开始旋转呢？雪不仅仅是表面的一层油漆；它是一种真正的材料积累，应该这样处理。这个配方展示了如何仅使用着色器给你的模型添加雪的外观。
- en: 'This effect is achieved in two steps. First, white is used for all the triangles
    facing the sky. Second, their vertices are extruded to simulate the effect of
    snow accumulation. You can see the result in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效果分为两个步骤。首先，使用白色处理所有面向天空的三角形。其次，它们的顶点被挤出以模拟雪积累的效果。你可以在下面的屏幕截图中看到结果：
- en: '![](img/00144.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00144.jpeg)'
- en: Keep in mind that this recipe does not aim to create a photorealistic snow effect.
    It provides a good starting point, but it is up to the artist to create the right
    textures and find the right parameters to make it fit your game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This effect is purely based on shaders. We will need the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader for the snow effect (`SnowShader`).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material for the shader (`SnowMat`).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assign the newly created material to the object that you want to be snowy and
    assign a color so it''s easier to tell where the snow is:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00145.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a snowy effect, open your shader and make the following changes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the properties of the shader with the following ones:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Complete them with their relative variables:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Replace the `Input` structure with the following one:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Replace the surface function with the following one. It will color the snowy
    parts of the model white:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Configure the `#pragma` directive so that it uses vertex modifiers:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following vertex modifiers, which extrude the vertices covered in snow:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can now use the material''s Inspector tab to select how much of your model
    is going to be covered and how thick the snow should be:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00146.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shader works in two steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Coloring the surface
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering the geometry.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coloring the surface
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step alters the color of the triangles that are facing the sky. It
    affects all the triangles with a normal direction similar to `_SnowDirection`.
    As seen before in [Chapter 3](part0107.html#361C60-e8c76c858d514bc3b1668fda96f8fa08),
    *Understanding Lighting Models*, comparing unit vectors can be done using the
    **dot product**. When two vectors are orthogonal, their dot product is zero; it
    is one (or minus one) when they are parallel to each other. The `_Snow` property
    is used to decide how aligned they should be in order to be considered as facing
    the sky.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at the surface function, you can see that we are not dotting
    the normal and snow direction directly. This is because they are usually defined
    in a different space. The snow direction is expressed in world coordinates, while
    the object normals are usually relative to the model itself. If we rotate the
    model, its normals will not change, which is not what we want. To fix this, we
    need to convert the normals from their object coordinates to world coordinates.
    This is done with the `WorldNormalVector()` function, as seen in the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This shader simply colors the model white; a more advanced one should initialize
    the `SurfaceOutputStandard` structure with textures and parameters from a realistic
    snow material.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Altering the geometry
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second effect of this shader alters the geometry to simulate the accumulation
    of snow. Firstly, we identify which triangles have been colored white by testing
    the same condition used in the surface function. This time, unfortunately, we
    cannot rely on `WorldNormalVector()` as the `SurfaceOutputStandard` structure
    is not yet initialized in the vertex modifier. We use this other method instead,
    which converts `_SnowDirection` to object coordinates:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we can extrude the geometry to simulate the accumulation of snow:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, this is a very basic effect. You could use a texture map to control
    the accumulation of snow more precisely or give a peculiar, uneven look.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need high-quality snow effects and props for your game, you can also
    check these resources on the Unity Asset Store:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Winter Suite ($30)**: A much more sophisticated version of the snow shader
    presented in this recipe can be found at [https://www.assetstore.unity3d.com/en/#!/content/13927](https://www.assetstore.unity3d.com/en/#!/content/13927).'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Winter Pack ($60)**: A very realistic set of props and materials for snowy
    environments can be found at [https://www.assetstore.unity3d.com/en/#!/content/13316](https://www.assetstore.unity3d.com/en/#!/content/13316).'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a volumetric explosion
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The art of game development is a clever trade-off between realism and efficiency.
    This is particularly true for explosions; they are at the heart of many games,
    yet the physics behind them is often beyond the computational power of modern
    machines. Explosions are, essentially, nothing more than very hot balls of gas;
    hence, the only way to correctly simulate them is by integrating a fluid simulation
    into your game. As you can imagine, this is unfeasible for a runtime application,
    and many games simulate them simply with particles. When an object explodes, it
    is common to simply instantiate fire, smoke, and debris particles so that, together,
    they can achieve believable results. This approach, unfortunately, is not very
    realistic and is easy to spot. There is an intermediate technique that can be
    used to achieve a much more realistic effect: volumetric explosions. The idea
    behind this concept is that explosions are not treated like a bunch of particles;
    they are evolving 3D objects, not just flat 2D textures.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complete this recipe with the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Create a new shader for this effect (`VolumetricExplosion`).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new material to host the shader (`VolumetricExplosionMat`).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attach the material to a sphere. You can create one directly from the editor,
    navigating to GameObject | 3D Object | Sphere:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00147.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
- en: This recipe works well with the standard Unity Sphere, but if you need big explosions,
    you might need to use a high-poly sphere. In fact, a vertex function can only
    modify the vertices of a mesh. All the other points will be interpolated using
    the positions of the nearby vertices. Fewer vertices means a lower resolution
    for your explosions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, you will also need a ramp texture that has, in a gradient,
    all the colors your explosions will have. You can create a texture like the following
    screenshot using GIMP or Photoshop:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00148.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
- en: You can find this image (`explosionRamp`) in `Chapter 6 `| `Textures` folder
    in the example code provided with this book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the picture, import it to Unity. Then, from its Inspector, make
    sure that Filter Mode is set to Bilinear and the Wrap Mode to Clamp. These two
    settings make sure that the ramp texture is sampled smoothly.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, you will need a noisy texture. You can search on the internet for freely
    available noise textures. The most commonly used ones are generated using Perlin
    noise. I have included an example in `Chapter 6 `| `Textures` folder for your
    use:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00149.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This effect works in two steps: a vertex function to change the geometry, and
    a surface function to give it the right color. The steps are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the current properties and add the following properties to the shader:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add their relative variables so that the Cg code of the shader can actually
    access them:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Change the `Input` structure so that it receives the UV data of the ramp texture:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following vertex function:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following surface function:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We specify the vertex function in the `#pragma` directive, adding the `nolightmap`
    parameter to prevent Unity from adding realistic lighting to our explosion:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last step is selecting the material and, from its Inspector, attaching
    the two textures in the relative slots:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00150.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'This is animated material, meaning that it evolves over time. You can watch
    the material changing in the editor by clicking on Animated Materials from the
    Scene window:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00151.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are reading this recipe, you should already be familiar with how Surface
    Shaders and vertex modifiers work. The main idea behind this effect is to alter
    the geometry of the sphere in a seemingly chaotic way, exactly as it happens in
    a real explosion. The following screenshot shows you what such an explosion will
    look like inside the editor. You can see that the original mesh has been heavily
    deformed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00152.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: The vertex function is a variant of the technique called normal extrusion introduced
    in the *Extruding your models* recipe of this chapter. The difference here is
    that the amount of extrusion is determined both by the time and noise texture.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: When you need a random number in Unity, you can rely on the `Random.Range()`
    function. There is no standard way to get random numbers in a shader, so the easiest
    way is to sample a noise texture.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Unity中需要一个随机数时，你可以依赖`Random.Range()`函数。在着色器中没有获取随机数的标准方式，所以最简单的方法是采样噪声纹理。
- en: 'There is no standard way to do this, so take this as an example only:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准的方式来做到这一点，所以这只是一个例子：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The built-in `_Time[3]` variable is used to get the current time from within
    the shader, and the red channel of the `disp.r` noise texture is used to make
    sure that each vertex moves independently. The `sin()` function makes the vertices
    go up and down, simulating the chaotic behavior of an explosion. Then, the normal
    extrusion takes place:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`_Time[3]`变量用于从着色器内部获取当前时间，`disp.r`噪声纹理的红通道用于确保每个顶点独立移动。`sin()`函数使顶点上下移动，模拟爆炸的混沌行为。然后，进行正常的拉伸：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You should play with these numbers and variables until you find a pattern of
    movement that you are happy with.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该玩转这些数字和变量，直到你找到一个让你满意的运动模式。
- en: The last part of the effect is achieved by the surface function. Here, the noise
    texture is used to sample a random color from the ramp texture. However, there
    are two more aspects that are worth noting. The first one is the introduction
    of `_RampOffset`. Its usage forces the explosion to sample colors from the left
    or right side of the texture. With positive values, the surface of the explosion
    tends to show more grey tones—exactly what happens when it is dissolving. You
    can use `_RampOffset` to determine how much fire or smoke there should be in your
    explosion. The second aspect introduced in the surface function is the usage of
    `clip()`. What `clip()` does is it clips (removes) pixels from the rendering pipeline.
    When invoked with a negative value, the current pixel is not drawn. This effect
    is controlled by `_ClipRange`, which determines which pixels of the volumetric
    explosions are going to be transparent.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 效果的最后部分是通过表面函数实现的。在这里，噪声纹理被用来从渐变纹理中采样一个随机颜色。然而，还有两个方面值得注意。第一个方面是引入了`_RampOffset`。它的使用强制爆炸从纹理的左侧或右侧采样颜色。使用正值时，爆炸的表面倾向于显示更多灰色调——这正是它正在溶解时发生的情况。你可以使用`_RampOffset`来确定你的爆炸中应该有多少火焰或烟雾。表面函数中引入的第二个方面是使用`clip()`。`clip()`的作用是从渲染管线中裁剪（移除）像素。当使用负值调用时，当前像素不会被绘制。这种效果由`_ClipRange`控制，它决定了哪些体积爆炸的像素将是透明的。
- en: By controlling both `_RampOffset` and `_ClipRange`, you have full control and
    can determine how the explosion behaves and dissolves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制`_RampOffset`和`_ClipRange`，你拥有完全的控制权，可以确定爆炸的行为和溶解方式。
- en: There's more…
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The shader presented in this recipe makes a sphere look like an explosion. If
    you really want to use it, you should couple it with some scripts in order to
    get the most out of it. The best thing to do is to create an explosion object
    and make it into a prefab so that you can reuse it every time you need to. You
    can do this by dragging the sphere back into the Project window. Once it is done,
    you can create as many explosions as you want using the `Instantiate()` function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中展示的着色器使球体看起来像爆炸。如果你真的想使用它，你应该结合一些脚本以便充分利用它。最好的做法是创建一个爆炸对象，并将其制作成预制件，这样你每次需要时都可以重用。你可以通过将球体拖回项目窗口来完成此操作。一旦完成，你可以使用`Instantiate()`函数创建任意数量的爆炸。
- en: 'It is worth noticing, however, that all the objects with the same material
    share the same look. If you have multiple explosions at the same time, they should
    not use the same material. When you are instantiating a new explosion, you should
    also duplicate its material. You can do this easily with this piece of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，所有相同材质的物体看起来都一样。如果你同时发生多个爆炸，它们不应该使用相同的材质。当你实例化一个新的爆炸时，你也应该复制其材质。你可以用这段代码轻松做到这一点：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Lastly, if you are going to use this shader in a realistic way, you should attach
    a script to it that changes its size, `_RampOffset`, and `_ClipRange` according
    to the type of explosion that you want to recreate.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你打算以现实的方式使用这个着色器，你应该给它附加一个脚本，根据你想要重现的爆炸类型来改变其大小、`_RampOffset`和`_ClipRange`。
- en: See also
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Much more can be done to make explosions realistic. The approach presented in
    this recipe only creates an empty shell; inside it, the explosion is actually
    empty.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以做更多的事情来使爆炸更逼真。本配方中展示的方法只创建了一个空壳；实际上，爆炸内部是空的。
- en: An easy trick to improve this is to create particles inside it. However, you
    can only go so far with this.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高这一效果的简单技巧是在其中创建粒子。然而，您只能做到这一步。
- en: The short movie, *The Butterfly Effect* ([http://unity3d.com/pages/butterfly](http://unity3d.com/pages/butterfly)),
    created by Unity Technologies in collaboration with Passion Pictures and Nvidia,
    is the perfect example.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity Technologies与Passion Pictures和Nvidia合作制作的短片*蝴蝶效应*([http://unity3d.com/pages/butterfly](http://unity3d.com/pages/butterfly))是完美的例子。
- en: It is based on the same concept of altering the geometry of a sphere, but it
    renders it with a technique called **volume ray casting**.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它基于改变球体几何形状的相同概念，但使用了一种称为**体积光线投射**的技术来呈现。
- en: 'In a nutshell, it renders the geometry as if it''s full. You can see an example
    in the following screenshot:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，它将几何形状呈现得仿佛是实心的。您可以在下面的屏幕截图中看到一个示例：
- en: '![](img/00153.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00153.jpeg)'
- en: If you are looking for high-quality explosions, check out Pyro Technix ([https://www.assetstore.unity3d.com/en/#!/content/16925](https://www.assetstore.unity3d.com/en/#!/content/16925))
    in the Asset Store. It includes volumetric explosions and couples them with realistic
    shockwaves.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在寻找高质量的爆炸效果，请查看Asset Store中的Pyro Technix ([https://www.assetstore.unity3d.com/en/#!/content/16925](https://www.assetstore.unity3d.com/en/#!/content/16925))。它包括体积爆炸，并将它们与逼真的冲击波相结合。
