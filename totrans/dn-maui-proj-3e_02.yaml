- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Our First .NET MAUI App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a to-do list app and, in doing so, explore all
    the bits and pieces of what makes up an app. We will look at creating pages, adding
    content to pages, navigating between pages, and creating a stunning layout. Well,
    *stunning* might be a bit of a stretch, but we will be sure to design the app
    so that you can tweak it to your needs once it is complete!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persisting data locally on a device using the repository pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What MVVM is and why it’s a great fit for .NET MAUI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using .NET MAUI pages (as views) and navigating between them using .NET MAUI
    controls in XAML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using styling in .NET MAUI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this project, you need to have Visual Studio installed on your **Macintosh**
    (**Mac**) or PC, as well as the .NET mobile components. Refer to *Chapter 1*,
    *Introduction to .NET MAUI*, for more details on how to set up your environment.
    This chapter provides screenshots and instructions for Visual Studio on Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be a classic **File** | **New** | **Project** chapter, guiding
    you step by step through the process of creating your first to-do list app. No
    downloads will be required whatsoever, apart from a few NuGet packages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full source for the code in this chapter at [https://github.com/Packt
    Publishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition)
    in the `Chapter02` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone needs a way of keeping track of things. To kick-start our .NET MAUI
    development learning curve, we’ve decided that a to-do list app is the best way
    to get started and to help you keep track of things. A simple, classic win-win
    scenario.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a project and defining a repository to store the items
    of a to-do list. We will render these items in list form and allow the user to
    edit them using a detailed user interface. We will also look at how to store the
    to-do list items locally on a device through **SQLite.NET** so that they don’t
    get lost when we exit the app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The build time for this project is about 2 hours.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET MAUI introduces a new code-sharing paradigm called single project. Previously,
    in Xamarin.Forms, you would have had a separate project for each platform your
    app would be deployed to. In .NET MAUI, all platforms are in a single project
    that is multi-targeted to all the supported platforms. By default, all code is
    considered shared, unless it is in one of the platform-specific subfolders. We
    will explore this further as we progress through this and future chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new project
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to create a new .NET MAUI project. Open Visual Studio 2022
    and select **Create a** **new project**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.1 – Visual Studio 2\uFEFF022](img/Figure_2.1_B19214.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Visual Studio 2022
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open the `maui` and select the **.NET MAUI App** item from the list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.2 – Create a new proje\uFEFFct](img/Figure_2.2_B19214.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Create a new project
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the next page of the wizard by naming your project `DoToo`, then click
    **Next**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.3 – Configure your new proj\uFEFFect](img/Figure_2.3_B19214.jpg)"
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Configure your new project
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Additional information](img/Figure_2.4_B19214.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Additional information
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! We’ve just created our first .NET MAUI app. Let’s take a look
    at what the template wizard generated for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Examining the files
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The selected template has now created a single project called `DoToo` as a
    .NET library that can target iOS, Mac Catalyst (macOS), Android, and Windows platforms.
    You can switch the target platform using the main toolbar in Visual Studio, as
    shown in *Figure 2**.5*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The Debug Target drop-down menu](img/Figure_2.5_B19214.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Debug Target drop-down menu
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The Windows platform is selected by default, but you can easily switch to iOS
    or Android by using the **Debug Target** drop-down menu. In the dropdown under
    the **Framework** sub-menu, you will find all the supported target platforms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The target framework will also change appropriately when you choose a target
    device. If you select an emulator under the **Android Emulators** menu item, then
    the Android target framework will become the current framework, whereas if you
    select an iOS simulator or device from one of the iOS menu items, iOS will be
    the current framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The project should now look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.6 – .NET MAUI project str\uFEFFucture](img/Figure_2.6_B19214.jpg)"
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – .NET MAUI project structure
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: We will highlight a few important files in the project so that we have a basic
    understanding of what they are. First, we will look at the shared code, after
    which we’ll look at the files/code specific to each platform (stored under the
    different platform folders).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Shared code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under `Dependencies`, we will find references to any external dependencies,
    such as each referenced .NET mobile framework. Under each framework, you will
    find the .NET MAUI dependency under the `packages` folder. We will update the
    .NET MAUI package version in the *Updating the .NET MAUI packages* section and
    add more dependencies as we progress through this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MauiProgram.cs` file is the starting point for the application. The initial
    template will generate a `MauiProgram` class that looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The static `MauiProgram` class contains a single `CreateMauiApp` method that
    returns `MauiApp`. This instance is created by using `MauiAppBuilder`, which works
    in much the same way that the ASP.NET builders work; `MauiAppBuilder` uses a `Application`
    instance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: What is a Fluent API?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: A Fluent API allows method chaining wherein each method of the API returns the
    same context. Fluent APIs form a distinct language in themselves by using terms
    specific to the topic of the API. This makes the API easier to grasp and use.
    C#’s **Language Integrated Query** (**LINQ**) is a good example of a Fluent API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods are used to add features and services to the `MauiApp` instance.
    The `UseMauiApp` extension method identifies the subclass of `Microsoft.Maui.Controls.Application`
    to use. By default, this class is defined in the `App.xaml` and `App.xaml.cs`
    files. Another extension method, `ConfigureFonts`, is used by the template to
    register custom font files in use by the application. Yet another example of an
    extension method that can be used is `ConfigureLifecycleEvents`, which is used
    to set up handlers for the cross-platform life cycle events available in .NET
    MAUI. We will discuss `ConfigureLifecycleEvents` more in *Chapter 3*, *Converting
    a Xamarin.Forms App into .**NET MAUI*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The `App.xaml` file is a XAML file that represents the app. This is a good place
    to put application-wide resources, which we will do later. We can also see the
    `App.xaml.cs` file, which contains the startup code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open `App.xaml.cs`, we can see the starting point for our .NET MAUI application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `MainPage` property is assigned to a page, which is particularly important
    as this determines which page is shown first to the user. In this template, this
    is the `DoToo.AppShell()`class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AppShell.xaml` and `AppShell.xaml.cs` files declare the first visible
    UI component in the .NET MAUI app. Shell provides a form of navigation between
    pages. When you open `AppShell.xaml`, it should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ShellContent` element identifies an individual page that is displayed within
    the shell. The `ContentTemplate` attribute is used to locate the class that implements
    the page – in this case, `MainPage` – while `Route` is the unique identifier for
    the page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The last two files are the `MainPage.xaml` file, which contains the first page
    of the application, and the code-behind file, which is called `MainPage.xaml.cs`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will work through each platform’s files. Each platform has a unique
    folder under the `Platforms` folder. Android files are in the `Android` folder,
    iOS files are in the `iOS` folder, Mac Catalyst files are in the `MacCatalyst`
    folder, Tizen files are in the `Tizen` folder, and Windows files are in the `Windows`
    folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Android
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Android-specific platform code lives under the `Platforms/Android` folder
    in the project:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Android-specific files](img/Figure_2.7_B19214.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Android-specific files
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The important files here are `MainActivity.cs` and `MainApplication.cs`. These
    two files contain the entry point for our application when we run the app on an
    Android device. A standard Android app will declare `MainLauncher` property of
    the `Activity` class attribute. `MauiAppCompatActivity` will search for a type
    decorated with `ApplicationAttribute` and instantiate it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This attribute can be found in the `MainApplication` class in `MainApplication.cs`.
    During initialization, `MainApplication` will call the `CreateMauiApp` method,
    which, in turn, calls `MauiProgram.CreateMauiApp`, which we explored earlier in
    this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to understand these files in detail; just remember that they
    are important for initializing our app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: iOS and Mac Catalyst
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The iOS and Mac Catalyst platform files are identical, but each has a folder
    for customizing the platform. Each platform’s files are contained in their respective
    named folder under the `Platform` folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – iOS platform-specific files](img/Figure_2.8_B19214.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – iOS platform-specific files
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`AppDelegate.cs` is the equivalent of the `MainApplication` class in the Android
    platform. It contains a single method called `CreateMauiApp` that has the same
    implementation as Android; it calls the `MauiProgram.CreateMauiApp` method.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The `Program.cs` file is the entry point for an iOS app. It contains the `Main`
    method, which calls `UIApplication.Main`, the launching point for an iOS application,
    and references the `AppDelegate` type to instantiate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by initializing .NET MAUI and then loads the application. After
    that, it returns control to iOS. It must do this within 17 seconds; otherwise,
    the app is terminated by the OS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The `info.plist` file is an iOS-specific file that contains information about
    the app, such as the bundle ID and its provisioning profiles. Visual Studio has
    a graphical editor for the `info.plist` file, but since it is a standard XML file,
    it can be edited in any text editor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: As with the Android app’s startup code, we don’t need to understand what is
    going on here in detail, other than that it’s important for initializing our app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Tizen
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tizen is Samsung’s custom distribution of Android. The `Main.cs` file is the
    launching point and, like the Android platform, the `Program` class has a `CreateMauiApp`
    method. Tizen is not enabled by default. To enable it, follow the instructions
    in the comments in the `DoToo.csproj` file. To develop applications for Tizen,
    you will need to install additional software distributed by Samsung.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last platform we will examine is the **WinUI** app. The file structure
    looks as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Windows-specific files](img/Figure_2.9_B19214.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Windows-specific files
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: It has an `App.xaml` file, which is like the one in the shared code, but specific
    to `App.xaml.cs`. This file is the Windows equivalent of Android’s `MauiApplication`,
    which contains the `CreateMauiApp` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for the platform project files. Next, we will look at how to keep
    .NET MAUI up to date.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Updating the .NET MAUI packages
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note – Windows users
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET MAUI is distributed as part of Visual Studio, it is best to allow
    Visual Studio to update the packages when you update Visual Studio. If you follow
    these steps, you can probably get .NET MAUI into an unusable state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI is distributed as a set of optional `dotnet workload` command. To
    see the currently installed workloads and their versions, you can use the `dotnet
    workload list` command. Visual Studio 2022 has a built-in developer PowerShell
    to execute commands. To access it, press *Ctrl* + *`* on both macOS and Windows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `dotnet workload list` should give you the following output. Note
    that your version numbers may be higher:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To update the packages in the MAUI workload, you can run `dotnet workload update`.
    This is a sample of the result from running that command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see the result, just run the `dotnet workload list` command again:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have a basic understanding of how .NET MAUI projects are structured,
    we can start building our first app!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository and a TodoItem model
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any good architecture always involves abstraction. In this app, we need something
    to store and retrieve the items of our to-do list. Later, these will be stored
    in a SQLite database, but adding a reference to the database directly in the code
    that is responsible for the GUI is generally a bad idea as it tightly couples
    your data storage implementation to the UI layer, making it harder to test your
    UI code independently from the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: So, what we need is something to abstract our database from the GUI. For this
    app, we’ve chosen to use a simple repository pattern. This repository is simply
    a class that sits between the SQLite database and our upcoming `ViewModel` class.
    This is the class that handles the interaction with the view, which, in turn,
    handles the GUI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The repository will expose methods for getting, adding, and updating items,
    as well as events that allow other parts of the app to react to changes in the
    repository. It will be hidden behind an interface so that we can replace the entire
    implementation later without modifying anything but a line of code in the initialization
    of the app. This is made possible by the **Microsoft.Extensions.DependencyInjection**
    NuGet package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Defining a to-do list item
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by creating a `TodoItem` class, which represents a single item
    on the list. This is a simple **Plain Old CLR Object** (**POCO**) class, where
    **CLR** stands for **Common Language Runtime**. In other words, this is a .NET
    class without any dependencies on third-party assemblies. To create the class,
    follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: In the `DoToo` project, create a folder called `Models`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class called `TodoItem.cs` to that folder and enter the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is self-explanatory; it’s a simple POCO class that only contains properties
    and no logic. We have a `Title` property that describes what we want to be done,
    a flag named `Completed` that determines whether the to-do list item is completed,
    a `Due` date for when we expect it to be done, and a unique `Id` property that
    we will need later for the database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository and its interface
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the `TodoItem` class, let’s define an interface that describes
    a repository that will store our to-do list items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In the `DoToo` project, create a folder called `Repositories`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an interface called `ITodoItemRepository.cs` in the `Repositories` folder
    and write the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wait, what? No Delete method?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The eagle-eyed among you might have noticed that we are not defining a `Delete`
    method in this interface. This is something that should be in a real-world app.
    While the app that we are creating in this chapter does not support deleting items,
    we are quite sure that you could add this yourself if you want to!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This interface defines everything we need for our app. It is there to create
    logical insulation between your implementation of a repository and the user of
    that repository. If any other parts of your application want an instance of `ITodoItemRepository`,
    we can pass it an object that implements `ITodoItemRepository`, regardless of
    how it’s implemented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let’s implement `ITodoItemRepository`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `TodoItemRepository.cs` in the `Repositories` folder.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is the bare-bones implementation of the interface, except for the
    `AddOrUpdateAsync(...)` method. This handles a small piece of logic that states
    that if the `Id` value of an item is `0`, it’s a new item. Any item with an `Id`
    value greater than `0` is stored in the database. This is because the database
    assigns a value larger than `0` when we create rows in a table.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: There are also two events defined in the preceding code. They will be used to
    notify subscribers of a list of items that have been updated or added.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Connecting SQLite to persist data
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have an interface, as well as a skeleton to implement that interface.
    The last thing we need to do to finish this section is to connect SQLite in the
    implementation of the repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Adding the SQLite NuGet package
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access SQLite in this project, we need to add a NuGet package called `sqlite-net-pcl`
    to the `DoToo` project. To do this, right-click on the `DoToo` project node of
    the solution and click **Manage** **NuGet Packages...**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Manage NuGet Packages...](img/Figure_2.10_B19214.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Manage NuGet Packages...
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Portable Class Library (PCL)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the NuGet package is suffixed with `-pcl`. This
    is an example of what happens when naming conventions go wrong. This package supports
    .NET Standard 1.0, even though the name says PCL, which was the predecessor of
    .NET Standard.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up the **NuGet Package** **Manager** window:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – NuGet Package Manager](img/Figure_2.11_B19214.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – NuGet Package Manager
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the SQLite NuGet package, follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Click `sqlite-net-pcl` in the search box.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the package by **sQLite-net** and click **Install**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dialog will be displayed showing you all the packages that will be downloaded
    to your system; accept the changes to complete the installation.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Version 1.8.116 of the `sqlite-net-pcl` package references versions of the
    native library that are not fully compatible with .NET 6+ on all platforms. To
    work around this, you need to add additional references to the following packages
    manually with a version of at least 2.1:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '- `SQLitePCLRaw.core`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '- `SQLitePCLRaw.provider.sqlite3`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '- `SQLitePCLRaw.bundle_green`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '- `SQLitePCLRaw.provider.dynamic_cdecl`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: See [https://github.com/praeclarum/sqlite-net/issues/1102](https://github.com/praeclarum/sqlite-net/issues/1102)
    for more details and a potential resolution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, we can add some code to the `TodoItem` class
    to map the C# object to a table and create the connection to the database in the
    repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Updating the TodoItem class
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since SQLite is a relational database, it needs to know some basic information
    about how to create the tables that will store our objects. This is done using
    attributes, which are defined in the SQLite namespace:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Open `Models/TodoItem.cs`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `using SQLite` statement at the start of the file right below the `namespace`
    statement, as shown in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `PrimaryKey` and `AutoIncrement` attributes right before the `Id` property,
    as shown in the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `PrimaryKey` attribute instructs SQLite that the `Id` property is the primary
    key of the table. The `AutoIncrement` attribute makes sure that the value of `Id`
    is increased by 1 for each new `TodoItem` class that is added to the table.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the data object classes properly configured, it is now time to create the
    connection to the database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connection to the SQLite database
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will now add all the code needed to communicate with the database. The first
    thing we need to do is define a connection field that will hold the connection
    to the database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Repositories/TodoItemRepository.cs` file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `using SQLite` statement right below the existing `using` statements,
    as shown in the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following field right below the class declaration:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The connection needs to be initialized. Once it is initialized, it can be reused
    throughout the lifespan of the repository. Since the method is asynchronous, it
    cannot be called from the constructor without introducing a locking strategy.
    To keep things simple, we will simply call it from each of the methods that are
    defined by the interface. To do so, add the following code to the `TodoItemRepository`
    class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The method begins by checking whether we already have a connection. If we do,
    we can simply `return`. If we don’t have a connection set up, we define a path
    on the disk to indicate where we want the database file to be located. In this
    case, we will choose the `MyDocuments` folder. .NET MAUI will find the closest
    match to this on each platform that we target.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the connection and store the reference to that connection in
    the `connection` field. We need to make sure that SQLite has created a table that
    mirrors the schema of the `TodoItem` table. To make developing the app easier,
    we add a default to-do list item if the `TodoItem` table is empty.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll add the implementation for the database operations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the GetItemsAsync(), AddItemsAsync(), and UpdateItemsAsync() methods
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only thing left to do in the repository is to implement the methods for
    getting, adding, and updating items:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `GetItemsAsync()` method in the `TodoItemRepository` class.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `GetItemsAsync()` method with the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To ensure that the connection to the database is valid, we call the `CreateConnectionAsync()`
    method we created in the previous section. When this method returns, we can ensure
    that it is initialized and that the `TodoItem` table has been created.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we use the connection to access the `TodoItem` table and return a `List<TodoItem>`
    item that contains all the to-do list items in the database.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SQLite and LINQ
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports querying data using LINQ. You can play around with this after
    the project is complete to get a better understanding of how to work it with databases
    in your app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for adding items is even simpler:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `AddItemAsync()` method in the `TodoItemRepository` class.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `AddItemAsync()` method with the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The call to `CreateConnectionAsync()` makes sure that we have a connection in
    the same way as we did for the `GetItemsAsync()` method. After this, we insert
    it into the database using the `InsertAsyncAsync(...)` method on the `connection`
    object. After an item has been inserted into the table, we invoke the `OnItemAdded`
    event to notify any subscribers.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code to update an item is the same as the `AddItemAsync()` method but also
    includes calls to `UpdateAsync` and `OnItemUpdated`. Let’s finish up by updating
    the `UpdateItemAsync()` method with the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `UpdateItemAsync()` method in the `TodoItemRepository` class.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `UpdateItemAsync()` method with the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, we’ll get started with MVVM. Grab a cup of coffee and let’s
    get started!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using MVVM – creating views and ViewModels
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Model-View-ViewModel**, or **MVVM** for short, is all about **separation
    of concerns**. It is an architectural pattern that defines three parts, each of
    which has a specific meaning:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: This is the visual component. In .NET MAUI, this is represented by
    a page.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ViewModel**: This is the class that acts as the glue between the model and
    the view.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are introducing MVVM here because the MVVM pattern was designed specifically
    around XAML-based GUIs. This app and the rest of the apps in this book will use
    XAML to define the GUI and we will use the MVVM pattern to separate the code into
    the three aforementioned parts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In this app, we could say that the model is the repository and the to-do list
    items it returns. `ViewModel` refers to this repository and exposes properties
    that the view can bind to. The ground rule is that any logic should reside in
    `ViewModel` and no logic should reside in the view. The view should know how to
    present data, such as converting a Boolean value into `Yes` or `No`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: MVVM can be implemented in many ways and there are quite a few frameworks that
    we can use to do so, such as **Prism**, **MVVMCross**, or even **TinyMvvm**. In
    this chapter, we have chosen to keep things simple and implement MVVM in a vanilla
    way first, and then use portions of the **CommunityToolkit.Mvvm** library. CommunityTookit.Mvvm
    is an open source library produced by the .NET Foundation. It is a replacement
    for the **MVVMLight** library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: "The main benefits of using MVVM as an architectural pattern are a clear separation\
    \ of concerns, cleaner code, and great testability of `ViewModel`. If you are\
    \ interested in learning more about MVVM, and how to use it with .NET MAUI, visit\
    \ [https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm](https://learn.microsoft.com/en-us/dotnet/arch\uFEFF\
    \uFEFF\uFEFFitecture/maui/mvvm)."
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Well, enough of that – let’s write some code instead!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Defining a ViewModel base class
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ViewModel` is the mediator between the view and the model. We can benefit
    from it greatly by creating a common base class for all our `ViewModel` classes
    to inherit from. To do this, follow these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `ViewModels` in the `DoToo` project.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class called `ViewModel` in the `ViewModels` folder.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ViewModel` class is a base class for all `ViewModel` objects. It is not
    meant to be instantiated on its own, so we mark it as `abstract`. It implements
    `INotifyPropertyChanged`, which is an interface defined in `System.ComponentModel`
    in the .NET base class libraries. This interface only defines one thing – the
    `PropertyChanged` event. Our `ViewModel` class must raise this event whenever
    we want the GUI to be aware of any changes to a property. This can be done manually
    by adding code to a setter in a property, as we did in the current implementation,
    or by using the **CommunityToolkit.Mvvm** library. We will talk about this in
    more detail in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: We will also take a little shortcut here by adding an `INavigation` property
    to `ViewModel`. This will help us with navigation later on. This is also something
    that can (and should) be abstracted since we don’t want `ViewModel` to be dependent
    on .NET MAUI to be able to reuse the `ViewModel` classes on any platform.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the CommunityToolkit.Mvvm library’s ObservableObject and ObservableProperty
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional way of implementing a `ViewModel` class is to inherit it from
    a base class (such as the `ViewModel` class that we defined previously) and then
    add code that might look as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each property that we want to add to a `ViewModel` class yields 13 lines of
    code. Not too bad, you might think. However, considering that a `ViewModel` class
    could potentially contain 10 to 20 properties, this rapidly turns into a lot of
    code. We can do better than this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In just a few simple steps, we can use the CommunityToolkit.Mvvm library to
    automatically inject almost all the code during the build process:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In the `DoToo` project, install the CommunityToolkit.Mvvm NuGet package.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `ViewModel` class so that it looks like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have changed the base class of our `ViewModel` class so that it has an `ObservableObject`
    attribute and added the `partial` modifier. This attribute will add the base implementation
    of `INotifyPropertyChanged` that was previously in our `ViewModel` base class
    automatically during the build process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our base class has been modified, we can use the `ObservableProperty`
    attribute to automatically generate the property implementation. The result is
    that the test class we had previously is reduced to a single line of code per
    property. This makes the code base more readable because everything happens behind
    the scenes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are a few things to note about the previous example. First, the class
    must be marked as `partial` for the `ObservableProperty` attribute to work, just
    like the `ObservableObject` attribute. Second, when using the `ObservableProperty`
    attribute, you place it on a private field, not a property. The CommunityToolkit.Mvvm
    library uses **Source Generators**, a feature added in .NET 5, to generate the
    actual property implementation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the great things about using Source Generators is that you can always
    view the generated source to see how things work. For example, to view the generated
    source for the `ViewModel` class, do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ViewModel.cs` file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the `ViewModel` type name.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Goto Implementation**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Normally, this would do nothing, as you are in the implementation of `ViewModel`.
    However, since there is additional generated code, Visual Studio will show you
    a list of locations that contain implementations for `ViewModel`, similar to what’s
    shown here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Finding all implementations of ViewModel](img/Figure_2.12_B19214.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Finding all implementations of ViewModel
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The first item in the list is what we added to the `ViewModel.cs` file, and
    the second item in the list is the generated code. By double-clicking the item,
    it will open the generated code in a new code window. In the *Creating TodoItemViewModel*
    section, you can follow the same steps to see what is generated for the property
    implementations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how to implement properties using a sample `ViewModel`,
    it is time to create the concrete `ViewModel` classes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Creating MainViewModel
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have mainly prepared to write the code that will make up the app
    itself. `MainViewModel` is the `ViewModel` class for the first view that is displayed
    to the user. It is responsible for providing data and logic to a list of to-do
    list items. We will create the bare-bones `ViewModel` classes and add code to
    them as we progress through this chapter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `MainViewModel` in the `ViewModels` folder.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following template code and resolve the references:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The structure of this class is something that we will reuse for all the `ViewModel`
    classes to come.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize the important features we want the `ViewModel` class to have:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We inherit from the `ViewModel` class to gain access to shared logic, such as
    the `INotifyPropertyChanged` interface and common navigation code.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All dependencies to other classes, such as repositories and services, which
    are passed through the constructor of `ViewModel`. This is handled by the `Microsoft.Extensions.DependencyInjection`,
    which is the implementation of the dependency injection we are using. We will
    add support for automatic dependency injection in the *Wiring up dependency* *injection*
    section.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use an asynchronous call to `LoadDataAsync()` as an entry point to initialize
    the `ViewModel` class. Different MVVM libraries might do this in different ways,
    but the basic functionality is the same.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating TodoItemViewModel
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TodoItemViewModel` is the `ViewModel` class that represents each item in the
    to-do list on `MainView`. It does not have an entire view of its own, although
    it could have. Instead, it is rendered by a template in `ListView`. We will get
    back to this when we create the controls for `MainView`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The important thing here is that this `ViewModel` object represents a single
    item, regardless of where we choose to render it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `TodoItemViewModel` class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Create a class called `TodoItemViewModel` in the `ViewModels` folder.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the class so that it matches the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As with any other `ViewModel` class, we inherit the `TodoItemViewModel` class
    from `ViewModel`. We conform to the pattern of injecting all the dependencies
    into the constructor. In this case, we pass an instance of the `TodoItem` class
    to the constructor that the `ViewModel` object will use to expose the view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The `ItemStatusChanged` event handler will be used later when we want to signal
    to the view that the state of the `TodoItem` class has changed. The `Item` property
    allows us to access the item that we passed in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The `StatusText` property is used to make the status of the to-do item human-readable
    in the view.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ItemViewModel class
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ItemViewModel` represents the to-do list item in a view that can be used to
    create new items and edit existing ones:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In the `ViewModels` folder, create a class called `ItemViewModel`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The pattern is the same as for the previous two `ViewModel` classes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We use dependency injection to pass the `TodoItemRepository` class to the `ViewModel`
    object
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use inheritance from the `ViewModel` base class to add the common features
    defined by the base class
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the MainView view
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we are done with the `ViewModel` classes, let’s create the skeleton
    code and the XAML required for the views. The template created a file named `MainPage.xml`.
    In MVVM, the convention is to use a `-View` suffix instead. We will also want
    to place all our views together in a subfolder, as we did with the `ViewModel`
    classes. Let’s deal with the `MainPage.xml` file first, which is the view that
    will be loaded first:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `MainPage.xml` file from the root of the project.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder called `Views` in the `DoToo` project.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **.NET MAUI** under the **C# Items** node on the left.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `MainView`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click **Add** to create the page:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Adding a new XAML file](img/Figure_2.13_B19214.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Adding a new XAML file
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add some content to the newly created view:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainView.xaml`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove all the template code below the `ContentPage` root node and add the
    XAML code highlighted in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To be able to access custom converters, we need to add a reference to a local
    namespace. The `line defines this namespace for us. We will not use it directly
    in this case, but it’s a good idea to have a local namespace defined. If we create
    custom controls, we can access them by writing something such as **<**`**`local:MyControl
    />`.**
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**The `Title` property on the `ContentPage` page gives the page a title. Depending
    on the platform we are running on, the title is displayed differently. If we use
    a standard navigation bar, it will be displayed at the top, for example, in both
    iOS and Android. A page should always have a title.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: The `ContentPage.ToolbarItems` node defines a toolbar item for adding new to-do
    items. It will also be rendered differently based on the platform, but it always
    follows the platform-specific UI guidelines.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: A page in .NET MAUI (and in an XML document, in general) can only have one root
    node. The root node in a .NET MAUI page populates the `Content` property of the
    page itself. Since we want our `MainView` view to contain a list of items and
    a button at the top to toggle a filter (to switch between all items and only active
    items), we need to add a `Layout` control to position them on the page. `Grid`
    is a control that allows you to split up the available space based on rows and
    columns.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: For our `MainView` view, we want to add two rows. The first row is a space calculated
    by the height of the button (`Height="auto"`) and the second row takes up all
    the remaining space for `ListView` (`Height="*"`). Elements such as `ListView`
    are positioned in the grid using the `Grid.Row` and `Grid.Column` attributes.
    Both properties default to `0` if they are not specified, just like the button.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`ListView` is a control that presents items in a list, which is coincidently
    exactly what our app will do. It’s worth noting that .NET MAUI does have a control
    called `CollectionView`, which can handle displaying collections of items better
    than `ListView`. Subsequent chapters will use this control, but we wanted to introduce
    you to the good old `ListView` control as well.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in how `Grid` works, you can search for more information
    about .NET MAUI grids on the internet or check out the official documentation
    at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to wire up `ViewModel` to the view. This can be done by passing
    the `ViewModel` class in the constructor of the view:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Open the code-behind file of `MainView` by expanding the `MainView.xaml` file
    in `MainView.xaml.cs`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using DoToo.ViewModels` statement to the top of the file, adjacent to
    the existing `using` statements.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the constructor of the class so that it looks as follows by adding the
    highlighted code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We follow the same pattern as we did with the `ViewModel` classes by passing
    any dependencies through the constructor. A view is always dependent on a `ViewModel`
    class. To simplify the project, we also assign the `Navigation` property of the
    page directly to the `Navigation` property defined in the `ViewModel` base class.
    In a larger project, we might want to abstract this property as well to make sure
    that we separate the `ViewModel` classes from .NET MAUI. For the sake of this
    app, however, it is OK to reference it directly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we assign `ViewModel` to the `BindingContext` class of the page. This
    tells the .NET MAUI binding engine to use our `ViewModel` object for the bindings
    that we will create later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: At this point, since we have removed `MainPage`, the project will no longer
    run. We will fix this in the *Making the app run* section later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ItemView view
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second view we will add is `ItemView`. We will use this to add and edit
    the to-do list items:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Create a new content page (in the same way that we created the `MainView` view)
    and name it `ItemView`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the XAML file so that it appears as in the following code. The changes
    are highlighted:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with `MainView`, we need a title. We will give it a default title of `New
    todo item` for now, but we will change this to `Edit todo item` when we reuse
    this view for editing later on. The user must be able to save a new or edited
    item, so we have added a toolbar `Save` button. The content of the page uses `StackLayout`
    to structure the controls. `StackLayout` adds an element vertically (the default
    option) or horizontally based on the space it calculates that the element takes
    up. This is a CPU-intensive process, so we should only use it on small portions
    of our layout. In `StackLayout`, we add a `Label` control, which is a line of
    text over the `Entry` control that comes underneath it. The `Entry` control is
    a text input control that contains the name of the to-do list item. Then, we have
    a section for `DatePicker`, where the user can select a due date for the to-do
    list item. The final control is a `Switch` control, which renders a toggle button
    to control when an item is complete, as well as a heading next to it. Since we
    want these to be displayed next to each other horizontally, we use a horizontal
    `StackLayout` control to do this.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step for the views is to wire up the `ItemViewModel` model to `ItemView`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Open the code-behind file of `ItemView` by expanding the `ItemView.xaml` file
    in **Solution Explorer**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using DoToo.ViewModels` statement to the top of the file, adjacent to
    the existing `using` statements.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the constructor of the class so that it looks as follows. Add the code
    that is marked in bold:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code is identical to the code that we added for `MainView`, except for
    the type of `ViewModel` class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up dependency injection
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we discussed the dependency injection pattern, which states that all
    dependencies, such as the repositories and view models, must be passed through
    the constructor of the class. This requirement has several benefits:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: It increases the readability of the code since we can quickly determine all
    the external dependencies
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes dependency injection possible
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes unit testing possible by mocking classes
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can control the lifetime of an object by specifying whether it should be
    a singleton or a new instance for each resolution
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection is a pattern that lets us determine, at runtime, which
    instance of an object should be passed to a constructor when an object is created.
    We do this by defining a container where we register all the types of a class.
    We let the framework that we are using resolve any dependencies between them.
    Let’s say that we ask the container for a `MainView` class. The container takes
    care of resolving `MainViewModel` and any dependencies that the class has.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI uses the `Microsoft.Extensions.DependencyInjection` NuGet library
    internally and it is exposed for us to use in our applications. The first step
    is to register the classes we want to participate in dependency injection.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Registering View, ViewModels, and Services
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our classes to be available through dependency injection, they need to be
    registered with the dependency injection service. .NET MAUI exposes the dependency
    injection service using the `Services` property of the `MauiAppBuilder` class.
    The `Services` property will return an `IServiceCollection` object, also referred
    to as the container. `IServiceCollection` has two methods we are interested in,
    `AddSingleton`, and `AddTransient`. The “Transient” and “Singleton” in the method
    names refer to the lifetime of the objects. Transient objects are created every
    time they are requested from the container. Singleton objects are created only
    once, and that one instance is returned every time the class is requested from
    the container.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'When registering classes with the container, it is recommended to use extension
    methods to group the types. For this app, there are three groups: `View`, `ViewModels`,
    and `Services`. The extension methods will take a single parameter and return
    a single value, the `MauiAppBuilder` instance. This is how the Builder pattern
    is implemented and allows us to chain the methods on the builder defined in the
    `CreateMauiApp` method.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the methods, follow these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MauiProgram.cs` file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes to the `MauiProgram` class. The changes are highlighted
    in bold:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Normally, registering a type is done by using the type name as the generic argument
    to the registration method, as in `mauiAppBuilder.Services.AddTransient<Views.MainView>();`.
    But that doesn’t work if you need to resolve an interface to an implementation,
    like what is happening in the `RegisterServices` method. There, the registration
    method doesn’t use the generic argument; instead, it passes in the type to register
    as the first argument, and the second argument is the type of the instance to
    return.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Info
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how `Microsoft.Extensions.DependencyInjection` works, visit
    [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)
    in your favorite browser.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Now that dependency injection is wired up, we can get the project running again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Making the app run
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are just a few more changes we need to make to enable the app to run:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Open the `App.xaml.cs` file by expanding the `App.xaml` node in the `DoToo`
    project.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the following lines in bold:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`AppShell.Xaml` and `AppShell.xaml.cs` are no longer used, so they can be deleted
    from the project.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When .NET MAUI initializes the `App` class via the builder, it does so by using
    the dependency injection container, so any arguments you add to the `App` constructor
    are resolved from the container as well, and their dependencies too. In this case,
    we are importing the `MainView` class (and all its dependencies, including `MainViewModel`
    and `TodoItemRepository`) and wrapping it in `NavigationPage`. `NavigationPage`
    is a page defined in .NET MAUI that adds a navigation bar and enables the user
    to navigate to other views.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI includes `Shell`, and we have a whole chapter about it in this book.
    However, to become a good .NET MAUI developer, you need to know the basics, and
    the basics of navigating in .NET MAUI uses the good old `NavigationPage` control.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it! Now, your project should start. Depending on the platform you are
    using, it might look as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The DoToo application in the Windows subsystem for Android](img/Figure_2.14_B19214.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The DoToo application in the Windows subsystem for Android
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running with a basic UI, let’s add some functionality,
    starting with displaying data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: If you are debugging the app using the Windows target framework and it isn’t
    working, and you aren’t getting any error messages, try using the Android target
    framework. Sometimes, you can get better error reporting from a different platform.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Adding data bindings
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data binding is the heart and soul of MVVM. This is the way that the views
    and ViewModel communicate with each other. In .NET MAUI, we need two things to
    make data binding happen:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: We need an object to implement `INotifyPropertyChanged`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to set the `BindingContext` class of the page to that object. We already
    do this on both `ItemView` and `MainView`.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A useful feature of data binding is that it allows us to use two-way communication.
    For example, when data binding text to an `Entry` control, the property on the
    data-bound object is updated directly. Consider the following XAML:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To make this work, we need a property named `Title` on the string object. We
    have to look at the documentation, define an object, and let **IntelliSense**
    provide us with a hint to find out what type our property should be.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Controls that perform an action, such as `Button`, usually expose a property
    called `Command`. This property is of the `ICommand` type, and we can either return
    `Microsoft.Maui.Controls.Command` or an implementation of our own. The `Command`
    property is explained in the next section, where we will use it to navigate to
    `ItemView`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will be adding the data binding and command implementations
    to our views and ViewModels, starting with navigating from `MainView` to `ItemView`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that .NET MAUI supports one-way binding in addition to
    two-way data binding, which comes in handy when you want to display data in a
    view but not allow it to update the ViewModel. From a performance perspective,
    it’s a good idea to mark those bindings as one-way bindings.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Navigating from MainView to ItemView to add a new item
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an `Add` toolbar button in `MainView`. When the user taps this button,
    we want it to take them to `ItemView`. The MVVM way to do this is to define a
    command and then bind that command to the button.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET MAUI, to navigate to a view, you need a reference to an instance of
    the destination. In this case, that would be `ItemView`. Since all our views have
    been registered with the dependency injection container, we will need a reference
    to the container to request a new instance of the view when we are ready to navigate.
    We will use constructor injection to have the container provide us with its instance,
    like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` statement for `DoToo.Views`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following field to the class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the constructor as follows. The changes are highlighted:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will capture the instance of `ItemView` that was created by the dependency
    injection container in a class field. Now, let’s look at the command implementation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: All commands should be exposed as a generic `ICommand` type. This abstracts
    the actual command implementation, which is good general practice to follow. The
    command must be a property; in our case, we are creating a new `Command` object
    that we assign to this property. The property is read-only, which is usually fine
    for a `Command` object. The action of the command (the code that we want to run
    when the command is executed) is passed to the constructor of the `Command` object.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Following those requirements, you might end up writing something like the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a lot of boilerplate code in that implementation that you would have
    to repeat for each command. This boilerplate code can get in the way of what the
    command is doing. Like how we were able to eliminate boilerplate code with properties,
    we can do the same with `ICommand`, but instead, we can use the `RelayCommand`
    attribute. The `RelayCommand` attribute uses a source generator to wrap a method
    in a new `Command` instance and expose it through a property. The property name
    that’s generated is the method name with “Command” appended to it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the `Command` object’s implementation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method to the class:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add `using CommunityToolkit.Mvvm.Input;` to the `usings` section of the file.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the class definition to allow the Source Generators to do their thing:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The action of the command is simply to use the `Navigation` service to push
    the `itemView` instance onto the stack for us.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we just need to wire up the `AddItemAsync` command from `ViewModel`
    to the `Add` button in the view:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `ContentPage` element:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `Command` attribute to `ToolbarItem`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the app and tap the `Add` button to navigate to the new `ItemView` view.
    Notice that the back button appears automatically.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Adding new items to the list
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have finished adding navigation to a new item, let’s add the code
    to create a new item and save it to the database:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/ItemViewModel.cs`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Item` property holds a reference to the current item that we want to add
    or edit. A new item is created in the constructor and when we want to edit an
    item, we can simply assign our own item to this property. The new item is not
    added to the database unless we execute the `Save` command defined at the end.
    Once the item has been added or updated, we remove the view from the navigation
    stack and return to `MainView` again.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Since the navigation keeps pages in a stack, the framework declares methods
    that reflect operations that you can perform on a stack. The operation of removing
    the topmost item in a stack is known as *popping the stack*, so instead of `RemoveAsync()`,
    we have `PopAsync()`. To add a page to the navigation stack, we push it, so the
    method is called `PushAsync()`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have extended `ItemViewModel` with the necessary commands and properties,
    it’s time to data-bind them in the XAML:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/ItemView.xaml`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the code marked in bold:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The binding to the `ToolbarItems` command attribute triggers the `SaveAsync`
    command exposed by `ItemViewModel` when a user taps the `Save` link. It’s worth
    noting again that any attribute called `Command` indicates that an action will
    take place and we must bind it to an instance of an object implementing the `ICommand`
    interface.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The `Entry` control that represents the title is data-bound to the `Item.Title`
    property of `ItemViewModel`, and the `Datepicker` and `Switch` controls bind similarly
    to their respective properties.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: We could have exposed `Title`, `Due`, and `Complete` as properties directly
    on `ItemViewModel`, but instead, we chose to reuse the already-existing `TodoItem`
    object as a reference. This is fine, so long as the properties of the `TodoItem`
    object implement the `INotifyPropertyChange` interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Binding ListView in MainView
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A to-do list is not much use without a list of items. Let’s extend `MainViewModel`
    with a list of items:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `using System.Collections.ObjectModel` in the `using` section of the class.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property for the to-do list items:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`ObservableCollection` is like an ordinary collection, but it has a useful
    superpower: it can notify listeners about changes in the list, such as when items
    are added or deleted. The `ListView` control listens to changes in the list and
    updates itself automatically based on these. However, it’s important to be aware
    that a change to an item in the list will not trigger an update. Changing the
    title of an item will not cause the list to re-render. Let’s move on to implementing
    the rest of `MainViewModel`.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some data:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace (or complete) the `LoadDataAsync` method and create the `CreateTodo`
    **ItemViewModel** and `ItemStatusChanged` methods:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Resolve all new references by adding the following `using` statements:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `LoadData` method calls the repository to fetch all items. Then, we wrap
    each to-do list item in `TodoItemViewModel`. This contains more information that
    is specific to the view that we don’t want to add to the `TodoItem` class. It
    is good practice to wrap plain objects in `ViewModel`; this makes it simpler to
    add actions or extra properties to it. `ItemStatusChanged` is a stub that is called
    when we change the status of the to-do list item from `active` to `completed`,
    and vice versa.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to hook up some events from the repository to know when data changes:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When an item is added to the repository, no matter who added it, `MainView`
    will add it to the `items` list. Since the items collection is an observable collection,
    the list updates. If an item is updated, we simply reload the list.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s data-bind our items to `ListView`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainView.xaml` and locate the `ListView` element.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify it so that it reflects the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ItemsSource` binding tells `ListView` where to find the collection to iterate
    over and is local to `ViewModel`. Any bindings in the `ViewCell` node, however,
    are local to each item that we iterate in the list. In this case, we are binding
    to `TodoItemViewModel`, which contains a property named `Item`. This, in turn,
    has properties such as `Title`, `Due`, and `Completed`. We can navigate down the
    hierarchy of objects without any problem when defining a binding.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The `DataTemplate` element defines what each row will look like. We use a grid
    to partition the space, just as we did earlier.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we didn’t discuss what `BoxView` was for, and it isn’t
    bound to any properties of `ViewModel`. The next two sections will cover how we
    can use the `Completed` property to color code our items with `BoxView`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ValueConverter object for the item’s status
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we want to bind to objects that are a representation of the original
    value. This could be a piece of text that is based on a Boolean value. Instead
    of `true` and `false`, for example, we might want to write `Yes` and `No` or return
    a color. This is where `ValueConverter` comes in handy. It can be used to convert
    a value to and from another value. We are going to write a `ValueConverter` object
    that converts the status of a to-do list item into a color:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In the root of the `DoToo` project, create a folder called `Converters`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class called `StatusColorConverter.cs` in the `Converters` folder
    and add the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `ValueConverter` object is a class that implements `IValueConverter`. This,
    in turn, only has two methods defined. The `Convert` method is called when the
    view reads data from `ViewModel` and the `ConvertBack` method is used when `ViewModel`
    gets data from the view. The `ConvertBack` method is only used for controls that
    return data from plain text, such as the `Entry` control.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the implementation of the `Convert` method, we’ll notice that
    any value passed to the method is of the `object` type. This is because we don’t
    know what type the user has bound to the property to which we are adding this
    `ValueConverter` class. We may also notice that we fetch colors from a resource
    file. We could have defined the colors in the code, but this is not recommended.
    So, instead, we went the extra mile and added them as a global resource to the
    `App.xaml` file. Resources are a good thing to take another look at once you have
    finished this chapter:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Open `App.xaml` in the `DoToo` project.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ResourceDictionary` element:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ResourceDictionary` can define a wide range of different objects. We only
    need the two colors that we want to access from `ValueConverter`. Notice that
    these can be accessed by the key given to them and from any other XAML file using
    a static resource binding.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '`ValueConverter` itself is referenced as a static resource but from a local
    scope.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Using ValueConverter
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to use our brand-new `StatusColorConverter` object in `MainView`. Unfortunately,
    we have to jump through some hoops to make this happen. We need to do three things:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Define a namespace in XAML
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a local resource that represents an instance of the converter
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare that we want to use the converter in the binding
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start with the namespace:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following namespace to the page:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a `Resource` node to the `MainView.xaml` file:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `ResourceDictionary` element, shown in bold under the root
    element of the XAML file:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This has the same form as the global resource dictionary, but since this one
    is defined in `MainView`, it can only be accessed from there. We could have defined
    this in the global resource dictionary, but it’s usually more efficient to define
    objects that you only consume in one place as close to that place as possible.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to add the converter:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `BoxView` node in the XAML file.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `BackgroundColor` XAML, which is marked in bold:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What we have done here is bind a `bool` value to a property that takes a `Color`
    object. Right before the data binding takes place, however, `ValueConverter` converts
    the `bool` value into a color. This is just one of the many cases where `ValueConverter`
    comes in handy. Keep this in mind when you define the GUI.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to an item using a command
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to be able to see the details for a selected to-do list item. When we
    tap a row, we should navigate to the item in that row.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to add the following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SelectedItem` property, the `OnSelectedItemChanging` event handler,
    and the `NavigateToItemAsync` method to the class:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `SelectedItem` property is a property that we will data-bind to `ListView`.
    When we select a row in `ListView`, this property is set to the `TodoItemViewModel`
    object that represents that row. We are using the `ObservableProperty` attribute
    here to carry out its `PropertyChanged` magic. However, since the setter is being
    generated through the `ObservableProperty` attribute, there is no place to add
    additional code to the property. Luckily, the `ObservableProperty` source generator
    also adds two partial methods that can be implemented. We are using `OnSelectedItemChanging`
    to add additional functionality to the setter. The other partial method is `OnSelectedItemChanged`.
    `OnSelectedItemChanging` is called before the property value has changed and `OnSelectedItemChanged`
    is called after the value has changed. Remember that you can always view the generated
    source to learn more about how these attributes are extending your code.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The `OnSelectedItemChanging` method then calls `NavigateToItem`, which creates
    a new `ItemView` view using the .NET MAUI dependency injection container. At this
    point, we change the `Title` of the view from `"Add todo item"` to `"Edit todo
    item"`. We extract `ViewModel` from the newly created `ItemView` view and assign
    the current `TodoItem` object that `TodoItemViewModel` contains. Confused? Remember
    that `TodoItemViewModel` wraps a `TodoItem` object, and it is that item that we
    want to pass to `ItemView`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not done yet. Now, we need to data-bind the new `SelectedItem` property
    to the right place in the view:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate `ListView` and add the attributes in bold:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `SelectedItem` attribute binds the `SelectedItem` property’s `ListView`
    view to the `ViewModel` property. When the selection of an item in `ListView`
    changes, the `ViewModel` property’s `SelectedItem` property is called and we navigate
    to the new and exciting views.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The `x:Name` attribute is for naming `ListView` because we need to make a small
    and ugly hack to make this work. `ListView` stays selected after the navigation
    is done. When we navigate back, it cannot be selected again until we select another
    row. To mitigate this, we need to hook up to the `ItemSelected` event of `ListView`
    and reset the selected item directly on `ListView`. This is not recommended because
    we shouldn’t have any logic in our views, but sometimes, we have no other choice:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml.cs`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in bold:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We should now be able to navigate to an item in the list. Next, we will mark
    it as complete.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Marking an item as complete using a command
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to add a functionality that allows us to toggle items between `complete`
    and `active`. It is possible to navigate to the detailed view of the to-do list
    item, but this is too much work for a user. Instead, we’ll add a `ContextAction`
    item to `ListView`. In iOS, for example, this is accessed by swiping left on a
    row:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModel/TodoItemViewModel.cs`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `using` statement for `CommunityToolkit.Mvvm.Input`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a command to toggle the status of the item and a piece of text that describes
    the status:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we have added a command for toggling the state of an item. When executed,
    it inverses the current state and raises the `ItemStatusChanged` event so that
    subscribers are notified. To change the text of the context action button depending
    on the status, we added a `StatusText` property. This is not recommended practice
    because we are adding code that only exists because of a specific UI case to `ViewModel`.
    Ideally, this would be handled by the view, perhaps by using `ValueConverter`.
    To save us from having to implement these steps, however, we have left it as a
    string property:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `ListView.ItemTemplate` node and add the following `ViewCell.ContextActions`
    node:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating the filter toggle function using a command
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We want to be able to toggle between viewing active items only and all the items.
    We will create a simple mechanism to do this.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Hook up the changes in `MainViewModel` as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs` and locate `ItemStatusChangeMethod`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the implementation to the `ItemStatusChanged` method and a property called
    `ShowAll` to control the filtering:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `ItemStatusChanged` event handler is triggered when we use the context action
    from the previous section. Since the sender is always an object, we try to cast
    it to `TodoItemViewModel`. If this is successful, we check whether we can remove
    it from the list if `ShowAll` is not `true`. This is a small optimization; we
    could have called `LoadData` and reloaded the entire list, but since the `Items`
    list is set to `ObservableCollection`, it communicates to `ListView` that one
    item has been removed from the list. We also call the repository to update the
    item to persist the change of status.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShowAll` property is what controls which state our filter is in. We need
    to adjust the `LoadData` method to reflect this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Locate the `Load` method in `MainViewModel`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code marked in bold:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If `ShowAll` is `false`, we limit the content of the list to the items that
    have not been completed. We can do this either by having two methods, `GetAllItems()`
    and `GetActiveItems()`, or by using a `filter` argument that can pass to `GetItemsAsync()`.
    Take a minute to think about how we could implement this.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the code that toggles the filter:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `FilterText` and `ToggleFilterAsync` properties:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `ShowAll` property is a Boolean value, and that does not display well in
    a human-readable form. We will use another `ValueConverter` to change the status
    into a human-readable form:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class in the `Converters` folder named `FilterTextConverter.cs`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`FilterTextConverter` is very similar to the previous converter we created.
    The difference is that in the `Convert` method, we convert a `bool` value into
    the `"All"` or `"Active"` string. This converter will be used in the view to change
    the value of `ShowAll` into a value more suitable for display in the user interface.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The logic for the `ToggleFilterAsync` command is a simple inversion of the state
    and then a call to `LoadDataAsync`. This, in turn, causes the list to be reloaded.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can filter the items, we need to hook up the filter button to `Command`
    and `Converter`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following highlighted entry to `ResourceDictionary`:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Locate the button that controls the filter (the only button in the file).
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust your code to reflect the following code:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have now finished with this feature! However, our app isn’t very attractive;
    we’ll deal with this in the following section.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the contents
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This last section is about making the app look a bit nicer. We will just scratch
    the surface of the possibilities here, but this should give you some ideas about
    how styling works.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Setting an application-wide background color
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Styles are a great way of applying styling to elements. They can be applied
    either to all elements of a type or the elements referenced by a key if you add
    an `x:Key` attribute:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Open `App.xaml`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following XAML, which is in bold, to the file:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first style we will apply is a new background color and text color to the
    navigation bar. The second style will be applied to the filter button. We can
    define a style by setting `TargetType`, which tells .NET MAUI which type of object
    this style can be applied to. We can then add one or more properties that we want
    to set. The result will be the same as if we had added these properties directly
    to the element in the XAML code.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: Styles that lack the `x:Key` attribute are applied to all instances of the type
    defined in `TargetType`. Styles that have a key must be explicitly assigned in
    the XAML of the user interface. We will see examples of this when we define the
    filter button in the next section.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the MainView and ListView items
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will improve the appearance of `MainView` and `ListView`.
    Open `Views/MainView.xaml` and apply the changes in bold in the XAML code in each
    of the following sections.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: The ﬁlter button
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The filter button allows us to toggle the state of the list to show only the
    active to-do items or all the to-do items. Let’s style it to make it stand out
    a bit in the layout:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Find the filter button.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the following changes:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The style is applied using `DynamicResource`. Anything defined in a resource
    dictionary, either in the `App.xaml` file or in the local XAML file, is accessible
    through it. Then, we set `BackgroundColor`, again setting `DynamicResource` to
    `ActiveColor` and `TextColor` to `Black`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The `Button.Triggers` node is a useful feature. We can define several types
    of triggers that fire when certain criteria are met. In this case, we use a data
    trigger that checks whether the value of `ShowAll` changes to `true`. If it does,
    we set `TextColor` to white and `BackgroundColor` to `CompletedColor`. The coolest
    part is that when `ShowAll` becomes `false` again, it switches back to whichever
    value it was before.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Touching up ListView
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ListView` could use a couple of minor changes. The first change is formatting
    the due date string to a more human-readable format and the second is changing
    the color of the `Completed` label to a nice green tint:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Open `Views/MainView.xaml`.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the labels that bind `Item.Due` and `Item.Completed` in `ListView`:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we added a formatting string to the binding to format the date using a
    specific format. In this case, we used the `0:MMMM d, yyyy` format, which will
    display the date as a string in the format of, for example, May 5, 2020.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: We also added a text color to the `Completed` label that is only visible if
    an item is completed. We did this by referencing our dictionary in `App.xaml`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all the code changes are complete, run our application. Here is a
    small gallery of screenshots that should match your application:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – DoToo on Android](img/Figure_2.15_B19214.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – DoToo on Android
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a good grasp of all the steps involved in creating a .NET
    MAUI app from scratch. In this chapter, we learned about the project structure
    and the important files in a newly created project. We talked about dependency
    injection and learned the basics of MVVM by creating all the views and the `ViewModel`
    classes needed. We also covered data storage in SQLite to persist data on our
    device in a fast and secure way. Using the knowledge you’ve gained from this chapter,
    you should now be able to create the backbone of any app you’d like.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on upgrading an existing Xamarin.Forms application
    to .NET MAUI.**
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于将现有的Xamarin.Forms应用程序升级到.NET MAUI。**
