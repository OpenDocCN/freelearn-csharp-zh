<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-73"><a id="_idTextAnchor072"/>4</h1>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Refactoring at the Method Level</h1>
<p>In the last chapter, we covered improving individual lines of code. We’ll expand on those lessons to cover refactoring entire methods and solving issues with how code comes together to form larger methods that then interact with each other.</p>
<p>We saw a little of this in <a href="B21324_02.xhtml#_idTextAnchor026"><em class="italic">Chapter 2</em></a> when we covered the extract method refactoring. However, in this chapter, we’ll expand our set of tools covering the basics of refactoring methods and then move into more advanced areas as we cover the following main topics:</p>
<ul>
<li>Refactoring the flight tracker</li>
<li>Refactoring methods</li>
<li>Refactoring constructors</li>
<li>Refactoring parameters</li>
<li>Refactoring to functions</li>
<li>Introducing static methods and extension methods</li>
</ul>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Technical requirements</h1>
<p>The starting code for this chapter is available from GitHub at <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> in the <code>Chapter04/Ch4BeginningCode</code> folder.</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Refactoring the flight tracker</h1>
<p>This chapter’s code focuses<a id="_idIndexMarker187"/> largely on a single <code>FlightTracker</code> class intended to track and display the outgoing flights from a commercial airport for passengers in the terminal, as pictured in <em class="italic">Figure 4</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 4.1 – FlightTracker displaying outbound flight statuses" src="img/B21324_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – FlightTracker displaying outbound flight statuses</p>
<p>The <code>FlightTracker</code> class <a id="_idIndexMarker188"/>has a number of methods related to managing and displaying flights. It is supported by the <code>Flight</code> class which represents an individual flight in the system and the <code>FlightStatus</code> <code>enum</code> which represents all relevant statuses of a flight, as shown in the class diagram in <em class="italic">Figure 4</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 4.2 – A class diagram showing FlightTracker and supporting classes" src="img/B21324_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – A class diagram showing FlightTracker and supporting classes</p>
<p>We’ll explore these pieces of code throughout this chapter, but for now, we need to understand that the key responsibilities of <code>FlightTracker</code> include the following:</p>
<ul>
<li>Tracking a list of flights</li>
<li>Scheduling new flights (adding them to the list)</li>
<li>Marking flights as arrived, departed, or delayed</li>
<li>Displaying all flights</li>
<li>Finding a flight by its ID</li>
</ul>
<p>This is a fairly simple flight tracker class, but we’ll see a slightly more complicated version of one in the<a id="_idIndexMarker189"/> next chapter as we explore object-oriented refactoring.</p>
<p>For now, let’s look at a few simple steps we can take to improve these methods.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Refactoring methods</h1>
<p>In this section, we’ll explore a number of refactorings related to methods and their interactions. We’ll start by discussing the access modifier of a method.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Changing method access modifiers</h2>
<p>During my time as a professional C# instructor, I noticed my students often tended to not think about the <strong class="bold">access modifiers</strong> they used in their code. Specifically, my students would<a id="_idIndexMarker190"/> usually do one of two things:</p>
<ul>
<li>They marked all <a id="_idIndexMarker191"/>methods as <strong class="bold">public</strong> by default unless someone (usually me) suggested they use a different access modifier</li>
<li>They marked all <a id="_idIndexMarker192"/>methods as <strong class="bold">private</strong> by default (or omitted the access modifier entirely, defaulting to <strong class="bold">private</strong> anyway) until the compiler gave them an issue requiring them to make a method more accessible</li>
</ul>
<p>Both approaches are insufficient for a simple reason: we want to explicitly declare the visibility level of our methods. This way, whenever you read code, you are reminded explicitly by the access modifier what other code can access the code you’re working with. This is particularly useful when working with non-private methods that can be referenced outside of the class.</p>
<p class="callout-heading">Access modifiers</p>
<p class="callout">C# has several access modifiers as of C# 12 that govern what other areas can refer to your code. The current access modifiers are <code>public</code>, <code>private</code>, <code>protected</code>, <code>internal</code>, <code>protected internal</code>, <code>private internal</code>, and the new <code>file</code> access modifier that restricts access to something within a single source file. While these access modifiers all have their uses, I’m going to focus primarily on <code>public</code> and <code>private</code> in this section for simplicity’s sake.</p>
<p>If we mark a method as <strong class="bold">public</strong>, <strong class="bold">protected</strong>, or <strong class="bold">internal</strong>, there should be a good reason for that – typically related to the method being a primary way in which we intend for others to use our code.</p>
<p>Our <code>FlightTracker</code> class has a <code>public</code> method called <code>FindFlightById</code> that is used by most of the other methods in<a id="_idIndexMarker193"/> the class but nothing outside of the class. This method looks up the flight by <code>ID</code> and returns it if one is found:</p>
<pre class="source-code">
<strong class="bold">public</strong> Flight? FindFlightById(string id) {
  return _flights.Find(f =&gt; f.Id == id);
}</pre>
<p>Given these circumstances, you might make an explicit decision to mark the method as <code>private</code>, restricting its usage within this class, as shown in the following code:</p>
<pre class="source-code">
<strong class="bold">private</strong> Flight? FindFlightById(string id) {
  return _flights.Find(f =&gt; f.Id == id);
}</pre>
<p>By marking this method as <code>private</code>, you have greater freedom in the future to rename it, change how it works, modify its parameters, or remove it entirely.</p>
<p>Changing the access modifier is generally safe if nothing outside the class uses the method. Otherwise, this decision will cause compiler errors.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Renaming methods and parameters</h2>
<p>Let’s <a id="_idIndexMarker194"/>take a look at three <a id="_idIndexMarker195"/>very similar methods for managing flights in <code>FlightTracker</code>:</p>
<pre class="source-code">
public Flight? <strong class="bold">DelayFlight(string fId, DateTime newTime)</strong> {
  // Details omitted
}
public Flight? <strong class="bold">MarkFlightArrived(DateTime time, string id)</strong>{
  // Details omitted
}
public Flight? <strong class="bold">MarkFlightDeparted(string id, DateTime t) </strong>{
  // Details omitted
}</pre>
<p>Each of these methods takes in a <code>DateTime</code> and a flight identifier string. However, the naming of these parameters and <a id="_idIndexMarker196"/>even these methods are not incredibly consistent.</p>
<p><code>DelayFlight</code> calls its flight ID <a id="_idIndexMarker197"/>variable <code>fId</code> and its new departure time <code>newTime</code>. <code>MarkFlightArrived</code> uses <code>time</code> for the arrival time and <code>id</code> for the flight identifier. <code>MarkFlightDeparted</code> uses <code>id</code> but chose <code>t</code> to denote the departure time.</p>
<p>While some of these naming choices are better than others on their own, the lack of naming consistency in methods within the same class can hurt other people’s ability to work effectively with your code. This can lead them to feel less confident in your abilities and can even introduce bugs from misunderstandings of what parameters or methods represent – all due to a lack of consistency.</p>
<p>To fix this, we can use the <em class="italic">rename parameter</em> refactoring to rename individual parameters to ensure consistency. This can be done by right-clicking on a parameter and selecting <strong class="bold">Rename…</strong> from the context menu, or pressing <em class="italic">Ctrl</em> + <em class="italic">R</em> twice with the parameter selected. See <em class="italic">Figure 4</em><em class="italic">.3</em>:</p>
<div><div><img alt="Figure 4.3 – Activating the rename parameter refactoring via the context menu" src="img/B21324_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Activating the rename parameter refactoring via the context menu</p>
<p>Next, type the new name you want to use for the parameter and press <em class="italic">Enter</em> to complete the change. See <em class="italic">Figure 4</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 4.4 – Renaming the parameter" src="img/B21324_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Renaming the parameter</p>
<p>While choosing your names, you’ll want to pick something that is clear and consistent with the terminology and names you use in your class already. Avoid very short and single-letter parameters <a id="_idIndexMarker198"/>wherever possible (excluding some cases, such as <code>x</code> and <code>y</code> for coordinates or other<a id="_idIndexMarker199"/> established usages of short parameter names).</p>
<p>In the case of this code, I chose to rename all the flight identifiers to <code>id</code> and chose to be more explicit about the names of the <code>DateTime</code> parameters to indicate what the parameter represented.</p>
<p>I also chose to use the same rename tool to rename the entire method of <code>DelayFlight</code> to <code>MarkFlightDelayed</code> to be more consistent with the other methods in this class:</p>
<pre class="source-code">
public Flight? <strong class="bold">MarkFlightDelayed(</strong>
<strong class="bold">  string id, DateTime newDepartureTime)</strong> {
  // Details omitted
}
public Flight? <strong class="bold">MarkFlightArrived(DateTime arrivalTime,</strong>
<strong class="bold">  string id)</strong> {
  // Details omitted
}
public Flight? <strong class="bold">MarkFlightDeparted(string id,</strong>
<strong class="bold">  DateTime departureTime)</strong> {
  // Details omitted
}</pre>
<p>Some of these names are perhaps a bit longer than I might like (particularly when trying to fit code onto a page in a book!), but <a id="_idIndexMarker200"/>clear parameter and method names can save a lot of confusion and even <a id="_idIndexMarker201"/>prevent certain bugs from occurring later.</p>
<p class="callout-heading">Note</p>
<p class="callout">If the inconsistent ordering of parameters annoys you, don’t worry. We’ll fix parameter ordering later on in this chapter.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Overloading methods</h2>
<p>Let’s shift gears and talk about how methods <a id="_idIndexMarker202"/>can work together in tandem. First, we’ll look at an example of <strong class="bold">overloading</strong> and then an example of <strong class="bold">chaining</strong>.</p>
<p>Let’s start by looking at the <code>ScheduleNewFlight</code> method:</p>
<pre class="source-code">
public Flight <strong class="bold">ScheduleNewFlight</strong>(<strong class="bold">string id, string dest,</strong>
<strong class="bold">  DateTime depart, string gate</strong>) {
  <strong class="bold">Flight flight = new() {</strong>
      Id = <strong class="bold">id</strong>,
      Destination = <strong class="bold">dest</strong>,
      DepartureTime = <strong class="bold">depart</strong>,
      Gate = <strong class="bold">gate</strong>,
      Status = FlightStatus.Inbound
  <strong class="bold">}</strong>;
  _flights.Add(flight);
  return flight;
}</pre>
<p>This method takes in four parameters representing flight information. It uses them to instantiate a <code>Flight</code> object, adds the flight to the private list of flights, and then returns the newly-created <code>Flight</code> object.</p>
<p>As the system grows, it’s reasonable to <a id="_idIndexMarker203"/>expect that someone might want to provide their own <code>Flight</code> object. To accommodate that, you can overload the <code>ScheduleNewFlight</code> method.</p>
<p class="callout-heading">Overloading</p>
<p class="callout">Overloading is where you offer a method with the same name as another method but a different set of types of parameters that can be accepted by the method. For example, you can have a method that takes in an <code>int</code> and another method that takes in two <code>strings</code>, but you can’t have two methods that both take in only a single <code>int</code>, even if the parameter names are different. From the compiler’s perspective, overloaded methods are entirely separate methods that just happen to have the same name.</p>
<p>The overloaded <code>ScheduleNewFlight</code> method that takes in a <code>Flight</code> object might look something like the following:</p>
<pre class="source-code">
public Flight <strong class="bold">ScheduleNewFlight(Flight flight)</strong> {
  _flights.Add(flight);
  return flight;
}</pre>
<p>Overloading the <code>ScheduleNewFlight</code> method is helpful because it helps people discover the different options for scheduling a flight based on Visual Studio’s suggestions, as shown in <em class="italic">Figure 4</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight" src="img/B21324_04_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Visual Studio suggestions showing available overloads for ScheduleNewFlight</p>
<p>By providing overloads, following standard conventions, and having consistent and predictable methods and parameters, you help others discover how to use your classes safely and effectively.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Chaining methods</h2>
<p>You may have noticed a few lines <a id="_idIndexMarker204"/>of duplication between our two <code>ScheduleNewFlight</code> overloads. Let’s take a look at them side by side for reference:</p>
<pre class="source-code">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = new() {
      Id = id,
      Destination = dest,
      DepartureTime = depart,
      Gate = gate,
      Status = FlightStatus.Inbound
  };
<strong class="bold">  _flights.Add(flight);</strong>
<strong class="bold">  return flight;</strong>
}
public Flight ScheduleNewFlight(Flight flight) {
<strong class="bold">  _flights.Add(flight);</strong>
<strong class="bold">  return flight;</strong>
}</pre>
<p>While this duplication is very minimal, I could see new requirements come in that would necessitate changing both places. For example, the business might require that whenever a new flight is scheduled, a log entry should be written, or perhaps a new <code>LastScheduleChange</code> property needs to be set to the current time.</p>
<p>When these types of changes occur, developers run the risk of introducing bugs unless they change all the affected areas. This means that code duplication, even minor code duplication such as this example, leads to additional work and additional sources of bugs if not every place with <a id="_idIndexMarker205"/>similar logic is updated.</p>
<p>One thing that can<a id="_idIndexMarker206"/> help with this is <strong class="bold">method chaining</strong>. Method chaining is when one method calls another related method and has it accomplish its work for it.</p>
<p>In this case, we can modify our first <code>ScheduleNewFlight</code> method to be responsible for creating a <code>Flight</code> object and then handing off that object to the other <code>ScheduleNewFlight</code> overload, as follows:</p>
<pre class="source-code">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = new() {
      Id = id,
      Destination = dest,
      DepartureTime = depart,
      Gate = gate,
      Status = FlightStatus.Inbound
  };
  <strong class="bold">return ScheduleNewFlight(flight);</strong>
}
public Flight ScheduleNewFlight(Flight flight) {
  _flights.Add(flight);
  return flight;
}</pre>
<p>Not only is this less code, but if we ever need to alter what happens when a new flight is scheduled, we now only have one place to modify.</p>
<p>Now that we’ve covered some of the basics of refactoring methods, let’s look briefly at some parallels with <strong class="bold">constructors</strong>. After all, constructors <a id="_idIndexMarker207"/>are essentially a special type of method that gets <a id="_idIndexMarker208"/>called when an object is instantiated.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor081"/>Refactoring constructors</h1>
<p>When you think about the job<a id="_idIndexMarker209"/> of a constructor, its whole reason for being is to get the object into its correct initial position. Once the constructor completes, the object is generally considered ready for use by other code.</p>
<p>This means that constructors can be very handy for ensuring that certain pieces of information are in place.</p>
<p>Right now, our <code>Flight</code> class is defined fairly minimally and only has the default constructor that .NET provides in the absence of any explicit constructor:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Flight.cs</p>
<pre class="source-code">
public class Flight {
    public string Id { get; set; }
    public string Destination { get; set; }
    public DateTime DepartureTime { get; set; }
    public DateTime ArrivalTime { get; set; }
    public string Gate { get; set; }
    public FlightStatus Status { get; set; }
    public override string ToString() {
        return $"{Id} to {Destination} at {DepartureTime}";
    }
}</pre>
<p>The problem with our <code>Flight</code> class lacking any explicit constructor is that flights don’t make sense without some of these pieces of information.</p>
<p>While more recent versions of C# have given us things such as the <code>required</code> keyword, which we’ll explore in <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>, the classic approach to requiring some piece of information at object creation<a id="_idIndexMarker210"/> has been to make the constructor take it in as a parameter. To demonstrate this, let’s add a parameterized constructor next.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Generating constructors</h2>
<p>While we could <a id="_idIndexMarker211"/>manually write a constructor, Visual Studio gives us some great code generation tools, including a <em class="italic">generate </em><em class="italic">constructor</em> refactoring.</p>
<p>To use this refactoring, select the class and open the <strong class="bold">Quick Actions</strong> menu. Then, select <strong class="bold">Generate constructor…</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.6</em>:</p>
<div><div><img alt="Figure 4.6 – Generating a constructor" src="img/B21324_04_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Generating a constructor</p>
<p>This will open a dialog that will allow you to select what members get initialized from the constructor when creating a <code>Flight</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.7</em>:</p>
<div><div><img alt="Figure 4.7 – Selecting required members for the constructor" src="img/B21324_04_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Selecting required members for the constructor</p>
<p>In this case, I chose to make <code>Id</code>, <code>Destination</code>, and <code>DepartureTime</code> part of the constructor and left the others unchecked. I also unchecked the <strong class="bold">Add null checks</strong> checkbox to prevent the <a id="_idIndexMarker212"/>generated code from being too complex for this example.</p>
<p>This generated the following constructor:</p>
<pre class="source-code">
public <strong class="bold">Flight(string id, string destination,</strong>
<strong class="bold">  DateTime departureTime)</strong> {
  Id = id;
  Destination = destination;
  DepartureTime = departureTime;
}</pre>
<p>The resulting code correctly sets the required properties based on its parameters.</p>
<p>If you wanted to, you could go back in and generate a new constructor with a different set of parameters, since classes can have any number of overloaded constructors.</p>
<p>In fact, we’ll add another constructor in the next section to illustrate this. However, for now, we have a problem we need to resolve in the form of a build error:</p>
<div><div><img alt="Figure 4.8 – Build error trying to instantiate a Flight instance" src="img/B21324_04_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Build error trying to instantiate a Flight instance</p>
<p>If you tried to build your project after adding the <code>Flight</code> constructor, you’ll see an error similar to that shown in <em class="italic">Figure 4</em><em class="italic">.8</em>. This “no argument given that corresponds to the required parameter” error exists because the <code>Flight flight = new()</code> code in <code>ScheduleNewFlight</code> is trying to invoke the default constructor for <code>Flight</code>, but that constructor no longer exists.</p>
<p>When we added our<a id="_idIndexMarker213"/> constructor a moment ago, this didn’t move the <code>Flight</code> class from having no constructors to one constructor. Instead, we went from having .NET’s default constructor with no parameters to one constructor with the new parameters we generated, removing the default constructor entirely.</p>
<p>We can add the default constructor back manually by explicitly defining it:</p>
<pre class="source-code">
public Flight() {
}</pre>
<p>This constructor does nothing aside from allowing others to instantiate the class by providing no parameters to the constructor. As soon as you declare your own constructor, .NET no longer provides the default constructor for you.</p>
<p>To fix this compiler error, we can either add a new constructor that takes in no parameters or we can adjust the <code>ScheduleNewFlight</code> code to use our new constructor instead of the default one that no longer exists.</p>
<p>Since part of the intent of adding a new constructor is to require certain pieces of information at the time of object creation, it makes more sense to change <code>ScheduleNewFlight</code> to use the new constructor, as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightTracker.cs</p>
<pre class="source-code">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart, string gate) {
  Flight flight = <strong class="bold">new(id, dest, depart)</strong> {
      Gate = gate,
      Status = FlightStatus.Inbound
  };
  return ScheduleNewFlight(flight);
}</pre>
<p>A nice side effect of doing this is that we no longer need to set those properties in the object initializer since the <a id="_idIndexMarker214"/>constructor does that for us.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/>Chaining constructors</h2>
<p>Earlier, we saw how we <a id="_idIndexMarker215"/>can chain together overloaded methods to work together to reduce code duplication. I also hinted that constructors are really just special methods. When you have multiple constructors, they act exactly like overloaded methods.</p>
<p>We can put all of these concepts<a id="_idIndexMarker216"/> together by <strong class="bold">chaining constructors</strong> together, so one constructor calls to the other.</p>
<p>First, let’s look at an example of <em class="italic">not</em> doing this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Flight.cs</p>
<pre class="source-code">
public Flight(string id, string destination,
  DateTime departureTime) {
<strong class="bold">  Id = id;</strong>
<strong class="bold">  Destination = destination;</strong>
<strong class="bold">  </strong><strong class="bold">DepartureTime = departureTime;</strong>
}
public Flight(string id, string destination,
  DateTime departureTime, FlightStatus status) {
<strong class="bold">  Id = id;</strong>
<strong class="bold">  Destination = destination;</strong>
<strong class="bold">  DepartureTime = departureTime;</strong>
  Status = status;
}</pre>
<p>Here, we have two constructors for <code>Flight</code> that are nearly identical, except the second one also accepts a <code>status</code> parameter.</p>
<p>While this isn’t an excessive<a id="_idIndexMarker217"/> amount of duplication, it can be avoided by chaining constructors together with <code>: this()</code> syntax, as follows:</p>
<pre class="source-code">
public Flight(string id, string destination,
  DateTime departureTime) {
  Id = id;
  Destination = destination;
  DepartureTime = departureTime;
}
public Flight(string id, string destination,
  DateTime departureTime, FlightStatus status)
  <strong class="bold">: this(id, destination, departureTime)</strong> {
  Status = status;
}</pre>
<p>In this case, the second <code>Flight</code> constructor starts out by calling the first constructor through its use of <code>: this</code>. Once that call completes, control will move back to the second constructor and it will execute the <code>Status = </code><code>status;</code> line.</p>
<p>Chaining constructors together adds a little complexity to your code, but it also reduces duplicated code while making it such that you can add new initialization logic in one place and multiple constructors can take advantage of the addition.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Refactoring parameters</h1>
<p>Now that we’ve<a id="_idIndexMarker218"/> explored the basics of methods and constructors, let’s talk about managing parameters. This is important because it is possible that poorly thought-out parameters can quickly reduce the maintainability of your code.</p>
<p>Let’s look at a few common refactorings you’ll want to perform over the life of your methods.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Reordering parameters</h2>
<p>Sometimes, you’ll realize that the<a id="_idIndexMarker219"/> order of parameters in a method doesn’t make as much sense as another arrangement might. At other times, you might notice that a few of your methods take in the same kinds of parameters, but with inconsistent ordering. In either case, you’ll find yourself wanting to reorder your method parameters.</p>
<p>Let’s look at a practical example from the various <code>MarkX</code> methods we saw earlier:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightTracker.cs</p>
<pre class="source-code">
public Flight? MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  // Details omitted...
}
public Flight? MarkFlightArrived(DateTime arrivalTime,
  string id) {
  // Details omitted...
}
public Flight? MarkFlightDeparted(string id,
  DateTime departureTime) {
  // Details omitted...
}</pre>
<p>Here, we have three methods that all take in <code>string</code> and <code>DateTime</code> parameters, but their ordering is inconsistent.</p>
<p>In this case, looking at these three methods, you decide that the most intuitive order is to put the flight ID first and then the time component as the second parameter. This means that <code>MarkFlightDelayed</code> and <code>MarkFlightDeparted</code> are correct but <code>MarkFlightArrived</code> needs to be adjusted.</p>
<p>You can add, remove, and<a id="_idIndexMarker220"/> reorder parameters from the same refactoring dialog in Visual Studio by selecting the method you want to refactor and then choosing <strong class="bold">Change signature…</strong> from the <strong class="bold">Quick Actions</strong> menu, as shown in <em class="italic">Figure 4</em><em class="italic">.9</em>:</p>
<div><div><img alt="Figure 4.9 – Triggering the Change signature… refactoring" src="img/B21324_04_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Triggering the Change signature… refactoring</p>
<p>This will bring up the <strong class="bold">Change Signature</strong> dialog (see <em class="italic">Figure 4</em><em class="italic">.10</em>) and allow you to use the up and down buttons in the upper right to reorder parameters until the order in the preview matches your expectations:</p>
<div><div><img alt="Figure 4.10 – Reordering parameters in the Change Signature dialog" src="img/B21324_04_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Reordering parameters in the Change Signature dialog</p>
<p>Once you are done, click <strong class="bold">OK</strong> and Visual Studio will update your method as well as everything that was called out to that <a id="_idIndexMarker221"/>method to use the revised parameter order.</p>
<p class="callout-heading">Tip</p>
<p class="callout">There are other ways of making which parameters a method requires more explicit using C#. One such way would<a id="_idIndexMarker222"/> be to use the <strong class="bold">named arguments</strong> feature of C# that allows you to specify method parameters by name followed by a colon, making the parameter usage explicit.</p>
<p class="callout">An example of using this to call our <code>MarkFlightArrived</code> method would be <code>MarkFlightArrived(arrivalTime:DateTime.Now, id:"MyId")</code>. Note that when using named arguments, you can specify arguments in whatever order you prefer. See the <em class="italic">Further reading</em> section for more details.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Adding parameters</h2>
<p>Occasionally, you’ll want to add a new parameter to your method. The most natural thing to do is generally to<a id="_idIndexMarker223"/> add the parameter to the end of the list of parameters. This, however, can have two downsides:</p>
<ul>
<li>The new parameter might not make the most sense when added to the end of the list instead of earlier on in the sequence of parameters</li>
<li>Manually adding a parameter means you must now manually adjust anything that was calling your method and provide a new value for the parameter</li>
</ul>
<p>Let’s look at a practical example and see how the <strong class="bold">Change Signature</strong> dialog can help.</p>
<p>The <code>MarkFlightArrived</code> method currently finds the flight by its <code>Id</code> and then updates its arrival time and status to match the parameters:</p>
<pre class="source-code">
public Flight? MarkFlightArrived(<strong class="bold">string id,</strong>
<strong class="bold">  DateTime arrivalTime</strong>) {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
<strong class="bold">    flight.ArrivalTime = arrivalTime;</strong>
<strong class="bold">    flight.Status = FlightStatus.OnTime;</strong>
    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");
    } else {
      Console.WriteLine($"{id} could not be found");
    }
    return flight;
}</pre>
<p>Let’s say we need to update this method to take in the gate that the plane should taxi to. While we could manually add it to the end of the parameter list, this would break every method that calls out to this method.</p>
<p>Right now, that’s not a lot of places, since only the tests are calling this method.</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">FlightTrackerTests.cs</p>
<pre class="source-code">
Flight? actual =
  _target.<strong class="bold">MarkFlightArrived(flightId, arrivalTime)</strong>;</pre>
<p>However, the <em class="italic">Change Signature</em> refactoring<a id="_idIndexMarker224"/> tools in Visual Studio provide a safer option when you click the <strong class="bold">Add</strong> button:</p>
<div><div><img alt="Figure 4.11 – Adding a new gate parameter to MarkFlightArrived" src="img/B21324_04_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Adding a new gate parameter to MarkFlightArrived</p>
<p>The <strong class="bold">Add Parameter</strong> dialog is one of the more complex ones in Visual Studio, but all it really needs is the following few things:</p>
<ul>
<li>The parameter name and type that is being added</li>
<li>Whether this parameter is required or optional (more on this shortly)</li>
<li>The value to use in places that are already calling the method</li>
</ul>
<p>In this case, our new parameter is going to be a <code>string</code> named <code>gate</code>. Callers must provide a value and any existing callers should use the <code>"A4"</code> string for now.</p>
<p>This use of <code>"A4"</code> may seem like a random string because it is. The only place using this method right now is a unit test where the gate really doesn’t matter for that test. If more places were using this method, I’d likely choose <strong class="bold">Infer from context</strong> or <strong class="bold">Introduce undefined </strong><strong class="bold">TODO variables</strong>.</p>
<p>Clicking <strong class="bold">OK</strong> will display the <em class="italic">Change Signature</em> dialog again with your new parameter listed, allowing you to reorder it as needed. Clicking <strong class="bold">OK</strong> in this dialog will add the parameter to your method and update your code.</p>
<p>This updates your <a id="_idIndexMarker225"/>method signature for <code>MarkFlightArrived</code> and the test calling your code:</p>
<pre class="source-code">
Flight? actual =
  _target.MarkFlightArrived(flightId, arrivalTime, <strong class="bold">"A4"</strong>);</pre>
<p>With the new parameter in place, you can update the <code>MarkFlightArrived</code> method to use it to set the flight’s <code>Gate</code> property:</p>
<pre class="source-code">
public Flight? MarkFlightArrived(string id,
  DateTime arrivalTime, <strong class="bold">string gate</strong>) {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
    flight.ArrivalTime = arrivalTime;
    <strong class="bold">flight.Gate = gate;</strong>
    flight.Status = FlightStatus.OnTime;
    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</pre>
<p>This workflow is a common one you’ll go through as you find yourself expanding methods to take in new parameters.</p>
<p>Next, let’s see <a id="_idIndexMarker226"/>some ways to simplify method calls using optional parameters.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Introducing optional parameters</h2>
<p>If you’re not a fan of the <strong class="bold">Change Signature</strong> dialog and would rather write the code yourself, you can always take <a id="_idIndexMarker227"/>advantage of optional parameters to safely add new parameters to the end of your parameter list.</p>
<p>With an optional parameter, you specify a default value. Places that call your method can either specify the value for this parameter or not pass any value at all. In cases where no value is passed, the default value will be used instead.</p>
<p class="callout-heading">Note</p>
<p class="callout">This only works with parameters at the end of your parameter list due to how optional parameters work in C#. Additionally, the compiler doesn’t allow certain types of default values such as new objects and certain literals.</p>
<p>If you wanted to declare <code>gate</code> as optional and default to <code>"TBD"</code> (short for “to be determined”), your method would look like the following:</p>
<pre class="source-code">
public Flight? MarkFlightArrived(string id,
  DateTime arrivalTime, <strong class="bold">string gate = "TBD"</strong>) {
  // Details omitted...
}</pre>
<p>The code calling your method could then be left in its prior state:</p>
<pre class="source-code">
Flight? actual =
  _target.<strong class="bold">MarkFlightArrived(flightId, arrivalTime)</strong>;</pre>
<p>Here, the code would compile, but “TBD” would be used for the gate.</p>
<p>Alternatively, you could specify the value for <code>gate</code> manually by providing a value for that parameter:</p>
<pre class="source-code">
Flight? actual =
  _target.MarkFlightArrived(flightId, arrivalTime, <strong class="bold">"A4"</strong>);</pre>
<p>Optional parameters can be particularly nice not just for expanding methods, but also for providing common <a id="_idIndexMarker228"/>defaults that callers can customize if they want.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Removing parameters</h2>
<p>Currently, the code requires<a id="_idIndexMarker229"/> you to specify the gate whenever a new flight is scheduled:</p>
<pre class="source-code">
public Flight ScheduleNewFlight(string id, string dest, DateTime depart, <strong class="bold">string gate</strong>) {
    Flight flight = new(id, dest, depart) {
        <strong class="bold">Gate = gate,</strong>
        Status = FlightStatus.Inbound
    };
    return ScheduleNewFlight(flight);
}</pre>
<p>Let’s say that you decide that since gates are now assigned at arrival, you shouldn’t need to specify the <code>gate</code> when you schedule a new flight.</p>
<p>While you could go in and just remove the <code>gate</code> parameter from the code, this won’t update any methods that are calling that method and will result in compiler errors you must resolve.</p>
<p>Instead, you can use the <strong class="bold">Change Signature</strong> dialog, select the parameter you want to remove, and click <strong class="bold">Remove</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.12</em>:</p>
<div><div><img alt="Figure 4.12 – Removing the gate parameter from ScheduleNewFlight" src="img/B21324_04_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Removing the gate parameter from ScheduleNewFlight</p>
<p>When you click <code>gate</code> parameter.</p>
<p>Of course, this isn’t magic, and it will leave behind code that relied on that gate parameter or code that was put in place to get the value ready to pass into <code>ScheduleNewFlight</code>. Still, the refactoring does a remarkable job of cleaning up the method definition and the direct calls of that method.</p>
<p>Applying the refactoring to remove the <code>gate</code> parameter results in a simpler method:</p>
<pre class="source-code">
public Flight ScheduleNewFlight(string id, string dest,
  DateTime depart) {
    Flight flight = new(id, dest, depart) {
        Status = FlightStatus.Inbound
    };
    return ScheduleNewFlight(flight);
}</pre>
<p>Now that we’ve covered the basics of methods, constructors, and parameters, let’s get into the more adventuresome aspects of refactoring methods: working with functions.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Refactoring to functions</h1>
<p>In this section, we’ll explore some aspects of refactoring related to <strong class="bold">functional programming</strong>. Functional programming is<a id="_idIndexMarker231"/> an approach to programming that focuses on functions and their interactions instead of purely on objects and classes.</p>
<p>Functional programming has become more popular over the last decade and that popularity has influenced the C# language with the addition of new forms of syntax.</p>
<p>We’ll explore a few of the syntactical improvements related to functional programming and see how they can help make concise and flexible programs. While this is not a book about functional programming, we’ll still find ourselves exploring a few of these concepts in this section and <a href="B21324_10.xhtml#_idTextAnchor209"><em class="italic">Chapter 10</em></a>, <em class="italic">Defensive </em><em class="italic">Coding Techniques</em>.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Using expression-bodied members</h2>
<p>To start dipping <a id="_idIndexMarker232"/>our toes into the waters of the more functional syntax, let’s take a look at the <code>FindFlightById</code> method in <code>FlightTracker</code>:</p>
<pre class="source-code">
private Flight? FindFlightById(string id) {
    return _flights.FirstOrDefault(f =&gt; f.Id == id);
}</pre>
<p>Clearly, this is a very brief method with only a single statement. At the same time, this method takes up three lines of the screen. Since developers usually leave a blank line above and below each method, the existence of this simple method takes up five lines of the screen. These five lines can be a significant portion of the visible region of the screen, as shown in <em class="italic">Figure 4</em><em class="italic">.13</em>:</p>
<div><div><img alt="Figure 4.13 – The visual footprint of a method with a single statement" src="img/B21324_04_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – The visual footprint of a method with a single statement</p>
<p>Instead, we can take<a id="_idIndexMarker233"/> advantage of expression-bodied members and convert our method to a single-line declaration using this new syntax by activating the <strong class="bold">Use expression body for method</strong> refactoring on the <strong class="bold">Quick Actions</strong> menu with the method selected, as shown in <em class="italic">Figure 4</em><em class="italic">.14</em>:</p>
<div><div><img alt="Figure 4.14 – Triggering the Use expression body for method refactoring^" src="img/B21324_04_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Triggering the Use expression body for method refactoring^</p>
<p>This converts our code to the following, more concise format:</p>
<pre class="source-code">
FindFlightById(string id) <strong class="bold">=&gt;</strong>
  _flights.FirstOrDefault(f =&gt; f.Id == id);</pre>
<p>This style only works for single-line implementations and it isn’t for everyone. However, if you use it for simple code, it<a id="_idIndexMarker234"/> helps reduce the “scrolling penalty” you face with many small methods in a larger file.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Passing functions as parameters with actions</h2>
<p>While expression-bodied members are<a id="_idIndexMarker235"/> less functional programming and more functional syntax, let’s shift gears and get a taste of what’s possible by thinking about methods as <strong class="bold">actions</strong> that you can store in variables and pass around to other methods.</p>
<p>Before we talk about <em class="italic">how</em> to do this, let’s explore <em class="italic">why</em> we’d want to do this by looking at our <code>MarkFlightX</code> methods in <code>FlightTracker</code>. We’ll start with the <code>MarkFlightDelayed</code> method:</p>
<pre class="source-code">
public Flight? MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
<strong class="bold">    flight.DepartureTime = newDepartureTime;</strong>
<strong class="bold">    flight.Status = FlightStatus.Delayed;</strong>
<strong class="bold">    Console.WriteLine($"{id} delayed until        {Format(newDepartureTime)}");</strong>
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</pre>
<p>This method does a few discrete things:</p>
<ul>
<li>It searches for a flight by its ID</li>
<li>If it finds the flight, it updates the properties on the flight and writes out the delay</li>
<li>If the flight can’t be <a id="_idIndexMarker236"/>found, a warning is written to the console</li>
</ul>
<p>On its own, this method is fine. Let’s look at <code>MarkFlightDeparted</code> now:</p>
<pre class="source-code">
public Flight? MarkFlightDeparted(string id,
  DateTime departureTime) {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
<strong class="bold">    flight.DepartureTime = departureTime;</strong>
<strong class="bold">    </strong><strong class="bold">flight.Status = FlightStatus.Departed;</strong>
<strong class="bold">    Console.WriteLine($"{id} departed at {Format(departureTime)}.");</strong>
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</pre>
<p>Compare this method to the last one and you’ll see that there are few differences between them. The method still must find a flight by its ID, check to see whether the flight was found or not, and update the flight. The only difference in this method is what updates occur to the flight and what message gets written to the console.</p>
<p>Let’s round out our look at these methods with a look at <code>MarkFlightArrived</code>:</p>
<pre class="source-code">
public Flight? MarkFlightArrived(string id,
  DateTime arrivalTime, string gate = "TBD") {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
<strong class="bold">    flight.ArrivalTime = arrivalTime;</strong>
<strong class="bold">    flight.Gate = gate;</strong>
<strong class="bold">    flight.Status = FlightStatus.OnTime;</strong>
<strong class="bold">    Console.WriteLine($"{id} arrived at {Format(arrivalTime)}.");</strong>
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</pre>
<p>Here, the pattern repeats itself. The only <a id="_idIndexMarker237"/>major difference between these three methods is what happens if the flight is found.</p>
<p>Thinking about it in that way, consider our logic with the following pseudocode:</p>
<pre class="source-code">
Flight? flight = FindFlightById(id);
if (flight != null) {
  <strong class="bold">ApplyUpdateToFlight(flight);</strong>
} else {
  Console.WriteLine($"{id} could not be found");
}
return flight;</pre>
<p>Here, <code>ApplyUpdateToFlight</code> is a placeholder for some method or function we could apply to the flight object. This is because the <em class="italic">action</em> we take turns out to be the only thing that varies here.</p>
<p>In fact, .NET has a class called an <code>Action</code> that can serve this very purpose:</p>
<pre class="source-code">
private Flight? UpdateFlight(string id,
  <strong class="bold">Action&lt;Flight&gt; updateAction</strong>) {
  Flight? flight = FindFlightById(id);
  if (flight != null) {
    <strong class="bold">updateAction(flight);</strong>
  } else {
    Console.WriteLine($"{id} could not be found");
  }
  return flight;
}</pre>
<p>Here, the <code>updateAction</code> parameter represents a specific function that can be called. What function is it? We don’t know. The<a id="_idIndexMarker238"/> exact function will be provided by whoever called the <code>UpdateFlight</code> method – just like any other parameter.</p>
<p>However, because <code>updateAction</code> is defined as <code>Action&lt;Flight&gt;</code>, we know that the function takes in a single parameter of the <code>Flight</code> type, which is why we can provide that parameter to the function when we invoke it inside this method.</p>
<p>To help the idea of <code>Action</code> syntax sink in a little more, let’s see a few other signatures:</p>
<ul>
<li><code>Action&lt;int&gt;</code> – A function taking in a single integer parameter</li>
<li><code>Action&lt;string, bool&gt;</code> – A function taking in a string and then a boolean</li>
<li><code>Action</code> – A function taking in no parameters at all</li>
</ul>
<p>Now that declaring the <code>Action</code> parameters makes a little more sense syntactically, let’s see how one of our old methods might be updated to use this new method:</p>
<pre class="source-code">
public Flight? MarkFlightDelayed(string id,
  DateTime newDepartureTime) {
  return <strong class="bold">UpdateFlight(id, (flight) =&gt; {</strong>
<strong class="bold">    flight.DepartureTime = newDepartureTime;</strong>
<strong class="bold">    flight.Status = FlightStatus.Delayed;</strong>
<strong class="bold">    Console.WriteLine($"{id} delayed to {Format(newDepartureTime)}");</strong>
<strong class="bold">  });</strong>
}</pre>
<p>Here, the <code>MarkFlightDelayed</code> method calls directly into the <code>UpdateFlight</code> method and provides an <code>Action&lt;Flight&gt;</code> in the form of the <code>(flight) =&gt; { }</code> syntax.</p>
<p>When the <code>UpdateFlight</code> method<a id="_idIndexMarker239"/> runs, it checks to see whether the flight exists and, if it does, the method calls the arrow function we provided to actually update the flight.</p>
<p>If the syntax of this is difficult, here’s a different way of representing the same thing, by using a local variable to hold the <code>Action&lt;Flight&gt;</code>:</p>
<pre class="source-code">
<strong class="bold">Action&lt;Flight&gt; updateAction = (flight) =&gt; {</strong>
  flight.DepartureTime = newDepartureTime;
  flight.Status = FlightStatus.Delayed;
  Console.WriteLine($"{id} delayed to {Format(newDepartureTime)}");
<strong class="bold">};</strong>
return UpdateFlight(id, <strong class="bold">updateAction</strong>);</pre>
<p>It’s undoubtedly possible to have a happy and productive career as a developer without declaring an <code>Action</code> variable. However, I’ve found that when I’m able to think in terms of discrete <code>Actions</code>, it can open some very interesting and flexible solutions to problems.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Returning data from Actions with Funcs</h2>
<p>Before we move on to talking<a id="_idIndexMarker240"/> about static and extension methods, let’s take a brief look at <code>Funcs</code>.</p>
<p>A <code>Action</code> in that it represents a <em class="italic">function</em> that can be invoked and potentially passed parameters. However, while <code>Actions</code> do not return any results, <code>Funcs</code> do.</p>
<p>Let’s examine a simple C# method that <a id="_idIndexMarker242"/>adds two numbers together and displays their result in an equation string:</p>
<pre class="source-code">
public <strong class="bold">void</strong> AddAction(<strong class="bold">int</strong> x, <strong class="bold">int</strong> y) {
    int sum = x + y;
    Console.WriteLine($"{x} + {y} is {sum}");
}</pre>
<p>This method has a <code>void</code> return type, meaning it doesn’t return any value. As a result, it could be stored in an <code>Action</code> and invoked in that way:</p>
<pre class="source-code">
<strong class="bold">Action&lt;int, int&gt;</strong> myAction = AddAction;
myAction(2, 2);</pre>
<p>Now, let’s look at a slightly different version of the <code>Add</code> method:</p>
<pre class="source-code">
public <strong class="bold">string</strong> AddFunc(<strong class="bold">int</strong> x, <strong class="bold">int</strong> y) {
    int sum = x + y;
    return $"{x} + {y} is {sum}";
}</pre>
<p>Here, <code>AddFunc</code> has a return type of <code>string</code>. Because the method no longer returns a void, it can no longer be considered an <code>Action</code> and is now considered a <code>Func</code> because it returns some value.</p>
<p>As a result, if we wanted to store a reference to this method, we’d need to do so in a <code>Func</code>, as shown here:</p>
<pre class="source-code">
<strong class="bold">Func&lt;int, int, string&gt;</strong> myFunc = AddFunc;
<strong class="bold">string</strong> equation = myFunc(2, 2);
Console.WriteLine(equation);</pre>
<p>Note that in addition to using a <code>Func</code> instead of an <code>Action</code>, we now have a third <code>Func</code> represents the return type of the <code>Func</code>. In the case of <code>myFunc</code>, the third generic type parameter indicates that <code>AddFunc</code> returns a <code>string</code>.</p>
<p><code>Action</code> and <code>Func</code> are very closely related with the only significant difference being that <code>Func</code> returns a value. In practice, I tend to use <code>Action</code> when I want to accomplish something, such as in the <a id="_idIndexMarker244"/>earlier example of updating flights. On the other hand, I tend to use <code>Func</code> to determine when to do something or how to get a specific value I need.</p>
<p>For example, I might declare a method that takes in a <code>Func&lt;Flight, bool&gt;</code> that it uses to determine whether a flight from a list of flights should be displayed:</p>
<pre class="source-code">
public void DisplayMatchingFlights(List&lt;Flight&gt; flights,
  <strong class="bold">Func&lt;Flight, bool&gt; shouldDisplay</strong>) {
  foreach (Flight flight in flights) {
    if (<strong class="bold">shouldDisplay(flight)</strong>) {
      Console.WriteLine(flight);
    }
  }
}</pre>
<p>This method calls the <code>shouldDisplay</code> Func for every flight in the list in order to determine whether it should be displayed. Flights only display if the <code>shouldDisplay</code> Func returns <code>true</code> for that flight.</p>
<p>This structure allows the same method to be used for different scenarios, including the following:</p>
<ul>
<li>Listing upcoming flights</li>
<li>Listing delayed flights</li>
<li>Listing flights heading to a specific airport</li>
</ul>
<p>The only difference between these is what the <code>shouldDisplay</code> parameter holds.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Introducing static methods and extension methods</h1>
<p>Now that we’ve explored some of the more functional aspects of method refactoring, let’s take a look at some of the features that helped revolutionize .NET: <strong class="bold">static methods</strong> and <strong class="bold">extension methods</strong>.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Making methods static</h2>
<p>Sometimes, your classes will <a id="_idIndexMarker245"/>have methods that don’t work directly with instance members (fields, properties, or non-static methods) of that class. For example, <code>FlightTracker</code> has a <code>Format</code> method that converts a <code>DateTime</code> to a string resembling “Wed Jul 12 23:14 PM”:</p>
<pre class="source-code">
private string Format(DateTime time) {
    return time.ToString("ddd MMM dd HH:mm tt");
}</pre>
<p>Here, <code>Format</code> doesn’t rely on anything other than the parameters it is provided to calculate a result. Because of this, we can make <code>Format</code> a static method.</p>
<p>Static methods are methods associated with the class itself and not with an instance of the class. As a result, you don’t need to instantiate an instance of the class to call them. The C# compiler is also able to make occasional optimizations surrounding static code that can result in faster code.</p>
<p>Typically, static methods can also be <a id="_idIndexMarker246"/>considered <strong class="bold">pure methods</strong> – that is to say, methods without direct side effects that always produce the same result when given the same input.</p>
<p>As shown in <em class="italic">Figure 4</em><em class="italic">.14</em>, you can mark a method as static by adding the <code>static</code> keyword after the access modifier or by choosing the <strong class="bold">Make static</strong> option on the <strong class="bold">Quick </strong><strong class="bold">Actions</strong> menu:</p>
<div><div><img alt="Figure 4.15 – Moving a method to a static method" src="img/B21324_04_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Moving a method to a static method</p>
<p>The static version of <strong class="bold">Format</strong> looks very<a id="_idIndexMarker247"/> similar and works almost identically:</p>
<pre class="source-code">
private <strong class="bold">static </strong>string Format(DateTime time) {
    return time.ToString("ddd MMM dd HH:mm tt");
}</pre>
<p>The <code>Format</code> method can still be called simply with <code>Format(DateTime.Now)</code> as it could before, but adding static also allows you to call it from the class itself, such as <code>FlightTracker.Format(DateTime.Now)</code>.</p>
<p>Marking a method as static has a few advantages:</p>
<ul>
<li>The compiler can make optimizations resulting in faster runtime performance</li>
<li>Code can call the static method without needing to instantiate the class</li>
<li>The static method could be converted to an extension method, as we’ll see later</li>
</ul>
<p>The <code>static</code> keyword may seem like a great thing to use everywhere you can due to these added features. Unfortunately, <code>static</code> has some drawbacks as well. Marking a method as <code>static</code> also means it can no longer call non-<code>static</code> methods or access instance-level data.</p>
<p>There are certainly many uses for <code>static</code>, but it’s still something that many developers find distasteful or consider an anti-pattern in excess.</p>
<p>Personally, I find <code>static</code> is appropriate for “helper methods” and, in some cases, to simplify unit testing complex classes that can be complex to instantiate in testing scenarios. However, I draw the line at making fields <code>static</code> whenever possible, as <code>static</code> data can lead to <a id="_idIndexMarker248"/>many problems in developing and testing applications.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Moving static members to another type</h2>
<p>Sometimes, it doesn’t make sense<a id="_idIndexMarker249"/> for a static method to remain in the class it started in.</p>
<p>For example, our <code>Format</code> method takes any <code>DateTime</code> and returns a customized string appropriate to Cloudy Skies Airlines’ business needs. This logic is currently inside of the <code>FlightTracker</code> class, and yet is completely unrelated to tracking flights and could be useful to have in any number of places throughout their application.</p>
<p>In this scenario, it makes sense to pull <code>Format</code> into a different class where other developers can more readily discover these formatting capabilities.</p>
<p>Visual Studio provides a built-in refactoring for this. To use it, select a static method and open the <strong class="bold">Quick Actions</strong> menu, then click <strong class="bold">Move static members to another type...</strong>, as shown in <em class="italic">Figure 4</em><em class="italic">.16</em>:</p>
<div><div><img alt="Figure 4.16 – Moving static members to another type" src="img/B21324_04_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Moving static members to another type</p>
<p>Next, you will be prompted to select the Type your static methods should be moved to. This can be the name of a new class if you don’t currently have a class suitable for this. For Cloudy Skies, there is no existing Type that should own this, so creating one named <code>DateHelpers</code> makes sense.</p>
<p>Additionally, you will be asked to check or uncheck the static methods you want to move with an option to <strong class="bold">Select Dependents</strong> (see <em class="italic">Figure 4</em><em class="italic">.17</em>) and select any methods that your selected static methods call:</p>
<div><div><img alt="Figure 4.17 – Selecting the destination type and the members to move" src="img/B21324_04_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Selecting the destination type and the members to move</p>
<p>Click <strong class="bold">OK</strong> to move your<a id="_idIndexMarker250"/> selected method and create a new class.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The current behavior of Visual Studio is to keep your method’s current access modifier and create the new static class as <code>internal</code>. This may introduce compiler errors if your method was <code>private</code>, as code at the old location will no longer be able to access your code. I recommend changing your static class and its methods to <code>public</code> to avoid issues.</p>
<p>Here’s the resulting <strong class="bold">static class</strong> after <a id="_idIndexMarker251"/>adjusting its modifiers:</p>
<pre class="source-code">
public <strong class="bold">static</strong> class DateHelpers {
    public <strong class="bold">static</strong> string Format(DateTime time) {
        return time.ToString("ddd MMM dd HH:mm tt");
    }
}</pre>
<p>Now we have a dedicated class just for “helper methods” associated with dates and times.</p>
<p class="callout-heading">Static classes</p>
<p class="callout">If you’re not familiar with static classes, a static class can only have static methods in it and cannot be instantiated or inherited from. Static classes are required for extension methods.</p>
<p>The refactoring we<a id="_idIndexMarker252"/> just performed also updated any code that was using the old <code>Format</code> method to point to <code>DateTimeHelpers.Format</code>. For example, in <code>FlightTracker</code>, the <code>MarkFlightArrived</code> method’s flight logging now says <code>Console.WriteLine($"{id} arrived </code><code>at {DateHelpers.Format(arrivalTime)}.");</code>.</p>
<p>By pulling static members into their own dedicated type, we’ve created a home where date-related logic can live and help a wide variety of classes, and we’ve made our <code>FlightTracker</code> class more focused on its core job instead of being focused on date formatting as well as flight tracking.</p>
<p>Unfortunately, this change has somewhat hurt the readability of our code because callers must now specify <code>DateHelpers.Format</code> instead of just <code>Format</code>. An extension method can help with this, as we’ll see next.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>Creating extension methods</h2>
<p>Extension methods allow<a id="_idIndexMarker253"/> you to “extend” an existing Type by adding your own static methods that appear like they’re part of that Type.</p>
<p>That might sound intimidating, but if you’ve used LINQ, you’ve seen extension methods in action. Let’s look at the <code>FindFlightById</code> method in <code>FlightTracker</code> as an example:</p>
<pre class="source-code">
private Flight? FindFlightById(string id) =&gt;
    <strong class="bold">_flights.FirstOrDefault(f =&gt; f.Id == id)</strong>;</pre>
<p>Here, <code>_flights</code> is defined as a <code>List&lt;Flight&gt;</code>. Given that the code to find a flight by its ID, it’s understandable to suspect that <code>List</code> must have a method called <code>FirstOrDefault</code>; however, it does not.</p>
<p>Instead, the <code>FirstOrDefault</code> method is not defined on the <code>List&lt;T&gt;</code> type in the <code>System.Collections.Generic</code> namespace, but rather is defined as an extension method in a static class called <code>Enumerable</code> in the <code>System.Linq</code> namespace.</p>
<p>In other words, it is <a id="_idIndexMarker254"/>perfectly feasible to rewrite our code from earlier to explicitly use the <code>Enumerable</code> class, as follows:</p>
<pre class="source-code">
private Flight? FindFlightById(string id) =&gt;
    <strong class="bold">Enumerable.FirstOrDefault(_flights, f =&gt; f.Id == id);</strong></pre>
<p>While this is perfectly valid code, nobody I’ve ever worked with writes code in this way because using <code>FirstOrDefault</code> as an extension method is far more intuitive and readable.</p>
<p>This highlights the key point of extension methods: <em class="italic">extension methods allow you to add new features to existing classes in a way that appears like those methods were present on the object to begin with</em>, resulting in more intuitive code.</p>
<p>To declare a method as an extension method, the following things must be true:</p>
<ul>
<li>The method must be static</li>
<li>The method must be inside a static class</li>
<li>The first parameter of the method must start with the <code>this</code> keyword</li>
</ul>
<p>Our <code>DateHelpers</code> class and its <code>Format</code> method are both static, which means we can convert the method to an extension method by adding the <code>this</code> keyword to the method signature:</p>
<pre class="source-code">
public static class DateHelpers {
    public static string Format(<strong class="bold">this</strong> DateTime time) {
        return time.ToString("ddd MMM dd HH:mm tt");
    }
}</pre>
<p>Moving a static method to an extension method doesn’t mean you have to use it as an extension method and so our previous code will still compile. However, in order to get the most value out of our extension method, we should update prior code to take advantage of its new syntax.</p>
<p>Let’s take another look at the <code>MarkFlightArrived</code> method in <code>FlightTracker</code>. This time, if you delete the <code>DateFormatHelpers.Format(arrivalTime)</code>, instead write <code>arrivalTime.For</code>, and <a id="_idIndexMarker255"/>allow Visual Studio’s <strong class="bold">IntelliSense</strong> to suggest values, it will list your new extension method:</p>
<div><div><img alt="Figure 4.18 – IntelliSense suggesting the new extension method" src="img/B21324_04_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – IntelliSense suggesting the new extension method</p>
<p>Because <code>arrivalTime</code> is a <code>DateTime</code> and our extension method is built to work on any <code>DateTime</code>, the new <code>Format</code> method we wrote appears here on the <code>DateTime</code> type provided in .NET through the power of extension methods.</p>
<p>Rewriting the call to <code>arrivalTime.Format()</code> has the correct effect of calling out to the extension method, resulting in a far more readable experience.</p>
<p>If you’d prefer, you can still call out to the <code>Format</code> method via <code>DateHelpers.Format(arrivalTime)</code>. Introducing an extension method just gives you another option for how your syntax is structured.</p>
<p>The downsides of extension methods are, primarily, as follows:</p>
<ul>
<li>Extension methods require the use of static, which some teams avoid because it tends to spread throughout your code</li>
<li>It can be confusing that you’re using an extension method</li>
<li>It can be confusing where the new extension methods are defined</li>
</ul>
<p>Thankfully, Visual Studio allows you to go to the definition of any method, member, or type simply by holding <em class="italic">Ctrl</em> and clicking on the item you want to navigate to. Alternatively, you can select the identifier and press <em class="italic">F12</em> on your keyboard or right-click on it and choose <strong class="bold">Go To Definition</strong> to navigate to where the extension method is declared.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Reviewing and testing our refactored code</h1>
<p>Over the course of this chapter, we took a repetitive <code>FlightTracker</code> class and restructured it to ensure that its method <a id="_idIndexMarker256"/>signatures were more consistent and that common logic was reused wherever possible.</p>
<p class="callout-heading">Refactored code</p>
<p class="callout">The final refactored code from this chapter is available in the <a href="https://github.com/PacktPublishing/Refactoring-with-CSharp">https://github.com/PacktPublishing/Refactoring-with-CSharp</a> repository inside of the <code>Chapter04/Ch4RefactoredCode</code> folder.</p>
<p>Before we move on, we should ensure that all tests still pass by running the unit tests from the <strong class="bold">Test</strong> menu and then selecting the <strong class="bold">Run All Tests</strong> menu item.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Summary</h1>
<p>In this chapter, we saw how various methods, constructors, and parameter refactorings can be applied to keep your code orderly. We saw how overloading and chaining together methods and constructors gives you more options, while renaming, adding, removing, and reordering parameters helps ensure consistency.</p>
<p>Near the end of this chapter, we covered <code>Actions</code>, <code>Funcs</code>, static methods, and extension methods, and showed how thinking about your code in terms of small, reusable functions can help solve certain types of problems more effectively.</p>
<p>In the next chapter, we’ll cover object-oriented refactoring techniques and revisit our parameter refactorings in this chapter by exploring how large sets of parameters can be brought under control by extracting classes.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Questions</h1>
<ol>
<li>Are there any areas of your code where you seem to be confused more frequently by the parameter ordering or naming?</li>
<li>Can you think of any places in your code where slightly different actions are performed based on the same or similar conditions? If so, does moving to use an <code>Action</code> or a <code>Func</code> make sense?</li>
<li>Does your code have a set of “helper methods” that might make sense to make static and put into a static class? If so, would switching to extension methods improve your code elsewhere?</li>
</ol>
<h1 id="_idParaDest-101"><a id="_idTextAnchor100"/>Further reading</h1>
<p>You can find more information about the materials discussed in this chapter at the following URLs:</p>
<ul>
<li><em class="italic">Refactor into pure </em><em class="italic">functions</em>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions">https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-pure-functions</a></li>
<li><em class="italic">Action-Oriented </em><em class="italic">C#</em>: <a href="https://killalldefects.com/2019/09/15/action-oriented-c/">https://killalldefects.com/2019/09/15/action-oriented-c/</a></li>
<li><em class="italic">Refactor using an extension </em><em class="italic">method</em>: <a href="https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method">https://learn.microsoft.com/en-us/dotnet/standard/linq/refactor-extension-method</a></li>
<li><em class="italic">Named and Optional </em><em class="italic">Arguments</em>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments">https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/named-and-optional-arguments</a></li>
</ul>
</div>
</body></html>