- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: 'Dynamic Motion: Implementing Movement and Spawning'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态运动：实现移动和生成
- en: In the previous chapter, we learned about the basics of scripting, so now, let’s
    create the first script for our game. We will see the basics of how to move objects
    through scripting using the `Transform` component, which will be applied to the
    movement of our player with the keyboard keys, the constant movement of bullets,
    and other object movements. Also, we will see how to create and destroy objects
    during the game, such as the bullets our player and enemy shoot and the enemy
    waves that will be generated during the game (also called enemy spawners). These
    actions can be used in several other scenarios, so we will explore a few in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了脚本的基础知识，所以现在，让我们为我们的游戏创建第一个脚本。我们将看到如何通过脚本使用`Transform`组件来移动物体，这将应用于玩家通过键盘按键的移动、子弹的持续移动以及其他物体的移动。此外，我们还将了解如何在游戏中创建和销毁物体，例如玩家和敌人射击的子弹以及游戏过程中将生成的敌人波（也称为敌人生成器）。这些操作可以应用于多种其他场景，因此我们将在本章中探讨其中的一些。
- en: 'In this chapter, we will examine the following scripting concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下脚本概念：
- en: Implementing movement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现移动
- en: Implementing spawning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现生成
- en: Using the new Input System
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的输入系统
- en: We will start by scripting components to move our character with the keyboard,
    and then we will make our player shoot bullets. Something to consider is that
    we are going to first see the C# version and then show the Visual Scripting equivalent
    in each section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写脚本组件来使用键盘移动我们的角色，然后我们将让我们的玩家射击子弹。需要考虑的是，我们将首先展示C#版本，然后在每个部分展示相应的视觉脚本等效版本。
- en: Implementing movement
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现移动
- en: 'Almost every object in a game moves one way or another: the player character
    with the keyboard, enemies through AI, bullets that simply move forward, and so
    on. There are several ways of moving objects in Unity, so we will start with the
    simplest one— that is, using the `Transform` component.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎游戏中每个物体都会以某种方式移动：玩家角色通过键盘操作，敌人通过人工智能，子弹简单地向前移动，等等。在Unity中，有几种移动物体的方法，因此我们将从最简单的一种开始——那就是使用`Transform`组件。
- en: 'In this section, we will examine the following movement concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下运动概念：
- en: Moving objects through `Transform`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Transform`移动物体
- en: Using input
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入
- en: Understanding Delta Time
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Delta Time
- en: First, we will explore how to access the `Transform` component in our script
    to drive player movement, later applying movement based on the player’s keyboard
    input. Finally, we will explore the concept of *deltatime* to make sure that movement
    speeds are consistent on every computer. We will start learning about the `Transform`
    API to make a simple movement script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨如何在脚本中访问`Transform`组件以驱动玩家移动，稍后根据玩家的键盘输入应用移动。最后，我们将探讨*delta time*的概念，以确保在每台计算机上移动速度的一致性。我们将开始学习`Transform`
    API以制作一个简单的移动脚本。
- en: Moving objects through Transform
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Transform移动物体
- en: '`Transform` is the component that holds the translation, rotation, and scale
    of an object, so every movement system such as physics or pathfinding will affect
    this component. Sometimes, we want to move the object in a specific way according
    to our game by creating our own script, which will handle the movement calculations
    we need and modify `Transform` to apply them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform`是包含物体平移、旋转和缩放的组件，因此每个运动系统，如物理或路径查找，都会影响此组件。有时，我们想要根据我们的游戏以特定方式移动物体，通过创建自己的脚本来实现，该脚本将处理我们需要的移动计算并修改`Transform`以应用它们。'
- en: 'One concept applicable here is that components can alter other components.
    The main way of coding in Unity is to create components that interact with other
    components. Here, the idea is to create one that accesses another and tells it
    to do something—in this case, to move. To create a script that tells `Transform`
    to move, do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里适用的一个概念是组件可以改变其他组件。在Unity中编码的主要方式是创建与其他组件交互的组件。在这里，想法是创建一个可以访问另一个组件并告诉它做某事的组件——在这种情况下，就是移动。要创建一个告诉`Transform`移动的脚本，请执行以下操作：
- en: 'Create and add a script called `PlayerMovement` to our character, as we did
    in the previous chapter. In this case, it will be the animated 3D model we downloaded
    previously, named **Polyart_Mesh** (drag the 3D asset from the **Project** view
    to the scene). Remember to move the script to the **Scripts** folder after creation:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加一个名为 `PlayerMovement` 的脚本到我们的角色中，就像我们在上一章中所做的那样。在这种情况下，它将是之前下载的动画 3D 模型，命名为
    **Polyart_Mesh**（从 **项目** 视图中拖动 3D 资产到场景中）。记住在创建后，将脚本移动到 **脚本** 文件夹：
- en: '![](img/B21361_06_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_01.png)'
- en: 'Figure 6.1: Creating a PlayerMovement script in the character'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：在角色中创建 PlayerMovement 脚本
- en: Double-click the created script asset to open an IDE to edit the code.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击创建的脚本资产以打开 IDE 并编辑代码。
- en: 'The character is moving, and the movement is applied to every frame. So this
    script will use only the `Update` function or method, and we can remove `Start`
    (it is a good practice to remove unused functions):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角色正在移动，并且这种移动会应用到每一帧。因此，这个脚本将只使用 `Update` 函数或方法，我们可以移除 `Start`（移除未使用的函数是一种良好的实践）：
- en: '![](img/B21361_06_02_PRE_BOOK.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_02_PRE_BOOK.png)'
- en: 'Figure 6.2: A component with just the Update event function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：仅包含 Update 事件函数的组件
- en: 'To move our object along its local forward axis (the *z* axis), add the `transform.Translate(0,0,1);`
    line to the `Update` function, as shown in *Figure 6.3*:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使我们的对象沿着其局部前进轴（即 *z* 轴）移动，请在 `Update` 函数中添加 `transform.Translate(0,0,1);` 这一行，如图
    *图6.3* 所示：
- en: Every component has access to a `Transform` field (to be specific, a **getter**)
    that is a reference to the `Transform` of the GameObject the component is placed
    in. Through this field, we can access the `Translate` function of the `Transform`,
    which will receive the offset to apply to the `x`, `y`, and `z` local coordinates.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个组件都可以访问一个 `Transform` 字段（具体来说，是一个 **getter**），它是对放置该组件的 GameObject 的 `Transform`
    的引用。通过这个字段，我们可以访问 `Transform` 的 `Translate` 函数，该函数将接收应用到 `x`、`y` 和 `z` 本地坐标的偏移量。
- en: '![](img/B21361_06_03_PRE_BOOK.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_06_03_PRE_BOOK.png)'
- en: 'Figure 6.3: A simple Move Forward script'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.3：一个简单的向前移动脚本
- en: Save the file, and play the game to see the movement. Ensure that the camera
    points at the character to properly see the effect of the script. To do that,
    remember that you can select the camera in the hierarchy and move and rotate it
    until the character falls inside the frustum.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并玩游戏以查看移动效果。确保相机指向角色，以便正确地看到脚本的效果。为此，请记住您可以在层次结构中选择相机，并将其移动和旋转，直到角色位于视锥体内。
- en: 'Now that we have implemented a simple movement for the player, you will notice
    that they are moving too fast. That’s because we are using a fixed speed of 1
    meter, and because `Update` is executing all frames, we are moving 1 meter per
    frame. In a standard 30 **Frames Per Second** (**FPS**) game, the player would
    move 30 meters per second, which is too much, but our computer is perhaps running
    the game with way more FPS than that. We can control the player’s speed by adding
    a `speed` field and using the value set in the editor instead of the fixed value
    of 1\. You can see one way to do this in *Figure 6.4*, but remember the other
    options we discussed in *Chapter 5*, *Unleashing the Power of C# and Visual Scripting*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为玩家实现了简单的移动，您会注意到他们移动得太快。这是因为我们正在使用固定的速度 1 米，并且因为 `Update` 在每一帧执行，所以我们每帧移动
    1 米。在一个标准的 30 **每秒帧数**（**FPS**）的游戏中，玩家会移动 30 米每秒，这太多了，但我们的计算机可能以远高于这个 FPS 运行游戏。我们可以通过添加一个
    `speed` 字段并使用编辑器中设置的值而不是固定的 1 米值来控制玩家的速度。您可以在 *图6.4* 中看到一种实现方式，但请记住我们在 *第五章* 中讨论的其他选项，*释放
    C# 和视觉脚本的力量*：
- en: '![](img/B21361_06_04_PRE_BOOK.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_04_PRE_BOOK.png)'
- en: 'Figure 6.4: Creating a speed field and using it as the z speed of the movement
    script'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：创建速度字段并将其用作移动脚本的 z 速度
- en: 'Now, if you save the script to apply the changes and set the **Speed** of the
    player in the Editor, you can play the game and see the results. In my case, I
    used `0.1`, but you might need another value (there’s more on this in the *Understanding
    Delta Time* section):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您保存脚本以应用更改并在编辑器中设置玩家的 **速度**，您就可以玩游戏并看到结果。在我的情况下，我使用了 `0.1`，但您可能需要另一个值（关于这一点，请参阅
    *理解 Delta Time* 部分）：
- en: '![](img/B21361_06_05_PRE_BOOK.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_05_PRE_BOOK.png)'
- en: 'Figure 6.5: Setting a speed of 0.1 meters per frame'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：设置每帧 0.1 米的速度
- en: Now, for the Visual Scripting version, remember not to mix the C# and Visual
    Scripting versions of our scripts; this is not because it is impossible but because
    we want to keep things simple for now. So you can either delete the script from
    the player object and add the Visual Scripting version, or you can create two
    player objects and enable and disable them to try both versions. I recommend creating
    one project for the C# version of the scripts and then creating a second project
    to experiment with the Visual Script version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于视觉脚本版本，请记住不要混合我们的脚本的 C# 和视觉脚本版本；这并不是因为它不可能，而是因为我们现在想保持事情简单。所以你可以从玩家对象中删除脚本并添加视觉脚本版本，或者你可以创建两个玩家对象并启用和禁用它们来尝试两个版本。我建议为脚本的
    C# 版本创建一个项目，然后创建第二个项目来实验视觉脚本版本。
- en: 'The Visual Scripting Graph of this script will look like the following image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的视觉脚本图将如下所示：
- en: '![](img/B21361_06_06_PRE_BOOK.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_06_PRE_BOOK.png)'
- en: 'Figure 6.6: Setting a speed of 0.1 meters per frame'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：设置每帧速度为 0.1 米
- en: As you can see, we added a **Script Machine** component to our `Player` GameObject.
    Then, we pressed the **New** button in the **Script Machine** component to create
    a new **Graph** called `PlayerMovement`. We also created a **Float** variable
    called `speed` with the value of `0.1`. In the **Graph**, we added the **On Update**
    event node and attached it to the **Translate** (**X,Y,Z**) node of the **Transform**,
    which, similar to the C# version, will move along the local axes of the object.
    Finally, we connected the **Z** parameter pin of **Translate** to the `GetVariable`
    node, representing the speed we created in the GameObject. If you compare this
    **Graph** with the code we used in the C# version, they are essentially the same
    **Update** method and `Translate` function. If you don’t remember how to create
    this **Graph**, you can go back to *Chapter 5*, *Unleashing the Power of C# and
    Visual Scripting*, to recap the process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在 `Player` GameObject 中添加了一个 **脚本机器**组件。然后，我们在 **脚本机器**组件中按下 **新建**按钮来创建一个名为
    `PlayerMovement` 的新 **图**。我们还创建了一个名为 `speed` 的 **浮点**变量，其值为 `0.1`。在 **图**中，我们添加了
    **On Update** 事件节点并将其连接到 **Transform** 的 **Translate**（**X,Y,Z**）节点，这与 C# 版本类似，将沿着对象的局部轴移动。最后，我们将
    **Translate** 的 **Z** 参数引脚连接到表示我们在 GameObject 中创建的速度的 `GetVariable` 节点。如果你将此 **图**与我们在
    C# 版本中使用的代码进行比较，它们基本上是相同的 **Update** 方法和 `Translate` 函数。如果你不记得如何创建此 **图**，你可以回到
    *第 5 章*，*释放 C# 和视觉脚本的力量*，来回顾这个过程。
- en: You will notice that the player will move automatically. Now, let’s see how
    to execute the movement based on **player input** such as the keyboard and mouse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到玩家会自动移动。现在，让我们看看如何根据 **玩家输入**（如键盘和鼠标）来执行移动。
- en: Using Input
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入
- en: Unlike **NPCs** (**non-playable characters**) in a videogame, we want the player’s
    movement to be driven by the user’s input, based on which keys they press when
    they play, the mouse movement, and so on. To know whether a certain key has been
    pressed, such as the *Up* arrow, we can use the `Input.GetKey(KeyCode.W)` line,
    which will return a Boolean, indicating whether the key specified in the `KeyCode`
    enum is pressed, which is *W* in this case. This is usually the main setup for
    keyboard controllers in 3D video games. We can combine the `GetKey` function with
    an `If` statement to make the translation execute when the key is pressed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与电子游戏中的 **NPC**（**不可玩角色**）不同，我们希望玩家的移动由用户的输入驱动，基于他们在玩游戏时按下的键、鼠标移动等。为了知道是否按下了某个键，例如
    *向上* 方向键，我们可以使用 `Input.GetKey(KeyCode.W)` 行，这将返回一个布尔值，指示 `KeyCode` 枚举中指定的键是否被按下，在这种情况下是
    *W*。这通常是 3D 电子游戏中键盘控制器的主要设置。我们可以将 `GetKey` 函数与一个 `If` 语句结合使用，以便在按键时执行翻译。
- en: 'Let’s start by implementing the keyboard movement by following these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们按照以下步骤实现键盘移动：
- en: 'Make the forward movement execute only when the *W* key is pressed using the
    code, as shown in the next screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代码使前进移动仅在按下 *W* 键时执行，如下一个截图所示：
- en: '![](img/B21361_06_07_PRE_BOOK.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_07_PRE_BOOK.png)'
- en: 'Figure 6.7: Conditioning the movement until the W key is pressed'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：在按下 W 键之前条件化移动
- en: 'We can add other movement directions, using more `If` statements to move backward
    and *A* and *D* to move left and right, as shown in the following screenshot.
    Notice how we use the minus sign to inverse the speed when we need to move in
    the opposite axis direction:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用更多的`If`语句添加其他移动方向，使用*A*和*D*键来左右移动，如下面的截图所示。注意我们如何使用负号在需要沿相反轴方向移动时反转速度：
- en: '![](img/B21361_06_08_PRE_BOOK.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_08_PRE_BOOK.png)'
- en: 'Figure 6.8: Checking the W, S, A, and D key pressure'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：检查W、S、A和D键的压力
- en: 'If you also want to consider the arrow keys, you can use an `OR` inside `if`,
    as shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还想考虑箭头键，你可以在`if`中使用`OR`，如下面的截图所示：
- en: '![](img/B21361_06_09_PRE_BOOK.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_09_PRE_BOOK.png)'
- en: 'Figure 6.9: Checking the W, S, A, D, and arrow key pressure'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：检查W、S、A、D和箭头键的压力
- en: Save the changes, and test the movement in **Play** mode.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改，并在**播放**模式下测试移动。
- en: With these lines of code, we have implemented basic movement using the *WASD*
    keys. Something to take into account is that, first, we have another way to map
    several keys to a single action by configuring the Input Manager—a place where
    action mappings can be created. Second, at the time of writing, Unity has released
    a new Input System that is more extensible than this one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些代码行，我们使用*WASD*键实现了基本的移动。需要注意的是，首先，我们还有另一种方法通过配置输入管理器将多个键映射到单个动作——这是一个可以创建动作映射的地方。其次，在撰写本文时，Unity发布了一个比这个更可扩展的新输入系统。
- en: For now, we will use this one because it is simple enough to make our introduction
    to scripting with Unity easier, but in games with complex input, it is recommended
    that we look for more advanced tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用这个版本，因为它足够简单，可以使我们使用Unity进行脚本编写的介绍更容易，但在具有复杂输入的游戏中，我们建议寻找更高级的工具。
- en: 'Now, for the Visual Scripting version, the Graph will look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于Visual Scripting版本，图将看起来像这样：
- en: '![](img/B21361_06_10_PRE_BOOK.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_10_PRE_BOOK.png)'
- en: 'Figure 6.10: Input movement in Visual Scripting'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：Visual Scripting中的输入移动
- en: As you can see, the graph has grown in size considerably compared to the C#
    version, which serves as an example of why developers prefer to code instead of
    using visual tools. Of course, we have several ways to split this graph into smaller
    chunks and make it more readable. Also, I needed to squeeze the nodes together
    for them to be in the same image.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与C#版本相比，图的大小显著增加，这作为了开发者为什么更喜欢编码而不是使用可视化工具的例子。当然，我们有几种方法可以将这个图分成更小的块，使其更易于阅读。此外，我需要将节点挤压在一起，以便它们在同一张图像中。
- en: In the preceding screenshot, we can only see an example graph to move forward
    and backward, but you can easily extrapolate the necessary steps for lateral movement
    based on this graph. As usual, you can also check the GitHub repository of the
    project to see the completed files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们只能看到一个用于前后移动的示例图，但你可以很容易地根据这个图推断出横向移动所需的步骤。像往常一样，你还可以查看项目的GitHub仓库以查看完成的文件。
- en: Notice all the similarities to the C# version; we chained `If` nodes to the
    **On Update** event node in a way that if the first `If` node condition is `true`,
    it will execute the **Translate** in the player’s forward direction. If that condition
    is `false`, we chain the **False** output node to another **If** that checks the
    pressure of the other keys, and then, we move backward using the **Multiply (Scalar)**
    node to inverse the speed. You can see nodes like `If` that have more than one
    **Flow Output** pin to branch the execution of the code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有与C#版本的相似之处；我们将`If`节点链接到**On Update**事件节点，如果第一个`If`节点条件为`true`，它将在玩家的前进方向上执行**Translate**。如果该条件为`false`，我们将**False**输出节点链接到另一个检查其他按键压力的**If**节点，然后，我们使用**Multiply
    (Scalar)**节点反向速度来向后移动。你可以看到像`If`这样的节点，它们有多个**Flow Output**引脚来分支代码的执行。
- en: 'Also note the usage of the **GetKey (Key)** node, the Visual Scripting version
    of the same **GetKey** function we used previously. When looking at this node
    in the **Search** box, you will see all the versions of the function, and in this
    case, we selected the **GetKey(Key)** version; the one that receives a name (string)
    works differently, so we are not covering that one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意**GetKey (Key)**节点的使用，这是之前使用的相同**GetKey**函数的Visual Scripting版本。当你在**搜索**框中查看此节点时，你会看到该函数的所有版本，在这种情况下，我们选择了**GetKey(Key)**版本；接收名称（字符串）的那个版本工作方式不同，所以我们不涉及那个：
- en: '![](img/B21361_06_11_PRE_BOOK.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_11_PRE_BOOK.png)'
- en: 'Figure 6.11: All versions of Input GetKey'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：所有版本的Input GetKey
- en: 'We also used the `Or` node to combine the two **GetKey (Key)** functions into
    one condition to give to the `If`. These conditional operators can be found in
    the **Logic** category of the **Search** box:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`Or`节点将两个**GetKey (Key)**函数组合成一个条件，提供给`If`。这些条件运算符可以在**搜索**框的**逻辑**类别中找到：
- en: '![](img/B21361_06_12_PRE_BOOK.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_12_PRE_BOOK.png)'
- en: 'Figure 6.12: The Boolean Logic operators'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：布尔逻辑运算符
- en: One thing to highlight is the usage of the **Multiply** node to multiply the
    value of the speed variable by –1\. We needed to create a **Float Literal** node
    to represent the –1 value. Then, surely, all programmers will notice some limitations
    regarding how we used the `If` node’s `True` and `False` output pins, but we will
    address that in a moment. Finally, consider that this implementation has the problem
    of blocking the second input read if the first is successful; we will discuss
    a way to fix this when we add rotation to our character later in this section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个要点需要强调的是**乘法**节点用于将速度变量的值乘以-1。我们需要创建一个**浮点文字**节点来表示-1的值。然后，当然，所有程序员都会注意到一些关于我们如何使用`If`节点的`True`和`False`输出引脚的限制，但我们将稍后解决这个问题。最后，考虑到这种实现的问题是在第一次读取成功后阻止第二次输入读取；我们将在本节稍后添加旋转到我们的角色时讨论解决这个问题。
- en: 'Now, let’s implement the mouse controls. In this section, we will only cover
    rotation with mouse movement; we will shoot bullets in the next section, *Implementing
    spawning*. In the case of mouse movement, we can get a value saying how much the
    mouse has moved both horizontally and vertically. This value isn’t a Boolean but
    a number: a type of input usually known as an **axis**.The value of an axis will
    indicate the intensity of the movement, and the sign of that number will indicate
    the direction. For example, if Unity’s `“Mouse X”` axis says `0.5`, it means that
    the mouse moved to the right with a moderate speed, but if it says `-1`, it moved
    quickly to the left, and if there is no movement, it will say `0`. The same goes
    for sticks on gamepads; the axis named **Horizontal** represents the horizontal
    movement of the left stick in common joysticks, so if the player pulls the stick
    fully to the left, it will say `-1`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现鼠标控制。在本节中，我们只会涵盖鼠标移动的旋转；我们将在下一节中实现发射子弹，*实现生成*。在鼠标移动的情况下，我们可以得到一个值，表示鼠标在水平和垂直方向上移动了多少。这个值不是一个布尔值，而是一个数字：通常称为**轴**的输入类型。轴的值将指示移动的强度，而该数字的符号将指示方向。例如，如果Unity的`“Mouse
    X”`轴的值为`0.5`，这意味着鼠标以适中的速度向右移动，但如果它说`-1`，则快速向左移动，如果没有移动，它将说`0`。游戏手柄上的摇杆也是如此；名为**水平**的轴表示常见摇杆上左摇杆的水平移动，所以如果玩家将摇杆完全向左拉，它将说`-1`。
- en: 'We can create our own axes to map other common joystick pressure-based controls,
    but for our game, the default ones are enough. To detect mouse movement, follow
    these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的轴来映射其他常见的基于摇杆压力的控件，但对我们游戏来说，默认的轴就足够了。要检测鼠标移动，请按照以下步骤操作：
- en: 'Use the `Input.GetAxis` function inside `Update`, next to the movement `if`
    statements, as shown in the following screenshot, to store the value of this frame’s
    mouse movement in a variable:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数内部，在移动`if`语句旁边使用`Input.GetAxis`函数，如图下截图所示，以存储这一帧鼠标移动的值：
- en: '![](img/B21361_06_13_PRE_BOOK.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_13_PRE_BOOK.png)'
- en: 'Figure 6.13: Getting the horizontal movement of the mouse'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：获取鼠标的水平移动
- en: 'Use the `transform.Rotate` function to rotate the character. This function
    receives the degrees to rotate in the x, y, and z axes. In this case, we need
    to rotate horizontally, so we will use the mouse movement value as the y-axis
    rotation, as shown in the next screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`transform.Rotate`函数来旋转角色。这个函数接收x、y和z轴上要旋转的度数。在这种情况下，我们需要水平旋转，所以我们将使用鼠标移动值作为y轴旋转，如图下截图所示：
- en: '![](img/B21361_06_14_PRE_BOOK.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_14_PRE_BOOK.png)'
- en: 'Figure 6.14: Rotating the object horizontally based on mouse movement'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：根据鼠标移动水平旋转对象
- en: 'If you save and test this, you will notice that the character will rotate but
    very quickly or slowly, depending on your computer. Remember, this kind of value
    needs to be configurable, so let’s create a `rotationSpeed` field to configure
    the speed of the player in the Editor:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存并测试这个，你会注意到角色会旋转，但速度非常快或非常慢，这取决于你的电脑。记住，这种类型的值需要可配置，所以让我们在编辑器中创建一个`rotationSpeed`字段来配置玩家的速度：
- en: '![](img/B21361_06_15_PRE_BOOK.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_15_PRE_BOOK.png)'
- en: 'Figure 6.15: The speed and rotation speed fields'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：速度和旋转速度字段
- en: 'Now, we need to multiply the mouse movement value by the speed, so, depending
    on the `rotationSpeed`, we can increase or reduce the rotation amount. As an example,
    if we set a value of `0.5` in the rotation speed, multiplying that value by the
    mouse movement will make the object rotate at half the previous speed, as shown
    in the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将鼠标移动值乘以速度，因此，根据`rotationSpeed`，我们可以增加或减少旋转量。例如，如果我们设置旋转速度为`0.5`，将这个值乘以鼠标移动将使对象以之前速度的一半旋转，如下面的截图所示：
- en: '![](img/B21361_06_16_PRE_BOOK.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_16_PRE_BOOK.png)'
- en: 'Figure 6.16: Multiplying the mouse movement by the rotation speed'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：将鼠标移动乘以旋转速度
- en: 'Save the code, and go back to the editor to set the rotation speed value. If
    you don’t do this, the object won’t rotate because the default value of the float
    type fields is `0`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码，然后返回编辑器设置旋转速度值。如果不这样做，对象将不会旋转，因为浮点类型字段的默认值是`0`：
- en: '![](img/B21361_06_17_PRE_BOOK.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_17_PRE_BOOK.png)'
- en: 'Figure 6.17: Setting the rotation speed'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：设置旋转速度
- en: 'The Visual Scripting additions to achieve rotation will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现旋转的Visual Scripting添加将看起来像这样：
- en: '![](img/B21361_06_18_PRE_BOOK.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_18_PRE_BOOK.png)'
- en: 'Figure 6.18: Rotating in Visual Scripting'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：在Visual Scripting中旋转
- en: 'The first thing to note here is the usage of the **Sequence** node. An output
    pin can only be attached to one other node, but in this case, **On Update** needs
    to do two different things: rotate and move, each one being independent of the
    other. **Sequence** is a node that will execute all its output pins one after
    the other, regardless of the results of each one. You can specify the number of
    output pins in the **Steps** input box; in this example, two is enough.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的第一件事是**Sequence**节点的使用。一个输出引脚只能附加到另一个节点，但在这个情况下，**On Update**需要做两件不同的事情：旋转和移动，每件都是独立的。**Sequence**是一个节点，它将依次执行所有输出引脚，而不考虑每个节点的结果。您可以在**Steps**输入框中指定输出引脚的数量；在这个例子中，两个就足够了。
- en: In the output pin `0`, the first one, we added the rotation code, which is pretty
    self-explanatory, given that it is essentially the same as the movement code with
    slightly different nodes (**Rotate** (**X, Y, Z**) and **GetAxis**). Then, to
    output pin 1, we attached the `If` that checks the movement input—the one we did
    at the beginning of this section. This will cause the rotation to be executed
    first and the movement second.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出引脚`0`，第一个引脚，我们添加了旋转代码，这相当直观，因为它基本上与移动代码相同，只是节点略有不同（**Rotate**（**X, Y, Z**）和**GetAxis**）。然后，为了输出引脚1，我们附加了检查移动输入的`If`——这是我们在本节开头所做的。这将导致首先执行旋转，然后是移动。
- en: Regarding the limitation we mentioned before, it’s basically the fact that we
    cannot execute both **forward** and **backward** movements, given that if the
    forward movement keys are pressed, the first `If` will be true. Because the backward
    key movement is checked in the false output pin, they won’t be checked in such
    cases. Of course, as our first movement script, it might be enough, but consider
    the lateral movement. If we continue the `If` chaining using `True` and `False`
    output pins, we will have a scenario where we can only move in one direction.
    So we cannot combine, for example, `Forward` and `Right` to move diagonally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前提到的限制，基本上是这样的事实：我们不能同时执行**向前**和**向后**移动，因为如果按下向前移动键，第一个`If`将是真的。由于向后移动键的检查是在假输出引脚中进行的，所以在这种情况下它们不会被检查。当然，作为我们的第一个移动脚本，这可能已经足够了，但考虑侧向移动。如果我们继续使用`True`和`False`输出引脚的`If`链接，我们将面临只能单向移动的场景。因此，我们不能组合例如`Forward`和`Right`来斜向移动。
- en: 'A simple solution to this issue is to put the `If` nodes in the sequence instead
    of chaining them, so all the `If` nodes are checked, which we did in the original
    C#. You can see an example of this in the next image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是将`If`节点按顺序放置而不是链接它们，这样就可以检查所有的`If`节点，就像我们在原始C#中做的那样。您可以在下一张图片中看到这个示例：
- en: '![](img/B21361_06_19_PRE_BOOK.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_19_PRE_BOOK.png)'
- en: 'Figure 6.19: Sequencing Ifs'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：`If`的顺序
- en: Something to consider here is that the connection of the `If` nodes and any
    kind of node can be removed by right-clicking the circle pins on both ends of
    the line that connects them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，可以通过右键单击连接`If`节点和任何类型节点的线条两端的小圆点来移除这些节点的连接。
- en: Making basic input scripting tends to be easy, but the most difficult thing
    to do is to make intuitive and engaging input. Aside from adhering to the standards
    for the user to quickly adapt to your game, like jumping with the *Space* key
    or the A button in a gamepad, I recommend experimenting with the full expressivity
    of controls. That will allow us to better understand when it feels natural to
    use things like drag-and-drop, charging a punch when holding the key and executing
    the punch when releasing it, or using the triggers to control progressive things
    like the acceleration/braking of a car. This is even more interesting when talking
    about AR/VR experiences, where the possibilities are endless.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 制作基本的输入脚本通常很容易，但最难的是制作直观且吸引人的输入。除了遵守用户快速适应你的游戏的标准，比如用空格键或游戏手柄上的A按钮进行跳跃，我建议你尝试控制的全表达性。这将使我们更好地理解何时使用拖放、在按住键时蓄力打击并在释放时执行打击，或使用扳机来控制渐进式事物，如汽车的加速/制动等感觉自然。当谈到AR/VR体验时，这甚至更有趣，因为可能性是无限的。
- en: Now that we have completed our movement script, we need to refine it to work
    on every machine by exploring the concept of Delta Time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的移动脚本，我们需要通过探索Delta Time的概念来对其进行细化，以确保它在每台机器上都能正常工作。
- en: Understanding Delta Time
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Delta Time
- en: Unity’s **Update** loop executes as fast as the computer can. While you can
    set in Unity the desired frame rate, achieving it depends exclusively on your
    computer’s capabilities, which are influenced by various factors, not just hardware.
    This means you can’t always guarantee a consistent FPS. You must code your scripts
    to handle every possible scenario. Our current script moves at a certain speed
    per frame, and the *per frame* part is important here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**Update**循环以电脑能运行的最快速度执行。虽然你可以在Unity中设置所需的帧率，但实现它完全取决于你电脑的能力，这受到各种因素的影响，而不仅仅是硬件。这意味着你无法始终保证一致的FPS。你必须编写你的脚本以处理每个可能的场景。我们当前的脚本以每帧一定的速度移动，这里的*每帧*部分很重要。
- en: We have set the movement speed to 0.1, so if my computer runs the game at 120
    FPS, the player will move 12 meters per second. Now, what happens on a computer
    where the game runs at 60 FPS? As you can guess, it will move only 6 meters per
    second, making our game have inconsistent behavior across different computers.
    This is where Delta Time saves the day.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将移动速度设置为0.1，所以如果我的电脑以120 FPS运行游戏，玩家每秒将移动12米。现在，在一个游戏以60 FPS运行的电脑上会发生什么呢？正如你所猜想的，它将只移动6米每秒，这使得我们的游戏在不同电脑上表现出不一致的行为。这就是Delta
    Time发挥作用的时候。
- en: '**Delta Time** is a value that tells us how much time has passed since the
    previous frame. This time depends a lot on our game’s graphics, number of entities,
    physics bodies, audio, and countless aspects that will dictate how fast your computer
    can process a frame. As an example, if your game runs at 10 FPS, it means that,
    in a second, your computer can process the `Update` loop 10 times, meaning that
    each loop takes approximately `0.1` seconds; in the frame, Delta Time will provide
    that value.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**Delta Time**是一个告诉我们自上一帧以来过去了多少时间的值。这个时间很大程度上取决于我们的游戏图形、实体数量、物理体、音频以及无数方面，这些都会决定你的电脑可以多快地处理一帧。例如，如果你的游戏以10
    FPS运行，这意味着在一秒钟内，你的电脑可以处理`Update`循环10次，这意味着每个循环大约需要`0.1`秒；在帧中，Delta Time将提供这个值。'
- en: 'In the following diagram, you can see an example of four frames taking different
    times to process, which can happen in real-life cases:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以看到四个帧处理不同时间的示例，这在现实生活中可能会发生：
- en: '![](img/B21361_06_20_PRE_Book.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_20_PRE_Book.png)'
- en: 'Figure 6.20: Delta Time values varying in different frames of the game'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：游戏中不同帧的Delta Time值变化
- en: Here, we need to code in such a way as to change the *per frame* part of the
    movement to *per second*; we need to have consistent movement per second across
    different computers. One way to do that is to move proportionally to the Delta
    Time; the higher the Delta Time value, the longer that frame is, and the further
    the movement should be to match the real time that has passed since the last update.
    We can think about our `speed` field’s current value in terms of `0.1` meters
    per second; our Delta Time saying `0.5` means that half a second has passed, so
    we should move half the speed, `0.05`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要编写代码以改变移动的 *每帧* 部分，变为 *每秒*；我们需要在不同计算机上保持每秒一致的移动。一种方法是按比例移动到 Delta Time；Delta
    Time 值越高，帧越长，移动应该越远以匹配自上次更新以来经过的真实时间。我们可以将 `speed` 字段的当前值视为 `0.1` 米每秒；我们的 Delta
    Time 表示 `0.5` 意味着已经过去了半秒，所以我们应该移动一半的速度，`0.05`。
- en: After two frames a second have passed, the sum of the movements of the frames
    (2 x 0.05) matches the target speed, `0.1`. Delta Time can be interpreted as the
    percentage of a second that has passed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两帧一秒后，帧移动的总和（2 x 0.05）与目标速度 `0.1` 匹配。Delta Time 可以解释为已经过去的一秒的百分比。
- en: 'To make the Delta Time affect our movement, we should simply multiply our speed
    by Delta Time every frame because it can be different every frame. So let’s do
    that:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 Delta Time 影响我们的移动，我们只需在每一帧将我们的速度乘以 Delta Time，因为每一帧都可能不同。所以让我们这样做：
- en: 'We access Delta Time using `Time.deltaTime`. We can start affecting the movement
    by multiplying the Delta Time in every `Translate`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `Time.deltaTime` 访问 Delta Time。我们可以通过在每次 `Translate` 中乘以 Delta Time 来开始影响移动：
- en: '![](img/B21361_06_21_PRE_BOOK.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_21_PRE_BOOK.png)'
- en: 'Figure 6.21: Multiplying speed by Delta Time'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21：将速度乘以 Delta Time
- en: 'We can do the same with the rotation speed by chaining the mouse and speed
    multiplications:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过链式鼠标和速度乘法来对旋转速度做同样的事情：
- en: '![](img/B21361_06_22_PRE_BOOK.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_22_PRE_BOOK.png)'
- en: 'Figure 6.22: Applying Delta Time to the rotation code'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22：将 Delta Time 应用到旋转代码中
- en: If you save and play the game, you will notice that the movement will be slower
    than before. That’s because now `0.1` is the movement per second, meaning `10`
    centimeters per second, which is pretty slow; try raising those values. In my
    case, `10` for speed and `180` for rotation speed were enough, but the rotation
    speed depends on the player’s preferred sensibility, which can be configurable,
    but let’s keep that for another time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存并玩这个游戏，你会注意到移动速度会比之前慢。这是因为现在 `0.1` 是每秒的移动量，意味着每秒 `10` 厘米，这相当慢；试着提高这些值。在我的情况下，速度是
    `10`，旋转速度是 `180`，但旋转速度取决于玩家的偏好灵敏度，这可以配置，但让我们留到下次再说。
- en: 'The Visual Scripting change for the rotation will look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的视觉脚本更改将看起来像这样：
- en: '![](img/B21361_06_23_PRE_BOOK.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_23_PRE_BOOK.png)'
- en: 'Figure 6.23: Applying Delta Time to the Rotate Visual Script'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23：将 Delta Time 应用到旋转视觉脚本
- en: For movement, you can easily extrapolate from this example or check the project
    on GitHub. We simply chained another **Multiply** node with **Get Delta Time**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动，你可以很容易地从这个例子中推断出来，或者查看 GitHub 上的项目。我们只是链式连接了另一个 `Multiply` 节点与 `Get Delta
    Time`。
- en: We just learned how to mix the Input System of Unity, which tells us about the
    state of the keyboard, mouse, and other input devices, with the basic `Transform`
    movement functions. This way, we can start making our game feel more dynamic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何将 Unity 的输入系统与基本的 `Transform` 移动功能混合，这告诉我们键盘、鼠标和其他输入设备的状态。这样，我们可以开始让我们的游戏感觉更加动态。
- en: Now that we have finished the player’s movement, let’s discuss how to make the
    player shoot bullets using `Instantiate` functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了玩家的移动，让我们讨论如何使用 `Instantiate` 函数让玩家射击子弹。
- en: Implementing spawning
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现生成
- en: We have created lots of objects in the editor that define our level, but once
    the game begins, and according to the player’s actions, new objects must be created
    to better fit the scenarios generated by player interaction. Enemies might need
    to appear after a while, or bullets must be created according to the player’s
    input; even when enemies die, there’s a chance of spawning a power-up. This means
    that we cannot create all the necessary objects beforehand but should create them
    dynamically, and that’s done through scripting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编辑器中创建了大量的对象来定义我们的关卡，但一旦游戏开始，根据玩家的操作，必须创建新的对象以更好地适应由玩家交互生成的场景。敌人可能过一段时间后出现，或者必须根据玩家的输入创建子弹；即使敌人死亡，也有可能出现一个增益物品。这意味着我们无法事先创建所有必要的对象，而应该动态地创建它们，这通过脚本完成。
- en: 'In this section, we will examine the following spawning concepts:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下生成概念：
- en: Spawning objects
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成对象
- en: Timing actions
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时动作
- en: Destroying objects
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁对象
- en: We will start seeing the Unity `Instantiate` function, which allows us to create
    instances of Prefabs at runtime, such as when pressing a key, or in a time-based
    fashion, such as making our enemy spawn bullets once every so often. Also, we
    will learn how to destroy these objects to prevent our scene from starting to
    perform badly due to too many objects being processed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始看到Unity的`Instantiate`函数，它允许我们在运行时创建Prefab的实例，例如在按下一个键时，或者以基于时间的模式，例如让我们的敌人每隔一段时间发射子弹。此外，我们还将学习如何销毁这些对象，以防止我们的场景因为处理过多的对象而开始表现不佳。
- en: Let’s start with how to shoot bullets according to the player’s input.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何根据玩家的输入射击子弹开始。
- en: Spawning objects
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成对象
- en: To spawn an object in runtime or **Play** mode, we need a description of the
    object, which components it has, its settings, and its possible sub-objects. You
    might be thinking about Prefabs here, and you are right; we will use an instruction
    that will tell Unity to create an instance of a Prefab via scripting. Remember
    that an instance of a Prefab is an object created based on the Prefab—basically
    a clone of the original one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时或**播放**模式下生成对象，我们需要对象的描述、它拥有的组件、其设置以及可能的子对象。你可能在这里想到了Prefab，你是对的；我们将使用一个指令来告诉Unity通过脚本创建Prefab的实例。请记住，Prefab的实例是基于Prefab创建的对象——基本上是原始对象的克隆。
- en: 'We will start by shooting the player’s bullets, so first, let’s create the
    bullet Prefab by following these steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先射击玩家的子弹，所以首先，让我们按照以下步骤创建子弹Prefab：
- en: Create a sphere in **GameObject | 3D Object | Sphere**. You can replace the
    sphere mesh with another bullet model if you want, but we will keep the sphere
    in this example for now.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**GameObject | 3D Object | Sphere**中创建一个球体。如果您想，可以用另一个子弹模型替换球体网格，但在此例中我们将保持球体不变。
- en: Rename the sphere `Bullet`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体重命名为`Bullet`。
- en: Create a material by clicking on the **+** button of the **Project** window,
    choosing the option **Material**, and calling it `Bullet`. Remember to place it
    inside the `Materials` folder.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**项目**窗口的**+**按钮，选择**材料**选项，并将其命名为`Bullet`来创建一个材料。请记住将其放置在`Materials`文件夹内。
- en: 'Check the **Emission** checkbox in the material, and set the **Emission Map**
    and **Base Map** colors to red:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材料中勾选**发射**复选框，并将**发射贴图**和**基础贴图**颜色设置为红色：
- en: '![](img/B21361_06_24.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_24.png)'
- en: 'Figure 6.24: Creating a red bullet material with an emission color'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：创建具有发射颜色的红色子弹材料
- en: Apply the **Material** to the **Sphere** by dragging the material to it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将材料拖动到球体上，将**材料**应用到**球体**上。
- en: Set the **Scale** to a smaller value—`0.3, 0.3, 0.3` worked in my case.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**缩放**设置为较小的值——在我的例子中`0.3, 0.3, 0.3`有效。
- en: Create a script called `ForwardMovement` to make the bullet constantly move
    forward at a fixed speed. You can create it both with C# and Visual Scripting,
    but for simplicity, we are only going to use C# in this case.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ForwardMovement`的脚本，使子弹以固定速度持续向前移动。您可以使用C#和视觉脚本创建它，但为了简单起见，我们在此情况下只使用C#。
- en: I suggest you try to solve this by yourself first and look at the screenshot
    in the next step with the solution later as a little challenge, recapping the
    movement concepts we saw previously. If you don’t recall how to create a script,
    please refer to *Chapter 5*, *Unleashing the Power of C# and Visual Scripting*,
    and check the previous section to see how to move objects.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我建议您先自己尝试解决这个问题，并在下一步查看带有解决方案的截图，作为一个小挑战，回顾我们之前看到的运动概念。如果您不记得如何创建脚本，请参考*第5章*，*释放C#和视觉脚本的威力*，并查看前面的部分以了解如何移动对象。
- en: 'The next screenshot shows you what the script should look like:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个截图显示了脚本应该的样子：
- en: '![](img/B21361_06_25_PRE_BOOK.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_25_PRE_BOOK.png)'
- en: 'Figure 6.25: A simple ForwardMovement script'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：一个简单的ForwardMovement脚本
- en: 'Add the script (if not already there) to the bullet, and set the speed to a
    value you see fit. Usually, bullets are faster than the player, but that depends
    on the game experience you want to get. In my case, `20` worked fine. Test it
    by placing the bullet near the player and playing the game:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本（如果尚未添加）添加到子弹上，并将速度设置为合适的值。通常，子弹比玩家快，但这取决于你想要的游戏体验。在我的情况下，`20`就足够了。通过将子弹放置在玩家附近并玩游戏来测试它：
- en: '![](img/B21361_06_26.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_26.png)'
- en: 'Figure 6.26: A ForwardMovement script in the bullet'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：在bullet中的ForwardMovement脚本
- en: 'Drag the bullet `GameObject` instance to the `Prefabs` folder to create a **Bullet**
    Prefab. Remember that the Prefab is an asset that has a description of the created
    bullet, like a blueprint of how to create a bullet:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子弹`GameObject`实例拖到`Prefabs`文件夹中，创建一个**Bullet**预制件。请记住，预制件是一个资产，它描述了创建的子弹，就像创建子弹的蓝图：
- en: '![](img/B21361_06_27_PRE_BOOK.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_27_PRE_BOOK.png)'
- en: 'Figure 6.27: Creating a Prefab'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：创建预制件
- en: Remove the original bullet from the scene; we will use the Prefab to create
    bullets when the player presses a key (if ever).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除原始子弹；当玩家按下键时（如果有的话），我们将使用预制件来创建子弹。
- en: 'Now that we have our bullet Prefab, it is time to instantiate it (clone it)
    when the player presses a key. To do that, follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了子弹预制件，当玩家按下键时，是时候实例化它（克隆它）了。为此，请按照以下步骤操作：
- en: Create and add a script to the player’s `GameObject` called `PlayerShooting`,
    and open it.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家的`GameObject`上创建并添加一个名为`PlayerShooting`的脚本，并打开它。
- en: We need a way for the script to have access to the Prefab to know which Prefab
    to use from probably the dozens we will have in our project. All of the data that
    our script needs, which depends on the desired game experience, is in the form
    of a field, such as the **speed** field used previously. So, in this case, we
    need a field of the `GameObject` type—a field that can reference or point to a
    specific Prefab, which can be set using the editor.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种方法让脚本能够访问预制件，以便知道从可能的项目中的几十个预制件中选择哪个。我们脚本需要的所有数据，这取决于期望的游戏体验，都是以字段的形式存在的，例如之前使用的**速度**字段。因此，在这种情况下，我们需要一个`GameObject`类型的字段——一个可以引用或指向特定预制件的字段，这可以通过编辑器设置。
- en: Adding the field code would look like this:![](img/B21361_06_28_PRE_BOOK.png)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加字段代码将看起来像这样：![](img/B21361_06_28_PRE_BOOK.png)
- en: 'Figure 6.28: The Prefab reference field'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.28：预制件引用字段
- en: As you might have guessed, we can use the `GameObject` type to reference not
    only Prefabs but also other objects. Imagine an enemy AI needing a reference to
    the player object to get its position, using `GameObject` to link the two objects.
    The trick here is considering that Prefabs are just regular GameObjects that live
    outside the scene; you cannot see them, but they are in memory, ready to be copied
    or instantiated. You will only see them through copies or instances that are placed
    in the scene with scripting or via the editor, as we have done so far.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所猜，我们可以使用`GameObject`类型来引用不仅预制件，还可以引用其他对象。想象一下，一个敌人AI需要引用玩家对象来获取其位置，使用`GameObject`来连接两个对象。这里的技巧是考虑到预制件只是存在于场景外的普通`GameObject`；你无法看到它们，但它们在内存中，准备好被复制或实例化。你只能通过脚本或编辑器放置在场景中的副本或实例来看到它们，就像我们到目前为止所做的那样。
- en: 'In the editor, click on the circle toward the right of the property and select
    the `Bullet` Prefab. Another option is to just drag the `Bullet` Prefab to the
    property. This way, we tell our script that the bullet to shoot will be that particular
    one. Remember to drag the Prefab and not the bullet in the scene (the one in the
    scene should have been deleted by now):'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，点击属性右侧的圆圈并选择`Bullet`预制件。另一个选项是将`Bullet`预制件直接拖到属性上。这样，我们就告诉我们的脚本要发射的子弹是那个特定的一个。请记住，拖动的是预制件而不是场景中的子弹（现在应该已经删除了）：
- en: '![](img/B21361_06_29_PRE_BOOK.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_29_PRE_BOOK.png)'
- en: 'Figure 6.29: Setting the Prefab reference to point the bullet'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：设置预制件引用以指向子弹
- en: 'We will shoot the bullet when the player presses the left mouse button, so
    place the appropriate `if` statement to handle that in the `Update` event function,
    like the one shown in the next screenshot:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家按下左鼠标按钮时，我们将发射子弹，所以请在`Update`事件函数中放置适当的`if`语句来处理，就像下一个截图所示：
- en: '![](img/B21361_06_30_PRE_BOOK.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_30_PRE_BOOK.png)'
- en: 'Figure 6.30: Detecting the pressure of the left mouse button'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：检测左鼠标按钮的压力
- en: You will notice that this time, we used `GetKeyDown` instead of `GetKey`, the
    former being a way to detect the exact frame the pressure of the key started;
    this `if` statement executes its code only in that frame and until the key is
    released and re-pressed, it won’t enter again. This is one way to prevent bullets
    from spawning in every frame, but just for fun, you can try using `GetKey` instead
    to check how it would behave. Also, `KeyCode.Mouse0` is the mouse button number
    that belongs to the left-click, `KeyCode.Mouse1` is the right-click, and `KeyCode.Mouse2`
    is the middle click.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到这次，我们使用了`GetKeyDown`而不是`GetKey`，前者是一种检测按键压力开始的确切帧的方法；这个`if`语句仅在那一帧执行其代码，直到按键被释放并重新按下，它才不会再次进入。这是防止子弹在每一帧生成的一种方法，但为了好玩，你可以尝试使用`GetKey`来检查它会如何表现。此外，`KeyCode.Mouse0`是鼠标左键的按钮编号，`KeyCode.Mouse1`是右键，而`KeyCode.Mouse2`是中键。
- en: 'Use the `Instantiate` function to clone the Prefab, passing the reference to
    it as the first parameter. This will create a clone of the aforementioned Prefab
    that will be placed in the scene:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Instantiate`函数克隆Prefab，将对其的引用作为第一个参数传递。这将创建一个上述Prefab的克隆，并将其放置在场景中：
- en: '![](img/B21361_06_31_PRE_BOOK.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_31_PRE_BOOK.png)'
- en: 'Figure 6.31: Instantiating the Prefab'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：实例化Prefab
- en: 'If you save the script and play the game, you will notice that when you press
    the mouse, a bullet will spawn, but probably not in the place you expect. If you
    don’t see it, check the Hierarchy for new objects; it will be there. The problem
    here is that we didn’t specify the desired spawn position, and we have two ways
    of setting that, which we will see in the next steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存脚本并玩游戏，你会注意到当你按下鼠标时，会生成子弹，但可能不是你期望的位置。如果你看不到它，请检查层次结构中的新对象；它会在那里。这里的问题是我们没有指定所需的生成位置，并且我们有两种方法可以设置它，我们将在下一步中看到：
- en: 'The first way is to use the `transform.position` and `transform.rotation` inherited
    fields from `MonoBehaviour`, which will tell us our current position and rotation,
    respectively. We can pass them as the second and third parameters of the `Instantiate`
    function, which will understand that this is the place we want our bullet to appear.
    Remember that it is important to set the rotation to make the bullet face the
    same direction as the player so that it will move that way:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是使用从`MonoBehaviour`继承的`transform.position`和`transform.rotation`字段，这将分别告诉我们我们的当前位置和旋转。我们可以将它们作为`Instantiate`函数的第二个和第三个参数传递，这样它就会理解这是我们希望子弹出现的位置。记住，设置旋转以使子弹面向与玩家相同的方向是很重要的，这样它才会以这种方式移动：
- en: '![](img/B21361_06_32_PRE_BOOK.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_32_PRE_BOOK.png)'
- en: 'Figure 6.32: Instantiating the Prefab in our position and rotation'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32：在当前位置和旋转中实例化Prefab
- en: 'The second way is by using the previous version of `Instantiate` but saving
    the reference returned by the function, which will point to the clone of the Prefab.
    This allows us to change whatever we want from it. In this case, we will need
    the following three lines: the first will instantiate and capture the clone reference,
    the second will set the position, and the third will set the rotation. We will
    also use the `transform.position` field of the clone, but this time to change
    its value by using the `=` (assignment) operator:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是通过使用之前的`Instantiate`版本，但保存函数返回的引用，这将指向Prefab的克隆。这允许我们更改我们想要的任何内容。在这种情况下，我们需要以下三条线：第一条将实例化并捕获克隆引用，第二条将设置位置，第三条将设置旋转。我们还将使用克隆的`transform.position`字段，但这次是通过使用`=`（赋值）运算符来更改其值：
- en: '![](img/B21361_06_33_PRE_BOOK.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_33_PRE_BOOK.png)'
- en: 'Figure 6.33: The longer version of instantiating a Prefab in a specific position'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33：在特定位置实例化Prefab的较长版本
- en: Remember that you can check the project’s GitHub repository linked in the *Preface*
    to see the full script finished. Now, you can save the file with one of the versions
    and try to shoot.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以检查在*前言*中链接的项目GitHub仓库，以查看完整的脚本。现在，你可以保存文件的一个版本并尝试射击。
- en: 'If you try the script so far, you should see the bullet spawn in the player’s
    position, but in our case, it will probably be the floor. The problem here is
    that the player’s character pivot is there, and usually, every humanoid character
    has the pivot in their feet. We have several ways to fix that. The most flexible
    method is to create a **Shoot Point**, an empty GameObject child of the player,
    placed in the position we want the bullet to spawn. We can use the position of
    that object instead of the player’s position by following these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试运行到目前为止的脚本，您应该会看到子弹在玩家的位置生成，但在我们的情况下，它可能是在地板上。这里的问题是玩家的角色枢轴就在那里，通常，每个类人角色都有枢轴在他们的脚上。我们有几种方法可以解决这个问题。最灵活的方法是创建一个
    **Shoot Point**，它是玩家的一个空GameObject子对象，放置在我们希望子弹生成的位置。我们可以通过以下步骤使用该对象的坐标而不是玩家的坐标：
- en: Create an empty `GameObject` in **GameObject | Create Empty**. Name it `ShootPoint`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **GameObject | Create Empty** 中创建一个空的 `GameObject`。命名为 `ShootPoint`。
- en: 'Make it a child of the player’s GameObject, and place it where you want the
    bullet to appear, probably a little higher and further forward:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其设置为玩家的GameObject的子对象，并将其放置在您希望子弹出现的位置，可能稍微高一点，再往前一些：
- en: '![](img/B21361_06_34_PRE_BOOK.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_34_PRE_BOOK.png)'
- en: 'Figure 6.34: An empty ShootPoint object placed inside the character'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34：在角色内部放置一个空的ShootPoint对象
- en: 'As usual, to access the data of another object, we need a reference to it,
    such as the Prefab reference, but this time, it needs to point to our `ShootPoint`.
    We can create another `GameObject` type field, but this time, drag `ShootPoint`
    instead of the Prefab. The script and the object set would look as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，要访问另一个对象的数据，我们需要一个对该对象的引用，例如Prefab引用，但这次，它需要指向我们的 `ShootPoint`。我们可以创建另一个
    `GameObject` 类型字段，但这次，拖动 `ShootPoint` 而不是Prefab。脚本和对象设置将如下所示：
- en: '![](img/B21361_06_35_%26_36_PRE_BOOK.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_35_%26_36_PRE_BOOK.png)'
- en: 'Figure 6.35: The Prefab and Shoot Point fields and how they are set in the
    editor'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：Prefab和Shoot Point字段以及它们在编辑器中的设置
- en: 'We can access the position of the `ShootPoint` by using its `transform.position`
    field again, as shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用其 `transform.position` 字段再次访问 `ShootPoint` 的位置，如下面的截图所示：
- en: '![](img/B21361_06_37_PRE_BOOK.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_37_PRE_BOOK.png)'
- en: 'Figure 6.36: Positioning the bullet clone in the shooting spawn point'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：在射击生成点定位子弹克隆体
- en: 'The Visual Scripting version of **ForwardMovement** will look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**ForwardMovement** 的视觉脚本版本看起来是这样的：'
- en: '![](img/B21361_06_38_PRE_BOOK.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_38_PRE_BOOK.png)'
- en: 'Figure 6.37: ForwardMovement with Visual Scripting'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：使用视觉脚本进行ForwardMovement
- en: 'And `PlayerShooting` will look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `PlayerShooting` 将看起来像这样：
- en: '![](img/B21361_06_39_PRE_BOOK.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_39_PRE_BOOK.png)'
- en: 'Figure 6.38: Instantiating in the PlayerShooting Visual Script'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38：在PlayerShooting视觉脚本中实例化
- en: As you can see, we added a second **Script Machine** component with a new graph
    called **Player Shooting**. We also added a new variable, `bulletPrefab`, of type
    `GameObject` and dragged the **Bullet** Prefab to it, and a second `GameObject`
    type variable called `shootPoint`, to have a reference to the bullet’s spawn position.
    The rest of the script is essentially the counterpart of the C# version without
    any major differences.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加了一个名为 **Player Shooting** 的新图的新 **Script Machine** 组件。我们还添加了一个新的变量，`bulletPrefab`，类型为
    `GameObject`，并将 **Bullet** Prefab 拖动到它上面，以及一个名为 `shootPoint` 的第二个 `GameObject`
    类型变量，以便引用子弹的生成位置。脚本的其他部分基本上是C#版本的对应物，没有太大差异。
- en: Something to highlight here is how we connected the `Transform GetPosition`
    and `Transform GetRotation` nodes to the `GetVariable` node belonging to the `shootPoint`;
    this way, we access the position and rotation of the shooting point. If you don’t
    specify that, it will use the player’s position and rotation, which, in the case
    of our model, is in the player’s character’s feet.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要强调的是，我们如何将 `Transform GetPosition` 和 `Transform GetRotation` 节点连接到 `shootPoint`
    所属的 `GetVariable` 节点；这样，我们就可以访问射击点的位置和旋转。如果您没有指定，它将使用玩家的位置和旋转，在我们的模型中，这通常是玩家的角色脚部。
- en: 'You will notice that, now, shooting and rotating with the mouse has a problem;
    when moving the mouse to rotate, the pointer will fall outside the **Game** view,
    and when clicking, you will accidentally click the editor, losing the focus on
    the **Game** view, so you will need to click the **Game** View again to regain
    focus and use input again. A way to prevent this is to disable the cursor while
    playing. To do this, follow these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，现在使用鼠标射击和旋转出现了问题；当移动鼠标进行旋转时，指针会落在**游戏**视图之外，当你点击时，你会不小心点击到编辑器，从而失去对**游戏**视图的焦点，因此你需要再次点击**游戏**视图来恢复焦点并再次使用输入。防止这种情况的一种方法是游戏时禁用光标。为此，请按照以下步骤操作：
- en: Add a `Start` event function to our `Player Movement` script.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Start`事件函数添加到我们的`玩家移动`脚本中。
- en: 'Add the two lines you can see in the following screenshot to your script. The
    first one will make the cursor visible, and the second one will lock it in the
    middle of the screen so that it will never abandon the **Game** View. Consider
    the latter; you will need to reenable the cursor when you switch back to the main
    menu or the pause menu, allowing the mouse to click the UI buttons:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下截图中的两行代码添加到你的脚本中。第一行将使光标可见，第二行将锁定光标在屏幕中间，这样它就永远不会离开**游戏**视图。考虑后者；当你切换回主菜单或暂停菜单时，你需要重新启用光标，以便鼠标可以点击UI按钮：
- en: '![](img/B21361_06_40_PRE_BOOK.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_40_PRE_BOOK.png)'
- en: 'Figure 6.39: Disabling the mouse cursor'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.39：禁用鼠标光标
- en: Save and test this. If you want to stop the game, you could press either *Ctrl*
    + *Shift* + *P* (*Command* + *Shift* + *P* on a Mac) or the *Esc* key to reenable
    the mouse. Both options only work in the editor; in the real game, you will need
    to reset `Cursor.visible` to `true` and `Cursor.lockState` to `CursorLockMode.None`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试。如果你想停止游戏，可以按*Ctrl* + *Shift* + *P*（在Mac上为*Command* + *Shift* + *P*）或*Esc*键来重新启用鼠标。这两个选项仅在编辑器中有效；在真实游戏中，你需要将`Cursor.visible`重置为`true`，将`Cursor.lockState`重置为`CursorLockMode.None`。
- en: 'The Visual Scripting equivalent will look like this:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉脚本等效的代码如下：
- en: '![](img/B21361_06_41_PRE_BOOK.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_41_PRE_BOOK.png)'
- en: 'Figure 6.40: Disabling the mouse cursor in Visual Scripting'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.40：在视觉脚本中禁用鼠标光标
- en: Now that we have covered the basics of object spawning, let’s see an advanced
    example by combining it with timers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了对象生成的基础知识，让我们通过结合定时器来查看一个高级示例。
- en: Timing actions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时动作
- en: Not entirely related to spawning but usually used together, timing actions are
    common tasks in video games. The idea is to schedule something to happen later;
    maybe we want a bullet to be destroyed after a while to prevent memory overflow,
    or we want to control the spawn rate of enemies or when they should spawn. That’s
    exactly what we are going to do in this section, starting with implementing **enemy
    waves**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成不完全相关，但通常一起使用，定时动作是视频游戏中的常见任务。想法是安排某事在以后发生；也许我们希望子弹在一段时间后销毁以防止内存溢出，或者我们想要控制敌人的生成速率或它们应该何时生成。这正是我们将在本节中要做的，从实现**敌人波次**开始。
- en: The idea is that we want to spawn enemies at a certain rate in different moments
    of the game; maybe we want to spawn enemies from the beggining during 5 seconds
    at a rate of 2 per second, getting 10 enemies and giving the player up to 20 seconds
    to finish them, programming another wave, starting at 25 seconds. Of course, this
    depends a lot on the exact game you want, and you can start with an idea like
    this one and modify it after some testing to find the exact way you want the wave
    system to work. In our case, we will apply timing by implementing a simple wave
    system.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是我们希望在游戏的各个不同时刻以一定的速率生成敌人；也许我们希望在游戏开始的前5秒内以每秒2个的速率生成敌人，总共生成10个敌人，给玩家最多20秒的时间来完成它们，然后编程下一波，从第25秒开始。当然，这很大程度上取决于你想要的精确游戏，你可以从一个像这样的想法开始，并在测试后进行修改，以找到你想要的波次系统工作的确切方式。在我们的案例中，我们将通过实现一个简单的波次系统来应用定时。
- en: 'First of all, we need an enemy, and for now, we will simply use the same 3D
    model we used for the player but add a `Forward Movement` script to simply make
    it move forward; later in this book, we will add AI behavior to our enemies. I
    suggest you try creating this Prefab on your own first. After you have done so,
    refer to the following steps to compare your work with the recommended approach
    and confirm if you’ve done it correctly:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个敌人，目前我们将简单地使用与玩家相同的3D模型，但添加一个`向前移动`脚本，使其简单地向前移动；在本书的后面部分，我们将为敌人添加AI行为。我建议你首先自己尝试创建这个预制件。在你完成之后，参考以下步骤来比较你的工作与推荐方法，并确认你是否正确完成了：
- en: 'Drag the downloaded Character FBX model to the scene to create another instance
    of it, but name it `Enemy` this time:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的 Character FBX 模型拖到场景中创建其另一个实例，但这次命名为 `Enemy`：
- en: Add the `ForwardMovement` script created for the bullets, but this time as `Enemy`,
    and set it at a speed of `10` for now.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加为子弹创建的 `ForwardMovement` 脚本，但这次作为 `Enemy` 使用，并暂时将其速度设置为 `10`。
- en: Drag the `Enemy` GameObject to the **Project** panel to create its Prefab; we
    will need to spawn it later. Remember to select **Prefab Variant** to keep this
    Prefab linked with the original model, allowing any changes to the model to automatically
    update the Prefab.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Enemy` 游戏对象拖到 **项目** 面板中创建其 Prefab；我们稍后会需要它。请记住选择 **Prefab 变体** 以保持此 Prefab
    与原始模型链接，允许对模型的任何更改自动更新 Prefab。
- en: Remember also to destroy the original `Enemy` from the scene.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要记得从场景中删除原始的 `Enemy`。
- en: 'Now, to schedule actions, we will use the `Invoke` functions to create timers.
    They are basic but enough for our requirements. Let’s use them by following these
    steps:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，为了安排动作，我们将使用 `Invoke` 函数创建计时器。它们很简单，但足以满足我们的需求。让我们按照以下步骤使用它们：
- en: Create an empty GameObject at one end of the base and call it `Wave1a`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基座的一端创建一个空的游戏对象，并将其命名为 `Wave1a`。
- en: Create and add a script called `WaveSpawner` to it.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个名为 `WaveSpawner` 的脚本。
- en: 'Our spawner will need four fields: the `Enemy` `Prefab` to spawn, the `startTime`
    of the wave, the `endTime`, and the spawn rate of the enemies (how much time should
    be between each spawn). The script and the settings will look like the following
    screenshot:![](img/B21361_06_42_PRE_BOOK.png)'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的生成器需要四个字段：要生成的 `Enemy` Prefab、波浪的 `startTime`、`endTime` 以及敌人的生成速率（每次生成之间应该有多少时间）。脚本和设置将类似于以下截图：![](img/B21361_06_42_PRE_BOOK.png)
- en: 'Figure 6.41: The fields of the wave spawner script'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.41：波浪生成器脚本的字段
- en: We will use the `InvokeRepeating` function to schedule a custom function to
    repeat periodically. You will need to schedule the repetition just once; Unity
    will remember that, so don’t do it for every frame. This is a good reason to use
    the `Start` event function instead. The first argument of the function is a string
    (text between the quotation marks) with the name of the other function to execute
    periodically, and unlike `Start` or `Update`, you can name the function whatever
    you want. The second argument is the time to start repeating—our `startTime` field,
    in this case. Finally, the third argument is the repetition rate of the function—how
    much time needs to pass between each repetition—this being the `spawnRate` field.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用 `InvokeRepeating` 函数来安排一个自定义函数以周期性重复执行。您只需要调度一次重复；Unity 会记住这一点，所以不要为每一帧都做这件事。这是使用
    `Start` 事件函数的一个很好的理由。函数的第一个参数是一个字符串（引号之间的文本），包含要周期性执行的另一个函数的名称，并且与 `Start` 或 `Update`
    不同，您可以随意命名该函数。第二个参数是开始重复的时间——在这个例子中是我们的 `startTime` 字段。最后，第三个参数是函数的重复率——每次重复之间需要经过多少时间——这就是
    `spawnRate` 字段。
- en: 'You can find how to call that function in the next screenshot, along with the
    custom `Spawn` function:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在下一张截图和自定义的 `Spawn` 函数中找到如何调用该函数：
- en: '![](img/B21361_06_43_PRE_BOOK.png)'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_06_43_PRE_BOOK.png)'
- en: 'Figure 6.42: Scheduling a Spawn function to repeat'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.42：安排重复的 Spawn 函数
- en: Inside the `Spawn` function, we can add the spawning code using the `Instantiate`
    function. The idea is to call this function at a certain rate to spawn one enemy
    per call. This time, the spawn position will be in the same position as the spawner,
    so place it carefully:![](img/B21361_06_44_PRE_BOOK.png)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Spawn` 函数内部，我们可以使用 `Instantiate` 函数添加生成代码。想法是在一定频率下调用此函数，每次调用生成一个敌人。这次，生成位置将与生成器相同，所以请小心放置：![](img/B21361_06_44_PRE_BOOK.png)
- en: 'Figure 6.43: Instantiating in the Spawn function'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.43：在 Spawn 函数中实例化
- en: 'If you test this script by setting the Prefab `startTime` and `spawnRate` fields
    to some values greater than 0, you will notice that the enemies will start spawning
    but never stop, and you can see that we haven’t used the `endTime` field so far.
    The idea is to call the `CancelInvoke` function, the one function that will cancel
    all the `InvokeRepeating` calls we made, but after a while. We will delay the
    execution of `CancelInvoke` using the `Invoke` function, which works similarly
    to `InvokeRepeating`, but this one executes just once. In the next screenshot,
    you can see how we added an `Invoke` call to the `CancelInvoke` function in `Start`,
    using the `endTime` field as the time to execute `CancelInvoke`. This will execute
    `CancelInvoke` after a while, canceling the first `InvokeRepeating` call that
    spawns the Prefab:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你通过将预制件的`startTime`和`spawnRate`字段设置为大于0的值来测试这个脚本，你会注意到敌人会开始生成但永远不会停止，你可以看到我们还没有使用`endTime`字段。想法是调用`CancelInvoke`函数，这是唯一一个可以取消我们做出的所有`InvokeRepeating`调用的函数，但过一段时间后。我们将使用`Invoke`函数延迟执行`CancelInvoke`，它的工作方式与`InvokeRepeating`类似，但这个函数只执行一次。在下一个截图中，你可以看到我们如何在`Start`中添加了对`CancelInvoke`函数的`Invoke`调用，使用`endTime`字段作为执行`CancelInvoke`的时间。这将延迟执行`CancelInvoke`，取消生成预制件的第一个`InvokeRepeating`调用：
- en: '![](img/B21361_06_45_PRE_BOOk.png)'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21361_06_45_PRE_BOOk.png)'
- en: 'Figure 6.44: Scheduling a Spawn repetition but canceling after a while with
    CancelInvoke'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.44：安排生成重复，但使用CancelInvoke在一段时间后取消
- en: This time, we used `Invoke` to delay the call to `CancelInvoke`. We didn’t create
    a custom function because `CancelInvoke` doesn’t receive arguments. If you need
    to schedule a function with arguments, you will need to create a wrapper function;
    this function should have no parameters itself but is used to call your target
    function (the one you originally intend to use) with the necessary arguments.
    This approach is similar to what we did with the `Spawn` function, where the wrapper’s
    sole purpose is to call the `Instantiate` method with specific arguments.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，我们使用`Invoke`来延迟调用`CancelInvoke`。我们没有创建一个自定义函数，因为`CancelInvoke`不接受任何参数。如果你需要安排一个带有参数的函数，你需要创建一个包装函数；这个函数本身没有参数，但用于调用你的目标函数（你最初打算使用的函数）并传递必要的参数。这种方法与我们处理`Spawn`函数的方式类似，其中包装函数的唯一目的是使用特定的参数调用`Instantiate`方法。
- en: 'Now, you can save and set some real values to your spawner. In my case, I used
    the ones shown in the following screenshot:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以为你的生成器保存并设置一些真实值。在我的例子中，我使用了以下截图所示的内容：
- en: '![](img/B21361_06_46_PRE_BOOK.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_46_PRE_BOOK.png)'
- en: 'Figure 6.45: Spawning enemies from the beggining during 5 seconds of the gameplay
    every 0.5 seconds, and 2 per second'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.45：在游戏开始后的5秒内，每0.5秒生成一次敌人，每次生成2个
- en: 'You should see the enemies being spawned next to each other, and because they
    move forward, they will form a row. This behavior will change later when we make
    use of the AI features of Unity in a future chapter. Now, the Visual Scripting
    version will look like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到敌人挨着生成，由于它们向前移动，它们将排成一行。这种行为将在我们未来章节中使用Unity的AI功能时改变。现在，视觉脚本版本将看起来像这样：
- en: '![](img/B21361_06_47_PRE_BOOK.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_47_PRE_BOOK.png)'
- en: 'Figure 6.46: Spawning enemies in Visual Scripting'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46：在视觉脚本中生成敌人
- en: While we could use the `InvokeRepeating` approach in Visual Scripting, here
    we can see some benefits of the visual approach, given that it sometimes has more
    flexibility than coding. In this case, we used the `Wait For Seconds` node at
    the beginning of the `Start`, a node that basically will hold the execution of
    the flow for a couple of seconds. This will create the initial delay we had in
    the original script; that’s why we used the `startTime` as the amount of `Delay`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在视觉脚本中使用`InvokeRepeating`方法，但在这里我们可以看到视觉方法的一些好处，因为它有时比编码更具灵活性。在这种情况下，我们在`Start`的开始处使用了`Wait
    For Seconds`节点，这个节点基本上会暂停流程的执行几秒钟。这将创建原始脚本中存在的初始延迟；这就是为什么我们使用了`startTime`作为`Delay`的数量。
- en: Now, after the wait, we used a `For` loop; for this example, we changed the
    concept of the script, as we want to spawn a specific number of enemies instead
    of spawning during a set time. The `For` loop is essentially a classic `For` that
    will repeat whatever is connected to the `Body` output pin the number of times
    specified by the `Last` input pin.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在等待之后，我们使用了一个`For`循环；在这个例子中，我们改变了脚本的概念，因为我们想要生成特定数量的敌人，而不是在设定的时间内生成。`For`循环本质上是一个经典的`For`循环，它将重复连接到`Body`输出引脚的内容，重复次数由`Last`输入引脚指定的次数。
- en: We connected that pin to a variable to control the number of enemies we wanted
    to spawn. Then, we connected an `Instantiate` to the `Body` output pin of the
    `For` loop to instantiate our enemies and then a `Wait For Seconds` node to stop
    the flow for a set time before the loop can continue spawning enemies.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将那个引脚连接到一个变量，以控制我们想要生成的敌人数量。然后，我们将`For`循环的`Body`输出引脚连接到`Instantiate`，以实例化我们的敌人，然后连接一个`Wait
    For Seconds`节点，在循环可以继续生成敌人之前停止流程一段时间。
- en: 'What is interesting is that if you play the game now, you will receive an error
    in the console that looks like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你现在玩游戏，你将在控制台收到一个看起来像这样的错误：
- en: '![](img/B21361_06_48_PRE_BOOK.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_48_PRE_BOOK.png)'
- en: 'Figure 6.47: Error when using Wait nodes'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.47：使用Wait节点时的错误
- en: 'You can even go back to the Graph Editor and see that the conflicting node
    will be highlighted in red:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以回到Graph Editor，并看到冲突的节点将以红色突出显示：
- en: '![](img/B21361_06_49_PRE_BOOK.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_49_PRE_BOOK.png)'
- en: 'Figure 6.48: Node causing the error'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.48：导致错误的节点
- en: The issue here is that in order for the `Wait For Seconds` nodes to work, you
    need to mark the `Start` event as a **Coroutine**. This will basically allow the
    event to be paused for an amount of time and be resumed later.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，为了让`Wait For Seconds`节点工作，你需要将`Start`事件标记为**Coroutine**。这基本上将允许事件暂停一段时间，然后稍后继续。
- en: 'The concept of coroutines exists in C#, but as it is simpler to implement here
    in Visual Scripting than in C#, we decided to go with this approach here. If you
    want more info about them, please check out this documentation: [https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的概念存在于C#中，但由于在Visual Scripting中比在C#中更容易实现，我们决定采用这种方法。如果你想了解更多信息，请查看以下文档：[https://docs.unity3d.com/Manual/Coroutines.html](https://docs.unity3d.com/Manual/Coroutines.html)
- en: To solve this error, just select the `On Start` event node and check the **Coroutine**
    checkbox in the **Graph Inspector** pane on the left of the **Script Graph** Editor.
    If you don’t see it, try clicking the **Info** button (the circle with *i*) in
    the top-left part of the editor.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个错误，请选择`On Start`事件节点，并在**Script Graph**编辑器的左侧的**Graph Inspector**面板中检查**Coroutine**复选框。如果你看不到它，请尝试在编辑器的左上角点击**Info**按钮（带*i*的圆圈）。
- en: A coroutine is a function that can be paused and resumed later, and that’s exactly
    what the `Wait` node does. Coroutines also exist in `MonoBehaviours`, but let’s
    keep things simple for now.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种可以被暂停并在稍后继续执行的功能，这正是`Wait`节点所做的事情。协程也存在于`MonoBehaviours`中，但现在让我们保持简单。
- en: '![](img/B21361_06_50_PRE_BOOK.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_50_PRE_BOOK.png)'
- en: 'Figure 6.49: Marking Start as a coroutine'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.49：将开始标记为协程
- en: Now that we have discussed timing and spawn, let’s discuss timing and `Destroy`
    to prevent our bullets from living forever in the memory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了时间和生成，让我们讨论时间和`Destroy`，以防止我们的子弹在内存中永远存在。
- en: Destroying objects
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁对象
- en: 'We can use the `Destroy` function to destroy object instances. The idea is
    to make bullets have a script that schedules their own auto-destruction after
    a while to prevent them from living forever. We will create the script by following
    these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Destroy`函数来销毁对象实例。想法是让子弹有一个脚本，在一段时间后安排自己的自动销毁，以防止它们永远存在。我们将通过以下步骤创建脚本：
- en: Select the Prefab of `Bullet`, and add a script called `Autodestroy` to it,
    as you did with other objects using the **Add Component** | **New Script** option.
    This time, the script will be added to the Prefab, and each instance of the Prefab
    you spawn will have it.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Bullet`的Prefab，并使用**Add Component** | **New Script**选项添加一个名为`Autodestroy`的脚本，就像你为其他对象所做的那样。这次，脚本将添加到Prefab中，并且你生成的Prefab的每个实例都将拥有它。
- en: You can use the `Destroy` function, as shown in the next screenshot, to destroy
    the object just once in `Start`:![](img/B21361_06_51_PRE_BOOK.png)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用`Destroy`函数，如下一张截图所示，在`Start`中一次性销毁对象：![](img/B21361_06_51_PRE_BOOK.png)
- en: 'Figure 6.50: Destroying an object when it starts'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.50：对象开始时销毁
- en: The `Destroy` function expects the object to destroy as the first argument,
    and here, we use the `gameObject` reference—a way to point to the GameObject that
    our script is placed into to destroy it. If you use the `this` pointer instead
    of `GameObject`, we will destroy only the `Autodestroy` component we are creating.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Destroy`函数期望将对象作为第一个参数，在这里，我们使用`gameObject`引用——这是一种指向放置脚本的GameObject的方式，以便将其销毁。如果你使用`this`指针而不是`GameObject`，我们只会销毁我们正在创建的`Autodestroy`组件。'
- en: Of course, we don’t want the bullet to be destroyed as soon as it is spawned,
    so we need to delay the destruction. You may be thinking about using `Invoke`,
    but unlike most functions in Unity, `Destroy` can receive a second argument, which
    is the time to wait until destruction.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们不想在子弹被生成后立即销毁它，所以我们需要延迟销毁。你可能正在考虑使用`Invoke`，但与Unity中的大多数函数不同，`Destroy`可以接收第二个参数，即等待销毁的时间。
- en: 'Create a delay field to use as the second argument of `Destroy`, as shown in
    the next screenshot:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个延迟字段，将其用作`Destroy`的第二个参数，如下一个截图所示：
- en: '![](img/B21361_06_52_PRE_BOOK.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_52_PRE_BOOK.png)'
- en: 'Figure 6.51: Using a field to configure the delay to destroy the object'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.51：使用字段配置销毁对象的延迟
- en: Set the `delay` field to a proper value; in my case, 5 was enough. Now, check
    how the bullets despawn (i.e., are removed) after a while by looking at them being
    removed from the Hierarchy.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`delay`字段设置为适当的值；在我的情况下，5就足够了。现在，通过观察它们从层次结构中被移除，检查子弹经过一段时间后是如何消失的（即被移除）。
- en: 'The Visual Scripting equivalent will look like this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉脚本等效的代码如下所示：
- en: '![](img/B21361_06_53_PRE_BOOK.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_53_PRE_BOOK.png)'
- en: 'Figure 6.52: Destroying in Visual Scripting'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.52：在视觉脚本中销毁
- en: Regarding this version, note how we use the **Component Destroy** (**Obj** and
    **T**)version of the `Destroy` node, which includes the delay time. Additionally,
    look for the `Object Pool`concept, which is a way to recycle objects instead of
    creating them constantly; you will learn that sometimes creating and destroying
    objects is not that performant.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个版本，注意我们如何使用**组件销毁**（**Obj**和**T**）版本的`Destroy`节点，它包括延迟时间。此外，寻找`Object Pool`概念，这是一种回收对象而不是不断创建对象的方法；你将了解到有时创建和销毁对象并不那么高效。
- en: Now, we can create and destroy objects at will, which is something very common
    in Unity scripting. In the next section, we will discuss how to modify the scripts
    we have created so far to support the new Unity Input System.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以随意创建和销毁对象，这在Unity脚本中是非常常见的。在下一节中，我们将讨论如何修改我们迄今为止创建的脚本以支持新的Unity输入系统。
- en: Using the new Input System
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的输入系统
- en: We have been using the **Input** class to detect the buttons and axes being
    pressed, and for our simple usage, that is more than enough. However, the default
    Unity Input System has its limitations regarding extensibility to support new
    input hardware and mappings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用**输入**类来检测被按下的按钮和轴，对于我们的简单使用，这已经足够了。然而，默认的Unity输入系统在扩展性方面有其局限性，无法支持新的输入硬件和映射。
- en: 'In this section, we will explore the following concepts:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下概念：
- en: Installing the new Input System
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新的输入系统
- en: Creating Input Mappings
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建输入映射
- en: Using mappings in scripts
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本中使用映射
- en: Let’s start exploring how to install the new Input System.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索如何安装新的输入系统。
- en: Installing the new Input System
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装新的输入系统
- en: To start using the new Input System, it needs to be installed like any other
    package we have installed so far, using the **Package Manager**. The package is
    just called **Input System**, so go ahead and install it as usual. In this case,
    we are using version 1.7.0, but a newer one may be available by the time you read
    this chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用新的输入系统，它需要像我们迄今为止安装的任何其他包一样安装，使用**包管理器**。这个包只是叫做**输入系统**，所以按照常规安装即可。在这种情况下，我们使用版本1.7.0，但当你阅读这一章时，可能有一个更新的版本可用。
- en: '![](img/B21361_06_54.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_54.png)'
- en: 'Figure 6.53: Installing the new Input System package'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.53：安装新的输入系统包
- en: 'By default, when you install the Input System, it will prompt you to enable
    the new Input System, with a window like the one in the following image. If that
    appears, just click **Yes** and wait for Unity to restart:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你安装输入系统时，它将提示你启用新的输入系统，窗口如下面的图像所示。如果出现，只需点击**是**并等待Unity重新启动：
- en: '![](img/B21361_06_55_PRE_BOOK.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_55_PRE_BOOK.png)'
- en: 'Figure 6.54: Switching the active Input System'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.54：切换活动输入系统
- en: If, for some reason, that doesn’t appear, the alternative is going to **Edit
    | Project Settings** and then **Player | Other Settings | Configuration**, and
    setting the **Active Input Handling** property to **Input System Package (New)**.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因它没有出现，另一种选择是**编辑 | 项目设置**然后**玩家 | 其他设置 | 配置**，并将**活动输入处理**属性设置为**输入系统包（新**）。
- en: There’s an option called **Both** to keep both the old input system and the
    new one enabled, but let’s stick with just one.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**Both**的选项，可以同时启用旧输入系统和新输入系统，但让我们只使用一个。
- en: '![](img/B21361_06_56.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_56.png)'
- en: 'Figure 6.55: Switching the active Input System'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.55：切换活动输入系统
- en: Now that we have the system installed and set up, let’s explore how to create
    the Input Mappings needed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并设置了系统，让我们来探索如何创建所需的输入映射。
- en: Creating Input Mappings
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输入映射
- en: The new system has a way to directly request the current state of a button or
    thumbstick to the gamepad, mouse, keyboard, or whatever other device we have,
    like what we have done so far with the previous Input System. However, using this
    method would prevent us from using one of the best features of the system, Input
    Mappings.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统有一种直接请求游戏手柄、鼠标、键盘或我们拥有的任何其他设备（如我们之前在输入系统中所做的那样）的按钮或摇杆当前状态的方法。然而，使用这种方法将阻止我们使用系统的最佳功能之一，即输入映射。
- en: The idea of an Input Mapping is to abstract input actions from the physical
    input. Instead of thinking about the space bar, the left thumbstick of a gamepad,
    or the right click of a mouse, you think in terms of actions, like moving, shooting,
    or jumping. In code, you ask if the `Shoot` button has been pressed, or the current
    value of the `Move` axes, as we did with the mouse axes rotation. While the previous
    system supported a certain degree of Input Mapping, the one in the new Input System
    is way more powerful and easier to configure.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 输入映射的想法是将输入动作从物理输入中抽象出来。不是考虑空格键、游戏手柄的左侧摇杆或鼠标的右键点击，而是从动作的角度思考，比如移动、射击或跳跃。在代码中，你询问是否按下了`射击`按钮，或者`移动`轴的当前值，就像我们用鼠标轴旋转所做的那样。虽然先前的系统支持一定程度的输入映射，但新输入系统的功能更强大，配置也更简单。
- en: '| **Action** | **Mappings** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **动作** | **映射** |'
- en: '| Shoot | Left mouse button, Left Control, and the *X* button of the gamepad
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 射击 | 左鼠标按钮、左控制键和游戏手柄的 *X* 按钮 |'
- en: '| Jump | Space, *Y* button of gamepad |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 跳跃 | 空格键，游戏手柄的 *Y* 按钮 |'
- en: '| Horizontal movement | *A* and *D* keys, Left and Right arrows, and the gamepad
    Left Stick |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 水平移动 | *A* 和 *D* 键，左右箭头，以及游戏手柄的左侧摇杆 |'
- en: 'Table 6.01: Example of the Input Mapping table'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.01：输入映射表示例
- en: The power of this idea is that the actual keys or buttons that will trigger
    these actions are configurable in the Unity editor, allowing any game designed
    to alter the exact keys to control the entire game without changing the code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的力量在于，实际触发这些动作的键或按钮可以在Unity编辑器中配置，允许任何游戏设计者更改控制整个游戏的精确键，而无需更改代码。
- en: We can even map more than one button to the same action, even from different
    devices, so we can make the mouse, keyboard, and gamepad trigger the same action,
    greatly simplifying our code. Another benefit is that the user can also rebind
    the keys with some custom UI that we can add to our game, which is very common
    in PC games.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将多个按钮映射到同一动作，即使来自不同的设备，这样我们就可以使鼠标、键盘和游戏手柄触发相同的动作，极大地简化了我们的代码。另一个好处是，用户还可以通过我们添加到游戏中的某些自定义UI重新绑定按键，这在PC游戏中非常常见。
- en: 'The easiest way to start creating an Input Mapping is through the **Player
    Input** component. This component, as the name suggests, represents the input
    of a particular player, allowing us to have one of those on each player in our
    game to support split-screen multiplayer, but let’s focus on single-player. Adding
    this script to our player will allow us to use the **Create Actions** button to
    create a default Input Mapping asset. This asset, as a material, can be used by
    several players, so we will modify it so that it will affect all of them (for
    example, by the addition of the `Jump` Input Mapping):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建输入映射的最简单方法是通过**玩家输入**组件。正如其名所示，该组件代表特定玩家的输入，使我们能够在游戏中每个玩家身上都有一个，以支持分屏多人游戏，但让我们先专注于单人游戏。将此脚本添加到我们的玩家中，将允许我们使用**创建动作**按钮创建默认的输入映射资产。这个资产，作为一个材料，可以被多个玩家使用，因此我们将对其进行修改，使其影响所有玩家（例如，通过添加`Jump`输入映射）：
- en: '![](img/B21361_06_57_PRE_BOOK.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_57_PRE_BOOK.png)'
- en: 'Figure 6.56: Creating input action assets using the Player Input component'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.56：使用玩家输入组件创建输入动作资产
- en: 'After clicking the **Create Actions** button and saving the asset location
    in the save prompt, you will see the following screen:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**创建动作**按钮并保存资产位置到保存提示后，您将看到以下屏幕：
- en: '![](img/B21361_06_58_PRE_BOOK.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_58_PRE_BOOK.png)'
- en: 'Figure 6.57: The default Input Mapping file'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.57：默认输入映射文件
- en: The first part to understand from this asset is the **Action Maps** section
    (the left panel). This allows us to create separate Action Maps for different
    situations, for example, for driving and on-foot controls in games like Grand
    Theft Auto (**GTA***)*. By default, **Player** and **UI** mappings are created
    to separate the mappings for the player controlling and navigating through the
    UI. If you check the **Player Input** component again, you will see that the **Default
    Map** property is set to **Player**, which means that we will only concern ourselves
    with the player controlling the Input Mappings in this GameObject; any UI action
    pressed won’t be considered. We can switch the active map in runtime at will,
    for example, to disable the character controller input when we are in the pause
    menu or switch to the driving mappings while in a car, using the same buttons
    but for other purposes.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '从这个资产中，我们首先需要理解的是**动作映射**部分（左侧面板）。这允许我们为不同的情况创建单独的动作映射，例如，在像《侠盗猎车手》（**GTA**）这样的游戏中，为驾驶和步行控制创建不同的动作映射。默认情况下，**玩家**和**UI**映射被创建来分离玩家控制和导航UI的映射。如果您再次检查**玩家输入**组件，您会看到**默认映射**属性被设置为**玩家**，这意味着我们将只关注在这个GameObject中控制输入映射的玩家；任何UI动作的按下都不会被考虑。我们可以在运行时随意切换活动映射，例如，在暂停菜单中禁用角色控制器输入，或者在车内切换到驾驶映射，使用相同的按钮，但用于其他目的。 '
- en: 'If you select an Action Map in the left panel, you will see all the actions
    it contains in the **Actions** list in the middle panel. In the case of the **Player**,
    we have the **Move**, **Look**, and **Fire** mappings, which are exactly the inputs
    we will use in our game. Bear in mind you can add more if you need to use the
    **+** button, but for now, let’s stick with the default ones. When you select
    any action from the list, you will see their configurations in the **Action Properties**
    panel shown on the right:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在左侧面板中选择动作映射，您将在中间面板的**动作**列表中看到它包含的所有动作。在**玩家**的情况下，我们有**移动**、**观察**和**射击**映射，这些正是我们将在游戏中使用的输入。请注意，如果您需要使用**+**按钮，您可以添加更多映射，但现在让我们坚持使用默认的映射。当您从列表中选择任何动作时，您将在右侧显示的**动作属性**面板中看到它们的配置：
- en: '![](img/B21361_06_59_PRE_BOOK.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_59_PRE_BOOK.png)'
- en: 'Figure 6.59: The Move (left) and Fire (right) action configurations'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.59：移动（左侧）和射击（右侧）动作配置
- en: As you can see, there’s a property called **Action Type** that will dictate
    which kind of input we are talking about. If you select **Move** in the middle
    panel, you can see that it’s a **Value** action type, with **Control Type** being
    `Vector2`, meaning it will return the x and y axis values, the horizontal and
    vertical values—the kind we expect from any thumbstick in a gamepad. In the previous
    system, we got those values from separate 1D axes, like the `Mouse X` and `Mouse
    Y` axes, but here, they are combined into a single variable for convenience. On
    the other hand, the **Fire** action is of type **Button**, which has the capacity
    not only to check its current state (pressed or released) but also do checks for
    things such as whether it has just been pressed or just released, the equivalents
    to `GetKey`, `GetKeyDown`, and `GetKeyUp` from the previous system.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个名为**动作类型**的属性，它将决定我们正在讨论哪种类型的输入。如果您在中间面板中选择**移动**，您会看到它是一个**值**动作类型，**控制类型**为`Vector2`，这意味着它将返回x轴和y轴的值，即水平和垂直的值——这是我们期望从任何游戏手柄的摇杆中得到的类型。在之前的系统中，我们从单独的1D轴中获取这些值，例如`鼠标X`和`鼠标Y`轴，但在这里，为了方便起见，它们被合并成一个单一变量。另一方面，**射击**动作的类型是**按钮**，它不仅能够检查其当前状态（按下或释放），还能进行诸如是否刚刚被按下或刚刚被释放的检查，这与之前系统中的`GetKey`、`GetKeyDown`和`GetKeyUp`功能相当。
- en: Now that we understand which actions we have and of which type each one is,
    let’s discuss how the physical input will trigger them. You can click the arrow
    on the left of each action in the middle panel to see its physical mappings. Let’s
    start exploring the **Move** action mappings.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们有哪些动作以及每种动作的类型，让我们讨论物理输入如何触发它们。您可以通过点击中间面板中每个动作左侧的箭头来查看其物理映射。让我们开始探索**移动**动作映射。
- en: 'In this case, we have four mappings:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有四个映射：
- en: '**Left Stick** [**Gamepad**]: The left stick of the gamepad'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧摇杆** [**游戏手柄**]：游戏手柄的左侧摇杆'
- en: '**Primary 2D Axis** [**XR Controller**]: The main stick of the VR controllers'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要2D轴** [**XR控制器**]：VR控制器的摇杆'
- en: '**Stick** [**Joystick**]: The main stick for arcade-like joysticks or even
    flight sticks'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摇杆** [**操纵杆**]：类似街机或甚至飞行杆的主要摇杆'
- en: '**WASD**: A composite input simulating a stick through the *W*, *A*, *S*, and
    *D* keys'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASD**：通过*W*、*A*、*S*和*D*键模拟摇杆的复合输入'
- en: 'If you select any of them, you can check their configurations; let’s compare
    the left stick and WASD as an example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择其中的任何一个，你可以检查它们的配置；让我们以左摇杆和WASD为例进行比较：
- en: '![](img/B21361_06_60_PRE_BOOK.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_60_PRE_BOOK.png)'
- en: 'Figure 6.59: The left stick mapping (left) and the WASD key mapping (right)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.59：左摇杆映射（左）和WASD键映射（右）
- en: 'In the case of the **Left Stick**, you can see the **Path** property that allows
    you to pick all the possible hardware physical controls that provide `Vector2`
    values (the x and y axes). In the case of the **WASD** key mapping, you can see
    it is a composite binding of type **2D Vector**, which, as stated previously,
    allows us to simulate a 2D axis with other inputs—keys in this case. If you expand
    the **WASD** Input Mappings in the middle panel, you can see all inputs that are
    composited for this 2D axis and their configurations by selecting them:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在**左摇杆**的情况下，你可以看到允许你选择所有可能提供`Vector2`值（x轴和y轴）的硬件物理控制的**路径**属性。在**WASD**键映射的情况下，你可以看到它是一个类型为**2D向量**的复合绑定，正如之前所述，这允许我们通过其他输入（在这种情况下是按键）来模拟2D轴。如果你展开中间面板中的**WASD**输入映射，你可以看到为这个2D轴组合的所有输入及其配置，通过选择它们来查看：
- en: '![](img/B21361_06_61_PRE_BOOK.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_61_PRE_BOOK.png)'
- en: 'Figure 6.60: The inputs considered for the WASD composite 2D axis'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.60：考虑的WASD复合2D轴的输入
- en: In the preceding case, it maps not only the *W*, *A*, *S*, and *D* buttons but
    also the four keyboard arrows. Each one of those mappings has not only a path
    to select the physical button but also the **Composite Part** setting, allowing
    us to specify which direction this input will pull the simulated stick.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，它不仅映射了*W*、*A*、*S*和*D*按钮，还映射了四个键盘箭头。每个映射不仅有一个选择物理按钮的路径，还有一个**复合部分**设置，允许我们指定这个输入将拉动模拟摇杆的方向。
- en: And with this, we have just scratched the surface of what this system is capable
    of, but for now, let’s keep things simple and use these settings as they are.
    Remember that a new asset was created with the same name as our game (*SuperShooter*,
    in our case) in the root folder of the project. You can reopen this Action Mapping
    window by double-clicking it whenever you want. Now let’s see how we can use these
    inputs in our code.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们刚刚触及了这个系统所能做到的一小部分，但到目前为止，让我们保持简单，并使用这些设置。记住，在项目的根目录中创建了一个与我们的游戏同名的新资产（在我们的例子中是*SuperShooter*）。你可以随时通过双击它来重新打开这个动作映射窗口。现在让我们看看我们如何在代码中使用这些输入。
- en: 'There’s much more this system can do for us. One example is Interactions, which
    allow us to do things like making the input trigger the action if it’s pressed
    for *X* amount of time. Another is Composite, which triggers the action if a combination
    of keys is pressed. Check the Input System package documentation here for more
    information: [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统还能为我们做更多的事情。一个例子是交互，它允许我们执行诸如在按下*X*段时间内触发动作等操作。另一个例子是复合，当按下按键组合时触发动作。有关更多信息，请查看输入系统包文档：[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6)
- en: Using Mappings in our scripts
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的脚本中使用映射
- en: This Input System provides several ways to detect the input state. The **Player
    Input** component has a **Behavior** property to switch between some of the available
    modes. The simplest one is the one called **Send Messages**, which is the one
    that we will use to execute methods in our code when the keys are pressed. In
    this mode, each action in the mappings will have its own event, and you can see
    all of them in the tooltip at the bottom of the component. As you add mappings,
    more will appear.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输入系统提供了几种检测输入状态的方法。**玩家输入**组件有一个**行为**属性，可以在一些可用模式之间切换。最简单的一个是称为**发送消息**的模式，这是我们将在按键按下时在代码中执行方法所使用的模式。在这个模式下，映射中的每个动作都将有自己的事件，你可以在组件底部的工具提示中看到所有这些。随着你添加映射，将出现更多。
- en: '![](img/B21361_06_62_PRE_BOOK.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_62_PRE_BOOK.png)'
- en: 'Figure 6.61: All the input events for the default mapping'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.61：默认映射的所有输入事件
- en: 'For more information about the other PlayerInput behavior modes, check out
    its documentation here: [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于其他PlayerInput行为模式的信息，请查看以下文档：[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/PlayerInput.html#notification-behaviors)
- en: 'From the list, we will need `OnMove`, `OnLook`, and `OnFire`. We can modify
    our `PlayerMovement` script to use them, like in the following screenshot:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中，我们需要`OnMove`、`OnLook`和`OnFire`。我们可以修改我们的`PlayerMovement`脚本以使用它们，如下面的截图所示：
- en: '![](img/B21361_06_63_PRE_BOOK.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21361_06_63_PRE_BOOK.png)'
- en: 'Figure 6.62: PlayerMovement with the new Input System'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.62：使用新输入系统的PlayerMovement
- en: The first difference you will notice is that we don’t request the status of
    the input in the `Update` method as we did before. Instead, we listen to the `OnMove`
    and `OnLook` events, which provide us with an `InputValue` parameter containing
    the current state of those axes. The idea is that every time these axes change
    value, these events will execute, and if the values don’t change, like when the
    player keeps pushing the stick all the way to the right, they won’t be executed.
    That’s why we need to store the current value in the `movementValue` and `lookValue`
    variables—to use the latest value of the axis later in the `Update` and apply
    the movement in every frame. Consider those as private, meaning they won’t appear
    in the editor, but that’s fine for our purposes. Also, observe that we added the
    `using UnityEngine.InputSystem` line at the top of the file to enable the usage
    of the new Input System in our script.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到的一个不同点是，我们不再像以前那样在`Update`方法中请求输入状态。相反，我们监听`OnMove`和`OnLook`事件，这些事件为我们提供了一个包含那些轴当前状态的`InputValue`参数。想法是，每当这些轴的值发生变化时，这些事件就会执行，如果值没有变化，比如当玩家一直将摇杆推到最右边时，它们就不会执行。这就是为什么我们需要在`movementValue`和`lookValue`变量中存储当前值——以便在`Update`方法中稍后使用轴的最新值，并在每一帧中应用移动。将这些视为私有，意味着它们不会出现在编辑器中，但对我们来说这没问题。此外，注意我们在文件顶部添加了`using
    UnityEngine.InputSystem`行，以启用脚本中新的输入系统的使用。
- en: In this version of the `PlayerMovement` script, we used the axis input type
    like we did with the mouse before but also for movement, unlike the previous version
    that used buttons. This is the preferred option most of the time, so we will stick
    with that version. Observe how we use a single `transform.Translate` to move;
    we need to use the x axis of `movementValue` to move the x axis of our player,
    but we use the y axis of `movementValue` to move the z axis of our player. We
    don’t want to move our player vertically, so that’s why we needed to split the
    axis this way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`PlayerMovement`脚本中，我们使用了与鼠标相同的轴输入类型，但这次也用于移动，而之前的版本使用的是按钮。这通常是首选选项，所以我们将坚持使用这个版本。观察我们如何使用单个`transform.Translate`来移动；我们需要使用`movementValue`的x轴来移动玩家的x轴，但我们使用`movementValue`的y轴来移动玩家的z轴。我们不希望玩家垂直移动，这就是为什么我们需要以这种方式拆分轴。
- en: The `InputValue` parameter has the `Get<Vector2>()` method, which will give
    us the current value of both axes, given that `Vector2` is a variable that contains
    the x and y properties. Then, we multiply the vector by the movement or rotation
    speed according to the case. You will notice that we don’t multiply by `Time.deltaTime`
    in the axis events, but we do that in the `Update`. That’s because `Time.deltaTime`
    can change between frames, so storing the movement value while considering the
    `Time.deltaTime` of the last time we moved the stick won’t be useful for us. Also,
    notice how `movementValue` is a `Vector2`, just a combination of the x and y axes,
    while `lookValue` is a simple float. We did it this way because we will rotate
    our character only by following the lateral movement of the mouse; we don’t want
    to rotate it up and down. Check that we extract `value.Get<Vector2>().x`, with
    emphasis on the `.x` part, where we extract just the horizontal part of the axis
    for our calculations.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputValue`参数具有`Get<Vector2>()`方法，它将给出两个轴的当前值，前提是`Vector2`是一个包含x和y属性的变量。然后，我们根据情况将向量乘以移动或旋转速度。你会注意到在轴事件中我们没有乘以`Time.deltaTime`，但在`Update`中我们这样做。这是因为`Time.deltaTime`可以在帧之间变化，所以考虑我们上次移动摇杆时的`Time.deltaTime`来存储移动值对我们来说将没有用。此外，注意`movementValue`是一个`Vector2`，仅仅是x和y轴的组合，而`lookValue`是一个简单的浮点数。我们这样做是因为我们将只通过跟随鼠标的横向移动来旋转我们的角色；我们不希望它上下旋转。检查我们提取`value.Get<Vector2>().x`，重点在于`.x`部分，我们只提取轴的横向部分用于计算。'
- en: 'Regarding the `PlayerShooting` component, we need to change it to this:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`PlayerShooting`组件，我们需要将其更改为这样：
- en: '![](img/B21361_06_64_PRE_BOOK.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_64_PRE_BOOK.png)'
- en: 'Figure 6.63: PlayerShooting script using the new Input System'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.63：使用新输入系统的PlayerShooting脚本
- en: 'This case is simpler, as we don’t need to execute the shooting behavior for
    each frame; we only need to execute something at the very same moment the input
    is pressed, which is exactly when the `OnFire` event will be executed. If you
    also need to detect when the key was released, you can add the `InputValue` parameter,
    as we did with `OnMove` and `OnLook`, and consult the `isPressed` property:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况比较简单，因为我们不需要为每一帧执行射击行为；我们只需要在输入被按下时执行某些操作，这正是`OnFire`事件将被执行的时刻。如果你还需要检测键何时被释放，你可以添加`InputValue`参数，就像我们在`OnMove`和`OnLook`中做的那样，并查看`isPressed`属性：
- en: '![](img/B21361_06_65_PRE_BOOK.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_65_PRE_BOOK.png)'
- en: 'Figure 6.64: Getting the state of the button'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.64：获取按钮的状态
- en: 'Regarding the Visual Script Machine version of our scripts, first, you will
    need to refresh the **Visual Script Node Library** by going to **Edit | Project
    Settings | Visual Scripting** and clicking the **Regenerate Nodes** button. If
    you don’t do this, you won’t see the new Input System nodes:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们脚本的Visual Script Machine版本，首先，你需要通过转到**编辑 | 项目设置 | 视觉脚本**并点击**重新生成节点**按钮来刷新**视觉脚本节点库**。如果你不这样做，你将看不到新的输入系统节点：
- en: '![](img/B21361_06_66_PRE_BOOK.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_66_PRE_BOOK.png)'
- en: 'Figure 6.65: Regenerating Visual Scripting nodes to support the new Input System'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.65：重新生成支持新输入系统的视觉脚本节点
- en: 'Now, the `PlayerShooting` visual script should look like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlayerShooting`视觉脚本应该看起来像这样：
- en: '![](img/B21361_06_67_PRE_BOOK.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_67_PRE_BOOK.png)'
- en: 'Figure 6.66: Instantiating bullets with the new Input System'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.66：使用新输入系统实例化子弹
- en: The new **On Input System Event Button** node allows us to detect when an action
    button has been pressed and react accordingly. You can pick the specific action
    in the **Input Action** parameter, and you can even make the node react to the
    pressure, release, or hold states of the button with the option right below the
    node’s title. There is a bug where the **Input Action** property might not show
    any option; in such cases, try removing and adding the node again in the graph
    and check that you added the `ScriptMachine` component to the same GameObject
    that has the `PlayerInput` component. Also, ensure that you selected the Player
    GameObject in the Hierarchy.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**输入系统事件按钮**节点允许我们检测动作按钮何时被按下，并相应地做出反应。你可以在**输入动作**参数中选择特定的动作，你甚至可以使用节点标题下面的选项使节点对按钮的压力、释放或保持状态做出反应。存在一个错误，即**输入动作**属性可能不会显示任何选项；在这种情况下，尝试在图中重新添加和删除节点，并确保你添加了`ScriptMachine`组件到具有`PlayerInput`组件的同一GameObject。此外，请确保你在层次结构中选择了Player
    GameObject。
- en: 'Regarding movement, it can be achieved this way:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动，可以这样实现：
- en: '![](img/B21361_06_68_PRE_BOOK.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21361_06_68_PRE_BOOK.png)'
- en: 'Figure 6.67: Moving with the new Input System'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.67：使用新的输入系统移动
- en: In this case, we used the **On Input System Event Vector2** node. This time,
    we used the `OnHold` mode, which means that, unlike the C# version, it won’t execute
    just when the axis changes, but all the frames when the axis is pressed act like
    an `Update`; that, however, will only execute when the user presses the stick.
    The output pin of the node is the `Vector2` value, so we multiply it by the `speed`
    variable (declared in the `Variables` component of our player) and by `DeltaTime`.
    Finally, we use the `Vector2` `GetX` and `Vector2` `GetY` nodes to translate over
    the x and z axes. You may have trouble when rewiring the **Multiply** nodes with
    the new **Input System** node, given that the return type is different compared
    to the previously used node (a `Vector2` instead of a single float). I recommend
    just deleting all nodes in this graph and redoing them to make sure everything
    is fine. This way, we make our scripts react to the input messages from Unity’s
    new Input System.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 **On Input System Event Vector2** 节点。这次，我们使用了 `OnHold` 模式，这意味着与
    C# 版本不同，它不会仅在轴变化时执行，而是在轴被按下的所有帧都像 `Update` 一样执行；然而，这只有在用户按下摇杆时才会执行。节点的输出引脚是 `Vector2`
    值，因此我们将其乘以 `speed` 变量（在玩家的 `Variables` 组件中声明）和 `DeltaTime`。最后，我们使用 `Vector2 GetX`
    和 `Vector2 GetY` 节点在 x 和 z 轴上平移。由于与之前使用的节点（`Vector2` 而不是单个浮点数）的返回类型不同，您可能会在重新连接新的
    **Input System** 节点时遇到麻烦。我建议删除此图中的所有节点并重新创建它们，以确保一切正常。这样，我们使我们的脚本能够对 Unity 新输入系统的输入消息做出反应。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We created our first real scripts in this chapter, which provide useful behavior.
    We discussed how to move a GameObject based on input and instantiate Prefabs via
    scripting, creating objects at will according to the game situation. Also, we
    saw how to schedule actions—in this case, spawning—but this can be used to schedule
    anything. We saw how to destroy created objects to avoid increasing the number
    of objects to an unmanageable level. Finally, we explored the new Input System
    to provide maximum flexibility to customize our game’s input. We will use these
    actions to create other kinds of objects, such as sounds and effects, later in
    this book.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了第一个真正的脚本，这些脚本提供了有用的行为。我们讨论了如何根据输入移动 GameObject 以及通过脚本实例化 Prefabs，根据游戏情况随意创建对象。我们还看到了如何安排动作——在这种情况下，生成——但这可以用来安排任何事物。我们看到了如何销毁创建的对象以避免对象数量增加到无法管理的水平。最后，我们探索了新的输入系统，以提供最大的灵活性来自定义游戏的输入。我们将在本书的后面部分使用这些动作来创建其他类型的对象，例如声音和效果。
- en: Now, you are able to create any type of movement or spawning logic that your
    objects will need, and you can make sure those objects are destroyed when needed.
    You might think that all games move and create shooting systems in the same way,
    and while they are similar, being able to create your own movement and shooting
    scripts allows you to customize those aspects of the game to behave as you intend,
    creating the exact experience you are looking for.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您能够创建任何类型的移动或生成逻辑，您的对象将需要这些逻辑，并且您可以在需要时确保这些对象被销毁。您可能会认为所有游戏都以相同的方式移动和创建射击系统，尽管它们是相似的，但能够创建自己的移动和射击脚本允许您自定义游戏中的这些方面，使其按您的意图行事，创造出您所寻找的精确体验。
- en: In the next chapter, we will discuss how to detect collisions to prevent the
    player and bullets from passing through walls and much more.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何检测碰撞以防止玩家和子弹穿过墙壁以及更多内容。
- en: Learn more on Discord
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多信息
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity 游戏开发专家和作者本人一起阅读此书。提出问题，为其他读者提供解决方案，通过 Ask Me Anything 会话与作者聊天等等。扫描二维码或访问链接加入社区：
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/unitydev](https://packt.link/unitydev)'
- en: '![](img/QR_Code1498477041053909218.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code1498477041053909218.png)'
