- en: Object Pool
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池
- en: The Object Pool pattern is straightforward to understand; as its name suggests,
    it organizes a pool of objects. The simplest way to visualize the design intent
    behind this pattern is to imagine a swimming pool filled to the brim with balloons
    of various colors. If you wish, you can take all the green ones out, play with
    them and, once done, put them back. In other words, you always have a collection
    of specific types of objects ready to be used, and a place to store them afterward.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式很容易理解；正如其名所示，它组织了一个对象池。可视化这个模式背后的设计意图的最简单方式是想象一个装满了各种颜色气球的游泳池。如果你愿意，你可以拿出所有的绿色气球，玩一玩，完成后，再放回去。换句话说，你始终有一组特定类型的对象可供使用，并在之后有一个地方来存储它们。
- en: If we translate this concept into code, what we have is specific types of objects
    already contained in memory, which we can pull from when we need and then pool
    them back into memory when we are finished. This approach means we are using a
    constant size of reserved memory for specific types of ready-made objects. As
    you may already presume, this is a very optimized way of managing objects for
    a video game project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个概念转化为代码，我们得到的是已经包含在内存中的特定类型的对象，当我们需要时可以从中提取，完成后再将它们池化回内存。这种方法意味着我们为特定类型的现成对象使用了一个恒定的预留内存大小。正如你可能已经预想的，这对于视频游戏项目来说是一种非常优化的对象管理方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: We will review the basics of the Object Pool pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾对象池模式的基础知识
- en: We will implement the Object Pool pattern to manage reusable game objects for
    a zombie game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现对象池模式来管理僵尸游戏的可重用游戏对象
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is hands-on; you will need to have a basic understanding of Unity
    and C#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的；你需要对Unity和C#有基本的了解。
- en: 'We will be using the following specific Unity engine and C# language concepts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下特定的Unity引擎和C#语言概念：
- en: Prefabs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制体
- en: Singletons
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Namespaces
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)'
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，看看代码的实际应用：
- en: '[http://bit.ly/2WutcB2](http://bit.ly/2WutcB2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2WutcB2](http://bit.ly/2WutcB2)'
- en: An overview of the Object Pool pattern
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象池模式的概述
- en: The Object Pool pattern is usually defined as a creational design pattern in
    academic documentation, but in this book, we have categorized it as an optimization
    pattern, because its core purpose is more aligned with optimization than the creation
    process – at least in the way we are going to use it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式通常在学术文档中被定义为一种创建型设计模式，但在这本书中，我们将它归类为优化模式，因为其核心目的与优化比创建过程更契合——至少在我们将要使用它的方式上是这样。
- en: The core concept of this pattern is simple; a pool in the form of a container
    holds a collection of initialized objects. Clients can request the Object Pool
    for a specific type and number of objects. The Client must return the objects
    to the Object Pool once it's done using them. So, this means the pool always get
    filled back up, and is never drained.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的核心概念很简单；一个以容器形式存在的池子包含了一组初始化后的对象。客户端可以请求对象池提供特定类型和数量的对象。一旦客户端使用完毕，必须将对象返回给对象池。这意味着池子总是会被填满，而不会耗尽。
- en: 'The following diagram illustrates the back and forth between the `Client` and
    the `ObjectPool`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了`Client`和`ObjectPool`之间的来回交互：
- en: '![](img/55cefb52-61e0-4305-8ec2-5a7e41f4307c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55cefb52-61e0-4305-8ec2-5a7e41f4307c.png)'
- en: As you can see, the `Reusable Object` is always in memory; it is just its owner
    that switches between the Client and `ObjectPool`, depending on whether it's in
    an acquired or released state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，可重用对象始终在内存中；只是它的所有者会在客户端和`ObjectPool`之间切换，这取决于它是否处于获取或释放状态。
- en: Benefits and drawbacks
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和缺点
- en: 'The Object Pool pattern is quite popular with Unity developers, but it has
    its critics in the broader software development community:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池模式在Unity开发者中相当受欢迎，但在更广泛的软件开发社区中也有其批评者：
- en: '**Benefits**:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: '**Predictable memory usage**: Because the Object Pool pattern is configurable,
    you can set limits for the number of instances of specific objects available.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测的内存使用**：由于对象池模式是可配置的，您可以设置特定对象实例数量的限制。'
- en: '**Performance boost**: By having objects already initialized in memory, you
    avoid the loading cost of initializing new ones.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能提升**：由于对象已经在内存中初始化，因此避免了初始化新对象时的加载成本。'
- en: '**Drawbacks**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点**:'
- en: '**Layering on already-managed memory**: Some criticize the Object Pool pattern
    as being unnecessary in most cases, because modern managed programming languages
    such as C# already optimally control memory allocation.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在已管理的内存上分层**：有些人批评对象池模式在大多数情况下是不必要的，因为现代托管编程语言如C#已经最优地控制内存分配。'
- en: '**Unpredictable object states**: The main pitfall of the Object Pool pattern
    is that, if incorrectly managed, objects will be returned to the pool in their
    current state instead of their default one. This issue can cause unpredictable
    behaviors the next time they are pulled out of the pool, because objects might
    be in an unexpected state.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可预测的对象状态**：对象池模式的主要缺陷在于，如果管理不当，对象将不会返回到其默认状态，而是返回到当前状态。这可能导致在下次从池中取出对象时出现不可预测的行为，因为对象可能处于意外的状态。'
- en: Object pools have a lot of added value for mobile games, because phones have
    limited memory and resources compared to the average PC or console.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对比于普通的PC或游戏机，对象池对于移动游戏来说具有很多附加价值，因为手机内存和资源有限。
- en: Use case example
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例示例
- en: As with the other creational patterns, the Object Pool can be a great pattern
    to use when designing a spawn system. But, this time, we will focus on having
    a Client pulling and pooling directly from an Object Pool without any layers of
    abstraction between them, so we can see the system at work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他创建型模式一样，对象池在设计生成系统时可以是一个很好的模式。但这次，我们将专注于客户端直接从对象池中拉取和池化，而不在它们之间有任何抽象层，这样我们就可以看到系统的工作情况。
- en: 'Just to give some context to the following code example, let''s imagine we
    are doing a *Plants versus Zombies* clone. Like most zombie games, we have hordes
    of zombies moving toward a target. Each horde can contain various types of zombies,
    such as the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给下面的代码示例提供一些背景信息，让我们想象我们正在制作一个《植物大战僵尸》的克隆版。像大多数僵尸游戏一样，我们有成群的僵尸向目标移动。每个群体可以包含各种类型的僵尸，例如以下几种：
- en: Walkers
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Walkers
- en: Runners
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Runners
- en: But, what's important to consider is that every time our player kills one of
    them, instead of destroying the instance of the defeated zombie in memory, we
    can instead send it back to an Object Pool so that it can be used again afterward.
    With this approach, we are recycling our zombie-type entities instead of initializing
    new ones.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，重要的是要考虑的是，每次我们的玩家杀死其中一个僵尸时，我们不必在内存中销毁被击败僵尸的实例，而是可以将其送回对象池，以便之后再次使用。采用这种方法，我们正在回收僵尸类型的实体，而不是初始化新的实体。
- en: In the next section, we will implement this use case and adapt it, so that it
    works with Unity's GameObjects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现此用例并对其进行调整，以便它与Unity的GameObject一起工作。
- en: Code example
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: This chapter might be difficult to follow just by reading the code, because
    we are managing prefabs inside a scene. So, we recommend that you download the
    Unity project associated with this book on our Git depot at [https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过阅读代码可能难以理解本章内容，因为我们正在场景内部管理预制体。因此，我们建议您在我们的Git仓库[https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018](https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018)上下载与本书相关的Unity项目。
- en: In the Unity project, there should be a folder named Object Pool, with a scene
    included that will have the entire set of dependencies to run this example properly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity项目中，应该有一个名为Object Pool的文件夹，其中包含一个场景，该场景将包含运行此示例所需的全部依赖项。
- en: 'But, in case the GitHub address is unavailable, here''s a quick list of steps
    that need to be done in order to execute the following code example inside a Unity
    scene:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果GitHub地址不可用，以下是一个快速步骤列表，用于在Unity场景中执行以下代码示例：
- en: Open a new scene, add an empty `GameObject`, and name it `Object Pool`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的场景，添加一个空的`GameObject`，并将其命名为`Object Pool`。
- en: 'Create a set of prefabs and related scripts for each type of zombie. Here are
    some examples of zombie behavior scripts:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每种僵尸类型创建一组预制体和相关脚本。以下是一些僵尸行为脚本的示例：
- en: '`Runner`:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runner`:'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Walker`:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Walker`:'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Screamer`:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Screamer`:'
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Attach the `ObjectPool` script to the `GameObject` Object Pool.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ObjectPool`脚本附加到`GameObject`对象池。
- en: 'In the inspector of the `GameObject` Object Pool, configure the list of zombie
    prefabs that the `ObjectPool` instance will manage. You can refer to the following
    screenshot for reference:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameObject`对象池的检查器中，配置`ObjectPool`实例将要管理的僵尸预制体列表。你可以参考以下截图作为参考：
- en: '![](img/43532542-f677-4cd0-9daf-34be205bf351.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43532542-f677-4cd0-9daf-34be205bf351.png)'
- en: 'Now, it''s time for us to write the `ObjectPool` class. As you will see, it''s
    quite long, so it''s essential we read through it, and review its core features
    afterward:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是我们编写`ObjectPool`类的时候了。正如你将看到的，它相当长，因此我们阅读它并随后审查其核心功能是至关重要的：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, here''s a quick breakdown of what''s happening in the `ObjectPool` class
    in each function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是对`ObjectPool`类中每个函数所发生情况的快速概述：
- en: '`Start()`: In this function, we are initializing a `list()` that will contain
    instances of our pooled objects.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start()`: 在此函数中，我们正在初始化一个`list()`，它将包含我们的池化对象实例。'
- en: '`PullObject()`: By calling this function, Clients can request an instance of
    an object from the pool just by specifying the name of its type. If we have it
    in store, we return its instance; if not, we initialize a new instance of it.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PullObject()`: 通过调用此函数，客户端可以通过指定对象类型的名称来请求池中的对象实例。如果我们有存储，我们返回其实例；如果没有，我们初始化它的一个新实例。'
- en: '`PoolObject()`: A client can use this function to return instances of objects
    to the pool. `ObjectPool` will deactivate the returning object and attach it back
    to itself as a child, so it can keep it contained.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PoolObject()`: 客户端可以使用此函数将对象实例返回到池中。`ObjectPool`将使返回的对象失效，并将其作为子对象附加回自身，以便将其包含在内。'
- en: We can also see that our `ObjectPool` class is a singleton; this is a common
    approach, because we usually need to have Object Pools globally accessible and
    always available. To learn how to implement a singleton, please review [Chapter
    6](b8d60568-5961-4e57-b722-36028db5d1a9.xhtml), *Singleton*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，我们的`ObjectPool`类是一个单例；这是一种常见的做法，因为我们通常需要全局访问对象池，并且始终可用。要了解如何实现单例，请参阅第6章，*单例*。
- en: 'The next step is to test out our `ObjectPool` with a `Client` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`Client`类测试我们的`ObjectPool`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `Client` class is quite straightforward:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Client`类相当简单：
- en: If the player presses *G*, we request an instance of a Walker zombie from the
    `ObjectPool`. Then, we place it randomly in the scene.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下*G*键，我们从`ObjectPool`请求一个Walker僵尸的实例。然后，我们将它随机放置在场景中。
- en: If the player presses *P*, we send all the Walker objects that are currently
    in our scene back into the pool.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下*P*键，我们将场景中当前的所有Walker对象送回池中。
- en: And that's it; with one class, we can implement a simple, configurable, and
    extensible Object Pool.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；通过一个类，我们可以实现一个简单、可配置和可扩展的对象池。
- en: Summary
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have just added the Object Pool pattern to our toolkit; it's one of the most
    useful patterns for Unity developers because, as we saw in our code example, we
    can easily recycle GameObjects that are already in our scene without having to
    initialize new ones. When dealing with huge prefabs that contain a lot of data
    and components to initialize, this pattern can help you avoid inconsistent frame
    rates.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将对象池模式添加到我们的工具箱中；这是Unity开发者最有用的模式之一，因为我们从代码示例中看到，我们可以轻松地回收场景中已经存在的GameObject，而无需初始化新的GameObject。当处理包含大量数据和组件的巨大预制体时，此模式可以帮助你避免不稳定的帧率。
- en: In the next chapter, we are going to explore the Spatial Partition pattern—a
    subject matter that's quite important to understand when building open-world games.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨空间分区模式——这是构建开放世界游戏时理解的一个重要主题。
- en: Exercise
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Now that you have learned all the core creational patterns, such as Factory,
    Prototype, and Object Pool, it would be a valuable practical exercise to combine
    all those patterns and build the ultimate Spawn System. The goal is to have a
    system that reuses instances of objects of specific types and only creates new
    ones when it's necessary, and, if it does, uses a Factory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学完了所有核心创建型模式，例如工厂模式、原型模式和对象池模式，将所有这些模式结合起来构建终极生成系统将是一项非常有价值的实践练习。目标是拥有一个系统，它可以重用特定类型的对象实例，并且只有在必要时才创建新的实例，如果需要，则使用工厂。
- en: Further reading
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Programming Patterns* by Robert Nystrom[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*游戏编程模式*》由罗伯特·尼斯特罗姆[http://gameprogrammingpatterns.com](http://gameprogrammingpatterns.com/)
