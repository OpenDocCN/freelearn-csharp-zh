- en: Game Loop and Update Method
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环和更新方法
- en: In this chapter, we are going to explore the Game Loop and Update Method. Both
    are core game development patterns that are often confused with each other by
    beginners because they both can be associated with the concept of continuous looping
    sequences. But, as we are going to see, the Game Loop and Update Method might
    be related, but have very distinct responsibilities and are implemented on different
    layers of Unity's architecture.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨游戏循环和更新方法。两者都是游戏开发的核心模式，初学者经常将它们混淆，因为它们都可以与连续循环序列的概念相关联。但是，正如我们将要看到的，游戏循环和更新方法可能有关联，但它们具有非常不同的职责，并且在Unity架构的不同层上实现。
- en: If we want to understand the core principles behind the Game Loop and Update
    Method, then we need to consider what video games are in their most basic forms.
    The best definition I have encountered is that video games are simulations composed
    of interactive virtual spaces filled with objects and animated entities, with
    distinct behaviors. These virtual spaces are drawn frame by frame on a screen,
    while the continually-running system listens and reacts accordingly to a user's
    input.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要理解游戏循环和更新方法背后的核心原则，那么我们需要考虑视频游戏在其最基本的形式下是什么。我遇到的最佳定义是，视频游戏是由交互式虚拟空间组成的模拟，这些空间充满了物体和动画实体，具有不同的行为。这些虚拟空间是逐帧绘制在屏幕上的，而持续运行的系统会根据用户的输入进行监听和响应。
- en: But what exactly makes it possible for a video game to continually run a simulation
    and react to a user's input without any latency? The answer is the combination
    of the Game Loop, which can be described as the heartbeat of a running game, but
    also the Update Method, which can act as the ears of the system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，究竟是什么使得视频游戏能够持续运行模拟并即时响应用户的输入而没有任何延迟？答案是游戏循环的组合，它可以被描述为运行中的游戏的脉搏，但同时也是更新方法，它可以充当系统的耳朵。
- en: But as a Unity developer, you will never have to write a Game Loop or Update
    Method by hand, because they are already natively implemented in the engine. So,
    in the following sections, we are just going to explore the theory behind these
    patterns, so that we are of their presence when we are working in Unity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但是作为一个Unity开发者，你永远不会需要手动编写游戏循环或更新方法，因为它们已经在引擎中本地实现了。所以，在接下来的章节中，我们只是将要探索这些模式背后的理论，这样我们就能在Unity工作中意识到它们的存在。
- en: 'The following topic will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: A quick review of the core concepts behind the Game Loop and Update Method patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速回顾游戏循环和更新方法模式背后的核心概念
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will focus on theory instead of practice; a basic understanding
    of programming is enough for this material.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于理论而不是实践；对编程的基本理解就足够了。
- en: What makes a game run?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是什么让游戏运行？
- en: As stated before, video games are simulations; a bullet buzzing through the
    air and then hitting an enemy combatant in *Call of Duty* is made possible because
    of a collection of systems interacting together to give the illusion that a 3D
    cylinder-shaped mesh traveling through space on a curved vector is being affected
    by gravity and wind resistance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，视频游戏是模拟；子弹在空中嗡嗡作响，然后在《使命召唤》中击中敌人战斗人员，这是由于一系列系统相互作用，共同营造出一种3D圆柱形网格在弯曲矢量上穿越空间时受到重力和空气阻力的影响的错觉。
- en: But the question we need to answer is, what is driving all these systems to
    run in perfect synchronization? Contrary to a spreadsheet or a browser, a video
    game is not event-driven; it's continuously processing, even when the player is
    not pressing any buttons. By implementing the Game Loop pattern, it's possible
    to have a system that cycles on itself at a constant rate, while calling sub-systems
    in perfect synchronicity, but still being able to react dynamically to a user's
    input.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们需要回答的问题是，是什么驱动所有这些系统以完美的同步运行？与电子表格或浏览器不同，视频游戏不是事件驱动的；它是持续处理的，即使玩家没有按任何按钮。通过实现游戏循环模式，可以有一个以恒定速率自行循环的系统，同时以完美的同步调用子系统，但仍能动态地响应用户的输入。
- en: 'So, in this section, we will review two core concepts: the implementation of
    the main loop, and the importance of timing, because the primary purpose of the
    Game Loop is to simulate time, not just execute code over and over again.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们将回顾两个核心概念：主循环的实现和计时的重要性，因为游戏循环的主要目的是模拟时间，而不仅仅是重复执行代码。
- en: You might notice that game designers often talk about core game loops. They
    are usually referring to what we call experience or reward loops. This subject
    is beyond the scope of this book, but we could say that games are composed of
    loops at almost every level.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到游戏设计师经常谈论核心游戏循环。他们通常指的是我们所说的体验或奖励循环。这个主题超出了本书的范围，但我们可以这样说，游戏几乎在每一个层面上都是由循环组成的。
- en: The main loop
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要循环
- en: Even during the early 1980s, when programmers wrote games in pure assembly language
    without the help of an engine such as Unity, the concept of Game Loops existed.
    During that time, the implementation of a Game Loop needed to be precise in its
    timing, because it had to synchronize correctly with the movement of a CRT's television
    electron gun, or the image on the screen would get distorted and the game would
    become unresponsive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在20世纪80年代初，程序员在没有像Unity这样的引擎的帮助下用纯汇编语言编写游戏时，游戏循环的概念就已经存在了。在那个时期，游戏循环的实现需要在时序上非常精确，因为它必须正确地与CRT电视电子枪的运动同步，否则屏幕上的图像会扭曲，游戏将变得无响应。
- en: 'The following is an example of a game loop written in assembly for an Atari
    2600\. You can see the main routine calling a specific sequence of sub-routines
    cyclically. Each sub-routine runs at a particular phase of an analog television''s
    screen drawing sequence. Between every step, you can do calculations, capture
    the player''s input, or draw sprites:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个为Atari 2600编写的游戏循环汇编代码示例。你可以看到主程序周期性地调用一系列子程序。每个子程序在模拟电视屏幕绘制序列的特定阶段运行。在每一步之间，你可以进行计算、捕获玩家的输入或绘制精灵：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The modern day implementations of a game loop are not that different, they might
    be more sophisticated, but the core principles and sequencing pattern are similar.
    Every game loop must gather the player's input data and calculate new transforms
    on the entities in the scene before calling the rendering pipeline (also known
    as the draw loop). You can't draw something before knowing where things are supposed
    to be related to the most recent input of the player.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏循环的实现并没有太大差异，它们可能更加复杂，但核心原则和顺序模式是相似的。每个游戏循环都必须在调用渲染管线（也称为绘制循环）之前收集玩家的输入数据，并在场景中的实体上计算新的变换。在不知道事物应该与玩家最新的输入相关联的位置之前，你不能绘制任何东西。
- en: In this section, we reviewed that one of the primary responsibilities of the
    Game Loop is to make sure that subroutines are called in the right order at every
    cycle. In other words, it's maintaining a continuous sequence of system calls.
    But in the next section, we are going to review another important responsibility
    of the Game Loop, which is keeping a degree of consistent timing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了游戏循环的主要职责之一是确保在每一周期中按正确顺序调用子程序。换句话说，它是在维护系统调用的连续序列。但在下一节中，我们将回顾游戏循环的另一个重要职责，即保持一定程度的时序一致性。
- en: Always keep in mind that a Game Loop and the Update Method are related, but
    they're not the same. They're both sequential patterns, but are not implemented
    the same way, and don't have the same responsibilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总要记住，游戏循环和更新方法相关联，但它们并不相同。它们都是顺序模式，但实现方式不同，且责任也不同。
- en: It's all about timing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这一切都关乎时机
- en: As with comedy, timing is key to game programming; complex physics calculations
    are executed while thousands of pixels are rendered on a screen in a matter of
    milliseconds. Being aware of what is being called at every frame is key to mastering
    optimization.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就像喜剧一样，时机对于游戏编程至关重要；在屏幕上渲染数千个像素的同时，复杂的物理计算在毫秒级内完成。了解每一帧被调用的是什么，对于掌握优化至关重要。
- en: In an engine such as Unity, the core game loop and rendering pipeline are abstracted,
    and we can only hook into its sequencing mechanism by the Scripting API's magic
    functions, such as: `FixedUpdate()`, `Update()`, and `LateUpdate()`. This approach
    permits the engine to protect its internal clock and its established sequence
    of system calls, while giving us the ability to execute code at specific moments
    of the Game Loop safely.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity这样的引擎中，核心游戏循环和渲染管线被抽象化，我们只能通过脚本API的魔法函数（如：`FixedUpdate()`、`Update()`和`LateUpdate()`）来挂钩其顺序机制。这种方法允许引擎保护其内部时钟和已建立的系统调用序列，同时让我们能够在游戏循环的特定时刻安全地执行代码。
- en: But the trade-off is that we lose granular control over the exact moment a specific
    system is updated. In most cases, this is not an issue, but for massive AAA production,
    this limitation can be a deal-breaker. Often, complex CPU-intensive games need
    a more granular approach to managing the timing of precise calculations; when
    having a ticking mechanism, this becomes essential. Instead of relying on trying
    to synchronize with the CPU's internal clock, Game Loops have a ticking mechanism
    that's very similar to what an analog watch might have. Like a clock, the Game
    Loop doesn't cycle around, but ticks. The Game Loop manages the variation of time
    between these ticks instead, depending on available operating systems and hardware
    resources. This approach permits us to have a more granular control in the way
    we schedule the processing time of specific game systems between every frame.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种权衡是我们失去了对特定系统更新确切时刻的精确控制。在大多数情况下，这不是问题，但对于大规模AAA制作来说，这种限制可能是一个决定性的因素。通常，复杂的CPU密集型游戏需要更细粒度的方法来管理精确计算的时机；当有一个滴答机制时，这变得至关重要。而不是依赖于尝试与CPU的内部时钟同步，游戏循环有一个类似于模拟手表的滴答机制。像时钟一样，游戏循环不会循环，而是滴答。游戏循环管理滴答之间的时间变化，这取决于可用的操作系统和硬件资源。这种方法允许我们在每一帧之间以更细粒度的控制方式安排特定游戏系统的处理时间。
- en: In the game industry, the terms *frame* and *tick* are often used interchangeably,
    but be careful, because they're not necessarily synonyms. We could say a **frame**
    is a unit of time based on the delay it takes to generate and draw a new frame
    onto the screen. And a **tick** is a unit of time that's related to a game's internal
    clock, which is simulated by the execution of the main game loop; it's similar
    to an analog clock's second hand ticks as it goes around the clock.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏行业中，术语*帧*和*滴答*经常被互换使用，但请注意，它们并不一定是同义词。我们可以这样说，**帧**是基于生成和绘制新帧到屏幕上所需延迟的时间单位。而**滴答**是与游戏内部时钟相关的时间单位，它通过主游戏循环的执行来模拟；它类似于一个模拟时钟的秒针在时钟上移动时的滴答声。
- en: In the previous sections, we examined a very high-level and simplified overview
    of the Game Loop pattern. Of course, the actual implementation details of a Game
    Loop in a modern AAA game engine is beyond the scope of this book. For those that
    want to dive deep into the subject matter, and have a more academic understanding
    of the subject matter, I recommend reading the listed books in the *Further reading*
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们考察了游戏循环模式的一个非常高级和简化的概述。当然，现代AAA游戏引擎中游戏循环的实际实现细节超出了本书的范围。对于那些想要深入研究主题并对此有更学术性理解的人，我建议阅读*进一步阅读*部分列出的书籍。
- en: In the next section, we are going to explore Unity's implementation of the Update
    method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索Unity对更新方法的实现。
- en: Update Method
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新方法
- en: If we all agree that the Game Loop pattern's main goal is to abstract a CPU's
    clock cycle by implementing a ticker so we can time the execution of our code
    on every frame, in a consistent manner, then we could say that the Update Method
    pattern simplifies this process by offering a way to encapsulate our game entities,
    and let them update themselves on each frame.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们都同意游戏循环模式的主要目标是通过实现一个计时器来抽象CPU的时钟周期，以便我们可以以一致的方式在每一帧上计时我们的代码执行，那么我们可以说更新方法模式通过提供一种封装我们的游戏实体并让它们在每一帧自行更新的方式来简化这一过程。
- en: In the following section of this book, we are going to review the Update Method
    and its implementation inside the Unity engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一节中，我们将回顾更新方法和它在Unity引擎中的实现。
- en: Over the years, I've noticed that game programming consists mostly of manipulating
    data with perfect timing. So, knowing how to manage data, and time, is essential
    for mastery of game programming.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，我发现游戏编程主要是由精确的时间控制来操纵数据。因此，了解如何管理数据和时间是掌握游戏编程的关键。
- en: Overview
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: One of the biggest challenges of implementing a Game Loop is keeping track of
    all the entities contained inside a scene, and how to update their states at every
    frame. But the Update Method offers a scalable, but straightforward solution,
    by having every object expose an `Update()` function that's called every frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实现游戏循环的最大挑战之一是跟踪场景中包含的所有实体，以及如何在每一帧更新它们的状态。但更新方法提供了一种可扩展且直接的解决方案，通过让每个对象都暴露一个每帧被调用的`Update()`函数。
- en: The Game Loop is not aware of the content of the `Update()` function of each
    object, just that every object that has one should be called at every frame. So,
    we are basically encapsulating the updating process of each game object's state
    through a single interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环并不了解每个对象`Update()`函数的内容，只知道每个拥有该函数的对象都应该在每一帧被调用。因此，我们基本上通过一个单一接口封装了每个游戏对象状态的更新过程。
- en: Challenge
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战
- en: 'As we can see in the following example, a basic Game Loop implementation looks
    simple, but can be very complicated to implement correctly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在以下示例中看到的那样，一个基本的游戏循环实现看起来很简单，但正确实现可能会非常复杂：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once we capture the player''s controller inputs, we must update the transforms
    and states of our game''s objects before drawing them on the screen. But to achieve
    this, we need to know what entities to update, and how to request them to do so.
    If these entities don''t have a common object type or interface, we will need
    to manage them on a case-by-case basis:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们捕获了玩家的控制器输入，我们必须在屏幕上绘制游戏对象之前更新游戏对象的变换和状态。但要实现这一点，我们需要知道要更新哪些实体，以及如何请求它们这样做。如果这些实体没有共同的类型或接口，我们就需要逐个管理它们：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But our problems don't stop there; we also need to maintain a dynamic list of
    entities that will hold each object during their entire lifespan. As we can see,
    this type of approach doesn't scale well for larger games. So, the best solution
    would be to let the entities update themselves at every frame. In other words,
    let's have them encapsulate their behaviors, and the easiest to way to remind
    them to update themselves is to have a standard public function that we can call
    at every frame.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的问题还没有结束；我们还需要维护一个动态的实体列表，以在它们的整个生命周期中持有每个对象。正如我们所看到的，这种类型的方案对于大型游戏来说扩展性不好。因此，最好的解决方案是让实体在每一帧自行更新。换句话说，让我们让它们封装自己的行为，而提醒它们自行更新的最简单方法是在每一帧调用一个标准的公共函数。
- en: Let's see in the next section how we can resolve all these issues with the Update
    Method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中看看我们如何通过更新方法来解决所有这些问题。
- en: Solution
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Now that we have found a solution that offers a standard interface to our game's
    scene entities and encapsulates them, we still need to maintain a list. Games
    are dynamic software; entities explode and spawn in a matter of seconds, manually
    managing a list of objects is error-prone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了一个提供标准接口给游戏场景实体并将它们封装起来的解决方案，我们仍然需要维护一个列表。游戏是动态的软件；实体在几秒钟内爆炸和生成，手动管理对象列表是容易出错的。
- en: But, if we had a common type for all our game's objects, then it will be easy
    for us to dynamically maintain a list of entities, and walk through it at every
    frame. If we have a container that holds all our game's objects, such as a scene,
    then we could iterate through it to find all the objects of a specific type, and
    call their `Update()` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们为所有游戏对象有一个共同的类型，那么我们就可以很容易地动态维护一个实体列表，并在每一帧遍历它。如果我们有一个包含所有游戏对象的容器，比如场景，那么我们可以遍历它以找到特定类型的所有对象，并调用它们的`Update()`方法。
- en: That's mostly what `MonoBehaviour` is in Unity; it offers a common parent type
    for objects that are in a scene that need to update themselves at every frame.
    So, any component that is a child of the `MonoBehaviour` parent class has a magic
    method named `Update()`, which is called at every frame. So, while Unity does
    all the heavy lifting under the hood, you can focus on implementing the behaviors
    that you want to *tick* (update) at every frame by writing them inside a script's
    `Update()` method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是Unity中的`MonoBehaviour`；它为需要每帧更新自己的场景中的对象提供了一个共同的父类型。因此，任何是`MonoBehaviour`父类子类的组件都有一个名为`Update()`的魔法方法，它在每一帧被调用。因此，虽然Unity在幕后做了所有繁重的工作，但你可以通过在脚本的`Update()`方法中编写代码来专注于实现你想要在每一帧*触发*（更新）的行为。
- en: In the next section, we will dive deeper into Unity's implementation of the
    Update Method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更深入地探讨Unity的更新方法实现。
- en: Unity's Update Method
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity的更新方法
- en: As a Unity developer, we don't need to implement our Update Method; it's native
    to the engine's scripting API. But the Unity engineers expanded on the core concept
    and exposed several types of `Update()` methods; each one permits us to execute
    code at different moments in the period of a frame.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Unity开发者，我们不需要实现自己的更新方法；它是引擎脚本API的固有部分。但Unity工程师扩展了核心概念，并公开了几种类型的`Update()`方法；每一种都允许我们在帧的不同时刻执行代码。
- en: 'The following diagram is an example of the steps of execution during the time
    it takes to render a frame to the screen:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在屏幕上渲染帧所需时间内执行步骤的示例：
- en: '![](img/f1f4bef2-9388-44b6-a310-2eea7f70b8a5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1f4bef2-9388-44b6-a310-2eea7f70b8a5.png)'
- en: Each step in the diagram is completed in less than 1/30 of a second and in a
    constant order. But the Unity engineers had the foresight to know that having
    a singular `Update()` is not enough, because specific systems need to be processed
    in different moments of a frame. So they decided to expose three main types of
    `Update()` methods, which we'll review individually.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的每一步都在不到 1/30 秒内完成，并且按照恒定的顺序进行。但 Unity 工程师有远见，知道只有一个 `Update()` 是不够的，因为特定的系统需要在帧的不同时刻进行处理。因此，他们决定公开三种主要的
    `Update()` 方法，我们将逐一进行回顾。
- en: 'Take note that only objects that are active in a scene and that inherit from
    the `MonoBehaviour` parent class will have their various `Update()` methods called:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有场景中活跃且继承自 `MonoBehaviour` 父类的对象才会调用它们的各种 `Update()` 方法：
- en: '**Update()**: This method is called on at the same frequency as the game''s
    frame rate, which might be inconsistent, but at least frequent. In it, you should
    only implement code that needs to be executed in correspondence with every rendered
    frame. Because of its higher call frequency, it''s a good place to implement your
    input listeners.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Update()**: 此方法以与游戏帧率相同的频率被调用，这可能是不可靠的，但至少是频繁的。在其中，你应该只实现需要与每个渲染帧相对应的代码。由于其更高的调用频率，这是一个实现输入监听器的好地方。'
- en: '**LateUpdate()**: This method is called after `Update()`. It''s for code that
    needs to be executed after the completion of a call to `Update()`. Useful for
    camera movement translations that are dependent on the movement of a character
    that is being controlled by the player.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LateUpdate()**: 此方法在 `Update()` 之后被调用。它用于需要在 `Update()` 调用完成后执行的代码。对于依赖于玩家控制的角色的移动的相机移动转换非常有用。'
- en: '**FixedUpdate()**: This method is called each time the physics simulation is
    ticked (updated). The timing of the calls of the `FixedUpdate()` method offers
    stable delta times between each frame. This approach is necessary for physics
    calculations and the simulation of certain types of behaviors, such as accelerated
    motion.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FixedUpdate()**: 每当物理模拟被触发（更新）时，都会调用此方法。`FixedUpdate()` 方法的调用时机在每一帧之间提供了稳定的
    delta 时间。这种方法对于物理计算和某些类型行为的模拟（如加速运动）是必要的。'
- en: 'The following segment showcases the intervals between an `Update()` and a `FixedUpdate()`:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下部分展示了 `Update()` 和 `FixedUpdate()` 之间的间隔：
- en: '![](img/2c21f590-324b-48fa-bcba-056a6aced3f8.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c21f590-324b-48fa-bcba-056a6aced3f8.png)'
- en: As we can see, a `FixedUpdate()` call is consistent, while an `Update()` varies
    over time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`FixedUpdate()` 调用是一致的，而 `Update()` 随时间变化。
- en: 'The following is what the various Update Methods look like inside a typical
    `MonoBehaviour` script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在典型 `MonoBehaviour` 脚本内部各种更新方法的外观：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most important takeaway is that we always need to be aware of when our code
    will be executed. Unity simplifies this task for us by abstracting the inner ticking
    (updating) mechanisms of the engine and exposing it through the API in the form
    of various Update Methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们始终需要意识到我们的代码将在何时执行。Unity 通过抽象引擎的内部触发（更新）机制，并通过 API 中的各种更新方法来简化这项任务。
- en: Summary
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the Game Loop pattern and its core principles.
    Like many modern engines, Unity abstracts the inner working of its core game loop,
    instead of some API hooks, which permits us to control the timing of the execution
    of our code at each frame, without having to synchronize manually with the CPU's
    internal clock.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了游戏循环模式及其核心原则。像许多现代引擎一样，Unity 抽象了其核心游戏循环的内部工作，而不是一些 API 钩子，这允许我们在每个帧控制代码的执行时间，而无需手动与
    CPU 的内部时钟同步。
- en: We also skated over the surface of the core concepts that encompass the Update
    Method pattern. As Unity programmers, we don't need to manually implement this
    pattern because it's native to the scripting API, but we still have to be aware
    of its purpose. A solid understanding of the timing and sequencing of Unity's
    update functions is essential. Even if we don't know what's happening under the
    hood, we can at least have control over the sequence of execution of our code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也简要地提到了包含更新方法模式的核心理念。作为Unity程序员，我们不需要手动实现这个模式，因为它已经是脚本API的本地功能，但我们仍然需要了解其目的。对Unity更新函数的时机和顺序有扎实的理解是至关重要的。即使我们不知道底层发生了什么，我们至少可以控制我们代码的执行顺序。
- en: In the next chapter, we will dive into practical design patterns and apply them
    to resolve real-life game architecture issues and challenges. Our first subject
    will be the *Prototype* pattern.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨实际的设计模式，并将它们应用于解决现实生活中的游戏架构问题和挑战。我们的第一个主题将是*原型*模式。
- en: Further reading
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Game Engine Architecture* by Jason Gregory:[http://www.gameenginebook.com](http://www.gameenginebook.com)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jason Gregory的*《游戏引擎架构》*：[http://www.gameenginebook.com](http://www.gameenginebook.com)
- en: '*Racing the Beam* by Nick Montfort and Ian Bogost:[https://mitpress.mit.edu/books/racing-beam](https://mitpress.mit.edu/books/racing-beam)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nick Montfort和Ian Bogost的*《赛跑光束》*：[https://mitpress.mit.edu/books/racing-beam](https://mitpress.mit.edu/books/racing-beam)
