<html><head></head><body>
		<div><h1 id="_idParaDest-101" class="chapter-number"><a id="_idTextAnchor102"/>4</h1>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor103"/>Building Databases and Planning for Data-Rich Applications</h1>
			<p>In previous chapters, we established a foundational SaaS application consisting of a straightforward database with a single table. This database was connected to an API, and we showcased secure multi-tenancy implementation using SQL Server, .NET, and Entity Framework.</p>
			<p>In this chapter, we will delve deeper into the intricacies of the database layer and its interactions with Entity Framework. As the bedrock of an entire application, the design choices made at the database level will influence every subsequent layer in the stack. We will explore how to construct and design resilient databases for data-intensive SaaS applications. You will acquire a variety of skills, such as normalization, indexing, performance optimization, as well as techniques to test and maintain the database.</p>
			<p>Once deployed, a database often represents the most demanding aspect of a system to keep current. The database is inherently stateful, and it is crucial to prevent data loss or corruption during updates. In addition to learning about database design and construction, we will examine several strategies to maintain and update the database, with an emphasis on the tools provided by Entity Framework.</p>
			<p>The expertise you gain in this chapter is vital to create scalable and dependable SaaS applications. By mastering the methods discussed in this chapter, you will be capable of designing databases optimized for performance, scalability, and maintainability, thereby facilitating the development and maintenance of your SaaS applications.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>The importance of data in a SaaS application</li>
				<li>Building a database using SQL Server and Entity Framework</li>
				<li>Testing the database and data-rich applications</li>
				<li>Working in production, keeping your database up to date, and keeping your data safe</li>
			</ul>
			<p>Data and a database are the foundations of a SaaS application. Let’s start by considering how important they are.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor104"/>Technical requirements</h1>
			<p>All code from this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-4</a>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor105"/>The importance of data in a SaaS application</h1>
			<p>In a<a id="_idIndexMarker206"/> SaaS application, a database serves as the foundation for the application. The database (or more accurately, the data contained within) is what drives the application and where the primary value for users lies. A SaaS application without data is just an empty shell!</p>
			<p>One of the key considerations when building a SaaS application is the type of data that the application will store and how it will be used. Will the application be storing large amounts of structured data, such as customer records or transaction histories? Or will it be storing unstructured data, such as the data underpinning a social media feed? The type of data will have a significant impact on the design and architecture of the application.</p>
			<p>Another important consideration is how the data will be accessed and manipulated. Will the data be accessed by a large number of users simultaneously, or will it only be accessed by a few users at a time? Will the data be updated frequently, or will it be mostly static? These factors will influence the choice of database technology and the design of the data model.</p>
			<p>In a SaaS application, it is also important to consider how the data will be shared among different tenants. As we discussed in the previous chapter, the data for each tenant must be kept separate and secure, while still allowing for efficient access to and manipulation of the data that pertains to the current tenant. This requires careful planning and design of a data model and database schema.</p>
			<p>It is also important to consider scalability. While a SaaS application may well start off with a small user base and thus a comparatively low number of reads/writes, this can change very quickly as the user base increases! It’s important to design a data model and schema in a way that allows the application to grow. Similarly, the amount of data that is transmitted over the internet must be managed. Bandwidth is not free nor unlimited, and in data-intensive applications, this can become a burden.</p>
			<p>The importance of data is not limited to technical considerations. Data plays a crucial role in the user experience. The way that data is presented, organized, and accessed can significantly impact the usability of an application. While this is, of course, dependent on the user interface, the structure of the underlying data, and the ease and speed with which it can be queried, will be noticed at the frontend by end users.</p>
			<p>For a<a id="_idIndexMarker207"/> company building an application and hosting a database, data can be a key source of revenue. Some SaaS applications monetize their data by selling access to information about consumer demographics and buying habits to businesses looking to target specific market demographics. This data is often collected and classified by machine learning algorithms, allowing for insights about the users and creators of the data. With this valuable information, businesses can create targeted marketing campaigns and improve their products and services to better meet the needs of their customers.</p>
			<p>Data is important for a myriad of reasons, and so it should go without saying that maintaining data security and compliance is a crucial aspect of building a successful SaaS application. It is the responsibility of the SaaS provider to ensure that sensitive data, such as financial or personal information, is kept secure and compliant with relevant regulations. To achieve this, the SaaS provider may need to implement various security measures, such as encryption and access controls, to protect the data.</p>
			<p>Data and the database are absolutely critical parts of a SaaS application, and it’s important for SaaS developers to have a strong understanding of how to design, build, and maintain data-rich applications.</p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor106"/>Building a database</h1>
			<p>In this <a id="_idIndexMarker208"/>section, we will focus on using SQL Server and Entity Framework to design and construct a database for your SaaS application. We will cover a range of topics, including choosing the right database technology, designing an efficient and scalable data model with Entity Framework, and implementing database security and compliance measures with SQL Server. By the end of this section, you will have a solid understanding of how to build a robust and reliable database for your SaaS application.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor107"/>Types of database</h2>
			<p>Because this is a book focused on making use of the Microsoft stack, I will focus on SQL Server as the underlying database platform, and I will use Entity Framework to interact with the <a id="_idIndexMarker209"/>database. SQL Server is a <strong class="bold">relational database</strong>, which is a type of database that stores data in the form of tables, with rows representing <a id="_idIndexMarker210"/>individual records and columns representing data attributes. It is a very structured way to store data, and the “shape” of the data must be known in advance and built into the application at design time.</p>
			<p>While we will focus on SQL Server and, therefore, relational data, it is worth briefly considering the alternatives, which are outside the scope of this book. Some of the following alternatives may be worth further investigation if you have a specific use case that may require something other than relational data:</p>
			<ul>
				<li><strong class="bold">Document databases</strong>: A document database is<a id="_idIndexMarker211"/> a type of <a id="_idIndexMarker212"/>database that stores data in the form of documents. In this context, a document is data that is typically made up of key-value pairs and is designed to be scalable and flexible. In a document database, the structure or shape of the data will not be set when the database is designed, making it a good choice to store and query large volumes of data with diverse structures.</li>
				<li><strong class="bold">Graph databases</strong>: These <a id="_idIndexMarker213"/>databases store data in the<a id="_idIndexMarker214"/> form of nodes (representing data entities) and edges (representing relationships between nodes). They are often used in applications that need to represent complex relationships between data entities, such as social networks or recommendation engines.</li>
				<li><strong class="bold">Key-value stores</strong>: These<a id="_idIndexMarker215"/> databases store data in<a id="_idIndexMarker216"/> the form of key-value pairs, where the key is used to identify the data and the value is the data itself. They are often used for simple data storage and retrieval scenarios where the data does not need to be queried or indexed. This is similar to a document database but more limited in that it is only really suitable for simple use cases.</li>
				<li><strong class="bold">In-memory databases</strong>: These databases store data in memory, rather than on disk. They<a id="_idIndexMarker217"/> are often used for applications <a id="_idIndexMarker218"/>that require fast read and write access to data, such as online gaming or financial applications. Note that in-memory databases can also be used to help test databases. These are two separate use cases and should not be confused.</li>
				<li><strong class="bold">Time-series databases</strong>: These <a id="_idIndexMarker219"/>databases are<a id="_idIndexMarker220"/> designed specifically for storing and querying time-stamped data, such as sensor readings or financial transactions. They are often used in applications that need to analyze data over time.</li>
			</ul>
			<p>In this chapter, we will focus on SQL Server, which is a relational database. We will interact with the database using a tool that Microsoft developed specifically for this purpose – namely, Entity Framework.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor108"/>What is ACID?</h2>
			<p>When working with databases – and particularly relational databases – you will often come across the acronym <strong class="bold">ACID</strong>. This<a id="_idIndexMarker221"/> refers to the four properties of a database transaction – namely, atomicity, consistency, isolation, and durability:</p>
			<ul>
				<li><strong class="bold">Atomicity</strong>: A <a id="_idIndexMarker222"/>transaction is treated as a single, indivisible unit of work, and either all its operations are completed or none of them are</li>
				<li><strong class="bold">Consistency</strong>: The<a id="_idIndexMarker223"/> transaction brings the database from one valid state to another, preserving database invariants and constraints</li>
				<li><strong class="bold">Isolation</strong>: The<a id="_idIndexMarker224"/> concurrent execution of transactions results in a system state that would be obtained if transactions were executed serially, in some order</li>
				<li><strong class="bold">Durability</strong>: Once a<a id="_idIndexMarker225"/> transaction has been committed, its changes to the database persist and survive future system failures</li>
			</ul>
			<p>These properties are a set of properties that are guaranteed by a database management system to ensure the reliability and consistency of data stored in a database. ACID is most commonly associated with <strong class="bold">relational database management systems</strong> (<strong class="bold">RDBMS</strong>), such as Oracle, MySQL, PostgreSQL, and Microsoft SQL Server. However, some newer<a id="_idIndexMarker226"/> databases, such as NoSQL databases and NewSQL databases, may also provide ACID guarantees, although they may have different levels of consistency and durability. The level of ACID support depends on the specific database technology and how it is implemented and configured.</p>
			<p>ACID is generally associated with transactions in relational databases, and less commonly so in NoSQL or document databases. In this chapter, and indeed throughout this book, we will focus on SQL Server, a relational database that provides support for ACID transactions.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/>Entity Framework</h2>
			<p>Entity Framework is<a id="_idIndexMarker227"/> an <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) tool<a id="_idIndexMarker228"/> that allows developers to interact with a database using .NET objects. It simplifies the process of accessing and manipulating data by eliminating the need to write SQL queries and manually map data to objects. Entity Framework is well-suited for developers who are familiar with .NET and want to streamline their data access and manipulation tasks, which makes it an excellent choice for study in this .NET-focused book!</p>
			<p>While we will focus on SQL Server, one of the big benefits of using Entity Framework is its ability to generate database-agnostic code, allowing developers to change a database platform or support multiple database platforms without having to significantly rewrite their code. This feature is of particular interest when dealing with a multi-tenant SaaS application, where certain customers may mandate a specific database platform.</p>
			<p>Entity Framework wraps up a lot of the complexities associated with writing code that interacts with a database. Concepts such as lazy loading, change tracking, and automatic migration of data and schema changes are handled out of the box.</p>
			<p>Unlike many other ORMs, Entity Framework supports several different approaches to interacting with a database, including the traditional database-first approach, the code-first approach, and the model-first approach. This gives developers the flexibility to choose the approach that best fits their needs.</p>
			<p>Entity Framework is a powerful tool that can greatly enhance the productivity of experienced .NET developers by simplifying data access and manipulation tasks, and it is highly recommended <a id="_idIndexMarker229"/>when approaching a project that will be highly dependent on a data platform – such as a SaaS application.</p>
			<p>It is out of the scope of this chapter to cover all of the possible ways to use Entity Framework, so I will focus on one – Code First.</p>
			<h4>Code first with Entity Framework</h4>
			<p>Code first with Entity Framework<a id="_idIndexMarker230"/> is a development approach that allows developers to create their .NET application’s data model using C# code, rather than designing a database using a UI such as SQL Server Management Studio, or through writing and maintaining SQL scripts. This approach is particularly useful for developers who prefer to work with code and want more control over their application’s data model. With code first, developers can define their data model using classes and properties in their code, and Entity Framework will handle the creation and management of the underlying database. This approach allows developers to focus on the data model and business logic of their application, without having to worry about the implementation details of the database.</p>
			<p>We saw this approach in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>. When the database was configured, we didn’t write a single line of SQL code – we wrote a C# class called <code>GoodHabits.cs</code> and defined the data structure in C# code. We then used two commands on the Entity Framework CLI that updated the database. In <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, we modified this file to facilitate multi-tenancy.</p>
			<h4>Stored procedures with Entity Framework</h4>
			<p>Traditionally, it <a id="_idIndexMarker231"/>has been very common to use stored procedures when designing a database. While this is still a very valid and useful approach to database development, it is increasingly being seen as best practice to use an ORM such as Entity Framework to access and manipulate data in a database, rather than using stored procedures. There are a few reasons for this.</p>
			<p>Entity Framework allows you to work with objects and entities in your code, rather than having to write raw SQL queries. This gives you a higher level of abstraction, which can make it easier to develop an application. With this approach, you can build your database in a familiar object-orientated way, which can make it easier to reason about and maintain. Entity Framework is able to interpret relationships between objects and create database relationships from C# code. If you create logic and then model it in a stored procedure, Entity Framework loses sight of that logic.</p>
			<p>Another <a id="_idIndexMarker232"/>huge benefit of using Entity Framework is that many database platforms are supported out of the box. However, logic in stored procedures is typically not transferrable between database platforms and would have to be built and maintained separately on a per-platform basis.</p>
			<p>Finally, Entity Framework has a number of testing tools available to use. Using stored procedures and triggers will require specific testing infrastructure and techniques, and this may make it harder to test an application because logic is split between code and the database.</p>
			<p>There are certain cases when using stored procedures or triggers may be beneficial. These include the following:</p>
			<ul>
				<li>When working with very large datasets, or in situations where performance is critical, it may be advantageous to execute logic directly against a database by way of a stored procedure</li>
				<li>In cases where data security is a concern, stored procedures can help to prevent unauthorized access to data by limiting the types of queries that can be run against a database.</li>
				<li>In cases where you want to abstract the data access layer of your application from the underlying database schema, using stored procedures can help to decouple the two. This can be particularly useful in situations where a database schema may change frequently.</li>
			</ul>
			<p>It is important to understand your specific use case when deciding whether or not to make use of stored procedures in your database. For the demo application, we will continue to use Entity Framework to manipulate and access the database.</p>
			<h4>Normalization</h4>
			<p>Database normalization<a id="_idIndexMarker233"/> is the process of organizing a database in a way that reduces redundancy and improves data integrity. It involves dividing the database into smaller, more focused tables that are related to each other through relationships. The goal of normalization is to eliminate redundancy and ensure that each piece of data is stored in only one place in the database. Normalization is an important step in the database design process and can greatly improve the performance and reliability of a database.</p>
			<p>Entity Framework <a id="_idIndexMarker234"/>supports the process of normalizing a database in several ways. One of the main ways it does this is through the creation and modification of tables and relationships within the database. This allows developers to structure their data in a way that reduces redundancy and improves data integrity – a key goal of normalization. Entity Framework also includes support for the automatic migration of data changes. This means that when developers make changes to their data model, those changes are automatically reflected in the underlying database. This can be particularly useful when normalizing a database, as it allows developers to easily update the structure of their data without having to manually migrate data between tables.</p>
			<p>In addition, Entity Framework’s LINQ query syntax allows developers to easily retrieve and manipulate data from a normalized database. It supports a wide range of operations, including filtering, sorting, and aggregation, making it easy to work with data from multiple tables. Finally, Entity Framework’s support for eager and lazy loading allows developers to optimize the performance of their application by only loading the data they need on demand, rather than loading all data upfront. This can be harder with a poorly normalized database. Overall, Entity Framework provides a number of tools and features to help developers normalize their databases and improve the performance and reliability of their applications.</p>
			<p>There are several normal forms that can be used to measure the degree of normalization in a database. The first three (called 1NF, 2NF, and 3NF) are used to address redundancy in a database and are generally considered to be good practice in most instances.</p>
			<p>Beyond the first three, the additional normal forms are designed to address specific types of problems; however, these are less commonly used and are considered out of the scope of this chapter.</p>
			<p>It is worth noting that achieving higher normal forms does not always constitute a better-designed database. It is generally better to design a database that is efficient and performant around a specific use case than to adhere blindly to the normalization rules. That said, achieving 3NF is usually a good starting point from which to work, and further normalization, or indeed denormalization, can follow from there.</p>
			<p>Let’s illustrate this with an example. Let’s consider adding a user table to the <code>GoodHabit</code> example we developed in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>.</p>
			<p>To<a id="_idIndexMarker235"/> achieve the first normal form (1NF), all attributes in the database must be atomic. This means that each column in the database should contain a single value. We could design a user table that looked like this:</p>
			<div><div><img src="img/B19343_Figure_4.1.jpg" alt="Figure 4.1 – Poorly normalized data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Poorly normalized data</p>
			<p>The preceding table shows poorly normalized data. The <strong class="bold">Name</strong> column contains two pieces of information (first and last name), which may be useful to use separately. The <strong class="bold">Habits</strong> column contains a comma-separated list of data. This can be improved upon like so:</p>
			<div><div><img src="img/B19343_Figure_4.2.jpg" alt="Figure 4.2 – Data in the first normal form (1NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Data in the first normal form (1NF)</p>
			<p>The preceding table shows the data in 1NF. Each attribute holds a single value. We now have a row in the database for each habit, but the users appear multiple times. If Dave decided that he would prefer to be called David, we would have to update the data in multiple places.</p>
			<p>To move this data into the second normal form, we need to break the data into two tables – one for the user, and one for the habit. We will need a third table to link the users to the habits they are going to work on:</p>
			<div><div><img src="img/B19343_Figure_4.3.jpg" alt="Figure 4.3 – Data in the second normal form (2NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Data in the second normal form (2NF)</p>
			<p>This is <a id="_idIndexMarker236"/>much better, and we can start to see that this could be queried and updated in a very tidy way. There is one further improvement we could make though. The <strong class="bold">Habit</strong> table has a <strong class="bold">Frequency</strong> column that is indirectly dependent on the ID column. This is called a transitive dependency. In order to move this data to the third normal form, we must break this transitive dependency by adding a <strong class="bold">Frequency</strong> table:</p>
			<div><div><img src="img/B19343_Figure_4.4.jpg" alt="Figure 4.4 – Data in the third normal form (3NF)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Data in the third normal form (3NF)</p>
			<p>The third normal form is sufficient at this stage, and we’ll take this no further. You can see that all of the data is separated into individual tables, and linked through foreign key constraints to the <strong class="bold">UserHabit</strong> table. This allows efficient querying and updating of the data in the database.</p>
			<h3>Indexing and performance optimization</h3>
			<p>Indexing a database <a id="_idIndexMarker237"/>means creating a separate data structure that is used to improve the performance of certain types of queries. Indexes are typically created on specific columns within a table, allowing the database to quickly locate the rows that match given criteria. For example, if you have a large table of customer records and you frequently search for customers by their last name, you could create an index on the <code>last_name</code> column to improve the performance of those searches. Indexes can significantly improve the performance of certain types of queries, but they also have a cost in terms of storage space and maintenance. As a result, it is important to carefully consider which columns should be indexed and to balance the benefits of indexing with the costs.</p>
			<p>To do indexing<a id="_idIndexMarker238"/> with Entity Framework, developers can use a variety of tools and approaches. One way to do indexing is to use the Entity Framework Fluent API, which allows developers to define indexes on their entities using code. To create an index using the Fluent API, developers can use the <code>HasIndex</code> method and specify the properties that should be included in the index. Another option is to use Entity Framework Designer, a visual tool that allows developers to design their data model using a graphical interface. The Designer includes the ability to define indexes on entities by right-clicking on an entity and selecting <strong class="bold">Add Index</strong>. Finally, developers can use database migrations to create indexes on their entities by adding the appropriate code to their migration files.</p>
			<p>Configuring indexes with Entity Framework is straightforward!</p>
			<p>If we consider the <code>GoodHabit</code> table that we developed in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>, we used the following C# code to define the structure of the table:</p>
			<pre class="source-code">
public class GoodHabit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
}</pre>
			<p>We can add an index to the <code>Name</code> column by decorating the class with an attribute like so:</p>
			<pre class="source-code">
[Index(nameof(Name))]
public class GoodHabit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
}</pre>
			<p>This will <a id="_idIndexMarker239"/>instruct the database platform to create an<a id="_idIndexMarker240"/> index for the <code>Name</code> column. We could do the same for the <code>ID</code> column in the same way. You can create a composite index by setting the attribute as follows:</p>
			<pre class="source-code">
[Index(nameof(Name), nameof(Id))]</pre>
			<p>If you need to set the sort order of the indexes, you can use one of the following:</p>
			<pre class="source-code">
[Index(nameof(Name), nameof(Id)), AllDescending = true]
[Index(nameof(Name), nameof(Id)), IsDescending = new[] { false, true }]</pre>
			<p>If you want to name your index, you can use the following:</p>
			<pre class="source-code">
[Index(nameof(Name), Name = "Index_Name")]</pre>
			<p>There is a great deal of flexibility provided by Entity Framework, and it is out of the scope of this book to cover all of it.</p>
			<p>You can get more information about it at <a href="https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations">https://learn.microsoft.com/en-us/ef/core/modeling/indexes?tabs=data-annotations</a>.</p>
			<p>We will now build out a database for the example application, being mindful of what we have just learned.</p>
			<h3>Designing a database schema using Entity Framework code first</h3>
			<p>Before we start <a id="_idIndexMarker241"/>designing a database, let’s stop and think about what our requirements are:</p>
			<ul>
				<li>The database will store user information to identify individual users</li>
				<li>Users can add habits to the database to track their progress and achieve their goals</li>
				<li>Users can log progress for each habit and set reminders to perform it</li>
				<li>Users can set goals for their habits, such as running a certain number of miles or saving a certain amount of money</li>
				<li>The database can support users in achieving their goals and improving their overall well-being by tracking and managing their habits</li>
			</ul>
			<p>The following <a id="_idIndexMarker242"/>figure shows a diagram representing the database that we just configured. This shows the tables, columns, and relationships between the tables:</p>
			<div><div><img src="img/B19343_Figure_4.5.jpg" alt="Figure 4.5 – A suggested database schema"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – A suggested database schema</p>
			<p>The preceding diagram shows a schema that can meet the requirements defined previously.</p>
			<h3>Creating the entity classes</h3>
			<p>As we are using <a id="_idIndexMarker243"/>Entity Framework code first, we will build this database by writing C# code. Create the entity classes with the following:</p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.Database/Entities; \</strong>
<strong class="bold">touch Goal.cs; \</strong>
<strong class="bold">touch Progress.cs; \</strong>
<strong class="bold">touch Reminder.cs; \</strong>
<strong class="bold">touch User.cs;</strong></pre>
			<p>We <a id="_idIndexMarker244"/>already have the <code>Habit</code> entity, but we will update it with some additional properties. Copy the following code into <code>Habit.cs</code>:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Name), nameof(Id))]
public class Habit : IHasTenant
{
    public int Id { get; set; }
    public string Name { get; set; } = default!;
    public string Description { get; set; } = default!;
    public int UserId { get; set; }
    public virtual ICollection&lt;Progress&gt; ProgressUpdates {
      get; set; } = default!;
    public virtual ICollection&lt;Reminder&gt; Reminders { get;
      set; } = default!;
    public virtual Goal Goal { get; set; } = default!;
    public Duration Duration { get; set; }
    public string TenantName { get; set; } = default!;
}
public enum Duration { DayLong, WeekLong, MonthLong }</pre>
			<p>Next, <code>Goal.cs</code> should<a id="_idIndexMarker245"/> look like this:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Goal
{
    public int Id { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}</pre>
			<p><code>Progress.cs</code> should look like this:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Progress
{
    public int Id { get; set; }
    public DateTime Date { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}</pre>
			<p><code>Reminder.cs</code> should<a id="_idIndexMarker246"/> look like this:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class Reminder
{
    public int Id { get; set; }
    public Frequency Frequency { get; set; }
    public int HabitId { get; set; }
    public virtual Habit Habit { get; set; } = default!;
}
public enum Frequency { Daily, Weekly, Monthly }</pre>
			<p>And finally, <code>User.cs</code> should look like this:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database.Entities;
[Index(nameof(Id))]
public class User
{
    public int Id { get; set; }
    public string FirstName { get; set; } = default!;
    public string LastName { get; set; } = default!;
    public string Email { get; set; } = default!;
}</pre>
			<p>Add the<a id="_idIndexMarker247"/> following lines of code into the <code>GoodHabitsDbContext</code> class:</p>
			<pre class="source-code">
  public DbSet&lt;User&gt;? Users { get; set; }
  public DbSet&lt;Progress&gt;? Progress { get; set; }
  public DbSet&lt;Reminder&gt;? Reminders { get; set; }
  public DbSet&lt;Goal&gt;? Goals { get; set; }</pre>
			<p>You can create the migration by running the following in the console:</p>
			<pre class="source-code">
<strong class="bold">dotnet-ef migrations add AdditionalEntities --startup-project ../GoodHabits.HabitService/GoodHabits.HabitService.csproj</strong></pre>
			<p>The migrations will be automatically applied to the database when <code>HabitService</code> runs, so simply run the Habit service to push the changes to the database.</p>
			<p>Using the Server Explorer to view the database, we can see that the schema has been successfully applied!</p>
			<div><div><img src="img/B19343_Figure_4.6.jpg" alt="Figure 4.6 – The schema applied to the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The schema applied to the database</p>
			<p>The preceding<a id="_idIndexMarker248"/> figure shows that the schema has successfully migrated to the database.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor110"/>Testing data-rich applications</h1>
			<p>Testing<a id="_idIndexMarker249"/> the database layer of a SaaS application is an essential part of the development process. A database is a critical component of any application, as it stores and manages the data that an application relies on. Ensuring that the database is working correctly is crucial for the overall stability and performance of the application.</p>
			<p>There are several challenges that you may encounter when testing the database layer of your application. One challenge is ensuring that the database schema is correct and that the data is stored and retrieved correctly. Another challenge is ensuring that the database is properly optimized for performance, particularly if you are dealing with large amounts of data.</p>
			<p>There are a<a id="_idIndexMarker250"/> number of different techniques that you can use to test the database layer of your application. One common technique is to use unit tests to verify that individual database functions are working correctly. Another technique is to use integration tests to ensure that the database is working correctly in conjunction with the rest of the application. You may also want to use performance tests to ensure that the database is able to handle large amounts of data without experiencing any issues.</p>
			<p>Unit tests are a type of automated testing that is used to verify the behavior of individual units of code, such as individual functions or methods. In contrast to unit tests, integration tests focus on testing how different parts of an application work together as a system. Integration tests are used to ensure that different components of the application are able to communicate and interact with one another correctly.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor111"/>Upgrading a database</h1>
			<p>Upgrading a<a id="_idIndexMarker251"/> database with Entity Framework involves making changes to the database schema and data to reflect changes in an application. This can include adding new tables or columns, modifying existing tables or columns, and migrating data from one format to another.</p>
			<p>There are several approaches that you can take when upgrading a database with Entity Framework. One approach is to use the <code>DbMigrations</code> class to automatically generate and execute the necessary SQL commands to update the database schema. This can be convenient, as it allows you to make changes to the database using a high-level API, rather than having to write raw SQL commands. However, it can also be less flexible than some other approaches, as it relies on Entity Framework to generate the SQL commands, and that may not always produce optimal results. This is the approach that we will take in this chapter.</p>
			<p>It is worth being aware of a popular alternative approach, which is to use Entity Framework’s <code>DbContext</code> class to manually execute SQL commands to update a database. This can be more flexible, as you have complete control over the SQL commands that are executed. However, it can also be more time-consuming and error-prone, as you have to write and debug the SQL commands yourself.</p>
			<p>Finally, it is, of course, possible to update a database separately from Entity Framework using any preferred method, which most likely involves executing SQL scripts.</p>
			<p>I think<a id="_idIndexMarker252"/> that it is generally preferable to make use of the built-in migration tools and allow Entity Framework to do the heavy lifting for us.</p>
			<p>We saw this process in practice twice – when we created the initial migration in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>, and when we just updated the schema.</p>
			<p>If you look at the <code>Migrations</code> folder in the <code>Database</code> project, you should see the following files:</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B19343_Figure_4.7.jpg" alt="Figure 4.7 – The Migrations folder"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – The Migrations folder</p>
			<p>In the preceding figure, we can see the <code>.._InitialSetup.cs</code> file that contains our first pass, the <code>.._MultiTenant.cs</code> file that has the modifications that we made in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, and the <code>AdditionalEntities.cs</code> file that we added in this chapter.</p>
			<p>If you recall, in <a href="B19343_02.xhtml#_idTextAnchor056"><em class="italic">Chapter 2</em></a>, we added the initial migration with the following:</p>
			<pre class="source-code">
dotnet-ef migrations add Initial</pre>
			<p>However, when creating the second migration, we used this instead:</p>
			<pre class="source-code">
dotnet-ef migrations add MultiTenant --startup-project ../GoodHabits.Api/GoodHabits.Api.csproj</pre>
			<p>The reason for this is that the work we did in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a> to introduce the multi-tenancy has added parameters to the constructor, which are defined in the API project. Pointing the migration<a id="_idIndexMarker253"/> tool at the API project allows it to create migrations via the <code>HabitService</code> project.</p>
			<p>If you look into either of these generated classes, you will see two methods, named <code>Up</code> and <code>Down</code>. These methods allow the migration to be added to the database, or rolled back.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/>Applying the migrations</h2>
			<p>Because of <a id="_idIndexMarker254"/>how we have configured the databases for multi-tenancy in <a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, we do not need to manually update each database. However, should you find you need to manually update a database, you can use the following:</p>
			<pre class="source-code">
<strong class="bold">dotnet-ef database update --startup-project ../GoodHabits.Api/GoodHabits.HabitService.csproj</strong></pre>
			<p>Issuing this command will instruct Entity Framework to look in the <code>Migrations</code> folder and compare the migrations that it finds there with the migrations that are present in the database. If there are any additional migrations that have not yet been applied to the database, Entity Framework will apply those migrations. Let’s take a closer look at the first one we created, called <code>initial</code>:</p>
			<pre class="source-code">
using Microsoft.EntityFrameworkCore.Migrations;
#nullable disable
#pragma warning disable CA1814 // Prefer jagged arrays over
                               // multidimensional
namespace GoodHabits.Database.Migrations
{
    /// &lt;inheritdoc /&gt;
    public partial class InitialSetup : Migration
    {
        /// &lt;inheritdoc /&gt;
        protected override void Up(MigrationBuilder
          migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Habits",
                columns: table =&gt; new
                {
                    Id = table.Column&lt;int&gt;(type: "int",
                      nullable: false)
                        .Annotation("SqlServer:Identity",
                          "1, 1"),
                    Name = table.Column&lt;string&gt;(type:
                      "nvarchar(max)", nullable: false),
                    Description =
                      table.Column&lt;string&gt;(type:
                      "nvarchar(max)", nullable: false)
                },
                constraints: table =&gt;
                {
                    table.PrimaryKey("PK_Habits",
                      x =&gt; x.Id);
                });
            migrationBuilder.InsertData(
                table: "Habits",
                columns: new[] { "Id", "Description",
                  "Name" },
                values: new object[,]
                {
                    { 100, "Become a francophone",
                      "Learn French" },
                    { 101, "Get really fit",
                      "Run a marathon" },
                    { 102, "Finish your book project",
                      "Write every day" }
                });
        }
        /// &lt;inheritdoc /&gt;
        protected override void Down(MigrationBuilder
          migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Habits");
        }
    }
}</pre>
			<p>This code is auto-generated by the migration tool, but it’s perfectly acceptable to manually adjust the<a id="_idIndexMarker255"/> code here if there is a reason to. We can see two methods here. One is called <code>Up</code>, and the other <code>Down</code>.</p>
			<p>The <code>Up</code> method creates the table in the database, and the <code>Down</code> method drops the table. This is converted into SQL code, which is issued to the database engine when the <code>database update</code> command is issued.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor113"/>Summary</h1>
			<p>We have covered a lot in this chapter!</p>
			<p>We learned that data is important in a SaaS application. This can be trying not only from a technical point of view but also from the point of view of a user, as well as the organization building the application.</p>
			<p>We then moved on to a technical implementation with Entity Framework, demonstrating how to build a database in code using C#, and then automatically generate migrations and update the database.</p>
			<p>We also talked about testing strategies and maintaining a database in production.</p>
			<p>In the next chapter, we will build out the API layer and start to interact with the data structure we previously created. The application will start to take shape!</p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor114"/>Further reading</h1>
			<ul>
				<li>What is Code-First?: <a href="https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx">https://www.entityframeworktutorial.net/code-first/what-is-code-first.aspx</a></li>
				<li>Testing with Entity Framework: <a href="https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/">https://www.michalbialecki.com/en/2020/11/28/unit-tests-in-entity-framework-core-5/</a></li>
				<li>Data-driven culture: <a href="https://www.smartkarrot.com/resources/blog/data-driven-culture/">https://www.smartkarrot.com/resources/blog/data-driven-culture/</a></li>
				<li>Database normalization: <a href="https://www.sqlshack.com/what-is-database-normalization-in-sql-server/">https://www.sqlshack.com/what-is-database-normalization-in-sql-server/</a></li>
			</ul>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor115"/>Questions</h1>
			<ol>
				<li>In what ways can a business monetize data that is present in a SaaS application?</li>
				<li>What are the ethical considerations around data monetization?</li>
				<li>How are foreign key relationships represented in Entity Framework?</li>
				<li>What is the difference between a unit test and an integration test?</li>
				<li>If I want to roll back migration in a live database, how do I ensure that no data is lost?</li>
			</ol>
		</div>
	</body></html>