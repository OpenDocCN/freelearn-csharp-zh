- en: Chapter 3. Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter deep-dives into the asynchronous and multithreaded programming
    concepts. We will discuss platform-specific problems and give an in-depth description
    of how threading scenarios are executed on different platforms. The chapter is
    divided into following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading on Xamarin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading on Xamarin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Xamarin platforms together with Windows Runtime follow the basic principles
    of a single-threaded apartment model. In this model, in simple terms, a process
    is assigned a single thread which acts as the main trunk for all the other possible
    branches to be created from and yield back to.
  prefs: []
  type: TYPE_NORMAL
- en: While developers still have the ability to create and consume multiple threads,
    in modern applications on Xamarin target platforms, this model has been extended
    with concurrency implementations that delegate the responsibility of thread management
    to runtime and allow the developer only to define execution blocks which may or
    may not be executed on a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Single thread model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android and iOS, each mobile application is started and run on a single thread
    that is generally referred to as the main or the UI thread. Most of the UI interaction
    and process lifecycle event handlers and delegates are executed on this thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, developers' main concern should be keeping the main thread accessible
    to UI interaction as long as possible. If we were to execute a blocking call on
    this thread, it immediately would be reflected to the user as a screen freeze
    or an application nonresponsive error, which will inevitably get terminated by
    the so-called watch-dog implementation of the underlying platform. In addition
    to the platform-specific restrictions, users also expect a responsive UI at all
    times and cannot tolerate frozen screens even for a fraction of a second. If the
    screen freeze lasts any longer, they will try to forcefully terminate the application
    (see the *Feedback* section of [Chapter 7](ch07.html "Chapter 7. View Elements"),
    *View Elements*).
  prefs: []
  type: TYPE_NORMAL
- en: Developers can still create, consume, and monitor other threads from the main
    thread. It is possible to use background threads and invoke long running processes
    in the background. For this purpose, the `System.Threading` namespace and threading
    related classes are available on Xamarin.iOS and Xamarin.Android projects. Moreover,
    each platform has its own threading implementation under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s imagine we want to execute a long running process and we
    do not want this method to block the UI thread. With classic threading, the implementation
    would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each `Thread` can give information about the current execution state, and it
    can be canceled, started, interrupted, or even joined by another thread. Developers
    can use the threading model for throttling their application and/or executing
    their code more efficiently without committing the cardinal sin of blocking the
    UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: It might get a little complicated when the process you are executing on a separate
    thread needs to update a UI component. This would be a cross-thread violation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we wanted to update a UI component from a separate thread
    in an Android activity, we would need to execute it on the activity as follows
    (using `Activity.RunOnUiThread`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The same execution on iOS would look similar to (using `NSObject.InvokeOnMainThread`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For reference, on Windows Runtime the same execution would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The implementation in classic threading gets even more complex when there is
    an exception or the operation has to be canceled, not to mention the fact that
    synchronization between threads and thread-safe data flow is completely left to
    developers or third-party implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Another important mishap of using the `System.Threading` namespace and the classic
    threading model in Xamarin, is that this namespace and thread-related classes
    cannot be used in PCLs.
  prefs: []
  type: TYPE_NORMAL
- en: Task-based Asynchronous Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the introduction of the Tasks framework in .NET 4.0 and its later adoption
    by Mono, the **Task-based Asynchronous Pattern** (**TAP**) has become de-facto
    the main implementation strategy for mobile applications. While providing the
    required abstraction from the treading structure, it also gives the development
    teams the opportunity to create easily readable, manageable, and scalable application
    projects. As mentioned earlier, since each Xamarin target platform has the threading
    implemented according to the underlying runtime, this abstraction that the Tasks
    framework provides makes it the perfect candidate for asynchronous implementations
    in cross-platform projects and an invaluable part of portable class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, each execution block is represented by a `Task` or a `Task<T>`
    according to the return value of the block (for example, if the block is returning
    void, it should be converted to return `Task` and if the block is returning an
    `int`, the method signature should be `Task<int>`). Tasks can be executed either
    synchronously or asynchronously, can be awaited for a result or executed as a
    promise with a callback on completion, can be pushed to another thread-pool or
    executed on the main thread taking processor time when available.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are especially suited for computationally intensive operations, since
    they provide excellent control over when and how the asynchronous method is executed.
    Cancellation and progress support on these methods makes long running processes
    easily manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency model on iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concurrency and operation blocks on iOS runtime are Apple's take on the same
    issues that the Tasks framework is trying to resolve. In essence, the Tasks framework
    and concurrency model on iOS are the solution to creating multitasking, robust,
    and easily scalable applications by creating an abstraction layer so that applications
    do not directly manage threads, but let the operating system decide on where and
    when to execute operations.
  prefs: []
  type: TYPE_NORMAL
- en: The iOS runtime uses operation or dispatch queues to asynchronously dispatch
    tasks in a **first-in-first-out** (**FIFO**) manner. This approach provides automatic
    thread-pool management as well as a simple programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: While the iOS runtime constructs such as `NSOperation`, `NSBlockOperation`,
    and `NSOperationQueue` are implemented in the Xamarin.iOS framework and are ready
    to use, the implementations would only be targeting the iOS platform while Tasks
    can be used on all three platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Task Parallel Library** (**TPL**) constitutes the core part of parallel
    computing in the .NET framework and has inherently the same stature in Xamarin
    runtime(s).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous method execution, together with the `async` and `await` keywords
    (introduced with C# 5.0), can make the apps more responsive and efficient and
    decrease the complexity of implementing multithreading and synchronization. Without
    having the need to implement a parameterized thread, start and push are delegated
    to a background thread, with so called "awaitables." You can convert your methods
    to async promises easily with `Task` or `Task<T>` as the return type. In return,
    the runtime chooses the best time to execute the code and returns the result to
    your execution context.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the previous thread creation example with Tasks would be as simple
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, the Tasks framework is not only about creating threads or executing
    non-blocking methods, but also about coordinating and managing these asynchronous
    tasks in the easiest way possible. There are many static helper methods as well
    as methods implemented for Tasks that help developers to easily implement some
    of these coordination scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Continuation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ContinueWith` function on the `Task` class allows the developers to chain
    dependent Tasks together and execute them as one Task as a whole. The continuation
    delegate is executed once the result from the first task is posted back to the
    task scheduler. It is important to mention that the first task and the continuation
    methods are not necessarily executed on the same thread. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In case the second task was dependent on the result from the first task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cancellation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`CancellationToken` and `CancellationTokenSource` are used as the remote token
    to control the execution lifetime of an async method, thread, or a number of threads
    and the event source that the token reflects the events of.'
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, `CancellationTokenSource` is responsible for throwing either
    time-based or manual cancel events and these events can be retrieved through the
    token in the context of the asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a cancellation source using the default constructor and time-based
    cancellation can be added to the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are executing an async method, we can use the token from this source,
    or we can associate it with a `TaskFactory` to create a cooperating list of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can also cancel the thread or a group of threads using the `Cancel`
    or `CancelAfter` (with a time delay) methods of `CancellationTokenSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Progress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another asynchronous control feature that helps keep the user informed about
    the operations being invoked in the background is the progress callback implementation.
    Just like `CancellationToken`, we can supply the asynchronous tasks with an event
    handler for progress events that the asynchronous method can invoke to pass progress
    information back to the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: For simple progress reporting, it is enough to expand asynchronous methods with
    an additional parameter that derives from the `IProgress<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we were to implement a progress event handler in the `GetFibonacciRangeAsync`
    method, we could use the number of values to be calculated and the current ordinal
    being calculated to report an overall progress in percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to use the progress value in our view model, we can make
    use of the `Progress<T>` class, which is the default implementation of `IProgress<T>`.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Task batches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In task-based asynchronous pattern, there are other ways than continuation
    to execute tasks in a batch, even in parallel. The example from the previous section
    was awaiting each number calculation separately and executing the next call. However,
    the manner in which the inner methods were implemented made them independent from
    each other. Hence, it is not actually necessary to wait for them one by one to
    return the result. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Mvx` static class and the `Trace` method are provided by the MvvmCross
    library. It will be further discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, each Fibonacci number in the sequence is calculated in parallel and when
    the sequence range is complete, an array of result values is returned. Finally,
    we sort the array and return the list of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend this implementation by adding a progress notifier with an interlocked
    (thread-safe) counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting log traces from the calculations above are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The total time for the calculations was about 1.2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeating the same calculations with an `await` on each method would give the
    following output (calculating ordinal 4 until 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The same calculations took around 6.3 seconds overall.
  prefs: []
  type: TYPE_NORMAL
- en: On top of `WhenAll`, developers are also equipped with the `WhenAny`, `WaitAll`,
    `WaitAny` methods on the `Task` class and `ContinueWhenAll` and `ContinueWhenAny`
    on the `TaskFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, the discussion was centered on the `System.Threading.Tasks`
    namespace and the `Task` class. Even though tasks are the cornerstone of the task-based
    asynchronous model and so-called Task Parallelism, the concurrent collections
    namespace makes up the Data Parallelism side of the async model and provides developers
    with tools to execute code most efficiently and in a thread-safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: '`BlockingCollection<T>` is one of the concurrent collection implementations
    that encapsulates the core synchronization and coordination between threads and
    provides a thread-safe data storage to implement a provider-consumer model in
    Xamarin applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Using `BlockingCollection<T>`, we can easily implement a new method that makes
    use of the parallel execution from the previous example. In this implementation,
    our view model will be the consumer and the Fibonacci source and the range calculation
    tasks will be the provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to rewrite the range calculation method using a blocking collection,
    our method signature would be similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'So in a way, the consumer is going to create the blocking collection and will
    pass it to the provider to fill it up with the calculated values. The provider
    in return will need to push each calculated value from the parallel tasks with
    the `TryAdd` or `Add` methods. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once all the calculations are completed, the provider needs to mark
    the collection as add-completed. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While these tasks are being executed on the provider side, we can create the
    consumer in our view model with a `while` loop, checking on certain intervals
    if there is a new item with `TryTake` until it is completed. However, there is
    already an implemented method on the concurrent collection for this purpose: `GetConsumingEnumerable`.
    Using this method makes the execution on the consumer thread as simple as a `foreach`
    block. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this model, the provider thread (together with each parallel task being executed)
    and the consumer thread are executed almost instantaneously and the results are
    reflected to the UI almost immediately through the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous implementation, even though possibly multiple values are added
    to the blocking collection and the blocking collection''s support for multiple
    consumers, the `foreach` loop follows a more linear execution. We can extend this
    model by adding multiple consumers using the `Parallel.ForEach` extension method
    from the `System.Threading.Tasks.Parallel` namespace. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are other constructs and implementation patterns that developers can use
    and adapt on concurrent scenarios such as `Partitioner`, `ActionBlock`, `ConcurrentScheduler`,
    among others. However, these concepts are beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to draw parallels with and even convert from the classic threading
    and eventing patterns while implementing asynchronous tasks. However, async methods
    have to be implemented with caution to avoid deadlocks and uncaught exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Async pattern conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Observer pattern—also known as the **Event-based Asynchronous Pattern**
    (**EAP**)—used to be the main development tool for long running processes and
    service/remote application APIs. Events and delegates still make up a considerable
    amount of UI-related implementation in modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, asynchronous tasks and awaitables provide a much more convenient way
    to deal with long running processes and chain completion methods.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is possible to implement conversion patterns from other async
    patterns to task-based implementations. These types of scenarios involve using
    the `TaskCompletionSource` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to demonstrate this, we will be using a simplified version of the
    Fibonacci source implementation from previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have an event handler for successful calculations and another
    one for failed calculations (for example, if the ordinal is less than 0, it should
    throw an `ArgumentOutOfRangeException`).
  prefs: []
  type: TYPE_NORMAL
- en: Our aim here is to implement an asynchronous method, which we can execute and
    yield the result to the UI without having to subscribe to the event every time
    a new `FibonacciSource` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we can implement a new version of `FibonacciSource` and expose
    only async methods instead of event-based methods. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now calls to calculate Fibonacci numbers would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This implementation can be further extended with progress and cancellation token
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-threading with tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important thing to realize about asynchronous calls is that they don't necessarily
    run on a separate thread. As a matter of fact, calls are "scheduled" to run in
    a so-called Synchronization Context on the main thread unless they are instructed
    otherwise. Synchronization Context is the message queue that takes care of the
    scheduling of the async calls that need to be awaited. Once the async method (or
    `Task` in most of the cases) is successfully executed, the result is posted back
    onto the Synchronization Context (that is, the main UI thread).
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, we will be using the async implementation (EAP conversion)
    from the previous example with some additional diagnostic calls to get additional
    information about the threads and synchronization contexts being used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TraceThreadInfo` method and the associated `ThreadInfo` class used in the
    examples here is a custom implementation used through dependency injection. The
    reason for this is that threading namespace only contains task-related classes
    in PCLs and the only way to actually get the current thread ID is to use platform-specific
    implementation. Platform-specific implementation patterns will be discussed in
    detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the tracing method, we will be logging the current thread ID and the current
    synchronization context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The calculation command attached to the calculate button is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated trace log will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-threading with tasks](img/B04693_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Trace for in-line execution of tasks
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the trace messages of the execution stack above, one can easily see
    that in spite of the fact we are dealing with async tasks, the whole execution
    takes place on the main thread except for the actual call for the internal method
    of the source (that is, it is executed on Thread 106). The rest of the method
    calls have `Android.App.SyncContext` as the synchronization context and the execution
    order is no different than the call sequence that is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the implementation a little bit and using the `ContinueWith` function
    of the `Task` item, we get slightly different results. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The trace log for this implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-threading with tasks](img/B04693_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Async execution of Tasks
  prefs: []
  type: TYPE_NORMAL
- en: As the trace log suggests, `ContinueWith` lambda is executed on a separate thread
    but the execution is still sequential.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important note here is that we are assigning the results back to the ViewModel
    on a separate thread. In this example, the cross-thread invocation is handled
    by the MvvmCross framework. If we were to deal with this assignment, the call
    would look similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, once the execution gets onto a separate thread, the
    synchronization context is nullified. In .NET runtime, asynchronous tasks that
    are not tracked by the main synchronization context are actually assigned a `TaskScheduler`
    instance and the execution is done through this context. In this case, `TaskScheduler`
    is responsible to redirect the success post messages back to the main thread if
    the task is configured to use the same context (that is, `ConfigureAwait(true)`).
  prefs: []
  type: TYPE_NORMAL
- en: However, the way synchronization context works in .NET and the configured task
    invocations yield back to the main thread can cause deadlocks if the asynchronous
    tasks are called synchronously (that is, with `Task.Result` or `Task.Wait()`)
    on the main thread. In such a scenario, once the async call finishes executing
    and tries to yield back into the main context, the main context will still not
    be accessible since it is actually waiting for the async task itself to complete.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigureAwait(false)` informs the scheduler not to look for and post back
    the result to the same execution context where the task was invoked, but rather
    just execute and run to completion on the execution context. This avoids the deadlock
    scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: This deadlock scenario is specific for .NET runtime and because of the way mono
    runtime on Android and Mono.Touch compiler deal with the task executions; the
    deadlocks currently do not happen on these platforms. However, it is important
    to follow the coding conventions associated with asynchronous tasks and awaitables
    to avoid any unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to execute the whole task on a separate thread we can use `Task.Run`
    (which will push the task to the ThreadPool) or `Task.Factory.StartNew`. Using
    the `StartNew` method would let you define which type of a method you are about
    to execute in this task and let the runtime make an informed decision about using
    a different thread. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the trace below, the biggest difference with the previous examples is that
    the `DoCalculate` method exits before even the execution starts for the task we
    created for the calculations. This type of execution would eloquently fit with
    the MVVM pattern applied on a cross platform mobile app project. It would avoid
    any UI blocking issues and create a sense of continuity for the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-threading with tasks](img/B04693_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Starting a new async task
  prefs: []
  type: TYPE_NORMAL
- en: If we want to analyze the same execution on the iOS application (that is, calculate
    the number on the Fibonacci sequence on a certain ordinal), we can easily identify
    the threading pattern with the Xcode Instruments "System Trace" template.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-threading with tasks](img/B04693_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating four different Fibonacci numbers
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling exceptions can become cumbersome if correct asynchronous paths are
    not followed in multithreaded implementations. However, in most cases, the async/await
    language constructs take the load of the developers. If the async chain is not
    broken and calls are implemented correctly, catching exceptions in asynchronous
    context is no different than catching them with linear code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our example from previous sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if the ordinal we pass in as a parameter is a negative number,
    it would throw an exception with the message **Cannot calculate Fibonacci number
    for a negative number** and we would be displaying the error message in the info
    textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we were to use the `ContinueWith` construct to execute the same
    code the outcome would have been a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the exception message we would receive would be **One or more
    errors occurred**. The reason for this is that the exception thrown in the second
    scenario is an `AggregateException` because of the async chain we created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exception handling](img/B04693_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AggregateException in async chain
  prefs: []
  type: TYPE_NORMAL
- en: The result would have been the same if we were using the `.Result` or `.Wait()`
    calls on the task itself.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of this implementation is where we are calling `await` on
    the asynchronous method. The catch block would never have been called if this
    was not the case. Without the `await` keyword, the try/catch block would have
    been just checking if the preparation of the Task went as expected, not the actual
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: Another type of async execution that cannot be caught with a try/catch block
    is the type of async methods that return `void` instead of a `Task` or `Task<T>`.
    Similar to having an exception thrown in an event handler, the only two places
    they would be caught are the `AppDomain.UnhandledException` or `Application.ThreadException`
    events. It is always a better practice for asynchronous methods to return `Task`
    and then return void.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in the `ContinueWith` implementation, with the reference to the `Task`
    at hand, we can also check for the status of the task once it runs to completion
    before we make the result assignment. This assignment is what actually causes
    the exception to bubble-up to upper layers. In this case, we do not need a try/catch
    block. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Initialization pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Especially in scenarios where a service is involved, a common requirement is
    to have an initialization function that would prepare the communication channel
    and/or make a "ping" or an authentication call. When developers are confronted
    with this type of a scenario, the biggest mistake they can make is to call the
    asynchronous initialization function in the constructor with a `.Result` and/or
    `.Wait()` statement (making it a synchronous call).
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, let's assume we have a service that implements an interface
    with two simple async method implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to call `ServiceMethodAsync`, we first need to make an
    `AuthenticateAsync` call and receive the authentication token from the service.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we implemented the call for authentication in the constructor
    of the service. Even though the implementation might work in some cases, if the
    service constructor is called from the main UI thread, the thread would go into
    a deadlock as it was described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest solution would be to either expose the initialization function
    to outer layers or have the service call initialization before each service call.
    For this purpose we can wrap the authentication call in an initialization method.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The service method call would look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, we can also expose the initialization through an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the caller method needs to check if the service needs async initialization
    and check for the required task results. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Semaphores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Synchronization and throttling methodology on the asynchronous context is a
    little different than the classic .NET runtime implementations. For instance,
    lock blocks are not allowed on async calls and you will not be able to use `Mutex`
    for synchronization. `Mutex` is inapplicable as a mutex can only be owned by a
    single thread and async executions are not guaranteed to complete on the same
    thread as they started. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to handle the non-deterministic execution and threading model of asynchronous
    tasks, a new construct was added to .NET: Semaphore. `Semaphore` (implementation
    of `WaitHandle`) and `SemaphoreSlim` (lightweight version of `Semaphore` that
    is implemented with monitors) types do not enforce thread identity on the `Wait`
    and `Release` calls and can be asynchronously awaited.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s execute a number of parallel calculations orchestrated
    with a semaphore that allows 3 access count (`SemaphoreSlim(3)` or `SemaphoreSlim(3,3)`)
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This parallel execution can be easily spotted on the average system time view
    of Instruments'' System Trace template. This is shown in the screenshot below
    where each ordinal calculation would give the exact number of peaks on the selected
    calculation threads):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Semaphores](img/B04693_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: System time average on synchronized threads
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threading and task solutions are not the only option when there is a need to
    execute a not time-bound, long running process. Moreover, both of these options
    are for executing code when your application is in the foreground or in an active
    state. When the application is entering the backgrounded or suspended state, the
    application might still require the execution of some longer method before the
    volatile data is lost, or it might require a process to be running in the background
    when the application is not in an interactive state.
  prefs: []
  type: TYPE_NORMAL
- en: For these types of scenarios, both iOS and Android offer backgrounding and background
    operation options.
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks on iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Background tasks on iOS are the easiest way for your application to execute
    processing tasks without the need for the UI thread or having to respond to lifecycle
    delegates.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of background tasks that can be executed for different
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background-safe tasks**: These tasks are the ones that can be executed at
    any stage of the process lifetime. They are not affected and/or interrupted by
    the application going into the background. The code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**DidEnterBackground tasks**: Another type of background task is executed to
    pass the state-save or clean-up logic to a background process. The `DidEnterBackground`
    lifetime delegate is used to initialize these tasks and continue processing even
    after the application goes into the background state. The creation of these tasks
    is similar to the background-safe tasks. The only difference is that the `EndBackgroundTask`
    method has to be called inside the execution block rather than the calling thread,
    since the calling process might have already returned not waiting for the execution
    of the background task. The code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Background transfers**: These tasks are specific to iOS 7+ and provide a
    longer processing time (a strict limit on other background tasks is 600 seconds,
    while background transfers can last up to 10,000 seconds). Background transfer
    tasks are used to perform long lasting network operations and upload/download
    large files over the wire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services (Android only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the Android platform, once the activities enter the backgrounded state, they
    cannot perform tasks and are usually stopped soon after entering the background.
    Services are application components introduced to provide an interface for developers
    to start and stop long running processes in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Even though services are created as part of an application, they have their
    own separate lifecycle and can run even if the application and activity that started
    them was stopped or destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service can take one or both of two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Started**: A service is "started" when an activity explicitly starts it by
    calling the `StartService` method using an intent. A started service is generally
    used as a `BackgroundWorker` and once the processing operation is finished, the
    service itself or the activity stops it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bound**: A "bound" service generally acts as the provider to clients in the
    activities of the application or even other applications. A bound service is kept
    alive as long as another component is bound to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these initialization patterns use the callback methods similar but not
    limited to `OnStartCommand`, `OnBind`, `OnCreate`, and `OnDestroy` to start background
    processing and deal with its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: There are various base classes implemented in the Android namespace and according
    to the requirements, these base classes can be implemented and started or bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement a started service to do some background processing, the
    first step of the implementation process would be to create the `IntentService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IntentService` base class already deals with lifecycle events such as
    `OnStart`, so all we have to implement is the `OnHandleIntent` method to respond
    to intent requests from activities. The two attributes of the class, `Service`
    and `IntentFilter`, are used by Xamarin compiler to generate the entries in the
    application manifest. The debug build for this implementation gives out the following
    service entry in the application manifest. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation in an activity, the intent service can be started by
    either using the intent filter entry or using the type of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overall, asynchronous/concurrent implementation patterns and background tasks
    allow the developers to push the heavy-lifting away from the UI thread and create
    responsive applications in the single-threaded paradigm of modern mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Task-based Asynchronous Pattern provides an efficient and scalable way to
    implement asynchronous operations with ease. Moreover, progress, cancellation,
    and concurrent collections help monitor, scale, and manage the execution of these
    asynchronous blocks while providing a way to cooperate between each other. Implementing
    these blocks, developers do not need to carry the burden of threads, synchronization,
    and scaling the threads according to the hardware resources.
  prefs: []
  type: TYPE_NORMAL
- en: After analyzing memory and CPU-related topics so far in this book, in the next
    chapter we will discuss local storage and how to use it efficiently.
  prefs: []
  type: TYPE_NORMAL
