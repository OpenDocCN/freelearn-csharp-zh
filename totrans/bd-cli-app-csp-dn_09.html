<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-133" class="chapter-number"><a id="_idTextAnchor136"/>9</h1>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor137"/>Working with External APIs and Services</h1>
			<p>Although an autonomous application can provide great value to its users, consuming external APIs and services can make it provide even greater value to those users by integrating the functionalities of the application with <span class="No-Break">other applications!</span></p>
			<p>However, consuming external APIs and services creates new dependencies for your application. While this might make perfect sense, you have to know how to interact with these dependencies and how to integrate them into your application, so you don’t couple your application too much to that external dependency and avoid having to change your application’s code every time that <span class="No-Break">dependency changes.</span></p>
			<p>More specifically, in this chapter, we will discuss <span class="No-Break">the following:</span></p>
			<ul>
				<li>The benefits of consuming <span class="No-Break">external APIs</span></li>
				<li>Extending <strong class="bold">Bookmarkr</strong>’s capabilities by consuming an <span class="No-Break">external API</span></li>
				<li>The proper way in .NET to consume <span class="No-Break">external APIs</span></li>
				<li>How to avoid tight coupling between our application’s commands and the <span class="No-Break">external API</span></li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor138"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this <span class="No-Break">book, </span><a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter09</span></a></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Why consume external APIs?</h1>
			<p>When building your application, you have to consider multiple factors and sometimes implement multiple features that go well beyond <span class="No-Break">your expertise.</span></p>
			<p>Does that mean you should not build an application if you do not master every feature? No! Many applications rely on code developed by other people who are more skilled and experienced in a very <a id="_idIndexMarker273"/>specific area. These pieces of code are packaged as APIs and services so we can use (aka consume) them without having to understand every line of code <span class="No-Break">they contain.</span></p>
			<p>We have already come across this situation when we added logging into Bookmarkr. We didn’t develop the logging engine ourselves. We instead relied on an existing service provided by an organization that knows how to do it (and do it well!). By relying on that service, our application was able to benefit from logging functionality without having to be experts in the logging <span class="No-Break">business domain.</span></p>
			<p>Now, I can hear your thoughts (yes, I can – that is my sixth sense 😊). You are thinking that it doesn’t seem that complicated to develop your own logging engine, and you might be right. This is a business decision: if it is part of your core business, then yes, it makes sense to invest time, resources, and money in developing, testing, and maintaining your own logging engine. But remember, while it might be cool to develop it, you will have to maintain it, and that is what hurts many organizations in the long run! You know what they say… You build it, you run <span class="No-Break">it! </span><span class="No-Break">😉</span></p>
			<p>Also keep in mind that building your own “dependencies” (aka, services that are not part of your core business) is not always easy. An example of that is a payment gateway. There is a lot of regulation involved in building and offering such a service. If it’s not your core business (in other words, if you are not Stripe or such a company), don’t do it! Consume an <span class="No-Break">existing service.</span></p>
			<p>By consuming external APIs and services, we can then focus on what we do best, and in our case, it is managing bookmarks! That is the key to consuming external APIs and services: having the ability to focus on our core business and delegating other concerns to whom those concerns are their <span class="No-Break">core business.</span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor140"/>How to consume an external API</h1>
			<p>.NET provides a way to interact with external APIs and services by abstracting the need to construct our own HTTP requests, handle the underlying networking details, send the request, and receive the response while performing serialization and deserialization and handling <span class="No-Break">communication issues.</span></p>
			<p>So, in order to interact with these external APIs and services, .NET provides us with the <strong class="source-inline">HttpClient</strong> class. However, the <a id="_idIndexMarker274"/>proper way to deal with this class is through the <strong class="source-inline">IHttpClientFactory</strong> interface. This allows us to create and manage <strong class="source-inline">HttpClient</strong> instances for optimal performance and <span class="No-Break">resource management.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor141"/>Benefits of using IHttpClientFactory</h2>
			<p>Using <strong class="source-inline">IHttpClientFactory</strong> provides <span class="No-Break">several </span><span class="No-Break"><a id="_idIndexMarker275"/></span><span class="No-Break">advantages:</span></p>
			<ul>
				<li><strong class="bold">Connection management</strong>: It manages the lifetime of <strong class="source-inline">HttpMessageHandler</strong> instances, which helps prevent issues such as <span class="No-Break">socket exhaustion</span></li>
				<li><strong class="bold">Connection reuse</strong>: It reuses underlying HTTP connections, <span class="No-Break">improving performance</span></li>
				<li><strong class="bold">Resilience</strong>: It adds resilience to <span class="No-Break">transient faults</span></li>
				<li><strong class="bold">Configurability</strong>: It allows for easy configuration of <span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break"> instances</span></li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor142"/>Bookmarkr: your bookmarks, anywhere!</h1>
			<p>Up to this point, Bookmarkr has been <a id="_idIndexMarker276"/>managing our bookmarks locally. This means that we are tied to the physical boundaries of <span class="No-Break">our computer.</span></p>
			<p>But what happens if we want to access these bookmarks from <span class="No-Break">another computer?</span></p>
			<p>To make this happen, we will need to extend the capabilities of Bookmarkr beyond the local computer. To do this, we will make Bookmarkr call an external API that will be responsible for storing and retrieving <span class="No-Break">our bookmarks.</span></p>
			<p>For that matter, we will add a new command called <strong class="source-inline">sync</strong> that will be responsible for synchronizing the local<a id="_idIndexMarker277"/> bookmarks with the<a id="_idIndexMarker278"/> ones stored by the <span class="No-Break">external service.</span></p>
			<p class="callout-heading">About the external service</p>
			<p class="callout">When you consume <a id="_idIndexMarker279"/>an external service, you don’t have to know its internals (aka, its architecture, technology stack, application code, and dependencies). This is in accordance with the encapsulation principle of <span class="No-Break">object-oriented programming.</span></p>
			<p class="callout">All you need to know is how to send requests to it and how to interpret the responses <span class="No-Break">it returns.</span></p>
			<p class="callout">However, since I know that you are curious to know more about it, I have provided the details of its architecture and its application and infrastructure code in the <strong class="source-inline">appendixA-bookmarkr-syncr</strong> branch of the <span class="No-Break">GitHub repository.</span></p>
			<p>Let’s start by adding the <span class="No-Break">new command!</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor143"/>The sync command</h1>
			<p>Following the project structure that we<a id="_idIndexMarker280"/> designed in the previous chapter, let’s add a new folder named <strong class="source-inline">Sync</strong> under the <strong class="source-inline">Commands</strong> folder, and within this folder, let’s add a new code file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">SyncCommand.cs</strong></span><span class="No-Break">.</span></p>
			<p>The startup code for this command is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class SyncCommand : Command
{
    #region Properties
    private readonly IBookmarkService _service;
    #endregion
    #region Constructor
    public SyncCommand(IBookmarkService service, string name, string? 
    description = null)
        : base(name, description)
    {
        _service = service;
        this.SetHandler(OnSyncCommand);
    }
    #endregion
    #region Options
    #endregion
    #region Handler method
    private async Task OnSyncCommand()
    {
    }
    #endregion
}</pre>			<p>This code is pretty straightforward and needs <span class="No-Break">no explanation.</span></p>
			<p>The synchronization process comprises the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>The local bookmarks<a id="_idIndexMarker281"/> are sent by Bookmarkr’s <strong class="source-inline">sync</strong> command to the<a id="_idIndexMarker282"/> external service (<span class="No-Break">called BookmarkrSyncr).</span></li>
				<li>BookmarkrSyncr will then perform the synchronization between the local bookmarks it receives from Bookmarkr with the ones it has in its <span class="No-Break">data store.</span></li>
				<li>BookmarkrSyncr will send the synchronized bookmarks back to the Bookmarkr <strong class="source-inline">sync</strong> command’s <span class="No-Break">handler method.</span></li>
				<li>The <strong class="source-inline">sync</strong> command’s handler method will store the received bookmarks in the local data store. Keep in mind that if the application is dealing with large datasets or rate-limiting APIs, batching and retry techniques will <span class="No-Break">be needed.</span></li>
			</ol>
			<p>So, the <strong class="source-inline">sync</strong> command needs to<a id="_idIndexMarker283"/> have a reference to <strong class="source-inline">IHttpClientFactory</strong>. Let’s <span class="No-Break">add this:</span></p>
			<pre class="source-code">
#region Properties
    private readonly IBookmarkService _service;
    private readonly IHttpClientFactory _clientFactory;
#endregion
#region Constructor
    public SyncCommand(IHttpClientFactory clientFactory, 
    IBookmarkService service, string name, string? description = null)
        : base(name, description)
    {
        _service = service;
        _clientFactory = clientFactory;
        this.SetHandler(OnSyncCommand);
    }
#endregion</pre>			<p>In this code, we are adding a <strong class="source-inline">private</strong> property of type <strong class="source-inline">IHttpClientFactory</strong> and we are injecting it through <span class="No-Break">the constructor.</span></p>
			<p>We are then using it in the command’s <span class="No-Break">method handler:</span></p>
			<pre class="source-code">
#region Handler method
    private async Task OnSyncCommand()
    {
        var retrievedBookmarks = _service.GetAll();
        var serializedRetrievedBookmarks = JsonSerializer.
        Serialize(retrievedBookmarks);
        var content = new StringContent(serializedRetrievedBookmarks, 
        Encoding.UTF8, "application/json");
        var client = _clientFactory.CreateClient("bookmarkrSyncr");
        var response = await client.PostAsync(«sync», content);
        if (response.IsSuccessStatusCode)
        {
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var mergedBookmarks = await JsonSerializer.
            DeserializeAsync&lt;List&lt;Bookmark&gt;&gt;(
                await response.Content.ReadAsStreamAsync(),
                options
            );
            _service.ClearAll();
            _service.Import(mergedBookmarks!);
            Log.Information("Successfully synced bookmarks");
        }
        else
        {
            switch(response.StatusCode)
            {
                case HttpStatusCode.NotFound:
                    Log.Error("Resource not found"); break;
                case HttpStatusCode.Unauthorized:
                    Log.Error("Unauthorized access"); break;
                default:
                    var error = await response.Content.
                    ReadAsStringAsync();
                    Log.Error($"Failed to sync bookmarks | {error}");
                    break;
            }
        }
    }
#endregion</pre>			<p>This code is pretty easy to understand <a id="_idIndexMarker284"/>and conforms to the synchronization process we <span class="No-Break">described earlier.</span></p>
			<p>There is, however, one segment in that code that requires <span class="No-Break">an explanation:</span></p>
			<ul>
				<li>We create an HTTP client from the <strong class="source-inline">IHttpClientFactory</strong> instance by relying on the named clients approach. As you can see, we are providing the name of the client configuration (here, <strong class="source-inline">bookmarkrSyncr</strong>) to the <strong class="source-inline">CreateClient</strong> method. We will get back to this <span class="No-Break">configuration later.</span></li>
				<li>Next, we issue a <strong class="source-inline">POST</strong> request to the <strong class="source-inline">sync</strong> endpoint of the remote web service, passing the list of local bookmarks that have been previously serialized as JSON using an instance of the <span class="No-Break"><strong class="source-inline">StringContent</strong></span><span class="No-Break"> class:</span><ul><li>If the request is <a id="_idIndexMarker285"/>successful, we deserialize the returned list of bookmarks (which represents the list of synchronized local and remote bookmarks) and we replace the local list of bookmarks with this <span class="No-Break">new list</span></li><li>If the request is not successful, we display an error message corresponding to the returned HTTP <span class="No-Break">status code</span></li></ul></li>
			</ul>
			<p>In order to import the <strong class="source-inline">IHttpClientFactory</strong> interface, we need to reference the <strong class="source-inline">Microsoft.Extensions.Http</strong> NuGet package. As we already know by now, we can do this by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet add package Microsoft.Extensions.Http</pre>			<p>Before we can use our new command, let’s register it within the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class!</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor144"/>Registering the sync command</h1>
			<p>Let’s register the <strong class="source-inline">sync</strong> command <a id="_idIndexMarker286"/>in the <strong class="source-inline">Program</strong> class. It’s only a matter of one line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
rootCommand.AddCommand(new SyncCommand(_clientFactory, _service, "sync", "sync local and remote bookmark stores"));</pre>			<p>But wait! Where did the <strong class="source-inline">_clientFactory</strong> variable <span class="No-Break">come from?!</span></p>
			<p>Well done! You spotted <span class="No-Break">it! </span><span class="No-Break">😊</span></p>
			<p>As you may have guessed, this is a reference to the <strong class="source-inline">HttpClient</strong> that we need to configure to make the magic happen. This is where we will talk about the named clients approach that we <span class="No-Break">mentioned earlier.</span></p>
			<p>The <strong class="source-inline">_clientFactory</strong> variable is of type <strong class="source-inline">IHttpClientFactory</strong>. So, we first need to declare it within the <strong class="source-inline">Main</strong> method of the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
IHttpClientFactory _clientFactory;</pre>			<p>This will allow us later to retrieve a<a id="_idIndexMarker287"/> reference to it and pass it to the constructor of <strong class="source-inline">SyncCommand</strong> during its registration (as we saw earlier). We can retrieve that reference <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
_clientFactory = host.Services.GetRequiredService&lt;IHttpClientFactory&gt;();</pre>			<p>Finally, let’s register the HTTP client for the BookmarkrSyncr service. We do this within the <strong class="source-inline">ConfigureServices</strong> block <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
services.AddHttpClient("bookmarkrSyncr", client =&gt;
{
    client.BaseAddress = new Uri("https://bookmarkrsyncr-api.
    azurewebsites.net");
    client.DefaultRequestHeaders.Add("Accept", "application/json");
    client.DefaultRequestHeaders.Add("User-Agent", "Bookmarkr");
});</pre>			<p>Let’s explain what this <span class="No-Break">code does:</span></p>
			<ul>
				<li>A name (<strong class="source-inline">bookmarkrSyncr</strong>) is provided for the registered HTTP client. This is why we call this approach “<strong class="source-inline">named clients</strong>”. Notice that this is the same name that is passed to the <strong class="source-inline">CreateClient</strong> method in the <strong class="source-inline">SyncCommand</strong> class we saw earlier. This is how the appropriate HTTP client <span class="No-Break">is selected.</span></li>
				<li>We then specify the base address for the service and a couple of request headers. Note that the base address does not specify the <strong class="source-inline">sync</strong> endpoint. It is specified when performing the request. This allows a web service to have different endpoints and for those endpoints to be invoked as needed without having to specify the base address over and <span class="No-Break">over again.</span></li>
			</ul>
			<p class="callout-heading">About the base address</p>
			<p class="callout">You may have noticed that the base address points to an external URL. I deployed the code of the BookmarkrSyncr service in <a id="_idIndexMarker288"/>App Service <span class="No-Break">on Azure.</span></p>
			<p class="callout">I will keep this service up and running as long as I can but keep in mind that you have access to both its infrastructure and application code in the <strong class="source-inline">appendixA-bookmarkr-syncr</strong> branch if you need to <span class="No-Break">redeploy it.</span></p>
			<p>Everything is now set up. We<a id="_idIndexMarker289"/> can run the program and see <span class="No-Break">what happens.</span></p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor145"/>Running the program</h1>
			<p>To run the program, we simply <a id="_idIndexMarker290"/>need to execute <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet run sync</pre>			<p>The result will be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B22400_09_01.jpg" alt="Figure 9.1 – The sync command in action"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The sync command in action</p>
			<p>Great, <span class="No-Break">isn’t it?</span></p>
			<p>If we list all available local bookmarks, we will notice that they have indeed been synchronized with the remote list <a id="_idIndexMarker291"/><span class="No-Break">of bookmarks.</span></p>
			<p class="callout-heading">What about security?</p>
			<p class="callout">You may certainly have noticed that the web service can be used without any authentication. In other words, anonymous requests are allowed, which may be a <span class="No-Break">security concern.</span></p>
			<p class="callout">You are totally right, and this is intentional for now as security will be addressed in <a href="B22400_13.xhtml#_idTextAnchor220"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> where we will see how we can authenticate users using a technique called “Personal Access Tokens,” which resembles using <span class="No-Break">API keys.</span></p>
			<p>The code works great but there is actually a drawback <span class="No-Break">to it.</span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor146"/>Reducing the coupling between our application and the external dependency</h1>
			<p>In the previous section, although we applied the best practices of consuming external APIs, we created a coupling between our application and <span class="No-Break">that dependency…</span></p>
			<p>Notice that our application actually <a id="_idIndexMarker292"/>knows about the data type and structure that is returned by the API. This means that whenever this API changes, we will need to update our <span class="No-Break">code accordingly.</span></p>
			<p>This also means that our application is responsible for handling the different HTTP codes that the API may return. Can’t we abstract this complexity somewhere so that eventual changes are scoped to a small portion of <span class="No-Break">our code?</span></p>
			<p>Of course we can! And there is a pattern for that, which is called <span class="No-Break"><strong class="bold">Service Agent</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>About the Service Agent pattern</h2>
			<p>The Service Agent pattern abstracts away the details of HTTP communication into a dedicated service, allowing other services (or, in our case, commands) to interact with external systems without directly <a id="_idIndexMarker293"/>dealing with HTTP requests <span class="No-Break">and responses.</span></p>
			<p>There are many benefits to the Service<a id="_idIndexMarker294"/> Agent pattern, among which are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Abstraction</strong>: It abstracts the complexity of HTTP communication, including constructing the HTTP request, handling the response, and <span class="No-Break">managing errors</span></li>
				<li><strong class="bold">Encapsulation</strong>: It encapsulates all the logic related to communicating with a specific external service <span class="No-Break">or API</span></li>
				<li><strong class="bold">Reusability</strong>: Service Agent can be reused by multiple components or services within <span class="No-Break">the application</span></li>
				<li><strong class="bold">Separation of concerns</strong>: It separates the business logic (in the <strong class="source-inline">sync</strong> command) from the communication logic (in <span class="No-Break">Service Agent)</span></li>
				<li><strong class="bold">Maintainability</strong>: Changes to the external API or communication protocol only need to be made in one place (<span class="No-Break">Service Agent)</span></li>
			</ul>
			<p>I believe that it’s clear to you by now that our CLI application can greatly benefit from leveraging the Service Agent pattern. Let’s now see how we can <span class="No-Break">implement it!</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor148"/>Implementing the Service Agent pattern</h2>
			<p>This pattern is often implemented using <strong class="source-inline">IHttpClientFactory</strong> and named or typed <span class="No-Break"><strong class="source-inline">HttpClient</strong></span><span class="No-Break"> instances.</span></p>
			<p>We are already using these<a id="_idIndexMarker295"/> artifacts, so it will be quite straightforward for us to abstract the HTTP details away from the <strong class="source-inline">sync</strong> command and into a dedicated Service <span class="No-Break">Agent class.</span></p>
			<p>The first step we will perform is to create a folder structure for Service Agents. Following the project structure we have laid out in the previous chapter, let’s create a folder named <strong class="source-inline">ServiceAgents</strong> and a subfolder <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">BookmarkrSyncrServiceAgent</strong></span><span class="No-Break">.</span></p>
			<p>Within this subfolder, let’s create two code artifacts: an interface file named <strong class="source-inline">IBookmarkrSyncrServiceAgent.cs</strong>, and a class file <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">BookmarkrSyncrServiceAgent.cs</strong></span><span class="No-Break">.</span></p>
			<p>Here is the code <a id="_idIndexMarker296"/>of the <span class="No-Break"><strong class="source-inline">IBookmarkrSyncrServiceAgent</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
namespace bookmarkr.ServiceAgents;
public interface IBookmarkrSyncrServiceAgent
{
    Task&lt;List&lt;Bookmark&gt;&gt; SyncBookmarks(List&lt;Bookmark&gt; localBookmarks);
}</pre>			<p>This interface only exposes one operation, <strong class="source-inline">SyncBookmarks</strong>, which takes the list of local bookmarks (held by the Bookmarkr CLI application) and returns the synced list of bookmarks that includes the bookmarks from the remote web <span class="No-Break">service, BookmarkrSyncr.</span></p>
			<p>Let’s now implement <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
namespace bookmarkr.ServiceAgents;
public class BookmarkrSyncrServiceAgent : IBookmarkrSyncrServiceAgent
{
    private readonly IHttpClientFactory _clientFactory;
    public BookmarkrSyncrServiceAgent(IHttpClientFactory 
    clientFactory)
    {
        _clientFactory = clientFactory;
    }
    public async Task&lt;List&lt;Bookmark&gt;&gt; Sync(List&lt;Bookmark&gt; localBookmarks)
    {
        var serializedRetrievedBookmarks = JsonSerializer.
        Serialize(localBookmarks);
        var content = new StringContent(serializedRetrievedBookmarks, 
        Encoding.UTF8, "application/json");
        var client = _clientFactory.CreateClient("bookmarkrSyncr");
        var response = await client.PostAsync(«sync», content);
        if (response.IsSuccessStatusCode)
        {
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            var mergedBookmarks = await JsonSerializer.
            DeserializeAsync&lt;List&lt;Bookmark&gt;&gt;(
                await response.Content.ReadAsStreamAsync(),
                options
            );
            return mergedBookmarks!;
        }
        else
        {
            switch(response.StatusCode)
            {
                case HttpStatusCode.NotFound:
                    throw new HttpRequestException($"Resource not 
                    found: {response.StatusCode}");
                case HttpStatusCode.Unauthorized:
                    throw new HttpRequestException($"Unauthorized 
                    access: {response.StatusCode}");
                default:
                    var error = await response.Content.
                    ReadAsStringAsync();
                    throw new HttpRequestException($"Failed to sync 
                    bookmarks: {response.StatusCode} | {error}");
            }
        }
    }
}</pre>			<p>As you may have noticed, this implementation is reusing the code that was located in the body of the <strong class="source-inline">Sync</strong> command’s handler<a id="_idIndexMarker297"/> method, hence abstracting it from this method and encapsulating it into the Service <span class="No-Break">Agent class.</span></p>
			<p>For this reason, the code of this class does not need a lot of explanation. However, it is worth mentioning that in case of an unsuccessful request, we return an instance of <strong class="source-inline">HttpRequestException</strong> with the details about <span class="No-Break">the issue.</span></p>
			<p>Next, we need to update the code <a id="_idIndexMarker298"/>of the <strong class="source-inline">SyncCommand</strong> class to abstract the use of <strong class="source-inline">IHttpClientFactory</strong> and use our new Service Agent instead. The updated code is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class SyncCommand : Command
{
    #region Properties
    private readonly IBookmarkService _service;
    private readonly IBookmarkrSyncrServiceAgent _serviceAgent;
    #endregion
    #region Constructor
    public SyncCommand(IBookmarkrSyncrServiceAgent serviceAgent, 
    IBookmarkService service, string name, string? description = null)
        : base(name, description)
    {
        _service = service;
        _serviceAgent = serviceAgent;
        this.SetHandler(OnSyncCommand);
    }
    #endregion
    #region Options
    #endregion
    #region Handler method
    private async Task OnSyncCommand()
    {
        var retrievedBookmarks = _service.GetAll();
        try
        {
            var mergedBookmarks = await _serviceAgent.
            Sync(retrievedBookmarks);
            _service.ClearAll();
            _service.Import(mergedBookmarks!);
            Log.Information("Successfully synced bookmarks");
        }
        catch(HttpRequestException ex)
        {
            Log.Error(ex.Message);
        }
    }
    #endregion
}</pre>			<p>This code is quite simple and easy to read. What we did basically was replace the use of <strong class="source-inline">IHttpClientFactory</strong> with the use of <strong class="source-inline">IBookmarkrSyncrServiceAgent</strong> and remove all the code, in the <strong class="source-inline">OnSyncCommand</strong> method, that was dealing with the HTTP communication (which we abstracted away into the Service Agent class) by the call to the <strong class="source-inline">Sync</strong> method of the Service <a id="_idIndexMarker299"/>Agent. Hence, the <strong class="source-inline">OnSyncCommand</strong> method is also leaner, shrinking from 41 lines of code down <span class="No-Break">to 16.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For your reference, we provide a copy of the <strong class="source-inline">SyncCommand</strong> class as it was before introducing the use of the Service Agent class. By doing so, you can easily compare the differences between the two implementations. Look for the file named <strong class="source-inline">SyncCommand_NoServiceAgent.txt</strong> in the <span class="No-Break"><strong class="source-inline">Commands/Sync</strong></span><span class="No-Break"> folder.</span></p>
			<p>The final step is to register the Service Agent into the list of services in the <strong class="source-inline">ConfigureServices</strong> section of the <span class="No-Break"><strong class="source-inline">Program</strong></span><span class="No-Break"> class.</span></p>
			<p>As we have seen previously, this can be easily done by adding this line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
services.AddScoped&lt;IBookmarkrSyncrServiceAgent, BookmarkrSyncrServiceAgent&gt;();</pre>			<p>We need not forget to declare a variable for the <span class="No-Break">Service Agent:</span></p>
			<pre class="source-code">
IBookmarkrSyncrServiceAgent _serviceAgent;</pre>			<p>Next, we need to retrieve the instance of that <span class="No-Break">Service Agent:</span></p>
			<pre class="source-code">
_serviceAgent = host.Services.GetRequiredService&lt;IBookmarkrSyncrServiceAgent&gt;();</pre>			<p>We pass it to the constructor of the <span class="No-Break"><strong class="source-inline">SyncCommand</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
rootCommand.AddCommand(new SyncCommand(_serviceAgent, _service, "sync", "sync local and remote bookmark stores"));</pre>			<p>Everything is now in place. Let’s make sure that the application still works <span class="No-Break">as expected.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>Rerunning the program</h2>
			<p>We can run the program the same<a id="_idIndexMarker300"/> way we did before, by typing <span class="No-Break">this command:</span></p>
			<pre class="console">
dotnet run sync</pre>			<p>We will get the exact same result, proving that the application still works as it is <span class="No-Break">supposed to:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B22400_09_02.jpg" alt="Figure 9.2 – The sync command in action using the Service Agent"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The sync command in action using the Service Agent</p>
			<p>Awesome! By leveraging the Service Agent pattern, we have been able to provide a clean separation between the business logic and the details of HTTP communication. Hence, we can consume the BookmarkrSyncr web service in any other command (using the <strong class="source-inline">BookmarkrSyncrServiceAgent</strong> class), without this command having to deal with the HTTP <span class="No-Break">communication details.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor150"/>Summary</h1>
			<p>In this chapter, we learned how to extend the functionalities of Bookmarkr by consuming external APIs <span class="No-Break">and services.</span></p>
			<p>We explored the best practices of communicating with external dependencies, handling response data, codes, and errors, and designing that integration in a way that does not create a heavy coupling between the external dependency and our application, making it easy to replace that dependency over time if this <span class="No-Break">proves necessary.</span></p>
			<p>In the next chapter, we will cover one of the key aspects of building applications, which is testing <span class="No-Break">those applications.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor151"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn <span class="No-Break">through practice.</span></p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the Bookmarkr application by adding the <span class="No-Break">following features.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor152"/>Task #1 – adding SQLite as a data store</h2>
			<p>Who said that APIs are the only external dependencies an application can rely on? Certainly not <span class="No-Break">me! </span><span class="No-Break">😊</span></p>
			<p>Until now, our application has stored its bookmarks in memory. You will certainly agree with me that this is not an ideal solution as bookmarks will be lost as soon as the application terminates <span class="No-Break">or restarts.</span></p>
			<p>You are asked to add a new dependency to the Bookmarkr application – a <strong class="bold">SQLite</strong> database! This will allow bookmarks to be <a id="_idIndexMarker301"/>stored in a more permanent manner by Bookmarkr, making it more useful to our <span class="No-Break">users </span><span class="No-Break">😉</span><span class="No-Break">.</span></p>
			<p>Why SQLite? You <span class="No-Break">may ask…</span></p>
			<p>SQLite is a versatile and lightweight database solution, designed to be both simple and easy to use while requiring minimal setup and administration. One of its most significant advantages is its portability: the entire database is stored in a single file, which makes it easy to move, back up, and distribute. Its self-contained nature also means that SQLite doesn’t require a separate server process or system configuration, simplifying its deployment. That is why it is a great fit for <span class="No-Break">CLI applications!</span></p>
			<p>Now, you will also need to modify the code of <strong class="source-inline">BookmarkService</strong> to retrieve bookmarks from and store bookmarks in the <span class="No-Break">SQLite database.</span></p>
			<p>Consider using the <strong class="source-inline">Microsoft.Data.Sqlite</strong> library for .NET, as it is a reliable and lightweight library. Consider adding migrations and ensuring thread-safe access for SQLite in concurrent <span class="No-Break">CLI scenarios.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Task #2 – retrieving the web page name based on its URL</h2>
			<p>Until now, when adding a new bookmark, we had to pass both the web page name <span class="No-Break">and URL.</span></p>
			<p>Now that we know how to work with external dependencies, let’s tweak the <strong class="source-inline">link add</strong> command so that it makes an HTTP request to retrieve the name of the web page to bookmark based on the provided URL. If the name can’t be retrieved, we can then use the name that was passed as a <span class="No-Break">command option.</span></p>
			<p>If the web page cannot be found, the bookmark’s name should be <strong class="source-inline">Unnamed bookmark</strong>. If the request takes more than 30 seconds, terminate it and also set the name to <span class="No-Break"><strong class="source-inline">Unnamed bookmark</strong></span><span class="No-Break">.</span></p>
		</div>
	

		<div id="_idContainer120" class="Content">
			<h1 id="_idParaDest-151" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor154"/>Part 4: Testing and Deployment</h1>
			<p>In this part, you will explore the critical aspects of testing, packaging, and deploying CLI applications. You'll learn various strategies for testing CLI tools, including unit testing individual components. Next, you'll delve into packaging your CLI application for distribution, using the most commonly used mechanisms such as Docker, .NET Tool, and Winget. You'll understand how to specify entry points, define dependencies, and structure your project for optimal packaging. Finally, you'll explore deployment methods, learning how to distribute your CLI tool through package managers and ensure it works consistently across <span class="No-Break">different environments.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B22400_10.xhtml#_idTextAnchor155"><em class="italic">Chapter 10</em></a><em class="italic">, Testing CLI Applications</em></li>
				<li><a href="B22400_11.xhtml#_idTextAnchor185"><em class="italic">Chapter 11</em></a><em class="italic">, Packaging and Deployment</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer121">
			</div>
		</div>
		<div>
			<div id="_idContainer122">
			</div>
		</div>
		<div>
			<div id="_idContainer123">
			</div>
		</div>
		<div>
			<div id="_idContainer124">
			</div>
		</div>
		<div>
			<div id="_idContainer125">
			</div>
		</div>
		<div>
			<div id="_idContainer126" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer127" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer128">
			</div>
		</div>
		<div>
			<div id="_idContainer129">
			</div>
		</div>
		<div>
			<div id="_idContainer130" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>