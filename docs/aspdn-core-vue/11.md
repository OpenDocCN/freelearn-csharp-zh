# 十一、Todo 应用中的 Vue.js 基础

本章主要介绍 Vue.js、Node.js npm 和 Vue CLI。 这些工具帮助开发人员根据用户的选项为 Vue.js 项目提供不同的配置。 本章还描述了 Vue 组件的特性以及使用它们可以做什么。 不仅如此，您还将了解前端 web 框架的实际结构。 我们会使用 TypeScript 来完成我刚才在 Todo 应用中提到的所有事情。

在本章中，我们将涵盖以下主题:

*   使用 Vue CLI 启动项目
*   Vue CLI 生成的文件和文件夹
*   从一个 Vue 组件开始
*   Vue 组件中的常见特性

# 技术要求

以下是你完成本章所需要的东西:

*   **Visual Studio Code**:[https://code.visualstudio.com/](https://code.visualstudio.com/)
*   **npm**:Node Package Manager from[https://nodejs.org/en/](https://nodejs.org/en/)
*   **Vue CLI**:[https://cli.vuejs.org/](https://cli.vuejs.org/)

本章已完成的知识库可以在以下链接中找到:[https://github.com/PacktPublishing/ASP.NET-Core-and-Vue.js/tree/master/Chapter11/vue3-typescript-todo](https://github.com/PacktPublishing/ASP.NET-Core-and-Vue.js/tree/master/Chapter11/vue3-typescript-todo)

# 使用 Vue CLI 启动项目

**Vue CLI**是标准的开发工具，用于启动 Vue.js 项目。 CLI 允许你在一个项目中添加不同的支持，比如对 Babel、ESLint、TypeScript、Progressive Web Apps(**PWAs**)、PostCSS、单元测试和端到端测试的支持。

确保你有我们在[*第二章*](02.html#_idTextAnchor027)，*设置开发环境*中安装的 npm。 如果你有忘记安装 npm,你可以去[https://nodejs.org/en/【显示】和](https://nodejs.org/en/)安装最新的**长期支持**(【病人】LTS)版本的 node . js。

如果你不能在[*第二章*](02.html#_idTextAnchor027)，*设置开发环境*中安装 vae .js CLI，你现在可以运行以下命令:

```
npm install -g @vue/cli
```

该命令用于全局安装 Vue CLI。 `npm`命令的最后一部分是包名，而`-g`在全局上表示*。*

 *安装 Vue CLI 后，让我们创建我们的第一个 Vue.js 应用，并构建一个简单的 Todo 应用来尝试 Vue 组件的常见功能:

1.  Run the following command to create the directory of your Vue.js app:

    ```
    vue create todo-app
    ```

    `vue create`命令还将触发 Vue CLI，打开 Vue 应用的一系列配置。

2.  You should see the first list of options requesting the preset of the app, as per the following screenshot:

    ![Figure 11.1 – Vue CLI configuration options ](image/Figure_11.1_B15970.jpg)

    图 11.1 - Vue CLI 配置选项

    选择`Manually select features`并按*进入*查看要配置的各种选项。

3.  The `Choose Vue version`, `Babel`, and `Linter / Formatter` options are enabled by the Vue CLI. Let's also turn on `TypeScript` by pointing the cursor to `TypeScript`, as shown, and then press the *spacebar*:

    ![Figure 11.2 – Adding TypeScript to the Vue.js CLI configuration ](image/Figure_11.2_B15970.jpg)

    图 11.2 -在 Vue.js 的 CLI 配置中添加 TypeScript

    按*进入*将`TypeScript`支持添加到我们正在创建的 Vue.js 项目中。

4.  Let's use version 3 of Vue.js in the project by selecting the `3.x (Preview)` option, as shown in the following screenshot:

    ![Figure 11.3 – Choosing Vue.js 3 ](image/Figure_11.3_B15970.jpg)

    图 11.3 -选择 Vue.js

    2 .按*进入*选择 Vue.js。

5.  下一个问题是我们是否愿意使用`class-style component syntax`。 按*进入*拒绝。 在这个问题中默认选择的值是`No`，所以按*Enter*会对这个配置回答 no。 我们将不使用`class-style component syntax`。
6.  另一个问题是我们是否愿意使用`Babel alongside TypeScript`。 按*输入*接受。 Babel 是一个编译器，它将帮助你的 Vue.js 应用自动检测腻子，使 Vue.js 应用与大多数浏览器兼容。
7.  As regards `linter / formatter` while we are writing our code, let's choose `ESLint`, a static code analysis tool, plus `Prettier`, an opinionated code formatter, as shown in the following screenshot:

    ![Figure 11.4 – Formatter configuration in the Vue CLI ](image/Figure_11.4_B15970.jpg)

    图 11.4 - Vue CLI 中的 Formatter 配置

    使用方向键指向`ESLint + Prettier`配置后，按*进入*。

8.  对于下一个选项，也就是附加的 lint 特性，选择`Lint on save`。
9.  然后，选择专用的配置文件，用于优先放置 Babel、ESLint 等的配置。
10.  最后，暂时不要接受`saving the preset for future projects`。

Vue CLI 将开始创建我们的项目，用 Git 初始化项目，安装 CLI 插件，并添加 JavaScript 包。

现在，启动 VS Code 文本编辑器并安装扩展，即**Prettier - Code 格式化器**、**Vetur**和**vcode -icons**，如下截图所示:

![Figure 11.5 – VS Code extensions ](image/Figure_11.5_B15970.jpg)

图 11.5 - VS Code 扩展

Vetur 是 Vue 语言服务器，而 vcode -icons 的设计目的是将图标带到 VS code 文本编辑器的文件和文件夹中。

现在你可以使用 Visual Studio Code 打开项目，查看 Vue CLI 为你生成的文件和文件夹:

![Figure 11.6 – Files and folders generated by the Vue CLI ](image/Figure_11.6_B15970.jpg)

图 11.6 - Vue CLI 生成的文件和文件夹

前面的屏幕截图显示了 Vue CLI 生成的文件和文件夹，我们将在下一节讨论这些内容。

# Vue CLI 生成的文件和文件夹

Vue CLI 已经生成了开始 Vue.js 开发所需的文件和文件夹。 让我们依次来看看这些:

*   `node_modules folder`:该文件夹包含从 npm 下载的库。
*   `public folder`:此文件夹包含 HTML 文件和图标。 在公共文件夹中只会看到一个 HTML 文件，因此被称为“单页应用”。
*   `src folder`:这个文件夹是我们编写业务逻辑、创建 Vue 文件组件以及 JavaScript 或 TypeScript 文件的目录。
*   `.browserlistrc`:该文件是描述应用目标浏览器的工具。
*   `.eslintrc.js`:这个文件是 ESLint 的一个配置工具。
*   `.gitignore`:该文件用于 Git 中不提交目录或文件。 必须忽略的目录的一个很好的例子是`node_modules`。 `node_modules`的文件大小很大，但是可以通过在根项目目录中运行`npm install`在项目中检索。
*   `babel.config.js`:该文件用于 Babel (JavaScript 编译器)的项目范围配置。 Babel 将较老的 JavaScript 版本(ES6+)转换为较低的 JavaScript 版本(ES5 及以下)，以便较老的浏览器能够理解。
*   `package-lock.json`:该文件将项目的依赖关系锁定到特定版本的包。
*   `package.json`: This file holds the information of our project's dependencies and scripts, which we can use to run in the terminal.

    我希望大家记住`package.json`的三个要素:

    `scripts`:`scripts`属性可以在其中声明一些自定义 CLI 命令。 Vue.js CLI 在我们的项目中有三个默认的`npm`脚本，即通过`vue-cli-service serve`命令运行 Vue 项目的服务器，用于构建用于部署的 Vue 项目的构建，以及用于运行 Vue 项目的检查器的 lint。 这里的思想是，我们只需在脚本的块中创建一个键和值对，就可以将长命令转换为短命令。

    `dependencies`:`dependencies`属性只是我们的应用运行所需的关键包列表。 我们通过`npm install`命令安装的任何库都将在依赖项中列出。

    `devDependencies`:`devDependencies`属性是一个帮助开发者编写应用的包列表。 我们可以通过添加`-D`标志来明确地告诉 npm 一个库必须包含在`devDependencies`中。 例如，`npm install -D``prettier`命令将把更漂亮的包添加到`devDepenencies`中。 此外，当你为应用运行`npm build`命令时，`devDependencies`不会被编译或包含。

*   `tsconfig`:该文件允许我们声明编译项目时所需的编译器选项。 它还表明该项目是一个 TypeScript 项目。

现在，我们对 Vue CLI 为我们构建的生成的文件和文件夹有了基本的了解。 让我们在 VS Code 的终端中运行下面的命令来运行应用来测试它是否会出现在浏览器中:

```
npm run serve
```

点击浏览器中的`localhost:8080`查看 Vue.js 应用的运行情况，如下图所示:

![Figure 11.7 – Starting UI ](image/Figure_11.7_B15970.jpg)

图 11.7 -启动 UI

启动 Vue.js 应用后，您将在浏览器上看到带有 Vue.js 徽标的欢迎消息。 默认 UI 有一些关于 Vue.js 中特性文档的外部链接。

在看到我们的 Vue.js 应用在浏览器中运行后，我们现在可以在下一节中讨论 Vue 组件及其组件。

# 开始使用 Vue 组件

Vue 组件是 Vue.js 应用的主要构建块。 组件由`template`语法、`script`和`style`组成。

让我们来看看在我们的应用的`root`组件`App.vue`中生成的代码:

```
<template>
  <img alt="Vue logo" src="./assets/logo.png" />
  <HelloWorld msg="Welcome to Your Vue.js + TypeScript App" />
</template>
<script lang="ts">
import { defineComponent } from "vue";
import HelloWorld from "./components/HelloWorld.vue";
export default defineComponent({
  name: "App",
  components: {
    HelloWorld
  }
});
</script>
<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```

下面是一些关于 Vue.js 组件部分的简单明了的解释:

语法部分是我们将应用的状态绑定到我们选择的 HTML DOM 的地方。 您还可以看到在模板中正在使用`HelloWorld`组件。 我们还将在本章的后半部分创建一些 Vue 组件。

在`script`部分，我们可以编写 JavaScript/TypeScript 代码，在应用中开发一些业务逻辑，导入文件或包，并定义应用的状态。 状态**是一个对象，我们可以在其中存储属性值并在 UI 上呈现它们。**

 **您可以在脚本块中看到`HelloWorld`被导入并注册到 components 属性中，以允许`App.vue`组件在`template`部分呈现`HelloWorld`。

在`style`部分中，我们定义了要创建的组件的样式。 您可以在这里使用 CSS 预处理程序，如 SASS、LESS、Stylus 和 PostCSS，但这些都需要加载器插件才能工作。

现在，从模板和脚本部分删除`HelloWorld`组件，然后从组件目录中删除它。 在从应用中删除`HelloWorld`组件后，您应该只能在浏览器中看到 Vue.js 徽标。

让我们在下一节中编写第一个 Vue.js 组件。

## 编写一个 Vue 组件

让我们在组件目录中创建一个 Vue 组件(文件以`.vue`格式结束)，并将其命名为`TodoForm`。 文件名应该像这样-`TodoForm.vue`。 然后编写以下代码:

```
<template>
  <h1>TodoForm Works!</h1>
</template>
```

如果我们只是在 UI 中呈现一条消息，我们不需要包含任何 JavaScript/TypeScript 代码和 CSS 样式。 现在像这样将它导入到`App.vue`文件中:

```
<template>
  <img alt="Vue logo" src="./assets/logo.png" />
  <TodoForm />
</template>
<script lang="ts">
import { defineComponent } from "vue";
import TodoForm from "./components/TodoForm.vue";
export default defineComponent({
  name: "App",
  components: {
    TodoForm,
  },
});
</script>
```

`TodoForm`在中导入的方式与`HelloWorld`在 UI 中导入和呈现的方式相同。 现在点击**Save**按钮，在浏览器中看到结果:

![Figure 11.8 – Vue.js component ](image/Figure_11.8_B15970.jpg)

图 11.8 - Vue.js 组件

我们创建 Vue 组件的实现是一种快速而粗糙的方法，但是我们将在下一节中向它添加一些特性。

# Vue 组件的常见特性

在本节中,我们将使用一些常见的特性在 Vue 组件构建我们的 Todo 应用。有许多指令(自定义的 HTML 属性),事件,和接口,我们可以使用在 Vue.js,但大部分都是很少使用,随着时间的推移你会倾向于忘记。 因此，在这个 Vue.js Todo 应用的快速演示中，我们将只使用 Vue 组件中最常见的事件、指令和 api。

让我们开始吧。

## 在 Vue 组件中写入本地状态

因为我们在这个项目中使用的是 TypeScript，所以我通常要做的第一件事就是编写应用中需要的模型。所以让我们在`src`目录下创建一个文件夹并命名为`models`。 然后，在`models`文件夹(`src`|`models`|`todoModel.ts`)中创建一个 TypeScript 文件，并添加以下代码:

```
export type TodoType = {
  id: string;
  done: boolean;
  content: string;
};
// OR
export interface TodoModel {
  id: string;
  done: boolean;
  content: string;
}
```

状态的形状或模型可以使用类型或接口来编写。 它们都是一样的; 区别在于您不能实现两个或多个接口，而类型允许我们这样做。 我们将在这里使用一个简单的模型，该模型具有`id`、`done`和`content`基本类型属性。

现在我们将需要一些第三方包。 它们是`uuid`用于生成应用的唯一标识符，`@types/uuid`用于生成 UUID 库的`Type`定义。 当我们使用`uuid`库时，我们的 Vue.js TypeScript 项目会给我们提供智能提示，最后是 Bootstrap 5 来样式化我们的组件。

因此，让我们运行以下命令开始安装包:

```
npm i uuid @types/uuid bootstrap@next
```

`i`是 install 的缩写，Bootstrap 的`@next`后缀明确表示我们想要这个库的 alpha 或 beta 版本，因为在撰写本文时 Bootstrap 的稳定版本是 v4。 然而，如果你看到 npm 网站上 Bootstrap 的稳定版本是版本 5，那么在`bootstrap`之后你就不需要`@next`了。

现在让我们在 Vue.js 项目中使用 Bootstrap 包，用下面的代码替换`App.vue`中生成的样式，导入 Bootstrap 的 CSS:

```
<style>
@import "../node_modules/bootstrap/dist/css/bootstrap.css";
</style>
```

在根组件中导入 Bootstrap 后，让我们使用 Bootstrap 包中的容器，Bootstrap 中最基本的布局元素之一。 我们可以在`div`标签中使用它，然后像这样包装 Vue 徽标和`TodoForm`组件:

```
<template>
  <div class="container">
    <img alt="Vue logo" src="./assets/logo.png" />
    <TodoForm />
  </div>
</template>
```

点击**Save**保存更新后的文件，并在浏览器中查看布局的变化。 然后，让我们通过更改 HTML 并向组件添加状态来更新 components 文件夹中的`TodoForm.vue`。

让我们用以下代码编辑`TodoForm`组件中的消息:

```
<template>
  <div class="mb-4">
    <h1>Vue 3</h1>
    <h2>TypeScript Demo {{ version }}</h2>
  </div>
</template>
```

新消息在`TodoForm.vue`现在 Vue 3 打印稿演示,但文本的胡子语法插值,`{{ version }}`,这个词版本里面,不会显示在 UI 中,因为这是一种 UI 和国家之间的数据绑定。

现在让我们为`TodoForm`组件创建一个状态:

```
<script lang="ts">
import { defineComponent, ref } from "vue";
export default defineComponent({
  name: "TodoForm",
  setup() {
    // local state
    const version = ref("v1");
    return { version }; // same as { version:version }
  },
});
</script>
```

我们需要 Vue 库中的`defineComponent`和`ref`。 `defineComponent`组件是不言自明的。 `ref`用于创建和跟踪一个本地状态，该状态用于呈现响应性的任何更改，当状态值发生变化时，该状态将重新呈现 UI。 我们调用`ref`并传递字符串类型的`an initial value v1`，并将其存储在版本变量中。 然后我们需要将它作为一个匿名 JavaScript 对象的属性返回。

保存并在浏览器上查看 Vue 应用。 你应该看到**TypeScript 演示**消息后面跟着**v1**，如下所示:

![Figure 11.9 – Text interpolation data binding using a mustache ](image/Figure_11.9_B15970.jpg)

图 11.9 -使用胡子的文本插值数据绑定

这就是执行数据绑定的简单程度。 现在让我们创建另外两个局部状态，一个具有显式类型，另一个具有隐式类型。

让我们首先导入我们创建的`TodoType`模型:

```
import { TodoType } from "@/models/todoModel";
```

路径中的`@`符号是`tsconfig`提供的一个解析别名，帮助我们轻松地直接访问导出的代码或库，而不需要编写太多的点和斜杠。 你可以检查`tsconfig`文件的属性来查看`baseUrl`的值和路径:

```
   // implicit type safe
    const version = ref("v1");
    const newTodo = ref(""); // ref<string> is too verbose
    // explicit type safe
    const todos = ref<TodoType[]>([]);
```

用上面指出的新状态更新组件的`setup`功能。 状态的`version`和`newTodo`是用隐式类型编写的。 TypeScript 知道你传递的是什么类型，它可以推断出你从`ref`返回的是什么类型。 您可以将鼠标悬停在`version`和`newTodo`上，您将看到它们是字符串类型。

告诉 TypeScript 编译器初始值类型的显式方法是使用`ref`中的泛型。 在前面的代码中可以看到，`todos`是数组的`TodoType`类型。 这是为了可读性而编写状态静态类型的好方法，而不仅仅是为了智能感知。

您会注意到，我们没有显式地为 version 和`newTodo`添加类型，这两种类型都是字符串，因为如果值是原始类型，比如布尔类型、字符串类型和数字类型，那么很容易判断值的类型。

好了，我们已经完成了在`TodoForm`组件中写入状态并渲染它。 现在让我们向`TodoForm`组件添加功能。

## 在 Vue 组件中添加一个功能

在 Vue 组件中编写一个函数非常简单。 第一步涉及在`TodoType`下面导入`uuid`来为模型的 ID 生成一个 UUID:

```
import { v4 as uuidv4 } from "uuid";
```

我们正在导入`v4`并将其重命名为`uuidv4`，以提高可读性。

现在我们可以开始添加一个函数，在其中创建一个新的`Todo`对象:

```
// explicit type safe
    const todos = ref<TodoType[]>([]);
    function addNewTodo(): void {
      if (!newTodo.value) return;
      todos.value.push({
        id: uuidv4(),
        done: false,
        content: newTodo.value,
      });
      console.log("newTodo:", newTodo.value);
      newTodo.value = "";
    }
```

返回`void`的`addNewTodo`函数检查将要连接到输入字段的`newTodo.value`是否为空。 这就是通过访问`value`属性来获得状态值的方法。 然后，如果值不为空，我们将把一个`Todo`对象推到 todos 中。 `Todo`对象将生成一个`id`，`done`设置为`false`，以及一个`content`属性，其值将来自`newTodo`。 该函数还记录了`newTodo`的字符串值，然后将其设置为一个空字符串，以删除用户的输入。

然后，让将`addNewTodo`函数连同`todos`和`newTodo`一起包含在 setup 的返回对象中，如下所示:

```
    return { version, todos, newTodo, addNewTodo };
```

正如您在前面的代码中看到的，返回状态和函数将使它们可以在 Vue 组件的模板部分中使用。

现在把这个 HTML 表单放在`div`标签下面，它包装了 Vue3 的 TypeScript 演示:

```
<form @submit.prevent="addNewTodo">
    <div class="mb-5">
      <label for="newTodo" class="form-label">New Todo
        </label>
      <input
        class="form-control"
        id="newTodo"
        placeholder="what's on your mind?"
        v-model="newTodo"
        name="newTodo"
      />
      <div class="m-2">
        <button type="submit" class="btn btn-primary">Add 
          New Todo</button>
      </div>
    </div>
  </form>
```

`@submit`，其中是一个提交侦听器，在每次点击带有`type="submit"`属性的按钮时调用我们创建的`addNewTodo`函数。 `newTodo`输入被绑定到输入的`v-model`，这是一个指令，用于在输入和模型或状态之间创建双向数据绑定。 其余的细节是基本的 HTML 语法和 Bootstrap 样式。

保存文件并检查浏览器。 你会看到在**TypeScript Demo v1**下面简单地添加了 todo 表单:

![Figure 11.10 – Simple form ](image/Figure_11.10_B15970.jpg)

图 11.10 -简单的表单

表单还没有准备好呈现我们在输入中添加的内容，但是我们可以在控制台中看到它是否工作。 现在打开你的 Chrome DevTools，进入控制台**标签。 将`check all emails`写入输入字段，点击应用的**Add New Todo**按钮，可以看到它正在控制台注册:**

 **![Figure 11.11 – Console log ](image/Figure_11.11_B15970.jpg)

图 11.11 -控制台日志

上面的*图 11.11*显示了**Console**标签和**newTodo: check all email**登录 DevTools。 这是一个快速**概念验证**(**PoC**)，我们可以用它在我们的 Vue 组件中创建函数。

我们刚刚为 Vue 组件中的一个函数做了一个 PoC。 现在让我们在组件中呈现待办事项列表。

## 在 Vue 组件中的数组中循环

现在我们可以为`TodoType`数组添加 UI，这是一个集合，这意味着我们编写一个 todos 循环并在集合或列表中呈现每个项目。 我们可以通过使用`v-for`指令来实现。

在`form`标签下面写下以下内容:

```
<div>
    <ul class="list-group">
      <li class="list-group-item" v-for="todo in todos" 
         :key="todo.id">
        <h3>
          {{ todo.content }}
        </h3>
      </li>
    </ul>
  </div>
```

代码在待办事项中执行一个`for each`循环，并在列表中呈现每个待办事项的`content`属性。 你会注意到另一个 Vue.js 指令`:key="todo.id"`，它的目的是帮助 Vue.js 运行时确定当`todos`状态改变时，列表中的哪个特定对象需要重新渲染。 反过来，DOM 的重新呈现在没有键的情况下性能更高。

`key`指令前的冒号是`v-bind`指令的简写，它用于一个或多个数据绑定属性。 `key`指令(`key=" "`)需要一个字符串值或数字值才能工作。 在 key 指令中传递什么东西的一个很好的例子就是 ID。 然而，key 指令不一定是 ID，重要的是它必须是唯一的。

在字段中输入`check all emails`，然后按*输入*，再次尝试该表单。 添加后，用户界面会看到**检查所有邮件**，如下截图所示:

![Figure 11.12 – Rendering a list of todos ](image/Figure_11.12_B15970.jpg)

图 11.12 -呈现待办事项列表

现在我们可以在控制台日志中呈现我们的待办事项，在浏览器的屏幕上呈现。

如果我们想在`todos`状态为空的情况下渲染某些内容，该怎么办? 如果我们想要将 todo 标记为 done，并将 todo 的样式从普通更改为带划线的呢? 这就是我们接下来要写的。

## Vue 组件中的 If-else 条件

在本节中，我们有两个目标。 我们的第一个目标是，如果`todos`状态为空，用一个悲伤的表情符号显示一个空列表的消息。 你可以从以下链接获得:[https://emojipedia.org/](https://emojipedia.org/)。

如果`todos`状态不为空，我们可以开始显示待办事项列表并隐藏`Empty list`以一个悲伤的面消息。

将空列表 UI 的代码放在表单标签和待办事项列表之间，如下所示:

```
  </form>
  <div v-if="todos.length === 0">
    <h3>Empty list 🥺</h3>
  </div>
  <div v-else>
    <ul class="list-group">
```

在这段代码中，我们使用`v-if`指令有条件地渲染一个块，而可选的`v-else`指令在条件中作为`else`。

检查浏览器并刷新页面，以查看新的 UI*图 11.13*。 当`todos`状态为空时，你应该看到一个悲伤的表情:

![Figure 11.13 – Empty list with the sad face ](image/Figure_11.13_B15970.jpg)

图 11.13 -带悲伤表情的空列表

当`todos`状态不再为空时，带悲伤表情的空列表立即消失。 简单的对吧?

本节的第二个目标是创建一个功能，其中可以更新`Todo`对象的`done`属性。 我们将通过在 todo 内容上标记一个删除线来让用户知道`done`是否已经变成`true`。 删除线是一种简单的 CSS 样式，我们也将写一些。

让我们开始。 编写一个名为`toggleDone`的新函数，它接受一个`TodoType`对象，如下所示:

```
    function toggleDone(todo: TodoType): void {
      todo.done = !todo.done;
    }
```

`toggleDone`函数在每次调用该函数时将`done`属性更新为其相反的值。

现在让我们创建一个 CSS 类，把它放在一个`style`节中，像这样:

```
<style>
.mark {
  text-decoration: line-through;
}
</style>
```

代码中的样式是一个贯行，将给 todos 内容一个划线，作为标记。

现在用以下新属性更新`h3`标记:

```
  <h3
    :class="{ mark: todo.done }"
    style="cursor: pointer"
    @click="toggleDone(todo)"
  >
```

`:class`是`v-bind:class`的缩写，是一个类指令，它根据`todo.done`的布尔值动态切换类。 如果`todo.done`为`true`，则`mark class`style 被激活;如果`todo.done`为`false`，则`mark class`style 被关闭。 简单而有用的。

你还会注意到这里有`@click`。 `@`符号是`v-on`指令的简写，它监听 DOM 事件以运行或调用 JavaScript 函数。 当您开始在任何 HTML 标记中键入`@`符号时，您可以在编辑器的智能感知中看到所有事件。 你会得到`mousehover`，`blur`，`keyup`等等。

让我们检查一下和`toggleDone`函数。 `toggleDone`函数也被放置，并且我们将传递来自`v-for`循环指令的 todo 对象，您将在`<li>`元素中找到该指令。 现在我们可以测试应用的新功能了。

然后输入`check all emails`和`yoga`。 然后点击**检查所有邮件**，用划线标记，如下图所示:

![Figure 11.14 – Mark what's done with a strike-through ](image/Figure_11.14_B15970.jpg)

图 11.14 -标记划线所做的事情

删除线意味着`todo`对象中的`done`属性被设置为`true`。

让我们创建更多的功能，例如标记列表中的所有项，删除列表中的所有项，或者只删除一个项。

编写一个带有`number`类型的`removeTodo`函数，如下所示:

```
    function removeTodo(index: number): void {
      todos.value.splice(index, 1);
    }
```

我们将从待办事项列表中删除一个特定的`todo`对象。

在组件的`setup`函数的返回对象中包含`removeTodo`:

```
return {
      …,
      removeTodo,
    };
```

`removeTodo`现在可以在 HTML 中使用了。

现在让我们更新一下`template`语法，特别是`li`标签:

```
<ul class="list-group">
 <li 
   class="list-group-item d-flex flex-row justify-content-
     between align-items-center"
   v-for="(todo, index) in todos"
   :key="todo.id">
   <h3
```

我们正在更新`li`标签的类和`v-for`。 您将注意到在`v-for`中有第二个参数`index`。 这是我们从循环中得到的 todo 项的索引。 是的，我们可以接触到。

接下来，我们将以下代码添加到`h3`标签:

```
<button
   type="button"
   class="btn btn-warning"
   @click="removeTodo(index)"
  >
    ✔ Done & Remove
</button>
```

我们将索引传递给`removeTodo`函数，并将按钮命名为`Done & Remove`并使用一个检查表情符。

现在我们再写两个函数，命名为`markAllDone`和`removeAllTodos`，如下所示:

```
    function markAllDone(): void {
      todos.value.forEach((todo) => (todo.done = true));
    }
    function removeAllTodos(): void {
      todos.value = [];
    }
```

`markAllDone`将所有已完成的待办事项设置为`true`，而`removeAllTodos`将待办事项设置为空数组，删除列表中的所有项目。

然后，在`return`语句中包括`markAllDone`和`removeAllTodos`，就像这样:

```
    return {
      …,
      markAllDone,
      removeAllTodos,
    };
```

`markAllDone`和`removeAllTodos`现在可以在`TodoForm`组件的`template`语法中使用。

现在，让我们在**add new Todo**按钮下面添加两个新的按钮:

```
<div class="m-2">
    <button 
type="button" class="btn btn-danger" 
@click="removeAllTodos">
      Remove All
    </button>
</div>
<div class="m-2">
    <button 
type="button" 
class="btn btn-success" 
@click="markAllDone">
      Mark All Done
    </button>
</div>
```

这两个新按钮处理`removeAlltodos`和`markAllDone`功能。 运行应用并检查浏览器。 我们会得到以下截图:

![Figure 11.15 – Remove All and Mark All Done ](image/Figure_11.15_B15970.jpg)

图 11.15 -删除所有并标记所有完成

添加另一个 todo 标题`order pizza`，然后单击**标记所有完成**按钮。 您应该看到所有的待办事项都执行了，如图 11.15 中所示。 然后，点击**Remove All**按钮删除所有待办事项。

我相信您会发现 Vue.js 很容易使用，而且添加功能并不难。 现在，让我们在下一节中通过将状态从父组件向下传递到子组件来让它变得更复杂一点。

## 道具的创建和传递

在某些情况下，父组件必须将一个状态或函数传递给它的子组件，以呈现 UI 或创建功能，我们通过道具来实现。 Props 是一个在中也会用到的术语，其他 JavaScript 框架或库，如 Angular、React、苗条和 Ember。

首先，让我们在`TodoForm`组件中定义道具。 从 Vue 导入`PropType`以获得类型安全。 如果你的 Vue 项目使用的是 JavaScript，那么就不需要这个，但是如果你使用的是 TypeScript，那么就会很有用:

```
import { defineComponent, ref, PropType } from "vue";
```

导入`PropType`后，在`defineComponent`上面创建一个模型并命名为`Props`，如下所示:

```
import { v4 as uuidv4 } from "uuid";
type Props = {
  title: string;
  subTitle: string;
};
export default defineComponent({
```

您可以使用类型或接口来创建模型。 现在，让我们定义`TodoForm`的`about props`，并将其放在设置之前，如下所示:

```
  name: "TodoForm",
  props: {
    about: {
      type: Object as PropType<Props>,
      required: true,
    },
  },
  setup() {
```

我们的道具命名为`about`。 `about`是必需的道具，它是`PropType`形状为`Props`的物体。

接下来是用`title`字符串和 subTitle 字符串属性创建一个状态名，如下所示:

```
// Vue 3
  setup() {
    const about = ref({
      title: "Vue 3",
      subTitle: "TypeScript demo",
    });
    return {
      about,
    };
  },
  // Vue 2
  /*
   data:() => ({
     about: {
        title: "Vue 3",
        subTitle: "TypeScript demo"
      }
   })
 */
```

导入`ref`并使用它来创建一个状态，将其存储在`about`中，然后返回`about`。 您将注意到，我在设置之上放置了一个 Vue 3 标签，在数据函数之上放置了一个 Vue 2 标签。 这是在 Vue.js 中编写组件的两种不同方式，当你开始在互联网上寻找一个示例 Vue 项目时，你会遇到这两种方式。 我想说,90%的在写这篇文章的时候,你会看到什么,直到未来几个月将写在 Vue.js 2 因为 Vue.js 3 刚刚发布 2020 年 9 月,大多数 Vue.js 社区和图书馆作者还没有采用最新 Vue.js 版本。

在通过`App.vue`组件的`about`之前，我们需要更新`TodoForm`的设置。 所以回到`TodoForm.vue`组件，像这样更新设置:

```
  setup(props) {
```

我们可以在设置中使用可选的参数。 第一个参数是`props`，它是将传递给子组件的任何状态和函数的入口点。

让我们将`props`映射到`TodoForm`的`template`语法，替换 Vue 3 TypeScript 演示消息:

```
<template>
  <div class="mb-4">
    <h1>{{ about.title }}</h1>
    <h2>{{ about.subTitle }} {{ version }}</h2>
  </div>
```

其想法是，从现在开始，欢迎消息`TodoForm`将来自其父组件。

现在，让我们更新`App.vue`组件的`template`部分:

```
    <TodoForm :about="about" />
```

这里我们将`App.vue`的`about`状态传递给`TodoForm`的`about`、`:about`和`props`。

你应该看到 UI 仍然在工作，如下面的截图所示:

![Figure 11.16 – TodoForm with about props ](image/Figure_11.16_B15970.jpg)

图 11.16 -带有 about props 的 TodoForm

Vue3TypeScript 演示再次呈现。 如果你没有看到 Vue 3 的 TypeScript 演示，而你想要调试它怎么办? 我们可以在道具中使用一个控制台日志，我们将在下一部分中进行操作。

## Vue 组件中的生命周期挂钩

**生命周期钩子**是在组件生命周期的每个特定点自动调用的函数或方法。 我们可以利用组件生命周期中的关键事件来编写应用中的业务逻辑。

让我们使用最常用的生命周期钩子，它们是 Vue 3 中的`onMounted`或 Vue 2 中的`mounted`。 `onMounted`在 DOM 被挂载时运行或触发:

```
import { defineComponent, ref, PropType, onMounted } from "vue";
```

我们正在从 Vue 进口`onMounted`

然后我们使用`onMounted`，并将其放在`setup`函数的`return`语句之前，如下所示:

```
    onMounted(() => console.log(props.about.title));
    return {
```

我们在这里记录`about`属性的`title`值，当你打开 Chrome DevTools 或 Firefox DevTools 时，你会看到，如下截图所示:

![Figure 11.17 – Console logging props ](image/Figure_11.17_B15970.jpg)

图 11.17 -控制台日志记录道具

您可以从`App.vue`组件的`about the state`传递的`about`道具中看到 Vue3 日志。 `onMounted`是当你在用户界面上自动呈现来自 web 服务的数据时，你将总是使用的。 我们将在下一个应用中对 HTTP 请求进行`onMounted`处理，这个实际的 Vue.js 应用使用 ASP。 净的核心。

就是这样。 您可以使用我们刚刚创建的 Todo 应用来玩。 现在让我们总结一下您在构建这个简单的 Todo 应用时学到的所有内容。

# 总结

我们在这一章做了很多事情。 您已经了解了 Vue CLI 是搭建项目的好工具，可以为开发人员节省大量时间。 您了解了 Vue 组件的各个部分，即模板块(它是 Vue 的 UI 部分)、用于编写业务逻辑的脚本部分和用于样式化组件的样式块。 您还学习了如何创建 Vue 组件以及如何使用 Vue 中的公共接口，例如用于循环的`v-for`、用于写入事件的`v-if`条件和`@`符号。

您还能够学习如何使用`ref`在 Vue 组件中编写状态，以及如何使用冒号前缀或双花括号进行数据绑定。

最后，您了解了什么是道具以及如何在两个 Vue 组件之间传递道具。 您还了解了什么时候在 Vue 组件中使用生命周期钩子来触发函数。

在下一章中，我们将开始开发现实世界中的企业 Vue.js 应用。

# 进一步阅读

我承认我的记忆力很差。 这就是为什么，每当我在软件开发中学习一项新技术时，我都需要备忘单来帮助我记住一项技术的关键方面。 以下链接是 Vue.js 中的备忘单:

*   **Vue Essentials 小抄**:[vuemastery.com/pdf/Vue-Essentials-Cheat-Sheet.pdf](http://vuemastery.com/pdf/Vue-Essentials-Cheat-Sheet.pdf)
*   **Vue.js 备忘单**:[devhints。 io/vue](http://devhints.io/vue)*****