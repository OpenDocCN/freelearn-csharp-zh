- en: Chapter 4. Continuing the Space Shooter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter continues from the previous one in creating a twin-stick space
    shooter game. At this stage, we have a working game. At least, the gamer can control
    a spaceship using two axes: movement and rotation. WASD keys on the keyboard control
    movement (up, down, left, and right) and the mouse cursor controls rotation—the
    spaceship always rotates to face the cursor. In addition to player controls, the
    level features enemy characters that spawn at regular intervals, fly around the
    level, and move toward the player with hostile intent. Finally, both the player
    and enemies support a Health component, which means both are susceptible to damage
    and can be destroyed. Right now, however, the player lacks two important features:
    it cannot fire a weapon and it cannot increase the score. This chapter tackles
    these issues and more. Firing weapons, as we''ll see, represents a particularly
    interesting problem. Overall, this chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Weapons and spawning ammo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management and pooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound and audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The completed project so far can be found in the book's companion files in the
    `Chapter04/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  prefs: []
  type: TYPE_NORMAL
- en: Guns and gun turrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start tackling weapons in detail. Specifically, the level contains a player
    and enemy ships. The player must shoot enemies but, right now, cannot do so. See
    *Figure 4.1*. On thinking carefully about weapons, we identify three main concepts
    or things that need development. First, there's the spawner or generator—the object
    that actually fires ammo in the scene when the fire button is pressed. Second,
    there's the ammo itself that, once generated, travels through the level on its
    own. Third, there's the ability for ammo to collide with other objects and damage
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Guns and gun turrets](img/B05118_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The game so far'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tackling each area in order, we begin with turrets—the points where bullets
    are spawned and fired. For this game, the player will have only one turret, but
    ideally, the game should support the addition of more, if desired, allowing the
    player to dual-fire or more! To create the first turret, add a new empty game
    object to the scene by selecting **GameObject** | **Create Empty** from the application
    menu. Name this `Turret`. Then, position the `Turret` object to the front of the
    spaceship, making sure that the blue forward vector arrow is pointing ahead in
    the direction that ammo will be fired. Finally, make the turret a child of the
    spaceship by dragging and dropping it in the **Hierarchy** panel. See *Figure
    4.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Guns and gun turrets](img/B05118_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2:Positioning a Turret object as a child of the spaceship
  prefs: []
  type: TYPE_NORMAL
- en: Creating a `Turret` object for the ammo as a spawn location is a splendid beginning,
    but for ammo to actually be fired, we'll need an ammo object. Specifically, we'll
    create an `Ammo` prefab that can be instantiated as ammo, when needed. We'll do
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Ammo prefabs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the player presses the fire button, the spaceship should shoot ammo objects
    in the scene. These objects will be based on an `Ammo` prefab. Let's create this
    prefab now. To start, we'll configure the texture to be used as an ammo graphic.
    Open the `Textures` folder in the **Project** panel, and select the `Ammo` texture.
    This texture features several different versions of an ammo sprite, aligned in
    a row side by side. See *Figure 4.3*. When ammo is fired, we don't want to show
    the complete texture; instead, we want to show either just one of the images or
    the images played as an animation sequence, frame by frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Preparing to create an Ammo prefab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Presently, Unity recognizes the texture (and each ammo element) as a complete
    unit. We can use Sprite Editor, however, to separate each part. To do this, select
    the **Texture** in the project (if it''s not already selected), and then (from
    the **Object Inspector**) change the **Sprite Mode** drop-down from **Single**
    to **Multiple**. This signifies that more than one sprite is contained within
    the texture space. See *Figure 4.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Select multiple sprites for textures featuring more than one sprite'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Apply** button, and then click on the **Sprite Editor** button
    from the **Object Inspector**. This opens the Sprite Editor, allowing you to separate
    each sprite. To do this, click and drag your mouse to select each sprite, making
    sure that the **Pivot** is aligned to the object **Center**. See *Figure 4.5*.
    Then, click on **Apply** to accept the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Separating multiple sprites in the Sprite Editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'After accepting the changes in the Sprite Editor, Unity automatically cuts
    the relevant sprites into separate units, each of which can now be selected as
    a separate object in the **Project** panel. Click on the right arrow at the side
    of the texture, and all sprites within will expand outwards. See *Figure 4.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Expand all sprites within a texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag and drop one of the sprites from the **Project** panel to the **Scene**
    via the **Hierarchy** panel. On doing this, it will be added as a sprite object.
    This represents the beginning of our `Ammo` prefab. The sprite itself may not
    initially be oriented to face upward at the game camera. If so, rotate the sprite
    by **90** degrees until it looks correct. See *Figure 4.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Aligning the ammo sprite'
  prefs: []
  type: TYPE_NORMAL
- en: Now create a new, empty game object in the scene (**GameObject** | **Create
    Empty** from the application menu) and rename it `Ammo`. Make this new object
    a parent of `Ammo_Sprite` and ensure that its local forward vector is pointing
    in the direction that the ammo should travel. We'll soon reuse the `Mover` script
    (created in the previous chapter) on the ammo to make it move.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Building an ammo object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag and drop the `Mover.cs` script from the **Project** panel to the `Ammo`
    parent object via the **Hierarchy** panel in order to add it as a component. Then,
    select the `Ammo` object and, from the **Object Inspector**, change the ammo''s
    **Max Speed** in the **Mover** component to `7`. Finally, add a **Box Collider**
    to the object to approximate its volume (**Component** | **Physics** | **Box Collider**
    from the application menu), and then test this all in the viewport by pressing
    play on the toolbar. The `Ammo` object should shoot forward as though fired from
    a weapon. If it moves up or down incorrectly, then make sure that the parent object
    is rotated so that its blue forward vector really is pointing forward. See *Figure
    4.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Moving forward with an Ammo prefab (Mover and Collider)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a **Rigidbody** component to the ammo to make it part of the Unity
    physics system. To do this, select the `Ammo` object and navigate to **Component**
    | **Physics** | **Rigidbody** from the application menu. Then, from the **Rigidbody**
    component in the **Inspector**, disable the **Use Gravity** checkbox to prevent
    the ammo from falling to the ground during gameplay. For our purposes, gravity
    need not apply to the ammo as it should simply travel along and eventually be
    destroyed. This highlights an important point in game development generally: real-world
    physics need not apply to every object accurately. We only need enough physics
    to make objects appear correct to the player when they''re looking. See *Figure
    4.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ammo prefabs](img/B05118_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Removing gravity from the Ammo object'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to adding a `Mover` script and physics components, we also need
    the ammo to behave distinctly. Specifically, it should damage the objects with
    which it collides, and it should also destroy or disable itself on collision.
    To achieve this, a new script file must be created, `Ammo.cs`. The entire code
    for this is included in *Code Sample 4.1* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 4-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Ammo` class should be attached to the `Ammo` prefab object and will be
    instantiated for all ammo objects created. Its main purpose is to damage any objects
    with which it collides.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OnTriggerEnter` function is invoked for the ammo when it enters a trigger
    attached to a movable unit, such as the player or enemies. Specifically, it retrieves
    the `Health` component attached to the object, if it has one, and reduces its
    health by the `Damage` amount. The `Health` component was created in the previous
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that each ammo object will have a Lifetime. This represents the amount
    of time in seconds for which the ammo should remain alive and active after it
    is fired and generated in the scene. After the lifetime expires, the ammo should
    either be destroyed entirely or deactivated (more on this shortly).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Invoke` function is used to deactivate the ammo object after the `LifeTime`
    interval. This happens during the `OnEnable` event. This is called automatically
    by Unity each time an object is activated (that is, changed from being disabled
    to enabled).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, drag and drop the `Ammo` script file from the `Scripts` folder in the
    **Project** panel to the `Ammo` object, and then finally, drag and drop the whole
    `Ammo` object in the **Scene** back to the **Project** panel in the `Prefabs`
    folder in order to create a new `Ammo` prefab. See *Figure 4.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4-1](img/B05118_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Creating an Ammo prefab'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You've now created an `Ammo` prefab, which can be spawned from
    weapon points to attack enemies directly. This is good, but we've still not handled
    the spawning process itself and we'll address this next.
  prefs: []
  type: TYPE_NORMAL
- en: Ammo spawning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Ammo` prefab created so far presents us with a technical problem that,
    if not taken seriously, has the potential to cause some serious performance penalties
    for our game. Specifically, when the spaceship weapon is fired, we'll need to
    generate ammo that launches into the scene and destroys the enemies on collision.
    This is fine in general, but the problem is that the player could potentially
    press the fire button many times in quick succession and could even hold down
    the fire button for long periods of time, and thereby spawn potentially hundreds
    of ammo prefabs. We could, of course, use the `Instantiate` function seen already
    to generate these prefabs dynamically, but this is problematic because instantiate
    is computationally expensive. When used to generate many items in succession,
    it will typically cause a nightmarish slowdown that'll reduce the FPS to unacceptable
    levels. We need to avoid this!
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is known as **Pooling**, **Object Pooling**, or **Object Caching**.
    In essence, it means that we must spawn a large and recyclable batch of ammo objects
    at the level startup (a pool of objects) that initially, begin hidden or deactivated,
    and we simply activate the objects as and when needed (when the player fires a
    weapon). When the ammo collides with an enemy or when its lifetime expires, we
    don''t destroy the object entirely, we simply deactivate it again, returning it
    to the pool for reuse later if needed. In this way, we avoid all calls to `Instantiate`
    and simply recycle all ammo objects that we have. To get started with coding this
    functionality, we''ll make an `AmmoManager` class. This class will be responsible
    for two features: first, generating a pool of ammo objects at scene startup, and
    second, giving us a valid and available ammo object from the pool on demand, such
    as on weapon-fire. Consider the following `AmmoManager` *Code Sample 4.2* to achieve
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 4.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AmmoManager` features an `AmmoArray` member variable, which holds a complete
    list (sequential array of references) of all ammo objects to be generated at startup
    (during the `Awake` event).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmmoArray` will be sized to `PoolSize`. This refers to the total number of
    ammo objects to be generated. The `Awake` function generates the ammo objects
    at the beginning of the level, and these are added to the queue with `Enqueue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once generated, each ammo object is deactivated with `SetActive(false)` and
    is held in the pool until needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmmoManager` uses the `Queue` class from the `Mono` library to manage how
    specific ammo objects are selected from the pool to be activated when fire is
    pressed. The queue works as a **First-In-First-Out** (**FIFO**) object. That is,
    ammo objects are added to the queue one at a time and can be removed when selected
    to be activated. The object removed from the queue is always the object at the
    front. More information on the `Queue` class can be found online at [https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx](https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Enqueue` function of the `Queue` object is called during `Awake` to add
    objects initially to the queue, one by one, as they are generated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SpawnAmmo` function should be called to generate a new item of ammo in
    the scene. This function does not rely on the `Instantiate` function but uses
    the `Queue` object instead. It removes the first ammo object from the queue, activates
    it, and then adds it to the end of the queue again behind all the other ammo objects.
    In this way, a cycle of generation and regeneration happens, allowing all ammo
    objects to be recycled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmmoManager` is coded as a singleton object, meaning that one, and only one,
    instance of the object should exist in the scene at any one time. This functionality
    is achieved through the static member, `AmmoManagerSingleton`. For more information
    on singleton objects, refer to *Mastering Unity Scripting* by *Packt Publishing*
    at [https://www.packtpub.com/game-development/mastering-unity-5x-scripting](https://www.packtpub.com/game-development/mastering-unity-5x-scripting).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use this class, create a new `GameObject` in the scene called `AmmoManager`
    by selecting **GameObject** | **Create Empty** from the application menu. Then,
    drag and drop the `AmmoManager` script from the **Project** panel to select the
    object in the scene. Once created, drag and drop the `Ammo` prefab from the `Prefabs`
    folder to the **Ammo Prefab** slot for the **Ammo Manager** component in the **Object
    Inspector**. See *Figure 4.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.2](img/B05118_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Adding the Ammo Manager to an object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the scene features an `AmmoManager` object to hold an ammo pool, offscreen
    and hidden. However, still nothing about our existing functionality actually connects
    a fire button press from the gamer with the generation of ammo in the scene. That
    is, we have no code to actually make the ammo visible and working! This connection
    should now be made via the `PlayerController` script that we started in the previous
    chapter. This class should now be amended to handle ammo generation. The recoded
    `PlayerController` class is included in the following *Code Sample 4.3*. The amendments
    are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 4.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerController` now features a `TurretTransform` array variable, listing
    all child empties being used as turret spawn locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During the `Update` function, `PlayerController` checks for fire button presses.
    If detected, the code cycles through all turrets and spawns one ammo object at
    each turret location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once ammo is fired, `ReloadDelay` is engaged (set to `true`). This means that
    the delay must first expire before new ammo can be fired again later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After adding this code to `PlayerController`, select the `Player` object in
    the scene and then drag and drop the `Turret` empty object on to the `TurretTransform`
    slot. This example uses only one turret, but you could add more if desired. See
    *Figure 4.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Configuring TurretTransform for spawning ammo'
  prefs: []
  type: TYPE_NORMAL
- en: Now you're ready to play test and fire ammo. By playing the scene and pressing
    fire on the keyboard or mouse (left-click), ammo will be generated. Excellent!
    However, on testing this, you may notice two main problems. First, the ammo appears
    too big or too small. Second, the ammo sometimes bounces, flips, or reacts to
    the player spaceship. Let's fix these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ammo appears wrongly-sized, you can simply change the scale of the prefab.
    Select the `Ammo` prefab in the **Project** panel, and from the **Object Inspector**,
    enter a new scale in the **Transform** component. See *Figure 4.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Changing the Ammo prefab scale'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the ammo appears to bounce or react to the player spaceship, then we''ll
    need to make the ammo immune or unresponsive to the player. To achieve this, we
    can use physics layers. In short, both the player spaceship and ammo should be
    added to a single layer, and all objects on this layer should be defined as immune
    to each other in terms of physical reactions. First, select the `Player` object
    in the scene. Then, from the **Object Inspector**, click on the **Layer** drop-down,
    and choose **Add Layer** from the context menu. See *Figure 4.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Creating a new layer for Physics exclusions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the layer `Player`. This is to indicate that all objects attached to the
    layer are associated with the `Player`. See *Figure 4.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Creating layers'
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign both the `Player` object in the scene and `Ammo` prefab in the **Project**
    panel to the newly created **Player** layer. Select each, and simply click on
    the **Layer** drop-down, selecting the **Player** option. See *Figure 4.17*. If
    prompted with a pop-up dialog, choose to change children also. This makes sure
    that all child objects are also associated with the same **Layer** as the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Assigning Player and Ammo to the Player layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both **Player** and **Ammo** have now been assigned to the same layer. From
    here, we can make all objects in the same layer immune from each other insofar
    as **Physics** applies. To do this, navigate to **Edit** | **Project Settings**
    | **Physics** from the application menu. See *Figure 4.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Accessing Physics options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The global **Physics** settings appear in the **Object Inspector**. At the
    bottom of the **Inspector**, the **Layer** **Collision Matrix** displays how layers
    affect each other. Intersecting layers with a check mark can and will affect each
    other. For this reason, remove the check mark for the **Player** layer to prevent
    collisions occurring between objects on this layer. See *Figure 4.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: Setting the Layer Collision Matrix for improved collisions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Layer Collision Matrix** set from the **Object Inspector**, test
    run the game so far by pressing play on the toolbar. When you do this and press
    fire, ammo will issue from the turrets and no longer react to the player spaceship.
    The ammo should, however, collide with, and destroy, the enemies. See *Figure
    4.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.3](img/B05118_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: Destroying enemies by shooting guns!'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent work! We now have a spaceship that can fire weapons and destroy enemies,
    and the physics works as expected. Maybe you'd like to customize player controls
    a little or perhaps you want to use a gamepad. The next section will explore this
    issue further.
  prefs: []
  type: TYPE_NORMAL
- en: User controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maybe you don''t like the default controls and key combinations associated
    with the input axes—**Horizontal**, **Vertical**, and **Fire1**. Maybe you want
    to change them. These input axes are read using the `Input.GetAxis` function (shown
    earlier) and are specified by human readable names, but it''s not immediately
    clear how Unity maps specific input buttons and devices to these virtual axes.
    Here, we''ll see briefly how to customize these. To get started, let''s access
    the **Input** settings by navigating to **Edit** | **Project Settings** | **Input**
    from the application menu. See *Figure 4.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User controls](img/B05118_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Accessing the Input menu'
  prefs: []
  type: TYPE_NORMAL
- en: On selecting this option, a collection of custom-defined input axes appear as
    a list in the **Object Inspector**. See *Figure 4.22*. This defines all axes used
    by the input system. The **Horizontal** and **Vertical** axes should be listed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '![User controls](img/B05118_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Exploring the input axes'
  prefs: []
  type: TYPE_NORMAL
- en: 'By expanding each axis in the **Object Inspector**, you can easily customize
    how user input is mapped, that is, how specific keys and controls on hardware
    devices, such as a keyboard and mouse, will map to an axis. The **Horizontal**
    axis, for example, is defined twice. For the first definition, **Horizontal**
    is mapped to the `left`, `right`, and *A* and *D* keys on the keyboard. Right
    and *D* are mapped as **Positive Button** because, when pressed, they produce
    positive floating-point values from the `Input.GetAxis` function (0-1). Left and
    *A* are mapped as **Negative Button** because, when pressed, they result in negative
    floating-points values for `Input.GetAxis`. This makes it easy to move objects
    left and right using negative and positive numbers. See *Figure 4.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User controls](img/B05118_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Configuring an Input axis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that **Horizontal** is defined twice in the **Object Inspector**—once
    near the top of the list and once near the bottom. These two definitions are accumulative
    and not contradictory—they stack atop one another. They allow you to map multiple
    devices to the same axis, giving you cross-platform and multidevice control over
    your games. By default, **Horizontal** is mapped in the first definition to the
    `left`, `right`, *A*, and *D* keys on the keyboard, and in the second definition,
    to joystick motion. Both definitions are valid and work together. You can have
    as many definitions for the same axis as you need, depending on the controls you
    need to support. See *Figure 4.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User controls](img/B05118_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: Defining two horizontal axes'
  prefs: []
  type: TYPE_NORMAL
- en: For this project, the controls will remain at their defaults, but go ahead and
    change or add additional controls if you want to support different configurations.
    More information on player input and customizing controls can be found in the
    online Unity documentation at [http://docs.unity3d.com/Manual/class-InputManager.html](http://docs.unity3d.com/Manual/class-InputManager.html).
  prefs: []
  type: TYPE_NORMAL
- en: Scores and scoring – UI and text objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to the scoring system and, in creating this, we'll create `GameController`.
    `GameController` is simply a script or class that manages all game-wide and overarching
    behavior. This includes the score because, for this game, the score refers to
    one single and global number representing the achievements and progress of the
    player. Before jumping into the implementation, start by creating a simple GUI
    to display the game score. GUI is an acronym for Graphic User Interface, and this
    refers to all the 2D graphical elements that sit atop the game window and provide
    information to the player. To create this, create a new GUI canvas object by selecting
    **GameObject** | **UI** | **Canvas** from the application menu. See *Figure 4.25*.
    More details on GUIs can be found in the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: Adding a Canvas object to the scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Canvas` object defines the total surface or area in which the GUI lives,
    including all buttons, text, and other widgets. On being generated in the scene,
    `Canvas` also features in the **Hierarchy** panel. Initially, the `Canvas` object
    may be too large or too small to be seen clearly in the viewport, so select the
    `Canvas` object in the **Hierarchy** panel and press the *F* key on the keyboard
    to focus the object. It should appear as a large vertically-aligned rectangle.
    See *Figure 4.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.26: Examining the Canvas object in the viewport'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Canvas` object is not visible itself in the **Game** tab. Rather, it acts
    simply as a container. Even so, it strongly influences how contained objects appear
    on the screen in terms of size, position, and scale. For this reason, before adding
    objects and refining the design of an interface, it''s helpful to configure your
    `Canvas` object first. To do this, select the `Canvas` object in the scene, and
    from the **Object Inspector**, click on the **UI Scale Mode** drop-down option
    from the **Canvas Scaler** component. From the drop-down list, choose the **Scale
    With Screen Size** option and enter an HD resolution in the **Reference Resolution**
    field, that is, specify `1920` for the **X** field and `1080` for the **Y** field.
    See *Figure 4.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.27: Adjusting the Canvas Scaler component'
  prefs: []
  type: TYPE_NORMAL
- en: 'By adjusting the **Canvas Scaler** to **Scale With Screen Size**, the user
    interface for the game will automatically stretch and shrink (up- and down-scale)
    to fit the target resolution, ensuring that each element is scaled to the same
    proportions, maintaining the overall look and feel. This is a quick and easy method
    to create a UI once and have it adjust size to fit nearly any resolution. It may
    not always be the best solution to maintaining the highest quality graphical fidelity,
    but it''s functional and suitable in many cases. In any case, before proceeding
    with the UI design, it''s helpful to see both the **Scene** viewport and **Game**
    tab side by side in the interface (or across two monitors, if you have a multi-monitor
    configuration). This allows us to build the interface in the **Scene** viewport,
    and then preview its effects in the **Game** tab. You can rearrange the **Scene**
    and **Game** tabs simply by dragging and dropping the **Game** tab beside the
    **Scene** tab in the **Unity Editor**. See *Figure 4.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Docking the Scene and Game tabs side by side'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add the text widget to the GUI to display the game score. To do
    this, select the `Canvas` object in the **Hierarchy** panel, and then right-click
    on that object (in the **Hierarchy** panel) to display a context menu. From here,
    select **UI** | **Text**. This creates a new text object as a child of the `Canvas`
    object as opposed to a top-level object with no parent. See *Figure 4.29*. The
    `Text` object is useful to draw text onscreen with a specific color, size, and
    font setting.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.29: Creating a text object for the UI'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `Text` object may not initially appear visible in either the
    scene or viewport, even though it's listed as an object in the **Hierarchy** panel.
    However, look more closely in the **Scene** and you're likely to see very small
    and dark text, which appears both in the **Canvas** and **Game** tab. See *Figure
    4.30*. By default, new text objects feature black text at a small font size. For
    this project, these settings will need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.30: Newly created text objects can sometimes be difficult to see'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `Text` object in the **Hierarchy** panel, if it''s not already selected,
    and from the **Object Inspector** (in the **Text** component), change the text
    **Color** to white and **Font Size** to `20`. See *Figure 4.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.31: Changing text size and color'
  prefs: []
  type: TYPE_NORMAL
- en: 'The text, however, still appears too small even after changing its size. If
    you increase the size further, however, the text may disappear from view. This
    happens because each `Text` object has a rectangular boundary defining its limits,
    and when the font size increases beyond what can fit in the boundary, the text
    is automatically hidden altogether. To fix this, we''ll increase the text boundary.
    To do this, switch to the **Rect Transform** tool with *T* or select the tool
    from the toolbar. See *Figure 4.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.32: Selecting the Rect Transform tool'
  prefs: []
  type: TYPE_NORMAL
- en: On activating the **Rect Transform** tool, a clearly defined boundary will be
    drawn around the selected `Text` object in the **Scene** viewport, indicating
    its rectangular extents. Let's increase the boundary size to accommodate larger
    text. To do this, simply click and drag on the boundary edges with the mouse to
    extend them as needed. See *Figure 4.33*. This will increase the boundary size
    and now you can increase **Font Size** to improve text readability.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.33: Adjust the text rectangle to support larger font sizes'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting the text boundary size, the text can also be vertically
    aligned to the boundary center. Simply click on the center alignment button for
    the vertical group. For horizontal alignment, the text should remain left-aligned
    to allow for the score display. See *Figure 4.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.34: Aligning text within the boundary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the text is now aligned vertically within its containing boundary,
    we''ll still need to align it as a whole to the canvas container to ensure that
    it remains on screen at the same position and orientation, even if the **Game**
    window is resized and realigned. To do this, we''ll use **Anchors**. To start,
    use the transform tool (*W*) to reposition the `Text` object to the top right
    corner of the screen at the location where the **Score** should appear. The object
    will automatically move within a 2D plane as opposed to 3D space. As you move
    the `Text` object in the **Scene** viewport, check its appearance in the **Game**
    tab to ensure that it looks correct and appropriate. See *Figure 4.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.35: Positioning the Score text within the Game tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'To secure the position of the `Text` object on screen (preventing it from sliding
    or moving), even if the **Game** tab is resized by the user, we can set the object''s
    anchor position to the top right corner of the screen. This ensures that the text
    is always positioned as a constant, proportional offset from its anchor. To do
    this, click on the **Anchor Presets** button in the **Rect Transform** component
    in the **Object Inspector**. When you do this, a preset menu appears from which
    you can choose a range of alignment locations. Each preset is graphically presented
    as a small diagram, including a red dot at the location of anchor alignment. Select
    the top right preset. See *Figure 4.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scores and scoring – UI and text objects](img/B05118_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.36: Aligning the Text object to the screen'
  prefs: []
  type: TYPE_NORMAL
- en: Excellent work! The `Text` object is now created and ready to use. Of course,
    in play mode, the text remains unchanged and doesn't display a real score. That's
    because we need to add some code. However, overall, the `Text` object is in place
    and we can move on.
  prefs: []
  type: TYPE_NORMAL
- en: Working with scores – scripting with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To display a score in the GUI, we'll first need score functionality, that is,
    code to create a score system. Essentially, the score functionality will be added
    to a general, overarching `GameController` class, responsible for all game-wide
    logic and features. The code for `GameController` and its score feature set is
    included in *Code Sample 4.4*, as follows. This file should be added to the `Scripts`
    folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 4.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GameController` class uses the `UnityEngine.ui` namespace. This is important
    because it includes access to all the UI classes and objects in Unity. If you
    don't include this namespace in your source files, then you cannot use UI objects
    from that script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameController` class features two text public members, namely, `ScoreText`
    and `GameOverText`. These refer to two text objects, both of which are optional
    insofar as the `GameController` code will work just fine, even if the members
    are null. `ScoreText` is a reference to a text GUI object to display score text,
    and `GameOverText` is to display any message when a game-over condition occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the `GameController` code, create a new, empty object in the scene named
    `GameController`. Then, drag and drop the `GameController` script file to that
    object. Once added, drag and drop the `ScoreText` object to the **Score Text**
    field for `GameController` in the **Object Inspector**. See *Figure 4.37*. In
    the **Score Prefix** field, enter the text that should prefix the `Score` itself.
    The score, on its own, is simply a number (such as 1,000). The prefix allows you
    to add text to the front of this score, indicating to the player what the numbers
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.4](img/B05118_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.37: Creating a GameController to maintain the game score'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take the game for a test run and you''ll see the score display at the
    top right corner of the `Game` tab using the GUI text object. This is fine, but
    the score always remains at `0` right now. This is because we have no code, yet,
    to increase the score. For our game, the score should increase when an `Enemy`
    object is destroyed. To achieve this, we''ll create a new script file, `ScoreOnDestroy`.
    This is included in *Code Sample 4.5*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The script should be attached to any object that assigns you points when it''s
    destroyed, such as the enemies. The total number of points assigned is specified
    by `ScoreValue`. To attach the script to the enemy prefab, select the `Prefabs`
    in the **Project** panel, and from the **Object Inspector**, click on the **Add
    Component** button. Then type `ScoreOnDestroy` in the search field to add the
    component to the prefab. Once added, specify the total number of points to be
    allocated for destroying an enemy. For this game, a value of 50 points is assigned.
    See *Figure 4.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 4.4](img/B05118_04_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.38: Adding a Score component to the Enemy prefab'
  prefs: []
  type: TYPE_NORMAL
- en: Great work! You now have destroyable enemies that assign you points on destruction.
    This means that you can finally have an in-game score and could even extend gameplay
    to include high-score features and leaderboards. This also means that our game
    is almost finished and ready to build. Next, we'll add some final touches.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll add the final touches to the game. First on the agenda
    is to fix the game background! Until now, the background has simply displayed
    the default background color associated with the game camera. However, as the
    game is set in space, we should display a space background. To do this, create
    a new **Quad** object in the **Scene** that''ll display a space image. Navigate
    to **GameObject** | **3D Object** | **Quad** from the menu. Then rotate the object
    and move it downward so that it displays a flat, vertically-aligned backdrop.
    You may need to scale the object to look correct. See *Figure 4.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.39: Creating a backdrop for the level and building a Quad'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag and drop the space texture from the **Project** panel to **Quad**
    in the **Scene** to apply it as a material. Once assigned, select the **Quad**
    and change the **Tiling** settings from the material properties in the **Object
    Inspector**. Increase the **X** and **Y** tiling to `3`. See *Figure 4.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.40: Configuring the texture tiling'
  prefs: []
  type: TYPE_NORMAL
- en: 'If texture tiling seems broken for you, then be sure to check the Texture Importing
    settings. To do this, select the texture in the **Project** panel, and from the
    **Object Inspector**, ensure that **Texture Type** is set to **Texture** and the
    **Wrap Mode** is set to **Repeat**. See *Figure 4.41*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.41: Configuring a texture for seamless tiling'
  prefs: []
  type: TYPE_NORMAL
- en: Now the level has a suitable background. Let's add some background music, which
    will play on a loop. To do this, first select the music track in the **Project**
    panel in the `Audio` folder. When selected, make sure that the music **Load Type**,
    from the **Object Inspector**, is set to **Streaming** and **Preload Audio Data**
    is disabled. See *Figure 4.42*. This improves loading times as Unity will not
    need to load all music data to memory as the scene begins.
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.42: Configuring audio data ready for playback'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new, empty **GameObject** in the scene named `Music`, and then
    drag and drop the `Music` track from the **Project** panel to the `Music` object,
    adding it as an **Audio Source** component. **Audio** **Source** components play
    sound effects and music. See *Figure 4.43*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.43: Creating a GameObject with an AudioSource component'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Audio Source** component in the **Object Inspector**, enable the
    **Play On Awake** and **Loop** checkboxes to ensure that the music is played from
    the level beginning and loops endlessly for as long as the game is running. The
    **Spatial Blend** field should be set to `0`, meaning 2D. In short, 2D sounds
    have a consistent volume throughout the level regardless of the player''s position.
    This is because 2D sounds are not spatially located. 3D sounds, in contrast, are
    used for gunshots, footsteps, explosions, and other sounds that exist in 3D space
    and whose volume should change based on how close the player is standing to them
    when they play. See *Figure 4.44*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.44: Looping a music track'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take the game for a test run! Click on the play button on the toolbar
    and test it out. If the music doesn''t play, check that the **Mute Audio** button
    is not enabled from the **Game** tab. See *Figure 4.45*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polishing](img/B05118_04_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.45: Playing a game – disabling Mute Audio, if necessary'
  prefs: []
  type: TYPE_NORMAL
- en: Testing and diagnosis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With practically all games, you''ll need to spend considerable time testing
    and debugging heavily to reduce bugs and errors as much as humanly possible. With
    this sample program, very little debugging and testing has been required by you,
    but that''s not because the game is simple. It''s because I''ve already prechecked
    and pretested most of the code and functionality before presenting the material
    to you in this book, ensuring that you get a smooth learning experience. For your
    own projects, however, you''ll need to do lots of testing. One way to get started
    is using the **Stats** panel. To open this, click on the **Stats** button on the
    **Game** tab. See *Figure 4.46*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and diagnosis](img/B05118_04_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.46: Viewing game performance information via the Stats panel'
  prefs: []
  type: TYPE_NORMAL
- en: More details on the **Stats** panel are included in [Chapter 2](ch02.html "Chapter 2. Project
    A – the Collection Game Continued"), *Project A – the Collection Game Continued*
    of this book, and more information can be found online in the Unity documentation
    at [http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another debugging tool is the **Profiler**. This is useful when the **Stats**
    panel has already helped you identify a general problem, such as a low FPS, and
    you want to dig deeper to find where the problem might be located. More details
    on **Profiler** are included later in [Chapter 6](ch06.html "Chapter 6. Continuing
    the 2D Adventure"), *Continuing the 2D Adventure* but a short introduction is
    worth including here. To access the **Profiler** tool, select **Window** | **Profiler**
    from the application menu. This displays the **Profiler** window. See *Figure
    4.47*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and diagnosis](img/B05118_04_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.47: Accessing the Profiler window'
  prefs: []
  type: TYPE_NORMAL
- en: With the **Profiler** window open, click on play on the toolbar to play test
    your game. When you do this, the **Profiler** window fills with color-coded performance
    data in a graph. See *Figure 4.48*. Green represents the performance of rendering
    (graphical) data. Reading and understanding the graph requires some experience,
    but as a general rule, watch out for mountains and peaks, that is, watch out for
    sharp fluctuations in the graph (sharp ups and downs) as this could indicate a
    problem, especially when it roughly coincides with frame rate drops.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and diagnosis](img/B05118_04_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.48: During gameplay, the Profiler populates with data'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to investigate further, simply pause the game, and then click in
    the graph. The horizontal axis (*X* axis) represents the most recent frames, and
    the vertical axis represents workload. When you click in the graph, a line marker
    is added to indicate the frame under investigation. Beneath the graph, a list
    of all main processes for that frame are presented, typically ordered from top
    to bottom by the heaviness of their workload and proportion of frame time for
    which the process accounted. Heavier processes are listed at the top. See *Figure
    4.49*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing and diagnosis](img/B05118_04_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.49: Investigating performance data with the Profiler'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the **Profiler** can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, finally, we''re ready to build our game to a standalone form ready to
    send off to friends, family, and testers! The process to do this is the same as
    detailed in [Chapter 2](ch02.html "Chapter 2. Project A – the Collection Game
    Continued"), *Project A – the Collection Game Continued*, to build the coin collection
    game. From the application menu, choose **File** | **Build Settings**. From the
    build dialog, add our level to the level list by simply clicking on the **Add
    Current** button. Otherwise, drag and drop the level from the **Project** panel
    to the level list. See *Figure 4.50*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/B05118_04_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.50: Preparing to build the space shooter'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this game, the target platform will be Windows. Consequently, select the
    **PC, Mac & Linux Standalone** option from the **Platform** list, if it''s not
    selected already. If the **Switch Platform** button (at the bottom left) is not
    disabled, then you will need to press this button, confirming to Unity that it
    should build for the selected platform as opposed to a different platform. Then,
    click on the **Build And Run** button. On clicking this, Unity prompts you to
    select a folder on your computer where the built file will be output and saved.
    Once generated, double-click the executable to run it and test. See *Figure 4.51*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building](img/B05118_04_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.51: Test running the game as a standard Windows executable'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great work! We're really on a roll now, having completed two solid Unity projects.
    The first project was a coin collection game and the second was a twin-stick shooter.
    Both are, ultimately, simple games in that they don't rely on advanced mechanics
    or display sophisticated features. However, even very sophisticated games, when
    boiled down to their fundamental ingredients, can be found to rest on a similar
    foundation of essential concepts such as the ones that we've covered so far. That's
    why our projects are so critical to understanding Unity in a deep way. Next, we'll
    move on to creating a more 2D-focused game, considering interfaces, sprites, and
    physics, and lots more!
  prefs: []
  type: TYPE_NORMAL
