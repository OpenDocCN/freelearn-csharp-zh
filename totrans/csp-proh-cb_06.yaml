- en: Chapter 6. Making Apps Responsive with Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to asynchronous programming. This chapter will
    cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Return types of asynchronous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling tasks in asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is an exciting feature in C#. It allows you to continue
    program execution on the main thread while a long-running task runs in its own
    thread separately from the main thread. When this long-running task is complete,
    it will let the main thread know that it has completed (or failed). The benefit
    of asynchronous programming is that it improves the responsiveness of your application.
    The best way to learn and understand asynchronous programming is to experience
    it. The following recipes will illustrate some of the basics to you.
  prefs: []
  type: TYPE_NORMAL
- en: Return types of asynchronous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In asynchronous programming, the `async` methods can have three possible return
    types. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task<TResult>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have a look at each return type in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What could be the use of a `void` return type in asynchronous methods? Generally,
    `void` is used with event handlers. Just bear in mind that `void` returns nothing,
    so you can't wait for it. Therefore, if you call a `void` return type asynchronous
    method, your calling code should be able to continue executing code without having
    to wait for the asynchronous method to complete.
  prefs: []
  type: TYPE_NORMAL
- en: With asynchronous methods that have a return type of `Task`, you can utilize
    the `await` operator to pause the execution of the current thread until the called
    asynchronous method has completed. Keep in mind that an asynchronous method that
    returns a type of `Task` basically does not return an operand. Therefore, if it
    was written as a synchronous method, it would be a `void` return type method.
    This statement might be confusing, but it will become clear in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, asynchronous methods that have a `return` statement have a return type
    of `TResult`. In other words, if the asynchronous method returns a Boolean, you
    would create an asynchronous method with a return type of `Task<bool>`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `void` return type asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_06_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter6`:![How to do it…](img/B05391_06_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed to `Recipes.cs` in order to distinguish the code
    properly. You can, however, rename your class to whatever you like, if it makes
    more sense to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to confirm the new names of all references to the
    code element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to add another new project. Right-click on the solution and
    select **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This time, you will be creating a new Windows Forms application for your solution.
    We need to do this so that we can create a button click event. We called our project
    `winformAsync`:![How to do it…](img/B05391_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your **Solution Explorer** will now look similar to the following screenshot,
    with the Winforms application added:![How to do it…](img/B05391_06_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have added your Winforms application, add a reference to the `Chapter6`
    class you created earlier. To do this, right-click on **References** under the
    **winformAsync** project and click on the **Add Reference** menu item from the
    context menu:![How to do it…](img/B05391_06_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Reference Manager** screen, select the `Chapter6` class, which is
    found under the **Projects** | **Solution** node in the tree view to the left.
    Then, click on the **OK** button:![How to do it…](img/B05391_06_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another important step is to set the **winformAsync** project as the startup
    project in the solution. To do this, right-click the **winformAsync** project
    and select the **Set as StartUp Project** menu item from the context menu:![How
    to do it…](img/B05391_06_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **winformAsync** form designer, open **Toolbox** and select the **Button**
    control, which is found under the **All Windows Forms** node:![How to do it…](img/B05391_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Chapter6` class library, add a new class called `AsyncDemo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method to add to the `AsyncDemo` class is the asynchronous method
    that returns `TResult` (in this case, a Boolean). This method simply checks whether
    the current year is a leap year. It then returns a Boolean to the calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next method to add is the `void` returning method that returns a `Task`
    type so that it allows you to await the method. The method itself does not return
    any result, making it a `void` returning method. However, in order to use the
    `await` keyword, you return the `Task` type from this asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add a method that will call the previous asynchronous methods and
    display the result of the leap year check. You will notice that we are using the
    `await` keyword with both method calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the button click, add the following code that calls the long-running task
    asynchronously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **button1** button will display the outputs to our **Output**
    window. Throughout this code execution, the form remains responsive:![How to do
    it…](img/B05391_06_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you can also use the `await` operator in separate calls. Modify the
    code in the `LongTask()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code, we have seen the `void` returning type asynchronous method
    that was used in the `button1_Click` event. We also created a `Task` returning
    method that returns nothing (that would be a `void` if used in synchronous programming),
    but returning `Task` type allows us to await the method. Finally, we created a
    `Task<TResult>` returning method that performs some task and returns the result
    to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling tasks in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Task-Based Asynchronous Pattern** (**TAP**) is now the recommended method
    to create asynchronous code. It executes asynchronously on a thread from the thread
    pool and does not execute synchronously on the main thread of your application.
    It allows us to check the task''s state by calling the `Status` property.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a task to read a very large text file. This will be accomplished
    using an asynchronous `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a large text file (we called ours `taskFile.txt`) and place it in your
    `C:\temp` folder:![How to do it…](img/B05391_06_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `AsyncDemo` class, create a method called `ReadBigFile()` that returns
    a `Task<TResult>` type, which will be used to return an integer of bytes read
    from our big text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to open and read the file bytes. You will see that we
    are using the `ReadAsync()` method that asynchronously reads a sequence of bytes
    from the stream and advances the position in that stream by the number of bytes
    read from that stream. You will also notice that we are using a buffer to read
    those bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions you can expect to handle from the `ReadAsync()` method are `ArgumentNullException`,
    `ArgumentOutOfRangeException`, `ArgumentException`, `NotSupportedException`, `ObjectDisposedException`
    and `InvalidOperatorException`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the final section of code just after the `var readBytes = bigFile.ReadAsync(bigFileBuffer,
    0, (int)bigFile.Length);` line that uses a lambda expression to specify the work
    that the task needs to perform. In this case, it is to read the bytes in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If not done so in the previous recipe, add a button to your Windows Forms application's
    Forms Designer. On the **winformAsync** form designer, open **Toolbox** and select
    the **Button** control, which is found under the **All Windows Forms** node:![How
    to do it…](img/B05391_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the button control selected, double-click the control to create the click
    event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, make sure that you add code to call the `AsyncDemo` class''s `ReadBigFile()`
    method asynchronously. Remember to read the result from the method (which are
    the bytes read) into an integer variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **button1** button will display the outputs in our **Output**
    window. Throughout this code execution, the form remains responsive:![How to do
    it…](img/B05391_06_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note though that the information displayed in your **Output** window will
    differ from the screenshot. This is because the file you used is different from
    mine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The task is executed on a separate thread from the thread pool. This allows
    the application to remain responsive while the large file is being processed.
    Tasks can be used in multiple ways to improve your code. This recipe is but one
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exception handling in asynchronous programming has always been a challenge.
    This was especially true in the catch blocks. As of C# 6, you are now allowed
    to write asynchronous code inside the `catch` and `finally` block of your exception
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application will simulate the action of reading a logfile. Assume that a
    third-party system always makes a backup of the logfile before processing it in
    another application. While this processing is happening, the logfile is deleted
    and recreated. Our application, however, needs to read this logfile on a periodic
    basis. We, therefore, need to be prepared for the case where the file does not
    exist in the location we expect it in. Therefore, we will purposely omit the main
    logfile, so that we can force an error.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a text file and two folders to contain the logfiles. We will, however,
    only create a single logfile in the `BackupLog` folder. The `MainLog` folder will
    remain empty:![How to do it…](img/B05391_06_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our `AsyncDemo` class, write a method to read the main logfile in the `MainLog`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a second method to read the backup file in the `BackupLog` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In actual fact, we would probably only create a single method to read the logfiles,
    passing only the path as a parameter. In a production application, creating a
    class and overriding a method to read the different logfile locations would be
    a better approach. For the purposes of this recipe, however, we specifically wanted
    to create two separate methods so that the different calls to the asynchronous
    methods are clearly visible in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then create a main `ReadLogFile()` method that tries to read the main
    logfile. As we have not created the logfile in the `MainLog` folder, the code
    will throw a `FileNotFoundException`. It will then run the asynchronous method
    and await that in the `catch` block of the `ReadLogFile()` method (something that
    was impossible in the previous versions of C#), returning the bytes read to the
    calling code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If not done so in the previous recipe, add a button to your Windows Forms application's
    Forms Designer. On the **winformAsync** Forms Designer, open **Toolbox** and select
    the **Button** control, which is found under the **All Windows Forms** node:![How
    to do it…](img/B05391_06_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will write the code to create a new instance of the `AsyncDemo` class
    and attempt to read the main logfile. In a real-world example, it is at this point
    that the code does not know that the main logfile does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To simulate a file not found exception, we deleted the file from the `MainLog`
    folder. You will see that the exception is thrown, and the `catch` block runs
    the code to read the backup logfile instead:![How to do it…](img/B05391_06_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that we can await in `catch` and `finally` blocks allows developers
    much more flexibility, because asynchronous results can consistently be awaited
    throughout the application. As you can see from the code we wrote, as soon as
    the exception was thrown, we asynchronously read the file read method for the
    backup file.
  prefs: []
  type: TYPE_NORMAL
