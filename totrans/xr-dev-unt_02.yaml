- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Unity Editor and Scene Creation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity编辑器和场景创建
- en: In this chapter, we’ll lay the groundwork for your Unity journey. You’ll familiarize
    yourself with the Unity Editor, create a basic scene, and explore essential lighting
    aspects. We’ll cover installing Unity, navigating the Editor, working with **GameObjects**,
    importing assets, and experimenting with various lighting settings. By the end,
    you’ll have a solid foundation to delve deeper into Unity and create increasingly
    complex and captivating scenes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为您Unity之旅打下基础。您将熟悉Unity编辑器，创建一个基本场景，并探索基本照明方面。我们将涵盖安装Unity、导航编辑器、使用**GameObject**、导入资源和尝试各种照明设置。到那时，您将拥有深入Unity并创建越来越复杂和引人入胜场景的坚实基础。
- en: 'We’ll cover the following topics as we proceed:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的内容中涵盖以下主题：
- en: Setting up the Unity development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Unity开发环境
- en: Getting to know the Unity Editor and its interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Unity编辑器和其界面
- en: Understanding GameObjects and components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GameObject和组件
- en: Creating a basic scene in Unity and adding objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中创建基本场景并添加对象
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before diving into the Unity Editor, it is important to ensure that your system
    meets the minimum requirements to run Unity. To successfully complete the exercises
    in this chapter, you will require a personal computer that has *Unity 2021.3*
    LTS or a more recent version installed. To ensure your hardware meets the requirements,
    you can cross-check it on the Unity website ([https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入Unity编辑器之前，确保您的系统满足运行Unity的最低要求非常重要。为了成功完成本章的练习，您需要一个已安装*Unity 2021.3* LTS或更高版本的计算机。为了确保您的硬件满足要求，您可以在Unity网站上交叉检查（[https://docs.unity3d.com/Manual/system-requirements.html](https://docs.unity3d.com/Manual/system-requirements.html)）。
- en: Setting up the Unity development environment
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Unity开发环境
- en: First things first, let’s get Unity up and running on your development machine.
    Throughout this book, we’ll be harnessing the power of the Unity 3D game engine
    to create inspiring projects. Unity is an incredibly potent, cross-platform 3D
    development environment, complete with an intuitive and visually appealing editor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在您的开发机器上启动Unity。在整个本书中，我们将利用Unity 3D游戏引擎的强大功能来创建令人鼓舞的项目。Unity是一个功能强大的跨平台3D开发环境，配备直观且视觉上吸引人的编辑器。
- en: If you have not yet installed Unity on your computer, we will guide you through
    the process. Following the installation, we’ll proceed to create our initial scene.
    Let’s begin the setup and exploration of Unity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未在计算机上安装Unity，我们将引导您完成安装过程。安装完成后，我们将继续创建我们的初始场景。让我们开始设置和探索Unity。
- en: Installing the Unity Hub
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Unity Hub
- en: 'Over the course of this book, the **Unity Hub** will become your trusty command
    center for managing different Unity projects, Unity Editor versions, and modules.
    To initiate the installation process of the Unity Hub, follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，**Unity Hub**将成为您管理不同Unity项目、Unity编辑器版本和模块的可靠指挥中心。要启动Unity Hub的安装过程，请按照以下步骤操作：
- en: Head over to the official Unity website ([https://unity3d.com/get-unity/download](https://unity3d.com/get-unity/download))
    and navigate to the latest version of the Unity Hub.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问官方Unity网站（[https://unity3d.com/get-unity/download](https://unity3d.com/get-unity/download)）并导航到最新版本的Unity
    Hub。
- en: Follow the onscreen instructions to install Unity Hub.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照屏幕上的说明安装Unity Hub。
- en: With the Unity Hub installed, open it up and sign in using your Unity account.
    If you’re new to Unity, create an account to join the ranks of fellow creators.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Unity Hub后，打开它并使用您的Unity账户登录。如果您是Unity的新用户，请创建一个账户以加入其他创作者的行列。
- en: Without having the Unity Editor installed, the Unity Hub is just as powerful
    as a CD player without a CD. The next section covers how you can install the Unity
    Editor within the Unity Hub.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有安装Unity编辑器，Unity Hub就像没有CD的CD播放器一样强大。下一节将介绍如何在Unity Hub中安装Unity编辑器。
- en: Installing the Unity Editor
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Unity编辑器
- en: 'The **Unity Editor** is where the magic happens—a workspace for designing,
    building, and testing your game projects. To install it, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity编辑器**是魔法发生的地方——一个用于设计、构建和测试游戏项目的 workspace。要安装它，请按照以下步骤操作：'
- en: Within the Unity Hub, navigate to the **Installs** tab and hit the **Add** button
    to add a new Unity Editor version.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity Hub中，导航到**安装**选项卡，然后点击**添加**按钮以添加新的Unity编辑器版本。
- en: Opt for the latest LTS version of the Unity Editor and click **Next** to kick
    off the installation process.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Unity编辑器的最新LTS版本，并点击**下一步**以启动安装过程。
- en: 'During installation, don’t forget to include the necessary platforms and modules
    tailored to your specific needs. Add the *Windows/Mac/Linux Build Support*, depending
    on the operating system of your PC. Likewise, select the *Android* or *iOS Build
    Support*, depending on the nature of your smartphone, so that you can follow along
    with the AR tutorials in this book. Lastly, if you are using a VR headset that
    runs on Android, such as the *Quest 2* or *Quest Pro*, be sure to add the *Android
    Build Support* module along with its sub-modules: *OpenJDK* and *Android SDK &*
    *NDK Tools*.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装过程中，别忘了包括满足您特定需求的必要平台和模块。根据您PC的操作系统，添加*Windows/Mac/Linux构建支持*。同样，根据您智能手机的性质，选择*Android*或*iOS构建支持*，以便您能跟随本书中的AR教程。最后，如果您使用的是运行Android的VR头盔，例如*Quest
    2*或*Quest Pro*，请务必添加*Android构建支持*模块及其子模块：*OpenJDK*和*Android SDK & NDK Tools*。
- en: As we have the Unity Editor installed, it is time to create a project.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了Unity编辑器，现在是时候创建一个项目了。
- en: Loading a sample scene as a new Unity project
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将示例场景作为新Unity项目加载
- en: After installing the Unity Hub and the Unity Editor, it’s time to create a new
    Unity project. For the sake of simplicity, we will first use a sample scene. A
    sample scene in Unity is a pre-built scene created by Unity to show developers
    how various functions and techniques can be implemented. Unity offers a variety
    of sample scenes, ranging from simple 2D games to complex 3D environments, that
    can be used as a starting point for your own projects. The sample scenes can be
    downloaded via the Asset Store or directly from the Unity Hub. Here’s how to do
    that directly from the Unity Hub.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Unity Hub和Unity编辑器后，现在是时候创建一个新的Unity项目了。为了简单起见，我们首先使用一个示例场景。Unity中的示例场景是由Unity预先构建的场景，用于向开发者展示如何实现各种功能和技巧。Unity提供了各种示例场景，从简单的2D游戏到复杂的3D环境，可以作为您自己项目的起点。示例场景可以通过资产商店或直接从Unity
    Hub下载。以下是直接从Unity Hub进行操作的方法。
- en: '*Figure 2**.1* shows a project’s creation within the Unity Hub.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*显示了在Unity Hub中创建项目的过程。'
- en: "![Figure 2.1 – \uFEFFHow to create a project with a sample scene in the Unity\
    \ Hub](img/B20869_02_01.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 在Unity Hub中使用示例场景创建项目的方法](img/B20869_02_01.jpg)'
- en: Figure 2.1 – How to create a project with a sample scene in the Unity Hub
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 在Unity Hub中使用示例场景创建项目的方法
- en: 'To load a sample scene as a new project, just go through the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要将示例场景作为新项目加载，只需按照以下步骤操作：
- en: Open the Unity Hub and go to the **Projects** tab.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Unity Hub并转到**项目**标签页。
- en: Click on the **New** button to create a new project.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建**按钮以创建一个新项目。
- en: Choose **3D Sample Scene (URP)**, give your project a name, and select a location
    to save it. For this project, we’ve opted for **3D Sample Scene (URP)** as it
    provides a preconfigured environment showcasing the capabilities of the **Universal
    Render Pipeline** (**URP**), ideal for those new to Unity or seeking a reference.
    While the standard **3D (URP)** template is typically favored by developers for
    its clean slate, allowing for a customized setup, they often enhance these projects
    by importing additional packages or assets via the Package Manager or Unity Asset
    Store.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**3D示例场景（URP）**，给你的项目命名，并选择一个保存位置。对于这个项目，我们选择了**3D示例场景（URP）**，因为它提供了一个预配置的环境，展示了**通用渲染管线**（**URP**）的功能，非常适合Unity新手或寻求参考的人。虽然标准的**3D（URP）**模板通常受到开发者的青睐，因为它提供了一个干净的起点，允许自定义设置，但他们通常通过包管理器或Unity资产商店导入额外的包或资产来增强这些项目。
- en: Click on the **Create** button to create the project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**按钮以创建项目。
- en: Now that we’ve got that out of the way, let’s look at how to choose the right
    render pipeline.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这个问题，让我们来看看如何选择正确的渲染管线。
- en: Choosing the right render pipeline
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的渲染管线
- en: Upon examining the sample scene options, you might have noticed the choice between
    the URP and the **High Definition Render Pipeline** (**HDRP**). But which one
    is better, and what exactly is a render pipeline? In essence, a render pipeline
    is a sequence of steps and processes that dictate how the engine renders graphics.
    It transforms 3D assets, lighting, and other scene components into the final 2D
    image gracing your screen. While URP and HDRP share some low-level tasks, each
    pipeline is tailored to specific project needs and target platforms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查示例场景选项时，你可能已经注意到了URP和**高清渲染管线**（**HDRP**）之间的选择。但哪一个更好，渲染管线究竟是什么？本质上，渲染管线是一系列步骤和过程，它决定了引擎如何渲染图形。它将3D资产、光照和其他场景组件转换成最终出现在你屏幕上的2D图像。虽然URP和HDRP共享一些底层任务，但每个管线都是针对特定项目需求和目标平台定制的。
- en: '*Table 2.1* shows how URP and HDRP stack up against one another:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*表2.1*显示了URP和HDRP如何相互比较：'
- en: '![Table 2.1 – A comparison between URP and HDRP](img/B20869_Table_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![表2.1 – URP和HDRP的比较](img/B20869_Table_01.jpg)'
- en: Table 2.1 – A comparison between URP and HDRP
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – URP和HDRP的比较
- en: A comfortable VR experience demands high frame rates, typically exceeding 90
    FPS. URP emphasizes performance, ensuring smooth frame rates across various VR
    devices, including standalone VR headsets, PC-based VR, and mobile VR. As the
    market sees a growing number of standalone VR headsets, URP proves invaluable
    for its adaptability and ease of project optimization.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个舒适的VR体验需要高帧率，通常超过90 FPS。URP强调性能，确保在各种VR设备上，包括独立VR头戴式设备、基于PC的VR和移动VR，都能保持流畅的帧率。随着市场上独立VR头戴式设备的数量不断增长，URP因其适应性和项目优化的简便性而变得非常有价值。
- en: While URP may not boast the visual prowess of HDRP, it strikes a balance between
    graphic quality and performance, making it suitable for the majority of VR projects
    where performance is crucial.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然URP可能不具备HDRP的视觉能力，但它平衡了图形质量和性能，使其适合大多数对性能至关重要的VR项目。
- en: Unity’s versatility extends beyond HDRP and URP pipelines, allowing the creation
    of custom **Scriptable Render Pipeline** (**SRP**) pipelines for experienced graphics
    programmers. However, developing a custom SRP pipeline requires deep knowledge
    of 3D graphics programming, rendering pipelines, and C# language proficiency.
    For those lacking these skills, HDRP and URP offer an optimal balance between
    flexibility and ease of use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的通用性不仅限于HDRP和URP管线，它还允许经验丰富的图形程序员创建自定义的**可脚本渲染管线**（**SRP**）管线。然而，开发自定义SRP管线需要深入了解3D图形编程、渲染管线和C#语言的熟练度。对于那些缺乏这些技能的人来说，HDRP和URP提供了灵活性和易用性之间的最佳平衡。
- en: Given its many advantages, URP emerges as the go-to choice for most VR endeavors.
    Throughout this book, we’ll focus exclusively on URP. However, HDRP remains a
    worthy contender for those pursuing high-end PC VR experiences.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其众多优势，URP成为了大多数VR项目的首选选择。在这本书中，我们将专注于URP。然而，HDRP对于追求高端PC VR体验的人来说仍然是一个值得考虑的竞争者。
- en: With Unity installed, the render pipeline selected, and your project at your
    fingertips, it’s time to acquaint ourselves with the Unity Editor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Unity、选择了渲染管线并且你的项目在你的指尖上时，是时候熟悉Unity编辑器了。
- en: Getting to know the Unity Editor and its interface
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Unity编辑器和其界面
- en: If you’re new to Unity, the editor’s interface can be a bit overwhelming at
    first. But don’t worry—we’ll guide you through the Unity Editor and show you how
    to navigate its various menus and panels. Experienced users can also benefit from
    staying current with the latest best practices and techniques, as designing for
    VR presents unique challenges that may require a different approach than traditional
    game development.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始使用Unity，编辑器的界面一开始可能会有些令人不知所措。但别担心——我们将引导你通过Unity编辑器，并展示如何导航其各种菜单和面板。经验丰富的用户也可以通过保持对最新最佳实践和技术的新鲜感而受益，因为为VR设计会带来独特的挑战，可能需要与传统游戏开发不同的方法。
- en: Exploring the Unity interface
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Unity界面
- en: Upon launching a new Unity project, you’ll be greeted by the Unity Editor. This
    multifaceted workspace is composed of several distinct windows known as panels.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动一个新的Unity项目时，你会看到Unity编辑器。这个多功能的 workspace 由几个称为面板的独立窗口组成。
- en: '*Figure 2**.2* shows the window layout for the sample scene project we just
    created.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2*显示了刚刚创建的示例场景项目的窗口布局。'
- en: "![Figure 2.2 – \uFEFFThe window layout for the sample scene project](img/B20869_02_02.jpg)"
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 示例场景项目的窗口布局](img/B20869_02_02.jpg)'
- en: Figure 2.2 – The window layout for the sample scene project
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 示例场景项目的窗口布局
- en: '*Figure 2**.2* showcases a number of panels, namely: (*1*) **Scene** view,
    (*2*) **Game** view, (*3*) **Hierarchy**, (*4*) **Inspector**, (*5*) **Project**,
    and (*6*) **Console**.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2* 展示了多个面板，包括：(*1*) **场景**视图，(*2*) **游戏**视图，(*3*) **层级**，(*4*) **检查器**，(*5*)
    **项目**，和(*6*) **控制台**。'
- en: Let’s explore these essential panels that make up Unity’s interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索构成Unity界面的这些基本面板。
- en: Imagine the **Scene view** (*1*) as your canvas, where you’ll bring your game
    world to life, creating mesmerizing landscapes and placing your characters in
    fantastic environments. This panel is the heart of the game, where every object
    is placed and arranged to tell a compelling story. For example, you can select
    the **Safety Hat** GameObject within our sample scene and move, rotate, scale,
    or remove it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将**场景视图** (*1*) 想象成你的画布，你将在上面让你的游戏世界栩栩如生，创造迷人的景观，并将你的角色放置在奇幻的环境中。这个面板是游戏的核心，每个对象都被放置和排列，以讲述一个引人入胜的故事。例如，你可以在我们的示例场景中选择**安全帽**GameObject，并移动、旋转、缩放或删除它。
- en: The **Game view** (*2*) is the place where you can experience your game from
    your player’s perspective. It provides a real-time preview of the gameplay, including
    the visual rendering and user interface elements you’ve implemented.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏视图** (*2*) 是你可以从玩家视角体验游戏的地方。它提供了游戏玩法的实时预览，包括你实现的视觉渲染和用户界面元素。'
- en: The **Hierarchy panel** (*3*) or **Scene Hierarchy window** is your game’s blueprint,
    showcasing the organized list of every GameObject that makes up your game world.
    It’s like an architectural plan that helps you navigate, manage, and visualize
    the relationships between game elements, ensuring a coherent and structured experience.
    Our sample scene demonstrates what a well-structured hierarchy looks like. All
    added GameObjects are subordinate to the **Example Assets** parent object. This
    includes the **Props** GameObject, which itself serves as a parent object for
    any GameObjector asset that decorates a scene and adds details and context to
    the game world—for example, Jigsaw, Hammer, Workbench, and so on. So, keep in
    mind that grouping related objects together under a parent GameObject makes it
    easier to manage and manipulate them as a single entity. Additionally, naming
    conventions can be used to make the hierarchy more readable and easier to understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**层级面板** (*3*) 或 **场景层级窗口** 是你游戏的设计蓝图，展示了构成你游戏世界的每个GameObject的有序列表。它就像一张建筑图纸，帮助你导航、管理和可视化游戏元素之间的关系，确保体验连贯且结构化。我们的示例场景展示了良好结构化的层级是什么样的。所有添加的GameObject都隶属于**示例资产**父对象。这包括**道具**GameObject，它本身也作为任何装饰场景并增加游戏世界细节和背景的GameObject或资产的父对象——例如，拼图、锤子、工作台等等。因此，请记住，将相关对象分组放在父GameObject下，可以更容易地管理和操作它们作为一个单一实体。此外，命名约定可以用来使层级更易于阅读和理解。'
- en: The **Inspector panel** (*4*) or **Inspector window** is the control center
    for fine-tuning your game elements. It’s where you can adjust every tiny detail
    of your GameObjects or assets, making sure your game world is precisely how you
    envisioned it. From position and scale to adding components and modifying scripts,
    the **Inspector** panel is your ticket to perfection. Let’s select the **Safety
    Hat** object in the **Scene Hierarchy** window by navigating to **Example Asset**
    | **Props** | **Safety Hat**. The **Inspector** window shows all the defined components
    of the **Safety Hat** object. The **Transform** component is responsible for positioning,
    rotating, and scaling the object. You will find a gizmo representation of it in
    the Scene View, which allows us to transform objects directly there. Two other
    components that can be seen in the **Inspector** window are the **Mesh Filter**
    and **Mesh Renderer** components. The **Mesh Filter** and **Mesh Renderer** components
    provide a way to create and display 3D models in a scene. The **Mesh Filter**
    component defines the model’s geometry, while the **Mesh Renderer** component
    applies visual properties such as materials and textures. Without these components,
    you wouldn’t see the object in the Scene View.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查器面板**（*4*）或**检查器窗口**是微调游戏元素的控制中心。在这里，您可以调整GameObject或资产的所有细微细节，确保您的游戏世界精确地符合您的设想。从位置和缩放到添加组件和修改脚本，**检查器**面板是您通往完美的通行证。让我们通过导航到**示例资产**
    | **道具** | **安全帽**在**场景层次结构**窗口中选择**安全帽**对象。**检查器**窗口显示了**安全帽**对象的所有定义组件。**变换**组件负责定位、旋转和缩放对象。您将在场景视图中找到它的
    Gizmo 表示，这允许我们直接在那里变换对象。**检查器**窗口中还可以看到的其他两个组件是**网格过滤**和**网格渲染器**组件。**网格过滤**和**网格渲染器**组件提供了一种在场景中创建和显示3D模型的方法。**网格过滤**组件定义了模型的几何形状，而**网格渲染器**组件应用了如材质和纹理等视觉属性。没有这些组件，您在场景视图中将看不到对象。'
- en: The **Project** panel (*5*) holds all the building blocks of your game, from
    **textures** and models to sounds and scripts. It’s like a library of resources,
    where every imported or created asset is at your fingertips, waiting to be used
    in your XR project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目**面板（*5*）包含了您游戏的所有构建块，从**纹理**和模型到声音和脚本。它就像是一个资源库，其中每个导入或创建的资产都触手可及，等待在您的XR项目中使用。'
- en: Finally, the **Console** panel (*6*) is an essential tool, assisting in the
    identification and resolution of issues during development. It provides detailed
    logs, warnings, and error messages, allowing for efficient troubleshooting and
    ensuring the integrity of the game’s performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**控制台**面板（*6*）是一个重要的工具，在开发过程中帮助识别和解决问题。它提供详细的日志、警告和错误消息，允许进行高效的故障排除，并确保游戏性能的完整性。
- en: You are now familiar with the default panels in Unity. Next, we will get to
    know the Unity Grid and Snap system, which is a game changer when building scenes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在熟悉了Unity中的默认面板。接下来，我们将了解Unity网格和吸附系统，这在构建场景时是一个变革性的工具。
- en: Tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can keep the default layout, or customize your panels using the dropdown
    at the top right of the Unity Editor under **Layout**. We usually prefer the 2x3
    layout, but for simplicity, we will use the default layout in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保持默认布局，或者使用Unity编辑器右上角的下拉菜单在**布局**下自定义您的面板。我们通常更喜欢2x3布局，但为了简单起见，本书中将使用默认布局。
- en: Using the Grid and Snap system
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用网格和吸附系统
- en: The **Unity Grid and Snap system** helps align and place objects in a more organized
    manner in the game environment. It allows you to snap objects to a grid and also
    to other objects for easier placement and arrangement.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity网格和吸附系统**帮助在游戏环境中以更组织化的方式对齐和放置对象。它允许您将对象吸附到网格上，也可以吸附到其他对象上，以便更容易地进行放置和排列。'
- en: '*Figure 2**.3* shows you where to find the system.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2**.3*显示了您可以在哪里找到该系统。'
- en: "![Figure 2.3 – \uFEFFHow to use the Grid and Snap system](img/B20869_02_03.jpg)"
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 如何使用网格和吸附系统](img/B20869_02_03.jpg)'
- en: Figure 2.3 – How to use the Grid and Snap system
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 如何使用网格和吸附系统
- en: To make use of this system, you will need to turn on the **Grid Snapping** button,
    which is represented by an icon with a grid and magnet (*1*). Furthermore, make
    sure to activate the **Global** handles by selecting the **Global** icon (*2*)
    positioned adjacent to the **Grid** **Snapping** field.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此系统，您需要启用**网格吸附**按钮，该按钮由一个带有网格和磁铁图标的图标表示（*1*）。此外，请确保通过选择位于**网格** **吸附**字段旁边的**全局**图标（*2*）来激活**全局**句柄。
- en: The `1` for all three axes (**X**, **Y**, and **Z**), meaning each grid square
    has a width, height, and depth of one unit. This setting can be adjusted as needed
    to match the scale of the objects in your scene. The **Grid Size** field determines
    the increment at which objects will snap to the grid, so a larger grid size will
    result in coarser snapping, while a smaller grid size will result in finer snapping.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个轴（**X**、**Y**和**Z**）的`1`，意味着每个网格方格的宽度、高度和深度都是一单位。此设置可以根据需要调整，以匹配场景中对象的缩放。**网格大小**字段决定了对象吸附到网格的增量，因此较大的网格大小会导致更粗糙的吸附，而较小的网格大小会导致更精细的吸附。
- en: Your turn
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的回合
- en: 1\. Select the same stud as in *Figure 2**.3* and move it two units towards
    the **Y** direction. Activate **Grid Snapping**, and try different grid sizes
    to place the stud back on the workbench.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 选择与*图2**.3*中相同的支架，并将其沿**Y**方向移动两个单位。激活**网格吸附**，并尝试不同的网格大小，将支架放回工作台上。
- en: '2\. Try to become familiar with the navigation in the **Scene** view by moving,
    orbiting, and zooming through the scene. This documentation may help you: [https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html](https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html)).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 通过在场景中移动、环绕和缩放来熟悉**场景**视图中的导航。以下文档可能对你有所帮助：[https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html](https://docs.unity3d.com/510/Documentation/Manual/SceneViewNavigation.html))
- en: 3\. Pick another two GameObjectsand move, scale, and rotate them as you like.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 选择另外两个游戏对象，并按你的喜好移动、缩放和旋转它们。
- en: Understanding GameObjects and components
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解游戏对象和组件
- en: GameObjects and **components** are essential building blocks of Unity projects,
    allowing developers to create interactive and dynamic content. Now, we’ll provide
    a comprehensive overview of GameObjects and components and how they work together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏对象和**组件**是Unity项目的核心构建模块，允许开发者创建交互性和动态内容。现在，我们将提供一个关于游戏对象和组件的全面概述，以及它们是如何协同工作的。
- en: Understanding the default new scene
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解默认新场景
- en: Unity empowers developers with the ability to create multiple scenes within
    the editor. This feature aids in managing complexity, enhancing performance, and
    fostering more modular and reusable game projects. To create a new default scene
    alongside our sample scene, access the menu at the uppermost section of the editor
    and choose `Scenes` folder with a name of your choosing. After following these
    steps, you will be presented with a new Unity scene containing a **Main Camera**
    GameObject and a **Directional Light** GameObject. Both GameObjects are located
    in the **Scene Hierarchy** window and displayed in the **Scene** window, which
    features an infinite reference ground plane grid. In Unity, GameObjects serve
    as the foundational building blocks of a game scene. They represent visible or
    interactive elements such as characters, props, light sources, or cameras. Each
    GameObject possesses a **Transform** component that defines its position, rotation,
    and scale and can be augmented with additional components for **physics**, **collision
    detection**, or **game logic**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Unity赋予开发者能够在编辑器内创建多个场景的能力。这一功能有助于管理复杂性、提升性能，并促进更模块化和可重用的游戏项目。要创建一个与我们的示例场景并列的新默认场景，请访问编辑器最上方的菜单，并选择名为你选择的`Scenes`文件夹。按照这些步骤操作后，你将看到一个包含**主摄像机**游戏对象和**方向光**游戏对象的Unity新场景。这两个游戏对象都位于**场景层次结构**窗口中，并在**场景**窗口中显示，该窗口具有无限参考地面网格。在Unity中，游戏对象是游戏场景的基础构建模块。它们代表可见或交互式元素，如角色、道具、光源或摄像机。每个游戏对象都有一个**变换**组件，它定义了其位置、旋转和缩放，并且可以通过添加额外的组件来增强**物理**、**碰撞检测**或**游戏逻辑**。
- en: Let’s create our first GameObject. Keep in mind that while Unity is primarily
    a game engine, it does offer some basic modeling capabilities. You can create
    simple 3D models using Unity’s built-in 3D object **primitives** or import more
    intricate models fashioned in other 3D modeling software. Third-party plugins
    are also available to further bolster Unity’s modeling prowess. However, it’s
    important to remember that Unity is no match for dedicated 3D modeling software
    such as *Blender*, *3ds Max*, or *Maya*, and it’s better suited for creating and
    manipulating models for use in game development.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个GameObject。请注意，虽然Unity主要是一个游戏引擎，但它确实提供了一些基本的建模能力。您可以使用Unity内置的3D对象**原语**创建简单的3D模型，或者导入在其他3D建模软件中创建的更复杂的模型。还有第三方插件可以进一步增强Unity的建模能力。然而，重要的是要记住，Unity无法与专门的3D建模软件如*Blender*、*3ds
    Max*或*Maya*相提并论，它更适合创建和操作用于游戏开发的模型。
- en: We’ll start by creating a plane primitive to act as our floor. To do so, right-click
    in the `0`,`0`,`0`) but rather at a different location. By default, newly created
    objects are parented to the active object in the `Ground`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个平面原语作为我们的地板。为此，在`(0,0,0)`的默认位置右键单击，而是在不同的位置。默认情况下，新创建的对象被放置在`Ground`的激活对象下。
- en: In the `Ground` object’s **Inspector** window, you’ll notice that besides the
    **Mesh Filter** and **Mesh Renderer** components responsible for the GameObject’s
    visual appearance, there’s also a **Mesh Collider** component. Up next, you’ll
    learn more about this and other types of colliders.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Ground`对象的**检查器**窗口中，您会注意到，除了负责GameObject视觉外观的**网格过滤器**和**网格渲染器**组件外，还有一个**网格碰撞器**组件。接下来，您将了解更多关于这个和其他类型碰撞器的信息。
- en: Adding a collider
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加碰撞器
- en: '**Colliders** are components that define the shape of an object and are used
    to determine physical interactions with other objects in the scene. There are
    several types of colliders available in Unity, each with its own specific use
    case, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**碰撞器**是定义对象形状的组件，用于确定场景中与其他对象的物理交互。Unity中提供了几种类型的碰撞器，每种都有其特定的用途，如下所示：'
- en: '**Box collider**: This type of collider defines a rectangular shape, perfect
    for objects with a box-like shape.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**盒子碰撞器**：此类碰撞器定义了矩形形状，非常适合类似盒子的对象。'
- en: '**Sphere collider**: This type of collider defines a spherical shape, great
    for objects with a round shape, such as a ball.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**球体碰撞器**：此类碰撞器定义了球形形状，非常适合圆形对象，例如球。'
- en: '**Capsule collider**: This type of collider is a combination of a cylinder
    and two spheres, useful for objects that are shaped like a capsule, such as a
    character.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胶囊碰撞器**：此类碰撞器是圆柱体和两个球体的组合，适用于形状像胶囊的对象，例如角色。'
- en: '**Mesh collider**: This type of collider defines the shape of an object based
    on its mesh, allowing precise collision detection.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格碰撞器**：此类碰撞器根据对象的网格定义其形状，允许精确的碰撞检测。'
- en: '**Wheel collider**: This type of collider is specifically designed for wheel-based
    objects, such as vehicles. It allows realistic wheel behavior and suspension.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮式碰撞器**：此类碰撞器专门为基于轮子的对象设计，例如车辆。它允许实现逼真的轮子和悬挂行为。'
- en: By incorporating a collider component, you can define an object’s interactions
    with other scene colliders, such as bouncing, stopping, or passing through. Additionally,
    colliders can trigger events, such as activating sound effects upon collision.
    Applying a collider to the ground is sensible, as it establishes environmental
    boundaries and enables lifelike interactions with other scene objects, preventing
    characters from falling through the ground, for instance.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集成碰撞器组件，您可以定义对象与其他场景碰撞器之间的交互，例如反弹、停止或穿透。此外，碰撞器可以触发事件，例如在碰撞时激活声音效果。将碰撞器应用于地面是合理的，因为它建立了环境边界，并使场景中的其他对象能够进行逼真的交互，例如防止角色穿过地面。
- en: Components are versatile tools that can be assigned to GameObjects, shaping
    their behavior, appearance, and functionality. Consider **Main Camera**, which
    is equipped with components such as **Transform** (defining position, rotation,
    and scale) and **Camera** (specifying settings such as **field of view** (**FOV**)
    and clipping planes). Similarly, the **Directional Light** GameObject features
    components such as **Transform** and **Light**, which determine the light’s type,
    color, and intensity, among other properties.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是可变的工具，可以被分配给GameObject，塑造其行为、外观和功能。考虑**主摄像机**，它配备了如**变换**（定义位置、旋转和缩放）和**摄像机**（指定如**视野**（**FOV**）和裁剪平面）等组件。同样，**方向光**GameObject具有如**变换**和**灯光**等组件，这些组件决定了灯光的类型、颜色和强度，以及其他属性。
- en: Other examples of components include **Rigidbody** for incorporating physics-based
    behavior, **AudioSource** for playing sounds, and **Particle System** for crafting
    visual effects such as fire, smoke, or magical spells. Each component fulfills
    a unique function and significantly influences your game world and its interactions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其他组件的例子包括用于引入基于物理行为的**刚体**，用于播放声音的**音频源**，以及用于制作如火焰、烟雾或魔法咒语等视觉效果**粒子系统**。每个组件都执行独特的功能，并显著影响你的游戏世界及其交互。
- en: As we progress through this book, we will explore and utilize an array of essential
    components, starting with the next section, where we breathe life into our initial
    basic scene.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们这本书的进展，我们将探索和利用一系列基本组件，从下一节开始，我们将为我们的初始基本场景注入生命。
- en: Creating a basic scene in Unity and adding objects
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中创建基本场景并添加对象
- en: In this section, we will walk you through constructing the scene depicted in
    *Figure 2**.4*, which integrates elements such as primitives, materials, prefabs,
    lighting, and imported assets.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何构建图*2**.4*中所示的场景，该场景集成了如原始形状、材质、预制件、光照和导入资源等元素。
- en: "![Figure 2.4 – \uFEFFThe basic scene we are going to create](img/B20869_02_04.jpg)"
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 我们将要创建的基本场景](img/B20869_02_04.jpg)'
- en: Figure 2.4 – The basic scene we are going to create
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 我们将要创建的基本场景
- en: By engaging with this step-by-step tutorial, you will develop a strong knowledge
    of these core concepts while assembling an aesthetically striking scene. Our initial
    task involves crafting a table using primitive shapes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参与这个逐步教程，你将在组装一个美观的场景的同时，对这些核心概念有一个深入的了解。我们的初始任务包括使用原始形状制作一个表格。
- en: Building a table with primitives
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用原始形状构建桌子
- en: Primitives, as the name suggests, are simple geometric shapes that form the
    building blocks for more complex models in our scene. Imagine a chair taking shape
    as a cube forms the seat, two cylinders become the sturdy legs, and two more cylinders
    morph into supportive back legs. The backrest is crafted from a plane, its size
    and placement perfectly complementing the seat and legs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，原始形状是简单的几何形状，它们构成了我们场景中更复杂模型的构建块。想象一把椅子逐渐成形，一个立方体形成座位，两个圆柱体成为坚固的腿，另外两个圆柱体变成支撑的后腿。靠背是由一个平面制成的，其大小和位置完美地补充了座位和腿。
- en: A table for our scene can be crafted in a similar fashion—a cube takes center
    stage as the tabletop, while four cylinders rise up to serve as legs. Textures
    are applied, giving the tabletop and legs a lifelike appearance. The size and
    positioning of each primitive are adjusted, resulting in a table that looks like
    it was plucked from the real world.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的场景，可以用类似的方式制作一个桌子——一个立方体作为桌面，而四个圆柱体则作为腿。应用纹理，使桌面和腿看起来更加逼真。调整每个原始形状的大小和位置，结果是一个看起来像是从现实世界中摘取的桌子。
- en: To create the table, we recommend following the sequence illustrated in *Figure
    2**.5*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建桌子，我们建议遵循图*2**.5*中所示的操作顺序。
- en: "![Figure 2.5 – \uFEFFHow to use the Grid and Snap system](img/B20869_02_05.jpg)"
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 如何使用网格和吸附系统](img/B20869_02_05.jpg)'
- en: Figure 2.5 – How to use the Grid and Snap system
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 如何使用网格和吸附系统
- en: 'To build your table, go through the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建你的桌子，请按照以下步骤进行：
- en: Create a single table leg by introducing a cylinder to the scene. This can be
    achieved by right-clicking into the `0.05`, `0.2`, `0.05`) and position at (`0`,
    `0.2`, `0`).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将一个圆柱体引入场景来创建一个单独的桌腿。这可以通过在`0.05`, `0.2`, `0.05`)处右键单击并定位在(`0`, `0.2`, `0`)来实现。
- en: The table requires four identical legs. To achieve this, reproduce the original
    leg by copying (right-click on the object in the **Scene Hierarchy** window and
    click **Copy**) and pasting it three times. Fine-tune the positions of the duplicated
    legs based on the preceding reference image.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 桌子需要四条相同的腿。为了实现这一点，通过复制（在**Scene Hierarchy**窗口中右键单击对象并点击**Copy**）和粘贴三次来复制原始腿。根据前面的参考图像，根据需要调整复制腿的位置。
- en: Next, add a **Cube** primitive to the scene that will serve as the tabletop.
    Rescale and position the cube so that it rests on the table legs. To achieve the
    scaling and positioning more simply, shift to **Wireframe** mode, as shown in
    *Figure 2**.6*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向场景添加一个**Cube**原始对象，该对象将作为桌面。调整立方体的缩放和位置，使其 resting on the table legs。为了更简单地实现缩放和定位，切换到**Wireframe**模式，如图*图2**.6*所示。
- en: "![Figure 2.6 – \uFEFFHow to use Wireframe mode](img/B20869_02_06.jpg)"
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 如何使用线框模式](img/B20869_02_06.jpg)'
- en: Figure 2.6 – How to use Wireframe mode
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 如何使用线框模式
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Our advice here is to initially scale just the **Y** value and place the cube
    on top of the legs using the Grid and Snap system. Subsequently, you can shift
    your view from the scene to the top and modify the **Shading** mode from **Shaded**
    to **Wireframe**. This change reveals the cylinders and the cube, simplifying
    the task of scaling the **X** and **Z** values and positioning the **Cube** object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是首先仅缩放**Y**值，并使用网格和吸附系统将立方体放置在腿上。随后，您可以切换视图从场景到顶部，并将**Shading**模式从**Shaded**更改为**Wireframe**。这种更改揭示了圆柱体和立方体，简化了缩放**X**和**Z**值以及定位**Cube**对象的任务。
- en: To organize the table components, create a nested parent-child object hierarchy.
    First, assign appropriate names to the objects by renaming the `Table top` and
    the cylinders as their respective table legs. Subsequently, select all the legs
    (*cmd*/*Ctrl* + left-click). Click and drag them onto the `Table top` object in
    the `Table top` object, establishing a parent-child relationship.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要组织桌子组件，创建一个嵌套的父子对象层次结构。首先，通过重命名`Table top`和圆柱体为相应的桌子腿来为对象分配适当的名称。随后，选择所有腿（*cmd*/*Ctrl*
    + 左键点击）。点击并拖动它们到`Table top`对象中的`Table top`对象上，建立父子关系。
- en: To further refine the table structure, create an empty GameObject by selecting
    `Table`. Make the `Table top` object a child of the `Table` object. This results
    in a harmoniously structured table consisting of five interconnected primitives.
    With this arrangement, the table can be easily scaled and relocated without the
    need to individually select each GameObject.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进一步细化表格结构，通过选择`Table`创建一个空GameObject。将`Table top`对象设置为`Table`对象的子对象。这样，就得到了一个由五个相互连接的原始对象组成的和谐结构的桌子。使用这种布局，可以轻松地缩放和移动桌子，无需单独选择每个GameObject。
- en: To complete the scene, place a sphere primitive named `Table` object. You can
    use the Grid and Snap techniques discussed earlier for this. For a more refined
    look, feel free to scale the sphere to your liking. In the following section,
    we will enhance the appearance of both the `Table` and **Sphere** objects using
    materials.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成场景，放置一个名为`Table`的球体原始对象。您可以为此使用前面讨论过的网格和吸附技术。为了获得更精致的外观，您可以自由地缩放球体。在下一节中，我们将使用材质增强`Table`和**Sphere**对象的外观。
- en: Changing the appearance of the ground, table, and sphere
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何更改地面、桌子和球体的外观
- en: 'Up to this point, the scene consists of a ground and a table with a sphere
    placed on it, all displaying the standard gray color. Let’s enhance this by creating
    a new red material for the sphere through the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，场景由一个地面和一个桌子组成，球体放在桌子上，所有这些都显示标准的灰色。让我们通过以下步骤创建一个新的红色材质来增强球体的外观：
- en: Navigate to the `Materials` folder in the `Assets` | `Materials`).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Assets` | `Materials`中的`Materials`文件夹。
- en: Click on the `Red Material`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Red Material`。
- en: Select the white square adjacent to the **Base Map** field in the **Inspector**
    window. This action will launch the **Color** window. Select the **#FF0000** hex
    code.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口中，选择**Base Map**字段旁边的白色方块。此操作将启动**Color**窗口。选择**#FF0000**十六进制代码。
- en: Now, you can apply the `Red Material` material by dragging and dropping it on
    top of the **Sphere** object.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过将`Red Material`材质拖放到**Sphere**对象上方来应用该材质。
- en: Now, the sphere should appear in red. So far, we have used the simplest form
    of a material to apply a simple red color to a sphere geometry.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，球体应该呈现红色。到目前为止，我们已经使用了最简单的材质形式，将简单的红色应用到球体几何形状上。
- en: When creating materials for objects in a 3D game or application, it’s often
    necessary to add additional details and depth to the surface of the object beyond
    what can be achieved with just a single texture. This is where maps such as base
    maps, metallic maps normal maps, height maps, and occlusion maps come in.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建3D游戏或应用程序中的物体材质时，通常需要在物体表面添加额外的细节和深度，而不仅仅是使用单个纹理所能达到的。这就是基础地图、金属地图、法线地图、高度地图和遮挡地图等地图发挥作用的地方。
- en: 'Let us get to know each of these maps, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次了解这些地图：
- en: '`Red Material` material) or we can assign a texture (such as a picture of a
    brick wall) that defines the color and pattern of an object’s surface.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将材质指定为**红色材质**（Red Material）或者我们可以分配一个纹理（例如砖墙的图片）来定义物体表面的颜色和图案。
- en: '**Metallic Map**: A Metallic Map defines the extent to which an object’s surface
    should appear to be metallic, with areas of the map that are white appearing highly
    metallic, and areas that are black appearing non-metallic.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金属地图**：金属地图定义了物体表面看起来应该是金属的程度，地图中白色区域看起来非常金属，而黑色区域看起来非金属。'
- en: '**Normal Map**: A Normal Map is a type of texture that defines the surface
    normal vectors of an object, giving the illusion of additional depth and detail
    on the surface. Normal Maps are often used to create the appearance of bumps,
    dents, and other small details on an object’s surface, without adding extra geometry.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线地图**：法线地图是一种纹理，定义了物体的表面法线向量，给表面带来额外的深度和细节的错觉。法线地图通常用于在物体的表面上创建凹凸、坑洼和其他小细节的外观，而不需要添加额外的几何形状。'
- en: '**Height Map**: A Height Map is a black-and-white image that defines the height
    of an object’s surface. Height Maps are used to create the appearance of depth
    and relief on a surface, such as mountains and valleys on a terrain or the ridges
    and valleys of a fingerprint.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度地图**：高度地图是一种黑白图像，定义了物体表面的高度。高度地图用于在表面上创建深度和立体感，例如地形上的山脉和山谷或指纹的脊和谷。'
- en: '**Occlusion Map**: An Occlusion Map is a texture that defines which parts of
    an object are occluded, or hidden, from view. Occlusion Maps are used to create
    the appearance of shadows and ambient occlusion, giving objects a more grounded,
    realistic look by making them appear to cast shadows and have depth.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡地图**：遮挡地图是一种纹理，定义了物体的哪些部分被遮挡或隐藏在视线之外。遮挡地图用于创建阴影和环境遮挡的效果，通过使物体看起来能够投射阴影和具有深度，从而让物体看起来更加真实和有质感。'
- en: To visualize these maps, imagine a piece of paper with a picture of a wall painted
    on it. The **Base Map** would be the paint on the wall, the **Normal Map** would
    add the appearance of bumps and dents to the surface, the **Height Map** would
    create the appearance of depth and relief, and the **Occlusion Map** would add
    the appearance of shadows. When these maps are combined, they can create a much
    more detailed and believable representation of a wall. You may have noticed that
    this example did not cover the **Metallic Map**. You do not have to use all of
    the maps for a material. The choice of which maps to use depends on the desired
    appearance of the material and the level of detail you want to achieve. For example,
    a simple material for a flat, single-colored object may only require a **Base
    Map** (or albedo color) to define its appearance. A more complex material, such
    as a metal object with intricate details, might require a **Base Map**, **Normal
    Map**, **Height Map**, and **Metallic Map** to achieve the desired look.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这些地图，想象一张画有墙壁图片的纸张。**基础地图**将是墙上的油漆，**法线地图**将为表面添加凹凸感，**高度地图**将创造出深度和立体感，而**遮挡地图**将添加阴影效果。当这些地图结合在一起时，它们可以创建一个更加详细和逼真的墙壁表示。你可能已经注意到这个例子没有涵盖**金属地图**。你不需要为一种材质使用所有这些地图。选择使用哪些地图取决于所需的材质外观和想要达到的细节程度。例如，一个简单材质的平面单色物体可能只需要一个**基础地图**（或反照率颜色）来定义其外观。一个更复杂的材质，如具有复杂细节的金属物体，可能需要一个**基础地图**、**法线地图**、**高度地图**和**金属地图**来实现期望的外观。
- en: Creating maps can be a complex and time-consuming task, especially for intricate
    objects. To save time and effort, it’s often best to utilize pre-made materials
    or models from marketplaces such as the **Unity Asset Store**, **ArtStation**,
    and **Sketchfab**. These sites offer a wealth of free content to choose from.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建地图可能是一个复杂且耗时的工作，尤其是对于复杂的物体。为了节省时间和精力，通常最好利用市场上现成的材质或模型，例如**Unity Asset Store**、**ArtStation**和**Sketchfab**。这些网站提供了丰富的免费内容供选择。
- en: 'In our sample scene, we have a variety of pre-made materials available. Let’s
    use a wooden material for the tabletop. Here’s what you need to do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，我们有各种预制的材质可供使用。让我们为桌面使用木质材质。以下是您需要做的：
- en: Open the `Materials` folder (`Assets` | `ExampleAssets` | `Materials`).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Materials`文件夹（`Assets` | `ExampleAssets` | `Materials`）。
- en: Search for the **OBS_Mat** material and drag it onto the top of the table.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索**OBS_Mat**材质并将其拖放到桌面的顶部。
- en: Now, the tabletop should exhibit a wooden texture, as illustrated in *Figure
    2**.7*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，桌面应该显示出木质纹理，如图*图2.7*所示。
- en: "![Figure 2.7 – \uFEFFThe table top with its wooden texture](img/B20869_02_07.jpg)"
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 带有木质纹理的桌面](img/B20869_02_07.jpg)'
- en: Figure 2.7 – The table top with its wooden texture
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 带有木质纹理的桌面
- en: Upon examining the surface inputs in the **Inspector** window, the wooden material
    consists of a base map, metallic map, normal map, and occlusion map. To preview
    each map, *cmd*/*Ctrl* + left-click the corresponding squares next to the maps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中检查表面输入，木质材质包括基础图、金属图、法线图和遮挡图。要预览每个图，请*cmd*/*Ctrl* + 左键单击图旁边的相应方块。
- en: Let’s also choose an appropriate material for the ground. In the `Materials`
    folder (`Assets` | `ExampleAssets` | `Materials`) and search for the **Ground_Mat**
    material. Drag it onto the ground, and the surface should now appear more realistic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也为地面选择一个合适的材质。在`Materials`文件夹（`Assets` | `ExampleAssets` | `Materials`）中搜索**Ground_Mat**材质。将其拖放到地面上，现在表面应该看起来更加逼真。
- en: Next, you will learn how to create a brick wall material in the scene.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何在场景中创建砖墙材质。
- en: Creating a brick wall material
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建砖墙材质
- en: In the previous sections, we explored the application of a red albedo color
    to a sphere and utilized more advanced materials for the ground and table. It’s
    worth noting that materials play a crucial role in determining how a surface is
    rendered, encompassing not only the textures of an object’s surface but also its
    interaction with light sources.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了将红色漫反射颜色应用于球体以及使用更高级的材质为地面和桌子。值得注意的是，材质在确定表面渲染方式方面起着至关重要的作用，它不仅包括物体表面的纹理，还包括它与光源的交互。
- en: A texture is an image that is applied to a 3D model or a 2D surface to add detail
    or color. It can be thought of as skin that covers the surface of an object to
    give it a specific look or feel. Textures can be created within Unity or imported
    from external image files and then assigned to materials that are applied to GameObjects
    in a scene. This technique enhances the level of detail and realism in the rendered
    object.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理是应用于3D模型或2D表面以添加细节或颜色的图像。它可以被视为覆盖在物体表面的皮肤，以赋予它特定的外观或感觉。纹理可以在Unity中创建或从外部图像文件导入，然后分配给场景中GameObject应用的材质。这种技术增强了渲染对象的细节和真实感。
- en: 'In this section, we will delve into the process of creating and applying a
    more sophisticated material by developing a brick wall material and applying it
    to a wall constructed from a transformed cube. Follow these steps to get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过开发砖墙材质并将其应用于由变换后的立方体构建的墙壁，深入了解创建和应用更复杂材质的过程。按照以下步骤开始：
- en: Let’s start by creating a wall by inserting a new cube into the scene, renaming
    it `Wall`, scaling it to (`2`, `1`, `0.1`), and positioning it at (`0.2`, `0.5`,
    `1.8`) behind the table.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在场景中插入一个新的立方体来创建墙壁，将其重命名为`Wall`，将其缩放为（`2`，`1`，`0.1`），并将其定位在（`0.2`，`0.5`，`1.8`）在桌子后面。
- en: Navigate to the `Assets` folder in the `Textures`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Textures`中的`Assets`文件夹。
- en: To give the `Wall` cube a brick-like appearance, download and utilize the `BrickWall.jpg`
    texture file that is provided in this book’s GitHub repository, or find a suitable
    brick wall texture through an online search. Import the image into the newly created
    `Textures` folder. This can be accomplished by simply dragging the image from
    your local filesystem and dropping it into the corresponding Unity folder.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使`Wall`立方体呈现出砖块般的外观，请下载并使用本书GitHub仓库中提供的`BrickWall.jpg`纹理文件，或者通过在线搜索找到合适的砖墙纹理。将图像导入新创建的`Textures`文件夹。这可以通过简单地从您的本地文件系统拖动图像并将其放入相应的Unity文件夹中完成。
- en: Staying in the `Materials` folder. Here, generate a new material and rename
    it `Brick_Mat`. You can create the material by right-clicking within the folder,
    selecting **Create**, and then choosing **Material**.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持处于`Materials`文件夹中。在这里，生成一个新的材质并将其重命名为`Brick_Mat`。您可以通过在文件夹内右键单击，选择**创建**，然后选择**材质**来创建材质。
- en: With the `Brick_Mat` material selected, navigate to the **Inspector** window.
    Look for the small *torus symbol* situated adjacent to the **Base Map** field
    and select it. Proceed to search for and select the imported **BrickWall** image.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`Brick_Mat`材质后，导航到**检查器**窗口。寻找位于**基础贴图**字段旁边的较小**环状符号**并选择它。然后继续搜索并选择导入的**BrickWall**图像。
- en: The final step involves moving the `Brick_Mat` material from the `Wall` cube
    present in the **Scene** window. This can be achieved via a simple drag and drop
    maneuver.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将`Brick_Mat`材质从**场景**窗口中现有的`Wall`立方体移动出来。这可以通过简单的拖放操作完成。
- en: With these steps, your scene should now look similar to the one shown in *Figure
    2**.8*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您的场景现在应该看起来与图*2.8*中所示相似。
- en: "![Figure 2.8 – \uFEFFThe brick wall in the scene](img/B20869_02_08.jpg)"
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 场景中的砖墙](img/B20869_02_08.jpg)'
- en: Figure 2.8 – The brick wall in the scene
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 场景中的砖墙
- en: 'You have now witnessed the prowess of materials in transforming a scene’s realism.
    In the next section, we will learn about another important component of any Unity
    scene in more detail: prefabs.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经见证了材质在转换场景真实感方面的能力。在下一节中，我们将更详细地了解Unity场景的另一个重要组件：预制件。
- en: Unpacking a prefab
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包预制件
- en: In this section, we will learn how to convert a prefab from the sample scene
    into a regular GameObject in Unity. Prefabs are reusable, prefabricated objects
    that can be utilized multiple times within a scene, acting like building blocks
    for your environment. They are master copies of objects saved in separate files,
    allowing you to create multiple instances and streamline scene management.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将样本场景中的预制件转换为Unity中的普通GameObject。预制件是可重复使用的预制对象，可以在场景中多次使用，类似于构建环境的积木。它们是保存在单独文件中的对象的副本，允许您创建多个实例并简化场景管理。
- en: To import a prefab, navigate to the `Assets` | `ExampleAssets` | `Prefabs`.
    Drag and drop the **ConstructionLight_Low** object from the **Scene Hierarchy**
    window into the scene. In the **Scene Hierarchy** window, you’ll notice a blue
    cube icon, indicating it is a prefab instance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入预制件，导航到`Assets` | `ExampleAssets` | `Prefabs`。将**场景层次结构**窗口中的**ConstructionLight_Low**对象拖放到场景中。在**场景层次结构**窗口中，您会注意到一个蓝色立方体图标，表示它是一个预制件实例。
- en: We’ll now unpack the **ConstructionLight_Low** object to turn it into a regular
    GameObject. Right-click in the **Scene Hierarchy** window and select **Prefab**
    | **Unpack**. This way, modifications to the prefab won’t affect the unpacked
    instance. Go ahead and position it in front of the brick wall.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解包**ConstructionLight_Low**对象，将其转换为普通GameObject。在**场景层次结构**窗口中右键单击并选择**预制件**
    | **解包**。这样，对预制件的修改不会影响解包实例。请将其放置在砖墙前面。
- en: 'It’s important to remember that using prefabs in Unity is advantageous in various
    scenarios, such as the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在Unity中使用预制件在各种场景中都有优势，例如以下情况：
- en: '**Repeating GameObjects**: Save time and effort by creating an object once,
    converting it into a prefab, and duplicating it as needed'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复的游戏对象**：通过一次创建一个对象，将其转换为预制件，并在需要时进行复制，可以节省时间和精力'
- en: '**Customizing GameObjects**: Manage customizations more efficiently with a
    prefab containing all possible modifications, adjusting instances as required'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义游戏对象**：使用包含所有可能修改的预制件，更有效地管理自定义，根据需要调整实例'
- en: '**Modular game design**: Facilitate a modular design by creating prefabs for
    individual-level components and assembling them into a complete level'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化游戏设计**：通过为单个级别组件创建预制件并将它们组装成完整级别，促进模块化设计'
- en: Using prefabs in Unity helps save time, manage complex GameObjects, and support
    an adaptable, modular game design. Next, we’ll discuss how to import assets from
    the Unity Asset Store.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中使用预制件有助于节省时间、管理复杂GameObject以及支持可适应的模块化游戏设计。接下来，我们将讨论如何从Unity资产商店导入资产。
- en: Importing from the Unity Asset Store
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Unity资产商店导入
- en: Let’s learn how to import and use models available on the Asset Store. The Unity
    Asset Store is a marketplace where users can find, purchase, and download a variety
    of assets, including 3D models, animations, audio, visual effects, and more, to
    use in their Unity projects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何导入和使用资产商店中可用的模型。Unity资产商店是一个市场，用户可以在此处找到、购买和下载各种资产，包括3D模型、动画、音频、视觉效果等，用于他们的Unity项目。
- en: 'Here’s how to import a spotlight model from the Asset Store:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从资产商店导入聚光灯模型的方法：
- en: Open your preferred web browser and navigate to the Unity Asset Store at [https://assetstore.unity.com/](https://assetstore.unity.com/).
    Here, input `Spotlight and Structure` in the search bar. Alternatively, you can
    directly access the package page via [https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453](https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453).
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你喜欢的网络浏览器，导航到Unity资产商店[https://assetstore.unity.com/](https://assetstore.unity.com/)。在这里，在搜索栏中输入`Spotlight
    and Structure`。或者，你可以直接通过[https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453](https://assetstore.unity.com/packages/3d/props/interior/spotlight-and-structure-141453)访问包页面。
- en: Once you have added the package to your assets, look for the **Open in Unity**
    button and click on it.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将包添加到你的资产中，寻找**在Unity中打开**按钮并点击它。
- en: The Unity application should open with a prompt to import the package. Proceed
    with the **Import** operation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity应用应该会打开，提示导入包。进行**导入**操作。
- en: Upon successful import, navigate to the package’s directory in the `Assets`
    | `SpaceZeta_Spotlight` | `Assets`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功导入后，导航到`Assets` | `SpaceZeta_Spotlight` | `Assets`目录下的包目录。
- en: Drag the `Spotlight.fbx` and `SpotlightStructure1.fbx` files into the scene
    and unpack them (right-click, then select **Prefab** | **Unpack**).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Spotlight.fbx`和`SpotlightStructure1.fbx`文件拖入场景并解包（右键单击，然后选择**预制体** | **解包**）。
- en: If the objects appear magenta, this typically signifies that the associated
    materials are either absent or incompatible with the render pipeline currently
    in use. To fix this, select **Spotlight** and change the shader to **Universal
    Render Pipeline** | **Lit** in the **Inspector** window.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体呈现品红色，这通常表明相关的材料要么不存在，要么与当前使用的渲染管线不兼容。要解决这个问题，请在**检查器**窗口中选择**聚光灯**，并将着色器更改为**通用渲染管线**
    | **Lit**。
- en: If your `Spotlight_basecolor.png`, `Spotlight_roughness.png`, `Spotlight_normal.png`,
    and `Spotlight_emission.png` files.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`Spotlight_basecolor.png`、`Spotlight_roughness.png`、`Spotlight_normal.png`和`Spotlight_emission.png`文件。
- en: Now, your `BrickWallLight` and `BrickWallLightStructure` and transform them
    according to what is shown in *Figure 2**.9*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据*图2.9*所示，将你的`BrickWallLight`和`BrickWallLightStructure`进行变换。
- en: "![Figure 2.9 – \uFEFFThe imported BrickWallLight model and its BrickWallLightStructure\
    \ model](img/B20869_02_09.jpg)"
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 导入的BrickWallLight模型及其BrickWallLightStructure模型](img/B20869_02_09.jpg)'
- en: Figure 2.9 – The imported BrickWallLight model and its BrickWallLightStructure
    model
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 导入的BrickWallLight模型及其BrickWallLightStructure模型
- en: You can use the same procedure to find and import other 3D models, animations,
    audio, and visual effects that you need for your scene. In line with the `BrickWallLight`
    model that was imported just now, the next section deals with the most crucial
    aspects of lighting.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的程序来查找和导入你场景所需的其它3D模型、动画、音频和视觉效果。与刚刚导入的`BrickWallLight`模型一致，下一节将处理照明的最关键方面。
- en: Understanding Unity’s lighting pipeline
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Unity的照明管线
- en: A crucial aspect to consider before implementing your project is planning the
    lighting. Here, we present a proven approach that has consistently delivered exceptional
    lighting in a wide array of XR projects over the years, closely aligning with
    Unity’s best practice lighting pipeline ([https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html](https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html)).
    This process consists of three primary steps, as shown in *Figure 2**.10*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施项目之前考虑的一个关键方面是规划照明。在这里，我们介绍了一种经过验证的方法，这种方法多年来一直在各种XR项目中提供了卓越的照明效果，并与Unity的最佳实践照明管线紧密一致([https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html](https://docs.unity3d.com/Manual/BestPracticeLightingPipelines.html))。此过程包括三个主要步骤，如*图2.10*所示。
- en: "![Figure 2.10 – \uFEFFUnity’s best practice lighting pipeline](img/B20869_02_10.jpg)"
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – Unity的最佳实践照明管线](img/B20869_02_10.jpg)'
- en: Figure 2.10 – Unity’s best practice lighting pipeline
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – Unity的最佳实践照明管线
- en: The selection of an appropriate render pipeline for your project is your initial
    step of the overall lighting pipeline process. As noted in *Table 2.1*, we recommend
    using URP for XR projects, which establishes the groundwork for effective lighting.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的项目选择合适的渲染管线是整体照明管线流程的第一步。如*表2.1*中所述，我们建议对于XR项目使用URP，这为有效的照明奠定了基础。
- en: The second step of the lighting pipeline is to determine how **indirect lighting**
    should be generated by selecting a suitable **Global Illumination (GI) system**
    and corresponding **lighting mode**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 照明管道的第二步是通过选择合适的**全局照明（GI）系统**和相应的**照明模式**来确定如何生成**间接照明**。
- en: Think about a room with a single window on a sunny day. The direct light is
    like the bright sunlight that’s coming straight into the room through the window—it’s
    the light you would feel directly on your skin if you stood in the path of the
    window. That’s similar to what we mean by direct lighting in Unity.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在一个阳光明媚的日子里，只有一个窗户的房间。直射光就像通过窗户直接进入房间的明亮阳光——如果你站在窗户的路径上，这就是你直接感受到的光。这与我们在Unity中说的直射光类似。
- en: Now, look at the corners of the room or the parts not directly in front of the
    window. They aren’t in complete darkness, right? They’re lit up, but not as brightly.
    That’s because the sunlight coming in hits different surfaces—the floor, walls,
    or furniture—and bounces off to these parts. This is what we refer to as indirect
    lighting.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看房间的角落或不在窗户正前方的地方。它们并不是完全黑暗的，对吧？它们被照亮了，但不是那么明亮。这是因为进入的阳光击中了不同的表面——地板、墙壁或家具——并反射到这些部分。这就是我们所说的间接照明。
- en: The GI system in Unity mimics the rules of how light bounces around in the room.
    It’s the system that calculates how much light gets to the darker parts of the
    room based on how much it reflects off the surfaces it hits.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的GI系统模仿了光线在房间中反弹的规则。它是计算光线根据其击中表面的反射量到达房间较暗部分的系统。
- en: Lastly, the lighting mode in Unity is akin to choosing what kind of surfaces
    you have in the room. Is it a shiny, reflective marble floor or a dark, matte
    wood floor? Depending on what you choose, the light would bounce off differently
    and light up the room in a unique way. This is what the lighting mode controls—it
    determines how the light interacts with different surfaces to create the overall
    lighting effect in your game scene.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Unity中的照明模式类似于选择房间中的表面类型。是光滑、反光的 marble 地板还是暗淡、哑光的木地板？根据您的选择，光线会以不同的方式反射并以独特的方式照亮房间。这就是照明模式控制的内容——它决定了光线如何与不同的表面相互作用，以在游戏场景中创建整体照明效果。
- en: With the GI settings tailored to your project’s requirements, it’s time to unleash
    your artistic vision. The last step of the lighting pipeline is to integrate lights,
    emissive surfaces, reflection probes, and light probes to harmoniously weave your
    scene’s illumination. By following this approach, you will construct a cohesive
    and detailed lighting environment, enhancing the realism and engagement of your
    virtual space and ensuring a high-quality user experience.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据GI设置调整到您项目的需求，现在是时候释放您的艺术想象力了。照明管道的最后一步是将灯光、发射表面、反射探针和灯光探针整合到您的场景中，以和谐地编织场景的照明。通过遵循这种方法，您将构建一个统一且详细的照明环境，增强虚拟空间的真实感和参与度，并确保高质量的用户体验。
- en: Now, it is time to implement the steps of the lighting pipeline into our scene.
    With URP already chosen for your project, let’s proceed to the second phase of
    the lighting pipeline. Here, we’ll focus on understanding and selecting the appropriate
    lighting settings for your scene. This crucial step ensures your virtual world
    is lit effectively.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将照明管道的步骤应用到我们的场景中了。由于URP已经为您的项目选择，让我们继续到照明管道的第二阶段。在这里，我们将专注于理解和选择适合您场景的适当照明设置。这一关键步骤确保您的虚拟世界得到有效的照明。
- en: Choosing the right lighting settings
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的照明设置
- en: As you’ve selected URP for your XR project, the next task is configuring indirect
    lighting. This process entails choosing a suitable GI system and lighting mode.
    **GI** imitates indirect light in 3D environments, leading to soft shadows and
    a natural appearance as light bounces between objects and surfaces. Unity’s lighting
    mode options present a variety of settings, each balancing visual quality and
    performance differently.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已为您的XR项目选择了URP，接下来的任务是配置间接照明。这个过程包括选择一个合适的GI系统和照明模式。**GI**模仿3D环境中的间接光，导致柔和的阴影和自然的外观，因为光线在物体和表面之间反弹。
- en: For simple mobile XR scenes, the most performant option is **Subtractive** mode,
    which relies on pre-calculated lightmaps to minimize **GPU** load and boost performance.
    **Shadowmask** mode follows closely, offering **real-time lighting** and baked
    shadows for static objects, striking a balance between visual quality and performance
    by reducing GPU load with pre-calculated shadows. Alternatively, **Baked Indirect
    Lighting** mode provides an ideal mix of real-time lighting, shadowing, and baked
    indirect lighting for high-quality XR visuals.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的移动XR场景，**减法模式**是最具性能的选项，它依赖于预先计算的光图来最小化**GPU**负载并提高性能。**阴影遮罩**模式紧随其后，提供**实时照明**和静态对象的烘焙阴影，通过减少GPU负载并使用预先计算阴影来在视觉效果和性能之间取得平衡。另外，**烘焙间接照明**模式提供了实时照明、阴影和烘焙间接照明的理想组合，适用于高质量的XR视觉效果。
- en: To set up indirect lighting, navigate to `Assets` folder, where it can be renamed.
    We suggest choosing **Mixed Lighting** by default, enabling the **Baked Global
    Illumination** option in the **Lighting** settings window. For the lighting mode,
    **Shadowmask** is the optimal choice for its balance between quality and performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置间接照明，导航到`Assets`文件夹，其中可以重命名。我们建议默认选择**混合照明**，在**照明**设置窗口中启用**烘焙全局照明**选项。对于照明模式，**阴影遮罩**在质量和性能之间提供了最佳平衡。
- en: Tip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Though **Baked Global Illumination** permits automatic lightmap generation,
    we advise against it. Instead, manually generate lightmaps before testing the
    scene or after implementing changes as it provides the flexibility to test different
    lighting scenarios and iterate on your design without the overhead of constant
    automatic updates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**烘焙全局照明**允许自动生成光图，但我们建议不要这样做。相反，在测试场景或实施更改后手动生成光图，因为它提供了测试不同照明场景和迭代设计的灵活性，而无需承受不断自动更新的开销。
- en: With that settled, you can proceed to place light objects within your scene.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定这些之后，你可以继续在你的场景中放置光源对象。
- en: Adding lights and a skybox
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加光源和天空盒
- en: '**Light objects** in Unity are an essential part of creating an immersive and
    believable environment. There are several different light objects to choose from,
    including Point Lights, Spot Lights, Directional Lights, and Area Lights. They
    can be categorized under **direct lighting**, which refers to the light that is
    emitted directly from a light source. Let’s take a closer look at each light object.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unity中的轻量级对象**是创建沉浸式和逼真环境的重要组成部分。你可以选择多种不同的光源对象，包括点光源、聚光灯、方向光和区域光。它们可以被归类为**直接照明**，这指的是直接从光源发出的光线。让我们更详细地看看每种光源对象。'
- en: '**Point Lights** emit light uniformly from a single point, ideal for localized
    sources such as lamps and candles. **Spot Lights** project light in a conical
    shape, perfect for directional sources such as flashlights and headlights. **Directional
    Lights** cast light in a single direction, resembling the sun or moon, while **Area
    Lights** disperse light from a specific area, akin to ceiling light panels.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**点光源**从单个点均匀地发出光线，非常适合局部光源，如灯具和蜡烛。**聚光灯**以圆锥形投射光线，非常适合方向光源，如手电筒和车灯。**方向光**以单一方向投射光线，类似于太阳或月亮，而**区域光**从特定区域散布光线，类似于天花板灯板。'
- en: Each light type has unique properties, and when combined, they can produce diverse
    lighting effects. Comprehending these light types is key to achieving effective
    lighting in Unity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每种光源类型都有其独特的属性，当它们组合在一起时，可以产生不同的照明效果。理解这些光源类型是实现Unity中有效照明的关键。
- en: Let's start by selecting the **Directional Light** GameObject in the **Scene
    Hierarchy** window and unchecking the checkbox at the top of its **Inspector**
    window. You’ll observe its substantial influence on the scene’s illuminance. However,
    you might be curious why the scene remains brighter than anticipated—the reason
    lies in the active **skybox**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**场景层次结构**窗口中选择**方向光**GameObject，并在其**检查器**窗口顶部取消勾选复选框。你会观察到它对场景照明的显著影响。然而，你可能好奇为什么场景比预期的更亮——原因在于激活的**天空盒**。
- en: In Unity, a skybox serves as a backdrop that surrounds the scene, imparting
    a sense of environment and depth, similar to the sky and surrounding landscape
    in real life. A skybox is created using a specific material applied to a large
    cube that encloses the scene, consistently appearing behind all other elements.
    This cube generates the illusion of a sky and environment extending beyond the
    scene’s actual boundaries.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，天空盒充当场景的背景，环绕场景，赋予环境感和深度，类似于现实生活中的天空和周围景观。天空盒是通过将特定材质应用于包围场景的大立方体来创建的，这个立方体始终出现在所有其他元素之后。这个立方体产生了天空和环境延伸到场景实际边界之外的错觉。
- en: Skyboxes play a crucial role in indirect lighting, as they impact the scene’s
    overall lighting ambiance. For instance, a bright sky with a blazing sun casts
    warm light over the scene, fostering a welcoming and inviting atmosphere. Conversely,
    a dark sky featuring a full moon casts cool, blue light over the scene, cultivating
    a more eerie and mysterious mood. Other examples of indirect lighting in Unity
    encompass GI, ambient light, and lightmaps, which all contribute to the final
    visual experience.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 天空盒在间接照明中扮演着至关重要的角色，因为它们影响场景的整体照明氛围。例如，晴朗的天空和炽热的太阳在场景上投射出温暖的光线，营造出欢迎和邀请的氛围。相反，一个有满月的天空投射出凉爽的蓝色光线，营造出更加诡异和神秘的氛围。Unity中其他间接照明的例子包括全局光照（GI）、环境光和光照贴图，它们都为最终的视觉体验做出了贡献。
- en: 'Let''s create and apply a totally dark skybox, following these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤创建并应用一个完全黑暗的天空盒：
- en: To create a new material, navigate to the `Materials` folder within the **Project**
    window. Right-click and choose **Create** | **Material**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的材质，导航到**项目**窗口中的`Materials`文件夹。右键单击并选择**创建** | **材质**。
- en: Name the new material `DarkSkybox_Mat` and select it to see its properties in
    the **Inspector** window.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新材质命名为`DarkSkybox_Mat`并选择它，以在**检查器**窗口中查看其属性。
- en: Choose the shader type by going to **Skybox** | **Procedural** and keep the
    default settings.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**天空盒** | **程序化**来选择着色器类型，并保持默认设置。
- en: Drag the new **Skybox** material to the sky.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的**天空盒**材质拖放到天空上。
- en: Your scene should now resemble the one shown in *Figure 2**.11*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景现在应该类似于*图2.11*中所示的场景。
- en: "![Figure 2.11 – \uFEFFThe skybox applied to the scene](img/B20869_02_11.jpg)"
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 应用到场景中的天空盒](img/B20869_02_11.jpg)'
- en: Figure 2.11 – The skybox applied to the scene
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 应用到场景中的天空盒
- en: Now, you can see that the elements in the scene are only visible because of
    the activated spotlight emanating from the **ConstructionLightLow** object. Since
    the influences of indirect lighting conditions have been eliminated, it is time
    to experiment with the remaining different light types.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到场景中的元素之所以可见，仅仅是因为从**ConstructionLightLow**对象发出的激活聚光灯。由于间接照明条件的影响已被消除，现在是时候尝试剩余的不同光照类型了。
- en: First, select the **Spot Light** child object of the **ConstructionLightLow**
    object and then go to the **Inspector** window. Here, change the light type to
    **Point**, which, while not entirely suitable for the construction light, will
    serve to illustrate the shift in behavior. A Point Light, you see, radiates its
    luminance in all directions, unlike the focused beam of a Spot Light.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择**ConstructionLightLow**对象的**Spot Light**子对象，然后转到**检查器**窗口。在这里，将光照类型更改为**点光源**，虽然它并不完全适合建筑灯光，但可以用来说明行为的变化。点光源，正如你所看到的，向所有方向辐射其亮度，与聚光灯的聚焦光束不同。
- en: Now, let us breathe life into the imported `BrickWallLight` object. To do so,
    add an empty child object to its existing child object. Rename it `Light` and
    proceed by selecting `Light`. With **Spot** as the chosen type, you are free to
    adjust **Position**, **Color**, **Intensity**, and other parameters to your heart’s
    content. To witness the full extent of your creation’s influence, momentarily
    disable the **ConstructionLightLow** object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让导入的`BrickWallLight`对象充满生机。要做到这一点，向其现有的子对象添加一个空子对象。将其重命名为`Light`，然后选择`Light`。选择**聚光灯**作为类型后，你可以自由调整**位置**、**颜色**、**强度**和其他参数。为了见证你创作的影响的全貌，暂时禁用**ConstructionLightLow**对象。
- en: Finally, we have arrived at the last uncharted territory of light types—the
    Area Light. *Figure 2**.12* demonstrates the incorporation of an Area Light into
    our scene, elevating it to new heights of brilliance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了光照类型中的最后一个未知领域——区域光源。*图2.12*展示了将区域光源融入我们的场景，将其提升到新的亮度高度。
- en: "![Figure 2.12 – \uFEFFAn Area Light illuminating the scene](img/B20869_02_12.jpg)"
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 面光源照亮场景](img/B20869_02_12.jpg)'
- en: Figure 2.12 – An Area Light illuminating the scene
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate an Area Light in your scene, go through the following steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Add a `1.3`, `0.75`, `0.1` ), and change its **Position** and **Rotation** parameters
    so that it is approximately aligned with the white cube light shown in *Figure
    2**.12*.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the object `Cube Light`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty child object. Right-click and select `Area Light`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Light`. Now, you will find the option to change the light type to **Area
    (baked only)**. Temporarily extinguish all other sources of light within your
    scene by unchecking their respective checkboxes in the **Inspector** window. You
    may observe that the scene plunges into darkness, with the Area Light seemingly
    unable to fulfill its illuminating duties.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unity offers a duo of lighting systems: **real-time lighting** and **precomputed
    lighting**. Real-time lighting illuminates the scene dynamically, shifting with
    the player’s movements through the environment. In contrast, precomputed lighting
    calculates the scene’s luminance before the game commences, delivering a stable
    and optimized lighting experience. A third, hybrid mode known as mixed lighting
    combines the best of both worlds, allowing flexibility in determining which parts
    of the scene utilize real-time and precomputed lighting.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Area Lights only allow precomputed lighting, requiring us to first bake a lightmap
    and assign its **emissive surface** to the GameObjects illuminated by the light.
    Baking a lightmap involves pre-calculating lighting data and storing it in a texture,
    optimizing the scene’s lighting during runtime. Baking is a one-time process that’s
    repeated only when lighting conditions change.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: To start, identify the GameObjects affected by the `Area Light`, such as the
    `Wall` object and `Cube Light` object itself, and activate their **Static** checkboxes
    in the **Inspector** window. Next, bake the lightmap by navigating to **Window**
    | **Rendering** | **Lighting**, and switching to the **Baked Lightmaps** tab.
    Click on **Generate Lighting** to see the transformation.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Notice that only the `Wall` object appears to shine, while the `Cube Light`
    object doesn’t. This occurs because there’s no object to reflect its light, as
    with the `Ground` object below.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: To enhance the scene, focus on the `Ground`, `BrickWallLight`, `BrickWallLightStructure`
    objects and their respective children. Enable their **Static** checkboxes and
    bake the lightmap once more. Observe the transformation of your scene.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.13* highlights the difference when using emissive surfaces with
    Area Lights.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 2.13 – \uFEFFThe influence of emissive surfaces of an Area Light](img/B20869_02_13.jpg)"
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – The influence of emissive surfaces of an Area Light
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The left image of *Figure 2**.13* features only the wall and Area Light as emissive
    surfaces, while the right image includes multiple GameObjects, resulting in a
    more dynamic, visually engaging experience.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Let's reactivate the lights of the `BrickWallLight` and the **ConstructionLightLow**
    objects. By doing so, we embrace the principle of mixed lighting, merging the
    strengths of both real-time and precomputed lighting. As a result, the objects
    within our scene become illuminated in a harmonious blend.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新激活`BrickWallLight`和**ConstructionLightLow**对象的灯光。通过这样做，我们遵循混合光照的原则，结合了实时和预计算光照的优点。结果，场景中的对象以和谐的方式被照亮。
- en: As an XR developer, the choice of lighting is a reflection of your artistic
    vision and the demands of your scene. Real-time lighting captivates with its dynamism,
    precomputed lighting entrances with its stability, and mixed lighting enchants
    with its versatility. In the last section of this chapter, we’ll introduce light
    and reflection probes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名XR开发者，光照的选择反映了你的艺术视野和场景的需求。实时光照以其动态性吸引人，预计算光照以其稳定性著称，混合光照则以其多功能性迷人。在本章的最后部分，我们将介绍光照和反射探针。
- en: Exploring light and reflection probes
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索光照和反射探针
- en: Finally, let’s delve into **reflection probes** and **light probes** by revisiting
    our **SampleScene** object. To access it, navigate to **Assets** | **Scenes**
    in the **Project** window and double-click on the **SampleScene** object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过重新访问**SampleScene**对象来深入了解**反射探针**和**光照探针**。要访问它，请在**项目**窗口中导航到**资产**
    | **场景**，然后双击**SampleScene**对象。
- en: In Unity, reflection probes and light probes contribute to the creation of realistic
    lighting and reflections within a scene. Reflection probes capture reflection
    data from the surrounding environment and apply it to the scene’s objects. By
    capturing a 360-degree view of the environment and storing it as a cube map, reflection
    probes enable accurate reflections on reflective surfaces in the scene. For instance,
    if you want a shiny car in a game to reflect nearby trees and the sky, place a
    reflection probe near the car to gather environmental data and apply it to the
    car’s reflections.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，反射探针和光照探针有助于在场景中创建逼真的光照和反射效果。反射探针从周围环境中捕获反射数据并将其应用于场景中的对象。通过捕获环境的360度视图并将其存储为立方体贴图，反射探针能够在场景中的反射表面上实现精确的反射。例如，如果你想在游戏中让一辆闪亮的汽车反射附近的树木和天空，你可以在汽车附近放置一个反射探针来收集环境数据并将其应用于汽车的反射。
- en: Light probes, conversely, capture lighting data from the surrounding environment
    and apply it to the scene’s objects. By placing probes at various points in the
    scene, they gather lighting information and store it as a texture. This texture
    is then utilized to provide realistic lighting to objects in the scene. For example,
    if a character is standing in a forest, you could place light probes around the
    character to capture lighting information from the trees and apply it to the character’s
    skin.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，光照探针从周围环境中捕获光照数据并将其应用于场景中的对象。通过在场景中的不同位置放置探针，它们收集光照信息并将其存储为纹理。然后，这个纹理被用来为场景中的对象提供逼真的光照。例如，如果一个角色站在森林中，你可以在角色周围放置光照探针来捕获树木的光照信息并将其应用于角色的皮肤。
- en: Examining the **SampleScene** object in the **Scene Hierarchy** window, we can
    see it contains three reflection probes and a light probe group with numerous
    light probes. The images in *Figure 2**.14* showcase the appearance of selected
    reflection probes (left side) and light probes (right side).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景层次结构**窗口中检查**SampleScene**对象，我们可以看到它包含三个反射探针和一个包含多个光照探针的光照探针组。*图2.14*中的图像展示了所选反射探针（左侧）和光照探针（右侧）的外观。
- en: "![Figure 2.14 – \uFEFFReflection and light probes in the sample scene](img/B20869_02_14.jpg)"
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 样场景中的反射和光照探针](img/B20869_02_14.jpg)'
- en: Figure 2.14 – Reflection and light probes in the sample scene
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 样场景中的反射和光照探针
- en: Essentially, not using reflection probes and light probes in a scene may result
    in less realistic lighting and reflections. However, if your scene doesn’t feature
    highly reflective objects or if the lighting is mostly uniform, removing the probes
    might not create a noticeable difference in the final result. In the case of this
    **SampleScene** object, this could very well be true.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，在场景中不使用反射探针和光照探针可能会导致光照和反射效果不够真实。然而，如果你的场景中没有高度反光的物体，或者光照主要是均匀的，移除探针可能不会在最终结果中产生明显的差异。对于这个**SampleScene**对象来说，这种情况很可能成立。
- en: As demonstrated, reflection and light probes are potent tools for significantly
    enhancing a scene’s realism in Unity. Nevertheless, their use is not always required
    or discernible in simpler scenes, as Unity’s built-in lightmapping technology
    is adept at approximating lighting and reflections without resorting to probes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，反射和光照探针是显著增强Unity场景真实感的有力工具。然而，在简单的场景中，它们的使用并不总是必需或明显的，因为Unity内置的光照贴图技术擅长在没有探针的情况下近似光照和反射。
- en: With a grasp of these principles, you’re equipped to create immersive and visually
    captivating XR experiences.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些原则，你就有能力创建沉浸式和视觉上引人入胜的XR体验。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you constructed a fundamental scene, familiarized yourself
    with the Unity Editor, started learning how to import assets to your own project,
    and were introduced to the essential aspects of lighting.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个基本场景，熟悉了Unity编辑器，开始学习如何将资产导入到自己的项目中，并介绍了照明的关键方面。
- en: You embarked on this journey by installing Unity through the Unity Hub and establishing
    a new project with a sample scene using URP. You then explored the Unity Editor’s
    basics, such as navigating its numerous windows and utilizing the scene editing
    options, including Grid and Snap. Moreover, you delved into GameObjects and their
    components, such as colliders.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过Unity Hub安装Unity并使用URP创建一个带有示例场景的新项目开始了这段旅程。然后，你探索了Unity编辑器的基础，例如导航其众多窗口和利用场景编辑选项，包括网格和吸附。此外，你深入研究了GameObject及其组件，例如碰撞体。
- en: Subsequently, you crafted your very own rudimentary scene, complete with a ground
    plane, a brick wall, and a table supporting a sphere. Along the way, you discovered
    the potency of materials, applied some, and designed your own advanced brick wall
    material using an imported image as a texture. You also examined the usefulness
    of prefabs and learned how to transform them into regular GameObjects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，你制作了自己的基本场景，包括地面平面、砖墙和一个支撑球体的桌子。在这个过程中，你发现了材质的强大作用，应用了一些材质，并使用导入的图像作为纹理设计了你自己高级的砖墙材质。你还考察了预制件的有用性，并学习了如何将它们转换为常规GameObject。
- en: Furthermore, you grasped the importance of importing assets by searching for
    and importing a spotlight from the Asset Store, addressing potential issues that
    may arise due to render pipeline incompatibilities. Finally, you delved into the
    expansive subject of lighting, understanding, and implementing Unity’s best practices
    lighting pipeline within your basic scene. In doing so, you identified the ideal
    render pipeline, selected the right lighting settings, and experimented with various
    lights, including Point Lights, Spot Lights, Directional Lights, and Area Lights.
    You also employed skyboxes and became acquainted with light and reflection probes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你通过在资产商店中搜索并导入聚光灯来理解导入资产的重要性，解决了由于渲染管线不兼容可能出现的潜在问题。最后，你深入研究了照明、理解和实施Unity最佳实践照明管线的基本场景。在这个过程中，你确定了理想的渲染管线，选择了正确的照明设置，并试验了各种灯光，包括点光源、聚光灯、方向光源和区域光源。你还使用了天空盒，并熟悉了光照和反射探针。
- en: Building upon this solid foundation, you are now prepared to delve deeper into
    Unity and create increasingly complex and captivating scenes. In the next chapter,
    we will construct our first VR scene, deploy it, and test it on various VR headsets
    or simulators, further expanding your understanding and mastery of Unity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个坚实的基础之上，你现在准备深入Unity，创建越来越复杂和引人入胜的场景。在下一章中，我们将构建我们的第一个VR场景，部署它，并在各种VR头盔或模拟器上测试它，进一步扩展你对Unity的理解和掌握。
- en: Part 2 – Interactive XR Applications with Custom Logic, Animations, Physics,
    Sound, and Visual Effects
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 使用自定义逻辑、动画、物理、声音和视觉效果进行交互式XR应用
- en: After delving into the Unity Engine intricacies and exploring various XR technologies
    in the first part of this book, this part covers all the essentials of XR development,
    taking you from a beginner to an intermediate level. In this part, you’ll master
    the creation of your first VR and AR experiences, including deployment to different
    devices and testing without specific VR headsets or smartphones, using simulators.
    Once you have a solid understanding of creating and deploying basic XR scenes,
    you’ll progress to developing more advanced XR applications.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分深入Unity引擎的复杂性并探索各种XR技术之后，本部分涵盖了XR开发的全部基本要素，将你的技能从初学者提升到中级水平。在本部分中，你将掌握创建你的第一个VR和AR体验，包括将应用部署到不同设备，并使用模拟器进行测试，而无需特定的VR头盔或智能手机。一旦你对创建和部署基本的XR场景有了扎实的理解，你将进步到开发更高级的XR应用。
- en: You’ll add interactivity to your XR applications, utilizing no-code options
    such as button clicks, and delve into more complex logic by scripting in C#. While
    this part contains numerous coding segments, don’t worry – we’ll explain C# in
    a beginner-friendly manner. Additionally, you’ll discover how to enhance the realism
    of your XR scenes by incorporating sounds and particle effects, while ensuring
    these physical phenomena adhere to real-world physics laws.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为你的XR应用添加交互性，利用无代码选项，如按钮点击，并通过C#脚本深入更复杂的逻辑。虽然这部分包含许多代码片段，但请放心——我们将以初学者友好的方式解释C#。此外，你还将了解如何通过结合声音和粒子效果来增强你的XR场景的真实感，同时确保这些物理现象遵循现实世界的物理定律。
- en: 'This part contains the following chapters:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 3*](B20869_03.xhtml#_idTextAnchor009), *VR Development in Unity*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第3章*](B20869_03.xhtml#_idTextAnchor009)，*Unity中的VR开发*'
- en: '[*Chapter 4*](B20869_04.xhtml#_idTextAnchor011), *AR Development in Unity*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B20869_04.xhtml#_idTextAnchor011)，*Unity中的AR开发*'
- en: '[*Chapter 5*](B20869_05.xhtml#_idTextAnchor016), *Building Interactive VR Experiences*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B20869_05.xhtml#_idTextAnchor016)，*构建交互式VR体验*'
- en: '[*Chapter 6*](B20869_06.xhtml#_idTextAnchor020), *Building Interactive AR Experiences*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B20869_06.xhtml#_idTextAnchor020)，*构建交互式AR体验*'
- en: '[*Chapter 7*](B20869_07.xhtml#_idTextAnchor024), *Adding Sound and Visual Effects*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B20869_07.xhtml#_idTextAnchor024)，*添加声音和视觉效果*'
