["```cs\nprivate static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);\n\npublic override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }\n\n```", "```cs\n public override void Initialize(AnalysisContext context)\n {\n  context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n }\n\n private static void AnalyzeSymbol(SymbolAnalysisContext context)\n {\n   ...\n }\n\n```", "```cs\npublic class NestedClass\n{\n  public class InnerClass\n  {\n    public class NestedClass\n    {\n    }\n  }\n}\n\n```", "```cs\npublic override void Initialize(AnalysisContext context)\n{\n  context.RegisterSymbolAction(symbolContext =>\n  {\n    var symbolName = symbolContext.Symbol.Name;\n\n    // Skip the immediate containing type, CS0542 already covers this case.\n    var outerType = symbolContext.Symbol.ContainingType?.ContainingType;\n    while (outerType != null)\n    {\n      // Check if the current outer type has the same name as the given member.\n      if (symbolName.Equals(outerType.Name))\n      {\n        // For all such symbols, report a diagnostic.\n        var diagnostic = Diagnostic.Create(Rule, symbolContext.Symbol.Locations[0], symbolContext.Symbol.Name);\n        symbolContext.ReportDiagnostic(diagnostic);\n        return;\n      }\n\n      outerType = outerType.ContainingType;\n    }\n  },\n  SymbolKind.NamedType,\n  SymbolKind.Method,\n  SymbolKind.Field,\n  SymbolKind.Event,\n  SymbolKind.Property);\n}\n\n```", "```cs\nnamespace ClassLibrary\n{\n public class OuterClass\n {\n  public class NestedClass\n  {\n   public class NestedClass\n   {\n   }\n  }\n }\n}\n\n```", "```cs\nnamespace ClassLibrary\n{\n public class OuterClass\n {\n  public class NestedClass\n  {\n   public class InnerClass\n   {\n    public class NestedClass\n    {\n    }\n   }\n  }\n }\n}\n\n```", "```cs\ncontext.RegisterSymbolAction(symbolContext =>\n{\n ...\n},\nSymbolKind.NamedType,\nSymbolKind.Method,\nSymbolKind.Field,\nSymbolKind.Event,\nSymbolKind.Property);\n\n```", "```cs\n// Skip the immediate containing type, CS0542 already covers this case.\nvar outerType = symbolContext.Symbol.ContainingType?.ContainingType;\n\n```", "```cs\nwhile (outerType != null)\n{\n // Check if the current outer type has the same name as the given member.\n if (symbolName.Equals(outerType.Name))\n {\n  // For all such symbols, report a diagnostic.\n  ...\n }\n\n outerType = outerType.ContainingType;\n}\n\n```", "```cs\nint local1 = 0;\nClass1 local2 = new Class1();\nvar local3 = 0;\nvar local4 = new Class1();\n\n```", "```cs\npublic override void Initialize(AnalysisContext context)\n{\n  context.RegisterSyntaxNodeAction(syntaxNodeContext =>\n  {\n    // Find implicitly typed variable declarations.\n    // Do not flag implicitly typed declarations that declare more than one variables,\n    // as the compiler already generates error CS0819 for those cases.\n    var declaration = (VariableDeclarationSyntax)syntaxNodeContext.Node;\n    if (!declaration.Type.IsVar || declaration.Variables.Count != 1)\n    {\n      return;\n    }\n\n    // Do not flag variable declarations with error type or special System types, such as int, char, string, and so on.\n    var typeInfo = syntaxNodeContext.SemanticModel.GetTypeInfo(declaration.Type, syntaxNodeContext.CancellationToken);\n    if (typeInfo.Type.TypeKind == TypeKind.Error || typeInfo.Type.SpecialType != SpecialType.None)\n    {\n      return;\n    }\n\n    // Report a diagnostic.\n    var variable = declaration.Variables[0];\n    var diagnostic = Diagnostic.Create(Rule, variable.GetLocation(), variable.Identifier.ValueText);\n    syntaxNodeContext.ReportDiagnostic(diagnostic);\n  }, \n  SyntaxKind.VariableDeclaration);\n}\n\n```", "```cs\nnamespace ClassLibrary\n{\n  public class Class1\n  {\n    public void M(int param1, Class1 param2)\n    {\n      // Explicitly typed variables - do not flag.\n      int local1 = param1;\n      Class1 local2 = param2;\n    }\n  }\n}\n\n```", "```cs\n // Implicitly typed variable with error type - do not flag.\n var local3 = UndefinedMethod();\n\n // Implicitly typed variable with special type - do not flag.\n var local4 = param1;\n\n```", "```cs\n // Implicitly typed variable with user defined type - flag.\n var local5 = param2;\n\n```", "```cs\ncontext.RegisterSyntaxNodeAction(syntaxNodeContext =>\n{\n...\n}, SyntaxKind.VariableDeclaration);\n\n```", "```cs\n// Do not flag implicitly typed declarations that declare more than one variables,\n// as the compiler already generates error CS0819 for those cases.\nvar declaration = (VariableDeclarationSyntax)syntaxNodeContext.Node;\nif (!declaration.Type.IsVar || declaration.Variables.Count != 1)\n{\n return;\n}\n\n```", "```cs\n// Do not flag variable declarations with error type or special System types, such as int, char, string, and so on.\nvar typeInfo = syntaxNodeContext.SemanticModel.GetTypeInfo(declaration.Type, syntaxNodeContext.CancellationToken);\nif (typeInfo.Type.TypeKind == TypeKind.Error || typeInfo.Type.SpecialType != SpecialType.None)\n{\n return;\n}\n\n```", "```cs\nvoid Method()\n{\n while (...)\n  if (...)\n   System.Console.WriteLine(value);\n}\n\n```", "```cs\npublic override void Initialize(AnalysisContext context)\n{\n   context.RegisterSyntaxTreeAction(syntaxTreeContext =>\n   {\n     // Iterate through all statements in the tree.\n     var root = syntaxTreeContext.Tree.GetRoot(syntaxTreeContext.CancellationToken);\n     foreach (var statement in root.DescendantNodes().OfType<StatementSyntax>())\n     {\n       // Skip analyzing block statements.\n       if (statement is BlockSyntax)\n       {\n         continue;\n       }\n\n       // Report issue for all statements that are nested within a statement,\n       // but not a block statement.\n       if (statement.Parent is StatementSyntax && !(statement.Parent is BlockSyntax))\n       {\n         var diagnostic = Diagnostic.Create(Rule, statement.GetFirstToken().GetLocation());\n         syntaxTreeContext.ReportDiagnostic(diagnostic);\n       }\n     }\n   });\n}\n\n```", "```cs\nnamespace ClassLibrary\n{\n  public class Class1\n  {\n    void Method(bool flag, int value)\n    {\n      while (flag)\n      if (value > 0)\n      System.Console.WriteLine(value);\n    }\n  }\n}\n\n```", "```cs\n// Skip analyzing block statements.\nif (statement is BlockSyntax)\n{\n  continue;\n}\n\n```", "```cs\n// Report issue for all statements that are nested within a statement,\n// but not a block statement.\nif (statement.Parent is StatementSyntax && !(statement.Parent is BlockSyntax))\n{\n  var diagnostic = Diagnostic.Create(Rule, statement.GetFirstToken().GetLocation());\n  syntaxTreeContext.ReportDiagnostic(diagnostic);\n}\n\n```", "```cs\nvoid M(int param1, ref int param2, int param3, params int[] param4)\n{\n int local1 = param1;\n param2 = 0;\n}\n\n```", "```cs\nnamespace ClassLibrary\n{\n  public class Class1\n  {\n    void M(int param1, ref int param2, int param3, params int[] param4)\n    {\n      int local1 = param1;\n      param2 = 0;\n    }\n  }\n}\n\n```", "```cs\n context.RegisterCodeBlockStartAction<SyntaxKind>(startCodeBlockContext =>\n {\n  ...\n }\n\n```", "```cs\n  // We only care about method bodies.\n  if (startCodeBlockContext.OwningSymbol.Kind != SymbolKind.Method)\n  {\n    return;\n  }\n\n  // We only care about methods with parameters.\n  var method = (IMethodSymbol)startCodeBlockContext.OwningSymbol;\n  if (method.Parameters.IsEmpty)\n  {\n    return;\n  }\n\n```", "```cs\n  // Initialize local mutable state in the start action.\n  var analyzer = new UnusedParametersAnalyzer(method);\n\n```", "```cs\n// Register an intermediate non-end action that accesses and modifies the state. startCodeBlockContext.RegisterSyntaxNodeAction(analyzer.AnalyzeSyntaxNode, SyntaxKind.IdentifierName);\n\n```", "```cs\n// Register an end action to report diagnostics based on the final state. startCodeBlockContext.RegisterCodeBlockEndAction(analyzer.CodeBlockEndAction);\n\n```", "```cs\n  #region Per-CodeBlock mutable state\n  private readonly HashSet<IParameterSymbol> _unusedParameters;\n  private readonly HashSet<string> _unusedParameterNames;\n  #endregion\n\n```", "```cs\n  #region State intialization\n  public UnusedParametersAnalyzer(IMethodSymbol method)\n  {\n    // Initialization: Assume all parameters are unused, except for:\n    //  1\\. Implicitly declared parameters\n    //  2\\. Parameters with no locations (example auto-generated parameters for accessors)\n    var parameters = method.Parameters.Where(p => !p.IsImplicitlyDeclared && p.Locations.Length > 0);\n    _unusedParameters = new HashSet<IParameterSymbol>(parameters);\n    _unusedParameterNames = new HashSet<string>(parameters.Select(p => p.Name));\n  }\n  #endregion\n\n```", "```cs\n  #region Intermediate actions\n  public void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context)\n  {\n    // Check if we have any pending unreferenced parameters.\n    if (_unusedParameters.Count == 0)\n    {\n      return;\n    }\n\n    // Syntactic check to avoid invoking GetSymbolInfo for every identifier.\n    var identifier = (IdentifierNameSyntax)context.Node;\n    if (!_unusedParameterNames.Contains(identifier.Identifier.ValueText))\n    {\n      return;\n    }\n\n```", "```cs\n    // Mark parameter as used.\n    var parmeter = context.SemanticModel.GetSymbolInfo(identifier, context.CancellationToken).Symbol as IParameterSymbol;\n    if (parmeter != null && _unusedParameters.Contains(parmeter))\n    {\n      _unusedParameters.Remove(parmeter);\n      _unusedParameterNames.Remove(parmeter.Name);\n    }\n  }\n  #endregion\n\n```", "```cs\n  #region End action\n  public void CodeBlockEndAction(CodeBlockAnalysisContext context)\n  {\n    // Report diagnostics for unused parameters.\n    foreach (var parameter in _unusedParameters)\n    {\n      var diagnostic = Diagnostic.Create(Rule, parameter.Locations[0], parameter.Name, parameter.ContainingSymbol.Name);\n      context.ReportDiagnostic(diagnostic);\n    }\n  }\n #endregion\n\n```", "```cs\nnamespace MyNamespace\n{\n  public class InsecureMethodAttribute : System.Attribute { }\n\n  public interface ISecureType { }\n\n  public interface IInsecureInterface\n  {\n    [InsecureMethodAttribute]\n    void F();\n  }\n\n  class MyInterfaceImpl1 : IInsecureInterface\n  {\n    public void F() {}\n  }\n\n  class MyInterfaceImpl2 : IInsecureInterface, ISecureType\n  {\n    public void F() {}\n  }\n\n  class MyInterfaceImpl3 : ISecureType\n  {\n    public void F() {}\n  }\n}\n\n```", "```cs\nclass MyInterfaceImpl2 : ISecureType\n{\n  public void F() {}\n}\n\n```", "```cs\ncontext.RegisterCompilationStartAction(compilationContext =>\n{\n ...\n}\n\n```", "```cs\n // Check if the attribute type marking insecure methods is defined.\n var insecureMethodAttributeType = compilationContext.Compilation.GetTypeByMetadataName(\"MyNamespace.InsecureMethodAttribute\");\n if (insecureMethodAttributeType == null)\n {\n   return;\n }\n\n // Check if the interface type marking secure types is defined.\n var secureTypeInterfaceType = compilationContext.Compilation.GetTypeByMetadataName(\"MyNamespace.ISecureType\");\n if (secureTypeInterfaceType == null)\n {\n   return;\n }\n\n```", "```cs\n// Initialize state in the start action.\nvar analyzer = new CompilationAnalyzer(insecureMethodAttributeType, secureTypeInterfaceType);\n\n```", "```cs\n// Register an intermediate non-end action that accesses and modifies the state. compilationContext.RegisterSymbolAction(analyzer.AnalyzeSymbol, SymbolKind.NamedType, SymbolKind.Method);\n\n```", "```cs\n// Register an end action to report diagnostics based on the final state. compilationContext.RegisterCompilationEndAction(analyzer.CompilationEndAction);\n\n```", "```cs\n#region Per-Compilation immutable state\n private readonly INamedTypeSymbol _insecureMethodAttributeType;\n private readonly INamedTypeSymbol _secureTypeInterfaceType;\n#endregion\n\n#region Per-Compilation mutable state\n /// <summary>\n /// List of secure types in the compilation implementing secure interface.\n /// </summary>\n private List<INamedTypeSymbol> _secureTypes;\n\n /// <summary>\n /// Set of insecure interface types in the compilation that have methods with an insecure method attribute.\n /// </summary>\n private HashSet<INamedTypeSymbol> _interfacesWithInsecureMethods; \n#endregion\n\n```", "```cs\n#region State intialization\n public CompilationAnalyzer(INamedTypeSymbol insecureMethodAttributeType, INamedTypeSymbol secureTypeInterfaceType)\n{\n  _insecureMethodAttributeType = insecureMethodAttributeType;\n  _secureTypeInterfaceType = secureTypeInterfaceType;\n\n  _secureTypes = null;\n  _interfacesWithInsecureMethods = null;\n }\n#endregion\n\n```", "```cs\n  #region Intermediate actions\n  public void AnalyzeSymbol(SymbolAnalysisContext context)\n  {\n    switch (context.Symbol.Kind)\n    {\n      case SymbolKind.NamedType:\n      // Check if the symbol implements \"_secureTypeInterfaceType\".\n      var namedType = (INamedTypeSymbol)context.Symbol;\n      if (namedType.AllInterfaces.Contains(_secureTypeInterfaceType))\n      {\n        _secureTypes = _secureTypes ?? new List<INamedTypeSymbol>();\n        _secureTypes.Add(namedType);\n      }\n\n      break;\n\n      case SymbolKind.Method:\n      // Check if this is an interface method with \"_insecureMethodAttributeType\" attribute.\n      var method = (IMethodSymbol)context.Symbol;\n      if (method.ContainingType.TypeKind == TypeKind.Interface && method.GetAttributes().Any(a => a.AttributeClass.Equals(_insecureMethodAttributeType)))\n      {\n        _interfacesWithInsecureMethods = _interfacesWithInsecureMethods ?? new HashSet<INamedTypeSymbol>();\n        _interfacesWithInsecureMethods.Add(method.ContainingType);\n      }\n\n      break;\n    }\n  }\n  #endregion\n\n```", "```cs\n   #region End action\n   public void CompilationEndAction(CompilationAnalysisContext context)\n   {\n     if (_interfacesWithInsecureMethods == null || _secureTypes == null)\n     {\n       // No violating types.\n       return;\n     }\n\n     // Report diagnostic for violating named types.\n     foreach (var secureType in _secureTypes)\n     {\n       foreach (var insecureInterface in _interfacesWithInsecureMethods)\n       {\n         if (secureType.AllInterfaces.Contains(insecureInterface))\n         {\n           var diagnostic = Diagnostic.Create(Rule, secureType.Locations[0], secureType.Name, \"MyNamespace.ISecureType\", insecureInterface.Name);\n       context.ReportDiagnostic(diagnostic);\n\n           break;\n         }\n       }\n     }\n   }\n   #endregion\n\n```", "```cs\n[TestMethod]\npublic void TestMethod1()\n{\n  var test = @\"class Class1 { }\";\n\n  VerifyCSharpDiagnostic(test);\n}\n\n```", "```cs\nvar expected = new DiagnosticResult\n{\n  Id = \"CSharpAnalyzers\",\n  Message = String.Format(\"Type name '{0}' contains lowercase letters\", \"Class1\"),\n  Severity = DiagnosticSeverity.Warning,\n  Locations = new[] {\n    new DiagnosticResultLocation(\"Test0.cs\", 11, 15)\n  }\n};\n\nVerifyCSharpDiagnostic(test, expected);\n\n```", "```cs\nnew DiagnosticResultLocation(\"Test0.cs\", 11, 7)\n\n```", "```cs\nvar test = @\"class CLASS1 { }\";\n\n```", "```cs\n var test = @\"class CLASS1 { }\";\n\n VerifyCSharpDiagnostic(test);\n\n```", "```cs\n//No diagnostics expected to show up\n[TestMethod]\npublic void TestMethod1()\n{\n  var test = @\"\";\n\n  VerifyCSharpDiagnostic(test);\n}\n\n```", "```cs\nvar expected = new DiagnosticResult\n{\n  Id = \"CSharpAnalyzers\",\n  Message = String.Format(\"Type name '{0}' contains lowercase letters\", \"Class1\"),\n  Severity = DiagnosticSeverity.Warning,\n  Locations = new[] { new DiagnosticResultLocation(\"Test0.cs\", 11, 15) }\n};\n\nVerifyCSharpDiagnostic(test, expected);\n\n```", "```cs\n protected override CodeFixProvider GetCSharpCodeFixProvider()\n {\n   return new CSharpAnalyzersCodeFixProvider();\n }\n\n protected override DiagnosticAnalyzer GetCSharpDiagnosticAnalyzer()\n {\n   return new CSharpAnalyzersAnalyzer();\n }\n\n```"]