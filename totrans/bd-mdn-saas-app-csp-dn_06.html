<html><head></head><body>
		<div><h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor140"/>6</h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor141"/>Microservices for SaaS Applications</h1>
			<p>Microservices are a powerful architectural pattern that is becoming increasingly popular in modern software development. Microservices are a way of organizing a large application into smaller, more manageable, and independent services that can communicate with each other using well-defined interfaces. This approach has gained popularity over the years as companies seek to build more scalable and robust software systems. With the increasing complexity of modern applications, it has become clear that the traditional monolithic approach to building software is no longer adequate. Microservices offer a way to break down complex applications into smaller, more manageable pieces that can be developed, deployed, and maintained independently.</p>
			<p>Implementing microservices requires a shift in the way that we think about building and deploying software. With microservices, we move away from the monolithic approach of building everything in a single application and instead build a series of smaller, independent services that can be deployed and scaled independently. This shift in approach allows us to build more flexible and resilient systems, as we can update, test, and deploy individual services independently. At the same time, we need to ensure that our microservices can communicate with each other efficiently and that we have mechanisms in place to handle errors and failures in our distributed systems.</p>
			<p>This chapter will explore the important considerations when building microservices, and provide a guide to help you get started with implementing microservices in your software development projects.</p>
			<p>The following main topics will be covered in this chapter:</p>
			<ul>
				<li>Microservices and their uses</li>
				<li>Best practices for building performant and secure microservices</li>
				<li>How to use the skills we learned for RESTful APIs with microservices</li>
				<li>Common pitfalls when building microservices and how to avoid them</li>
				<li>Some practical advice</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor142"/>Technical requirements</h1>
			<p>All code from this chapter can be found at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-6</a>.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor143"/>What are microservices and why use them?</h1>
			<p>Microservices <a id="_idIndexMarker364"/>are a software architecture style that structures an application as a collection of loosely coupled services. Unlike a traditional monolithic architecture, where all the functionality of the application is bundled into a single code base, microservices break down the functionality into smaller, independent services that can be developed, deployed, and scaled independently.</p>
			<p>The microservices architecture was first introduced in the early 2000s and has gained popularity in recent years due to the increasing demand for faster development and deployment cycles, flexible scaling, and improved application resilience. Microservices are seen as a way to deliver value to customers more quickly and with greater agility, making them ideal for organizations that are looking to rapidly iterate and innovate.</p>
			<p>Microservices also <a id="_idIndexMarker365"/>have several benefits for organizations. By breaking down an application into smaller, focused services, organizations can increase the speed and efficiency of their development process. Teams can work on smaller, independent services in parallel, reducing the risk of delays and helping ensure that each service is delivered with high quality. Additionally, microservices can be deployed and scaled independently, allowing organizations to respond more quickly to changes in demand and optimize the performance of their applications.</p>
			<p>When learning about microservices, it’s important to appreciate the underlying concepts of loose and tight coupling.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor144"/>The difference between loose and tight coupling</h2>
			<p>In a<a id="_idIndexMarker366"/> tightly coupled system, components are strongly dependent on one another and have a close relationship with each other. This <a id="_idIndexMarker367"/>means that changes in one<a id="_idIndexMarker368"/> component can have a significant and often breaking impact on other components in the system. Tightly coupled systems can quickly become very complex and difficult to maintain. Changes in one part of the system can cause unintended consequences elsewhere. If there is limited automated testing, this can be very difficult to detect and can result in bugs in production code.</p>
			<p>In contrast, a loosely coupled system has components that are independent and have minimal dependencies on one another. This allows components to be developed, deployed, and maintained independently, with little or no impact on other components in the system. Loose coupling <a id="_idIndexMarker369"/>enables teams to work more efficiently and with greater agility, as changes to one component can be made with little or no impact on other parts of the system. It may sound like loose coupling is an obvious choice, but in practice, a lot of additional work is required to design a loosely coupled system.</p>
			<p>The <a id="_idIndexMarker370"/>microservices architecture is based on the principles of loose coupling, where an application is broken down into smaller, focused services that can be developed, deployed, and scaled independently. This allows organizations to respond more quickly to changes in demand, optimize the performance of their applications, and increase the speed and efficiency of their development process.</p>
			<p>SaaS applications<a id="_idIndexMarker371"/> are typically quite complex. There will often be quite large teams working on the project, each of which will have areas of specialization. By breaking down an application into smaller, focused services, teams can work on them in parallel, reducing the risk of delays and increasing the speed of delivery. This helps organizations respond more quickly to changes in demand and deliver value to customers more rapidly.</p>
			<p>Another advantage of microservices is better scalability. Leaning on cloud-based infrastructure, each service can be deployed and scaled independently, allowing organizations to respond more quickly to changes in demand and optimize the performance of their applications. This is particularly important for SaaS applications, which often experience fluctuations in usage patterns. This can benefit the performance of the application, by provisioning more resources when the usage is high. When usage is low, some resources can be turned off, helping the organization manage its cloud compute costs and optimize the use of resources.</p>
			<p>Microservices should also be designed to be highly resilient, meaning that even if one service fails, the impact on the overall system is minimal. This makes microservices ideal for SaaS applications, where downtime can have a significant impact on customer satisfaction and an according impact on the revenue of the company delivering the application. By breaking down an application into smaller, focused services, organizations can reduce the risk of unintended consequences when making changes to the system, making maintenance and modification easier and reducing the risk of downtime.</p>
			<p>Microservices are a valuable tool for organizations looking to develop SaaS applications. They offer increased agility, better scalability, improved resilience, easier maintenance, and better cost management, making them an ideal choice for organizations looking to rapidly iterate and innovate.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor145"/>Docker</h2>
			<p>With the <code>GoodHabits</code> service, we<a id="_idIndexMarker372"/> have been using Docker to run a <code>devcontainer</code> that encompasses the development environment, and the SQL server database. This is only one way that Docker can be used. At its core, Docker is a tool that can be used to run a process in a container. You can think of a container as a very lightweight virtual machine, typically running a Linux distro.</p>
			<p>Docker <a id="_idIndexMarker373"/>often becomes a very important tool when building with microservices. A microservice app will typically have many different components that must be running for the overall system to run. This could involve running code in different programming languages, and running against multiple different database platforms. Attempting to get everything running reliably on a dev machine, and in several cloud environments, can quickly become a nightmare!</p>
			<p>Docker provides an efficient and reliable way to run your microservices in a set of networked containers. By containerizing your microservices, you can isolate them from each other, making them easier to build and run.</p>
			<p>Additionally, Docker allows you to easily package your microservices and their dependencies, making it simpler to deploy your services in different environments, including running them in a development environment. This helps ensure that your microservices will work consistently across different systems, which is essential, and also challenging when building microservices.</p>
			<p>While Docker is not strictly necessary for building microservices, it is highly recommended as a best practice to improve the efficiency and reliability of your microservices deployment. We’ll cover some more best practices in detail in the next section.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Best practices for building microservices</h1>
			<p>When<a id="_idIndexMarker374"/> building microservices, it’s important to think about best practices to ensure that you get the benefits from the additional work required to build a microservice application. The system should be scalable, maintainable, and resilient – payback for the extra effort! Here are some of the most important best practices or “principles” to keep in mind.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Design for failure</h2>
			<p>Microservices <a id="_idIndexMarker375"/>should be “designed for failure.” If they are going to fail (and all software will fail!), they should fail gracefully, with redundancy built in to ensure that the system continues to function even if one service fails.</p>
			<p>One of the essential steps when designing for failure is <em class="italic">adding redundancy to your system</em>. This can be achieved by having multiple instances of each service running in parallel so that if one fails, others can continue to operate. Note that this will incur some additional costs, such as cloud hosting costs. Load balancing helps distribute the load evenly across multiple instances of a service, reducing the risk of a single instance becoming overwhelmed, and also helps redirect the load to another instance if one instance fails.</p>
			<p><em class="italic">Circuit breakers</em> are<a id="_idIndexMarker376"/> another useful tool when designing for failure. These can be used to automatically detect and isolate failing services, preventing them from affecting the rest of the system. This makes it more likely that the overall system will continue to operate, even if one service fails.</p>
			<p><em class="italic">Idempotence</em> is<a id="_idIndexMarker377"/> also crucial when embracing the “design for failure” principle. This involves ensuring that each service is idempotent, meaning that it can be executed multiple times with the same result. This allows you to retry requests if a service fails, reducing the risk of data loss or inconsistent results. You will remember that we encountered this topic in the previous chapter when learning about certain HTTP verbs. The principle is the same here.</p>
			<p><em class="italic">Health checks</em> should<a id="_idIndexMarker378"/> be used to periodically test each service and determine whether it is operating correctly. This information can then be used to automatically redirect requests to other instances of the service if the original instance fails (leaning on the redundancy principle). These health checks should run automatically or on a defined schedule and can alert the team immediately if any issues arise.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Focus on decoupling</h2>
			<p>Microservices <a id="_idIndexMarker379"/>should be (by definition) loosely coupled, with minimal dependencies between services. This allows services to be developed, deployed, and modified independently, reducing the risk of unintended consequences.</p>
			<p>Decoupling is a central tenet and is an important aspect of building a microservices-based system. Decoupling refers to separating the concerns between different services, allowing them to operate independently and reducing the risk of cascading failures.</p>
			<p>There must be <em class="italic">clear service boundaries</em> – each service should have a specific responsibility and purpose, without overlapping with other services. Doing so will help ensure that each service can be developed and deployed independently, reducing the interdependencies between services.</p>
			<p><em class="italic">Asynchronous communication</em> is an<a id="_idIndexMarker380"/> important aspect of decoupling services. Instead of direct communication, messages can be sent between services and processed at a later time. This allows each service to operate independently, reducing the risk of blocking and cascading failures.</p>
			<p>It is very important to <em class="italic">implement some form of versioning</em> when decoupling services. Each service should have a version number, which can allow multiple versions of a service to coexist in the system. This allows for changes to be made to a service without them affecting other services, reducing the interdependencies between services. We looked at versioning in the previous chapter.</p>
			<p><em class="italic">Using an event-driven architecture</em> is <a id="_idIndexMarker381"/>another important part of decoupling services. Events can trigger actions in other services, reducing the need for direct communication. This allows each service to operate independently, reducing the interdependencies between services. This is often seen with event-based message queues facilitating communication between the various services in the system.</p>
			<p>Finally, <em class="italic">service discovery</em> is a<a id="_idIndexMarker382"/> useful tool for decoupling services. If you consider a system that has maybe 20 different loosely coupled services hosted in the cloud in a constellation of Docker containers, and perhaps multiple versions of some of them, keeping track of where they are all running can become very challenging. Using some form of service discovery allows the system to detect and connect to other services automatically, reducing the need for hardcoded connections.</p>
			<p>Embracing the “focus on decoupling” principle helps in building a robust microservices-based system. By<a id="_idIndexMarker383"/> defining clear service boundaries, using asynchronous communication, implementing versioning, using event-driven architecture, and considering service discovery, you can ensure that your system is scalable, flexible, and resilient.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor149"/>Embrace automation</h2>
			<p>Automation <a id="_idIndexMarker384"/>is critical for the efficient operation of microservices as it helps ensure consistency and reliability across services. Automation should be used as much as possible to improve testing (with an automated test suite), deployment (CI/CD), and scaling (perhaps with Terraform).</p>
			<p>Automation is a very important principle in all types of software development, but this is doubly true when building a SaaS application that makes use of a microservice architecture. Automating deployment and testing processes helps in reducing manual efforts and increases the speed of delivering new features to users. Automated deployment and testing processes ensure that services are deployed consistently, and any issues can be detected early in the development cycle. This helps in reducing downtime and increasing the overall efficiency of the system.</p>
			<p><em class="italic">Implementing CI/CD</em> helps ensure that code changes are automatically built, tested, and deployed. This helps in reducing the manual efforts involved in testing new features and gets them into the hands of the users as quickly as possible. CI/CD also helps in ensuring that code changes are deployed consistently and any issues are detected early in the development cycle. Using pipelines to automatically build, test, and deploy microservices will make managing the project as it starts to grow considerably easier!</p>
			<p>It is also useful to automate monitoring and logging. Automating monitoring and logging helps in detecting issues early and reduces downtime. Automated monitoring and logging processes ensure that the system is monitored consistently and that any issues are detected early, reducing manual efforts and increasing the overall efficiency of the system.</p>
			<p>When in production, a SaaS application can experience rapid fluctuations in the demands being placed on various parts of the system. Automation can facilitate automatic scaling to ensure that the system can handle increased traffic without manual intervention. Automated scaling processes ensure that the system can scale up or down based on the traffic, reducing manual efforts and increasing the overall efficiency of the system.</p>
			<p>Embracing<a id="_idIndexMarker385"/> the “embrace automation” principle helps in building a robust and efficient microservices-based system. Automating deployment and testing processes, implementing CI/CD, automating monitoring and logging, and automating scaling processes help in streamlining the processes, reducing manual efforts, and increasing the efficiency of the system.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Use contract-driven development</h2>
			<p>Microservices<a id="_idIndexMarker386"/> should have well-defined contracts that define the interface between services. This allows services to evolve independently, while still ensuring compatibility. In this context, a “contract” means an agreement that specifies the interactions between services, including details about the inputs and outputs of each service, communication protocols, and data formats. This contract can be represented in various forms, such as API specifications, message formats, or documentation, and should be agreed upon by all the teams involved in building and maintaining the services.</p>
			<p>Contract-driven development requires that clear contracts between services are defined. These contracts should define the inputs and outputs for each service and ensure that the services operate as expected. This helps in reducing the risk of breaking changes and increases the overall stability of the system.</p>
			<p>As with many parts <a id="_idIndexMarker387"/>of the application, testing is very important. <em class="italic">Contract testing</em> ensures that the contracts between services are tested and adhered to, reducing the risk of breaking changes and increasing the overall stability of the system.</p>
			<p>The “use contract-driven development” principle helps in building a robust and stable microservices-based system. Defining clear contracts between services, testing contracts, implementing contract testing, and automating contract testing help in ensuring that the services are operating as expected and adhering to the defined interface, reducing the risk of breaking changes and increasing the overall stability of the system.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Monitor and log aggressively</h2>
			<p>Microservices systems generate a large amount of data, and it’s important to have a robust monitoring and logging strategy in place. This will help you detect and diagnose issues – hopefully, before they have an impact on your user!</p>
			<p>The system should be continuously and automatically monitored, with the monitoring covering the overall health of the service, the response times of the whole system and each microservice, and resource utilization.</p>
			<p>Alongside the<a id="_idIndexMarker388"/> monitoring solution, there should also be a logging mechanism. Logging helps in tracking the activities of the system, detecting issues, and troubleshooting any problems. This logging should include logging requests, response times, and any error messages.</p>
			<p>Using<a id="_idIndexMarker389"/> centralized logging and monitoring helps in reducing manual efforts and increases the efficiency of the system. Centralized logging and monitoring ensure that the logs and the monitoring data are stored in a single place, making it easier to detect issues and troubleshoot problems.</p>
			<p>There is no point in doing this monitoring and logging if the system never reports any issues! Automated alerting processes ensure that any issues are detected early and the appropriate team is notified, reducing manual efforts and increasing the overall efficiency of the system.</p>
			<p>Monitoring, logging, and alerting help ensure the system is robust and efficient. While they do add a little bit of additional work to the development process, which is not seen when the system is running smoothly, they are very much worth the time invested when things inevitably go wrong!</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Implement security</h2>
			<p>It does <a id="_idIndexMarker390"/>somewhat go without saying, but microservices should be secure, with appropriate authentication, authorization, and encryption protocols in place. It’s also important to have a security strategy that covers the entire system, including the network, the infrastructure, and the services themselves.</p>
			<p>The nature of microservices is such that security can be challenging. There will often be multiple containers running all sorts of different software, each with its own set of attack vectors.</p>
			<p>Embracing the “implement security” principle is an essential aspect of building a microservices-based system. Security helps in protecting sensitive information, reducing the risk of security breaches, and ensuring the confidentiality and integrity of data. We must follow some steps to embrace this principle.</p>
			<p>Implementing <a id="_idIndexMarker391"/>authentication and authorization is the first step toward embracing the “implement security” principle. Authentication and authorization help in ensuring that only authorized users can access sensitive information, reducing the risk of security breaches. The authentication and authorization process should be robust and secure to ensure the confidentiality and integrity of data and must encompass every part of the system.</p>
			<p><em class="italic">Encrypting sensitive data</em> is a crucial aspect of embracing the “implement security” principle. Encryption <a id="_idIndexMarker392"/>helps in protecting sensitive information, reducing the risk of security breaches, and ensuring the confidentiality and integrity of data. The encryption should be applied to all sensitive data, including data at rest and data in transit.</p>
			<p>Because there are so many moving parts in a SaaS/microservice-based system, security should be implemented at a network level to encompass every part of the system. The security measures at the network level should include firewalls, intrusion detection and prevention systems, and network segmentation.</p>
			<p>Security is extremely important in any application. SaaS applications typically have complex security requirements. Embracing the “implement security” principle from the very start of the project helps in building a secure and reliable microservices-based SaaS application. Implementing authentication and authorization, encrypting sensitive data, and implementing security at the network level help in reducing the risk of security breaches and ensuring the confidentiality and integrity of data.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Focus on scalability</h2>
			<p>Microservices<a id="_idIndexMarker393"/> should be designed to be scalable, both horizontally (by adding more instances) and vertically (by adding more resources to existing instances). This will allow you to respond quickly to changes in demand and ensure that the system continues to perform well under heavy load.</p>
			<p>Embracing the “focus on scalability” principle is another important aspect of building a microservices-based SaaS application. Scalability helps in ensuring that the system can handle increased traffic, reduce downtime, and improve the overall performance of the system.</p>
			<p>Designing for<a id="_idIndexMarker394"/> scalability is the first step toward embracing the “focus on scalability” principle. Scalable design helps in ensuring that the system can handle increased traffic, reduce downtime, and improve the overall performance of the system. The design should take into account the expected traffic and resource utilization and should include provisions for increasing the resources as needed.</p>
			<p>As we discussed earlier, containerization helps in improving the scalability of the system by packaging the services and their dependencies, making it easier to deploy and scale the services as needed.</p>
			<p>To get the most benefit from a containerized application, you should include a load balancer. Load balancing helps in distributing the traffic evenly across the available resources, reducing downtime and improving the overall performance of the system.</p>
			<p>With containers and a load balancer, it is possible to automate scaling in the application. Implementing auto-scaling helps in ensuring that the system can handle increased traffic, reduce downtime, and improve the overall performance of the system. Auto-scaling automatically increases or decreases the resources as needed, based on the traffic and resource utilization.</p>
			<p>Designing for scalability, embracing containerization, implementing load balancing, and implementing auto-scaling help in ensuring that the system can handle increased traffic, reduce downtime, and improve the overall performance of the system.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Separate data stores</h2>
			<p>Most <a id="_idIndexMarker395"/>applications have a single database that stores all of the information associated with the application. While this approach can be taken in a microservices application, you can also implement a database on a per-service basis. There are pros and cons to this approach, and you don’t necessarily need to use a separate data store per service. The choice of using a separate data store per service or a shared data store depends on the requirements and constraints of your system.</p>
			<p>Having separate data stores for each service can provide benefits such as these:</p>
			<ul>
				<li><strong class="bold">Improved scalability</strong>: Each service can scale its data store independently, allowing for better resource utilization and reducing the likelihood of resource contention</li>
				<li><strong class="bold">Improved resilience</strong>: Each service can continue to function, even if one of the data stores experiences an issue</li>
				<li><strong class="bold">Improved data isolation</strong>: Each service has complete control over its data, making it easier to maintain data consistency and integrity</li>
			</ul>
			<p>However, separate data stores can also introduce challenges:</p>
			<ul>
				<li><strong class="bold">Increased operational complexity</strong>: Managing multiple data stores can be more complex than managing a single data store</li>
				<li><strong class="bold">Increased latency</strong>: Communication between services to access data in different data stores can introduce latency</li>
				<li><strong class="bold">Increased data duplication</strong>: The same data may need to be stored in multiple data stores, increasing storage costs and the risk of data inconsistency</li>
			</ul>
			<p>A shared <a id="_idIndexMarker396"/>data store, on the other hand, can simplify the architecture and reduce operational complexity, but it can also introduce constraints on scalability, resilience, and data isolation.</p>
			<p>Ultimately, the choice between separate data stores and a shared data store depends on the specific requirements and constraints of your system and should be made based on a careful evaluation of the trade-offs involved.</p>
			<p>Designing microservice applications is hard. There is a lot to think about to make sure that you can realize the benefits of this approach! These best practices will help you build microservices that are scalable, maintainable, and resilient. By following them, you can ensure that your microservices-based system is optimized for performance, efficiency, and reliability!</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Mixing microservices and RESTful APIs</h1>
			<p>When<a id="_idIndexMarker397"/> building a<a id="_idIndexMarker398"/> microservices-based architecture, REST is often used as the communication protocol between the different services. <strong class="bold">REST</strong>, or <strong class="bold">Representational State Transfer</strong>, is a commonly used and widely adopted <a id="_idIndexMarker399"/>web service architecture that provides a standardized way for clients and servers to communicate with each other. Microservices and REST are a natural fit, as REST provides the necessary communication infrastructure for microservices to communicate and exchange data with each other. We discussed contract-based development previously; the surface of the REST API can be seen as the contract for communication between services.</p>
			<p>One of the <a id="_idIndexMarker400"/>key advantages of using REST in a <a id="_idIndexMarker401"/>microservices-based system is that it provides a clear and standard way for services to communicate with each other. REST defines a set of rules for how services should exchange data, including the use of HTTP methods such as GET, POST, and DELETE, and the use of HTTP status codes to indicate success or failure. This makes it easy for developers to build and maintain microservices, as they know exactly what to expect when communicating with other services.</p>
			<p>Another advantage of using REST in a microservices-based system is that it provides a scalable and flexible way for services to communicate with each other. REST is platform-agnostic, typically communicating over HTTP, which means that it can be used with a variety of programming languages and technologies, making it an ideal choice for building microservices.</p>
			<p>Finally, using REST in a microservices-based system provides a secure way for services to communicate with each other. REST uses standard web security measures such as SSL/TLS encryption, which helps protect data in transit, and HTTP authentication, which helps ensure that only authorized clients can access the data.</p>
			<p>Microservices and REST are a natural fit, and using REST as the communication protocol between microservices provides a clear, scalable, and secure way for services to communicate and exchange data with each other. By using REST, developers can build and maintain microservices-based systems with confidence, knowing that they have a reliable and widely adopted communication infrastructure in place.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Splitting up a single REST API into microservices</h2>
			<p>When <a id="_idIndexMarker402"/>you think of a “typical” RESTful API, you will probably be thinking of a system with several controllers, each grouping several related methods or endpoints. It is not uncommon for an enterprise system with a single <strong class="bold">monolithic</strong> API to have dozens of controllers and hundreds of endpoints. Splitting this up into a contract-driven microservice-based system is not easy. There is no one correct way to approach this, and it can be more art than science.</p>
			<p>Here are a few approaches that can be taken for<a id="_idIndexMarker403"/> splitting up a monolithic REST API into microservices:</p>
			<ul>
				<li><strong class="bold">Functionality-based</strong>: This approach involves breaking down the monolithic API into smaller services based on the functionality they provide. For example, a service could be created to handle user authentication, while another could handle product management. This approach makes it easier to manage and maintain the services, as each one is focused on a specific task.</li>
				<li><strong class="bold">Data-driven</strong>: In this approach, the monolithic API is broken down into services based on the data they manage. For example, a service could be created to manage customer information, while another could manage order information. This approach is useful when there are different data access patterns, security requirements, or performance requirements for different datasets.</li>
				<li><strong class="bold">Domain-driven</strong>: This approach involves breaking down the monolithic API into services based on the domain it represents. For example, a service could be created to manage information about customers, while another could manage information about products. This approach is useful when there are complex business domains that can be broken down into smaller, manageable pieces.</li>
				<li><strong class="bold">Micro frontends</strong>: This approach involves breaking down the monolithic API into microservices and using a micro frontend architecture to combine the services into a single user interface. This approach provides a way to scale the frontend and the backend independently, while still providing a seamless user experience.</li>
			</ul>
			<p>Regardless of<a id="_idIndexMarker404"/> the approach used, it is important to consider the complexity of the API, the dependencies between the different parts of the API, and the skills and resources of the development team when determining the best way to split up a monolithic API into microservices. Additionally, it is important to continuously evaluate and refactor the microservices as needed to ensure that they continue to meet the needs of the application and the business.</p>
			<p>An often-asked question when discussing REST and microservices is, “<em class="italic">Should each controller in an API be its </em><em class="italic">own microservice?</em>”</p>
			<p>The <a id="_idIndexMarker405"/>answer is not straightforward and depends on the specific requirements of your system and the size and complexity of each controller. In general, each microservice should represent a single, self-contained business capability, and multiple controllers can be part of a single microservice if they work together to provide a single business function.</p>
			<p>If the controllers are tightly coupled and cannot be separated, it might make sense to have them in a single microservice. On the other hand, if each controller has separate business logic and data storage, and can be deployed and scaled independently, it might be a better fit to have each controller in its own microservice.</p>
			<p>The key is to determine the business functions that need to be performed and to decompose the system into a set of self-contained microservices that can be developed, deployed, and scaled independently. When in doubt, it is better to start with smaller microservices and consolidate them later if needed. This allows for easier testing and debugging, as well as more rapid development and deployment cycles.</p>
			<p>Each controller in an API doesn’t necessarily have to be its own microservice, but the decision should be based on the specific requirements of your system and the size and complexity of each controller.</p>
			<p>When combining microservices and REST, there are several important topics to cover to build a robust and scalable system, which play a crucial role in building a microservices-based system:</p>
			<ul>
				<li><strong class="bold">Designing RESTful APIs</strong>: RESTful APIs should be designed to be scalable, flexible, and easy to consume.</li>
				<li><strong class="bold">API documentation</strong>: API documentation should be clear, concise, and easy to understand, and should provide clear instructions on how to consume the APIs.</li>
				<li><strong class="bold">API versioning</strong>: API versioning helps in ensuring that the system can evolve, without breaking existing integrations.</li>
				<li><strong class="bold">API security</strong>: API security should be implemented to protect against unauthorized access, data theft, and other security risks.</li>
				<li><strong class="bold">Error handling</strong>: Error handling should be implemented to ensure that the system can handle and respond to errors consistently and predictably.</li>
				<li><strong class="bold">Data consistency</strong>: Data consistency is a crucial aspect of building a microservices-based system. Data consistency should be maintained across the microservices, to ensure that the system behaves as expected.</li>
			</ul>
			<p>When <a id="_idIndexMarker406"/>combining microservices and REST, it is important to focus on designing RESTful APIs, providing clear API documentation, implementing API versioning, securing the APIs, handling errors, and maintaining data consistency. These topics help in building a robust and scalable system that can handle increased traffic and provide a better user experience.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor157"/>Common pitfalls and how to avoid them</h1>
			<p>Building SaaS apps is hard. Building a microservice application is hard. Combining the two is really hard, and there are several common pitfalls that you should avoid!</p>
			<p>The first, most common, and most important one to avoid is building the microservices too early. It is often easier to start with a monolith and slowly break off small sections of the app into small, self-contained services when the need arises and not before.</p>
			<p>So, perhaps the best advice I can give about microservices is to not use them... until you have to! But, given that this is a chapter about microservices, here are some common traps that<a id="_idIndexMarker407"/> should be avoided if you have decided to go down this route!</p>
			<ul>
				<li><strong class="bold">Over-complication</strong>: One of the most common pitfalls when building microservices is over-complicating the architecture. This can result in additional bugs, increased maintenance costs, and longer development times.</li>
				<li><strong class="bold">Lack of communication and coordination</strong>: When building microservices, it is important to ensure that there is effective communication and coordination between teams. Without this, there can be delays and misunderstandings, which can result in problems with the overall architecture, which will inevitably manifest as a degraded experience for the users of the system.</li>
				<li><strong class="bold">Inconsistent data</strong>: When using microservices, it is important to ensure that data is consistent across all services. Otherwise, it can lead to problems with data integrity and accuracy.</li>
				<li><strong class="bold">Increased deployment complexity</strong>: Microservices can increase deployment complexity as each service must be deployed and managed individually.</li>
				<li><strong class="bold">Debugging complexity</strong>: Debugging complex microservice architectures can be more difficult than debugging a monolithic architecture.</li>
			</ul>
			<p>Here’s how to avoid the<a id="_idIndexMarker408"/> common pitfalls when building microservices:</p>
			<ul>
				<li><strong class="bold">Over-complicated microservice architecture</strong>: This can be avoided by keeping the architecture simple, focusing on the single responsibility principle, and defining clear boundaries for each microservice. It is also important to prioritize the microservices that need to be built and make sure they align with business goals.</li>
				<li><strong class="bold">Lack of communication and collaboration between teams</strong>: This can be mitigated by creating a culture of collaboration and having clear communication channels between teams. It’s also important to have regular meetings between teams to ensure that everyone is on the same page.</li>
				<li><strong class="bold">Underestimating the complexity of data management</strong>: To avoid this, it’s important to properly plan out the data management strategy for each microservice. This includes defining the data sources, data ownership, and data consistency. Using a data management solution, such as a data management platform or event sourcing, can also help.</li>
				<li><strong class="bold">Not adequately monitoring microservices</strong>: To avoid this pitfall, it’s important to have a solid monitoring strategy in place. This includes setting up logging and monitoring for each microservice and having alerting mechanisms in place for when things go wrong.</li>
				<li><strong class="bold">Lack of security considerations</strong>: To avoid this, it’s important to have a solid security strategy in place. This includes considering security at every stage of the microservice development process, including architecture, design, development, and<a id="_idIndexMarker409"/> deployment. It’s also important to regularly review the security strategy and make changes as needed.</li>
			</ul>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Some practical advice</h1>
			<p>Microservices are a huge and complex topic – rather than trying to give a demonstration of a full microservice application here, I will instead offer some practical advice using the demo app we have been building as the basis for this advice. The implementation is left up to you!</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/> A microservice architecture example</h2>
			<p>It is worth<a id="_idIndexMarker410"/> reiterating that in many cases, the best approach when planning a new application is to start with a single monolith app and carve off sections of the app into microservices when the need arises.</p>
			<p>For this example, I will assume that the Good Habits app has grown to the point where it is necessary to start thinking about separating it into microservices. I think that a useful way to split this up might be something like this:</p>
			<div><div><img src="img/B19343_06_01.jpg" alt="Figure 6.1 – Suggested microservice architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Suggested microservice architecture</p>
			<p>Let’s discuss the components in this diagram a bit more.</p>
			<h3>User interfaces and clients</h3>
			<p>It is very<a id="_idIndexMarker411"/> common these<a id="_idIndexMarker412"/> days for an application to have both a web client app and a mobile app – and sometimes, a desktop application as well. All of these clients will be communicating with the same backend and the same microservices. It is common to build a single <strong class="bold">gateway</strong> API that manages all external communication between the various microservices.</p>
			<h3>API gateway</h3>
			<p>Although <a id="_idIndexMarker413"/>it’s possible to enable user interface applications to directly communicate with microservices, managing this can become incredibly complex. The diagram only displays three microservices, but there could easily be 20 or more. Consider the added complexity of orchestrating communication between more than 20 microservices and three or more types of client UI – the situation becomes even more difficult to visualize and much harder to manage in practice!</p>
			<p>Using an<a id="_idIndexMarker414"/> API gateway in a microservice architecture provides several benefits. Firstly, an API gateway acts as a single entry point for clients, allowing for easier management of requests, authentication, and authorization. It also enables the composition of different microservices into a unified API, which can simplify the client’s interaction with the system. The API gateway can also provide load balancing and failover capabilities, which are important for high-availability systems. Another important benefit is the ability to enforce security and traffic policies, as well as to monitor and log requests. By using an API gateway, developers can more easily manage and evolve a microservice architecture, while maintaining a high level of security and performance.</p>
			<h3>Message broker</h3>
			<p>A<a id="_idIndexMarker415"/> message broker is used to facilitate communication between the various backend microservices. This performs much the same function on the backend as the API gateway does for the frontend. It detangles all of the communication between the services. Again, while we only have three services in the diagram, we should keep in mind that a real-world system may have many more, and inter-service communication can quickly become extremely complex and inefficient.</p>
			<p>Using a message broker in a microservice architecture provides many benefits. One of the main advantages is that it allows services to communicate with each other asynchronously, decoupling the sender from the receiver. This can improve reliability and scalability as services can process messages at their own pace and are not blocked by the performance of other services. A message broker can also act as a buffer between services, which can be particularly useful if one service is temporarily unavailable. It can help avoid message loss by persisting messages until they can be delivered to the appropriate service. A message broker can also provide a centralized way to monitor and manage the flow of messages between services, making it easier to track and debug issues. Finally, by separating the communication concerns from the business logic, services can be more easily tested and deployed independently.</p>
			<p>Using a message broker (and an API gateway) leans into a number of the microservice good design principles that we discussed earlier in this chapter.</p>
			<p>Several message <a id="_idIndexMarker416"/>brokers are commonly used in .NET microservice <a id="_idIndexMarker417"/>applications, including the following:</p>
			<ul>
				<li><strong class="bold">RabbitMQ</strong>: An <a id="_idIndexMarker418"/>open source message broker that supports multiple messaging protocols, including AMQP, MQTT, and STOMP</li>
				<li><strong class="bold">Apache Kafka</strong>: A <a id="_idIndexMarker419"/>distributed streaming platform that is optimized for handling high-volume and high-velocity data streams</li>
				<li><strong class="bold">Azure Service Bus</strong>: A <a id="_idIndexMarker420"/>fully-managed messaging service provided by Microsoft Azure that supports both traditional messaging patterns and pub/sub scenarios</li>
				<li><strong class="bold">AWS Simple Queue Service (SQS)</strong>: A <a id="_idIndexMarker421"/>fully-managed message queue service provided by Amazon Web Services that decouples and scales microservices, distributed systems, and serverless applications</li>
				<li><strong class="bold">NServiceBus</strong>: A <a id="_idIndexMarker422"/>messaging framework for .NET that provides a unified programming model for building distributed systems using a variety of messaging patterns</li>
			</ul>
			<p>All of these tools provide reliable message delivery, scalability, and fault tolerance, and they can help simplify the communication between microservices in a distributed system.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor160"/>The services</h2>
			<p>To give an example, I <a id="_idIndexMarker423"/>have laid out three services:</p>
			<ul>
				<li>A user service, which <a id="_idIndexMarker424"/>will handle everything related to the users. This includes authentication, password management, and keeping personal information up to date.</li>
				<li>A habit service, which<a id="_idIndexMarker425"/> deals with everything related to the habits that the users are trying to track.</li>
				<li>A feed service. In <a id="_idIndexMarker426"/>this more advanced version of the Good Habits app, I have assumed that there will be the ability to see your friends’ progress in a social media-style feed.</li>
			</ul>
			<p>Please note<a id="_idIndexMarker427"/> that I have chosen to also separate the data stores into individual databases. This allows us to treat each data store slightly differently. I have also decided to use a relational database for the User and the Habit service, but a document (NoSQL) database for the Feed service. This is a superpower of microservices – you can use different types of data storage based on the use case for individual microservices.</p>
			<h3>The User service</h3>
			<p>I have specifically <a id="_idIndexMarker428"/>broken this out because storing users’ private data should be taken very seriously. This data may include banking information (if the service has a paid tier) and may include personal information. It is easy to understand that the data that is stored in the User service may have to be treated more securely than the data in the Habit service.</p>
			<p>We should also consider that users in many jurisdictions have the right to be forgotten. By grouping all of the personal data in one place, we make this easier to achieve.</p>
			<p>The User service would probably not be subject to particularly high demand. Users would be expected to update their details infrequently, so this service could have fewer resources allocated to it.</p>
			<h3>The Habit service</h3>
			<p>In the<a id="_idIndexMarker429"/> Good Habits application, it would be expected that the Habit service would do most of the heavy lifting in the application, and so would have additional resources allocated to it. This service should also be designed to scale easily so that more development time can be put into the performance, and perhaps less attention is paid to security than for the User service. (Of course, security is still important!!)</p>
			<p>The type of data in this service would be highly relational, so a relational store is the most appropriate.</p>
			<h3>The Feed service</h3>
			<p>If we envisage<a id="_idIndexMarker430"/> a much more advanced version of the Good Habits app, we may have expanded to the point where we have a social network-type sets of features, which allows users to see their friends' progress and celebrate their success with them.</p>
			<p>This type of service is usually modeled using a document store, or something like GraphQL. A relational store is not appropriate. Using a microservice architecture allows us to choose the most appropriate type of data store!</p>
			<p>All of the information in the feed will have been selected by the users to make publicly available, so data security is less important in this service. We can be sure that there is no private data in this service, as the user data stores are not accessible from this service.</p>
			<h3>Overall architecture</h3>
			<p>The <a id="_idIndexMarker431"/>architecture in <em class="italic">Figure 6</em><em class="italic">.1</em> shows one way that we could use microservices to break up the application. But there are many possible ways to do this, and it is more art than science.</p>
			<p>The most important thing is to be guided by your users, and mindful of how the choices you make in splitting up the monolith will impact the users.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor161"/>A practical example</h1>
			<p>While it is <a id="_idIndexMarker432"/>outside the scope of this chapter to provide a complete example of a microservices project, we can build out some of the principles in the <code>GoodHabits</code> project to cement our understanding of the preceding advice.</p>
			<p>To illustrate this, we can do the following:</p>
			<ol>
				<li>Add a very basic <code>UserService</code>, to show how we can interact with multiple microservices.</li>
				<li>Add an API gateway that serves as a single point of entry to all of the microservices from any clients interacting with the system.</li>
			</ol>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>UserService</h2>
			<p>Run the <a id="_idIndexMarker433"/>following script to add the project and files for the User service:</p>
			<pre class="source-code">
<strong class="bold">dotnet new webapi -n GoodHabits.UserService; \</strong>
<strong class="bold">cd GoodHabits.UserService; \</strong>
<strong class="bold">rm ./WeatherForecast.cs; \</strong>
<strong class="bold">rm ./Controllers/WeatherForecastController.cs; \</strong>
<strong class="bold">touch Controllers/UsersController.cs; \</strong>
<strong class="bold">dotnet add package Microsoft.AspNetCore.Mvc.Versioning; \</strong>
<strong class="bold">dotnet add reference ../GoodHabits.Database/GoodHabits.Database.csproj; \</strong>
<strong class="bold">cd ..; \</strong>
<strong class="bold">dotnet sln add ./GoodHabits.UserService/GoodHabits.UserService.csproj;</strong></pre>
			<p>Next, we will configure how to start the Users microservices. Set up the <code>launchSettings.json</code> file so that it looks like this: </p>
			<pre class="source-code">
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "UserService": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5200",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}</pre>
			<p>Finally, add the following code to the controller:</p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.AspNetCore.Mvc;
namespace GoodHabits.UserService.Controllers;
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly Ilogger&lt;UsersController&gt; _logger;
    public UsersController(
        Ilogger&lt;UsersController&gt; logger
        )
    {
        _logger = logger;
    }
    [HttpGet()]
    public async Task&lt;IactionResult&gt; GetAsync()
    {
        return Ok(new List&lt;User&gt;()
        {
            new User() { Id = 111, FirstName = "Roger",
              LastName = "Waters", Email = "rw@pf.com"},
            new User() { Id = 222, FirstName = "Dave",
              LastName = "Gilmore", Email = "dg@pf.com"},
            new User() { Id = 333, FirstName = "Nick",
              LastName = "Mason", Email = "nm@pf.com"}
        });
    }
}</pre>
			<p>That is<a id="_idIndexMarker434"/> all that is required to set up a very simple User service. You can start this up independently and see how it works with Swagger. The provided functionality is very basic, and it would be a fantastic exercise to try to build this service out a bit more.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>API gateway</h2>
			<p>As described <a id="_idIndexMarker435"/>previously, an API gateway gives a client using the application a single point of entry into the application. All they need to do is talk to the gateway, and the complexity of the microservice implementation is kept hidden.</p>
			<p>We will use a package called Ocelot, which provides most of the functionality that we will need out of the box. To get started, execute the following script to set up the <code>ApiGateway</code> project:</p>
			<pre class="source-code">
<strong class="bold">dotnet new webapi -n GoodHabits.ApiGateway; \</strong>
<strong class="bold">cd GoodHabits.ApiGateway; \</strong>
<strong class="bold">rm ./WeatherForecast.cs; \</strong>
<strong class="bold">rm ./Controllers/WeatherForecastController.cs; \</strong>
<strong class="bold">dotnet add package Ocelot; \</strong>
<strong class="bold">dotnet add package Ocelot.Cache.CacheManager; \</strong>
<strong class="bold">dotnet sln add ./GoodHabits.ApiGateway/GoodHabits.ApiGateway.csproj; \</strong>
<strong class="bold">touch ocelot.json;</strong></pre>
			<p>As we did with <code>UserService</code>, we will need to modify the <code>launchsettings.json</code> file to configure how the API gateway starts. Set up the file like this: </p>
			<pre class="source-code">
{
  "$schema": "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "ApiGateway": {
      "commandName": "Project",
      "launchBrowser": true,
      "launchUrl": "swagger",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      },
      "applicationUrl": "http://localhost:5300",
      "dotnetRunMessages": true
    }
  }
}</pre>
			<p>Next, make<a id="_idIndexMarker436"/> the <code>Program.cs</code> file look like this:</p>
			<pre class="source-code">
using Ocelot.Cache.CacheManager;
using Ocelot.DependencyInjection;
using Ocelot.Middleware;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Configuration.AddJsonFile("ocelot.json", optional: false, reloadOnChange: true);
builder.Services.AddOcelot(builder.Configuration)
    .AddCacheManager(x =&gt;
    {
        x.WithDictionaryHandle();
    });
var app = builder.Build();
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
    app.UseCors(policy =&gt;
        policy.AllowAnyOrigin()
                .AllowAnyHeader()
                .AllowAnyMethod()
                );
}
app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();
await app.UseOcelot();
app.Run();</pre>
			<p>Here, you <a id="_idIndexMarker437"/>can see the key lines for the <code>Ocelot</code> package.</p>
			<p>Finally, configure <code>Ocelot</code> by adding the following config to <code>Ocelot.json</code>:</p>
			<pre class="source-code">
{
    "GlobalConfiguration": {
      "BaseUrl": "http://localhost:5900"
    },
    "Routes": [
      {
        "UpstreamPathTemplate": "/gateway/habits",
        "UpstreamHttpMethod": [ "Get", "Post" ],
        "DownstreamPathTemplate": "/api/habits",
        "DownstreamScheme": "http",
        "DownstreamHostAndPorts": [
          {
            "Host": "localhost",
            "Port": 5100
          }
        ],
        "RateLimitOptions": {
          "EnableRateLimiting": true,
          "Period": "10s",
          "PeriodTimespan": 10,
          "Limit": 3
        }
      },
      {
        "UpstreamPathTemplate": "/gateway/habits/{id}",
        "UpstreamHttpMethod": [ "Get", "Delete", "Put",
          "Patch" ],
        "DownstreamPathTemplate": "/api/habits/{id}",
        "DownstreamScheme": "http",
        "DownstreamHostAndPorts": [
          {
            "Host": "localhost",
            "Port": 5100
          }
        ],
        "RateLimitOptions": {
          "EnableRateLimiting": true,
          "Period": "10s",
          "PeriodTimespan": 10,
          "Limit": 1
        }
      },
      {
        "UpstreamPathTemplate": "/gateway/users",
        "UpstreamHttpMethod": [ "Get" ],
        "DownstreamPathTemplate": "/api/users",
        "DownstreamScheme": "http",
        "DownstreamHostAndPorts": [
          {
            "Host": "localhost",
            "Port": 5200
          }
        ]
      }
    ]
  }</pre>
			<p>If you look <a id="_idIndexMarker438"/>through the config file, you will see that we are simply mapping from one URL in the gateway to another URL in the two microservices that we have created, <code>HabitService</code> and <code>UserService</code>. This may seem like a needless complication, but if you consider that many more microservices might be added to the overall application, it makes sense to give a single point of entry.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>Running the combined application</h2>
			<p>To run the<a id="_idIndexMarker439"/> complete application, we need to start all four projects (<code>HabitService</code>, <code>UserService</code>, <code>APIGateway</code>, and <code>Client</code>) individually. This can become challenging, so we will set up tasks and launch configurations to manage this for us.</p>
			<p>In the <code>.vscode</code> folder, add the following code to <code>tasks.json</code>:</p>
			<pre class="source-code">
        {
            "label": "build-user-service",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.UserService/
                  GoodHabits.UserService.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "label": "build-api-gateway",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.ApiGateway/
                  GoodHabits.ApiGateway.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        }</pre>
			<p>In the same folder, add<a id="_idIndexMarker440"/> the following code to <code>launch.json</code>:</p>
			<pre class="source-code">
        {
            "name": "RunUserService",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build-user-service",
            "program": "${workspaceFolder}/
              GoodHabits.UserService/bin/Debug/net7.0/
              GoodHabits.UserService.dll",
            "args": [],
            "cwd": "${workspaceFolder}/
              GoodHabits.UserService",
            "stopAtEntry": false,
            "console": "integratedTerminal"
        },
        {
            "name": "RunApiGateway",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build-api-gateway",
            "program": "${workspaceFolder}/
              GoodHabits.ApiGateway/bin/Debug/net7.0/
              GoodHabits.ApiGateway.dll",
            "args": [],
            "cwd": "${workspaceFolder}/
              GoodHabits.ApiGateway",
            "stopAtEntry": false,
            "console": "integratedTerminal"
        }</pre>
			<p>Also<a id="_idIndexMarker441"/> in <code>launch.json</code>, add the following compound tasks:</p>
			<pre class="source-code">
    "compounds": [
        {
            "name": "Run Server",
            "configurations": [
                "RunHabitService",
                "RunUserService",
                "RunApiGateway"
            ]
        },
        {
            "name": "Run All",
            "configurations": [
                "RunHabitService",
                "RunClient",
                "RunUserService",
                "RunApiGateway"
            ]
        }
    ]</pre>
			<p>The preceding configuration will allow VSCode to start all four projects by hitting the <em class="italic">F5</em> key, or by using the build and run menu.</p>
			<p>There is much<a id="_idIndexMarker442"/> more that we could do at this point with the demo application. Some suggestions are as follows:</p>
			<ul>
				<li>Build out the User service so that it includes a lot more functionality that would be required for a real app</li>
				<li>Add additional routes to the <code>Ocelot</code> config</li>
				<li>Add a message queue (hint – try RabbitMQ)</li>
			</ul>
			<p>I hope that we have managed to illustrate most of the key learnings from this chapter and provided a foundation for you to build upon.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Summary</h1>
			<p>Microservices are a huge and complex topic, much too large to tackle in one chapter of a SaaS book! In this chapter, we provided a brief introduction to microservices, covering what they are and why they are important. We discussed the benefits of using microservices, including improved scalability, fault tolerance, and flexibility. We also talked about the challenges and pitfalls of implementing a microservices architecture, such as increased complexity.</p>
			<p>Next, we explored the common patterns for designing microservices, including service discovery, API gateways, and message brokers. We also looked at the role of containers and container orchestration systems, such as Docker, in deploying and managing microservices. Finally, we provided a set of pointers on how to implement a microservices architecture using C#, .NET, and various supporting tools. While this is only a small glimpse into the world of microservices, we hope that it has helped provide a foundation for your further exploration of this important topic.</p>
			<p>In the next chapter, we will learn how to build a user interface with Blazor. We’ll interface this UI with the Good Habits backend that we have been building in previous chapters!</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>How to build .NET Core microservices: <a href="https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/">https://www.altkomsoftware.com/blog/microservices-service-discovery-eureka/</a></li>
				<li>Creating a simple data-driven CRUD microservice: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice">https://learn.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice</a></li>
				<li>8 Ways to Secure Your Microservices Architecture: <a href="https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/">https://www.okta.com/resources/whitepaper/8-ways-to-secure-your-microservices-architecture/</a></li>
				<li>Follow 6 key steps to deploy microservices in production: <a href="https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production">https://www.techtarget.com/searchitoperations/tip/Follow-these-6-steps-to-deploy-microservices-in-production</a></li>
				<li>Microservices with .NET: <a href="https://dotnet.microsoft.com/en-us/apps/aspnet/microservices">https://dotnet.microsoft.com/en-us/apps/aspnet/microservices</a></li>
			</ul>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of this chapter:</p>
			<ol>
				<li>What is the difference between a monolithic and microservices architecture?</li>
				<li>What is the purpose of an API gateway in microservices architecture?</li>
				<li>How does a message broker facilitate communication between microservices?</li>
				<li>How does using a microservices architecture impact database design and management?</li>
				<li>What are some common challenges or pitfalls to consider when implementing microservices?</li>
			</ol>
		</div>
	

		<div><h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Part 3: Building the Frontend</h1>
			<p>After learning about the backend in the previous section, we will move on to the frontend. In this section, we will build a simple <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) using Blazor and connect this to the backend from the previous section. As well as the practical skills, this section will also introduce a lot of the theory around frontend development and building excellent UIs.</p>
			<p>This section has the following chapters:</p>
			<ul>
				<li><a href="B19343_07.xhtml#_idTextAnchor169"><em class="italic">Chapter 7</em></a>, <em class="italic">Building a User Interface</em></li>
				<li><a href="B19343_08.xhtml#_idTextAnchor200"><em class="italic">Chapter 8</em></a>, <em class="italic">Authentication and Authorization</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>