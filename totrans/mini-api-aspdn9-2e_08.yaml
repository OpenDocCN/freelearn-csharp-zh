- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating Minimal APIs with Data Sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite us working with minimal APIs, an API would have to be even more minimal
    not to work with an external state, which is not to say that it doesn’t happen.
    For example, an API might be in place to simply perform a calculation or validate
    data, which, on their own, are not necessarily use cases that require some kind
    of managed data.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is fair to say that a wide range of production APIs have some element
    of **create, read, update, delete** ( **CRUD** ) functionality. In the examples
    shown in previous chapters, such as the **Employee** API and the **Todo Item**
    API, we have referred to entities or objects, all of which would be potentially
    created, updated, deleted, or retrieved. The examples we explored stored these
    domain objects in memory, meaning that they would disappear with the application
    when it is stopped. It is now time to move that data into an external data source,
    where it can be persisted and managed separately from the minimal APIs we write.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore two fundamental methods of moving data between data sources
    in this book. Firstly, in this chapter, we will explore direct database connections
    with the **SqlConnection** type in addition to MongoDB Driver for SQL and NoSQL
    database types, respectively. The next chapter will cover the second method, which
    is **object-relational mapping** ( **ORM** ). Each method has its own configuration
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data integration in minimal APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to SQL Server with **SQLConnection**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a NoSQL database with a MongoDB Driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is quite hands-on, using several different technologies. As a
    result, you will need the following to be installed on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server 2022 Developer Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server Management Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB Community Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB Compass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will need to download and install all of the listed software. Installation
    for all products is wizard-based, so follow each of the wizards until you have
    them installed.
  prefs: []
  type: TYPE_NORMAL
- en: You might already have Visual Studio 2022 installed if you have been following
    along with the code examples in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been using Visual Studio Code, it is recommended that you now switch
    to Visual Studio 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can host your SQL and MongoDB servers on a cloud platform,
    such as Microsoft Azure or **Amazon Web Services** ( **AWS** ). Please note that
    the configuration and deployment of these data sources in the cloud are outside
    of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter is available in the GitHub repository at: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data integration in minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we defined APIs and their purpose. It is worth reiterating
    this definition in relation to data sources. APIs act as a gateway to a system,
    offering programmatic access to that system.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the objective of a client connecting to a system via an API is
    to work with data. That data has to be stored somewhere – preferably a source
    separate from the API itself so that it can be externally managed and persistent.
  prefs: []
  type: TYPE_NORMAL
- en: minimal APIs offer various connection methods to data sources. For the purposes
    of this chapter, we are going to focus on the most common persistent data storage
    types, those being **SQL** and **NoSQL** .
  prefs: []
  type: TYPE_NORMAL
- en: SQL versus NoSQL
  prefs: []
  type: TYPE_NORMAL
- en: It’s highly likely that as a reader of this book, you are at least somewhat
    familiar with SQL and NoSQL, but by way of a brief primer, SQL databases are relational
    databases, meaning that data is stored in a collection of tables, with records
    represented by rows and columns in each table. NoSQL is less structured than SQL
    in that the data can be stored in various formats, including documents, key-value
    pairs, column families, or graphs. Data is stored in these various formats in
    collections of entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many SQL and NoSQL products to choose from, with the mainstream ones
    outlined in *Table 8.1* :'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Relational Databases** | **NoSQL Databases** |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | Mongo DB ( document store) |'
  prefs: []
  type: TYPE_TB
- en: '| PostgreSQL | Cassandra (column family store) |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft SQL Server | Redis ( key-value store) |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle Database | DynamoDB ( key-value store) |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite | CouchDB ( document store) |'
  prefs: []
  type: TYPE_TB
- en: '| MariaDB | Cosmos DB ( multi-model database) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 8.1: Examples of mainstream database platforms'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether the data stores are SQL- or NoSQL-based, there are numerous
    ways that minimal APIs can access them, with different design patterns that can
    be adopted to ensure the consistency and integrity of the data being managed between
    the database and the API.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to start exploring data sources via minimal APIs with a direct connection
    to a SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your use case, the data connection method you choose is really
    important for optimal performance and security resilience, as is the way you manage
    connection lifetimes, the way queries are written, and how you pass parameters
    into commands and queries.
  prefs: []
  type: TYPE_NORMAL
- en: Direct SQL commands offer a lot of flexibility, as they act in the same way
    as they would if you had a database IDE open and you were writing queries in them.
    A connection is initiated to a database, a query or command is executed, and then
    the connection is disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start by exploring direct connection methods. We will continue to use
    the example of the **Employee** API, first connecting to a Microsoft SQL database,
    and then connecting to a MongoDB instance (NoSQL).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to and integrating with SQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start with an example that uses Microsoft SQL. First, open SQL Server
    Management Studio and create a database called **MyCompany** , with one table,
    **Employees** .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the SQL script in the following code block to create the table
    with the relevant columns and data types for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the **Employees** table, we have set the **Id** column as an identity column,
    meaning that it will be populated by SQL Server on insertion of any record, with
    the **Id** value incrementing by **1** on each insertion.
  prefs: []
  type: TYPE_NORMAL
- en: We now have everything we need to set up a connection to the database from our
    minimal API project.
  prefs: []
  type: TYPE_NORMAL
- en: Let us go back into the **Employee** API and set up the database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the connection to the database and retrieving records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL databases use a **connection string** to allow access from a code base.
    In this case, I am using Windows Authentication with my local SQL server, so I
    can use a simple connection string that assumes the currently logged-in Windows
    user is able to access my SQL server. Alternatively, if you are using a SQL server,
    you will need to generate a slightly different connection string. The simplest
    way to form the connection string is to use the guides for Microsoft SQL servers
    found at [https://connectionstrings.com](https://connectionstrings.com) , where
    (based on your authentication type) you can generate the appropriate string. The
    following code shows some simple examples of connection strings for each authentication
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a connection string, we can store it somewhere within the API
    where it can be easily retrieved. A good place to do this would be in a configuration
    file, which is, by default, offered to us in the form of **appsettings.json**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **appsettings.json** and add your connection string as shown (I am using
    SQL authentication in my JSON example, but you will need to add your Windows Authentication
    connection string if appropriate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Your **appsettings.json** file may have extra template values when you create
    your project. For simplicity, when following this example, it might be best to
    overwrite the content of the existing **appsettings.json** file with the example
    content shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a service that will manage the interactions with the database.
    This service will be injected into our API endpoints using dependency injection
    (see [*Chapter 7*](B20968_07.xhtml#_idTextAnchor119) for more details on dependency
    injection).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will register the service as a **singleton** . Doing this allows us to cleanly
    specify that there should only be one instance of the service, meaning that any
    requests coming into the API will share that service. Let us first get started
    with the creation of this database service by creating a new interface called
    **IDatabaseService** . This interface will lay out the **contract** for any services
    that are created for the purposes of speaking to a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you see an error at this point stating that **Employee** isn’t
    a known type. When it is created later, this error will clear.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create our service in the form of a concrete class that implements
    **IDatabaseService** . Create the class, calling it **SQLService** .
  prefs: []
  type: TYPE_NORMAL
- en: Once the **SQLService** class has been created, add a constructor that receives
    **IConfiguration** as a parameter, saving its value to a local **readonly** field.
  prefs: []
  type: TYPE_NORMAL
- en: More on IConfiguration
  prefs: []
  type: TYPE_NORMAL
- en: '**IConfiguration** is already registered for dependency injection in an ASP.NET
    application. It represents the content of **appsettings.json** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'This field will contain the connection string, and will allow it to be referenced
    in all queries and commands executed by the service, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’re going to finish off this service by adding the ability to add and
    retrieve employee records from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the same **Employee** class that we added in the examples from
    previous chapters. As a convenient reminder, this code block shows the **Employee**
    class that will act as the model for the database records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will be seeing errors by now (in the Visual Studio error list, and in the
    form of red lines under the code) stating that the class does not fully implement
    the **IDatabaseService** interface. We should add the two functions specified
    in the interface to the **SqlService** class to correct this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with **GetEmployeesAsync()** . The aim of this function is to return
    a list containing all the employees in the database. Start by creating the function
    definition and, in the body, instantiate a new **Employee** list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before going further, make sure you add the **Microsoft.Data.SqlClient** NuGet
    package, as this will be required. You can do this by going to **Tools** | **Manage
    NuGet Packages** | **Package Manager Console** , and then typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will open a new connection to SQL Server using **SqlConnection** .
    By wrapping the instance in a **using** statement, we are ensuring that once the
    control flow ha s exited the body of the **using** statement, the connection is
    automatically disposed of, thanks to **SqlConnection** implementing **IDisposable**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have a connection open that will be automatically disposed
    of. This is good because we’re responsibly managing the use of an external resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside the **using** statement, another **using** statement is added,
    but this time, for the creation of a **SqlCommand** object. This **SqlCommand**
    object represents the query we wish to execute, targeting the connection we now
    have open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we nest another **using** statement inside this one. This creates
    **SqlDataReader** , reading any returned rows from the query in **SqlCommand**
    , creating a new **Employee** instance for each record, and adding it to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can finish the function by returning the list of type **Employee**
    , meaning the finished function looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the **SqlCommand** usage in the previous code. Notice how we
    don’t build the SQL command string using concatenation, passing in the values
    from **Employee** as part of the string being put together. Instead, the best
    practice is to use SQL parameters. Parameterized queries allow us to guard against
    a security vulnerability called SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: In a SQL injection attack, a malicious value is passed in as a value, which
    can alter the originally intended behavior of a command. By passing in parameters,
    we avoid this, with parameters represented by the **@** character in the command
    string and added to the **SqlCommand** after the string is formed (we see this
    in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Employee records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have now completed our first connection to SQL with a transaction. Armed
    with this knowledge, we can also create the **AddEmployeeAsync()** function. The
    connection method is the same but the command is different, with **INSERT** being
    used instead of **SELECT** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Let us now turn our attention to the minimal API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Executing database transactions from API endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These endpoints will need to have the SQL service injected into them in order
    for them to be used in the endpoint body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to **Program.cs** and register the service as a singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have created a service for managing interaction with the SQL server
    and we have made it easily available through dependency injection, getting and
    creating employees from minimal API endpoints is very easy. Simply add a **GET**
    endpoint for retrieval and a **POST** endpoint for creation, adding calls to the
    appropriate functions we created in **SqlService** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Give the new endpoints a try. If successful, you should be able to retrieve
    the employees in the data source as a list or add new employees via the API.
  prefs: []
  type: TYPE_NORMAL
- en: As alluded to earlier in the chapter, because we have created an interface,
    we should be able to swap out the service for one that uses a different data source
    without having to change the endpoint. This leads us nicely to an example of a
    database connection to a NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For demonstrative purposes, we will connect to **MongoDB** , a widely used NoSQL
    database platform.
  prefs: []
  type: TYPE_NORMAL
- en: Before we create the service, we should first add some data to a MongoDB database.
    As per the technical requirements, you should have installed a MongoDB server,
    along with **MongoDB Compass** , a **graphical user interface** ( **GUI** ) for
    MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening MongoDB Compass and creating a connection to your installed
    MongoDB server instance. If you’ve installed MongoDB locally without modifying
    the installation, you should be able to just click **Connect** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Creating a new MongoDB connection](img/B20968_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Creating a new MongoDB connection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once connected, you will be able to see the existing databases on your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: View of existing MongoDB connections](img/B20968_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: View of existing MongoDB connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the navigation bar on the left-hand side, click the plus icon to add a new
    database. Once again, we will call the database **MyCompany** . Compass will also
    require you to create a collection. Just as we created an **Employees** table
    in our SQL database, we will create an **Employees** collection in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: MongoDB Database creation in Compass](img/B20968_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: MongoDB Database creation in Compass'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we haven’t been specified a schema for the **Employees** collection.
    This is because the collection is document-based. We can import data in JSON format,
    which mirrors the **Employee** class in our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a couple of fake employees and save them to a local JSON file. Here
    is some example JSON to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve saved the JSON file, you can import it into the **Employees** collection
    in MongoDB Compass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Importing data into a MongoDB database in Compass](img/B20968_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Importing data into a MongoDB database in Compass'
  prefs: []
  type: TYPE_NORMAL
- en: Our MongoDB collection is now set up with example data. Let us turn our attention
    back to the minimal API, where we will write a new service to interact with this
    NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to install the MongoDB driver in order to support interactions
    with a MongoDB database. You can do this via the **Package Manager Console** in
    Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class called **MongoDbService** , implementing the **IDatabaseService**
    interface. Make sure you reference **MongoDB.Bson** and **MongoDB.Driver** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create a constructor that, as before, receives an injected **IConfiguration**
    object containing the database connection string, before initiating the connection
    with an instance of **MongoClient** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this, a reference to the collection of type, **Employee** can be
    retrieved and stored in a **private** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, complete the implementation of the **IDatabaseService** interface by
    adding the required functions. These functions can simply utilize the **Employee**
    collection for querying and inserting records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The connection string needs to be changed to point to the MongoDB server and
    database. MongoDB connection strings are fairly simple in format. By default,
    the server should be running on port **27017** . Here is how a default connection
    string would look for this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This connection string can then be added to the **ConnectionStrings** object
    in **appsettings.json** . We should also add a Boolean flag to the JSON that allows
    us to specify whether MongoDB should be used, or whether the default SQL connection
    should be adopted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once complete, the **ConnectionStrings** section of **appsettings.json** should
    look like the example shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Having added a new data source connection string and an option to switch from
    the default source to MongoDB, we must register the new **MongoDbService** class
    for dependency injection. We will, however, also need to specify a new rule for
    how the dependency is resolved depending on whether the **UseMongoDB** flag is
    enabled or not.
  prefs: []
  type: TYPE_NORMAL
- en: Back in **Program.cs** , register the new **MongoDbService** class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following singleton registration for **IDatabaseService** , along
    with logic that checks the MongoDB flag in **appsettings.json** before resolving
    the correct database service to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You might not have realized it yet if you haven’t run the code, but we have
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of using an interface for **IDatabaseService** was to ensure that we
    could easily switch between data sources by modifying a Boolean flag in **appsettings.json**
    .
  prefs: []
  type: TYPE_NORMAL
- en: This would be fine if the data structures in the two data sources had identical
    schemas. Unfortunately, they don’t because, in SQL Server, **Id** is an **int**
    type, whereas, in MongoDB, the equivilent identifier is called **_id** and its
    data type is a string.
  prefs: []
  type: TYPE_NORMAL
- en: This means that as it exists currently, **Employee** is interchangeable between
    the two sources. This means that if we switch to MongoDB and try to deserialize
    data to **Employee** , it will fail with **FormatException** due to the differing
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we should create separate models for different data sources. This
    sounds like it goes against the idea of having a flexible system, but we can still
    ensure that we don’t have to modify existing endpoints for different data sources
    by using another interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new interface called **IEmployee** . It does not require any fields
    at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can use this interface to represent an employee model generically, regardless
    of whether it is a SQL Server model or a MongoDB model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new model called **EmployeeMongoDb** and set it up as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By adding the attributes shown in the previous code to the **Id** field, we
    are mapping **Id** to the string-based **_id** field in the MongoDB collection.
    We have also implemented **IEmployee** .
  prefs: []
  type: TYPE_NORMAL
- en: We will treat **Employee** as the default model, seeing as SQL Server is the
    default connection string in **appsettings.json** . Ensure that it also implements
    **IEmployee** .
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must change any area in the MongoDB service or SQL service that returns
    a concrete class to instead return **IEmployee** . You’ll also need to change
    any code that receives **Employee** as an argument. This then requires the service
    to cast **IEmployee** to a compatible concrete implementation, such as **EmployeeMongoDb**
    for the **MongoDb** service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes to both **SqlServerService** and **MongoDbService** can be seen in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing the previous code, we add the **GetEmployeesAsync()** and **AddEmployeeAsync()**
    methods using MongoDB. Notice how, in the **AddEmployeeAsync()** method, we can
    still take in **IEmployee** but then simply convert it to an **EmployeeMongoDb**
    object so that MongoDB can take care of generating a **string** ID, unlike the
    **int** ID used in SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method shows the same code using SQL Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Because **Employee** and **EmployeeMongoDb** both implement **IEmployee** ,
    the endpoint logic no longer has to change. We are preserving genericness at the
    highest level of abstraction, while dealing with more concrete classes lower down
    the abstraction layer within the services.
  prefs: []
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs: []
  type: TYPE_NORMAL
- en: The changes we have made using interfaces help us adhere to the open-closed
    principle, where we aim to allow new data sources to be added in the future without
    having to alter the original code base invasively. We will discuss this principle
    in more detail in [*Chapter 13*](B20968_13.xhtml#_idTextAnchor183) .
  prefs: []
  type: TYPE_NORMAL
- en: This was quite an intense chapter, so let’s review what we’ve covered before
    moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered some basic examples of direct communication
    with a database from minimal API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining the different kinds of databases, with examples of various
    SQL- and NoSQL-based database platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we talked about how using services with dependency injection
    can allow minimal API projects to seamlessly provide minimal API endpoints with
    interoperability with our chosen data source.
  prefs: []
  type: TYPE_NORMAL
- en: We created a service that interacts with a SQL Server database, using **appsettings.json**
    to define the specific properties of our data source for use in the service. We
    leveraged the functionality of **SqlConnection** and **SqlCommand** to execute
    commands and queries against the SQL Server database containing relational employee
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created a counterpart service that interacts with MongoDB, demonstrating
    the differences between **SqlCommand** and the MongoDB driver.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we modified the project using interfaces to make differing data source
    models interchangeable, while preserving the generic style of the API endpoint
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our exploration of data sources further by
    implementing two ORMs within the **Employee** API – Dapper and Entity Framework
    Core.
  prefs: []
  type: TYPE_NORMAL
