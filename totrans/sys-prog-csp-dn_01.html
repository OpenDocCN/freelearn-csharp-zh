<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor026"/>1</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>The One with the  Low-Level Secrets</h1>
			<p><em class="italic">Understanding </em><em class="italic">low-level APIs</em></p>
			<p>Writing software can be a daunting task. You need to consider many things when you try to convert your ideas into something that works on the machine. After all, there are so many things you need to tell the computer before it does something useful.</p>
			<p>But we are in luck. Many of the instructions we need to give the CPU are encapsulated in frameworks, tools, packages, and other pieces of software. These building blocks allow us to focus on what we want to build instead of how the CPU might interpret our instructions. That makes life a lot easier!</p>
			<p>This chapter looks into those building blocks, how they help us, and how we can best use them. This chapter also covers how .NET works and where it comes from. This is important: most developers take the advantages of .NET for granted. That is fine since the framework hides much complexity. However, when writing lower-level system software, it is essential to know why things in .NET work the way they do and how to use other solutions if needed. Also, it doesn’t hurt to be reminded of some basic things occasionally, especially when you might have to deviate from the road user-facing software developers take.</p>
			<p>So, we will cover the following topics:</p>
			<ul>
				<li>What are low-level APIs?</li>
				<li>How does the Base Class Library (BCL) help us .NET developers?</li>
				<li>What is the Common Language Runtime (CLR)?</li>
				<li>What are Win32 APIs and how do we call them?</li>
			</ul>
			<p>All in all, we are going low here and getting all technical.</p>
			<p>But before we dive into the building blocks the .NET ecosystem gives us, we need to chat about APIs – to be more precise, the difference between low-level and high-level APIs.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Technical requirements</h1>
			<p>You can visit the following link to view all the code in this chapter: <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter01</a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>What are low-level APIs, and how do they differ from higher-level abstractions?</h1>
			<p>Well, maybe <a id="_idIndexMarker054"/>we are going a bit too fast. Before we can look at low-level and high-level APIs, we need to agree on what an API means.</p>
			<p>API is an abbreviation for application programming interface. Although technically correct, it doesn’t tell us much. We need a better definition of API.</p>
			<p>What are interfaces?</p>
			<p>Let’s begin with the term <strong class="bold">interface.</strong> That alone can be defined entirely differently, depending on whom you ask.</p>
			<p>An interface can <a id="_idIndexMarker055"/>be a <strong class="bold">software interface</strong>, which is the boundary between two pieces of software. For instance, a database such as SQL Server allows users to access data by accepting SQL queries. That is the main interface for that database system.</p>
			<p>Another definition of an interface <a id="_idIndexMarker056"/>would be a <strong class="bold">hardware interface</strong>. The USB ports on your computer and the peripherals you connect to your machine using them are hardware interfaces.</p>
			<p>Of course, in C#, we also have interfaces. Most object-oriented programming languages support interfaces in one way or another. For instance, C++ has the concept of pure virtual classes. Python supports abstract base classes, which serve the same purpose.</p>
			<p>An API is the interface between a piece of software and other software meant for the programmer. This defines the boundaries of a given code set and how to interact with it.</p>
			<p>So, it is possible to create a giant library filled with wondrous and highly complex code. As the library user, you get a list of methods, classes, interfaces (yes, the C# kind), enums, and other means of interacting with that library.</p>
			<p>This is awesome since you can use that library without worrying about writing code yourself.</p>
			<p>Low-level and high-level APIs</p>
			<p>The level of an <a id="_idIndexMarker057"/>API is an arbitrary distinction to give you an idea of how close to the actual hardware an API is.</p>
			<p>No metric tells us when something is a lower or higher-level API. It is all relative and open for debate. This, however, is something we are not going to do here.</p>
			<p>Generally, a low-level API gives you more granular control over the hardware than a higher-level API. A higher-level API, however, is usually more portable and can be used to achieve goals much quicker.</p>
			<p>If that all sounds a bit abstract, don’t worry. Let me clarify this with some examples. For instance, imagine that you want to send some data across a network. Well, when I say network, I mean we send it to IP address <code>127.0.0.1</code>. In other words, we send it to localhost; we are speaking to ourselves.</p>
			<p>To do this, we<a id="_idIndexMarker058"/> need to call a lot of low-level APIs that the Windows SDK gives us. The code looks like this:</p>
			<pre class="source-code">
static void UseLowLevelAPI()
{
    WSAData wsaData;
    if (WSAStartup(0x0202, out wsaData) != 0)
    {
        Console.WriteLine("WSAStartup failed");
        return;
    }
    IntPtr sock = socket(2 /* AF_INET */, 1 /* SOCK_STREAM */, 0);
    if (sock == new IntPtr(-1))
    {
        Console.WriteLine("socket() failed");
        WSACleanup();
        return;
    }
    sockaddr_in sin = new sockaddr_in();
    sin.sin_family = 2; // AF_INET
    sin.sin_port =(ushort)IPAddress.HostToNetworkOrder((short)8000);     // Port 8000
    sin.sin_addr = BitConverter.ToUInt32(IPAddress.Parse("127.0.0.1")    .GetAddressBytes(), 0);
    if (connect(sock, ref sin, Marshal.SizeOf(typeof(        sockaddr_in))) != 0)
    {
        Console.WriteLine("connect() failed");
        closesocket(sock);
        WSACleanup();
        return;
    }
    byte[] data = Encoding.ASCII.GetBytes("Hello, server!");
    if (send(sock, data, data.Length, 0) == -1)
    {
        Console.WriteLine("send() failed");
    }
    closesocket(sock);
    WSACleanup();
}</pre>			<p>As you can<a id="_idIndexMarker059"/> see, many things must happen for such a relatively simple task. I have omitted all the code we need to access the APIs and the definition of the classes and structs, such as <code>WSAData</code>. I also simplified this sample and didn’t use much error handling or memory management.</p>
			<p>I won’t go through what’s happening in the preceding code as it isn’t part of what I’m trying to show you. We will revisit this later in this book when we discuss networking. I provided this code to show you what a low-level API looks like. Here, I want you to pay attention to the calls to <code>WSAStartup()</code>, <code>WSACleanup()</code>, <code>socket()</code>, <code>connect(</code>), <code>send()</code>, and <code>closesocket()</code>. These are APIs that come from the Windows SDK. They are the parts of Windows that help us set up connections to network interfaces, translate addresses, open and close sockets, and send data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is good to remember that the Windows SDK is a wrapper. The code inside the SDK, written mainly in C and a bit in C++, does the heavy lifting and calls the hardware. We don’t have to worry about this: the people at Microsoft have already figured out how to do all this.</p>
			<p>Like I said, low-level and high-level terms depend on how you look at them. It is all relative. You can consider Windows SDK APIs high-level APIs when you look at them from a C programmer’s perspective, who has to do all the heavy lifting.</p>
			<p>But we, as .NET developers, see this as rather low-level. This is because, as .NET developers, we have even easier tools to use. The preceding code isn’t something most developers will write. Instead, they will write the following:</p>
			<pre class="source-code">
static void UseHighLevelAPI()
{
    try
    {
        // Connect to server at 127.0.0.1:8000
        using (TcpClient client = new TcpClient("127.0.0.1", 8000))
        using (NetworkStream stream = client.GetStream())
        {
            // Prepare the message
            byte[] data = Encoding.ASCII.GetBytes("Hello, server!");
            // Send the message
            stream.Write(data, 0, data.Length);
            Console.WriteLine("Sent: Hello, server!");
        }
    }
    catch (SocketException e)
    {
        Console.WriteLine($"SocketException: {e}");
    }
    catch (IOException e)
    {
        Console.WriteLine($"IOException: {e}");
    }
    catch (Exception e)
    {
        Console.WriteLine($"Exception: {e}");
    }
}</pre>			<p>This code is much easier and a lot smaller. Most of the preceding code consists of catching exceptions.</p>
			<p>The <code>TcpClient</code> class is doing the hard work. We instantiate an instance of it, give it the address we want to connect to, get a <code>NetworkStream</code> instance from it, and then write a bunch of bytes. Simple. It works brilliantly.</p>
			<p>So, why would you care about the low-level stuff?</p>
			<p>Although<a id="_idIndexMarker060"/> the low-level code is a lot more work and complicated, it gives you one significant advantage: more control.</p>
			<p>We use TCP/IP here. But what if the device you want to communicate with doesn’t have TCP? And before you say “Everything is IP-based these days,” I’m pretty sure you have computers in your house that communicate over older technology. You might use devices that don’t have TCP on board every day. I’m talking about remote controls for most television sets. They use infrared. Many devices still use infrared. It’s cheap, well-understood, quick to install, and robust in terms of its use cases. It is also not supported by .NET.</p>
			<p>But when it comes to low-level APIs, it is pretty simple. There are some differences in how to set up the connection: there is no IP address, so you have to use the device ID, but the connection itself is not that hard to use. Look at the line where we set up the call to <code>socket()</code>. We use <code>2</code> as the first parameter, which stands for <code>AF_INET</code>, which means TCP. Change that to <code>26 (AF_IRDA)</code>, and the underlying libraries switch to infrared devices.</p>
			<p>This can’t be done with the .NET libraries that are available.</p>
			<p>The high-level APIs are amazing and help us write code that is easy to understand quickly. However, as systems programmers, we have to deal with hardware and other low-level systems. That’s when we have to use the low-level APIs.</p>
			<p>Before we dive into how to use these APIs, let’s look at the .NET libraries themselves. While we’re at it, we’ll examine the CLR so that you have a clear picture of what .NET gives us.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Overview of .NET Core runtime components (CLR, BCL)</h1>
			<p>Previously, we <a id="_idIndexMarker061"/>examined the difference between low-level and high-level programming languages. Like the APIs, lower and higher mean how close to or far away you are from the actual machine. Programming in C means you are very close to the hardware; programming in C# means you are far away. Of course, being further away means you are working in abstractions. The advantage is that many things are simplified, as seen earlier in this chapter. Also, with many abstractions, moving your code to other platforms is more manageable.</p>
			<p>The magic that makes this possible is the .NET runtime. Since the first version, the designers have always aimed to shield you from the low-level stuff as much as possible. This lets you write your code quickly and focus on functionality instead of boilerplate.</p>
			<p>.NET is a complex topic. But in short, it comes down to a set of tools in many different forms that help you achieve your goal.</p>
			<p class="callout-heading">Fun fact</p>
			<p class="callout">Before its initial launch, the project’s code name was Project 42. 42 is the answer to life, the universe, and everything in the books, TV shows, and the major motion picture from science fiction author Douglas Adams: <em class="italic">The Hitchhikers Guide to the Galaxy</em>. Adams wrote that 42 was the answer to everything; hence, the .NET designers thought it appropriate to name the solution to all developer problems Project 42.</p>
			<p>.NET does not solve all problems, but it makes life much easier. Let’s see how it does that.</p>
			<p>We can identify three major areas where .NET helps us:</p>
			<ul>
				<li>Development tools</li>
				<li>The CLR</li>
				<li>The BCL</li>
			</ul>
			<p>I will not be spending time on development tools here. Instead, I want to discuss the CLR and the BCL. These two form the backbone of the .NET ecosystem. In later chapters, I will cover other essential parts of the .NET ecosystem, such as the <strong class="bold">Common Type </strong><strong class="bold">System</strong> (<strong class="bold">CTS</strong>).</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>CLR</h2>
			<p>CLR is the <a id="_idIndexMarker062"/>runtime environment in which our code runs.</p>
			<p>The compiler (covered later in this book) compiles the<a id="_idIndexMarker063"/> code we have written. For now, we can imagine that the compiler takes our human-readable text and changes it into something a computer can understand and use.</p>
			<p>Well, not quite. I need to clarify things a bit here. Although what I wrote is technically correct when discussing compilers, this is only true for real compilers, such as those found using C or C++. This does not apply to the .NET-based world.</p>
			<p>The .NET compilers compile while targeting a common runtime instead of the hardware we run on.</p>
			<p>The compiler’s output is not native to the hardware. Instead, it outputs something called Intermediate Language (IL). This is a sort of “in-between” form. It’s not human-readable, but it is too abstract for computers to understand. It is in between those two forms.</p>
			<p>Let me clarify that with an example.</p>
			<p>I have written a .NET Console app with no top-level statements. In other words, this is the most simple piece of code we can write using .NET. The whole program consists of one single line:</p>
			<pre class="source-code">
Console.WriteLine("Hello, System Programmers!");</pre>			<p>I don’t need to explain what I’m doing here, right?</p>
			<p>If we use Visual Studio to compile the code, it will take all of our files, give them to the compiler, and instruct it to build a binary. That looks like this:</p>
			<pre class="source-code">
.method private hidebysig static void  '&lt;Main&gt;$'(string[] args) cil managed
{
  .entrypoint
  // Code size       12 (0xc)
  .maxstack  8
  IL_0000:  ldstr      "Hello, System Programmers!"
  IL_0005:  call       void
  [System.Console]System.Console::WriteLine(string)
  IL_000a:  nop
  IL_000b:  ret
} // end of method Program::'&lt;Main&gt;$'</pre>			<p>This is a <a id="_idIndexMarker064"/>bit harder to understand but not too hard. First, there’s some code to set things up (<code>.maxstack 8</code>). We load the string with the call to<a id="_idIndexMarker065"/> the <code>ldstr</code> function and then call the <code>System.Console::WriteLine(string)</code> method, and we are done.</p>
			<p>Again, this is not machine code. That looks a lot harder, and I’m not going to show you that. If compiled to something the CPU can understand and execute, this code is several pages long.</p>
			<p>However, I will show you part of it to give you a taster:</p>
			<pre class="source-code">
00007FF9558C06B0  push        rbp
00007FF9558C06B1  push        rdi
00007FF9558C06B2  push        rsi
00007FF9558C06B3  sub         rsp,20h
00007FF9558C06B7  mov         rbp,rsp
00007FF9558C06BA  mov         qword ptr [rbp+40h],rcx
00007FF9558C06BE  cmp         dword ptr [7FF95597CFA8h],0
00007FF9558C06C5  je
Program.&lt;Main&gt;$(System.String[])+01Ch (07FF9558C06CCh)
00007FF9558C06C7  call        00007FF9B54D7A10
00007FF9558C06CC  mov         rcx,1A871002068h
00007FF9558C06D6  mov         rcx,qword ptr [rcx]
00007FF9558C06D9  call        qword ptr
[CLRStub[MethodDescPrestub]@00007FF9559C17E0
(07FF9559C17E0h)]
00007FF9558C06DF  nop
00007FF9558C06E0  nop
00007FF9558C06E1  lea         rsp,[rbp+20h]
00007FF9558C06E5  pop         rsi
00007FF9558C06E6  pop         rdi
00007FF9558C06E7  pop         rbp</pre>			<p>This tiny<a id="_idIndexMarker066"/> assembly code segment instructs the CPU to take a pointer to the memory where the string is and then calls the first part of the <code>WriteLine</code> method.</p>
			<p>Again, the complete code would be several pages long.</p>
			<p>I hope you <a id="_idIndexMarker067"/>are beginning to appreciate the brevity and simplicity of the .NET system. But I also want you to know what happens behind the scenes. When writing system software, we sometimes need to do things that aren’t possible in .NET. Then, we have to rely on other ways to achieve our results. We won’t write pure assembly in this book: that would be too much. But I do want you to know what’s happening as that will benefit you enormously later on.</p>
			<p>Okay. Between the IL code I showed you and the assembly code I showed you is the place where the CLR lives.</p>
			<p>As stated in <a href="https://learn.microsoft.com/en-us/dotnet/standard/clr">https://learn.microsoft.com/en-us/dotnet/standard/clr</a>, the CLR offers us quite a <a id="_idIndexMarker068"/>lot of things:</p>
			<ul>
				<li>Performance improvements</li>
				<li>The ability to easily use components developed in other languages</li>
				<li>Extensible types provided by a class library</li>
				<li>Language features such as inheritance, interfaces, and overloading for object-oriented programming</li>
				<li>Support for explicit free threading that allows multithreaded and scalable applications to be created</li>
				<li>Support for structured exception handling</li>
				<li>Support for custom attributes</li>
				<li>Garbage collection</li>
			</ul>
			<p>This information<a id="_idIndexMarker069"/> comes straight out of the documentation from Microsoft, so if you want to know more, I urge you to look it up and read more <a id="_idIndexMarker070"/>about it. Later chapters will discuss some of these items, such as threading, exception handling, and garbage collection. For now, it is enough to know that when we compile our code, we prepare it for the CLR to use and run it. The CLR will take care of the rest and make it work nicely on actual hardware.</p>
			<p>The code that runs on the CLR is what we call managed code. All other code (thus code not under the CLR’s control) is unmanaged. You will deal with managed code most of the time, but when writing system software, you’ll encounter unmanaged code quite frequently. But don’t worry: I will guide you through that!</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>BCL</h2>
			<p>One of the <a id="_idIndexMarker071"/>goals the designers of .NET had in mind was to eliminate something developers called DLL Hell.</p>
			<p>The<a id="_idIndexMarker072"/> idea was that, when writing software, developers quickly realized that writing the same code repeatedly would be tiresome and a nightmare to maintain. Instead, they created libraries with functions they could reuse. These libraries would be loaded on demand and linked to the calling code. That is where the <a id="_idIndexMarker073"/>name <strong class="bold">Dynamic Link Library</strong> (<strong class="bold">DLL</strong>) originated.</p>
			<p>Of course, developers, being developers, were not content with the DLLs they or someone else wrote earlier and made changes to them. These changes weren’t always backward compatible. That meant that as a user of a DLL, you had to make sure you used the correct version. You couldn’t easily upgrade without testing if that particular version of the DLL worked with your code.</p>
			<p>There were <a id="_idIndexMarker074"/>two types of DLLs. One was proprietary to your code. You placed these DLLs in the same directory as your application, so all you needed to do was load the DLLs in your app directory. If a new application version came out, it came with its own set of DLLs.</p>
			<p>Since most of the DLLs didn’t change a lot (if they even changed at all) there were many repetitive and duplicate DLLs. So, instead of duplicating code, we were now duplicating DLLs.</p>
			<p>Fortunately, a solution was available: you could place DLLs in a shared space. On Windows, that was the <code>C:\Windows\System32</code> directory. The runtime knew that if it needed to load a DLL and couldn’t locate it in the <code>applications</code> directory, it could look at the <code>System32</code> directory and find it there.</p>
			<p>When doing this, you needed to be sure you maintained backward compatibility.</p>
			<p>Naturally, things went wrong. Updates would replace DLLs with newer, non-compatible versions. Sometimes, applications updated a DLL without realizing something else depended on it. Sometimes, an update would delete DLLs and thus break applications. In many cases, developers deployed the wrong versions. The list goes on and on. This caused many developers many frustrations and resulted in them calling this DLL Hell. Project 42 was set up to solve this. And in a way, it did.</p>
			<p>A few decades ago, a <code>String</code> class was the first thing a new C++ programmer would write. C and C++ did not have such a thing: strings were not native to the language (they still aren’t, but the helper classes containing them are part of the standard now). A string can be pretty simple: it is just a pointer to a place in memory where all subsequent bytes form one long string. The string ends when the system sees a byte with a value of 0 (zero, not the character o). That’s it. A <code>String</code> class would contain the address of that array of bytes, some helper methods that allocate and clear the memory, and additional functions such as <code>Length()</code>. That’s it.</p>
			<p>Soon, everybody wrote different versions, which would all be slightly different. .NET solved that by having a <code>String</code> class available. That class was part of a DLL that got shipped with the framework. The system registered that DLL, along with its version number. So, all developers needed to do was tell the system which version of the framework it was using, and by magic, things such as Strings were available. I am oversimplifying things here, but that is basically how things work.</p>
			<p>There is a vast library that you can use as a .NET developer. You can see it in <code>C:\Windows\assembly</code>. If you use Windows Explorer, you’ll see a filtered view of the contents. You can see the actual contents using a terminal or command line.</p>
			<p>These <a id="_idIndexMarker075"/>DLLs are part of the BCL. The BCL is a set of helper classes, functions, methods, and enums that help you do your work. Instead of figuring out all the code yourself, it is part of the installation and ready to use.</p>
			<p>The classes and other code constructs in the DLLs that form the BCL are organized into namespaces. The<a id="_idIndexMarker076"/> BCL contains lots of helpful code some of which are as follows:</p>
			<ul>
				<li><code>System</code> namespace, which contains classes such as O<code>bject</code>, <code>String</code>, <code>Array</code>, and so on.</li>
				<li><code>System.IO</code> namespace, for dealing with files, streams, and more.</li>
				<li><code>System.Net</code> for dealing with networking.</li>
				<li><code>System.Threading</code> for dealing with – you guessed it – multithreading.</li>
				<li><code>System.Data</code> for dealing with data storage in databases and other ways of persisting data.</li>
				<li><code>System.Xml</code> here, which you can use to handle XML files and data.</li>
				<li><code>System.Diagnostics</code> helps you identify issues in your code. We will be diving into this one later.</li>
				<li><code>System.Security</code> namespace, along with all things related to security and encryption.</li>
			</ul>
			<p>There are many more namespaces, but these are some of the most used ones. We will revisit them later.</p>
			<p>However, remember that these classes are there to help you. They wrap complicated and extensive code in good ways for most developers. However, If you find that the BCL code doesn’t get you where you want to be, nothing is stopping you from writing the code yourself. As we saw earlier, the BCL code is awesome if you want to set up a TCP/IP connection, but if you want to use an infrared connection instead, you must do it yourself.</p>
			<p>The good news is that you can mix and match. Use the BCL where you can and low-level APIs where you need to.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using P/Invoke to call low-level APIs</h1>
			<p>We have<a id="_idIndexMarker077"/> established that .NET gives you many tools to develop something quickly. It also helps you out by shielding you from the low-level details of <a id="_idIndexMarker078"/>the underlying operating system. But it also allows you to use low-level APIs if you need to.</p>
			<p>But how can we access those APIs? The answer is <strong class="bold">Platform Invocation</strong>, or (<strong class="bold">P/Invoke</strong>). We<a id="_idIndexMarker079"/> can use this tool to access the Win32 API directly. P/Invoke bridges the gap between the two platforms so that we can mix and match to our hearts’ content.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Win32 is the name of the SDK and the APIs made available. There is no such thing as a Win64 API. Our code is compiled against 64-bit Windows if you run that platform, yet we (and Microsoft) still call it the Win32 API.</p>
			<p>How does P/Invoke work?</p>
			<p>P/Invoke involves<a id="_idIndexMarker080"/> a couple of steps. These are the steps you must follow to use a Win32 API in a .NET application:</p>
			<ol>
				<li>Find the API you want to use.</li>
				<li>Find the DLL the API resides in.</li>
				<li>Load that DLL in your assembly.</li>
				<li>Declare a stub that tells your application how to call that API.</li>
				<li>Convert the .NET data types into something the Win32 API can understand.</li>
				<li>Use the API.</li>
			</ol>
			<p class="callout-heading">Warning!</p>
			<p class="callout">You are out of the loving and caring hands of .NET Framework and the CLR. You are no longer protected against mistakes. You are in an unmanaged world now. In the old days, they probably would have marked this part of the documentation with the warning “Here be dragons.” You are now responsible for many more things than you might be used to, such as memory management and error handling. You have more power over the system now, but remember: great power comes with great responsibility!</p>
			<p>Let me<a id="_idIndexMarker081"/> start <a id="_idIndexMarker082"/>with an example. This showcases the power of .NET Framework, but it also shows how the aforementioned steps work in <a id="_idIndexMarker083"/>practice. We are going to do a simple “Hello World.”</p>
			<p>To make sure we’re on the same page, let me show you the .NET version of this program:</p>
			<p><code>Console.WriteLine(“Hello, </code><code>System Programmers!”);</code></p>
			<p>Yes, this is the same sample we saw earlier. Hey, we have to start somewhere, right?</p>
			<p>Now, <code>Console</code> is a class from the BCL. It has a static method, <code>WriteLine</code>, that outputs that string to the output. But what if we assume we don’t want to use that class? How should we go about this then? To frame this question another way, how does <code>WriteLine</code> work internally? After all, there has to be a point somewhere during execution where the code has to call the Win32 API. That can be done by the CLR or by us, but something or someone has to call it.</p>
			<p>Let’s rewrite the code using P/Invoke. I will show you the entire program first, then dissect it and explain how it works line by line:</p>
			<pre class="source-code">
01: using System.Runtime.InteropServices;
02:
03: [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError =         true)]
04: static extern bool WriteConsole(
05:     IntPtr hConsoleOutput,
06:     string lpBuffer,
07:     uint nNumberOfCharsToWrite,
08:     out uint lpNumberOfCharsWritten,
09:     IntPtr lpReserved);
10:
11: [DllImport("kernel32.dll", SetLastError = true)]
12: static extern IntPtr GetStdHandle(int nStdHandle);
13:
14: const int STD_OUTPUT_HANDLE = -11;
15:
16: IntPtr stdHandle = GetStdHandle(STD_OUTPUT_HANDLE);
17: if (stdHandle == IntPtr.Zero)
18: {
19:     Console.WriteLine("Could not retrieve standard output           handle.");
20:     return;
21: }
22:
23: string output = "Hello, System Programmers!";
24: uint charsWritten;
25:
26: if (!WriteConsole(
27:     stdHandle,
28:     output,
29:     (uint)output.Length,
30:     out charsWritten,
31:     IntPtr.Zero))
32: {
33:     Console.WriteLine("Failed to write using Win32 API.");
34: }</pre>			<p>That’s a lot of code, but let’s go through it.</p>
			<p>In <em class="italic">line 1</em>, we import <a id="_idIndexMarker084"/>the namespace that allows us to use<a id="_idIndexMarker085"/> P/Invoke. .NET uses the name <code>InteropServices</code> for this, so it makes sense to import that.</p>
			<p>In <em class="italic">line 3</em>, we see the magic happening. Remember the steps we have to take? <em class="italic">Step 1</em> is to “Find the API you want to use.” Since we want to print something on the screen, the <code>WriteConsole</code> API sounds like a good fit.</p>
			<p>The official documentation from Microsoft states that the <code>WriteConsole</code> API “<em class="italic">Writes a character string to a console screen buffer beginning at the current cursor location.</em>” That sounds good to me.</p>
			<p>The documentation then gives us the signature of this API:</p>
			<pre class="source-code">
BOOL WINAPI WriteConsole(
  _In_             HANDLE  hConsoleOutput,
  _In_       const VOID    *lpBuffer,
  _In_             DWORD   nNumberOfCharsToWrite,
  _Out_opt_        LPDWORD lpNumberOfCharsWritten,
  _Reserved_       LPVOID  lpReserved
);</pre>			<p>If you’re a .NET developer, this might look weird. A lot is going on that we don’t know about or understand. We need to translate those types into something the CLR understands. Luckily, somebody has already figured that out for us. To make life even easier, they did <em class="italic">Steps 2</em> (find the DLL) and <em class="italic">4</em> (declare the stub) for us as well. Given the correct parameters, the CLR takes care of <em class="italic">Step 3</em> (load the DLL).</p>
			<p>That “someone who figured this out” is the people behind <a href="https://pinvoke.net">https://pinvoke.net</a>. You can search for APIs and learn how to use them there.</p>
			<p>The official <a id="_idIndexMarker086"/>documentation has a part called <code>Kernel32.dll</code> (<code>Pinvoke.Net</code> also gives you that information).</p>
			<p><em class="italic">Line 3</em> is what tells <code>InteropServices</code> to load the DLL. Let’s dive into that:</p>
			<pre class="source-code">
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]</pre>			<p>This line tells the <a id="_idIndexMarker087"/>CLR to load <code>kernel32.dll</code>. It then specifies how to handle characters. Characters and strings can be complicated. There are several different ways to represent a single character. It can be an ASCII character, it can be Unicode, or it can be ANSI. They all have a different representation in memory. Here, we say we want to use <code>Auto</code>. When doing that, the system looks at the complete string we use, finds out which set it can use to represent the complete string, and uses the first one it can find. Since it starts by trying to fit it in an ASCII string and then “moves up” toward more complicated, slower, and more memory-intensive ways, this guarantees we get the best way to represent this string.</p>
			<p>Next, we can see <code>SetLastError = true</code>. This instructs the system to inform us whenever something goes wrong. In case of an error, it calls the <code>GetLastError</code> API to get the error and return it to us. We will use this a lot later. For now, I advise you to always set <code>SetLastError</code> to <code>true</code>.</p>
			<p>Our runtime now knows to load <code>kernel32.dll</code>. But we must tell it what specific API we want to use. That happens in the following line. The function’s signature must always follow that <code>DllImport</code> directly: they always belong together. If you want to load multiple functions from the same Dll, you must still use <code>DllImport</code> for each.</p>
			<p>The following line is the stub for the function:</p>
			<pre class="source-code">
static extern bool WriteConsole(
    IntPtr hConsoleOutput,
    string lpBuffer,
    uint nNumberOfCharsToWrite,
    out uint lpNumberOfCharsWritten,
    IntPtr lpReserved);</pre>			<p>This<a id="_idIndexMarker088"/> looks like <a id="_idIndexMarker089"/>the code we saw from the official documentation, but now, the types have been translated into their .NET equivalents. Again, <code>Pinvoke.Net</code> is your friend here!</p>
			<p>The parameters are more or less self-explanatory, except for the first one. Let’s skip that one and look at the others:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">String lpBuffer</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">The string we want </strong><strong class="bold">to print</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>nNumberOfCharsToWrite</p>
						</td>
						<td class="No-Table-Style">
							<p>The number of characters we want to print from the given string</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>lpNumberOfCharsWritten</p>
						</td>
						<td class="No-Table-Style">
							<p>How many characters were written to the system</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>lpReserved</p>
						</td>
						<td class="No-Table-Style">
							<p>This isn’t used, so it can be ignored</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1: Parameters for WriteConsole</p>
			<p>One thing to notice here is that Win32 APIs use the Hungarian notation for their parameters. This style says you have to prefix every parameter with an abbreviation of the type so that when you read the code later, you know what type this stands for. In the days before the current modern and fast IDEs, this helped a lot: you couldn’t hover your mouse over a variable to see what type it was; you had to scroll through the code to find the declaration. By prefixing it, you could see it immediately. These days, we don’t need to do that anymore, but C and C++ developers still use this standard.</p>
			<p>So, as you can see, the string to print is a long pointer (lp), and the number of characters to write is a number (n).</p>
			<p>But let’s have a look at <code>hConsoleOutput</code>. It is a handle (it starts with h), which translates it into <code>IntPtr</code> in .NET.</p>
			<p>A pointer is just an address of something in memory. In our case, this memory belongs to the place where the console is. But how do we get that? Where is the code that controls <code>Console</code>, which is located in memory?</p>
			<p>The <a id="_idIndexMarker090"/>answer is <a id="_idIndexMarker091"/>that we don’t know. There is no fixed place; this can and will change every time you restart your program. So, we need to look for it.</p>
			<p>Luckily, that isn’t that hard to do as there’s an API we can use to do so. This API is called <code>GetStdHandle</code> and it lives in <code>kernel32.dll</code>. We know how to import that, and we can see it in our code on <em class="italic">lines 11</em> and <em class="italic">12</em>:</p>
			<pre class="source-code">
[DllImport("kernel32.dll", SetLastError = true)]
static extern IntPtr GetStdHandle(int nStdHandle);</pre>			<p>There are no strings, so we don’t need to set <code>CharSet</code>. However, we do need to set <code>SetLastError</code>.</p>
			<p>The method to find the address is called <code>GetStdHandle</code>, and it takes one parameter: <code>nStdHandle</code>. This tells this API what type of Console we are looking for. There are three types available:  <code>STD_INPUT_HANDLE, STD_OUTPUT_HANDLE</code>, and <code>STD_ERROR_HANDLE</code>. These three constants have -10, -11, and -12 as values, respectively. You’re right if you think it’s strange that they’re negative values. It’s weird. However, in Win32, these values are unsigned. They are the end of the integer range, so they don’t get in the way of any other types of console you might define yourself. Casting a high value of an unsigned int to a signed int results in a negative value.</p>
			<p>On <em class="italic">line 14</em>, we define the <code>STD_OUTPUT_HANDLE</code> constant and give it a value of <code>-11</code>. This sort of thing is common: the Win32 API is a mess with magic numbers and constants.</p>
			<p>On <em class="italic">line 16</em>, we use <code>GetStdHandle</code> to get the pointer to <code>Console</code> in memory, giving it <code>STD_OUTPUT_HANDLE</code>. If that goes wrong, we get a 0 (zero) back. But since .NET is strongly typed, we cannot use that number. Instead, we have to use the <code>IntPtr.Zero</code> constant, which is the same thing but in the correct type.</p>
			<p>Every time you get a 0 back from a Win32 API, you have an error situation going on. We need to deal with that, but that is a topic for later.</p>
			<p>Assuming all goes well, we can define our string, and the <code>out</code> variable tells us how many characters are written (<em class="italic">lines 23</em> and <em class="italic">24</em>).</p>
			<p>Then, on <em class="italic">line 26</em>, we call the actual API:</p>
			<pre class="source-code">
if (!WriteConsole(
    stdHandle,
    output,
    (uint)output.Length,
    out charsWritten,
    IntPtr.Zero))
{
    Console.WriteLine("Failed to write using Win32 API.");
}</pre>			<p>This<a id="_idIndexMarker092"/> should be clear now. We call the API, give it the correct parameters, and check if the result is <code>0</code> (<code>IntPtr.Zero</code>).</p>
			<p>The CLR <a id="_idIndexMarker093"/>converts the complex .NET <code>String</code> type into a simple array of bytes with a 0 at the end. We don’t have to worry about that. We can give this API a C# string and everything will work out fine.</p>
			<p>And that’s it. We have written something to the console using Win32 APIs!</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Dealing with errors</h1>
			<p>In the<a id="_idIndexMarker094"/> previous examples, we did a little bit of error checking. If we couldn’t get the handle, we showed a message. We did the same thing if we couldn’t write to the console. I realize it’s funny to write to the console that the system cannot write to it (look at <em class="italic">line 33</em>, for instance), but you get what I mean here.</p>
			<p>But this isn’t good enough if you want to know what’s going on for real. We need a more thorough way of handling errors.</p>
			<p>In .NET, we are used to getting exceptions whenever things go wrong. We know how to deal with that. In the low-level world, things are different. When something goes wrong, we get <code>0</code> back, and we’re left to deal with it. We could continue with the code without being bothered by the error. We could even ignore the results of a call to an API. However, that would lead to disaster. You should always check and deal with the results of an API call. How to deal with that is something we discuss in this section.</p>
			<p>There is a<a id="_idIndexMarker095"/> low-level API called <code>GetLastError</code> that can help us out here. The signature for P/Invoke is as follows:</p>
			<pre class="source-code">
[DllImport("kernel32.dll")]
static extern uint GetLastError();</pre>			<p>It seems pretty straightforward. There are no parameters to worry about, and we don’t have to set that <code>SetLastError</code> value here. Since <code>SetLastError</code> ensures that any error is saved in the registry so that <code>GetLastError</code> can read it, there’s no value in having that here. If there would be, and we set it to false, then how does <code>GetLastError</code> work?</p>
			<p>This function returns an unsigned integer. This number corresponds with an error; you can look up what that number means in the documentation.</p>
			<p>But there’s an issue: it doesn’t work. Well, it does, but there are no guarantees regarding the result.</p>
			<p>The BCL and the <code>CLR</code> work with the low-level Win32 APIs constantly. That is obvious: the BCL is a wrapper around the Win32 API, and the CLR uses that wrapper to call into the core system of the operating system. We can call the APIs ourselves, as we have just done, but the CLR also calls it. Sometimes, it does it in the same thread. Other times, it calls it on another thread. Things can also go wrong during the CLR calls to the APIs. That results in <code>GetLastError</code> possibly returning no errors or the wrong errors. Well, technically, they aren’t the wrong errors, but they might not have to do anything with what we’re doing.</p>
			<p>Luckily, the designers of .NET have thought about that and have added a class called <code>Marshal</code> to the <code>System.Runtime.InteropServices</code> namespace. That class is used to marshal between managed and unmanaged code – or, to put it in the context of what we are doing here, between Win32 APIs and our C# .NET code.</p>
			<p>Let’s assume we made a mistake. I know that’s hard to imagine but bear with me here. Instead of assigning <code>-11</code> to <code>STD_OUTPUT_HANDLE</code>, we set it to <code>11</code>. We all make mistakes, right?</p>
			<p>We then call <code>GetStdHandle</code> with <code>11</code>. That isn’t correct; we know that. The documentation says that the function returns <code>0</code> (or <code>IntPtr.Zero</code> in C#) if anything goes wrong. But in our case, it returns something else: <code>0xffffffffffffffff</code>. This is the unsigned version of the signed value, <code>-1</code>. In other words, the call to the API returns <code>-1</code>, which is not a valid handle.</p>
			<p>However, we don’t check that. We only check for the <code>0</code> value. This makes sense if you think about it. After all, <code>0</code> indicates something went wrong when calling that function. That didn’t happen: the function worked flawlessly. It just didn’t find anything matching the ID we gave it (<code>11</code> instead of <code>-11</code>). So, as far as the API is concerned, there are no errors.</p>
			<p>But then we<a id="_idIndexMarker096"/> get to the point where we call <code>WriteConsole</code>. We give it the handle of the console – or rather, we think we do. Instead, we give it a value of <code>-1</code> (<code>0xffffffffffffffff</code>). That is not a valid handle that <code>WriteConsole</code> can work with.</p>
			<p>In .NET you would get an exception, but that doesn’t happen here. The code continues happily without complaining. It just doesn’t output anything.</p>
			<p>These errors can be a pain to find and solve. In this case, it is quite straightforward, but imagine a situation where you try to set up a connection to an infrared receiver and something goes wrong. However, we keep going since we don’t check for that result. By the time we are ready to send data, nothing happens – or worse, the system crashes. We start to look at the code that does the actual sending, but nothing is wrong there. It takes much time and careful debugging to see that the error happens when we set up the connection. Let me repeat something I said earlier: you should always check the results of all API calls. That burden is on you. The .NET runtime generates exceptions in these cases, but if you are in unmanaged land, you are responsible for doing so.</p>
			<p>Let’s improve our code a bit.</p>
			<p>First, we’ll wrap our call to <code>WriteConsole</code> in a <code>try-catch</code> block and just catch <code>Exception</code>, although that is generally a bad idea. However, here, this is good enough.</p>
			<p>If <code>WriteConsole</code> returns <code>IntPtr.Zero</code>, we have a problem and something goes wrong. In an unmanaged environment, you would call <code>GetLastError</code> to see what happens, but that doesn’t work here. Instead, we use that <code>Marshal</code> class I spoke about earlier:</p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    Console.WriteLine($ something went wrong. Error code:
        {lastError}");
}</pre>			<p>When<a id="_idIndexMarker097"/> running this with <code>STD_OUTPUT_HANDLE</code> set to <code>11</code>, the system reports that something went wrong. It even tells us that the error code is <code>6</code>.</p>
			<p>Looking this up in the official documentation results in the following information:</p>
			<p>ERROR_INVALID_HANDLE</p>
			<p>6 (0x6)</p>
			<p>The handle is invalid.</p>
			<p>This is precisely what’s going on.</p>
			<p>“Wait a minute,” I can almost hear you say. “I can’t ask my users to look up the official documentation to see what an error message means every time something goes wrong!”</p>
			<p>Well, you’ve got a point there. And the .NET design team agrees. They’ve added some ways to get that error message. There are two ways to get it, and you can choose which one you want.</p>
			<p>First, if you want to have that error message, you can get it with the following code:</p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    var errorMessage = Marshal.GetPInvokeErrorMessage(lastError);
    Console.WriteLine($"Something went wrong. Error message:         {errorMessage}");
}</pre>			<p>Again, we <a id="_idIndexMarker098"/>start by getting the error code. We always have to do this, and we should do it as quickly as possible before another error somewhere else messes things up.</p>
			<p>Then, we call the <code>Marshal.GetPInvokeErrorMessage</code> method and give it that <code>lastError</code> code. It returns a string telling us <code>The handle </code><code>is invalid.</code></p>
			<p>Nice. But what if this error is so impactful that we cannot continue? .NET tells us to use exceptions in those cases. Good practice teaches us never to throw an exception but to use a specialized derived exception. We have just the right thing for that: <code>Win32Exception</code>.</p>
			<p>We could throw that and set the message to the message we got from <code>GetPInvokeErrorMessage</code>, but since that is such a common scenario, .NET Framework gives us a shortcut to do just so. Look at the following code:</p>
			<pre class="source-code">
try
{
    if(!WriteConsole(stdHandle, output, (uint)output.Length, out         charsWritten, IntPtr.Zero))
    {
        var lastError = Marshal.GetLastWin32Error();
        throw new Win32Exception(lastError);
    }
}
catch(Win32Exception e)
{
    Console.WriteLine($"Error: {e.Message}");
};</pre>			<p>This looks a lot better. This code results in a message on our screen stating <code>Error: The handle is invalid</code>. Okay, since this is just a simple example, I fail to properly deal with the issue (a rethrow would be a good idea here). How you continue after such an error depends on your coding style, your use case, and what you want to achieve.</p>
			<p>There is one <a id="_idIndexMarker099"/>other way to get the error message. This one is quite nice but not as straightforward as the others we’ve discussed: <code>FormatMessage</code>.</p>
			<p>The <code>FormatMessage</code> function comes from the Win32 API. Its declaration is as follows:</p>
			<pre class="source-code">
[DllImport("kernel32.dll")]
static extern uint FormatMessage(
    uint dwFlags,
    IntPtr lpSource,
    uint dwMessageId,
    uint dwLanguageId,
    [Out] StringBuilder lpBuffer,
    uint nSize,
    IntPtr Arguments);</pre>			<p>If we have an error code, we can use it as follows:</p>
			<pre class="source-code">
var lastError = Marshal.GetLastWin32Error();
int bufferSize = 256;
var errorBuffer = new StringBuilder(bufferSize);
var res = FormatMessage(
    0x00001000,
    IntPtr.Zero,
    (uint)lastError,
    0,
    errorBuffer,
    (uint)bufferSize,
    IntPtr.Zero);
if(res != IntPtr.Zero)
{
    var formattedError = errorBuffer.ToString();
    Console.WriteLine(formattedError);
}</pre>			<p>First, we <a id="_idIndexMarker100"/>create <code>StringBuilder</code>. The API uses this to build up the string with the error message. We give it a size of <code>256</code> characters. This size should be enough for most, if not all, errors. We need to give this size since in C and C++, you need to allocate a buffer beforehand; it cannot expand dynamically (well, it could, but you wouldn’t do that if you want high performance). We call <code>FormatMessage</code> with the 0x00001000 flag. This flag means “use the error code provided.” We can use other flags, but this one is used most of the time. We don’t have a message we want to format, so the second parameter is <code>IntPtr.Zero</code>. Then, we give it <code>lastError</code>, 0 for the language (that is, the system default, usually English), the buffer, the size of the buffer, and another <code>IntPtr.Zero</code> parameter. This last one means we don’t use arguments. Here, arguments are the same as what we have in C# when we want to format a string:</p>
			<pre class="source-code">
Console.WriteLine("Hello {0}", 42);</pre>			<p>Here, <code>42</code> is the argument.</p>
			<p>We get that same “The handle is invalid” message when we run this.</p>
			<p>You might want to use this API because it can do some nice tricks. For instance, replace <code>languageId</code> code 0 with the code 0x0413. This <code>languageId</code> is the Windows language ID for Dutch (please use whatever language you want.)</p>
			<p>The result is <code>De ingang is ongeldig</code>, which is more or less a good translation of the original error.</p>
			<p>This way, you can have nicely formatted, translated error messages!</p>
			<p>There’s one last thing to cover here: many samples online use the following code:</p>
			<pre class="source-code">
if(!WriteConsole(stdHandle, output, (uint)output.Length, out charsWritten, IntPtr.Zero))
{
    var lastError = Marshal.GetLastWin32Error();
    var errorMessage = new Win32Exception(lastError).Message;
    Console.WriteLine($"Error: {errorMessage}");
}</pre>			<p>Technically, there’s <a id="_idIndexMarker101"/>nothing wrong with this. But this isn’t why exceptions are there. Creating one just to get the message is wrong. However, I have seen this so many times that I thought I should warn you against it. If you don’t want to throw an exception, don’t create one. In that case, call <code>Marshal.GetPInvokeErrorMessage</code> instead. You will do yourself and those maintaining your code a huge favor.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Issues when debugging code with low-level APIs</h1>
			<p>Working with<a id="_idIndexMarker102"/> low-level APIs such as the Win32 API opens up a treasure trove of new and powerful tools. However, it comes with a <a id="_idIndexMarker103"/>couple of downsides. Debugging your code suddenly gets a lot harder, and it also becomes more critical.</p>
			<p>There are a couple of areas you need to be aware of when you want to debug your code using low-level APIs:</p>
			<ul>
				<li>Error handling</li>
				<li>Interoperability</li>
				<li>Debugging tools</li>
				<li>Compatibility and portability</li>
				<li>Documentation and community support</li>
			</ul>
			<p>Each of these can pose a challenge, requiring you to think about your debugging strategy before you start coding. Let’s go through the potential issues.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Error handling</h2>
			<p>As <a id="_idIndexMarker104"/>mentioned previously, you’re responsible for error handling when using low-level APIs. You don’t get exceptions from the functions you call when something goes wrong. You always have to be careful to check the return code of the calling code to see if it is 0. And even then, there is no guarantee that things work out as you expected. For instance, the call to <code>GetStdHandle</code> worked fine when we gave it an invalid type of <code>ConsoleId</code>, but the result was still not what we expected. You have to be very careful with these kinds of calls. Ideally, we would have caught that problem immediately and informed the system that something went wrong.</p>
			<p>Even if you catch all the error codes, that doesn’t mean you can identify what went wrong. Sometimes, the error messages are so cryptic that you must read the documentation to see what’s happening.</p>
			<p>There is a method in the API called <code>CoCreateInstance</code>. It deals with creating COM objects, which you use to connect to other systems, such as Word or Excel. To make that connection, give it the ID of the object you want to connect to. Those IDs are in the form of GUIDs, and you have to type them in. If there ever were a situation where it is easy to get things wrong, this would be it.</p>
			<p>Using a non-existing <code>ClassID</code> returns an error code of <code>0x80004005</code>. If we use the methods described previously to get the error message, you would expect to read something like <code>Invalid ClassId</code> or <code>COM Object not found</code>. Unfortunately, what you get is <code>E_FAIL: </code><code>Unspecified error</code>.</p>
			<p>Sigh.</p>
			<p>That isn’t helpful at all, is it? It failed. Okay, we got that. But why? What failed? We don’t know. The system doesn’t help you here at all. You have to know what you’re doing and what the system expects and go through every single line of the code to spot the error. That’s not easy.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Interoperability</h2>
			<p>As we’ve <a id="_idIndexMarker105"/>discussed, one of the steps you must take when calling Win32 APIs is to translate the types used in C# into their Win32 equivalents and vice versa. Sometimes, that’s easy; sometimes, it can be pretty challenging.</p>
			<p>The framework designers did a lot to help us: when the Win32 API expects a string, you can usually give it a C# string, and the CLR marshals the type back and forth without you even knowing it. But still, there is some marshaling going on. A C-style string is a pointer to a place in memory where a character sits. The next character is next to it, and so on, until the system finds a value of 0. That is the end-of-string marker. This is entirely different from the <code>String</code> class we have in C# (internally, the <code>String</code> class still has that list of characters ending with 0 somewhere, but we never see that, so we can pretend it isn’t there at all).</p>
			<p>Most types in C# have a sibling in Win32. Here’s a list of the most used types:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">C# Type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Win32 Type</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>byte</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>BYTE</code></p>
						</td>
						<td class="No-Table-Style">
							<p>8-bit unsigned integer.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>sbyte</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>CHAR</code></p>
						</td>
						<td class="No-Table-Style">
							<p>8-bit signed integer, typically used for ASCII characters.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>short</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>SHORT</code></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit signed integer.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ushort</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>WORD</code></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit unsigned integer.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>int</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>INT</code> or <code>LONG</code></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit signed integer</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>uint</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>UINT</code> or <code>DWORD</code></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit unsigned integer. Also used for flags and enumerations.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>long</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>LONGLONG</code></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit signed integer.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ulong</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>ULONGLONG</code></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit unsigned integer.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>float</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>FLOAT</code></p>
						</td>
						<td class="No-Table-Style">
							<p>32-bit floating-point number.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>double</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>DOUBLE</code></p>
						</td>
						<td class="No-Table-Style">
							<p>64-bit floating-point number.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>char</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>WCHAR</code> or <code>TCHAR</code></p>
						</td>
						<td class="No-Table-Style">
							<p>16-bit Unicode character in C#, whereas <code>WCHAR</code>/<code>TCHAR</code> varies in Win32.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>bool</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>BOOL</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Boolean type. <code>True</code> or <code>False</code> in C#, and typically <code>TRUE</code> or <code>FALSE</code> in Win32. Here, <code>FALSE</code> is defined as <code>0</code>, whereas <code>TRUE</code> is defined as <code>NOT FALSE</code>, meaning any other value, but usually, it is <code>1</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>IntPtr</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>HANDLE</code>, <code>HINSTANCE</code>, <code>HWND</code>, and so on</p>
						</td>
						<td class="No-Table-Style">
							<p>Represents a pointer or a handle. The type varies on context.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>UIntPtr</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Rarely used in Win32</p>
						</td>
						<td class="No-Table-Style">
							<p>An unsigned pointer or handle.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>T[]</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>T*</code> or <code>SAFEARRAY</code></p>
						</td>
						<td class="No-Table-Style">
							<p>An array of the <code>T</code> type. Its representation depends on the context in Win32.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>DateTime</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>FILETIME</code> or <code>SYSTEMTIME</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Represents Date and Time. Representation varies in Win32.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>Guid</code></p>
						</td>
						<td class="No-Table-Style">
							<p><code>GUID</code> or <code>UUID</code></p>
						</td>
						<td class="No-Table-Style">
							<p>GUID. 128-bit number. (GUID is usually tied to Windows platforms, while UUID is found on other platforms. They are basically the same, though.)</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>TimeSpan</code></p>
						</td>
						<td class="No-Table-Style">
							<p>Typically represented by a combination of <code>DWORDs</code></p>
						</td>
						<td class="No-Table-Style">
							<p>A time interval. This is not available on Win32.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table1.2: C# and Win32 types</p>
			<p>As you can<a id="_idIndexMarker106"/> see, most types can easily be translated between the platforms. When we dive into the more complex types, things get a bit more complicated since a lot of them are dependent on context or implementation. This makes marshaling types between the platforms a challenge.</p>
			<p>Another<a id="_idIndexMarker107"/> thing to consider is something called calling convention. A calling convention defines how to handle parameters when calling a function. The two most common types are <code>stdcall</code> and <code>cdecl</code>. Win32 APIs usually use <code>stdcall</code>, while most other C libraries expect <code>cdecl</code>.</p>
			<p>I won’t dive too deep into these two calling conventions. However, let’s summarize the most important differences:</p>
			<ul>
				<li><code>stdcall</code>: The callee cleans the stack. It has a fixed number of arguments and it is commonly used in the Windows API. Here, function names usually get decorated.</li>
				<li><code>cdecl</code>: The caller cleans the stack and allows variable-length argument lists. It is commonly used in the C standard library. Here, function names aren’t decorated.</li>
			</ul>
			<p>As you can see, knowing how to call a function is essential. The wrong convention can mess up the stack, and the arguments are passed to the function or return the wrong results. You could even mess up the memory, which is almost unheard of when writing managed code.</p>
			<p>When you don’t specify the calling convention, <code>stdcall</code> is assumed. You should give the correct calling convention if you need to call another library.</p>
			<p>Maybe an example would help here. We used <code>WriteConsole</code> to write to the console earlier, but there is a much easier way: the <code>printf</code> function. This function is part of the C runtime in the Microsoft <code>msvcrt.dll</code> library. If you want to use this function, import it with the now well-known <code>DllImport</code> declaration:</p>
			<pre class="source-code">
[DllImport("msvcrt.dll", CallingConvention = CallingConvention.Cdecl)]
static extern int printf(string format, int i, double d);
printf("Hello, System Programmers!\n", 1, 2.0);</pre>			<p>Since this function is not part of the Win32 API but instead resides in a separate DLL, you must be careful and specify the correct calling convention. Here, we need to use <code>cdecl</code>, which we can specify by setting <code>CallingConvention = </code><code>CallingConvention.Cdecl</code>.</p>
			<p>Other types include <code>WinAPI</code>, <code>StdCall</code> (they are basically the same), <code>ThisCall</code>, and <code>FastCall</code>. You will hardly ever encounter the last two, but at least you have heard of them now.</p>
			<p>When you call an<a id="_idIndexMarker108"/> API and get weird errors or unexpected behavior, you might want to look into how to marshal the types or the calling conventions. The system doesn’t help you here by giving you good error messages.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Debugging tools</h2>
			<p>Visual Studio Debugger is <a id="_idIndexMarker109"/>awesome. However, when<a id="_idIndexMarker110"/> mixing managed with unmanaged code, things might get tricky. If something goes wrong, the system might halt and show you a breakpoint. But since the code that’s being called is not C#, the debugger might not show you what you need to see. It tries its best, so it will probably disassemble the code and show you the assembly code that is at fault.</p>
			<p>I showed you some assembly code at the beginning of this chapter. That isn’t something you might want to see if you want to find errors in your code. Well, I don’t know if that applies to you, but I certainly don’t want to see that.</p>
			<p>If that happens, you might want to use other debuggers, such as WinDbg. Later in this book, when we cover debugging, we take a closer look at this tool. But trust me, debugging mixed code is no walk in the park.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Compatibility and portability</h2>
			<p>Windows <a id="_idIndexMarker111"/>changes. Sometimes, it changes a lot; sometimes, the changes are subtle. Although Microsoft is known for trying <a id="_idIndexMarker112"/>to keep things backward compatible as much as possible, sometimes, APIs change. The signature might change, or the behavior might change. And you only find out about that when things go horribly wrong. Again, you see very few exceptions or error messages, so you’re left to debug the code and step through it.</p>
			<p>As soon as you start using Win32 APIs, you are tying yourself to a limited set of devices and platforms you can use.</p>
			<p>And don’t even think about deploying the preceding code to a Linux platform. Sure, .NET runs fine on Linux, but not when you start using P/Invoke. And it might be that your code runs fine on one edition of Windows but breaks horribly on the next one that comes out of Redmond. We could call that “job security” since it will require us to update our code now and then, but I wouldn’t go as far as calling it fun.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Documentation and community support</h2>
			<p>The primary <a id="_idIndexMarker113"/>audience for<a id="_idIndexMarker114"/> the documentation of the Win32 API is C and C++ developers. As a C# developer, it is hard to find the information needed. Sites such as <a href="https://pinvoke.net">https://pinvoke.net</a> help, but only if you know how they work.</p>
			<p>The documentation of third-party DLLs you might want to use as a .NET developer is even harder to find. Sometimes, you must inspect a DLL, see how it works internally, and then translate it into the proper DLL import statement. If you do that, ensure you have the correct calling convention and types!</p>
			<p>Community support when mixing managed and unmanaged code is also a challenge. Most developers fall into one of two camps: they work in the unmanaged world or they work in the managed world. Doing both is very rare.</p>
			<p>Good developers who can do both are scarce. The good news is that by reading this book, you are on the right path to becoming one of that very elite group!</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Next steps</h1>
			<p>This chapter looked at the difference between low-level and high-level APIs. We dove into the foundations of .NET by examining the BCL and CLR. Then, we examined how to call into low-level APIs such as the Win32 API. We did that by reimplementing the ubiquitous <code>Console.WriteLine</code> into code that the Windows operating system can run without using the BCL. That led us to discuss error discovery and error handling, and how to best go about them.</p>
			<p>We also discussed the issues you might encounter when you start doing that sort of coding. We mentioned the differences in type systems and the issues you might have when dealing with debuggers.</p>
			<p>I hope this chapter has made you appreciate the .NET Framework and the hard work the BCL and CLR do for you as a developer. But I also hope you realize the power you get when using the Win32 API or other third-party libraries written in C or C++.</p>
			<p>System programming relies heavily on these techniques. Although using these APIs ties you to the operating system you’re developing for or even a specific version of that system, this is often the only way to achieve your results. And to be honest, I think working with these APIs is fun. It is all about getting back to the basics.</p>
			<p>Working with low-level APIs can be challenging. They can lead to a lot of hard-to-solve errors. But when used correctly, they can lead to better performance in your code. When writing system software, that is very important. As discussed previously, system software should not get in the way of the user or the systems the user directly interacts with. Instead, it should be as fast as possible. So, using the correct APIs might give you just that extra performance you need. I think this is so important that I wrote a complete chapter on performance, which happens to be the next chapter. We were born to run, so let’s run as fast as possible to the next part!</p>
		</div>
	</body></html>