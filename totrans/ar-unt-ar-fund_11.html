<html><head></head><body><div><div><h1 id="_idParaDest-183"><em class="italic"><a id="_idTextAnchor192"/>Chapter 8</em>: Planets: Tracking Images</h1>
			<p>In this chapter, we will be using augmented reality for data visualization and education. We're going to build a project where users can learn about the planets in our Solar System. Suppose you have a children's science book on the Solar System with a companion mobile app. On the page about planet Earth, for example, the reader can point their mobile device at the picture on the page and a 3D rendering of the Earth will pop out of the page.</p>
			<p>The AR mechanism we'll be using is known as <em class="italic">image tracking</em>. With image tracking, you prepare a reference library of images that may be recognized and tracked in the real world at runtime. When the user's device's camera detects one of these images, a virtual object can be instantiated at the image location. </p>
			<p>I have provided you with "planet cards," which have pictures and unique markers on them for each planet that I created from free resources available on the web, for you to print yourself and use with the app. For rendering the planets' spherical surface skins, we will be using free texture images of the actual planets.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Understanding AR image tracking</li>
				<li>Specifying the Planets project and getting started</li>
				<li>Defining and tracking reference images</li>
				<li>Creating and instantiating a virtual Earth prefab</li>
				<li>Rotating a planet on its axis</li>
				<li>Expanding the project with multiple planets</li>
				<li>Making a responsive UI</li>
			</ul>
			<p>By the end of this chapter, you'll have a working app that detects images on the provided planet cards, renders a 3D model of the given planet, and offers additional information details about a planet.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor193"/>Technical requirements</h1>
			<p>To implement the project in this chapter, you need Unity installed on your development computer, connected to a mobile device that supports augmented reality applications (see <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up for AR Development</em>, for instructions). We also assume that you have the <code>ARFramework</code> template and all its prerequisites installed. See <a href="B15145_05_Final_SB_epub.xhtml#_idTextAnchor119"><em class="italic">Chapter 5</em></a><em class="italic">, Using the AR User Framework</em>, for more details. The completed project can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a>.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor194"/>Understanding AR image tracking</h1>
			<p>Before we <a id="_idIndexMarker634"/>start building our project, let's take a moment to learn how AR image tracking works. In this section, I'll introduce some of the basic principles behind image recognition and tracking, and what makes some images better than others for this purpose.</p>
			<p>As we know, the principles behind augmented reality involve using compute mechanisms to recognize features in the real world, determine their position and orientation in a 3D space, instantiate virtual objects relative to and anchored within this 3D space, and track the user as they move within this space. Modern devices can accomplish this using their video cameras and other sensors built into the device to performing real-time spatial mapping of the environment. A different approach is for the device to track predetermined images. That is what we will use for the project in this chapter.</p>
			<p>Augmented reality technology was born in the 1990s, where QR code-like marker images were used for tracking. An example is shown in the following image:</p>
			<div><div><img src="img/Figure_8.01_B15145.jpg" alt="Figure 8.1 – A basic AR marker&#13;&#10;" width="316" height="316"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – A basic AR marker</p>
			<p>Marker images<a id="_idIndexMarker635"/> can be used for triggering and positioning virtual <a id="_idIndexMarker636"/>objects in the real world. These simplistic yet visually distinct markers are easily detected, even by low-end devices. Such markers<a id="_idIndexMarker637"/> are readily detectable becau<a id="_idTextAnchor195"/>se of their <em class="italic">distinctive details</em>, <em class="italic">high contrast edges</em>, and an <em class="italic">asymmetric shape</em> – that is, it's an easily recognizable image with unambiguous top, bottom, left, and right sides. In this way, the detection software can determine which marker image is in view and the orientation of the camera relative to the marker in 3D space.</p>
			<p>Taken to the next level, products<a id="_idIndexMarker638"/> such as Merge Cube (<a href="https://mergeedu.com/cube">https://mergeedu.com/cube</a>) have markers on each of its six faces, just like a physical cube that you can hold in your hand. Users can find companion apps with a wide gamut of games, learning, and exploration experiences. Merge offers a Unity package for developers so that you can build your own projects for it too. Merge Cube is depicted in the following image:</p>
			<div><div><img src="img/Figure_8.02_B15145.jpg" alt="Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each face&#13;&#10;" width="1373" height="743"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each face</p>
			<p>Markers <a id="_idIndexMarker639"/>can be <a id="_idIndexMarker640"/>combined with natural images to provide pleasing and informative yet visually distinct images that also act as AR markers. You'll often see this in AR augmented storybooks or even cereal boxes. This is the approach I have taken in this chapter.</p>
			<p>While markers provide the highest reliability, they are not necessarily required for image tracking. Ordinary photographic images can also be used. In AR lingo, these are referred to as <em class="italic">natural feature images</em>. Images for tracking must have the same characteristics that make markers reliable – distinctive details, high contrast edges, and an asymmetric shape. Much has been written about the best practices for selecting images. For<a id="_idIndexMarker641"/> instance, the AR Core developer guide (<a href="https://developers.google.com/ar/develop/java/augmented-images/">https://developers.google.com/ar/develop/java/augmented-images/</a>) contains additional tips about using reference images, including the following:</p>
			<ul>
				<li>Use an image resolution of at least 300 x 300 pixels. However, a very high resolution does not help with recognition.</li>
				<li>Color information is not used, so either color or grayscale images are just as good.</li>
				<li>Avoid images with a lot of geometric features, or too few.</li>
				<li>Avoid repeating patterns.</li>
			</ul>
			<p>The AR Core SDK comes with an <strong class="bold">arcoreimg</strong> tool<a id="_idIndexMarker642"/> that can evaluate images and returns a quality score between 0 and 100 for each image, where a score of at least 75 is recommended. Likewise, Unity uses a similar tool when compiling the Image Reference Library in your builds (we'll learn more about this later in this chapter).</p>
			<p>Given this general understanding of using image tracking in augmented reality applications, let's begin by defining a fun and interesting project – visualizing our Solar System's planets.</p>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor196"/>Specifying the Planets project</h1>
			<p>We are going to<a id="_idIndexMarker643"/> build a planet information app that allows users to scan <em class="italic">planet cards</em> to visualize a 3D model of each planet in the Solar System. Imagine this being part of a trading card collection or a companion app to a children's science book. When the user points the device's camera at one of the planet cards, they can see a 3D rendering of the planet. Upon pressing an <strong class="bold">Info</strong> button, the user can get additional information about that planet. In this section, I will define the general user experience flow, give you instructions for preparing the planet cards for your own use, and help you collect assets that you'll use in this project.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor197"/>User experience flow</h2>
			<p>The general<a id="_idIndexMarker644"/> onboarding user workflow will play out as follows:</p>
			<ol>
				<li><strong class="bold">Startup-mode</strong>: The app will start, check the device for AR support, and ask for camera permissions (OS-dependent). Once read, the app will go into Scan-mode.</li>
				<li><strong class="bold">Scan-mode</strong>: The user is prompted to aim the camera at an image for detection and tracking. When at least one image is being tracked, the app goes into Main-mode.</li>
				<li><strong class="bold">Main-mode</strong>: This is where the app responds to new or updated tracked images and allows the user to interact with the planet. When an image is tracked, it determines which planet corresponds to the image and instantiates the planet's game object. If tracking is lost, the app may go back to Scan-mode to prompt the user. If a different image is tracked, the current planet is replaced with the new image's planet.</li>
			</ol>
			<p>This workflow is a bit simpler than the ones we implemented in the previous chapters. In that case, we needed the user to scan the environment for trackable planes before starting Main-mode. The user was then asked to deliberately tap the screen to place a virtual object in the scene. Furthermore, in the AR Gallery project, we added Edit-mode to modify<a id="_idIndexMarker645"/> pictures that had been added by the user. Much of that is unnecessary in this project; the process is more automated as we let the device detect an image and we instantiate a virtual object in response.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Preparing the planet cards</h2>
			<p>For this project, we <a id="_idIndexMarker646"/>are using printed <em class="italic">planet cards</em> as marker images so that we can choose a planet to visualize. You can find a PDF file that contains the cards in the project files for this chapter (in the folder named <code>Printables/</code>). To prepare the cards for this project, follow these steps:</p>
			<ol>
				<li value="1">Print out the <code>PlanetCards.pdf</code> file. </li>
				<li>Then, cut the sheets into separate cards.</li>
				<li>I suggest that you print on thick paper stock or mount the printouts on paperboard to avoid warping, which may affect the software's ability to recognize the images at runtime.</li>
			</ol>
			<p>The following photo shows getting these cards ready for use:</p>
			<div><div><img src="img/Figure_8.03_B15145.jpg" alt="Figure 8.3 – Cutting the printed planet cards for this project&#13;&#10;" width="823" height="796"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Cutting the printed planet cards for this project</p>
			<p>These cards were<a id="_idIndexMarker647"/> created from a combination of resources that can be found for free on the web. I found the original flashcards on the <em class="italic">Kids Flashcards</em> website. Upon going to <a href="https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english">https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english</a>, I downloaded the <em class="italic">Solar System flashcards free</em> PDF file. </p>
			<p>First, I attempted to use the flashcards as-is, but the pictures were not distinctive enough to be detected individually. So, I decided to add <em class="italic">ArUco</em> markers to each one. ArUco is a square marker with a wide black border and inner binary matrix that determines its ID based on OpenCV (the Open Source Computer Vision library, which was developed at the <em class="italic">University of Cordoba, Spain</em>; see <a href="https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html">https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html</a>). I used the online ArUco marker generator at <a href="https://chev.me/arucogen/">https://chev.me/arucogen/</a> to make separate markers for each planet.</p>
			<p>Then, I used <em class="italic">Photoshop</em> to combine the markers with the planet flashcards to make our final planet cards for this project. (The Photoshop PSD file is also included with this chapter's files on GitHub.)</p>
			<p>Each planet card is also a separate PNG image. These have been provided for you in the <code>Image Library/</code> folder. Later in this chapter, we will create an image reference library and add these images. The images are named with the pattern <em class="italic">[planetname]</em><code>-MarkerCard.png</code>; for example, <code>Earth-MarkerCard.png</code>. We'll take advantage of this naming convention in our code. </p>
			<p>When the app <a id="_idIndexMarker648"/>detects a planet card, the application will instantiate a model of the planet. For this, we need texture images for the planet materials.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor199"/>Collecting planet textures and data</h2>
			<p>We need <a id="_idIndexMarker649"/>texture images to use as the planet skins of the spherical mesh for each planet. The ones we're using I found at the interesting <em class="italic">Solar System Scope</em> project site (<a href="https://www.solarsystemscope.com/">https://www.solarsystemscope.com/</a>). These are included with the files for this chapter in this book's GitHub repository and can be downloaded from <a href="https://www.solarsystemscope.com/textures/">https://www.solarsystemscope.com/textures/</a>. That said, you can find alternative assets in the Unity Asset Store (<a href="https://assetstore.unity.com/?q=solar%20system&amp;orderBy=1">https://assetstore.unity.com/?q=solar%20system&amp;orderBy=1</a>), including the classic <em class="italic">Planet Earth Free</em> package (<a href="https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399">https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399</a>) for Earth itself, which includes cloud cover.</p>
			<p>For additional metadata about the planets, I found the <em class="italic">Planetary Fact Sheet</em> on the NASA.gov website (<a href="https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html">https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html</a>) and more details at <a href="https://nssdc.gsfc.nasa.gov/planetary/planetfact.html">https://nssdc.gsfc.nasa.gov/planetary/planetfact.html</a>. We could use some of these details directly while rendering and animating our models, such as the planet diameter (km), rotation period (hours), and tilt (obliquity to orbit in degrees).</p>
			<p>With our planet cards, planet skin textures, and other planetary details in hand, we're ready to start building the project.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor200"/>Getting started</h1>
			<p>To begin, we'll <a id="_idIndexMarker650"/>create a new scene named <code>PlanetsScene</code> using the <code>ARFramework</code> scene template. Follow these steps:</p>
			<ol>
				<li value="1">Select <strong class="bold">File | New Scene</strong>.</li>
				<li>In the <strong class="bold">New Scene</strong> dialog box, select the <strong class="bold">ARFramework</strong> template.</li>
				<li>Press <strong class="bold">Create</strong>.</li>
				<li>Select <code>Scenes/</code> folder in your <code>Assets</code> project, name it <code>PlanetsScene</code>, and click <strong class="bold">Save</strong>. </li>
			</ol>
			<p>The new AR scene already has the following set up:</p>
			<ul>
				<li><strong class="bold">AR Session</strong> game object.</li>
				<li><strong class="bold">AR Session Origin</strong> rig with the raycast manager and plane manager components. </li>
				<li><strong class="bold">UI Canvas</strong> is a screen space canvas with child panels; that is, Startup UI, Scan UI, Main UI, and NonAR UI. It also contains the UI Controller component script that we wrote.</li>
				<li><strong class="bold">Interaction Controller</strong> is a game object that contains the Interaction Controller component script we wrote, which helps the app switch between interaction modes, including the Startup, Scan, Main, and NonAR modes. It also has a <strong class="bold">Player Input</strong> component that's been configured with the <strong class="bold">AR Input Actions</strong> asset we created previously.</li>
				<li>The <strong class="bold">OnboardingUX</strong> prefab from the AR Foundation Demos project, which provides AR session status and feature detection status messages, as well as animated onboarding graphics prompts.</li>
			</ul>
			<p>We can set the app title now, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong> object and unfold its child <strong class="bold">App Title Panel</strong>.</li>
				<li>Select the <strong class="bold">Title Text</strong> object.</li>
				<li>In its <code>Planet Explorer</code>.</li>
			</ol>
			<p>Using this scene as a basis, we will replace the AR trackable components with an AR Tracked<a id="_idIndexMarker651"/> Image Manager one. </p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Tracking reference images</h1>
			<p>Our starter <a id="_idIndexMarker652"/>scene includes an AR Session Origin with components for Player Input and AR Raycast Manager. It also has a component we do not need in this project, for detecting and tracking planes, which we'll replace with AR Tracked Image Manager instead. Documentation on <strong class="bold">AR Tracked Image Manager</strong> can be found at <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html</a>. Then, we'll create an image reference library for our planet card images.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/>Adding AR Tracked Image Manager</h2>
			<p>To configure the AR Session to<a id="_idIndexMarker653"/> track images, perform the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> game object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, use the <strong class="bold">3-dot</strong> context menu (or <em class="italic">right-click</em>) on <strong class="bold">AR Plane Manager</strong> and select <strong class="bold">Remove Component</strong>.</li>
				<li>Using the <code>AR</code> and add an <strong class="bold">AR Tracked Image Manager</strong> component.</li>
			</ol>
			<p>You'll notice that there is a <strong class="bold">Serialized Library</strong> slot on the component for the reference image library. We'll create that next.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/>Creating a reference image library</h2>
			<p>The reference <a id="_idIndexMarker654"/>image library contains records for each of the images that the application will be able to detect and track in the real world. In our case, we're going to add the planet card images. In the assets provided in the GitHub repository for this book, there is a folder named <code>Image Library/</code> that already contains the planet card images we'll be adding to the library. We will start with just the Earth card here; we will add the other planets later in this chapter.</p>
			<p>We can create the library by performing the following steps:</p>
			<ol>
				<li value="1">In the <code>Image Library/</code>.</li>
				<li><em class="italic">Right-click</em> on the <code>Image Library/</code> folder and select <strong class="bold">Create | XR | Reference Image Library</strong>.</li>
				<li>With the <strong class="bold">ReferenceImageLibrary</strong> assets selected, in the <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Image</strong>.</li>
				<li>Drag the <code>Earth-MarkerCard</code> image from the <strong class="bold">Project</strong> window onto the square image texture slot.</li>
				<li>Check the <strong class="bold">Specify Size</strong> checkbox. </li>
				<li>If you printed the planet cards from the PDF provided, at scale, the width will be about 8 cm, or 0.08 meters. Otherwise, use a ruler to measure the Earth planet card you printed.</li>
				<li>Then, enter the width (<code>0.08</code>) in the <strong class="bold">X</strong> field. The <strong class="bold">Y</strong> value will be automatically updated based on the PNG image's pixel dimensions.</li>
				<li>Check the <strong class="bold">Keep Texture At Runtime</strong> checkbox.</li>
			</ol>
			<p>The resulting <strong class="bold">Reference Image Library</strong> settings are shown in the following screenshot:</p>
			<div><div><img src="img/Figure_8.04_B15145.jpg" alt="Figure 8.4 – Reference Image Library with the Earth added&#13;&#10;" width="702" height="276"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Reference Image Library with the Earth added</p>
			<p>Now, we<a id="_idIndexMarker655"/> can update the <strong class="bold">AR Tracked Image Manager</strong> component, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> object.</li>
				<li>Drag the <strong class="bold">ReferenceImageLibrary</strong> asset from the <strong class="bold">Project</strong> window onto the <strong class="bold">Serialized Library</strong> slot of <strong class="bold">AR Tracked Image Manager</strong>.</li>
				<li>Temporarily, while we get this project set up, we'll instantiate an existing prefab object when the image is detected. <p>For example, drag the <code>ARF-samples/Prefabs/</code> folder onto the <strong class="bold">Tracked Image Prefab</strong> slot (or another similar object). </p></li>
			</ol>
			<p>The <strong class="bold">AR Tracked Image Manager</strong> component should now look as follows:</p>
			<div><div><img src="img/Figure_8.05_B15145.jpg" alt="Figure 8.5 – The AR Tracked Image Manager with the reference image library assigned&#13;&#10;" width="701" height="131"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – The AR Tracked Image Manager with the reference image library assigned</p>
			<p>You now have an AR scene that recognizes and tracks images that have been defined in a reference library. Currently, the library only contains the Earth-MarkerCard image. When the image is<a id="_idIndexMarker656"/> recognized while running the app, a simple cube will be placed on the Earth planet card.</p>
			<p>We're almost ready to try this out. But first, let's configure the user framework's UI and modes. </p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor204"/>Configuring the user interaction modes and UI</h1>
			<p>The scene<a id="_idIndexMarker657"/> template, <code>ARFramework</code>, where we started <a id="_idIndexMarker658"/>provides a simple framework for enabling user interaction modes and displaying the corresponding UI panels for a mode. This project will start in Startup-mode while the AR Session is initializing so that we can verify that the device supports AR. Then, it will transition to Scan-mode, where it will try to find one of the reference images. Once found, it will transition to Main-mode, where we can support additional user interactions with the app's content.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor205"/>Scanning for reference images</h2>
			<p>In Scan-mode, we'll <a id="_idIndexMarker659"/>display an instructional graphic prompting the user to point the camera at a planet card with a planet and marker image. Perform the following steps to configure this:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong> game object and unfold its child <strong class="bold">Scan UI</strong>. Select the child <strong class="bold">Animated Prompt</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong> window set <strong class="bold">Animated Prompt | Instruction to Find An Image</strong>.</li>
			</ol>
			<p>This will now play the Find Image Clip we defined on the <strong class="bold">OnboardingUX</strong> object, which is provided by the Unity Onboarding UX assets and is already present in our scene hierarchy. What you can expect is shown in the following screen capture. On the left is Startup-mode, where the AR Session is being initialized. On the right is Scan-mode, where the user is prompted to find an image (you can't see the video feed because I'm covering the camera to make the prompt more visible in the screen capture).</p>
			<div><div><img src="img/Figure_8.06_B15145.jpg" alt="Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)&#13;&#10;" width="865" height="775"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)</p>
			<p>Now, we need <a id="_idIndexMarker660"/>to set up the Scan-mode's script to know when an image has been found and transition to Main-mode. We'll replace the default <code>ScanMode</code> script with a similar one that references <code>ARTrackedImageManager</code> instead of <code>ARTrackedPlaneManager</code>, as follows:</p>
			<ol>
				<li value="1">In the <code>Scripts/</code> folder by <em class="italic">right-clicking</em> and selecting<code>ImageScanMode</code>.</li>
				<li>Edit <code>ImageScanMode</code> and replace its content, as follows:<pre>using UnityEngine;
using UnityEngine.XR.ARFoundation;
public class ImageScanMode : MonoBehaviour
{
    [SerializeField] ARTrackedImageManager imageManager;
    private void OnEnable()
    {
        UIController.ShowUI("Scan");
    }
    void Update()
    {
        if (imageManager.trackables.count &gt; 0)
        {
            InteractionController.EnableMode("Main");
        }
    }
}</pre></li>
				<li>Save the <a id="_idIndexMarker661"/>script. Then, back in Unity, in the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Scan Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>In the <strong class="bold">Inspector</strong> window, remove the original <strong class="bold">Scan Mode</strong> component using the <em class="italic">3-dot</em> context menu and selecting<strong class="bold"> Remove Component</strong>.</li>
				<li>Drag the <strong class="bold">ImageScanMode</strong> script onto the <strong class="bold">Scan Mode</strong> object, adding it as a new component.</li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">AR Session Origin</strong> object into the <strong class="bold">Inspector</strong> window and drop it onto the <strong class="bold">Image Scan Mode | Image Manager</strong> slot.</li>
			</ol>
			<p>The component will now look as follows:</p>
			<div><div><img src="img/Figure_8.07_B15145.jpg" alt="Figure 8.7 – The Image Scan Mode component&#13;&#10;" width="626" height="98"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – The Image Scan Mode component</p>
			<p>Currently, we have created a new scene using the <code>ARFramework</code> template and modified it to use <strong class="bold">AR Tracked Image Manager</strong> and prompt the user to scan for an image accordingly. When an image is detected (for example, the Earth-MarkerCard), a generic game<a id="_idIndexMarker662"/> object will be instantiated (for example, the AR Placed Cube prefab). Let's test what we have accomplished so far on the target device.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor206"/>Build and run</h2>
			<p>To build and<a id="_idIndexMarker663"/> run <a id="_idIndexMarker664"/>the scene on your target device, perform the following steps:</p>
			<ol>
				<li value="1">Ensure you've saved the work you've done on the current scene by going to <strong class="bold">File | Save</strong>.</li>
				<li>Select <strong class="bold">File | Build Settings</strong> to open the <strong class="bold">Build Settings</strong> window.</li>
				<li>Click <strong class="bold">Add Open Scenes</strong> to add the current scene to the <strong class="bold">Scenes In Build</strong> list (if it's not already present).</li>
				<li>Uncheck all but the current scene, <code>PlanetsScene</code>, from the list.</li>
				<li>Then, click <strong class="bold">Build And Run</strong> to build the project.</li>
			</ol>
			<p>When the app launches, point your device's camera at the printed Earth planet card. Your virtual cube should get instantiated at that location, as shown in the following screen capture from my phone:</p>
			<div><div><img src="img/Figure_8.08_B15145.jpg" alt="Figure 8.8 – The Earth card has been detected, and the cube has been instantiated&#13;&#10;" width="384" height="769"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.8 – The Earth card has been detected, and the cube has been instantiated</p>
			<p>We now <a id="_idIndexMarker665"/>have a basic AR scene with image detection set <a id="_idIndexMarker666"/>up to recognize the Earth planet card and instantiate a sample prefab at that location. Now, let's make a planet Earth model that we can use instead of this silly cube.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor207"/>Creating and instantiating a virtual Earth prefab</h1>
			<p>In this <a id="_idIndexMarker667"/>section, we<a id="_idIndexMarker668"/> will create prefab game objects for each of the planets. Since each of the planets has similar behaviors (for example, they rotate), we'll first create a generic Planet Prefab, and then make each specific planet a variant of that one. In Unity, <code>Planet</code> script that animates the planet's rotation and handles other behavior. Each planet will have its own "skin" defined by a material, along with a base texture map, which we downloaded earlier from the web. </p>
			<p>In this section, we'll create a generic Planet Prefab object, create an Earth Prefab as a variant, add<a id="_idIndexMarker670"/> planet metadata by writing a <code>Planet</code> component <a id="_idIndexMarker671"/>script, and implement a planet rotation animation.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor208"/>Creating the generic Planet Prefab</h2>
			<p>The <a id="_idIndexMarker672"/>Planet Prefab contains a 3D sphere that <a id="_idIndexMarker673"/>gets rendered with each planet's texture image. Planets spin along their axes, so we'll set up a hierarchy with an Incline transform that defines this incline axis. Follow these steps:</p>
			<ol>
				<li value="1">In your <code>Planet Prefab</code>.</li>
				<li><em class="italic">Double-click</em> (or select <strong class="bold">Open Prefab</strong> in the <strong class="bold">Inspector</strong> window) to open the prefab for editing.</li>
				<li>From the main menu, select <code>Incline</code>.</li>
				<li>Right-click the <code>Planet</code>.</li>
				<li>It will be useful to have any planets we instantiate in the scene on a specific layer. I will name this layer <code>PlacedObjects</code>. (I introduced and discussed layers in a previous chapter). With its root <code>PlacedObjects</code>.<p>If the <code>PlacedObjects</code> layer doesn't exist, select <code>PlacedObjects</code> to one of the empty slots. In the <code>PlacedObjects.</code></p><p>You will then be prompted with the question, <strong class="bold">Do you want to set layer to PlacedObjects for all child objects as well?</strong> Click <strong class="bold">Yes, Change Children</strong>.</p></li>
				<li><strong class="bold">Save</strong> the prefab. </li>
			</ol>
			<p>This is very simplistic right now (only a sphere child object is being parented by an Incline transform), but it will serve as a template for each planet prefab that we add. The Planet <a id="_idIndexMarker674"/>Prefab hierarchy is shown in the<a id="_idIndexMarker675"/> following screenshot:</p>
			<div><div><img src="img/Figure_8.09_B15145.jpg" alt="Figure 8.9 – The Planet Prefab hierarchy&#13;&#10;" width="427" height="177"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – The Planet Prefab hierarchy</p>
			<p>Each planet will be rendered with a skin representing an actual view of that planet. Before creating the Earth prefab, let's take a moment to understand render materials and the texture images we are going to use.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor209"/>Understanding equirectangular images</h2>
			<p>When Unity renders a 3D model, it starts with a<a id="_idIndexMarker676"/> 3D mesh that describes the geometry. Much like a fishing net, a mesh is a collection of vertices and vectors, with the vectors connecting these vertices, organized as triangles (or sometimes four-sided quads) that define the surface of the mesh. The following illustration shows a wireframe view of a sphere mesh on the left. On the right is a rendered view of the sphere, with a globe texture mapped onto its 3D surface:</p>
			<div><div><img src="img/Figure_8.10_B15145.jpg" alt="Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)&#13;&#10;" width="993" height="485"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)</p>
			<p>A texture<a id="_idIndexMarker677"/> image is just a 2D image file (for example, a PNG file) that is computationally mapped onto the 3D mesh's surface when it is rendered. Think of unraveling a globe as a 2D map, like cartographers have been doing for centuries. A common 2D projection is known as <strong class="bold">equirectangular</strong>, where the center (equator) is at the correct scale and the image gets increasingly stretched as it approaches the top and bottom poles. The following image shows the equirectangular texture of the preceding globe (illustration by <em class="italic">Stefan Kuhn</em>):</p>
			<div><div><img src="img/Figure_8.11_B15145.jpg" alt="Figure 8.11 – Equirectangular texture that defines the skin of a sphere&#13;&#10;" width="1009" height="505"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Equirectangular texture that defines the skin of a sphere</p>
			<p class="callout-heading">Information – Equirectangular Images Are Also Used in 360-Degree Media and VR</p>
			<p class="callout">Equirectangular images are also known as 360-degree <a id="_idIndexMarker678"/>images and used in virtual reality applications. In VR, the image is effectively mapped to the <em class="italic">inside</em> of a sphere, where you're viewing from the inside rather than the outside of a globe!</p>
			<p>For our project, we have texture images for each of the planets. The Mars one, for example, is as follows:</p>
			<div><div><img src="img/Figure_8.12_B15145.jpg" alt="Figure 8.12 – Texture map image for Mars&#13;&#10;" width="1121" height="580"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.12 – Texture map image for Mars</p>
			<p>To create a prefab for a specific planet, such as <a id="_idIndexMarker679"/>Earth, we'll need to create a material that uses the Earth texture image. We'll build that now.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor210"/>Creating the Earth prefab</h2>
			<p>The Earth <a id="_idIndexMarker680"/>prefab will be a variant of the Planet Prefab, with its own Earth Material. Create it by performing the following steps:</p>
			<ol>
				<li value="1">In the <code>Earth Prefab</code>.</li>
				<li><em class="italic">Double-click</em> <strong class="bold">Earth Prefab</strong> (or select <strong class="bold">Open Prefab</strong> in the <strong class="bold">Inspector</strong> window).</li>
				<li>In the <code>Materials/</code> folder (create one if necessary) and select <code>Earth Material</code>.</li>
				<li>Drag <strong class="bold">Earth Material</strong> from the <strong class="bold">Project</strong> window and drop it onto the <strong class="bold">Planet</strong> game object.</li>
				<li>Locate the <code>Planet Textures/earth</code>) in the <strong class="bold">Project</strong> Assets and drag it onto the <strong class="bold">Surface Inputs | Base Map</strong> texture chip. The <a id="_idIndexMarker681"/>following screenshot shows <strong class="bold">Earth Material</strong> in the <strong class="bold">Inspector</strong> window:<div><img src="img/Figure_8.13_B15145.jpg" alt="Figure 8.13 – Earth Material with the Base Map texture defined&#13;&#10;" width="621" height="291"/></div><p class="figure-caption">Figure 8.13 – Earth Material with the Base Map texture defined</p></li>
				<li>Let's pick a default size for our planet when added to the scene. Unless you want to place a 1-meter diameter planet into your scene (!), we need to set its <strong class="bold">Scale</strong>.<p>Select the <strong class="bold">Planet</strong> child object in the <strong class="bold">Hierarchy</strong> window.</p></li>
				<li>In its <code>0.1, 0.1, 0.1</code>). </li>
				<li>Likewise, to rest the planet on the image's surface, we could set its Y position to <code>0.05</code>. But to let it hover a little above, we will set <code>0.075</code>.</li>
				<li><strong class="bold">Save</strong> the prefab and exit back to the <strong class="bold">Scene</strong> hierarchy.</li>
			</ol>
			<p>Use this prefab instead of the AR Placed Cube prefab in the AR Tracked Image Manager component on the AR Session Origin object. Later, we'll manage this more correctly using a script but for now, let's just try it out:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> game object.</li>
				<li>Drag <strong class="bold">Earth Prefab</strong> from the <strong class="bold">Project</strong> window into the <strong class="bold">Inspector</strong> window and drop it into the <strong class="bold">AR Tracked Image Manager | Tracked Image Prefab</strong> slot.</li>
				<li><strong class="bold">Build and Run</strong> the scene. </li>
			</ol>
			<p>This time, when <a id="_idIndexMarker682"/>you point the camera at the Earth planet card, the Earth prefab will appear, as shown in the following screen capture:</p>
			<div><div><img src="img/Figure_8.14_B15145.jpg" alt="Figure 8.14 – While tracking the Earth planet card, the app instantiates an Earth prefab&#13;&#10;" width="496" height="992"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – While tracking the Earth planet card, the app instantiates an Earth prefab</p>
			<p>This looks pretty nice. The prefab could also include other information about the planet. We'll look at <a id="_idIndexMarker683"/>how to do this next.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor211"/>Adding planet metadata</h2>
			<p>Each planet <a id="_idIndexMarker684"/>prefab can include additional <a id="_idIndexMarker685"/>information about that planet. We can capture this in the <code>Planet</code> script of the prefab, as follows:</p>
			<ol>
				<li value="1">From the <strong class="bold">Project</strong> window, open <strong class="bold">Planet Prefab</strong> for editing.</li>
				<li>In the <code>Scripts/</code> folder, create a new C# script named <code>Planet</code>.</li>
				<li>Drag the <code>Planet</code> script onto the root <strong class="bold">Planet Prefab</strong> game object, adding it as a component.</li>
				<li>Open the <code>Planet</code> script in your code editor and write the following:<pre>using UnityEngine;
public class Planet : MonoBehaviour
{
    public string planetName;
    public string description;
}</pre></li>
				<li>Save the script. Then, in Unity, <strong class="bold">Save</strong> the prefab.<p>Although we have made all these changes to the Planet Prefab, the Earth Prefab inherits everything because it is a prefab variant. </p></li>
				<li>Now, open <strong class="bold">Earth Prefab</strong> for editing.</li>
				<li>In the <code>Earth</code>.</li>
				<li>In the <code>Earth is the third planet from the Sun and the only astronomical object known to harbor and support life</code>. </li>
				<li> <strong class="bold">Save</strong> the prefab.</li>
			</ol>
			<p>We also can <a id="_idIndexMarker686"/>ascribe behaviors to the planet <a id="_idIndexMarker687"/>prefab, such as rotation about its axis.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor212"/>Animating the planet's rotation</h2>
			<p>Planets spin. Some<a id="_idIndexMarker688"/> faster than others. Mercury<a id="_idIndexMarker689"/> just barely – it rotates once every 59 Earth days, while it orbits the Sun in 88 Earth days! And a planet's axis of rotation is not perfectly vertical (relative to its orbit around the Sun). Earth, for example, is tilted by 23.4 degrees, while Venus rotates on its side at 177.4 degrees! OK, enough science trivia – let's animate our Earth model. We're going to add a <code>Planet</code> behavior script to the Planet Prefab that rotates the planet along its rotation axis. Follow these steps to do so:</p>
			<ol>
				<li value="1">Open the <code>Planet</code> script in your code editor and add the following code:<pre>    [SerializeField] private float inclineDegrees =        23.4f;
    [SerializeField] private float rotationPeriodHours =        24f;
    [SerializeField] private Transform incline;
    [SerializeField] private Transform planet;
    public float animationHoursPerSecond = 1.0f;
    void Start()
    {
        incline.Rotate(0f, 0f, inclineDegrees);
    }
    void Update()
    {
        float speed =           rotationPeriodHours * animationHoursPerSecond;
        planet.Rotate(0f, speed * Time.deltaTime, 0f);
    }</pre></li>
			</ol>
			<p>At the top <a id="_idIndexMarker690"/>of the class, we will declare variables <a id="_idIndexMarker691"/>for <code>inclineDegrees</code> (Earth is 23.4) and <code>rotationPeriodHours</code> (Earth is 24). We will also define references to the prefab's <code>incline</code> and <code>planet</code> child objects. </p>
			<p>There's also a public <code>animationHoursPerSecond</code>, which sets the animation speed. I've initialized it to <code>1.0</code>, which means the Earth will complete one rotation in 24 seconds.</p>
			<p>The <code>Start()</code> function sets up the <strong class="bold">Incline</strong> angle by rotating along the Z-axis. This only needs to be done once.</p>
			<p>The <code>Update()</code> function rotates the planet about its local Y-axis. Since the planet is parented by the <code>Time.deltaTime</code> each <code>Update</code> is a common Unity idiom for calculating how an object's Transform changes from one frame to the next, where <code>deltaTime</code> is the fraction of a second since the previous <code>Update</code>.</p>
			<p>After saving the script, back in Unity, do the following:</p>
			<ol>
				<li value="1">From the <strong class="bold">Project</strong> window, open <strong class="bold">Planet Prefab</strong> for editing.</li>
				<li>Ensure the root <strong class="bold">Plane Prefab</strong> game object is selected in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Drag the <strong class="bold">Incline</strong> game object from the <strong class="bold">Hierarchy</strong> window into the <strong class="bold">Inspector</strong> window before dropping it onto the <strong class="bold">Planet | Incline</strong> slot.</li>
				<li>Drag the <strong class="bold">Planet</strong> object onto the <strong class="bold">Planet | Planet</strong> slot.</li>
			</ol>
			<p>The <strong class="bold">Planet</strong> component will now look like this in the <strong class="bold">Inspector</strong> window:</p>
			<div><div><img src="img/Figure_8.15_B15145.jpg" alt="Figure 8.15 – The Planet component on the Planet Prefab&#13;&#10;" width="688" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – The Planet component on the Planet Prefab</p>
			<p>Please now <strong class="bold">Build and Run</strong> the project. When the Earth is instantiated, it will be tilted and rotating at the rate of one full rotation every 24 seconds.</p>
			<p>At this point, we have a basic AR scene with image tracking. It lets the AR Tracked Image Manager<a id="_idIndexMarker692"/> instantiate our Earth Prefab directly<a id="_idIndexMarker693"/> when an image is detected. Currently, it doesn't distinguish what image is detected (supposing you had multiple images in the reference library) and always instantiates an Earth Prefab. We need to make the app more robust, and we can do this from the Main-mode.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor213"/>Building the app's Main-mode</h1>
			<p>As you <a id="_idIndexMarker694"/>now know, <code>ARTrackedImageManager</code> has a "Tracked Image Prefab" field; however, this is not intended for content" (<a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html</a>). Currently, when <em class="italic">any</em> reference image is recognized, the Earth Prefab will <em class="italic">always</em> be instantiated.</p>
			<p>Rather, when the app is in Main-mode, we should determine which planet card image is being tracked and instantiate the corresponding planet prefab for that card. So far, we only have one planet, Earth, in the image reference library. However, later in this chapter, we'll expand the project for all the planets. We can start by removing the prefab from the <strong class="bold">AR Tracked Image Manager</strong> component, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> game object.</li>
				<li>In the <strong class="bold">Inspector</strong> window, delete the contents of the <strong class="bold">AR Tracked Image Manager | Tracked Image Prefab</strong> slot, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_8.16_B15145.jpg" alt="Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared&#13;&#10;" width="618" height="133"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared</p>
			<p>When no prefab <a id="_idIndexMarker695"/>is specified in <code>ARTrackedImage</code> component on it. Now, we can instantiate the prefab as a child of that. </p>
			<p>In our scene framework, the app starts in Startup-mode, then goes into Scan-mode once the AR Session is ready. When Scan-mode detects a reference image, it goes into Main-mode by enabling the <strong class="bold">Main Mode</strong> game object under <strong class="bold">Interaction Controller</strong>. This displays the <strong class="bold">Main UI</strong> panel. Let's build this panel now.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor214"/>Writing the PlanetsMainMode script</h2>
			<p>In this<a id="_idIndexMarker696"/> section, we <a id="_idIndexMarker697"/>will write a new <code>PlanetsMainMode</code> script to replace the default <code>MainMode</code> one provided in the default scene template. Like other modes in our framework, it will display the appropriate UI panel when enabled. Then, when an image is tracked, it will find the corresponding planet prefab and instantiate it. </p>
			<p>The script needs to figure out which image the AR software found and decide which prefab to instantiate as a child of the tracked image. In our case, we'll use the name of the detected image file to determine which planet card is recognized (by design, each card image is prefixed with the planet's name; for example, <code>Earth-MarkerCard</code>). The script will implement a serializable dictionary we can use to look up the planet prefab for each planet name, using the <em class="italic">Serialized Dictionary Lite</em> Asset package (you already have this package installed because <code>ARFramework</code> also requires it. See <a href="https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992">https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992</a> for more information).</p>
			<p>Begin by performing the following steps:</p>
			<ol>
				<li value="1">In your <code>Scripts/</code> folder, create a new C# script named <code>PlanetsMainMode</code>.</li>
				<li>In <a id="_idIndexMarker698"/>the <strong class="bold">Hierarchy</strong> window, select <a id="_idIndexMarker699"/>the <strong class="bold">Main Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>In its <strong class="bold">Inspector</strong> window, remove the default <strong class="bold">Main Mode</strong> component using the <em class="italic">3-dot</em> context menu and selecting<strong class="bold"> Remove Component</strong>.</li>
				<li>Drag the <code>PlanetMainMode</code> script from the <strong class="bold">Project</strong> window onto the <strong class="bold">Main Mode</strong> object, adding it as a new component.</li>
				<li><em class="italic">Double-click</em> the <code>PlanetMainMode</code> script to open it for editing.</li>
				<li>Begin by adding the following <code>using</code> assembly declarations at the top of the file:<pre>using UnityEngine;
using RotaryHeart.Lib.SerializableDictionary;
using UnityEngine.XR.ARFoundation;
using TMPro;
using UnityEngine.UI;</pre></li>
				<li>When an image is tracked, we need to find which planet prefab to instantiate. At the top of the file, define a <code>PlanetPrefabDictionary</code> as follows, and declare a <code>planetPrefab</code> variable for it:<pre>[System.Serializable]
public class PlanetPrefabDictionary : SerializableDictionaryBase&lt;string, GameObject&gt; { }
public class PlanetsMainMode : MonoBehaviour
{
    [SerializeField] PlanetPrefabDictionary         planetPrefabs;</pre></li>
				<li>When this<a id="_idIndexMarker700"/> mode is enabled, similar <a id="_idIndexMarker701"/>to the original <code>MainMode</code> script, we'll show the Main UI panel:<pre>    private void OnEnable()
    {
        UIController.ShowUI("Main");
    }</pre></li>
				<li>Likewise, we'll enter Main-mode after Scan-mode has determined it has started tracking an image. So, <code>OnEnable</code> should also instantiate planets for the tracked images. Add a reference to <code>imageManager</code> at the top of the class:<pre>    [SerializeField] ARTrackedImageManager imageManager;</pre><p>Then, update <code>OnEnable</code>:</p><pre>    void OnEnable()
    {
        UIController.ShowUI("Main");
<code>InstantiatePlanet</code> for each one. </p></li>
				<li>Implement <code>InstantiatePlanet</code>, as follows:<pre>    void InstantiatePlanet(ARTrackedImage image)
    {
        string name =            image.referenceImage.name.Split('-')[0];
        if (image.transform.childCount == 0)
        {
            GameObject planet =                Instantiate(planetPrefabs[name]);
            planet.transform.SetParent(image.transform,                false);
        }
        else
        {
            Debug.Log($"{name} already instantiated");
        }
    }</pre><p>The <code>InstantiatePlanet</code> function <a id="_idIndexMarker702"/>determines <a id="_idIndexMarker703"/>the planet's name from the tracked image filename (for example, <code>Earth-MarkerImage</code>) by assuming the images follow our naming convention. It makes sure we don't already have the planet object in the scene. If not, the planet prefab is instantiated and parented to the tracked image object. (We pass <code>false</code> as a second parameter so that the planet is positioned relative to the tracked image transform. See <a href="https://docs.unity3d.com/ScriptReference/Transform.SetParent.html">https://docs.unity3d.com/ScriptReference/Transform.SetParent.html</a>.)</p></li>
				<li>Save the script. </li>
				<li>Back in Unity, make sure you have the <strong class="bold">Main Mode</strong> game object selected in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Drag the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> window into the <strong class="bold">Inspector</strong> window, dropping it onto the <strong class="bold">Image Manager</strong> slot.</li>
				<li>In the <strong class="bold">Inspector</strong> window, click the <strong class="bold">+</strong> button at the bottom right of the <strong class="bold">Planets Main Mode | Planet Prefabs</strong> list.</li>
				<li>Type<a id="_idIndexMarker704"/> the word <code>Earth</code> into<a id="_idIndexMarker705"/> the <code>Id</code> slot.</li>
				<li>Unfold the item and, from the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Earth Prefab</strong> object on the <strong class="bold">Value</strong> slot in the <strong class="bold">Inspector</strong> window.</li>
				<li>Use <strong class="bold">File | Save</strong> to save your work.</li>
			</ol>
			<p>If you <code>PlanetsMainMode</code> when it is enabled. Now, the code is ready to detect different planet card images and instantiate different corresponding planet prefabs. We will start by adding Mars.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor215"/>Expanding the project with multiple planets</h1>
			<p>To add another planet to the project, we need to add its planet card image to the Reference Image Library, create its planet prefab, including a material for rendering the planet skin, and add the reference to the <code>planetPrefabs</code> list in <code>PlanetsMainMode</code>. Then, we'll update the script to handle tracking multiple planets. Let's walk through the steps for adding Mars.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor216"/>Adding the planet card image to the Reference Image Library</h2>
			<p>Perform <a id="_idIndexMarker706"/>the following steps to <a id="_idIndexMarker707"/>add Mars to our <strong class="bold">Reference Image Library</strong>:</p>
			<ol>
				<li value="1">Locate and select your <code>Image Library/</code> folder.)</li>
				<li> In its <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Image</strong>.</li>
				<li>Locate and drag the <code>Mars-MarkerCard</code> image from the <strong class="bold">Project</strong> window and drop it onto the empty image <strong class="bold">Texture</strong> slot in the <strong class="bold">Inspector</strong> window.</li>
				<li>Check the <code>0.08</code> meters (8 cm).</li>
				<li>Also, check the <strong class="bold">Keep Texture At Runtime</strong> checkbox.</li>
			</ol>
			<p>The Reference Image Library should now look as follows:</p>
			<div><div><img src="img/Figure_8.17_B15145.jpg" alt="" width="807" height="495"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17 – Reference Image Library with the Mars-MarkerCard image added</p>
			<p>Next, we'll<a id="_idIndexMarker708"/> create the Mars Prefab and<a id="_idIndexMarker709"/> material. </p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor217"/>Creating the planet prefab</h2>
			<p>To create the <a id="_idIndexMarker710"/>planet prefab, we'll copy and modify the Earth Prefab assets. Perform the following steps:</p>
			<ol>
				<li value="1">In the <code>Prefabs/</code> folder).</li>
				<li>Select <code>Mars Prefab</code>.</li>
				<li>Open <strong class="bold">Mars Prefab</strong> for editing. Select the child <strong class="bold">Planet</strong> game object.</li>
				<li>In the <code>Materials/</code> folder and select <code>Mars Material</code>.</li>
				<li>Drag <strong class="bold">Mars Material</strong> onto the <strong class="bold">Planet</strong> object.</li>
				<li>In the <code>Planet Textures/</code> folder) and drag it onto the <strong class="bold">Mars Material | Base Map</strong> texture slot.<p>The Mars <a id="_idIndexMarker711"/>Prefab Planet should now look as follows:</p><div><img src="img/Figure_8.18_B15145.jpg" alt="Figure 8.18 – Mars Prefab with its Planet set to the Mars Material&#13;&#10;" width="1012" height="522"/></div><p class="figure-caption">Figure 8.18 – Mars Prefab with its Planet set to the Mars Material</p></li>
				<li>Next, we'll set the Mars Planet metadata. In the <strong class="bold">Hierarchy</strong> window, select the root <strong class="bold">Mars Prefab</strong> game object.</li>
				<li>In the <code>Mars</code>; <code>25.2</code>; <code>24.7</code>. For its <code>Mars is the fourth planet from the Sun and the second-smallest planet in the Solar System</code>.</li>
				<li><strong class="bold">Save</strong> the prefab and return to the scene Hierarchy (using the <strong class="bold">&lt;</strong> button at the top left of the <strong class="bold">Hierarchy</strong> window).</li>
			</ol>
			<p>Now, we can add the prefab to the Main-mode <strong class="bold">Planet Prefabs</strong> dictionary, as follows:</p>
			<ol>
				<li value="1">In the scene <strong class="bold">Hierarchy</strong>, select the <strong class="bold">Main Mode</strong> game object (under <strong class="bold">Interaction Controller</strong>).</li>
				<li>In the <strong class="bold">Inspector</strong> window, click the <strong class="bold">+</strong> button at the bottom right of the <strong class="bold">Planets Main Mode | Planet Prefabs</strong> list.</li>
				<li>Type the<a id="_idIndexMarker712"/> word <code>Mars</code> into the <code>Id</code> slot.</li>
				<li>Unfold the item and, from the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Mars Prefab</strong> object onto the <strong class="bold">Value</strong> slot in the <strong class="bold">Inspector</strong> window.</li>
			</ol>
			<p>The <strong class="bold">Planets Main Mode</strong> component should now look as follows:</p>
			<div><div><img src="img/Figure_8.19_B15145.jpg" alt="Figure 8.19 – The Planets Main Mode component's Planet Prefabs dictionary with Mars added&#13;&#10;" width="672" height="270"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19 – The Planets Main Mode component's Planet Prefabs dictionary with Mars added</p>
			<p>If you <strong class="bold">Build and Run</strong> now, when in Scan-mode, point the camera at your Mars planet card. The Mars 3D object will be added to the scene, rotating in all its glory!</p>
			<p>Unfortunately, after doing this, if you move the camera to scan the Earth planet card, nothing will happen. Let's fix that.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor218"/>Responding to detected images</h2>
			<p>Your scripts can<a id="_idIndexMarker713"/> subscribe to events so that they're notified when an image is being tracked, updated, or removed. Specifically, we can implement an <code>OnTrackedImageChanged</code> function to handle these events. We can use this in the <code>PlanetsMainMode</code> script, as follows:</p>
			<ol>
				<li value="1">Open the <code>PlanetsMainMode</code> script for editing again and add the following code:<pre>    void OnTrackedImageChanged         (ARTrackedImagesChangedEventArgs eventArgs)
    {
        foreach (ARTrackedImage newImage in                  eventArgs.added)
        {
            InstantiatePlanet(newImage);
        }
    }</pre></li>
				<li>Add the following line to your <code>OnEnable</code> function, adding a listener to <code>imageManager</code>:<pre>        imageManager.trackedImagesChanged +=            OnTrackedImageChanged;</pre></li>
				<li>Likewise, remove the listener in <code>OnDisable</code>:<pre>    void OnDisable()
    {
        imageManager.trackedImagesChanged -=            OnTrackedImageChanged;
    }</pre><p>When <code>ARTrackedImageManager</code> detects a new image, the Main-mode script will kick in. It contains a listener for the events and will call <code>InstantiatePlanet</code> for any newly tracked images.</p></li>
				<li>If the app completely loses image tracking, we should go back to Scan-mode and display its instructional graphic, prompting the user to find a reference image. Add this <a id="_idIndexMarker714"/>check to <code>Update</code>, as follows:<pre>    void Update()
    {
        if (imageManager.trackables.count == 0)
        {
            InteractionController.EnableMode("Scan");
        }
    }</pre><p class="callout-heading">Tip – Tracking the State of Individual Trackables</p><p class="callout">AR Foundation also provides you with the current tracking state of each trackable image individually. Given a trackable image (<code>ARTRackedImage</code>), you can check its <code>trackingState</code> for <code>Tracking</code> – image is actively tracking, <code>Limited</code> – image is being tracked but not reliably, or <code>None</code> – the image is not being tracked. See <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html</a><code>#tracking-state</code>. In this project, we will only go back to Scan mode when no images are being tracked, so we don't necessarily need this extra level of status monitoring.</p></li>
			</ol>
			<p>OK – this is getting pretty robust. <strong class="bold">Build and Run</strong> the project again, this time scanning either (or both) the Earth and Mars planet cards. We've got planets! The following screen capture shows the app running, with the addition of the information UI at the bottom of the screen, which we will add in the next section:</p>
			<div><div><img src="img/Figure_8.20_B15145.jpg" alt="Figure 8.20 – Earth and Mars rendered at runtime&#13;&#10;" width="447" height="893"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20 – Earth and Mars rendered at runtime</p>
			<p>Go ahead and <a id="_idIndexMarker715"/>add the rest of the planets to your project by following these same steps. As we mentioned earlier in this chapter, referencing the NASA data provided at <a href="https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html">https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html</a>, use their <em class="italic">Length of Day</em> row for our <code>Planet</code> script already includes an animation speed scalar, <code>animationHoursPerSecond</code>, that you can use to modify the rotation rates that are visualized in the app.</p>
			<p>Now that our application supports multiple planets, you might want to tell the user more about the specific planet that they are looking at. Let's add this capability to Main-mode so that it responsively updates the UI.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor219"/>Making a responsive UI</h1>
			<p>In this section, we'll <a id="_idIndexMarker716"/>add an info panel to the bottom of the screen (as shown in the preceding screen capture). When you point the camera at one planet or another, we'll show the planet's name, as well as an <strong class="bold">Info</strong> button, which will cause a text box to appear that contains more information about that planet.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/>Creating the Main-mode UI</h2>
			<p>When the app is<a id="_idIndexMarker717"/> in Main-mode, the Main UI panel is displayed. On this panel, we'll show the name of the current planet and an <strong class="bold">Info</strong> button for the user to press when they want more details about that planet. Perform the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, unfold the <strong class="bold">UI Canvas</strong> object and unfold its child <strong class="bold">Main UI</strong> object.</li>
				<li>The default child text in the panel is a temporary placeholder, so we can remove it. <em class="italic">Right-click</em> the child <strong class="bold">Text</strong> object and select <em class="italic">Delete</em>.</li>
				<li>Create a subpanel by <em class="italic">right-clicking</em> on <code>Info Panel</code>.</li>
				<li>Use <code>175</code>. </li>
				<li>I set my background <code>255</code>.</li>
				<li>Create a text element for the planet name. <em class="italic">Right-click</em> <code>Planet Name Text</code>.</li>
				<li>On the Planet Name Text <code>[Planet name]</code>.</li>
				<li>Set the text properties; for example, <code>50</code>; <code>72</code>.</li>
				<li>Create an <code>Info Button</code>.</li>
				<li>Set the button properties; for example, <code>150, 150</code>; <code>-20</code>.</li>
				<li>Unfold <code>-50</code> and its text content to <code>Info</code>.</li>
				<li><em class="italic">Right-click</em> <code>?</code>, <code>72</code>, <code>-15</code>.</li>
				<li>We're going to use this button to toggle a details panel on and off. So, let's replace its <strong class="bold">Button</strong> component with a <strong class="bold">Toggle</strong> instead. With the <strong class="bold">Info Button</strong> object selected in the <strong class="bold">Hierarchy</strong> window, in the <strong class="bold">Inspector</strong> window, remove the <strong class="bold">Button</strong> component using the <em class="italic">3-dot</em> context menu and selecting<strong class="bold"> Remove Component</strong>.</li>
				<li>Select <code>toggle</code>, and add a <strong class="bold">Toggle</strong> component.</li>
			</ol>
			<p>My main <strong class="bold">Info Panel</strong> now looks as follows:</p>
			<div><div><img src="img/Figure_8.21_B15145.jpg" alt="Figure 8.21 – Main UI's Info Panel with Planet Name Text and an Info Button&#13;&#10;" width="822" height="347"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 8.21 – Main UI's Info Panel with Planet Name Text and an Info Button</p>
			<p>The Planet Name Text's content will be filled in at runtime. Let's add that code now.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor221"/>Pointing the camera to show information</h2>
			<p>The plan is<a id="_idIndexMarker719"/> that with one or more virtual planets instantiated in the scene, the user can point the camera at a planet so that it displays the planet's name in the Info Panel. This can be implemented using a <code>Physics Raycast</code>. (Raycasts were introduced and explained in the previous chapters. See <a href="https://docs.unity3d.com/ScriptReference/Physics.Raycast.html">https://docs.unity3d.com/ScriptReference/Physics.Raycast.html</a>). Recall that at the beginning of this chapter, we put the Planet Prefab on a layer named <code>PlacedObjects</code>. We'll make use of that here.</p>
			<p>Make the following changes to the <code>PlanetsMainMode</code> script:</p>
			<ol>
				<li value="1">Ensure the script file contains the following assembly references:<pre>using TMPro;
using UnityEngine.UI;</pre></li>
				<li>At the top of the class, declare and initialize references to the AR <code>camera</code> and <code>layerMask</code> variables, as follows:<pre>    Camera;
    int layerMask;
    void Start()
    {
        camera = Camera.main;
        layerMask =             1 &lt;&lt; LayerMask.NameToLayer("PlacedObjects");
    }</pre></li>
				<li>Also, add references to the <code>planetName</code> and <code>infoButton</code> UI elements in the Info Panel:<pre>    [SerializeField] TMP_Text planetName;
    [SerializeField] Toggle infoButton;</pre></li>
				<li>We can initialize the UI settings when the mode is enabled. Please add the following lines to the <code>OnEnable</code> function:<pre>        planetName.text = "";
        infoButton.interactable = false;</pre></li>
				<li>Then, add<a id="_idIndexMarker720"/> the following highlighted code to the <code>Update</code> function:<pre>    void Update()
    {
        if (imageManager.trackables.count == 0)
        {
            InteractionController.EnableMode("Scan");
        }
<strong class="bold">        else</strong>
<strong class="bold">        {</strong>
<strong class="bold">            Ray = new Ray(camera.transform.position,                  camera.transform.forward);</strong>
<strong class="bold">            RaycastHit hit;</strong>
<strong class="bold">            if (Physics.Raycast(ray, out hit,                 Mathf.Infinity, layerMask))</strong>
<strong class="bold">            {</strong>
<strong class="bold">                Planet = hit.collider.                    GetComponentInParent&lt;Planet&gt;();</strong>
<strong class="bold">                planetName.text = planet.planetName;</strong>
<strong class="bold">                infoButton.interactable = true;</strong>
<strong class="bold">            }</strong>
<strong class="bold">            else</strong>
<strong class="bold">            {</strong>
<strong class="bold">                planetName.text = "";</strong>
<strong class="bold">                infoButton.interactable = false;               </strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
    }</pre></li>
				<li>Save the script. Back in Unity, select the <strong class="bold">Main Mode</strong> object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Drag the <strong class="bold">Planet Name Text</strong> game object from the <strong class="bold">Hierarchy</strong> window (under <strong class="bold">UI Canvas / Main UI / Info Panel</strong>) into the <strong class="bold">Planets Main Mode | Planet Name</strong> slot.</li>
				<li>Drag the <strong class="bold">Info Button</strong> object onto the <strong class="bold">Info Button</strong> slot.</li>
			</ol>
			<p>Go ahead and <strong class="bold">Build and Run</strong> the project one more time. While viewing one or more planets, as <a id="_idIndexMarker721"/>you point the device's camera at one of them, the planet's name will be shown in the Info Panel at the bottom of the screen.</p>
			<p>Lastly, let's set up the Info Button and description display.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/>Displaying information details</h2>
			<p>When the user<a id="_idIndexMarker722"/> is pointing their camera at a virtual 3D planet in the scene, we show the name of the planet in the Info Panel. When the user clicks the <strong class="bold">Info</strong> button, we want to show more information about the planet, such as its description text. Let's add a text panel for that now by performing the following steps:</p>
			<ol>
				<li value="1">In the <code>Details Panel</code>.</li>
				<li>It has already been set to <code>30</code>, <code>30</code>, <code>150</code>, and <code>200</code>.</li>
				<li><em class="italic">Right-click</em> <code>Details Text</code>.</li>
				<li>Format the text area; for example, set its <code>48</code>, its <code>30, 30, 30, 30</code>, and its <strong class="bold">Alignment</strong>: to <strong class="bold">Center, Middle</strong>.</li>
			</ol>
			<p>Now, add control of this panel to the <code>PlanetsMainMode</code> script, as follows:</p>
			<ol>
				<li value="1">Add <a id="_idIndexMarker723"/>references to <code>detailsPanel</code> and <code>detailsText</code> at the top of the class:<pre>    [SerializeField] GameObject detailsPanel;
    [SerializeField] TMP_Text detailsText;</pre></li>
				<li>Ensure the panel is hidden when the mode is enabled. Add the following line to the <code>OnEnable</code> function:<pre>       detailsPanel.SetActive(false);</pre></li>
				<li>Initialize the panel's content when a planet is being selected. That is, in <code>Update</code>, we must set <code>detailsText</code> at the same time we set <code>planetName</code>:<pre>            if (Physics.Raycast(ray, out hit,                 Mathf.Infinity, layerMask))
            {
                Planet = hit.collider.                    GetComponentInParent&lt;Planet&gt;();
                planetName.text = planet.planetName;
<strong class="bold">                detailsText.text = planet.description;</strong>
                infoButton.interactable = true;
            }
            else
            {
                planetName.text = "";
<strong class="bold">                detailsText.text = "";</strong>
                infoButton.interactable = false;
            }          </pre><p>Save the script. Back in Unity, we'll wire up the <strong class="bold">Info Button</strong> toggle.</p></li>
				<li>With <strong class="bold">Info Button</strong> selected in the <strong class="bold">Hierarchy</strong> window, in the <strong class="bold">Inspector</strong> window, click the <strong class="bold">+</strong> button<a id="_idIndexMarker724"/> at the bottom right of the <strong class="bold">Toggle | On Value Changed</strong> action list. </li>
				<li>From the <strong class="bold">Hierarchy</strong> window, drag the <strong class="bold">Details Panel</strong> game object onto the <strong class="bold">On Value Changed | Object</strong> slot.</li>
				<li>From the <strong class="bold">Function</strong> selection list, choose <strong class="bold">GameObject | Dynamic Bool | SetActive</strong>.</li>
				<li>Save the scene.</li>
			</ol>
			<p>Now, when you <strong class="bold">Build and Run</strong> the project and view a planet, then press the <strong class="bold">Info</strong> button, the Details Panel will be displayed alongside the planet's description text, as shown in the following screen capture from my phone:</p>
			<div><div><img src="img/Figure_8.22_B15145.jpg" alt="Figure 8.22 – Displaying description text about Mars in the toggled Details Panel&#13;&#10;" width="505" height="1013"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22 – Displaying description text about Mars in the toggled Details Panel</p>
			<p>In this section, we <a id="_idIndexMarker725"/>added a responsive UI to the scene. When the user points their device camera at a virtual planet that's been instantiated in the scene, the name of the planet is displayed in the Info Panel at the bottom of the screen. If the user taps the <strong class="bold">Info</strong> button, a text panel is toggled, showing additional details about that specific planet.</p>
			<p>Can you think of additional ways to improve this project? </p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor223"/>Summary</h1>
			<p>In this chapter, you built an AR project that lets you visualize and learn about planets in our Solar System. The scene uses AR image detection and tracks the planet cards that you printed out from the PDF file provided with the files for this book. Each planet card image includes a distinct marker with unique details, high contrast edges, and asymmetric shapes, making them readily detectable and trackable by the AR system. You set up the AR Session to track images using the AR Trackable Image Manager component and built a Reference Image Library asset with the planet card images.</p>
			<p>You then created a generic Planet Prefab with a Planet script that controls the rotation behavior and metadata for a planet. Then, you created separate prefab variants for each planet. You wrote a <code>PlanetsMainMode</code> script that instantiates the correct planet prefab when a specific planet card image is detected. This allows multiple tracked images and planets to be present in the scene. Then, you added a responsive UI where the user can point their device camera to an instantiated planet and get additional information about that virtual object. </p>
			<p>In the next chapter, we'll explore another kind of AR application: flipping the device camera so that it's facing the user to make selfie face filters.</p>
		</div>
	</div></body></html>