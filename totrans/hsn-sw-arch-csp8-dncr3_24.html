<html><head></head><body>
        

                            
                    <h1 class="header-title">Challenges of Applying CI Scenarios in DevOps</h1>
                
            
            
                
<p><strong>Continuous Integration </strong>(<strong>CI</strong>) is a step ahead of DevOps. In the previous chapter, we discussed the basics of CI and how DevOps depends on it. Its implementation was presented in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml"/><a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>, too, but differently from the other practical chapters, the purpose of this chapter is discussing how to enable CI in a real scenario, considering the challenges that you, as a software architect, will need to deal with.</p>
<p>The topics covered in this chapter are as follows:</p>
<ul>
<li>Understanding CI</li>
<li>Understanding the risks and challenges when using CI</li>
<li>Understanding the WWTravelClub project approach for this chapter</li>
</ul>
<p>Like in the previous chapter, the sample of the WWTravelClub will be presented during the explanation of the chapter, since all the screens captured to exemplify CI came from it. Besides this, we will offer a conclusion at the end of the chapter so you can understand CI principles easily.</p>
<p>By the end of the chapter, you will be able to decide whether or not to use CI in your project environment. Additionally, you will be able to define the tools needed for the successful use of this approach. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires Visual Studio 2019 Community Edition or better. You may also need an Azure DevOps account, as described in <a href="bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml"/><a href="bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml">Chapter 3</a>, <em>Documenting Requirements with Azure DevOps</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding CI</h1>
                
            
            
                
<p>As soon as you start working with a platform such as Azure DevOps, enabling CI will definitely be easy when it comes to clicking on the options for doing so, as we saw in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>. So, technology is not the Achilles' heel for implementing this process.</p>
<p>The following screenshot shows an example of how easy it is to turn on CI using Azure DevOps. By clicking in the build pipeline and editing it, you will be able to set a trigger that enables CI after some clicks:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f57caac3-6103-4833-a17e-082a6c739f89.png"/></p>
<p>The truth is that CI will help you solve some problems. For instance, it will force you to test your code, since you will need to commit the changes faster, so other developers can make use of the code you are programming. </p>
<p>On the other hand, you will not enable CI just by clicking on the preceding screenshot. For sure, you will turn on the possibility of starting a build as soon as you get a commit done and the code is done, but this is far from saying you have CI available in your solution.</p>
<p class="mce-root"/>
<p>The reason why you as a software architect need to worry a bit more about it is related to the real understanding of what DevOps is. As discussed in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>, the need to deliver value to the end user will always be a good way to decide and draw the development life cycle. So, even if turning on CI is easy, what is the impact of this feature being enabled for your end user? Once you have all the answers to this question and you know how to reduce the risks of its implementation, then you will be able to say that you have a CI process implemented.</p>
<p>It is worth mentioning that CI is a principle that will make DevOps work better and faster, as was discussed in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>. However, DevOps surely can live without it, once you are not sure if your process is mature enough to enable code being continuously delivered. More than that, if you turn on CI in a team that is not mature enough to deal with its complexity, you will probably cause a bad understanding of DevOps, since you will start incurring some risks while deploying your solution.</p>
<p>This is the reason why we are dedicating an extra chapter on CI. You need to understand the risks and challenges you will have as a software architect once you turn CI on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the risks and challenges when using CI</h1>
                
            
            
                
<p class="mce-root">Now, you may be thinking about the risks and challenges as a way for you to avoid using CI. But why should we avoid using it if it will help you do a better DevOps process? This is not the purpose of the chapter. The idea of this section is to help you, as a software architect, to mitigate the risks and find a better way to pass through the challenges using good processes and techniques.</p>
<p class="mce-root">The list of risks and challenges that will be discussed in the chapter are as follows:</p>
<ul>
<li class="mce-root">Continuous production deployment</li>
<li class="mce-root">Incomplete features in the production</li>
<li class="mce-root">Unstable solutions for testing</li>
</ul>
<p>Once you have the techniques and the processes defined to deal with them, there is no reason to not use CI. It is worth mentioning that DevOps does not depend on CI. However, it does make DevOps work more softly. Now, let's have a look at them.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Disabling continuous production deployment</h1>
                
            
            
                
<p>Continuous production deployment is a process where, after a commit of a new piece of code and some pipeline steps, you will have this code in the production environment. This is not impossible but is really hard and expensive to do. Besides, you need to have a really mature team. The problem is that most of the demos and samples you will find on the internet presenting CI will show you a fast-track to deploy the code. The demonstrations of CI/CD look so simple and easy to do! This <em>simplicity</em> can suggest you work as soon as possible on its implementation. However, if you think a little more, this scenario can be dangerous if you deploy directly in production! In a solution that needs to be available 24 hours a day, 7 days a week, this is impractical. So, you will need to worry about that and think of different solutions.</p>
<p>The first one is the use of a multi-stage scenario, as described in <a href="94c84805-6921-4b9b-9f11-745dce643f53.xhtml">Chapter 18</a>, <em>Understanding DevOps Principles</em>. The multi-stage scenario can bring more security to the ecosystem of the deployment you are building. Besides, you will get more options to avoid wrong deployments into production, such as pre-deployment approvals:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a694759e-0730-4a80-96c0-78b22dfd6f82.png"/></p>
<p class="mce-root">It is worth mentioning, too, that you can build a deployment pipeline where all your code and software structure will be updated by this tool. However, if you have something out of this scenario, such as database scripts and environment configurations, a wrong publication into production may cause damage to end users. Besides, the decision of when the production will be updated needs to be planned and, in many scenarios, all the platform users need. Use a <em>change management</em> procedure in these cases needs to be decided.</p>
<p>So, the challenge of delivering code to production will make you think about a schedule to do so. It does not matter if your cycle is monthly, daily, or even at each commit. The key point here is that you need to create a process and a pipeline that guarantees that only good and approved software is in the production stage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Incomplete features</h1>
                
            
            
                
<p>While a developer of your team is creating a new feature or fixing a bug, you will probably consider generating a branch that can avoid the use of the branch designed for continuous delivery. A branch can be considered a feature available in code repositories to enable the creation of an independent line of development since it isolates the code. As you can see in the following screenshot, creating a branch using Visual Studio is quite simple:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6a9163cb-9564-4941-a9fd-323d86ec3eb7.png" style="width:28.42em;height:26.83em;"/></p>
<p>This seems to be a good approach, but let's suppose that the developer has considered the implementation ready for deploying and has just merged the code into the master branch. What if this feature is not ready yet, just because a requirement was omitted? What if the bug has caused an incorrect behavior? The result can be a release with an incomplete feature or an incorrect fix.</p>
<p>A good practice to avoid broken features and even wrong fixes in the master branch is the use of pull requests. Pull requests will let other team developers know that the code you developed is ready to be merged. The following screenshot shows how you can use Azure DevOps to create a New Pull Request for a change you have made:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1da2c9b5-89d2-4b5e-b666-bc26a3f505e4.png" style="width:30.83em;height:35.42em;"/></p>
<p>Once the pull request is created and the reviewers are defined, each reviewer will be able to analyze the code and decide whether this code is healthy enough to be in the master branch. The following screenshot shows a way to check it by using the compare tool to analyze the change:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3738a72b-ec3a-469f-a1d5-4bc0103878f7.png"/></p>
<p>Once all approvals are done, you will be able to safely merge the code to the master branch, as you can see in the following screenshot. To merge the code, you will need to click on Complete merge. If the CI trigger is enabled, as shown earlier in the chapter, Azure DevOps will start a build pipeline:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/66fdc5c1-d45a-4c71-b95d-3746b6f34019.png"/></p>
<p>There is no way to argue that without a process like this, the master branch will suffer from many bad code being deployed that can cause damage together with CD. It is worth mentioning that the code review is an excellent practice in CI/CD scenarios, and it is considered a wonderful practice for creating good quality in any software as well.</p>
<p>The challenge that you need to focus on here is guaranteeing that only entire features will appear to your end users. You may use for solving it the feature flag principle, which is a technique that makes sure only features that are ready are presented to end users. Again, we are not talking about CI as a tool, but as a process to be defined and used every single time you need to deliver code for production.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Unstable solution for testing</h1>
                
            
            
                
<p>Considering that you have already mitigated the two other risks presented in this topic, you may find it pretty hard to have bad code after CI. It is true that the worries presented earlier will certainly be lower considering the fact that you are working with a multi-stage scenario and pull requests before pushing to the first stage.</p>
<p>But is there a way to accelerate the evaluation of release, being sure that this new release is ready for your stakeholder's tests? Yes, there is! Technically, the way you can do so is described in the use cases of <a href="c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml">Chapter 15</a>, <em>Testing Your Code with Unit Test Cases a</em><em>nd TDD</em>, and <a href="e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml">Chapter 20</a>, <em>Automation for Software Testing</em>.</p>
<p>As discussed in both those chapters, it is impracticable to automate every single part of the software, considering the efforts needed to do so. Besides, the maintenance of automation can be more expensive in scenarios where the user interface or the business rules change a lot.</p>
<p>To exemplify it, let's have a look at the following screenshot, which shows the unit and functional tests created by Azure DevOps when the WWTravelClub project is started:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1b21f9b1-ac3f-4d12-a1f1-89a463ed44d9.png"/></p>
<p>There are some architectural patterns, such as SOLID, presented in <a href="a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml">Chapter 9</a>, <em>Design Patterns and .NET Core Implementation</em>, and quality assurance approaches, such as peer review, that will give you better results than software testing.</p>
<p>However, these approaches do not invalidate automation practice. The truth is that all of them will be useful for getting a stable solution, especially when you are running a CI scenario. In this environment, the best thing you can do is to detect errors and wrong behaviors as fast as you can. Both unit and functional tests, as shown earlier, will help you with this. </p>
<p class="mce-root"/>
<p>Unit tests will help you a lot while discovering business logic errors before deployment, during the building pipeline. For instance, in the following screenshot, you will find a simulated error that canceled the build since the unit test did not pass:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4d978df6-4805-403c-8c8c-ad58718c16b7.png"/></p>
<p>The way to get this error is quite simple. You need to code something that does not respond according to what the unit tests are checking. Once you commit it, considering you have the trigger of continuous deployment on, you will have the code building in the pipeline. One of the last steps provided by the Azure DevOps Project Wizard we have created is the execution of the unit tests. So, after the build of the code, the unit tests will run. If the code does not match the tests anymore, you will get the error.</p>
<p>Meanwhile, the following screenshot shows an error during the functional tests in the Development/Tests stage. At this moment, the Development/Tests environment has a bug that was rapidly detected by functional tests:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f192881d-5f7d-4a01-9c6c-ce5cc904cced.png"/></p>
<p>But this is not the only good thing about applying functional tests in the process of CI/CD, once you have protected other deployment stages with this approach. For instance, let's take a look at the following screenshot from the Release pipeline interface in Azure DevOps. If you look at Release-9, you will realize that since this error happened after the publication in the Development/Tests environment, the multi-staged environment will protect the other stages of the deployment:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/acf1c1ea-946e-4322-bd1b-b5937476833e.png"/></p>
<p>The key point to success in the CI process is to think about it as a useful tool for accelerating the delivery of software and to not forget that a team always needs to deliver value to their end users. With this approach, the techniques presented earlier will provide incredible ways to achieve the results that your team aims for. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the WWTravelClub project approach</h1>
                
            
            
                
<p>During the chapter, WWTravelClub project screenshots were present, exemplifying the steps for getting a safer approach while enabling CI. Even considering WWTravelClub as a hypothetical scenario, some concerns were taken into account while building it:</p>
<ul>
<li>CI is enabled, but a multi-stage scenario is enabled too.</li>
<li>Even with a multi-stage scenario, the pull request is a way to guarantee that only code with good quality will be presented in the first stage.</li>
<li>To do a good job in the pull request, peer reviews are undertaken.</li>
<li>The peer reviews check, for instance, the presence of a feature flag while creating a new feature.</li>
<li>The peer reviews check both unit and functional tests developed during the creation of the new feature.</li>
</ul>
<p>The preceding steps are not exclusively for WWTravelClub. You as a software architect will need to define the approach to guarantee a safe CI scenario. You may use this as a starting point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter covered the importance of understanding when you can enable CI in the software development life cycle, considering the risks and challenges you will take as a software architect once you decide to have it done in your solution.</p>
<p>Additionally, the chapter introduced some solutions and concepts that can make this process easier, such as multi-stage environments, pull request reviews, feature flags, peer reviews, and automated tests. Understanding these techniques and processes will enable you to guide your project to a safer behavior when it comes to CI in a DevOps scenario.</p>
<p>In the next chapter, we will see how automation for software testing works.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is CI?</li>
<li>Can you have DevOps without CI?</li>
<li>What are the risks of enabling CI in a non-mature team?</li>
<li>How can a multi-stage environment help CI?</li>
<li>How can automated tests help CI?</li>
<li>How can pull requests help CI?</li>
<li>Do pull requests only work with CI?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">These are some websites where you will find more information on the topics covered in this chapter:</p>
<ul>
<li><a href="https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps/">https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps/</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github">https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github</a></li>
<li><a href="https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd">https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd</a></li>
<li><a href="https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering">https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering</a></li>
<li><a href="https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video">https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video</a></li>
<li><a href="https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure">https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest">https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest</a></li>
<li><a href="https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/">https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/</a></li>
<li><a href="https://martinfowler.com/bliki/FeatureToggle.html">https://martinfowler.com/bliki/FeatureToggle.html</a></li>
</ul>


            

            
        
    </body></html>