# 理解软件解决方案中的不同领域

本章致力于一种现代软件开发技术，称为**领域驱动设计（DDD**），它最初由Eric Evans提出。虽然DDD已经存在了15多年，但由于其解决两个重要问题的能力，它在过去几年取得了巨大的成功：

+   在没有单个专家对整个领域有深入知识的情况下建模复杂系统。这种知识被分散在几个人之间。

+   面对由多个开发团队组成的大型项目。一个项目被分成几个团队的原因有很多，最常见的是团队规模以及所有成员拥有不同的技能和/或不同的地点。事实上，经验证明，超过6-8人的团队效率不高，而且不同的技能和地点显然会阻止紧密的互动。团队划分阻止了项目所有相关人员之间的紧密互动。

相反，上述两个问题的重要性在过去几年中增长，原因如下：

+   软件系统始终占据每个组织内部的大量空间，并且变得越来越复杂和地理上分散。

+   同时，频繁更新的需求增加，以便这些复杂的软件系统能够根据快速变化的市场需求进行适应。

+   前述问题导致了更复杂的CI/CD周期的构想和采用复杂的分布式架构，这些架构可能利用可靠性、高吞吐量、快速更新以及逐步演进旧子系统的能力。是的——我们正在谈论的是我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”中分析过的基于微服务和容器架构。

在这个场景中，通常需要实现具有相关快速CI/CD周期的复杂软件系统，这些系统始终需要更多的人来演进和维护。反过来，这导致了开发适合高复杂度领域和多个松散耦合开发团队协作的技术需求。

在本章中，我们将分析与领域驱动设计（DDD）相关的基本原则、优势和常见模式，以及如何在我们的解决方案中使用它们。更具体地说，我们将涵盖以下主题：

+   软件领域是什么？

+   理解领域驱动设计

+   使用SOLID原则映射您的领域

+   用例场景 - 理解用例的应用领域

让我们开始吧。

# 技术要求

本章需要Visual Studio 2017或2019免费社区版或更高版本，并安装所有数据库工具。

本章中所有的代码片段都可以在本书相关的GitHub仓库中找到，[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)[。](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)

# 软件领域是什么？

如我们在[第2章](a4194162-692d-4ac4-9b8e-a48199e746ab.xhtml)“功能和非功能需求”和[第3章](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml)“使用Azure DevOps记录需求”中讨论的，从领域专家到开发团队的知识转移在软件设计中起着根本的作用。开发者试图与专家沟通，并使用领域专家和利益相关者能够理解的语言来描述他们的解决方案。然而，在组织的各个部分，同一个词可能有不同的含义，而在不同的上下文中，看似相同的概念实体可能有完全不同的形态。

例如，在我们的WWTravelClub用例中，订单支付和包裹处理子系统对客户使用完全不同的模型。订单支付通过支付方式、货币、银行账户和信用卡来表征客户，而包裹处理则更关注过去访问和/或购买过的位置和包裹、用户的偏好以及他们的地理位置。此外，虽然订单支付使用我们可能粗略定义为“银行语言”的语言来指代各种概念，但包裹处理则使用典型的旅行社/运营商语言。

应对这些差异的经典方式是使用一个独特的抽象实体称为**客户**，它映射到两个不同的视图——订单支付视图和包裹处理视图。每个投影操作都从**客户**抽象实体中提取一些操作和属性，并更改它们的名称。由于领域专家只给我们提供投影视图，我们作为系统设计者的主要任务是创建一个可以解释所有视图的概念模型。以下图表显示了如何处理不同的视图：

![图片](img/68ac81ab-ebad-4a37-921f-c8e3bf813822.png)

经典方法的主要优势是我们有一个独特且一致的数据表示。如果这个概念模型构建成功，所有操作都将有一个正式的定义和目的，整个抽象将是整个组织*应该*工作方式的合理化，可能突出和纠正错误，并简化一些程序。

然而，这种方法的缺点是什么？首先，工作组织的这种方式可能会对现有的组织产生过度的影响，可能阻止它在一定时间内正确运行，因为使用唯一连贯模型的约束没有提供足够的选项来减轻这种影响。必须消除错误，必须消除重复，并且一切必须完美连贯，以便有一个最小的不可减轻的影响，因为我们减轻影响的唯一方式就是放弃整体连贯性。

在小型组织、软件旨在服务于整体组织的小部分，或者软件自动化的数据流百分比足够小的情况下，这种最小影响是可以接受的。然而，随着软件成为整个地理分布组织的骨干，剧烈的变化变得更加难以接受和不可行。此外，随着软件系统复杂性的增加，还会出现其他几个问题，如下所示：

+   由于我们不能通过将这些任务分解成更小的松散耦合任务来面对复杂性，因此形成唯一连贯的数据视图变得更加困难。

+   随着复杂性的增加，需要频繁的系统变更，但更新和维护一个独特的全局模型相当困难。此外，由于系统小部分变更引入的bug/错误可能会通过唯一共享的模型传播到整个组织。

+   系统建模必须由几个团队分担，并且只能面对由单独团队处理的松散耦合任务。

+   需要转向基于微服务架构，这使得唯一数据库的瓶颈更加难以接受。

+   随着系统的增长，我们需要与更多的领域专家沟通，每位专家都说不同的语言，并且对数据模型有不同的看法。因此，我们需要将我们独特模型的属性和操作翻译成/从更多语言，以便与他们沟通。

+   随着系统的增长，处理具有数百/数千个字段的记录变得更加低效。这种低效源于数据库引擎在处理具有多个字段的较大记录时效率低下（内存碎片化、太多相关索引的问题等）。然而，主要的不效率发生在ORM和业务层，它们被迫在更新操作中处理这些大记录。事实上，虽然查询操作通常只需要从存储引擎检索的几个字段，但更新和业务处理涉及整个实体。

+   随着数据存储子系统流量的增长，我们需要在所有数据操作中实现读取和更新/写入并行性。正如我们在[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)“如何在云中选择您的数据存储”中讨论的那样，虽然读取并行性可以通过数据复制轻松实现，但写入并行性需要分片，而将一个独特且紧密连接的数据模型分片是困难的。

这些问题是领域驱动设计在过去几年中取得成功的原因，因为它们代表了更复杂的软件系统，这些系统成为了整个组织的支柱。下一节将详细讨论DDD的基本原则。

# 理解领域驱动设计

领域驱动设计是关于构建一个独特的领域模型，并保持所有视图作为独立的模型。因此，整个应用程序领域被分割成更小的领域，每个领域都有一个独立的模型。这些独立的领域被称为**边界上下文**。每个领域以其专家所使用的语言为特征，并用于命名所有领域概念和操作。因此，每个领域定义了一种由专家和开发团队共同使用的通用语言，称为**通用语言**。不再需要翻译，如果开发团队以接口作为其代码的基础，领域专家能够理解和验证它们，因为所有操作和属性都是使用专家使用的相同语言表达的。

在这里，我们正在摒弃一个繁琐的唯一抽象模型，但现在我们有了几个需要以某种方式关联的独立模型。DDD提出将处理所有这些独立模型，即所有边界上下文，如下所示：

+   每当语言术语的含义发生变化时，我们需要添加边界上下文的边界。例如，在WWTravelClub用例中，订单支付和套餐处理属于不同的边界上下文，因为它们对单词**客户**赋予了不同的含义。

+   我们需要明确表示边界上下文之间的关系。不同的开发团队可能在不同边界上下文中工作，但每个团队都必须对其正在工作的边界上下文与其他所有模型之间的关系有一个清晰的了解。为此，这种关系在一份独特的文档中表示，并与每个团队共享。

+   我们需要确保所有边界上下文与持续集成保持一致。会议被组织和简化系统原型被构建，以验证所有边界上下文是否协调一致地发展，也就是说，所有边界上下文都可以集成到期望的应用程序行为中。

下面的图显示了我们在上一节中讨论的WWTravelClub示例在采用领域驱动设计（DDD）后的变化：

![图片](img/f7b60e75-1f5b-4d4f-88cd-fb420114cd19.png)

两个边界上下文的客户实体之间存在关系，而包裹处理边界上下文的购买实体与支付相关。识别映射到各个边界上下文中彼此对应的实体是正式定义表示所有上下文之间可能通信的接口的第一步。

例如，从前面的图中，我们知道支付是在购买之后进行的，因此我们可以推断出支付订单边界上下文必须有一个为特定客户创建支付的操作。在这个领域，如果新客户不存在，则会创建新客户。支付创建操作在购买后立即触发。由于在购买商品后还会触发更多操作，我们可以使用我们在第9章中解释的发布/订阅模式来实现与购买事件相关的所有通信，该模式称为*设计模式和.NET Core实现*。这些在领域驱动设计中被称为**领域事件**。使用事件来实现边界上下文之间的通信非常常见，因为它有助于保持边界上下文松散耦合。

一旦在边界上下文接口中定义的事件或操作的实例跨越了上下文边界，它就会立即被翻译成接收上下文的通用语言。在输入数据开始与其他领域实体交互之前执行这种翻译非常重要，以避免其他领域的通用语言被额外的上下文术语污染。

每个边界上下文实现都必须包含一个数据模型层，该层完全用边界上下文通用语言（类和接口名称以及属性和方法名称）表达，没有任何其他边界上下文通用语言的污染，也没有编程技术内容的污染。这是确保与领域专家良好沟通并确保将领域规则正确翻译成代码，以便领域专家可以轻松验证的必要条件。

当通信语言与目标通用语言之间存在强烈不匹配时，会在接收边界上下文边界处添加一个反腐败层。这个反腐败层的唯一目的是执行语言翻译。

包含所有Bounded Context表示、Bounded Context之间的相互关系和接口定义的文档称为**上下文映射**。上下文之间的关系包含组织约束，指定了在不同Bounded Context上工作的团队之间所需的那种合作类型。这些关系不约束Bounded Context接口，但会影响它们在软件CI/CD周期中可能的发展方式。它们代表了团队合作模式。最常见的模式如下：

+   **合作伙伴**：这是Eric Evans最初提出的模式。其想法是两个团队在交付上相互依赖。换句话说，他们共同决定，如果需要，在软件CI/CD周期中更改Bounded Context的相互通信规范。

+   **客户/供应商开发团队**：在这种情况下，一个团队充当客户，另一个团队充当供应商。两个团队定义Bounded Context的客户端接口以及一些自动化验收测试来验证它。之后，供应商可以独立工作。当客户的Bounded Context是唯一活跃的部分，调用其他Bounded Context暴露的接口方法时，这种模式是有效的。对于订单-支付和包裹处理之间的交互，订单-支付作为供应商，因为其功能从属于包裹处理的需求。当这种模式可以应用时，它将两个Bounded Context完全解耦。

+   **遵从者**：这与客户/供应商类似，但在这个情况下，客户端接受由供应商端强加的接口，没有协商阶段。这种模式对其他模式没有提供任何优势，但有时我们被迫处于模式所描述的情况，因为供应商的Bounded Context是在一个无法过多配置/修改的现有产品中实现的，或者因为它是一个我们不希望修改的遗留子系统。

值得指出的是，Bounded Context的分离只有在结果Bounded Context是松散耦合的情况下才是有效的；否则，通过将整个系统分解为子部分而获得的复杂性降低将被协调和通信过程的复杂性所克服。然而，如果Bounded Context是以**语言标准**定义的，即每当**通用语言**发生变化时，就添加Bounded Context边界，那么这实际上应该是这种情况。事实上，不同的语言可能只是由于组织子部分之间松散交互的结果而产生的，因为一个组织要与之互动的子部分越多，它们最终使用的共同语言就越多。

此外，所有人类组织都可以通过演变成松散耦合的子部分来增长，这与复杂软件系统可能仅为了松散耦合子模块的合作而实现的原因相同：这是人类能够应对复杂性的唯一方式。由此，我们可以得出结论，复杂组织/人工系统总是可以被分解成松散耦合的子部分。我们只需要理解*如何*。

除了我们之前提到的基本原理之外，DDD 提供了一些基本原语来描述每个边界上下文，以及一些实现模式。虽然边界上下文原语是 DDD 的一个组成部分，但这些模式只是我们在实现中可以使用的有用启发式方法，因此一旦我们选择采用 DDD，在某些或所有边界上下文中使用这些模式并不是强制性的。

在下一节中，我们将描述原语和模式。

# 实体和价值对象

DDD 实体代表具有明确定义的标识以及在其上定义的所有操作的领域对象。它们与其他更经典方法中的实体差别不大。此外，DDD 实体是存储层设计的起点。主要区别在于，DDD 更强调它们的面向对象特性，而其他方法主要将它们用作*记录*，其属性可以在没有太多约束的情况下写入/更新。另一方面，DDD 强制实施强 SOLID 原则，以确保只有某些信息被封装在其中，并且只有某些信息可以从外部访问，哪些操作允许在它们上执行，以及哪些业务级别的验证标准适用于它们。

换句话说，DDD 实体比基于记录的方法中的实体更丰富。在其他方法中，操作实体是在代表业务和/或领域操作的类外部定义的。在 DDD 中，这些操作被移动到实体定义中，作为它们的类方法。这样做的原因是它们提供了更好的模块化，并将相关的软件块保持在同一位置，以便可以轻松维护和测试。

由于同样的原因，业务验证规则被移动到 DDD 实体内部。DDD 实体验证规则是业务级别的规则，因此它们不能与数据库完整性规则或用户输入验证规则混淆。它们通过编码所表示对象必须遵守的约束，有助于实体以某种方式表示领域对象。在 .NET Core 中，可以使用以下列出的技术之一执行业务验证：

+   在修改实体的所有类方法中调用验证方法

+   将验证方法连接到所有属性设置器

+   通过使用自定义验证属性装饰类及其属性，然后在每次修改实体时调用`System.ComponentModel.DataAnnotations.Validator`类的`TryValidateObject`静态方法

一旦检测到验证错误，就必须以某种方式处理，也就是说，必须中止当前操作，并将错误报告给适当的错误处理器。处理验证错误的最简单方法是通过抛出异常。这样，两个目的都很容易实现，我们可以选择在哪里拦截和处理它们。不幸的是，正如我们在第2章“在C#编程时需要考虑的性能问题”部分中讨论的那样，异常意味着巨大的性能损失，因此，通常需要考虑不同的选项。在正常流程控制中处理错误会破坏模块化，因为需要处理错误的代码会散布到导致错误的各个方法栈中，并且代码中会有一个不断变化的条件集。因此，需要更复杂的选择。

异常的一个好替代方案是通知错误处理器在依赖注入引擎中定义的任何错误。由于作用域，在处理每个请求时都会返回相同的服务实例，这样控制整个调用栈执行的处理器就可以在控制流返回时检查可能出现的错误，并适当地处理它们。不幸的是，这种复杂的技巧不能立即中止操作执行或将其返回给控制处理器。因此，开发者被迫添加适当的控制条件来防止操作继续进行。这就是为什么尽管存在性能问题，但仍然建议在这种情况下使用异常。

业务级验证不应与输入验证混淆，输入验证将在第13章“展示ASP.NET Core MVC”中更详细地讨论，因为这两种类型的验证有不同的和补充的目的。虽然业务级验证规则编码了领域规则，但输入验证强制执行每个单个输入的格式（字符串长度、电子邮件和URL的正确格式等），确保提供了所有必要的输入，强制执行所选的用户-机器交互协议，并提供快速和即时的反馈，引导用户与系统交互。

由于DDD实体必须有一个明确定义的身份，它们必须具有作为主键的属性。通常，会覆盖所有DDD实体的`Object.Equal`方法，使得当两个对象具有相同的主键时，它们被认为是相等的。这可以通过让所有实体继承自一个抽象的`Entity`类来实现，如下面的代码所示：

[PRE0]

值得指出的是，一旦我们在`Entity`类中重新定义了`Object.Equal`方法，我们也可以通过`==`和`!=`运算符来覆盖它们。

`IsTransient`谓词在实体最近被创建且尚未记录在持久存储中时返回`true`，因此其主键尚未定义。

在.NET中，当覆盖一个类的`Object.Equal`方法时，也覆盖其`Object.GetHashCode`方法是一个好的实践，以便类实例可以有效地存储在字典和集合等数据结构中。这就是为什么Entity类覆盖了它。

值得注意的是，实现一个定义了`Entity<K>`的所有属性/方法的`IEntity<K>`接口。当我们需要在接口后面隐藏数据类时，这个接口非常有用。

另一方面，值对象代表无法用数字或字符串编码的复杂类型。因此，它们没有标识符和主键。它们上没有定义操作，且是不可变的；也就是说，一旦它们被创建，所有字段都可以读取但不能修改。因此，它们通常使用具有受保护的/私有设置器的类进行编码。当所有独立的属性都相等时，两个值对象被认为是相等的（有些属性不是独立的，因为它们只是以不同的方式显示其他属性编码的数据，例如`DateTime`的ticks及其日期和时间字段的表示）。

典型的值对象包括以数字和货币符号表示的成本、以经纬度表示的位置、地址、联系信息等。当存储引擎的接口是Entity Framework，正如我们在第6章[8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml]“C#中的数据交互 - Entity Framework Core”和第7章[77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml]“如何在云中选择您的数据存储”中分析的那样，值对象通过`OwnsMany`和`OwnsOne`关系与使用它们的实体连接。实际上，这样的关系也接受没有定义主键的类。

当存储引擎是NoSQL数据库时，值对象存储在使用它们的实体的记录中。另一方面，在关系型数据库的情况下，它们可以与分离的表实现，这些表的主键由Entity Framework自动处理，并对开发者隐藏（没有属性被声明为主键）或者，在`OwnsOne`的情况下，它们被扁平化并添加到使用它们的实体关联的表中。

# 使用SOLID原则映射您的领域

在以下子节中，我们将描述一些与DDD（领域驱动设计）常用的一些模式。其中一些可以在所有项目中采用，而另一些则只能用于特定的边界上下文。总体思路是将业务层分为两层：

+   应用层

+   领域层

在这里，领域层基于通用语言，并操纵DDD实体和值对象。DDD实体和值对象在领域层中定义。整个业务层通过在领域层定义但在数据层实现的接口与使用Entity Framework实现的数据层进行通信。这些接口方法传递/返回的数据被称为DDD实体（查询及其结果的表示）。领域层没有直接引用实现数据层的库，但领域层接口与其数据层实现之间的连接是在应用层的依赖注入引擎中完成的。从这一点我们可以理解以下内容：

+   数据层必须实现领域层的接口，并必须创建领域层中定义的DDD实体和值对象，因此它引用了领域层。

+   应用层引用领域层和数据层，但数据层类型的引用仅出现在依赖引擎中，在那里它们与在领域层中定义的相应接口相关联。

因此，领域层包含领域对象的表示、在其上使用的函数、验证约束以及与各种实体的关系。为了增加模块化和解耦，实体之间的通信通常使用事件编码，即使用发布/订阅模式。这意味着实体更新可以触发连接到业务操作的事件。

这种分层架构允许我们更改整个数据层，而不会影响领域层，领域层只依赖于领域规范和语言，不依赖于处理数据的技术细节。

应用层包含所有可能影响多个实体的操作定义以及所有应用程序所需的查询定义。业务操作和查询都使用领域层定义的接口与数据层交互。然而，虽然业务操作通过这些接口操纵和交换实体，但查询则向它们发送查询规范并从它们接收通用的DTO（数据传输对象）。业务操作可以通过其他层（通常是表示层）或与应用层的通信来调用。业务操作还可以连接到由其他操作修改实体时触发的事件。

因此，应用层在领域层定义的接口上操作，而不是直接与它们的数据层实现交互，这意味着应用层与数据层解耦。更具体地说，数据层对象仅在依赖注入引擎定义中提及。所有其他应用层组件都引用在领域层中定义的接口，依赖注入引擎注入适当的实现。

应用层通过以下一个或多个模式与其他应用程序组件进行通信：

+   它在通信端点（如HTTP Web API）上暴露业务操作和查询（见[第12章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)，*使用.NET Core应用服务架构*）。在这种情况下，表示层可能连接到这个端点或连接到其他端点，这些端点反过来又从这些端点和其他端点获取信息。从多个端点收集信息并在唯一端点暴露这些信息的应用程序组件被称为网关。它们可以是定制的，也可以是通用目的的，例如Ocelot。

+   它被直接实现表示层的应用程序（如ASP.NET Core MVC Web应用程序）作为库引用。

+   它不是通过端点暴露所有信息，而是将其处理/创建的一些数据通信给其他应用程序组件，这些组件反过来又暴露端点。

在我们描述这些模式之前，我们需要理解聚合的概念。

# 聚合

到目前为止，我们讨论了实体作为基于DDD的业务层处理的*单元*。然而，几个实体可以被操作并合并成单个实体。一个例子是采购订单及其所有项目。实际上，独立于所属订单处理单个订单项是完全没有意义的。这是因为订单项实际上是订单的子部分，而不是独立的实体。

没有任何交易可以单独影响一个订单项而不影响该订单项所在的订单。想象一下，同一家公司的两个不同的人都在尝试增加水泥的总数量，但一个人增加了1型水泥（项目1）的数量，而另一个人增加了2型水泥（项目2）的数量。如果每个项目都被当作一个独立的实体来处理，那么这两个数量都会增加，这可能会导致一个不连贯的采购订单，因为水泥的总数量会被增加两次。

另一方面，如果整个订单及其所有订单项在每次交易中都被两个人加载和保存，那么其中一个人将覆盖另一个人的更改，因此最终做出更改的人将满足他们的需求。在Web应用程序中，不可能在整个用户查看和修改订单的过程中锁定整个采购订单，因此使用乐观并发策略。例如，只需为每个采购订单添加一个版本号，并执行以下操作：

1.  不打开任何事务的情况下读取订单。

1.  在保存修改后的订单之前，我们打开一个事务并执行第二次读取。

1.  如果新检索到的订单的版本号与用户修改的订单的版本号不同，则操作将被中止，因为有人在第一次读取后立即修改了显示给用户的订单。在这种情况下，用户会被告知问题，并且新检索到的订单将再次显示给用户。

1.  如果版本号没有更改，我们增加版本号，继续保存，并提交事务。

一个采购订单及其所有子部分（其订单项）被称为**聚合**，而订单实体被称为聚合的根。由于聚合是由通过**子部分**关系连接的实体层次结构，因此它们总是有根。

由于每个聚合代表一个单独的复杂实体，因此对其进行的所有操作都必须通过一个唯一的接口来暴露。因此，聚合根通常代表整个聚合，对聚合的所有操作都定义为根实体的方法。

当使用**聚合**模式时，在业务层和数据层之间传输的信息单元被称为**聚合**、查询和查询结果。因此，聚合取代了单个实体。

那么，我们在第6章[交互式数据C# - Entity Framework Core](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)和第7章[如何在云中选择您的数据存储](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)中看到的WWTravelClub位置和包实体怎么办？包是根植于它们相关位置的唯一聚合的一部分吗？不！实际上，位置很少更新，对包所做的更改不会影响其位置以及与同一位置相关联的其他包。

# 仓库模式和单元工作模式

存储库模式是我们实现领域数据层之间接口的方式。由存储库实现的接口在领域层中定义，而它们的实现则在数据层中定义。这种实现数据层接口的独特之处在于其实体中心性质，意味着每个根聚合应该有一个不同的存储库。每个存储库包含对相关聚合执行的所有保存/创建操作，以及所有对构成聚合的实体执行的查询操作。

由于也存在跨越多个聚合的事务，通常情况下，会应用*工作单元*模式与存储库模式结合。*工作单元*模式指出，每个数据层接口（在我们的案例中，每个存储库）都包含一个对*工作单元*接口的引用，该接口代表当前事务的标识。这意味着具有相同*工作单元*引用的多个存储库属于同一事务。

这两种模式都可以通过定义一些种子接口来实现：

[PRE1]

所有存储库接口都继承自`IRepository<T>`并将`T`绑定到它们关联的聚合根，而*工作单元*仅实现`IUnitOfWork`。当使用Entity Framework时，`IUnitOfWork`通常由`DBContext`实现，这意味着`SaveEntitiesAsync()`可以执行其他操作，然后调用`DBContext`的`SaveChangeAsync`方法，以便将所有挂起的更改通过单个事务保存。如果需要从存储引擎检索数据时启动的更广泛的交易，它必须由负责整个操作的应用程序层处理程序启动和提交/回滚。`IRepository<T>`从空的`IRepisotory`接口继承，以帮助自动存储库发现。与本书相关的GitHub存储库包含一个`RepositoryExtensions`类，其`AddAllRepositories` `IServiceCollection`扩展方法可以自动发现一个程序集中包含的所有存储库实现，并将它们添加到依赖注入引擎中。

下图是基于存储库和Unity of Work模式的存储层/领域层/数据层架构图：

![](img/6e4ba8d3-66e0-4aa9-8975-e6f64347fdb8.png)

避免直接引用存储库实现的优点在于，如果我们对这些接口进行模拟，则可以轻松地对各个模块进行测试。

# DDD实体和Entity Framework Core

DDD 要求实体以与我们在[第 6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中定义实体的方式不同。实际上，Entity Framework 实体是具有几乎无方法的公共属性记录列表，而 DDD 实体应该具有编码领域逻辑、更复杂的验证逻辑和只读属性的方法。虽然可以添加进一步的验证逻辑和方法而不会破坏 Entity Framework 的操作，但添加必须映射到数据库属性之外的只读属性可能会产生必须妥善处理的问题。防止属性映射到数据库相当简单——我们只需要用 `NotMapped` 属性装饰它们即可。

只读属性存在的问题稍微复杂一些，可以通过三种基本方式解决：

+   将 DDD 实体定义为不同的类，并在实体返回/传递到存储库方法时在它们之间复制数据。这是最简单的解决方案，但需要您编写一些代码以在两种格式之间转换实体。DDD 实体在领域层定义，而 EF 实体继续在数据层定义。

+   让 Entity Framework Core 将字段映射到类私有字段，这样您就可以通过编写自定义获取器和/或设置器来决定如何将它们公开为属性。这可以在实体的配置代码中完成，如下所示：

[PRE2]

这种方法的主要缺点是字段以字符串的形式提供，这阻止了任何编译时检查，也阻止了自动重构，从而可能成为错误和维护问题的来源。此外，由于整个配置必须使用 `OnModelCreating` `DBContext` 方法的流畅接口执行，因此我们无法使用数据注释来配置属性。在这种情况下，实体定义必须按照 DDD 的规定从领域层移动。

+   将包含所有公共属性的 Entity Framework 类隐藏在接口后面，该接口在需要时仅暴露属性获取器。接口在领域层定义，而实体继续在数据层定义。

    在这种情况下，存储库必须公开一个 `Create` 方法，该方法返回接口的实现；否则，高层无法创建新的实例并将其添加到存储引擎中，因为接口不能使用 `new` 创建。

例如，假设我们想要为[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中“定义数据库实体”小节中定义的`Destination`类定义一个DDD接口，称为`IDestination`，并且假设我们希望将`Id`、`Name`和`Country`属性公开为只读，因为一旦目的地创建后，它们就不能再修改。在这里，让`Destination`实现`IDestination`并在`IDestination`中将`Id`、`Name`和`Country`定义为只读就足够了：

[PRE3]

既然我们已经讨论了DDD的基本模式和如何为DDD的需求适配Entity Framework，我们可以讨论更高级的DDD模式。在下一个小节中，我们将介绍CQRS模式。

# 命令查询责任分离（Command Query Responsibility Segregation，CQRS）模式

在其更一般的形式中，该模式的用法相当简单：使用不同的结构来存储和查询数据。在这里，关于如何存储和更新数据的要求与查询的要求不同。在DDD的情况下，存储的单位是*聚合*，因此增加、删除和更新涉及聚合，而查询通常涉及从几个聚合中提取的属性的更多或更少的复杂转换。

此外，通常我们不会在查询结果上执行业务操作——我们只是使用它们来计算其他数据（平均值、总和等）。因此，虽然更新需要具有完整面向对象语义（方法、验证规则、封装信息等）的实体，但查询结果只需要属性/值对的集合，因此只有公共属性而没有方法的DTOs工作得很好。

在其更常见的形式中，该模式可以描述如下：

![图片](img/c535aa97-526c-4dff-8fe5-4fe14d85f1fb.png)

从这个例子中我们可以得出的主要结论是，查询结果的提取不需要通过实体的构建和聚合的构建，但查询中显示的字段必须从存储引擎中提取并投影到临时的DTOs中。如果查询是用LINQ实现的，我们需要使用`Select`子句将必要的属性投影到DTOs中：

[PRE4]

然而，在更复杂的情况下，CQRS可能以更强的形式实现。具体来说，我们可以使用不同的边界上下文来存储预处理后的查询结果。这种方法在涉及由不同分布式微服务处理的不同边界上下文中存储的数据的查询中很常见。

实际上，另一个选择是一个聚合器微服务，它会查询所有必要的微服务以组装每个查询结果。然而，对其他微服务的递归调用以构建答案可能会导致不可接受的响应时间。此外，将一些预处理提取出来可以确保更好地利用可用资源。这种模式通过将由边界上下文更新引起的更改发送到所有需要它们来计算其预处理的查询结果的微服务来实现。

这种更强大的CQRS模式的使用将通常的本地数据库事务转换为复杂且耗时的分布式事务，因为单个查询预处理器微服务中的失败应该使整个事务无效。正如我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中解释的，*将微服务架构应用于您的企业应用*，由于性能原因，通常不接受实现分布式事务，因此常见的解决方案是放弃立即的整体一致数据库，并接受整体数据库将在每次更新后最终一致。瞬态故障可以通过我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中分析的重试策略来解决，*将微服务架构应用于您的企业应用*，而永久性故障则通过在已提交的本地事务上执行纠正操作来处理，而不是假装实现一个全局分布式的整体事务。

正如我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)中讨论的，*将微服务架构应用于您的企业应用*，微服务之间的通信通常使用发布/订阅模式来实现以改善微服务分离。

在这一点上，你可能会有以下疑问：

"为什么我们一旦有了所有预处理的查询结果，还需要保留原始数据？我们永远不会用它们来回答查询！"

对此的一些答案如下：

+   它们是我们可能需要从失败中恢复的`真理`的来源。

+   当我们添加新的查询时，我们需要它们来计算新的预处理结果。

+   我们需要它们来处理新的更新。实际上，处理更新通常需要从数据库中检索一些数据，可能显示给用户，然后进行修改。例如，要修改现有采购订单中的项目，我们需要整个订单，以便我们可以将其显示给用户并计算更改，以便我们可以将其转发给其他微服务。此外，无论何时我们修改或向存储引擎添加数据，都必须验证整个数据库的一致性（唯一键约束、外键约束等）。

在下一节中，我们将描述一个用于处理跨越多个聚合或多个边界上下文的操作的常见模式。

# 命令处理器和领域事件

为了保持聚合分离，通常，与其他聚合和其他边界上下文之间的交互是通过事件完成的。在计算每个聚合过程期间存储所有事件，而不是立即处理它们，以避免它们干扰正在进行的计算，这是一种良好的实践。这可以通过向本章 *实体和价值对象* 小节中定义的抽象实体类添加以下代码轻松实现，如下所示：

[PRE5]

在这里，`IEventNotification` 是一个空接口，用于标记类作为事件。

事件处理通常在更改存储在存储引擎之前立即执行。因此，在 `IUnitOfWork` 实现的 `SaveEntitiesAsync()` 方法中执行事件处理是一个好地方（见 *存储库和单元工作模式* 小节）。

对事件 `T` 的订阅可以提供为 `IEventHandler<T>` 接口的一个实现：

[PRE6]

类似地，业务操作可以通过包含操作所有输入数据的 `command` 对象来描述，而实现实际操作的代码可以通过 `ICommandHandler<T>` 接口的实现来提供：

[PRE7]

在这里，`ICommand` 是一个空接口，用于标记类作为命令。`ICommandHandler<T>` 和 `IEventHandler<T>` 是我们在 [第 9 章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml) 中描述的命令模式的示例，*设计模式和 .NET Core 实现*。

每个 `ICommandHandler<T>` 都可以在依赖注入引擎中注册，以便需要执行命令 `T` 的类可以在它们的构造函数中使用 `ICommandHandler<T>`。这样，我们就将命令（命令类）的抽象定义与其执行方式解耦。

同样的构造不能应用于事件 `T` 和它们的 `IEventHandler<T>`，因为当一个事件被触发时，我们需要检索几个 `IEventHandler<T>` 而不是只有一个。我们需要这样做，因为每个事件可能有多个订阅。然而，几行代码就可以轻松解决这个问题。首先，我们需要定义一个类，它托管给定事件类型的所有处理器：

[PRE8]

理念是每个需要触发事件 `T` 的类都需要一个 `EventTrigger<T>`，然后将要触发的事件传递给它的 `Trigger` 方法，该方法反过来调用所有处理器。

然后，我们需要在依赖注入引擎中注册 `EventTrigger<T>`。一个不错的方法是定义依赖注入扩展，我们可以调用它来声明每个事件，如下所示：

[PRE9]

这个 `AddEventHandler` 扩展必须自动生成 `EventTrigger<T>` 的 DI 定义，并且必须处理每个类型 `T` 使用 `AddEventHandler` 声明的所有处理器。

以下扩展类为我们做了这件事：

[PRE10]

与每个事件 `T` 相关的所有处理程序的 `H` 类型记录在字典条目中，该字典条目由事件的 `T` 类型索引。然后，每个 `H` 都记录在依赖注入引擎中。

当第一次添加事件 `T` 的条目时，会创建相应的字典条目（一个 `List<Type>`）并将相应的 `EventTrigger<T>` 添加到依赖注入引擎中。`EventTrigger<T>` 实例是通过传递给 `AddSingleton<EventTrigger<T>>` 的函数创建的，该函数使用 `T` 的字典条目来获取所有处理程序类型。然后，使用所有处理程序类型通过 `p.GetService(type)` 从依赖注入引擎中检索它们的实例。我们可以使用这个操作，因为所有处理程序类型都已注册在依赖注入引擎中。最后，使用所有处理程序列表创建所需的 `EventTrigger<T>` 实例。

当程序启动时，所有 `ICommandHandler<T>` 和 `IEventHandler<T>` 的实现都可以通过反射自动检索并注册。为了帮助自动发现，它们继承自 `ICommandHandler` 和 `IEventHandler`，这两个接口都是空的。本书的 GitHub 仓库中提供的 `EventDIExtensions` 类包含用于自动发现和注册命令处理程序和事件处理程序的方法。GitHub 仓库还包含一个 `IEventMediator` 接口及其 `EventMediator` 接口，其 `TriggerEvents(IEnumerable<IEventNotification> events)` 方法从依赖注入引擎中检索其参数中接收到的所有与事件关联的处理程序并执行它们。只要将 `IEventMediator` 注入到类中，就可以触发事件。`EventDIExtensions` 还包含一个扩展方法，用于发现实现空 `IQuery` 接口的查询，并将它们添加到依赖注入引擎中。

更为复杂的实现由 `MediatR` NuGet 包提供。前一小节专门介绍了一种极端的 CQRS 模式实现。

# 事件溯源

事件溯源是 CQRS 强化形式的一种极端实现。当原始的边界上下文根本不用于检索信息，而仅作为 *真相来源* 用于新的查询和从故障中恢复时，它非常有用。在这种情况下，我们不是更新数据，而是简单地添加描述已执行操作的 *事件*：*删除记录 ID 15*，将名称更改为 *ID 21 中的 John*，等等。这些事件立即发送到所有依赖的边界上下文，在出现故障和/或添加新查询的情况下，我们只需重新处理其中的一些即可。

虽然我们之前描述的所有技术都可以在所有类型的项目中使用，只要进行一些小的修改，但事件溯源需要在采用之前进行深入分析，因为，在几种情况下，它可能比它能解决的问题造成更大的问题。为了了解它误用时可能引起的问题，想象一下我们将它应用于已经由多个用户修改和验证但尚未批准的采购订单。由于采购订单需要在更新/验证之前检索，因此采购订单的边界上下文不仅仅被用作*真相来源*，所以不应将其应用于事件溯源。如果不是这种情况，那么我们可以将其应用于事件溯源，在这种情况下，我们的代码将被迫在每次更新订单时从记录的事件中重建整个订单。

它的一个使用示例是我们描述在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”末尾的收入日志系统。单个收入通过事件溯源记录，然后发送到我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”中描述的微服务，该微服务反过来使用它们来预处理未来的查询，即计算每日收入。

在下一节中，我们将学习如何将DDD应用于本书的WWTravelClub用例。

# 用例 – 理解用例的领域

从[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)，“理解软件架构的重要性”中*案例研究 – WWTravelClub*部分列出的需求和[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)，“如何在云中选择您的数据存储”中*用例 – 我在哪里存储数据？*部分的分析中，我们知道WWTravelClub系统由以下部分组成：

+   可用目的地和套餐的信息。我们在[第7章](77cdecb5-cef4-4b02-80a1-052ad366b9f3.xhtml)，“如何在云中选择您的数据存储”中实现了该子系统数据层的第一个原型。

+   预订/购买订单子系统。

+   与专家/审查子系统的通信。

+   支付子系统。我们在本章*领域驱动设计*部分的开始简要分析了该子系统的功能和它与预订购买子系统的关系。

+   用户账户子系统。

+   统计报告子系统。

前面的子系统代表不同的*边界上下文*吗？某些子系统可以被拆分为不同的边界上下文吗？这些问题的答案由每个子系统使用的*语言*提供：

+   子系统1使用的语言是*旅行社*的语言。没有客户的概念；只有地点、套餐及其特性。

+   子系统2中使用的语言对所有服务购买都是通用的，例如可用的资源、预订和采购订单。这是一个独立的边界上下文。

+   子系统3中使用的语言与子系统1的语言有很多相似之处。然而，也存在典型的*社交媒体*概念，如评分、聊天、帖子分享、媒体分享等。这个子系统可以分为两部分：一个具有新边界上下文的社交媒体子系统和一个属于子系统1边界上下文的*可用信息*子系统。

+   正如我们在*领域驱动设计*部分所指出的，在子系统4中，我们使用*银行*的语言。这个子系统与预订/采购子系统进行通信并执行执行购买所需的任务。从这些观察结果中，我们可以看出它是一个不同的边界上下文，并且与购买/预订系统有客户/供应商关系。

+   子系统5肯定是一个独立的边界上下文（就像几乎所有网络应用一样）。它与所有具有用户或客户概念的边界上下文都有关系，因为用户账户的概念总是映射到这些概念上。但这是如何实现的呢？简单——当前登录的用户被认为是社交媒体边界上下文的社会媒体用户、预订/采购边界上下文的客户以及支付边界上下文的付款人。

+   查询仅子系统，即6，使用分析和统计的语言，与其他子系统中使用的语言有很大不同。然而，它几乎与所有边界上下文都有联系，因为它从它们那里获取所有输入。前面的约束迫使我们采用强形式的CQRS，因此将其视为一个查询仅分离的边界上下文。我们在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，*将微服务架构应用于您的企业应用*中实现了一部分，使用了一个符合强形式CQRS的微服务。

总之，列出的每个子系统定义了一个不同的边界上下文，但部分与*专家/审查子系统*的通信必须包含在*关于可用目的地和套餐的信息*边界上下文中。

随着分析的继续和原型的实现，一些边界上下文可能会分裂，而另一些边界上下文可能会被添加，但立即开始建模系统并立即开始分析我们拥有的部分信息之间的边界上下文关系是基本的，因为这将推动进一步的调查，并帮助我们定义所需的通信协议和通用语言，以便我们可以与领域专家互动。

以下是该领域映射的基本初步草图：

![图片](img/070f378b-16a3-47ff-bfd1-dd1a800fade6.png)

为了简单起见，我们省略了**统计报告**边界上下文。在这里，我们假设**用户账户**和**社交**边界上下文与所有与之通信的其他边界上下文具有**一致**的关系，因为它们使用现有的软件实现，所以所有其他组件都必须适应它们。

如我们之前提到的，**预订**和**支付**之间的关系是**客户/供应商**，因为**支付**提供用于执行**预订**任务的服务。所有其他关系都被归类为**合作伙伴**。大多数边界上下文都有的客户/用户的各种概念由**用户账户**授权令牌协调，它间接地负责在所有边界上下文之间映射这些概念。

**包裹/位置**子系统不仅传达了执行预订/购买所需的包裹信息，而且还负责通知待处理的购买订单可能的价格变化。最后，我们可以看到社交互动是从现有的评论或位置开始的，从而与**包裹/位置**边界上下文建立通信。

# 摘要

在本章中，我们分析了采用领域驱动设计的主要原因以及它如何满足市场需求。在这里，我们描述了如何识别领域以及如何使用领域图来协调同一应用程序中不同领域的工作团队。然后，我们分析了DDD如何通过实体、值对象和聚合来表示数据，并提供建议和代码片段，以便我们可以在实践中实现它们。

我们还介绍了一些与领域驱动设计（DDD）一起使用的典型模式，即存储库和单元工作模式、领域事件模式、CQRS和事件溯源。然后，我们学习了如何在实践中实现它们。我们还展示了如何使用解耦处理来实现领域事件和命令模式，以便我们可以将填充代码片段添加到现实世界的项目中。

最后，我们利用DDD的原则在实践上定义领域，并为本书的WWTravelClub用例创建了领域图的第一个草图。

在下一章中，你将学习如何在项目中最大化代码重用。

# 问题

1.  什么提供了主要的提示，以便我们可以发现领域边界？

1.  用于协调独立边界上下文开发的主体工具是什么？

1.  构成聚合的每个条目是否确实使用其自己的方法与系统的其余部分进行通信？

1.  为什么只有一个聚合根？

1.  多少个存储库可以管理一个聚合？

1.  存储库如何与应用程序层交互？

1.  为什么需要单元工作模式？

1.  CQRS轻量级形式的原因是什么？它的最强形式的原因又是什么？

1.  主要允许我们将命令/领域事件与其处理程序耦合的工具是什么？

1.  事件源是否可以用来实现任何有界上下文？

# 进一步阅读

+   更多关于领域驱动设计的资源可以在这里找到：[https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)

+   关于CQRS设计原则的详细讨论可以在这里找到：[http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)

+   更多关于MediatR的信息可以在MediatR的GitHub仓库中找到：[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)

+   可以在马丁·福勒的以下博客文章中找到对事件源的一个良好描述及其示例：[https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)
