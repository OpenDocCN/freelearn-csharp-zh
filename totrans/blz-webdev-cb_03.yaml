- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Control of Event Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive into the world of event handling within Blazor applications.
    An **event** is a fundamental building block that signifies an action within the
    browser, such as clicks, inputs, or page loads. Events allow developers to execute
    specific code upon user interactions – creating an interactive and dynamic user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by exploring how to hook into event delegates, laying the foundation
    for event management. Next, we’ll discuss delegating responsibilities using **EventCallback**
    and lambda expressions that increase flexibility in event handling.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also cover essential strategies for controlling event propagation and
    preventing the triggering of default events. These skills are vital for creating
    intuitive user interfaces where you have complete control over user interactions.
    Furthermore, we introduce the concept of custom events, expanding the possibilities
    for an **event-driven** application design.
  prefs: []
  type: TYPE_NORMAL
- en: A key focus will be on understanding how events trigger rendering in Blazor.
    This understanding is crucial for optimizing application performance and ensuring
    a seamless user experience. By the end of this chapter, you’ll have a thorough
    understanding of event handling in Blazor and have gained the practical skills
    to apply these concepts effectively in your web development projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into event delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegating with lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegating with **EventCallback**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing default event actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling event propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling long-running events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim of this chapter is to keep the examples straightforward and focus on
    the principles of event handling in Blazor. With that said, you won’t need any
    additional tools, just these basics:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern IDE (that supports Blazor development)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 9 installed on your development machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modern web browser (that supports WebAssembly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Blazor project (where you’ll write code as you go along)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the code examples (and data samples) that you’ll see can be found in a
    dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into event delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI events are the cornerstone of user interaction on the web – signaling every
    click, scroll, or keyboard press and enabling you to craft an interactive application.
    An event delegate acts as a bridge between the browser and your code. Each user
    interaction triggers a designated handler that executes a predefined action. In
    this recipe, we will dive into the mechanics of event delegates, illustrating
    how they are detected and managed within a Blazor application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a page, where users can display and hide a list of tickets by clicking
    a button.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you implement a clickable button, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe01** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement a basic event delegate hook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new routable **TicketManager** component that renders in **InteractiveWebAssembly**
    mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the **@code** section to your **TicketManager** component. Declare a **ShowTickets**
    property of type **bool** that will determine the visibility of the ticket list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, still inside the **@code** block, implement a method to toggle
    the **ShowTickets** property to change the ticket list’s visibility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the markup area of the **TicketManager** component, introduce a button that
    leverages the **ToggleTickets()** method and allows the user to update the UI
    accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the button, based on the current value of the **ShowTickets** property,
    conditionally skip displaying the list of tickets or render the horizontal separator,
    indicating where the tickets area starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Under the horizontal separator, render the list of tickets, utilizing the **Tickets.All**
    collection, from the copied sample data, as your data source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin the implementation by creating a routable **TicketManager** component,
    as outlined in *step 1* . We declare the navigable path with the **@page** directive.
    We also declare an interactive render mode as we will need our button to be actionable.
    Next, in *step 2* , we introduce a backing **ShowTickets** property. This property
    serves as a flag indicating the current visibility state of the ticket list –
    either displayed or hidden. Then, in *step 3* , we introduce a **ToggleTickets()**
    method designed to toggle the **ShowTickets** property.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the core of interactivity in *step 4* by hooking into the event
    callback mechanism of Blazor. We add a button in the component’s markup to give
    users the power to control the display state of the ticket list. With **@onclick**
    , we can trigger our **ToggleTickets()** method when an **onclick** event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5* , we check the value of the **ShowTickets** property and decide
    whether to skip rendering the ticket list entirely. For cases when we render the
    list, we add a **<hr />** tag to clearly indicate where the tickets area starts.
    In *step 6* , we iterate over the **Tickets.All** sample collection and render
    all available ticket titles in a flexible **div** container. With this setup,
    **TicketManager** reacts to user interactions and either renders or hides the
    ticket list, as dictated by the current value of the **ShowTickets** property.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blazor offers seamless integration with **onclick** , **ondrag** , **oncopy**
    , and other HTML events you’re already familiar with, allowing for dynamic and
    interactive web application development. By prefixing the event name with the
    **@** symbol, you signal to Blazor that you’re employing a Blazor-specific event
    rather than a standard HTML event. This distinction is crucial for harnessing
    the full power of Blazor’s event system.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key advantages of using Blazor events is their ability to update
    the DOM in real time. Blazor employs a native **diffing algorithm** , which calculates
    precisely which parts of the DOM have changed and updates only those parts. This
    results in a significantly smaller payload when communicating with the server
    and faster rendering times regardless of the selected render mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that Blazor rendering is typically triggered only upon
    the initial render of a component or when you explicitly invoke the **StateHasChanged()**
    lifecycle method. If we explore deeper, HTML event counterparts in Blazor are
    actually instances of **EventCallback<T>** (complete with event arguments). A
    closer look at the **EventCallback** implementation reveals that it invokes the
    **HandleEventAsync()** method of the **Receiver** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, our receiver inherits from **ComponentBase** . Intriguingly,
    the **ComponentBase.HandleEventAsync()** method automatically invokes **StateHasChanged()**
    . As a result, the component’s state updates without requiring manual intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Delegating with lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will explore the power of **lambda expressions** in .NET
    and their pivotal role in Blazor event handling. In the simplest terms, a lambda
    expression is an anonymous method that follows a specific syntax. These expressions
    are a cornerstone of functional programming in .NET and offer a streamlined approach
    to writing inline delegate implementations. When it comes to Blazor, delegating
    with lambda expressions becomes particularly advantageous. They come in handy
    for defining event handlers and callbacks directly within the markup. They also
    enable you to intercept incoming parameters and a current operational context.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s leverage lambda expressions and add a few more actions to the tickets
    list, allowing us to modify the state of a given ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you dive into delegating with lambda expressions, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe02** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **TicketManager** component from the *Hooking into event delegates*
    recipe or from the **Chapter03** / **Recipe01** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to see the power of delegating with lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **@code** block of **TicketManager** and, below the existing
    code, initialize an object of type **Ticket** to store the details of the currently
    selected ticket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below, still within the **@code** block, implement a **Show()** method that
    enables setting the value of the currently selected ticket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to the **TicketManager** markup and extend the rendering of ticket details
    by adding two action buttons below the **Title** section and attaching their actions
    with lambda expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the loop rendering ticket details, check whether the user has already
    set the **SelectedTicket** value and conditionally skip the specific ticket details
    rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the case where the **SelectedTicket** variable has a value, render the
    ticket title, price, and availability. Ensure that this section only becomes visible
    when the value of **SelectedTicket** is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **@code** block of **TicketManager** and initialize
    a **SelectedTicket** variable that will hold a reference to the currently selected
    ticket. Next, in *step 2* , we implement a **Show()** method, which accepts **Ticket**
    as a parameter. The singular responsibility of the **Show()** method is to update
    the **SelectedTicket** reference.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we shift to the **TicketManager** markup where we iterate over
    the **Tickets.All** collection from the sample and render each ticket title. Below
    the section with **Title** , we add two buttons enabling administrative actions,
    leveraging the delegation with lambda expressions. With the first button, we allow
    a user to display a given ticket’s details by attaching the **Show()** method
    to the button’s **@onclick** event and passing over a reference to the currently
    iterated **ticket** object. Here, the use of lambda expressions allows implementing
    precise and context-aware actions. The second button enables the user to top up
    the ticket stock. This time, we use an **anonymous lambda expression** – a lambda
    expression that encapsulates the operation itself rather than delegating to an
    existing method. We access the **Stock** property of each ticket as we iterate
    over the **Tickets.All** sample collection and increment the **Stock** value by
    5 directly within the markup.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the flexibility and power of lambda expressions comes great responsibility.
    Minimizing the amount of C# code within the markup is good practice. Use a strongly
    typed method to encapsulate complex and lengthy lambda expressions and maintain
    the clarity of your code.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we extend the **TicketManager** markup further. Similar to checking
    the **ShowTickets** value and conditionally displaying the list of tickets (that
    we implemented in the *Hooking into event delegates* recipe), we check whether
    the user set the value of **SelectedTicket** and conditionally skip the rendering
    of the specific ticket details. We conclude the implementation in *step 5* by
    adding a simple markup to render the **Title** , **Price** , and **Stock** properties
    of the ticket that the user selects. As Blazor converts the lambda expression
    to an **EventCallback** object, users will see updates of the **Stock** property
    value immediately after each **Top Up** button click.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re interested in learning more about the roles and capabilities of lambda
    expressions, visit the Microsoft Learn section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)'
  prefs: []
  type: TYPE_NORMAL
- en: Delegating with EventCallback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore event delegation with the help of **EventCallback**
    . **EventCallback** in Blazor is a mechanism that enables components to listen
    for and react to user-generated events or interactions, tying closely with the
    framework’s architectural design. This Blazor-native feature empowers developers
    to write cleaner, more efficient code by seamlessly integrating with the component
    lifecycle and the overall application state. The primary benefit of event callbacks
    is their ability to automatically manage UI updates through the **StateHasChanged()**
    method, ensuring that the user interface remains in sync with the application’s
    state. **EventCallback** is also a null-safe object – when it’s not assigned but
    invoked, it safely skips rather than throwing **NullReferenceException** . You
    will see **EventCallback** in all the recipes in this chapter, as it’s a building
    block of most interactivity in Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a component where we encapsulate administrative ticket actions
    with the help of **EventCallback** parameters. With that component, we will also
    simplify the markup of the ticket list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we implement delegation with **EventCallback** , do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe03** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **TicketManager** component from the *Delegating with lambda expressions*
    recipe or from the **Chapter03** / **Recipe02** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement an article management system using **EventCallback**
    delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **TicketOptions** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the **@code** block in **TicketOptions** and declare three required
    parameters, each of type **EventCallback** , corresponding to the different administrative
    actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump to the **TicketOptions** markup and construct buttons allowing a user
    to invoke **OnShow** , **OnTopUp** , and **OnRemove** actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Navigate to the **TicketManager** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the **@code** block of **TicketManager** , implement two new methods
    allowing you to remove and top up the stock of a **Ticket** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **TicketManager** markup, replace the existing action buttons in the
    ticket details with the **TicketOptions** instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we create a new **TicketOptions** component. In *step 2* , we
    initialize the **@code** block in **TicketOptions** and declare three required
    **EventCallback** parameters that will carry the action delegates necessary for
    triggering administrative ticket actions. Next, in *step 3* , we construct the
    **TicketOptions** markup with three buttons, each invoking **OnShow** , **OnTopUp**
    , or **OnRemove** parameters when users click them. Notice that we attach the
    **EventCallback** parameters directly to the **@onclick** event of each button.
    We don’t need to add additional methods that will act as proxies. Blazor will
    seamlessly link UI interactions with our predefined actions.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4* , we navigate to the **TicketManager** component. In *step 5* ,
    we extend the **@code** block of **TicketManager** with two additional methods.
    First, we implement a **TopUp()** method, that increments the current ticket **Stock**
    property value by 5. Next, we implement a **Remove()** method that simply removes
    a given ticket from the **Tickets.All** collection. In *step 6* , we locate the
    **TicketManager** markup area where we render primitive action buttons for each
    ticket. We replace those buttons with the **TicketOptions** markup and attach
    respective actions to each of the required **EventCallback** parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the **TicketOptions** component in place, we’ve significantly simplified
    the **TicketsManager** markup code. We’ve refactored ticket-related actions in
    a more organized and readable manner, making the overall code base cleaner and
    easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: But, since **TicketOptions** acts only as an action proxy and is not based on
    a **Ticket** reference, we effectively create new delegate instances, wrapping
    the actionable method inside, every time we render the **TicketOptions** component.
    This operation might come with a performance penalty even with all the C# optimization
    magic. In simple applications, the performance impact will likely be negligible.
    However, you must keep this in mind when working with data-heavy or highly reactive
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing default event actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore the mechanics of browsers automatically executing
    specific actions in response to user events. Default event actions can include
    form submission when the return key is pressed or navigating to a link’s URL when
    it’s clicked. However, there are scenarios in Blazor applications where you might
    need to intercept these automatic behaviors to control the user experience. Whether
    to manage form validation, confirm user intentions, or manage dynamic content
    updates without refreshing the page, preventing default actions becomes essential.
    I will guide you through stopping these default behaviors programmatically within
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a fast ticket creation feature, where we will intercept and
    apply custom logic with each key store a user makes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before exploring how to intercept and prevent default event actions, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe04** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **TicketManager** and **TicketOptions** from the *Delegating with event
    callbacks* recipe or from the **Chapter03** / **Recipe03** directory in the GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go through the process of preventing default event actions by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **@code** block of **TicketManager** and initialize a new **Creator**
    variable below the existing code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the **Creator** variable, still in the **@code** block, implement a **MonitorCreation()**
    method that intercepts a **KeyboardEventArgs** parameter, resolves its payload,
    and creates a new ticket instance when the user hits the *+* symbol on the keyboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jump over to the **TicketManager** markup. Below the render mode declaration
    at the top, construct a ticket creation area by adding a section header and an
    input with the **MonitorCreation()** method attached to its **@onkeydown** event,
    preventing the default **@** **onkeydown** behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **@code** block of **TicketManager** and initialize
    a **Creator** variable that will hold the current text that the user inputs in
    the fast ticket creation field. We will construct the creation field itself in
    a moment.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , next to the **Creator** variable, we implement a **MonitorCreation()**
    method, where we will put the custom **@onkeydown** logic for Blazor to execute
    instead of the default one. The **MonitorCreation()** method receives a **KeyboardEventArgs**
    object, having a **Key** property that we need for our custom creation logic.
    First, we check whether the clicked symbol matches the **+** key and add a new
    **Ticket** object to the **Tickets.All** collection. Next, we leverage the **IsBackspace()**
    extension method from the **Extensions** file provided with data samples. If the
    user clicks the backspace button and the **Creator** length indicates there are
    characters to remove, we remove the last character from the **Creator** value
    using the **range operator** . Lastly, we leverage another custom extension method
    from the **Extensions** file – **IsLetter()** – to check whether what the user
    pressed on their keyboard is in fact a letter and append it at the end of the
    current **Creator** value. With that implementation, we ignore all other keyboard
    actions. I strongly encourage you to experiment and add numbers support on your
    own!
  prefs: []
  type: TYPE_NORMAL
- en: In *step 3* , we jump to the **TicketManager** markup and build a section where
    users can fast-create new tickets. We add a **Quick creation** header, so it’s
    obvious what the intention of the input below is. And finally, we construct the
    **input** field where all the event-preventing happens. We set the **input** value
    to reflect the value of **Creator** . Notice, that we don’t leverage any binding
    here (more about binding in [*Chapter 2*](B22020_02.xhtml#_idTextAnchor065) ).
    Next, we attach the **MonitorCreation()** method to the **@onkeydown** event of
    the input so Blazor seamlessly triggers our custom logic. But **@onkeydown** has
    browser-default logic, conflicting with what we just attached. Here, we employ
    **@onkeydown:preventDefault** , instructing Blazor to bypass any default key-down
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the events in Blazor behave virtually the same, regardless of the render
    mode you use. However, some events, like **@onkeydown** , are inherently client-side
    in their expected result – responding immediately to user input. When using **@onkeydown**
    in **InteractiveServer** mode, you must consider that each event trigger will
    travel to the server and back before it’s reflected on the UI. In higher-latency
    scenarios, this round-trip can result in flaky and unstable behavior of the UI.
    Always consider the nature of the events you’re choosing and the appropriate render
    mode to ensure that your application remains user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: When building an internationally available application, you may need to support
    special local characters that require specific key combinations, such as using
    *Alt* + *a* to produce the letter **ą** in Polish. To handle these cases effectively,
    Blazor provides the ability to manage keyboard composition events.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can track the composition state of the input using the **IsComposing** property
    in **KeyboardEventArgs** . When **IsComposing** is set to **true** , it indicates
    that the user is entering a composite character. You should delay processing the
    input until **IsComposing** returns to **false** .
  prefs: []
  type: TYPE_NORMAL
- en: Controlling event propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore the process of controlling how events travel through
    the **Document Object Model** ( **DOM** ) within Blazor applications. Stopping
    default event propagation becomes crucial when we work with nested components
    or elements. You can ensure events such as clicks, hovers, or keyboard inputs
    have localized effects – thereby avoiding unintended ripple effects or behaviors
    in the UI. By mastering the control of event propagation, you can fine-tune interaction
    patterns within your application, leading to a smoother and more intuitive user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s allow users to click anywhere on the ticket record to display its details
    while ensuring that clicking on any of the nested administrative actions won’t
    propagate uncontrollably.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into controlling events propagation, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe05** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **TicketManager** and **TicketOptions** from the *Preventing default event
    actions* recipe or from the **Chapter03** / **Recipe04** directory in the GitHub
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control event propagation and see the **stopPropagation** attribute in action,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **TicketManager** markup and locate the container markup that
    we render for each ticket. Next to the assignment of the **id** attribute, attach
    the **Show()** method to the container’s **@** **onclick** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **TicketOptions** markup and attach the **stopPropagation**
    attribute to the **@onclick** event of each of the administrative action buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1* , we navigate to the **TicketManager** markup, where we render each
    ticket’s details in a dedicated container. You’ll find the container markup inside
    the **foreach** loop, with the **id** attribute set to correspond to the current
    ticket ID. In order to allow users to display ticket details by clicking anywhere
    on the container, next to the **id** attribute, we attached our **Show()** method
    to the **@onclick** event of the container. Now, whether users click on the **Show**
    button or anywhere inside the ticket container, Blazor will trigger the same action
    and render details of a given ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Now, here is the catch. Inside the ticket container, we have also nested the
    **Top Up** and **Remove** buttons – all reacting differently to the **@onclick**
    event. However, nested **@onclick** events within the same area would trigger
    simultaneously by default. In our example, when the user clicks on the **Top Up**
    button, they will both increase that ticket stock and render its details. With
    the **Remove** button, it gets even more confusing, as users can remove a ticket
    and display its details at the same time. That’s where we need the **stopPropagation**
    attribute. Attaching **stopPropagation** to a desired event, we instruct Blazor
    to prevent event propagation to the parent DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2* , we navigate to the **TicketOptions** markup, where we have all
    the administrative action buttons. Next to the **@onclick** attribute of each
    of the three buttons, we append the **@onclick:stopPropagation** attribute. That’s
    all it takes to ensure that users can safely increase the stock of the ticket
    or remove it entirely without experiencing unwanted rendering of the ticket details
    display.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the **stopPropagation** attribute is a powerful tool within Blazor applications
    for managing event flow, it’s essential to understand its scope and limitations.
    This attribute is specifically designed to work with Blazor events and does not
    directly influence the behavior of standard HTML events. HTML events must first
    be allowed to execute normally; only then can Blazor intercept these events and
    make decisions regarding event propagation from child components to their parents.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, we focused on controlling the **@onclick** event, but
    when dealing with complex interfaces where you need to control multiple events,
    **stopPropagation** must be explicit for each event.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when incorporating components from external libraries into your
    Blazor applications, you might encounter situations where direct control over
    event propagation is not straightforward. In such cases, a practical workaround
    is to wrap the external component within a neutral HTML element, for example,
    a **span** element. By applying **stopPropagation** to events on **span** , you
    effectively create a barrier for event propagation, with **span** acting as the
    nearest parent. This method allows you to manage event flow even in complex component
    hierarchies, ensuring intended behavior without unintended side effects from external
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we explore the possibility of enriching our Blazor application
    with custom events, diving into slightly more advanced territory where **JavaScript**
    interplays with Blazor. Alongside custom events, the concept of custom event arguments
    arises, allowing for the passage of tailored data that goes beyond the standard
    event payloads. Custom events and their corresponding arguments become invaluable
    when predefined events fall short, offering the flexibility to capture and respond
    to specific user actions or external system triggers with precision.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a component that overwrites the data that a user tries to copy
    from the area that this component protects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explore the implementation of custom events, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe06** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **TicketManager** and **TicketOptions** from the *Controlling event propagation*
    recipe or from the **Chapter03** / **Recipe05** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement custom logic for a copy event:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new JavaScript ( **.js** ) file to the application’s wwwroot directory.
    Adhere to the naming convention, **{ASSEMBLY NAME}.lib.module.js** . This file
    will contain the functions necessary for our custom events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript
    functions](img/Figure_3.1_B22020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript
    functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your newly created **.js** file, declare an **afterWebStarted()** function.
    Use the **registerCustomEventType** API to declare a new **preventcopy** event.
    Implement custom logic within this event to overwrite the current clipboard data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new **CustomEvents.cs** file that will serve as a central repository
    for all details related to custom events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **CustomEvents.cs** , add a class named **PreventedCopyEventArgs** that
    extends **EventArgs** . Include a **Stamp** property to persist when Blazor prevents
    the copy action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still within **CustomEvents.cs** , declare a **public** and **static** class
    named **EventHandlers** . Add a custom **EventHandler** attribute to this class
    and define an **onpreventcopy** event that returns **PreventedCopyEventArgs**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new **PreventCopy** component responsible for invoking the custom event
    logic you’ve defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **@code** section of the **PreventCopy** component, declare a required
    **ChildContent** parameter of type **RenderFragment** . Also, implement a **Log()**
    method to intercept and log the timestamp that **PreventedCopyEventArgs** carries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **PreventCopy** markup, construct a wrapping container, where you
    intercept the custom **@onpreventcopy** event and delegate it to the **Log()**
    method, while rendering **ChildContent** inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **TicketManager** markup, locate the area where we render the
    **SelectedTicket** details, and wrap it with the **PreventCopy** tags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We kick off the integration of a custom event by establishing a bridge between
    Blazor and JavaScript. In *step 1* , we add a **.js** file within the **wwwroot**
    directory, adhering to a specific naming convention ( **{ASSEMBLY NAME}.lib.module.js**
    or **{PACKAGE ID}.lib.module.js** ). This convention is crucial as Blazor automatically
    searches for these files to support custom events defined within the application.
    In *step 2* , we define an **afterWebStarted()** function, which takes a **blazor**
    argument (intentionally lowercase to differentiate from the globally available
    **Blazor** object) and which Blazor compilers expect. Using the **registerCustomEventType**
    API, we declare our **preventcopy** event, designed to intercept the browser’s
    **copy** event and overwrite clipboard data. While at it, we must also cancel
    the browser’s default copy behavior using the **preventDefault()** method. We
    return a timestamp marking the event trigger that we will utilize later.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning to Blazor in *step 3* , we introduce the **CustomEvents.cs** file
    to define our Blazor-side custom event handling. We implement the **PreventedCopyEventArgs**
    class in *step 4* , inheriting from **EventArgs** and reflecting our JavaScript
    function’s structure, including a **Stamp** property. In *step 5* , we register
    a Blazor custom event using the Razor compiler’s capabilities. Following the code
    generators convention, we declare **public static class EventHandlers** and leverage
    the **[EventHandler]** attribute to inform the Razor compiler of our custom **onpreventcopy**
    event. The Razor compiler will automatically align **onpreventcopy** with its
    JavaScript counterpart – **preventcopy** .
  prefs: []
  type: TYPE_NORMAL
- en: Next, in *step 6* , we add a **PreventCopy** component as a wrapper preventing
    copy operations within specified content. In *step 7* , in the **@code** block
    of **PreventCopy** , we declare a **ChildContent** parameter, where we can provide
    content to be protected and a primitive **Log()** method to log the timestamp
    of a prevented copy attempt. In *step 8* , we construct the **PreventCopy** markup.
    We add a container and intercept the **@onpreventcopy** event while also invoking
    the **Log()** method every time it’s triggered. Inside the container, we render
    the provided **ChildContent** markup. Now, Blazor will effectively prevent data
    leakage while maintaining an audit trail of any data copy attempts.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the **afterWebStarted()** function is crucial in integrating custom events
    within a **Blazor Web App** , it’s important to note that it’s designed specifically
    for this environment. When working outside the Blazor Web App context, an analogous
    approach is required but with a slight adjustment in the function naming. For
    plain server or WebAssembly projects, you must implement the **afterStarted()**
    function. This naming distinction allows us to clearly define when Blazor registers
    custom events and ensures clarity in the application’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Handling long-running events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we tackle a critical aspect of **single-page application** (
    **SPA** ) development – ensuring users are aware of operations occurring in the
    background. Unlike traditional web applications, SPAs do not naturally indicate
    when a process is executing behind the scenes. This lack of feedback can leave
    users staring at what appears to be a stale or unresponsive page, leading to frustration
    and confusion. It’s essential that you incorporate visual action indicators such
    as preloaders, loading spinners, or progress bars. These elements serve as visual
    cues that inform the user something is happening, enhancing the user experience
    by providing a sense of activity and progress. I will guide you through implementing
    these indicators in your SPA, ensuring that during long-running requests or operations,
    your users are kept in the loop, maintaining engagement and satisfaction with
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement two kinds of action indicators – a simple loading indicator
    and a primitive progress indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before starting the implementation of user-friendly status indicators, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a **Chapter03** / **Recipe07** directory – this will be your working
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy **TicketManager** , **TicketOptions** , **PreventCopy** , and **CustomEvents**
    from the *Introducing custom events* recipe or from the **Chapter03** / **Recipe07**
    directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build loading and progress indicators that improve the user experience of
    your app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **LoadingIndicator** component that will visually communicate to
    users when an operation is loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **@code** block of **LoadingIndicator** , declare a **Job** parameter
    – representing the task to display the loading state for, and a **ChildContent**
    parameter to allow passing the content to render when loading is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the parameter declaration, still within the **@code** block, initialize
    an **IsLoading** state variable and implement a **RunAsync()** method, which encapsulates
    the logic for managing the loading state while executing the **Job** delegate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **LoadingIndicator** markup, add a button for users to initiate the
    loading process by attaching the **RunAsync()** method to the button’s **@onclick**
    event and conditionally disabling it while loading is in progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the loading button, construct two areas – for when the loading is in
    progress and when it completes, based on the value of the **IsLoading** state
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create another component – **ProgressIndicator** – that will visually communicate
    to users the progress of the operation they request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the **@code** block of **ProgressIndicator** , declare two required
    parameters: a **Job** parameter – representing an abstract operation the progress
    indicator should monitor, and a **Total** parameter – to provide the number of
    elements the operation should run for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Below the parameter declaration, initialize a **Progress** state variable to
    reflect the operation’s progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still within the **@code** block, implement an expression-bodied **Label**
    property, where based on the **Progress** value, you construct a label for the
    action button (which we will add shortly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete the **@code** block by implementing a **RunAsync()** method to loop
    through the total amount of elements and execute the job for each index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **ProgressIndicator** markup, construct a button for users to invoke
    the processing through the **RunAsync()** method. Check the current value of the
    **Progress** variable to conditionally disable the action button and leverage
    the **Label** property to generate the button label dynamically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the **TicketManager** component, to its **@code** block, and implement
    a simple **SaveAsync()** method, leveraging **Tickets.SaveAsync()** provided with
    data samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **TicketManager** markup, below the render mode declaration, embed **ProgressIndicator**
    with **SaveAsync()** and **Tickets.All.Count** attached to the **Job** and **Total**
    parameters respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Still in the **TicketManager** markup, remove the button allowing to toggle
    tickets and the **ShowTickets** check.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in the **TicketManager** markup, find the **foreach** loop, where you
    render each ticket container, and wrap it inside the **LoadingIndicator** component.
    Attach the **Tickets.GetAsync()** method to the **Job** parameter that **LoadingIndicator**
    requires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *step 1* , we create a new **LoadingIndicator** component. In *step 2* ,
    we initialize the **@code** block of the **LoadingIndicator** component and declare
    two key parameters: **Func<Task> Job** to reference the asynchronous operation
    we intend to monitor, and **ChildContent** to allow passing the content to display
    when loading completes. Both parameters are designed to be operation-agnostic,
    making the component versatile and adaptable to various use cases. In *step 3*
    , we initialize an **IsLoading** state variable and implement the core functionality
    in the **RunAsync()** method. **RunAsync()** updates the **IsLoading** value to
    reflect the operation’s start, executes the declared **Job** delegate, and then
    resets **IsLoading** upon completion, seamlessly transitioning to display **ChildContent**
    . Notice that we’ve invoked the **StateHasChanged()** lifecycle method, before
    starting the **Job** operation. With that implementation, the moment Blazor reaches
    an asynchronous operation, and frees up the UI thread, it will re-render the component
    markup, reflecting the state changes based on the **IsLoading** value. In *step
    4* , we build the **LoadingIndicator** markup. First, we construct an action button
    for initiating the load process with the help of **RunAsync()** . We also attach
    the **disabled** button’s attribute to the value of the **IsLoading** state variable.
    Now, whenever loading is in progress, Blazor will disable the action button, effectively
    preventing users from requeuing the already running operation. In *step 5* , we
    add the visual loading indicator. During operation execution, we render a simple
    **Loading...** message, which you can enhance with CSS for a modern look, such
    as incorporating a spinner. When loading completes, we render the markup provided
    with the **ChildContent** parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 6* , we create a component with a different type of indicator – **ProgressIndicator**
    . In *step 7* , we initialize the **@code** block and define a **Job** parameter
    – allowing us to define an operation to run – and a **Total** parameter – representing
    the number of iterations the operation must go through. The **Job** signature
    effectively abstracts any asynchronous operation but also ensures that the operation
    accepts an **int** parameter, representing the index of the current execution
    iteration. In *step 8* , we initialize a **Progress** variable that we’ll use
    to monitor the actual execution progress from 0% to 100%. In *step 9* , we implement
    a **Label** property. With simple logic, based on the current **Progress** value,
    we generate either a **Process** call to action or actual processing progress.
    In *step 10* , we complete the **@code** block by implementing the core **RunAsync()**
    method. In **RunAsync()** , we loop from **0** to **Total** and invoke the **Job**
    delegate for each index while continuously updating the **Progress** value. When
    the processing is done, we reset the **Progress** value to a neutral **0** . In
    *step 11* , we build the **ProgressIndicator** markup. We construct a button allowing
    us to start the processing by triggering **RunAsync()** on the **@onclick** event.
    We also prevent the requeuing of the running operation by disabling the action
    button based on the **Progress** value, similar to the action button in the **LoadingIndicator**
    component. Lastly, to provide real-time progress feedback, we leverage the **Label**
    property to render the text on the button. Now, when the operation is running,
    Blazor will not only disable the button but also render the current progress on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 12* , we navigate to the **@code** block of the **TicketManager** component
    and implement a **SaveAsync()** method. The **SaveAsync()** method is just a proxy
    method that allows intercepting the current iteration index, finding the related
    ticket object in the **Tickets.All** collection, and passing it over for saving.
    In *step 13* , we jump to the **TicketManager** markup and, at the very top, we
    embed **ProgressIndicator** . Having the **SaveAsync()** method in place, we can
    attach it to the **ProgressIndicator** component required **Job** parameter. For
    the other required parameter – **Total** – we count the number of objects in the
    **Tickets.All** collection. With that setup, **ProgressIndicator** allows users
    to trigger the saving of each ticket and see the operation progress as it’s running.
    In *step 14* , we remove the button allowing to toggle tickets and the related
    **ShowTickets** check. We will no longer need them, as we will delegate the control
    over displaying the **Tickets.All** collection to **LoadingIndicator** . In *step
    15* , we locate the loop in which we render ticket containers. We wrap that entire
    area inside the **LoadingIndicator** component. As **LoadingIndicator** requires
    a **Job** delegate, we leverage a lambda expression and attach the **Tickets.GetAsync()**
    method. Now, when users request to load data, **LoadingIndicator** renders the
    **Loading…** message and triggers **Tickets.GetAsync()** seamlessly. When loading
    completes, the **LoadingIndicator** component updates the UI with a fresh set
    of ticket containers.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have already realized which scenarios the loading and progress indicators
    fit but let me give you a simple rule of thumb.
  prefs: []
  type: TYPE_NORMAL
- en: Any loading indicators are ideally suited for operations with unpredictable
    completion times, such as fetching data from an API, where the number of results
    and their arrival time are unknown.
  prefs: []
  type: TYPE_NORMAL
- en: Progress indicators, such as a progress bar, are ideal for operations with known
    results, such as submitting data changes or sending notifications.
  prefs: []
  type: TYPE_NORMAL
