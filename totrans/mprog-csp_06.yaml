- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Dynamic Proxy Generation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态代理生成
- en: In the previous chapters, we looked at how powerful it is to have the type of
    metadata that the .NET runtime provides us with, combining that with the power
    of creating your own metadata, the capability to analyze it, and turn it into
    useful information or take actions based on it. We’re now going to explore even
    further and let code make new code based on metadata.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们探讨了拥有.NET运行时提供的强大元数据类型是多么强大，结合创建自己的元数据、分析它的能力，以及将其转换为有用的信息或根据它采取行动的能力。现在，我们将进一步探索，让代码根据元数据生成新的代码。
- en: In this chapter, we will look into how we can take advantage of the fact that
    your code runs in a managed runtime environment and how that can be used to create
    new code at runtime after your code has been compiled.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何利用你的代码在托管运行时环境中运行的事实，以及如何在你代码编译后创建新的代码。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: An introduction to IL and Reflection.Emit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IL和Reflection.Emit简介
- en: Creating a dynamic assembly and module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态程序集和模块
- en: Virtual members and overrides
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟成员和重写
- en: Implementing an interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Upon completion of this chapter, you should understand the power of the .NET
    runtime and how you can turn metadata into new code to make you more productive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该理解.NET运行时的强大功能以及如何将元数据转换为新的代码，从而提高你的工作效率。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code specific to the chapter can be found on GitHub ([https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的特定源代码可以在GitHub上找到（[https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter6)）。
- en: An introduction to IL and Reflection.Emit
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IL和Reflection.Emit简介
- en: In [*Chapter 2*](B19418_02.xhtml#_idTextAnchor026), *Metaprogramming Concepts*,
    we touched on what the C# compiler turns your code into. **IL**, short for **Intermediate
    Language**, is a representation of instructions the .NET runtime understands and
    translates to CPU instructions for the target CPU your code is running on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B19418_02.xhtml#_idTextAnchor026)，*元编程概念*中，我们提到了C#编译器将你的代码转换成什么。**IL**，即**中间语言**，是.NET运行时理解的指令表示，并将其转换为针对你的代码运行的CPU的CPU指令。
- en: Since the .NET runtime operates dynamically on your code in this manner, it
    means that it is not a too far a jump to conclude that you should be able to generate
    code as your program executes. And luckily, that is the case. The .NET APIs include
    a whole namespace dedicated to generating code – **System.Reflection.Emit**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于.NET运行时以这种方式动态地在你代码上运行，这意味着可以得出结论，你应该能够在程序执行时生成代码。幸运的是，情况确实如此。.NET API包括一个专门用于生成代码的命名空间——**System.Reflection.Emit**。
- en: With the **Emit** APIs, you can go and create any constructs you want from scratch,
    introduce new types that do not exist in any source code, or create new types
    that inherit from other types and add new capabilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Emit** API，你可以从头开始创建任何你想要的构造，引入不存在于任何源代码中的新类型，或者创建从其他类型继承并添加新功能的新类型。
- en: For all the different types of artifacts, you can create class, method, properties,
    and more. There are specific builder types – **TypeBuilder** for classes and **MethodBuilder**
    for methods. Properties are also considered methods and are based on a convention
    of a prefix having the name of **get_** or **set_**, which then represents a **get**
    or **set** method respectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有不同类型的工件，你可以创建类、方法、属性等。存在特定的构建器类型——**TypeBuilder**用于类和**MethodBuilder**用于方法。属性也被视为方法，并且基于一个前缀具有**get_**或**set_**名称的约定，分别代表**get**或**set**方法。
- en: With a builder, you can call a method called **.GetILGenerator()**. This method
    will then return a type called **ILGenerator**. The **ILGenerator** method is
    where all the magic happens. This is the type you can use to generate the actual
    code. The primary method you use is the **.Emit()** method. The **.Emit()** method
    has several overloads to it and is the method used to add instructions that constitute
    your program. Instructions are referred to as an **op-code**, and there is a class
    with all the allowed instructions, or op-codes, called **OpCodes**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建器，你可以调用一个名为**.GetILGenerator()**的方法。这个方法将返回一个名为**ILGenerator**的类型。**ILGenerator**方法就是所有魔法发生的地方。这是你可以用来生成实际代码的类型。你主要使用的方法是**.Emit()**方法。**.Emit()**方法有几个重载，是用于添加构成你程序的指令的方法。指令被称为**操作码**，有一个包含所有允许指令或操作码的类，称为**OpCodes**。
- en: All the different op-codes are well defined and well documented, and you can
    find the documentation for all of them on Microsoft’s documentation pages ([https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不同的操作码都定义良好且文档齐全，你可以在微软的文档页面上找到所有这些文档的链接([https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields](https://learn.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=net-7.0#fields))。
- en: Even though they’re well defined and well documented, the preparation involved
    to get the right instructions in the right order can be hard and daunting. Therefore,
    it’s a good idea to derive the instructions from real code instead. A great resource
    for doing so is to use something such as **Sharplab** ([https://sharplab.io](https://sharplab.io)).
    With Sharplab, you can take regular C# code and see the instructions needed to
    be able to reproduce it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们定义良好且文档齐全，但要正确地准备指令顺序可能会很困难且令人畏惧。因此，从实际代码中推导指令是一个好主意。这样做的一个很好的资源是使用像**Sharplab**([https://sharplab.io](https://sharplab.io))这样的工具。使用Sharplab，你可以查看执行常规C#代码所需的指令，以便能够重现它。
- en: In order to get to the point of actually generating IL code, you need to jump
    through a couple more hoops.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到生成IL代码的实际阶段，你需要跳过几个额外的步骤。
- en: Creating a dynamic assembly and module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动态组件和模块
- en: When your code has gone through the compiler and been outputted to a binary
    that runs. That code is considered static and cannot be modified. The binary represented
    as an assembly is completely static; not only can you not modify code in it but
    you also cannot add to it either. It would be a security risk if arbitrary code
    could go and modify running code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码经过编译并输出为可运行的二进制文件时。这段代码被认为是静态的，不能被修改。表示为组件的二进制文件是完全静态的；你不仅不能修改其中的代码，而且也不能向其中添加内容。如果任意代码可以修改运行中的代码，这将是一个安全风险。
- en: To overcome this, you have to explicitly create a new assembly on the fly that
    only exists in memory. This is known as a **dynamic assembly**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，你必须显式地创建一个新的组件，它只存在于内存中。这被称为**动态组件**。
- en: All assemblies have also the concept of modules. An assembly must have at least
    one module. A module is a container that holds the concrete IL code and only metadata
    related to it, while an assembly is a higher-order abstract container that contains
    more metadata and could, in fact, refer to multiple **.dll** files. Generally,
    you’ll only see a one-to-one relationship between an **assembly** and a **module**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件也都有模块的概念。一个组件至少必须有一个模块。模块是一个容器，它包含具体的IL代码及其相关的元数据，而组件是一个更高层次的抽象容器，包含更多的元数据，实际上可以引用多个**.dll**文件。通常，你只会看到组件和模块之间的一对一关系。
- en: 'It is very easy to get started with this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这个过程非常简单：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code defines the two containers you need – first, the **.DefineDynamicAssembly()**
    method creates the dynamic assembly, and you tell it to give you an assembly that
    you will use to run code from. Once you have the dynamic assembly, you call **.DefineDynamicModule()**
    to get the container where you’ll generate the actual code that will run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了所需的两个容器——首先，**.DefineDynamicAssembly()**方法创建动态组件，并告诉它提供一个你将用于运行代码的组件。一旦你有了动态组件，你调用**.DefineDynamicModule()**来获取你将生成实际运行代码的容器。
- en: One thing you should take into consideration is the name of both the dynamic
    assembly and dynamic module. Assembly names need to be unique within a running
    process, and within an assembly, every module needs a unique name as well. So,
    if you’re going to create multiple dynamic assemblies and multiple modules within
    them, you need to guarantee unique names.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑的一件事是动态程序集和动态模块的名称。程序集名称需要在运行过程中是唯一的，并且在程序集内部，每个模块也需要一个唯一的名称。因此，如果你打算创建多个动态程序集以及它们内部的多个模块，你需要保证名称的唯一性。
- en: 'The simplest way to do that is to leverage **Guid** and mix it into your name.
    The following code will give a unique name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是利用**Guid**并将其混合到你的名字中。以下代码将给出一个唯一的名称：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code generates a new **Guid** and combines it with a prefix. The purpose
    of the prefix is to be able to recognize the different assemblies with a friendly
    name. There are some limitations to what characters can be used in an assembly
    name; that’s why you see that **-** is replaced with **_**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成一个新的**Guid**并将其与一个前缀组合。前缀的目的是能够识别具有友好名称的不同程序集。在程序集名称中可以使用的字符有一些限制；这就是为什么你会看到**-**被替换为**_**。
- en: If your code only needs one dynamic assembly and a dynamic module within it,
    the need to create a unique name might not be needed, as you can quite easily
    just give it a unique name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码只需要一个动态程序集以及它内部的动态模块，那么创建唯一名称的需求可能不是必需的，因为你可以相当容易地给它一个唯一的名称。
- en: You might not even need to have multiple dynamic assemblies and, most likely,
    not even multiple modules within the dynamic assembly. It is perfectly fine to
    have one global dynamic assembly. It all depends on your code and whether or not
    you’ll be generating types with the same name for different purposes that should
    then be grouped into specific assembly/module pair containers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能甚至不需要有多个动态程序集，以及很可能不需要在动态程序集内部有多个模块。拥有一个全局动态程序集是完全可行的。这完全取决于你的代码以及你是否会为不同的目的生成具有相同名称的类型，这些类型应该被分组到特定的程序集/模块对容器中。
- en: With a dynamic assembly and a dynamic module in place, we can start generating
    some code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了动态程序集和动态模块之后，我们可以开始生成一些代码。
- en: 'Let’s dynamically create a simple type without its source code that can print
    out a message. The target type we’re aiming for would look something like the
    following if we wrote it in C#:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动态创建一个没有源代码的简单类型，它可以打印出一条消息。如果我们用C#编写，目标类型看起来可能如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we put this into Sharplab ([https://sharplab.io](https://sharplab.io)),
    we can see the IL code that is behind it and use it as the template for what we’re
    trying to achieve:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此代码放入Sharplab（[https://sharplab.io](https://sharplab.io)），我们可以看到其背后的IL代码，并将其作为我们想要实现的模板：
- en: '![](img/B19418_06_1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19418_06_1.jpg)'
- en: Figure 6.1 – IL code
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – IL代码
- en: 'Start by creating a folder called **Chapter6**. Open this folder in your command-line
    interface and create a new console project:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为**Chapter6**的文件夹。在命令行界面中打开此文件夹，并创建一个新的控制台项目：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add a file called **MyTypeGenerator.cs**. Start by making the file look like
    the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为**MyTypeGenerator.cs**的文件。首先让文件看起来像以下这样：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we have pulled in two namespaces – **System.Reflection** and
    **System.Reflection.Emit**. These hold the APIs we will be needing.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们引入了两个命名空间——**System.Reflection**和**System.Reflection.Emit**。这些包含了我们将需要的API。
- en: 'The first thing we want to do is create the assembly and module, and add the
    following to the **Generate** method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的第一件事是创建程序集和模块，并将以下内容添加到**Generate**方法中：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the module, we can create a new type, and within the type, a method. Then,
    we append the following to the **Generate** method after the module has been defined:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从模块中，我们可以创建一个新的类型，并在类型内部创建一个方法。然后，在定义了模块之后，我们将以下内容追加到**Generate**方法中：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code creates a public class called **MyType** and then defines a public
    method called **SaySomething**. In the method, we then set that it has parameters.
    The method accepts **param** that allows us to define one or more parameter types.
    The last thing we do is define the parameter. This is done by giving it the parameter
    index it has and a name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个名为**MyType**的公共类，然后定义了一个名为**SaySomething**的公共方法。在方法中，我们设置它有参数。该方法接受**param**，这允许我们定义一个或多个参数类型。我们最后要做的是定义参数。这是通过给它参数索引和名称来完成的。
- en: Important note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The **ParameterAttributes** value you give the parameter indicates that there
    is nothing special with it; it is a regular parameter. If you wanted it to be
    an **out** or **ref** parameter, you would tell it that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你赋予参数的**ParameterAttributes**值表示它没有任何特殊之处；它是一个常规参数。如果你想让它成为一个**out**或**ref**参数，你需要这样告诉它。
- en: You now have the definition in place of the method with the expected signature.
    It is now time for you to fill in the actual code.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经有了具有预期签名的方法的定义。现在是时候填写实际的代码了。
- en: The code for this method is very simple, as we’re just taking the parameter
    coming in and passing it to another method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的代码非常简单，因为我们只是将传入的参数传递给另一个方法。
- en: 'With the method definition in place, you can start building out the code. Append
    the following code to the **Generate** method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义就绪后，你可以开始构建代码。将以下代码追加到**生成**方法中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code starts off by getting the **System.Console** type and the method called
    **WriteLine**, which accepts a simple **string**. The method is what you are going
    to use to call and forward the incoming parameter that will eventually produce
    the message in the console. Once you have the **WriteLine** method, you need **ILGenerator**
    for the **SaySomething** method you’re building. Then, the first thing you do
    is to emit an instruction to load the actual argument given to the parameter into
    what is known as the **evaluation stack**. **OpCodes.Ldarg_1** refers to 1, which
    might seem counterintuitive. In the context of an instance type, **OpCodes.Ldarg_0**
    would represent the value of **this**. With the argument loaded onto the stack,
    you emit code that calls the **WriteLine** method on **Console**, giving it the
    type of parameter to use. Finishing off your method, you emit a return instruction
    from the method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先获取**System.Console**类型和名为**WriteLine**的方法，该方法接受一个简单的**string**。这个方法是你将要用来调用和转发最终在控制台产生消息的参数的方法。一旦你有了**WriteLine**方法，你需要为构建的**SaySomething**方法获取**ILGenerator**。然后，你做的第一件事是发出一个指令将实际传递给参数的参数加载到所谓的**评估堆栈**中。**OpCodes.Ldarg_1**指的是1，这可能会显得有些反直觉。在实例类型的上下文中，**OpCodes.Ldarg_0**将代表**this**的值。参数加载到堆栈上后，你发出调用**Console**上的**WriteLine**方法的代码，给它传递参数的类型。完成你的方法后，你发出一个从方法返回的指令。
- en: 'The last piece of the **Generate** method is building out the actual **Type**
    and returning it. Append the following to the **Generate** method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成**方法的最后一部分是构建实际的**类型**并将其返回。将以下内容追加到**生成**方法中：'
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The full listing of the **MyTypeGenerator** class should now look like the
    following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**MyTypeGenerator**类的完整列表现在应该如下所示：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With your first code generator in place, you want to take it out for a spin.
    Since this is a type that is completely unknown to the compiler, there is really
    no way to write standard C# code that can call it. You will have to revert to
    reflection to do so.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一个代码生成器就绪后，你想要试运行它。由于这是一个对编译器完全未知的类型，实际上没有方法可以编写标准的C#代码来调用它。你将不得不回到反射来做这件事。
- en: 'In the **Program.cs** file of the **Chapter6** project, replace the existing
    code with the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter6**项目的**Program.cs**文件中，将现有代码替换为以下内容：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code calls into your new generator to get the generated **Type**. Next,
    it asks the generated type to get the method called **SaySomething**. You then
    go and create an instance of the type by using the **Activator** type in .NET.
    From the method, you can then invoke it and give the instance as the first parameter,
    and then add in the parameter it is expecting in the array that follows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码调用你的新生成器以获取生成的**类型**。接下来，它要求生成的类型调用名为**SaySomething**的方法。然后，你使用.NET中的**Activator**类型创建该类型的实例。从该方法中，你可以调用它并将实例作为第一个参数传递，然后添加它期望的数组中的参数。
- en: 'Running this using **dotnet run** or, if you prefer, your IDE, you should get
    a simple message:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**dotnet run**或，如果你更喜欢，你的IDE运行此代码，你应该得到一条简单的消息：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The intermediate language and how the runtime actually works with instructions
    is logical, but it might not be intuitive compared to writing C#. However, it
    gives you great powers and enables new scenarios.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 中间语言以及运行时如何与指令交互是逻辑的，但与编写C#相比可能不太直观。然而，它赋予你巨大的力量并使新的场景成为可能。
- en: Virtual members and overrides
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟成员和重写
- en: From my own experience, generating new types from scratch that didn’t exist
    at compile time is not the most common use case. I’ve found myself, more often
    than not, just wanting to automate something that I find tedious and forced upon
    me from libraries that I have to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，从头开始生成在编译时不存在的新类型并不是最常见的用例。我发现自己，大多数情况下，只是想自动化一些我觉得繁琐且被迫从必须使用的库中执行的任务。
- en: When that is the case, it is common to take a type and create a new one that
    inherits from this and then starts overriding behavior.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常的做法是取一个类型，创建一个新的类型，使其继承自该类型，然后开始重写行为。
- en: Since C# doesn’t have all its members as virtual, as the case is with Java,
    members have to be explicitly virtual. An example of a method that is virtual
    is one that all objects inherit – the **ToString** method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#不像Java那样所有成员都是虚拟的，因此成员必须显式声明为虚拟。一个虚拟方法的例子是所有对象都会继承的方法——**ToString**方法。
- en: 'Let’s continue the work on the **MyTypeGenerator** code by adding an override
    of the **ToString** method, just to see the mechanics of how it is done:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续对**MyTypeGenerator**代码的工作，通过添加对**ToString**方法的重写来了解它是如何实现的：
- en: 'In the **Generate** method of the **MyTypeGenerator** class, before you return
    the type, you need to define a new method that will be the **MyType** implementation
    of the **ToString** method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**MyTypeGenerator**类的**Generate**方法中，在你返回类型之前，你需要定义一个新的方法，它将是**MyType**的**ToString**方法实现：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, the code gets a reference to the method it wants to override from the
    base class. Since this type doesn’t have a specific base type, it will implicitly
    just be **object**. Then, you start defining the new **ToString** method and specify
    that it will return a **string** type. Since the **ToString** method doesn’t take
    any parameters, you just pass it an empty array of **Type**. From the method definition,
    you go and do as before – get **ILGenerator**. You then simply load the string
    into the evaluation stack, which will be the only thing there, and return from
    the method. To make it an override method, you then call **.DefineMethodOverride()**
    on the type builder to tell it which method you’re overriding and give it the
    original **ToString** method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码从基类获取它想要重写的方法的引用。由于此类型没有特定的基类型，它将隐式地成为**object**。然后，你开始定义新的**ToString**方法，并指定它将返回**string**类型。由于**ToString**方法不接受任何参数，你只需传递一个空的**Type**数组。从方法定义中，你像之前一样获取**ILGenerator**。然后，你只需将字符串加载到评估堆栈中，这将是唯一的东西，并从方法返回。为了使其成为重写方法，你随后在类型构建器上调用**.DefineMethodOverride()**来告诉它你要重写哪个方法，并给出原始的**ToString**方法。
- en: 'Open the **Program.cs** file and add a line of code that will invoke the **ToString**
    method to see that it works:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Program.cs**文件，添加一行代码来调用**ToString**方法，以验证其是否正常工作：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running the program should then print out the message:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序应该会打印出以下消息：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With what you’ve learned thus far in this chapter, you should now have the basic
    building blocks to create types with members on them and also override virtual
    members from inherited base types. All of these things will get you pretty far.
    Now that we’ve looked at the mechanics of how to generate code, let’s make a more
    concrete example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了创建具有成员的类型以及从继承的基类型重写虚拟成员的基本构建块。所有这些都会让你走得很远。现在我们已经了解了生成代码的机制，让我们举一个更具体的例子。
- en: Implementing an interface
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: In addition to overriding virtual members from a base type, there is often the
    need to implement interfaces that satisfy a need for a third-party library you
    are using. The implementation of the interface might not be important to your
    own code, but it is something that is forced on you to enable certain behaviors.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从基类型重写虚拟成员之外，通常还需要实现接口，以满足使用第三方库的需求。接口的实现可能对你的代码并不重要，但它是一种被迫执行的任务，以启用某些行为。
- en: Anyone who has been doing any XAML-flavored development will have come across
    an interface called **INotifyPropertyChanged**. The **INotifyPropertyChanged**
    interface is something that the data binding engine recognizes and will automatically
    use if a type implements it. Its purpose is to notify anyone using your object
    when a property changes. This is very useful when you have a UI element automatically
    reflecting changes being done in the data behind the scenes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进行过任何XAML风格开发的人都会遇到一个名为**INotifyPropertyChanged**的接口。**INotifyPropertyChanged**接口是数据绑定引擎能够识别并自动使用的一个接口，如果一个类型实现了它。它的目的是在属性发生变化时通知使用你对象的任何人。当你有一个UI元素自动反映后台数据的变化时，这非常有用。
- en: 'The **INotifyPropertyChanged** interface itself is very simple and looks like
    this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**INotifyPropertyChanged**接口本身非常简单，看起来如下：'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For an object implementing **INotifyPropertyChanged**, it means it needs to
    implement the logic for every property when its value is set. This can be very
    tedious and will bloat your code base with code that is not part of your domain.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现**INotifyPropertyChanged**的对象，这意味着它需要在值设置时为每个属性实现逻辑。这可能会非常繁琐，并且会使你的代码库膨胀，包含不属于你领域代码。
- en: 'Let’s say you have an object representing a person:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个代表人的对象：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the **INotifyPropertyChanged** requirement for binding purposes, the object
    would, for just one of the properties, need to explode into the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绑定目的需要**INotifyPropertyChanged**，对象只需对其中一个属性进行以下操作：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the code goes from simple one-liners per property to something
    that explicitly has a getter, setter, and private field to hold the actual value.
    In the setter, you have to then raise the **PropertyChanged** event, and a typical
    pattern is to have a convenience method that is reused for all properties to do
    that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码从每个属性的简单单行语句变成了具有显式getter、setter和私有字段来保存实际值的结构。在setter中，你必须引发**PropertyChanged**事件，并且一个典型的模式是有一个方便的方法，用于所有属性的重用。
- en: Thanks to code generation, you can make it all go away and get your code back
    to being readable and more maintainable, making you more productive in the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了代码生成，你可以让这一切都消失，让你的代码回到可读性和可维护性更高的状态，从而在过程中提高你的生产力。
- en: 'In the **Chapter6** folder, go and create a new file called **Person.cs** and
    make it look like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Chapter6**文件夹中，创建一个名为**Person.cs**的新文件，并使其看起来如下：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The **Person** class now represents the target version without any of the **INotifyPropertyChanged**
    things. At compile-time, it does not implement the **INotifyPropertyChanged**
    interface, but we will make it do so at runtime.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**Person**类代表的目标版本不包含任何**INotifyPropertyChanged**相关的内容。在编译时，它没有实现**INotifyPropertyChanged**接口，但我们将使其在运行时实现。
- en: Since we’ve made the properties **virtual**, we can create a new type that inherits
    from the **Person** type and overrides the properties to do what we want.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使属性**virtual**，我们可以创建一个新的类型，它从**Person**类型继承并覆盖属性以实现我们想要的功能。
- en: NotifyObjectWeaver class
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NotifyObjectWeaver类
- en: 'To be able to do what we want, we need to do the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够做到我们想要的事情，我们需要做以下事情：
- en: Create a new type.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类型。
- en: Inherit from the existing type.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现有类型继承。
- en: Implement the **INotifyPropertyChanged** interface.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口**INotifyPropertyChanged**。
- en: Add a method that handles the logic for when a property is changed.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个处理属性变化逻辑的方法。
- en: Override any virtual methods and implement the code needed for notification
    when properties change.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖任何虚拟方法并实现属性变化时所需的代码。
- en: In addition to this, it is also common to have properties that are dependent
    on other properties – for instance, to compose multiple properties together. These
    should also notify you of their change, so you want something to handle that as
    well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，也常见到一些属性依赖于其他属性——例如，将多个属性组合在一起。这些属性也应该通知你它们的变化，因此你希望有一种机制来处理这一点。
- en: 'Start by adding a file called **NotifyObjectWeaver.cs** in the **Chapter6**
    project. Then, add the following to the file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**Chapter6**项目中添加一个名为**NotifyObjectWeaver.cs**的文件。然后，向文件中添加以下内容：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code adds the common constants and statics you’ll be using in the code generation,
    ensuring that you do not have to repeat them throughout and that they gather at
    the top for better structure.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了在代码生成过程中将使用的常见常量和静态变量，确保你不需要在代码中重复它们，并且它们聚集在顶部以获得更好的结构。
- en: With this, you now have the start of the **NotifyObjectWeaver** class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你现在有了**NotifyObjectWeaver**类的起点。
- en: Creating the type
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建类型
- en: 'The first thing you’re going to start with is the code to define the type.
    It is pretty much what you’ve done before, only that we are now going to make
    your dynamically created type inherit from a base type and also implement an interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要开始编写的是定义类型的代码。这基本上是你之前所做过的，只是我们现在将使你动态创建的类型继承自基类型，并实现一个接口：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The call to **.SetParent()** is the key to the inheritance. It instructs the
    builder to take the **Type** input given to the method as the parent. The next
    thing you do is to instruct the builder that you will be implementing the **INotifyPropertyChanged**
    interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 **.SetParent()** 是继承的关键。它指示构建器将方法提供的 **Type** 输入作为父类。接下来，你需要指示构建器你将实现 **INotifyPropertyChanged**
    接口。
- en: Implementing the INotifyPropertyChanged interface
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 **INotifyPropertyChanged** 接口
- en: The **INotifyPropertyChanged** interface only has one field on it, the **PropertyChanged**
    event field that we need to implement. We need to add code that defines the event
    and also implements the logic to add and remove event handlers from the event.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**INotifyPropertyChanged** 接口上只有一个字段，即我们需要实现的 **PropertyChanged** 事件字段。我们需要添加代码来定义事件，并实现添加和从事件中移除事件处理器的逻辑。'
- en: 'In the **NotifyObjectWeaver** class, add the following method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **NotifyObjectWeaver** 类中添加以下方法：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The **DefineEvent** method defines the actual event on the type and then calls
    two methods to define the **add** and **remove** methods for the event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**DefineEvent** 方法在类型上定义实际的事件，然后调用两个方法来定义事件的 **add** 和 **remove** 方法。'
- en: 'Add the following method to the **NotifyObjectWeaver** class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 **NotifyObjectWeaver** 类中：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code adds a method that by convention will be used when event handlers are
    added, **add_PropertyChanged**. It uses the **Delegate** type that you added at
    the beginning of the class to get the **Combine** method that will be called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码添加了一个方法，按照惯例，当添加事件处理器时将使用此方法，**add_PropertyChanged**。它使用在类开头添加的 **Delegate**
    类型来获取将被调用的 **Combine** 方法。
- en: It then generates the needed IL code that adds the incoming callback to be called
    when a change happens, by calling the retrieved **Combine** method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它生成所需的 IL 代码，通过调用检索到的 **Combine** 方法，将传入的回调添加到在发生更改时将被调用的回调中。
- en: 'You should also, for good measure, add the opposite – the method that will
    remove a callback that has been added. Add the following method to the **NotifyObjectWeaver**
    class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保险起见，你还应该添加相反的方法——即移除已添加的回调的方法。将以下方法添加到 **NotifyObjectWeaver** 类中：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The implementation of **remove** is pretty much the same as for **add**, with
    the difference of getting the **Remove** method from the **Delegate** type and
    calling **.SetRemoveOnMethod()**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**remove** 的实现与 **add** 几乎相同，区别在于从 **Delegate** 类型获取 **Remove** 方法并调用 **.SetRemoveOnMethod()**。'
- en: The OnPropertyChanged method
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OnPropertyChanged** 方法'
- en: With the event logic in place, you now need a private method that all properties
    will call – an **OnPropertyChanged** method that will be doing all the heavy lifting.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件逻辑就绪后，你现在需要一个私有方法，所有属性都将调用它——一个将执行所有繁重工作的 **OnPropertyChanged** 方法。
- en: 'Start by adding the following method in the **NotifyObjectWeaver** class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在 **NotifyObjectWeaver** 类中添加以下方法：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code defines the **OnPropertyChanged** method with a signature that takes
    **string**, with the name of the property that changed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了带有 **string** 签名的 **OnPropertyChanged** 方法，其中包含已更改属性的名称。
- en: 'Then, add the following at the end of **DefineOnPropertyChangedMethod** to
    declare a local variable that holds the type of event args the code will create:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 **DefineOnPropertyChangedMethod** 的末尾添加以下内容，以声明一个用于存储代码将创建的事件参数类型的局部变量：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, you need code that checks whether the **PropertyChanged** event field is
    null or not and has the **propertyChangedNullLabel** label that the code can jump
    to if the value is null.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要代码来检查 **PropertyChanged** 事件字段是否为空，并具有代码可以跳转到的 **propertyChangedNullLabel**
    标签，如果值为空。
- en: 'Add the following code at the end of the **DefineOnPropertyChangedMethod**
    method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **DefineOnPropertyChangedMethod** 方法的末尾添加以下代码：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you need to add code that creates the **PropertyChangedEventArgs** instance
    with the argument that was passed into the **OnPropertyChanged** method. Then,
    call the **invoke** method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要添加代码来创建带有传递给 **OnPropertyChanged** 方法的参数的 **PropertyChangedEventArgs**
    实例。然后，调用 **invoke** 方法：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last piece of the puzzle is to mark the label that the null check will
    jump to if it is null, and then return from the method. Add the following to the
    end of the **DefineOnPropertyChangedMethod** method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是标记如果为空，null检查将跳转到的标签，然后从方法中返回。在 **DefineOnPropertyChangedMethod** 方法的末尾添加以下内容：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code to define the **OnPropertyChanged** method is now done. Now, you need
    to define the properties.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 **OnPropertyChanged** 方法的代码现在已完成。现在，你需要定义属性。
- en: The overriding properties
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖属性
- en: 'One of the requirements we had at the beginning was that we wanted to be able
    to notify other properties to make composites or, if it’s relevant, for another
    property to re-evaluate:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始的一个要求是，我们希望能够通知其他属性以创建复合体，或者如果相关的话，让另一个属性重新评估：
- en: 'Add a file called **NotifyChangedForAttribute.cs** and make it look like the
    following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 **NotifyChangedForAttribute.cs** 的文件，并使其看起来如下：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This custom attribute takes a **param** array of property names that will be
    called for a change, in addition to the property that changed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此自定义属性接受一个 **param** 数组，其中包含将因更改而调用的属性名称，以及更改的属性。
- en: 'For convenience, you should add a method to get the properties to notify, based
    on **PropertyInfo** for the property. In the **NotifyingObjectWeaver** class,
    add the following method:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便起见，你应该添加一个方法来获取通知的属性，基于 **PropertyInfo** 对属性进行操作。在 **NotifyingObjectWeaver**
    类中添加以下方法：
- en: '[PRE30]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code combines the name of the property, looks for the **NotifyChangesForAttribute**
    attribute, and adds the declared names.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 代码结合属性名称，查找 **NotifyChangesForAttribute** 属性，并添加声明的名称。
- en: 'You’re now ready to add the method that defines all the properties on the new
    type. Add the following method to the **NotifyingObjectWeaver** class:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以添加定义新类型上所有属性的方法。将以下方法添加到 **NotifyingObjectWeaver** 类中：
- en: '[PRE31]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code looks at the base type and gets all the properties and filters down
    to only virtual methods. Then, for all the properties it found, it goes and defines
    the **get** and **set** methods for the property.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查基类型，获取所有属性，并筛选出仅虚拟方法。然后，对于它找到的所有属性，它定义属性的 **get** 和 **set** 方法。
- en: 'Add the following method to the **NotifyingObjectWeaver** class:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到 **NotifyingObjectWeaver** 类中：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The **set_*** method is the method that will perform the notification. The code
    defines the method and first adds a call to the base type’s **set** method so
    that the base type can handle the value being set for itself. Then, it loops through
    all the properties to notify for and adds code to call the **OnPropertyChanged**
    method with the name of the property.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**set_*** 方法是执行通知的方法。代码定义了该方法，并首先调用基类型的 **set** 方法，以便基类型可以为自己处理设置的值。然后，它遍历所有要通知的属性，并添加代码来调用带有属性名称的
    **OnPropertyChanged** 方法。'
- en: Getting the value is slightly different, as you only want it to read through
    to the base type and get the value from it.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取值的方式略有不同，因为你只想让它读取到基类型并从中获取值。
- en: 'Add the following method to the **NotifyingObjectWeaver** class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 **NotifyingObjectWeaver** 类中：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You now have all the code for doing the code generation needed for the properties
    and also the method to raise the **PropertyChanged** event.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了执行属性代码生成所需的全部代码，以及引发 **PropertyChanged** 事件的函数。
- en: Initialization and public API
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化和公共API
- en: The last piece of the puzzle will be to do the main initialization that defines
    the dynamic assembly and module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图将是执行主要初始化，定义动态程序集和模块。
- en: 'Add the following in the **NotifyingObjectWeaver** class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **NotifyingObjectWeaver** 类中添加以下内容：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You now need a public API that can be called from the outside to get a proxy
    type of another type.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在需要一个公共API，可以从外部调用以获取其他类型的代理类型。
- en: 'Add the following code to the **NotifyingObjectWeaver** class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **NotifyingObjectWeaver** 类中：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The **GetProxyType** method checks first whether there is a proxy type for the
    given type and returns the existing one if that’s the case, creating the proxy
    type if it doesn’t have it in the cache.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetProxyType** 方法首先检查是否存在给定类型的代理类型，如果存在，则返回现有的代理类型；如果缓存中没有，则创建代理类型。'
- en: Using NotifyingObjectWeaver
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NotifyingObjectWeaver
- en: 'You now have a fully functional object weaver. Let’s take it out for a spin.
    In the **Program.cs** file, add the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了一个功能齐全的对象编织器。让我们在 **Program.cs** 文件中试运行它。添加以下代码：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The code asks for a wrapped-up type and then creates an instance of it. Since
    it now implements **INotifyPropertyChanged**, we can simply cast it to that type
    and interact with the **PropertyChanged** event.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 代码要求一个包装后的类型，然后创建它的一个实例。由于它现在实现了**INotifyPropertyChanged**，我们可以简单地将其转换为该类型，并与之交互**PropertyChanged**事件。
- en: And since the new type inherits from the **Person** class, we can also cast
    it to that type and set the property on it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新类型继承自**Person**类，我们也可以将其转换为该类型，并设置其属性。
- en: 'When you run this program, you should see the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你应该看到以下结果：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now would be a good time to try out the **NotifyChangesFor** functionality
    you added. Open the **Person.cs** file and change it to look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是尝试你添加的**NotifyChangesFor**功能的好时机。打开**Person.cs**文件，将其修改为以下样子：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since **FullName** is a composite of both **FirstName** and **LastName**, it
    makes sense to be notified if either of those properties changes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**FullName**是**FirstName**和**LastName**的组合，因此当这些属性中的任何一个发生变化时通知是有意义的。
- en: 'Running the program should now give you the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序现在应该会给你以下结果：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code in the GitHub repository has more capabilities that sit there as a
    reference. For instance, if the base type has a constructor that takes parameters,
    you should implement the same constructor in the type and pass along the constructor
    parameters to the base constructor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中的代码具有更多功能，可以作为参考。例如，如果基类型有一个接受参数的构造函数，你应该在类型中实现相同的构造函数，并将构造函数参数传递给基构造函数。
- en: Another common occurrence you may run into is the need to be able to ignore
    properties. Since the implementation in this chapter is an **opt-out** model,
    all virtual properties are considered properties that notify about changes. This
    might not be true, but it is most likely what you need from most properties. Therefore,
    you want to have a way to ignore these.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到另一个常见的情况，即需要能够忽略属性。由于本章的实现是一个**opt-out**模型，所有虚拟属性都被视为通知变化的属性。这可能并不总是正确的，但很可能正是大多数属性所需要的东西。因此，你需要有一种方法来忽略这些属性。
- en: Look at the complete listing in the GitHub repository, where you can see how
    these things are implemented.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看GitHub仓库中的完整列表，你可以看到这些功能是如何实现的。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the power of having a managed runtime
    environment, seeing how we can take full advantage of it by dynamically creating
    code that will be executed in the same premises as pre-compiled code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了拥有托管运行时环境的力量，看到我们如何通过动态创建将在与预编译代码相同的条件下执行代码来充分利用它。
- en: The possibilities are pretty much endless with such a power. It is super helpful
    as a way to automate tedious tasks and optimize the developer experience, but
    it can be used for so much more. For instance, if you have a system that dynamically
    connects to other systems and the types are dynamically created through configuration
    or similar, instead of going through untyped mechanisms such as the **Dictionary<,>**
    type to hold property values, an optimization would be to create types on the
    fly. The benefit is that you’d have something that was type-safe within the runtime.
    It could also prove to be a performance boost to your system, as you wouldn’t
    be looking up values from the dictionary.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的功能几乎有无穷的可能性。它作为自动化繁琐任务和优化开发者体验的方式非常有帮助，但它可以用于更多的事情。例如，如果你有一个动态连接到其他系统的系统，并且类型是通过配置或类似方式动态创建的，那么，而不是通过如**Dictionary<,>**类型这样的无类型机制来持有属性值，一种优化方法是在运行时动态创建类型。好处是，你将拥有在运行时类型安全的某种东西。这也可能对你的系统性能提升有所帮助，因为你不需要从字典中查找值。
- en: In the next chapter, we will dive into a constructor called **Expression**,
    how it can be used to represent code and logic, and how you can extract information
    from an **Expression**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究一个名为**Expression**的构造函数，了解它如何表示代码和逻辑，以及如何从**Expression**中提取信息。
