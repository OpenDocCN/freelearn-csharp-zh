<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-92">
    <a id="_idTextAnchor093">
    </a>
    
     6
    
   </h1>
   <h1 id="_idParaDest-93">
    <a id="_idTextAnchor094">
    </a>
    
     Enhancing Security and Quality
    
   </h1>
   <p>
    
     In the rapidly evolving digital world, where new cyber threats emerge with alarming frequency, web-based application security is not just a feature but a fundamental necessity.
    
    
     So that applications are prepared for various existing vulnerabilities, software engineers must consider security as part of the entire development flow of web-based solutions so that they can protect data, guarantee integrity and availability, and minimize threats that can compromise
    
    
     
      an organization.
     
    
   </p>
   <p>
    
     In this chapter, we’ll learn about basic security principles that every web developer should master, especially regarding how ASP.NET Core 9, as a powerful platform, can help us create secure,
    
    
     
      high-level applications.
     
    
   </p>
   <p>
    
     First, we’ll explore the essential principles of web security, understanding that security must be taken into consideration in all phases of developing a
    
    
     
      web solution.
     
    
   </p>
   <p>
    
     Next, we’ll address the concepts of authentication and authorization, both of which are commonly used when users and applications, as well as applications and external applications, interact with each other.
    
    
     Once we have a better understanding of authorization and authentication flows, we’ll use the ASP.NET Core Identity framework to add security to an API project and learn about some important approaches that are available in ASP.NET Core 9 that allow us to strengthen security mechanisms in
    
    
     
      our applications.
     
    
   </p>
   <p>
    
     In this chapter, we’ll cover the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding the security principles of
     
     
      
       web-based applications
      
     
    </li>
    <li>
     
      Comparing authorization
     
     
      
       and authentication
      
     
    </li>
    <li>
     
      Working with the ASP.NET Core
     
     
      
       Identity framework
      
     
    </li>
    <li>
     
      Strengthening
     
     
      
       application security
      
     
    </li>
   </ul>
   <p>
    
     For us to have a great learning experience in this chapter, we must prepare our environment with some tools that will be essential for us to fully utilize the concepts that will
    
    
     
      be introduced.
     
    
   </p>
   <h1 id="_idParaDest-94">
    <a id="_idTextAnchor095">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To complete this chapter, the following tools must be present in your
    
    
     
      development environment:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Docker
      
     </strong>
     
      : Docker Engine must be installed on your operating system and have a SQL Server container running.
     
     
      You can find more details about Docker and SQL Server in
     
     <a href="B21788_04.xhtml#_idTextAnchor061">
      
       <em class="italic">
        
         Chapter 4
        
       </em>
      
     </a>
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Postman
      
     </strong>
     
      : We’ll use this tool to execute requests that are sent to the APIs of the
     
     
      
       developed application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Azure Data Studio
      
     </strong>
     
      : We’ll use this tool to connect to a SQL Server database so that we can execute
     
     
      
       SQL scripts.
      
     
    </li>
   </ul>
   <p>
    
     The code examples for this chapter can be found in this book’s GitHub
    
    
     
      repository:
     
    
    <a href="https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06">
     
      
       https://github.com/PacktPublishing/ASP.NET-Core-9.0-Essentials/tree/main/Chapter06
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor096">
    </a>
    
     Understanding the security principles of web-based applications
    
   </h1>
   <p>
    
     Every year, new
    
    <a id="_idIndexMarker396">
    </a>
    
     approaches to developing solutions emerge for the most diverse types of environments and devices.
    
    
     With this comes various challenges.
    
    
     Developing web applications that previously focused on technologies such as HTML, CSS, JavaScript, and a programming language of choice is no longer
    
    
     
      a reality.
     
    
   </p>
   <p>
    
     Software engineers began to serve other contexts outside the environment of a programming IDE, often working with iInfrastructure, adding to a multitude of frameworks and tools that emerged along with the DevOps cCulture approach, and constant
    
    
     
      value delivery.
     
    
   </p>
   <p>
    
     The DevOps culture
    
    <a id="_idIndexMarker397">
    </a>
    
     has brought a new working model where teams avoid silos and work together while exchanging knowledge and, consequently, learning.
    
    
     Therefore, a subject that is becoming increasingly present in the lives of solution developers is
    
    <strong class="bold">
     
      security
     
    </strong>
    
     .
    
    
     The term security
    
    <a id="_idIndexMarker398">
    </a>
    
     has long ceased to be an isolated subject directed only at a cybersecurity team.
    
    
     It is now essential from the first stages of design and must be considered in all aspects of
    
    
     
      a solution.
     
    
   </p>
   <p>
    
     Paying attention to threats in applications and data control and management has become paramount and is even a strategic factor for companies and customers that use applications.
    
    
     There are many security standards and policies from a data processing perspective, such as
    
    <a id="_idIndexMarker399">
    </a>
    
     the
    
    <strong class="bold">
     
      General Data Protection Regulation
     
    </strong>
    
     (
    
    <strong class="bold">
     
      GDPR
     
    </strong>
    
     )
    
    
     
      in Europe.
     
    
   </p>
   <p>
    
     Security is
    
    <a id="_idIndexMarker400">
    </a>
    
     very important and ASP.NET Core 9 offers several mechanisms that we can use to deal with the challenges proposed by avoiding threats and maintaining secure and
    
    <a id="_idIndexMarker401">
    </a>
    
     
      reliable applications.
     
    
   </p>
   <p>
    
     However, we must understand how security aspects are applied to web applications and common vulnerabilities, as well as how ASP.NET Core 9 works to prevent threats from occurring
    
    
     
      in applications.
     
    
   </p>
   <h2 id="_idParaDest-96">
    <a id="_idTextAnchor097">
    </a>
    
     Security topics in web applications
    
   </h2>
   <p>
    
     As we’ve already learned in previous chapters, in general, a web application has two main components: the frontend, which is responsible for interacting with the user, and the backend, which is responsible for processing the application’s business rules, providing control, and interacting with the
    
    
     
      data layer.
     
    
   </p>
   <p>
    
     Most web applications, whether they’re client-server
    
    <a id="_idIndexMarker402">
    </a>
    
     ones or
    
    <strong class="bold">
     
      single-page applications
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SPAs
     
    </strong>
    
     ), use the aforementioned approach in some way.
    
    
     As shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     , several components are part of how the frontend and backend interact, such as the communication protocol, requests, responses, HTTP headers, the browser, the application server, the database, the TCP protocol, credentials, cookies, and local storage (browser),
    
    
     
      among others:
     
    
   </p>
   <div><div><img alt="Figure 6.1 – Components of a SPA" src="img/B21788_06_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.1 – Components of a SPA
    
   </p>
   <p>
    
     As we can see, several
    
    <a id="_idIndexMarker403">
    </a>
    
     components communicate with
    
    <a id="_idIndexMarker404">
    </a>
    
     each other.
    
    
     Similarly, several vulnerabilities can compromise the integrity of your application.
    
    
     In some cases, an information leak can have serious consequences for
    
    
     
      an organization.
     
    
   </p>
   <p>
    
     As a premise, software engineers must have a security aspect set out from the initial design stage that can often be associated not only with communication protocols and interactions between systems but also with
    
    
     
      code development.
     
    
   </p>
   <p>
    
     Let’s say that, during the development process, a software engineer made a very important change that was supposed to fix a critical problem in the application.
    
    
     To quickly perform the correction, the software engineer created communication with the database using SQL commands and string concatenation.
    
    
     After carrying out the tests, the engineer submitted the code to the Git repository so that the system could be updated.
    
    
     There was no code review and within a few minutes, the fix was in the
    
    
     
      production environment.
     
    
   </p>
   <p>
    
     So, what’s wrong in this
    
    <a id="_idIndexMarker405">
    </a>
    
     scenario?
    
    
     Initially, the software engineer acted correctly in providing a quick response to the problem that was found in the application and corrected it, and everything returned to normal.
    
    
     However, the approach they used to communicate with the database contained a vulnerability that could be exploited by malicious users by utilizing what’s
    
    <a id="_idIndexMarker406">
    </a>
    
     known as
    
    <strong class="bold">
     
      SQL
     
    </strong>
    
     <strong class="bold">
      
       injection attacks
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Let’s look at an example of some code that’s vulnerable to SQL
    
    
     
      injection attacks:
     
    
   </p>
   <pre class="source-code">
using System;
using System.Data.SqlClient;
public class VulnerableDataAccess
{
  private string connectionString = "TheConnectionString";
  public void GetUserData(string username)
  {
    <strong class="bold">string query = "SELECT * FROM Users WHERE</strong>
<strong class="bold">      Username = '" + username + "'";</strong>
    using (SqlConnection connection = new
      SqlConnection(connectionString))
    {
      SqlCommand command = new SqlCommand(query,
        connection);
      try
      {
        connection.Open();
        SqlDataReader reader = command.ExecuteReader();
        while (reader.Read())
        {
          Console.WriteLine(String.Format("{0}, {1}",
            reader["Username"], reader["Email"]));
        }
        reader.Close();
      }
      catch (Exception ex)
      {
        Console.WriteLine(ex.Message);
      }
    }
  }
}</pre>
   <p>
    
     In the preceding code, the
    
    <a id="_idIndexMarker407">
    </a>
    
     SQL query has been constructed by directly concatenating a user’s input (username) into the SQL string.
    
    
     This is a dangerous practice because it allows an attacker to alter the intended SQL query by injecting SQL code into the
    
    <strong class="source-inline">
     
      username
     
    </strong>
    
     variable.
    
    
     For example, if a user enters something like
    
    <strong class="source-inline">
     
      '; DROP TABLE users; --
     
    </strong>
    
     , the resulting SQL query would be
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
SELECT * FROM Users WHERE Username = <strong class="bold">''; DROP TABLE Users; --'</strong></pre>
   <p>
    
     This would execute the
    
    <strong class="source-inline">
     
      DROP TABLE
     
    </strong>
    
     statement, potentially
    
    
     
      destroying data.
     
    
   </p>
   <p>
    
     So, a simple change such as this, even
    
    <a id="_idIndexMarker408">
    </a>
    
     with great intentions, could have a big impact.
    
    
     Likewise, simple processes can avoid this situation by implementing a code review, a practice where members of the engineering team analyze the code that should be incorporated into the main code to search for any flaws, evaluate code patterns and complexity, and more.
    
    
     The code can only be incorporated into the main code if it meets the quality and
    
    
     
      security criteria.
     
    
   </p>
   <p>
    
     Furthermore, while integrating the new code into the main code, automated processes can be executed, where it would be possible to
    
    <a id="_idIndexMarker409">
    </a>
    
     add
    
    <strong class="bold">
     
      static code analysis
     
    </strong>
    
     mechanisms.
    
    
     If there are any invalid security and quality criteria, the application can’t be delivered to the productive environment.
    
    
     We’ll learn more about automated processes in
    
    <a href="B21788_10.xhtml#_idTextAnchor162">
     
      <em class="italic">
       
        Chapter 10
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Static code analysis
    
   </p>
   <p class="callout">
    
     Static code analysis
    
    <a id="_idIndexMarker410">
    </a>
    
     acts on security checks, coding standards, and cyclomatic complexity analysis, among other aspects, adding value to the application development
    
    <a id="_idIndexMarker411">
    </a>
    
     process associated with automation techniques
    
    <a id="_idIndexMarker412">
    </a>
    
     that involve
    
    <strong class="bold">
     
      continuous integration
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CI
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      continuous delivery
     
    </strong>
    
     (
    
    <strong class="bold">
     
      CD
     
    </strong>
    
     ).
    
    
     There are several tools available in the market for static code analysis, with the most famous
    
    <a id="_idIndexMarker413">
    </a>
    
     being
    
    <strong class="bold">
     
      SonarQube
     
    </strong>
    
     (
    
    <a href="https://hub.docker.com/_/sonarqube">
     
      https://hub.docker.com/_/sonarqube
     
    </a>
    
     ).
    
    
     It has a community version and can be hosted in any environment.
    
    
     However, it does have some limitations regarding how many lines of
    
    <a id="_idIndexMarker414">
    </a>
    
     code can be analyzed.
    
    
     Alternatively, there’s a version that’s delivered as a
    
    <strong class="bold">
     
      Software-as-a-Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SaaS
     
    </strong>
    
     ) offering
    
    <a id="_idIndexMarker415">
    </a>
    
     called
    
    <strong class="bold">
     
      Sonar
     
    </strong>
    
     <strong class="bold">
      
       Cloud
      
     </strong>
    
    
     
      (
     
    
    <a href="https://www.sonarsource.com/products/sonarcloud/">
     
      
       https://www.sonarsource.com/products/sonarcloud/
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p class="callout">
    
     Adding static analysis to the development flow is an
    
    
     
      excellent practice.
     
    
   </p>
   <p>
    
     In this chapter, we’ll explore other ways we can make our applications more secure and talk about various vulnerabilities.
    
    
     But first, let’s understand a common security model that’s used by most applications that’s based on two basic processes: authentication
    
    
     
      and authorization.
     
    
   </p>
   <h1 id="_idParaDest-97">
    <a id="_idTextAnchor098">
    </a>
    
     Comparing authorization and authentication
    
   </h1>
   <p>
    
     As we’ve been learning, the security aspect is important throughout the application development flow.
    
    
     Despite having good intentions, we can include vulnerabilities in our code that directly affect our users, applications,
    
    
     
      and companies.
     
    
   </p>
   <p>
    
     However, in addition to the code, some features require security processes.
    
    
     For example, this is the case for some service platforms, such as email managers, which allow users to access their messages privately once they’ve gained access by
    
    
     
      logging in.
     
    
   </p>
   <p>
    
     The login functionality is very important and, although it seems like a simple process, it requires a lot of attention.
    
    
     Otherwise, depending on the application, there may
    
    
     
      be consequences.
     
    
   </p>
   <p>
    
     What would happen if there was a vulnerability upon logging into an online banking platform?
    
    
     It would probably be a big problem for the users of this bank (and also for
    
    
     
      the bank).
     
    
   </p>
   <p>
    
     Modern systems work with identity management for different aspects.
    
    
     As discussed in previous chapters, web applications can make requests to different APIs.
    
    
     APIs allow companies to provide business as services, which allows for diverse integrations between different applications.
    
    
     With this, it’s possible to have applications with different types of functionalities that add value to the user, such as map APIs, payment gateways, and even APIs that provide
    
    
     
      AI functionalities.
     
    
   </p>
   <p>
    
     For applications and APIs to communicate securely, an identity-based security mechanism is necessary.
    
    
     With this, we can find out who is demanding some type of information
    
    
     
      and why.
     
    
   </p>
   <p>
    
     This security
    
    <a id="_idIndexMarker416">
    </a>
    
     mechanism is
    
    <a id="_idIndexMarker417">
    </a>
    
     divided into two concepts:
    
    <strong class="bold">
     
      authentication
     
    </strong>
    
     
      and
     
    
    
     <strong class="bold">
      
       authorization
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     In general, we know that this approach involves a login flow.
    
    
     However, it’s essential to understand the difference between authentication
    
    
     
      and authorization.
     
    
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor099">
    </a>
    
     Authentication
    
   </h2>
   <p>
    
     Authentication
    
    <a id="_idIndexMarker418">
    </a>
    
     aims to answer the question,
    
    <em class="italic">
     
      Who
     
    </em>
    
     <em class="italic">
      
       are you?
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.2 – The authentication flow" src="img/B21788_06_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.2 – The authentication flow
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .2
     
    </em>
    
     shows an
    
    <a id="_idIndexMarker419">
    </a>
    
     authentication flow where, through a login form, a user’s credentials are provided, such as their email
    
    
     
      and password.
     
    
   </p>
   <p>
    
     By posting this information to the server by clicking the
    
    <strong class="bold">
     
      log in
     
    </strong>
    
     button, the application starts identifying this user by using the
    
    
     
      credentials provided.
     
    
   </p>
   <p>
    
     If the user is found according to these credentials, then the application is aware of who wants to access
    
    
     
      the system.
     
    
   </p>
   <p>
    
     However, this is just one part
    
    <a id="_idIndexMarker420">
    </a>
    
     of the process.
    
    
     Now that the application has identified the user, it’s important to understand what this user can do.
    
    
     This is done during the
    
    
     
      authorization process.
     
    
   </p>
   <h2 id="_idParaDest-99">
    <a id="_idTextAnchor100">
    </a>
    
     Authorization
    
   </h2>
   <p>
    
     Authorization aims to
    
    <a id="_idIndexMarker421">
    </a>
    
     answer the question,
    
    <em class="italic">
     
      What can this
     
    </em>
    
     <em class="italic">
      
       user do?
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.3 – Checking permissions with the authorization flow" src="img/B21788_06_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.3 – Checking permissions with the authorization flow
    
   </p>
   <p>
    
     After identifying the user, the application starts identifying the user’s permissions, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     Authorization
    
    <a id="_idIndexMarker422">
    </a>
    
     defines the scope in which this user can act, whether in managing some information or accessing a certain type of data, among other aspects.
    
    
     The authorization flow often identifies the user through roles, where it’s possible to group access levels within the scope of
    
    
     
      the application.
     
    
   </p>
   <p>
    
     It’s very common to use roles because it’s possible to group the different permissions that a user can have within
    
    
     
      an application.
     
    
   </p>
   <p>
    
     In general, the authentication
    
    <a id="_idIndexMarker423">
    </a>
    
     and
    
    <a id="_idIndexMarker424">
    </a>
    
     authorization processes are simple.
    
    
     However, to be able to implement them securely, there are some standards that
    
    <a id="_idIndexMarker425">
    </a>
    
     we must be
    
    <a id="_idIndexMarker426">
    </a>
    
     aware of: the
    
    <strong class="bold">
     
      OAuth 2.0
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Open ID Connect
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       OIDC
      
     </strong>
    
    
     
      ) protocols.
     
    
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor101">
    </a>
    
     Understanding OAuth 2.0 and OIDC
    
   </h2>
   <p>
    
     Imagine a high-security building.
    
    
     Here, authorization can be thought of as acquiring permission to enter, while authentication verifies
    
    
     
      your identity.
     
    
   </p>
   <p>
    
     OAuth 2.0 focuses
    
    <a id="_idIndexMarker427">
    </a>
    
     on authorization, allowing users to grant access to their data on one platform (such as a social media account) to another, without the need for them to share their actual passwords.
    
    
     In other words, we allow other applications to access a certain scope of our information without us having to provide certain credentials, such as what happens when we log in to some platform using credentials from Microsoft, Google, Facebook, and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     The basic OAuth 2.0 flow
    
    <a id="_idIndexMarker428">
    </a>
    
     can be defined
    
    
     
      as follows:
     
    
   </p>
   <ol>
    <li>
     
      The user logs in to a new application using their social
     
     
      
       media account.
      
     
    </li>
    <li>
     
      The application redirects the user to the social media platform (the
     
     
      
       authorization server).
      
     
    </li>
    <li>
     
      After logging into the social media account, the user grants the application permission to use their data (such as their name, email, profile photo,
     
     
      
       and more).
      
     
    </li>
    <li>
     
      The authorization server generates special tokens for the application.
     
     
      Tokens are used to gain access to user data (access tokens).
     
     
      In some cases, refresh tokens are used to provide access to
     
     
      
       new tokens.
      
     
    </li>
    <li>
     
      The application uses the access token to retrieve your data from the social media
     
     
      
       platform securely.
      
     
    </li>
   </ol>
   <p>
    
     This process involves negotiating two different applications that share user information, without the need to enter their credentials for each new application, increasing security
    
    
     
      and convenience.
     
    
   </p>
   <p>
    
     On the other hand, OIDC builds on OAuth 2.0, adding an authentication layer.
    
    
     It leverages the OAuth authorization framework to verify a user’s identity through trusted providers such as Google
    
    
     
      or Facebook.
     
    
   </p>
   <p>
    
     Let’s see how OIDC complements
    
    
     
      OAuth 2.0:
     
    
   </p>
   <ol>
    <li>
     
      Some applications
     
     <a id="_idIndexMarker429">
     </a>
     
      provide the ability to log in using other social media platforms.
     
     
      In this case, during the OAuth 2.0 flow, instead of logging into the new application, you’re redirected to your social media login page (the
     
     
      
       OpenID provider).
      
     
    </li>
    <li>
     
      The user authenticates with their social media credentials, proving their identity to the
     
     
      
       OpenID provider.
      
     
    </li>
    <li>
     
      With the user’s consent, the OpenID provider shares their basic profile information (such as name and email) with the new application via an
     
     
      
       ID token.
      
     
    </li>
   </ol>
   <p>
    
     OIDC enables features such
    
    <a id="_idIndexMarker430">
    </a>
    
     as
    
    <strong class="bold">
     
      single sign-on
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SSO
     
    </strong>
    
     ), allowing you to access multiple applications using the same login credentials (think of logging into multiple websites with your
    
    
     
      Google account).
     
    
   </p>
   <p>
    
     Although OAuth 2.0
    
    <a id="_idIndexMarker431">
    </a>
    
     and OIDC flows are similar and interconnected, they serve
    
    
     
      different purposes:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Focus
      
     </strong>
     
      : OAuth 2.0 acts on authorization (granting access to data), while OIDC acts on the authentication layer (verifying
     
     
      
       user identity).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Sharing information
      
     </strong>
     
      : OAuth 2.0 mainly deals with access tokens, while OIDC introduces ID tokens containing user
     
     
      
       profile information.
      
     
    </li>
   </ul>
   <p>
    
     We can think of OAuth 2.0 as a key that opens the door to a house, while OIDC provides identity verification so that this key can
    
    
     
      be received.
     
    
   </p>
   <p>
    
     This flow is quite common in several applications we use, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .4
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.4 – Basic OAuth 2.0 flow" src="img/B21788_06_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.4 – Basic OAuth 2.0 flow
    
   </p>
   <p>
    
     The authorization
    
    <a id="_idIndexMarker432">
    </a>
    
     and authentication flows are constantly used by applications, allowing both to identify who the users are and define the type of permissions that these users can execute in a web system
    
    
     
      or API.
     
    
   </p>
   <p>
    
     Despite this straightforward explanation of the OAuth 2.0 and OIDC protocols, as well as concepts of authorization and authentication, the task of implementing this approach isn’t simple and depends on some important mechanisms to ensure these functionalities are
    
    
     
      running correctly.
     
    
   </p>
   <p>
    
     Due to this, ASP.NET Core 9 has abstractions that support the development of identity management while following the standards outlined so far.
    
    
     The abstraction that implements these resources is known
    
    <a id="_idIndexMarker433">
    </a>
    
     as ASP.NET Core Identity.
    
    
     It has been evolving with each new version of the framework and allows teams to use security best practices in their authorization and authentication flows, as well as integrate with other identity providers while allowing customizations to be made.
    
    
     We’ll learn more about this approach in the
    
    
     
      next section.
     
    
   </p>
   <h1 id="_idParaDest-101">
    <a id="_idTextAnchor102">
    </a>
    
     Working with the ASP.NET Core Identity framework
    
   </h1>
   <p>
    
     Modern applications
    
    <a id="_idIndexMarker434">
    </a>
    
     interact with different types of technologies, protocols, and standards.
    
    
     As we’ve been learning, security is extremely important at any level of a solution’s implementation flow.
    
    
     A book could easily be dedicated to the subject of authorization
    
    
     
      and authentication.
     
    
   </p>
   <p>
    
     However, the ASP.NET Core 9 platform has been evolving every year and as a result, the identity management model has undergone several improvements, in addition to some dependencies
    
    
     
      being eliminated.
     
    
   </p>
   <p>
    
     To be able to implement authorization and authentication in our applications, we have ASP.NET Core Identity.
    
    
     It’s a membership system that adds capabilities to web-based applications developed in ASP.NET Core 9 and operates in both authentication and
    
    
     
      authorization flows.
     
    
   </p>
   <p>
    
     The set of features available in ASP.NET Core Identity includes APIs, a UI, databases between user identity management and credentials, and the ability to grant and revoke permissions.
    
    
     This is in addition to features
    
    <a id="_idIndexMarker435">
    </a>
    
     such as integration with external logins,
    
    <strong class="bold">
     
      two-factor authentication
     
    </strong>
    
     (
    
    <strong class="bold">
     
      2FA
     
    </strong>
    
     ), password management, being able to block and activate accounts, and providing authentication
    
    
     
      in applications.
     
    
   </p>
   <p>
    
     Before we learn how to integrate an application with ASP.NET Core identity, let’s learn more about
    
    
     
      its structure.
     
    
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor103">
    </a>
    
     Understanding the ASP.NET Core Identity architecture
    
   </h2>
   <p>
    
     ASP.NET Core Identity
    
    <a id="_idIndexMarker436">
    </a>
    
     has an architectural structure that’s divided into the
    
    
     
      following layers:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Identity manager
      
     </strong>
     
      : These are
     
     <a id="_idIndexMarker437">
     </a>
     
      service classes that are responsible for implementing the business logic that involves identities.
     
     
      We can find classes such as
     
     <strong class="source-inline">
      
       UserManager
      
     </strong>
     
      for user management and
     
     <strong class="source-inline">
      
       RoleManager
      
     </strong>
     
      for
     
     
      
       role management.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Identity store
      
     </strong>
     
      : The identity store
     
     <a id="_idIndexMarker438">
     </a>
     
      is the domain entity that represents each piece of data in a database.
     
     
      We can see the identity store as a table in the database that’s mapped to a class such as
     
     <strong class="source-inline">
      
       UserStore
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       RoleStore
      
     </strong>
     
      ,
     
     
      
       among others.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Data access layer
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker439">
     </a>
     
      are classes that have the necessary logic to interact with the database so that they can persist and retrieve
     
     
      
       identity-related information.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Data source
      
     </strong>
     
      : The
     
     <a id="_idIndexMarker440">
     </a>
     
      data source is the data mechanism that will be used for persistence.
     
     
      By default, ASP.NET Core Identity
     
     <a id="_idIndexMarker441">
     </a>
     
      uses
     
     <strong class="bold">
      
       SQL Server
      
     </strong>
     
      .
     
     
      However, there are other databases available, and there’s the possibility of customizing other
     
     
      
       data sources.
      
     
    </li>
   </ul>
   <p>
    
     These four layers have well-defined responsibilities and are fully extensible, bringing flexibility to development and allowing the identity mechanism to be customized according to the context required in
    
    
     
      an organization.
     
    
   </p>
   <p>
    
     ASP.NET Core Identity manages both authentication and authorization and works with the following types
    
    
     
      of data:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Users
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker442">
     </a>
     
      represent users in the application.
     
     
      This entity has some basic attributes implemented, but they can easily
     
     
      
       be extended.
      
     
    </li>
    <li>
     <strong class="bold">
      
       User claims
      
     </strong>
     
      : These are a
     
     <a id="_idIndexMarker443">
     </a>
     
      set of statements (claims) about a user.
     
     
      Claims add information to the
     
     
      
       user’s identity.
      
     
    </li>
    <li>
     <strong class="bold">
      
       User logins
      
     </strong>
     
      : These
     
     <a id="_idIndexMarker444">
     </a>
     
      provide information about authentication with external providers such as Facebook, Google, Microsoft, and others, if your application has any integration with
     
     
      
       these providers.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Roles
      
     </strong>
     
      : These are
     
     <a id="_idIndexMarker445">
     </a>
     
      
       authorization groups.
      
     
    </li>
   </ul>
   <p>
    
     Based on the information that’s managed by the ASP.NET Core Identity platform, we have what we need to implement authorization and authentication flows in our applications.
    
    
     However, this is a robust and highly customizable framework that allows various customizations to be implemented across
    
    
     
      identity types.
     
    
   </p>
   <p class="callout-heading">
    
     Customizing Identity
    
   </p>
   <p class="callout">
    
     If you want to customize Identity, please consult the official
    
    
     
      documentation:
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/security/authentication/customize-identity-model?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that we know more about the architectural structure of ASP.NET Core Identity, it’s time to add it to
    
    
     
      an application.
     
    
   </p>
   <h2 id="_idParaDest-103">
    <a id="_idTextAnchor104">
    </a>
    
     Getting started with integrating ASP.NET Core Identity
    
   </h2>
   <p>
    
     Now that we have
    
    <a id="_idIndexMarker446">
    </a>
    
     greater knowledge about some of the security perspectives that are part of the context of an application, it’s time to use ASP.NET Core Identity to add authorization and
    
    
     
      authentication flows.
     
    
   </p>
   <p>
    
     As a basis, we’ll use the source code available in this book’s GitHub repository, as mentioned in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section, where you’ll be able to download the complete solution.
    
    
     The project we’ll be using is a version of the API project that we created in
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    <em class="italic">
    </em>
    
     since all assumptions related to database configurations have been created.
    
    
     Therefore, we’ll leverage the API structure and database structure created earlier.
    
    
     The objective is to
    
    
     
      implement Identity.
     
    
   </p>
   <p class="callout-heading">
    
     Database settings
    
   </p>
   <p class="callout">
    
     When starting a new project, you’ll need to configure
    
    <strong class="bold">
     
      EntityFrameworkCore
     
    </strong>
    
     and connect the application to a database, as we learned in
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     .
    
    
     This way, you’ll be able to follow along and configure ASP.NET Core Identity
    
    
     
      with ease.
     
    
   </p>
   <p>
    
     For this application, which
    
    <a id="_idIndexMarker447">
    </a>
    
     is a web API that connects to a SQL Server
    
    <a id="_idIndexMarker448">
    </a>
    
     database, we’ll use the same model we learned about in
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     and use
    
    <strong class="bold">
     
      EntityFrameworkCore
     
    </strong>
    
     .
    
    
     To do so, we’ll need to add one more library:
    
    <strong class="bold">
     
      Microsoft.AspNetCore.Identity.EntityFrameworkCore
     
    </strong>
    
     .
    
    
     This library allows Identity to work with
    
    <a id="_idIndexMarker449">
    </a>
    
     Entity
    
    
     
      Framework Core.
     
    
   </p>
   <p>
    
     Ensure this library has been added to your project by opening the
    
    <strong class="source-inline">
     
      WorkingWithIdentity.csproj
     
    </strong>
    
     file or running the following command in your terminal, inside the application directory, to
    
    
     
      install it:
     
    
   </p>
   <pre class="console">
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore -v 8.0.2</pre>
   <p class="callout-heading">
    
     Creating the WorkingWithIdentity.csproj project
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      WorkingWithIdentity.csproj
     
    </strong>
    
     project is a
    
    <a id="_idIndexMarker450">
    </a>
    
     web API that will be protected with ASP.NET Core Identity and is available in this book’s GitHub repository, as described in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section.
    
    
     However, if you want to create the project for yourself, follow
    
    
     
      these steps:
     
    
   </p>
   <p class="callout">
    
     1.
    
    
     Open your operating system’s terminal and access the folder where the project should
    
    
     
      be created.
     
    
   </p>
   <p class="callout">
    
     2.
    
    
     Run the following command to create
    
    
     
      the project:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      dotnet new webapi -
     
    </strong>
    
     <strong class="source-inline">
      
       n WorkingWithIdentity
      
     </strong>
    
   </p>
   <p class="callout">
    
     3.
    
    
     Access the new
    
    
     
      project folder:
     
    
   </p>
   <p class="callout">
    
     <strong class="source-inline">
      
       cd WorkingWithIdentity
      
     </strong>
    
   </p>
   <p class="callout">
    
     4.
    
    
     Add the following NuGet packages, all of which are necessary for using the SQL
    
    
     
      Server database:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      dotnet add
     
    </strong>
    
     <strong class="source-inline">
      
       package Microsoft.EntityFrameworkCore
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      dotnet add
     
    </strong>
    
     <strong class="source-inline">
      
       package Microsoft.EntityFrameworkCore.SqlServer
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      dotnet add
     
    </strong>
    
     <strong class="source-inline">
      
       package Microsoft.EntityFrameworkCore.Design
      
     </strong>
    
   </p>
   <p class="callout">
    
     5.
    
    
     Make sure you have
    
    <a id="_idIndexMarker451">
    </a>
    
     the
    
    <strong class="bold">
     
      dotnet-ef
     
    </strong>
    
     tool installed.
    
    
     To do so, run the
    
    
     
      following
     
    
    
     <a id="_idIndexMarker452">
     </a>
    
    
     
      command:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      dotnet tool install
     
    </strong>
    <strong class="source-inline">
     
      --
     
    </strong>
    
     <strong class="source-inline">
      
       global
      
     </strong>
    
    
     <strong class="source-inline">
      
       dotnet-ef
      
     </strong>
    
   </p>
   <p>
    
     By default, the project already contains
    
    <a id="_idIndexMarker453">
    </a>
    
     the
    
    <strong class="bold">
     
      Microsoft.AspNetCore.Identity
     
    </strong>
    
     library since we added it when we created the project.
    
    
     However, we still
    
    <a id="_idIndexMarker454">
    </a>
    
     need to follow a few more steps to configure the project.
    
    
     Let’s start by configuring the database context so that the stores and Identity
    
    <a id="_idIndexMarker455">
    </a>
    
     models can be mapped
    
    
     
      by
     
    
    
     <strong class="bold">
      
       EntityFramework
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-104">
    <a id="_idTextAnchor105">
    </a>
    
     Configuring the database context
    
   </h2>
   <p>
    
     For ASP.NET
    
    <a id="_idIndexMarker456">
    </a>
    
     Core Identity to be able to manage
    
    <strong class="bold">
     
      users
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      roles
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      claims
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      tokens
     
    </strong>
    
     , we must configure the application by adding this capability to the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class, which is responsible for interacting with the SQL
    
    
     
      Server database.
     
    
   </p>
   <p>
    
     To do this, we must change the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class, available in the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     directory of the reference project in this
    
    
     
      chapter’s repository.
     
    
   </p>
   <p>
    
     The first step is to change the inheritance class to
    
    <strong class="source-inline">
     
      IdentityDbContext&lt;IdentityUser&gt;
     
    </strong>
    
     , which is located in the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Identity.EntityFrameworkCore
     
    </strong>
    
     namespace.
    
    
     Once we’ve done this, we’ll have the following
    
    
     
      updated class:
     
    
   </p>
   <pre class="source-code">
namespace WorkingWithIdentity.Context;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using WorkingWithIdentity.Model;
public class BankingDbContext : IdentityDbContext&lt;IdentityUser&gt;
{
    public BankingDbContext(DbContextOptions
      &lt;BankingDbContext&gt; options) : base(options)
    {
    }
     public DbSet&lt;Account&gt; Accounts { get; set; }
     public DbSet&lt;Customer&gt; Customers { get; set; }
     public DbSet&lt;Movement&gt; Movements { get; set; }
}</pre>
   <p>
    
     As we learned in
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class is an abstraction of
    
    <strong class="bold">
     
      Entity Framework Core
     
    </strong>
    
     that allows
    
    <a id="_idIndexMarker457">
    </a>
    
     the application to interact with the database, where each entity in the database is represented by properties of the
    
    <strong class="source-inline">
     
      DbSet
     
    </strong>
    
     type.
    
    
     This allows classes to be mapped to entities and
    
    
     
      vice versa.
     
    
   </p>
   <p>
    
     By changing the inheritance of the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       IdentityDb
      
     </strong>
    
    <strong class="source-inline">
     
      Context&lt;IdentityUser&gt;
     
    </strong>
    
     , we’re reusing the default
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     implementation from ASP.NET Identity Core.
    
    
     This contains the
    
    <strong class="source-inline">
     
      DbSet
     
    </strong>
    
     type for mapping the Identity tables that will be part of
    
    
     
      the database.
     
    
   </p>
   <p>
    
     To ensure that all the database settings are available in the application, open the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file and make sure that the following line of code exists in
    
    
     
      the file:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddDbContext&lt;BankingDbContext&gt;(
  options =&gt;   options.UseSqlServer(builder
  .Configuration.GetConnectionString("BankingDbContext")));</pre>
   <p>
    
     It’s very important to configure the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class in the ASP.NET Core dependency injection container.
    
    
     In this case, we added the
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     class to the dependency injection context while also configuring the use of SQL Server, whose connection will be based on the
    
    <strong class="source-inline">
     
      ConnectionString
     
    </strong>
    
     value, which is passed as a parameter to the
    
    <strong class="source-inline">
     
      UseSqlServer
     
    </strong>
    
     method.
    
    
     This
    
    <strong class="source-inline">
     
      ConnectionString
     
    </strong>
    
     is obtained through the application
    
    <a id="_idIndexMarker458">
    </a>
    
     settings, which in this case can be found in the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file.
     
    
   </p>
   <p>
    
     At this point, we have all the necessary configurations so that ASP.NET Core Identity is configured in the data layer.
    
    
     In the next section, we’ll update the database so that we can add the necessary tables for
    
    
     
      identity management.
     
    
   </p>
   <h2 id="_idParaDest-105">
    <a id="_idTextAnchor106">
    </a>
    
     Updating the database
    
   </h2>
   <p>
    
     In
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , we created an
    
    <a id="_idIndexMarker459">
    </a>
    
     API that simulates digital bank operations and connected it to a database using Entity Framework Core.
    
    
     For this example, we’ll use the same database – that is,
    
    <strong class="bold">
     
      dbBanking
     
    </strong>
    
     .
    
    
     Currently, it has the following
    
    
     
      data structure:
     
    
   </p>
   <div><div><img alt="Figure 6.5 – The structure of the dbBanking database" src="img/B21788_06_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.5 – The structure of the dbBanking database
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      dbBanking
     
    </strong>
    
     database
    
    <a id="_idIndexMarker460">
    </a>
    
     consists of four tables, three of which are part of the application context – that is,
    
    <strong class="bold">
     
      dbo.Accounts
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      dbo.Customers
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      dbo.Movements
     
    </strong>
    
     .
    
    
     The fourth table,
    
    <strong class="bold">
     
      dbo.EFMigrationsHistory
     
    </strong>
    
     , is responsible for managing the status of changes that are made to the database
    
    
     
      using migrations.
     
    
   </p>
   <p class="callout-heading">
    
     Database migrations
    
   </p>
   <p class="callout">
    
     In
    
    <a href="B21788_05.xhtml#_idTextAnchor078">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     , we explored how migrations work, their importance during application development, and changes that can be made dynamically to the database.
    
    
     If you want to learn more about how ASP.NET Core 9 migrations
    
    <a id="_idIndexMarker461">
    </a>
    
     works, please refer
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli">
     
      
       https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      dbo.EFMigrationsHistory
     
    </strong>
    
     table
    
    <a id="_idIndexMarker462">
    </a>
    
     contains the history of the first entities that were created for the bank API.
    
    
     You can check the history that’s been generated through the code in the application’s directory structure, in the
    
    <strong class="bold">
     
      Migrations
     
    </strong>
    
     folder, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .6
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.6 – Migrations classes for the API" src="img/B21788_06_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.6 – Migrations classes for the API
    
   </p>
   <p>
    
     These classes are automatically generated by the Entity Framework Core command-line tool and should not be
    
    
     
      changed manually.
     
    
   </p>
   <p>
    
     After making changes to the
    
    <strong class="source-inline">
     
      DbContext
     
    </strong>
    
     class and adding the ASP.NET Core Identity models, we must change the database.
    
    
     To do so, we’ll create a
    
    
     
      new migration.
     
    
   </p>
   <p>
    
     To do this, open a terminal of your choice, access the root directory of the
    
    <strong class="bold">
     
      WorkingWithIdentity
     
    </strong>
    
     application, and execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet ef migrations add IdentityModels</pre>
   <p>
    
     The preceding command uses Entity Framework Core’s
    
    <strong class="source-inline">
     
      ef
     
    </strong>
    
     tool and adds a migration
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       IdentityModels
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Again, when opening the project’s
    
    <strong class="bold">
     
      Migrations
     
    </strong>
    
     folder, we can analyze which new classes were created, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .7
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.7 – Migration classes for the Identity model" src="img/B21788_06_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.7 – Migration classes for the Identity model
    
   </p>
   <p>
    
     Now that we have the
    
    <a id="_idIndexMarker463">
    </a>
    
     migration structure for the database, we must update
    
    <strong class="bold">
     
      dbBanking
     
    </strong>
    
     so that it includes the Identity tables.
    
    
     To do this, in your preferred terminal, run the following command in the
    
    
     
      project directory:
     
    
   </p>
   <pre class="console">
dotnet ef database update</pre>
   <p>
    
     The preceding command reads the migrations available in the project, analyzes the migration history in the
    
    <strong class="bold">
     
      dbo.EFMigrationsHistory
     
    </strong>
    
     table in the database, and applies the updates, which in this case involve creating the tables necessary for ASP.NET Core Identity to work correctly.
    
    
     We’ll see the new tables that have
    
    
     
      been created:
     
    
   </p>
   <div><div><img alt="Figure 6.8 – The database now contains ASP.NET Core Identity tables" src="img/B21788_06_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.8 – The database now contains ASP.NET Core Identity tables
    
   </p>
   <p>
    
     With that, all basic ASP.NET Core Identity settings related to the data model have been added successfully.
    
    
     However, we still need to add some other configurations to the project so that the application is capable of handling authorization and authentication.
    
    
     So, in the next section, we’ll add ASP.NET Core Identity services to the application’s dependency
    
    
     
      injection context.
     
    
   </p>
   <h2 id="_idParaDest-106">
    <a id="_idTextAnchor107">
    </a>
    
     Adding ASP.NET Core Identity services and routes
    
   </h2>
   <p>
    
     Asp.Net Core Identity
    
    <a id="_idIndexMarker464">
    </a>
    
     contains the necessary abstractions to deal
    
    <a id="_idIndexMarker465">
    </a>
    
     with authorization and authentication mechanisms using the services available in the dependency injection container, in addition to wheels for authentication and
    
    
     
      token generation.
     
    
   </p>
   <p>
    
     However, it’s
    
    <a id="_idIndexMarker466">
    </a>
    
     necessary to activate these abstractions explicitly.
    
    
     To do so, we
    
    <a id="_idIndexMarker467">
    </a>
    
     must add a few lines of code to the application.
    
    
     Open the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file so that we can edit them.
    
    
     At this point, we must follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Adding the required Identity namespace – that is,
     
     
      <strong class="source-inline">
       
        using Microsoft.AspNetCore.identity;
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add the authentication services that are responsible for determining the identity of users to the dependency injection container, as well as the authentication method.
     
     
      In this case, we’ll be using a bearer
     
     
      
       token:
      
     
     
      <strong class="source-inline">
       
        builder.Services.AddAuthentication().AddBearerToken();
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add the authorization services to the dependency injection container by
     
     
      
       running
      
     
     
      <strong class="source-inline">
       
        builder.Services.AddAuthorization();
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add the Identity APIs and configure data access through Entity Framework Core by
     
     
      
       running
      
     
     
      <strong class="source-inline">
       
        builder.Services.AddIdentityApiEndpoints&lt;IdentityUser&gt;().AddEntityFrameworkStores&lt;BankingDbContext&gt;();
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Map the Identity endpoints
     
     
      
       using
      
     
     
      <strong class="source-inline">
       
        app.MapIdentityApi&lt;IdentityUser&gt;();
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add each request authentication middleware to the application’s request processing pipeline, using the settings defined by
     
     <strong class="source-inline">
      
       AddAuthentication()
      
     </strong>
     
      to validate and define the user’s
     
     
      
       identity:
      
     
     
      <strong class="source-inline">
       
        app.UseAuthentication();
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add middleware that checks authorization policies against the identity of the authenticated user to determine whether the user is allowed to proceed with the current
     
     
      
       request:
      
     
     
      <strong class="source-inline">
       
        app.UseAuthorization();
       
      </strong>
     
     
      
       .
      
     
     <p class="list-inset">
      
       By making
      
      <a id="_idIndexMarker468">
      </a>
      
       these changes, we’ll have the following
      
      <a id="_idIndexMarker469">
      </a>
      
       complete code in the
      
      
       <strong class="source-inline">
        
         Program.cs
        
       </strong>
      
      
       
        file:
       
      
     </p>
     <pre class="source-code">
using Dapper;
<strong class="bold">using Microsoft.AspNetCore.Identity;</strong>
using Microsoft.Data.SqlClient;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.SqlServer;
using WorkingWithIdentity.Context;
using WorkingWithIdentity.Model;
using WorkingWithIdentity.RouteHandler;
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.Services.AddAuthentication().AddBearerToken();</strong>
// Adding the Authorization Services from the Asp.Net Core Identity
<strong class="bold">builder.Services.AddAuthorization();</strong>
// Configure the Database access for the Asp.Net Core Identity
<strong class="bold">builder.Services.AddIdentityApiEndpoints</strong>
<strong class="bold">  &lt;IdentityUser&gt;()</strong>
<strong class="bold">    .AddEntityFrameworkStores&lt;BankingDbContext&gt;();</strong>
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddDbContext&lt;BankingDbContext&gt;
  (options =&gt; options.UseSqlServer(builder
    .Configuration.GetConnectionString(
      "BankingDbContext")));
builder.Services.AddScoped(_ =&gt; new SqlConnection
  (builder.Configuration.GetConnectionString(
    "BankingDbContext")));
var app = builder.Build();
// Configure the HTTP request pipeline adding the ASP.NET Core Identity routes
<strong class="bold">app.MapIdentityApi&lt;IdentityUser&gt;();</strong>
// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}
app.UseHttpsRedirection();
<strong class="bold">app.RegisterAccountRoutes();</strong>
<strong class="bold">app.RegisterCustomerRoutes();</strong>
app.MapGet("GetAllCustomersUsingDapper", async(SqlConnection connection) =&gt;
{
  var customers = await connection
    .QueryAsync&lt;Customer&gt;("SELECT Id,
    Name FROM Customers ORDER BY Name");
    return Results.Ok(customers);
});
app.MapGet("GetCustomerByIdUsingDapper",
  async(int id, SqlConnection connection) =&gt;
{
    var customer = await connection
      .QueryFirstOrDefaultAsync&lt;Customer&gt;(
      "SELECT Id, Name FROM Customers WHERE
      Id = @id", new { id });
    if (customer is null) return Results.NotFound();
    return Results.Ok(customer);
});
<strong class="bold">app.UseAuthentication();</strong>
<strong class="bold">app.UseAuthorization();</strong>
app.Run();</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Register account and customer routes
    
   </p>
   <p class="callout">
    
     The routes that are responsible for processing requests for the Account and Customers APIs were registered through the
    
    <strong class="source-inline">
     
      app.RegisterAccountRoutes
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      app.RegisterCustomerRoutes
     
    </strong>
    
     extension methods, as highlighted in the
    
    
     
      preceding code.
     
    
   </p>
   <p class="callout">
    
     This is a good practice for correctly separating responsibilities, as well as improving the maintainability of the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     
      file code.
     
    
   </p>
   <p class="callout">
    
     To create these extension methods, two classes were created, as
    
    
     
      shown here:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public static
     
    </strong>
    
     <strong class="source-inline">
      
       class AccountRoutes
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public static
     
    </strong>
    
     <strong class="source-inline">
      
       void RegisterAccountRoutes(this
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       IEndpointRouteBuilder routes)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var group =
     
    </strong>
    
     <strong class="source-inline">
      
       routes.MapGroup("/accounts");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      //
     
    </strong>
    
     <strong class="source-inline">
      
       GET: /accounts
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      group.MapGet("/", async (BankingDbContext
     
    </strong>
    
     <strong class="source-inline">
      
       dbContext) =&gt;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      return await
     
    </strong>
    
     <strong class="source-inline">
      
       dbContext.Accounts.Include(a =&gt;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       a.Customer)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      .Include(a =&gt;
     
    </strong>
    
     <strong class="source-inline">
      
       a.Movements)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      .
     
    </strong>
    
     <strong class="source-inline">
      
       ToListAsync();
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      });
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      //
     
    </strong>
    
     <strong class="source-inline">
      
       other methods
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public static
     
    </strong>
    
     <strong class="source-inline">
      
       class CustomerRoutes
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public static
     
    </strong>
    
     <strong class="source-inline">
      
       void RegisterCustomerRoutes(this
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       IEndpointRouteBuilder routes)
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var group =
     
    </strong>
    
     <strong class="source-inline">
      
       routes.MapGroup("/customers");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      //
     
    </strong>
    
     <strong class="source-inline">
      
       GET: /customers
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      group.MapGet("/", async (BankingDbContext
     
    </strong>
    
     <strong class="source-inline">
      
       dbContext) =&gt;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      return
     
    </strong>
    
     <strong class="source-inline">
      
       await dbContext.Customers.ToListAsync();
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      });
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      //
     
    </strong>
    
     <strong class="source-inline">
      
       other methods
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     The extension classes that were created here have a static method that’s responsible for registering the routes of the respective entities.
    
    
     This is a practice that makes code more organized and easier to read and maintain.
    
    
     To learn more about creating extension methods, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method">
     
      
       https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     When analyzing the preceding code, it’s very important to consider the order of the highlighted lines of code; otherwise, the objects and route mappings won’t
    
    
     
      work correctly.
     
    
   </p>
   <p>
    
     So far, the solution code presents a configuration model that already allows us to benefit from the authorization and authentication features of ASP.NET Core Identity.
    
    
     However, there are some cases where there’s a need to customize access types based on user roles.
    
    
     Fortunately, ASP.NET Core 9 offers a powerful feature that allows us to segregate the type of access to application resources, as we will see in the
    
    
     
      next section.
     
    
   </p>
   <h3>
    
     Role-based authorization
    
   </h3>
   <p>
    
     To have greater control over the user authorization flow in the application, we can implement
    
    <strong class="bold">
     
      role-based authorization
     
    </strong>
    
     .
    
    
     This
    
    <a id="_idIndexMarker470">
    </a>
    
     role-based control allows you to segregate the type of access to parts of your application based on the roles that have been assigned to users.
    
    
     Imagine a scenario where there are two roles:
    
    <strong class="bold">
     
      Administrator
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Reader
     
    </strong>
    
     .
    
    
     By using
    
    <a id="_idIndexMarker471">
    </a>
    
     the role-based authorization approach, you can ensure
    
    <a id="_idIndexMarker472">
    </a>
    
     that only users authorized to certain areas of the application can access specific resources or perform specific actions in
    
    
     
      an application.
     
    
   </p>
   <p>
    
     In ASP.NET Core 9, the role-based authorization approach can be implemented by defining policies, which extend role-based authorization with more complex logic, offering fine-grained control over
    
    
     
      user permissions.
     
    
   </p>
   <p>
    
     Once a policy has been defined, it can be applied to controllers, actions, or even Razor Pages to enforce the desired authorization behavior.
    
    
     Policies make your authorization logic more modular and reusable.
    
    
     This is especially useful in larger applications, where access control can
    
    
     
      become complex.
     
    
   </p>
   <p>
    
     For example, consider a scenario where you want to create a policy that only allows users with the
    
    <strong class="bold">
     
      Admin
     
    </strong>
    
     role
    
    <a id="_idIndexMarker473">
    </a>
    
     to access certain administrative resources.
    
    
     Also, you might want to create another policy that only allows users with the
    
    <strong class="bold">
     
      Manager
     
    </strong>
    
     role
    
    <a id="_idIndexMarker474">
    </a>
    
     to be employed for over 1 year so that they can access specific reports.
    
    
     These policies can be defined in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file and then applied to controllers or actions using the
    
    <strong class="bold">
     
      [
     
    </strong>
    
     <strong class="bold">
      
       Authorize]
      
     </strong>
    
    
     
      attribute.
     
    
   </p>
   <p>
    
     Let’s look at a simple example of a policy that could be added to a
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">builder.Services.AddAuthorization(options =&gt;</strong>
<strong class="bold">{    options.AddPolicy("AdminOnly",</strong>
<strong class="bold">     policy =&gt; policy.RequireRole("Admin"));</strong>
<strong class="bold">});</strong>
var app = builder.Build();
app.UseAuthorization();
 app.MapGet("/admin", <strong class="bold">[Authorize(Policy = "AdminOnly")]</strong>
  () =&gt; {
    return Results.Ok("Welcome, Admin!");
});
app.Run();</pre>
   <p>
    
     In the preceding code, we
    
    <a id="_idIndexMarker475">
    </a>
    
     configured a policy called
    
    <strong class="source-inline">
     
      AdminOnly
     
    </strong>
    
     that sets a rule where the user has the
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     role.
    
    
     The
    
    <strong class="source-inline">
     
      [Authorize]
     
    </strong>
    
     attribute is then applied to an endpoint and uses the policy we created earlier, restricting access to users who meet the
    
    
     
      policy criteria.
     
    
   </p>
   <p>
    
     Now, let’s look at a more complex example.
    
    
     Here, a custom policy has been defined that checks the user’s role and provides an additional claim that requires the user’s employment duration to be
    
    
     
      1 year:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddAuthorization(options =&gt;
{
    options.AddPolicy("EmployeeWithExperience",
    policy =&gt;
    {
       <strong class="bold"> policy.RequireRole("Manager");</strong>
<strong class="bold">        policy.RequireClaim("EmploymentDuration", "1Year");</strong>
    });
});
var app = builder.Build();
app.UseAuthorization();
app.MapGet("/reports",
  [Authorize(Policy = " EmployeeWithExperience ")]
  () =&gt; {    return Results.Ok("Access granted to experienced managers.");
});
app.Run();</pre>
   <p>
    
     In this example, the
    
    <strong class="source-inline">
     
      EmployeeWithExperience
     
    </strong>
    
     policy requires that the user has the
    
    <strong class="source-inline">
     
      Manager
     
    </strong>
    
     role and owns a claim named
    
    <strong class="source-inline">
     
      EmploymentDuration
     
    </strong>
    
     with a value of
    
    <strong class="source-inline">
     
      1Year
     
    </strong>
    
     .
    
    
     This policy applies to the
    
    <strong class="source-inline">
     
      /reports
     
    </strong>
    
     endpoint, restricting access to
    
    
     
      managers only.
     
    
   </p>
   <p>
    
     Role-based authorization
    
    <a id="_idIndexMarker476">
    </a>
    
     and policies give you a powerful way to manage access to your application’s resources, allowing you to build complex authorization logic that goes beyond simple role checks and incorporate additional conditions and claims
    
    
     
      as needed.
     
    
   </p>
   <p>
    
     Now that we know more about ASP.NET Core Identity, have integrated it into our application, and know how to segregate access to application resources by implementing authorization policies, it’s time to add restrictions to the
    
    
     
      application’s routes.
     
    
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor108">
    </a>
    
     Securing APIs with ASP.NET Core Identity
    
   </h2>
   <p>
    
     At this point, the
    
    <a id="_idIndexMarker477">
    </a>
    
     application has been fully integrated with ASP.NET Core Identity.
    
    
     Now, we’ll run it so that we can analyze the results.
    
    
     Open a terminal of your choice and access the application directory.
    
    
     Then, run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet run</pre>
   <p>
    
     An
    
    <a id="_idIndexMarker478">
    </a>
    
     address in
    
    <strong class="source-inline">
     
      http://localhost:&lt;port&gt;
     
    </strong>
    
     format will be provided.
    
    
     The port number may be different from the one shown in this example, but the execution will be the same.
    
    
     Access the
    
    <strong class="source-inline">
     
      http://localhost:&lt;port&gt;/swagger/index.html
     
    </strong>
    
     address; you should see the
    
    
     
      following output:
     
    
   </p>
   <div><div><img alt="Figure 6.9 – Banking API integrated with ASP.NET Core Identity" src="img/B21788_06_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.9 – Banking API integrated with ASP.NET Core Identity
    
   </p>
   <p>
    
     As we can see, new routes were added to the API.
    
    
     These routes are the APIs that are provided by ASP.NET Core Identity.
    
    
     Each API allows us to manage the application’s users and add different capabilities, such as password recovery, user creation, or
    
    
     
      password reset.
     
    
   </p>
   <p>
    
     However, upon attempting to execute an endpoint, such as performing a
    
    <strong class="bold">
     
      GET
     
    </strong>
    
     request on the
    
    <strong class="bold">
     
      /accounts
     
    </strong>
    
     API, we realized that we were able to obtain a valid response.
    
    
     To perform the test, simply open the
    
    <strong class="bold">
     
      GET
     
    </strong>
    
     method of the
    
    <strong class="bold">
     
      /accounts
     
    </strong>
    
     API, click the
    
    <strong class="bold">
     
      Try Out
     
    </strong>
    
     button, and then the
    
    <strong class="bold">
     
      Execute
     
    </strong>
    
     button.
    
    
     We should get the
    
    
     
      following response:
     
    
   </p>
   <div><div><img alt="Figure 6.10 – Requesting an API without authentication and authorization" src="img/B21788_06_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.10 – Requesting an API without authentication and authorization
    
   </p>
   <p>
    
     As we can
    
    <a id="_idIndexMarker479">
    </a>
    
     see, we have an HTTP status code of
    
    <strong class="bold">
     
      200
     
    </strong>
    
     , which means that the request was successful, even if the result didn’t return any existing account records in the database.
    
    
     If you have any records registered in this table in your local database, the result will be an array of account objects serialized in
    
    
     
      JSON format.
     
    
   </p>
   <p>
    
     However, we want to add authentication and authorization processes to the application’s APIs.
    
    
     To do so, we must make some changes to the
    
    
     
      source code.
     
    
   </p>
   <p>
    
     As we know, each API has its routes registered in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file.
    
    
     These routes act as entry points for requests.
    
    
     Since we want to protect each route so that only known and authorized users can consume the API, we must add a configuration to the routes so that when someone attempts to request the API without being authenticated, the request must return an HTTP
    
    <strong class="bold">
     
      401
     
    </strong>
    
     status code, informing the API consumer that there’s a need
    
    
     
      for authentication.
     
    
   </p>
   <p>
    
     In the next section, we’ll learn how to protect routes and prevent
    
    
     
      unauthorized requests.
     
    
   </p>
   <h2 id="_idParaDest-108">
    <a id="_idTextAnchor109">
    </a>
    
     Securing application routes
    
   </h2>
   <p>
    
     Even if all authentication and
    
    <a id="_idIndexMarker480">
    </a>
    
     authorization settings are present in the application, it’s necessary to determine what should be protected and
    
    
     
      what shouldn’t.
     
    
   </p>
   <p>
    
     One of the ways we can ensure that a given API method is protected by authentication and authorization middleware is by adding an explicit configuration to
    
    
     
      the routes.
     
    
   </p>
   <p>
    
     In the application that we’re working on, the API routes were implemented in separate files as
    
    <strong class="bold">
     
      extension methods
     
    </strong>
    
     , as a
    
    <a id="_idIndexMarker481">
    </a>
    
     good practice.
    
    
     So, let’s make the necessary change in the
    
    <strong class="source-inline">
     
      AccountHandler.cs
     
    </strong>
    
     file, located in the application’s
    
    
     <strong class="source-inline">
      
       RouteHandler
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     To do this, we’ll configure the
    
    <strong class="source-inline">
     
      /accounts
     
    </strong>
    
     route so that it only accepts requests if the user is authenticated.
    
    
     Let’s look at the
    
    
     
      changed code:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/accounts", async (BankingDbContext
  dbContext) =&gt; {
    var accounts = await dbContext.Accounts.ToListAsync();
    return Results.Ok(accounts);
}).<strong class="bold">RequireAuthorization()</strong>;</pre>
   <p>
    
     Here, we added the
    
    <strong class="source-inline">
     
      RequireAuthorization()
     
    </strong>
    
     method call.
    
    
     We’ve already learned that authorization is a process that validates a user’s permissions, while authentication involves identifying the user.
    
    
     In this case, if the user isn’t authenticated, they can’t
    
    
     
      be authorized.
     
    
   </p>
   <p>
    
     Again, in a terminal of your choice, inside the application directory, execute the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet run</pre>
   <p>
    
     Next, we’ll request the
    
    <strong class="source-inline">
     
      /accounts
     
    </strong>
    
     route.
    
    
     However, let’s execute
    
    <a id="_idIndexMarker482">
    </a>
    
     the
    
    <strong class="bold">
     
      Postman
     
    </strong>
    
     application first.
    
    
     Follow
    
    
     
      the steps:
     
    
   </p>
   <ol>
    <li>
     
      Go to
     
     <strong class="bold">
      
       File
      
     </strong>
     
      |
     
     <strong class="bold">
      
       New
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        HTTP
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      A new tab will open where you can make
     
     
      
       a request.
      
     
    </li>
    <li>
     
      Add the URL of the running application – that is,
     
     <strong class="source-inline">
      
       http://localhost:&lt;port&gt;/accounts
      
     </strong>
     
      – and check whether the selected method
     
     
      
       is
      
     
     
      <strong class="bold">
       
        GET
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Then, click on the
     
     <strong class="bold">
      
       Send
      
     </strong>
     
      button.
     
     
      We’ll get
     
     <a id="_idIndexMarker483">
     </a>
     
      the
     
     
      
       following output:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.11 – Requesting the protected route" src="img/B21788_06_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.11 – Requesting the protected route
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .11
     
    </em>
    
     highlights the return of the request with an HTTP status code of 401, which means that the request
    
    
     
      wasn’t authorized.
     
    
   </p>
   <p>
    
     For a successful request for this route to be made, we must log in and configure the request with the authenticated
    
    
     
      user’s information.
     
    
   </p>
   <p>
    
     Before logging in, we
    
    <a id="_idIndexMarker484">
    </a>
    
     must create a user in the application.
    
    
     To do this, perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a new HTTP request
     
     
      
       in Postman.
      
     
    </li>
    <li>
     
      Set the request type
     
     
      
       to
      
     
     
      <strong class="bold">
       
        POST
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Add
     
     <strong class="source-inline">
      
       http://localhost:&lt;port&gt;/register
      
     </strong>
     
      as the route.
     
     
      This is the default route for creating ASP.NET Core Identity users that will be added to
     
     
      
       the application.
      
     
    </li>
    <li>
     
      At this point, we need to define the body of the request.
     
     
      To do this, click on the
     
     <strong class="bold">
      
       Body
      
     </strong>
     
      tab, select the
     
     <strong class="bold">
      
       raw
      
     </strong>
     
      option, and add the JSON shown in
     
     
      <em class="italic">
       
        Figure 6
       
      </em>
     
     
      <em class="italic">
       
        .12
       
      </em>
     
     
      
       :
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.12 – Configuring the body of the register user request" src="img/B21788_06_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.12 – Configuring the body of the register user request
    
   </p>
   <ol>
    <li value="5">
     
      You can change the properties of the JSON object to
     
     
      
       your liking.
      
     
    </li>
    <li>
     
      Finally, click the
     
     <strong class="bold">
      
       Send
      
     </strong>
     
      button to make
     
     
      
       the request.
      
     
    </li>
   </ol>
   <p>
    
     Upon being executed, we should get a response similar to the one shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .13
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.13: Registering a new user using ASP.NET Core Identity" src="img/B21788_06_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.13: Registering a new user using ASP.NET Core Identity
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .13
     
    </em>
    
     displays an
    
    <a id="_idIndexMarker485">
    </a>
    
     HTTP status code of 200, informing us that the request was successful and that a new user has been registered in
    
    
     
      the database.
     
    
   </p>
   <p>
    
     At this point, we must log in.
    
    
     We’ll do so using Postman.
    
    
     Create a new HTTP request and perform the following steps to configure
    
    
     
      the request:
     
    
   </p>
   <ol>
    <li>
     
      Set the request type
     
     
      
       to
      
     
     
      <strong class="bold">
       
        POST
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Set the URL
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        http://localhost:&lt;port&gt;/login
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Select the
     
     <strong class="bold">
      
       Body
      
     </strong>
     
      tab, then the
     
     <strong class="bold">
      
       raw
      
     </strong>
     
      option, and add the
     
     
      
       following JSON:
      
     
     <pre class="source-code">
{
  "email": "myuser@myemail.com",
  "password": "P4$$word"
}</pre>
    </li>
    <li>
     
      Click the
     
     
      <strong class="bold">
       
        Send
       
      </strong>
     
     
      
       button.
      
     
    </li>
    <li>
     
      Make sure you’ve added the JSON parameters according to the user data you created in
     
     
      
       your environment.
      
     
    </li>
    <li>
     
      Upon performing
     
     <a id="_idIndexMarker486">
     </a>
     
      the request, you should see the
     
     
      
       following response:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 6.14 – Getting a login response" src="img/B21788_06_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.14 – Getting a login response
    
   </p>
   <p>
    
     In response to the login request, we can see that a JSON object with some important properties has
    
    
     
      been returned:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       tokenType
      
     </strong>
     
      : This value will always be
     
     <strong class="source-inline">
      
       Bearer
      
     </strong>
     
      , which indicates that this response provides a
     
     <strong class="source-inline">
      
       Bearer
      
     </strong>
     
      token in the form of an opaque
     
     <strong class="source-inline">
      
       accessToken
      
     </strong>
     
      , as we configured in the
     
     
      <strong class="source-inline">
       
        Program.cs
       
      </strong>
     
     
      
       file.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       accessToken
      
     </strong>
     
      : This is the token that’s generated for the authenticated user.
     
     
      It must be sent as part of the authorization
     
     
      
       request header.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       expiresIn
      
     </strong>
     
      : A value in seconds that represents the expiration time
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        accessToken
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       refreshToken
      
     </strong>
     
      : If set, we can obtain a new
     
     <strong class="source-inline">
      
       access_token
      
     </strong>
     
      value upon expiration by using a refresh endpoint without having to re-enter
     
     
      
       user credentials.
      
     
    </li>
   </ul>
   <p>
    
     The values displayed in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .14
     
    </em>
    
     will be
    
    <a id="_idIndexMarker487">
    </a>
    
     different for each request and don’t represent a
    
    <strong class="bold">
     
      JWT
     
    </strong>
    
     .
    
    
     The
    
    <strong class="bold">
     
      access token
     
    </strong>
    
     is generated and encrypted in a proprietary way in this version of
    
    <a id="_idIndexMarker488">
    </a>
    
     ASP.NET Core Identity and doesn’t follow a known convention.
    
    
     However, it’s possible to change to a
    
    <strong class="bold">
     
      JWT
     
    </strong>
    
     if you wish, as well as other configuration parameters of the token
    
    
     
      generation process.
     
    
   </p>
   <p class="callout-heading">
    
     ASP.NET Core Identity configurations
    
   </p>
   <p class="callout">
    
     ASP.NET Core Identity offers different authentication options, including
    
    <a id="_idIndexMarker489">
    </a>
    
     JWT (
    
    <a href="https://jwt.io/introduction">
     
      https://jwt.io/introduction
     
    </a>
    
     ), cookies, and other settings.
    
    
     To learn more about the different configuration options, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.identity.identityoptions?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     However, the token-based approach we’re using, even though it doesn’t involve a JWT, uses the same configuration process as a request being made with the authenticated user’s credentials.
    
    
     In the next section, we’ll use the
    
    <strong class="bold">
     
      access token
     
    </strong>
    
     value to make a request on the
    
    <strong class="source-inline">
     
      /accounts
     
    </strong>
    
     route and obtain a
    
    
     
      valid response.
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor110">
    </a>
    
     Requesting an API with the access token
    
   </h2>
   <p>
    
     The access token
    
    <a id="_idIndexMarker490">
    </a>
    
     contains the authenticated user’s information in
    
    
     
      encrypted form.
     
    
   </p>
   <p>
    
     For us to make a valid request on the
    
    <strong class="source-inline">
     
      /accounts
     
    </strong>
    
     route, we’ll need to pass the token as a parameter in the request header.
    
    
     So, copy the access token value and, in Postman, open the tab that contains the request, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .11
     
    </em>
    
     , for the
    
    <strong class="source-inline">
     
      /accounts
     
    </strong>
    
     route.
    
    
     Then, perform the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="bold">
      
       GET
      
     </strong>
     
      request tab for the
     
     <strong class="source-inline">
      
       /accounts
      
     </strong>
     
      route, click on the
     
     
      <strong class="bold">
       
        Authorization
       
      </strong>
     
     
      
       tab.
      
     
    </li>
    <li>
     
      For
     
     <strong class="bold">
      
       Type
      
     </strong>
     
      , select the
     
     <strong class="bold">
      
       Bearer
      
     </strong>
     
      <strong class="bold">
       
        Token
       
      </strong>
     
     
      
       option.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="bold">
      
       Token
      
     </strong>
     
      field, paste the value of the access token that you obtained via the
     
     
      
       login request.
      
     
    </li>
    <li>
     
      Click the
     
     
      <strong class="bold">
       
        Send
       
      </strong>
     
     
      
       button.
      
     
    </li>
   </ol>
   <p>
    
     As shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    <em class="italic">
     
      .15
     
    </em>
    
     , an empty
    
    <a id="_idIndexMarker491">
    </a>
    
     array is returned since no accounts have been registered in the database.
    
    
     Note that the HTTP status code is
    
    <strong class="bold">
     
      200
     
    </strong>
    
     , which means that it was a
    
    
     
      successful request:
     
    
   </p>
   <div><div><img alt="Figure 6.15 – Successful accounts request" src="img/B21788_06_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.15 – Successful accounts request
    
   </p>
   <p>
    
     So far, the application is working as expected.
    
    
     However, it’s important to understand how this authorization
    
    
     
      process works.
     
    
   </p>
   <p>
    
     When requesting the account route again, we inform the access token, as configured previously.
    
    
     Despite Postman having a user-friendly UI, when selecting the authentication type and entering the access token, Postman automatically adds an HTTP header.
    
    
     HTTP headers are key/value pairs that are part of requests
    
    
     
      and responses.
     
    
   </p>
   <p>
    
     For this request, the header was created with the authorization key and the access token value.
    
    
     You can check this header by clicking on the
    
    <strong class="bold">
     
      Headers
     
    </strong>
    
     tab and viewing the hidden headers, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .16
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.16 – The authorization HTTP header" src="img/B21788_06_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.16 – The authorization HTTP header
    
   </p>
   <p>
    
     When making the
    
    <a id="_idIndexMarker492">
    </a>
    
     request, the authentication and authorization
    
    <strong class="bold">
     
      middleware
     
    </strong>
    
     comes
    
    <a id="_idIndexMarker493">
    </a>
    
     into action.
    
    
     The authentication middleware reads the token that was informed in the authorization header and fills in the user credentials for the request in
    
    <a id="_idIndexMarker494">
    </a>
    
     the
    
    <strong class="bold">
     
      HttpContext.User
     
    </strong>
    
     object, which is part of the request.
    
    
     This object allows us to access information such as
    
    <strong class="bold">
     
      claims
     
    </strong>
    
     , which
    
    <a id="_idIndexMarker495">
    </a>
    
     contain data such as the user’s name and email, and
    
    <strong class="bold">
     
      roles
     
    </strong>
    
     , which
    
    <a id="_idIndexMarker496">
    </a>
    
     allow us to determine the user’s access type, such as admin, member, and
    
    
     
      so on.
     
    
   </p>
   <p class="callout-heading">
    
     The ASP.NET Core 9 HttpContext object
    
   </p>
   <p class="callout">
    
     In ASP.NET Core,
    
    <strong class="source-inline">
     
      HttpContext.User
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker497">
    </a>
    
     core property that represents the user security context associated with an HTTP request.
    
    
     This property is an instance of
    
    <strong class="source-inline">
     
      ClaimsPrincipal
     
    </strong>
    
     , a .NET class that contains the user’s identity in the form of claims.
    
    <strong class="source-inline">
     
      HttpContext.User
     
    </strong>
    
     is a key element in handling user authentication and authorization in an ASP.NET
    
    
     
      Core application.
     
    
   </p>
   <p class="callout">
    
     During the authentication process, when a request arrives at the application, the authentication middleware reads the authentication tokens or cookies attached to the request, validates them, and constructs a
    
    <strong class="source-inline">
     
      ClaimsPrincipal
     
    </strong>
    
     object.
    
    
     The
    
    <strong class="source-inline">
     
      ClaimsPrincipal
     
    </strong>
    
     object can contain one or more instances
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       ClaimsIdentity
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout">
    
     Each
    
    <strong class="source-inline">
     
      ClaimsIdentity
     
    </strong>
    
     instance can contain multiple claims.
    
    
     A claim is a statement about a subject that’s been made by an issuer and can represent the user’s identity attributes, such as name, role, email,
    
    
     
      and more.
     
    
   </p>
   <p class="callout">
    
     This process allows the use of
    
    <strong class="source-inline">
     
      HttpContext.User
     
    </strong>
    
     in application-wide authorization checks to determine whether the current user has permission to perform certain operations to ensure that only properly authenticated and authorized users can access certain resources or perform
    
    
     
      specific actions.
     
    
   </p>
   <p class="callout">
    
     The following code shows the
    
    <a id="_idIndexMarker498">
    </a>
    
     use of
    
    <strong class="source-inline">
     
      HttpContext.User
     
    </strong>
    
     when executing an action.
    
    
     This object is automatically populated by the execution pipeline
    
    
     
      through middleware:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      public
     
    </strong>
    
     <strong class="source-inline">
      
       IActionResult ExampleAction(){
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var user =
     
    </strong>
    
     <strong class="source-inline">
      
       HttpContext.User;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      if (user.Identity.IsAuthenticated)     {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      // Do something for
     
    </strong>
    
     <strong class="source-inline">
      
       authenticated users
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      var userName =
     
    </strong>
    
     <strong class="source-inline">
      
       user.Identity.Name;
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      // Get the
     
    </strong>
    
     <strong class="source-inline">
      
       user's name
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      return
     
    </strong>
    
     <strong class="source-inline">
      
       Content($"Welcome, {userName}");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
     
    </strong>
    
     <strong class="source-inline">
      
       else
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      {
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      // Handle
     
    </strong>
    
     <strong class="source-inline">
      
       non-authenticated users
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      return Unauthorized("You must be logged in to
     
    </strong>
    
     <strong class="source-inline">
      
       access this.");
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     You can learn more
    
    <a id="_idIndexMarker499">
    </a>
    
     about
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-context?view=aspnetcore-8.0#httpcontext-user
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Authorization middleware
    
    <a id="_idIndexMarker500">
    </a>
    
     analyzes whether the requested route requires authorization.
    
    
     If so, it decrypts the token, analyzes whether it’s a valid token, and allows the request on the route to be
    
    
     
      made correctly.
     
    
   </p>
   <p class="callout-heading">
    
     What is middleware?
    
   </p>
   <p class="callout">
    
     During the execution
    
    <a id="_idIndexMarker501">
    </a>
    
     flow of a request in ASP.NET Core 9, several types of processes are carried out, such as identifying the route to be executed, among other functionalities.
    
    
     This flow is called a pipeline.
    
    
     In
    
    <a id="_idIndexMarker502">
    </a>
    
     some cases, there’s a need to add functionality to the execution pipeline.
    
    
     This is done through middleware, something we implemented by adding the
    
    <strong class="source-inline">
     
      app.UseAuthtentication()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      app.UseAuthorization()
     
    </strong>
    
     method calls to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file, which allows us to pre-process the request for authentication and authorization requirements.
    
    
     Through middleware, it’s possible to add functionality to both requests
    
    
     
      and responses.
     
    
   </p>
   <p class="callout">
    
     We’ll learn more about middleware in
    
    <a href="B21788_08.xhtml#_idTextAnchor132">
     
      <em class="italic">
       
        Chapter 8
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     With each API request, the token is sent so that the user information and their respective accesses are loaded during the request execution flow.
    
    
     This is a characteristic of cloud-native applications.
    
    
     The stateless approach allows applications to be scalable and resilient and ensures the server doesn’t retain any information about a client’s state between requests, eliminating the need to manage session state.
    
    
     This leads to easier scaling and load balancing, makes it easier to scale servers when the need arises to handle high user demand, and allows each server instance to be able to handle any request without needing to know the context of
    
    
     
      previous requests.
     
    
   </p>
   <p>
    
     By not relying on server-side state, developers can avoid issues related to session management, such as session persistence, synchronization across distributed systems, and
    
    
     
      resource locking.
     
    
   </p>
   <p>
    
     Modern applications must have security as a premise by design, and the implementation of authentication and authorization has several advantages within the context of applications.
    
    
     However, other aspects related to security are linked not only to the functionalities available to users but also to the application’s source code.
    
    
     In the next section, we’ll learn how to reinforce security
    
    
     
      in applications.
     
    
   </p>
   <h1 id="_idParaDest-110">
    <a id="_idTextAnchor111">
    </a>
    
     Strengthening application security
    
   </h1>
   <p>
    
     For us to be
    
    <a id="_idIndexMarker503">
    </a>
    
     able to create secure web-based applications, we must go beyond implementing the use of a security layer based on authentication and authorization, something we implemented when using ASP.NET
    
    
     
      Core Identity.
     
    
   </p>
   <p>
    
     ASP.NET Core 9 allows us to deal with security as a premise when developing applications, providing tools and mechanisms that facilitate the implementation of features that minimize possible loopholes, something that can generate attacks from
    
    
     
      malicious users.
     
    
   </p>
   <p>
    
     Let’s learn about some good security practices that should be part of every software engineer’s toolbox.
    
    
     We’ll start by understanding how we can improve the process of managing sensitive configurations in our
    
    
     
      development environment.
     
    
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor112">
    </a>
    
     Managing secrets properly
    
   </h2>
   <p>
    
     Every application has
    
    <a id="_idIndexMarker504">
    </a>
    
     configurations and some of these can be sensitive, such as database connections, encryption keys, and even security keys for accessing
    
    
     
      external resources.
     
    
   </p>
   <p>
    
     So far, we’ve learned that it’s good practice to keep such settings separate from the C# source code and that we can manage settings through files such as
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     and even environment variables.
    
    
     ASP.NET Core 9 allows us to handle external
    
    
     
      configuration management.
     
    
   </p>
   <p>
    
     Keeping the settings hard-coded is a bad practice since to change any hard-coded parameter, we must recompile the application.
    
    
     In addition, there’s the possibility of malicious users decompiling the application if they have access to the binaries, and then obtaining
    
    
     
      sensitive data.
     
    
   </p>
   <p class="callout-heading">
    
     Obfuscator
    
   </p>
   <p class="callout">
    
     Code obfuscation
    
    <a id="_idIndexMarker505">
    </a>
    
     refers to the process of transforming application source code into a form that’s difficult for humans to understand but can still be executed by a computer.
    
    
     This technique is primarily used to protect intellectual property by making it difficult for attackers or unauthorized users to reverse engineer the code and understand
    
    
     
      its logic.
     
    
   </p>
   <p class="callout">
    
     The process of obfuscation involves several techniques, such as renaming variables and methods to meaningless symbols, removing metadata, encrypting strings, and altering the control flow to make the code more
    
    <a id="_idIndexMarker506">
    </a>
    
     complex.
    
    
     For more information, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022">
     
      
       https://learn.microsoft.com/en-us/visualstudio/ide/dotfuscator/?view=vs-2022
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Imagine a situation where our
    
    <a id="_idIndexMarker507">
    </a>
    
     application uses an API key to connect to a payment gateway to process transactions from an online store, or even the database connection string.
    
    
     If this key is exposed, malicious users can potentially manipulate transaction data, access sensitive information, and even delete
    
    
     
      your database.
     
    
   </p>
   <p>
    
     You might be thinking that since your code is in a private repository, and all settings are being kept in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     files, this problem
    
    
     
      is solved.
     
    
   </p>
   <p>
    
     Of course, since it’s a private repository, the chances of an attacker gaining access to the data aren’t very high.
    
    
     However, consider that your company may work with employees and third-party companies that can access the data in
    
    
     
      your repository.
     
    
   </p>
   <p>
    
     While it’s good practice to manage settings in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     files, this isn’t a good approach for sensitive information.
    
    
     With this, we avoid synchronizing the source code of applications with external repositories containing information that shouldn’t
    
    
     
      be shared.
     
    
   </p>
   <p>
    
     Fortunately, ASP.NET Core 9 implements the best development practices and provides secret management in your local environment.
    
    
     Proper secret management ensures that sensitive data, such as API keys, isn’t hard-coded into your application’s source code but is stored and accessed securely, protecting your infrastructure and
    
    
     
      data integrity.
     
    
   </p>
   <p>
    
     The Secret Manager tool
    
    <a id="_idIndexMarker508">
    </a>
    
     is included in the .NET Core SDK, so you typically don’t need to install anything else if you have
    
    
     
      the SDK.
     
    
   </p>
   <p>
    
     To start using Secret Manager, you need to initialize it for your project.
    
    
     Navigate to the project’s
    
    <strong class="source-inline">
     
      WorkingWithIdentity
     
    </strong>
    
     directory, which we worked on previously, in the Command Prompt or terminal where your
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     file is located.
    
    
     Then, run the following command to initialize
    
    
     
      secret storage:
     
    
   </p>
   <pre class="console">
dotnet user-secrets init</pre>
   <p>
    
     The preceding command adds a
    
    <strong class="source-inline">
     
      UserSecretsId
     
    </strong>
    
     element within a
    
    <strong class="source-inline">
     
      PropertyGroup
     
    </strong>
    
     value to your
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     (project file).
    
    
     This ID uniquely identifies your
    
    
     
      project’s secrets.
     
    
   </p>
   <p>
    
     You can verify the addition of the
    
    <strong class="source-inline">
     
      UserSecretsId
     
    </strong>
    
     element by opening the
    
    <strong class="source-inline">
     
      .csproj
     
    </strong>
    
     file in your code editor, as shown in
    
    
     <em class="italic">
      
       Figure 6
      
     </em>
    
    
     <em class="italic">
      
       .17
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 6.17 – The UserSecretsId element configured in the .csproj file" src="img/B21788_06_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 6.17 – The UserSecretsId element configured in the .csproj file
    
   </p>
   <p>
    
     Next, we’ll configure the
    
    <a id="_idIndexMarker509">
    </a>
    
     connection string with the SQL Server database.
    
    
     To do this, we must add some new code by executing the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet user-secrets set "ConnectionStrings:BankingDbContext" "YOUR DATABASE CONNECTION STRING"</pre>
   <p class="callout-heading">
    
     Secrets naming convention
    
   </p>
   <p class="callout">
    
     The notation commonly uses colons (
    
    <strong class="source-inline">
     
      :
     
    </strong>
    
     ) to separate different levels of a hierarchy in the key names of secrets.
    
    
     This structure not only helps in organizing the keys logically but also aligns with how the ASP.NET Core 9 configuration system retrieves values from various configuration sources, such as
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     , environment variables, and
    
    
     
      Secret Manager.
     
    
   </p>
   <p class="callout">
    
     In the
    
    <strong class="source-inline">
     
      WorkingWithIdentity
     
    </strong>
    
     application, we have the following configuration in the
    
    
     <strong class="source-inline">
      
       appsettings.json
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       ConnectionStrings" {
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      "
     
    </strong>
    
     <strong class="source-inline">
      
       BankingDbContext": "..."
      
     </strong>
    
   </p>
   <p class="callout">
    <strong class="source-inline">
     
      }
     
    </strong>
   </p>
   <p class="callout">
    
     The preceding JSON represents a property of the
    
    <strong class="source-inline">
     
      object
     
    </strong>
    
     type called
    
    <strong class="source-inline">
     
      ConnectionStrings
     
    </strong>
    
     that has a string property
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       BankingDbContext
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p class="callout">
    
     Based on this, the secret is called
    
    <strong class="source-inline">
     
      ConnectionStrings:BankingDbContext
     
    </strong>
    
     .
    
    
     Here,
    
    <strong class="source-inline">
     
      ConnectionStrings
     
    </strong>
    
     is the top-level category and
    
    <strong class="source-inline">
     
      BankingDbContext
     
    </strong>
    
     is the actual key containing the respective secret – in this case, the SQL Server database connection string.
    
    
     This notation helps to logically group
    
    
     
      related settings.
     
    
   </p>
   <p class="callout">
    
     Since this is a convention used by ASP.NET Core 9, there’s no need to change the application’s source code to obtain the database
    
    
     
      connection string.
     
    
   </p>
   <p class="callout">
    
     When using environment variables (which don’t allow colons in variable names on some operating systems), colon separators are typically replaced with double underscores (
    
    <strong class="source-inline">
     
      __
     
    </strong>
    
     ).
    
    
     So, if you were defining these secrets via environment variables in a production environment, you would define them
    
    
     
      like this:
     
    
   </p>
   <p class="callout">
    
     <strong class="source-inline">
      
       ConnectionStrings__BankingDbContext
      
     </strong>
    
   </p>
   <p class="callout">
    
     This naming convention ensures that when the ASP.NET Core configuration system reads the environment variables, it can reconstruct the hierarchy and treat them equivalently to secrets defined in
    
    <strong class="source-inline">
     
      appsettings.json
     
    </strong>
    
     or
    
    
     
      Secret Manager.
     
    
   </p>
   <p>
    
     There’s no need to change the
    
    <a id="_idIndexMarker510">
    </a>
    
     application code to obtain the secret since this is a feature of ASP.NET Core 9 and works in the same way if you want to use
    
    
     
      environment variables.
     
    
   </p>
   <p>
    
     The secret that’s created is kept in the operating system; its location may vary from environment to environment.
    
    
     However, you can manage secrets using the
    
    <strong class="source-inline">
     
      user-secrets
     
    </strong>
    
     tool.
    
    
     For example, you can use it to list the secrets that exist on your
    
    
     
      local machine:
     
    
   </p>
   <pre class="console">
dotnet user-secrets list</pre>
   <p>
    
     You can use the following command to remove a
    
    
     
      specific secret:
     
    
   </p>
   <pre class="console">
dotnet user-secrets remove "ConnectionStrings:BankingDbContext"</pre>
   <p>
    
     You can even clear
    
    
     
      all secrets:
     
    
   </p>
   <pre class="console">
dotnet user-secrets clear</pre>
   <p>
    
     All secrets information is kept in your operating system.
    
    
     When integrating the source code with your remote code repository, the secrets won’t
    
    
     
      be shared.
     
    
   </p>
   <p>
    
     Keep in mind that the
    
    <a id="_idIndexMarker511">
    </a>
    
     Secret Manager tool is intended for development purposes only.
    
    
     For production environments, you should use a secure vault such
    
    <a id="_idIndexMarker512">
    </a>
    
     as
    
    <strong class="bold">
     
      Azure Key Vault
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      AWS Secrets Manager
     
    </strong>
    
     , or another secure means of managing sensitive
    
    <a id="_idIndexMarker513">
    </a>
    
     configuration data.
    
    
     We’ll learn more about configuration management in
    
    <a href="B21788_09.xhtml#_idTextAnchor146">
     
      <em class="italic">
       
        Chapter 9
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Now that we know how to better manage application secrets, let’s learn about other good security
    
    <a id="_idIndexMarker514">
    </a>
    
     practices, including
    
    <a id="_idIndexMarker515">
    </a>
    
     the use of
    
    <strong class="bold">
     
      Hypertext Transfer Protocol Secure
     
    </strong>
    
     (
    
    <strong class="bold">
     
      HTTPS
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Cross-Origin Resource
     
    </strong>
    
     <strong class="bold">
      
       Sharing
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="bold">
      
       CORS
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor113">
    </a>
    
     Enforcing HTTPS and working with CORS
    
   </h2>
   <p>
    
     HTTPS enforcement
    
    <a id="_idIndexMarker516">
    </a>
    
     is important for ensuring secure communication between clients and servers by encrypting data transmitted over the network.
    
    
     As we’ve already learned, ASP.NET Core 9 provides us with integrated middleware to enforce HTTPS, which can be configured to redirect all HTTP requests
    
    
     
      to HTTPS.
     
    
   </p>
   <p>
    
     To enforce HTTPS in an ASP.NET Core 9 application, simply add the following line of code to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file to add a middleware to the application’s
    
    
     
      execution pipeline:
     
    
   </p>
   <pre class="source-code">
// Enforce HTTPS
app.UseHttpsRedirection();</pre>
   <p>
    
     It’s important to know that adding the middleware that enforces the use of HTTPS is a configuration step for the application.
    
    
     Likewise, you must also configure your web server (for example, IIS, NGINX, Azure
    
    <a id="_idIndexMarker517">
    </a>
    
     App Services, and so on) to enforce HTTPS and obtain a valid SSL/TLS certificate from a trusted
    
    
     
      certificate authority.
     
    
   </p>
   <p>
    
     In addition to enforcing HTTPS, you
    
    <a id="_idIndexMarker518">
    </a>
    
     can configure
    
    <strong class="bold">
     
      CORS
     
    </strong>
    
     , a feature that’s implemented by browsers to restrict web applications running on one origin from accessing resources on a different origin without explicit permission.
    
    
     It’s more common to see this type of behavior in SPA applications that use technologies such
    
    <a id="_idIndexMarker519">
    </a>
    
     as
    
    <strong class="bold">
     
      Angular
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      React
     
    </strong>
    
     , or
    
    <a id="_idIndexMarker520">
    </a>
    
     even
    
    <a id="_idIndexMarker521">
    </a>
    
     pure
    
    <strong class="bold">
     
      JavaScript
     
    </strong>
    
     .
    
    
     When making an HTTP request through JavaScript, it’s executed in the browser, which, through the security mechanism, doesn’t allow a request on one origin server to be made to another server where the resource is hosted.
    
    
     Fortunately, ASP.NET Core 9 provides middleware to configure and manage CORS policies, allowing you to specify which origins, headers, and methods are allowed.
    
    
     This feature is interesting because we can only respond to certain requests based on a
    
    
     
      specific origin.
     
    
   </p>
   <p>
    
     To enable and configure
    
    <a id="_idIndexMarker522">
    </a>
    
     CORS in an ASP.NET Core 9 application, you can add the following code to the
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
// Add services to the container.
builder.Services.AddRazorPages();
// Configure CORS policy
<strong class="bold">builder.Services.AddCors(options =&gt;</strong>
<strong class="bold">{</strong>
<strong class="bold">    options.AddPolicy("AllowSpecificOrigin",</strong>
<strong class="bold">        builder =&gt;</strong>
<strong class="bold">        {</strong>
<strong class="bold">            builder.WithOrigins("https://myapp.com")</strong>
<strong class="bold">                   .AllowAnyHeader()</strong>
<strong class="bold">                   .AllowAnyMethod();</strong>
<strong class="bold">        });</strong>
<strong class="bold">});</strong>
var app = builder.Build();
// Enforce HTTPS
app.UseHttpsRedirection();
// Use CORS policy
<strong class="bold">app.UseCors("AllowSpecificOrigin");</strong>
app.UseStaticFiles();
app.UseRouting();
app.UseAuthorization();
app.MapRazorPages();
app.Run();</pre>
   <p>
    
     Let’s understand the
    
    
     
      preceding code:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       builder.Services.AddCors(options =&gt; { ...
      
      
       })
      
     </strong>
     
      : This line adds CORS services
     
     <a id="_idIndexMarker523">
     </a>
     
      to the application’s dependency injection container.
     
     
      The
     
     <strong class="source-inline">
      
       options
      
     </strong>
     
      parameter, which is of the
     
     <strong class="source-inline">
      
       Action&lt;CorsOptions&gt;
      
     </strong>
     
      type, allows you to configure
     
     
      
       CORS policies.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       options.AddPolicy
      
     </strong>
     
      : In this line, we’re adding a new policy named
     
     <strong class="source-inline">
      
       AllowSpecificOrigin
      
     </strong>
     
      .
     
     
      The
     
     <strong class="source-inline">
      
       builder
      
     </strong>
     
      parameter in the Lambda expression is an instance of the
     
     <strong class="source-inline">
      
       CorsPolicyBuilder
      
     </strong>
     
      class, which provides methods to configure
     
     
      
       the policy.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       builder.WithOrigins("https://myapp.com")
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       WithOrigins
      
     </strong>
     
      method defines the origins that are allowed to access the application’s resources.
     
     
      In this case, any requests coming from
     
     <strong class="source-inline">
      
       https://myapp.com
      
     </strong>
     
      will be allowed by this
     
     
      
       CORS policy.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       AllowAnyHeader()
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       AllowAnyHeader
      
     </strong>
     
      method allows any HTTP headers in the request, allowing the specified origin to include any headers without being blocked by the
     
     
      
       CORS policy.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       AllowAnyMethod()
      
     </strong>
     
      : This method defines that any HTTP methods (
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       PUT
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       DELETE
      
     </strong>
     
      , and others) can be used in
     
     
      
       the request.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       app.UseCors("AllowSpecificOrigin")
      
     </strong>
     
      : This triggers the CORS middleware in the
     
     <a id="_idIndexMarker524">
     </a>
     
      request pipeline, referencing the previously created policy globally to all HTTP requests of
     
     
      
       the application.
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Learn more about CORS
    
   </p>
   <p class="callout">
    
     As defined earlier, CORS is
    
    <a id="_idIndexMarker525">
    </a>
    
     an HTTP header-based mechanism that lets you tell the browser which origins can load resources.
    
    
     ASP.NET Core 9 has an excellent framework for implementing CORS in your applications.
    
    
     To learn more, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The preceding example illustrates the use of CORS in an ASP.NET Core 9 application.
    
    
     However, apart from the origin, it doesn’t have restrictions on the use of HTTP headers or methods.
    
    
     In some cases, it will be necessary to explicitly define the HTTP headers and methods that an origin
    
    
     
      can access.
     
    
   </p>
   <p>
    
     However, the features available in ASP.NET Core 9 give us great flexibility in defining different policies for different origins, creating more restricted and specific rules for CORS.
    
    
     This is an important mechanism since the browser uses it to allow SPAs or other applications running on the client to be able to consume external
    
    
     
      resources appropriately.
     
    
   </p>
   <p>
    
     CORS is not a
    
    <a id="_idIndexMarker526">
    </a>
    
     security mechanism, but its use is recommended.
    
    
     In the next section, we’ll talk about some security mechanisms we can use to prevent vulnerabilities
    
    
     
      in applications.
     
    
   </p>
   <h2 id="_idParaDest-113">
    <a id="_idTextAnchor114">
    </a>
    
     Preventing common vulnerabilities
    
   </h2>
   <p>
    
     When we talk about vulnerabilities
    
    <a id="_idIndexMarker527">
    </a>
    
     in applications, several topics can be taken into consideration, such as source code, servers, credential management, protocols used, and encryption,
    
    
     
      among others.
     
    
   </p>
   <p>
    
     Some common vulnerabilities are already well known, but if they aren’t addressed in applications, they can cause some problems for organizations.
    
    
     ASP.NET Core 9 offers mechanisms for dealing with several common threats in
    
    
     
      web applications:
     
    
   </p>
   <ul>
    <li>
     
      
       SQL injection
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cross-site
      
     </strong>
     
      <strong class="bold">
       
        scripting
       
      </strong>
     
     
      
       (
      
     
     
      <strong class="bold">
       
        XSS
       
      </strong>
     
     
      
       )
      
     
    </li>
    <li>
     <strong class="bold">
      
       Cross-site request
      
     </strong>
     
      <strong class="bold">
       
        forgery
       
      </strong>
     
     
      
       (
      
     
     
      <strong class="bold">
       
        CSRF
       
      </strong>
     
     
      
       )
      
     
    </li>
   </ul>
   <p>
    
     Let’s learn how to prevent each of
    
    
     
      these vulnerabilities.
     
    
   </p>
   <h3>
    
     SQL injection
    
   </h3>
   <p>
    
     SQL injection is a
    
    <a id="_idIndexMarker528">
    </a>
    
     common attack where an attacker inserts malicious SQL code into an
    
    
     
      SQL query.
     
    
   </p>
   <p>
    
     To prevent SQL injection, always use
    
    <a id="_idIndexMarker529">
    </a>
    
     parameterized queries or ORM frameworks such as Entity Framework, which handle query parameters safely and help us avoid string concatenation.
    
    
     We learned about this in the
    
    <em class="italic">
     
      Security topics in web
     
    </em>
    
     <em class="italic">
      
       applications
      
     </em>
    
    
     
      section.
     
    
   </p>
   <h3>
    
     XSS
    
   </h3>
   <p>
    
     XSS attacks
    
    <a id="_idIndexMarker530">
    </a>
    
     occur when an attacker injects malicious scripts into a web page.
    
    
     To prevent XSS, always encode or escape user input before rendering it in the browser.
    
    
     This way, if there’s any code injection in an input, for example, it will be encoded with special characters.
    
    
     ASP.NET Core 9 provides built-in helpers to sanitize the output, as shown in the
    
    
     
      following example:
     
    
   </p>
   <pre class="source-code">
@{
var inputSimulator = "&lt;script&gt;
  alert('Injected Code');&lt;/script&gt;";
}
&lt;p&gt;@inputSimulator&lt;/p&gt;
// output: &amp;lt;script&amp;gt;alert('Injected Code');&amp;lt;/script&amp;gt;</pre>
   <p>
    
     In the
    
    <a id="_idIndexMarker531">
    </a>
    
     preceding example, the JavaScript code was encoded, preventing the injected code from being sent and executed since, after encoding, it becomes just a string.
    
    
     To learn more about the vulnerabilities associated with XSS, go
    
    
     
      to
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/security/cross-site-scripting?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <h3>
    
     CSRF
    
   </h3>
   <p>
    
     CSRF
    
    <a id="_idIndexMarker532">
    </a>
    
     is a type of security attack in which a malicious website tricks a user’s browser into performing actions on another website where the user is authenticated, without the user’s knowledge.
    
    
     This can lead to unauthorized actions such as changing settings, transferring funds, or making purchases.
    
    
     ASP.NET Core provides built-in anti-forgery tokens to prevent CSRF attacks.
    
    
     These tokens are automatically included in forms and validated on
    
    
     
      the server.
     
    
   </p>
   <p>
    
     To use anti-forgery tokens in a simplified way in Razor Pages or MVC, add the following code to
    
    
     
      your form:
     
    
   </p>
   <pre class="source-code">
&lt;form method="post"&gt;
@Html.AntiForgeryToken()
&lt;!-- Form fields --&gt;
&lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;</pre>
   <p>
    
     At this point, we
    
    <a id="_idIndexMarker533">
    </a>
    
     must add the
    
    <strong class="source-inline">
     
      ValidateAntiForgeryToken
     
    </strong>
    
     attribute to the action that will process the form request, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
[ValidateAntiForgeryToken]
public IActionResult SubmitForm()
{
  // Process the form submission
  return View();
}</pre>
   <p>
    
     ASP.NET Core 9 also
    
    <a id="_idIndexMarker534">
    </a>
    
     ¢provides other mechanisms for dealing with this vulnerability.
    
    
     You can learn more
    
    
     
      at
     
    
    <a href="https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0">
     
      
       https://learn.microsoft.com/en-us/aspnet/core/security/anti-request-forgery?view=aspnetcore-9.0
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     As we’ve learned, applications can contain several vulnerabilities that aren’t only associated with the source code but also with the hosting server, communication protocol, and
    
    
     
      many others.
     
    
   </p>
   <p>
    
     In any case, the ASP.NET Core 9 platform provides several mechanisms and best practices that, combined and related to the requirements of the applications, allow us to minimize risks and keep our solutions robust, secure, and reliable while following the best practices of modern applications.
    
    
     As we progress through this book, we’ll learn about more mechanisms and approaches we can use to create increasingly
    
    
     
      robust applications.
     
    
   </p>
   <h1 id="_idParaDest-114">
    <a id="_idTextAnchor115">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we learned about the principles of web application security and how they influence the development model and the interaction with users and other applications.
    
    
     In addition, we learned about the authorization and authentication processes, comparing the flows of these processes and getting to know standards such as OAuth 2.0 and OIDC.
    
    
     To reinforce our knowledge about authentication and authorization, we worked with ASP.NET Core Identity, which provides all the mechanisms that support user authentication and authorization in an application, integrated with a database for managing identities securely.
    
    
     To do so, we consumed information securely by providing tokens provided by ASP.NET Core Identity.
    
    
     Finally, we discussed how to strengthen the security of applications, understood secret management, and learned about techniques such as the use of CORS to prevent common vulnerabilities in
    
    
     
      web applications.
     
    
   </p>
   <p>
    
     In the next chapter, we’ll learn how to add more capabilities to applications, understand how to implement best practices, and learn how to use caching
    
    
     
      and monitoring.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-115" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor116">
    </a>
    
     Part 3: Applying Best Practices
    
   </h1>
   <p>
    
     In this section, we assume that you are more familiar with the ASP.NET Core 9 platform and most of the powerful features available in this technology.
    
    
     As we advance in the knowledge of the platform and the need to develop increasingly rich solutions, we must stick to best practices.
    
    
     Therefore, we will cover topics related to the addition of features that interact with the application, including the challenge strategy, resilience, and best practices.
    
    
     We will also learn how to implement monitoring (Logging and Tracing), allowing software engineers the ability to deal with bug fixes, optimizations, and proactive actions.
    
    
     We will also explore the use of Middleware to customize the interaction flow in
    
    
     
      the application.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B21788_07.xhtml#_idTextAnchor117">
      <em class="italic">
       
        Chapter 7
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Adding Capabilities to Applications
      
     </em>
    </li>
    <li>
     <a href="B21788_08.xhtml#_idTextAnchor132">
      <em class="italic">
       
        Chapter 8
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Enhancing Applications with Middleware in ASP.NET Core 9
      
     </em>
    </li>
    <li>
     <a href="B21788_09.xhtml#_idTextAnchor146">
      <em class="italic">
       
        Chapter 9
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Managing Application Settings
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>