- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing State – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we continue to look at managing state. Most applications manage
    state in some form.
  prefs: []
  type: TYPE_NORMAL
- en: A state is simply information that is persisted in some way. It can be data
    stored in a database, session states, or even something stored in a URL.
  prefs: []
  type: TYPE_NORMAL
- en: The user state is stored in memory either in the web browser or on the server.
    It contains the component hierarchy and the most recently rendered UI (render
    tree). It also contains the values or fields and properties in the component instances
    as well as the data stored in service instances in dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: If we make JavaScript calls, the values we set are also stored in memory. Blazor
    Server relies on the circuit (SignalR connection) to hold the user state, and
    Blazor WebAssembly relies on the browser’s memory. But when we have a mix of both
    states, state management becomes a bit trickier. If we reload the page, the circuit
    and the memory will be lost. The same goes for switching pages; if there are no
    more `InteractiveServer` components on the page, the SignalR connection will be
    terminated and the state lost. Managing state is not about handling connections
    or connection issues but rather how we can keep the data even if we reload the
    web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Saving state between page navigations or sessions improves the user experience
    and could be the difference between a sale and no sale. Imagine reloading the
    page and all your items in the shopping cart are gone; the chances are you won’t
    shop there again.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine returning to a page a week or month later and all those things are
    still there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing data on the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data in the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing browser storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an in-memory state container service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root-level cascading values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already talked about and even implemented some of these things. Let’s
    take this opportunity to recap the things we have already talked about, as well
    as introduce some new techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have followed the previous chapters or use the `Chapter10` folder
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s end result a[t https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter11)11.
  prefs: []
  type: TYPE_NORMAL
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added `Auth0` account information in the `Settings` files. You can find the
    instructions in *Chapter 8*, *Authentication and Authorization*.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data on the server side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways in which to store data on the server side. The
    only thing to remember is that Blazor WebAssembly (or `InteractiveWebAssembly`)
    will always need an API. Blazor Server (or `InteractiveServer`) doesn’t need an
    API since we can access the server-side resources directly.
  prefs: []
  type: TYPE_NORMAL
- en: I have had discussions with many developers regarding APIs or direct access,
    which all boils down to what you intend to do with the application. If you are
    building a Blazor Server application and have no interest in moving to Blazor
    WebAssembly, I would probably go for direct access, as we have done in the `MyBlog`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: I would not do direct database queries in the components, though. I would keep
    them in an API, just not a Web API. As we have seen, exposing those API functions
    in an API, as we did in *Chapter 7*, *Creating an API*, does not require a lot
    of steps. We can always start with direct server access and move to an API if
    we want to.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to storing data, we can save it in Blob storage, key-value storage,
    a relational database, a document database, table storage, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is no end to the possibilities. If .NET can communicate with the technology,
    we will be able to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Storing data in the URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, this option might sound horrific but it’s not. Data, in this
    case, can be the blog post ID or the page number if we use paging. Typically,
    the things you want to save in the URL are things you want to be able to link
    to later on, such as blog posts in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a parameter from the URL, we use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The URL is `posts` followed by the page number (for paging through blog posts)
    of the post.
  prefs: []
  type: TYPE_NORMAL
- en: To find that particular route, `PageNumber` must be an integer; otherwise, the
    route won’t be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `public` parameter with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we store data in the URL, we need to make sure to use the `OnParametersSet`
    or `OnParametersSetAsync` method; otherwise, the data won’t get reloaded if we
    change the parameter. If the parameter changes, Blazor won’t run `OnInitializedAsync`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: This is why our `post.razor` component loads the things that change based on
    the parameter in the URL in `OnParametersSet`, and loads the things that are not
    affected by the parameter in `OnInitializedAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use optional parameters by specifying them as nullable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So this route would match “`/post/`" and “`/post/42`", for example.
  prefs: []
  type: TYPE_NORMAL
- en: Route constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we specify what type the parameter should be, this is called a **route
    constraint**. We add a constraint so the match will only happen if the parameter
    value can be converted into the type we specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following constraints are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datetime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guid`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL elements will be converted in to a **C#** object. Therefore, it’s important
    to use an invariant culture when adding them to a URL. string is not part of the
    list because that is the default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Using a query string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only talked about routes that are specified in the `page` directive,
    but we can also read data from the query string.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavigationManager` gives us access to the URI, so by using this code, we can
    access the query string parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We won’t dig deeper into this, but now we know that it is possible to access
    query string parameters if we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also access the `query` parameter using an attribute like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is a bit nicer to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Having data in the URL does not really mean storing the data. If we navigate
    to another page, we need to make sure to include the new URL; otherwise, it would
    be lost. We can use the browser storage instead if we want to store data that
    we don’t need to include every time in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing browser storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The browser has a bunch of different ways of storing data in the web browser.
    They are handled differently depending on what type we use. **Local storage**
    is scoped to the user’s browser window. The data will still be saved if the user
    reloads the page or even closes the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: The data is also shared across tabs. **Session storage** is scoped to the **Browser**
    tab; if you reload the tab, the data will be saved, but if you close the tab,
    the data will be lost. `SessionsStorage` is, in a way, safer to use because we
    avoid risks with bugs that may occur due to multiple tabs manipulating the same
    values in storage.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to access the browser storage, we need to use JavaScript. Luckily,
    we won’t need to write the code ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 5, Microsoft introduced **Protected Browser Storage**, which uses data
    protection in ASP.NET Core and is not available in WebAssembly. We can, however,
    use an open-source library called `Blazored.LocalStorage`, which can be used by
    both Blazor Server and Blazor WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: But we are here to learn new things, right?
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s implement an interface so that we can use both versions in our app,
    depending on which hosting model we are using. There is a problem with this implementation.
    If we are running in `AutoMode`, the state will not be shared between the different
    hosting models. The solution is to stick to `Blazored.LocalStorage` in both implementations.
    But to show the difference between the implementations, we will do both in this
    case. Please note that this is stored in clear text on the user’s computer, so
    be careful with what you store.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need an interface that can read and write to storage:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, create a new folder called `Interfaces`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, create a new class called `IBrowserStorage.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the content in the file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we have an interface containing `get`, `set`, and `delete` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Blazor Server (InteractiveServer)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Blazor Server, we will use protected browser storage:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, add a new folder called `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, create a new class called `BlogProtectedBrowserStorage.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (I realize the naming is overkill, but it will be easier to tell the Blazor
    Server and the Blazor WebAssembly implementation apart because we will soon create
    another one.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the new file and add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the class with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `BlogProtectedBrowserStorage` class implements the `IBrowserStorage` interface
    for protected browser storage. We inject a `ProtectedSessionStorage` instance
    and implement the `set`, `get`, and `delete` methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following just beneath the line ending with `.AddInteractiveWebAssemblyComponents();`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are configuring Blazor to return an instance of `BlogProtectedBrowserStorage`
    when we inject `IBrowserStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the same as we did with the API. We inject different implementations
    depending on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing WebAssembly (InteractiveWebAssembly)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Blazor WebAssembly, we will use `Blazored.SessionStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client`project, add a `NuGet` reference to `Blazored.SessionStorage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new folder called `Services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, create a new class called `BlogBrowserStorage.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the new file and replace the content with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The implementations of `ProtectedBrowserStorage` and `Blazored.SessionStorage`
    are pretty similar to one another. The names of the methods are different but
    the parameters are the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just above `await builder.Build().RunAsync();` add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `AddBlazoredSessionStorage` extension method hooks up everything so that
    we can start using the browser session storage.
  prefs: []
  type: TYPE_NORMAL
- en: Then we add our configuration for `IBrowserStorage`, just as we did with the
    server, but in this case, we return `BlogBrowserStorage` when we ask the dependency
    injection for `IBrowserStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the shared code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also need to implement some code that calls the services we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, open `Pages/Admin/BlogPostEdit.razor`. We
    are going to make a couple of changes to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject `IBrowserStorage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we can only run JavaScript calls when doing an action (like a click)
    or in the `OnAfterRender` method, let’s create an `OnAfterRenderMethod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we load the component and the `Id` is `null`, this means we are editing
    a new file, and then we can check whether we have a file saved in browser storage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This implementation can only have one file in the drafts and only saves new
    posts. If we were to edit an existing post, it would not save those changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need our `UpdateHTML` method to become async. Change the method to look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `Id` on the blog post is `null`, we will store the post in the browser storage.
    Make sure to change all the references from `UpdateHTML` to `UpdateHTMLAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure to await the call as well in the `OnParametersSetAsync` method like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is one problem with this implementation: we are currently prerendering
    our components. When we are prerendering, no connection is made to the web browser.
    There is no state to retrieve. Simply put, we need to disable the prerendering
    on this component to make it work. So, let’s do that!'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `@rendermode InteractiveServer` to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are done. Now it’s time to test the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the project by pressing *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the site (so we can access the admin tools).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Blog posts** followed by **New blog post**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type anything in the boxes, and as soon as we type something in the text area,
    it will save the post to storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Blog posts** (so we navigate away from our blog post).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New blog post** and all the information will still be there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F12* to see the browser developer tools. Click **Application** | **Session
    storage** | **https://localhost:portnumber**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see one post with the key `EditCurrentPost`, and the value of that
    post should be an encrypted string, as seen in *Figure 11.1*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The encrypted protected browser storage ](img/B21849_11_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 11.1: The encrypted protected browser storage'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s test Blazor WebAssembly (InteractiveWebAssembly) next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `EditPost.razor` file again and change `@rendermode @(new InteractiveServerRenderMode(prerender:
    false))` to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might need to clean and rebuild your project to make this work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in to the site (so we can access the admin tools).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Blog posts** and then **New blog post**. You may notice that there is
    a delay between loading the page and the components showing up. This is the initial
    WebAssembly load time to get everything started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type anything in the boxes, and as soon as we type something in the text area,
    it will save the post to storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Blog posts** (so we navigate away from our blog post).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New blog post** and all the information should still be there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *F12* to see the browser developer tools. Click **Application** | **Session
    storage** | **https://localhost:portnumber**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should see one post with the key `EditCurrentPost`, and the value of that
    post should be a JSON string, as seen in *Figure 11.2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to change the data in the storage, it would also change in the application,
    so keep in mind that this is plain text, and the end user can manipulate the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Browser storage that is unprotected ](img/B21849_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Browser storage that is unprotected'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have implemented protected browser storage for Blazor Server and session
    storage for Blazor WebAssembly. The way we can mix and match the hosting model
    where we need it is a really amazing power of .NET 8.
  prefs: []
  type: TYPE_NORMAL
- en: We only have one way left to go through, so let’s make it the most fun.
  prefs: []
  type: TYPE_NORMAL
- en: Using an in-memory state container service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to in-memory state containers, we simply use dependency injection
    to keep the instance of the service in memory for the predetermined time (scoped,
    singleton, or transient).
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 4*, *Understanding Basic Blazor Components*, we discussed how the
    scope of dependency injections differs from Blazor Server and Blazor WebAssembly.
    The big difference for us in this section is the fact that Blazor WebAssembly
    runs inside the web browser and doesn’t have a connection to the server or other
    users.
  prefs: []
  type: TYPE_NORMAL
- en: To show how the in-memory state works, we will do something that might seem
    a bit overkill for a blog but it will be cool to see. When we edit our blog post,
    we will update all the web browsers connected to our blog in real time (I did
    say overkill).
  prefs: []
  type: TYPE_NORMAL
- en: We will have to implement that a bit differently, depending on the host. Let’s
    start with Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing real-time updates on Blazor Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation for Blazor Server can also be used for Blazor WebAssembly.
    Since WebAssembly is running in our browser, it would only notify the users connected
    to the site, which would be just you. But it might be good to know that the same
    thing works in Blazor Server as well as Blazor WebAssembly:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, in the `Interfaces` folder, create an interface
    called `IBlogNotificationService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have an action that we can subscribe to when the blog post is updated and
    a method we can call when we update a post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Services` folder in the `BlazorWebServer` project, add a new class called
    `BlazorServerBlogNotificationService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might seem unnecessary to give the class a name that includes `BlazorServer`,
    but it makes sure we can easily tell the classes apart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the content with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is pretty straightforward here. If we call `SendNotification`, it will
    check whether anyone is listening for the `BlogPostChanged` action and whether
    to trigger the action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add the dependency injection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whenever we ask for an instance of the `IBlogNotificationService` type, we will
    get back an instance of `BlazorServerBlogNotificationService`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We add this dependency injection as a singleton. I can’t stress this enough.
    When using Blazor Server, this will be the same instance for *ALL* users, so we
    must be careful when we use `Singleton`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, we want the service to notify all the visitors of our blog that
    the blog post has changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, open `Post.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code at the top (or close to the top) of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add dependency injection for `IBlogNotificationService` and we also need
    to implement `IDisposable` to prevent any memory leaks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the top of the `OnInitializedAsync` method, add the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We added a listener to the event so we know when we should update the information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need the `PostChanged` method, so add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the parameter has the same ID as the post we are currently viewing, then
    replace the content with the post in the event and call `StateHasChanged`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since this is happening on another thread, we need to call `StateHasChanged`
    using `InvokeAsync` so that it runs on the UI thread.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also need to stop listening to the updates by implementing the `Dispose`
    method. Add the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We remove the event listener to prevent any memory leaks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Post` component is currently a static rendered component. We don’t have
    any interactivity, so let’s enable that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add this to the component:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `SharedComponents` project, open the `Pages/Admin/BlogPostEdit.Razor`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we make changes to our blog post, we need to send a notification as well.
    At the top of the file, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add a namespace and inject our notification service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `UpdateHTMLAsync` method, add the following just under the `!string.IsNullOrEmpty(Post.Text)`
    `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time we change something, it will now send a notification that the blog
    post has changed. I do realize that it would make more sense to do this when we
    save a post, but it makes for a much cooler demo.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s start with testing `InteractiveServer`. In `BlogPortEditPage.razor`,
    change `@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))`
    to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the project by pressing *Ctrl* + *F5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the URL and open another web browser. We should now have two web browser
    windows open showing us the blog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first window, open a blog post (doesn’t matter which one), and in the
    second window, log in and edit the same blog post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we change the text of the blog post in the second window, the change should
    be reflected in real time in the first window.
  prefs: []
  type: TYPE_NORMAL
- en: I am constantly amazed how a feature that would be a bit tricky to implement
    without using Blazor only requires 10 steps (not counting the test), and if we
    didn’t prepare for the next step, it would take even fewer steps.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will implement the same feature for Blazor WebAssembly, but Blazor
    WebAssembly runs inside the user’s web browser. There is no real-time communication
    built in, as with Blazor Server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing real-time updates on Blazor WebAssembly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already have a lot of things in place. We only need to add a real-time messaging
    system. Since SignalR is both easy to implement and awesome, let’s use that.
  prefs: []
  type: TYPE_NORMAL
- en: The first time I used SignalR, my first thought was, “Wait, it can’t be that
    easy. I must have forgotten something, or something must be missing”. Hopefully,
    we will have the same experience now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether that still holds true today:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, add a new folder called `Hubs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the new folder, create a class called `BlogNotificationHub.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The class inherits from the `Hub` class. There is a method called `SendNotification`.
    Keep that name in mind; we will come back to that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We call `Clients.All.SendAsync`, which means we will send a message called `BlogPostChanged`
    with the content of a blog post.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The name `BlogPostChanged` is also important, so keep that in mind as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This adds SignalR. We already have access to SignalR since this project is a
    mix of hosting models.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just above `app.MapRazorComponents<App>()`, add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we configure what URL `BlogNotificationHub` should use. In this case,
    we are using the same URL as the name of the hub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The URL here is also important. We will use that in just a bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `BlazorWebApp.Client`, add a reference to the `Microsoft.AspNetCore.SignalR.Client
    NuGet` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Services` folder, create a class called `BlazorWebAssemblyBlogNotificationService.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this file, we will implement the SignalR communication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A lot is happening here. The class is implementing `IBlogNotificationService`
    and `IAsyncDisposable`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the constructor, we use dependency injection to get `NavigationManager` so
    we can figure out the URL to the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we configure the connection to the hub. Then, we specify the URL to the
    hub; this should be the same as we specified in *step 7*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can configure the hub connection to listen for events. In this case,
    we listen for the `BlogPostChanged` event, the same name we specified in *step
    3*. When someone sends the event, the method we specify will run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The method, in this case, triggers the event we have in `IBlogNotificationService`.
    Then, we start the connection. Since the constructor can’t be async, we won’t
    await the `StartAsync` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`IBlogNotificationService` also implements the `SendNotification` method, and
    we trigger the event with the same name on the hub, which will result in the hub
    sending the `BlogPostChanged` event to all connected clients.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last thing we do is make sure that we dispose of the hub connection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, we need to configure dependency injection. Just above
    `await builder.Build().RunAsync();`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is where things get a bit tricky, since we have different implementations
    depending on whether we’re using InteractiveServer or InteractiveWebAssembly.
    We need to make sure to run it in the same way both for `EditPost` and the `Post`
    component. In a mixed scenario like this, it is a better option to always implement
    it with a SignalR connection because then we can use the same implementation regardless
    of the hosting model. In the `SharedComponents` project, open `Pages/Admin/BlogPostEdit.razor`
    and change `@rendermode @(new InteractiveServerRenderMode(prerender: false))`
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might need to clean and rebuild the solution to make it work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open `Post.razor` and do the same thing; change `@rendermode InteractiveServer`
    to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it’s time to carry out testing, run the project by pressing *Ctrl* + *F5*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the URL and open another web browser. We should now have two web browser
    windows open showing us the blog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first window, open a blog post (it doesn’t matter which one), and in
    the second window, log in and edit the same blog post.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we change the text of the blog post in the second window, the change should
    be reflected in real time in the first window.
  prefs: []
  type: TYPE_NORMAL
- en: In *13* steps (not counting testing), we have implemented real-time communication
    between the server and client, a Blazor WebAssembly client with .NET code running
    inside the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: And no JavaScript!
  prefs: []
  type: TYPE_NORMAL
- en: State management frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Speaking of JavaScript, in the JavaScript framework world of Angular, React,
    and so on, there are frameworks we can use to manage state (**Redux** and **ngRX**,
    to name a couple). This is the case for Blazor as well. Very simply, we have a
    state that we can change using methods; if the state changes, the components that
    are listening to that change will be notified.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of frameworks like that for Blazor. I have personally never
    used a framework but instead built a `Singleton` service and connected my components
    to that (basically what these frameworks do).
  prefs: []
  type: TYPE_NORMAL
- en: Check out Fluxor or Blazor-State if you want to dive deeper into that. There
    is another way to share state between components, which is called root-level cascading
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Root-level cascading values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Root-level cascading values are a new feature in .NET 8\. This is a great way
    to share state not only between components but also between different render modes.
    It will automatically add a cascading value; we have already used this feature,
    and then we added `AddCascadingAuthenticationState()`, which uses the root-level
    cascading value in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This does not share the value between InteractiveServer and InteractiveWebAssembly,
    though, but gives us a way to share the state between components without using
    dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: The really nice thing is that if the value changes, it will automatically change
    the parameter and trigger a rerender of the component. No special code is needed
    inside the component. But subscribing to value changes does have a cost, so be
    careful with how many things you use with root-level cascading values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to update the values by calling the `NotifyChangedAsync` method
    on `CascadingValueSource`. An implementation could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `INotifyPropertyChanged` interface to call `NotifyChangedAsync`
    when we change the property. On GitHub, you can find a full example of this if
    you want to play further with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how we can handle state in our application and how
    we can use local storage to store data, both encrypted and not. We looked at different
    ways of doing that, and we also made sure to include SignalR to be able to use
    real-time communication with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Almost all applications need to save data in some form. Perhaps it can be settings
    or preferences. The things we covered in the chapter are the most common ones,
    but we should also know that there are many open-source projects we can use to
    persist state. I personally prefer the components to load state from a database
    when needed be self-contained, and not have to rely on state coming or being somewhere
    else. This approach has served me well in the past.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at debugging. Hopefully, you haven’t
    needed to know how to debug yet!
  prefs: []
  type: TYPE_NORMAL
