<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-107"><a id="_idTextAnchor114"/>5</h1>
<h1 id="_idParaDest-108"><a id="_idTextAnchor115"/>Optimizing Data Access with Entity Framework Core</h1>
<p>Before Entity Framework was introduced in 2008, developers used <strong class="bold">ActiveX Data Objects</strong> (<strong class="bold">ADOs</strong>) and <strong class="bold">Object Linking and Embedding Database</strong> (<strong class="bold">OLE DB</strong>) to access their data for applications. Since its introduction, Entity Framework has evolved over the years into a high-performance bridge between <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) systems and relational databases. It enables developers to use <strong class="bold">Language Integrated Query</strong> (<strong class="bold">LINQ</strong>) syntax to perform complex queries using C#. However, some LINQ statements can be overwhelming for new developers. Since this is one of the most discussed topics when it comes to data access, we’ll cover various standards and implementations when using Entity Framework Core.</p>
<p>This chapter will be similar to <a href="B19493_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">CI/CD – Building Quality Software with Software</em>, where we will review patterns for implementing Entity Framework Core to access data but also look at some common uses of Entity Framework Core in the industry.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Entity Framework Core Implementations</li>
<li>Common Entity Framework Core Practices</li>
<li>Implementing the Theme Park Example</li>
</ul>
<p>When you’ve finished reading this chapter, you’ll have a better understanding of the various design patterns and approaches you can use with Entity Framework Core and the various standards involved; we will end the chapter by applying these standards to a theme park example.</p>
<p>Let’s get started by examining the various Entity Framework Core common implementations used by many developers.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor116"/>Technical requirements</h1>
<p>I recommend using your favorite editor to view the GitHub repository. Our recommendations include the following:</p>
<ul>
<li>Visual Studio (preferably 2022 or newer)</li>
<li>Visual Studio Code</li>
<li>JetBrains Rider</li>
</ul>
<p>The editor we’ll be using is Visual Studio Enterprise 2022, but any version (Community or Professional) will work with the code.</p>
<p>We will also be using <strong class="bold">SQL Server Management Studio</strong> (<strong class="bold">SSMS</strong>) for our example at the end of the chapter. However, if you feel you don’t need to download another tool, you can view SQL Server data through Visual Studio 2022 as well without installing SSMS.</p>
<p class="callout-heading">Downloading SQL Server Developer Edition</p>
<p class="callout">To run a local copy of SQL Server, download the Developer edition of SQL Server from <a href="https://www.microsoft.com/en-us/sql-server/sql-server-downloads">https://www.microsoft.com/en-us/sql-server/sql-server-downloads</a>.</p>
<p>The code for this chapter is located in Packt Publishing’s GitHub repository, which you can navigate to here: <a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</a>.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor117"/>Entity Framework Core Implementations</h1>
<p>Over the years, developers <a id="_idIndexMarker227"/>have used Entity Framework Core in various ways. Some were exceptionally <strong class="bold">creative</strong>.</p>
<p>In this section, we’ll discuss the following architectural approaches:</p>
<ul>
<li>Repository/Unit of Work</li>
<li>Specification</li>
<li>Extension Methods</li>
</ul>
<p>While these implementations are based on real-world experiences, they are merely observations, and, as mentioned in <a href="B19493_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, the decision will fall on teams and/or community members<a id="_idIndexMarker228"/> as to the right approach for the application and trade-offs incurred.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor118"/>Repository/Unit of Work</h2>
<p>While this implementation <a id="_idIndexMarker229"/>has already caused some<a id="_idIndexMarker230"/> friction among developers, it’s a common pattern seen with early adopters of ASP.NET Entity Framework applications (including me). However, it’s been said by community members it’s not an efficient way to use Entity Framework architecturally because of the duplication of repositories.</p>
<h3>Implementation</h3>
<p>Out of the<a id="_idIndexMarker231"/> box, the <code>DbContext</code> follows<a id="_idIndexMarker232"/> a <strong class="bold">repository</strong> and <strong class="bold">unit of work</strong> design pattern.</p>
<p>The repository design pattern is a class that manages objects between the business domain and the mapping of properties from the database using lists and single domain objects.</p>
<p>Repositories are self-contained in the <code>DbContext</code>, which is considered a Unit of Work design pattern. A unit of work pattern manages a list of objects (as repositories do) using a <code>ChangeTracker</code> to track changes in a transaction-like state and organizes how each change should be saved and how to resolve concurrency problems.</p>
<p>In Entity Framework, repositories are represented as <code>DbSet</code> instances in the <code>DbContext</code> where the <code>DbContext</code> is the unit of work itself.</p>
<p>Let’s look at an example. We have a database called <code>ThemePark</code> and it contains two tables: attractions and locations. We’ve also created a <code>ThemeParkDbContext</code> class to manage our entities. If you’ve worked with Entity Framework at any time, you’ve likely encountered the repository design pattern implemented in a similar fashion:</p>
<pre class="source-code">
public class AttractionRepository
{
    private readonly ThemeParkDbContext _context;
    public AttractionRepository(ThemeParkDbContext context)
    {
        _context = context;
    }
    public List&lt;Attraction&gt; GetAttractions()
    {
        return _context.Attractions.ToList();
    }
    public Attraction GetAttraction(int id)
    {
        return _context.Attractions.FirstOrDefault(e =&gt; e.Id == id,             null);
    }
}</pre> <p>What is wrong <a id="_idIndexMarker233"/>with<a id="_idIndexMarker234"/> this implementation? While this does separate<a id="_idIndexMarker235"/> the<a id="_idIndexMarker236"/> business rules from the data access, it’s an unnecessary layer for applications when a repository layer already exists in the <code>DbContext</code>.</p>
<p>One of the jokes I love from the developer community is, “<em class="italic">What are the two hardest problems in computer science? Cache invalidation, naming things, and </em><em class="italic">off-by-one errors.</em>”</p>
<p>Consider this a case of naming things wrong. What if we changed the name to <code>Service</code>, like so?</p>
<pre class="source-code">
public class <strong class="bold">AttractionService</strong>
{
    private readonly ThemeParkDbContext _context;
    public <strong class="bold">AttractionService</strong>(ThemeParkDbContext context)
    {
        _context = context;
    }
}</pre> <p>Why <code>Service</code>? The repository pattern is already contained in the <code>DbContext</code> as a <code>DbSet&lt;Attraction&gt;</code>. The service uses the repository pattern to retrieve the data and perform additional updates before returning the data. Changing the class name from <code>Repository</code> to <code>Service</code> signifies we don’t need a repository pattern on top of an already existing repository. When creating a service for individual repositories (<code>DbSet</code> instances), this provides <a id="_idIndexMarker237"/>multiple<a id="_idIndexMarker238"/> benefits, as follows:</p>
<ol>
<li><code>DbContext</code>. Add <code>.Include()</code> on the <code>DbContext</code> to retrieve related entities.</li>
<li><code>DbContext</code> instance through the constructor, allowing for multiple approaches to accessing data including LINQ statements, stored procedures, or even call raw SQL.</li>
<li><strong class="bold">Additional processing</strong>—When calling a data access service, there are times when the data requires more massaging before returning the results. While this is temporarily acceptable in this service, it may require refactoring to the appropriate <a id="_idIndexMarker239"/>business<a id="_idIndexMarker240"/> entity or processing <a id="_idIndexMarker241"/>through <a id="_idIndexMarker242"/>another class.</li>
</ol>
<p>The benefits seen through this approach could easily pivot the already existing repository naming convention to a service moniker.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor119"/>The Specification Pattern</h2>
<p>Developers are always looking<a id="_idIndexMarker243"/> to reuse <a id="_idIndexMarker244"/>existing code and make it as flexible as possible for maintenance purposes; update a line of code and it could change the retrieval of data required.</p>
<p>The specification pattern is solving the problem of attaching requirements to an object with the rise of <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>) making it easier to understand the results retrieved <a id="_idIndexMarker245"/>through a query. It uses a base class to retrieve data as either a list or a single entity while writing the least amount of code.</p>
<h3>Implementation</h3>
<p>When creating a specification class, you need two classes: one for processing the request and the specification for what you need. The specification class is built exactly as the class implies: it defines the filter for a single entity or list of entities, sorting and grouping, and inclusion of various related entities. Everything you can do with a LINQ query can be defined in the specification class.</p>
<p>A sample specification’s contract (interface) could have the following structure:</p>
<pre class="source-code">
public interface ISpecification&lt;T&gt;
{
    Expression&lt;Func&lt;T, bool&gt;&gt; Filter { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; OrderBy { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; OrderByDescending { get; }
    List&lt;Expression&lt;Func&lt;T, object&gt;&gt;&gt; Includes { get; }
    Expression&lt;Func&lt;T, object&gt;&gt; GroupBy { get; }
}</pre> <p>The implementation of a <code>Specification</code> class would look like this:</p>
<pre class="source-code">
public class Specification&lt;TEntity&gt;: ISpecification&lt;TEntity&gt; where TEntity: class
{
    public Expression&lt;Func&lt;TEntity, bool&gt;&gt; Filter { get; }
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; OrderBy { get; set; } =         null!;
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; OrderByDescending { get;         set; } = null!;
    public Expression&lt;Func&lt;TEntity, object&gt;&gt; GroupBy { get; set; } =         null!;
    public List&lt;Expression&lt;Func&lt;TEntity, object&gt;&gt;&gt; Includes { get; } =         null!;
    public Specification(Expression&lt;Func&lt;TEntity, bool&gt;&gt; filter)
    {
        Filter = filter;
    }
}</pre> <p>As mentioned at the start<a id="_idIndexMarker246"/> of this <a id="_idIndexMarker247"/>section, the properties in the class represent all of the different aspects of retrieving data: filtering, including, sorting, and grouping.</p>
<p>Once you have the specification defined, we need a way to build our query based on a specification. In this case, we’ll create a <code>SpecificationBuilder&lt;T&gt;</code> class:</p>
<pre class="source-code">
public static class SpecificationBuilder&lt;TEntity&gt; where TEntity: class
{
    public static IQueryable&lt;TEntity&gt; GetQuery(IQueryable&lt;TEntity&gt; inputQuery,
        ISpecification&lt;TEntity&gt; specification)
    {
        var query = inputQuery;
        if (specification == null)
        {
            return query;
        }
        if (specification.Filter != null)
        {
            query = query.Where(specification.Filter);
        }
        if (specification.Includes != null
            &amp;&amp; specification.Includes.Any())
        {
            foreach (var include in specification.Includes)
            {
                query = query.Include(include);
            }
        }
        if (specification.OrderBy != null)
        {
            query = query
                .OrderBy(specification.OrderBy);
        }
        else if (specification.OrderByDescending != null)
        {
            query = query
                .OrderByDescending(specification.OrderByDescending);
        }
        if (specification.GroupBy != null)
        {
            query = query
                .GroupBy(specification.GroupBy)
                .SelectMany(x =&gt; x);
        }
        return query;
    }
}</pre> <p>In the preceding code<a id="_idIndexMarker248"/> snippet, our <code>SpecificationBuilder</code> class <a id="_idIndexMarker249"/>creates a LINQ query to retrieve the data. Since everything is self-contained and completely independent of itself, the class was marked as static.</p>
<p>With every specification class, we need a way to retrieve the data. We’ll make the class abstract and call it <code>BaseSpecificationService&lt;TEntity&gt;</code>:</p>
<pre class="source-code">
public abstract class BaseSpecificationService&lt;TEntity&gt; where TEntity : class
{
    private readonly ThemeParkDbContext _context;
    protected BaseSpecificationService(ThemeParkDbContext context)
    {
        _context = context;
    }
    protected ISpecification&lt;TEntity&gt; Specification { get; set; } =         null!;
    protected IQueryable&lt;TEntity&gt; GetQuery()
    {
        return SpecificationBuilder&lt;TEntity&gt;
            .GetQuery(_context.Set&lt;TEntity&gt;().AsQueryable(),                  Specification);
    }
}</pre> <p>In the preceding code, <code>BaseSpecificationService</code> is what we’ll use to create our specific data <a id="_idIndexMarker250"/>needs. We require a specification<a id="_idIndexMarker251"/> property and a way to retrieve the query based on that specification.</p>
<p>With the specification pattern, the names of your classes are the specifications of the data required.</p>
<p>Let’s look at another example with a simple <code>Product</code> class:</p>
<pre class="source-code">
public class Product
{
    public string Name { get; private set; }
    public int Price { get; private set; }
}</pre> <p>If you need a list of all products below <code>$5.00</code>, a specification class would look like the following:</p>
<pre class="source-code">
public class GetProductsLessThanFiveDollars : BaseSpecificationService&lt;Product&gt;
{
    public GetProductsLessThanFiveDollars(InventoryDbContext context) : base(context)
    {
        Specification = new Specification&lt;Product&gt;(product =&gt; product.Price &lt;= 5);
    }
}</pre> <p>This code creates the specification and uses it to retrieve the results:</p>
<pre class="source-code">
var productsBelowFiveDollarsSpecification = new GetProductsLessThanFiveDollars(_context);
var results = productsBelowFiveDollarsSpecification.GetQuery().ToList();</pre> <p>The preceding code would generate a list of products of less than 5 dollars.</p>
<p>While this is a simple<a id="_idIndexMarker252"/> example, there are more<a id="_idIndexMarker253"/> extensive libraries dedicated to this type of Entity Framework design pattern, such as Steve Smith’s specification library located at <a href="https://specification.ardalis.com">https://specification.ardalis.com</a>.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor120"/>Extension Methods</h2>
<p>If we revisit the<a id="_idIndexMarker254"/> repository/unit of work method, the association between specific business logic and the data should be relatively close to <code>DbContext</code>. Instead of creating service classes while passing <code>DbContext</code> in, why not just attach your data access to the actual <code>DbSet</code> instance itself as an <code>IQueryable</code> extension method?</p>
<p>The ability to add specific calls to a <code>DbContext</code> or <code>DbSet</code> instance is extremely attractive because they can be placed anywhere in your project.</p>
<p>The extension method approach does require a bit of discipline where specific entities are concerned. For example, if you created a product entity, your <code>IQueryable</code> extension methods should return only products and not order entities. Mixing order extension methods with product extension methods is usually frowned upon.</p>
<h3>Implementation</h3>
<p>Extension methods allow <a id="_idIndexMarker255"/>your code to be more direct when accessing data.</p>
<p>Since we can attach extension methods to interfaces, let’s define a simple interface for our <code>ThemeParkDbContext</code> class, as follows:</p>
<pre class="source-code">
public interface IThemeParkDbContext
{
    DbSet&lt;Attraction&gt; Attractions { get; set; }
    DbSet&lt;Location&gt; Locations { get; set; }
    DbSet&lt;TEntity&gt; Set&lt;TEntity&gt;() where TEntity : class;
    DatabaseFacade Database { get; }
}</pre> <p>With our theme park idea, we built <code>AttractionExtensions</code> and <code>LocationExtensions</code> files for data access, like so:</p>
<pre class="source-code">
public static class AttractionExtensions
{
    public static List&lt;Attraction&gt; GetAttractions(this IThemeParkDbContext context)
    {
        return context.Attractions.ToList();
    }
    public static Attraction GetAttraction(this IThemeParkDbContext context, int id)
    {
        return context.Attractions
            .Include(t =&gt; t.Location)
            .FirstOrDefault(e =&gt; e!.Id == id, null)!;
    }
}</pre> <p>Our <code>AttractionExtensions</code> file has only two methods, <code>GetAttractions()</code> and <code>GetAttraction()</code>, which we attach to the <code>ThemeParkDbContext</code> class.</p>
<p>Our <code>LocationExtensions</code> file is <a id="_idIndexMarker256"/>small and compact as well, as we can see here:</p>
<pre class="source-code">
public static class LocationExtensions
{
    public static List&lt;Location&gt; GetLocations(this IThemeParkDbContext context)
    {
        return context.Locations.ToList();
    }
    public static Location GetLocation(this IThemeParkDbContext context, int id)
    {
        return context.Locations.FirstOrDefault(e =&gt; e!.Id == id, null)!;
    }
}</pre> <p>In this section, we reviewed some of the more common Entity Framework Core design patterns used in real-world applications such as the repository and unit of work patterns, the specification pattern, and the extension methods approach to accessing data.</p>
<p>While these are common in the .NET community, there are other patterns available for Entity Framework Core allowing even easier access to your data, but they do have drawbacks. Let’s look at these more closely:</p>
<ul>
<li><code>DbContext</code> instance would exist for each partitioned feature in the application; for example, one <code>DbContext</code> instance for the <code>Books</code> and <code>BookAuthors</code> tables and another <code>DbContext</code> instance for the <code>Orders</code> and <code>Books</code> tables. One drawback is possible state conflicts across multiple <code>DbContext</code> instances (<em class="italic">NOT</em> recommended).</li>
<li><code>DbContext</code> instance as a conduit while making direct calls to stored procedures without using LINQ. One drawback occurs when changes are made to a stored procedure and the mapping code doesn’t reflect the results returned, causing an error.</li>
</ul>
<p>In the next section, we’ll be <a id="_idIndexMarker257"/>covering some common practices when using Entity Framework Core in real-world applications.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor121"/>Common Entity Framework Core Practices</h1>
<p>Even though Entity<a id="_idIndexMarker258"/> Framework patterns provide additional structure to your code, there are also common practices to keep in mind when building applications with Entity Framework.</p>
<p>In this section, we’ll review some of the more common uses of Entity Framework and their benefits: how <code>async</code>/<code>await</code> can make your application more scalable, logging your queries to optimize SQL output, creating resource files to hold seed data for tables, learning about deferred execution, speeding up access with a read-only method called <code>.AsNoTracking()</code>, leveraging the database where it makes sense, and using AutoMapper to map source objects to destination objects.</p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor122"/>Confirming Your Model</h2>
<p>If you’re using the<a id="_idIndexMarker259"/> database-first approach (where<a id="_idIndexMarker260"/> you have an existing database to work with) to generate your models, confirm that all of your indexes, relationships, identity fields, and foreign keys represent your model accordingly before using <code>Scaffold-DbContext</code>. The <code>Scaffold-Database</code> command creates your <code>DbContext</code> instance based on an existing database. The command takes everything into account when creating the <code>DbContext</code> instance.</p>
<p>If your relationships aren’t correct, this will cause problems with navigation properties on your model when accessing them through your <code>DbContext</code> instance. Essentially, your navigation properties will be empty.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor123"/>Using Async/Await</h2>
<p>For I/O-bound activities, such <a id="_idIndexMarker261"/>as database <a id="_idIndexMarker262"/>operations, it makes sense to use <code>async</code>/<code>await</code> for creating scalable applications. While it may not be apparent when running the web application on a developer machine, the true benefits of using <code>async</code>/<code>await</code> appear when you have hundreds of people hitting the website at once.</p>
<p>The reason to use <code>async</code>/<code>await</code> is to avoid blocking thread requests. When a request comes into a web server, the .NET Framework maintains a pool of threads to process those incoming requests. For each request, a thread is taken from the pool and used to process the request synchronously. While the thread is being used, nothing can use it until the process is completed (“blocking thread”). Once the process completes, the thread is released and returned to the thread pool for the next request.</p>
<p>When you use <code>async</code>/<code>await</code>, you aren’t taking a thread from the thread pool. Anything in between <code>async</code> and <code>await</code> doesn’t use a thread, which means you’re saving memory in the long run and allowing your application to perform better.</p>
<p>When it comes to making Entity Framework Core calls, it’s best to use <code>async</code>/<code>await</code> for performance reasons.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor124"/>Logging Your Queries</h2>
<p>Most <code>OptionsBuilder</code> class specifically for logging to help solve this issue.</p>
<p>For simple logging using Entity Framework, place a <code>.LogTo()</code> method into your <code>DbContext</code> instance’s <code>onConfiguring()</code> method, as shown in the following code snippet:</p>
<pre class="source-code">
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.LogTo(Console.WriteLine);
        }
    }</pre> <p>The <code>.LogTo()</code> method takes <a id="_idIndexMarker265"/>either an action or a func on where to send the log data. In this snippet, we are simply logging to the debug window.</p>
<p>Simple logging to the debug window is the easiest to implement because it’s a simple <code>Console.Write()</code> method and doesn’t require any third-party packages, but there are other types of logging available that are just as easy to plug into Entity Framework Core.</p>
<p class="callout-heading">Additional logging options</p>
<p class="callout">For additional logging methods in Entity Framework Core, navigate to the following URL: <a href="https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/">https://learn.microsoft.com/en-us/ef/core/logging-events-diagnostics/</a>.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor125"/>Using Resources for Large Seed Data</h2>
<p>If you need initial seed<a id="_idIndexMarker266"/> data <a id="_idIndexMarker267"/>with fewer than 20 records for your tables, it’s easy to just hand-code the records on the fly in your <code>DbContext</code> instance using <code>.HasData()</code>.</p>
<p>But what if you have a table requiring hundreds of records seeded on the initial load? Hand-typing records can be painful using code.</p>
<p>One hidden gem in .NET is the use of resource files for storing simple strings (normally used for localization/translation), but it can also be used for populating seed data.</p>
<p>Let’s use our <code>Attraction</code>/<code>Location</code> table example and show the steps for creating seed data in a resource file:</p>
<ol>
<li>Open SQL Server Management Studio.</li>
<li>Confirm the seeded records are created the way you want them in each table (<code>Attraction</code> and <code>Location</code>).</li>
<li>Perform a <code>SELECT</code> operation with the JSON clause added to the end, as shown in the following <a id="_idIndexMarker268"/>SQL<a id="_idIndexMarker269"/> snippet:<pre class="source-code">
SELECT
     [ID]
     ,[Name]
     ,[LocationID]
FROM [dbo].Attraction
FOR JSON AUTO, INCLUDE_NULL_VALUES</pre></li> <li>Click on the result, and a new result pane will open with your JSON. The JSON will look like this:<pre class="source-code">
[{
        "ID": 1,
        "Name": "Twirly Ride",
        "LocationID": 2
    }, {
        "ID": 2,
        "Name": "Mine car Coaster",
        "LocationID": 5
    }, {
        "ID": 3,
        "Name": "Haunted House",
        "LocationID": 3
    }, {
        "ID": 4,
        "Name": "Dragon Ride",
        "LocationID": 2
    }, {
        "ID": 5,
        "Name": "Gift Shop",
        "LocationID": 1
    }, {
        "ID": 6,
        "Name": "Space Ride",
        "LocationID": 4
    }, {
        "ID": 7,
        "Name": "Shootout at OK Corral\/Lazer Tag",
        "LocationID": 5
    }
]</pre></li> <li>Copy the<a id="_idIndexMarker270"/> JSON<a id="_idIndexMarker271"/> returned.</li>
<li>Open Visual Studio and add a resource file through Visual Studio. The following screenshot illustrates the process:</li>
</ol>
<div><div><img alt="Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio" src="img/Figure_5.01_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Creating a resource file called SeedResource.resx in Visual Studio</p>
<ol>
<li value="7">Your resource file will <a id="_idIndexMarker272"/>automatically<a id="_idIndexMarker273"/> open. For our example, we’ll create the resource with the following parameters:<ol><li><code>AttractionRecords</code></li><li><strong class="bold">Value</strong>: &lt;Paste your JSON here&gt;</li><li><strong class="bold">Comment</strong>: (These are optional, but added to identify for other devs)</li><li><strong class="bold">Access Modifier</strong>: Change this to <strong class="bold">Internal</strong></li></ol></li>
</ol>
<p>Your resource record should look like this:</p>
<div><div><img alt="Figure 5.2 – A sample record in the Resources.resx file containing JSON for the Attraction table" src="img/Figure_5.02_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – A sample record in the Resources.resx file containing JSON for the Attraction table</p>
<ol>
<li value="8">Save your resource file.</li>
<li>Open your <code>AttractionConfiguration</code> class and locate your <code>.HasData()</code> attraction in your <code>DbContext</code> instance and replace it with the following code:<pre class="source-code">
var records = JsonSerializer.Deserialize&lt;Attraction[]&gt;(
    SeedResource.AttractionRecords);
if (records != null)
{
    builder.HasData(records);
}</pre></li> <li>Save and compile<a id="_idIndexMarker274"/> your<a id="_idIndexMarker275"/> code.</li>
</ol>
<p>If you require a large amount of seed data, it’s better to create resource files with JSON data instead of hand-coding all of the records into code. Finding long pages of large JSON strings in a <code>DbContext</code> configuration may seem jarring to some developers.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor126"/>Understanding Deferred Execution</h2>
<p>Deferred execution when<a id="_idIndexMarker276"/> making<a id="_idIndexMarker277"/> Entity Framework calls means the LINQ query is delayed until the realized value is required.</p>
<p>Here’s an example:</p>
<pre class="source-code">
var products = this.Products.ToList().Where(r =&gt; r.CategoryId == 15);</pre> <p>While this will return the correct list of items, it’s not as performant as it could be. With the <code>.ToList()</code> method added after the Products <code>DbSet</code> instance, the entire <code>Products</code> table is loaded, and <em class="italic">then</em> the <code>.Where()</code> method is executed.</p>
<p>A better approach to this call is shown in this code snippet:</p>
<pre class="source-code">
var products = this.Products.Where(r =&gt; r.CategoryId == 15).ToList();</pre> <p>This will also return the correct list of products. However, the SQL query generated will contain a <code>WHERE</code> clause as well to filter out and return the correct list of records. The difference here is the first query will return <em class="italic">all</em> of the records from the <code>Products</code> table and then filter out the resulting product list using the <code>.Where()</code> LINQ method. Remember—LINQ can also work with arrays.</p>
<p>With the second query, a <code>WHERE</code> clause is created when the <code>.ToList()</code> method is encountered, and a subset of records is returned and “materialized” into entities, making this query extremely faster.</p>
<p>Deferred execution means you are building the query and not executing it immediately. When you are<a id="_idIndexMarker278"/> finished <a id="_idIndexMarker279"/>building your query and want the results, end your LINQ query with a <code>.ToList()</code> method. If you are looking for one entity, end your LINQ query with a <code>.Single()</code>, <code>.SingleOrDefault()</code>, <code>.First()</code>, or <code>.</code><code>FirstOrDefault()</code> method.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor127"/>Using a Read-Only State with .AsNoTracking()</h2>
<p>When retrieving<a id="_idIndexMarker280"/> data <a id="_idIndexMarker281"/>using LINQ, the <code>DbContext</code> instance has something called a <code>ChangeTracker</code>, which is updated when an entity’s state changes. This requires overhead—a small amount of overhead, but overhead, nonetheless.</p>
<p>If you are using <code>DbSet</code> in a read-only situation, use the <code>.AsNoTracking()</code> method at the beginning of a LINQ statement to make Entity Framework Core aware it doesn’t need to track the state of models returned.</p>
<p>For example, the following LINQ query will retrieve an <code>Attraction</code> object without updating the <code>ChangeTracker</code>:</p>
<pre class="source-code">
public Attraction GetAttraction(int id)
{
    return _context.Attractions
        .AsNoTracking()
        .FirstOrDefault(e =&gt; e!.Id == id, null)!;
}</pre> <p>In the previous snippet, we <a id="_idIndexMarker282"/>place the <code>.AsNoTracking()</code> method right after the <code>DbSet</code> instance, letting<a id="_idIndexMarker283"/> Entity Framework Core know not to track anything.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor128"/>Leveraging the Database</h2>
<p>While it’s tempting to<a id="_idIndexMarker284"/> create <a id="_idIndexMarker285"/>everything in Entity Framework, there are times when it’s better to let the database perform data-heavy operations.</p>
<p>With one project, I was writing large LINQ queries in code to retrieve entities into memory. Then, I continued to write code to calculate a count of items, sum up totals, and finally relate all types of child entities to the main collection of entities.</p>
<p>I realized I could achieve all of this using a stored procedure and bypass Entity Framework altogether. A stored procedure took care of these details, and Entity Framework Core simply retrieved the results.</p>
<p>Sometimes, it makes sense to let the database do the heavy lifting of calculating data and provide the results to the application since that’s its job.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor129"/>Avoiding the Manual Property Mapping</h2>
<p>When sending entities <a id="_idIndexMarker286"/>to <a id="_idIndexMarker287"/>render on the client, it’s best to create <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>). You only want to send the minimal amount of data relevant to the currently displayed web page.</p>
<p>However, it gets tiring writing manual left-to-right property assignments. One recommendation is to use AutoMapper.</p>
<p>AutoMapper enables the automation of mapping properties from one source object to a destination object. In the following example, we are taking an <code>Attraction</code> object and copying the properties over to a new <code>AttractionDto</code> object. AutoMapper handles the heavy lifting for us by matching properties and copying the data over to the destination object:</p>
<pre class="source-code">
var config = new MapperConfiguration(cfg =&gt;
    cfg.CreateMap&lt;Attraction, AttractionDto&gt;());
IMapper mapper = new Mapper(config);
var dest = mapper.Map&lt;Attraction, AttractionDto&gt;(attractionObject);</pre> <p><code>AutoMapper</code> is very flexible, fills a specific need, has been downloaded from NuGet over 400,000 times, and is used by over 100,000 developers in the industry.</p>
<p class="callout-heading">AutoMapper Library</p>
<p class="callout">The previous functionality only<a id="_idIndexMarker288"/> scratches the surface of what AutoMapper is capable of doing for developers. To understand the full potential of AutoMapper, visit the fully documented website at the following URL: <a href="https://docs.automapper.org/">https://docs.automapper.org/</a>.</p>
<p>In this section, we<a id="_idIndexMarker289"/> learned about the common uses of Entity Framework Core in the industry. We learned it’s best to confirm your database before creating your database-first <code>DbContext</code> instance, along with leveraging the capabilities of your database instead of hand-coding everything, and about how to perform read-only queries with <code>.AsNoTracking()</code>, why it’s best to use <code>async</code>/<code>await</code>, and why understanding deferred execution is important when writing LINQ queries. Finally, we examined how to log your queries, how to seed your tables using resource files, and avoiding manual left-to-right property mapping by using AutoMapper.</p>
<p>In the next section, we’ll take a simple Entity Framework application and apply all of our standards, and even learn some new techniques as well.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor130"/>Implementing the Theme Park Example</h1>
<p>There is so much to digest<a id="_idIndexMarker290"/> when it comes to Entity Framework Core and all of its features. There are entire books on Entity Framework Core; this chapter will only scratch the surface.</p>
<p class="callout-heading">Entity Framework Core Recommendation</p>
<p class="callout">For a deeper dive into Entity Framework Core, I would recommend Mastering Entity Framework Core 2.0 at <a href="https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133">https://www.packtpub.com/product/mastering-entity-framework-core-20/9781788294133</a>.</p>
<p>In this section, we’ll update a small ASP.NET application that uses Entity Framework Core with all of the standards we discussed in the previous section, with a few additional techniques to help understand Entity Framework Core even better.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor131"/>Overview</h2>
<p>In this example, we’ll <a id="_idIndexMarker291"/>use our previous <code>DbContext</code> instance with <code>Attractions</code> and <code>Locations</code> tables and create a database with SQL Server.</p>
<p class="callout-heading">Running the Web Application</p>
<p class="callout">The application used for this section is found on the Packt Publishing GitHub repository under <code>Ch5/EFApplication</code>.</p>
<p>We’ll keep our data access simple. We’ll use the services approach, accepting a <code>DbContext</code> instance to retrieve our data and create our database from our <code>DbContext</code> model in SQL Server.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor132"/>Creating the Database</h2>
<p>For our application to work, we<a id="_idIndexMarker292"/> need to create our database in SQL Server. Since we already have our <code>DbContext</code> instance created (using the model-first approach), we can use Entity Framework Core migrations to build our tables.</p>
<p>To create your local version of the database, type the following into the Package Manager Console (navigate to this via <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Package </strong><strong class="bold">Manager Console</strong>):</p>
<pre class="source-code">
Update-Database</pre> <p>Once you hit <em class="italic">Enter</em>, Entity Framework Core will locate the <code>DbContext</code> instance, read the configuration file (<code>appsettings.json</code>), and use the connection string to create our database and tables <a id="_idIndexMarker293"/>with seed data in it.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor133"/>Adding an Asynchronous Read-Only Mode</h2>
<p>Our first matter at <a id="_idIndexMarker294"/>hand is<a id="_idIndexMarker295"/> to apply <code>async</code>/<code>await</code> to the correct services so that we can scale the application later. If you are working with an existing ASP.NET application with Entity Framework and want to use <code>async</code>/<code>await</code> methods, it’s best to start with the database. If you are creating a “greenfield” project (meaning from scratch), use <code>async</code>/<code>await</code> methods right away to save yourself headaches later.</p>
<p>In the <code>AttractionService</code> and <code>LocationService</code> classes, we can convert all LINQ calls as follows:</p>
<pre class="source-code">
public List&lt;Attraction&gt; GetAttractions()
{
    return _context.Attractions
        .ToList();
}</pre> <p>We convert them into the following with <code>async</code>/<code>await</code>:</p>
<pre class="source-code">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .ToListAsync();
}</pre> <p>Also, since we’re not creating, updating, or deleting data, we can safely say this is a read-only query. So, we can apply a <code>.AsNoTracking()</code> method to the query, as follows:</p>
<pre class="source-code">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .AsNoTracking()
        .ToListAsync();
}</pre> <p>As mentioned before, the <code>.AsNoTracking()</code> method will reduce the Entity Framework <a id="_idIndexMarker296"/>overhead<a id="_idIndexMarker297"/> since we aren’t tracking the model’s state but are simply populating the model.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor134"/>Including Child Entities</h2>
<p>When we query <a id="_idIndexMarker298"/>our attractions, we <a id="_idIndexMarker299"/>also want the attraction’s location. How do we include the location (stored in a separate table) in our query?</p>
<p>As we call the <code>GetAttractionsAsync()</code> method, we place a <code>.Include()</code> method to retrieve the related entity. Our new <code>GetAttractionsAsync()</code> method is modified to match the following code:</p>
<pre class="source-code">
public async Task&lt;List&lt;Attraction&gt;&gt; GetAttractionsAsync()
{
    return await _context.Attractions
        .AsNoTracking()
        .Include(r=&gt; r.Location)
        .ToListAsync();
}</pre> <p>The <code>.Include()</code> method relies heavily on the database relationships you created when building your model. I’ll refer you back to the “confirming your model” best practice we previously<a id="_idIndexMarker300"/> discussed. Entity <a id="_idIndexMarker301"/>Framework Core uses the model’s relationships to load related entities.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor135"/>Extending your Model</h2>
<p>In our <code>Location</code> model, we <a id="_idIndexMarker302"/>need a <a id="_idIndexMarker303"/>way to know how many attractions are available at a location; we need a new property called <code>AttractionCount</code>.</p>
<p>While this is a simple property added to the <code>Location</code> class, there are multiple decisions to be made here.</p>
<p>First, let’s create a new file under the <code>Partials</code> folder with the same class name, <code>Location</code>:</p>
<pre class="source-code">
namespace EFApplication.DataContext.Models;
public partial class Location
{
    public int AttractionCount { get; set; }
}</pre> <p>In the preceding code snippet, something may look strange. Even though the file is located in the <code>Partials</code> folder, <em class="italic">the partial namespace has to be the same namespace as the entities’ primary model</em> for the partial to work. .NET projects typically follow the convention of namespaces matching folder structures.</p>
<p>When we run our application, we should experience a problem with our <code>Location</code> model as it currently stands, as represented here:</p>
<div><div><img alt="Figure 5.3 – The error message when you create a property on an Entity Framework object" src="img/Figure_5.03_B19493.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The error message when you create a property on an Entity Framework object</p>
<p>What Entity Framework Core is telling us is there isn’t an <code>AttractionCount</code> field in the table and it can’t populate the property since it doesn’t exist.</p>
<p>We have three options here, as follows:</p>
<ol>
<li>Place a <code>[NotMapped]</code> attribute on the property so that it doesn’t try to populate the property and count our attractions by hand.</li>
<li>Create a SQL Server function to calculate a calculated property called <code>AttractionCount</code> and return it so that it can populate our extra property.</li>
<li>Automatically count the number of attractions already in the model.</li>
</ol>
<p>Let’s focus on <a id="_idIndexMarker304"/>implementing <em class="italic">option 3</em> as <a id="_idIndexMarker305"/>a quick hit for success.</p>
<p>While we do need a <code>[NotMapped]</code> attribute so that Entity Framework Core doesn’t try to load it, we’ll change the property into an <code>expression-bodied</code> property. We could make this an auto property ( <code>{get;set;}</code>), but we’re only using this as a <code>get</code> property, as shown in the following code snippet:</p>
<pre class="source-code">
public partial class Location
{
    [NotMapped]
    public int AttractionCount =&gt; Attractions.Count;
}</pre> <p>Keep in mind this is assuming you have a foreign-key relationship in your SQL Server instance created to load the attractions when a location is loaded. If you don’t have a <code>.Include()</code> method, your attraction count will be 0.</p>
<p>In this section, we learned how to create databases using the model-first approach, how to add an asynchronous, read-only mode using the <code>.AsNoTracking()</code> method so the state isn’t attached to the objects, how to include child entities when retrieving a parent model, and finally, how to extend your model using a partial class and attaching a <code>[NotMapped]</code> attribute<a id="_idIndexMarker306"/> to properties, letting<a id="_idIndexMarker307"/> Entity Framework know whether it should map a field to the property.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor136"/>Summary</h1>
<p>In this chapter, we learned about three different Entity Framework Core patterns including Repository and Unit of Work, Specification, and Extension Methods and how to implement each one into your own projects.</p>
<p>Then, we examined some of the standards in the industry, such as confirming your model, adding <code>async</code>/<code>await</code> to your LINQ calls, implementing logging, using resource files for seeding data, and understanding deferred execution.</p>
<p>We also reviewed how to perform read-only queries and how to leverage the database by letting it perform data-intensive procedures.</p>
<p>Finally, we applied these standards to an existing application with a way to create our database using the model-first approach, then examined how to add an asynchronous, read-only mode using the <code>.AsNoTracking()</code> method so that state isn’t attached to objects, how to include child entities when retrieving a parent model, and finally, how to extend your model while letting Entity Framework know which properties to populate and which properties to ignore.</p>
<p>In the next chapter, we’ll learn about UI standards with MVC, Razor Pages, ViewComponents, HTMLHelpers, and Task Runners.</p>
</div>
</body></html>