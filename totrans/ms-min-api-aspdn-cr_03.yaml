- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Minimal APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will try to apply some advanced development techniques available
    in earlier versions of .NET. We will touch on four common topics that are disjointed
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll cover productivity topics and best practices for frontend interfacing
    and configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Every developer, sooner or later, will encounter the issues that we describe
    in this chapter. A programmer will have to write documentation for APIs, will
    have to make the API talk to a JavaScript frontend, will have to handle errors
    and try to fix them, and will have to configure the application according to parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The themes we will touch on in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Swagger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting CORS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with global API settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As reported in the previous chapters, it will be necessary to have the .NET
    6 development framework available; you will also need to use .NET tools to run
    an in-memory web server.
  prefs: []
  type: TYPE_NORMAL
- en: To validate the functionality of **cross-origin resource sharing** (**CORS**),
    we should exploit a frontend application residing on a different HTTP address
    from the one where we will host the API.
  prefs: []
  type: TYPE_NORMAL
- en: To test the CORS example that we will propose within the chapter, we will take
    advantage of a web server in memory, which will allow us to host a simple static
    HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To host the web page (HTML and JavaScript), we will therefore use **LiveReloadServer**,
    which you can install as a .NET tool with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All the code samples in this chapter can be found in the GitHub repository for
    this book at [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-Core-6/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Swagger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swagger has entered the life of .NET developers in a big way; it’s been present
    on the project shelves for several versions of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swagger is a tool based on the OpenAPI specification and allows you to document
    APIs with a web application. According to the official documentation available
    at [https://oai.github.io/Documentation/introduction.xhtml](https://oai.github.io/Documentation/introduction.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: “The OpenAPI Specification allows the description of a remote API accessible
    through HTTP or HTTP-like protocols.
  prefs: []
  type: TYPE_NORMAL
- en: An *API*defines the allowed interactions between two pieces of software, just
    like a user interface defines the ways in which a user can interact with a program.
  prefs: []
  type: TYPE_NORMAL
- en: An API is composed of the list of possible methods to call (requests to make),
    their parameters, return values and any data format they require (among other
    things). This is equivalent to how a user’s interactions with a mobile phone app
    are limited to the buttons, sliders and text boxes in the app’s user interface.”
  prefs: []
  type: TYPE_NORMAL
- en: Swagger in the Visual Studio scaffold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We understand then that **Swagger**, as we know it in the .NET world, is nothing
    but a set of specifications defined for all applications that expose web-based
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Visual Studio scaffold](img/Figure_3.1_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Visual Studio scaffold
  prefs: []
  type: TYPE_NORMAL
- en: By selecting `Swashbuckle.AspNetCore` and automatically configures it in the
    `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the few lines that are added with a new project. With these few pieces
    of information, a web application is enabled only for the development environment,
    which allows the developer to test the API without generating a client or using
    tools external to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The graphical part generated by Swagger greatly increases productivity and allows
    the developer to share information with those who will interface with the application,
    be it a frontend application or a machine application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We remind you that enabling Swagger in a production environment is *strongly
    discouraged* because sensitive information could be publicly exposed on the web
    or on the network where the application resides.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to introduce Swagger into our API applications; this functionality
    allows us to document our API, as well as allow users to generate a client to
    call our application. Let’s see the options we have to quickly interface an application
    with APIs described with OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: OpenAPI Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Swagger, and especially with the OpenAPI standard, you can automatically
    generate clients to connect to the web application. Clients can be generated for
    many languages but also for development tools. We know how tedious and repetitive
    it is to write clients to access the Web API. **Open API Generator** helps us
    automate code generation, inspect the API documentation made by Swagger and OpenAPI,
    and automatically generate code to interface with the API. Simple, easy, and above
    all, fast.
  prefs: []
  type: TYPE_NORMAL
- en: The `@openapitools/openapi-generator-cli` npm package is a very well-known package
    wrapper for OpenAPI Generator, which you can find at [https://openapi-generator.tech/](https://openapi-generator.tech/).
  prefs: []
  type: TYPE_NORMAL
- en: With this tool, you can generate clients for programming languages as well as
    load testing tools such as **JMeter** and **K6**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not necessary to install the tool on your machine, but if the URL of
    the application is accessible from the machine, you can use a Docker image, as
    described by the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The command allows you to generate a `petstore.yaml` file that is mounted on
    the Docker volume.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go into detail to understand how you can leverage Swagger in .NET
    6 projects and with minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger in minimal APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ASP.NET Web API, as in the following code excerpt, we see a method documented
    with C# language annotations with the triple slash (`///`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation section is leveraged to add more information to the API description.
    In addition, the `ProducesResponseType` annotations help Swagger identify the
    possible codes that the client must handle as a result of the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Swagger, in addition to the annotations on single methods, is also instructed
    by the documentation of the language to give further information to those who
    will then have to use the API application. A description of the methods of the
    parameters is always welcome by those who will have to interface; unfortunately,
    it is not possible to exploit this functionality in the minimal API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go in order and see how to start using Swagger on a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this first example, we have configured Swagger and general Swagger information.
    We have included additional information that enriches Swagger’s UI. The only mandatory
    information is the title, while the version, contact, description, license, and
    terms of service are optional.
  prefs: []
  type: TYPE_NORMAL
- en: The `UseSwaggerUI()` method automatically configures where to put the UI and
    the JSON file describing the API with the OpenAPI format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result at the graphical level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The Swagger UI](img/Figure_3.2_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Swagger UI
  prefs: []
  type: TYPE_NORMAL
- en: We can immediately see that the OpenAPI contract information has been placed
    in the `/swagger/v1/swagger.json` path.
  prefs: []
  type: TYPE_NORMAL
- en: The contact information is populated, but no operations are reported as we haven’t
    entered any yet. Should the API have versioning? In the top-right section, we
    can select the available operations for each version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can customize the Swagger URL and insert the documentation on a new path;
    the important thing is to redefine `SwaggerEndpoint`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now go on to add the endpoints that describe the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to define `RouteHandlerBuilder` because it allows us to
    describe all the properties of the endpoint that we have written in code.
  prefs: []
  type: TYPE_NORMAL
- en: The UI of Swagger must be enriched as much as possible; we must describe at
    best what the minimal APIs allow us to specify. Unfortunately, not all the functionalities
    are available, as in ASP.NET Web API.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning in minimal APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Versioning** in minimal APIs is not handled in the framework functionality;
    as a result, even Swagger cannot handle UI-side API versioning. So, we observe
    that when we go to the **Select a definition** section shown in *Figure 3.2*,
    only one entry for the current version of the API is visible.'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We just realized that not all features are available in Swagger; let’s now explore
    what is available instead. To describe the possible output values of an endpoint,
    we can call functions that can be called after the handler, such as the `Produces`
    or `WithTags` functions, which we are now going to explore.
  prefs: []
  type: TYPE_NORMAL
- en: The `Produces` function decorates the endpoint with all the possible responses
    that the client should be able to manage. We can add the name of the operation
    ID; this information will not appear in the Swagger screen, but it will be the
    name with which the client will create the method to call the endpoint. `OperationId`
    is the unique name of the operation made available by the handler.
  prefs: []
  type: TYPE_NORMAL
- en: To exclude an endpoint from the API description, you need to call `ExcludeFromDescription()`.
    This function is rarely used, but it is very useful in cases where you don’t want
    to expose endpoints to programmers who are developing the frontend because that
    particular endpoint is used by a machine application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add and tag the various endpoints and segment them for better
    client management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the graphical result of Swagger; as I anticipated earlier, the tags
    and operation IDs are not shown by the web client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Swagger UI methods  ](img/Figure_3.3_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Swagger UI methods
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint description, on the other hand, is very useful to include. It’s
    very easy to implement: just insert C# comments in the method (just insert three
    slashes, `///`, in the method). Minimal APIs don’t have methods like we are used
    to in web-based controllers, so they are not natively supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Swagger isn’t just the GUI we’re used to seeing. Above all, Swagger is the JSON
    file that supports the OpenAPI specification, of which the latest version is 3.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we show the section containing the description of
    the first endpoint that we inserted in the API. We can infer both the tag and
    the operation ID; this information will be used by those who will interface with
    the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have seen how to configure Swagger and what is currently
    not yet supported.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will also see how to configure OpenAPI, both for
    the OpenID Connect standard and authentication via the API key.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet of the Swagger UI, Swagger makes the schematics
    of the objects involved available, both inbound to the various endpoints and outbound
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Input and output data schema ](img/Figure_3.4_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Input and output data schema
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to deal with these objects and how to validate and define
    them in [*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation
    and Mapping*.
  prefs: []
  type: TYPE_NORMAL
- en: Swagger OperationFilter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The operation filter allows you to add behavior to all operations shown by Swagger.
    In the following example, we’ll show you how to add an HTTP header to a particular
    call, filtering it by `OperationId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you go to define an operation filter, you can also set filters based on
    routes, tags, and operation IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To define an operation filter, the `IOperationFilter` interface must be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, you can define all interfaces or objects that have been
    previously registered in the dependency inject engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter then consists of a single method, called `Apply`, which provides
    two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OpenApiOperation`: An operation where we can add parameters or check the operation
    ID of the current call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OperationFilterContext`: The filter context that allows you to read `ApiDescription`,
    where you can find the URL of the current endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, to enable the operation filter in Swagger, we will need to register
    it inside the `SwaggerGen` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this method, we should then add the filter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result at the UI level; in the endpoint and only for a particular
    operation ID, we would have a new mandatory header with a default parameter that,
    in development, will not have to be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – API key section ](img/Figure_3.5_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – API key section
  prefs: []
  type: TYPE_NORMAL
- en: This case study helps us a lot when we have an API key that we need to set up
    and we don’t want to insert it on every single call.
  prefs: []
  type: TYPE_NORMAL
- en: Operation filter in production
  prefs: []
  type: TYPE_NORMAL
- en: Since Swagger should not be enabled in the production environment, the filter
    and its default value will not create application security problems.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you disable Swagger in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we figured out how to enable a UI tool that describes the API
    and allows us to test it. In the next section, we will see how to enable the call
    between **single-page applications** (**SPAs**) and the backend via CORS.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling CORS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CORS is a security mechanism whereby an HTTP/S request is blocked if it arrives
    from a different domain than the one where the application is hosted. More information
    can be found in the Microsoft documentation or on the Mozilla site for developers.
  prefs: []
  type: TYPE_NORMAL
- en: A browser prevents a web page from making requests to a domain other than the
    domain that serves that web page. A web page, SPA, or server-side web page can
    make HTTP requests to several backend APIs that are hosted in different origins.
  prefs: []
  type: TYPE_NORMAL
- en: This restriction is called the **same-origin policy**. The same-origin policy
    prevents a malicious site from reading data from another site. Browsers don’t
    block HTTP requests but do block response data.
  prefs: []
  type: TYPE_NORMAL
- en: We, therefore, understand that the CORS qualification, as it relates to safety,
    must be evaluated with caution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common scenario is that of SPAs that are released on web servers with
    different web addresses than the web server hosting the minimal API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – SPA and minimal API ](img/Figure_3.6_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – SPA and minimal API
  prefs: []
  type: TYPE_NORMAL
- en: A similar scenario is that of microservices, which need to talk to each other.
    Each microservice will reside at a particular web address that will be different
    from the others.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Microservices and minimal APIs ](img/Figure_3.7_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Microservices and minimal APIs
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, therefore, a CORS problem is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: We now understand the cases in which a CORS request can occur. Now let’s see
    what the correct HTTP request flow is and how the browser handles the request.
  prefs: []
  type: TYPE_NORMAL
- en: CORS flow from an HTTP request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens when a call leaves the browser for a different address other than
    the one where the frontend is hosted?
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP call is executed and it goes all the way to the backend code, which
    executes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The response, with the correct data inside, is blocked by the browser. That’s
    why when we execute a call with Postman, Fiddler, or any HTTP client, the response
    reaches us correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – CORS flow ](img/Figure_3.8_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – CORS flow
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we can see that the browser makes the first call with
    the `OPTIONS` method, to which the backend responds correctly with a `204` status
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – First request for the CORS call (204 No Content result) ](img/Figure_3.9_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – First request for the CORS call (204 No Content result)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second call that the browser makes, an error occurs; the `strict-origin-when-cross-origin`
    value is shown in **Referrer Policy**, which indicates the refusal by the browser
    to accept data from the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Second request for the CORS call (blocked by the browser) ](img/Figure_3.10_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Second request for the CORS call (blocked by the browser)
  prefs: []
  type: TYPE_NORMAL
- en: 'When CORS is enabled, in the response to the `OPTIONS` method call, three headers
    are inserted with the characteristics that the backend is willing to respect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Request for CORS call (with CORS enabled) ](img/Figure_3.11_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Request for CORS call (with CORS enabled)
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can see that three headers are added that define `Access-Control-Allow-Headers`,
    `Access-Control-Allow-Methods`, and `Access-Control-Allow-Origin`.
  prefs: []
  type: TYPE_NORMAL
- en: The browser with this information can accept or block the response to this API.
  prefs: []
  type: TYPE_NORMAL
- en: Setting CORS with a policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many configurations are possible within a .NET 6 application for activating
    CORS. We can define authorization policies in which the four available settings
    can be configured. CORS can also be activated by adding extension methods or annotations.
  prefs: []
  type: TYPE_NORMAL
- en: But let us proceed in order.
  prefs: []
  type: TYPE_NORMAL
- en: The `CorsPolicyBuilder` class allows us to define what is allowed or not allowed
    within the CORS acceptance policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have, therefore, the possibility to set different methods, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AllowAnyHeader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowAnyMethod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowAnyOrigin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowCredentials`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the first three methods are descriptive and allow us to enable any settings
    relating to the header, method, and origin of the HTTP call, respectively, `AllowCredentials`
    allows us to include the cookie with the authentication credentials.
  prefs: []
  type: TYPE_NORMAL
- en: CORS policy recommendations
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend that you don’t use the `AllowAny` methods but instead filter out
    the necessary information to allow for greater security. As a best practice, when
    enabling CORS, we recommend the use of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WithExposedHeaders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithHeaders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WithOrigins`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To simulate a scenario for CORS, we created a simple frontend application with
    three different buttons. Each button allows you to test one of the possible configurations
    of CORS within the minimal API. We will explain these configurations in a few
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the CORS scenario, we have created a single-page application that
    can be launched on a web server in memory. We have used `LiveReloadServer`, a
    tool that can be installed with the .NET CLI. We talked about it at the start
    of the chapter and now it’s time to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing it, you need to launch the SPA with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `BasePath` is the folder where you are going to download the examples
    available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you must start the application backend, either through Visual Studio or
    Visual Studio Code or through the .NET CLI with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve figured out how to start an example that highlights the CORS problem;
    now we need to configure the server to accept the request and inform the browser
    that it is aware that the request is coming from a different source.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk about policy configuration. We will understand the characteristics
    of the default policy as well as how to create a custom one.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a default policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To configure a single CORS enabling policy, you need to define the behavior
    in the `Program.cs` file and add the desired configurations. Let’s implement a
    policy and define it as `Default`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to enable the policy for the whole application, simply add `app.UseCors();`
    before defining the handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring custom policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can create several policies within an application; each policy may have its
    own configuration and each policy may be associated with one or more endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of microservices, having several policies helps to precisely segment
    access from a different source.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure a new policy, it is necessary to add it and give it a
    name; this name will give access to the policy and allow it to be associated with
    the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The customized policy, as in the previous example, is assigned to the entire
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We next look at how to apply a single policy to a specific endpoint; to this
    end, two methods are available. The first is via an extension method to the `IEndpointConventionBuilder`
    interface. The second method is to add the `EnableCors` annotation followed by
    the name of the policy to be enabled for that method.
  prefs: []
  type: TYPE_NORMAL
- en: Setting CORS with extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is necessary to use the `RequireCors` method followed by the name of the
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this method, it is then possible to enable one or more policies for an
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting CORS with an annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second method is to add the `EnableCors` annotation followed by the name
    of the policy to be enabled for that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Regarding controller programming, it soon becomes apparent that it is not possible
    to apply a policy to all methods of a particular controller. It is also not possible
    to group controllers and enable the policy. It is therefore necessary to apply
    the individual policy to the method or the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we found out how to configure browser protection for applications
    hosted on different domains.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start configuring our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Working with global API settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just defined how you can load data with the `options` pattern within
    an ASP.NET application. In this section, we want to describe how you can configure
    an application and take advantage of everything we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: With the birth of `Web.config` file to the `appsettings.json` file. The configurations
    can also be read from other sources, such as other file formats like the old `.ini`
    file or a positional file.
  prefs: []
  type: TYPE_NORMAL
- en: In minimal APIs, the `options` pattern feature remains unchanged, but in the
    next few paragraphs, we will see how to reuse the interfaces or the `appsettings.json`
    file structure.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration in .NET 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object provided from .NET is `IConfiguration`, which allows us to read some
    specific configurations inside the `appsettings` file.
  prefs: []
  type: TYPE_NORMAL
- en: But, as described earlier, this interface does much more than just access a
    file for reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following extract from the official documentation helps us understand how
    the interface is the generic access point that allows us to access the data inserted
    in various services:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration in ASP.NET Core is performed using one or more configuration providers.
    Configuration providers read configuration data from key-value pairs using a variety
    of configuration sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of configuration sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Settings files, such as `appsettings.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure App Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom providers, installed or created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory .NET objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([https://docs.microsoft.com/aspnet/core/fundamentals/configuration/](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/))
  prefs: []
  type: TYPE_NORMAL
- en: The `IConfiguration` and `IOptions` interfaces, which we will see in the next
    chapter, are designed to read data from the various providers. These interfaces
    are not suitable for reading and editing the configuration file while the program
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: The `IConfiguration` interface is available through the `builder` object, `builder.Configuration`,
    which provides all the methods needed to read a value, an object, or a connection
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'After looking at one of the most important interfaces that we will use to configure
    the application, we want to define good development practices and use a fundamental
    building block for any developer: namely, classes. Copying the configuration into
    a class will allow us to better enjoy the content anywhere in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define classes containing a property and classes corresponding `appsettings`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration classes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, we bring back the corresponding JSON of the C# class that we just
    saw:'
  prefs: []
  type: TYPE_NORMAL
- en: appsettings.json definition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will be performing several operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first operation we perform creates an instance of the `startupConfig` object
    that will be of the `MyCustomStartupObject` type. To populate the instance of
    this object, through `IConfiguration`, we are going to read the data from the
    section called `MyCustomStartupObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The newly created object can then be used in the various handlers of the minimal
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, in this second operation, we use the dependency injection engine to
    request the instance of the `IConfiguration` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With the `IConfiguration` object, we will retrieve the data similarly to the
    operation just described. We select the `GetSection(nameof(MyCustomObject))` section
    and type the object with the `Get<T>()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in these last two examples, we read a single key, present at the root
    level of the `appsettings` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `configuration.GetValue<T>(“JsonRootKey”)` method extracts the value of
    a key and converts it into an object; this method is used to read strings or numbers
    from a root-level property.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we can see how you can leverage an `IConfiguration` method
    to read `ConnectionString`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `appsettings` file, *connection strings* are placed in a specific section,
    `ConnectionStrings`, that allows you to name the string and read it. Multiple
    connection strings can be placed in this section to exploit it in different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration provider for Azure App Service, connection strings should
    be entered with a prefix that also indicates the SQL provider you are trying to
    use, as described in the following link: [https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings](https://docs.microsoft.com/azure/app-service/configure-common#configure-connection-strings).'
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, connection strings are available as environment variables, prefixed
    with the following connection types:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLServer: `SQLCONNSTR_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL: `MYSQLCONNSTR_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAzure: `SQLAZURECONNSTR_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom: `CUSTOMCONNSTR_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL: `POSTGRESQLCONNSTR_`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For completeness, we will bring back the entire code just described in order
    to have a better general picture of how to exploit the `IConfiguration` object
    inside the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We’ve seen how to take advantage of the `appsettings` file with connection strings,
    but very often, we have many different files for each environment. Let’s see how
    to take advantage of one file for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: Priority in appsettings files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `appsettings` file can be managed according to the environments in which
    the application is located. In this case, the practice is to place key information
    for that environment in the `appsettings.{ENVIRONMENT}.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The root file (that is, `appsettings.json`) should be used for the production
    environment only.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we created these examples in the two files for the `“Priority”`
    key, what would we get?
  prefs: []
  type: TYPE_NORMAL
- en: appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: appsettings.Development.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If it is a *Development* environment, the value of the key would result in `Dev`,
    while in a *Production* environment, the value would result in `Root`.
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if the environment was anything other than *Production* or
    *Development*? For example, if it were called *Stage*? In this case, having not
    specified any `appsettings.Stage.json` file, the read value would be that of one
    of the `appsettings.json` files and therefore, `Root`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we specified the `appsettings.Stage.json` file, the value would
    be read from the that file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s visit the `Options` pattern. There are objects that the framework
    provides to load configuration information upon startup or when changes are made
    by the systems department. Let’s go over how.
  prefs: []
  type: TYPE_NORMAL
- en: Options pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `options` pattern uses classes to provide strongly typed access to groups
    of related settings, that is, when configuration settings are isolated by scenario
    into separate classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `options` pattern will be implemented with different interfaces and different
    functionalities. Each interface (see the following subsection) has its own features
    that help us achieve certain goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s start in order. We define an object for each type of interface (we
    will do it to better represent the examples), but the same class can be used to
    register more options inside the configuration file. It is important to keep the
    structure of the file identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each option is registered in the dependency injection engine via the `Configure`
    method, which also requires the registration of the `T` type present in the method
    signature. As you can see, in the registration phase, we declared the types and
    the section of the file where to retrieve the information, and nothing more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have not yet defined how the object should be read, how often, and with what
    type of interface.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that changes is the parameter, as seen in the last two examples
    of the preceding code snippet. This parameter allows you to add a name to the
    option type. The name is required to match the type used in the method signature.
    This feature is called **named options**.
  prefs: []
  type: TYPE_NORMAL
- en: Different option interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Different interfaces can take advantage of the recordings you just defined.
    Some support named options and some do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IOptions<TOptions>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Does not support the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading of configuration data after the app has started
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Named options
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is registered as a singleton and can be injected into any service lifetime
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IOptionsSnapshot<TOptions>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is useful in scenarios where options should be recomputed on every request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is registered as **scoped** and therefore cannot be injected into a singleton
    service
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports named options
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IOptionsMonitor<TOptions>`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is used to retrieve options and manage options notifications for `TOptions` instances
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Is registered as a singleton and can be injected into any service lifetime
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supports the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Change notifications
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Named options
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reloadable configuration
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Selective options invalidation (`IOptionsMonitorCache<TOptions>`)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to point you to the use of `IOptionsFactory<TOptions>`, which is responsible
    for creating new instances of options. It has a single `Create` method. The default
    implementation takes all registered `IConfigureOptions<TOptions>` and `IPostConfigureOptions<TOptions>`
    and performs all configurations first, followed by post-configuration ([https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces](https://docs.microsoft.com/aspnet/core/fundamentals/configuration/options#options-interfaces)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Configure` method can also be followed by another method in the configuration
    pipeline. This method is called `PostConfigure` and is intended to modify the
    configuration each time it is configured or reread. Here is an example of how
    to record this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having defined the theory of these numerous interfaces, it remains for us to
    see `IOptions` at work with a concrete example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the use of the three interfaces just described and the use of `IOptionsFactory`,
    which, along with the `Create` method and with the named options function, retrieves
    the correct instance of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, we want to bring attention to the use of the different
    interfaces available.
  prefs: []
  type: TYPE_NORMAL
- en: Each individual interface used in the previous snippet has a particular life
    cycle that characterizes its behavior. Finally, each interface has slight differences
    in the methods, as we have already described in the previous paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: IOptions and validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Last but not least is the validation functionality of the data present in the
    configuration. This is very useful when the team that has to release the application
    still performs manual or delicate operations that need to be at least verified
    by the code.
  prefs: []
  type: TYPE_NORMAL
- en: Before the advent of .NET Core, very often, the application would not start
    because of an incorrect configuration. Now, with this feature, we can validate
    the data in the configuration and throw errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: Register option with validation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the configuration file where an error is explicitly reported:'
  prefs: []
  type: TYPE_NORMAL
- en: Appsettings section for configuration validation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the class containing the validation logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The application then encounters errors while using the particular configuration
    and not at startup. This is also because, as we have seen before, `IOptions` could
    reload information following a change in `appsettings`:'
  prefs: []
  type: TYPE_NORMAL
- en: Error validate option
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Best practice for using validation in IOptions
  prefs: []
  type: TYPE_NORMAL
- en: This setting is not suitable for all application scenarios. Only some options
    can have formal validations; if we think of a connection string, it is not necessarily
    formally incorrect, but the connection may not be working.
  prefs: []
  type: TYPE_NORMAL
- en: Be cautious about applying this feature, especially since it reports errors
    at runtime and not during startup and gives an Internal Server Error, which is
    not a best practice in scenarios that should be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Everything we’ve seen up to this point is about configuring the `appsettings.json`
    file, but what if we wanted to use other sources for configuration management?
    We’ll look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the section, the `IConfiguration` interface
    and all variants of `IOptions` work not only with the `appsettings` file but also
    on different sources.
  prefs: []
  type: TYPE_NORMAL
- en: Each source has its own characteristics, and the syntax for accessing objects
    is very similar between providers. The main problem is when we must define a complex
    object or an array of objects; in this case, we will see how to behave and be
    able to replicate the dynamic structure of a JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at two very common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an application in Azure App Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start with Azure, and in particular, the Azure Web Apps service.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Configuration** page, there are two sections: **Application settings**
    and **Connection strings**.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we need to insert the keys and values or JSON objects
    that we saw in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the `appsettings.json` file. In this section, in addition to the textual
    string, it is necessary to set the connection type, as we saw in the *Configuration
    in .NET 6* section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Azure App Service Application settings ](img/Figure_3.12_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Azure App Service Application settings
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To insert an object, we must specify the parent for each key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent__key`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are *two* underscores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object in the JSON file would be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, we should write `MyCustomObject__CustomProperty`.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inserting an array is much more verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parent__child__ArrayIndexNumber_key`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The array in the JSON file would be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to access the `ValueOne` value, we should write the following: `MyCustomArray__CustomPropertyArray__0__CustomKey`.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an application in Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are developing for containers and therefore for Docker, `appsettings`
    files are usually replaced in the `docker-compose` file, and very often in the
    `override` file, because it behaves analogously to the settings files divided
    by the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to provide a brief overview of the features that are usually leveraged
    to configure an application hosted in Docker. Let’s see in detail how to define
    root keys and objects, and how to set the connection string. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Minimal APIs that use configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker-compose.override.yaml` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There is only one application container for this example, and the service that
    instantiates it is called `dockerenvironment`.
  prefs: []
  type: TYPE_NORMAL
- en: In the configuration section, we can see three particularities that we are going
    to analyze line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet we want to show you has several very interesting components: a
    property in the configuration root, an object composed of a single property, and
    a connection string to a database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first configuration, you are going to set a property that is the root
    of the configurations. In this case, it is a simple string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second configuration, we are going to set up an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The object is called `RootSettings`, while the only property it contains is
    called `SampleVariable`. This object can be read in different ways. We recommend
    using the `Ioptions` object that we have seen extensively before. In the preceding
    example, we show how to access a single property present in an object via code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, via code, you need to use the following notation to access the
    value: `RootSettings:SampleVariable`. This approach is useful if you need to read
    a single property, but we recommend using the `Ioptions` interfaces to access
    the object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last example, we show you how to set the connection string called `SqlConnection`.
    This way, it will be easy to retrieve the information from the base methods available
    on `Iconfiguration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To read the information, it is necessary to exploit this method: `GetConnectionString(“SqlConnection”)`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of scenarios for configuring our applications; in the next section,
    we will also see how to handle errors.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is one of the features that every application must provide. The
    representation of an error allows the client to understand the error and possibly
    handle the request accordingly. Very often, we have our own customized methods
    of handling errors.
  prefs: []
  type: TYPE_NORMAL
- en: Since what we’re describing is a key functionality of the application, we think
    it’s fair to see what the framework provides and what is more correct to use.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET provides the same tool for minimal APIs that we can implement in traditional
    development: a **Developer Exception Page**. This is nothing but middleware that
    reports the error in plain text format. This middleware can’t be removed from
    the ASP.NET pipeline and works exclusively in the development environment ([https://docs.microsoft.com/aspnet/core/fundamentals/error-handling](https://docs.microsoft.com/aspnet/core/fundamentals/error-handling)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Minimal APIs pipeline, ExceptionHandler ](img/Figure_3.13_B17902.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Minimal APIs pipeline, ExceptionHandler
  prefs: []
  type: TYPE_NORMAL
- en: If exceptions are raised within our code, the only way to catch them in the
    application layer is through middleware that is activated before sending the response
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error handling middleware is standard and can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We have shown here a possible implementation of the middleware. In order to
    be implemented, the `UseExceptionHandler` method must be exploited, allowing the
    writing of management code for the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the `var` functionality called `exceptionHandlerPathFeature = context.Features.Get<IExceptionHandlerPathFeature>()!;`,
    we can access the error stack and return the information of interest for the caller
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When an exception occurs in the code, as in the preceding example, the middleware
    steps in and handles the return message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If the exception were to occur in internal application stacks, the middleware
    would still intervene to provide the client with the correct error and appropriate
    indication.
  prefs: []
  type: TYPE_NORMAL
- en: Problem Details and the IETF standard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Problem Details for HTTP APIs* is an IETF standard that was approved in 2016\.
    This standard allows a set of information to be returned to the caller with standard
    fields and JSON notations that help identify the error.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP status codes are sometimes not enough to convey enough information about
    an error to be useful. While the humans behind web browsers can be informed about
    the nature of the problem with an HTML response body, non-human consumers, such
    as machine, PC, and server, of so-called *HTTP APIs* usually cannot.
  prefs: []
  type: TYPE_NORMAL
- en: This specification defines simple JSON and XML document formats to suit this
    purpose. They are designed to be reused by HTTP APIs, which can identify distinct
    *problem types* specific to their needs.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, API clients can be informed of both the high-level error class and the
    finer-grained details of the problem ([https://datatracker.ietf.org/doc/html/rfc7807](https://datatracker.ietf.org/doc/html/rfc7807)).
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, there is a package with all the functionality that meets the IETF standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package is called `Hellang.Middleware.ProblemDetails`, and you can download
    it at the following address: [https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/](https://www.nuget.org/packages/Hellang.Middleware.ProblemDetails/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see now how to insert the package into the project and configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are only two instructions to make this package work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`builder.Services.AddProblemDetails`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.UseProblemDetails();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since, in the minimal APIs, the `IActionResultExecutor` interface is not present
    in the ASP.NET pipeline, it is necessary to add a custom class to handle the response
    in case of an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you need to add a class (the following) and register it in the
    dependency injection engine: `builder.Services.TryAddSingleton<IActionResultExecutor<ObjectResult>,
    ProblemDetailsResultExecutor>();`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the class to support the package, also under minimal APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the standard for handling error messages has been present
    in the IETF standard for several years, but for the C# language, it is necessary
    to add the package just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see how this package goes about handling errors on some endpoints
    that we report here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We throw an application-level exception with this endpoint. In this case, the
    `ProblemDetails` middleware goes and returns a JSON error consistent with the
    error. We then have the handling of an unhandled exception for free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By inserting additional configurations in the `Program` file, you can map some
    specific exceptions to HTTP errors. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The code with the `NotImplementedException` exception is mapped to HTTP error
    code `501`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is possible to create extensions to the `ProblemDetails` class of
    the framework with additional fields or to call the `base` method by adding custom
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the last two examples of `MapGet` endpoint handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen several advanced aspects regarding the implementation
    of minimal APIs. We explored Swagger, which is used to document APIs and provide
    the developer with a convenient, working debugging environment. We saw how CORS
    handles the issue of applications hosted on different addresses other than the
    current API. Finally, we saw how to load configuration information and handle
    unexpected errors in the application.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the nuts and bolts that will allow us to be productive in a short
    amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add a fundamental building block for SOLID pattern-oriented
    programming, namely the dependency injection engine, which will help us to better
    manage the application code scattered in the various layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: What’s New in .NET 6?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the second part of the book, we want to show you the features of the .NET
    6 framework and how they can also be used in minimal APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following chapters in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B17902_04.xhtml#_idTextAnchor061), *Dependency Injection in a
    Minimal API Project*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B17902_05.xhtml#_idTextAnchor068), *Using Logging to Identify
    Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17902_06.xhtml#_idTextAnchor082), *Exploring Validation and
    Mapping*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17902_07.xhtml#_idTextAnchor094), *Integration with the Data
    Access Layer*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
