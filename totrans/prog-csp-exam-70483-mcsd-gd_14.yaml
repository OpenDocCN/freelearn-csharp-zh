- en: Performing I/O Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any programming language, all applications are dependent upon some sort of
    data. These applications interact with one another, passing data present in different
    sources such as file objects and external web services.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the different functionalities provided in C#
    to access and utilize data in file objects and external web services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing I/O operations on file objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different helper classes available in the `System.Net` namespace that help us
    with I/O operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters covered in this book, the programs explained in
    this chapter will be developed in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: Sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: File I/O operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**File** is a very crude term representing a collection of data stored on a
    disk at a particular directory path. While writing C# applications, there are
    several occasions when we will need to use file objects:'
  prefs: []
  type: TYPE_NORMAL
- en: To store data in an application or pass it across to another application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access configuration settings that are necessary for application execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To access files that are present in a directory path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations are called I/O operations. C# provides a namespace, `System.IO`,
    that has some helper classes. These helper classes help us execute I/O operations
    on file objects. In this section, we will look at those helper classes in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Working with System.IO helper classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `System.IO` namespace contains a collection of classes that allow us to
    do file manipulation in C#. It includes classes that allow us to do operations
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read data from a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write data to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create/delete new files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At different points during this chapter, through code examples, we will look
    at all of these I/O operations that we can perform on a file. However, before
    we start looking at those examples, we need to understand a very important concept,
    *Stream*, on which I/O operations are based.
  prefs: []
  type: TYPE_NORMAL
- en: A stream signifies a sequence of bytes exchanged between applications during
    an I/O operation. In C#, it's represented by an abstract class called `System.IO.Stream`.
    It provides a wrapper class to transfer bytes, and all classes that need to read/write
    bytes from any source must inherit from this particular class.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to learn more about streams and how we deal with it them in
    C#, let's first look at how we deal with drives, directories, and some other basic
    operations with files.
  prefs: []
  type: TYPE_NORMAL
- en: Drives and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A drive represents a storage medium for the filesystem. It can be a hard drive,
    a CD, or any other storage type. In .NET Framework, we have a `DriveInfo` class
    in the `System.IO` namespace, which helps us access the filesystem information
    that is available on the drive. It provides methods that can help us access information
    such as name, size, and the free space available on the drive. Please refer to
    the following code implementation, in which we are looping through all the files
    available on the drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding piece of code, we are browsing through all the drives (that
    is, C, D, E, and so on) available on the filesystem and are publishing information
    related to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of drive, that is, fixed, RAM, CD ROM, removable, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total available memory size on the drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total free memory available on the drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we execute the code, the execution will loop through all the drives that
    are present in the filesystem. Once a drive is retrieved, the execution will retrieve
    certain properties about the drive, such as free space, total size, and drive
    type. Thus, when we execute the program, we will get the following output. Please
    note that we may not get all the information as it also depends upon the security
    permissions on the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afdd2c02-9e45-42c1-80be-08f0ee2b310d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the system in which we are executing this program, we just have a C drive.
    Thus, while the program is executing, we are showing the properties of the C drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other properties on the `driveinfo` object as well. If we click on
    Go to Definition on the `DriveInfo` class, we can see the attributes of the class.
    Please visit the following link for more information: [https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.driveinfo?view=netframework-4.7.2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each drive in a filesystem comprises directories and files. A directory in
    itself can comprise multiple sub-directories and files. If we need to do an operation
    on a particular directory, we do it using the `DirectoryInfo` class in C#. In
    the following code snippet, we are creating an object of the `DirectoryInfo` class,
    passing the location of a particular directory path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `directoryInfo` object, we are then looping through all the child directories
    and are showing the information related to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time the directory was created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time the directory was last modified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we execute the preceding program, we do so on the `C:\\UCN Code Base\\Programming-in-C-Exam-70-483-MCSD-Guide\\Book70483Samples`
    file path. Please note that this is where we have been placing the codebase for
    the chapters we''ve got through in this book. Thus, when we execute this program,
    it will loop through the sub-folders of all those chapters and will fetch information
    such as `Directory Name`, `Directory created time`, and `Directory last modified
    time`. The following is the output that we will get for the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4612923-6053-45fa-bd9e-66bfc4286adb.png)'
  prefs: []
  type: TYPE_IMG
- en: There are additional operations available with the `DirectoryInfo` object.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the directory exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using a particular directory path, we can identify if any directory with that
    path exists in the filesystem or not. In the code implementation, we are creating
    a `DirectoryInfo` object and then using the `Exists` property to check whether
    the directory exists in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the code using the path mentioned during the creation of the
    `DirectoryInfo` object, the program execution will determine whether there is
    a directory in the filesystem in the specified path. Thus, when the program is
    executed, as we do not currently have a sub-folder called `Chapter 20` in the
    `Book70483Samples` base folder we will see Does not exists in the console output
    window. The following is globally the relevant output on the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbe540ac-7c34-4fd9-ac85-449f85e1c677.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at how to create a directory in a filesystem
    using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `DirectoryInfo` class, we can also create new directories in the
    filesystem. The following code illustrates how we create a new directory in the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding code is executed, it will create a subdirectory called `Chapter
    20` in the root folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we are passing an absolute path to create the directory.
    However, if we need to create a subdirectory in a particular directory, we can
    just execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `parentDirectory` is the parent directory in which we
    want to create the subdirectory. `NameChildDirectory` is the name that we want
    to give to the child directory.
  prefs: []
  type: TYPE_NORMAL
- en: Looping through the files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `DirectoryInfo` class, we can also loop through the files present
    in the directory. The following code shows how we can loop through the files and
    access their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are looping through the files present in
    the `Chapter 20` directory and showing the information present in it. In the `Chapter
    20` folder, we have only one file: `dynamics365eula.txt`. Thus, when the program
    is executed, it will pick up the file and will read the file information present
    in it. To illustrate this, we are displaying the filename, the time the file was
    created, and the time the file was last accessed. So when the code is executed,
    we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9d8c047-0d90-4dd4-bfe0-928a8cdce0ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have some knowledge about drives and `DirectoryInfo`, we will explore
    some helper classes that allow us to do operations on files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the helper classes that allow us to do operations
    on the files present in a directory. C# provides the `File` and `FileInfo` helper
    classes to do operations on files. While going through the following code snippets,
    we will be looking at some of the typical operations that we can do with file
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a file exists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This basically involves checking whether a file with the given path exists
    or not. This can help us write fail-safe code in such a way that we read a file
    only after establishing that it exists in the given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`File` is a static class available in the `System.IO` namespace. This class
    provides operations that we can use to execute functionalities related to file
    access. In the preceding code, we have declared a file path and, using the static
    `File` class, we are checking whether the file indeed exists in the given path.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving a file from one location to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this operation, we basically cut the file from one location and paste it
    into another. The following code snippet shows how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are first checking whether the file exists
    in a particular location. If the file is present in the location, we are copying
    it into another location.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code is executed, we will notice that the file is cut from the source
    location and is pasted in to the target location.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a file from one location to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this operation, we basically copy the file from one location and paste it
    into another. Please note the `Move` operation will delete the file present in
    the source folder. However, the `Copy` operation will copy the file present in
    the source folder to the destination folder. The following code snippet shows
    how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the code is executed, we will see that the file is copied from the source
    file location and pasted in to the target file location path.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this operation, we delete a file present in the specified location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the code is executed, we will see that the file is deleted from the source
    file location. Once the code is executed, we will see that the file specified
    in the `sourceFileLocation` path has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that operations that work with the `File` class work the same way
    with the `FileInfo` class. The same implementations that we have done with the
    `File` class can be done via the `FileInfo` class as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all the preceding examples, we have been hard-coding the path property of
    the file. This is not a recommended practice as it is error-prone. For example,
    if you look at the actual path of any file and compare it to what we need to supply
    in the program, you will notice a difference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Actual path: `C:\File Location\Chapter 20\Sample.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Path which we need to specify in the program: `C:\\File Location\\Chapter 20\\Sample.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to provide some extra slashes in the path. Also, when we are combining
    the folder path with the file path, we need to concatenate them with an extra
    `\` as well. For these reasons, hardcoding the path is not a recommended practice.
    A better approach is to use the `Path` helper class. The following code shows
    how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code implementation, we have declared a folder path. Please
    also note the use of `&` before the filename. This is an escape character that
    allows us to not specify an extra `\` in the folder path structure. We have also
    declared a filename and are now combining the two together using the helper static
    class: `Path`. Once we have combined them, we retrieve the properties in the resulting
    file path. If the code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c6a1269-e54e-48ec-a187-e1c11e4fab4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s examine the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Path.GetDirectoryName`: This returns the directory name of the combined path
    file. Note that it has the complete absolute directory path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetExtension`: This returns the file extension of the combined path file.
    In this case, it''s a `.txt` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetFileName`: This returns the name of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Path.GetPathRoot`: This returns the root of the filepath. In this case, it''s
    `C:`, hence it''s mentioned in the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are aware of basic operations on files, we will look at how to access
    and modify the contents of a file. For this, we will look at the operations available
    in `FileStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Stream object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main operations with files are related to reading, writing, retrieving,
    and updating text present in file. In .NET, these operations are performed using
    an exchange of bytes in I/O operations. This sequence of bytes is a stream, and
    in .NET, it's represented using the abstract `Stream` class. This class forms
    the basis of all I/O operations in .NET such as `FileStream` and `MemoryStream`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With stream we can perform the following operations in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading data in the stream object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data into the stream object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for or finding relevant information from the stream object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at the different operations that are implemented using stream
    objects. In the next section, we will go through the `FileStream` object, which
    aids operations on the file object.
  prefs: []
  type: TYPE_NORMAL
- en: FileStream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `FileStream` object, we can read and write information back to the
    file in the directory. It's done using the `File` and `FileInfo` object we discussed
    in the previous section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets go through the following code example, in which we are writing information
    to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code implementation, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening the `Sample.txt` file that's present in the specified location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `File` object from it and then converting the data present in the
    file to a `FileStream` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to the file using the `Write` operation available in the `FileStream`
    object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that we are using the `using` block for the `FileStream` object.
    Due to this, the `Dispose` method will be automatically called for the `FileStream`
    object. Therefore, the memory from unmanaged resources will be reclaimed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that in the preceding implementation, we are encoding the string
    value before we are writing that data to the `FileStream` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of handling the same functionality is to use the `StreamWriter`
    helper class. The following code implementation shows how it can be handled using
    the `StreamWriter` helper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While choosing between the two helper classes, we need to consider the data
    we are dealing with. A `FileStream` object deals with an array of bytes. However,
    the `StreamWriter` class implements `TextWriter`. It only deals with string data
    and automatically encodes it into bytes so that we don't have to explicitly do
    it. However, in cases when we use the `FileStream` class, we must encode and decode
    the bytes to data into the string representation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some best practices relating to exception
    handling while dealing with file I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any real-world scenario, multiple people might be working with the same file
    concurrently. Using threading in C#, we can lock objects while a particular operation
    is happening on a resource. However, such locking is not available on files present
    in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it''s quite possible that files that are being accessed in the program
    have been moved or even deleted altogether by a different application or user.
    C# provides some exceptions with which we can handle such scenarios in a better
    way. Please refer to the following code implementation, where we are handling
    an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'From a functionality perspective, in the preceding code we are reading file
    present in the given location. We are retrieving all the text present in the file
    and then passing it back to the calling function. Please also note the following
    best practices that we are using in the code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we are first checking whether the file exists in the directory
    location using the `Exists` method. If the file exists, we proceed to extract
    data from the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though we have checked that the file exists before we proceed, there are
    still some circumstances in which the file is removed, deleted, or becomes inaccessible
    after the code moves to the next block. To handle such scenarios, we are catching
    the `DirectoryNotFoundException` and `FileNotFoundException` exceptions. `DirectoryNotFoundException`
    is thrown when the directory specified in the path no longer exists. `FileNotFoundException`
    is thrown when the file specified in the path no longer exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of how to execute I/O operations on a
    file, we will look at examples of calling external web services to get a response
    from them.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications in .NET Framework, we will encounter several scenarios
    where we need to call external APIs to get the required data. .NET Framework provides
    a `System.Net` namespace that provides a large number of helper classes that allow
    us to execute these operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will go through an example in which we will use the `WebRequest`
    and `WebResponse` classes to call the external APIs and process their responses.
    We will be calling an external page, and we also process the response that we
    will get from the call. We will also be looking at code examples in which we will
    learn how to make asynchronous calls to an external web server.
  prefs: []
  type: TYPE_NORMAL
- en: WebRequest and WebResponse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`WebRequest` is an abstract base class provided by .NET Framework for accessing
    data from the internet. Using this class, we send a request to a particular URL,
    such as `www.google.com`.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `WebResponse` is an abstract class that provides a response
    from the URL called by the `WebRequest` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WebRequest` object is created by calling the static `Create` method. In
    the method, we pass the address URL that we want to call in the request. The request
    inspects the address we are passing to it and selects a protocol implementation,
    for example, HTTP or FTP. Based upon the web address passed, an appropriate instance
    of the derived class, such as `HttpWebRequest` for HTTP or `FtpWebRequest` for
    FTP, is returned when the `WebRequest` object is created. The `WebRequest` class
    also allows us to specify some other properties, such as the authentication and
    content type. Let''s go through the following code implementation, which will
    help us learn more about this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code implementation, we are creating a `WebRequest` object
    for `http://google.com`. We are using a `GET` method in the `HTTP` request and
    passing parameters embedded in the URL itself. As the protocol is `HTTP`, we are
    converting the `WebResponse` object to `httpWebResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have captured the response, we are retrieving the stream of bytes into
    a `Stream` object and are then using a `StreamReader` object to retrieve the response
    from `google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very important thing to note here is that in the `finally` block, we are
    closing all the response, stream, and reader objects that have been created in
    the `try`...`catch` block. This is essential: as we are dealing with unmanaged
    resources, it''s important to reclaim the memory for better performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For further reading, please refer to the following blog from Microsoft, which
    discusses the different parameters that we can set in the `WebRequest` object
    when we are making a call: [https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.net.webrequest?view=netframework-4.7.2).'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we were making synchronous calls to the external web
    service and waiting for a response. However, in a real-world scenario, this may
    not be the ideal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The external server to which we are making a call may take some time to send
    us the response. Therefore, if our application continues to wait for a response
    during this time, the responsiveness of the application will be challenged. To
    avoid such scenarios, we can make I/O calls asynchronous. In the next section,
    we will learn why we need to look at making asynchronous I/O calls and how they're
    implemented in code.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous I/O operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were going through the `WebRequest` and `WebResponse` section, we wrote
    a program in which we made a call to `google.com`. In very crude terms, when the
    request is made, it's picked up by the Google server, which then assigns a thread
    to cater to this request. The thread then sends the response to the calling machine.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically, however, there is always a possibility that fewer free threads
    are available on the server. Also, there is the possibility that the server may
    take a long time to complete the request and send the response to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge here is that we must design communication between the caller and
    the server is such a way that the performance and responsiveness of the application
    are not compromised. We do that by making the calls asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: If we make these operations asynchronous, we can rest assured that, while the
    server is processing the request and sending us the response, our application
    remains responsive and users can continue using the application. We do this using
    the `async`/`await` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any method that is written asynchronously in C# must have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: The method definition must have the `async` keyword to indicate that the method
    is executed asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method must have one of the following return types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`: If the function has no return statements'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task<TResult>`: If the function has a return statement in which the object
    being returned is of type `TResult`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Void`: If the function is an event handler'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the function, we execute an asynchronous call to an external web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function may have an `await` statement. The `await` statement basically
    tells the compiler that the application must wait at that statement for the asynchronous
    process executed by the external web server to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go through all these points in the following code implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer to the following in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have defined a function called `ExecuteOperationAsync`. To indicate the asynchronous
    behavior of the function, we have used the `async` keyword in the function definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have declared the return type of the function as `Task<int>`, which indicates
    that the function will return an object of type `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have declared an object of the `HttpClient` helper class and are making a
    call to `http://google.com`. We are making the request call asynchronously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure that the application carries on doing other work, we are calling the
    `ExecuteParallelWork` function so that, until the response arrives, the application
    does not stop processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used an `await` statement so that the compiler stops at that point and
    waits for the response for a asynchronous request call. Once the response is received,
    it checks the length of the response string and returns the result to the calling
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a fair understanding of how asynchronous calls work in I/O
    operations, we will look at how to use them in I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at how different I/O operations can be made
    asynchronous using this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Async operations on file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to perform I/O operations on a file asynchronously.
    This can be helpful in scenarios when the data that we are writing to the file
    is large.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code implementation shows how to write data to a file asynchronously.
    Please note that we must use the `FileStream` object to execute file I/O operations
    asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code implementation, we are creating a new file in a given
    directory location. The calling function does not require a value to be returned,
    so we have just set the return type as `Task`. To create the file and write data
    to it, we have used a `FileStream` object. For a detailed analysis of the properties
    passed in the constructor of the class, please refer to the following link: [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netframework-4.7.2).'
  prefs: []
  type: TYPE_NORMAL
- en: After creating the object, we are generating a random sequence of bytes and
    are then writing it asynchronously to the `FileStream` object.
  prefs: []
  type: TYPE_NORMAL
- en: For a code implementation related to calling web requests asynchronously, we
    can refer to the implementation in the previous example where we created an object
    called `HttpClient` and made a call asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to execute multiple I/O operations asynchronously
    and in a parallel manner.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite useful in scenarios where the application must wait for the completion
    of different functions that are executing in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Using the await statement for parallel asynchronous calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing programs, we often come across situations in which we must wait
    for results from different asynchronous calls. This is required when the processing
    is dependent upon multiple responses from an external medium, such as web services.
    Let''s look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are executing asynchronous calls to different servers.
    Suppose we have to wait for the output from all of them before we can proceed;
    we can use the `WhenAll` statement. The `WhenAll` statement will ensure that the
    execution waits for responses from all three asynchronous calls before the processing
    can move ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to execute I/O operations related to files and
    networks in C#. We went over namespaces that provide helper classes for executing
    I/O operations. We started with the basic operations that we can perform on drives
    and directories. We looked at code that we can use to loop through files in directories.
  prefs: []
  type: TYPE_NORMAL
- en: Then we looked at the helper classes that help us with I/O operations on files.
    We looked at the `File` and `FileInfo` classes, which help us create, copy, move,
    and delete files. We looked at best practices for dealing with directory and file
    paths. We then looked at s*treams*, or sequences of bytes, which allow us to edit
    information present in files. We then looked at best practices for exception handling
    in files.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at helper classes for dealing with I/O operations over
    networks. We looked at a code example in which we made HTTP calls over the internet.
    We then looked at a code implementation in which we made asynchronous I/O calls.
    Whenever possible, it's always beneficial to use asynchronous operations because
    it's better for the overall performance of the application. We went over code
    examples for executing asynchronous operations on both I/O and over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how LINQ queries can we used in C# to work
    efficiently when we are querying different data sources, such as XML and SQL.
    Working with code examples, we will explore the different components of LINQ,
    along with the different operators that we can use while working with LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which syntax should we use to append text to a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`File.CreateText`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FileInfo.Create`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`File.Create`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`File.AppendText`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which syntax should we use if the application needs to wait for asynchronous
    calls from multiple sources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`async`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`await`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task.WhenAll`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which one of the following statements is incorrect?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StreamWriter` only works with text; however, `FileStream` works with bytes.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We can lock files in .NET.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we have an asynchronous function, it can have one of three return types:
    `Task`, `Task<TResult>`, and `Void`.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DirectoryNotFoundException` is thrown when the directory in the file path
    is no longer available.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**File.AppendText.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Task.WhenAll.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Except "B" that is we can lock files, all other statements are true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
