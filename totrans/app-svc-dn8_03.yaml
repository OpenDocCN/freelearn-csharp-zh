- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Entity Models for SQL Server Using EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about managing relational data stored in SQL Server, Azure SQL
    Database, or Azure SQL Edge by using the higher-level object-to-data store mapping
    technology named **Entity Framework Core** (**EF Core**). Then, you will learn
    how to store entity models that use inheritance hierarchies using three different
    mapping strategies. Finally, you will build class libraries for a SQL Server database
    that will be used in code examples throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing SQL Server data with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping inheritance hierarchies with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a reusable entity data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing data with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core is an **object-relational mapper** (**ORM**) that uses ADO.NET underneath
    when working with SQL Server. Because it is a higher-level technology, it is not
    as efficient as using ADO.NET directly, but it can be easier for developers to
    work with because they can treat the data as objects instead of rows in multiple
    tables. This should feel more natural for an object-oriented developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'EF Core 8 only targets .NET 8\. EF Core 7 targeted .NET 6, so it could be used
    with both the **Long Term Support** (**LTS**) release of .NET 6 and the **Standard
    Term Support** (**STS**) release of.NET 7, as shown in *Figure 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19587_03_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: EF Core 7 targeted .NET 6 or later'
  prefs: []
  type: TYPE_NORMAL
- en: When EF Core 9 is released in November 2024, we can expect it to target .NET
    8 or later, so you can upgrade EF Core while still getting long-term support for
    the .NET 8 platform. The EF Core team is responsible for making sure that you
    will be able to swap 8 for 9 in the version number of their packages and your
    code should still work. They are usually very good at that, and they will document
    any needed changes to your code in the official release notes for EF Core 9.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Entity Framework Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as traditional RDBMSs like SQL Server, EF Core supports modern cloud-based,
    nonrelational, schema-less data stores, such as Azure Cosmos DB and MongoDB, sometimes
    with third-party providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches to working with EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database First**: A database already exists, so you build a model that matches
    its structure and features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code First**: No database exists, so you build a model and then use EF Core
    to create a database that matches its structure and features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use EF Core with an existing database because that is the most common
    scenario. You will also see an example of Code First later in this chapter that
    will create its database at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding models using an existing database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scaffolding is the process of using a tool to create classes that represent
    the model of an existing database using reverse engineering. A good scaffolding
    tool allows you to extend the automatically generated classes and then regenerate
    those classes without losing your extended classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that you will never regenerate the classes using the tool, then
    feel free to change the code for the automatically generated classes as much as
    you want. The code generated by the tool is just the best approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Do not be afraid to overrule a tool when you know better.
    For example, when using SQLite for the Northwind database, date/time columns are
    mapped to `string` properties, and `money` columns are mapped to `double` properties.
    In the Northwind database, these would be better mapped to `DateTime` and `decimal`
    respectively, but in another database, they might need more flexibility. As another
    example, in the Northwind database, a `CustomerId` should always be five uppercase
    alphabetic characters. The tool cannot infer this automatically, so you could
    add a regular expression to validate it. Keep in mind that tool behavior is one
    of the more volatile components of .NET, so these examples may not be valid by
    the time you read this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the dotnet-ef tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET has a command-line tool named `dotnet`. It can be extended with capabilities
    useful for working with EF Core. It can perform design-time tasks like creating
    and applying migrations from an older model to a newer model and generating code
    for a model from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet` `ef` command-line tool is not automatically installed. You must
    install this package as either a **global** or **local tool**. If you have already
    installed an older version of the tool, then you should uninstall any existing
    version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make sure you have the latest version of the tool installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, check if you have already installed `dotnet-ef`
    as a global tool, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check in the list if an older version of the tool has been installed, like
    the one for .NET 7, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If an older version is already installed, then uninstall the tool, as shown
    in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the latest version, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If necessary, follow any OS-specific instructions to add the `dotnet tools`
    directory to your `PATH` environment variable, as described in the output of installing
    the `dotnet-ef` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to install a preview version, you can specify a version wildcard,
    for example, for EF Core 9 previews, as shown in the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`dotnet tool install --global dotnet-ef --version 9-*`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of uninstalling and then installing, you can update using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining EF Core models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EF Core uses a combination of **conventions**, **annotation attributes**, and
    **Fluent API** statements to build an **entity model** at runtime so that any
    actions performed on the classes can later be automatically translated into actions
    performed on the actual database. An **entity class** represents the structure
    of a table, and an instance of the class represents a row in that table.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will review the three ways to define a model, with code examples,
    and then we will create some classes that implement those techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core conventions to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we will write will use the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a table is assumed to match the name of a `DbSet<T>` property in
    the `DbContext` class, for example, `Products`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the columns are assumed to match the names of properties in the
    entity model class, for example, `ProductId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` .NET type is assumed to be an `nvarchar` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int` .NET type is assumed to be an `int` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key is assumed to be a property that is named `Id` or `ID`. Or,
    when the entity model class is named `Product`, then the property can be named
    `ProductId` or `ProductID`. If this property is of an integer type or the `Guid`
    type, then it is also assumed to be an `IDENTITY` column (a column type that automatically
    assigns a value when inserting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice**: There are many other conventions that you should know, and
    you can even define your own, but that is beyond the scope of this book. You can
    read about them at the following link: [https://learn.microsoft.com/en-us/ef/core/modeling/](https://learn.microsoft.com/en-us/ef/core/modeling/).'
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core annotation attributes to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conventions often aren’t enough to completely map the classes to the database
    objects. For example, some databases like SQLite use dynamic column types so the
    tool has to guess about what property types its columns should map to, based on
    the current data values in that column.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way of adding more smarts to your model is to apply annotation attributes,
    as shown in *Table 3.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `[Required]` | Ensures the value is not null. |'
  prefs: []
  type: TYPE_TB
- en: '| `[StringLength(50)]` | Ensures the value is up to 50 characters in length.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[RegularExpression(expression)]` | Ensures the value matches the specified
    regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | Specifies the column
    type and column name used in the table. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.1: Common EF Core annotation attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the database, the maximum length of a product name is 40, and
    the value cannot be null, as shown highlighted in the following partial DDL code,
    which defines how to create a table named `Products`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In a `Product` class, we could apply attributes to specify this, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Good Practice**: If you have nullability checks enabled, then you do not
    need to decorate a non-nullable reference type with the `[Required]` attribute
    as shown above. This is because the C# nullability will flow to the EF Core model.
    A `string` property will be required; a `string?` property will be optional, in
    other words, nullable. You can read more about this at the following link: [https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties](https://learn.microsoft.com/en-us/ef/core/modeling/entity-properties?tabs=data-annotations%2Cwith-nrt#required-and-optional-properties).'
  prefs: []
  type: TYPE_NORMAL
- en: When there isn’t an obvious map between .NET types and database types, an attribute
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the database, the column type of `UnitPrice` for the `Products`
    table is `money`. .NET does not have a `money` type, so it should use `decimal`
    instead, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is for the `Categories` table, as shown highlighted in the
    following DDL code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Description` column can be longer than the maximum 8,000 characters that
    can be stored in an `nvarchar` variable, so it needs to map to `ntext` instead,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the EF Core Fluent API to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last way that the model can be defined is by using the Fluent API. This
    API can be used instead of attributes, as well as being used in addition to them.
    One reason you might need to do this is if the entity models need to be defined
    in a .NET Standard 2.0 class library so they can be used on legacy platforms.
    In this case, the class library should not include references to data annotation
    libraries. Another reason is that your team might have a policy to separate raw
    data models from validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to define the `ProductName` property, instead of decorating the
    property with two attributes, an equivalent Fluent API statement could be written
    in the `OnModelCreating` method of the database context class, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This keeps the entity model class simpler. You will see an example of this in
    the coding task below.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data seeding with the Fluent API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another benefit of the Fluent API is to provide initial data to populate a database.
    EF Core automatically works out what insert, update, or delete operations must
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to make sure that a new database has at least one
    row in the `Product` table, then we would call the `HasData` method, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Calls to `HasData` take effect either during a data migration executed by the
    `dotnet ef database update` command or when you call the `Database.EnsureCreated`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Our model will map to an existing database that is already populated with data,
    so we will not need to use this technique in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Northwind database model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Northwind` class will be used to represent the database. To use EF Core,
    the class must inherit from `DbContext`. This class understands how to communicate
    with databases and dynamically generate SQL statements to query and manipulate
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Your `DbContext`-derived class should have an overridden method named `OnConfiguring`,
    which will set the database connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Inside your `DbContext`-derived class, you must define at least one property
    of the `DbSet<T>` type. These properties represent the tables. To tell EF Core
    what columns each table has, the `DbSet<T>` properties use generics to specify
    a class that represents a row in the table. That entity model class has properties
    that represent its columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `DbContext`-derived class can optionally have an overridden method named
    `OnModelCreating`. This is where you can write Fluent API statements as an alternative
    to decorating your entity classes with attributes. This can enhance the clarity
    and maintainability of the model configuration because all of it could be in one
    place instead of scattered throughout your code base. You can also mix and match
    both techniques, but then you’d lose this primary benefit.
  prefs: []
  type: TYPE_NORMAL
- en: If you did not create the Northwind database, or if you deleted it, then you
    will need to create it now. Instructions are in *Chapter 2, Managing Relational
    Data Using SQL Server*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the model for the Northwind database in a console app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a console app project, as defined
    in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter03`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Console.EFCore`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Console.EFCore` project, add package references to the EF
    Core data provider for SQL Server, and globally and statically import the `System.Console`
    class, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step assumes a database connection string for a local SQL Server authenticated
    with Windows integrated security. Modify it for Azure SQL Database or Azure SQL
    Edge with a user ID and password if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal in the `Northwind.Console.EFCore` folder, generate
    a model for all the tables in a new folder named `Models`, as shown in the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Command-line tools need to have their commands entered all in one line. The
    `dotnet-ef` tool often needs long commands to be entered. I recommend that you
    type from the print book or copy and paste long commands like this from the eBook
    into a plain text editor like Notepad. Then make sure that the whole command is
    properly formatted as a single line with correct spacing before you then copy
    and paste it to the command line. Copying and pasting directly from the eBook
    is likely to include newline characters, missing spaces, and so on that break
    the command. All command lines that must be entered from this book are available
    to copy from as a single line at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/command-lines.md).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The command action: `dbcontext scaffold`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The connection string: This will be different depending on whether you are
    connecting to a local SQL Server (with or without an instance name) or Azure SQL
    Database.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.SqlServer`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output folder: `--output-dir Models`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace Northwind.Models`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of data annotations as well as the Fluent API: `--data-annotations`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Renaming the context from `[database_name]Context`: `--context NorthwindDb`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note the build messages and warnings, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Do not commit your project to Git until you have fixed this
    warning. If you used a username and password to connect to your SQL Server database,
    then that information is now in your source code! We will fix this by replacing
    the fixed connection string with a dynamically generated one that reads the sensitive
    values from environment variables.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `Models` folder and note the 28 class files that were automatically
    generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Category.cs` and note that it represents a row in the `Categories` table,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It decorates the entity class with the `[Index]` attribute that was introduced
    in EF Core 5\. This indicates properties that should have an index for its column
    in the table. In earlier versions, only the Fluent API was supported for defining
    indexes. Since we are working with an existing database, this attribute is not
    needed. But if we want to recreate a new empty Northwind database from our code,
    then this information will be used to create indexes in the `Categories` table.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name in the database is `Categories` but the `dotnet-ef` tool used
    the **Humanizer** third-party library to automatically singularize the class name
    to `Category`, which is a more natural name when creating a single entity.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The entity class is declared using the `partial` keyword so that you can create
    a matching `partial` class for adding additional code. This allows you to rerun
    the tool and regenerate the entity class without losing that extra code you wrote
    in your `partial` class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryId` property is decorated with the `[Key]` attribute to explicitly
    indicate that it is the primary key for this entity although its name follows
    the primary key convention too.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Products` property uses the `[InverseProperty]` attribute to define the
    foreign key relationship to the `Category` property on the `Product` entity class.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `ProductsAboveAveragePrice.cs` and note that it represents a row returned
    by a database view rather than a table, so it is decorated with the `[Keyless]`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `NorthwindDb.cs` and review the class, as shown in the following edited-for-space
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `NorthwindDb` data context class is `partial` to allow you to extend it
    and regenerate it in the future. We used the name `NorthwindDb` because `Northwind`
    is used for a namespace.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NorthwindDb` has two constructors: a default parameter-less one and one that
    allows options to be passed in. This is useful in apps where you want to specify
    the connection string at runtime.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DbSet<T>` properties that represent tables like `Categories`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnConfiguring` method, if options have not been specified in the constructor,
    then it defaults to using the connection string used during scaffolding. It has
    a compiler warning to remind you that you should not hardcode security information
    in this connection string.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnModelCreating` method, the Fluent API is used to configure the entity
    classes, and then a partial method named `OnModelCreatingPartial` is invoked.
    This allows you to implement that partial method in your own partial `Northwind`
    class to add your own Fluent API configuration, which will not be lost if you
    regenerate the model classes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the top of the `NorthwindDb.cs` file, import the namespace for working with
    ADO.NET types, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the `OnConfiguring` method to dynamically set the connection string
    and set any sensitive parameters using environment variables, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Close the automatically generated class files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**More Information**: If you have not worked with environment variables before,
    then you can learn about them from an online section available at the following
    link: [https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md](https://github.com/markjprice/cs12dotnet8/blob/main/docs/ch09-environment-variables.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Querying the Northwind model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can query the model:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements. Add statements to create an
    instance of the `NorthwindDb` data context class and use it to query the products
    table for those that cost more than a given price, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the console app and note the results, as shown in the following partial
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of your connection string will be different.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the tracking of entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to start with the definition of entity **identity resolution**. EF Core
    resolves each entity instance by reading its unique primary key value. This ensures
    no ambiguities about the identities of entities or relationships between them.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core can only track entities with keys because it uses a key to uniquely
    identify the entity in the database. Keyless entities, like those returned by
    views, are never tracked.
  prefs: []
  type: TYPE_NORMAL
- en: By default, EF Core assumes that you want to track entities in local memory
    so that if you make changes, like adding a new entity, modifying an existing entity,
    or removing an existing entity, then you can call `SaveChanges` and all those
    changes will be made in the underlying data store.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute a query within a data context, like getting all customers in
    Germany, and then execute another query within the same data context, like getting
    all customers whose name starts with A, if one of those customer entities already
    exists in the context, it will be identified and not replaced or loaded twice.
    However, if the telephone number of that customer is updated in the database between
    the executions of the two queries, then the entity being tracked in the data context
    is not refreshed with the new telephone number.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not need to track these changes, or you want to load new instances
    of an entity for every query execution with the latest data values, even if the
    entity is already loaded, then you can disable tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable tracking for an individual query, call the `AsNoTracking` method
    as part of the query, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable tracking by default for the data context, set the change tracker’s
    query tracking behavior to `NoTracking`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable tracking for an individual query, but retain identity resolution,
    call the `AsNoTrackingWithIdentityResolution` method as part of the query, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable tracking but perform identity resolution by default for the data
    context, set the change tracker’s query-tracking behavior to `NoTrackingWithIdentityResolution`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To set defaults for all new instances of a data context, in the `OnConfiguring`
    method, call the `UseQueryTrackingBehavior` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A scenario using default tracking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default is **change tracking** with identity resolution. Once an entity
    is loaded into the data context, underlying changes are not reflected and only
    one copy exists. Entities have local changes tracked and a call to `SaveChanges`
    updates the database, as shown in *Table 3.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Entity in data context** | **Row in database** |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste,
    123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Save changes | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-1928
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.2: Default tracking scenario'
  prefs: []
  type: TYPE_NORMAL
- en: The same scenario using no tracking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**No tracking** and no identity resolution. Every query loads another instance
    of a database row into the data context, including underlying changes, allowing
    duplicates and mixed out-of-date and updated data. No local entity changes are
    tracked, so `SaveChanges` does nothing, as shown in *Table 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Entities in data context** | **Row in database** |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567Alfred’s
    Futterkiste, 123-9876 | Alfred’s Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste,
    123-9876Alfred’s Futterkiste, 123-9876 | Alfred’s Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste,
    123-9876Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Save changes | Alfred’s Futterkiste, 123-4567Alfred’s Futterkiste, 123-9876Alfred’s
    Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.3: No tracking scenario'
  prefs: []
  type: TYPE_NORMAL
- en: The same scenario using no tracking with identity resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No tracking with identity resolution. Once an entity is loaded into the data
    context, underlying changes are not reflected and only one copy exists. No local
    entity changes are tracked, so `SaveChanges` does nothing, as shown in *Table
    3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Action** | **Entities in data context** | **Row in database** |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-4567 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in database | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers starting with A | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Query for customers in Germany | Alfred’s Futterkiste, 123-4567 | Alfred’s
    Futterkiste, 123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Change telephone in entity | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste,
    123-9876 |'
  prefs: []
  type: TYPE_TB
- en: '| Save changes | Alfred’s Futterkiste, 123-1928 | Alfred’s Futterkiste, 123-9876
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.4: Identity resolution scenario'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of tracking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which should you choose? Of course, it depends on your specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: You will sometimes read blogs that excitedly tell you that you can dramatically
    improve your EF Core queries by calling `AsNoTracking`. But if you run a query
    that returns thousands of entities and then run the same query again within the
    same data context, you now have thousands of duplicates! This wastes memory and
    impacts performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understand how the three tracking choices work and select the best for your
    data context or individual queries. In the next topic, you will learn how to map
    inheritance hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping inheritance hierarchies with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have an inheritance hierarchy for some C# classes to store
    information about students and employees, both of which are types of people. All
    people have a name and an ID to uniquely identify them, students have a subject
    they are studying, and employees have a hire date, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By default, EF Core will map these to a single table using the **table-per-hierarchy**
    (**TPH**) mapping strategy. EF Core 5 introduced support for the **table-per-type**
    (**TPT**) mapping strategy. EF Core 7 introduced support for the **table-per-concrete-type**
    (**TPC**) mapping strategy. Let’s explore the differences between these mapping
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Table-per-hierarchy (TPH) mapping strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPH will use a single table
    structure with a discriminator column to indicate which type of person, a student
    or employee, the row is, with nullable columns for extra values that only apply
    to some of the types, as shown highlighted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Some data in the table might look like *Table 3.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Name** | **Discriminator** | **Subject** | **HireDate** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Roman Roy | Student | History | NULL |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Kendall Roy | Employee | NULL | 02/04/2014 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Siobhan Roy | Employee | NULL | 12/09/2020 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.5: Sample data in the People table'
  prefs: []
  type: TYPE_NORMAL
- en: TPH requires the `Discriminator` column to store the class name of the type
    for each row. TPH requires the columns for properties of derived types to be nullable,
    like `Subject` and `HireDate`. This will cause an issue if those properties are
    required (non-null) at the class level. EF Core does not handle this by default.
  prefs: []
  type: TYPE_NORMAL
- en: The main benefits of the TPH mapping strategy are simplicity and performance,
    which is why it is used by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: If the discriminator column has many different values, then
    you can improve performance even more by defining an index on the discriminator.
    But if there are only a few different values, an index may make overall performance
    worse because it affects updating time. In this case, there are only two potential
    values, `Student` and `Employee`, so in a table with 100,000 rows, an index would
    make little difference.'
  prefs: []
  type: TYPE_NORMAL
- en: Table-per-type (TPT) mapping strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPT will use a table for every
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Some data in the tables might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Name** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Roman Roy |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Kendall Roy |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Siobhan Roy |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.6: People table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Subject** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | History |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.7: Students table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **HireDate** |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 02/04/2014 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 12/09/2020 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.8: Employees table'
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of the TPT mapping strategy is reduced storage due to the full
    normalization of the data. The main disadvantage is that a single entity is spread
    over multiple tables and reconstructing it takes more effort and therefore reduces
    overall performance. TPT is usually a poor choice, so only use it if the table
    structure is already normalized and cannot be restructured.
  prefs: []
  type: TYPE_NORMAL
- en: Table-per-concrete-type (TPC) mapping strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the `Person`-`Student`-`Employee` hierarchy, TPC will use a table for each
    non-abstract type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since there is not a single table with an `IDENTITY` column to assign `Id` values,
    we can use the `(NEXT VALUE FOR [PersonIds])` command to define a sequence shared
    between the two tables so they do not assign the same `Id` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some data in the tables might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Name** | **Subject** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Roman Roy | History |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.9: Students table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Name** | **HireDate** |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Kendall Roy | 02/04/2014 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Siobhan Roy | 12/09/2020 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 3.10: Employees table'
  prefs: []
  type: TYPE_NORMAL
- en: The main benefit of the TPC mapping strategy is performance because when querying
    a single concrete type, only one table is needed so we avoid expensive joins.
    It works best for large inheritance hierarchies of many concrete types, each with
    many type-specific properties.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring inheritance hierarchy mapping strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, all types must be included in the model, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For TPH, you are now finished, because it is the default! If you want to make
    this explicit, then in the data context class `OnModelCreating` method, call the
    appropriate “use mapping strategy” method on the base class of the hierarchy.
    `Person` is the base class, so you would call `UseTphMappingStrategy` on that
    entity type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To use either of the other two mapping strategies, call the appropriate method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can optionally specify the table name to use for each entity class,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The TPC strategy should have a shared sequence, so we should configure that
    too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Example of hierarchy mapping strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s see this in action using a new database and project named `HierarchyMapping`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a console app project, as defined in
    the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter03`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Console.HierarchyMapping`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Do not use top-level statements**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enable native AOT publish**: Cleared.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the startup project to run `Northwind.Console.HierarchyMapping`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Console.HierarchyMapping` project, add package references
    to the EF Core data provider for SQL Server, and globally and statically import
    the `System.Console` class, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Northwind.Console.HierarchyMapping` project, add a new folder named
    `Models`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Models`, add a new class file named `Person.cs`, and modify its contents,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Models`, add a new class file named `Student.cs`, and modify its contents,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Models`, add a new class file named `Employee.cs`, and modify its contents,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Models`, add a new class file named `HierarchyDb.cs`, and modify its contents,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Program.cs`, delete the existing statements. Add statements to configure
    the connection string for the `HierarchyDb` data context and then use it to delete
    and then create a database named `HierarchyMapping` (not `Northwind`!), show the
    automatically generated SQL script, and then output the students, employees, and
    people, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the console app, and note the results including the single table named
    `People` that is created, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your preferred database tool, view the contents of the `People` table, as
    shown in *Figure 3.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_03_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The People table when using the TPH mapping strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Close the connection to the `HierarchyMapping` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `HierarchyDb.cs`, comment out the method call that configures TPH and add
    a call to the method that configures TPT, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the console app, and note the results including the three tables named
    `People`, `Students`, and `Employees` that are created, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your preferred database tool, view the contents of the tables, as shown
    in *Figure 3.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_03_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: The tables when using the TPT mapping strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Close the connection to the `HierarchyMapping` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `HierarchyDb.cs`, comment out the method call that configures TPT. Add a
    call to the method that configures TPC and configure a sequence to track assigned
    ID values starting at four because we always add three sample rows, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the console app, and note the results including the two tables named
    `Students` and `Employees` that are created as well as the shared sequence that
    starts at 4, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your preferred database tool, view the contents of the tables, as shown
    in *Figure 3.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The tables when using the TPC mapping strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Close the connection to the `HierarchyMapping` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, after the statement to write the `database create` script
    to the console, add some statements to add two new people using the current database
    context, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the console app, and note the results, including the two new people added
    using the database context with IDs that start at 4, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now seen how an object-relational mapper like EF Core can define an object
    inheritance hierarchy and map it in three different ways to an underlying database
    structure with one or more related tables. You’ve also seen how Code First works
    especially well with this since it is so easy to delete and recreate the database
    each time the project starts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a reusable entity data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practical applications usually need to work with data in a relational database
    or another data store. Earlier in this chapter, we defined EF Core models in the
    same console app project that we used them in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will define an entity data model for the Northwind database as a pair
    of reusable class libraries. One part of the pair will define the entities, like
    `Product` and `Customer`. The second part of the pair will define the tables in
    the database and the default configuration for how to connect to the database,
    and use the Fluent API to configure additional options for the model. This pair
    of class libraries will be used in many of the apps and services that you create
    in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should create a separate class library project for your
    entity data models. This allows easier sharing between backend web servers and
    frontend desktop, mobile, and Blazor clients.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library for entity models using SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will now create the entity models using the `dotnet-ef` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.EntityModels.SqlServer`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter03`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, treat warnings as
    errors, and add package references for the SQL Server database provider and EF
    Core design-time support, as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**More Information**: If you are unfamiliar with how packages like `Microsoft.EntityFrameworkCore.Design`
    can manage their assets, then you can learn more at the following link: [https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets](https://learn.microsoft.com/en-us/nuget/consume-packages/package-references-in-project-files#controlling-dependency-assets).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the `Class1.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.Common.EntityModels.SqlServer` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a command prompt or terminal for the `Northwind.Common.EntityModels.SqlServer`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step assumes a database connection string for a local SQL Server authenticated
    with Windows integrated security. Modify it for Azure SQL Database or Azure SQL
    Edge with a user ID and password if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the command line, generate entity class models for all tables, as shown
    in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The command to perform: `dbcontext scaffold`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The connection string: `"``Data Source=.;Initial Catalog=Northwind;Integrated
    Security=true;TrustServerCertificate=True;"` .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.SqlServer`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace for the generated classes: `--namespace Northwind.EntityModels`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that 28 classes were generated, from `AlphabeticalListOfProduct.cs` to
    `Territory.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NorthwindContext.cs`, delete the `OnConfiguring` method including the warning
    and connection string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Customer.cs`, the `dotnet-ef` tool correctly identified that the `CustomerId`
    column is the primary key and it is limited to a maximum of five characters, but
    we also want the values to always be uppercase. So, add a regular expression to
    validate its primary key value to only allow uppercase Western characters, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a class library for the data context using SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, you will move the context model that represents the database to a separate
    class library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `Northwind.Common.DataContext.SqlServer`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter03`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `DataContext` project, add a project reference to the `EntityModels`
    project, and add a package reference to the EF Core data provider for SQL Server,
    as shown in the following markup:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The path to the project reference should not have a line break
    in your project file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Northwind.Common.DataContext.SqlServer` project, delete the `Class1.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the `Northwind.Common.DataContext.SqlServer` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the `NorthwindContext.cs` file from the `Northwind.Common.EntityModels.SqlServer`
    project/folder to the `Northwind.Common.DataContext.SqlServer` project/folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a class named
    `NorthwindContextExtensions.cs`, and modify its contents to define an extension
    method that adds the Northwind database context to a collection of dependency
    services, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the two class libraries and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: We have provided an optional argument for the `AddNorthwindContext`
    method so that we can override the SQL Server database connection string. This
    will allow us more flexibility, for example, to load these values from a configuration
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Calculated properties on entity creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: EF Core 7 added an `IMaterializationInterceptor` interface that allows interception
    before and after an entity is created, and when properties are initialized. This
    is useful for calculated values.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a service or client app requests entities to show to the user,
    it might want to cache a copy of the entity for a period of time. To do this,
    it needs to know when the entity was last refreshed. It would be useful if this
    information was automatically generated and stored with each entity at the time
    of loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal, we must complete four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, define an interface with the extra property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, at least one entity model class must implement the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, define a class that implements the interceptor interface with a method
    named `InitializedInstance` that will execute on any entity, and if that entity
    implements the custom interface with the extra property, then it will set its
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we must create an instance of the interceptor and register it in the
    data context class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let’s implement this for Northwind `Employee` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, add a new file named
    `IHasLastRefreshed.cs`, and modify its contents to define the interface, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Northwind.Common.EntityModels.SqlServer` project, add a new file named
    `EmployeePartial.cs`, and modify its contents to implement the interface, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Good Practice**: Add extension code like this to a separate partial entity
    class file so that you can later regenerate the `Employee.cs` file using the `dotnet-ef`
    tool without overwriting your additional code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a new file named
    `SetLastRefreshedInterceptor.cs`, and modify its contents to define the interceptor,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Northwind.Common.DataContext.SqlServer` project, in `NorthwindContext.cs`,
    delete the existing `OnConfiguring` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Northwind.Common.DataContext.SqlServer` project, add a new file named
    `NorthwindContextPartial.cs`, then declare and register the interceptor in the
    `OnConfiguring` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a test project to check the integration of the class libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we will not be creating a client project in this chapter that uses the
    EF Core model, we should create a test project to make sure the database context
    and entity models integrate correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred coding tool to add a new **xUnit Test Project [C#]** / `xunit`
    project named `Northwind.Common.EntityModels.Tests` to the `Chapter03` solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Northwind.Common.EntityModels.Tests.csproj`, modify the configuration to
    treat warnings as errors and to add an item group with a project reference to
    the `Northwind.Common.DataContext.SqlServer` project, as shown in the following
    markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Warning!** The path to the project reference should not have a line break
    in your project file.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Build the `Northwind.Common.EntityModels.Tests` project to build and restore
    project dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing unit tests for entity models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-written unit test will have three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: This part will declare and instantiate variables for input and
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act**: This part will execute the unit that you are testing. In our case,
    that means calling the method that we want to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assert**: This part will make one or more assertions about the output. An
    assertion is a belief that, if not true, indicates a failed test. For example,
    when adding 2 and 2, we would expect the result to be 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write some unit tests for the `NorthwindContext` and entity model
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the file `UnitTest1.cs` to `NorthwindEntityModelsTests.cs` and then open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, rename the class to `NorthwindEntityModelsTests`. (Visual
    Studio prompts you to rename the class when you rename the file.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `NorthwindEntityModelsTests` class to import the `Northwind.EntityModels`
    namespace and have some test methods for ensuring the context class can connect,
    ensuring the provider is SQL Server, and ensuring the first product is named `Chai`,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running unit tests using Visual Studio 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio 2022, navigate to **Test** | **Run All Tests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **Test Explorer**, note that the results indicate that four tests ran, and
    all passed, as shown in *Figure 3.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B19587_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: All unit tests passed'
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests using Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are ready to run the unit tests and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio Code, in the `Northwind.Common.EntityModels.Tests` project’s
    **TERMINAL** window, run the tests, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using **C# Dev Kit**, then you can also build the test project and
    then run the tests from the **Testing** section in the **Primary Side Bar**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the output, note that the results indicate that four tests ran, and all passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an optional task, can you think of other tests you could write to make sure
    the database context and entity models are correct?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What can the `dotnet-ef` tool be used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type would you use for the property that represents a table, for example,
    the `Products` property of a data context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type would you use for the property that represents a one-to-many relationship,
    for example, the `Products` property of a `Category` entity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the EF Core convention for primary keys?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you choose the Fluent API in preference to annotation attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you implement the `IMaterializationInterceptor` interface in an entity
    type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 3.2 – Practice benchmarking ADO.NET against EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Chapter03` solution, create a console app named `Ch03Ex02_ADONETvsEFCore`
    that uses Benchmark.NET to compare retrieving all the products from the Northwind
    database using ADO.NET (`SqlClient`) and using EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn how to use Benchmark.NET by reading the online-only section *Benchmarking
    Performance and Testing* at the following link: [https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md](https://github.com/markjprice/apps-services-net8/blob/main/docs/ch01-benchmarking.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.3 – Review performance choices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data tier can have an outsized influence on the overall performance of an
    app or service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docs: [https://learn.microsoft.com/en-us/ef/core/performance/](https://learn.microsoft.com/en-us/ef/core/performance/)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.4 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core](https://github.com/markjprice/apps-services-net8/blob/main/docs/book-links.md#chapter-3---building-entity-models-for-sql-server-using-ef-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to execute a simple query and process the results using the slower but more
    object-oriented EF Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure and decide between three mapping strategies for type hierarchies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement calculated properties on entity creation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use cloud-native data storage with
    Azure Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the author, and learn about new releases – follow the QR code
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/apps_and_services_dotnet8](https://packt.link/apps_and_services_dotnet8)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code3048220001028652625.png)'
  prefs: []
  type: TYPE_IMG
