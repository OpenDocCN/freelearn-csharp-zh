<html><head></head><body>
  <div id="_idContainer346" class="Basic-Text-Frame">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-104" class="chapterTitle">Collisions and Health: Detecting Collisions Accurately</h1>
    <p class="normal">As games try to simulate real-world behaviors, one important aspect of simulating is physics, which dictates how objects move and how they collide with each other, such as the collision of players and walls or bullets and enemies. Physics can be difficult to control due to the myriad of reactions that can happen after a collision, so we will learn how to properly configure our game to create physics as accurately as we can. This will generate the desired arcade movement feeling based on realistic collisions—after all, sometimes, real life is not as interesting as video games!</p>
    <p class="normal">In this chapter, we will examine the following collision concepts:</p>
    <ul>
      <li class="bulletList">Configuring physics</li>
      <li class="bulletList">Detecting collisions</li>
      <li class="bulletList">Moving with physics</li>
    </ul>
    <p class="normal">First, we will learn how to properly configure physics, a step needed for the collisions between objects to be detected by our scripts, using new Unity events that we will learn. All of this is needed in order to detect when our bullets reach our enemies and damage them. Then, we are going to discuss the difference between moving with <code class="inlineCode">Transform</code>, as we have done so far, and moving with Rigidbody, as well as the pros and cons of each of these two methods. We will use these to experiment with different ways of moving our player and let you decide which one you want to use. Let’s start by discussing the physics settings.</p>
    <h1 id="_idParaDest-105" class="heading-1">Configuring physics</h1>
    <p class="normal">Unity’s <a id="_idIndexMarker348"/>physics system is prepared to cover a great range of possible gameplay applications, so properly configuring it is important to get the desired result. In this section, we will examine the following physics settings concepts:</p>
    <ul>
      <li class="bulletList">Setting shapes</li>
      <li class="bulletList">Physics object types</li>
      <li class="bulletList">Filtering collisions</li>
    </ul>
    <p class="normal">We are going to start by learning about the different kinds of colliders that Unity offers and then learn about different ways to configure those to detect different kinds of physics reactions (<strong class="keyWord">collisions</strong> and <strong class="keyWord">triggers</strong>). Finally, we will discuss how to ignore collisions between specific objects to prevent situations such as the player’s bullets damaging the player.</p>
    <h2 id="_idParaDest-106" class="heading-2">Setting shapes</h2>
    <p class="normal">At the beginning<a id="_idIndexMarker349"/> of this book, we learned that objects usually have two shapes: the visual shape (which is basically the 3D mesh) and the physical one (the collider—the one that the physics system will use to calculate collisions). Remember that the idea of this is to allow you to have a highly detailed visual model surrounding a simplified physics shape to increase performance.</p>
    <p class="normal">Unity has several types of <a id="_idIndexMarker350"/>colliders, so here, we will recap the common ones, starting with the primitive types—that<a id="_idIndexMarker351"/> is, <strong class="keyWord">Box</strong>, <strong class="keyWord">Sphere</strong>, and <strong class="keyWord">Capsule</strong>. These <a id="_idIndexMarker352"/>shapes <a id="_idIndexMarker353"/>are the cheapest ones (in terms of performance) to detect collisions due to the fact that the collisions between them are done via mathematical formulae, unlike other colliders such as the <strong class="keyWord">Mesh Collider</strong>, which<a id="_idIndexMarker354"/> allows you to use any mesh as the physics body<a id="_idIndexMarker355"/> of the object, but with a higher performance cost and some limitations. The idea is that you should use a primitive type to represent your objects or a combination of them; for example, an airplane could be made with two Box colliders, one for the body and the other one for the wings. You can find an example of this in the following screenshot, where you can see a weapons collider made from primitives:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_01_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.1: Compound colliders</p>
    <p class="normal">Anyway, this <a id="_idIndexMarker356"/>is not always necessary; if we want a weapon to just fall to the ground, maybe a Box collider covering the entire weapon can be enough, considering those kinds of collisions don’t need to be accurate, thereby increasing performance. Also, some shapes cannot be represented even with a combination of primitive shapes, such as ramps or <a id="_idIndexMarker357"/>pyramids, where your only solution is to use a <a id="_idIndexMarker358"/>Mesh Collider, which asks for a 3D mesh to use for collisions. However, we won’t use them in this book, given their high-performance impact; we will solve all of our physics colliders with primitives.</p>
    <p class="normal">Now, let’s add the necessary colliders to our scene to prepare it to calculate collisions properly. If you used an Asset Store environment package other than mine, you might already have the scene modules with colliders; I will show the work I needed to do in my case but try to extrapolate the main ideas here into your scene.</p>
    <p class="normal">To add the colliders, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Select a wall in the base, and check the object and possible child objects for collider components; in my case, I have no colliders. If you detect any Mesh Collider, you can leave it if you want, but I would suggest you remove it and replace it with another option in the next step. The idea is to add the collider to it, but the problem I detected here is that, due to the fact my wall is not an instance of a Prefab, I need to add a collider to every wall in the scene.</li>
      <li class="numberedList">One option is to create a Prefab and replace all of the walls with instances of it (the recommended solution); alternatively, you can just select all walls in the Hierarchy (by clicking them while pressing <em class="italic">Ctrl</em> or <em class="italic">command</em> on a Mac) and with <a id="_idIndexMarker359"/>them selected, use the <strong class="screenText">Add Component</strong> button to add a collider to all of them. In my case, I will use the <code class="inlineCode">Box Collider</code> component, which will adapt the size of the collider to the mesh. If it doesn’t adapt, you can just change the <strong class="screenText">Size</strong> and <strong class="screenText">Center</strong> properties of the <strong class="screenText">Box Collider</strong> components to cover the entire wall:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_02_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.2: A Box Collider added to a wall</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Repeat <em class="italic">steps 1</em> and <em class="italic">2</em> for the corners, floor tiles, and any other obstacle that will block player and enemy movement.</li>
    </ol>
    <p class="normal">Now that we have added the needed colliders to the walls and floor, we can continue with the player and enemy. We will be adding <a id="_idIndexMarker360"/>the <strong class="keyWord">Capsule Collider</strong> to <a id="_idIndexMarker361"/>them, the usual collider to use in movable characters, due to the fact that the rounded bottom will allow the object to smoothly climb ramps. Being horizontally rounded allows the object to easily rotate in corners without getting stuck, along with other conveniences of that shape. </p>
    <p class="normal">You might want to create an enemy Prefab based on one of the characters we downloaded before, so you can add the collider to that Prefab. Our player is a simple GameObject in the scene, so you will need to add the collider to that one but do consider creating a Prefab for the player for convenience.</p>
    <p class="normal">You may be <a id="_idIndexMarker362"/>tempted to add several Box colliders to the bones of the character to create a realistic shape of the object. While we can use this approach to vary the damage based on where enemies were shot on their bodies, note that we are primarily creating movement colliders, and using a Capsule collider is sufficient for this purpose. In advanced damage systems, both capsule and Bone colliders will coexist, one for movement and the other for damage detection, but we will simplify this in our game.</p>
    <p class="normal">Also, sometimes, the collider won’t adapt well to the visual shape of the object, and in my case, the Capsule collider didn’t fit the character very well. I needed to fix its shape to match the character by setting its values as shown in the following screenshot: <strong class="keyWord">Center</strong> to <code class="inlineCode">0,1,0,</code> <strong class="keyWord">Radius</strong> to <code class="inlineCode">0.5</code>, and <strong class="keyWord">Height</strong> to <code class="inlineCode">2</code>:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_03.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.3: Character collider</p>
    <p class="normal">The bullet we created with the Sphere already had a Sphere collider, but if you replaced the mesh of the bullet with another one, you might want to change the collider. For the time being, we don’t need other objects in our game, so now that everything has its proper collider, let’s see how to set the different physics settings to each object to enable proper collision detection.</p>
    <p class="normal">If you check the <a id="_idIndexMarker363"/>Terrain’s components, you will see that it has its own kind of<a id="_idIndexMarker364"/> collider, the <strong class="keyWord">Terrain collider</strong>. For Terrains, that’s the only collider to use.</p>
    <h2 id="_idParaDest-107" class="heading-2">Physics object types</h2>
    <p class="normal">Now that <a id="_idIndexMarker365"/>we have added colliders to every object by making the objects have a presence in the physics simulation, it is time to configure them to have the exact physics behavior we want. We have a myriad of possible combinations of settings, but we will discuss a set of common profiles that cover most situations. Remember, besides colliders, we saw the Rigidbody component at the beginning of this book, which is the one that applies physics to the object. The following profiles are created with a combination of colliders and Rigidbody settings:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Static Collider</strong>: As <a id="_idIndexMarker366"/>the name suggests, this kind of collider<a id="_idIndexMarker367"/> is not supposed to move, aside from some specific exceptions. Most of the environment objects fall into this category, such as walls, floors, obstacles, and terrain. These kinds of colliders are just colliders with no <code class="inlineCode">Rigidbody</code> component, so they have a presence in the physics simulation but don’t have any physics applied to them; they cannot be moved by other objects’ collisions, they won’t have physics, and they will be fixed in their position no matter what. Take into account that this has nothing to do with the <strong class="screenText">Static</strong> checkbox at the top-right part of the editor; that is for systems that we will explore later in several chapters (such as <em class="chapterRef">Chapter 12</em>, <em class="italic">Enlightening Worlds: Illuminating Scenes with the Universal Render Pipeline</em>), so you can have a Static Collider with that checkbox unchecked if needed.</li>
      <li class="bulletList"><strong class="keyWord">Physics Collider</strong>: These <a id="_idIndexMarker368"/>are colliders with a <code class="inlineCode">Rigidbody</code> component, like<a id="_idIndexMarker369"/> the example of the falling ball we created in the first part of this book. These are fully physics-driven objects that have gravity and can be moved through forces; other objects can push them, and they perform every other physics reaction you can expect. You can use this for the player, grenade movement, falling crates, or all objects in heavily physics-based games, such as <em class="italic">The Incredible Machine</em>.</li>
      <li class="bulletList"><strong class="keyWord">Kinematic Collider</strong>: These<a id="_idIndexMarker370"/> are colliders that have a <code class="inlineCode">Rigidbody</code> component <a id="_idIndexMarker371"/>but have the <strong class="screenText">Is Kinematic</strong> checkbox checked. These don’t have physics reactions to collisions and forces like <strong class="screenText">Static Colliders</strong>, but they are expected to move, allowing <strong class="keyWord">Physics Colliders</strong> to <a id="_idIndexMarker372"/>handle collisions against them properly when moving. These can be used in objects that need to move using animations or custom scripting movements, such as moving platforms.</li>
      <li class="bulletList"><strong class="keyWord">Trigger Static Collider</strong>: This<a id="_idIndexMarker373"/> is a regular<a id="_idIndexMarker374"/> Static Collider but with the <strong class="screenText">Is Trigger</strong> checkbox of the collider checked. The difference is that when kinematic and physics objects pass through it, a <code class="inlineCode">Trigger</code> event is automatically generated; this can be captured via scripting, which allows us to detect when something is inside the collider. This event can be used to create buttons or trigger objects in areas of the game when the player passes through something happening, such as a wave of enemies being spawned, a door being opened, or winning the game if that area is the goal of the player. Note that regular Static Colliders won’t generate a trigger event when passing through this type because those aren’t supposed to move.</li>
      <li class="bulletList"><strong class="keyWord">Trigger Kinematic Collider</strong>: Kinematic Colliders don’t generate collisions, so they<a id="_idIndexMarker375"/> will pass through any<a id="_idIndexMarker376"/> other object, but they will generate <code class="inlineCode">Trigger</code> events, so we can react via scripting. This can be used to create moveable power-ups that, when touched, disappear and give us points, or bullets that move with custom scripting movements and no physics, just straight like our bullets, but damage other objects when they touch them.</li>
    </ul>
    <p class="normal">Of course, other<a id="_idIndexMarker377"/> profiles can exist aside from the specified ones to use in some games with specific gameplay requirements, but it’s down to you to experiment with all possible combinations of physics settings to see whether they are useful for your case; the described profiles will cover 99% of cases.</p>
    <p class="normal">To recap the previous scenarios, check out the following table showing the reaction of contact between all the types of colliders. You will find a row per each profile that can move; remember that static profiles aren’t supposed to move. Each column represents the reaction when they collide with the other types: <code class="inlineCode">Nothing</code> means the object will pass through with no effect, <code class="inlineCode">Trigger</code> means the object will pass through but raise <code class="inlineCode">Trigger</code> events, and <code class="inlineCode">Collision</code> means the first object won’t be able to pass through the second object:</p>
    <table id="table001-2" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell"/>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Static</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Dynamic</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Kinematic</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Trigger Static</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Collides with Trigger Kinematic</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Dynamic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Kinematic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nothing</p>
          </td>
          <td class="table-cell">
            <p class="normal">Collision</p>
          </td>
          <td class="table-cell">
            <p class="normal">Nothing</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal">Trigger Kinematic</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
          <td class="table-cell">
            <p class="normal">Trigger</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 7.01: Collision Reaction Matrix</p>
    <p class="normal">Considering this, let’s start configuring the physics of our scene’s objects.</p>
    <p class="normal">The walls, corners, floor tiles, and obstacles should use the Static Collider profile, so there is no <code class="inlineCode">Rigidbody</code> component <a id="_idIndexMarker378"/>on them, and their colliders will have the <strong class="keyWord">Is Trigger</strong> checkbox unchecked:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.4: Configuration for floor tiles; remember that the Static checkbox is for lighting only</p>
    <p class="normal">The player should move and generate collisions against objects, so we need the player to have a <strong class="keyWord">Dynamic</strong> profile. This profile will generate funny behavior with our current movement script (which I encourage you to test), especially when colliding against walls, so it won’t behave as you expected. We will deal with this later in this chapter:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_05_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.5: Dynamic settings on the player</p>
    <p class="normal">The <code class="inlineCode">Enemy</code> Prefab <a id="_idIndexMarker379"/>we suggested you create previously will use the Kinematic profile because we will move this object with Unity’s AI systems later in the book, so we don’t need physics here. Also, as we want the player to collide with the Enemy Prefab objects, we need a collision reaction here, so there’s no <code class="inlineCode">Trigger</code>:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_06.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.6: Kinematic settings for the enemy</p>
    <p class="normal">The <code class="inlineCode">Bullet</code> Prefab <a id="_idIndexMarker380"/>moves with simplistic movement via scripting (it just moves forward) and not physics. We don’t need collisions here; we will code the bullet to destroy itself as soon as it touches something and will damage the collided object (if possible), so a Kinematic Trigger profile is enough for this one. We will use the <code class="inlineCode">Trigger</code> event to script the contact reactions:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_07.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.7: The Kinematic Trigger settings for our bullet, Is Trigger and Is Kinematic, are checked</p>
    <p class="normal">Now that we<a id="_idIndexMarker381"/> have properly configured the objects let’s check how to filter undesired collisions between certain object types.</p>
    <h2 id="_idParaDest-108" class="heading-2">Filtering collisions</h2>
    <p class="normal">Sometimes, we <a id="_idIndexMarker382"/>want certain objects to ignore each other, like the bullets shot by the player, which shouldn’t collide with the player itself. We can always filter that with an <code class="inlineCode">if</code> statement in the C# script, checking whether the hit object is from the opposite team or whatever filtering logic you want, but by then, it is too late; the physics system wasted resources by checking a collision between objects that were never meant to collide. Here is where the Layer Collision Matrix can help us.</p>
    <p class="normal">The <strong class="keyWord">Layer Collision Matrix</strong> sounds<a id="_idIndexMarker383"/> scary, but it is a simple setting of the physics system that allows us to specify which groups of objects should collide with other groups. For example, the player’s bullets should collide with enemies, and enemy bullets should collide with the player. In this case, the enemies’ bullets will pass through enemies, but this is desirable in our case. The idea is to create groups and put our objects inside them; in Unity, these groups are <a id="_idIndexMarker384"/>called <strong class="keyWord">layers</strong>. We can create layers and set the layer property of the GameObject (the top part of the <strong class="screenText">Inspector</strong>) to assign the object to that group or layer. Note that you have a limited number of layers, so try to use them wisely.</p>
    <p class="normal">We can achieve<a id="_idIndexMarker385"/> this by doing the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong>, and inside it, look for the <strong class="screenText">Tags and Layers</strong> option from the left pane:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_08_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.8: The Tags and Layers settings</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">From the <strong class="screenText">Layers</strong> section, fill the empty spaces to create layers. We will use this for the bullet scenario, so we need four layers: <code class="inlineCode">Player</code>, <code class="inlineCode">Enemy</code>, <code class="inlineCode">PlayerBullet</code>, and <code class="inlineCode">EnemyBullet</code>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_09_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.9: Creating layers</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Select the <code class="inlineCode">Player</code> GameObject in the Hierarchy, and from the top part of the Inspector, change the <strong class="screenText">Layer</strong> property to <code class="inlineCode">Player</code>. Also, change the <code class="inlineCode">Enemy</code> Prefab to have <a id="_idIndexMarker386"/>the <code class="inlineCode">Enemy</code> layer. A window will appear, asking you whether you want to also change the child objects; select <strong class="screenText">Yes</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_10_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.10: Changing the layers of the player and the enemy Prefab</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">In the case of the bullet, we have a problem; we have one Prefab but two layers, and a Prefab can only have one layer. We have two options: changing the layer according to the shooter via scripting or creating two <code class="inlineCode">bullet</code> Prefabs with different layers. For simplicity, I will choose the latter, also taking the chance to apply another material to the enemy bullet to make it look different.</li>
      <li class="numberedList">We will create a Prefab <strong class="screenText">Variant</strong> of the player bullet. Remember that a Variant is a Prefab that is based on an original one, like class inheritance. When the original Prefab changes, the Variant will change, but the Variant can have differences, which will make it unique.</li>
      <li class="numberedList">Drop a bullet Prefab into the scene to create an instance.</li>
      <li class="numberedList">Drag the instance again to the <code class="inlineCode">Prefabs</code> folder, this time selecting the <strong class="screenText">Prefab</strong> <strong class="screenText">Variant</strong> option in the window that will appear.</li>
      <li class="numberedList">Rename it <code class="inlineCode">Enemy Bullet</code>.</li>
      <li class="numberedList">Destroy the Prefab instance in the scene.</li>
      <li class="numberedList">Create a second material similar to the player bullet with a different color, and put it on the enemy bullet Prefab Variant.</li>
      <li class="numberedList">Select the enemy bullet Prefab, set its layer to <code class="inlineCode">EnemyBullet</code>, and do the same for the original Prefab (<code class="inlineCode">PlayerBullet</code>). Even if you changed the original Prefab layer, as the Variant modified it, the modified version (or override) will prevail, allowing each Prefab to have its own layer.</li>
    </ol>
    <p class="normal">Now that we<a id="_idIndexMarker387"/> have configured the layers, let’s configure the physics system to use them:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Go to <strong class="screenText">Edit | Project Settings</strong> and look for the <strong class="screenText">Physics </strong>settings (not <strong class="screenText">Physics 2D</strong>).</li>
      <li class="numberedList">Scroll down until you see the <strong class="screenText">Layer Collision Matrix</strong>, a half grid of checkboxes. You will notice that each column and row is labeled with the names of the layers, so each checkbox in the cross of a row and column will allow us to specify whether these two should collide. In our case, we configured the Layer Collision Matrix as shown in the following screenshot so that player bullets do not hit the player or other player bullets, and enemy bullets do not hit enemies or other enemy bullets:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_11_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.11: Making player bullets collide with enemies and enemy bullets collide with the player</p>
    <p class="normal">It is worth <a id="_idIndexMarker388"/>noting that, sometimes, filtering logic won’t be that rigid or predictable. For example, it might involve only hit objects that have a certain amount of life, objects that don’t have an invisibility temporal buff or conditions that can change during the game and are difficult to generate for all possible layers for all possible groups. So, in these cases, we should rely on manual filtering after the <strong class="keyWord">Trigger</strong> or <strong class="keyWord">Collision</strong> event.</p>
    <p class="normal">Now that we have filtered collisions, let’s check whether our settings are working properly by reacting to collisions in the next section.</p>
    <h1 id="_idParaDest-109" class="heading-1">Detecting collisions</h1>
    <p class="normal">As you can see, proper <a id="_idIndexMarker389"/>physics settings can be complicated and very important, but now that we have tackled that, let’s perform some tasks with those settings by reacting to the contact in different ways, creating a <strong class="keyWord">health system</strong> in the process.</p>
    <p class="normal">In this section, we will examine the following collision concepts:</p>
    <ul>
      <li class="bulletList">Detecting Trigger events</li>
      <li class="bulletList">Modifying the other object</li>
    </ul>
    <p class="normal">First, we are going to<a id="_idIndexMarker390"/> explore the different collision and trigger events Unity offers us to react to contact between two objects, through Unity <strong class="keyWord">collision</strong> events. This allows us to execute any reaction code we want to place, but here, we are going to explore how to modify the contacted object components using the <code class="inlineCode">GetComponent</code> function.</p>
    <h2 id="_idParaDest-110" class="heading-2">Detecting Trigger events</h2>
    <p class="normal">If objects <a id="_idIndexMarker391"/>are properly configured, as previously discussed, we can get two reactions: collisions or triggers. The <strong class="keyWord">Collision</strong> reaction has a default effect that blocks the movement of the objects, but we can add custom behavior on top of that using scripting; however, with a <strong class="keyWord">Trigger</strong>, unless we add custom behavior, it won’t produce any noticeable effect. Either way, we can script reactions to both possible scenarios, such as adding a score, reducing health, and losing the game. To do so, we can use <a id="_idIndexMarker392"/>the suite of <strong class="keyWord">Physics events</strong>.</p>
    <p class="normal">These events are split into two <a id="_idIndexMarker393"/>groups, <strong class="keyWord">Collision events</strong> and <strong class="keyWord">Trigger events</strong>, so<a id="_idIndexMarker394"/> according to your object setting, you will need to pick the appropriate group. Both groups have three main events, <strong class="keyWord">Enter</strong>, <strong class="keyWord">Stay</strong>, and <strong class="keyWord">Exit</strong>, telling us when a collision or trigger began (<em class="italic">Enter</em>), whether it is still happening or still in contact (<em class="italic">Stay</em>), and when it stopped contacting (<em class="italic">Exit</em>). For example, we can script a behavior such as playing a sound when two objects first make contact in the Enter event, such as a friction sound, and stop it when the contact ends in the Exit event.</p>
    <p class="normal">Let’s test this by creating our first contact behavior: the bullet being destroyed when coming into contact with something. Remember that the bullets are configured to be triggers, so they will generate <code class="inlineCode">Trigger</code> events on contact with anything. You can do this with the following steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create and add a script called <code class="inlineCode">ContactDestroyer</code> on the <strong class="screenText">Player Bullet</strong> Prefab; as the <strong class="screenText">Enemy Bullet</strong> Prefab is a Variant of it, it will also have the same script.</li>
      <li class="numberedList">To detect when a trigger happens, such as with <strong class="screenText">Start</strong> and <strong class="screenText">Update</strong>, create an event function named <code class="inlineCode">OnTriggerEnter</code>.</li>
      <li class="numberedList">Inside the event, use the <code class="inlineCode">Destroy(gameObject);</code> line to make the bullet destroy itself when touching something:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_12_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.12: Auto-destroying on contact with something</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Save the script, and shoot the bullets against the walls to see how they disappear instead of passing through them. Here, we don’t have a collision but a trigger that destroys the bullet on contact. This way, we are sure that the bullet will never pass through anything, but we are still not implementing a physics-based movement.</li>
    </ol>
    <p class="normal">After enabling<a id="_idIndexMarker395"/> these components, for now, we won’t need the other Collision events, but if you need them, they will work similarly; just create a function called <code class="inlineCode">OnCollisionEnter</code> instead.</p>
    <p class="normal">Now, let’s explore another version of the same function. We’ll configure it to not only tell us that we hit something but also what we came into contact with. We will use this to make <a id="_idIndexMarker396"/>our <strong class="keyWord">Contact Destroyer</strong> also destroy the other object. To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Replace the <code class="inlineCode">OnTriggerEnter</code> method signature with the one in the following screenshot. This one receives a parameter of the <code class="inlineCode">Collider</code> type, indicating the exact collider that hit us:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_13_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.14: Version of the trigger event that tells us which object we collided with</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">We can access the GameObject of that collider using the <code class="inlineCode">gameObject</code> property. We can use this to destroy the other one as well, as shown in the following screenshot. If we just use the <code class="inlineCode">Destroy</code> function by passing the <code class="inlineCode">other</code> variable, it will only destroy the <code class="inlineCode">Collider</code> component:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_14_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.14: Destroying both objects</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="3">Save and<a id="_idIndexMarker397"/> test the script. You will notice that the bullet will destroy everything it touches. Remember to verify that your enemy has a Capsule collider for the bullet to detect collisions against it.</li>
    </ol>
    <p class="normal">The equivalent version in visual scripting would be like the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_15_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.15: Destroying both objects with Visual Scripting</p>
    <p class="normal">As you can see, we created an <strong class="keyWord">On Trigger Enter</strong> node and chained it to two <strong class="keyWord">Destroy</strong> nodes. To specify which object each <strong class="keyWord">Destroy</strong> node will destroy, we used the <strong class="keyWord">Component: Get GameObject</strong> node twice. The right one was created with no node connected to its left input pin, which means it will return the GameObject that currently executes this <a id="_idIndexMarker398"/>script (hence, the <strong class="keyWord">This</strong> label in the node left pin), in this case, the bullet. For the second one, we needed to connect the <strong class="keyWord">Collider</strong> output pin at the right of the <strong class="keyWord">OnTriggerEnter</strong> node to the <strong class="keyWord">Get GameObject</strong> node; this way, we specify that we want to obtain the GameObject that contains the collider our bullet collided with.</p>
    <p class="normal">Now, in our game, we don’t want the bullet to destroy everything on contact; instead, we will make the enemies and the player have a life amount; the bullets will reduce that life amount until it reaches 0, so let’s find out how to do that.</p>
    <h2 id="_idParaDest-111" class="heading-2">Modifying the other object</h2>
    <p class="normal">For the bullet to <a id="_idIndexMarker399"/>damage the collided object, we will need to access a <code class="inlineCode">Life</code> component to change its amount, so we will need to create this <code class="inlineCode">Life</code> component to hold a float field with the amount of life. Every object with this component will be considered a damageable object. To access the <code class="inlineCode">Life</code> component from our bullet scripts, we will need the <code class="inlineCode">GetComponent</code> function.</p>
    <p class="normal">If you have a reference to a GameObject or component, you can use <code class="inlineCode">GetComponent</code> to access a specific component if the object contains it (if not, it will return <code class="inlineCode">null</code>). Let’s see how to use that function to make the bullet lower the amount of life of the other object:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create and add a <code class="inlineCode">Life</code> component with a <code class="inlineCode">public float</code> field, called <code class="inlineCode">amount</code>, to both the player and enemy Prefabs. Remember to set the value as <code class="inlineCode">100</code> (or whatever life amount you want to give them) in the <strong class="screenText">Amount</strong> field for both in the Inspector:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_16_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.17: The Life component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Remove the <code class="inlineCode">ContactDestroyer</code> component from the player bullet, which will also remove it from the <strong class="screenText">Enemy Bullet Variant</strong>.</li>
      <li class="numberedList">Add a<a id="_idIndexMarker400"/> new script called <code class="inlineCode">ContactDamager</code> to both the enemy and the player.</li>
      <li class="numberedList">Add an <code class="inlineCode">OnTriggerEnter</code> event that receives the <code class="inlineCode">other</code> collider as a parameter, and just add the <code class="inlineCode">Destroy</code> function call that auto-destroys itself, not the one that destroys the other object; our script won’t be responsible for destroying it, just reducing its life.</li>
      <li class="numberedList">Add a float field called <code class="inlineCode">damage</code> so that we can configure the amount of damage to inflict on the other object. Remember to save the file and set a value before continuing.</li>
      <li class="numberedList">Use <code class="inlineCode">GetComponent</code> on the reference to the other collider to get a reference to its <code class="inlineCode">Life</code> component and save it in a variable:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_17_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.18: Accessing the collided object’s Life component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="7">Before reducing the life of the object, we must check that the <code class="inlineCode">Life</code> reference isn’t <code class="inlineCode">null</code>, which would happen if the other object didn’t have the <code class="inlineCode">Life</code> component, as in the case of walls and obstacles. The idea is that the bullet will destroy itself when anything collides with it and reduce the life of the other object if it is a damageable object that contains the <code class="inlineCode">Life</code> component.
    <p class="normal">In the following screenshot, you will find the full script:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_18_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.18: Reducing the life of the collided object</p></li>
    </ol>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Place an enemy in the scene and set its speed to <code class="inlineCode">0</code> to prevent it from moving.</li>
      <li class="numberedList">Select it in the Hierarchy before hitting <strong class="screenText">Play</strong>, and start shooting at it.</li>
    </ol>
    <p class="normal">You can see<a id="_idIndexMarker401"/> how the life value reduces in the Inspector. You can also press the <em class="keystroke">Esc</em> key to regain control of the mouse and select the object while in <strong class="screenText">Play</strong> mode, seeing the <strong class="screenText">life</strong> field change during the runtime in the editor.</p>
    <p class="normal">Now, you will notice that life is decreasing, but it will become negative; we want the object to destroy itself when life is below 0 instead. We can do this in two ways: one is to add an <code class="inlineCode">Update</code> to the <code class="inlineCode">Life</code> component, which will check all of the frames to see whether life is below 0, destroying itself when that happens. </p>
    <p class="normal">The second way is by encapsulating the life field and checking its value inside the setter to prevent all frames from being checked. I would prefer the second way, but we will implement the first one to make our scripts<a id="_idIndexMarker402"/> as simple as possible for beginners.</p>
    <p class="normal">To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Add <code class="inlineCode">Update</code> to the <code class="inlineCode">Life</code> component.</li>
      <li class="numberedList">Add <code class="inlineCode">If</code> to check whether the amount field is below or equals <code class="inlineCode">0</code>.</li>
      <li class="numberedList">Add <code class="inlineCode">Destroy</code> in case the <code class="inlineCode">if</code> condition is <code class="inlineCode">true</code>.</li>
      <li class="numberedList">The full <code class="inlineCode">Life</code> script will look like the following screenshot:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_19_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.19: The Life component</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Save and see how the object is destroyed once <code class="inlineCode">Life</code> becomes <code class="inlineCode">0</code>.</li>
    </ol>
    <p class="normal">The Visual Scripting version for the <code class="inlineCode">Life</code> component would look like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_20_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.20: The Life component in Visual Scripting</p>
    <p class="normal">The script <a id="_idIndexMarker403"/>is pretty straightforward—we check if our <code class="inlineCode">Life</code> variable is less than 0 and then destroy ourselves, as we did previously. Now, let’s check the <strong class="keyWord">Damager</strong> script:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_21_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.21: The Damager component in Visual Scripting</p>
    <p class="normal">This version is a little bit different from our C# counterpart. At first glance, it looks the same: we use the <strong class="keyWord">Get Variable</strong> as before to read the life, and then we use the <strong class="keyWord">Subtract</strong> node to subtract <strong class="keyWord">damage</strong> from <strong class="keyWord">life</strong>, and the result of that calculation becomes the new value of <strong class="keyWord">life</strong>, with the <strong class="keyWord">Set Variable</strong> node used to alter the current value of that variable.</p>
    <p class="normal">The first <a id="_idIndexMarker404"/>difference we can see here is the absence of any <code class="inlineCode">GetComponent</code> node. In C#, we used that instruction to get the <code class="inlineCode">Life</code> component on the collided object in order to read and alter its <strong class="keyWord">amount</strong> variable, reducing the remaining life. But as in Visual Scripting, our node graphs don’t have variables, so we don’t need to access the component to read them. Instead, knowing that the enemy has a <code class="inlineCode">Life</code> variable in its <strong class="keyWord">Variables</strong> component, we use the <strong class="keyWord">Get Variable</strong> node, connecting it to the collider we hit (the <strong class="keyWord">Collider</strong> output pin of <strong class="keyWord">On Trigger Enter</strong>), so essentially, we are reading the value of the <code class="inlineCode">Life</code> variable of the collided object.</p>
    <p class="normal">The same goes for changing its value: we use the <strong class="keyWord">Set Value</strong> node, connecting it to the collider, specifying that we want to alter the value of the <code class="inlineCode">Life</code> variable of the collider object, not ours (as bullets don’t have a <code class="inlineCode">Life</code> variable). Note that this can raise an error if the collided object doesn’t have the <code class="inlineCode">Life</code> variable, which is why we added the <strong class="keyWord">Object Has Variable</strong> node, which checks if the object has a variable called <code class="inlineCode">Life</code>. If it doesn’t, we just do nothing, which is useful when we collide with walls or other non-destructible objects. Finally, we make the <strong class="keyWord">Damager</strong> (the bullet in this case) auto-destroy itself.</p>
    <div class="note">
      <p class="normal">You can instantiate an object when this happens, such as a sound, a particle, or maybe a power-up. I will leave this as a challenge for you. By using a similar script, you can implement a life power-up that increases the life value or a speed power-up that accesses the <code class="inlineCode">PlayerMovement</code> script and increases the <strong class="screenText">Speed</strong> field; from now on, use your imagination to create exciting behaviors using the previously acquired knowledge.</p>
    </div>
    <p class="normal">Now that <a id="_idIndexMarker405"/>we have explored how to detect collisions and react to them, let’s explore how to fix the player falling when hitting a wall.</p>
    <h1 id="_idParaDest-112" class="heading-1">Moving with physics</h1>
    <p class="normal">So far, the player, the only object that moves <a id="_idIndexMarker406"/>with the <strong class="keyWord">Dynamic Collider Profile</strong> and the one that will move with physics, actually moves through custom scripting using the Transform API. Instead, every dynamic object should move using <a id="_idIndexMarker407"/>the Rigidbody API functions in a way the physics system understands better. As such, here, we will explore how to move objects, this time through the <strong class="screenText">Rigidbody</strong> component.</p>
    <p class="normal">In this section, we will examine the following physics movement concepts:</p>
    <ul>
      <li class="bulletList">Applying forces</li>
      <li class="bulletList">Tweaking physics</li>
    </ul>
    <p class="normal">We will start by seeing how to move objects the correct physical way through forces, and we will apply this concept to the movement of our player. Then, we will explore why real physics is not always fun and how we can tweak the physics properties of our objects to have a more responsive and appealing behavior.</p>
    <h2 id="_idParaDest-113" class="heading-2">Applying forces</h2>
    <p class="normal">The physically<a id="_idIndexMarker408"/> accurate way of moving an object is through forces, which affect the object’s velocity. To apply force, we need to access <code class="inlineCode">Rigidbody</code> instead of <code class="inlineCode">Transform</code> and use the <code class="inlineCode">AddForce</code> and <code class="inlineCode">AddTorque</code> functions to move and rotate, respectively. These are functions where you can specify the amount of force to apply to each axis of position and rotation. This method of movement will have full physics reactions; the forces will accumulate on the velocity to start moving and will suffer drag effects that will make the speed slowly decrease, and the most important aspect here is that they will collide against walls, blocking the object’s way.</p>
    <p class="normal">To get <a id="_idIndexMarker409"/>this kind of movement, we can do the following:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">Create a <code class="inlineCode">Rigidbody</code> field in the <code class="inlineCode">PlayerMovement</code> script, but this time, make it <code class="inlineCode">private</code>—that is, do not write the <code class="inlineCode">public</code> keyword in the field, which will make it disappear in the editor; we will get the reference another way:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_22_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.22: The private Rigidbody reference field</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">Note that we named this variable <code class="inlineCode">rb</code> just to prevent our scripts from being too wide, making the screenshots of the code in the book too small. It’s recommended to name the variable properly in your scripts—in this case, it would be named <code class="inlineCode">rigidbody</code>.</li>
      <li class="numberedList">Using <code class="inlineCode">GetComponent</code> in the <code class="inlineCode">Start</code> event function, get our Rigidbody and save it in the field. We will use this field to cache the result of the <code class="inlineCode">GetComponent</code> function; calling that function every frame to access the Rigidbody is not performant. Also, note here that the <code class="inlineCode">GetComponent</code> function can be used to retrieve not only components from other objects (like the collision example) but also your own:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_23_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.23: Caching the Rigidbody reference for future usage</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="4">Replace the <code class="inlineCode">transform.Translate</code> calls with <code class="inlineCode">rb.AddRelativeForce</code>. This will call the add force functions of the Rigidbody, specifically the relative ones, which will <a id="_idIndexMarker410"/>consider the current rotation of the object. For example, if you specify a force in the <em class="italic">z</em>-axis (the third parameter), the object will apply its force along with its forward vector.</li>
      <li class="numberedList">Replace the <code class="inlineCode">transform.Rotate</code> calls with <code class="inlineCode">rb.AddRelativeTorque</code>, which will apply rotation forces:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_24_PRE_BOOK.png" alt="A picture containing text, screenshot, font, line  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.24: Using the Rigidbody forces API</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="6">Check that the player GameObject Capsule collider does not intersect with the floor and is just a little bit over it. If the player intersects, the movement won’t work properly. If this is the case, move it upward.</li>
    </ol>
    <p class="normal">If you have used Unity before, you might find it odd to use <code class="inlineCode">Update</code> instead of <code class="inlineCode">FixedUpdate</code> to apply physics forces. FixedUpdate is a special update that runs at a fixed rate, regardless of the actual game’s <strong class="keyWord">Frames per Second</strong> (<strong class="keyWord">FPS</strong>), and here is where the Physics system executes. It is configured by default to run 50 times per frame. This means that if the game runs at 200 FPS, the FixedUpdate will execute every 4 frames, but if the game runs at 25 FPS, the fixed update will execute twice per frame. This is done this way to enhance the stability of the physics calculations, given their complexity.</p>
    <p class="normal">While it would be correct to call any Rigidbody method that applies forces and torque in the FixedUpdate, it is not necessarily wrong to do that in the <code class="inlineCode">Update</code> method. For simplicity, we kept our code in the Update method, given that FixedUpdate can be tricky to use for beginners, as it can execute more than once per frame or even skip some frames. One <a id="_idIndexMarker411"/>example is checking if a key is pressed using methods like <code class="inlineCode">Input.GetKeyDown</code>, given the key pressure happens in specific frames. If you call that method in the FixedUpdate and FixedUpdate skips the frame where the key was pressed, the key pressure won’t be detected, making the game feel unresponsive. A classic fix would be to detect key presses in the Update method and store them if they were pressed in boolean variables to check them later in the FixedUpdate. But again, due to simplicity, we decided to leave it as is.</p>
    <p class="normal">In the Visual Scripting version, the change is the same: replace the <strong class="screenText">Transform</strong><strong class="keyWord"> </strong>and <strong class="keyWord">Rotate</strong> nodes with the <strong class="screenText">Add Relative Force</strong><strong class="keyWord"> </strong>and <strong class="screenText">Add Relative Torque</strong> nodes, respectively. An example of <strong class="screenText">Add Relative Force</strong> would be the following one:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_25_PRE_BOOK.png" alt="A screenshot of a computer program  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 7.25: Using the Rigidbody Forces API</p>
    <p class="normal">And for <a id="_idIndexMarker412"/>rotation like this:</p>
    <figure class="mediaobject"><img src="../Images/B21361_07_26_PRE_BOOK.png" alt="A screenshot of a computer  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 7.26: Using the Rigidbody torque API</p>
    <p class="normal">You can see that we don’t need to use the <strong class="screenText">GetComponent</strong> nodes here either, given that just using the <strong class="screenText">Add Relative Force</strong> or <strong class="screenText">Torque</strong> nodes makes Visual Scripting understand that we want to apply those actions on our own Rigidbody component (explaining the use of the This label again). If, in any other case, we needed to call those functions on a Rigidbody other than ours, we would need the <strong class="screenText">GetComponent</strong> node there, but let’s explore that later.</p>
    <p class="normal">Now, if you save and test the results, you will probably find the player falling, and that’s because now we are using real physics, which contains floor friction, and due to the force being applied at the center of gravity, it will make the object fall. Remember that, in terms of physics, you are a capsule; you don’t have legs to move, and here is where standard physics is not suitable for our game. The solution is to tweak physics to emulate the kind of behavior we need.</p>
    <h2 id="_idParaDest-114" class="heading-2">Tweaking physics</h2>
    <p class="normal">To make <a id="_idIndexMarker413"/>our player move like in a regular platformer game, we will need to freeze certain axes to prevent an object from falling. Remove the friction to the ground and increase the air friction (drag) to make the player reduce its speed automatically when releasing the keys.</p>
    <p class="normal">To do this, follow these steps:</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="1">In the <code class="inlineCode">Rigidbody</code> component, look at the <strong class="screenText">Constraints</strong> section at the bottom and check the <strong class="screenText">X</strong> and <strong class="screenText">Z</strong> axes of the <strong class="screenText">Freeze Rotation</strong> property:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_27_PRE_BOOK.png" alt="A screenshot of a computer  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 7.27: Freezing the rotation axes</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="2">This will prevent the object from falling sideways but will allow it to rotate horizontally. You might also freeze the <em class="italic">y</em>-axis of the <strong class="screenText">Freeze Position</strong> property if you don’t want the player to jump, preventing some undesired vertical movement on collisions.</li>
      <li class="numberedList">You will probably need to change the speed values because you changed from a meters-per-second value to newtons-per-second, the expected value of the <strong class="screenText">Add Force</strong> and <strong class="screenText">Add Torque</strong> functions. Using 1,000 in speed and 160 in rotation speed was enough for me.</li>
      <li class="numberedList">Now, you will probably notice that the speed will increase a lot over time, as will the rotation. Remember that you are using forces, which affect your velocity. When you stop applying forces, the velocity is preserved, and that’s why the player keeps rotating even if you are not moving the mouse. The fix to this is to increase the <strong class="screenText">Drag</strong> and <strong class="screenText">Angular Drag</strong>, which emulates air friction and will reduce the movement and rotation, respectively, when no force is applied. Experiment with values that you find suitable; in my case, I used <code class="inlineCode">2</code> for <strong class="screenText">Drag</strong> and <code class="inlineCode">10</code> for <strong class="screenText">Angular Drag</strong>, needing to increase <strong class="screenText">Rotation Speed</strong> to <code class="inlineCode">150</code> to compensate for the drag increase:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_28.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.28: Setting air friction for rotation and movement</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="5">Now, if<a id="_idIndexMarker414"/> you move while touching the wall, instead of sliding, like in most games, your player will stick to the obstacles due to contact friction. We can remove this by creating a <code class="inlineCode">Physics Material</code>, an asset that can be assigned to the colliders to control how they react in those scenarios.</li>
      <li class="numberedList">Start creating one by clicking on the <strong class="screenText">+</strong> button in the <strong class="screenText">Project</strong> window and selecting <strong class="screenText">Physics Material</strong> (not the 2D version). Call it <code class="inlineCode">Player</code>, and remember to put it in a folder for those kinds of assets.</li>
      <li class="numberedList">Select it, and set <strong class="screenText">Static Friction</strong> and <strong class="screenText">Dynamic Friction</strong> to <code class="inlineCode">0</code> and <strong class="screenText">Friction Combine</strong> to <code class="inlineCode">Minimum</code>, which will make the <strong class="screenText">Physics</strong> system pick the minimum friction of the two colliding objects, which is always the minimum—in our case, zero:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_29.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.29: Creating a physics material</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="8">Select the player, and <a id="_idIndexMarker415"/>drag this asset to the <strong class="screenText">Material</strong> property of the <strong class="screenText">Capsule Collider</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B21361_07_30_PRE_BOOK.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 7.30: Setting the physics material of the player</p>
    <ol style="list-style-type: decimal;" class="numberedList">
      <li class="numberedList" value="9">If you play the game now, you may notice that the player will move faster than before because we don’t have any kind of friction on the floor, so you may need to reduce the movement force.</li>
    </ol>
    <p class="normal">As you can see, we needed to bend the physics rules to allow a responsive player movement. You can get more responsiveness by increasing drags and forces so that speeds are applied<a id="_idIndexMarker416"/> faster and reduced faster, but that depends, again, on the experience you want your game to have.</p>
    <div class="packt_tip">
      <p class="normal">Some games want an immediate response with no velocity interpolation, going from 0 to full speed and vice versa, from one frame to the other. In these cases, you can override the velocity and rotation vectors of the player directly at your will or even use other systems instead of physics, such as the Character Controller component, which has special physics for platform characters. You can read more about it here: <a href="https://docs.unity3d.com/Manual/CharacterControllers.html"><span class="url">https://docs.unity3d.com/Manual/CharacterControllers.html</span></a>.</p>
    </div>
    <h1 id="_idParaDest-115" class="heading-1">Summary</h1>
    <p class="normal">Every game has physics, in some way or another, for movement, collision detection, or both. In this chapter, we learned how to use the physics system for both being aware of proper settings to make the system work properly, reacting to collisions to generate gameplay systems, and moving the player in such a way that it collides with obstacles, keeping its physically inaccurate movement. We used these concepts to create our player and bullet movement and make our bullets damage the enemies, but we can reuse this knowledge to create a myriad of other possible gameplay requirements, so I suggest you play around a little bit with the physics concepts seen here; you can discover a lot of interesting use cases.</p>
    <p class="normal">In the next chapter, we will discuss how to program the visual aspects of the game, such as effects, and make the UI react to the input.</p>
    <h1 id="_idParaDest-116" class="heading-1">Learn more on Discord</h1>
    <p class="normal">Read this book alongside other users, Unity game development experts, and the author himself. Ask questions, provide solutions to other readers, chat with the author via Ask Me Anything sessions, and much more. Scan the QR code or visit the link to join the community:</p>
    <p class="normal"><a href="https://packt.link/unitydev"><span class="url">https://packt.link/unitydev</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1498477041053909218.png" alt="" role="presentation"/></p>
  </div>
</body></html>