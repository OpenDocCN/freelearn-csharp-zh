<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer178">&#13;
    <h1 class="chapterNumber">5</h1>&#13;
    <h1 id="_idParaDest-107" class="chapterTitle">Working with Classes, Structs, and OOP</h1>&#13;
    <p class="normal">For obvious reasons, the goal of this book isn't to give you a splitting headache from information overload. However, these next topics will take you out of the beginner's cubicle and into the open air of <strong class="keyword">object-oriented programming</strong> (<strong class="keyword">OOP</strong>). Up to this point, we've been relying<a id="_idIndexMarker260"/> exclusively on predefined variable types that are part of the C# language: under-the-hood strings, lists, and dictionaries that are classes, which is why we can create them and use their properties through dot notation. However, relying on built-in types has one glaring weakness—the inability to deviate from the blueprints that C# has already set.</p>&#13;
    <p class="normal">Creating your classes gives you the freedom to define and configure blueprints of your design, capturing information and driving action that is specific to your game or application. In essence, custom classes and OOP are the keys to the programming kingdom; without them, unique programs will be few and far between.</p>&#13;
    <p class="normal">In this chapter, you'll get hands-on experience creating classes from scratch and discuss the inner workings of class variables, constructors, and methods. You'll also be introduced to the differences between reference and value type objects, and how these concepts can be applied inside Unity. The following topics will be discussed in more detail as you move along:</p>&#13;
    <ul>&#13;
      <li class="bullet">Introducing OOP</li>&#13;
      <li class="bullet">Defining classes</li>&#13;
      <li class="bullet">Declaring structs</li>&#13;
      <li class="bullet">Understanding reference and value types</li>&#13;
      <li class="bullet">Integrating the object-oriented mindset</li>&#13;
      <li class="bullet">Applying OOP in Unity</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-108" class="title">Introducing OOP</h1>&#13;
    <p class="normal">OOP is the main<a id="_idIndexMarker261"/> programming paradigm that you'll use when coding in C#. If class and struct instances are the blueprints of our programs, then OOP is the architecture that holds everything together. When we refer to OOP as a programming paradigm, we are saying that it has specific principles for how the overall program should work and communicate.</p>&#13;
    <p class="normal">Essentially, OOP focuses on objects rather than pure sequential logic—the data they hold, how they drive action, and, most importantly, how they communicate with each other.</p>&#13;
    <h1 id="_idParaDest-109" class="title">Defining classes</h1>&#13;
    <p class="normal">Back in <em class="chapterRef">Chapter 2</em>, <em class="italic">The Building Blocks of Programming</em>, we briefly talked about how classes are <a id="_idIndexMarker262"/>blueprints for objects and mentioned that they can be treated as custom variable types. We also learned that the <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>script is a class, but a special one that Unity can attach to objects in the scene. The main thing to remember with classes is that they are <em class="italic">reference types</em>—that is, when they are assigned or passed to another variable, the original object is referenced, not a new copy. We'll get into this after we discuss structs. However, before any of that, we need to understand the basics of creating classes.</p>&#13;
    <p class="normal">For now, we're going to set aside how classes and scripts work in Unity and focus on how they are created and used in C#. Classes are created using the <code class="Code-In-Text--PACKT-">class</code> keyword, as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">accessModifier <span class="hljs-keyword">class</span> <span class="hljs-title">UniqueName</span>&#13;
{&#13;
    Variables &#13;
    Constructors&#13;
    Methods&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Any variables or methods declared inside a class belong to that class and are accessed through its unique class name.</p>&#13;
    <p class="normal">To make the examples as cohesive as possible throughout this chapter, we'll be creating and modifying a simple <code class="Code-In-Text--PACKT-">Character</code> class that a typical game would have. We'll also be moving away from code screenshots to get you accustomed to reading and interpreting code as you would see it "in the wild." However, the first thing we need is a custom class of our own, so let's create one.</p>&#13;
    <p class="normal">We'll need a class to practice with before we can understand their inner workings, so let's create a new C# script and start from scratch:</p>&#13;
    <ol>&#13;
      <li class="numbered">Right-click on the <code class="Code-In-Text--PACKT-">Scripts</code> folder that you created in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting to Know Your Environment</em>, and choose <strong class="screenText">Create</strong> | <strong class="screenText">C# Script</strong>.</li>&#13;
      <li class="numbered">Name the script <code class="Code-In-Text--PACKT-">Character</code>, open it up in Visual Studio, and delete all the generated code.</li>&#13;
      <li class="numbered">Declare a public class called <code class="Code-In-Text--PACKT-">Character</code> followed by a set of curly braces, and then save the file. Your class code should exactly match the following code:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine;&#13;
       &#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span>&#13;
{ &#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">We deleted the generated code because we won't need to attach this script to a Unity GameObject.</li>&#13;
    </ol>&#13;
    <p class="normal"><code class="Code-In-Text--PACKT-">Character</code> is now registered as a public class blueprint. This means that any class in the project can <a id="_idIndexMarker263"/>use it to create characters. However, these are just the instructions—to create a character takes an additional step. This creational step is called <em class="italic">instantiation </em>and is the subject of the next section.</p>&#13;
    <h2 id="_idParaDest-110" class="title">Instantiating class objects</h2>&#13;
    <p class="normal">Instantiation<a id="_idIndexMarker264"/> is the act of creating an object from a specific set of instructions, which is called an instance. If classes are blueprints, instances are the houses built from their instructions; every new instance of <code class="Code-In-Text--PACKT-">Character</code> is its object, just like two houses built from the same instructions are still two different physical structures. What happens to one doesn't have any repercussions on the other.</p>&#13;
    <p class="normal">In <em class="chapterRef">Chapter 4</em>, <em class="italic">Control Flow and Collection Types</em>, we created lists and dictionaries, which are default classes that come with C#, using their types and the <code class="Code-In-Text--PACKT-">new</code> keyword. We can do the same thing for custom classes such as <code class="Code-In-Text--PACKT-">Character</code>, which you'll do next.</p>&#13;
    <p class="normal">We declared the <code class="Code-In-Text--PACKT-">Character</code> class as public, which means that a <code class="Code-In-Text--PACKT-">Character</code> instance can be created in any other class. Since we have <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>working already, let's declare a new character in the <code class="Code-In-Text--PACKT-">Start()</code> method.</p>&#13;
    <p class="normal">Open <code class="Code-In-Text--PACKT-">LearningCurve</code> and declare a new <code class="Code-In-Text--PACKT-">Character</code> type variable, called <code class="Code-In-Text--PACKT-">hero</code>, in the <code class="Code-In-Text--PACKT-">Start()</code> method:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Character hero = <span class="hljs-keyword">new</span> Character(); &#13;
</code></pre>&#13;
    <p class="normal">Let's break this down one step at a time:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">The variable type is specified as <code class="Code-In-Text--PACKT-">Character</code>, meaning that the variable is an instance of that class.</li>&#13;
      <li class="numbered">The variable is named <code class="Code-In-Text--PACKT-">hero</code>, and it is created using the <code class="Code-In-Text--PACKT-">new</code> keyword, followed by the <code class="Code-In-Text--PACKT-">Character</code> class name and two parentheses. This is where the actual instance is created in the program's memory, even if the class is empty right now.</li>&#13;
      <li class="numbered">We can use the <code class="Code-In-Text--PACKT-">hero</code> variable just like any other object we've worked with so far. When the <code class="Code-In-Text--PACKT-">Character</code> class gets variables and methods of its own, we can access them from <code class="Code-In-Text--PACKT-">hero</code> using dot notation.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">You could just as easily have used an inferred declaration when creating the <code class="Code-In-Text--PACKT-">hero</code> variable, like so: </p>&#13;
      <pre class="programlisting code"><code class="hljs-code">var hero = <span class="hljs-keyword">new</span> Character();&#13;
</code></pre>&#13;
    </div>&#13;
    <p class="normal">Now our character class can't do much without any class fields to work with. You'll be adding<a id="_idIndexMarker265"/> class fields, and more, in the next few sections.</p>&#13;
    <h2 id="_idParaDest-111" class="title">Adding class fields</h2>&#13;
    <p class="normal">Adding <a id="_idIndexMarker266"/>variables, or fields, to a custom class is no different than what we've already been doing with <code class="Code-In-Text--PACKT-">LearningCurve</code>. The same concepts apply, including access modifiers, variable scope, and value assignments. However, any variables belonging to a class are created with the class instance, meaning that if there are no values assigned, they will default to zero or null. In general, choosing to set initial values comes down to what information they will store:</p>&#13;
    <ul>&#13;
      <li class="bullet">If a variable needs to have the same starting value whenever a class instance is created, setting an initial value is a solid idea. This would be useful for something like experience points or the starting score.</li>&#13;
      <li class="bullet">If a variable needs to be customized in every class instance, like <code class="Code-In-Text--PACKT-">CharacterName</code>, leave its value unassigned and use a class constructor (a topic that we'll get to in the <em class="italic">Using constructors</em> section).</li>&#13;
    </ul>&#13;
    <p class="normal">Every character class is going to need a few basic fields; it's your job to add them in the following section.</p>&#13;
    <p class="normal">Let's incorporate two variables to hold the character's name and the number of starting experience points:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add two <code class="Code-In-Text--PACKT-">public</code> variables inside the <code class="Code-In-Text--PACKT-">Character</code> class's curly braces—a <code class="Code-In-Text--PACKT-">string</code> variable for the name, and an <code class="Code-In-Text--PACKT-">integer</code> variable for the experience points.</li>&#13;
      <li class="numbered">Leave the <code class="Code-In-Text--PACKT-">name</code> value empty, but set the experience points to <code class="Code-In-Text--PACKT-">0</code> so that every character starts from the bottom:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span>&#13;
{&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> exp = <span class="hljs-number">0</span>; &#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Add a debug log in <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>right after the <code class="Code-In-Text--PACKT-">Character</code> instance was initialized. Use it to print out the new character's <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">exp</code> variables using dot <a id="_idIndexMarker267"/>notation:&#13;
        <pre class="programlisting code"><code class="hljs-code">Character hero = <span class="hljs-keyword">new</span> Character(); &#13;
Debug.LogFormat(<span class="hljs-string">"Hero: {0} - {1} EXP"</span>, hero.name, hero.exp);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">When <code class="Code-In-Text--PACKT-">hero</code> is initialized, <code class="Code-In-Text--PACKT-">name</code> is assigned a null value that shows up as an empty space in the debug log, while <code class="Code-In-Text--PACKT-">exp</code> prints out <code class="Code-In-Text--PACKT-">0</code>. Notice that we didn't have to attach the <code class="Code-In-Text--PACKT-">Character</code> script to any GameObjects in the scene; we just referenced them in <code class="Code-In-Text--PACKT-">LearningCurve</code> and Unity did the rest. The console will now debug out our character information, which is referenced as follows:<figure class="mediaobject"><img src="Images/B17573_05_01.png" alt="" width="640" height="107"/></figure>&#13;
    <p class="packt_figref">Figure 5.1: Screenshot of custom class properties printed in the console</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">At this point, our class is working, but it's not very practical with these empty values. You'll need to <a id="_idIndexMarker268"/>fix that with what's called a class constructor.</p>&#13;
    <h2 id="_idParaDest-112" class="title">Using constructors</h2>&#13;
    <p class="normal">Class constructors<a id="_idIndexMarker269"/> are special methods that fire automatically when a class instance is created, which is similar to how the <code class="Code-In-Text--PACKT-">Start</code> method runs in <code class="Code-In-Text--PACKT-">LearningCurve</code>. Constructors build the class according to its blueprint:</p>&#13;
    <ul>&#13;
      <li class="bullet">If a constructor is not specified, C# generates a default one. The default constructor sets any variables to their default type values—numeric values are set to zero, Booleans to false, and reference types (classes) to null.</li>&#13;
      <li class="bullet">Custom constructors can be defined with parameters, just like any other method, and are used to set class variable values at initialization.</li>&#13;
      <li class="bullet">A class can have multiple constructors.</li>&#13;
    </ul>&#13;
    <p class="normal">Constructors are written like regular methods but with a few differences; for instance, they need to be public, have no return type, and the method name is always the class name. As an example, let's add a basic constructor with no parameters to the <code class="Code-In-Text--PACKT-">Character</code> class and set the name field to something other than null.</p>&#13;
    <p class="normal">Add this new code directly underneath the class variables, as follows:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;&#13;
<span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> exp = <span class="hljs-number">0</span>;&#13;
<span class="code-highlight"><strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Character</strong><strong class="hljs-function-slc">()</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">{</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">    name = </strong><strong class="hljs-string-slc">"Not assigned"</strong><strong class="hljs-slc">;</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">}</strong></span>&#13;
</code></pre>&#13;
    <p class="normal">Run the project in Unity and you'll see the <code class="Code-In-Text--PACKT-">hero</code> instance using this new constructor. The debug log will show the hero's name as <strong class="screenText">Not assigned</strong> instead of a null value: </p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_05_02.png" alt="" width="554" height="92"/></figure>&#13;
    <p class="packt_figref">Figure 5.2: Screenshot of unassigned custom class variables printed to the console</p>&#13;
    <p class="normal">This is good progress, but we need the class constructor to be more flexible. This means that we need to be able to pass in values so that they can be used as starting values, which you'll do next.</p>&#13;
    <p class="normal">Now, the <code class="Code-In-Text--PACKT-">Character</code> class is starting to behave more like a real object, but we can make this even better by adding a second constructor to take in a name at initialization and set it to the <code class="Code-In-Text--PACKT-">name</code> field:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add another constructor to <code class="Code-In-Text--PACKT-">Character</code> that takes in a <code class="Code-In-Text--PACKT-">string</code> parameter, called <code class="Code-In-Text--PACKT-">name</code>.</li>&#13;
      <li class="numbered">Assign<a id="_idIndexMarker270"/> the parameter to the class's <code class="Code-In-Text--PACKT-">name</code> variable using the <code class="Code-In-Text--PACKT-">this</code> keyword. This is called <em class="italic">constructor overloading</em>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Character</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> name</span><span class="hljs-function">)</span>&#13;
{&#13;
    <span class="hljs-keyword">this</span>.name = name;&#13;
}&#13;
</code></pre>&#13;
        <div class="note">&#13;
          <p class="Information-Box--PACKT-">For convenience, constructors will often have parameters that share a name with a class variable. In these cases, use the <code class="Code-In-Text--PACKT-">this</code> keyword to specify which variable belongs to the class. In the example here, <code class="Code-In-Text--PACKT-">this.name</code> refers to the class's name variable, while <code class="Code-In-Text--PACKT-">name</code> is the parameter; without the <code class="Code-In-Text--PACKT-">this</code> keyword, the compiler will throw a warning because it won't be able to tell them apart.</p>&#13;
        </div>&#13;
      </li>&#13;
      <li class="numbered">Create a new <code class="Code-In-Text--PACKT-">Character</code> instance in <code class="Code-In-Text--PACKT-">LearningCurve</code>, called <code class="Code-In-Text--PACKT-">heroine</code>. Use the custom constructor to pass in a name when it's initialized and print out the details in the console:&#13;
        <pre class="programlisting code"><code class="hljs-code">Character heroine = <span class="hljs-keyword">new</span> Character(<span class="hljs-string">"Agatha"</span>);&#13;
Debug.LogFormat(<span class="hljs-string">"Hero: {0} - {1} EXP"</span>, heroine.name,&#13;
        heroine.exp);&#13;
</code></pre>&#13;
        <p class="bullet-para">When a class has multiple constructors or a method has multiple variations, Visual Studio will show a set of arrows in the autocomplete popup that can be scrolled through using the arrow keys:</p>&#13;
        <figure class="mediaobject"><img src="Images/B17573_05_03.png" alt="" width="751" height="97"/></figure>&#13;
        <p class="packt_figref">Figure 5.3: Screenshot of multiple method constructors in Visual Studio</p>&#13;
      </li>&#13;
      <li class="numbered">We can now choose between the basic and custom constructor when we initialize a new <code class="Code-In-Text--PACKT-">Character</code> class. The <code class="Code-In-Text--PACKT-">Character</code> class itself is now far more flexible when it comes to configuring different instances for different situations:<figure class="mediaobject"><img src="Images/B17573_05_04.png" alt="" width="750" height="202"/></figure>&#13;
    <p class="packt_figref">Figure 5.4: Screenshot of multiple custom class instances printed in the console</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">Now the real work<a id="_idIndexMarker271"/> starts; our class needs methods to be able to do anything useful besides acting as a storage facility for variables. Your next task is to put this into practice.</p>&#13;
    <h2 id="_idParaDest-113" class="title">Declaring class methods</h2>&#13;
    <p class="normal">Adding<a id="_idIndexMarker272"/> methods to custom classes is no different from adding them to <code class="Code-In-Text--PACKT-">LearningCurve</code>. However, this is a good opportunity to talk about a staple of good <a id="_idIndexMarker273"/>programming—<strong class="keyword">Don't Repeat Yourself</strong> (<strong class="keyword">DRY</strong>). DRY is a benchmark of all well-written code. Essentially, if you find yourself writing the same line, or lines, over and over, it's time to rethink and reorganize. This usually takes the form of a new method to hold the repeated code, making it easier to modify and call that functionality elsewhere in the current script or even from other scripts.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">In programming terms, you'll<a id="_idIndexMarker274"/> see this referred to as <strong class="keyword">abstracting </strong>out a method or feature.</p>&#13;
    </div>&#13;
    <p class="normal">We have a fair bit of repeated code already, so let's take a look and see where we can increase the legibility and efficiency of our scripts.</p>&#13;
    <p class="normal">Our repeated debug logs are a perfect opportunity to abstract out some code directly into the <code class="Code-In-Text--PACKT-">Character</code> class:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add a new <code class="Code-In-Text--PACKT-">public</code> method with a <code class="Code-In-Text--PACKT-">void</code> return type, called <code class="Code-In-Text--PACKT-">PrintStatsInfo</code>, to the <code class="Code-In-Text--PACKT-">Character</code> class.</li>&#13;
      <li class="numbered">Copy and paste the debug log from <code class="Code-In-Text--PACKT-">LearningCurve</code> into the method body.</li>&#13;
      <li class="numbered">Change the variables to <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">exp</code>, since they can now be referenced from the class directly:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">PrintStatsInfo</span><span class="hljs-function">()</span>&#13;
{&#13;
      Debug.LogFormat(<span class="hljs-string">"Hero: {0} - {1} EXP"</span>, name, exp);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Replace<a id="_idIndexMarker275"/> the character debug log that we previously added to <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>with method calls to <code class="Code-In-Text--PACKT-">PrintStatsInfo</code>, and click on play:&#13;
        <pre class="programlisting code"><code class="hljs-code"> Character hero = <span class="hljs-keyword">new</span> Character();&#13;
<span class="code-highlight"><strong class="hljs-slc"> hero.PrintStatsInfo();</strong></span>&#13;
 Character heroine = <span class="hljs-keyword">new</span> Character(<span class="hljs-string">"Agatha"</span>);&#13;
<span class="code-highlight"><strong class="hljs-slc"> heroine.PrintStatsInfo();</strong></span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Now that the <code class="Code-In-Text--PACKT-">Character</code> class has a method, any instance can freely access it using dot notation. Since <code class="Code-In-Text--PACKT-">hero</code> and <code class="Code-In-Text--PACKT-">heroine</code> are both separate objects, <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> debugs their respective <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">exp</code> values to the console.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">This behavior is better than having the debug logs directly in <code class="Code-In-Text--PACKT-">LearningCurve</code>. It's always a good idea to group functionality into a class and drive action through methods. This makes the code more readable—as our <code class="Code-In-Text--PACKT-">Character</code> objects are giving a command when printing out the debug logs, instead of repeating code.</p>&#13;
    </div>&#13;
    <p class="bullet-para">The entire <code class="Code-In-Text--PACKT-">Character</code> class should look like the following code:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> System.Collections;&#13;
<span class="hljs-keyword">using</span> System.Collections.Generic;&#13;
<span class="hljs-keyword">using</span> UnityEngine;&#13;
 &#13;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Character</span>&#13;
{&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> exp = <span class="hljs-number">0</span>;&#13;
 &#13;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Character</span><span class="hljs-function">()</span>&#13;
    {&#13;
        name = <span class="hljs-string">"Not assigned"</span>;&#13;
    }&#13;
 &#13;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Character</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> name</span><span class="hljs-function">)</span>&#13;
    {&#13;
        <span class="hljs-keyword">this</span>.name = name;&#13;
    }&#13;
 &#13;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">PrintStatsInfo</span><span class="hljs-function">()</span>&#13;
    {&#13;
        Debug.LogFormat(<span class="hljs-string">"Hero: {0} - {1} EXP"</span>, name, exp);&#13;
    }&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">With classes<a id="_idIndexMarker276"/> covered, you're well on your way to writing modularized code that's readable, lightweight, and reusable. Now it's time to tackle the class's cousin object —the struct!</p>&#13;
    <h1 id="_idParaDest-114" class="title">Declaring structs</h1>&#13;
    <p class="normal"><strong class="keyword">Structs</strong> are<a id="_idIndexMarker277"/> similar to classes in that they are also blueprints for objects you want to create in your programs. The main difference is that they are <em class="italic">value types</em>, meaning they are passed by value instead of reference, like classes are. When structs are assigned or passed to another variable, a new copy of the struct is created, so the original isn't referenced at all. We'll go into this in more detail in the next section. First, we need to understand how structs work and the specific rules that apply when creating them.</p>&#13;
    <p class="normal">Structs are declared in the same way as classes, and can hold fields, methods, and constructors:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">accessModifier <span class="hljs-keyword">struct</span> UniqueName &#13;
{&#13;
    Variables&#13;
    Constructors&#13;
    Methods&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Like classes, any variables and methods belong exclusively to the struct and are accessed by its unique name.</p>&#13;
    <p class="normal">However, structs have a few limitations:</p>&#13;
    <ul>&#13;
      <li class="bullet">Variables cannot be initialized with values inside the struct declaration unless they're marked with the <code class="Code-In-Text--PACKT-">static</code> or <code class="Code-In-Text--PACKT-">const</code> modifier—you can read more about this in <em class="chapterRef">Chapter 10</em>, <em class="italic">Revisiting Types, Methods, and Classes</em>.</li>&#13;
      <li class="bullet">Constructors without parameters aren't permitted.</li>&#13;
      <li class="bullet">Structs come with a default constructor that will automatically set all variables to their default values according to their type.</li>&#13;
    </ul>&#13;
    <p class="normal">Every character <a id="_idIndexMarker278"/>requires a good weapon, and these weapons are the perfect fit for a struct object over a class. We'll discuss why that is in the <em class="italic">Understanding reference and value types </em>section of this chapter. However, first, you're going to create one to play around with.</p>&#13;
    <p class="normal">Our characters are going to need good weapons to see them through quests, which are good candidates for a simple struct:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Right-click on the <code class="Code-In-Text--PACKT-">Scripts</code> folder, choose <strong class="screenText">Create</strong>, and select <strong class="screenText">C# Script</strong>.</li>&#13;
      <li class="numbered">Name it <code class="Code-In-Text--PACKT-">Weapon</code>, open it up in Visual Studio, and delete all the generated code after <code class="Code-In-Text--PACKT-">using UnityEngine</code>.</li>&#13;
      <li class="numbered">Declare a public struct called <code class="Code-In-Text--PACKT-">Weapon</code>, followed by a set of curly braces, and then save the file.</li>&#13;
      <li class="numbered">Add a field for <code class="Code-In-Text--PACKT-">name</code> of type <code class="Code-In-Text--PACKT-">string</code> and another field for <code class="Code-In-Text--PACKT-">damage</code> of type <code class="Code-In-Text--PACKT-">int</code>:<div class="note">&#13;
          <p class="Information-Box--PACKT-">You can have classes and structs nested within each other, but this is generally frowned upon because it clutters up the code.</p>&#13;
        </div>&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> Weapon&#13;
{&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> name;&#13;
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> damage;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Declare a constructor with the <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">damage</code> parameters, and set the struct fields using the <code class="Code-In-Text--PACKT-">this</code> keyword:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Weapon</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> name, </span><span class="hljs-built_in">int</span><span class="hljs-params"> damage</span><span class="hljs-function">)</span>&#13;
{&#13;
    <span class="hljs-keyword">this</span>.name = name;&#13;
    <span class="hljs-keyword">this</span>.damage = damage;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Add a debug method below the constructor to print out the weapon information:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">PrintWeaponStats</span><span class="hljs-function">()</span>&#13;
{&#13;
    Debug.LogFormat(<span class="hljs-string">"Weapon: {0} - {1} DMG"</span>, name, damage);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">In <code class="Code-In-Text--PACKT-">LearningCurve</code>, create a new <code class="Code-In-Text--PACKT-">Weapon</code> struct using the custom constructor and the <code class="Code-In-Text--PACKT-">new</code> keyword:&#13;
        <pre class="programlisting code"><code class="hljs-code">Weapon huntingBow = <span class="hljs-keyword">new</span> Weapon(<span class="hljs-string">"Hunting Bow"</span>, <span class="hljs-number">105</span>); &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Our new <code class="Code-In-Text--PACKT-">huntingBow</code> object uses the custom constructor and provides values for both fields on initialization.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">It's a good idea to limit scripts to a single class, but it's fairly common to see structs that are used exclusively by a class included in the file. </p>&#13;
    </div>&#13;
    <p class="normal">Now that we<a id="_idIndexMarker279"/> have an example of both reference (class) and value (struct) objects, it's time to get acquainted with each of their finer points. More specifically, you'll need to understand how each of these objects is passed and stored in memory.</p>&#13;
    <h1 id="_idParaDest-115" class="title">Understanding reference and value types</h1>&#13;
    <p class="normal">Other than<a id="_idIndexMarker280"/> keywords<a id="_idIndexMarker281"/> and initial field values, we haven't seen much difference between classes and structs so far. Classes are best suited for grouping together complex actions and data that will change throughout a program; structs are a better choice for simple objects and data that will remain constant for the most part. Besides their uses, they are fundamentally different in one key area—that is, how they are passed or assigned between variables. Classes are <em class="italic">reference types</em>, meaning that they are passed by reference; structs are <em class="italic">value types</em>, meaning that <a id="_idIndexMarker282"/>they are<a id="_idIndexMarker283"/> passed by value.</p>&#13;
    <h2 id="_idParaDest-116" class="title">Reference types</h2>&#13;
    <p class="normal">When the<a id="_idIndexMarker284"/> instances of our <code class="Code-In-Text--PACKT-">Character</code> class are initialized, the <code class="Code-In-Text--PACKT-">hero</code> and <code class="Code-In-Text--PACKT-">heroine</code> variables don't hold their class information—instead, they hold a reference to where the object is located in the program's memory. If we assigned <code class="Code-In-Text--PACKT-">hero</code> or <code class="Code-In-Text--PACKT-">heroine</code> to another variable in the same class, the memory reference is assigned, not the character data. This has several implications, the most important being that if we have multiple variables storing the same memory reference, a change to one affects them all.</p>&#13;
    <p class="normal">Topics like this are better demonstrated than explained; it's up to you to try this out in a practical example, next.</p>&#13;
    <p class="normal">It's time to test that the <code class="Code-In-Text--PACKT-">Character</code> class is a reference type:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Declare a new <code class="Code-In-Text--PACKT-">Character</code> variable in <code class="Code-In-Text--PACKT-">LearningCurve</code> called <code class="Code-In-Text--PACKT-">hero2</code>. Assign <code class="Code-In-Text--PACKT-">hero2</code> to the <code class="Code-In-Text--PACKT-">hero</code> variable and use the <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> method to print out both sets of information.</li>&#13;
      <li class="numbered">Click play<strong class="keyword"> </strong>and take a look at the two debug logs that show up in the console:&#13;
        <pre class="programlisting code"><code class="hljs-code">Character hero = <span class="hljs-keyword">new</span> Character();&#13;
<span class="code-highlight"><strong class="hljs-slc">Character hero2 = hero;</strong></span>&#13;
 &#13;
hero.PrintStatsInfo();&#13;
<span class="code-highlight"><strong class="hljs-slc">hero2.PrintStatsInfo();</strong></span> &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">The two debug logs will be identical because <code class="Code-In-Text--PACKT-">hero2</code> was assigned to <code class="Code-In-Text--PACKT-">hero</code> when it was created. At this point, both <code class="Code-In-Text--PACKT-">hero2</code> and <code class="Code-In-Text--PACKT-">hero</code> point to where <code class="Code-In-Text--PACKT-">hero</code> is located in memory:<figure class="mediaobject"><img src="Images/B17573_05_05.png" alt="" width="750" height="164"/></figure>&#13;
        <p class="packt_figref">Figure 5.5: Screenshot of the struct stats printed to the console</p>&#13;
      </li>&#13;
      <li class="numbered">Now, change the name of <code class="Code-In-Text--PACKT-">hero2</code> to something fun and click play<strong class="keyword"> </strong>again:&#13;
        <pre class="programlisting code"><code class="hljs-code">Character hero2 = hero;&#13;
<span class="code-highlight"><strong class="hljs-slc">hero2.name = </strong><strong class="hljs-string-slc">"Sir Krane the Brave"</strong><strong class="hljs-slc">;</strong></span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">You'll see that both <code class="Code-In-Text--PACKT-">hero</code> and <code class="Code-In-Text--PACKT-">hero2</code> now have the same name, even though only one of our characters' data was changed:<figure class="mediaobject"><img src="Images/B17573_05_06.png" alt="" width="751" height="166"/></figure>&#13;
    <p class="packt_figref">Figure 5.6: Screenshot of class instance properties printed to the console</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">The lesson here is that reference types need to be treated carefully and not copied when assigned to new variables. Any change to one reference trickles through all other variables holding the same reference.</p>&#13;
    <p class="normal">If you're trying to copy a class, either create a new, separate instance or reconsider whether a<a id="_idIndexMarker285"/> struct might be a better choice for your object blueprint. You'll get a better glimpse of value types in the following section.</p>&#13;
    <h2 id="_idParaDest-117" class="title">Value types</h2>&#13;
    <p class="normal">When a struct <a id="_idIndexMarker286"/>object is created, all of its data is stored in its corresponding variable with no references or connections to its memory location. This makes structs useful for creating objects that need to be copied quickly and efficiently, while still retaining their separate identities. Try this out with our <code class="Code-In-Text--PACKT-">Weapon</code> struct in the following exercise.</p>&#13;
    <p class="normal">Let's create a new weapon object by copying <code class="Code-In-Text--PACKT-">huntingBow</code> into a new variable and updating its data to see whether the changes affect both structs:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Declare a new <code class="Code-In-Text--PACKT-">Weapon</code> struct in <code class="Code-In-Text--PACKT-">LearningCurve</code>, and<em class="italic"> </em>assign <code class="Code-In-Text--PACKT-">huntingBow</code> as its initial value:&#13;
        <pre class="programlisting code"><code class="hljs-code">Weapon huntingBow = <span class="hljs-keyword">new</span> Weapon(<span class="hljs-string">"Hunting Bow"</span>, <span class="hljs-number">105</span>);&#13;
<span class="code-highlight"><strong class="hljs-slc">Weapon warBow = huntingBow;</strong></span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Print out each weapon's data using the debug method:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-slc">huntingBow.PrintWeaponStats();</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">warBow.PrintWeaponStats();</strong></span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">The way they're set up now, both <code class="Code-In-Text--PACKT-">huntingBow</code> and <code class="Code-In-Text--PACKT-">warBow</code> will have the same debug logs, just like our two characters did before we changed any data:<figure class="mediaobject"><img src="Images/B17573_05_07.png" alt="" width="750" height="131"/></figure>&#13;
        <p class="packt_figref">Figure 5.7: Screenshot of the struct instances printed to the console</p>&#13;
      </li>&#13;
      <li class="numbered">Change the <code class="Code-In-Text--PACKT-">warBow.name</code> and <code class="Code-In-Text--PACKT-">warBow.damage</code> fields to values of your choice and click on play again:&#13;
        <pre class="programlisting code"><code class="hljs-code"> Weapon warBow = huntingBow;&#13;
<span class="code-highlight"><strong class="hljs-slc"> warBow.name = </strong><strong class="hljs-string-slc">"War Bow"</strong><strong class="hljs-slc">;</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc"> warBow.damage = </strong><strong class="hljs-number-slc">155</strong><strong class="hljs-slc">;</strong></span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">The console <a id="_idIndexMarker287"/>will show that only the data relating to <code class="Code-In-Text--PACKT-">warBow</code> was changed, and that <code class="Code-In-Text--PACKT-">huntingBow</code> retains its original data.<figure class="mediaobject"><img src="Images/B17573_05_08.png" alt="" width="750" height="174"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 5.8: Screenshot of updated struct properties printed to console</p>&#13;
    <p class="normal">The takeaway from this example is that structs are easily copied and modified as their separate objects, unlike classes, which retain references to an original object. Now that we understand a little more about how structs and classes work under the hood, and confirmed how reference and value types behave in their natural habitat, we're in a good place to start talking about one of the most important coding topics, OOP, and how it fits <a id="_idIndexMarker288"/>into the programming landscape.</p>&#13;
    <h1 id="_idParaDest-118" class="title">Integrating the object-oriented mindset</h1>&#13;
    <p class="normal">Things in the <a id="_idIndexMarker289"/>physical world operate on a similar level to OOP; when you want to buy a soft drink, you grab a can of soda, not the liquid itself. The can is an object, grouping related information and actions together in a self-contained package. However, there are rules when dealing with objects, both in programming and the grocery store —for instance, who can access them. Different variations and generic actions all play into the nature of the objects all around us.</p>&#13;
    <p class="normal">In programming terms, these rules are the main tenets of OOP: <em class="italic">encapsulation</em>, <em class="italic">inheritance</em>, and <em class="italic">polymorphism</em>. </p>&#13;
    <h2 id="_idParaDest-119" class="title">Encapsulation</h2>&#13;
    <p class="normal">One of the <a id="_idIndexMarker290"/>best things about OOP is that it supports encapsulation—defining how accessible an object's variables and methods are to outside code (this is sometimes referred to as <em class="italic">calling code</em>). Take our soda can as an example—in a vending machine, the possible interactions are limited. Since the machine is locked, not just anyone can come up and grab one; if you happen to have the right change, you'll be allowed provisional access to it, but in a specified quantity. If the machine itself is locked inside a room, only someone with the door key will even know the soda can exists.</p>&#13;
    <p class="normal">The question you're asking yourself now is, how do we set these limitations? The simple answer is that we've been using encapsulation this entire time by specifying access modifiers for our object variables and methods.</p>&#13;
    <p class="normal">If you need a refresher, go back and visit the <em class="italic">Access modifiers</em> section in <em class="chapterRef">Chapter 3</em>, <em class="italic">Diving into Variables, Types, and Methods</em>.</p>&#13;
    <p class="normal">Let's try out a simple encapsulation example to understand how this works in practice. Our <code class="Code-In-Text--PACKT-">Character</code> class is public, as are its fields and methods. However, what if we wanted a method that can reset a character's data to its initial values? This could come in handy, but could prove disastrous if it was accidentally called, making it a perfect candidate for a private object member:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Create a <code class="Code-In-Text--PACKT-">private</code> method called <code class="Code-In-Text--PACKT-">Reset</code>, with no return value inside the <code class="Code-In-Text--PACKT-">Character</code> class. Set the <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">exp</code> variables back to <code class="Code-In-Text--PACKT-">"Not assigned"</code> and <code class="Code-In-Text--PACKT-">0</code>, respectively:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Reset</span><span class="hljs-function">()</span>&#13;
{&#13;
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"Not assigned"</span>;&#13;
    <span class="hljs-keyword">this</span>.exp = <span class="hljs-number">0</span>;&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Try and call <code class="Code-In-Text--PACKT-">Reset()</code> from <code class="Code-In-Text--PACKT-">LearningCurve</code> after printing out the <code class="Code-In-Text--PACKT-">hero2</code> data: <figure class="mediaobject"><img src="Images/B17573_05_09.png" alt="" width="750" height="140"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 5.9: Screenshot of an inaccessible method in the Character class</p>&#13;
    <p class="normal">If you're<a id="_idIndexMarker291"/> wondering whether Visual Studio is broken, it's not. Marking a method or variable as private will make it inaccessible inside this class or struct using dot notation; if you manually type it in and hover over <code class="Code-In-Text--PACKT-">Reset()</code>, you'll see an error message regarding the method being protected.</p>&#13;
    <p class="normal">To actually call this private method, we could add a reset command inside the class constructor:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Character</span><span class="hljs-function">()</span>&#13;
{&#13;
    Reset();&#13;
}&#13;
</code></pre>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Encapsulation does allow more complex accessibility setups with objects; however, for now, we're going to stick with <code class="Code-In-Text--PACKT-">public</code> and <code class="Code-In-Text--PACKT-">private</code> members. As we begin to flesh out our game prototype in the next chapter, we'll add in different modifiers as needed.</p>&#13;
    </div>&#13;
    <p class="normal">Now, let's talk about inheritance, which is going to be your best friend when creating class hierarchies<a id="_idIndexMarker292"/> in your future games.</p>&#13;
    <h2 id="_idParaDest-120" class="title">Inheritance</h2>&#13;
    <p class="normal">A C# class can be<a id="_idIndexMarker293"/> created in the image of another class, sharing its member variables and methods, but able to define its unique data. In OOP, we refer to this as <em class="italic">inheritance</em>, and it's a powerful way of creating related classes without having to repeat code. Take the soda example again—there are generic sodas on the market that have all the same basic properties, and then there are special sodas. The special sodas share the same basic properties but have different branding, or packaging, that sets them apart. When you look at both side by side, it's obvious that they're both cans of soda—but they're also obviously not the same.</p>&#13;
    <p class="normal">The original class is usually called the base or parent class, while the inheriting class is called the derived or child class. Any base class members marked with the <code class="Code-In-Text--PACKT-">public</code>, <code class="Code-In-Text--PACKT-">protected</code>, or <code class="Code-In-Text--PACKT-">internal</code> access modifiers are automatically part of the derived class—except for constructors. Class constructors always belong to their containing class, but they can be used from derived classes to keep repeated code to a minimum. Don't worry too much about the different base class scenarios right now. Instead, let's try out a simple game example.</p>&#13;
    <p class="normal">Most games have more than one type of character, so let's create a new class called <code class="Code-In-Text--PACKT-">Paladin</code> that inherits from the <code class="Code-In-Text--PACKT-">Character</code> class. You can add this new class to the <code class="Code-In-Text--PACKT-">Character</code> script or create a new one. If you're adding the new class to the <code class="Code-In-Text--PACKT-">Character</code> script, make sure it's outside the <code class="Code-In-Text--PACKT-">Character</code> class's curly brackets:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Paladin</span>: <span class="hljs-title">Character</span>&#13;
{&#13;
}&#13;
</code></pre>&#13;
    <p class="normal">Just as <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>inherits from <code class="Code-In-Text--PACKT-">MonoBehavior</code>, all we need to do is add a colon and the base class we want to inherit from, and C# does the rest. Now, any <code class="Code-In-Text--PACKT-">Paladin</code> instances will have access to a <code class="Code-In-Text--PACKT-">name</code> property and an <code class="Code-In-Text--PACKT-">exp</code> property along with a <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> method.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">It's generally considered best practice to create a new script for different classes instead of adding them to existing ones. This separates your scripts and avoids having too many lines of code in any single file (called a bloated file).</p>&#13;
    </div>&#13;
    <p class="normal">This is great, but how do inherited classes handle their construction? You can find out in the following <a id="_idIndexMarker294"/>section.</p>&#13;
    <h3 id="_idParaDest-121" class="title">Base constructors</h3>&#13;
    <p class="normal">When a class<a id="_idIndexMarker295"/> inherits from another class, they form a pyramid of sorts with member variables flowing down from the parent class to any of its derived children. The parent class isn't aware of any of its children, but all children are aware of their parent. However, parent class constructors can be called directly from child constructors with a simple syntax modification:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span>: <span class="hljs-title">ParentClass</span>&#13;
{&#13;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ChildClass</span><span class="hljs-function">(): </span><span class="code-highlight"><strong class="hljs-title-slc">base</strong><strong class="hljs-function-slc">()</strong></span>&#13;
    {&#13;
    }&#13;
} &#13;
</code></pre>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">base</code> keyword stands in for the parent constructor—in this case, the default constructor. However, since <code class="Code-In-Text--PACKT-">base</code> is standing in for a constructor, and a constructor is a method, a child class can pass parameters up the pyramid to its parent constructor.</p>&#13;
    <p class="normal">Since we want all <code class="Code-In-Text--PACKT-">Paladin</code> objects to have a name, and <code class="Code-In-Text--PACKT-">Character</code> already has a constructor that handles this, we can call the <code class="Code-In-Text--PACKT-">base</code> constructor directly from the <code class="Code-In-Text--PACKT-">Paladin</code> class and save ourselves the trouble of rewriting a constructor:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add a constructor to the <code class="Code-In-Text--PACKT-">Paladin</code> class that takes in a <code class="Code-In-Text--PACKT-">string</code> parameter, called <code class="Code-In-Text--PACKT-">name</code>. Use a <code class="Code-In-Text--PACKT-">colon</code> and the <code class="Code-In-Text--PACKT-">base</code> keyword to call the parent constructor, passing in <code class="Code-In-Text--PACKT-">name</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Paladin</span>: <span class="hljs-title">Character</span>&#13;
{&#13;
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-function-slc"> </strong><strong class="hljs-title-slc">Paladin</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-built_in-slc">string</strong><strong class="hljs-params-slc"> name</strong><strong class="hljs-function-slc">): </strong><strong class="hljs-title-slc">base</strong><strong class="hljs-function-slc">(</strong><strong class="hljs-params-slc">name</strong><strong class="hljs-function-slc">)</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">    {</strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">      </strong></span>&#13;
<span class="code-highlight"><strong class="hljs-slc">    }</strong></span>&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">In <code class="Code-In-Text--PACKT-">LearningCurve</code>, create a new <code class="Code-In-Text--PACKT-">Paladin</code> instance called <code class="Code-In-Text--PACKT-">knight</code>. Use the base constructor to assign a value. Call <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> from <code class="Code-In-Text--PACKT-">knight</code> and take a look at the console:&#13;
        <pre class="programlisting code"><code class="hljs-code">Paladin knight = <span class="hljs-keyword">new</span> Paladin(<span class="hljs-string">"Sir Arthur"</span>);&#13;
knight.PrintStatsInfo(); &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">The debug log will be the same as our other <code class="Code-In-Text--PACKT-">Character</code> instances, but with the name that we assigned to the <code class="Code-In-Text--PACKT-">Paladin</code> constructor: <figure class="mediaobject"><img src="Images/B17573_05_10.png" alt="" width="751" height="120"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 5.10: Screenshot of base character constructor properties</p>&#13;
    <p class="normal">When the <code class="Code-In-Text--PACKT-">Paladin</code> constructor fires, it passes the <code class="Code-In-Text--PACKT-">name</code> parameter to the <code class="Code-In-Text--PACKT-">Character</code> constructor, which sets the <code class="Code-In-Text--PACKT-">name</code> value. Essentially, we used the <code class="Code-In-Text--PACKT-">Character</code> constructor to do the initialization work for the <code class="Code-In-Text--PACKT-">Paladin</code> class, making the <code class="Code-In-Text--PACKT-">Paladin</code> constructor only responsible for initializing its unique properties, which it doesn't have at this point.</p>&#13;
    <p class="normal">Aside from inheritance, there will be times when you want to make new objects out of a combination <a id="_idIndexMarker296"/>of other existing objects. Think of Lego; you don't start building from nothing—you already have blocks of different colors and structures to work with. In programming terms, this is called <em class="italic">composition</em>, which we'll discuss in the following section.</p>&#13;
    <h2 id="_idParaDest-122" class="title">Composition</h2>&#13;
    <p class="normal">Aside from<a id="_idIndexMarker297"/> inheritance, classes can be composed of other classes. Take our <code class="Code-In-Text--PACKT-">Weapon</code> struct, for example. <code class="Code-In-Text--PACKT-">Paladin</code> can easily contain a <code class="Code-In-Text--PACKT-">Weapon</code> variable inside itself and have access to all its properties and methods. Let's do that by updating <code class="Code-In-Text--PACKT-">Paladin</code> to take in a starting weapon and assign its value in the constructor:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Paladin</span>: <span class="hljs-title">Character</span>&#13;
{&#13;
   <span class="code-highlight"><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">public</strong><strong class="hljs-slc"> Weapon weapon;</strong></span>&#13;
 &#13;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">Paladin</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> name,</span><span class="code-highlight"><strong class="hljs-params-slc"> Weapon weapon</strong></span><span class="hljs-function">): </span><span class="hljs-title">base</span><span class="hljs-function">(</span><span class="hljs-params">name</span><span class="hljs-function">)</span>&#13;
    {&#13;
        <span class="code-highlight"><strong class="hljs-keyword-slc">this</strong><strong class="hljs-slc">.weapon = weapon;</strong></span>&#13;
    }&#13;
} &#13;
</code></pre>&#13;
    <p class="normal">Since <code class="Code-In-Text--PACKT-">weapon</code> is unique to <code class="Code-In-Text--PACKT-">Paladin</code> and not <code class="Code-In-Text--PACKT-">Character</code>, we need to set its initial value in the constructor. We also need to update the <code class="Code-In-Text--PACKT-">knight</code> instance to include a <code class="Code-In-Text--PACKT-">Weapon</code> variable. So, let's use <code class="Code-In-Text--PACKT-">huntingBow</code>:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">Paladin knight = <span class="hljs-keyword">new</span> Paladin(<span class="hljs-string">"Sir Arthur"</span>, <span class="code-highlight"><strong class="hljs-slc">huntingBow</strong></span>);&#13;
</code></pre>&#13;
    <p class="normal">If you run the game now, you won't see anything different because we're using the <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> method from the <code class="Code-In-Text--PACKT-">Character</code> class, which doesn't know about the <code class="Code-In-Text--PACKT-">Paladin</code> class's <code class="Code-In-Text--PACKT-">weapon</code> property. To tackle<a id="_idIndexMarker298"/> this problem, we need to talk about polymorphism.</p>&#13;
    <h2 id="_idParaDest-123" class="title">Polymorphism</h2>&#13;
    <p class="normal">Polymorphism<a id="_idIndexMarker299"/> is the Greek word for <em class="italic">many-shaped</em> and applies<a id="_idIndexMarker300"/> to OOP in two distinct ways:</p>&#13;
    <ul>&#13;
      <li class="bullet">Derived class objects are treated the same as parent class objects. For example, an array of <code class="Code-In-Text--PACKT-">Character</code> objects could also store <code class="Code-In-Text--PACKT-">Paladin</code> objects, as they derive from <code class="Code-In-Text--PACKT-">Character</code>.</li>&#13;
      <li class="bullet">Parent classes can mark methods as <code class="Code-In-Text--PACKT-">virtual</code>, meaning that their instructions can be modified by derived classes using the <code class="Code-In-Text--PACKT-">override</code> keyword. In the case of <code class="Code-In-Text--PACKT-">Character</code> and <code class="Code-In-Text--PACKT-">Paladin</code>, it would be useful if we could debug different messages from <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> for each one.</li>&#13;
    </ul>&#13;
    <p class="normal">Polymorphism allows derived classes to keep the structure of their parent class while also having the freedom to tailor actions to fit their specific needs. Any method you mark as <code class="Code-In-Text--PACKT-">virtual</code> will give you the freedom of object polymorphism. Let's take this new knowledge and apply it to our character debug method.</p>&#13;
    <p class="normal">Let's modify <code class="Code-In-Text--PACKT-">Character</code> and <code class="Code-In-Text--PACKT-">Paladin</code> to print out different debug logs using <code class="Code-In-Text--PACKT-">PrintStatsInfo</code>:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Change <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> in the <code class="Code-In-Text--PACKT-">Character</code> class by adding the <code class="Code-In-Text--PACKT-">virtual</code> keyword between <code class="Code-In-Text--PACKT-">public</code> and <code class="Code-In-Text--PACKT-">void</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="code-highlight"><strong class="hljs-keyword-slc">virtual</strong></span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">PrintStatsInfo</span><span class="hljs-function">()</span>&#13;
{&#13;
    Debug.LogFormat(<span class="hljs-string">"Hero: {0} - {1} EXP"</span>, name, exp);&#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Declare the <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> method in the <code class="Code-In-Text--PACKT-">Paladin</code> class using the <code class="Code-In-Text--PACKT-">override</code> keyword. Add a debug log to print out the <code class="Code-In-Text--PACKT-">Paladin</code> properties in whatever way you like:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">override</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">PrintStatsInfo</span><span class="hljs-function">()</span>&#13;
{&#13;
    Debug.LogFormat(<span class="hljs-string">"Hail {0} - take up your {1}!"</span>, name, &#13;
             weapon.name);&#13;
}&#13;
</code></pre>&#13;
        <p class="bullet-para">This might look like repeated code, which we already said is bad form, but this is a special case. What we've done by marking <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> as <code class="Code-In-Text--PACKT-">virtual</code> in the <code class="Code-In-Text--PACKT-">Character</code> class is to tell the compiler that this method can have many shapes according to the calling class.</p>&#13;
      </li>&#13;
      <li class="numbered">When we declared the overridden version of <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> in <code class="Code-In-Text--PACKT-">Paladin</code>, we added the custom behavior that only applies to that class. Thanks to polymorphism, we don't have to choose which version of <code class="Code-In-Text--PACKT-">PrintStatsInfo</code> we want to<a id="_idIndexMarker301"/> call from a <code class="Code-In-Text--PACKT-">Character</code> or <code class="Code-In-Text--PACKT-">Paladin</code> object—the <a id="_idIndexMarker302"/>compiler already knows:<figure class="mediaobject"><img src="Images/B17573_05_11.png" alt="" width="750" height="112"/></figure>&#13;
    <p class="packt_figref">Figure 5.11: Screenshot of polymorphic character properties</p>&#13;
      </li>&#13;
    </ol>&#13;
&#13;
    <p class="normal">This was a lot to take in, I know. So, let's review some of the main points of OOP as we approach the finish line:</p>&#13;
    <ul>&#13;
      <li class="bullet">OOP is all about grouping related data and actions into objects—objects that can communicate and act independently from each other.</li>&#13;
      <li class="bullet">Access to class members can be set using access modifiers, just like variables.</li>&#13;
      <li class="bullet">Classes can inherit from other classes, creating trickle-down hierarchies of parent/child relationships.</li>&#13;
      <li class="bullet">Classes can have members of other class or struct types.</li>&#13;
      <li class="bullet">Classes can override any parent methods marked as <code class="Code-In-Text--PACKT-">virtual</code>, allowing them to perform custom actions while retaining the same blueprint.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">OOP is not the only programming paradigm that can be used with C#—you can find practical explanations of the other main approaches here: <a href="http://cs.lmu.edu/~ray/notes/paradigms"><span class="url">http://cs.lmu.edu/~ray/notes/paradigms</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">All the OOP you've learned in this chapter is directly applicable to the C# world. However, we still need to put this into perspective with Unity, which is what you'll spend the<a id="_idIndexMarker303"/> rest of the chapter focusing<a id="_idIndexMarker304"/> on.</p>&#13;
    <h1 id="_idParaDest-124" class="title">Applying OOP in Unity</h1>&#13;
    <p class="normal">If you're <a id="_idIndexMarker305"/>around OOP languages <a id="_idIndexMarker306"/>enough, you'll eventually hear the phrase <em class="italic">everything is an object</em> whispered like a secret prayer between developers. Following OOP principles, everything in a program should be an object, but GameObjects in Unity can represent your classes and structs. However, that's not to say all objects in Unity have to be in the physical scene, so we can still use our newfound programmed classes behind the scenes.</p>&#13;
    <h2 id="_idParaDest-125" class="title">Objects are a class act</h2>&#13;
    <p class="normal">Back in <em class="chapterRef">Chapter 2</em>, <em class="italic">The Building Blocks of Programming</em>, we discussed how a script is transformed <a id="_idIndexMarker307"/>into a component when it's added to a GameObject in Unity. Think of this in terms of the OOP principle of composition—GameObjects are the parent containers, and they can be made up of multiple components. This might sound contradictory to the idea of one C# class per script but, in truth, that's more of a guideline for better readability than an actual requirement. Classes can be nested inside one another—it just gets messy fast. However, having multiple script components attached to a single GameObject can be very useful, especially when dealing with manager classes or behaviors.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">Always try to boil down objects to their most basic elements, and then use composition to build bigger, more complex objects out of those smaller classes. It's easier to modify a GameObject made out of small, interchangeable components than one large, clunky one.</p>&#13;
    </div>&#13;
    <p class="normal">Let's take a look at <strong class="screenText">Main Camera</strong> to see this in action:</p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_05_12.png" alt="" width="828" height="338"/></figure>&#13;
    <p class="packt_figref">Figure 5.12: Screenshot of the Main Camera object in the Inspector</p>&#13;
    <p class="normal">Each component in the preceding screenshot (<strong class="screenText">Transform</strong>, <strong class="screenText">Camera</strong>, <strong class="screenText">Audio Listener</strong>, and the <strong class="screenText">Learning Curve</strong> script) started as a class in Unity. Like instances of <code class="Code-In-Text--PACKT-">Character</code> or <code class="Code-In-Text--PACKT-">Weapon</code>, these components become objects in computer memory when we click on play, complete with their member variables and methods.</p>&#13;
    <p class="normal">If we were to attach <code class="Code-In-Text--PACKT-">LearningCurve</code> (or any script or component) to 1,000 GameObjects and click on play, 1,000 separate instances of <code class="Code-In-Text--PACKT-">LearningCurve</code> would be created and stored in memory.</p>&#13;
    <p class="normal">We can even create our instances of these components using their component name as the data type. Like classes, Unity component classes are reference types and can be created like<a id="_idIndexMarker308"/> any other variable. However, finding and assigning these Unity components is slightly different than what you've seen so far. For that, you'll need to understand a little more about how GameObjects work in the following section.</p>&#13;
    <h2 id="_idParaDest-126" class="title">Accessing components</h2>&#13;
    <p class="normal">Now that<a id="_idIndexMarker309"/> we know how components act on GameObjects, how do we go about accessing their specific instances? Lucky for us, all GameObjects in Unity inherit from the <code class="Code-In-Text--PACKT-">GameObject</code> class, which means we can use their member methods to find anything we need in a scene. There are two ways to assign or retrieve GameObjects that are active in the current scene:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Through the <code class="Code-In-Text--PACKT-">GetComponent()</code> or <code class="Code-In-Text--PACKT-">Find()</code> methods in the <code class="Code-In-Text--PACKT-">GameObject</code> class, which work with public and private variables.</li>&#13;
      <li class="numbered">By dragging and dropping the GameObjects themselves from the <code class="Code-In-Text--PACKT-">Project</code> panel directly into variable slots in the <strong class="screenText">Inspector</strong> tab. This option only works with public variables in C#, since they are the only ones that will appear in the Inspector. If you decide you need a private variable displayed in the Inspector, you can mark it with the <code class="Code-In-Text--PACKT-">SerializeField</code> attribute.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">You can learn <a id="_idIndexMarker310"/>more about attributes and <code class="Code-In-Text--PACKT-">SerializeField</code> in the Unity documentation: <a href="https://docs.unity3d.com/ScriptReference/SerializeField.html"><span class="url">https://docs.unity3d.com/ScriptReference/SerializeField.html</span></a>.</p>&#13;
    </div>&#13;
    <p class="normal">Let's <a id="_idIndexMarker311"/>take a look at the syntax of the first option.</p>&#13;
    <h3 id="_idParaDest-127" class="title">Accessing components in code</h3>&#13;
    <p class="normal">Using <code class="Code-In-Text--PACKT-">GetComponent</code> is fairly <a id="_idIndexMarker312"/>simple, but its method signature is slightly different from other methods that we've seen so far:</p>&#13;
    <pre class="programlisting code"><code class="hljs-code">GameObject.GetComponent&lt;ComponentType&gt;();&#13;
</code></pre>&#13;
    <p class="normal">All we need is the component type that we're looking for, and the <code class="Code-In-Text--PACKT-">GameObject</code> class will return the component if it exists and null if it doesn't. There are other variations of the <code class="Code-In-Text--PACKT-">GetComponent</code> method, but this one is the simplest because we don't need to know specifics about the <code class="Code-In-Text--PACKT-">GameObject</code> class that we're looking for. This is called a <code class="Code-In-Text--PACKT-">generic</code> method, which we'll discuss further in <em class="chapterRef">Chapter 13</em>, <em class="italic">Exploring Generics, Delegates, and Beyond</em>. However, for now, let's just work with the camera's transform.</p>&#13;
    <p class="normal">Since <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>is already attached to the <strong class="screenText">Main Camera</strong> object, let's grab the camera's <code class="Code-In-Text--PACKT-">Transform</code> component and store it in a public variable. The <code class="Code-In-Text--PACKT-">Transform</code> component controls an object's position, rotation, and scale in Unity, so it's a handy example:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add a new public <code class="Code-In-Text--PACKT-">Transform</code> type variable, called <code class="Code-In-Text--PACKT-">CamTransform</code>, to <code class="Code-In-Text--PACKT-">LearningCurve</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Transform CamTransform;&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Initialize <code class="Code-In-Text--PACKT-">CamTransform</code> in <code class="Code-In-Text--PACKT-">Start</code> using the <code class="Code-In-Text--PACKT-">GetComponent</code> method from the <code class="Code-In-Text--PACKT-">GameObject</code> class. Use the <code class="Code-In-Text--PACKT-">this</code> keyword, since <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>is attached to the same <code class="Code-In-Text--PACKT-">GameObject</code> component as the <code class="Code-In-Text--PACKT-">Transform</code> component.</li>&#13;
      <li class="numbered">Access and debug the <code class="Code-In-Text--PACKT-">localPosition</code> property of <code class="Code-In-Text--PACKT-">CamTransform</code> using dot notation:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Start</span><span class="hljs-function">()</span>&#13;
{&#13;
    CamTransform = <span class="hljs-keyword">this</span>.GetComponent&lt;Transform&gt;();&#13;
    Debug.Log(CamTransform.localPosition); &#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">We've added an uninitialized <code class="Code-In-Text--PACKT-">public Transform</code> variable at the top of <code class="Code-In-Text--PACKT-">LearningCurve</code> and initialized it using the <code class="Code-In-Text--PACKT-">GetComponent</code> method inside <code class="Code-In-Text--PACKT-">Start</code>. <code class="Code-In-Text--PACKT-">GetComponent</code> finds the <code class="Code-In-Text--PACKT-">Transform</code> component attached to this <code class="Code-In-Text--PACKT-">GameObject</code> component and returns it to <code class="Code-In-Text--PACKT-">CamTransform</code>. With <code class="Code-In-Text--PACKT-">CamTransform</code> now storing a <code class="Code-In-Text--PACKT-">Transform</code> object, we have access to all its class properties and methods—including <code class="Code-In-Text--PACKT-">localPosition</code> in the following screenshot:<figure class="mediaobject"><img src="Images/B17573_05_13.png" alt="" width="749" height="338"/></figure>&#13;
      </li>&#13;
    </ol>&#13;
    <p class="packt_figref">Figure 5.13: Screenshot of the Transform position printed to the console</p>&#13;
    <p class="normal">The <code class="Code-In-Text--PACKT-">GetComponent</code> method is <a id="_idIndexMarker313"/>fantastic for quickly retrieving components, but it only has access to components on the GameObject that the calling script is attached to. For instance, if we use <code class="Code-In-Text--PACKT-">GetComponent</code> from the <code class="Code-In-Text--PACKT-">LearningCurve</code> script attached to the <strong class="screenText">Main Camera</strong>, we'll only be able to access the <strong class="screenText">Transform</strong>, <strong class="screenText">Camera</strong>, and <strong class="screenText">Audio Listener</strong> components.</p>&#13;
    <p class="normal">If we want to reference a component on a separate GameObject, such as <strong class="screenText">Directional Light</strong>, we would need to get a reference to the object first using the <code class="Code-In-Text--PACKT-">Find</code> method. All it takes is the name of a GameObject, and Unity will kick back the appropriate GameObject for us to store or manipulate.</p>&#13;
    <p class="normal">For reference, the name of each GameObject can be found at the top of the <strong class="screenText">Inspector</strong> tab with the object selected:</p>&#13;
    <figure class="mediaobject"><img src="Images/B17573_05_14.png" alt="" width="828" height="125"/></figure>&#13;
    <p class="packt_figref">Figure 5.14: Screenshot of the Directional Light object in the Inspector</p>&#13;
    <p class="normal">Finding objects in your game scenes is crucial in Unity, so you'll need to practice. Let's take the objects we have to work with and practice finding and assigning their components.</p>&#13;
    <p class="normal">Let's take the <code class="Code-In-Text--PACKT-">Find</code> method<a id="_idIndexMarker314"/> out for a spin and retrieve the <strong class="screenText">Directional Light </strong>object from <code class="Code-In-Text--PACKT-">LearningCurve</code>:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Add two variables to <code class="Code-In-Text--PACKT-">LearningCurve</code> underneath <code class="Code-In-Text--PACKT-">CamTransform</code>—one of type <code class="Code-In-Text--PACKT-">GameObject</code> and one of type <code class="Code-In-Text--PACKT-">Transform</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> GameObject DirectionLight;&#13;
<span class="hljs-keyword">public</span> Transform LightTransform; &#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Find the <code class="Code-In-Text--PACKT-">Directional Light</code> component by name, and use it to initialize <code class="Code-In-Text--PACKT-">DirectionLight</code> inside the <code class="Code-In-Text--PACKT-">Start()</code> method:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Start</span><span class="hljs-function">()</span>&#13;
{&#13;
    DirectionLight = GameObject.Find(<span class="hljs-string">"Directional Light"</span>); &#13;
}&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Set the value of <code class="Code-In-Text--PACKT-">LightTransform</code> to the <code class="Code-In-Text--PACKT-">Transform</code> component attached to <code class="Code-In-Text--PACKT-">DirectionLight</code>, and debug its <code class="Code-In-Text--PACKT-">localPosition</code>. Since <code class="Code-In-Text--PACKT-">DirectionLight</code> is its <code class="Code-In-Text--PACKT-">GameObject</code> now, <code class="Code-In-Text--PACKT-">GetComponent</code> works perfectly:&#13;
        <pre class="programlisting code"><code class="hljs-code">LightTransform = DirectionLight.GetComponent&lt;Transform&gt;();&#13;
Debug.Log(LightTransform.localPosition);&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Before running the game, it's important to understand that method calls can be chained together to cut down the number of code steps. For instance, we could initialize <code class="Code-In-Text--PACKT-">LightTransform</code> in a single line by combining <code class="Code-In-Text--PACKT-">Find</code> and <code class="Code-In-Text--PACKT-">GetComponent</code> without having to go through <code class="Code-In-Text--PACKT-">DirectionLight</code>:&#13;
        <pre class="programlisting code"><code class="hljs-code">GameObject.Find(<span class="hljs-string">"Directional Light"</span>).GetComponent&lt;Transform&gt;();&#13;
</code></pre>&#13;
      </li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">A word of warning—long lines of chained code can lead to poor readability and confusion when working on complex applications. It's a good rule of thumb to avoid lines longer than this example. </p>&#13;
    </div>&#13;
    <p class="normal">While finding objects in code always works, you can also simply drag and drop the objects<a id="_idIndexMarker315"/> themselves into the <strong class="screenText">Inspector</strong> tab. Let's demonstrate how to do that in the following section.</p>&#13;
    <h3 id="_idParaDest-128" class="title">Drag and drop</h3>&#13;
    <p class="normal">Now that <a id="_idIndexMarker316"/>we've covered the code-intensive way of doing things, let's take a quick look at Unity's drag and drop functionality. Although dragging and dropping is much faster than using the <code class="Code-In-Text--PACKT-">GameObject</code> class in code, Unity sometimes loses the connections between objects and variables made this way when saving or exporting projects, or when Unity updates.</p>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">When you need to assign a few variables quickly, then, by all means, take advantage of this feature. For most cases, I'd advise sticking with code. </p>&#13;
    </div>&#13;
    <p class="normal">Let's change <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>to show how to assign a <code class="Code-In-Text--PACKT-">GameObject</code> component using drag and drop:</p>&#13;
    <ol>&#13;
      <li class="numbered" value="1">Comment out the following line of code, where we used <code class="Code-In-Text--PACKT-">GameObject.Find()</code> to retrieve and assign the <code class="Code-In-Text--PACKT-">Directional Light</code> object to the <code class="Code-In-Text--PACKT-">DirectionLight</code> variable:&#13;
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//DirectionLight = GameObject.Find("Directional Light");</span>&#13;
</code></pre>&#13;
      </li>&#13;
      <li class="numbered">Select the <strong class="screenText">Main Camera</strong> GameObject, drag <strong class="screenText">Directional Light</strong> to the <code class="Code-In-Text--PACKT-">Direction Light</code> field in the <strong class="screenText">Learning Curve</strong> component, and click on play:<figure class="mediaobject"><img src="Images/B17573_05_15.png" alt="" width="752" height="207"/></figure>&#13;
        <p class="packt_figref">Figure 5.15: Screenshot of dragging Directional Light to the script property</p>&#13;
      </li>&#13;
      <li class="numbered">The <strong class="screenText">Directional Light</strong> GameObject is now assigned to the <code class="Code-In-Text--PACKT-">DirectionLight</code> variable. No code was involved because Unity assigned the variable internally, with no change to the <code class="Code-In-Text--PACKT-">LearningCurve</code><em class="italic"> </em>class.</li>&#13;
    </ol>&#13;
    <div class="note">&#13;
      <p class="Information-Box--PACKT-">It is important to understand a few things when deciding whether to assign variables using drag and drop or <code class="Code-In-Text--PACKT-">GameObject.Find()</code>. First, the <code class="Code-In-Text--PACKT-">Find()</code> method is marginally slower, leaving your game open to performance issues if you are <a id="_idIndexMarker317"/>calling the method multiple times in multiple scripts. Second, you need to be sure your GameObjects all have unique names in the scene hierarchy; if they don't, it may lead to some nasty bugs in situations where you have several objects of the same name or change the object names themselves.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-129" class="title">Summary</h1>&#13;
    <p class="normal">Our journey into classes, structs, and OOP marks the end of the first section on the fundamentals of C#. You've learned how to declare your classes and structs, which is the scaffolding for every application or game you'll ever make. You've also identified the differences in how these two objects are passed and accessed and how they relate to OOP. Finally, you got hands-on with the tenets of OOP—creating classes using inheritance, composition, and polymorphism.</p>&#13;
    <p class="normal">Identifying related data and actions, creating blueprints to give them shape, and using instances to build interactions are a strong foundation for approaching any program or game. Add the ability to access components to the mix, and you've got the makings of a Unity developer.</p>&#13;
    <p class="normal">The next chapter will segue into the basics of game development and scripting object behavior directly in Unity. We'll start by fleshing out the requirements of a simple open-world adventure game, work with GameObjects in the scene, and finish off with a white-boxed environment ready for our characters.</p>&#13;
    <h1 id="_idParaDest-130" class="title">Pop quiz – all things OOP</h1>&#13;
    <ol>&#13;
      <li class="numbered" value="1">What method handles the initialization logic inside a class?</li>&#13;
      <li class="numbered">Being value types, how are structs passed?</li>&#13;
      <li class="numbered">What are the main tenets of OOP?</li>&#13;
      <li class="numbered">Which <code class="Code-In-Text--PACKT-">GameObject</code> class method would you use to find a component on the same object as the calling class?</li>&#13;
    </ol>&#13;
    <h1 class="heading-1">JOIN us on Discord!</h1>&#13;
    <p class="normal">Read this book alongside other users, Unity/C# experts, and Harrison Ferrone. Ask questions, provide solutions to other readers, chat with the author via <em class="italic">Ask Me Anything sessions</em> and much more.</p>&#13;
<p class="normal">Join Now! </p>&#13;
    <p class="normal"><a href="https://packt.link/csharpunity2021"><span class="url">https://packt.link/csharpunity2021</span></a></p>&#13;
    <p class="normal"><span class="url"><img style="height: 8em; width: auto;" src="Images/QR_Code_9781801813945.png" alt="" width="354" height="354"/></span></p>&#13;
  </div>&#13;
</div></body></html>