<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Inside the CLR"><div class="titlepage" id="aid-E9OE2"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Inside the CLR</h1></div></div></div><p>Since CLR is just a generic name for different tools and software based on well-known and accepted principles in computing, we'll begin with a review of some of the most important concepts of software programming that we often take for granted. So, to put things in context, this chapter reviews the most important concepts around the motivations for the creation of .NET, how this framework integrates with the Windows operating system, and what makes the so called CLR the excellent runtime it is.</p><p>In short, this chapter covers the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A brief, but carefully selected, dictionary of the common terms and concepts utilized in general and .NET programming</li><li class="listitem">A rapid review of goals after the creation of .NET and the main architects behind its construction</li><li class="listitem">Explanations of each of the main parts that compose the CLR, its tools, and how the tools work</li><li class="listitem">A basic approach to the complexity of algorithms and how to measure it</li><li class="listitem">A select list of the most outstanding characteristics related to the CLR that appeared in recent versions</li></ul></div><div class="section" title="An annotated reminder of some important computing terms"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>An annotated reminder of some important computing terms</h1></div></div></div><p>Let's check out <a id="id0" class="indexterm"/>some important concepts widely used in software construction that show up frequently in .NET programming.</p><div class="section" title="Context"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Context</h2></div></div></div><p>As <a id="id1" class="indexterm"/>Wikipedia <a id="id2" class="indexterm"/>states:</p><div class="blockquote"><blockquote class="blockquote"><p>In computer science, a task context<a id="id3" class="indexterm"/> is the minimal set of data used by a task (which may be a process or thread) that must be saved to allow a task interruption at a given date, and a continuation of this task at the point it has been interrupted and at an arbitrary future date.</p></blockquote></div><p>In <a id="id4" class="indexterm"/>other words, context is a term related to the data<a id="id5" class="indexterm"/> handled by a thread. Such data is conveniently stored and recovered by the system as required.</p><p>Practical approaches to this concept include HTTP request/response and database scenarios in which the context plays a very important role.</p></div><div class="section" title="The OS multitask execution model"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>The OS multitask execution model</h2></div></div></div><p>A <a id="id6" class="indexterm"/>CPU is able to manage multiple <a id="id7" class="indexterm"/>processes in a period of time. As we mentioned, this is achieved by saving and restoring (in an extremely fast manner) the context of execution with a technique called<a id="id8" class="indexterm"/> context switch.</p><p>When a thread ceases to execute, it is said to be in the <a id="id9" class="indexterm"/>
<span class="strong"><strong>Idle</strong></span> state. This categorization might be useful at the time of analyzing processes execution with the tools that are able to isolate threads in the <span class="strong"><strong>Idle</strong></span> state:</p><div class="mediaobject"><img src="../Images/image00396.jpeg" alt="The OS multitask execution model"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Context types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Context types</h2></div></div></div><p>In <a id="id10" class="indexterm"/>some languages, such as C#, we also <a id="id11" class="indexterm"/>find the concept of safe or secure context. In a way, this relates to the so-called thread safety.</p></div><div class="section" title="Thread safety"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Thread safety</h2></div></div></div><p>A <a id="id12" class="indexterm"/>piece of code is said to be thread-safe if it only<a id="id13" class="indexterm"/> manipulates shared data structures in a manner that guarantees safe execution by multiple threads at the same time. There are various strategies used in order to create thread-safe data structures, and the .NET framework is very careful about this concept and its implementations.</p><p>Actually, most of the MSDN (the official documentation) includes the indication <span class="emphasis"><em>this type is thread-safe</em></span> at the bottom for those to whom it is applicable (a vast majority).</p></div><div class="section" title="State"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>State</h2></div></div></div><p>The state <a id="id14" class="indexterm"/>of a computer program is a technical term for<a id="id15" class="indexterm"/> all the stored information, at a given instant in time, to which the program has access. The output of a computer program at any time is completely determined by its current inputs and its state. A very important variant of this concept is the program's state.</p></div><div class="section" title="Program state"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Program state</h2></div></div></div><p>This <a id="id16" class="indexterm"/>concept is especially important, and it <a id="id17" class="indexterm"/>has several meanings. We know that a computer program stores data in variables, which are just labeled storage locations in the computer's memory. The contents of these memory locations, at any given point in the program's execution, are called the program's state.</p><p>In object-oriented languages, it is said that a class defines its state through fields, and the values that these fields have at a given moment of execution determine the state of that object. Although it's not mandatory, it's considered a good practice in OOP programming when the methods of a class have the sole purpose of preserving the coherence and logic of its state and nothing else.</p><p>In addition, a common taxonomy of programming languages establishes two categories: imperative and declarative programming. C# or Java are examples of the former, and HTML is a typical declarative syntax (since it's not a language itself). Well, in declarative programming, sentences tend to change the state of the program while using the declarative paradigm, languages indicate only the desired result, with no specifications about how the engine will manage to obtain the results.</p></div><div class="section" title="Serialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Serialization</h2></div></div></div><p>Serialization<a id="id18" class="indexterm"/> is the process of translating data<a id="id19" class="indexterm"/> structures or the object state into a format that can be stored (for example, in a file or a memory buffer) or transmitted across a network connection and reconstructed later in the same or another computer environment.</p><p>So, we used to say that serializing an object means to convert its state into a byte stream in such a way that the byte stream can be converted back into a copy of the object. Popular text formats emerged years ago and are now well known and accepted, such as XML and JSON, independently of other previous formats (binary included):</p><div class="mediaobject"><img src="../Images/image00397.jpeg" alt="Serialization"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Process"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Process</h2></div></div></div><p>The<a id="id20" class="indexterm"/> OS fragments operations among several functional units. This is done by allocating different memory areas for each unit in execution. It's<a id="id21" class="indexterm"/> important to distinguish between processes and threads.</p><p>Each process is given a set of resources by the OS, which—in Windows—means that a process will have its own virtual address space allocated and managed accordingly. When Windows initializes a process, it is actually establishing a context of execution, which implies a process environment block, also known as PEB and a data structure. However, let's make this clear: the OS doesn't execute processes; it only establishes the execution context.</p></div><div class="section" title="Thread"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Thread</h2></div></div></div><p>A thread<a id="id22" class="indexterm"/> is the functional (or working) unit of a <a id="id23" class="indexterm"/>process. And that is what the OS executes. Thus, a single process might have several threads of execution, which is something that happens very often. Each thread has its own address space within the resources previously allocated by the creation of the process. These resources are shared by all threads linked to the process:</p><div class="mediaobject"><img src="../Images/image00398.jpeg" alt="Thread"/></div><p style="clear:both; height: 1em;"> </p><p>It's important <a id="id24" class="indexterm"/>to recall that a thread only belongs to a <a id="id25" class="indexterm"/>single process, thus having access to only the resources defined by that process. When using the tools that will be suggested now, we can look at multiple threads executing concurrently (which means that they start working in an independent manner) and share resources, such as memory and data.</p><p>Different processes do not share these resources. In particular, the threads of a process share its instructions (the executable code) and its context (the values of its variables at any given moment).</p><p>Programming languages such as .NET languages, Java, or Python expose threading to the developer while abstracting the platform-specific differences in threading implementations at runtime.</p><div class="note" title="Note"><h3 class="title"><a id="tip02"/>Tip</h3><p>Note that communication between threads is possible through the common set of resources initialized by the process creation.</p></div><p>Of course, there is much more written<a id="id26" class="indexterm"/> about these two concepts, which go far beyond the scope of this book (refer to Wikipedia, <a class="ulink" href="https://en.wikipedia.org/wiki/Thread_(computing)">https://en.wikipedia.org/wiki/Thread_(computing)</a>, for more details), but the system provides us with mechanisms to check the execution of any process and also check what the threads in execution are.</p><p>If you are curious about it or just need to check whether something is going wrong, there are two main tools that I recommend: the Task Manager (included in the operating system, which you'll probably know), and—even better—one of the tools designed by the distinguished engineer and technical fellow Mark Russinowitch, available for free and composed of a set of more than 50 utilities.</p><p>Some have a Windows interface and others are console utilities, but all of them are highly optimized and configurable to monitoring and controlling the inner aspects of our operating system at any moment. They<a id="id27" class="indexterm"/> are available for free at <a class="ulink" href="https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx">https://technet.microsoft.com/en-us/sysinternals/bb545021.aspx</a>.</p><p>If you don't<a id="id28" class="indexterm"/> want to install anything else, open <span class="strong"><strong>Task Manager</strong></span> (just right-click on the task bar to access it) and select the <span class="strong"><strong>Details</strong></span> tab. You will see a more detailed description of every process, the amount of CPU used by each process, the memory allocated for each process, and so on. You can even right-click on one of the processes and see how there is a context menu that offers a few possibilities, including launching a new dialog window that shows some properties related to it:</p><div class="mediaobject"><img src="../Images/image00399.jpeg" alt="Thread"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="SysInternals"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>SysInternals</h2></div></div></div><p>If you really want to <a id="id29" class="indexterm"/>know how a process<a id="id30" class="indexterm"/> behaves in its entirety, the tools to use are SysInternals. If you go to the link indicated earlier, you'll see an item menu especially dedicated to process utilities. There, you have several choices to work with, but the most comprehensive are <span class="strong"><strong>Process Explorer</strong></span> and <span class="strong"><strong>Process Monitor</strong></span>.</p><p>
<span class="strong"><strong>Process Explorer</strong></span> and <span class="strong"><strong>Process Monitor</strong></span> don't require installation (they're written in C++), so you can execute them directly from any device for a Windows platform.</p><p>For example, if you run <span class="strong"><strong>Process Explorer</strong></span>, you'll see a fully detailed window showing every single detail of all the processes currently active in the system.</p><p>With <span class="strong"><strong>Process Explorer</strong></span>, you <a id="id31" class="indexterm"/>can find <a id="id32" class="indexterm"/>out what files, registry keys, and other objects processes have opened, together with the DLLs they have loaded, who owns each process, and so on. Every thread is visible and the tool provides you with detailed information, available through a very intuitive user interface:</p><div class="mediaobject"><img src="../Images/image00400.jpeg" alt="SysInternals"/></div><p style="clear:both; height: 1em;"> </p><p>It's also very useful to check the system's general behavior at real time, since it creates graphics of activities of CPU usage, I/O, Memory, among others, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00401.jpeg" alt="SysInternals"/></div><p style="clear:both; height: 1em;"> </p><p>In a similar way, <span class="strong"><strong>Process Monitor</strong></span>, focuses on monitoring the filesystem, the Registry, and all processes and threads with their activities in real time, since it actually is a mixture of two previous<a id="id33" class="indexterm"/> utilities merged together: <span class="strong"><strong>FileMon</strong></span> (<span class="strong"><strong>File Monitor</strong></span>)<a id="id34" class="indexterm"/> and<a id="id35" class="indexterm"/> <span class="strong"><strong>RegMon</strong></span> (<span class="strong"><strong>Registry Monitor</strong></span>), which are not available anymore.</p><p>If you try out PM, you'll see some of the information included in PE, plus the specific information provided by PM—just conveyed in a different manner.</p></div><div class="section" title="Static versus dynamic memory"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Static versus dynamic memory</h2></div></div></div><p>When a program <a id="id36" class="indexterm"/>starts<a id="id37" class="indexterm"/> execution, the OS assigns a process <a id="id38" class="indexterm"/>to it by means of scheduling: the method by which work specified by some means is assigned to resources that complete the work. This means that the resources for the process are assigned, and that implies memory allocation.</p><p>As we'll see, there are mainly two types of memory allocation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Fixed memory (linked to the stack), determined at compile time. Local variables are declared and used in the stack. Note that it is a contiguous block of memory allocated when the process resources are initially assigned. The allocation mechanism is very fast (although the access not so much).</li><li class="listitem">The other is dynamic memory (the heap), which can grow as the program required it, and it's assigned at runtime. This is the place where instance variables are allocated (those that point to an instance of a class or object).</li></ul></div><p>Usually, the <a id="id39" class="indexterm"/>first type is calculated at compile time since the compiler knows how much memory will be needed to allocate the variables declared depending on its type (<code class="literal">int</code>, <code class="literal">double</code>, and so on). They are declared inside functions with a syntax such as <code class="literal">int x = 1;</code>
</p><p>The second type requires<a id="id40" class="indexterm"/> the <code class="literal">new</code> operator to be invoked. Let's <a id="id41" class="indexterm"/>say there is a class named <code class="literal">Book</code> in our code, we create an instance of such <code class="literal">Book</code> with an expression of this type:</p><div class="informalexample"><pre class="programlisting">Book myBook = new Book();</pre></div><p>This instructs the runtime to allocate enough space in the heap to hold an instance of that type along with its fields; the state of the class is allocated in the heap. This means that the whole state of a program will store its state in a different memory (and, optionally, disk) locations.</p><p>Of course, there are more aspects to account for, which we'll cover in the <span class="emphasis"><em>The Stack and the Heap</em></span> section in this chapter. Luckily, the IDE lets us watch and analyze all these aspects (and many more) at debug time, offering an extraordinary debugging experience.</p></div><div class="section" title="Garbage collector"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Garbage collector</h2></div></div></div><p>
<span class="strong"><strong>Garbage collection</strong></span> (<span class="strong"><strong>GC</strong></span>) is<a id="id42" class="indexterm"/> a form <a id="id43" class="indexterm"/>of automatic memory management. The GC in .NET, attempts to reclaim garbage or the memory occupied by objects that are no longer in use by the program. Going back to the previous code declaration of <code class="literal">Book</code>, when there are no references to the <code class="literal">Book</code> object in the stack, the GC will reclaim that space to the system, liberating memory (it's a bit more complex, in fact, and I'll get into further detail later in this chapter—when we talk about memory management—but let's put it that way for the moment).</p><p>It's important to note that garbage collectors are not something exclusive to the .NET platform. Actually, you can find it in all platforms and programs even if you're dealing with browsers. Current JavaScript engines, for instance, such as Chrome's V8, Microsoft's Chakra—and others—use a garbage collection mechanism as well.</p></div><div class="section" title="Concurrent computing"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Concurrent computing</h2></div></div></div><p>Concurrency or concurrent computing<a id="id44" class="indexterm"/> is a very <a id="id45" class="indexterm"/>common concept nowadays, and we'll discover it at several instances along this book. The official definition in Wikipedia (<a class="ulink" href="https://en.wikipedia.org/wiki/Concurrent_computing">https://en.wikipedia.org/wiki/Concurrent_computing</a>) says:</p><div class="blockquote"><blockquote class="blockquote"><p>"Concurrent computing <a id="id46" class="indexterm"/>is a form of computing in which several computations are executed during overlapping time periods—concurrently—instead of sequentially (one completing before the next starts). This is a property of a system—this may be an individual program, a computer, or a network—and there is a separate execution point or "thread of control" for each computation ("process"). A concurrent system is one where a computation can advance without waiting for all other computations to complete; where more than one computation can advance at the same time."</p></blockquote></div></div><div class="section" title="Parallel computing"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Parallel computing</h2></div></div></div><p>Parallel computing<a id="id47" class="indexterm"/> is a type of computation<a id="id48" class="indexterm"/> in which many calculations are carried out simultaneously, operating on the principle that large problems can often be divided into smaller ones, which are then solved at the same time. .NET offers several variants of this type of computing, which we'll cover over the next few chapters:</p><div class="mediaobject"><img src="../Images/image00402.jpeg" alt="Parallel computing"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="Imperative programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Imperative programming</h2></div></div></div><p>Imperative programming<a id="id49" class="indexterm"/> is a programming<a id="id50" class="indexterm"/> paradigm that describes computation in terms of the program's state. C#, JavaScript, Java, or C++ are typical examples of imperative languages.</p></div><div class="section" title="Declarative programming"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Declarative programming</h2></div></div></div><p>In contrast to imperative<a id="id51" class="indexterm"/> programming, languages <a id="id52" class="indexterm"/>considered declarative describe only the desired results without explicitly listing commands or steps that must be performed. Many markup languages, such as HTML, XAML, or XSLT, fall into this category.</p></div></div></div>
<div class="section" title="The evolution of .NET"><div class="titlepage" id="aid-F8902"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>The evolution of .NET</h1></div></div></div><p>Until the arrival of .NET, the <a id="id53" class="indexterm"/>Microsoft programming ecosystem had been ruled by a few <a id="id54" class="indexterm"/>classic languages, Visual Basic and C++ (with the Microsoft Foundation classes) being typical examples of this.</p><div class="note" title="Note"><h3 class="title"><a id="note02"/>Note</h3><p>Also known as <span class="strong"><strong>MFC</strong></span>, <span class="strong"><strong>Microsoft Foundation Classes</strong></span><a id="id55" class="indexterm"/> is a library that wraps portions of the Windows API in C++ classes, including functionalities that enable them to use a default application framework. Classes are defined for many of the handle-managed Windows objects and also for predefined windows and common controls. It was introduced in 1992 with Microsoft's C/C++ 7.0 compiler for use with 16-bit versions of Windows as an extremely thin object-oriented C++ wrapper for the Windows API.</p></div><p>However, the big changes proposed by .NET were started using a totally different component model approach. Up until 2002, when .NET officially appeared, such a component model was <a id="id56" class="indexterm"/>
<span class="strong"><strong>COM</strong></span> (<span class="strong"><strong>Component Object Model</strong></span>), introduced by the company in 1993. COM is the basis for several other Microsoft technologies and frameworks, including OLE, OLE automation, ActiveX, COM+, DCOM, the Windows shell, DirectX, <a id="id57" class="indexterm"/>
<span class="strong"><strong>UMDF</strong></span> (<span class="strong"><strong>User-Mode Driver Framework</strong></span>), and Windows runtime.</p><div class="note" title="Note"><h3 class="title"><a id="note03"/>Note</h3><p>A device-driver development platform (Windows Driver Development Kit) first introduced with Microsoft's Windows <a id="id58" class="indexterm"/>Vista operating system is also available for Windows XP. It facilitates the creation of drivers for certain classes of devices.</p></div><p>At the time of writing this, COM is a competitor with another specification named <span class="strong"><strong>CORBA</strong></span> (<span class="strong"><strong>Common Object Request Broker Architecture</strong></span>), a <a id="id59" class="indexterm"/>standard defined by the<a id="id60" class="indexterm"/> <span class="strong"><strong>Object Management Group</strong></span> (<span class="strong"><strong>OMG</strong></span>), designed to facilitate the communication of systems that are<a id="id61" class="indexterm"/> deployed on diverse platforms. CORBA enables collaboration between systems on different operating systems, programming languages, and computing hardware. In its life cycle, it has received a lot of criticism, mainly because of poor implementations of the standard.</p><div class="section" title=".NET as a reaction to the Java World"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>.NET as a reaction to the Java World</h2></div></div></div><p>In 1995, a new model <a id="id62" class="indexterm"/>was conceived to supersede COM and the unwanted effects related<a id="id63" class="indexterm"/> to it, especially versions and the use of the Windows Registry on which COM depends to define accessible interfaces or contracts; a corruption or modified fragment of the registry could indicate that a component was not accessible at runtime. Also, in order to install applications, elevated permissions were required, since the Windows Registry is a sensible part of the system.</p><p>A year later, various quarters of Microsoft started making contacts with some of the most distinguished software engineers, and these contacts remained active over the years. These included architects such as Anders Hejlsberg (who became the main author of C# and the principal architect of .NET framework), Jean Paoli (one of the signatures in the XML Standard and the former ideologist of AJAX technologies), Don Box (who participated in the creation of SOAP and XML Schemas), Stan Lippman (one of the fathers of C++, who was working at the time at Disney), Don Syme (the architect for generics and the principal author of the F# language), and so on.</p><p>The purpose of this project was to create a new execution platform, free from the caveats of COM and one that was able to hold a set of languages to execute in a secure and extensible manner. The new platform should be able to program and integrate the new world of web services, which had just appeared—based on XML—along with other technologies. The initial name of the new <a id="id64" class="indexterm"/>proposal was <span class="strong"><strong>Next Generation Windows Services</strong></span> (<span class="strong"><strong>NGWS</strong></span>).</p><p>By late 2000, the first betas of .NET framework were released, and the first version appeared on February 13, 2002. Since then, .NET has been always aligned with new versions of the IDE (Visual Studio). The current version of the classic .NET framework at the time of writing this is 4.6.1, but we will get into more detail on this later in the chapter.</p><p>An alternative .NET appeared in 2015 for the first time. In the <code class="literal">//BUILD/</code> event, Microsoft announced the creation and availability of another version of .NET, called .NET Core.</p><div class="section" title="The open source movement and .NET Core"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>The open source movement and .NET Core</h3></div></div></div><p>Part of an idea for the open<a id="id65" class="indexterm"/> source movement and .NET Core <a id="id66" class="indexterm"/>comes from a deep change in the way software creation and availability is conceived in Redmond nowadays. When Satya Nadella took over as the CEO at Microsoft, they clearly shifted to a new mantra: <span class="emphasis"><em>mobile-first, cloud-first</em></span>. They also redefined themselves as <span class="emphasis"><em>a company of software and services</em></span>.</p><p>This meant embracing the open source idea with all its consequences. As a result, a lot of the NET Framework has already been opened to the community, and this movement will continue until the whole platform is opened, some say. Besides, a second purpose (clearly stated several times at the <code class="literal">//BUILD/</code> event) was to create a programming ecosystem powerful enough to allow anyone to program any type of application for any platform or device. So, they started to support Mac OX and Linux as well as several tools to build applications for Android and iOS.</p><p>However, the implications run deeper. If you want to build applications for Mac OS and Linux, you need a different <span class="strong"><strong>Common Language Runtime</strong></span> (<span class="strong"><strong>CLR</strong></span>)<a id="id67" class="indexterm"/> that is able to execute in these platforms without losing out on performance. This is where .NET Core comes into play.</p><p>At the time writing this, Microsoft has published several (ambitious) improvements to the .NET ecosystem, mainly based on two different flavors of .NET:</p><div class="mediaobject"><img src="../Images/image00403.jpeg" alt="The open source movement and .NET Core"/></div><p style="clear:both; height: 1em;"> </p><p>The first one is the version that was last available—.NET (.NET framework 4.6.x)—and the second one is the new version, intended to allow compilations that are valid not only for Windows platforms, but also for Linux and Mac OSes.</p><p>NET Core<a id="id68" class="indexterm"/> is the generic name for a new open source version of the CLR made available in 2015 (updated last November to version 1.1) intended to support multiple flexible .NET implementations. In addition, the team is working on something called <a id="id69" class="indexterm"/>
<span class="strong"><strong>.NET Native</strong></span>, which compiles to native code in every destination platform.</p><p>However, let's keep on going with the main concepts behind the CLR, from a version-independent point of view.</p><div class="note" title="Note"><h3 class="title"><a id="note04"/>Note</h3><p>The whole project is available on GitHub at <a class="ulink" href="https://github.com/dotnet/coreclr">https://github.com/dotnet/coreclr</a>.</p></div></div></div><div class="section" title="Common Language Runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Common Language Runtime</h2></div></div></div><p>To address some of the<a id="id70" class="indexterm"/> problems of COM and introduce the bunch of new <a id="id71" class="indexterm"/>capabilities that were requested as part of the new platform, a team at Microsoft started to evolve prior ideas (and the names associated with the platform as well). So, the framework was soon renamed to <span class="strong"><strong>Component Object Runtime</strong></span> (<span class="strong"><strong>COR</strong></span>)<a id="id72" class="indexterm"/> prior to the first public beta, when it was finally given the name of Common Language Runtime in order to drive the fact that the new platform was not associated with a single language.</p><p>Actually, there are dozens of compilers available for use with the .NET framework, and all of them generate a type intermediate code, which—in turn—is converted into native code at execution time, as shown in the following figure:</p><div class="mediaobject"><img src="../Images/image00404.jpeg" alt="Common Language Runtime"/></div><p style="clear:both; height: 1em;"> </p><p>The CLR, as well as COM, focuses on contracts between components, and these contracts are based on types, but that's where the similarities end. Unlike COM, the CLR establishes a well-defined form to specify contracts, which is generally known as metadata.</p><p>Also, the CLR includes the possibility of reading metadata without any knowledge of the underlying file format. Furthermore, such metadata is extensible by means of custom attributes, which are strongly typed themselves. Other interesting information included in the metadata includes the <a id="id73" class="indexterm"/>version information (remember, there should be no dependencies of the Registry) and component dependencies.</p><p>Besides, for any component (called assembly), the presence of metadata is mandatory, which means that it's not possible to deploy the access of a component without reading its metadata. In the initial versions, implementations of security were mainly based on some evidence included in the metadata. Furthermore, such metadata is available for any other program inside or outside the CLR through a process called <span class="strong"><strong>Reflection</strong></span>.</p><p>Another important difference is that .NET contracts, above all, describe the logical structure of types. There are no in-memory representations, reading order sequences, alignment or parameter conventions, among other things, as Don Box explains in detail in his magnificent Essential .NET<a id="id74" class="indexterm"/> (<a class="ulink" href="http://www.amazon.com/Essential-NET-Volume-Language-Runtime/dp/0201734117">http://www.amazon.com/Essential-NET-Volume-Language-Runtime/dp/0201734117</a>).</p><div class="section" title="Common Intermediate Language"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Common Intermediate Language</h3></div></div></div><p>The way these previous conventions and protocols are resolved in CLR is by means of a technique called contract virtualization. This implies that most of the code (if not all) written for the CLR doesn't contain the <a id="id75" class="indexterm"/>machine code but an intermediate language called <span class="strong"><strong>Common Intermediate Language</strong></span> (<span class="strong"><strong>CIL</strong></span>), or just <span class="strong"><strong>Intermediate Language</strong></span> (<span class="strong"><strong>IL</strong></span>).</p><p>CLR never executes CIL directly. Instead, CIL is always translated into native machine code prior to its execution by means of a technique called <span class="strong"><strong>JIT</strong></span> (<span class="strong"><strong>Just-In-Time</strong></span>) compilation. This is to say that the JIT process always adapts the resulting executable code to the destination machine (independent from the developer). There are several modes of performing a JIT process, and we'll look at them in more detail later in this chapter.</p><p>Thus, CLR is what we might call a type-centered framework. For CLR, everything is a type, an object, or a value.</p></div><div class="section" title="Managed execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Managed execution</h3></div></div></div><p>Another critical factor in the <a id="id76" class="indexterm"/>behavior of CLR is the fact that programmers are encouraged to forget about the explicit management of memory and the manual management of threads (especially associated with languages such as C and C++) to adopt the new way of execution that the CLR proposes: managed execution.</p><p>Under managed execution, CLR has complete knowledge of everything that happens in its execution context. This includes every variable, method, type, event, and so on. This encourages and fosters productivity and eases the path to debugging in many ways.</p><div class="mediaobject"><img src="../Images/image00405.jpeg" alt="Managed execution"/></div><p style="clear:both; height: 1em;"> </p><p>Additionally, CLR <a id="id77" class="indexterm"/>supports the creation of runtime code (or generative programming) by means of a utility called CodeDOM. With this feature, you can emit code in different languages and compile it (and execute it) directly in the memory.</p><p>All this drives us to the next logical questions: which languages are available to be used with this infrastructure, which are the common points among them, how is the resulting code assembled and prepared for execution, what are the units of stored information (as I said, they're called assemblies), and finally, how is all this information organized and structured into one of these assemblies?</p></div><div class="section" title="Components and languages"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Components and languages</h3></div></div></div><p>Every execution <a id="id78" class="indexterm"/>environment has a notion of software<a id="id79" class="indexterm"/> components. For CLR, such components must be written in a CLI-compliant language and compiled accordingly. You can read a list of CLI languages on Wikipedia. But the question is what is a CLI-compliant language?</p><p>
<span class="strong"><strong>CLI</strong></span> stands for <a id="id80" class="indexterm"/>
<span class="strong"><strong>Common Language Infrastructure</strong></span>, and it's a software specification standardized by <span class="strong"><strong>ISO</strong></span><a id="id81" class="indexterm"/> and <span class="strong"><strong>ECMA</strong></span><a id="id82" class="indexterm"/> describing the executable code and a runtime environment that allows multiple high-level languages to be used on different computer platforms without being rewritten for specific architectures. The .NET framework and the free and open source Mono are implementations of CLI.</p><div class="note" title="Note"><h3 class="title"><a id="note05"/>Note</h3><p>Note<a id="id83" class="indexterm"/> that the official <a id="id84" class="indexterm"/>sites for these terms <a id="id85" class="indexterm"/>and entities<a id="id86" class="indexterm"/> are as follows:</p><p>
<span class="strong"><strong>ISO</strong></span>: <a class="ulink" href="http://www.iso.org/iso/home.html">http://www.iso.org/iso/home.html</a>
</p><p>
<span class="strong"><strong>ECMA</strong></span>: <a class="ulink" href="http://www.ecma-international.org/">http://www.ecma-international.org/</a>
</p><p>
<span class="strong"><strong>MONO</strong></span>: <a class="ulink" href="http://www.mono-project.com/">http://www.mono-project.com/</a>
</p><p>
<span class="strong"><strong>CLI languages</strong></span>: <a class="ulink" href="https://en.wikipedia.org/wiki/List_of_CLI_languages">https://en.wikipedia.org/wiki/List_of_CLI_languages</a>
</p></div><p>The most relevant points in the <a id="id87" class="indexterm"/>CLI would be as follows (according to Wikipedia):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">First, to substitute COM, metadata is key and provides information on the architecture of assemblies, such as a menu or an index of what you can find inside. Since it doesn't depend on the language, any program can read this information.</li><li class="listitem">That established, there should be a common set of rules to comply in terms of data types and operations. This is the <a id="id88" class="indexterm"/><span class="strong"><strong>Common Type System</strong></span> (<span class="strong"><strong>CTS</strong></span>). All languages that adhere to CTS can work with a set of rules.</li><li class="listitem">For minimal interoperation between languages, there is another set of rules, and this should be common to all programming languages in this group, so a DLL made with one language and then compiled can be used by another DLL compiled in a different CTS language, for example.</li><li class="listitem">Finally, we have a Virtual Execution System, which is responsible for running this application and many other tasks, such as managing the memory requested by the program, organizing execution blocks, and so on.</li></ul></div><p>With all this in mind, when we use a .NET compiler (from now on, compiler), we generate a byte stream, usually stored as a file in the local filesystem or on a web server.</p></div><div class="section" title="Structure of an assembly file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Structure of an assembly file</h3></div></div></div><p>Files generated by a<a id="id89" class="indexterm"/> compilation process are called <a id="id90" class="indexterm"/>assemblies, and any assembly follows the basic rules of any other executable file in Windows and adds a few extensions and information suitable and mandatory for the execution in a managed environment.</p><p>In short, we understand that an assembly is just a set of modules containing the IL code and metadata, which serve as the primary unit of a software component in CLI. Security, versioning, type resolution, processes (application domains), and so on, all work on a per-assembly basis.</p><p>The significance of this implies changes in the structure of executable files. This leads to a new file architecture represented in the following figure:</p><div class="mediaobject"><img src="../Images/image00406.jpeg" alt="Structure of an assembly file"/></div><p style="clear:both; height: 1em;"> </p><p>Note that a PE file is one that conforms to the Portable/Executable format: a file format for executables, object code, DLLs, FON (Font) files, and others used in 32-bit and 64-bit versions of Windows operating systems. It was first introduced by Microsoft in Windows NT 3.1, and all later versions of Windows support this file structure.</p><p>This is why we find a PE/COFF header in the format, which contains compatible information required by the system. However, from the point of view of a .NET programmer, what really matters is that an assembly holds three main areas: the CLR header, the IL code, and a <a id="id91" class="indexterm"/>section with resources (<span class="strong"><strong>Native Image Section</strong></span> in the figure).</p><div class="note" title="Note"><h3 class="title"><a id="tip03"/>Tip</h3><p>A detailed description of the PE format<a id="id92" class="indexterm"/> is available at <a class="ulink" href="http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx">http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx</a>.</p></div><div class="section" title="Program execution"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec01"/>Program execution</h4></div></div></div><p>Among the libraries linked with <a id="id93" class="indexterm"/>CLR, we found a few responsible for loading assemblies in the memory and starting and initializing the execution context. They're generally referenced as CLR Loader. Together with some other utilities, they provide the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Automatic memory management</li><li class="listitem">Use of garbage collector</li><li class="listitem">Metadata access to find information on types</li><li class="listitem">Loading modules</li><li class="listitem">Analyzing managed libraries and programs</li><li class="listitem">A robust exception management subsystem to enable programs to communicate and respond to failures in structured ways</li><li class="listitem">Native and legacy code interoperability</li><li class="listitem">A JIT compilation of managed code into native code</li><li class="listitem">A sophisticated security infrastructure</li></ul></div><p>This loader uses OS services to facilitate the loading, compilation, and execution of an assembly. As we've mentioned previously, CLR serves as an execution abstraction for .NET languages. To achieve this, it uses a set of DLLs, which acts as a middle layer between the OS and the application program. Remember that CLR itself is a collection of DLLs, and these DLLs work together to define the virtual execution environment. The most relevant ones are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">mscoree.dll</code> (sometimes called shim because it is simply a facade in front of the actual DLLs <a id="id94" class="indexterm"/>that the<a id="id95" class="indexterm"/> CLR comprises)</li><li class="listitem"><code class="literal">clr.dll</code></li><li class="listitem"><code class="literal">mscorsvr.dll</code> (multiprocessor) or <code class="literal">mscorwks.dll</code> (uniprocessor)</li></ul></div><p>In practice, one <a id="id96" class="indexterm"/>of the main roles of <code class="literal">mscoree.dll</code> is to select the appropriate<a id="id97" class="indexterm"/> build (uniprocessor or multiprocessor) based on any number of factors, including (but not limited to) the underlying hardware.</p><p>The <code class="literal">clr.dll</code> is the real <a id="id98" class="indexterm"/>manager, and the rest are utilities for different purposes. This library is the only one of the CLRs that is located at <code class="literal">$System.Root$</code>, as we can find through a simple search:</p><div class="mediaobject"><img src="../Images/image00407.jpeg" alt="Program execution"/></div><p style="clear:both; height: 1em;"> </p><p>My system is showing two<a id="id99" class="indexterm"/> versions (there are some more), each one ready to launch programs compiled for 32-bit or 64-bit versions. The rest of the DLLs are located at another place: a secure set of directories generally called <a id="id100" class="indexterm"/>
<span class="strong"><strong>Global Assembly Cache</strong></span> (<span class="strong"><strong>GAC</strong></span>).</p><p>Actually, the latest edition of Windows 10 installs files for all versions of such GAC, corresponding to versions 1.0, 1.1, 2.0, 3.0, 3.5, and 4.0, although several are just placeholders with minimum information, and we only find complete versions of .NET 2.0, .NET 3.5 (only partially), and .NET 4.0.</p><p>Also, note that these placeholders (for the versions not fully installed) admit further installations if some old software requires them to. This is to say that the execution of a .NET program relies on the version indicated in its metadata and nothing else.</p><p>You can check which versions of .NET are installed in a system using the <code class="literal">CLRver.exe</code> utility, as shown in the following figure:</p><div class="mediaobject"><img src="../Images/image00408.jpeg" alt="Program execution"/></div><p style="clear:both; height: 1em;"> </p><p>Internally, several operations take place before execution. When we launch a .NET program, we'll proceed just as usual, as if it were just another standard executable of Windows.</p><p>Behind the scenes, the <a id="id101" class="indexterm"/>system will read the header in which it will be instructed to launch <code class="literal">mscore.dll</code>, which—in turn—will start the whole running process in a managed environment. Here, we'll omit all the intricacies inherent to this process since it goes far beyond the scope of this book.</p></div></div></div><div class="section" title="Metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Metadata</h2></div></div></div><p>We've mentioned that the key aspect of the new programming model is the heavy reliance on <a id="id102" class="indexterm"/>metadata. Furthermore, the ability to reflect against metadata enables programming<a id="id103" class="indexterm"/> techniques in which programs are generated by other programs, not humans, and this is where CodeDOM comes into play.</p><p>We'll cover some aspects of CodeDOM and its usages when dealing with the language, and we'll look at how the IDE itself uses this feature frequently every time it creates source code from a template.</p><p>In order to help the CLR find the various pieces of an assembly, every assembly has exactly one module whose metadata contains the assembly manifest: an additional piece of CLR metadata that acts as a directory of adjunct files that contain additional type definitions and code. Furthermore, CLR can directly load modules that contain an assembly manifest.</p><p>So, what is the aspect of a manifest in a real program and how can we examine its content? Fortunately, we have a bunch of .NET utilities (which, technically, don't belong to CLR but to the .NET framework ecosystem) that allow us to visualize this information easily.</p><div class="section" title="Introducing metadata with a basic Hello World"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Introducing metadata with a basic Hello World</h3></div></div></div><p>Let's build a typical <a id="id104" class="indexterm"/>Hello World program and analyze its contents once it is compiled so that we can inspect how it's converted into <span class="strong"><strong>Intermediate Language</strong></span> (<span class="strong"><strong>IL</strong></span>)<a id="id105" class="indexterm"/> and where the meta-information that we're talking about is.</p><p>Along the course of this book, I'll use Visual Studio 2015 Community Edition Update 1 (or higher if an updated version appears) for reasons that I'll explain later. You can install it for free; it's a fully capable version with tons of project types, utilities, and so on.</p><div class="note" title="Note"><h3 class="title"><a id="note06"/>Note</h3><p>Visual Studio 2015 CE update 1<a id="id106" class="indexterm"/> is available at <a class="ulink" href="https://www.visualstudio.com/vs/community/">https://www.visualstudio.com/vs/community/</a>.</p></div><p>The only requirement is to register for free in order to get a developer's license that Microsoft uses for statistical purposes—that's all.</p><p>After launching Visual Studio, in the main menu, select <span class="strong"><strong>New Project</strong></span> and go to the <span class="strong"><strong>Visual C#</strong></span> templates, where the IDE offers several project types, and select a console application, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00409.jpeg" alt="Introducing metadata with a basic Hello World"/></div><p style="clear:both; height: 1em;"> </p><p>Visual Studio will create a basic code structure composed of several references to libraries (more about that later) as well as a namespace block that includes the <code class="literal">program</code> class. Inside that class, we will find an application entry point in a fashion similar to what we would find in C++ or Java languages.</p><p>To produce some kind of output, we're going to use two static methods of the <code class="literal">Console</code> class: <code class="literal">WriteLine</code>, which outputs a string adding a carriage return, and <code class="literal">ReadLine</code>, which forces the program to stop until the user introduces a character and presses the return key so that we can see the output that is produced.</p><p>After cleaning these references<a id="id107" class="indexterm"/> that we're not going to use, and including the couple of sentences mentioned previously, the code will look like this:</p><div class="informalexample"><pre class="programlisting">using System;
namespace ConsoleApplication1
{
  class Program
  {
    static void Main(string[] args)
    {
      Console.WriteLine("Hello! I'm executing in the CLR context.");
      Console.ReadLine();
    }
  }
}</pre></div><p>To test it, we just have to press <span class="emphasis"><em>F5</em></span> or the <span class="strong"><strong>Start</strong></span> button and we'll see the corresponding output (nothing amazing, so we're not including the capture).</p><p>At the time of editing the code, you will have noticed several useful characteristics of the IDE's editor: the colorizing of sentences (distinguishing the different purposes: classes, methods, arguments, literals, and so on); <span class="strong"><strong>IntelliSense</strong></span>, which offers what makes sense to write for every class' member; <span class="strong"><strong>Tooltips</strong></span>, indicating every return type for methods; the value type for literals or constants; and the number of references made to every member of the program that could be found in your code.</p><p>Technically, there are hundreds of other useful features, but that's something we will have the chance to test starting from the next chapter, when we get into the C# aspects and discover how to prove them.</p><p>As for this little program, it's a bit more interesting to check what produced such output, which we'll find in the <code class="literal">Bin/Debug</code> folder of our project. (Remember to press the <span class="strong"><strong>Show all files</strong></span> button at the head of Solution Explorer, by the way):</p><div class="mediaobject"><img src="../Images/image00410.jpeg" alt="Introducing metadata with a basic Hello World"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, two<a id="id108" class="indexterm"/> executables are generated. The first one is the standalone executable that you can launch directly from its folder. The other, with the <code class="literal">.vshost</code> prefix before the extension, is the one Visual Studio uses at debug time and that contains some extra information required by the IDE. Both produce the same results.</p><p>Once we have an executable, it is time to link the .NET tool – that will let us view the metadata that we're talking about – to Visual Studio.</p><p>To do this, we go to the <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>External Tools</strong></span> option in the main menu, and we'll see a configuration dialog window, presenting several (and already tuned) external tools available; press the <span class="strong"><strong>New</strong></span> button and change the title to <code class="literal">IL Disassembler</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00411.jpeg" alt="Introducing metadata with a basic Hello World"/></div><p style="clear:both; height: 1em;"> </p><p>Next, we need to configure the arguments that we're going to pass to the new entry: the name of the tool and the required parameters.</p><p>You'll notice that there are <a id="id109" class="indexterm"/>several versions of this tool. These depend on your machine.</p><p>For our purposes, it will suffice to include the following information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The root of the tool (named <code class="literal">ILDASM.exe</code>, and located in my machine at <code class="literal">C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools</code>)</li><li class="listitem">The path of the executable generated, for which I'm using a predefined macro expressed by <code class="literal">$targetpath</code></li></ul></div><p>Given that our program is already compiled, we can go back to the <span class="strong"><strong>Tools</strong></span> menu and find a new entry for <code class="literal">IL Disassembler</code>. Once launched, a window will appear, showing the IL code of our program, plus a reference called <code class="literal">Manifest</code> (which shows the metadata), and we can also double-click to show another window with this information, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00412.jpeg" alt="Introducing metadata with a basic Hello World"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note07"/>Note</h3><p>Note that I've modified ILDASM's font size for clarity.</p></div><p>The information included in <a id="id110" class="indexterm"/>the manifest comes from two sources: the IDE itself, configured to prepare the assembly for execution (we can view most of the lines if we take a more detailed look at the window's content), and customizable information that we can embed in the executable's manifest, such as descriptions, the assembly title, the company information, trademark, culture, and so on. We'll explore how to configure that information in the next chapter.</p><p>In the same manner, we can keep on analyzing the contents of every single node shown in the main ILDASM window. For instance, if we want to see the IL code linked to our <code class="literal">Main</code> entry point, the tool will show us another window where we can appreciate the aspect of the IL code (note the presence of the text <code class="literal">cil</code> managed next to the declaration of main):</p><div class="mediaobject"><img src="../Images/image00413.jpeg" alt="Introducing metadata with a basic Hello World"/></div><p style="clear:both; height: 1em;"> </p><p>As I pointed out in the screenshot, entries with the prefix <code class="literal">IL_</code> will be converted to the machine code at execution time. Note the resemblance of these instructions with the Assembly language.</p><p>Also, keep in mind that this<a id="id111" class="indexterm"/> concept has not changed since the first version of .NET: main concepts and procedures to generate CIL and machine code are, basically, the same as they used to be.</p></div><div class="section" title="PreJIT, JIT, EconoJIT, and RyuJIT"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>PreJIT, JIT, EconoJIT, and RyuJIT</h3></div></div></div><p>I have already mentioned that the process of converting this IL code into machine code is undertaken by another piece of the .NET framework, generically known as <a id="id112" class="indexterm"/>
<span class="strong"><strong>Just-In-Time Compiler</strong></span> (<span class="strong"><strong>JIT</strong></span>). However, since the very beginning of .NET, this process can be executed in at least three different ways, which is why there are three JIT-suffixed names.</p><p>To simplify the details of these processes, we'll say that the default method of compilation (and the preferred one in general terms) is the JIT compilation (let's call it Normal JIT):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">In the <a id="id113" class="indexterm"/>Normal JIT mode, the code is compiled as required (on demand) and not thrown away but cached for a later use. In this fashion, as the application keeps on running, any code required for execution at a later time that is already compiled is just retrieved from the cached area. The process is highly optimized and the performance penalty is negligible.</li><li class="listitem">In the <a id="id114" class="indexterm"/>PreJIT mode, .NET operates in a different manner. To operate using PreJIT, you need a utility called <code class="literal">ngen.exe</code> (which stands for native generation) to produce native machine code previous to the first execution. The code is then converted and <code class="literal">.exe</code> is rewritten into the machine code, which gives some optimization, especially at start time.</li><li class="listitem">As for the <a id="id115" class="indexterm"/>EconoJIT mode, it's used mainly in applications deployed for low-memory devices, such as mobiles, and it's pretty similar to NormalJIT with the difference that the compiled code is not cached in order to save memory.</li></ul></div><p>In 2015, Microsoft continued to develop a special project called<a id="id116" class="indexterm"/> Roslyn, which is a set of tools and services to provide extra functionalities to the process of code management, compilation, and deployment, among others. In connection with this project (which will be treated in depth in <a class="link" title="Chapter 4. Comparing Approaches for Programming" href="part0028.xhtml#aid-QMFO2">Chapter 4</a>, <span class="emphasis"><em>Comparing Approaches for Programming</em></span>), another JIT appeared, called<a id="id117" class="indexterm"/> RyuJIT, which has been made available since the beginning as an open source project and is now included in the latest version of V. Studio by default (remember, V. Studio 2015 Update 1).</p><p>Now, let me quote what the .NET team says about their new compiler:</p><div class="blockquote"><blockquote class="blockquote"><p>"RyuJIT<a id="id118" class="indexterm"/> is a new, next-generation x64 compiler twice as fast as the one before, meaning apps compiled with RyuJIT start up to 30% faster (Time spent in the JIT compiler is only one component of startup time, so the app doesn't start twice as fast just because the JIT is twice as fast.) Moreover, the new JIT still produces great code that runs efficiently throughout the long run of a server process.</p><p>This graph compares the compile time ("throughput") ratio of JIT64 to RyuJIT on a variety of code samples. Each line shows the multiple of how much faster RyuJIT is than JIT64, so higher numbers are better."</p></blockquote></div><div class="mediaobject"><img src="../Images/image00414.jpeg" alt="PreJIT, JIT, EconoJIT, and RyuJIT"/></div><p style="clear:both; height: 1em;"> </p><p>They finish by saying that RyuJIT will be the basis for all their JIT compilers in the future: x86, ARM, MDIL, and whatever else comes along.</p></div><div class="section" title="Common Type System"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>Common Type System</h3></div></div></div><p>In the .NET framework, the <span class="strong"><strong>Common Type System</strong></span> (<span class="strong"><strong>CTS</strong></span>)<a id="id119" class="indexterm"/> is the set of rules and specifications established to define, use, and manage the data types used by any .NET application in a language-independent manner.</p><p>We must understand that types are the building blocks of any CLR program. Programming languages such as C#, F#, and VB.NET have several constructs for expressing types (for example, <code class="literal">classes</code>, <code class="literal">structs</code>, <code class="literal">enums</code>, and so on), but ultimately, all of these constructs map down to a CLR type definition.</p><p>Also, note that a type can declare private and non-private members. The latter form, sometimes known as the contract of the type (since it exposes the usable part of that type), is what we can access by programming techniques. This is the reason why we highlighted the importance of metadata in the CLR.</p><p>The common type system is much broader than what most programming languages can handle. In addition to the CTS, a subdivision named CLI selects a subset of the CTS that all languages compatible with CLI must endure. This subset is called<a id="id120" class="indexterm"/> <span class="strong"><strong>Common Language Specification</strong></span> (<span class="strong"><strong>CLS</strong></span>), and component writers are recommended to make their components' functionalities accessible through CLS-compatible types and members.</p><div class="section" title="Naming conventions, rules, and type access modes"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec02"/>Naming conventions, rules, and type access modes</h4></div></div></div><p>As for the naming <a id="id121" class="indexterm"/>rules for a type, this is what applies: any CLR type name has three parts: the assembly name, an optional namespace prefix, and a local name. In the previous <a id="id122" class="indexterm"/>example, <code class="literal">ConsoleApplication1</code> was the assembly name, and it was the same as the namespace (but we could have changed it without problems). Program was the name of the only type available, which happened to be a class in this case. So, the whole name of this class was <code class="literal">ConsoleApplication1.ConsoleApplication1.Program</code>.</p><p>Namespaces<a id="id123" class="indexterm"/> are optional<a id="id124" class="indexterm"/> prefixes that help us define logical divisions in our code. Their purpose is to avoid confusion and the eventual overriding of members as well as allowing a more organized distribution of the application's code.</p><p>For example, in a typical application (not the demo shown earlier), a namespace would describe the whole solution, which might be separated into domains (different areas in which the application is divided, and they sometimes correspond to individual projects in the solution), and every domain would most likely contain several classes, and each class would contain several members. When you're dealing with solutions that hold, for instance, 50 projects, such logical divisions are very helpful in order to keep things under control.</p><p>As for the way that a member of a type can be accessed, each member manages how it can be used as well as how the type works. So, each member has its own access modifier (for example, <code class="literal">private</code>, <code class="literal">public</code>, or <code class="literal">protected</code>) that controls how it should be reached and whether that member is visible to other members. If we don't specify any access modifier, it is assumed that it is <code class="literal">private</code>.</p><p>Besides, you can establish whether an instance of the type is required to reference a member, or you can just reference such a member by its whole name without having to call the constructor and get an instance of the type. In such cases, we prefix the declaration of these members with the <code class="literal">static</code> keyword.</p></div><div class="section" title="Members of a type"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec03"/>Members of a type</h4></div></div></div><p>Basically, a type admits three kinds of <a id="id125" class="indexterm"/>members: fields, methods, and nested types. By nested type, we understand just another type that is included as part of the implementation of the declaring type. All other type members (for example, properties and events) are simply methods that have been extended with additional metadata.</p><p>I know, you might be thinking, <span class="emphasis"><em>so, properties are methods?</em></span> Well, yes; once compiled, the resulting code turns into methods. They convert into <code class="literal">name_of_class.set_method(value)</code> and <code class="literal">name_of_class.get_method()</code> methods in charge of assigning or reading the values linked to the method's name.</p><p>Let's review this with a very simple class that defines a couple of methods:</p><div class="informalexample"><pre class="programlisting">class SimpleClass
{
  public string data { get; set; }
  public int num { get; set; }
}</pre></div><p>Well, once compiled, we can check out the resulting IL code using IL dissasembler as we did earlier, obtaining the following view:</p><div class="mediaobject"><img src="../Images/image00415.jpeg" alt="Members of a type"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see, the compiler declares <code class="literal">data</code> and <code class="literal">num</code> as instances of the <code class="literal">string</code> and <code class="literal">int</code> classes, respectively, and it defines the corresponding methods to access these properties.</p><p>How does the CLR <a id="id126" class="indexterm"/>manage the memory space occupied by a type at runtime? If you remember, we highlighted the importance of the concept of state at the beginning of this chapter. The significance is clear here: the kind of members defined in the type will determine the memory allocation required.</p><p>Also, the CLR will guarantee that these members are initialized to their default values in case we indicate it in the declaring sentences: for numeric types, the default value is zero; for Boolean types, it's <code class="literal">false</code>, and for object references, the value is <code class="literal">null</code>.</p><p>We can also categorize types depending on their memory allocation: value types are stored in the stack, while reference types will use the heap. A deeper explanation of this will be provided in the next chapter, since the new abilities of Visual Studio 2015 allow us to analyze everything that happens at runtime in great detail with our code under a bunch of different points of view.</p></div></div><div class="section" title="A quick tip on the execution and memory analysis of an assembly in Visual Studio 2015"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec09"/>A quick tip on the execution and memory analysis of an assembly in Visual Studio 2015</h3></div></div></div><p>All the concepts <a id="id127" class="indexterm"/>reviewed up until here are directly available using the new debugging tools, as shown in the following screenshot, which displays the execution threads of the previous program stopped in a breakpoint:</p><div class="mediaobject"><img src="../Images/image00416.jpeg" alt="A quick tip on the execution and memory analysis of an assembly in Visual Studio 2015"/></div><p style="clear:both; height: 1em;"> </p><p>Note the different icons and columns of the information provided by the tool. We can distinguish known and unknown threads, if they are named (or not), their location, and even <code class="literal">ThreadID</code>, which we can use in conjunction with SysInternals tools if we need some extra information that's not included here:</p><div class="mediaobject"><img src="../Images/image00417.jpeg" alt="A quick tip on the execution and memory analysis of an assembly in Visual Studio 2015"/></div><p style="clear:both; height: 1em;"> </p><p>The same features <a id="id128" class="indexterm"/>are available for memory analysis. It even goes beyond the runtime periods, since the IDE is able to capture and categorize the usage of the memory required by the runtime in the application execution and keep it ready for us if we take a snapshot of the managed memory.</p><p>In this way, we can review it further and check out the possible bottlenecks and memory leaks. The preceding screenshot shows the managed memory used by the previous application at runtime.</p><p>A review of the capabilities of debugging found in Visual Studio 2015 will be covered in depth along the different chapters in this book, since there are many different scenarios in which an aid like this will be helpful and clear.</p></div><div class="section" title="The stack and the heap"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec10"/>The stack and the heap</h3></div></div></div><p>A quick reminder of these<a id="id129" class="indexterm"/> two concepts might be helpful since it transcends the .NET framework, and it's something that's common to many languages and platforms.</p><p>To start with, let's remember a few <a id="id130" class="indexterm"/>concepts related to processes that we saw at the beginning of this chapter: when a program starts execution, it initializes resources based on the metadata that the CLR reads from the assembly's manifest (as shown in the figure given in the <span class="emphasis"><em>The structure of an assembly file</em></span> section). These resources will be shared with all the threads that such a process launches.</p><p>When we declare a variable, a space in the stack in allocated. So, let's start with the following code:</p><div class="informalexample"><pre class="programlisting">class Program
{
  static void Main(string[] args)
  {
    Book b;
    b.Title = "The C# Programming Language";
    Console.WriteLine(b.Title);
    Console.ReadLine();
  }
}

class Book
{
  public string Title;
  public int Pages;
}</pre></div><p>If we try to compile this, we'll obtain a compilation error message indicating the use of non-assigned variable <code class="literal">b</code>. The reason is that in memory, we just have a declared variable and it's assigned to null, since we didn't instantiate <code class="literal">b</code>.</p><p>However, if we use the constructor of the class (the default one, since the class has no explicit constructor), changing the line to <code class="literal">Book b = new Book();</code>, then our code compiles and executes properly.</p><p>Therefore, the role of the <code class="literal">new</code> operator is crucial here. It indicates to the compiler that it has to allocate space for a new instance of the <code class="literal">Book</code> object, call the constructor, and—as we'll discover soon—initialize the object's fields to their default value types.</p><p>So, what's in the stack memory at the moment? Well, we just have a declaration called <code class="literal">b</code>, whose value is a memory address: exactly the address where <code class="literal">StackAndHeap.Book</code> is declared in the Heap (which I anticipate will be <code class="literal">0x2525910</code>).</p><p>However, how in the world will I know this address and what's going on inside the execution context? Let's take a look at the inner workings of this small application as Visual Studio offers different debugging windows available in this version of the IDE. To do this, we'll mark a breakpoint in line 14, <code class="literal">Console.ReadLine();</code>, and relaunch the application so that it hits the<a id="id131" class="indexterm"/> breakpoint.</p><p>Once here, there's plenty of information available. In the <span class="strong"><strong>Diagnostics Tools</strong></span> window (also new in this version of the IDE), we can watch the memory in use, the events, and the CPU usage. In the <span class="strong"><strong>Memory Usage</strong></span> tab, we can take a snapshot of what's going on (actually, we can take several snapshots at different moments of execution and compare them).</p><p>Once the snapshot<a id="id132" class="indexterm"/> is ready, we'll look at the time elapsed, the size of objects, and the Heap size (along with some other options to improve the experience):</p><div class="mediaobject"><img src="../Images/image00418.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>Note that we can choose to view the Heap sorted by the object size or the heap size. Also, if we choose one of these, a new window appears, showing every component actually in the execution context.</p><p>If we want to check exactly what our code is doing, we can filter by the name of the desired class (<code class="literal">Book</code>, in this case) in order to get an exclusive look at this object, its instances, the references to the object alive in the moment of execution, and a bunch of other details.</p><p>Of course, if we take a look at the <span class="strong"><strong>Autos</strong></span> or <span class="strong"><strong>Locals</strong></span> windows, we'll discover the actual values of these members as well:</p><div class="mediaobject"><img src="../Images/image00419.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>As we can see in the <a id="id133" class="indexterm"/>
<span class="strong"><strong>Autos</strong></span> window, the object has initialized the remaining values (those not established by code) using the default value for that type (0 for integer values). This level of detail in the analysis of executables really helps in cases where bugs are fuzzy or only happen occasionally.</p><p>We can even see the actual memory location of every member by clicking on the <span class="strong"><strong>StackAndHeap.Book</strong></span> entry:</p><div class="mediaobject"><img src="../Images/image00420.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>Perhaps you're wondering, can we even see further? (I mean the actual assembly code produced by the execution context). The answer, again, is yes; we can right-click on the instance, select <span class="strong"><strong>Add Watch</strong></span>, and we'll be adding an inspection point directly to that memory position, as shown in the following figure:</p><div class="mediaobject"><img src="../Images/image00421.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, the assembly code is available <a id="id134" class="indexterm"/>as well, as long as we have enabled it by navigating to <span class="strong"><strong>Tools</strong></span> | <span class="strong"><strong>Options</strong></span> | <span class="strong"><strong>Debugger</strong></span> in the IDE. Also, in this case, you should enable <span class="strong"><strong>Enable Address Level Debugging</strong></span> in the same dialog box. After this, just go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span> | <span class="strong"><strong>Dissasembly</strong></span>, and you will be shown the window with the lowest level (executable) code marking the breakpoint, line numbers, and the translation of such code into the original C# statement:</p><div class="mediaobject"><img src="../Images/image00422.jpeg" alt="The stack and the heap"/></div><p style="clear:both; height: 1em;"> </p><p>What happens when the reference to the <code class="literal">Book</code> object is reassigned or nulled (and the program keeps going on)? The memory allocated for <code class="literal">Book</code> remains in the memory as an orphan, and it's then when garbage collector comes into play.</p></div><div class="section" title="Garbage collection"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Garbage collection</h3></div></div></div><p>Basically, garbage collection<a id="id135" class="indexterm"/> is the process of reclaiming memory from the system. Of course, this memory shouldn't be in use; that is, the space occupied by the objects allocated in Heap should not have any variable pointing to them in order to be cleared.</p><p>Among the numerous classes included in .NET framework, there's one that's specially dedicated to this process. This means that the garbage collection of objects is not just an automatic process undertaken by CLR but a true, executable object that can even be used in our code (GC is the name, by the way, and we will deal with it in some cases when we try to optimize execution in the other chapters).</p><p>Actually, we can see this in action in a number of ways. For example, let's say that we create a method that concatenates strings in a loop and doesn't do anything else with them; it just notifies the user when the process is finished:</p><div class="informalexample"><pre class="programlisting">static void GenerateStrings()
{
  string initialString = "Initial Data-";
  for (int i = 0; i &lt; 5000; i++)
  {
    initialString += "-More data-";
  }
  Console.WriteLine("Strings generated");
}</pre></div><p>There's something to remember here. Since strings are immutable (which means that they cannot be changed, of course), the process has to create new strings in every loop. This means a lot of memory that the process will use and that can be reclaimed since every new string has to be created anew, and the previous one is useless.</p><p>We can<a id="id136" class="indexterm"/> use CLR Profiler to see what happens in CLR when running this application. You can download CLR Profiler<a id="id137" class="indexterm"/> from <a class="ulink" href="http://clrprofiler.codeplex.com/">http://clrprofiler.codeplex.com/</a>, and once unzipped, you'll see two versions (32 and 64 bits) of the tool. This tool show us a more detailed set of statistics, which include GC interventions. Once launched, you'll see a window like this:</p><div class="mediaobject"><img src="../Images/image00423.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><p>Ensure that you check the allocations and calls checkboxes before launching the application using <span class="strong"><strong>Start Desktop App</strong></span>. After launching (if the application has no stops and is running at a stretch), without breaks, you'll be shown a new statistical window pointing to various summaries of execution.</p><p>Each of these summaries lead to a different window in which you can analyze (even with statistical graphics) what happened at runtime in more detail as well as how garbage collector intervened when required.</p><p>The following figure shows the main statistical window (note the two sections dedicated to GC statistics and <a id="id138" class="indexterm"/>garbage collection handle statistics:</p><div class="mediaobject"><img src="../Images/image00424.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><p>The screenshot shows two GC-related areas. The first one indicates three kinds of collections, named <code class="literal">Gen 0</code>, <code class="literal">Gen 1</code>, and <code class="literal">Gen 2</code>. These names are simply short names for generations.</p><p>This is because GC marks objects depending on their references. Initially, when the GC starts working, these objects with no references are cleaned up. Those still connected are marked as <code class="literal">Gen 1</code>. The second review of the GC is initially similar, but if it discovers that there are objects marked <code class="literal">Gen 1</code> that still hold references, they're marked as <code class="literal">Gen 2</code>, and those from <code class="literal">Gen 0</code> with any references are promoted to <code class="literal">Gen 1</code>. The process goes on while the application is under execution.</p><p>This is the reason we can often read that the following principles apply to objects that are subject to recollection:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Newest objects are usually collected soon (they're normally created in a function call and are out of the scope when the function finishes)</li><li class="listitem">The oldest objects commonly last more (often because they hold references from global or static classes)</li></ul></div><p>The second area shows the number of handles created, destroyed, and surviving (surviving due to garbage collector, of course).</p><p>The first one (<span class="strong"><strong>Time Line</strong></span>) will, in turn, show statistics including the precise execution times in which GC operated, as well as the .NET types implied:</p><div class="mediaobject"><img src="../Images/image00425.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the <a id="id139" class="indexterm"/>figure shows a bunch of objects collected and/or promoted to other generations as the program goes on.</p><p>This is, of course, much more complex than that. The GC has rules to operate with different frequencies depending on the generation. So, <code class="literal">Gen 0</code> is visited more frequently that <code class="literal">Gen 1</code> and much less than <code class="literal">Gen 2</code>.</p><p>Furthermore, in the second window, we see all the mechanisms implicit in the execution, allowing us different levels of details so that we can have the whole picture with distinct points of view:</p><div class="mediaobject"><img src="../Images/image00426.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><p>This is a proof of some <a id="id140" class="indexterm"/>of the characteristics of GC. First of all, a de-referenced object is not immediately collected, since the process happens periodically, and there are many factors that influence this frequency. On the other hand, not all orphans are collected at the same time.</p><p>One of the reasons for this is that the collection mechanism itself is computationally expensive, and it affects performance, so the recommendation, for most cases, is to just let GC do its work the way it is optimized to do.</p><p>Are there exceptions to this rule? Yes; the exceptions are in those cases where you have reserved a lot of resources and you want to make sure that you clean them up before you exit the method or sequence in which your program operates. This doesn't mean that you call GC in every turn of a loop execution (due to the performance reasons we mentioned).</p><p>One of the possible solutions in these cases is implementing the <code class="literal">IDisposable</code> interface. Let's remember that you can see any member of the CLR by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>J</em></span> or selecting <span class="strong"><strong>Object Explorer</strong></span> in the main menu.</p><p>We'll be presented with a window containing a search box in order to filter our member, and we'll see all places where such a member appears:</p><div class="mediaobject"><img src="../Images/image00427.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><div class="note" title="Note"><h3 class="title"><a id="note08"/>Note</h3><p>Note that this interface is not available for .NET Core Runtime.</p></div><p>So, we would redefine our class<a id="id141" class="indexterm"/> to implement <code class="literal">IDisposable</code> (which means that we should write a <code class="literal">Dispose()</code> method to invoke the GC inside it). Or, even better, we can follow the recommendations of the IDE and implement <code class="literal">Dispose Pattern</code>, which is offered to us as an option as soon as we indicate that our program implements this interface, as shown in the following screenshot:</p><div class="mediaobject"><img src="../Images/image00428.jpeg" alt="Garbage collection"/></div><p style="clear:both; height: 1em;"> </p><p>Also, remember that, in cases where <a id="id142" class="indexterm"/>we have to explicitly dispose a resource, another common and more suggested way is the <code class="literal">using</code> block within the context of a method. A typical scenario is when you open a file using some of the classes in the <code class="literal">System.IO</code> namespace, such as File. Let's quickly look at it as a reminder.</p><p>Imagine that you have a simple text file named <code class="literal">Data.txt</code> and you want to open it, read its content, and present it in the console. A possible way to do this rapidly would be by using the following code:</p><div class="informalexample"><pre class="programlisting">class Program2
{
  static void Main(string[] args)
  {
    var reader = File.OpenText("Data.txt");
    var text = reader.ReadToEnd();
    Console.WriteLine(text);
    Console.Read();
  }
}</pre></div><p>What's the problem with this code? It works, but it's using an external resource, since the <code class="literal">OpenText</code> method returns an <code class="literal">StreamReader</code> object, which we later use to read the contents, and it's not explicitly closed. We should always remember to close those objects that we open and take some time to process.</p><p>One of the possible side effects consists of preventing other processes from accessing the file we opened.</p><p>So, the best and suggested solution for these cases is to include the declaration of the conflicting object within a <code class="literal">using</code> block, as follows:</p><div class="informalexample"><pre class="programlisting">string text;
using (var reader = File.OpenText("Data.txt"))
{
  text = reader.ReadToEnd();
}
Console.WriteLine(text);
Console.Read();</pre></div><p>In this way, garbage <a id="id143" class="indexterm"/>collector is automatically invoked to liberate the resources managed by <code class="literal">StreamReader</code>, and there's no need to close it explicitly.</p><p>Finally, there's always another way of forcing an object to die, that is, using the corresponding finalizer (a method preceded by the <code class="literal">~</code> sign, which is right opposite to a destructor). It's not a recommended way to destroy objects, but it has been there since the very beginning (let's remember that Hejlsberg inspired many features of the language in C++). And, by the way, the advanced pattern of implementing <code class="literal">IDispose</code> includes this option for more advanced collectable scenarios.</p></div></div><div class="section" title="Implementing algorithms with the CLR"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>Implementing algorithms with the CLR</h2></div></div></div><p>So far, we've seen some of<a id="id144" class="indexterm"/> the more important concepts, techniques, and tools available and related to CLR. In other words, we've seen how the engine works and how the IDE and other tools gives us support to control and monitor what's going on behind the scenes.</p><p>Let's dig into <a id="id145" class="indexterm"/>some of the more <a id="id146" class="indexterm"/>typical structures and algorithms that we'll find in everyday programming so that we can understand the resources that .NET framework puts in our hands to solve common problems a bit better.</p><p>We've mentioned that .NET framework installs a repository of DLLs that offer a large number of functionalities. These DLLs are organized by namespaces, so they can be used individually or in conjunction with others.</p><p>As it happens with other frameworks such as J2EE, in .NET, we will use the object-oriented programming paradigm as a suitable approach to programming problems.</p><div class="section" title="Data structures, algorithms, and complexity"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Data structures, algorithms, and complexity</h3></div></div></div><p>In the initial versions of .NET (1.0, 1.1), we could use several types of constructions to deal with collections of elements. All modern languages include these constructs as typical resources, and some of these you should know for sure: arrays, stacks, and queues are typical examples.</p><p>Of course, the <a id="id147" class="indexterm"/>evolution <a id="id148" class="indexterm"/>of .NET has produced many novelties, starting with generics, in version 2.0, and other types of similar constructions, such as dictionaries, <code class="literal">ObservableCollections</code>, and others in a long list.</p><p>But the question is, are we using<a id="id149" class="indexterm"/> these algorithms properly? What happens when you have to use one of these constructions and push it to the limits? And to cope with these limits, do we have a way to find out and measure these implementations so that we can use the most appropriate one in every situation?</p><p>These questions take us to the measure of complexity. The most common approach to the problem nowadays relies on a technique called <span class="emphasis"><em>Big O Notation</em></span> or <span class="emphasis"><em>Asymptotic Analysis</em></span>.</p></div><div class="section" title="Big O Notation"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Big O Notation</h3></div></div></div><p>
<span class="strong"><strong>Big O Notation</strong></span> (<span class="strong"><strong>Big Omicron Notation</strong></span>)<a id="id150" class="indexterm"/> is a variant of a mathematical discipline that describes the limiting behavior of a function when a value leans toward a particular value or toward infinity. When you apply it to computer science, it's used to classify algorithms by how they respond to changes in the input size.</p><p>We understand "how they respond" in two ways: response in time (often the most important) as well as response in space, which could lead to memory leaks and other types of problems (eventually including DoS attacks and other threats).</p><div class="note" title="Note"><h3 class="title"><a id="tip04"/>Tip</h3><p>One of the most exhaustive lists of links to explanations of the thousands of algorithms cataloged up to date is published by <span class="strong"><strong>NIST</strong></span> (<span class="strong"><strong>National Institute of Standards and Technology</strong></span>)<a id="id151" class="indexterm"/> at <a class="ulink" href="https://xlinux.nist.gov/dads/">https://xlinux.nist.gov/dads/</a>.</p></div><p>The way to express the response in relation to the input (the O notation) consists in a formula such as <span class="emphasis"><em>O([formula])</em></span>, where formula is a mathematical expression that indicates the growth, that is the number of times the algorithm executes, as the input grows. Many algorithms are of type <span class="emphasis"><em>O(n)</em></span>, and they are called linear because the growth is proportional to the number of inputs. In other words, such growth would be represented by a straight line (although it is never exact).</p><p>A typical example is the analysis of sorting algorithms, and NIST mentions a canonical case: quicksort is <span class="emphasis"><em>O(n log n)</em></span> on average, and bubble offers <span class="emphasis"><em>O(n²)</em></span>. This means that on a desktop computer, a quicksort implementation can beat a bubble one, which is running on a supercomputer when the numbers to be sorted grow beyond a certain point.</p><div class="note" title="Note"><h3 class="title"><a id="note09"/>Note</h3><p>As an example, in order to sort 1,000,000 numbers, the quicksort takes 20,000,000 steps on average, while the bubble sort takes 1,000,000,000,000 steps!</p></div><p>The following graphic <a id="id152" class="indexterm"/>shows the growth in time of four classical sorting algorithms (bubble, insertion, selection, and shell). As you can see in the graph, the behavior is quite linear until the number of elements passes 25,000, in which the elements differ noticeably. The shell algorithm wins and has a factor of a worst case complexity of <span class="emphasis"><em>O(n^1.5)</em></span>. Note that quicksort has a smaller factor <span class="emphasis"><em>(n log n)</em></span>.</p><p>Unfortunately, there's no mechanical procedure to calculate the Big-O, and the only procedures that can be found deal with a, more or less, empirical approach.</p><p>However, we can use some well-defined tables that categorize the algorithms and give us the <span class="emphasis"><em>O(formula)</em></span> to get an idea of what we can obtain out of its usage, such as the one published by Wikipedia, which is accessible at <a class="ulink" href="http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions">http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions</a>:</p><div class="mediaobject"><img src="../Images/image00429.jpeg" alt="Big O Notation"/></div><p style="clear:both; height: 1em;"> </p><p>From the point of view of .NET framework, we can use all collections linked to the <code class="literal">System.Collections.Generics</code> namespace that guarantee optimized performance for a vast majority<a id="id153" class="indexterm"/> of situations.</p><div class="section" title="An approach to performance in the most common sorting algorithms"><div class="titlepage"><div><div><h4 class="title"><a id="ch01lvl4sec04"/>An approach to performance in the most common sorting algorithms</h4></div></div></div><p>You will find in <code class="literal">DEMO01-04</code> a .NET<a id="id154" class="indexterm"/> program that compares three classical algorithms (bubble, merge, and heap) to the one implemented in <code class="literal">List&lt;T&gt;</code> collections using integers. Of course, this approach is a practical, everyday approach and not a scientific one, for which the generated numbers should be uniformly randomly generated (refer to Rasmus Faber's answer to this question at <a class="ulink" href="http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228">http://stackoverflow.com/questions/609501/generating-a-random-decimal-in-c/610228#610228</a>).</p><p>Besides that, another consideration should be made for the generators themselves. For practical purposes such as testing these algorithms, generators included in .NET framework do their job pretty well. However, if you need or are curious about a serious approach, perhaps the most documented and tested one is the Donald Knuth's <span class="emphasis"><em>Spectral Test</em></span>, published in the second volume of his world's famous <span class="emphasis"><em>The Art of Computer Programming, Volume 2: Seminumerical Algorithms (2nd Edition)</em></span>, by <span class="emphasis"><em>Knuth, Donald E.</em></span>, published by Addison-Wesley.</p><p>That said, the random generator class included in .NET can give us good enough results for our purposes. As for the sorting methods targeted here, I've chosen the most commonly recommended ones in comparison with to extremes: the slowest one (bubble with an <span class="emphasis"><em>O(n²)</em></span> in performance) and the one included in the <code class="literal">System.Collections.Generic</code> namespace for the <code class="literal">List&lt;T&gt;</code> class (which is, internally, a quick sort). In the middle, a comparison is made between the heap and merge methods—all of them considered <span class="emphasis"><em>O(n log n)</em></span> in performance.</p><p>The previously mentioned demo follows recommended implementations with some updates and improvements for the user interface, which is a simple Windows Forms application, so you can test these algorithms thoroughly.</p><p>Also, note that you should execute these tests several times with different amounts of inputs to get a real glimpse of these methods' performance, and that .NET framework is built with optimized sorting methods for integers, strings, and other built-in types, avoiding the cost of calling delegates for comparisons, and so on. So, in comparison with built-in types, typical sorting algorithms are going to be much slower normally.</p><p>For example, for 30,000 integers, we obtain the following results:</p><div class="mediaobject"><img src="../Images/image00430.jpeg" alt="An approach to performance in the most common sorting algorithms"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, the results<a id="id155" class="indexterm"/> of bubble (even being an optimized bubble method) are far worse when the total numbers go beyond 10,000. Of course, for smaller numbers, the difference decreases, and if the routine does not exceed 1,000, it's negligible for most practical purposes.</p><p>As an optional exercise for you, we leave the implementation of these algorithms for string sorting.</p><div class="note" title="Note"><h3 class="title"><a id="tip05"/>Tip</h3><p>You can use some of these routines to quickly generate strings:</p><div class="informalexample"><pre class="programlisting">int rndStringLength = 14; //max:32-&gt; Guid limit
Guid.NewGuid().ToString("N").Substring(0, rndStringLength);</pre></div><p>This one is suggested by Ranvir at <a class="ulink" href="http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string">http://stackoverflow.com/questions/1122483/random-string-generator-returning-same-string</a>:</p><div class="informalexample"><pre class="programlisting">public string RandomStr()
{
  string rStr = Path.GetRandomFileName();
  rStr = rStr.Replace(".", ""); // Removing the "."
  return rStr;
}</pre></div></div><p>Remember that, for such situations, you should use generic versions of the merge and heap algorithms so that an invocation can be made to the same algorithm independently of the input values.</p></div></div></div><div class="section" title="Relevant features appearing in versions 4.5x, 4.6, and .NET Core 1.0 and 1.1"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Relevant features appearing in versions 4.5x, 4.6, and .NET Core 1.0 and 1.1</h2></div></div></div><p>Among the new features that we can find in the latest versions of .NET framework and which we have not mentioned yet, some relate to the CLR (as well as many others that will be covered in the following chapters), and among those that relate to the core of .NET, we can find the ones mentioned in the next few sections.</p><div class="section" title=".NET 4.5.x"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec14"/>.NET 4.5.x</h3></div></div></div><p>We can summarize the <a id="id156" class="indexterm"/>main improvements and new features that appeared in .NET 4.5 in the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Reduction of system restarts</li><li class="listitem">Arrays larger than 2 gigabytes (GB) on 64-bit platforms</li><li class="listitem">An improvement of background garbage collection for servers (with implications in performance and memory management)</li><li class="listitem">JIT compilation in the background, optionally available on multicore processors (to improve the application performance, obviously)</li><li class="listitem">New console (<code class="literal">System.Console</code>) support for Unicode (UTF-16) encoding</li><li class="listitem">An improvement in performance when retrieving resources (especially useful for desktop applications)</li><li class="listitem">The possibility of customizing the reflection context so that it overrides the default behavior</li><li class="listitem">New asynchronous features were added to C# and Visual Basic languages in order to add a task-based model to perform asynchronous operations</li><li class="listitem">Improved support for parallel computing (performance analysis, control, and debugging)</li><li class="listitem">The ability to explicitly compact the <span class="strong"><strong>large object heap</strong></span> (<span class="strong"><strong>LOH</strong></span>) <a id="id157" class="indexterm"/>during garbage collection</li></ul></div></div><div class="section" title=".NET 4.6 (aligned with Visual Studio 2015)"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec15"/>.NET 4.6 (aligned with Visual Studio 2015)</h3></div></div></div><p>In .NET 4.6<a id="id158" class="indexterm"/>, new features and improvements are not many, but they're important:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">64-bit JIT compiler for managed code (formerly called RyuJIT in beta versions).</li><li class="listitem">Assembly loader improvements (working in conjunction with NGEN images; decreases the virtual memory and saves the physical memory).</li><li class="listitem">Many changes in <a id="id159" class="indexterm"/><span class="strong"><strong>Base Class Libraries</strong></span> (<span class="strong"><strong>BCLs</strong></span>):<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Several new capabilities in the Garbage Collection class</li><li class="listitem">Improvements in SIMD<a id="id160" class="indexterm"/> support (for information on SIMD, refer to <a class="ulink" href="https://en.wikipedia.org/wiki/SIMD">https://en.wikipedia.org/wiki/SIMD</a>)</li><li class="listitem">Cryptography updates related to the Windows CNG cryptography APIs<a id="id161" class="indexterm"/> (a CNG reference is available at <a class="ulink" href="https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx">https://msdn.microsoft.com/library/windows/desktop/aa376214.aspx</a>)</li></ul></div></li><li class="listitem">.NET Native, a new technology that compiles apps to native code rather than IL. They produce apps characterized by faster startup and execution times, among other advantages.<div class="note" title="Note"><h3 class="title"><a id="note10"/>Note</h3><p>.NET Native<a id="id162" class="indexterm"/> has major improvements at runtime, but it has a few drawbacks as well, among some other considerations that may affect the way applications behave and should be coded. We'll talk about this in greater depth in other chapters.</p></div></li><li class="listitem">Open source .NET framework packages (such as Immutable Collections, SIMD APIs and networking APIs, which are now available on GitHub)</li></ul></div></div><div class="section" title=".NET Core 1.0"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec16"/>.NET Core 1.0</h3></div></div></div><p>.NET Core is a new version of .NET intended to execute in any operating system (Windows, Linux, MacOS), that can be <a id="id163" class="indexterm"/>used in device, cloud, and embedded/IoT scenarios.</p><p>It uses a new set of libraries, and –as Rich<a id="id164" class="indexterm"/> Lander mentions in the official documentation guide (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/core/">https://docs.microsoft.com/en-us/dotnet/articles/core/</a>) the set of characteristics that<a id="id165" class="indexterm"/> best define this version are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Flexible deployment</strong></span>: Can be<a id="id166" class="indexterm"/> included in your app or installed side-by-side user- or machine-wide.</li><li class="listitem"><span class="strong"><strong>Cross-platform</strong></span>: Runs on <a id="id167" class="indexterm"/>Windows, MacOS and Linux; can be ported to other OSes. The supported Operating Systems (<a class="ulink" href="https://github.com/dotnet/core/blob/master/roadmap.md">https://github.com/dotnet/core/blob/master/roadmap.md</a>), CPUs and application scenarios<a id="id168" class="indexterm"/> will grow over time, provided by Microsoft, other companies, and individuals.</li><li class="listitem"><span class="strong"><strong>Command-line tools</strong></span><a id="id169" class="indexterm"/>: All product scenarios can be exercised at the command-line.</li><li class="listitem"><span class="strong"><strong>Compatible</strong></span><a id="id170" class="indexterm"/>: .NET Core is compatible with .NET Framework, Xamarin and <a id="id171" class="indexterm"/>Mono, via the.NET Standard Library (<a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/articles/standard/library">https://docs.microsoft.com/en-us/dotnet/articles/standard/library</a>).</li><li class="listitem"><span class="strong"><strong>Open source</strong></span>: The .NET <a id="id172" class="indexterm"/>Core platform is open source, using MIT and Apache 2 licenses. Documentation is licensed under CC-BY (<a class="ulink" href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a>). .NET Core is a .NET Foundation project (<a class="ulink" href="http://www.dotnetfoundation.org/">http://www.dotnetfoundation.org/</a>).</li><li class="listitem"><span class="strong"><strong>Supported by Microsoft</strong></span>: .NET Core<a id="id173" class="indexterm"/> is supported by Microsoft, per .NET Core Support (<a class="ulink" href="https://www.microsoft.com/net/core/support/">https://www.microsoft.com/net/core/support/</a>).</li></ul></div></div><div class="section" title=".NET Core 1.1"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec17"/>.NET Core 1.1</h3></div></div></div><p>Added support for Linus <a id="id174" class="indexterm"/>Mint 18, Open Suse 42.1, MacOS 10.12, and Windows Server 2016, with side-by-side installation.</p><p>New API's (more than 1000) and bug fixes.</p><p>New documentation<a id="id175" class="indexterm"/> available at <a class="ulink" href="https://docs.microsoft.com/en-us/dotnet/">https://docs.microsoft.com/en-us/dotnet/</a>.</p><p>A new version of ASP.NET Core 1.1.</p><p>At the end of this book, we'll cover .NET Core<a id="id176" class="indexterm"/> so you can have an idea of its behavior and is advantages, specially in the cross-platform area.</p></div></div></div>
<div class="section" title="Summary" id="aid-G6PI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>CLR is the heart of .NET framework, and we have reviewed some of the most important concepts behind its architecture, design, and implementation in order to better understand how our code works and how it can be analyzed in the search for possible problems.</p><p>So, overall, in this chapter, we saw an annotated (with commentaries, graphics, and diagrams) reminder of some important terms and concepts of computing that we will find within the book, and with this foundation, we went through a brief introduction to the motivations that rely on .NET framework's creation along with its fathers.</p><p>Next, we covered the what's inside CLR and how we can view it in action using tools provided by CLR itself and others available in Visual Studio 2015 from the Update 1.</p><p>The third point was a basic review of the complexity of algorithms, the Big O Notation and the way in which we can measure it in practice by testing some sorting methods implemented in C# in order to finish with a short list of the most relevant features the latest versions of .NET offer and that we will cover in different chapters of this book.</p><p>In the next chapter, we will dig into the substance of the C# language from the very beginning (don't miss Hejlsberg's true reasons for the creation of delegates) and how it has evolved to simplify and consolidate programming techniques with generics, lambda expressions, anonymous types, and the LINQ syntax.</p></div></body></html>