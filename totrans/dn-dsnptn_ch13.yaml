- en: Chapter 13. Reactive Programming Using RxJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how .NET **Reactive Extensions** (**Rx**) aided
    natural programming in terms of composability, scalability, and responsiveness.
    We saw how streams enable natural state management with respect to time. Some
    of the constructs were dealt with in detail as well. More importantly, we saw
    how reactive constructs could be integrated seamlessly into the MVVM pattern,
    in terms of achieving data synchronization between View and Model via the View
    Model layer. Now, in this chapter, we will take a deep dive into the **Reactive
    Extensions for JavaScript** (**RxJS**) library, and look at how to write asynchronous
    and event-driven programs using observable collections. We will also take a detailed
    look at some interesting use cases, and their implementations with RxJS, to clearly
    understand how the RxJS library is leveraged to create concurrent and responsive
    applications. This will cover the reactive spectrum of web and Windows programming
    and, by the end of this chapter, you will be in a position to appreciate the possibilities
    of JavaScript and confidently leverage RxJS by having a jump start at it. This
    chapter includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A refresher on JavaScript execution context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An analogy of RxJS with YieldJS (a custom JS framework created by the authors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed outline on RxJS foundations and formalisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed code samples that demonstrate RxJS in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JS world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to recap one's understanding of some of the JavaScript world's
    state of affairs. The most important aspect is that the language is single-threaded
    and, given this, the only option left for developers to write asynchronous code
    is by using callbacks, promises, and events. As a developer, you should be comfortable
    with the functional programming aspects of JS (in addition to its innate dynamic
    nature), including closures, higher-order functions, anonymous functions, and
    extension methods (augmenting types). We also cannot discount the advancements
    that have been made in the language core itself, with Node.js now becoming a preferred
    backend for serious scalability involving async I/O. Let's have a quick peek into
    these core concepts before we dive into RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: As we all know (we presume you do), functions are objects in JavaScript, and
    they are first-class citizens, which makes JS a functional programming language
    as well (although it is formally classified as a dynamic language). We already
    discussed and saw in [Chapter 10](dn-dsnptn_ch10.html "Chapter 10. Pattern Implementation
    Using Object/Functional Programming"), *Pattern Implementation Using Object/Functional
    Programming* (that too, in depth), how higher-order functions, along with closures,
    enable you to compose programs naturally, now that we have been thinning the OOP
    wall for some time (at least from Chapter 10 onwards). Well, we don't intend to
    imply that JS is an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JS supports OOP through prototypal inheritance compared to classic inheritance
    in C#. This is important to understand how types can be augmented (analogous to
    our extension methods in C#).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a higher-order function, which leverages callback (yet another
    function, which typically gets called for notification and continuation purposes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code snippet, the callback (`onComplete`) is passed as an attribute
    to a function (`doSomething`), thus making it (`doSomething`) a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at a Closure in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `add` is a higher-order function (as it can be assigned
    to a variable), and `x` becomes a closure (lexical closure) within this function
    (irrespective of any nested/sub functions within). The results presented as comments
    against the respective statements speak for themselves. Also, see how anonymous
    functions (in this case, the inner function within the `add` function) are so
    natural in the JS realm. If you remember (from [Chapter 9](dn-dsnptn_ch09.html
    "Chapter 9. Functional Programming Techniques for Better State Management"), *Functional
    Programming Techniques for Better State Management*), this also touches upon currying
    (an important concept in the functional programming world, which we've already
    dealt with in detail), a formalism that breaks any function with arity greater
    than one into a series of function evaluations (each accepting one argument at
    a time).
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept to understand is augmenting types in JS. This provides
    an amazing way to impart capabilities to a type (just like the way we use extension
    methods in C#). Let's quickly look at the power of this, using the following example
    in terms of dynamically adding error-handling capability to functions (ones that
    don't have it) at runtime. Ever thought of that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code essentially augments a function object by adding the `throws`
    method to its prototype object (the base object). It deftly leverages some nifty
    features in the JS language (including array slicing, `arguments` object, function
    context capture using closure, and the `apply` method used for function evaluation).
    We suggest you look it up in case you are unable to follow the code. The candidate
    function, which deliberately throws an exception and one that should gracefully
    exit function evaluation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code (line 1) can be used in place of direct function evaluation
    (line 2), where the program throws a runtime error (ReferenceError: RxJS is not defined)
    and breaks execution. What is important to note is the preservation of arity for
    these functions despite using the decorator. This is where you will understand
    the relevance of the arguments object and the `apply` method. Here, our decorator
    assumes the semantics - that of issuing the first argument with the error message
    followed by the function arguments in the exact same order! You can easily achieve
    this with a find and replace in your code file, can''t you?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We guess that now you've got a handle on how things work in the JS world. It's
    important to know these as we move forward to explore reactive programming using
    RxJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try out the code samples in this chapter, please ensure you have **Node.js**
    set up and RxJS dependencies installed through `npm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Rx foundations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it may sound repetitive, it is so important to understand the foundations
    of Rx and the key design patterns that govern Rx. Being a book on patterns and
    idioms, it would be really gratifying to know if any interested reader would benefit
    from understanding the underpinnings of these keys concepts as they are realized
    in the host language (JS in this case) directly or via libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The two key design patterns based on which Rx works are the **observer** and
    **iterator** patterns. Let's have a quick look at how these patterns are implemented,
    and then speculate or peek at a possible implementation of RxJS. This way of learning
    would really help in forming a deeper understanding of the core concepts. And
    not to hide the fact that the authors themselves have attempted to create a JS
    library (code-named `YieldJS` on GitHub at [http://shinexavier.github.io/YieldJS/](http://shinexavier.github.io/YieldJS/)),
    which gives the rudimentary capability of RxJS despite being a pull-based implementation.
    However, one thing to keep in mind is that this library was never intended to
    be created as an RxJS clone, but to bring in the **yield** (from the C# world)
    capability to JS prior to ES 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The strategy was very straightforward, since the language ES 5.0 didn't have
    inherent support for **yield** where you would want a generator object, which
    would continuously yield the next computed value and at the same time provide
    an option for forward iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding statement is very powerful with respect to the fact that this
    library would impart the following capabilities to a generator function in JS:'
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting the generator function object to have forward iteration capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepting a series (unlimited) of iterator methods, which act as continuation
    methods to the core yielded elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yielding the next valid result based on the continuous and sequenced (the very
    order in which it is specified during iteration) iterator function evaluations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting lazy evaluation by yielding the computed value only when requested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What do you think the authors had in mind when they set on this task of creating
    this library? In case you are still wondering, it was a novel attempt to create
    LINQ capability for sequences created by any generator object (functions, in our
    case) in JS. A subset of the library implementation is depicted in the following
    code, as this helps reason about a possible implementation of RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As highlighted in the preceding code, the key to this implementation is the
    state object `fnContext`, which holds information regarding every function (provided
    during iteration) and its evaluation details. This is critical for the continuation
    needed during iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the generator would be a method, `getGenerator(numberOfElements)`,
    which augments any generator function (by accepting the number of elements to
    be generated) and has the following interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current`: Yields the current element during the course of a generation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moveNext`: Attempts to generate the next element based on the generator function,
    increments the iteration pointer, and returns `true` if successful. If unsuccessful
    (primarily because the iteration pointer points to the last element returned by
    the generator function based on the number of elements specified), it returns
    `false`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From a usage standpoint, take a look at the following generic sequence generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this accepts a seed incremental value during sequence initialization,
    and returns the actual function (anonymous), which can be invoked multiple times
    to generate the seed sequences. Another critical thing would be the accumulator
    (`y` in our case), which holds the previous item in our sequence because of its
    closure property. Now, let''s see our generator in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you really look carefully, the preceding code snippet has the basic
    framework for creating a reactive library in terms of manipulating sequences (upon
    generation) to suit your needs. This is done using the iterator methods, which
    sort of become your LINQ operators. What really enables this are the context objects,
    which get created for each of the iterator functions. You will understand this
    when we look at some of the iterator methods shown next (ideally, the end users
    are just expected to write the sequence generator, and this library of iterator
    methods can be used for manipulating sequences in real time). Plus, the moment
    you understand how the context object provided during function evaluation can
    be used to write more iterator methods, it becomes all the more exciting and the
    possibilities seem endless. The context object provides the following attributes
    for creating various useful iterator functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index`: Gives the index of the current element in the iteration context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current`: Gives the current element in the iteration context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outList`: Gives the cumulative output collection/array till that point of
    iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very standard use of transform operators, where the `current` element
    in the sequence is retrieved and manipulated (squared in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, you clearly see how the `outList` property is leveraged
    for generating unique sequences! Typically, this property becomes very handy for
    implementing aggregation operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an interesting scenario, where a predicate function (`even`) is used
    in conjunction with an iterator function (`filter`) to filter those elements in
    the sequence that satisfy a certain condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And finally, here you see how the `index` property is leveraged for skipping
    certain elements in the sequence!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see the entire thing in action, look at the following example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Do you get the connection now? Do you see how the two iterator methods (a filter
    and a transformation operator in this case) are composed elegantly in a declarative
    manner? One that would chain these operators during an iteration as an element
    in the sequence is generated. This is reactive (except that, with the iteration,
    you pull as opposed to the conventional push)! Don't you get it? All we need is
    a callback to be passed to our generator object, which would get notified any
    time a new element in the sequence is generated! We will leave that entirely to
    any interested reader (depending on whether you like to be an API producer or
    a consumer) to toy around with this implementation (you are free to fork it on
    GitHub), or directly jump to RxJS and start benefiting from it. Either way, by
    now, we feel you are ready and have the foundation to lock horns with RxJS!
  prefs: []
  type: TYPE_NORMAL
- en: RxJS formalism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, unlike YieldJS, RxJS is push-based. Here, the subscribers would automatically
    receive new values from the publisher. A subscriber or listener is denoted by
    the `observer` object, and the publisher (that pushes/publishes new values) is
    denoted by the `Observable` object. Just like the way we specified iterator methods
    (our future operators) to compose our generated sequences, we can efficiently
    do the same (transform, filter, and so on) for all the elements in the observable
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Observables and observers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The generator becomes our observable, and the callback function, which would
    be interested in these sequences, becomes the observer. Having said this, creating
    `Observables` is pretty straightforward, as we saw in the earlier chapter with
    reactive extensions for .NET. The following code bares it all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The client in the preceding code is the `observer`, which has the three important
    callbacks (highlighted), namely, `OnNext`, `OnError`, and `OnCompleted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected, this faithfully prints the following on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at some key bridges offered by RxJS when it comes to working
    with core language constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Observables from arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s see how observables can be created from arrays using RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As highlighted in the preceding code, you can see that the `from` operator does
    the trick here, and you get the same results as earlier!
  prefs: []
  type: TYPE_NORMAL
- en: Observables from events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, we can create observables from events using the `fromEvent` operator.
    The following is an observable, which displays the mouse pointer coordinates whenever
    the mouse crosses diagonally across the window. Since we need the DOM elements
    (document and window) here, we will use the **JSbin** playground for running this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you observe the preceding code, you''ll see that `allMoves` is the primary
    observable sequence, and then we derive the next `movesCrossingDiagonal` sequence
    from `allMoves`. All these sequences are immutable, and we just subscribe (the
    two subscribers are highlighted in code) to those that are of interest. We also
    see the use of the `filter` operator. See the following equivalent code executed
    in the JSbin editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observables from events](img/B05691_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the HTML code given in the preceding screenshot, you can see the Rx library
    included (you could simply do this in JSbin by using the **Add library** option
    shown in the web editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observables from events](img/B05691_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will get these results, as seen in the preceding screenshot, the moment
    you move your mouse in the output window (not shown in this screenshot on account
    of brevity).
  prefs: []
  type: TYPE_NORMAL
- en: Observables from callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating observables from callbacks is indispensable when it comes to asynchronous
    and event-driven programming, and it truly completes the final dimension of possibilities
    that observables have to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s presume you have a file named `alas.tmp` within the `tmp` folder,
    and you modify its contents and save it. The observer would immediately get notified
    of this change, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, this preceding code, as you can see, helps you with subscribing to a file
    system watcher (directory watcher in this case). There's a shortcoming though!
    Can you spot that before we address this in the coming sections?
  prefs: []
  type: TYPE_NORMAL
- en: Observable pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember the operator chaining we did with YieldJS a while ago? Well that''s
    precisely what an `Observable` pipeline is. And if you remember how we trickled
    the state across the chaining operations (as opposed to maintaining it outside),
    you are in good hands. RxJS offers the same, as the `Observable` pipeline is self-contained
    and the state flows from one chained operator to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code yields the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Another thing to note is that this pipeline is highly efficient in terms of
    evaluations (or, we say, the various steps in an algorithm). In place of conventionally
    having three iterations/passes (per operator), we can do this operator chaining
    in just one iteration for all the three operators. We saw how this is clearly
    achieved in YieldJS. Additionally, you get the benefit of lazy evaluations as
    well! Be sure to check out other operators that may become handy for your day-to-day
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Subject et al.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, we have subjects (those that implement both
    `Observer` and `Observable` types) within RxJS as well. This makes it a powerful
    mediator (a proxy object to be precise) between a source and downstream subscribers/observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is seen upon execution of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These are some of the specialized subjects which one could leverage based on
    their intent of usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncSubject`: Represents the result of an asynchronous action. It can be
    used like a `promise` object in JS. It caches and returns only the last value,
    thus making it ideal for use in asynchronous operations, including AJAX calls,
    file I/O, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject`: This mandates a starting value, making it ideal for initializing
    with placeholder values during any asynchronous operation, including AJAX calls,
    file I/O, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject`: Caches values (based on the buffer size specified) and re-emits
    those to subscribers irrespective of the time they subscribe to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedulers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw earlier, schedulers are powerful tools to manage and handle concurrency.
    You have a lot more control in terms of the concurrency models you choose for
    notifications and subscriptions. You have the following three basic schedulers
    at your disposal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Immediate**: This is de-facto for most of the operators, and is synchronous
    in nature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default**: This is asynchronous in nature, and leverages the event loop (using
    `nextTick` in the case of Node.js), `setTimeout`, and so on, behind the scenes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current t****hread**: This, again, is synchronous in nature, except that
    in the case of recursive operators (such as `repeat`), it enqueues executions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And we have two handy operators to help us here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`observeOn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribeOn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these return observable instances, but give fine-grained control on concurrency
    by taking in the scheduler as an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Please do check out the RxJS references for a deeper understanding of these
    (as coverage of these needs a chapter on its own, and that is not the true intent
    of this book). Now that we have looked at some of the core formalisms in RxJS,
    let's try to explore the world of RxJS with more examples.
  prefs: []
  type: TYPE_NORMAL
- en: RxJS samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we even proceed without seeing our spell checker in action on a web
    page? For this, we need an ASP.NET Web API that provides the suggestions. We will
    reuse our earlier `NorvigSpellCheckerModel` class as-is for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this preceding code, a `SearchContext` class has been created to pass in
    values for the get API! Also, a small change has been made to the `Global.asax.cs`
    file to accommodate JSONP responses (highlighted in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following utility class, which helps you with formatting needs, is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see how we can make a responsive frontend using RxJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As indicated here, you would need the following two JS files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function (`initialize`) is called as soon as the DOM is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we do some throttling, and do not overload the server
    with requests, by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Transforming keyup DOM events into observable sequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focusing on the value entered (the `pluck` operator here serves this purpose)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up search items which have more than three characters (using the `filter`
    operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slowing down user input with a timeout of 500 milliseconds (using the `debounce`
    operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restricting lookup for distinct values in the input stream (using the `distinctUntilChanged`
    operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function issues the search against the web API, and gets back an observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clearSelector` and `createLineItem` functions are helper functions for
    DOM manipulations, which facilitate display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![RxJS samples](img/B05691_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, by now we have seen how to subscribe to observable sequences (both keyboard
    events and AJAX calls/responses).
  prefs: []
  type: TYPE_NORMAL
- en: The next sample we will deal with is a logical extension of what we discussed
    earlier. Remember we asked if you could spot a shortcoming in the file watcher
    sample that we discussed under observable from callbacks?
  prefs: []
  type: TYPE_NORMAL
- en: Real-time file watcher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The earlier version would terminate the observable sequence upon detecting
    the first change, thus impairing its ability to continuously detect changes. The
    solution to this fix is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see in the highlighted code, the fix to the earlier problem is recursive
    scheduling (using the `sceduleRecursive` operator) upon sequence completion (indicated
    using `onCompleted`) during an event detection by the file system watcher component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following result indicates that our fix works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Change galore
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This sample has a wider implication in various domains, especially logistics.
    The solution involves finding all the change sets for an amount with a given set
    of currency denominations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, here we have a global function (in order
    to clearly set a boundary on the global scope), which accepts the denominations
    (in an array) and the amount as two independent attributes. Now, what is important
    here is the strategy we employed to make the computation (or steps in the algorithm)
    asynchronous. For this, we used the default scheduler (`Rx.Scheduler.default`),
    which never blocks the event loop. In case you noticed, the resource cleanups
    are done in the `onCompleted` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printChangeSet` function again creates a local scope, and further employs
    the `findCombinationSet` function to shortlist the applicable `changeSets` out
    of the possible currency combinations (based on the available denominations).
    Another important thing to note here is the tail call optimization done for the
    recursion involving the `findCombinationSet` function (see highlighted code) by
    passing accumulated transient sums, thereby eliminating call-stack growth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you are wondering about this `generateChangeSets` function, you guessed
    it right. This is the JS equivalent of the C# subset generation code we saw in
    [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional Programming Techniques
    for Better State Management"), *Functional Programming Techniques for Better State
    Management*. So, by now you would have got a hang on the algorithm employed here,
    which can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate all possible subsets (possibly denomination combinations).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to determine possible counts per denomination.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If step 2 is successful, do pretty printing, as shown in the following output
    for `calculateChange([1, 5, 10, 25], 25)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In case you didn't notice, the console logs appear first before the results
    are printed, clearly indicating that step 2 and beyond are asynchronous!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you must have understood how reactive programming is employed for modeling
    solutions the way the world exists. The principle has been applied for various
    mainstream programming languages, as thought leaders such as Erik Meijer found
    this too natural to express and compose. And we got lucky in this discovery process.
    We believe, as developers, you must have have started appreciating the world of
    functional and reactive programming beyond OOP. In the next chapter, we will be
    specifying, in brief, some important topics which could not be covered in the
    book, such as polyglot programming, **domain specific languages** (**DSLs**),
    ontology, and AntiPatterns.
  prefs: []
  type: TYPE_NORMAL
