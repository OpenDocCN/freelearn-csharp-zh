<html><head></head><body>
		<div id="_idContainer031">
			<h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor056"/>2</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Building a Simple Demo Application</h1>
			<p>In this chapter, we will build a very simple demo application that will form the basis and framework of the SaaS application that we will build out in subsequent chapters. The purpose of this chapter is to get familiar with all of the tools and techniques that we will leverage later in this book, and in our careers as builders of SaaS applications! Once we have this foundational knowledge and framework app, it will be much easier to start to build more <span class="No-Break">complex functionality.</span></p>
			<p>Before we start building the framework application, we must first discover and install the tools that we will use. Then, we’ll build out the skeleton application. Once we have that working, then we will start to think about what would be required to flesh this out into a real-world <span class="No-Break">SaaS application!</span></p>
			<p>This chapter will give you a very brief look at a lot of different technologies. Please don’t feel overwhelmed! We are going to configure a dev environment from scratch, using Docker, and then we are going to initialize a database, API, <span class="No-Break">and UI.</span></p>
			<p>This chapter uses a lot of different technologies, some of which you may not be familiar with. Don’t worry! Everything in this chapter is written out in detail, and anything that is skipped over quickly in this chapter will be explained fully in <span class="No-Break">subsequent chapters.</span></p>
			<p>Developing SaaS applications, almost by definition, requires a wide array of different technologies. We will take a quick look at them all in this chapter, and then deepen our knowledge and understanding in <span class="No-Break">subsequent chapters!</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Getting set up – installing <span class="No-Break">the tools</span></li>
				<li>Building a simple <span class="No-Break">example application</span></li>
				<li>Where do we go <span class="No-Break">from here?</span></li>
			</ul>
			<p>By the end of the chapter, you’ll have built, installed, and configured your development environment, and you’ll have initialized all of the components required to build out a SaaS app. Hopefully, you will finish this chapter inspired to understand how we will make the most out of these tools <span class="No-Break">and techniques!</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Technical requirements</h1>
			<p>All code from this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2"><span class="No-Break">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Setting up</h1>
			<p>In this <a id="_idIndexMarker064"/>section, we’ll cover the tools that I recommend using to work through the examples in this book. Please note that there are not really any specific tools for building a SaaS application – the typical set of developer tools that you are probably accustomed to will do the job. However, I will refer to a specific set of tools in this book, and so I’ll describe them in this section, explain my selection, and cover how to install and configure <span class="No-Break">the tools.</span></p>
			<p>I am sure that any of the popular tools out there would be perfectly sufficient, so don’t feel like you <em class="italic">must</em> go with my selection, and feel free to use whatever you are most comfortable with! You should be able to adapt the examples to work with your tooling <span class="No-Break">of choice.</span></p>
			<p>There are only two tools that need to be installed on your machine to follow along with the code that will be supplied in <span class="No-Break">this book:</span></p>
			<ul>
				<li><span class="No-Break">Docker Desktop</span></li>
				<li>Visual <span class="No-Break">Studio Code</span></li>
			</ul>
			<p>These tools are fairly stable, and it is likely the best choice to use the latest version. For reference, I am using Docker v20.10.17 and VS <span class="No-Break">Code v1.71.2.</span></p>
			<p>These tools are chosen deliberately as they are available for all operating systems, they are free to use, and they will give us a consistent base on which to work through the code examples. These are the two tools that I find most useful in my day-to-day work as a software developer! They are typically the first two applications that I install when building a new <span class="No-Break">developer machine.</span></p>
			<p>I’m going to use a neat trick with Docker to containerize the entire developer setup, which is why these two tools are the only ones that you need to install on your machine, and it is also the reason that I am confident that the example provided will work on any <span class="No-Break">operating system.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Visual Studio Code</h2>
			<p>Visual Studio Code has<a id="_idIndexMarker065"/> gone from being a <em class="italic">lite</em> version of the full Visual Studio application to being an absolute workhorse for all manner of development work. With the availability of a massive range of extensions, it can be configured for just about any coding task, and then further modified to suit <span class="No-Break">individual preferences.</span></p>
			<p>VSCode has <a id="_idIndexMarker066"/>become my IDE of choice for many different projects, but the real strength of a SaaS project is that it can be configured to support all of the different layers that will be built. You can add extensions for database development, API development, and UI development and build a highly customized developer environment that is specifically tailored to your project and your <span class="No-Break">preferred tooling.</span></p>
			<p>Start by installing Visual Studio Code. This is done simply by clicking this URL and following the instructions for your operating system of <span class="No-Break">choice: </span><a href="https://code.visualstudio.com/download"><span class="No-Break">https://code.visualstudio.com/download</span></a></p>
			<p>When VSCode is installed, you will also need to install a couple <span class="No-Break">of extensions.</span></p>
			<p>You will need three extensions for <span class="No-Break">VS Code:</span></p>
			<ul>
				<li><span class="No-Break">Remote containers</span></li>
				<li><span class="No-Break">Remote WSL</span></li>
				<li><span class="No-Break">Docker</span></li>
			</ul>
			<p>The tags for the required extensions are <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ms-vscode-remote.remote-containers
ms-vscode-remote.remote-wsl
ms-azuretools.vscode-docker</pre>
			<p>When VSCode is correctly configured, the <strong class="bold">EXTENSIONS</strong> pane should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B19343_Figure_2.1.jpg" alt="Figure 2.1 – Visual Studio Code with extensions configured"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Visual Studio Code with extensions configured</p>
			<p>We will use <a id="_idIndexMarker067"/>a number of other <a id="_idIndexMarker068"/>extensions specific to the project, but these will be installed in a dev container for ease of use – more on <span class="No-Break">this later!</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Docker</h2>
			<p>Docker <a id="_idIndexMarker069"/>is a relatively recent<a id="_idIndexMarker070"/> addition to the developer toolbox, but it has quickly become completely invaluable for building and deploying applications. In more recent years, Docker has also become an incredible tool to encapsulate all of the setup required on a <span class="No-Break">developer machine.</span></p>
			<p>Docker is a containerization tool. The principle at play is derived from shipping containers. Shipping containers are a standard size, which means that the machinery to move them and load them at the port and onto ships is completely standardized around the globe. Of course, what goes into the shipping containers can be anything from cars to cucumbers, but the infrastructure to move the containers is <span class="No-Break">identical regardless.</span></p>
			<p>This principle is applied to software packaged with Docker. Whatever software tool is to be run is put inside a Docker container – analogous to a shipping container – and the Docker infrastructure is then used to run <span class="No-Break">the container.</span></p>
			<p>You can<a id="_idIndexMarker071"/> consider a container to be a tiny virtual machine, or maybe an executable of its own. The important thing to keep in mind is that any piece of code, application, service, and so on that has been placed inside a <a id="_idIndexMarker072"/>Docker container will run on any computer with Docker installed. Furthermore, it will run (or not run!) in an identical way regardless of whether or not the host operating system is Windows, Mac, <span class="No-Break">or Linux.</span></p>
			<p>This concept of containers is fantastic for shipping running software. I can now pull a Docker image for just about any software utility I can think of, and no matter what platform I am working with, I can execute <span class="No-Break">that software.</span></p>
			<p>From a software provider’s point of view, the huge benefit is that they can be certain that their code will run correctly on my machine because it’s running against a standard platform – <span class="No-Break">Docker!</span></p>
			<p>You may be wondering why this is important when it comes to setting up a <span class="No-Break">developer environment.</span></p>
			<p>Dev containers are a relatively new but extremely powerful concept that can take all of the power that Docker has when running applications and apply that to developing applications. It is now possible to configure an entire dev environment – with all of the associated dependencies – and put all of that in <span class="No-Break">a container!</span></p>
			<p>This may not be of the utmost importance for a more basic project, but a SaaS application is rarely a <span class="No-Break">basic project.</span></p>
			<p>The nature of a SaaS application typically requires that many project-specific tools are installed on each developer machine. Worse, it is very common that specific versions of the tools will be required, which can often make the initial setup for new team members particularly painful. These tools can include <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <span class="No-Break">database platform</span></li>
				<li>A framework, such as .NET – very often with specific <span class="No-Break">version requirements</span></li>
				<li>Package management, such as NPM <span class="No-Break">or NuGet</span></li>
				<li>A web server of some kind for <span class="No-Break">the frontend</span></li>
				<li>A huge number of <span class="No-Break">CLI tools</span></li>
				<li>And many other <span class="No-Break">dev tools</span></li>
			</ul>
			<p>If your<a id="_idIndexMarker073"/> dev team supports multiple projects – as is often the case – this can become a real <span class="No-Break">pain point.</span></p>
			<p>I try to use dev containers as much as I possibly can to wrap up dependencies, and I will use this technique in the examples in <span class="No-Break">this book.</span></p>
			<p>Please note that <a id="_idIndexMarker074"/>Docker is an enormous topic in itself, and it is out of the scope of this book to cover it in any sort of depth. I will cover just enough to get familiar with the techniques that I am using, and leave it up to the reader to do more of a deep dive into all <span class="No-Break">things Docker!</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Dev containers</h2>
			<p>As<a id="_idIndexMarker075"/> developers, we all have our favorite set of tools that we work with on a day-to-day basis. This will start with our choice of operating system, and from there we will pick IDEs, database platforms, frontend frameworks, and all of the <span class="No-Break">associated tooling.</span></p>
			<p>This<a id="_idIndexMarker076"/> huge variety of systems, tools, platforms, and frameworks provides a challenge for the author of a book describing how to build a <span class="No-Break">SaaS platform…</span></p>
			<p>In order for the tutorials in this book to appeal to the broadest range of developers possible, I am going to make use of a relatively new concept known as <strong class="bold">Dev Containers</strong>. This allows us to configure a Docker container to do all of our development. This will give you a consistent platform with which to work and will ensure that all of the examples that are provided will work on literally <span class="No-Break">any machine.</span></p>
			<p>Making use of dev containers gives us a completely consistent development platform to work with so that we can be sure that all readers of this book will be able to run the example code that is provided, but there is a small configuration overhead to <span class="No-Break">get started.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>What is a dev container?</h2>
			<p>Continuing <a id="_idIndexMarker077"/>with the analogy of a shipping container, a dev container is simply a wrapper around the myriad of developer tools that you will use when working on the code in <span class="No-Break">this book.</span></p>
			<p>Broadly speaking, the tools and services that will be required are <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <span class="No-Break">database platform</span></li>
				<li>The .<span class="No-Break">NET SDK</span></li>
				<li>Extensions to support <span class="No-Break">database development</span></li>
				<li>Extensions to support <span class="No-Break">API development</span></li>
				<li>Extensions to support frontend and <span class="No-Break">Blazor development</span></li>
			</ul>
			<p>All of the above will be packaged up in a <span class="No-Break">dev container.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Configuring the Docker containers</h2>
			<p>The <a id="_idIndexMarker078"/>code for<a id="_idIndexMarker079"/> this first example is available at <a href="https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2">https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2</a>. Either clone the repo or follow through with this <span class="No-Break">example setup.</span></p>
			<p>If you are following along, then start by creating a new folder that will form the root of your project, and then open that folder in VSCode. This is a completely blank canvas, but by the end of this chapter, we will have the skeleton framework for a functioning <span class="No-Break">SaaS application.</span></p>
			<p>Start by creating the following folder and <span class="No-Break">file structure:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B19343_Figure_2.2.jpg" alt="Figure 2.2 – Expected folder structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Expected folder structure</p>
			<p>With the folder structure created, we can now start to fill out these files. We’ll start with the Dockerfile in the <strong class="source-inline">dev-env</strong> folder. This will be used to configure the developer environment and will contain the instructions to install the tools that will be used to build <span class="No-Break">the application.</span></p>
			<h3>Dockerfile</h3>
			<p>Open<a id="_idIndexMarker080"/> <span class="No-Break">the file:</span></p>
			<pre class="source-code">
docker/dev-env/Dockerfile</pre>
			<p>And paste in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
# [Choice] .NET version: 7.0, 6.0, 5.0, 3.1, 6.0-bullseye, 5.0-bullseye, 3.1-bullseye, 6.0-focal, 5.0-focal, 3.1-focal
ARG VARIANT="7.0"
FROM mcr.microsoft.com/vscode/devcontainers/dotnet:0-${VARIANT}
# [Choice] Node.js version: none, lts/*, 16, 14, 12, 10
ARG NODE_VERSION="none"
RUN if [ "${NODE_VERSION}" != "none" ]; then su vscode -c "umask 0002 &amp;&amp; . /usr/local/share/nvm/nvm.sh &amp;&amp; nvm install ${NODE_VERSION} 2&gt;&amp;1"; fi
# [Optional] Uncomment this section to install additional OS packages.
RUN apt-get update &amp;&amp; \
    export DEBIAN_FRONTEND=noninteractive &amp;&amp; \
    apt-get -qy full-upgrade &amp;&amp; \
    apt-get install -qy curl &amp;&amp; \
    apt-get -y install --no-install-recommends vim &amp;&amp; \
    curl -sSL https://get.docker.com/ | sh
RUN dotnet tool install -g dotnet-ef
ENV PATH $PATH:/root/.dotnet/tools
# configure for https
RUN dotnet dev-certs https</pre>
			<p>This<a id="_idIndexMarker081"/> configures the developer environment to facilitate .NET application development. Let’s go through this in detail. The first line determines the version of .NET that will <span class="No-Break">be used:</span></p>
			<pre class="source-code">
ARG VARIANT="7.0"</pre>
			<p>We are using 7.0, which is the latest version at the time <span class="No-Break">of writing.</span></p>
			<p>Next, the version of Node <span class="No-Break">is configured:</span></p>
			<pre class="source-code">
ARG NODE_VERSION="none"</pre>
			<p>No node version is installed. It is often useful to enable node or npm, but they are not needed <span class="No-Break">at present.</span></p>
			<p>The next command is used to install any packages or tools that you may want <span class="No-Break">to use:</span></p>
			<pre class="source-code">
RUN apt-get update &amp;&amp; export DEBIAN_FRONTEND=noninteractive \
&amp;&amp; apt-get -y install --no-install-recommends vim</pre>
			<p>This command updates the package manager and installs the Vim CLI tool, which we will <span class="No-Break">use later.</span></p>
			<p>The above has all been a “standard” configuration of the environment. Next, we will add some bespoke customizations that will allow us to make use of <span class="No-Break">Entity Framework:</span></p>
			<pre class="source-code">
RUN dotnet tool install -g dotnet-ef</pre>
			<p>This command <a id="_idIndexMarker082"/>installs the .NET <strong class="bold">Entity Framework</strong> (<strong class="bold">EF</strong>) tools that we will use to interact with <span class="No-Break">the database.</span></p>
			<p>Finally, we will add the dot net tools to the <strong class="source-inline">path</strong> variable so that we are able to make use of them from the <span class="No-Break">command line:</span></p>
			<pre class="source-code">
ENV PATH $PATH:/root/.dotnet/tools</pre>
			<h3>Sqlserver.env</h3>
			<p>This<a id="_idIndexMarker083"/> file simply sets some environment variables for the SQL Server instance that we will spin up shortly. Copy in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
ACCEPT_EULA="Y"
SA_PASSWORD="Password1"</pre>
			<p>It should go without saying that passwords should never be used in any environment other than this example! Also, note that checking in passwords is extremely bad practice, and should not be done when working on a production application. We will remedy this when we talk about security in <a href="B19343_08.xhtml#_idTextAnchor200"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break"><em class="italic">.</em></span></p>
			<h3>Docker-compose.yaml</h3>
			<p>This is<a id="_idIndexMarker084"/> where things get interesting. Docker Compose is a tool that lets us use multiple containers at the same time. It is a container <span class="No-Break">orchestration tool!</span></p>
			<p>Paste the following into the <span class="No-Break"><strong class="source-inline">docker-compose</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
version: '3.4'
services:
  sql_server:
    container_name: sqlserver
    image: "mcr.microsoft.com/mssql/server:2022-latest"
    ports:
      - "9876:1433"
    volumes:
      - habit-db-volume:/var/lib/mssqlql/data/
    env_file:
      - sqlserver/sqlserver.env
  dev-env:
    container_name: dev-env
    build:
      context: ./dev-env
    volumes:
      - "..:/workspace"
    stdin_open: true # docker run -i
    tty: true # docker run -t
volumes:
  habit-db-volume: null</pre>
			<p>The <a id="_idIndexMarker085"/>preceding commands for Docker Compose tie everything that we have done together. With this script, we can start up a set of Docker containers that allow us to build the API, and the UI, and also interact with a database – all without having to install anything directly on the <span class="No-Break">host machine!</span></p>
			<p>To recap: we have constructed a container called <strong class="source-inline">dev-env</strong> that is specific to our requirements. We have also provisioned a container with an instance of SQL Server 2022 running in it that will serve as our <span class="No-Break">database platform.</span></p>
			<h3>Running the containers</h3>
			<p>That is all of the <a id="_idIndexMarker086"/>Docker-specific configurations. Now we will run the containers and start <span class="No-Break">to interact.</span></p>
			<p>We have built a Docker-based environment – now it’s time to start it up. To do this, open VSCode, open a new terminal, and enter <span class="No-Break">the following:</span></p>
			<pre class="source-code">
cd .\docker\
docker compose up</pre>
			<p>Your terminal should look like <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B19343_Figure_2.3.jpg" alt="Figure 2.3 – Expected output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Expected output</p>
			<p>This can <a id="_idIndexMarker087"/>take a while the first time you run this command, but it is significantly faster in subsequent uses. This command will start up the services that are described in the <strong class="source-inline">docker compose</strong> file. Namely, a SQL Server instance, and the developer environment that we configured with .NET 6.0 and <span class="No-Break">Entity Framework.</span></p>
			<p>With the above, we have created a container with .NET and Entity Framework installed. You can convince yourself that we have actually achieved that by trying the following. Open a new terminal in VSCode and enter the following to <strong class="source-inline">exec</strong> into the <span class="No-Break">dev-env container:</span></p>
			<pre class="source-code">
docker exec -it dev-env /bin/bash</pre>
			<p>The <strong class="source-inline">exec</strong> command allows interactions with an already running container through <span class="No-Break">the terminal.</span></p>
			<p>Running the preceding command will open an interactive terminal in the <strong class="source-inline">dev-env</strong> Docker container where we can check to see whether the .NET and EF tools are correctly installed by typing the following into the console that was opened by the preceding <span class="No-Break"><strong class="source-inline">exec</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
dotnet –-version
dotnet-ef --version</pre>
			<p>The preceding commands should return <span class="No-Break">the following:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B19343_Figure_2.4.jpg" alt="Figure 2.4 – Expected terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Expected terminal output</p>
			<p>Next, we <a id="_idIndexMarker088"/>can do something similar to ensure the SQL Server container is running. Again, open a new terminal in VSCode and enter <span class="No-Break">the following:</span></p>
			<pre class="source-code">
docker exec -it sqlserver /bin/bash</pre>
			<p>Again, this will open another interactive terminal in the <strong class="source-inline">sqlserver</strong> container. You can convince yourself of this by typing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
/opt/mssql-tools/bin/sqlcmd -S localhost -U SA</pre>
			<p>And when prompted, enter the password from the <strong class="source-inline">sqlserver.env</strong> file (<strong class="source-inline">Password1</strong>) to enter the SQL Server command-line interface. You can do simple checks on the database platform, such as checking <span class="No-Break">the version:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B19343_Figure_2.5.jpg" alt="Figure 2.5 – Checking the version"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Checking the version</p>
			<p>At this point, we have done all of the Docker container setups, but the only way that we can interact with our environments is to use the command line, and these days, that is not really acceptable! Thankfully, Visual Studio Code has a neat trick up <span class="No-Break">its sleeve!</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Configuring dev containers in VSCode</h2>
			<p>You <a id="_idIndexMarker089"/>will remember that we installed the <strong class="source-inline">Remote Containers</strong> extension for VSCode. This will allow us to open an instance of VSCode that makes use of the Docker containers that we have set up previously. This will require a little bit of additional configuration, but once set up, it will “just work” for the remainder of <span class="No-Break">the project!</span></p>
			<p>Start by<a id="_idIndexMarker090"/> creating a folder called <strong class="source-inline">dev-env</strong> in the <span class="No-Break">project root:</span></p>
			<pre class="source-code">
.devcontainer</pre>
			<p>This is where VSCode will look to get <span class="No-Break">the configuration.</span></p>
			<p>In this folder, create a file called <strong class="source-inline">devcontainer.json</strong>. Your folder structure should look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B19343_Figure_2.6.jpg" alt="Figure 2.6 – Folder structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Folder structure</p>
			<p>In the <strong class="source-inline">devcontiner.json</strong> file, paste <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
    "name": "SaaS Book",
    "dockerComposeFile": ["../docker/docker-compose.yaml"],
    "service": "dev-env",
    "workspaceFolder": "/workspace",
    "customizations": {
        "vscode": {
            "extensions": [
                "ms-dotnettools.csharp",
                "shardulm94.trailing-spaces",
                "mikestead.dotenv",
                "fernandoescolar.vscode-solution-explorer",
                "jmrog.vscode-nuget-package-manager",
                "patcx.vscode-nuget-gallery",
                "pkief.material-icon-theme",
                "ms-mssql.mssql",
                "humao.rest-client",
                "rangav.vscode-thunder-client",
                "formulahendry.dotnet-test-explorer",
                "kevin-chatham.aspnetcorerazor-html-css-
                  class-completion",
                "syncfusioninc.blazor-vscode-extensions",
                "ms-dotnettools.vscode-dotnet-runtime",
                "ms-dotnettools.blazorwasm-companion"
                ]
          }
    },
    "remoteUser": "root"
}</pre>
			<p>Let’s go through this line by line. The following line of code tells VSCode where to look for the <strong class="source-inline">docker compose</strong> file. This is the file that we created previously, which configures the two <span class="No-Break">Docker containers:</span></p>
			<pre class="source-code">
"dockerComposeFile": ["../docker/docker-compose.yaml"],</pre>
			<p>The following line simply tells VSCode that the container named <strong class="source-inline">dev-env</strong> is the <span class="No-Break">primary container:</span></p>
			<pre class="source-code">
"service": "dev-env",</pre>
			<p>The next line defines a working folder inside the container – more on <span class="No-Break">this shortly:</span></p>
			<pre class="source-code">
"workspaceFolder": "/workspace",</pre>
			<p>The<a id="_idIndexMarker091"/> following is quite clever including the dev container configuration. This section allows us to define which extensions we want to have available to us when we start to work in the dev container. I have listed three extensions to get us started, but this list will grow as the project <span class="No-Break">gains complexity:</span></p>
			<pre class="source-code">
"extensions": [ … ],</pre>
			<p>This is a particularly clever addition from Microsoft because this allows the VSCode configuration to exist as JSON within the project. This file is checked into the repo and moved with the code, meaning that any time a new team member pulls this repo, they will<a id="_idIndexMarker092"/> immediately have a fully configured editor that is specific to <span class="No-Break">the project.</span></p>
			<p>We have all become familiar with <em class="italic">infrastructure as code</em> in recent years. Using a dev container allows you to configure the <em class="italic">developer environment as code</em>. Doing this makes it incredibly easy to onboard new team members, and also means the end of <em class="italic">well, it works on my machine</em>. Using this technique means that everyone is working on a completely consistent platform, regardless of the physical hardware, the operating system choice, or the specific version of .NET <span class="No-Break">or Node.</span></p>
			<p>This is a huge win for developing SaaS applications, given the complex and often arduous route to getting a new team member up <span class="No-Break">and running.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Starting the environment</h2>
			<p>That is the <a id="_idIndexMarker093"/>end of the configuration. I hope that we are all now working on a consistent and predictable platform, and will have no trouble following along with the examples in <span class="No-Break">this book!</span></p>
			<p>To start the environment in Docker, hit <em class="italic">F1</em> to open the command menu, and search for <strong class="source-inline">Remote-Containers: Rebuild and Reopen </strong><span class="No-Break"><strong class="source-inline">in Container</strong></span><span class="No-Break">.</span></p>
			<p>You will see the options in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.7</em> appear. Select the first one and hi<a id="_idTextAnchor067"/>t <em class="italic">Enter</em> <span class="No-Break">to continue.</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B19343_Figure_2.7.jpg" alt="Figure 2.7 – Rebuild and Reopen in Container"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Rebuild and Reopen in Container</p>
			<p>This will close the current instance of VSCode, and reopen a new instance that is operating out of the <strong class="source-inline">dev-env</strong> container that was configured previously. Note that this can take some time the first time you do it, but it is faster in <span class="No-Break">subsequent uses.</span></p>
			<p>You will notice a few differences! First of all, look in the bottom-left corner, and you will see that you are running in a dev container called <span class="No-Break"><strong class="source-inline">SaaS Book</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19343_Icon.jpg" alt=""/>
				</div>
			</div>
			<p>If you click to view the installed extensions, you will see a separate pane that shows the extensions that are installed in this instance of VSCode match the extensions specified in the <strong class="source-inline">devcontainers.json</strong> file. This list will start to grow significantly as the project takes shape throughout the course of <span class="No-Break">this book.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.8</em> shows some of the extensions that are installed<a id="_idTextAnchor068"/> in <span class="No-Break">the container:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19343_Figure_2.8.jpg" alt="Figure 2.8 – Installed extensions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Installed extensions</p>
			<p>If you <a id="_idIndexMarker094"/>open a terminal, you will also notice that this is a Linux environment. You can convince yourself of that by checking the version by running the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
cat /etc/os-release</pre>
			<p>You’ll see the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B19343_Figure_2.9.jpg" alt="Figure 2.9 – Output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Output</p>
			<p>This<a id="_idIndexMarker095"/> shows that we are in a Debian environment. Notice also that we are working in a folder called <strong class="source-inline">workspace</strong>, which is what was configured in the <strong class="source-inline">devcontainer.json</strong> file previously. This is configurable as per <span class="No-Break">your preferences.</span></p>
			<p>To further convince ourselves that this is indeed the <strong class="source-inline">dev-env</strong> container that we configured earlier, you can check the .NET, and the Entity Framework versions again in the terminal <span class="No-Break">in VSCode:</span></p>
			<pre class="source-code">
dotnet –-version
dotnet-ef --version</pre>
			<p>You will see the <span class="No-Break">following output:</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B19343_Figure_2.10.jpg" alt="Figure 2.10 – Terminal output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Terminal output</p>
			<p>That is the environment configured to the extent that is currently required. <span class="No-Break">Let’s recap:</span></p>
			<ul>
				<li>We have a container that has the .NET SDK installed, ready to use to build any kind of .<span class="No-Break">NET applications.</span></li>
				<li>The same container has Entity Framework command-line tools installed so that we can use Entity Framework to build and interact with a database. You will recall that we have installed Entity Framework in <span class="No-Break">the Dockerfile.</span></li>
				<li>We have a separate container running SQL Server, which hosts the database that we can interact with. It is worth noting that we have not installed SQL Server itself on the host machine. We have access to the database via a Docker container. You will see more of this in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> and <a href="B19343_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></li>
			</ul>
			<p>This is now the basis of a developer machine that can be used to build SaaS applications, and we have achieved this without ever having to install any of these tools directly on the machine that you are working on – everything is packaged up in Docker containers. This configuration exists as code, and as such it moves with the repo. Any developer who clones this repository locally will immediately have access to all of the project-specific tools <span class="No-Break">and configurations.</span></p>
			<p>As we progress through this project, this setup will become more complex. It will grow as the project grows. But this is sufficient for now, so we will leave it here and start to piece together a very <span class="No-Break">basic application.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Configuring VSCode</h2>
			<p>At this <a id="_idIndexMarker096"/>early stage, there is not much config required, as we do not really have any application-specific code. However, we’ll lay the groundwork here. Open a terminal, and enter <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">mkdir .vscode; \</strong>
<strong class="bold">cd .vscode; \</strong>
<strong class="bold">touch launch.json; \</strong>
<strong class="bold">touch settings.json; \</strong>
<strong class="bold">touch tasks.json; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>Add the following <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">settings.json</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
{
    "thunder-client.saveToWorkspace": true,
    "thunder-client.workspaceRelativePath": ".thunder-client"
}</pre>
			<p>The preceding <a id="_idIndexMarker097"/>is some config for an HTTP testing tool that we will make use of in <a href="B19343_05.xhtml#_idTextAnchor116"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. We don’t need to put anything into <strong class="source-inline">launch.json</strong> or <span class="No-Break"><strong class="source-inline">tasks.json</strong></span><span class="No-Break"> yet.</span></p>
			<p>That should be all the configuration that is required for the time being, so we can <span class="No-Break">move on.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Exiting the environment</h2>
			<p>Getting <a id="_idIndexMarker098"/>out of the dev container environment and back to your host is straightforward. Simply hit <em class="italic">F1</em> again and search for <strong class="source-inline">Reopen </strong><span class="No-Break"><strong class="source-inline">Folder Locally</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19343_Figure_2.11.jpg" alt="Figure 2.11 – Return to the local workspace"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Return to the local workspace</p>
			<p>This will quickly return you to the host. You will no longer see the indicator in the lower-left corner that you are in a dev container, and the terminal will again connect directly to the <span class="No-Break">host machine.</span></p>
			<p>We have achieved a lot in this section, and we have set ourselves up to start working in a Dockerized environment. This may seem like a bit more work than simply starting to write code on your local machine, but I hope that as we proceed through this book together, you will start to see the value in taking the time to build out this environment right at the start of <span class="No-Break">the project!</span></p>
			<p>In the next section, we’ll really start to build out the application and start to show the power of the <span class="No-Break">preceding techniques.</span></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Building out a sample application</h1>
			<p>In this section, we’ll use the tools that we have just installed to create a very basic wireframe for a SaaS application. At this point, this will simply be a <a id="_idIndexMarker099"/>skeleton application that we can build out much more fully in subsequent chapters. However, this will introduce us to all of the different tools that we will <span class="No-Break">be using.</span></p>
			<p>The sample application that we will build as we work through this book will be an application to track a habit – something that you may like to try to do every day – such as learning a new language, or writing a few pages of a book in order to stay up to date with your publishing deadlines! I hope that this is something that you may be able to make use of after you have finished working through <span class="No-Break">this book!</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>Database technologies</h2>
			<p>We <a id="_idIndexMarker100"/>will start with the database. We are using SQL Server as the database platform – this is a book based on Microsoft technologies, so we will stick with them as much as possible! However, other database platforms <a id="_idIndexMarker101"/>are available, and can easily be used. The Docker-based setup provided above makes it very easy to experiment with other database platforms. You can replace the SQL Server container with a Postgres container and see if everything <span class="No-Break">still works!</span></p>
			<p>The database and the database platform are often a source of some pain when getting developers onboarded and up to speed on a project. This is particularly evident in a SaaS project and is only partly mitigated using the Dockerized <span class="No-Break">solution above.</span></p>
			<p>It is very common these days to <a id="_idIndexMarker102"/>make use of an <strong class="bold">Object Relational Mapper</strong> (<strong class="bold">ORM</strong>) to manage the interactions between the code and the database, and this is a pattern that I will adhere to in this book. I will be using Entity Framework for all interactions initially, but note that when we discuss performance and scaling, I will touch on other techniques that can be used when database performance <span class="No-Break">is paramount.</span></p>
			<p>I will make use of Entity Framework’s “code-first” approach to define the database and populate it with some initial startup data, and I’ll make use of the migrations to keep the database up to date. This will come in very handy in later chapters when we talk about testing with a database, and also when we look at CI/CD and how to update a <span class="No-Break">production database.</span></p>
			<h3>Creating the database</h3>
			<p>Make <a id="_idIndexMarker103"/>sure that you are in the dev container (check the bottom left of VSCode) and open a new terminal. Use the terminal to create a new .NET class library called <strong class="source-inline">GoodHabits.Database</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
dotnet new classlib --name GoodHabits.Database;</pre>
			<p>You should see the folder appear in File Explorer, and the following output in <span class="No-Break">the terminal:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19343_Figure_2.12.jpg" alt="Figure 2.12 – Create the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Create the database</p>
			<p>Before we can use this project to interact with the database, we need to add a few NuGet packages. So, again, in the terminal, enter <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">cd GoodHabits.Database; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Design; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Analyzers; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Relational; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.SqlServer; \</strong>
<strong class="bold">dotnet add package Microsoft.EntityFrameworkCore.Tools; \</strong>
<strong class="bold">touch GoodHabitsDbContext.cs; \</strong>
<strong class="bold">rm Class1.cs; \</strong>
<strong class="bold">touch SeedData.cs; \</strong>
<strong class="bold">mkdir Entities; \</strong>
<strong class="bold">cd Entities; \</strong>
<strong class="bold">touch Habit.cs; \</strong>
<strong class="bold">cd ..;</strong></pre>
			<p>With the <a id="_idIndexMarker104"/>preceding, we have instructed the .NET CLI to add all of the required NuGet packages to facilitate interactions with the database. We have also added a <strong class="source-inline">GoodHabitsDbContext</strong> class, a <strong class="source-inline">SeedData</strong> class, and a <strong class="source-inline">Habit</strong> class. We’ll now add some basic setup into these three files that will give us a foundation to work on in <span class="No-Break">later chapters.</span></p>
			<p>Enter the following code into the <span class="No-Break"><strong class="source-inline">Habits.cs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
namespace GoodHabits.Database.Entities;
public class Habit
{
  public int Id { get; set; }
  public string Name { get; set; } = default!;
  public string Description { get; set; } = default!;
}</pre>
			<p>The above is a very straightforward entity class representing a habit that a user of the app may want to embed into their <span class="No-Break">day-to-day lives.</span></p>
			<p>Next, add some dummy data, by adding the following code to the <span class="No-Break"><strong class="source-inline">SeedData.cs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
public static class SeedData
{
    public static void Seed(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity&lt;Habit&gt;().HasData(
            new Habit { Id = 100, Name = "Learn French",
              Description = "Become a francophone" },
            new Habit { Id = 101, Name = "Run a marathon",
              Description = "Get really fit" },
            new Habit { Id = 102, Name = "Write every day",
              Description = "Finish your book project"  }
        );
    }
}</pre>
			<p>Now create a <strong class="source-inline">DbContext</strong> by entering the following code into the <span class="No-Break"><strong class="source-inline">GoodHabitsDbContext.cs</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
using GoodHabits.Database.Entities;
using Microsoft.EntityFrameworkCore;
namespace GoodHabits.Database;
public class GoodHabitsDbContext : DbContext
{
    public DbSet&lt;Habit&gt;? Habits { get; set; }
    protected override void
      OnConfiguring(DbContextOptionsBuilder options)
       =&gt; options.UseSqlServer("Server=
         sqlserver;Database=GoodHabitsDatabase;User
         Id=sa;Password=Password1 ;Integrated
         Security=false;TrustServerCertificate=true;");
    protected override void OnModelCreating(ModelBuilder
      modelBuilder) =&gt; SeedData.Seed(modelBuilder);
}</pre>
			<p>This <a id="_idIndexMarker105"/>does a few things. Firstly, we define a <strong class="source-inline">DbSet</strong>. This is mapped onto a table in <span class="No-Break">the database.</span></p>
			<p>Next, we hardcode the database connection string. Of course, it is bad practice to hardcode the connection string, and doubly bad to have the password there in plain text. We will correct these errors in <a href="B19343_03.xhtml#_idTextAnchor082"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, but this is sufficient to prove that we are connected to <span class="No-Break">the database.</span></p>
			<p>With this setup done, we can test this out and see whether we can migrate this information into the SQL Server database that we have running in a second <span class="No-Break">Docker container.</span></p>
			<p>To do this, let’s start by using Entity Framework to create an initial migration. Enter the following into the terminal to generate the <span class="No-Break">initial migration:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet-ef migrations add InitialSetup;</strong></pre>
			<p>You will see a <strong class="source-inline">Migrations</strong> folder has appeared in File Explorer with the <strong class="source-inline">InitialSetup</strong> migration modeled as a class. You don’t have to worry too much about this at present, but it’s worth taking the time to have a look at <span class="No-Break">this class.</span></p>
			<p>Then <a id="_idIndexMarker106"/>enter the following to deploy the migration to the SQL <span class="No-Break">Server database:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet-ef database update;</strong></pre>
			<p>This sends the migration to <span class="No-Break">the database.</span></p>
			<p>And that is it for now. We have configured a basic database using Entity Framework in “code-first” mode, and have sent the first migration to <span class="No-Break">the database.</span></p>
			<h3>How do we know that this has worked?</h3>
			<p>It’s one thing<a id="_idIndexMarker107"/> to understand that the command has been executed successfully, but seeing is believing, and we need to dip into the database to really be sure that all of this is actually working <span class="No-Break">as expected.</span></p>
			<p>You will notice that when we defined the extensions that we wanted to be installed in the dev container, we specified the following extension should <span class="No-Break">be included:</span></p>
			<pre class="source-code">
"ms-mssql.mssql",</pre>
			<p>This is an extension for VSCode from Microsoft that allows us to query a SQL server database directly from VSCode. Click on the extension and we will add a new connection, with the following <span class="No-Break">information added:</span></p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Notes</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Hostname</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">sqlerver</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">This is the name of the Docker container that we configured to run the SQL Server </em><span class="No-Break"><em class="italic" lang="en-US" xml:lang="en-US">2022 instance</em></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Database <span class="No-Break">to connect</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">GoodHabitsDatabase</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">This was defined i</em><em class="italic">n</em><em class="italic" lang="en-US" xml:lang="en-US"> the </em><strong class="source-inline">DbContext</strong><em class="italic" lang="en-US" xml:lang="en-US"> class on the </em><span class="No-Break"><em class="italic" lang="en-US" xml:lang="en-US">connection string</em></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Authentication Type</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">SQL Login</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">User name</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">sa</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Password</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">Password1</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic" lang="en-US" xml:lang="en-US">Defined </em><span class="No-Break"><em class="italic" lang="en-US" xml:lang="en-US">in</em></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">sqlserver.env</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Save Password</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">Yes</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Display Name</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline" lang="en-US" xml:lang="en-US">GoodHabits</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p>You may need to okay a <span class="No-Break">security popup.</span></p>
			<p>With the <a id="_idIndexMarker108"/>above correctly entered, you should now get a view of the database, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19343_Figure_2.13.jpg" alt="Figure 2.13 – Browse the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – Browse the database</p>
			<p>You will note that the <strong class="source-inline">Habits</strong> table that we have defined as a <strong class="source-inline">DbSet</strong> in the <strong class="source-inline">DbContext</strong> file has been successfully migrated to the SQL Server database. You can right-click on the table named <strong class="source-inline">dbo.Habits</strong> and then click on <strong class="bold">Select to 1000</strong> to see <span class="No-Break">the contents.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19343_Figure_2.14.jpg" alt="Figure 2.14 – Data stored in the database"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Data stored in the database</p>
			<p>Again, you <a id="_idIndexMarker109"/>will see that the information that we have added in the <strong class="source-inline">DbContext</strong> file is present and correct in <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>API technology</h2>
			<p>Next, we will<a id="_idIndexMarker110"/> move on to the API. The purpose <a id="_idIndexMarker111"/>of the API is to facilitate the storage and retrieval of information from the database by the users and also to do any required <span class="No-Break">data processing.</span></p>
			<p>There are many different technologies that are available with which to build an API. This book is focused on Microsoft technologies, so we will use the .NET Web API framework and the C# language. However, the tools and techniques described could easily be adapted to make use of <span class="No-Break">different technologies.</span></p>
			<p>Additionally, there are many different ideas about how best to structure an API, and there is no <em class="italic">one size fits all</em> approach that will work with every project out there. I have decided that I will use the RESTful paradigm for the examples in this book, but again, the concepts and ideas that are presented should copy over very well if your project is using some other structure, such <span class="No-Break">as GraphQL.</span></p>
			<p>The nature of a SaaS application is such that there are a huge number of choices to make when the project is getting started. This remains true even when the project is a demo application in <span class="No-Break">a book!</span></p>
			<h3>Creating the HabitService API</h3>
			<p>Making sure that<a id="_idIndexMarker112"/> you are in the dev container environment, and are in the root of the project (the <strong class="source-inline">workspace</strong> folder), create a new <strong class="source-inline">webapi</strong> project with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet new webapi --name GoodHabits.HabitService; \
cd GoodHabits.HabitService; \
dotnet add reference ../GoodHabits.Database/GoodHabits.Database.csproj; \
dotnet add package Microsoft.EntityFrameworkCore.Design; \
cd ..;</pre>
			<p>The .NET CLI does a lot of work setting up the API. We need to make a change to the <strong class="source-inline">launchSettings.json</strong> file. Open the <strong class="source-inline">Properties</strong> folder and replace the default launch settings with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
  "$schema":
    "https://json.schemastore.org/launchsettings.json",
  "profiles": {
    "HabitService": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5100",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}</pre>
			<p>The most important thing to note is that we will be running the <strong class="source-inline">HabitService</strong> on port <strong class="source-inline">5100</strong>. This is important to keep track of when we start to look at microservices in <a href="B19343_06.xhtml#_idTextAnchor140"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
			<p>Out of the box, the default web API comes with the Weather API, which you can take a look at to get an idea of how these endpoints are configured. We can test this by entering the following into <span class="No-Break">the terminal:</span></p>
			<pre class="source-code">
dotnet run</pre>
			<p>This will start the application running on the port that is specified in <strong class="source-inline">launchSettings.json</strong> – port <strong class="source-inline">5100</strong> in <span class="No-Break">this case.</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19343_Figure_2.15.jpg" alt="Figure 2.15 – Console output indicating success"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Console output indicating success</p>
			<p>You can check to see whether the application is running by going to the following URL in your browser (remember to check the port <span class="No-Break">number!): </span><a href="http://127.0.0.1:5100/swagger/index.html"><span class="No-Break">http://127.0.0.1:5100/swagger/index.html</span></a></p>
			<p>Note that you may get some HTTPS warnings from your browser, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B19343_Figure_2.16.jpg" alt="Figure 2.16 – The GoodHabits API"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – The GoodHabits API</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>User interface technology</h2>
			<p>Finally, we <a id="_idIndexMarker113"/>need a user interface <a id="_idIndexMarker114"/>on which to display <span class="No-Break">the information.</span></p>
			<p>As I have pointed out for both the database and the API, there are many different UI technologies, and the underlying tools and techniques that you will learn in this book can be applied to any one of them. Often, the best technology to use in any given situation is the one that you are most <span class="No-Break">comfortable with.</span></p>
			<p>This is a Microsoft-centric book aimed at existing .NET developers, so I will use Blazor for the examples that are <a id="_idIndexMarker115"/>provided. If you prefer Angular, React, Vue, or any of the other millions of UI frameworks that are out there, please don’t be put off. In fact, adapting these examples <a id="_idIndexMarker116"/>to work with your UI of choice would be an excellent exercise to further your understanding of the concepts that we will cover in <span class="No-Break">this book.</span></p>
			<h3>Creating the UI</h3>
			<p>Creating a <a id="_idIndexMarker117"/>simple demo Blazor UI is straightforward with the CLI tools provided by Microsoft. Enter the following commands into the terminal to create <span class="No-Break">the UI:</span></p>
			<pre class="source-code">
<strong class="bold">dotnet new blazorwasm -o GoodHabits.Client;</strong></pre>
			<p>This follows the same pattern that we used to create the HabitServer project. And, like the HabitServer project, we will need to modify the launch configuration in <strong class="source-inline">launchSettings.json</strong>. Again, look in the <strong class="source-inline">Properties</strong> folder, and overwrite the contents <span class="No-Break">with this:</span></p>
			<pre class="source-code">
{
  "profiles": {
    "GoodHabitsClient": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "inspectUri": "{wsProtocol}://{url.hostname}:
        {url.port}/_framework/debug/ws-
        proxy?browser={browserInspectUri}",
      "applicationUrl": "http://localhost:5900",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}</pre>
			<p>Again, take <a id="_idIndexMarker118"/>note of the port that the client is running on. We will use <strong class="source-inline">5900</strong> for <span class="No-Break">the client.</span></p>
			<p>With the config done, you can now start the client by typing <strong class="source-inline">dotnet run</strong> into <span class="No-Break">the console.</span></p>
			<p>Again, you will see that the <strong class="source-inline">Client</strong> app is running on the ports specified in <strong class="source-inline">launchSettings.json</strong>, which should be <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">5900</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B19343_Figure_2.17.jpg" alt="Figure 2.17 – Console output indicating success"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Console output indicating success</p>
			<p>Again, as per the API, you can follow this link in your browser to see the Blazor <span class="No-Break">app running:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B19343_Figure_2.18.jpg" alt="Figure 2.18 – Hello, world!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Hello, world!</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>Starting the application</h2>
			<p>Currently, we only <a id="_idIndexMarker119"/>have two projects to run, the HabitService API and the Blazor client. So, we can fairly easily start the whole project by typing <strong class="source-inline">dotnet run</strong> twice. As we build on this application, it will become more and more complex, and harder to run in this way. So, we’ll create build and launch configurations to tell VSCode how to start <span class="No-Break">the application.</span></p>
			<p>We have already created the config files for this in the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">vscode</strong></span><span class="No-Break"> folder.</span></p>
			<p>Start by opening <strong class="source-inline">tasks.json</strong>, and copy in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build-client",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.Client/
                  GoodHabits.Client.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
        {
            "label": "build-habit-service",
            "type": "shell",
            "command": "dotnet",
            "args": [
                "build",
                "${workspaceFolder}/GoodHabits.HabitService
                  /GoodHabits.HabitService.csproj"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            }
        },
    ]
}</pre>
			<p>You can see in <a id="_idIndexMarker120"/>the above JSON that two tasks are defined to build the client and the <span class="No-Break">habit service.</span></p>
			<p>Next, modify <strong class="source-inline">launch.json</strong> by adding<a id="_idIndexMarker121"/> the following <span class="No-Break">JSON config:</span></p>
			<pre class="source-code">
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "RunClient",
            "type": "blazorwasm",
            "request": "launch",
            "preLaunchTask": "build-client",
            "cwd": "${workspaceFolder}/GoodHabits.Client",
            "url": "https://localhost:5900"
        },
        {
            "name": "RunHabitService",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build-habit-service",
            "program": "${workspaceFolder}/
              GoodHabits.HabitService/bin/Debug/net7.0/
              GoodHabits.HabitService.dll",
            "args": [],
            "cwd":
              "${workspaceFolder}/GoodHabits.HabitService",
            "stopAtEntry": false,
            "console": "integratedTerminal"
        },
    ],
    "compounds": [
        {
            "name": "Run All",
            "configurations": [
                "RunHabitService",
                "RunClient"
            ]
        }
    ]
}</pre>
			<p>Again, you <a id="_idIndexMarker122"/>can see that two configurations are added to run the individual project. You can also see nearer the bottom that there is a <strong class="source-inline">compounds launch</strong> command set to run all of <span class="No-Break">the projects.</span></p>
			<p>You can test this out by pressing <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">D</em> to enter the <strong class="bold">Run and Debug</strong> menu, selecting <strong class="bold">Run</strong> All from the dropdown, and pressing the <span class="No-Break">play button.</span></p>
			<p>You will see that this starts the API and the client at the same time. This will be very handy as the number of projects starts <span class="No-Break">to grow!</span></p>
			<p>Note that you can also hit <em class="italic">F5</em> to start the application <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor076"/>Adding a solution file</h2>
			<p>There is one<a id="_idIndexMarker123"/> last small piece of setup to do before we move on to really building out the application, and that is to add a solution file. This is not strictly necessary, but it is commonly done when working with .NET projects and will allow us to easily build, clean, and test the projects with a <span class="No-Break">single command.</span></p>
			<p>To add a solution file, simply navigate to the project root, and run <span class="No-Break">the following:</span></p>
			<pre class="source-code">
dotnet new sln --name GoodHabits; \
dotnet sln add ./GoodHabits.Client/GoodHabits.Client.csproj; \
dotnet sln add ./GoodHabits.HabitService/GoodHabits.HabitService.csproj; \
dotnet sln add ./GoodHabits.Database/GoodHabits.Database.csproj;</pre>
			<p>This simply <a id="_idIndexMarker124"/>adds a solution file and references the three projects that we <span class="No-Break">have created.</span></p>
			<p>And that is the final piece of setup work to do – now we can progress to building <span class="No-Break">the application.</span></p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor077"/>Where do we go from here?</h1>
			<p>We have done a lot of work in this chapter, but we haven’t really started to build the application yet. We have instead focused on choosing the tools that we will use and building a development environment around those tools. We now have the outline of a SaaS application that we can continue to work with as we move through <span class="No-Break">this book.</span></p>
			<p>Taking the time at the start of the project to select the correct tools is an important step of any SaaS project, and it should not <span class="No-Break">be skipped.</span></p>
			<p>Being successful in developing any application requires that some thought is put into the technologies and frameworks that will be used, and also the tooling that will be used. In this chapter, we have set ourselves up very well to be able to get our hands dirty and try things out as we explore the concepts that are required to build a <span class="No-Break">SaaS application.</span></p>
			<p>The following chapters will start to introduce a lot more SaaS-specific considerations, and we will use this outline app to <span class="No-Break">demonstrate them.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor078"/>Summary</h1>
			<p>In this chapter, we have briefly touched on a lot of different tools, topics, and techniques. This is the nature of developing SaaS applications – please don’t feel overwhelmed! To get started, we installed the tools that we need to work with, namely Docker Desktop and Visual Studio Code. This is quite a light set of tools for a SaaS project. But as you have seen, we used Docker to wrap up the developer environment. We learned about dev containers, and how they significantly streamline project setup for complex projects, such as a SaaS application, and we then configured a dev container and learned how to work in <span class="No-Break">that environment.</span></p>
			<p>With the core of the environment set up, we set up a database and populated it with some data using Entity Framework, then made the data available through an API, and finally surfaced the data on a <span class="No-Break">Blazor UI!</span></p>
			<p>With all of the above, we have configured all of the individual parts required to build up a fully featured SaaS application. Read on, and we will do <span class="No-Break">just that!</span></p>
			<p>In the next chapter, you will learn about a core part of building SaaS applications, and that is multi-tenancy. We will cover what this is and why it is so important, and start to think about how we will implement it in our <span class="No-Break">sample application.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor079"/>Further reading</h1>
			<ul>
				<li>Developing inside a <span class="No-Break">Container: </span><a href="https://code.visualstudio.com/docs/devcontainers/containers"><span class="No-Break">https://code.visualstudio.com/docs/devcontainers/containers</span></a></li>
				<li>Entity Framework Dev Environment in <span class="No-Break">Docker: </span><a href="https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f"><span class="No-Break">https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f</span></a></li>
				<li>.NET Development in Docker with Dev <span class="No-Break">Containers: </span><a href="https://itnext.io/net-development-in-docker-6509d8a5077b"><span class="No-Break">https://itnext.io/net-development-in-docker-6509d8a5077b</span></a></li>
				<li>Blazor Tutorial - Build your first Blazor <span class="No-Break">app: </span><a href="https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro"><span class="No-Break">https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro</span></a></li>
				<li>Tutorial: Create a web API with ASP.NET <span class="No-Break">Core: </span><a href="https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&amp;tabs=visual-studio"><span class="No-Break">https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&amp;tabs=visual-studio</span></a></li>
			</ul>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor080"/>Questions</h1>
			<ol>
				<li>What are the advantages of using <span class="No-Break">dev containers?</span></li>
				<li>How were we able to use SQL Server without having to install it on our <span class="No-Break">developer machines?</span></li>
				<li>What are the HTTP verbs commonly associated with <span class="No-Break">RESTful APIs?</span></li>
				<li>What are the benefits of using <span class="No-Break">Entity Framework?</span></li>
			</ol>
			<p>We have covered a lot in this chapter! Don’t worry if the answers to the above questions are not 100% clear at this stage – we will expand on all of them in the <span class="No-Break">coming chapters.</span></p>
		</div>
	

		<div id="_idContainer032" class="Content">
			<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Part 2: Building the Backend</h1>
			<p>This section covers all things backend related, starting with the database and building up to the API layer. This section also introduces the topics of multi-tenancy and microservices, both of which are very important for developing <span class="No-Break">SaaS applications.</span></p>
			<p>This section has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B19343_03.xhtml#_idTextAnchor082"><em class="italic">Chapter 3</em></a>, <em class="italic">What Is Multi-Tenancy, and Why Is It Important in SaaS Applications?</em></li>
				<li><a href="B19343_04.xhtml#_idTextAnchor102"><em class="italic">Chapter 4</em></a>, <em class="italic">Building Databases and Planning for Data-Rich Applications</em></li>
				<li><a href="B19343_05.xhtml#_idTextAnchor116"><em class="italic">Chapter 5</em></a>, <em class="italic">Building R</em><em class="italic">EST</em><em class="italic">ful APIs</em></li>
				<li><a href="B19343_06.xhtml#_idTextAnchor140"><em class="italic">Chapter 6</em></a>, <em class="italic">Microservices for SaaS Applications</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer033" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer034">
			</div>
		</div>
	</body></html>