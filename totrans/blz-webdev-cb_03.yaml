- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Taking Control of Event Handling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌控事件处理
- en: In this chapter, we’ll dive into the world of event handling within Blazor applications.
    An **event** is a fundamental building block that signifies an action within the
    browser, such as clicks, inputs, or page loads. Events allow developers to execute
    specific code upon user interactions – creating an interactive and dynamic user
    experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Blazor 应用程序中的事件处理世界。**事件** 是一个基本构建块，表示浏览器内的动作，如点击、输入或页面加载。事件允许开发者在用户交互时执行特定代码，从而创建一个交互性和动态的用户体验。
- en: We’ll start by exploring how to hook into event delegates, laying the foundation
    for event management. Next, we’ll discuss delegating responsibilities using **EventCallback**
    and lambda expressions that increase flexibility in event handling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何钩入事件委托，为事件管理打下基础。接下来，我们将讨论使用 **EventCallback** 和 lambda 表达式进行责任委托，这增加了事件处理中的灵活性。
- en: We’ll also cover essential strategies for controlling event propagation and
    preventing the triggering of default events. These skills are vital for creating
    intuitive user interfaces where you have complete control over user interactions.
    Furthermore, we introduce the concept of custom events, expanding the possibilities
    for an **event-driven** application design.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涵盖控制事件传播和防止触发默认事件的必要策略。这些技能对于创建直观的用户界面，其中你可以完全控制用户交互至关重要。此外，我们还将介绍自定义事件的概念，扩展了
    **事件驱动** 应用程序设计的可能性。
- en: A key focus will be on understanding how events trigger rendering in Blazor.
    This understanding is crucial for optimizing application performance and ensuring
    a seamless user experience. By the end of this chapter, you’ll have a thorough
    understanding of event handling in Blazor and have gained the practical skills
    to apply these concepts effectively in your web development projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的重点将在于理解事件如何在 Blazor 中触发渲染。这种理解对于优化应用程序性能和确保无缝的用户体验至关重要。到本章结束时，你将深入理解 Blazor
    的事件处理，并掌握将这些概念有效地应用于你的 Web 开发项目的实践技能。
- en: 'Here’s the list of recipes we’ll cover in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将在本章中涵盖的菜谱列表：
- en: Hooking into event delegates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩入事件委托
- en: Delegating with lambda expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式进行委托
- en: Delegating with **EventCallback**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **EventCallback** 进行委托
- en: Preventing default event actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止默认事件行为
- en: Controlling event propagation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制事件传播
- en: Introducing custom events
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍自定义事件
- en: Handling long-running events
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理长时间运行的事件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The aim of this chapter is to keep the examples straightforward and focus on
    the principles of event handling in Blazor. With that said, you won’t need any
    additional tools, just these basics:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是使示例保持简单，并专注于 Blazor 事件处理的原则。换句话说，你不需要任何额外的工具，只需这些基础知识：
- en: A modern IDE (that supports Blazor development)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 Blazor 开发的现代 IDE
- en: .NET 9 installed on your development machine
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的开发机器上安装 .NET 9
- en: A modern web browser (that supports WebAssembly)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持 WebAssembly 的现代网络浏览器
- en: A Blazor project (where you’ll write code as you go along)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Blazor 项目（你将在其中编写代码）
- en: 'All the code examples (and data samples) that you’ll see can be found in a
    dedicated GitHub repository at: [https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03)
    . In each recipe that needs any samples, I will also point you to the directory
    where you can find them.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的全部代码示例（和数据样本）都可以在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03](https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/BlazorCookbook.App.Client/Chapters/Chapter03)
    。在需要任何样本的每个菜谱中，我还会指导你找到它们的目录。
- en: Hooking into event delegates
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钩入事件委托
- en: UI events are the cornerstone of user interaction on the web – signaling every
    click, scroll, or keyboard press and enabling you to craft an interactive application.
    An event delegate acts as a bridge between the browser and your code. Each user
    interaction triggers a designated handler that executes a predefined action. In
    this recipe, we will dive into the mechanics of event delegates, illustrating
    how they are detected and managed within a Blazor application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: UI事件是网络用户交互的基础——标记每一次点击、滚动或键盘按键，并使您能够构建一个交互式应用程序。事件委托充当浏览器和您的代码之间的桥梁。每次用户交互都会触发一个指定的处理程序，执行预定义的操作。在本例中，我们将深入了解事件委托的机制，展示它们如何在Blazor应用程序中被检测和管理。
- en: Let’s create a page, where users can display and hide a list of tickets by clicking
    a button.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个页面，用户可以通过点击按钮来显示和隐藏一系列票据。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you implement a clickable button, do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现可点击按钮之前，执行以下操作：
- en: Create a **Chapter03** / **Recipe01** directory – this will be your working
    directory
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建**Chapter03** / **Recipe01**目录——这将成为您的工作目录
- en: Copy **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter03** / **Data**目录复制**Ticket**和**Tickets**样本文件
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement a basic event delegate hook:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现基本的事件委托钩子：
- en: 'Create a new routable **TicketManager** component that renders in **InteractiveWebAssembly**
    mode:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的可路由的**TicketManager**组件，以**InteractiveWebAssembly**模式渲染：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the **@code** section to your **TicketManager** component. Declare a **ShowTickets**
    property of type **bool** that will determine the visibility of the ticket list:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的**TicketManager**组件中添加**@code**部分。声明一个类型为**bool**的**ShowTickets**属性，该属性将决定票据列表的可见性：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, still inside the **@code** block, implement a method to toggle
    the **ShowTickets** property to change the ticket list’s visibility:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，仍然在**@code**块内部，实现一个方法来切换**ShowTickets**属性以改变票据列表的可见性：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the markup area of the **TicketManager** component, introduce a button that
    leverages the **ToggleTickets()** method and allows the user to update the UI
    accordingly:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketManager**组件的标记区域中，引入一个按钮，该按钮利用**ToggleTickets()**方法并允许用户相应地更新UI：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Below the button, based on the current value of the **ShowTickets** property,
    conditionally skip displaying the list of tickets or render the horizontal separator,
    indicating where the tickets area starts:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮下方，根据**ShowTickets**属性的当前值，有条件地跳过显示票据列表或渲染水平分隔符，指示票据区域开始的位置：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Under the horizontal separator, render the list of tickets, utilizing the **Tickets.All**
    collection, from the copied sample data, as your data source:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在水平分隔符下方，渲染票据列表，利用从复制的样本数据中获取的**Tickets.All**集合作为数据源：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We begin the implementation by creating a routable **TicketManager** component,
    as outlined in *step 1* . We declare the navigable path with the **@page** directive.
    We also declare an interactive render mode as we will need our button to be actionable.
    Next, in *step 2* , we introduce a backing **ShowTickets** property. This property
    serves as a flag indicating the current visibility state of the ticket list –
    either displayed or hidden. Then, in *step 3* , we introduce a **ToggleTickets()**
    method designed to toggle the **ShowTickets** property.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始实现的过程是创建一个可路由的**TicketManager**组件，如*步骤1*所述。我们使用**@page**指令声明可导航路径。我们还声明了一个交互式渲染模式，因为我们需要我们的按钮是可操作的。接下来，在*步骤2*中，我们引入了一个后备的**ShowTickets**属性。此属性作为标志，指示票据列表当前的可见状态——要么显示，要么隐藏。然后，在*步骤3*中，我们引入了一个**ToggleTickets()**方法，用于切换**ShowTickets**属性。
- en: We implement the core of interactivity in *step 4* by hooking into the event
    callback mechanism of Blazor. We add a button in the component’s markup to give
    users the power to control the display state of the ticket list. With **@onclick**
    , we can trigger our **ToggleTickets()** method when an **onclick** event occurs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过挂钩Blazor的事件回调机制，在*步骤4*中实现了交互的核心。我们在组件的标记中添加了一个按钮，使用户能够控制票据列表的显示状态。使用**@onclick**，我们可以在发生**onclick**事件时触发我们的**ToggleTickets()**方法。
- en: In *step 5* , we check the value of the **ShowTickets** property and decide
    whether to skip rendering the ticket list entirely. For cases when we render the
    list, we add a **<hr />** tag to clearly indicate where the tickets area starts.
    In *step 6* , we iterate over the **Tickets.All** sample collection and render
    all available ticket titles in a flexible **div** container. With this setup,
    **TicketManager** reacts to user interactions and either renders or hides the
    ticket list, as dictated by the current value of the **ShowTickets** property.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 5* 中，我们检查 **ShowTickets** 属性的值，并决定是否完全跳过渲染票据列表。在渲染列表的情况下，我们添加一个 **<hr
    />** 标签，以清楚地指示票据区域开始的位置。在 *步骤 6* 中，我们遍历 **Tickets.All** 样本集合，并在灵活的 **div** 容器中渲染所有可用的票据标题。通过这种设置，**TicketManager**
    会根据 **ShowTickets** 属性的当前值响应用户交互，并相应地渲染或隐藏票据列表。
- en: There’s more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Blazor offers seamless integration with **onclick** , **ondrag** , **oncopy**
    , and other HTML events you’re already familiar with, allowing for dynamic and
    interactive web application development. By prefixing the event name with the
    **@** symbol, you signal to Blazor that you’re employing a Blazor-specific event
    rather than a standard HTML event. This distinction is crucial for harnessing
    the full power of Blazor’s event system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 提供了与 **onclick**、**ondrag**、**oncopy** 以及您已经熟悉的其他 HTML 事件的无缝集成，允许进行动态和交互式
    Web 应用程序开发。通过在事件名称前加上 **@** 符号，您向 Blazor 表明您正在使用 Blazor 特定的事件而不是标准 HTML 事件。这种区别对于充分利用
    Blazor 事件系统的全部功能至关重要。
- en: One of the key advantages of using Blazor events is their ability to update
    the DOM in real time. Blazor employs a native **diffing algorithm** , which calculates
    precisely which parts of the DOM have changed and updates only those parts. This
    results in a significantly smaller payload when communicating with the server
    and faster rendering times regardless of the selected render mode.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Blazor 事件的一个主要优势是它们能够实时更新 DOM。Blazor 使用一个本地的 **diffing 算法**，该算法精确地计算出 DOM
    中哪些部分已更改，并仅更新这些部分。这导致与服务器通信时的负载显著减小，并且无论选择的渲染模式如何，渲染时间都会更快。
- en: 'It’s important to note that Blazor rendering is typically triggered only upon
    the initial render of a component or when you explicitly invoke the **StateHasChanged()**
    lifecycle method. If we explore deeper, HTML event counterparts in Blazor are
    actually instances of **EventCallback<T>** (complete with event arguments). A
    closer look at the **EventCallback** implementation reveals that it invokes the
    **HandleEventAsync()** method of the **Receiver** object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，Blazor 渲染通常仅在组件的初始渲染时触发，或者当您显式调用 **StateHasChanged()** 生命周期方法时。如果我们进一步探讨，Blazor
    中的 HTML 事件对应项实际上是 **EventCallback<T>** 的实例（包括事件参数）。仔细查看 **EventCallback** 的实现可以发现，它调用
    **Receiver** 对象的 **HandleEventAsync()** 方法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In most cases, our receiver inherits from **ComponentBase** . Intriguingly,
    the **ComponentBase.HandleEventAsync()** method automatically invokes **StateHasChanged()**
    . As a result, the component’s state updates without requiring manual intervention:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们的接收器继承自 **ComponentBase**。有趣的是，**ComponentBase.HandleEventAsync()**
    方法会自动调用 **StateHasChanged()**。因此，组件的状态更新无需手动干预：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Delegating with lambda expressions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式进行委托
- en: In this recipe, we will explore the power of **lambda expressions** in .NET
    and their pivotal role in Blazor event handling. In the simplest terms, a lambda
    expression is an anonymous method that follows a specific syntax. These expressions
    are a cornerstone of functional programming in .NET and offer a streamlined approach
    to writing inline delegate implementations. When it comes to Blazor, delegating
    with lambda expressions becomes particularly advantageous. They come in handy
    for defining event handlers and callbacks directly within the markup. They also
    enable you to intercept incoming parameters and a current operational context.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨 .NET 中 lambda 表达式的力量及其在 Blazor 事件处理中的关键作用。最简单的说法，lambda 表达式是一个遵循特定语法的匿名方法。这些表达式是
    .NET 中函数式编程的基石，并提供了一种简化的方法来编写内联委托实现。当涉及到 Blazor 时，使用 lambda 表达式进行委托变得特别有利。它们在定义标记内的直接事件处理程序和回调时非常有用。它们还使您能够拦截传入的参数和当前的运行上下文。
- en: Let’s leverage lambda expressions and add a few more actions to the tickets
    list, allowing us to modify the state of a given ticket.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用 lambda 表达式并给票据列表添加更多操作，以便我们能够修改指定票据的状态。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Before you dive into delegating with lambda expressions, do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用lambda表达式进行委托之前，请执行以下操作：
- en: Create a **Chapter03** / **Recipe02** directory – this will be your working
    directory
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter03** / **Recipe02**目录——这将是你的工作目录
- en: Copy the **TicketManager** component from the *Hooking into event delegates*
    recipe or from the **Chapter03** / **Recipe01** directory in the GitHub repository
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*钩入事件委托*食谱或从GitHub仓库中的**Chapter03** / **Recipe01**目录复制**TicketManager**组件
- en: Copy **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter03** / **Data**目录复制**Ticket**和**Tickets**样本文件
- en: How to do it…
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to see the power of delegating with lambda expressions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查看使用lambda表达式进行委托的强大功能：
- en: 'Navigate to the **@code** block of **TicketManager** and, below the existing
    code, initialize an object of type **Ticket** to store the details of the currently
    selected ticket:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**的**@code**代码块，并在现有代码下方初始化一个**Ticket**类型的对象来存储当前选中票的详细信息：
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below, still within the **@code** block, implement a **Show()** method that
    enables setting the value of the currently selected ticket:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的**@code**代码块中，实现一个**Show()**方法，以便设置当前选中票的值：
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Jump to the **TicketManager** markup and extend the rendering of ticket details
    by adding two action buttons below the **Title** section and attaching their actions
    with lambda expressions:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**TicketManager**的标记，通过在**Title**部分下方添加两个操作按钮并使用lambda表达式附加其操作来扩展票详情的渲染：
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Below the loop rendering ticket details, check whether the user has already
    set the **SelectedTicket** value and conditionally skip the specific ticket details
    rendering:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环渲染票详情下方，检查用户是否已经设置了**SelectedTicket**值，并根据条件跳过特定票详情的渲染：
- en: '[PRE11]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the case where the **SelectedTicket** variable has a value, render the
    ticket title, price, and availability. Ensure that this section only becomes visible
    when the value of **SelectedTicket** is available:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**SelectedTicket**变量有值的情况，渲染票标题、价格和可用性。确保此部分仅在**SelectedTicket**的值可用时可见：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **@code** block of **TicketManager** and initialize
    a **SelectedTicket** variable that will hold a reference to the currently selected
    ticket. Next, in *step 2* , we implement a **Show()** method, which accepts **Ticket**
    as a parameter. The singular responsibility of the **Show()** method is to update
    the **SelectedTicket** reference.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们导航到**TicketManager**的**@code**代码块，并初始化一个**SelectedTicket**变量，该变量将保存对当前选中票的引用。接下来，在*步骤2*中，我们实现一个**Show()**方法，该方法接受**Ticket**作为参数。**Show()**方法的单一职责是更新**SelectedTicket**引用。
- en: In *step 3* , we shift to the **TicketManager** markup where we iterate over
    the **Tickets.All** collection from the sample and render each ticket title. Below
    the section with **Title** , we add two buttons enabling administrative actions,
    leveraging the delegation with lambda expressions. With the first button, we allow
    a user to display a given ticket’s details by attaching the **Show()** method
    to the button’s **@onclick** event and passing over a reference to the currently
    iterated **ticket** object. Here, the use of lambda expressions allows implementing
    precise and context-aware actions. The second button enables the user to top up
    the ticket stock. This time, we use an **anonymous lambda expression** – a lambda
    expression that encapsulates the operation itself rather than delegating to an
    existing method. We access the **Stock** property of each ticket as we iterate
    over the **Tickets.All** sample collection and increment the **Stock** value by
    5 directly within the markup.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们转向**TicketManager**的标记，遍历样本中的**Tickets.All**集合并渲染每个票标题。在**Title**部分下方，我们添加了两个按钮，允许执行管理操作，利用lambda表达式进行委托。使用第一个按钮，我们允许用户通过将**Show()**方法附加到按钮的**@onclick**事件并传递当前迭代的**ticket**对象来显示给定票的详细信息。在这里，lambda表达式的使用允许实现精确和上下文相关的操作。第二个按钮允许用户补充票库存。这次，我们使用了一个**匿名lambda表达式**——一个封装操作本身而不是委托给现有方法的lambda表达式。我们在遍历**Tickets.All**样本集合时访问每个票的**Stock**属性，并在标记内直接将**Stock**值增加5。
- en: However, with the flexibility and power of lambda expressions comes great responsibility.
    Minimizing the amount of C# code within the markup is good practice. Use a strongly
    typed method to encapsulate complex and lengthy lambda expressions and maintain
    the clarity of your code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，lambda表达式的灵活性和强大功能也带来了巨大的责任。在标记中尽量减少C#代码的数量是一种良好的实践。使用强类型方法封装复杂和冗长的lambda表达式，以保持代码的清晰性。
- en: In *step 4* , we extend the **TicketManager** markup further. Similar to checking
    the **ShowTickets** value and conditionally displaying the list of tickets (that
    we implemented in the *Hooking into event delegates* recipe), we check whether
    the user set the value of **SelectedTicket** and conditionally skip the rendering
    of the specific ticket details. We conclude the implementation in *step 5* by
    adding a simple markup to render the **Title** , **Price** , and **Stock** properties
    of the ticket that the user selects. As Blazor converts the lambda expression
    to an **EventCallback** object, users will see updates of the **Stock** property
    value immediately after each **Top Up** button click.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们进一步扩展了**TicketManager**的标记。类似于检查**ShowTickets**值并条件性地显示票务列表（我们在*Hooking
    into event delegates*菜谱中实现），我们检查用户是否设置了**SelectedTicket**的值，并条件性地跳过渲染特定的票务详情。我们在*步骤5*中通过添加简单的标记来渲染用户选择的票务的**标题**、**价格**和**库存**属性。由于Blazor将lambda表达式转换为**EventCallback**对象，用户将在每次点击**充值**按钮后立即看到**库存**属性值的更新。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'If you’re interested in learning more about the roles and capabilities of lambda
    expressions, visit the Microsoft Learn section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于lambda表达式角色和功能的信息，请访问Microsoft Learn部分：
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions)'
- en: Delegating with EventCallback
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EventCallback进行委托
- en: In this recipe, we explore event delegation with the help of **EventCallback**
    . **EventCallback** in Blazor is a mechanism that enables components to listen
    for and react to user-generated events or interactions, tying closely with the
    framework’s architectural design. This Blazor-native feature empowers developers
    to write cleaner, more efficient code by seamlessly integrating with the component
    lifecycle and the overall application state. The primary benefit of event callbacks
    is their ability to automatically manage UI updates through the **StateHasChanged()**
    method, ensuring that the user interface remains in sync with the application’s
    state. **EventCallback** is also a null-safe object – when it’s not assigned but
    invoked, it safely skips rather than throwing **NullReferenceException** . You
    will see **EventCallback** in all the recipes in this chapter, as it’s a building
    block of most interactivity in Blazor.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们借助**EventCallback**来探索事件委托。Blazor中的**EventCallback**是一种机制，它使组件能够监听并响应用户生成的事件或交互，与框架的架构设计紧密相连。这个Blazor原生特性通过无缝集成组件生命周期和整体应用程序状态，使开发者能够编写更干净、更高效的代码。事件回调的主要优势在于它们能够通过**StateHasChanged()**方法自动管理UI更新，确保用户界面与应用程序状态保持同步。**EventCallback**也是一个空安全对象——当它未被分配但被调用时，它会安全地跳过而不是抛出**NullReferenceException**。你将在本章的所有菜谱中看到**EventCallback**，因为它是Blazor中大多数交互的基础。
- en: Let’s implement a component where we encapsulate administrative ticket actions
    with the help of **EventCallback** parameters. With that component, we will also
    simplify the markup of the ticket list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个组件，利用**EventCallback**参数封装管理票务操作。使用该组件，我们还将简化票务列表的标记。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we implement delegation with **EventCallback** , do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现使用**EventCallback**的委托之前，请执行以下操作：
- en: Create a **Chapter03** / **Recipe03** directory – this will be your working
    directory
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter03**/**Recipe03**目录——这将是你的工作目录
- en: Copy the **TicketManager** component from the *Delegating with lambda expressions*
    recipe or from the **Chapter03** / **Recipe02** directory in the GitHub repository
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*Delegating with lambda expressions*菜谱或从GitHub仓库中的**Chapter03**/**Recipe02**目录复制**TicketManager**组件
- en: Copy the **Ticket** and **Tickets** sample files from the **Chapter03** / **Data**
    directory in the GitHub repository
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter03**/**Data**目录复制**Ticket**和**Tickets**样本文件
- en: How to do it…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Follow these steps to implement an article management system using **EventCallback**
    delegates:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用**EventCallback**委托实现文章管理系统：
- en: Create a new **TicketOptions** component.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**TicketOptions**组件。
- en: 'Initialize the **@code** block in **TicketOptions** and declare three required
    parameters, each of type **EventCallback** , corresponding to the different administrative
    actions:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketOptions**中初始化**@code**块并声明三个必需的参数，每个参数的类型为**EventCallback**，对应不同的管理操作：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Jump to the **TicketOptions** markup and construct buttons allowing a user
    to invoke **OnShow** , **OnTopUp** , and **OnRemove** actions:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**TicketOptions**标记并构建允许用户调用**OnShow**、**OnTopUp**和**OnRemove**操作的按钮：
- en: '[PRE14]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Navigate to the **TicketManager** component.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**组件。
- en: 'Within the **@code** block of **TicketManager** , implement two new methods
    allowing you to remove and top up the stock of a **Ticket** object:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketManager**的**@code**块中，实现两个新方法，允许你移除和补充**Ticket**对象的库存：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the **TicketManager** markup, replace the existing action buttons in the
    ticket details with the **TicketOptions** instance:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketManager**标记中，将现有的操作按钮替换为**TicketOptions**实例：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we create a new **TicketOptions** component. In *step 2* , we
    initialize the **@code** block in **TicketOptions** and declare three required
    **EventCallback** parameters that will carry the action delegates necessary for
    triggering administrative ticket actions. Next, in *step 3* , we construct the
    **TicketOptions** markup with three buttons, each invoking **OnShow** , **OnTopUp**
    , or **OnRemove** parameters when users click them. Notice that we attach the
    **EventCallback** parameters directly to the **@onclick** event of each button.
    We don’t need to add additional methods that will act as proxies. Blazor will
    seamlessly link UI interactions with our predefined actions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 1**中，我们创建一个新的**TicketOptions**组件。在**步骤 2**中，我们在**TicketOptions**中初始化**@code**块并声明三个必需的**EventCallback**参数，这些参数将携带触发管理票务操作的必要的行为委托。接下来，在**步骤
    3**中，我们使用三个按钮构建**TicketOptions**标记，每个按钮在用户点击时将调用**OnShow**、**OnTopUp**或**OnRemove**参数。请注意，我们将**EventCallback**参数直接附加到每个按钮的**@onclick**事件上。我们不需要添加额外的作为代理的方法。Blazor将无缝地将UI交互与我们的预定义操作链接起来。
- en: In *step 4* , we navigate to the **TicketManager** component. In *step 5* ,
    we extend the **@code** block of **TicketManager** with two additional methods.
    First, we implement a **TopUp()** method, that increments the current ticket **Stock**
    property value by 5. Next, we implement a **Remove()** method that simply removes
    a given ticket from the **Tickets.All** collection. In *step 6* , we locate the
    **TicketManager** markup area where we render primitive action buttons for each
    ticket. We replace those buttons with the **TicketOptions** markup and attach
    respective actions to each of the required **EventCallback** parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 4**中，我们导航到**TicketManager**组件。在**步骤 5**中，我们在**TicketManager**的**@code**块中扩展两个额外的方法。首先，我们实现一个**TopUp()**方法，该方法将当前票的**Stock**属性值增加5。接下来，我们实现一个**Remove()**方法，该方法简单地从**Tickets.All**集合中移除指定的票。在**步骤
    6**中，我们定位到渲染每个票的原始操作按钮的**TicketManager**标记区域。我们将这些按钮替换为**TicketOptions**标记，并将相应的操作附加到每个必需的**EventCallback**参数上。
- en: There’s more…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the **TicketOptions** component in place, we’ve significantly simplified
    the **TicketsManager** markup code. We’ve refactored ticket-related actions in
    a more organized and readable manner, making the overall code base cleaner and
    easier to maintain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在**TicketOptions**组件就位后，我们已经显著简化了**TicketsManager**标记代码。我们以更组织化和可读的方式重构了与票务相关的操作，使整体代码库更干净且易于维护。
- en: But, since **TicketOptions** acts only as an action proxy and is not based on
    a **Ticket** reference, we effectively create new delegate instances, wrapping
    the actionable method inside, every time we render the **TicketOptions** component.
    This operation might come with a performance penalty even with all the C# optimization
    magic. In simple applications, the performance impact will likely be negligible.
    However, you must keep this in mind when working with data-heavy or highly reactive
    systems.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于**TicketOptions**仅作为操作代理，并不基于**Ticket**引用，因此每次渲染**TicketOptions**组件时，我们实际上都创建了新的委托实例，将可操作的方法包裹在其中。即使有所有C#优化魔法，这种操作也可能带来性能损失。在简单应用程序中，性能影响可能微乎其微。然而，当与数据密集型或高度反应性系统一起工作时，你必须记住这一点。
- en: Preventing default event actions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止默认事件操作
- en: In this recipe, we explore the mechanics of browsers automatically executing
    specific actions in response to user events. Default event actions can include
    form submission when the return key is pressed or navigating to a link’s URL when
    it’s clicked. However, there are scenarios in Blazor applications where you might
    need to intercept these automatic behaviors to control the user experience. Whether
    to manage form validation, confirm user intentions, or manage dynamic content
    updates without refreshing the page, preventing default actions becomes essential.
    I will guide you through stopping these default behaviors programmatically within
    your application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了浏览器自动执行特定操作以响应用户事件的机制。默认事件操作可能包括当按下回车键时表单提交或当点击链接时导航到链接的URL。然而，在Blazor应用程序中，您可能需要拦截这些自动行为以控制用户体验。无论是管理表单验证、确认用户意图还是管理不刷新页面的动态内容更新，防止默认操作变得至关重要。我将指导您如何在应用程序中以编程方式停止这些默认行为。
- en: Let’s implement a fast ticket creation feature, where we will intercept and
    apply custom logic with each key store a user makes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个快速创建票据的功能，我们将拦截并应用每个用户创建的键的自定义逻辑，并存储。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before exploring how to intercept and prevent default event actions, do the
    following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索如何拦截和防止默认事件操作之前，执行以下操作：
- en: Create a **Chapter03** / **Recipe04** directory – this will be your working
    directory
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**Chapter03** / **Recipe04**目录——这将成为您的工作目录
- en: Copy **TicketManager** and **TicketOptions** from the *Delegating with event
    callbacks* recipe or from the **Chapter03** / **Recipe03** directory in the GitHub
    repository
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从*事件回调中的委托*菜谱或从GitHub仓库中的**Chapter03** / **Recipe03**目录复制**TicketManager**和**TicketOptions**
- en: Copy **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从GitHub仓库中的**Chapter03** / **Data**目录复制**Ticket**，**Tickets**和**Extensions**文件
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Go through the process of preventing default event actions by following these
    steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤防止默认事件操作：
- en: 'Navigate to the **@code** block of **TicketManager** and initialize a new **Creator**
    variable below the existing code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**的**@code**块，并在现有代码下方初始化一个新的**Creator**变量：
- en: '[PRE17]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Below the **Creator** variable, still in the **@code** block, implement a **MonitorCreation()**
    method that intercepts a **KeyboardEventArgs** parameter, resolves its payload,
    and creates a new ticket instance when the user hits the *+* symbol on the keyboard:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Creator**变量下方，仍然在**@code**块中，实现一个**MonitorCreation()**方法，该方法拦截一个**KeyboardEventArgs**参数，解析其有效负载，并在用户在键盘上按下*+*符号时创建一个新的票据实例：
- en: '[PRE18]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Jump over to the **TicketManager** markup. Below the render mode declaration
    at the top, construct a ticket creation area by adding a section header and an
    input with the **MonitorCreation()** method attached to its **@onkeydown** event,
    preventing the default **@** **onkeydown** behavior:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到**TicketManager**标记。在顶部的渲染模式声明下方，通过添加一个部分标题和一个带有附加到其**@onkeydown**事件的**MonitorCreation()**方法的输入来构建一个票据创建区域，防止默认的**@**
    **onkeydown**行为：
- en: '[PRE19]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *step 1* , we navigate to the **@code** block of **TicketManager** and initialize
    a **Creator** variable that will hold the current text that the user inputs in
    the fast ticket creation field. We will construct the creation field itself in
    a moment.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们导航到**TicketManager**的**@code**块，并初始化一个**Creator**变量，该变量将保存用户在快速创建票据字段中输入的当前文本。我们将在稍后构建创建字段本身。
- en: In *step 2* , next to the **Creator** variable, we implement a **MonitorCreation()**
    method, where we will put the custom **@onkeydown** logic for Blazor to execute
    instead of the default one. The **MonitorCreation()** method receives a **KeyboardEventArgs**
    object, having a **Key** property that we need for our custom creation logic.
    First, we check whether the clicked symbol matches the **+** key and add a new
    **Ticket** object to the **Tickets.All** collection. Next, we leverage the **IsBackspace()**
    extension method from the **Extensions** file provided with data samples. If the
    user clicks the backspace button and the **Creator** length indicates there are
    characters to remove, we remove the last character from the **Creator** value
    using the **range operator** . Lastly, we leverage another custom extension method
    from the **Extensions** file – **IsLetter()** – to check whether what the user
    pressed on their keyboard is in fact a letter and append it at the end of the
    current **Creator** value. With that implementation, we ignore all other keyboard
    actions. I strongly encourage you to experiment and add numbers support on your
    own!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 2 步* 中，在 **Creator** 变量旁边，我们实现了一个 **MonitorCreation()** 方法，我们将在这里放置 Blazor
    执行的自定义 **@onkeydown** 逻辑，而不是默认的。**MonitorCreation()** 方法接收一个 **KeyboardEventArgs**
    对象，它有一个 **Key** 属性，这是我们自定义创建逻辑所需要的。首先，我们检查点击的符号是否匹配 **+** 键，并将一个新的 **Ticket**
    对象添加到 **Tickets.All** 集合中。接下来，我们利用数据样本提供的 **Extensions** 文件中的 **IsBackspace()**
    扩展方法。如果用户点击了退格键，并且 **Creator** 的长度指示有字符可以删除，我们将使用 **范围运算符** 从 **Creator** 的值中删除最后一个字符。最后，我们利用
    **Extensions** 文件中的另一个自定义扩展方法 – **IsLetter()** – 来检查用户按在键盘上的键是否实际上是一个字母，并将其附加到当前
    **Creator** 值的末尾。通过这种实现，我们忽略了所有其他键盘操作。我强烈建议您进行实验，并自行添加数字支持！
- en: In *step 3* , we jump to the **TicketManager** markup and build a section where
    users can fast-create new tickets. We add a **Quick creation** header, so it’s
    obvious what the intention of the input below is. And finally, we construct the
    **input** field where all the event-preventing happens. We set the **input** value
    to reflect the value of **Creator** . Notice, that we don’t leverage any binding
    here (more about binding in [*Chapter 2*](B22020_02.xhtml#_idTextAnchor065) ).
    Next, we attach the **MonitorCreation()** method to the **@onkeydown** event of
    the input so Blazor seamlessly triggers our custom logic. But **@onkeydown** has
    browser-default logic, conflicting with what we just attached. Here, we employ
    **@onkeydown:preventDefault** , instructing Blazor to bypass any default key-down
    behavior.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 3 步* 中，我们跳转到 **TicketManager** 标记，并构建一个用户可以快速创建新票据的部分。我们添加了一个 **快速创建**
    标题，以便清楚地了解下面输入的目的。最后，我们构建了 **输入** 字段，所有的事件预防都发生在这里。我们将 **输入** 的值设置为反映 **Creator**
    的值。请注意，我们在这里没有利用任何绑定（更多关于绑定的内容请参阅 [*第 2 章*](B22020_02.xhtml#_idTextAnchor065)）。接下来，我们将
    **MonitorCreation()** 方法附加到输入的 **@onkeydown** 事件上，以便 Blazor 无缝地触发我们的自定义逻辑。但是 **@onkeydown**
    有浏览器默认逻辑，与我们刚刚附加的逻辑冲突。在这里，我们使用 **@onkeydown:preventDefault**，指示 Blazor 跳过任何默认的键按下行为。
- en: There’s more…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All the events in Blazor behave virtually the same, regardless of the render
    mode you use. However, some events, like **@onkeydown** , are inherently client-side
    in their expected result – responding immediately to user input. When using **@onkeydown**
    in **InteractiveServer** mode, you must consider that each event trigger will
    travel to the server and back before it’s reflected on the UI. In higher-latency
    scenarios, this round-trip can result in flaky and unstable behavior of the UI.
    Always consider the nature of the events you’re choosing and the appropriate render
    mode to ensure that your application remains user-friendly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 中的所有事件在渲染模式方面表现几乎相同。然而，一些事件，如 **@onkeydown**，在预期的结果上本质上是客户端的 – 立即响应用户输入。当在
    **InteractiveServer** 模式下使用 **@onkeydown** 时，你必须考虑到每个事件触发器在反映到 UI 之前将往返于服务器。在高延迟场景中，这种往返可能会导致
    UI 的不稳定和不稳定行为。始终考虑你选择的事件的性质和适当的渲染模式，以确保你的应用程序保持用户友好。
- en: When building an internationally available application, you may need to support
    special local characters that require specific key combinations, such as using
    *Alt* + *a* to produce the letter **ą** in Polish. To handle these cases effectively,
    Blazor provides the ability to manage keyboard composition events.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个国际化的应用程序时，你可能需要支持特殊的地方字符，这些字符需要特定的键组合，例如使用 *Alt* + *a* 来生成波兰语的字母 **ą**。为了有效地处理这些情况，Blazor
    提供了管理键盘组合事件的能力。
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can track the composition state of the input using the **IsComposing** property
    in **KeyboardEventArgs** . When **IsComposing** is set to **true** , it indicates
    that the user is entering a composite character. You should delay processing the
    input until **IsComposing** returns to **false** .
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **KeyboardEventArgs** 中的 **IsComposing** 属性来跟踪输入的组成状态。当 **IsComposing**
    设置为 **true** 时，表示用户正在输入一个复合字符。您应该在 **IsComposing** 返回到 **false** 之前延迟处理输入。
- en: Controlling event propagation
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制事件传播
- en: In this recipe, we explore the process of controlling how events travel through
    the **Document Object Model** ( **DOM** ) within Blazor applications. Stopping
    default event propagation becomes crucial when we work with nested components
    or elements. You can ensure events such as clicks, hovers, or keyboard inputs
    have localized effects – thereby avoiding unintended ripple effects or behaviors
    in the UI. By mastering the control of event propagation, you can fine-tune interaction
    patterns within your application, leading to a smoother and more intuitive user
    experience.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们探讨了在 Blazor 应用程序中控制事件如何在 **Document Object Model** ( **DOM** ) 中传播的过程。当我们与嵌套组件或元素一起工作时，停止默认事件传播变得至关重要。您可以通过确保事件（如点击、悬停或键盘输入）具有局部影响来避免在
    UI 中产生意外的涟漪效果或行为。通过掌握事件传播的控制，您可以在应用程序中微调交互模式，从而实现更流畅、更直观的用户体验。
- en: Let’s allow users to click anywhere on the ticket record to display its details
    while ensuring that clicking on any of the nested administrative actions won’t
    propagate uncontrollably.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户能够点击票记录的任何位置来显示其详细信息，同时确保点击嵌套的任何管理操作都不会无控制地传播。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before diving into controlling events propagation, do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入控制事件传播之前，请执行以下操作：
- en: Create a **Chapter03** / **Recipe05** directory – this will be your working
    directory
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter03** / **Recipe05** 目录 – 这将是您的工作目录
- en: Copy **TicketManager** and **TicketOptions** from the *Preventing default event
    actions* recipe or from the **Chapter03** / **Recipe04** directory in the GitHub
    repository
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *Preventing default event actions* 食谱或从 GitHub 仓库中的 **Chapter03** / **Recipe04**
    目录复制 **TicketManager** 和 **TicketOptions**
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter03** / **Data** 目录复制 **Ticket**、**Tickets** 和 **Extensions**
    文件
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To control event propagation and see the **stopPropagation** attribute in action,
    follow these steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制事件传播并查看 **stopPropagation** 属性的作用，请按照以下步骤操作：
- en: 'Navigate to the **TicketManager** markup and locate the container markup that
    we render for each ticket. Next to the assignment of the **id** attribute, attach
    the **Show()** method to the container’s **@** **onclick** event:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **TicketManager** 标记，并找到我们为每个票渲染的容器标记。在 **id** 属性的分配旁边，将 **Show()** 方法附加到容器的
    **@** **onclick** 事件：
- en: '[PRE21]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Navigate to the **TicketOptions** markup and attach the **stopPropagation**
    attribute to the **@onclick** event of each of the administrative action buttons:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 **TicketOptions** 标记，并将 **stopPropagation** 属性附加到每个管理操作按钮的 **@onclick**
    事件：
- en: '[PRE22]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1* , we navigate to the **TicketManager** markup, where we render each
    ticket’s details in a dedicated container. You’ll find the container markup inside
    the **foreach** loop, with the **id** attribute set to correspond to the current
    ticket ID. In order to allow users to display ticket details by clicking anywhere
    on the container, next to the **id** attribute, we attached our **Show()** method
    to the **@onclick** event of the container. Now, whether users click on the **Show**
    button or anywhere inside the ticket container, Blazor will trigger the same action
    and render details of a given ticket.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们导航到 **TicketManager** 标记，在那里我们在一个专门的容器中渲染每个票的详细信息。您将在 **foreach**
    循环内找到容器标记，其 **id** 属性设置为对应当前票 ID。为了允许用户通过点击容器上的任何位置来显示票详情，我们在 **id** 属性旁边将我们的
    **Show()** 方法附加到容器的 **@onclick** 事件。现在，无论用户点击 **Show** 按钮，还是点击票容器内的任何位置，Blazor
    都将触发相同的操作并渲染给定票的详细信息。
- en: Now, here is the catch. Inside the ticket container, we have also nested the
    **Top Up** and **Remove** buttons – all reacting differently to the **@onclick**
    event. However, nested **@onclick** events within the same area would trigger
    simultaneously by default. In our example, when the user clicks on the **Top Up**
    button, they will both increase that ticket stock and render its details. With
    the **Remove** button, it gets even more confusing, as users can remove a ticket
    and display its details at the same time. That’s where we need the **stopPropagation**
    attribute. Attaching **stopPropagation** to a desired event, we instruct Blazor
    to prevent event propagation to the parent DOM element.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有个关键点。在票据容器内部，我们还嵌入了**Top Up**和**Remove**按钮——它们对**@onclick**事件的反应各不相同。然而，在同一区域内嵌套的**@onclick**事件默认情况下会同时触发。在我们的例子中，当用户点击**Top
    Up**按钮时，它将同时增加票据库存并渲染其详情。对于**Remove**按钮来说，情况更加复杂，因为用户可以在移除票据的同时显示其详情。这就是我们需要**stopPropagation**属性的地方。将**stopPropagation**属性附加到所需事件上，我们指示Blazor阻止事件传播到父DOM元素。
- en: In *step 2* , we navigate to the **TicketOptions** markup, where we have all
    the administrative action buttons. Next to the **@onclick** attribute of each
    of the three buttons, we append the **@onclick:stopPropagation** attribute. That’s
    all it takes to ensure that users can safely increase the stock of the ticket
    or remove it entirely without experiencing unwanted rendering of the ticket details
    display.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤 2**中，我们导航到**TicketOptions**标记，其中包含所有管理操作按钮。在每个三个按钮的**@onclick**属性旁边，我们附加了**@onclick:stopPropagation**属性。这就足够确保用户可以安全地增加票据库存或完全移除它，而不会遇到不希望的票据详情显示渲染。
- en: There’s more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While the **stopPropagation** attribute is a powerful tool within Blazor applications
    for managing event flow, it’s essential to understand its scope and limitations.
    This attribute is specifically designed to work with Blazor events and does not
    directly influence the behavior of standard HTML events. HTML events must first
    be allowed to execute normally; only then can Blazor intercept these events and
    make decisions regarding event propagation from child components to their parents.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**stopPropagation**属性是Blazor应用程序中管理事件流的有力工具，但了解其作用域和限制是至关重要的。该属性专门设计用于与Blazor事件一起工作，并且不会直接影响标准HTML事件的行为。HTML事件必须首先允许正常执行；然后Blazor才能拦截这些事件并就事件从子组件传播到父组件做出决策。
- en: In our implementation, we focused on controlling the **@onclick** event, but
    when dealing with complex interfaces where you need to control multiple events,
    **stopPropagation** must be explicit for each event.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们专注于控制**@onclick**事件，但在处理需要控制多个事件的复杂界面时，**stopPropagation**必须对每个事件都是明确的。
- en: Additionally, when incorporating components from external libraries into your
    Blazor applications, you might encounter situations where direct control over
    event propagation is not straightforward. In such cases, a practical workaround
    is to wrap the external component within a neutral HTML element, for example,
    a **span** element. By applying **stopPropagation** to events on **span** , you
    effectively create a barrier for event propagation, with **span** acting as the
    nearest parent. This method allows you to manage event flow even in complex component
    hierarchies, ensuring intended behavior without unintended side effects from external
    components.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当将外部库中的组件集成到Blazor应用程序中时，可能会遇到直接控制事件传播并不直接的情况。在这种情况下，一个实用的解决方案是将外部组件包裹在一个中立的HTML元素中，例如，一个**span**元素。通过将**stopPropagation**应用于**span**上的事件，你实际上创建了一个阻止事件传播的屏障，其中**span**充当最近的父元素。这种方法允许你在复杂的组件层次结构中管理事件流，确保预期的行为，而不会受到外部组件的意外副作用。
- en: Introducing custom events
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入自定义事件
- en: In this recipe, we explore the possibility of enriching our Blazor application
    with custom events, diving into slightly more advanced territory where **JavaScript**
    interplays with Blazor. Alongside custom events, the concept of custom event arguments
    arises, allowing for the passage of tailored data that goes beyond the standard
    event payloads. Custom events and their corresponding arguments become invaluable
    when predefined events fall short, offering the flexibility to capture and respond
    to specific user actions or external system triggers with precision.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们探讨了丰富我们的 Blazor 应用程序的自定义事件的可能性，深入到稍微更高级的领域，其中 **JavaScript** 与 Blazor
    交互。除了自定义事件外，自定义事件参数的概念也出现了，允许传递超出标准事件负载的定制数据。当预定义的事件不足时，自定义事件及其相应的参数变得非常有价值，提供了捕捉和精确响应特定用户操作或外部系统触发的灵活性。
- en: Let’s implement a component that overwrites the data that a user tries to copy
    from the area that this component protects.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个组件，该组件覆盖用户尝试从该组件保护区域复制的所有数据。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we explore the implementation of custom events, do the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索自定义事件的实现之前，请执行以下操作：
- en: Create a **Chapter03** / **Recipe06** directory – this will be your working
    directory
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter03** / **Recipe06** 目录——这将是你的工作目录
- en: Copy **TicketManager** and **TicketOptions** from the *Controlling event propagation*
    recipe or from the **Chapter03** / **Recipe05** directory in the GitHub repository
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *控制事件传播* 菜谱或从 GitHub 仓库的 **Chapter03** / **Recipe05** 目录复制 **TicketManager**
    和 **TicketOptions**
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库的 **Chapter03** / **Data** 目录复制 **Ticket**、**Tickets** 和 **Extensions**
    文件
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to implement custom logic for a copy event:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现复制事件的自定义逻辑：
- en: Add a new JavaScript ( **.js** ) file to the application’s wwwroot directory.
    Adhere to the naming convention, **{ASSEMBLY NAME}.lib.module.js** . This file
    will contain the functions necessary for our custom events.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序的 wwwroot 目录添加一个新的 JavaScript（**.js**）文件。遵循命名约定 **{ASSEMBLY NAME}.lib.module.js**。此文件将包含我们自定义事件所需的函数。
- en: '![Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript
    functions](img/Figure_3.1_B22020.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1：添加包含 JavaScript 函数的 BlazorCookbook.App.Client.lib.module.js 文件](img/Figure_3.1_B22020.jpg)'
- en: 'Figure 3.1: Adding a BlazorCookbook.App.Client.lib.module.js file with JavaScript
    functions'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1：添加包含 JavaScript 函数的 BlazorCookbook.App.Client.lib.module.js 文件
- en: 'Inside your newly created **.js** file, declare an **afterWebStarted()** function.
    Use the **registerCustomEventType** API to declare a new **preventcopy** event.
    Implement custom logic within this event to overwrite the current clipboard data:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你新创建的 **.js** 文件中，声明一个 **afterWebStarted()** 函数。使用 **registerCustomEventType**
    API 声明一个新的 **preventcopy** 事件。在事件中实现自定义逻辑以覆盖当前的剪贴板数据：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a new **CustomEvents.cs** file that will serve as a central repository
    for all details related to custom events.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **CustomEvents.cs** 文件，该文件将作为所有与自定义事件相关的详细信息的中枢存储库。
- en: 'In **CustomEvents.cs** , add a class named **PreventedCopyEventArgs** that
    extends **EventArgs** . Include a **Stamp** property to persist when Blazor prevents
    the copy action:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **CustomEvents.cs** 中，添加一个名为 **PreventedCopyEventArgs** 的类，该类扩展了 **EventArgs**。包括一个
    **Stamp** 属性，以便在 Blazor 阻止复制操作时持久化：
- en: '[PRE24]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Still within **CustomEvents.cs** , declare a **public** and **static** class
    named **EventHandlers** . Add a custom **EventHandler** attribute to this class
    and define an **onpreventcopy** event that returns **PreventedCopyEventArgs**
    .
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 **CustomEvents.cs** 文件中，声明一个名为 **EventHandlers** 的 **public** 和 **static**
    类。向这个类添加一个自定义的 **EventHandler** 属性，并定义一个返回 **PreventedCopyEventArgs** 的 **onpreventcopy**
    事件。
- en: '[PRE25]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Add a new **PreventCopy** component responsible for invoking the custom event
    logic you’ve defined.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的 **PreventCopy** 组件，用于调用你定义的自定义事件逻辑。
- en: 'In the **@code** section of the **PreventCopy** component, declare a required
    **ChildContent** parameter of type **RenderFragment** . Also, implement a **Log()**
    method to intercept and log the timestamp that **PreventedCopyEventArgs** carries:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **PreventCopy** 组件的 **@code** 部分，声明一个必需的 **ChildContent** 参数，其类型为 **RenderFragment**。同时，实现一个
    **Log()** 方法来拦截并记录 **PreventedCopyEventArgs** 带有的时间戳：
- en: '[PRE26]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Within the **PreventCopy** markup, construct a wrapping container, where you
    intercept the custom **@onpreventcopy** event and delegate it to the **Log()**
    method, while rendering **ChildContent** inside:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **PreventCopy** 标记内部，构建一个包装容器，其中拦截自定义的 **@onpreventcopy** 事件并将其委托给 **Log()**
    方法，同时在内部渲染 **ChildContent**：
- en: '[PRE27]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Navigate to the **TicketManager** markup, locate the area where we render the
    **SelectedTicket** details, and wrap it with the **PreventCopy** tags:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**标记，找到我们渲染**SelectedTicket**详情的区域，并用**PreventCopy**标签包裹它：
- en: '[PRE28]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We kick off the integration of a custom event by establishing a bridge between
    Blazor and JavaScript. In *step 1* , we add a **.js** file within the **wwwroot**
    directory, adhering to a specific naming convention ( **{ASSEMBLY NAME}.lib.module.js**
    or **{PACKAGE ID}.lib.module.js** ). This convention is crucial as Blazor automatically
    searches for these files to support custom events defined within the application.
    In *step 2* , we define an **afterWebStarted()** function, which takes a **blazor**
    argument (intentionally lowercase to differentiate from the globally available
    **Blazor** object) and which Blazor compilers expect. Using the **registerCustomEventType**
    API, we declare our **preventcopy** event, designed to intercept the browser’s
    **copy** event and overwrite clipboard data. While at it, we must also cancel
    the browser’s default copy behavior using the **preventDefault()** method. We
    return a timestamp marking the event trigger that we will utilize later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在Blazor和JavaScript之间建立桥梁来启动自定义事件的集成。在**第1步**中，我们在**wwwroot**目录中添加了一个**.js**文件，遵循特定的命名约定（**{ASSEMBLY
    NAME}.lib.module.js**或**{PACKAGE ID}.lib.module.js**）。这个约定至关重要，因为Blazor会自动搜索这些文件以支持在应用程序中定义的自定义事件。在**第2步**中，我们定义了一个**afterWebStarted()**函数，它接受一个**blazor**参数（有意使用小写字母以区分全局可用的**Blazor**对象），这是Blazor编译器期望的。使用**registerCustomEventType**
    API，我们声明了我们的**preventcopy**事件，该事件旨在拦截浏览器的**copy**事件并覆盖剪贴板数据。在此过程中，我们还必须使用**preventDefault()**方法取消浏览器默认的复制行为。我们返回一个标记事件触发的时间戳，我们将在以后使用。
- en: Transitioning to Blazor in *step 3* , we introduce the **CustomEvents.cs** file
    to define our Blazor-side custom event handling. We implement the **PreventedCopyEventArgs**
    class in *step 4* , inheriting from **EventArgs** and reflecting our JavaScript
    function’s structure, including a **Stamp** property. In *step 5* , we register
    a Blazor custom event using the Razor compiler’s capabilities. Following the code
    generators convention, we declare **public static class EventHandlers** and leverage
    the **[EventHandler]** attribute to inform the Razor compiler of our custom **onpreventcopy**
    event. The Razor compiler will automatically align **onpreventcopy** with its
    JavaScript counterpart – **preventcopy** .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**第3步**过渡到Blazor时，我们引入了**CustomEvents.cs**文件来定义我们的Blazor端自定义事件处理。在**第4步**中，我们实现了**PreventedCopyEventArgs**类，它继承自**EventArgs**，并反映了我们的JavaScript函数的结构，包括一个**Stamp**属性。在**第5步**中，我们使用Razor编译器的功能注册了一个Blazor自定义事件。遵循代码生成器的约定，我们声明了一个**public
    static class EventHandlers**，并利用**[EventHandler]**属性通知Razor编译器我们的自定义**onpreventcopy**事件。Razor编译器将自动将**onpreventcopy**与其JavaScript对应者**preventcopy**对齐。
- en: Next, in *step 6* , we add a **PreventCopy** component as a wrapper preventing
    copy operations within specified content. In *step 7* , in the **@code** block
    of **PreventCopy** , we declare a **ChildContent** parameter, where we can provide
    content to be protected and a primitive **Log()** method to log the timestamp
    of a prevented copy attempt. In *step 8* , we construct the **PreventCopy** markup.
    We add a container and intercept the **@onpreventcopy** event while also invoking
    the **Log()** method every time it’s triggered. Inside the container, we render
    the provided **ChildContent** markup. Now, Blazor will effectively prevent data
    leakage while maintaining an audit trail of any data copy attempts.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在**第6步**中，我们添加了一个**PreventCopy**组件作为包装器，防止在指定内容内进行复制操作。在**第7步**中，在**PreventCopy**的**@code**块中，我们声明了一个**ChildContent**参数，其中我们可以提供要保护的内容和一个原始的**Log()**方法来记录被阻止的复制尝试的时间戳。在**第8步**中，我们构建了**PreventCopy**标记。我们添加了一个容器并拦截了**@onpreventcopy**事件，同时每次它被触发时都会调用**Log()**方法。在容器内部，我们渲染提供的**ChildContent**标记。现在，Blazor将有效地防止数据泄露，同时维护任何数据复制尝试的审计记录。
- en: There’s more…
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While the **afterWebStarted()** function is crucial in integrating custom events
    within a **Blazor Web App** , it’s important to note that it’s designed specifically
    for this environment. When working outside the Blazor Web App context, an analogous
    approach is required but with a slight adjustment in the function naming. For
    plain server or WebAssembly projects, you must implement the **afterStarted()**
    function. This naming distinction allows us to clearly define when Blazor registers
    custom events and ensures clarity in the application’s lifecycle.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 **afterWebStarted()** 函数在集成 **Blazor Web App** 中的自定义事件时至关重要，但需要注意的是，它专门为这个环境设计。当在
    Blazor Web App 上下文之外工作时，需要采用类似的方法，但需要在函数命名上进行轻微调整。对于普通的服务器或 WebAssembly 项目，你必须实现
    **afterStarted()** 函数。这种命名区分使我们能够清楚地定义 Blazor 注册自定义事件的时间，并确保应用程序生命周期的清晰性。
- en: Handling long-running events
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理长时间运行的事件
- en: In this recipe, we tackle a critical aspect of **single-page application** (
    **SPA** ) development – ensuring users are aware of operations occurring in the
    background. Unlike traditional web applications, SPAs do not naturally indicate
    when a process is executing behind the scenes. This lack of feedback can leave
    users staring at what appears to be a stale or unresponsive page, leading to frustration
    and confusion. It’s essential that you incorporate visual action indicators such
    as preloaders, loading spinners, or progress bars. These elements serve as visual
    cues that inform the user something is happening, enhancing the user experience
    by providing a sense of activity and progress. I will guide you through implementing
    these indicators in your SPA, ensuring that during long-running requests or operations,
    your users are kept in the loop, maintaining engagement and satisfaction with
    your application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们解决 **单页应用程序** ( **SPA** ) 开发的一个关键方面 - 确保用户意识到后台正在进行的操作。与传统Web应用程序不同，SPAs
    并不自然地指示后台正在执行的过程。这种缺乏反馈可能导致用户盯着看似停滞或无响应的页面，从而导致挫败感和困惑。在应用程序中融入视觉动作指示器，如预加载器、加载旋转器或进度条，是至关重要的。这些元素作为视觉提示，告知用户正在发生的事情，通过提供活动感和进度感来提升用户体验。我将指导你如何在你的SPA中实现这些指示器，确保在长时间运行请求或操作期间，你的用户能够保持了解，保持对应用程序的参与和满意度。
- en: Let’s implement two kinds of action indicators – a simple loading indicator
    and a primitive progress indicator.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现两种动作指示器 - 一个简单的加载指示器和一种原始的进度指示器。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before starting the implementation of user-friendly status indicators, do the
    following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现用户友好的状态指示器之前，执行以下操作：
- en: Create a **Chapter03** / **Recipe07** directory – this will be your working
    directory
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 **Chapter03** / **Recipe07** 目录 - 这将是你的工作目录
- en: Copy **TicketManager** , **TicketOptions** , **PreventCopy** , and **CustomEvents**
    from the *Introducing custom events* recipe or from the **Chapter03** / **Recipe07**
    directory in the GitHub repository
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 *介绍自定义事件* 菜谱或从 GitHub 仓库中的 **Chapter03** / **Recipe07** 目录复制 **TicketManager**、**TicketOptions**、**PreventCopy**
    和 **CustomEvents**
- en: Copy the **Ticket** , **Tickets** , and **Extensions** files from the **Chapter03**
    / **Data** directory in the GitHub repository
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库中的 **Chapter03** / **Data** 目录复制 **Ticket**、**Tickets** 和 **Extensions**
    文件
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To build loading and progress indicators that improve the user experience of
    your app, follow these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建改进应用程序用户体验的加载和进度指示器，请按照以下步骤操作：
- en: Create a new **LoadingIndicator** component that will visually communicate to
    users when an operation is loading.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **LoadingIndicator** 组件，该组件将向用户直观地传达操作正在加载。
- en: 'In the **@code** block of **LoadingIndicator** , declare a **Job** parameter
    – representing the task to display the loading state for, and a **ChildContent**
    parameter to allow passing the content to render when loading is complete:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **LoadingIndicator** 的 **@code** 块中，声明一个 **Job** 参数 - 表示用于显示加载状态的任务，以及一个 **ChildContent**
    参数，允许在加载完成后传递要渲染的内容：
- en: '[PRE29]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Below the parameter declaration, still within the **@code** block, initialize
    an **IsLoading** state variable and implement a **RunAsync()** method, which encapsulates
    the logic for managing the loading state while executing the **Job** delegate:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数声明下方，仍然在 **@code** 块内，初始化一个 **IsLoading** 状态变量并实现一个 **RunAsync()** 方法，该方法封装了在执行
    **Job** 委托时管理加载状态的逻辑：
- en: '[PRE30]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the **LoadingIndicator** markup, add a button for users to initiate the
    loading process by attaching the **RunAsync()** method to the button’s **@onclick**
    event and conditionally disabling it while loading is in progress:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**LoadingIndicator**标记中，添加一个按钮，用户可以通过将其**@onclick**事件附加到**RunAsync()**方法来启动加载过程，并在加载过程中条件性地禁用它：
- en: '[PRE31]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Below the loading button, construct two areas – for when the loading is in
    progress and when it completes, based on the value of the **IsLoading** state
    variable:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在加载按钮下方，根据**IsLoading**状态变量的值构建两个区域——当加载正在进行时和加载完成后：
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Create another component – **ProgressIndicator** – that will visually communicate
    to users the progress of the operation they request.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个组件——**ProgressIndicator**——将向用户直观地传达他们请求的操作的进度：
- en: 'Within the **@code** block of **ProgressIndicator** , declare two required
    parameters: a **Job** parameter – representing an abstract operation the progress
    indicator should monitor, and a **Total** parameter – to provide the number of
    elements the operation should run for:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ProgressIndicator**的**@code**块内，声明两个必需的参数：一个**Job**参数——表示进度指示器应监控的抽象操作，以及一个**Total**参数——提供操作应运行的元素数量：
- en: '[PRE33]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Below the parameter declaration, initialize a **Progress** state variable to
    reflect the operation’s progress:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数声明下方，初始化一个**Progress**状态变量以反映操作的进度：
- en: '[PRE34]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Still within the **@code** block, implement an expression-bodied **Label**
    property, where based on the **Progress** value, you construct a label for the
    action button (which we will add shortly):'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**@code**块内，实现一个表达式体的**Label**属性，根据**Progress**值构建动作按钮的标签（我们将在稍后添加）：
- en: '[PRE35]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Complete the **@code** block by implementing a **RunAsync()** method to loop
    through the total amount of elements and execute the job for each index:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现一个**RunAsync()**方法来完成**@code**块，该方法遍历总元素数量并为每个索引执行作业：
- en: '[PRE36]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the **ProgressIndicator** markup, construct a button for users to invoke
    the processing through the **RunAsync()** method. Check the current value of the
    **Progress** variable to conditionally disable the action button and leverage
    the **Label** property to generate the button label dynamically:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ProgressIndicator**标记中，构建一个按钮，用户可以通过调用**RunAsync()**方法来调用处理。检查**Progress**变量的当前值以条件性地禁用动作按钮，并利用**Label**属性动态生成按钮标签：
- en: '[PRE37]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Navigate to the **TicketManager** component, to its **@code** block, and implement
    a simple **SaveAsync()** method, leveraging **Tickets.SaveAsync()** provided with
    data samples:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**TicketManager**组件，到其**@code**块，并实现一个简单的**SaveAsync()**方法，利用提供的数据样本的**Tickets.SaveAsync()**：
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the **TicketManager** markup, below the render mode declaration, embed **ProgressIndicator**
    with **SaveAsync()** and **Tickets.All.Count** attached to the **Job** and **Total**
    parameters respectively:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**TicketManager**标记中，在渲染模式声明下方，使用**SaveAsync()**和**Tickets.All.Count**分别附加到**Job**和**Total**参数上嵌入**ProgressIndicator**：
- en: '[PRE39]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Still in the **TicketManager** markup, remove the button allowing to toggle
    tickets and the **ShowTickets** check.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在**TicketManager**标记中，移除允许切换票据的按钮和**ShowTickets**复选框。
- en: 'Now, in the **TicketManager** markup, find the **foreach** loop, where you
    render each ticket container, and wrap it inside the **LoadingIndicator** component.
    Attach the **Tickets.GetAsync()** method to the **Job** parameter that **LoadingIndicator**
    requires:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**TicketManager**标记中找到**foreach**循环，其中渲染每个票据容器，并将其包裹在**LoadingIndicator**组件内部。将**Tickets.GetAsync()**方法附加到**LoadingIndicator**所需的**Job**参数：
- en: '[PRE40]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In *step 1* , we create a new **LoadingIndicator** component. In *step 2* ,
    we initialize the **@code** block of the **LoadingIndicator** component and declare
    two key parameters: **Func<Task> Job** to reference the asynchronous operation
    we intend to monitor, and **ChildContent** to allow passing the content to display
    when loading completes. Both parameters are designed to be operation-agnostic,
    making the component versatile and adaptable to various use cases. In *step 3*
    , we initialize an **IsLoading** state variable and implement the core functionality
    in the **RunAsync()** method. **RunAsync()** updates the **IsLoading** value to
    reflect the operation’s start, executes the declared **Job** delegate, and then
    resets **IsLoading** upon completion, seamlessly transitioning to display **ChildContent**
    . Notice that we’ve invoked the **StateHasChanged()** lifecycle method, before
    starting the **Job** operation. With that implementation, the moment Blazor reaches
    an asynchronous operation, and frees up the UI thread, it will re-render the component
    markup, reflecting the state changes based on the **IsLoading** value. In *step
    4* , we build the **LoadingIndicator** markup. First, we construct an action button
    for initiating the load process with the help of **RunAsync()** . We also attach
    the **disabled** button’s attribute to the value of the **IsLoading** state variable.
    Now, whenever loading is in progress, Blazor will disable the action button, effectively
    preventing users from requeuing the already running operation. In *step 5* , we
    add the visual loading indicator. During operation execution, we render a simple
    **Loading...** message, which you can enhance with CSS for a modern look, such
    as incorporating a spinner. When loading completes, we render the markup provided
    with the **ChildContent** parameter.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们创建一个新的**LoadingIndicator**组件。在*步骤 2*中，我们初始化**LoadingIndicator**组件的**@code**块并声明两个关键参数：**Func<Task>
    Job**用于引用我们打算监控的异步操作，以及**ChildContent**允许在加载完成后传递要显示的内容。这两个参数都被设计为操作无关，使组件具有通用性和适应性，适用于各种用例。在*步骤
    3*中，我们初始化一个**IsLoading**状态变量并在**RunAsync()**方法中实现核心功能。**RunAsync()**更新**IsLoading**的值以反映操作的开始，执行声明的**Job**委托，并在完成后重置**IsLoading**，无缝地过渡到显示**ChildContent**。请注意，我们在开始**Job**操作之前调用了**StateHasChanged()**生命周期方法。有了这种实现，当Blazor达到异步操作并释放UI线程时，它将重新渲染组件标记，根据**IsLoading**的值反映状态变化。在*步骤
    4*中，我们构建**LoadingIndicator**的标记。首先，我们使用**RunAsync()**构建一个用于启动加载过程的操作按钮。我们还把**disabled**按钮的属性附加到**IsLoading**状态变量的值上。现在，每当加载正在进行时，Blazor将禁用操作按钮，有效地防止用户重新排队已经正在运行的操作。在*步骤
    5*中，我们添加视觉加载指示器。在操作执行期间，我们渲染一个简单的**Loading...**消息，您可以使用CSS增强其现代外观，例如加入一个旋转器。当加载完成后，我们渲染**ChildContent**参数提供的标记。
- en: In *step 6* , we create a component with a different type of indicator – **ProgressIndicator**
    . In *step 7* , we initialize the **@code** block and define a **Job** parameter
    – allowing us to define an operation to run – and a **Total** parameter – representing
    the number of iterations the operation must go through. The **Job** signature
    effectively abstracts any asynchronous operation but also ensures that the operation
    accepts an **int** parameter, representing the index of the current execution
    iteration. In *step 8* , we initialize a **Progress** variable that we’ll use
    to monitor the actual execution progress from 0% to 100%. In *step 9* , we implement
    a **Label** property. With simple logic, based on the current **Progress** value,
    we generate either a **Process** call to action or actual processing progress.
    In *step 10* , we complete the **@code** block by implementing the core **RunAsync()**
    method. In **RunAsync()** , we loop from **0** to **Total** and invoke the **Job**
    delegate for each index while continuously updating the **Progress** value. When
    the processing is done, we reset the **Progress** value to a neutral **0** . In
    *step 11* , we build the **ProgressIndicator** markup. We construct a button allowing
    us to start the processing by triggering **RunAsync()** on the **@onclick** event.
    We also prevent the requeuing of the running operation by disabling the action
    button based on the **Progress** value, similar to the action button in the **LoadingIndicator**
    component. Lastly, to provide real-time progress feedback, we leverage the **Label**
    property to render the text on the button. Now, when the operation is running,
    Blazor will not only disable the button but also render the current progress on
    it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6步*中，我们创建了一个具有不同类型指示器的组件 – **ProgressIndicator**。在*第7步*中，我们初始化**@code**块并定义一个**Job**参数
    – 允许我们定义一个要运行的操作 – 以及一个**Total**参数 – 表示操作必须经历的迭代次数。**Job**签名有效地抽象了任何异步操作，同时也确保操作接受一个**int**参数，表示当前执行迭代的索引。在*第8步*中，我们初始化一个**Progress**变量，我们将用它来监控实际的执行进度，从0%到100%。在*第9步*中，我们实现了一个**Label**属性。通过简单的逻辑，基于当前的**Progress**值，我们生成一个**Process**调用操作或实际的进度处理。在*第10步*中，我们通过实现核心的**RunAsync()**方法来完成**@code**块。在**RunAsync()**中，我们从**0**循环到**Total**，并对每个索引调用**Job**委托，同时持续更新**Progress**值。当处理完成时，我们将**Progress**值重置为一个中性的**0**。在*第11步*中，我们构建**ProgressIndicator**标记。我们构建一个按钮，允许我们通过在**@onclick**事件上触发**RunAsync()**来启动处理。我们还根据**Progress**值禁用动作按钮，以防止正在运行的操作重新排队，类似于**LoadingIndicator**组件中的动作按钮。最后，为了提供实时的进度反馈，我们利用**Label**属性在按钮上渲染文本。现在，当操作正在运行时，Blazor不仅会禁用按钮，还会在它上面渲染当前的进度。
- en: In *step 12* , we navigate to the **@code** block of the **TicketManager** component
    and implement a **SaveAsync()** method. The **SaveAsync()** method is just a proxy
    method that allows intercepting the current iteration index, finding the related
    ticket object in the **Tickets.All** collection, and passing it over for saving.
    In *step 13* , we jump to the **TicketManager** markup and, at the very top, we
    embed **ProgressIndicator** . Having the **SaveAsync()** method in place, we can
    attach it to the **ProgressIndicator** component required **Job** parameter. For
    the other required parameter – **Total** – we count the number of objects in the
    **Tickets.All** collection. With that setup, **ProgressIndicator** allows users
    to trigger the saving of each ticket and see the operation progress as it’s running.
    In *step 14* , we remove the button allowing to toggle tickets and the related
    **ShowTickets** check. We will no longer need them, as we will delegate the control
    over displaying the **Tickets.All** collection to **LoadingIndicator** . In *step
    15* , we locate the loop in which we render ticket containers. We wrap that entire
    area inside the **LoadingIndicator** component. As **LoadingIndicator** requires
    a **Job** delegate, we leverage a lambda expression and attach the **Tickets.GetAsync()**
    method. Now, when users request to load data, **LoadingIndicator** renders the
    **Loading…** message and triggers **Tickets.GetAsync()** seamlessly. When loading
    completes, the **LoadingIndicator** component updates the UI with a fresh set
    of ticket containers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，我们导航到**TicketManager**组件的**@code**块并实现一个**SaveAsync()**方法。**SaveAsync()**方法只是一个代理方法，允许拦截当前迭代索引，在**Tickets.All**集合中找到相关的票据对象，并将其传递以保存。在*步骤13*中，我们跳转到**TicketManager**标记，并在顶部嵌入**ProgressIndicator**。由于有**SaveAsync()**方法，我们可以将其附加到需要**Job**参数的**ProgressIndicator**组件。对于其他必需参数——**Total**——我们计算**Tickets.All**集合中的对象数量。有了这样的设置，**ProgressIndicator**允许用户触发每个票据的保存并看到操作进度。在*步骤14*中，我们移除允许切换票据和相关**ShowTickets**复选框的按钮。我们将不再需要它们，因为我们将会将显示**Tickets.All**集合的控制权委托给**LoadingIndicator**。在*步骤15*中，我们定位到渲染票据容器的循环。我们将整个区域包裹在**LoadingIndicator**组件内部。由于**LoadingIndicator**需要一个**Job**委托，我们利用lambda表达式并附加**Tickets.GetAsync()**方法。现在，当用户请求加载数据时，**LoadingIndicator**渲染**Loading…**消息并无缝触发**Tickets.GetAsync()**。当加载完成时，**LoadingIndicator**组件使用一组新的票据容器更新UI。
- en: There’s more…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have already realized which scenarios the loading and progress indicators
    fit but let me give you a simple rule of thumb.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到加载和进度指示器适用于哪些场景，但让我给你一个简单的经验法则。
- en: Any loading indicators are ideally suited for operations with unpredictable
    completion times, such as fetching data from an API, where the number of results
    and their arrival time are unknown.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 任何加载指示器都非常适合具有不可预测完成时间的操作，例如从API获取数据，其中结果的数量和到达时间都是未知的。
- en: Progress indicators, such as a progress bar, are ideal for operations with known
    results, such as submitting data changes or sending notifications.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 进度指示器，如进度条，非常适合已知结果的操作，例如提交数据更改或发送通知。
