- en: '*Chapter 3*: Developing UI with the Unity UI System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI is very important for a game, and Unity offers three different UI solutions
    for game developers. They are the **Immediate Mode Graphical User Interface**
    (**IMGUI)**, the **Unity UI** (**uGUI**) package, and the **UI Toolkit**. IMGUI
    is a relatively old UI solution in Unity and it is not recommended for building
    a runtime UI. The UI Toolkit is the latest UI solution; however, it is still missing
    some features you can find in the uGUI package and IMGUI. The uGUI package is
    a mature UI solution in Unity that is widely used in the game industry. Therefore,
    this chapter will introduce how to use uGUI to develop the UI of your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: C# scripts and common UI elements in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# scripts and the UI Event System in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Model-View-ViewModel** (**MVVM**) pattern and the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tips to increase performance of the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: C# scripts and common UI components in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: uGUI has been provided as a built-in package in the Unity Editor since Unity
    2019; therefore, we can see the content of the uGUI package directly in the **Project**
    window, which also includes the C# source code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The uGUI package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The uGUI package
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous chapter, the Unity development workflow is primarily
    built around the structure of components. uGUI is no exception. It is a `GameObject`
    with a set of components.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 3.1*, we can find the C# source code of many commonly used
    UI elements, such as **Text**, **Slider**, and **Toggle**. However, some UI components
    are implemented using C++ code inside the engine, such as **Canvas**, and the
    code of such components cannot be viewed from within the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will introduce the commonly used UI components in Unity.
    We can divide these components into the following four categories, according to
    their functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Canvas`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image and Raw Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selectable UI components`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Canvas** is the most basic and important UI component of uGUI. To understand
    how to use uGUI correctly and efficiently, it is essential to understand **Canvas**
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canvas** is the component used to render UI elements in uGUI. All UI elements
    should be located inside the area of a canvas, which is very simple to create
    in a scene.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Creating a canvas from the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.2_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Creating a canvas from the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 3.2*, you can create a new canvas as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** | **Canvas**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition to creating a new **Canvas** object from the **Hierarchy** window,
    we can also create a new **Canvas** object by clicking **GameObject** | **UI**
    | **Canvas**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Creating a canvas from the GameObject menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.3_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Creating a canvas from the GameObject menu
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.2* and *Figure 3.3*, we can also create other different
    UI elements from these menus, such as **Text**, **Button**, **Image**, and **Slider**.
    Since all UI elements are the children of **Canvas**, if you want to create a
    new UI element directly and there is no canvas, a new **Canvas** object will be
    created automatically. The new UI element will be a child object of the **Canvas**
    object parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – A Canvas object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.4_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – A Canvas object
  prefs: []
  type: TYPE_NORMAL
- en: Once a **Canvas** object is created, we can see that there is not only a **Canvas**
    component attached to this GameObject but also **Rect Transform**, **Canvas Scaler**,
    and **Graphic Raycaster** components. As mentioned previously, **Canvas** is the
    component used to render UI elements, so all UI components must be children of
    Canvas; otherwise, they will not be rendered by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore them separately in order.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you select the **Canvas** object in the scene, you may be surprised to find
    that its position is strange. By default, it is not in the field of view of **Main
    Camera**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode
    in the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.5_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – A Canvas object with the Screen Space - Overlay render mode in
    the scene
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the **Canvas** component attached to this GameObject provides
    three different **render modes**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Screen Space - Overlay**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen Space - Camera**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World Space**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Render modes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.6_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Render modes
  prefs: []
  type: TYPE_NORMAL
- en: The **Screen Space - Overlay** render mode places UI elements on the screen
    that are rendered on top of the scene. Therefore, the cameras located in the scene
    used to render the game scene will not affect the rendering of the UI. This is
    the default render mode provided by the **Canvas** component.
  prefs: []
  type: TYPE_NORMAL
- en: As the name implies, the **Screen Space - Camera** render mode is somewhat similar
    to the previous one. However, as can be seen from the name, the second render
    mode will be affected by the camera.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Screen Space - Camera render mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.7_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The Screen Space - Camera render mode
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.7*, if the **Screen Space - Camera** render mode
    is selected, we need to specify a camera for this canvas and set a distance between
    them. Furthermore, if we still select this canvas in the scene, we will find that
    it has been moved into the field of view of this particular camera.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in
    the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.8_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – A Canvas object with the Screen Space - Camera render mode in the
    scene
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the UI elements are rendered by this camera, which means that
    the camera settings affect the appearance of the UI. This is different from the
    **Screen Space - Overlay** render mode.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.9* shows that when the **Field of View** value of this camera is
    changed from 100 to 30, the game scene and the UI have changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half
    and 30 in the lower half'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.9_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – The field of view (FoV) of the camera is 100 in the upper half
    and 30 in the lower half
  prefs: []
  type: TYPE_NORMAL
- en: The last render mode is **World Space**. In this mode, the canvas will work
    like any other GameObject in the scene. The biggest difference between this mode
    and the **Screen Space - Camera** render mode is that we can manually adjust the
    size, position, and even rotation angle of the canvas, just like a normal GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 3.10*, we can use the **Rect Transform** component of this
    **Canvas** object to adjust its **Width** and **Rotation** values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – The World Space render mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – The World Space render mode
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.11* shows the **Canvas** object in the scene after manually setting
    the **Width** and **Rotation** values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – A Canvas object with the World Space render mode in the scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – A Canvas object with the World Space render mode in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the **RectTransform** component to set the size of the canvas.
    Every UI object will contain a **RectTransform** component, just like every normal
    GameObject will contain a Transform component. Next, we will explore the **RectTransform**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The Rect Transform component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Rect Transform** component is similar to the regular **Transform** component.
    The biggest difference is that the former is used for UI elements instead of regular
    GameObjects. When a new UI element object is created, the **Rect Transform** component
    will be automatically attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this component, you can see some properties that can be seen on the
    **Transform** component, such as **Position**, **Rotation**, and **Scale**. There
    are also some unique properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – A Rect Transform component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – A Rect Transform component
  prefs: []
  type: TYPE_NORMAL
- en: These unique ones are **Anchor** and **Pivot**. We will discuss these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The anchors are numerical values indicating the position of the four corners
    of the area as seen from the `AnchorMin.x` and `AnchorMin.y`, and the upper right
    is represented by `AnchorMax.x` and `AnchorMax.y`. By default, the lower left
    is 0.5 and 0.5, and the upper right is also 0.5 and 0.5, centered relative to
    the parent, as shown in *Figure 3.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can directly modify the value of anchors – for example, we can change the
    lower-left corner from 0.5 and 0.5 to 0 and 0, so that the lower-left corner of
    the parent and child are the same. Then, we change the upper-right corner from
    0.5 and 0.5 to 0.5 and 1, which means that the position of the upper-right corner
    of the child is half of the *x* axis position of the upper-right corner of the
    parent. The result is shown in *Figure 3.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Modifying the anchors'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Modifying the anchors
  prefs: []
  type: TYPE_NORMAL
- en: Anchors are very useful when developing the UI in Unity. For example, if you
    want to display the UI at the top of the screen, such as a title, you need to
    specify the distance from the top of the parent. If you want to display the UI
    at the bottom of the screen, such as a footer, you need to specify the distance
    from the bottom of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make it easier for developers to use anchors, Unity provides some
    anchor presets, as shown in *Figure 3.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Anchor Presets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Anchor Presets
  prefs: []
  type: TYPE_NORMAL
- en: Pivot
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **Pivot** point is the origin of this rectangle area. The value of the
    **Pivot** point is specified in normalized values between 0 and 1\. When the UI
    element is scaled or rotated, it will scale or rotate around that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Rotate 45 degrees along the z axis around the center and'
  prefs: []
  type: TYPE_NORMAL
- en: 45 degrees along the z axis around the upper-right corner
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Rotate 45 degrees along the *z* axis around the center and 45
    degrees along the *z* axis around the upper-right corner
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.15* shows a 45-degree rotation along the *z* axis around the center,
    which has a **Pivot** point value of 0.5 and 0.5, and a 45-degree rotation along
    the *z* axis around the upper-right corner, which has a **Pivot** point value
    of 1 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas Scaler component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Along with the **Canvas** component, a **Canvas Scaler** component is also
    created automatically. The **Canvas Scaler** component is used to control the
    overall scale and pixel density of UI elements inside a canvas. By using **Canvas
    Scaler**, we can implement a resolution-independent UI layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – The Canvas Scaler component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – The Canvas Scaler component
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three **UI Scale Mode** types provided by a **Canvas Scaler** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant Pixel Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale With Screen Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant Physical Size**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the canvas render mode is **ScreenSpace - Overlay** or **ScreenSpace - Camera**,
    then we can set the UI Scale Mode. On the other hand, if the canvas render mode
    is **World Space**, the UI Scale Mode cannot be modified. Next, we will introduce
    these three different modes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constant Pixel Size** is the default UI Scale Mode. In this mode, the size
    of the UI elements will retain the same size in pixels regardless of screen size.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The Hello World UI text displayed in different screen sizes'
  prefs: []
  type: TYPE_NORMAL
- en: (1920 x 1080 in the upper half and 3840 x 2160 in the lower half)
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – The Hello World UI text displayed in different screen sizes (1920
    x 1080 in the upper half and 3840 x 2160 in the lower half)
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 3.17*, a **Hello World** UI text will retain its own size
    in pixels. When the screen resolution is relatively low (*1920 x 1080*), the text
    will be displayed larger. When at a higher screen resolution (*3840 x 2160*),
    the text will be displayed smaller.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to keep the UI elements displayed consistently under different screen
    resolutions, the **Scale With Screen Size** mode is an ideal option.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – The Scale With Screen Size mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – The Scale With Screen Size mode
  prefs: []
  type: TYPE_NORMAL
- en: If **UI Scale Mode** is set to **Scale With Screen Size**, the position and
    size of the UI elements will be specified according to the value of pixels in
    the **Reference Resolution** properties, as shown in *Figure 3.18*.
  prefs: []
  type: TYPE_NORMAL
- en: If the current screen resolution is greater than the reference resolution, the
    canvas will be scaled to fit the screen resolution. Conversely, if the current
    screen resolution is less than the reference resolution, the canvas will shrink
    to fit the screen resolution.
  prefs: []
  type: TYPE_NORMAL
- en: If the screen resolution ratio is the same as the reference resolution ratio,
    it is very easy to scale and shrink the UI elements. But when the screen resolution
    ratio is different from the reference resolution ratio, scaling the canvas will
    distort it. In order to avoid this situation, the resolution of the canvas will
    also depend on the setting of **Screen Match Mode**, which you can also see in
    *Figure 3.18*. By default, the **Screen Match Mode** setting is **Match Width
    or Height**, which allows you to scale the canvas area with the width or height
    as the reference, or a value in between.
  prefs: []
  type: TYPE_NORMAL
- en: When **UI Scale Mode** is set to **Constant Physical Size**, the position and
    size of UI elements are specified in physical units such as *millimeters* and
    *inches*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – The Constant Physical Size mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – The Constant Physical Size mode
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the **Canvas Scaler** component, another component is also automatically
    created, which we will take a look at next.
  prefs: []
  type: TYPE_NORMAL
- en: The Graphic Raycaster component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the name suggests, the **Graphic Raycaster** component is used to perform
    raycasting against a list of UI elements within a canvas to determine which of
    the UI elements has been hit. So it can translate the player's input into UI events.
    It should be noted that there needs to be an **Event System** component in the
    scene for **Graphic Raycaster** to work properly. About the **Event System** component,
    we will introduce it later in the section "*C# scripts and the UI Event System
    in Unity*".
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful when you need to determine whether the cursor is over UI elements
    in the scene, such as UI text or UI images. For example, say you want the player
    to be able to drag and drop a UI image into your game to change its position,
    then you have to know whether the player''s cursor is over the UI image and get
    data about the cursor movement when the drag occurs. In this case, you need to
    create a script that implements the `IPointerDownHandler` and `IDragHandler` interfaces
    defined in the `UnityEngine.EventSystems` namespace, meaning that you can get
    events when the player clicks and drags the image, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `UnityEngine.EventSystems` namespace with the `using` keyword to
    get events related to clicking and dragging UI elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DragAndDropExample` class implements the two interfaces, namely, `IPointerDownHandler`
    and `IDragHandler`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, we implement the `OnPointerDown` method in the `IPointerDownHandler`
    interface, which will be called when the UI element is clicked.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: And we implemented the `OnDrag` method in the `IDragHandler` interface. When
    a drag occurs, this method will be called every time the cursor is moved.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the implementation of the `OnPointerDown` method, which takes `PointerEventData`
    as an argument, gets an instance of the `RectTransform` component, and assigns
    it to the `_rectTransform` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the implementation of the `OnDrag` method, which also takes `PointerEventData`
    as an argument, gets the cursor position, and modifies the `position` property
    of the `_rectTransform` field to move the UI element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for this script to work, you need to attach the script to the UI element
    in the scene that you want to drag and drop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Dragging and dropping a UI image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Dragging and dropping a UI image
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.20* shows the UI image drag and drop interaction based on the **Graphic
    Raycaster** component.'
  prefs: []
  type: TYPE_NORMAL
- en: The components described previously are automatically created when a **Canvas**
    object is created. Next, we will introduce other UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Displaying images is an important function of the UI. There are two types of
    components provided by uGUI that display images – the **Image** component and
    the **Raw Image** component.
  prefs: []
  type: TYPE_NORMAL
- en: We will now explain these features and how to use them properly.
  prefs: []
  type: TYPE_NORMAL
- en: The Image component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the **Image** component to display an image on your UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Creating a new image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Creating a new image
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 3.21*, you can create a new image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** > **Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to create a background image for your game UI, you can also select
    **UI** > **Panel**. The panel is nothing but an image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – The Image component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – The Image component
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we create a panel as the background. As you can see in *Figure
    3.22*, here we specify a texture called **SF Background** as the source image
    of this **Image** component. It should be noted that the texture used by the **Image**
    component must be set to the Sprite type when imported into Unity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Texture Import Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Texture Import Settings
  prefs: []
  type: TYPE_NORMAL
- en: '**Texture Type** can be set in the texture''s **Import Settings** panel, as
    shown in *Figure 3.23*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sprites are 2D graphic objects used for the UI and other elements of 2D gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using sprites as an image source is that the corners will not
    be stretched or distorted when resizing the sprites.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – The Sprite Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – The Sprite Editor
  prefs: []
  type: TYPE_NORMAL
- en: This is because **Sprite Editor** in Unity provides the option of **9-slicing**
    the image, which divides the image into nine regions. As shown in *Figure 3.24*,
    in this case, when the image is resized, the corners of the image will remain
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 9-slicing is a common technique in UI implementation. The main advantage of
    using 9-slicing is that it can handle the stretching of the image very well. Once
    an image is stretched, there will be problems such as distortion and blurring,
    but some parts of the image can be stretched. For example, a UI background frame,
    the middle part of which is usually a solid color, can be stretched, but the four
    corners of the image may have some special patterns that cannot be stretched.
    At this time, we can use the 9-slicing technique to divide the whole image into
    nine grids, and each of the four corners is in a grid. Then, we can only stretch
    and enlarge the middle part of the image and keep the four corners as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in most cases, using the **Image** component to display UI images
    is the preferred choice.
  prefs: []
  type: TYPE_NORMAL
- en: The Raw Image component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Raw Image** component is another component used to display images on the
    game UI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Creating a new raw image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Creating a new raw image
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 3.25*, you can create a new image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** > **Raw Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The difference between the **Raw Image** component and the **Image** component
    is that the source of an **Image** component must be a **Sprite** type. Conversely,
    **Raw Image** accepts any texture. Also, the function of the **Raw Image** component
    is simpler than an **Image** component, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – A Raw Image component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – A Raw Image component
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to modify the image displayed by the **Image**
    and **Raw Image** components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that in order to be able to access UI-related classes in
    the code, we need to use the `UnityEngine.UI` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of the UI is **text**. Next, let's explore the two components
    provided by uGUI to display text.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to display characters in uGUI is to use the **Text** component.
    However, it is also troublesome to adjust the spacing between characters and express
    decorations with **Text** alone. **TextMeshPro** is another option, which provides
    gorgeous character expression. In this section, we will explore the **Text** and
    **TextMeshPro** components in turn.
  prefs: []
  type: TYPE_NORMAL
- en: The Text component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Text** component is a component commonly used to display UI text since
    the early days of uGUI. Creating text for the game UI is very simple; just follow
    these step:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** > **Text**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Creating text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – Creating text
  prefs: []
  type: TYPE_NORMAL
- en: 'A **Text** object will be created in the canvas; we can find it in the **Scene**
    view of the Unity Editor, as shown in *Figure 3.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Text in the Scene view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Text in the Scene view
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the text content is in a white frame, which represents the
    **Rect Transform** component attached to this **Text** object and identifies its
    size. If changing the font size causes the text content to exceed this white frame,
    the text content cannot be displayed. Therefore, remember to consider the **Rect
    Transform** component of **Text** when changing the font size.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to changing the font size, you can also change the font used or
    enable **Rich Text**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – The Text component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – The Text component
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 3.29*, if the `<b></b>, <i></i>,` and `<color></color>`,
    within the text to provide style changes to the text.
  prefs: []
  type: TYPE_NORMAL
- en: However, the function provided by the **Text** component is relatively simple.
    When the **Text** component changes, the polygon used to display the text needs
    to be recalculated, resulting in graphic reconstruction, which can cause potential
    performance problems, and when displayed in high resolution, the text rendered
    by this component looks very blurry. Therefore, after the original **Text** component,
    Unity also provides another text solution for the UI. Next, we will introduce
    the **TextMesh Pro** component.
  prefs: []
  type: TYPE_NORMAL
- en: The TextMeshPro component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TextMeshPro** (**TMP**) is the ultimate text solution for the UI provided
    by Unity. It is a powerful mechanism for text rendering that can be used to replace
    the **Text** component. **TextMesh Pro** has been designed to take advantage of
    **Signed Distance Field** (**SDF**) rendering, allowing it to render text beautifully
    at any resolution. You can also create custom shaders for **TextMesh Pro** to
    get effects such as outlines and soft shadows.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that it is not included in the default `Unity UI` package,
    but is included in the `TextMeshPro` package. So if you can't find **TextMesh
    Pro** when creating UI text, then you should first check whether this package
    has been added to your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Creating a TextMeshPro object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Creating a TextMeshPro object
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating **TextMeshPro** text for the game UI is very simple; just follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** > **Text** > **TextMeshPro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.31 – The TextMeshPro component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – The TextMeshPro component
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 3.31*, the text rendered by **TextMeshPro** is sharper than
    that rendered by the **Text** component.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to rendering the text sharper, **TextMeshPro** also provides improved
    control over text format and layout. As shown in *Figure 3.32*, you can directly
    change the style of the text through the editor. There are several common styles
    to choose from, such as *bold* and italics. Similarly, you can also use tags to
    modify the text style, just like the **Text** component, and features such as
    **Spacing Options**, **Alignment**, and **Wrapping**, can be used to control the
    text layout.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can also achieve more rendering effects, such as clicking the
    outline option of the shader to add outline effects to the text.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – The TextMeshPro component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – The TextMeshPro component
  prefs: []
  type: TYPE_NORMAL
- en: Using TextMesh Pro to implement your UI text is a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: Selectable UI components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use selectable components in uGUI to handle interactions. These components
    include **Button**, **Toggle**, **Slider**, **Dropdown**, **Input Field**, and
    **Scrollbar**. In this section, we will mainly discuss the most commonly used
    component, namely, the **Button** component.
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a **Button** element for the game UI is very simple; just follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **UI** > **Button - TextMeshPro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Creating a Button object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – Creating a Button object
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 3.33*, there are two options to create a button in the menu,
    namely, **Button** and **Button -TextMeshPro**. Here, we select **Button -TextMeshPro**
    so that the text content on the button is rendered by **TextMeshPro**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – An Image component and a Button component are attached to the
    button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – An Image component and a Button component are attached to the
    button
  prefs: []
  type: TYPE_NORMAL
- en: Once a default button object is created, this object includes not only a **Button**
    component but also an **Image** component. This is because the **Button** component
    only provides the function of interacting with the user; it does not provide the
    function of graphic display. Therefore, the image of the button needs an **Image**
    component to display.
  prefs: []
  type: TYPE_NORMAL
- en: Selected states
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Selectable` class, namely, `Normal`, `Highlighted`, `Pressed`, `Selected`,
    and `Disabled`, which are defined by an enumeration named `Selectable.SelectionState`.
    Therefore, as shown in *Figure 3.34*, there are five different colors in the **Transition**
    section corresponding to these five different selected states, which means that
    when the user interacts with this button, this button will provide different feedback
    according to the different states.
  prefs: []
  type: TYPE_NORMAL
- en: onClick
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The important role of a button is to receive user clicks and trigger corresponding
    events. In Unity, it is very easy to set up button `onClick` events. You can either
    manually set up button `onClick` events in the editor or set button `onClick`
    events programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: In order to set up a new event to the button in the editor, we can click the
    **+** button at the bottom of the **On Click ()** section, as shown in *Figure
    3.35*. This will create a new action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Setting up a new onClick event in the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Setting up a new onClick event in the editor
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also programmatically set the button `onClick` event; the following
    code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned about commonly used UI components and got an understanding
    of uGUI, the UI solution provided by Unity. Next, we will explore the UI Event
    System in Unity. If there is no event system in the scene, UI elements such as
    buttons cannot interact with players, so it's an important topic.
  prefs: []
  type: TYPE_NORMAL
- en: C# scripts and the UI Event System in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**EventSystem** is a mechanism for sending events to objects in a game that
    supports keyboards, mice, screen touches, and so on. EventSystem consists of multiple
    modules for sending events. If there is no **EventSystem** object in the scene,
    then, when creating a canvas, an **EventSystem** object will be automatically
    created along with it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – EventSystem'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – EventSystem
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 3.36*, the **Inspector** window of the **EventSystem** object
    exposes very few functionalities. This is because EventSystem is designed as a
    manager for cooperation between various **input modules**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that there can be, at most, one **EventSystem** object in
    a scene. If there are multiple **EventSystem** objects in the scene, a warning
    message will be displayed, as shown in *Figure 3.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – A warning message when there are multiple EventSystem objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – A warning message when there are multiple EventSystem objects
  prefs: []
  type: TYPE_NORMAL
- en: When the game is running, **EventSystem** will look for the **InputModule**
    component attached to the same GameObject. This is because **InputModule** is
    the class responsible for the main logic of **EventSystem**. We can also find
    the Input Module used in this case, as shown in *Figure 3.36*, namely, **Standalone
    Input Module**. Next, we will introduce Input Modules.
  prefs: []
  type: TYPE_NORMAL
- en: Input Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides two built-in Input Modules, namely, the **Standalone Input Module**
    and the **Touch Input Module**. In the past, the Standalone Input Module was used
    for keyboards, mice, and game controllers, and the Touch Input Module was for
    touch panels such as smartphones. Nowadays, the Standalone Input Module is compatible
    with all platforms and the Touch Input Module has been deprecated, so you can
    treat the Input Module as the Standalone Input Module.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the Input Module is to map hardware-specific inputs (such as
    touches, joysticks, mice, and game controllers) to events sent through the messaging
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The new Input System package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to this default built-in Input Module, Unity also provides a new,
    more powerful, flexible, and configurable **Input System** package.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – The Input System package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – The Input System package
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the new input system, then you need to install the package
    from the Package Manager window, as shown in *Figure 3.38*. Moreover, a newly
    created **EventSystem** component will still use the legacy **Standalone Input
    Module** component by default, so you need to manually replace it with the new
    **InputSystemUIInputModule** component, as shown in *Figure 3.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Replace with InputSystemUIInputModule'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.39_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Replace with InputSystemUIInputModule
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, we learned that in order to ensure that the game UI
    can correctly respond to player input, an **EventSystem** component and an Input
    Module are necessary. Next, let's move on to discussing how to create UI in Unity
    using the Model-View-ViewModel (MVVM) pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Model-View-ViewModel (MVVM) pattern and the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common challenge in Unity development is to find elegant ways to decouple
    components from each other, especially when developing the UI because it involves
    UI logic and UI rendering. **Model–View–ViewModel** (**MVVM**) is a software architectural
    pattern that helps developers separate the **ViewModel**, which is the UI logic,
    from the **View**, which is the UI graphics. In this section, we will explore
    how to implement an MVVM pattern in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 – MVVM'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.40_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.40 – MVVM
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, MVVM consists of three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Database`, or `PlayerPrefs`, which stores player preferences in Unity, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour` and is attached to the UI object. Its main role is to manage
    UI elements and trigger UI events, but it does not implement any concrete UI logic
    itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonoBehaviour`. It does not need to consider what the UI looks like; it only
    needs to implement concrete logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that there are three parts in MVVM, so how should they be connected?
    Generally, we use two ways to connect them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewModel` and `View`. Elements bound to data will automatically reflect every
    data change. By using data binding, a `ViewModel` can modify the value of the
    UI control in the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven programming**: This method is used to raise events from the
    View triggered by user actions, which are then processed by the ViewModel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some mature MVVM framework implementations for Unity, such as the
    **Loxodon Framework**, which is a lightweight MVVM framework built specifically
    to target Unity. You can find its repository on GitHub ([https://github.com/vovgou/loxodon-framework](https://github.com/vovgou/loxodon-framework))
    or add it to your project via Unity Asset Store directly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41 – Loxodon Framework'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.41_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.41 – Loxodon Framework
  prefs: []
  type: TYPE_NORMAL
- en: Since our next example will use this framework, I recommend that you import
    this framework into your project first. After importing this framework, you should
    find it in the `Assets` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42 – The LoxodonFramework folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.42_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.42 – The LoxodonFramework folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s perform the following steps to implement a sample MVVM UI via **LoxodonFramework**
    in Unity:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's set up `LoxodonFramework` in our game scene. We need to create
    a new canvas and add the **GlobalWindowManager** component to this canvas, as
    shown in *Figure 3.43*. A **GlobalWindowManager** component is a container that
    is used to manage views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.43 – The GlobalWindowManager component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.43_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.43 – The GlobalWindowManager component
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to define a view. As we mentioned earlier, a view represents
    UI elements in Unity. As you can see from the following code, this view is relatively
    simple, containing only a button UI element and a text UI element, and this `SampleView`
    class inherits from the `Window` class in the Loxodon Framework. In the following
    code, you can also find the `BindingSet` class, which is used to bind and connect
    properties of `ViewModel` and `View`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s break down this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The two `_submitButton` and `_message` fields of this `SampleView` class refer
    to a `Button` component and a `TextMeshProUGUI` component, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnCreate` method, we first create a `BindingSet` instance to bind `SampleView`
    to its corresponding `ViewModel` class – that is, `SampleViewModel`. We will introduce
    how to create the `SampleViewModel` class later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we bind the `text` property of the `_message` field in `SampleView` to
    the `Message` property in `SampleViewModel` by calling the `Bind` method of `BindingSet`.
    You can see in the code that we use `OneWay` binding here, which means that only
    the view model can modify the value of the UI element in the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also bind the `onClick` event of the `_submitButton` field in `SampleView`
    to the `Submit` method in `SampleViewModel`. Finally, we call the `Build` method
    of `BindingSet` to build the binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, we also need to create these required UI elements in the Unity
    scene, as shown in the following figure. Let's call it **SampleUI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.44 – Setting up the UI elements'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.44_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.44 – Setting up the UI elements
  prefs: []
  type: TYPE_NORMAL
- en: Then, let's create a new folder called `Resources` and create a prefab for this
    sample UI by dragging it from the **Hierarchy** window to the **Resources** folder,
    as shown in the following screenshot. So far, we have created UI elements and
    a **View** component that represent UI elements in the MVVM architecture. **SampleUI**
    can be removed from the scene because we will load its prefab and create the UI
    at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.45 – The SampleUI prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.45_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.45 – The SampleUI prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `SampleViewModel` class, which implements concrete logic. The
    `SampleViewModel` class inherits from the `ViewModelBase` class in the Loxodon
    framework, and the logic is implemented in the `Submit` method, which modifies
    the `Message` property. In the view we created earlier, we bound the button''s
    `onClick` event to the `Submit` method in the `SampleViewModel` class, and we
    also bound the view''s `text` property of the Text UI element to the `Message`
    property of `SampleViewModel`. Therefore, after the `Submit` method modifies the
    `Message` property, the modified message content will be displayed on the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, start up code is needed to register services and create the UI. The
    following start up code supports loading the prefab of `ApplicationContext` class
    in the following code; we use it to store data and services that can be accessed
    by other classes in the Loxodon Framework. Then, the code registers the `IUIViewLocator`
    service to load the UI prefab and create the UI elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's run the game. As you can see in the following screenshot, we create a
    view that displays the message text at the top and a `SampleViewModel` class to
    update the message information, and the view will also update the UI text to display
    the latest information through data binding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.46 – The sample UI with MVVM'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.46_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.46 – The sample UI with MVVM
  prefs: []
  type: TYPE_NORMAL
- en: This way, the UI graphics and UI logic are separated. UI designers and programmers
    can work at the same time without relying on each other, thereby improving the
    efficiency of UI development in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how to use MVVM to implement the UI in Unity.
    Next, we will learn what we must pay attention to when implementing the UI in
    Unity – that is, optimizing UI performance.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tips to increase performance of the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UI is an important part of a game, so if you do not implement it properly,
    it may cause potential performance issues. In this section, we will discuss the
    best practices for implementing the game UI in Unity to optimize the performance
    problems caused by the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first best practice tip is to be good at using the Unity **Profiler**.
    The Profiler is a tool that you can use to get performance data about your game,
    including **CPU Usage**, **GPU Usage**, **Rendering**, **Memory,** **UI**, and
    **UI Details**. In order to view performance data about the UI, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Window** > **Analysis** > **Profiler** to open the **Profiler** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **UI** or **UI Details** module area in the **Profiler** window to
    view performance data related to the UI, such as the CPU time consumed by **Layout**
    and **Render**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.47 – The UI area in the Profiler window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.47_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.47 – The UI area in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the **UI** and **UI Details** areas, the **CPU Usage** area
    in the **Profiler** window also provides performance information related to the
    UI. In the **CPU Usage** area, you can see the CPU time consumed by a specific
    marker, such as **UGUI.Rendering.RenderOverlays**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.48 – The CPU Usage area in the Profiler window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.48_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.48 – The CPU Usage area in the Profiler window
  prefs: []
  type: TYPE_NORMAL
- en: This was just a brief introduction to the Profiler tool. In the following chapters,
    we will discuss the Unity Profiler in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple canvases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second-best practice tip is a very important aspect that needs to be considered
    when implementing the UI in Unity, especially when your game UI is very complex.
    If necessary, you may need to create multiple canvases to manage and display different
    UI elements. As we have mentioned before, a canvas generates meshes representing
    the UI elements placed on it and regenerates the meshes when the UI elements change.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you build the UI of the entire game in a single canvas with thousands
    of UI elements, and when one or more UI elements on the canvas change, all the
    meshes used to display the UI regenerate. This may be expensive, and you may experience
    CPU spikes that take a few milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is a good idea to create multiple different canvases to manage
    them, based on the update frequency of UI elements. For example, frequently updated
    dynamic UI elements such as progress bars and timers can be in one canvas, and
    infrequently updated static UI elements such as UI panels and background images
    can be in another. Of course, there is no magic bullet; you need to manage the
    canvas on a project-by-project basis.
  prefs: []
  type: TYPE_NORMAL
- en: Use Sprite Atlas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we introduced when discussing UI images, sprites are 2D graphic objects used
    for the UI and other elements of 2D gameplay. When importing a new texture into
    the Unity Editor, we can set the texture type of this texture to a sprite. So,
    your game project may contain a lot of sprite files. If so, many sprites are treated
    as separate individuals, and rendering performance may decrease. This is because
    Unity will issue a **draw call** for each sprite in the scene, and multiple draw
    calls may consume a lot of resources and negatively affect your game performance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A draw call is a call to the graphics API to draw objects (for example, to draw
    a triangle).
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, there are two draw calls to render **Button1**
    and **Button2** because these two buttons use two different textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.49 – Multiple draw calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.49_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.49 – Multiple draw calls
  prefs: []
  type: TYPE_NORMAL
- en: So, it is a good idea to combine several textures or sprites into a combined
    texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform the following steps to use the **Sprite Atlas** provided by
    Unity to combine textures:'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Sprite Atlas** packing is disabled, enable it in **Edit** > **Project
    Settings** > **Editor** > **Sprite Packer** > **Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Assets** > **Create** > **2D** > **Sprite Atlas** to create a Sprite
    Atlas asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.50 – Creating a Sprite Atlas'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.50_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.50 – Creating a Sprite Atlas
  prefs: []
  type: TYPE_NORMAL
- en: Under the **Objects for Packing** drop-down menu of the Sprite Atlas asset,
    select the **+** symbol to add textures or folders to the Sprite Atlas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, we still need to be aware that although Sprite Atlas can effectively
    reduce the count of draw calls, improper use can easily lead to a waste of memory.
    When a sprite is active in an atlas, Unity loads all the sprites in the atlas
    to which the sprite belongs. If there are many sprites in an atlas, even if only
    one sprite is referenced in the scene, the whole atlas will be loaded, which will
    cause large memory consumption. In order to solve this problem, the sprites can
    be packaged into multiple smaller atlases according to their purpose. For example,
    the sprites used in the login panel can be packaged as a login panel atlas, while
    the sprites used in the game character panel are packaged as a character panel
    atlas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by introducing some of the most commonly used UI
    component classes of the uGUI solution, such as the **Canvas**, **Rect Transform**,
    and **Image** components. We then explained the Event System in Unity, the legacy
    Input Module, and the new more powerful Input System package provided by Unity.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to decouple components from each other when developing
    the UI in Unity by using the MVVM architectural pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored some best practices for implementing the game UI in Unity
    to optimize the performance problems caused by the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the animation system in Unity and,
    at the same time, we will also introduce how to optimize animation performance
    in Unity.
  prefs: []
  type: TYPE_NORMAL
