<html><head></head><body>
<div id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-180"><a id="_idTextAnchor189"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-181"><a id="_idTextAnchor190"/><span class="koboSpan" id="kobo.2.1">Catching Exceptions with Exception Handling</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We always try to make our code as stable as possible when building web applications, but there are times when we can’t catch everything. </span><span class="koboSpan" id="kobo.3.2">This is why exceptions are considered a foundational part of development. </span><span class="koboSpan" id="kobo.3.3">Exception handling is essential for preventing web applications from crashing and displaying an ugly error message on a page. </span><span class="koboSpan" id="kobo.3.4">It’s tempting to wrap everything with </span><strong class="source-inline"><span class="koboSpan" id="kobo.4.1">try</span></strong><span class="koboSpan" id="kobo.5.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">catch</span></strong><span class="koboSpan" id="kobo.7.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">try</span></strong><span class="koboSpan" id="kobo.9.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">finally</span></strong><span class="koboSpan" id="kobo.11.1"> statements and move on. </span><span class="koboSpan" id="kobo.11.2">This should be avoided. </span><span class="koboSpan" id="kobo.11.3">Coding with </span><strong class="source-inline"><span class="koboSpan" id="kobo.12.1">try</span></strong><span class="koboSpan" id="kobo.13.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.14.1">catch</span></strong><span class="koboSpan" id="kobo.15.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.16.1">finally</span></strong><span class="koboSpan" id="kobo.17.1"> statements in an application should be the exception to </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">the rule.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">The common coding standards in this chapter are meant to remove those types of scenarios and provide a better </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">developer experience.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">In this chapter, we’ll examine what exception handling means to developers and when to use it, along with where to handle global exceptions and examine performance considerations. </span><span class="koboSpan" id="kobo.21.2">Once we understand the basics of exception handling, the last section will cover some common practices of exception handling, such as applying the “prevention before exception” principle to code, using logging, learning how exception handling is similar to unit tests, and why empty catch blocks should </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">be avoided.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">Finally, we’ll learn how to use .NET’s new exception filter, along with pattern matching, when to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">finally</span></strong><span class="koboSpan" id="kobo.25.1"> blocks, and why it’s a good idea to </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">rethrow exceptions.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">exception handling</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Handling </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">global exceptions</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.33.1">Performance considerations</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Common exception </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">handling techniques</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.36.1">After completing this chapter, you’ll understand exception handling better, when and how to use it, how to implement global exception handling, and how to know if performance is a problem when using </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">exception handling.</span></span></p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor191"/><span class="koboSpan" id="kobo.38.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.39.1">We recommend using a favorite editor to add the exception handling code snippets throughout this chapter. </span><span class="koboSpan" id="kobo.39.2">Our recommendations are </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.41.1">Visual Studio (preferably the </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">latest version)</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Studio Code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.45.1">JetBrains Rider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.46.1">The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">the code.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor192"/><span class="koboSpan" id="kobo.48.1">Using exception handling</span></h1>
<p><span class="koboSpan" id="kobo.49.1">In this section, we’ll discuss what exception handling is, the two types of error handling, when to use error handling in an application, and how exceptions </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">affect performance.</span></span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor193"/><span class="koboSpan" id="kobo.51.1">What is exception handling?</span></h2>
<p><span class="koboSpan" id="kobo.52.1">Exception handling is the ability to recover gracefully from unexpected situations in the code during runtime; </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.53.1">how do we handle errors or problems we experience in applications? </span><span class="koboSpan" id="kobo.53.2">It also involves cleaning up allocated resources when issues occur to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">memory leaks.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">There are two types </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">of errors:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Runtime errors</span></strong><span class="koboSpan" id="kobo.58.1">: These are </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.59.1">unexpected errors we experience when running </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.61.1">Manual</span></strong><span class="koboSpan" id="kobo.62.1">: These are intentional errors </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.63.1">that are thrown based on a condition (for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">ArgumentNullException.ThrowIfNull()</span></strong><span class="koboSpan" id="kobo.65.1"> at the beginning of a method to confirm whether a parameter is null </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">or not).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.67.1">Since this book focuses on intermediate to advanced developers, we’re assuming debugging an ASP.NET application is a common process; we all know debugging and exception handling go hand-in-hand. </span><span class="koboSpan" id="kobo.67.2">Developers should have a general understanding of what the code in question does when they wrap it with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">try</span></strong><span class="koboSpan" id="kobo.69.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">catch</span></strong><span class="koboSpan" id="kobo.71.1"> block. </span><span class="koboSpan" id="kobo.71.2">The ability to create useful exceptions is extremely important. </span><span class="koboSpan" id="kobo.71.3">Exceptions should be clear </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">and simple.</span></span></p>
<p><span class="koboSpan" id="kobo.73.1">For example, early in my career, a developer was experiencing an error message telling them they were running out of disk space. </span><span class="koboSpan" id="kobo.73.2">Other developers were experiencing the same error in the application as well and were frantically trying to figure out the problem. </span><span class="koboSpan" id="kobo.73.3">The issue turned out to be a bad error message created by a developer along with a </span><em class="italic"><span class="koboSpan" id="kobo.74.1">server</span></em><span class="koboSpan" id="kobo.75.1"> running out of disk space, not individual developer machines. </span><span class="koboSpan" id="kobo.75.2">This could’ve been avoided by </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.76.1">creating better log messages or detecting whether there was disk space available. </span><span class="koboSpan" id="kobo.76.2">While we can write better error messages in the exception handlers, we can only protect the code from </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">so much.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Seriously, though – the ability to create a simple and clear error message can be a challenge while coding, but it does make a difference in the long run. </span><span class="koboSpan" id="kobo.78.2">We’ll cover some of the common exception handling techniques in the </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">next section.</span></span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor194"/><span class="koboSpan" id="kobo.80.1">When to use exception handling</span></h2>
<p><span class="koboSpan" id="kobo.81.1">The ability to identify whether or not code requires an exception handler can be tricky. </span><span class="koboSpan" id="kobo.81.2">In addition to </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.82.1">whether a </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">try</span></strong><span class="koboSpan" id="kobo.84.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">catch</span></strong><span class="koboSpan" id="kobo.86.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.87.1">finally</span></strong><span class="koboSpan" id="kobo.88.1"> block is required, are there resources involved that we need to </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">clean up?</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Context is important when it comes to exception handling. </span><span class="koboSpan" id="kobo.90.2">In my experience, I always ask three questions before adding </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">exception handling:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Can I legitimately handle this error myself?</span></strong><span class="koboSpan" id="kobo.93.1"> An example could be using </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">TryParse</span></strong><span class="koboSpan" id="kobo.95.1"> instead of a full </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">try</span></strong><span class="koboSpan" id="kobo.97.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">catch</span></strong><span class="koboSpan" id="kobo.99.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">finally</span></strong><span class="koboSpan" id="kobo.101.1"> block or having to manually throw an error because of an </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">invalid parameter.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Will an external resource throw exceptions?</span></strong><span class="koboSpan" id="kobo.104.1"> Examples include web APIs, storage issues, file missing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">so on.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Do I have to clean up after myself if an error occurs?</span></strong><span class="koboSpan" id="kobo.107.1"> Examples include losing a file connection, loading a bitmap, or a </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">database connection.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.109.1">Developers should only use exception handling when they encounter a line of code that they cannot handle </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.110.1">and is considered outside of their control, similar to the possibility of not enough disk </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">drive space.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">In this section, we reviewed what exception handling was and when to use </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">it properly.</span></span></p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor195"/><span class="koboSpan" id="kobo.114.1">Handling global exceptions</span></h1>
<p><span class="koboSpan" id="kobo.115.1">As mentioned earlier in </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.116.1">this chapter, we can only handle so many errors when it comes to web applications. </span><span class="koboSpan" id="kobo.116.2">But what if we want to provide a catch-all for all </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">unhandled exceptions?</span></span></p>
<p><span class="koboSpan" id="kobo.118.1">For global exceptions, we need to revisit the middleware. </span><span class="koboSpan" id="kobo.118.2">There is a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">UseExceptionHandler()</span></strong><span class="koboSpan" id="kobo.120.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">Startup.cs</span></strong><span class="koboSpan" id="kobo.122.1"> file that points to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">/Error</span></strong><span class="koboSpan" id="kobo.124.1"> page (either Razor or MVC), as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}</span></pre> <p><span class="koboSpan" id="kobo.127.1">Pay particular attention to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">env.IsDevelopment()</span></strong><span class="koboSpan" id="kobo.129.1"> condition. </span><em class="italic"><span class="koboSpan" id="kobo.130.1">The </span></em><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">/Error</span></strong><em class="italic"><span class="koboSpan" id="kobo.132.1"> page is meant for non-development viewing only</span></em><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">As we mentioned back in </span><a href="B19493_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.134.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.135.1"> regarding security, always be careful what to show on this page. </span><span class="koboSpan" id="kobo.135.2">It may expose system data such as a database connection string that contains credentials or other </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">sensitive data.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">To access the exception through the error page, we require the </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">IExceptionHandlerPathFeature</span></strong><span class="koboSpan" id="kobo.139.1"> instance through </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">HttpContext.Features</span></strong><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">This can </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.142.1">be seen in the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">OnGet()</span></strong><span class="koboSpan" id="kobo.144.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1"> page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.148.1">
public void OnGet()
{
    RequestId = Activity.Current?.Id ?? </span><span class="koboSpan" id="kobo.148.2">HttpContext.TraceIdentifier;
    var exceptionFeature =
        HttpContext.Features.Get&lt;IExceptionHandlerPathFeature&gt;();
    // Access the Exception through exceptionFeature?.Error
    // Access the Path through exceptionFeature?.Path
    if (exceptionFeature?.Path == "/")
    {
        ErrorMessage ??= string.Empty;
        ErrorMessage += " We have bigger problems if the main page is             bombing.";
        _logger.Log(LogLevel.Error, exceptionFeature?.Error,             ErrorMessage);
    }
}</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">HttpContext.Features</span></strong><span class="koboSpan" id="kobo.150.1"> gives us access to the error. </span><span class="koboSpan" id="kobo.150.2">From there, we need to determine what to display on the page. </span><span class="koboSpan" id="kobo.150.3">In this case, we can see that the main page contains the error. </span><span class="koboSpan" id="kobo.150.4">Once we have identified the issue, we can create a public message, and log the error, and store it in </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">ErrorMessage</span></strong><span class="koboSpan" id="kobo.152.1"> so that the main page can </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">display it.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">While this is a simplistic example, alternatively, we can use our middleware to catch global errors as well. </span><span class="koboSpan" id="kobo.154.2">Instead of </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.155.1">passing in a page location, we can use a Lambda for our exception handling in the middleware, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.157.1">
app.UseExceptionHandler(handler =&gt;
{
    var logger = loggerFactory.CreateLogger("Middleware");
    handler.Run(async context =&gt;
    {
        context.Response.StatusCode = StatusCodes.            Status501NotImplemented;
        context.Response.ContentType = MediaTypeNames.Text.Plain;
        await context.Response.WriteAsync("Uh-oh...an exception was             thrown.");
        var exceptionFeature =
            context.Features.Get&lt;IExceptionHandlerPathFeature&gt;();
        if (exceptionFeature?.Path == "/")
        {
            var message = " Yep, the home page isn't implemented                 yet.";
            await context.Response.WriteAsync(message);
            logger.Log(LogLevel.Error, exceptionFeature.Error,                 $@"Error:{message}");
        }
    });
});</span></pre> <p><span class="koboSpan" id="kobo.158.1">We retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">ExceptionHandlerPathFeature</span></strong><span class="koboSpan" id="kobo.160.1"> instance the same way as we did on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">/Error</span></strong><span class="koboSpan" id="kobo.162.1"> page. </span><span class="koboSpan" id="kobo.162.2">Of </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.163.1">course, we always want to log the error, so we know what to fix (“It’s that darn home </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">page again”).</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">In this section, we learned how to use middleware to create a global exception handler. </span><span class="koboSpan" id="kobo.165.2">This allows us to centralize the error handling and avoid too many exception handlers throughout our application. </span><span class="koboSpan" id="kobo.165.3">Next, we’ll focus on performance considerations when writing </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">exception handlers.</span></span></p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor196"/><span class="koboSpan" id="kobo.167.1">Performance considerations</span></h1>
<p><span class="koboSpan" id="kobo.168.1">One common myth about exception handling is that it doesn’t affect performance. </span><span class="koboSpan" id="kobo.168.2">If exceptions are </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.169.1">significantly harming the application’s performance, that’s a sign that exceptions are being used too much. </span><span class="koboSpan" id="kobo.169.2">Exceptions should not control the flow of the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">application whatsoever.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Ideally, the code should flow with no interruptions. </span><span class="koboSpan" id="kobo.171.2">In small web applications with a few users, this type of approach may be adequate, but for high-performing, high-traffic websites, placing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">try</span></strong><span class="koboSpan" id="kobo.173.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">catch</span></strong><span class="koboSpan" id="kobo.175.1"> block in frequently-called code may cause the site to suffer a </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">performance hit.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">In this section, we covered what exception handling was, reviewed the two types of errors in applications, identified where exception handling is ideal, and covered some of the performance myths regarding exceptions. </span><span class="koboSpan" id="kobo.177.2">Next, we’ll look at some common exception </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">handling techniques.</span></span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor197"/><span class="koboSpan" id="kobo.179.1">Common exception handling techniques</span></h1>
<p><span class="koboSpan" id="kobo.180.1">Exceptions are </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.181.1">expensive in .NET. </span><span class="koboSpan" id="kobo.181.2">When an exception occurs in the application, there are resources in place to begin the error handling process when an exception occurs, such as the stack trace process. </span><span class="koboSpan" id="kobo.181.3">Even when we are catching and handling the errors, ASP.NET is still creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">Exception</span></strong><span class="koboSpan" id="kobo.183.1"> object and everything associated with it along with walking up the call stack to locate </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">the handler.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">In this section, we’ll look at common approaches in the industry to minimize the exceptions through “prevention before exception,” why to use logging, why unit testing is similar to exception </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.186.1">handling, why empty catch blocks should be avoided, how to simplify exceptions using exception filtering and pattern matching, why blocks are important when releasing resources, and how to rethrow </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">exceptions properly.</span></span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor198"/><span class="koboSpan" id="kobo.188.1">Prevention before exception</span></h2>
<p><span class="koboSpan" id="kobo.189.1">As we said in the previous section, exceptions interrupt the flow of an application when encountered and can cause more problems than intended, such as releasing resources that were previously allocated and triggering multiple exceptions up the call stack. </span><span class="koboSpan" id="kobo.189.2">If we’re writing </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">try</span></strong><span class="koboSpan" id="kobo.191.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">catch</span></strong><span class="koboSpan" id="kobo.193.1"> blocks of code to control the flow of the program, we’re doing it wrong. </span><span class="koboSpan" id="kobo.193.2">It’s best to perform checks before wrapping code with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">If there’s one thing to take </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.199.1">away from this chapter, let it be this principle: prevention </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">before exception.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">The concept of prevention before exception refers to the idea of trying to prevent the error from happening using less destructive methods, such as stopping the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">website completely.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">For example, examine the </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.205.1">
var number = "2";
int result;
try
{
    result = int.Parse(number);
}
catch
{
    result = 0;
}
// use result</span></pre> <p><span class="koboSpan" id="kobo.206.1">In a happy path, the number will be parsed and the result will be </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">2</span></strong><span class="koboSpan" id="kobo.208.1">. </span><span class="koboSpan" id="kobo.208.2">However, if the string contained a value of “hi”, the result will become </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">a zero.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">A better approach would be using the newest </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">TryParse</span></strong><span class="koboSpan" id="kobo.212.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">var</span></strong><span class="koboSpan" id="kobo.214.1">, a</span><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.215.1">s </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
var number = "2";
if (!int.TryParse(number, out var result))
{
    result = 0;
}
// use result</span></pre> <p><span class="koboSpan" id="kobo.218.1">With this approach, we are attempting to convert the number and store the converted value into a new </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.219.1">variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">result</span></strong><span class="koboSpan" id="kobo.221.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">TryParse</span></strong><span class="koboSpan" id="kobo.223.1"> returns true if the conversion was successful and false if not. </span><span class="koboSpan" id="kobo.223.2">If the conversion fails, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">result</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.225.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">0</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">We prevented an exception by handling the conversion through easier means. </span><span class="koboSpan" id="kobo.228.2">There are a large number of conversion methods in .NET and we can accomplish the same thing without </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">finally</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.234.1"> blocks.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">For simpler exceptions, look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">try</span></strong><span class="koboSpan" id="kobo.237.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">catch</span></strong><span class="koboSpan" id="kobo.239.1"> block and ask if we can apply some sort of prevention before </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">creating exceptions.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.241.1">Use logging</span></h2>
<p><span class="koboSpan" id="kobo.242.1">When creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">try</span></strong><span class="koboSpan" id="kobo.244.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">catch</span></strong><span class="koboSpan" id="kobo.246.1"> block, it’s </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.247.1">best to show the intent of what we want to get out of the code. </span><span class="koboSpan" id="kobo.247.2">Is the error something we can recover from or is it something that requires investigation when </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">it occurs?</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">If it’s the latter, it’s best to send a well-constructed error message to the logger before throwing the error. </span><span class="koboSpan" id="kobo.249.2">As mentioned in various chapters, it’s best to use a logging strategy to identify issues throughout the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.251.1">If we use the previous example to determine the value that caused the error, we can create a log entry, as </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
var number = "hi";
int result;
try
{
    result = int.Parse(number);
}
catch
{
    // gives us "OnGetAsync:invalid number - hi"
    _logger.LogInformation($"{MethodBase.GetCurrentMethod()}:invalid number - {number}");
    result = 0;
}
// use result</span></pre> <p><span class="koboSpan" id="kobo.254.1">While this gives us a </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.255.1">clear log entry for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">try</span></strong><span class="koboSpan" id="kobo.257.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">catch</span></strong><span class="koboSpan" id="kobo.259.1"> block, we can copy this one-liner to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">TryParse</span></strong><span class="koboSpan" id="kobo.261.1"> example </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">The idea is to provide enough information to developers without jarring the user’s experience </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">with errors.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor201"/><span class="koboSpan" id="kobo.265.1">Apply a unit testing methodology</span></h2>
<p><span class="koboSpan" id="kobo.266.1">If we have to </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.267.1">use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">try</span></strong><span class="koboSpan" id="kobo.269.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">catch</span></strong><span class="koboSpan" id="kobo.271.1"> block, look at it like a unit test. </span><span class="koboSpan" id="kobo.271.2">We mentioned that unit tests have the triple-A approach (Arrange, Act, and Assert). </span><span class="koboSpan" id="kobo.271.3">We want to create a minimal amount of code to get the job done and </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">move on.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">Initialize the objects at the beginning (Arrange) and wrap a </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">try</span></strong><span class="koboSpan" id="kobo.275.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">catch</span></strong><span class="koboSpan" id="kobo.277.1"> block around the suspecting line causing the error (Act). </span><span class="koboSpan" id="kobo.277.2">Minimize the amount of code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.281.1"> block.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">Once again, we can apply this </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.283.1">approach to the previous code example, which has been modified </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
// Arrange
var number = "2";
int result;
try
{
    // Act
    result = int.Parse(number);
}
// Assert
catch
{
    // gives us "OnGetAsync:invalid number - hi"
    _logger.LogInformation($"{MethodBase.GetCurrentMethod()}:invalid number - {number}");
    result = 0;
}
// use result</span></pre> <p><span class="koboSpan" id="kobo.286.1">Anything above the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">try</span></strong><span class="koboSpan" id="kobo.288.1"> statement would be considered part of </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Arrange</span></strong><span class="koboSpan" id="kobo.290.1">; the one-liner inside the try’s brackets is considered </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Act</span></strong><span class="koboSpan" id="kobo.292.1">. </span><span class="koboSpan" id="kobo.292.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Assert</span></strong><span class="koboSpan" id="kobo.294.1"> piece would be part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">catch</span></strong><span class="koboSpan" id="kobo.296.1"> statement. </span><span class="koboSpan" id="kobo.296.2">This statement would be the equivalent of a </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">failed </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">Assert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/><span class="koboSpan" id="kobo.300.1">Avoid empty catch statements</span></h2>
<p><span class="koboSpan" id="kobo.301.1">While preventing </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.302.1">errors is critical to our applications, consider an empty catch statement, as </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.304.1">
private void Deposit(Account myAccount, decimal amount)
{
    try
    {
        myAccount.Deposit(amount);
    }
    catch { }
}</span></pre> <p><span class="koboSpan" id="kobo.305.1">What happens when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">Deposit()</span></strong><span class="koboSpan" id="kobo.307.1"> method doesn’t work? </span><span class="koboSpan" id="kobo.307.2">If we do have an error in the code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">catch</span></strong><span class="koboSpan" id="kobo.309.1"> statement should contain something to let the developer know an error occurred. </span><span class="koboSpan" id="kobo.309.2">At the very least, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">Log</span></strong><span class="koboSpan" id="kobo.311.1"> statement should exist to notify the team about </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">the issue.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">While an empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">try</span></strong><span class="koboSpan" id="kobo.315.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">catch</span></strong><span class="koboSpan" id="kobo.317.1"> block keeps the program from crashing, it causes a bigger problem. </span><span class="koboSpan" id="kobo.317.2">Once someone discovers there’s an error with depositing funds, it may be hard to find the issue since it doesn’t log the problem because it’s not logging or throwing </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">an error.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.319.1">Use exception filtering and pattern matching</span></h2>
<p><span class="koboSpan" id="kobo.320.1">If we are dealing with multiple exceptions for a section of code, a new feature in .NET called </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.321.1">exception filtering can make </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.322.1">the exception handling terser. </span><span class="koboSpan" id="kobo.322.2">If we have compact code, exception filtering can provide a more efficient and modern </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">For instance, file handling can often result in a wide variety of exceptions. </span><span class="koboSpan" id="kobo.324.2">Consider the following </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.326.1">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (DirectoryNotFoundException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":Directory not found - " + e.Message);
}
catch (FileNotFoundException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":File Not Found - " + e.Message);
}
catch (IOException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":I/O Error - " + e.Message);
}
catch (NotSupportedException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":Not Supported - " + e.Message);
}
catch (Exception e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":General Exception - " + e.Message);
}
// Use filestream</span></pre> <p><span class="koboSpan" id="kobo.327.1">In the preceding code, we log each exception and provide a message based on the specific </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.328.1">exception. </span><span class="koboSpan" id="kobo.328.2">With exception filtering, we </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.329.1">can shorten the lines to something a little easier </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">to read:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (Exception e) when
    (  e is DirectoryNotFoundException
    || e is FileNotFoundException)
{
    _logger.Log(LogLevel.Warning, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
catch (Exception e) when
    (e is NotSupportedException
    || e is IOException)
{
    _logger.Log(LogLevel.Error, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
catch (Exception e)
{
    _logger.Log(LogLevel.Error, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
// Use filestream</span></pre> <p><span class="koboSpan" id="kobo.332.1">In the preceding code, we are grouping </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">DirectoryNotFoundException</span></strong><span class="koboSpan" id="kobo.334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">FileNotFoundException</span></strong><span class="koboSpan" id="kobo.336.1"> and logging them as warnings. </span><span class="koboSpan" id="kobo.336.2">When we encounter a </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">NotSupportedException</span></strong><span class="koboSpan" id="kobo.338.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">IOException</span></strong><span class="koboSpan" id="kobo.340.1"> error, we consider that a little more of a problem </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.341.1">and log those as errors. </span><span class="koboSpan" id="kobo.341.2">Anything</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.342.1"> else coming through will be caught as a general exception and logged as an error with </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the message.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">Along with exception filtering, .NET introduced another new feature called pattern matching. </span><span class="koboSpan" id="kobo.344.2">With pattern matching, we can shorten the code </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">even further:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.346.1">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (Exception e)
{
    var logLevel = e switch
    {
        DirectoryNotFoundException =&gt; LogLevel.Warning,
        FileNotFoundException =&gt; LogLevel.Warning,
        _ =&gt; LogLevel.Error
    };
    _logger.Log(logLevel, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
// Use filestream</span></pre> <p><span class="koboSpan" id="kobo.347.1">The preceding code uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">switch</span></strong><span class="koboSpan" id="kobo.349.1"> statement inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">catch</span></strong><span class="koboSpan" id="kobo.351.1"> brackets to identify what type of exception we’re experiencing. </span><span class="koboSpan" id="kobo.351.2">Think of switch pattern matching as an inline </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">if</span></strong><span class="koboSpan" id="kobo.353.1"> statement. </span><span class="koboSpan" id="kobo.353.2">The preceding line returns the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">logLevel</span></strong><span class="koboSpan" id="kobo.355.1"> based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">exception type.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">The underscore (</span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">_</span></strong><span class="koboSpan" id="kobo.359.1">) is called a discard variable (it’s like a default in a switch statement). </span><span class="koboSpan" id="kobo.359.2">If everything else falls </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.360.1">through the switch, then </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.361.1">we’ll just default the log level to </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">LogLevel.Error</span></strong><span class="koboSpan" id="kobo.363.1"> and log the message with the current method, the name of the exception type, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">exception message.</span></span></p>
<p><span class="koboSpan" id="kobo.365.1">Exception handling can be wordy with, for instance, I/O-based methods and connections. </span><span class="koboSpan" id="kobo.365.2">Exception filtering and pattern matching can help ease the wordiness of catching </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">various exceptions.</span></span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor204"/><span class="koboSpan" id="kobo.367.1">Use finally blocks for cleanup</span></h2>
<p><span class="koboSpan" id="kobo.368.1">When working with </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.369.1">database connections, file-based operations, or resources, it’s best to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">finally</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.371.1">for cleanup.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">For example, if we’re connecting to a database and want to close the connection afterward, we’d have to create a piece of code similar to </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
using System.Data.SqlClient;
var connectionString = @"Data Source=localhost;Initial Catalog=myDatabase;Integrated Security=true;";
using SqlConnection connection = new SqlConnection(connectionString);
var command = new SqlCommand("UPDATE Users SET Name='Jonathan' WHERE ID=1 ", connection);
try
{
    command.Connection.Open();
    command.ExecuteNonQuery();
}
catch (SqlException ex)
{
    Console.WriteLine(ex.ToString());
    throw;
}
finally
{
    connection.Close();
}</span></pre> <p><span class="koboSpan" id="kobo.375.1">In the </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.376.1">preceding code, the connection object is passed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">SqlCommand</span></strong><span class="koboSpan" id="kobo.378.1"> constructor. </span><span class="koboSpan" id="kobo.378.2">When we execute the SQL query, the command is passed into the connection and executed. </span><span class="koboSpan" id="kobo.378.3">Once our code is executed, we close the connection in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">finally</span></strong><span class="koboSpan" id="kobo.380.1"> statement. </span><span class="koboSpan" id="kobo.380.2">Since we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">using</span></strong><span class="koboSpan" id="kobo.382.1"> statement and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">SqlConnection</span></strong><span class="koboSpan" id="kobo.384.1"> class implements </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">IDisposable</span></strong><span class="koboSpan" id="kobo.386.1">, it will automatically be </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">disposed of.</span></span></p>
<p><span class="koboSpan" id="kobo.388.1">There are times when we need </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">finally</span></strong><span class="koboSpan" id="kobo.390.1"> statements to clean up, but there are exceptions when they </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">aren’t necessary.</span></span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor205"/><span class="koboSpan" id="kobo.392.1">Knowing when to throw</span></h2>
<p><span class="koboSpan" id="kobo.393.1">In the previous </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.394.1">code example, we issued </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">throw;</span></strong><span class="koboSpan" id="kobo.396.1"> as opposed to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">throw ex;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">If we run the code example in the previous section with </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">throw;</span></strong><span class="koboSpan" id="kobo.401.1">, we see that the stack trace in Visual Studio is seen through the </span><strong class="bold"><span class="koboSpan" id="kobo.402.1">Call </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.403.1">Stack</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1"> pane:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.405.1"><img alt="Figure 8.1 – Snapshot of a call stack with a simple throw;" src="image/B19493_08_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">Figure 8.1 – Snapshot of a call stack with a simple throw;</span></p>
<p><span class="koboSpan" id="kobo.407.1">What happens if we change the line to </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">throw ex;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">?</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 8.2 – Snapshot of a call stack with throw ex;" src="image/B19493_08_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 8.2 – Snapshot of a call stack with throw ex;</span></p>
<p><span class="koboSpan" id="kobo.412.1">The stack trace completely disappears. </span><span class="koboSpan" id="kobo.412.2">The error will become harder to track if we don’t have a stack trace. </span><span class="koboSpan" id="kobo.412.3">There are times when we want to simply throw the exception. </span><span class="koboSpan" id="kobo.412.4">It’s always better to rethrow the exception so that the stack trace is left intact for </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">locating errors.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">In this section, we covered many standards of what is considered practical when applying exception handling in the code. </span><span class="koboSpan" id="kobo.414.2">We learned how to minimize exceptions with “prevention </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.415.1">before exception,” why logging is important, and why exception handling is like </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">We also learned to avoid empty catch blocks, simplify exceptions using exception filtering and pattern matching, when to use finally blocks, and how to rethrow </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">exceptions properly.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.419.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.420.1">Exception handling is important but requires a level of experience when writing truly robust applications. </span><span class="koboSpan" id="kobo.420.2">Applications need to recover so that the user doesn’t have a </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">jarring experience.</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">In this chapter, we learned about exception handling, when to use it, and where it makes sense, as well as </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">performance considerations.</span></span></p>
<p><span class="koboSpan" id="kobo.424.1">We ended this chapter by learning about the common techniques of exception handling by understanding the “prevention before exception” principle, why logging is important, and why exception handling is like </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">unit testing.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">We also learned that empty catch blocks are wasteful, how to simplify exceptions using exception filtering and pattern matching, when to use finally blocks, and how to rethrow </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">exceptions properly.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">In the next chapter, we’ll look at web API standards and how they are extremely important to the ASP.NET </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">Core ecosystem.</span></span></p>
</div>
</body></html>