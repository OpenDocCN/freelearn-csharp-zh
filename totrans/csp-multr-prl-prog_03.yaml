- en: Chapter 3. Thread Class – Heavyweight Concurrency in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。线程类 – C#中的重量级并发
- en: In the previous chapter, we examined the `BackgroundWorker` component and how
    to use it to achieve performance gains by multithreading our application. This
    component is useful but has many limitations. In order to have very precise control
    over the concurrently running threads in our applications, we can use the `Thread`
    class instead.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了`BackgroundWorker`组件及其如何通过多线程我们的应用程序来实现性能提升。这个组件很有用，但有很多限制。为了对我们的应用程序中并发运行的线程有非常精确的控制，我们可以使用`Thread`类。
- en: In this chapter, we will study this class in detail and develop more complex
    multithreaded applications that take full advantage of the multiprocessing capabilities
    of today's hardware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细研究这个类，并开发更多复杂的多线程应用程序，充分利用当今硬件的多处理能力。
- en: We will use the terms **heavyweight concurrency** and **lightweight concurrency**
    throughout this book. Let's take a minute to reflect on what we mean by this.
    When we use the `Thread` class, as we will see in this and the next chapter, we
    will develop multithreaded applications through heavyweight concurrency. This
    means that it is up to us to create, coordinate, and manage the different threads
    in our application. It will also be up to us to know how many processing cores
    the hardware has that runs our application in order to maximize the multithreading
    efficiency of our application. We use the term heavyweight concurrency to describe
    this kind of multithreaded development because it takes extra code and work on
    the developer's part to achieve maximum benefits. We have to create the threads,
    coordinate the interaction of the threads, manage when threads have completed,
    and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用**重量级并发**和**轻量级并发**这两个术语。让我们花一分钟时间思考一下我们所说的意思。当我们使用`Thread`类时，正如我们将在本章和下一章中看到的，我们将通过重量级并发来开发多线程应用程序。这意味着创建、协调和管理我们应用程序中的不同线程的责任在我们身上。我们还需要知道运行我们应用程序的硬件有多少个处理核心，以便最大化我们应用程序的多线程效率。我们使用重量级并发这个术语来描述这种多线程开发，因为它需要开发者额外编写代码并付出更多努力来实现最大效益。我们必须创建线程，协调线程之间的交互，管理线程何时完成，等等。
- en: Later in the book, we will study the `Task` class and **Task Parallel Library**
    (**TPL**). This library is a recent addition to the .NET framework and takes multithreading
    application development to the next level. Using these classes allows the developer
    to achieve the maximum benefits of multithreading an application with much less
    effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，我们将研究`Task`类和**任务并行库**（**TPL**）。这个库是.NET框架的最近新增功能，将多线程应用程序开发提升到了新的水平。使用这些类可以让开发者以更少的努力实现多线程应用程序的最大化效益。
- en: TPL handles thread creation, coordination, and management for you. Developing
    using the TPL classes is referred to as lightweight concurrency because it takes
    less effort by the developer. There are some downsides, as we will see, to using
    these classes because much of the multithreaded work is handled for you and may
    not be done exactly how you want it to be.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TPL为您处理线程创建、协调和管理。使用TPL类进行开发被称为轻量级并发，因为开发者需要付出的努力更少。正如我们将看到的，使用这些类有一些缺点，因为大部分多线程工作都是由您来处理的，可能不会按照您期望的方式完成。
- en: So, depending on your application and expertise, there are times when both heavyweight
    concurrency and lightweight concurrency are the right solution. The key is to
    understand both and know when to use each.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据您的应用程序和专业知识，有时重量级并发和轻量级并发都是正确的解决方案。关键是理解两者，并知道何时使用每个。
- en: 'For now, we will focus on heavyweight concurrency and the `Thread` class. After
    reading this chapter and following the exercises, we shall be able to:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于重量级并发和`Thread`类。阅读本章并完成练习后，我们将能够：
- en: Develop applications with great control over multiple running threads, offering
    exciting performance enhancements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发对多个运行线程有极大控制的程序，提供令人兴奋的性能提升
- en: Learn how to create independent and very flexible threads using a very powerful
    class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用一个非常强大的类创建独立且非常灵活的线程
- en: Find out how to start, control, and coordinate multiple threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何启动、控制和协调多个线程
- en: Discover how to send parameters to and retrieve data from threads
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现如何向线程发送参数并从线程检索数据
- en: Learn how to share data between many threads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在多个线程之间共享数据
- en: Find out how to combine asynchronous and synchronous execution in order to have
    exhaustive control over the running threads and their tasks
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何结合异步和同步执行，以便对正在运行的线程及其任务有详尽的控制
- en: Develop applications capable of launching multiple threads when necessary
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发能够在必要时启动多个线程的应用程序
- en: Creating threads with the Thread class
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Thread`类创建线程
- en: So far, we have used the `BackgroundWorker` component to create new threads
    independent of the main application thread. The applications can respond to UI
    events while processing continues and take full advantage of multiple cores, thus
    running faster. However, there are some restrictions when we must control and
    coordinate the execution of many threads that are not intended to just run in
    the background. Now, let's learn how to use the `Thread` class to make an application
    capable of taking full control of the synchronous and asynchronous execution of
    concurrent threads. The `Thread` class is just what it sounds like, a class that
    allows you to create separate threads of execution for your process to run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`BackgroundWorker`组件创建与主应用程序线程无关的新线程。应用程序可以在处理过程中响应用户界面事件，充分利用多个核心，从而运行得更快。然而，当我们必须控制和管理许多线程的执行时，有一些限制，这些线程不是为了仅在后台运行而设计的。现在，让我们学习如何使用`Thread`类使应用程序能够完全控制并发线程的同步和异步执行。`Thread`类正如其名，是一个允许您为您的进程创建单独执行线程的类。
- en: We can work with many instances of the `Thread` class (`System.Threading.Thread`)
    in order to run many concurrent threads with more control capabilities than the
    ones created using the `BackgroundWorker` component. As we learned in the previous
    chapter, the performance results will depend upon the number of cores or processors
    available in the computer on which we run the application. However, the `Thread`
    class offers many fine-tuning capabilities to help us achieve the desired performance
    using multithreading.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用许多`Thread`类（`System.Threading.Thread`）的实例来运行许多并发线程，这些线程比使用`BackgroundWorker`组件创建的线程具有更多的控制能力。正如我们在上一章所学，性能结果将取决于我们运行应用程序的计算机上可用的核心或处理器的数量。然而，`Thread`类提供了许多精细调优的能力，帮助我们通过多线程实现所需的性能。
- en: The `Thread` class does a great job of offering great flexibility while offering
    a simple way to initialize, coordinate, run, stop, and free multiple threads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类在提供极大的灵活性的同时，提供了一个简单的方式来初始化、协调、运行、停止和释放多个线程。'
- en: Let's get started with an encryption program
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们从加密程序开始
- en: To demonstrate how to use the `Thread` class, we are going to create a simple
    WPF application that takes text messages and encrypts and decrypts them. The customers
    of this application are working with a new cellular phone capable of sending SMS
    (text messages) with access to the complete Unicode character set. The cellular
    phone is a single-core device. The application has to work in a very fast and
    efficient encryption engine capable of encrypting the incoming text messages and
    leaving them in an output queue. This engine is going to run on a huge server
    with many multi-core processors. They want it to use a very fine-tuned multithreading
    application capable of working with as many threads as there are available cores
    in the computer on which the engine is being executed. So, the application will
    have to be smart enough to detect the number of cores and create that many threads.
    In this way, it uses the full capabilities of the hardware, but doesn't create
    extra threads that will not further enhance performance.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用`Thread`类，我们将创建一个简单的WPF应用程序，该应用程序可以接收文本消息并对它们进行加密和解密。该应用程序的客户正在使用一款新型手机，这款手机能够发送包含完整Unicode字符集的短信（文本消息）。这款手机是单核设备。该应用程序需要在非常快速且高效的加密引擎上运行，该引擎能够加密传入的文本消息并将它们留在输出队列中。这个引擎将在拥有许多多核处理器的巨大服务器上运行。他们希望它能够使用一个非常精细调优的多线程应用程序，能够利用在执行引擎的计算机上可用的所有核心数量。因此，该应用程序必须足够智能，能够检测核心数量并创建相应数量的线程。这样，它就可以充分利用硬件的全部功能，但不会创建额外的线程，这些线程不会进一步提高性能。
- en: How to do it
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'First, we are going to build a new C# WPF application, and we will define and
    test the methods to encrypt and decrypt a string:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建一个新的C# WPF应用程序，并定义和测试加密和解密字符串的方法：
- en: Create a new C# project using the WPF application template in Visual Studio.
    Use `SMSEncryption` as the project's name.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Visual Studio中的WPF应用程序模板创建一个新的C#项目。将项目名称命名为`SMSEncryption`。
- en: Open `MainWindow.xaml` in the designer mode, add the following controls, and
    align them as shown in the following screenshot:![How to do it](img/8321EN_03_01.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计模式下打开`MainWindow.xaml`，添加以下控件，并按以下截图所示对齐：![如何操作](img/8321EN_03_01.jpg)
- en: One image showing a text message graphic called `imgTextMessage`.
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一张显示文本消息图形的图片，名为`imgTextMessage`。
- en: Three textboxes with their `Text` property set to `SMS Encryption Engine`, `Original
    Messages`, and `Encrypted Messages`.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个文本框，它们的`Text`属性设置为`SMS Encryption Engine`、`Original Messages`和`Encrypted Messages`。
- en: Two textboxes with their `Names` property set to `txtOriginalSMS` and `txtEncryptedSMS`,
    and their `AcceptsReturn` property set to `true`.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个文本框，它们的`Names`属性设置为`txtOriginalSMS`和`txtEncryptedSMS`，以及它们的`AcceptsReturn`属性设置为`true`。
- en: One button control named `butTest` with its `Text` property set to `Test`. This
    is the button that will test the encryption and decryption methods.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`butTest`的按钮控件，其`Text`属性设置为`Test`。这是将要测试加密和解密方法的按钮。
- en: Next, add a class file called `EncryptionProcedures` that has two static methods,
    one called `Encrypt` and the other called `Decrypt`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为`EncryptionProcedures`的类文件，它有两个静态方法，一个名为`Encrypt`，另一个名为`Decrypt`。
- en: 'The `Encrypt` method will encrypt the string received as a parameter and return
    a string containing the resulting encoded message with unrecognizable characters.
    Add the following code for this method:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Encrypt`方法将加密作为参数接收的字符串，并返回一个包含结果编码消息的字符串，其中包含不可识别的字符。为此方法添加以下代码：'
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Decrypt` method will decrypt the encrypted string received as a parameter
    and return a string with the resulting decoded message:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Decrypt`方法将解密作为参数接收的加密字符串，并返回一个包含解码消息的字符串：'
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `Click` event handler method for the button, `butTest`, and enter
    the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开按钮`butTest`的`Click`事件处理方法，并输入以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Build and run the application.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Enter a short text in the textbox labeled `Original SMS Messages`, and click
    on the **Test** button. The encrypted message will appear in the textbox labeled
    `Encrypted SMS Messages`. The decrypted message will also become visible in the
    bottom textbox, but this will be the result of decrypting the encrypted message
    to test the algorithm.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签为`Original SMS Messages`的文本框中输入简短文本，然后单击**Test**按钮。加密消息将出现在标签为`Encrypted
    SMS Messages`的文本框中。解密消息也将出现在底部的文本框中，但这将是解密加密消息以测试算法的结果。
- en: The results will look similar to the following screenshot:![How to do it](img/8321EN_03_02.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将类似于以下截图：![如何操作](img/8321EN_03_02.jpg)
- en: How it works
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this program, we have created the `Encrypt` and `Decrypt` methods that take
    a `String` value and encrypt and decrypt it, respectively. The encryption algorithm
    uses a random number generator and many **Exclusive OR** (**XOR**) operations.
    It also adds garbage in the text in order to confuse potential hackers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了`Encrypt`和`Decrypt`方法，它们分别接受一个`String`值并对其进行加密和解密。加密算法使用随机数生成器和许多**异或**（**XOR**）操作。它还在文本中添加垃圾数据，以混淆潜在的攻击者。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that in C#, the XOR operation is specified by the `^` operator and
    can be applied to numbers. Thus, we needed many typecastings to `char` type, and
    then we called the `ToString()` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在C#中，异或操作由`^`运算符指定，可以应用于数字。因此，我们需要进行许多类型转换到`char`类型，然后调用`ToString()`方法。
- en: 'One of the most exciting properties of the XOR operation is the possibility
    of returning to the original value when it is applied twice. For example, consider
    the following lines of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 异或操作最令人兴奋的特性之一是当它被应用两次时，可以返回原始值。例如，考虑以下代码行：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The value assigned to `liSecondXOR` will be the same as is in `liOriginalValue`,
    that is, `120`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`liSecondXOR`的值将与`liOriginalValue`中的值相同，即`120`。
- en: As the encryption algorithms use the complete Unicode character set, with 65,536
    possible characters, the resulting text is unreadable and very confusing, as it
    is not limited to the classic 256-character set.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密算法使用完整的Unicode字符集，有65,536个可能的字符，因此生成的文本是不可读的，并且非常混乱，因为它不仅限于经典的256字符集。
- en: Creating an application with threads
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个使用线程的应用程序
- en: As we have tested the decryption of the previously encrypted message, we are
    sure it is working fine. We are now going to run the encryption algorithm in a
    new thread created using the `Thread` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经测试了之前加密消息的解密，我们确信它运行良好。现在我们将使用`Thread`类创建的新线程运行加密算法。
- en: We want to use the `Thread` class to have tight control over the execution of
    the different processing threads in our application. First, we need to make the
    encryption function run in just one thread. Later, we will align the threads with
    the number of cores in our hardware to ensure maximum efficiency. So, for now,
    we will change the application we previously built so that the encryption logic
    runs in a separate thread from the main application. This will begin to give us
    control over when and how we encrypt the text messages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想使用`Thread`类来紧密控制应用程序中不同处理线程的执行。首先，我们需要让加密函数仅在单个线程中运行。稍后，我们将线程与硬件的核心数对齐，以确保最大效率。因此，现在我们将更改之前构建的应用程序，以便加密逻辑在主应用程序之外单独的线程中运行。这将开始让我们控制何时以及如何加密文本消息。
- en: How to do it
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, we are going to make some changes to the application, and we will encrypt
    the messages in a new independent thread created and configured using the `Thread`
    class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对应用程序进行一些修改，并使用`Thread`类创建和配置的新独立线程来加密消息：
- en: Open the `SMSEncryption` project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SMSEncryption`项目。
- en: Add a button control (`butRunInThread`). Set its `Text` property to `Run in
    a Thread`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个按钮控件（`butRunInThread`）。将其`Text`属性设置为`Run in a Thread`。
- en: 'Since we are going to use the `Thread` class, we need to add a `Using` statement
    so that our application can find this class from the .NET framework. Add the following
    line of code at the beginning (as we are going to use the `System.Threading.Thread`
    class):'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用`Thread`类，我们需要添加一个`Using`语句，以便我们的应用程序可以从.NET框架中找到这个类。在开头添加以下代码行（因为我们将使用`System.Threading.Thread`类）：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following line in the `MainWindow` code-behind file, `MainWindow.xaml.cs`
    class definition to declare three new private variables:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`代码隐藏文件，`MainWindow.xaml.cs`类定义中添加以下行，以声明三个新的私有变量：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add one button control named `butRunInThread` with its `Text` property set to
    `Run in a Thread`. This is the button that will test the encryption and decryption
    methods running in a separate thread from the main thread.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`butRunInThread`的按钮控件，并将其`Text`属性设置为`Run in a Thread`。这是将测试在主线程之外运行的加密和解密方法的按钮。
- en: 'Open the `Click` event method for the `butRunInThread` button and enter the
    following code to run the encryption process in a new thread created using the
    `Thread` class:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`butRunInThread`按钮的`Click`事件方法，并输入以下代码以使用`Thread`类创建的新线程运行加密过程：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we need to create the `ThreadEncryptProcedure` that will run in a separate
    thread and encrypt the text message. Enter the following code to create this procedure.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个将在单独线程中运行并加密文本消息的`ThreadEncryptProcedure`。输入以下代码以创建此过程。
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Build and run the application.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Enter or copy and paste a long text in the `Textbox` labeled `Original SMS Messages`
    and click on the **Run in a Thread** button. The encrypted message will appear
    in the `Textbox` labeled `Encrypted Messages`. However, the code runs in a different
    thread. The results will be similar to what is shown in the following screenshot:![How
    to do it](img/8321EN_03_03.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记为`Original SMS Messages`的`Textbox`中输入或复制粘贴一段长文本，然后点击**Run in a Thread**按钮。加密的消息将出现在标记为`Encrypted
    Messages`的`Textbox`中。然而，代码是在不同的线程中运行的。结果将类似于以下截图所示：![如何操作](img/8321EN_03_03.jpg)
- en: How it works
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Now, when the user clicks the **Run in a Thread** button, the encryption runs
    in a new thread, but with synchronous execution. We create the thread and then
    we start the thread with the `proThreadEncryption.Start();` command. Since it
    is a synchronous operation, we then wait on the thread to complete operation with
    the `proThreadEncryption.Join();` command. So, in a separate thread, the `ThreadEncryptProcedure`
    runs and encrypts the text message string into a list of strings.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击**Run in a Thread**按钮时，加密将在新线程中运行，但具有同步执行。我们创建线程，然后使用`proThreadEncryption.Start();`命令启动线程。由于这是一个同步操作，我们随后使用`proThreadEncryption.Join();`命令等待线程完成操作。因此，在单独的线程中，`ThreadEncryptProcedure`运行并加密文本消息字符串到字符串列表。
- en: When the thread running the `ThreadEncryptProcedure` completes, the main thread,
    which was waiting on the thread to complete by executing the `Join` command, continues
    and takes the encrypted list of strings and displays them in the bottom textbox.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`ThreadEncryptProcedure`的线程完成时，主线程将继续执行，它通过执行`Join`命令等待线程完成。然后，主线程将获取加密的字符串列表并在底部的文本框中显示它们。
- en: The `Thread.Join` method tells the issuing thread to wait here until the thread
    completes. As we are not using a `BackgroundWorker` component, which simplified
    UI decoupling, we must do that work in code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Join`方法指示发出调用的线程在此等待，直到线程完成。由于我们没有使用`BackgroundWorker`组件，该组件简化了UI解耦，我们必须在代码中完成这项工作。'
- en: 'The following lines declare the two private string lists that will work as
    an input (`prlsSMSToEncrypt`) and as an output (`prlsEncryptedSMS`) for the new
    independent thread:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行声明了两个私有字符串列表，它们将作为新独立线程的输入（`prlsSMSToEncrypt`）和输出（`prlsEncryptedSMS`）：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When started, the thread will execute the code in the `ThreadEncryptProcedure`
    (without parameters). This procedure is private and resides in the same class
    as the two aforementioned private string lists. Thus, the code in the `ThreadEncryptProcedure`
    can access these two variables to take the input strings, encrypt them, and add
    them to the output string list. Instead of working against the UI controls, we
    decouple the UI and avoid the problems related to multithreading with the UI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，线程将执行`ThreadEncryptProcedure`中的代码（无参数）。此过程是私有的，位于与上述两个私有字符串列表相同的类中。因此，`ThreadEncryptProcedure`中的代码可以访问这两个变量，以获取输入字符串，加密它们，并将它们添加到输出字符串列表中。我们不是针对UI控件进行操作，而是解耦UI，避免与UI相关的多线程问题。
- en: '`ThreadEncryptProcedure` does a very simple task without touching the UI controls.
    For each string in the input string list (`prlsSMSToEncrypt`), it encrypts the
    string and adds it to the output string list (`prlsEncryptedSMS`).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadEncryptProcedure`执行一个非常简单的任务，不接触UI控件。对于输入字符串列表（`prlsSMSToEncrypt`）中的每个字符串，它都会加密该字符串并将其添加到输出字符串列表（`prlsEncryptedSMS`）中。'
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    prepare everything the thread needs from the UI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**在单独的线程中运行**按钮时，以下代码行会从UI中准备线程所需的所有内容：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we create a new instance of `List<string>`. As mentioned earlier, we
    pass the number of items (capacity) as a parameter in order to optimize the execution,
    using the `LineCount` property for the lines in the `txtOriginalSMS` textbox.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的`List<string>`实例。如前所述，我们通过将项目数量（容量）作为参数传递来优化执行，使用`txtOriginalSMS`文本框中的`LineCount`属性。
- en: Then, we use the `Add` method to add all the strings to our new `List<string>`
    instance. Now, we have everything the thread needs as an input in a private `List<string>`,
    which it can access without problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Add`方法将所有字符串添加到我们的新`List<string>`实例中。现在，线程所需的所有输入都在一个私有的`List<string>`中，它可以无问题地访问。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mastering the use of lists, arrays, and collections is a must when working with
    multithreading.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用多线程时，掌握列表、数组和集合的使用是必不可少的。
- en: This is a very simple way to share data with a new independent thread without
    complications. However, we must be very careful, as we must learn more things
    in order to change data in the same variables accessed from many threads.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的方法，可以在不出现复杂情况的情况下与新的独立线程共享数据。然而，我们必须非常小心，因为我们必须学习更多东西才能在许多线程访问的相同变量中更改数据。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we access variables from multiple threads, they must be of thread safety
    types. **Thread safety types** are those that are safe for multithreaded operations.
    If you have any doubt about a type, you can check whether it is of a thread safety
    type or not in the C# documentation. It offers a section describing the thread
    safety, as shown in the following screenshot for the `Int32` type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从多个线程访问变量时，它们必须是线程安全类型。**线程安全类型**是那些在多线程操作中安全的类型。如果您对某个类型有疑问，可以在C#文档中检查它是否为线程安全类型。它提供了一个描述线程安全的部分，如下面的截图所示，用于`Int32`类型：
- en: '![How it works](img/8321EN_03_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/8321EN_03_04.jpg)'
- en: 'The following line declared the `proThreadEncryption` variable with the `Thread`
    type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行声明了`proThreadEncryption`变量，其类型为`Thread`：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    create an instance of the `Thread` class specifying the method it must execute
    in the new thread when it is started. In order to accomplish this, we use the
    `ThreadStart` delegate because we do not need to send parameters or other data
    to the thread for initialization purposes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**在单独的线程中运行**按钮时，以下代码行创建了一个`Thread`类的实例，指定了当线程启动时必须在新的线程中执行的方法。为了实现这一点，我们使用了`ThreadStart`委托，因为我们不需要向线程发送参数或其他数据以进行初始化：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the thread is created, it does not start running the code in the specified
    `ThreadEncryptProcedure` until we call the `Start()` method. Since we do not want
    to send parameters to the procedure, we use the `Start()` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了线程，它不会在指定的`ThreadEncryptProcedure`中开始运行代码，直到我们调用`Start()`方法。由于我们不希望向该程序发送参数，我们使用`Start()`方法：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method tells the scheduler to start running the code in the new independent
    thread with an asynchronous execution. However, as it is executed asynchronously,
    we lose control over the time when the code in the thread begins running. It can
    be 100 milliseconds, 200 milliseconds, or 2 seconds.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法告诉调度器以异步执行开始在新独立的线程中运行代码。然而，由于它是异步执行的，我们失去了控制代码在线程中开始运行的时间。它可能是100毫秒、200毫秒，或者2秒。
- en: 'In this case, we do not want to start an independent thread and lose control
    over its execution time, but we want to start it with a synchronous execution
    and wait, in the main thread, until it finishes. In order to do so, we call the
    `Join` method in the next line:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不想启动一个独立的线程并失去对其执行时间的控制，但我们希望以同步执行启动它，并在主线程中等待，直到它完成。为了做到这一点，我们在下一行调用`Join`方法：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It makes the new thread run the `ThreadEncryptProcedure` code. Once it finishes
    its execution, it returns control to the main thread and goes on with the next
    statement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它使新线程运行`ThreadEncryptProcedure`代码。一旦它完成执行，它将控制权返回给主线程，并继续执行下一个语句。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It works as if we were calling a classic method, but in another thread.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像我们正在调用一个经典方法，但是在另一个线程中。
- en: Separating the code in a new thread using the `Thread` class is easy if we follow
    this simple code pattern.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Thread`类在新的线程中分离代码非常简单，如果我们遵循这个简单的代码模式。
- en: 'Since it was joined with the main thread, the statements after the call to
    the `Join` method are executed as soon as the thread finishes its execution. These
    lines collect the encrypted strings generated in the `prlsEncryptedSMS` string
    list and append them, one per line, in the `txtEncryptedSMS` textbox:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与主线程连接在一起，因此在调用`Join`方法之后的语句会在线程执行完毕后立即执行。这些行收集在`prlsEncryptedSMS`字符串列表中生成的加密字符串，并将它们逐行追加到`txtEncryptedSMS`文本框中：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As the thread stores the results of its processing in a private variable, which
    is also accessible from the main thread, we can use it to show the results in
    the UI controls.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于线程将处理结果存储在一个私有变量中，这个变量也可以从主线程访问，因此我们可以使用它来在UI控件中显示结果。
- en: This is a very simple way to retrieve data from threads, leaving the results
    in a variable, accessible from both the main and the secondary threads.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种从线程中检索数据并使结果留在变量中的非常简单的方法，这个变量可以从主线程和辅助线程访问。
- en: This is one of the main advantages of threads over processes. It is very easy
    to share data between threads without much effort.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是线程相对于进程的主要优势之一。在不需要太多努力的情况下，很容易在线程之间共享数据。
- en: Sharing data between threads
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程之间共享数据
- en: So far, we have used the `BackgroundWorker` component and the `Thread` class
    to execute code in independent threads. The `Thread` class allows us to have great
    control over the thread while the `BackgroundWorker` component offers a very simple
    way to update the UI without using complicated delegates or callbacks. How can
    we combine this component and this class in an application to make it faster to
    complete while keeping the UI responsive?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了`BackgroundWorker`组件和`Thread`类来在独立的线程中执行代码。`Thread`类允许我们对线程有很好的控制，而`BackgroundWorker`组件提供了一个非常简单的方式来更新UI，而无需使用复杂的委托或回调。我们如何在应用程序中将这个组件和这个类结合起来，使其完成速度更快，同时保持UI的响应性？
- en: If we want to work with a `BackgroundWorker` component to show some feedback
    or progress to the UI controls, while one or more threads created using the `Thread`
    class is running, we must find a way to share data between threads.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在`Thread`类创建的一个或多个线程运行时，使用`BackgroundWorker`组件向UI控件显示一些反馈或进度，我们必须找到一种方法在线程之间共享数据。
- en: We made something like that in our last example. However, we must use some techniques
    in order to avoid confusion between the different ways in which this useful component,
    `BackgroundWorker`, and this flexible and powerful class, `Thread`, work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一个例子中，我们做了类似的事情。然而，我们必须使用一些技术来避免混淆，因为这种有用的组件`BackgroundWorker`和这种灵活且强大的类`Thread`以不同的方式工作。
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can do it using the `Thread` class, but there is a `BackgroundWorker` component
    ready to help us. Thus, let's be pragmatic and use the best of both worlds.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Thread` 类来实现，但有一个 `BackgroundWorker` 组件可以帮助我们。因此，让我们采取实用主义的态度，利用两者的优点。
- en: How to do it
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Now, we are going to make some changes to the application, adding a `BackgroundWorker`
    component to display progress. In order to accomplish that, we must share data
    between two threads:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对应用程序进行一些修改，添加一个 `BackgroundWorker` 组件来显示进度。为了实现这一点，我们必须在两个线程之间共享数据：
- en: Open the `SMSEncryption` project.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SMSEncryption` 项目。
- en: Add a label control (`lblNumberOfSMSEncrypted`). Set its `Text` property to
    `0`. Add another label control, and set its `Text` property to `Number of Messages
    Encrypted`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个标签控件 (`lblNumberOfSMSEncrypted`)。将其 `Text` 属性设置为 `0`。再添加另一个标签控件，并设置其 `Text`
    属性为 `已加密消息数量`。
- en: 'Add a `BackgroundWorker` component (`bakShowEncryptedStrings`) to create a
    new independent thread capable of talking to the UI, as we learned in the previous
    chapter. Declare the following variable in the `MainWindow.xaml.cs` file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们在上一章中学到的，添加一个 `BackgroundWorker` 组件 (`bakShowEncryptedStrings`) 来创建一个能够与
    UI 通信的新独立线程。在 `MainWindow.xaml.cs` 文件中声明以下变量：
- en: '[PRE15]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order for the program to recognize the `BackgroundWorker` class, you will
    also need to add the following:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让程序能够识别 `BackgroundWorker` 类，你还需要添加以下内容：
- en: '[PRE16]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Set the following properties of the `BackgroundWorker` component in the `MainWindow`
    constructor.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 构造函数中设置 `BackgroundWorker` 组件的以下属性。
- en: 'Add the following lines in the `MainWindow` class definition to declare three
    new private variables:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 类定义中添加以下行以声明三个新的私有变量：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following line of code at the beginning of `ThreadEncryptProcedure`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ThreadEncryptProcedure` 的开头添加以下代码行：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following line of code after the line `prlsEncryptedSMS.Add(lsEncryptedText);`
    in `ThreadEncryptProcedure`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ThreadEncryptProcedure` 中的 `prlsEncryptedSMS.Add(lsEncryptedText);` 行之后添加以下代码行：
- en: '[PRE19]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Register the `DoWork` event handler in the `MainWindow` constructor for the
    `BackgroundWorker` component `bakShowEncryptedStrings`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 构造函数中为 `BackgroundWorker` 组件 `bakShowEncryptedStrings` 注册 `DoWork`
    事件处理程序：
- en: '[PRE20]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, enter the following code in the `bakShowEncryptedStrings_DoWork` method:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `bakShowEncryptedStrings_DoWork` 方法中输入以下代码：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Register the `ProgressChanged` event handler in the `MainWindow` constructor
    for the `BackgroundWorker` component `bakShowEncryptedStrings`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow` 构造函数中为 `BackgroundWorker` 组件 `bakShowEncryptedStrings` 注册 `ProgressChanged`
    事件处理程序：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Open the `ProgressChanged` event in the `BackgroundWorker bakShowEncryptedStrings`,
    and enter the following code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BackgroundWorker bakShowEncryptedStrings` 的 `ProgressChanged` 事件中打开，并输入以下代码：
- en: '[PRE23]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `Click` event in the `butRunInThread` button and enter the following
    code before the line `proThreadEncryption.Start();` (we must start the `BackgroundWorker`
    component before we start the encryption thread):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `butRunInThread` 按钮的 `Click` 事件中打开，并在 `proThreadEncryption.Start();` 行之前输入以下代码（在我们开始加密线程之前，我们必须启动
    `BackgroundWorker` 组件）：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to comment out the `proThreadEncryption.Join();` line because
    we do not want the main thread to wait on the encryption routine to finish. We
    will also comment out lines after this that display the encrypted text message
    once the encryption thread finishes. We will be doing this through the `BackgroundWorker`
    processing and will explain this in the following code snippet:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要注释掉 `proThreadEncryption.Join();` 行，因为我们不希望主线程等待加密例程完成。我们还将注释掉在此之后显示加密文本消息的行。我们将通过
    `BackgroundWorker` 处理来完成这项工作，以下代码片段将解释这一点：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Try running the application before commenting out these lines after the `Join`
    method but leave the `proThreadEncryption.Join();` command uncommented. You will
    create a race condition that may throw a null exception error for the variable,
    `prlsEncryptedSMS`. If the main thread tries to use this variable to display the
    encrypted text message before the encryption thread finishes the first line, then
    this variable will still be null. Since both the main thread and the encryption
    thread are running in parallel, we cannot ensure this will not happen.![How to
    do it](img/8321EN_03_05.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Join` 方法之后注释掉这些行之前尝试运行应用程序。但请保留 `proThreadEncryption.Join();` 命令未注释。这将创建一个可能导致变量
    `prlsEncryptedSMS` 抛出空异常错误的竞争条件。如果主线程在加密线程完成第一行之前尝试使用此变量来显示加密的文本消息，那么此变量仍然将是 null。由于主线程和加密线程是并行运行的，我们无法保证这种情况不会发生。![如何操作](img/8321EN_03_05.jpg)
- en: Now, let's build and run the application with those lines commented out.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用这些行注释掉并构建和运行应用程序。
- en: Enter or copy and paste a very long text (with more than 5,000 lines) in the
    textbox labeled `Original Messages`, and click on the **Run in a Thread** button.
    You will see the strings representing the messages encrypted appearing in the
    textbox labeled **Encrypted Messages** as the number of messages that are encrypted
    increases. The application will look something like the following screenshot:![How
    to do it](img/8321EN_03_06.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记为`Original Messages`的文本框中输入或复制粘贴一个非常长的文本（超过5,000行），然后点击**在线程中运行**按钮。随着加密消息数量的增加，您将看到代表加密消息的字符串出现在标记为**Encrypted
    Messages**的文本框中。应用程序看起来可能如下截图所示：![如何操作](img/8321EN_03_06.jpg)
- en: How it works
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Now, when the user clicks on the **Run in a Thread** button, the encryption
    runs in a new thread, but with an asynchronous execution because we no longer
    tell the main thread to wait on it with the `Thread.Join()` method. At the same
    time, the `BackgroundWorker` component creates a new thread to give some feedback
    to the UI and also runs asynchronously. Thus, we have two concurrent threads with
    an asynchronous execution, doing completely different tasks in parallel.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击**在线程中运行**按钮时，加密将在新线程中运行，但由于我们不再使用`Thread.Join()`方法让主线程等待它，因此它是异步执行的。同时，`BackgroundWorker`组件创建一个新线程来向UI提供反馈，并且也是异步运行的。因此，我们有两个并发线程，它们以异步方式执行，并行完成完全不同的任务。
- en: 'This is why we added the following lines:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们添加了以下行：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we start the `BackgroundWorker` thread, and then the encryption thread
    that is created with the `Thread` class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们启动`BackgroundWorker`线程，然后使用`Thread`类创建的加密线程。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With these examples, we have learned and seen the differences between executing
    a thread in a synchronous and an asynchronous way. We must master this in order
    to have complete control over many concurrent threads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些示例，我们学习和看到了以同步和异步方式执行线程之间的差异。我们必须掌握这一点，才能完全控制许多并发线程。
- en: We are using the `BackgroundWorker` component in order to give some feedback
    to the UI controls. In order to do so, the encryption thread must share data with
    the `BackgroundWorker` thread.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`BackgroundWorker`组件来向UI控件提供一些反馈。为了做到这一点，加密线程必须与`BackgroundWorker`线程共享数据。
- en: We use the same technique that we used in the previous example. However, this
    time, our application is operating concurrently. While the encryption thread is
    adding encrypted strings to the `prlsEncryptedSMS` string list, the `BackgroundWorker`
    thread looks at the number of the last encrypted string and calls the `ReportProgress`
    method, sending it as a parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与上一个示例中相同的技巧。然而，这次，我们的应用程序是并发操作的。当加密线程向`prlsEncryptedSMS`字符串列表添加加密字符串时，`BackgroundWorker`线程查看最后一个加密字符串的编号，并调用`ReportProgress`方法，将其作为参数发送。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that too many calls to the `ReportProgress` method can generate a stack
    overflow exception. Because this method runs code that upgrades the textbox adding
    lines, it takes a lot more time than encrypting. If we have 100,000 messages to
    encrypt, and we make 100,000 calls to the `ReportProgress` method; it is highly
    probable that a stack overflow will be generated. The code in this method runs
    in the main thread, and for this reason, we must sacrifice some UI feedback to
    achieve a better overall performance and avoid exceptions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，过多的`ReportProgress`方法调用可能会生成堆栈溢出异常。因为这个方法运行代码来升级文本框并添加行，它比加密花费更多的时间。如果我们有10万个消息要加密，并且我们对`ReportProgress`方法进行了10万个调用；高度可能产生堆栈溢出。这个方法中的代码在主线程中运行，因此我们必须牺牲一些UI反馈以实现更好的整体性能并避免异常。
- en: The code in the `DoWork` and the `ReportProgress` event handlers is a little
    complex to account for this and not send updates for every single line encrypted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoWork`和`ReportProgress`事件处理器中的代码有点复杂，以避免为每条加密的行发送更新。'
- en: 'Now, we define three new private variables:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义三个新的私有变量：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The encryption thread initializes `priLastEncryptedString` and then increments
    its value each time it adds an encrypted string to the `prlsEncryptedSMS` string
    list. This value is useful for the `BackgroundWorker` thread.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 加密线程初始化`priLastEncryptedString`，然后在每次将加密字符串添加到`prlsEncryptedSMS`字符串列表时增加其值。这个值对`BackgroundWorker`线程很有用。
- en: The code executed in the `DoWork` event handler by the `BackgroundWorker` thread
    concurrently with the encryption thread initializes `priLastEncryptedStringShown`
    and `priOldLastEncryptedStringShown`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由`BackgroundWorker`线程与加密线程并发执行的`DoWork`事件处理器中的代码初始化`priLastEncryptedStringShown`和`priOldLastEncryptedStringShown`。
- en: 'Then, it waits until the encryption thread has some results. This is necessary
    because both the threads are launched asynchronously, at nearly the same time.
    It is a `while` loop, but with a call to the `Thread.Sleep` method, with 10 milliseconds
    of inactivity for the thread:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它等待直到加密线程有一些结果。这是必要的，因为这两个线程都是异步启动的，几乎同时。这是一个`while`循环，但调用`Thread.Sleep`方法，线程有10毫秒的不活动时间：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Since the `priLastEncryptedString` variable has a value less than `1`, the encryption
    thread has not added any value yet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`priLastEncryptedString`变量的值小于`1`，加密线程尚未添加任何值。
- en: The `Thread.Sleep` method suspends the current thread (the thread in the actual
    context) for a specified time in milliseconds (0.001 seconds). As it suspends
    the thread execution, it does not consume CPU cycles. Hence, it does not waste
    processing power.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`方法使当前线程（实际上下文中的线程）暂停指定的毫秒数（0.001秒）。因为它暂停了线程执行，所以它不消耗CPU周期。因此，它不会浪费处理能力。'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never use loops without instructions to wait for some time in a thread, because
    you will be wasting processing power. Instead, use the `Thread.Sleep` method when
    you have to pause a thread.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在没有等待某些时间指令的情况下使用循环，因为你会浪费处理能力。相反，当你需要暂停线程时，使用`Thread.Sleep`方法。
- en: 'When the encryption thread finishes encrypting the first string, adding it
    to the encrypted string list, and incrementing the value of `priLastEncryptedString`,
    the `BackgroundWorker` thread will move on to the next part of the code in the
    `DoWork` event handler method. Now, it will enter in the other loop:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当加密线程完成第一个字符串的加密，将其添加到加密字符串列表中，并增加`priLastEncryptedString`的值后，`BackgroundWorker`线程将进入`DoWork`事件处理器方法中的下一部分代码。现在，它将进入另一个循环：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The loop (and the `DoWork` thread) will go on running while the encryption thread
    is running, or while there are encrypted strings to be shown. We know when the
    `proThreadEncryption` thread is not running, or is not calling its `IsAlive` method.
    The `IsAlive` method returns either `true` or `false`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当加密线程正在运行或还有要显示的加密字符串时，循环（以及`DoWork`线程）将继续运行。我们知道当`proThreadEncryption`线程没有运行或没有调用其`IsAlive`方法时。`IsAlive`方法返回`true`或`false`。
- en: The first line in the loop saves the value of `priLastEncryptedString` in `liLast`.
    This is necessary because the value is changing concurrently on another thread
    (the encryption thread)—we are not alone (the joys of multithreaded logic!). We
    must save the value to work with the captured value in the rest of the comparisons
    and assignments. We do not want to work with a moving target within one iteration
    of the loop.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的第一行将`priLastEncryptedString`的值保存到`liLast`中。这是必要的，因为该值在另一个线程（加密线程）上并发更改——我们不是孤军奋战（多线程逻辑的乐趣！）。我们必须保存该值，以便在循环的其余比较和赋值中使用捕获的值。我们不希望在循环的一次迭代中与移动的目标一起工作。
- en: If the last encrypted string is not the last string shown, we use the `sender`
    parameter typecast to a `BackgroundWorker` component to call the `ReportProgress`
    method with the last string shown as a parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个加密字符串不是最后显示的字符串，我们使用`sender`参数转换为`BackgroundWorker`组件来调用带有最后显示字符串作为参数的`ReportProgress`方法。
- en: Once the `ReportProgress` method returns with an asynchronous event triggered
    to update the UI, we save the last string shown and make the thread suspend its
    execution for 1 second (1,000 milliseconds). This is necessary in order to avoid
    a probable stack overflow. Because the execution of the `DoWork` code is faster
    than the code programmed in the `ProgressChanged` event handler, we must give
    some time to the UI controls to get updated.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`ReportProgress`方法通过异步事件触发以更新UI返回，我们就保存最后显示的字符串，并使线程暂停执行1秒（1,000毫秒）。这是必要的，以避免可能的堆栈溢出。因为`DoWork`代码的执行速度比`ProgressChanged`事件处理器中编写的代码快，我们必须给UI控件一些时间来更新。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we call the `Thread.Sleep` method, the current thread suspends its execution
    for a specified time, though the other threads keep running. That is the reason
    why the counter shows big steps when we run the application with several text
    lines. The encryption thread works without suspensions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `Thread.Sleep` 方法时，当前线程会暂停其执行指定的时间，尽管其他线程仍在运行。这就是为什么当我们用几行文本运行应用程序时，计数器会显示大步的原因。加密线程工作时不暂停。
- en: Thus, the `BackgroundWorker` component helps the `Thread` class to update the
    UI controls. The `ProgressChanged` event handler does the rest of the job.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`BackgroundWorker` 组件帮助 `Thread` 类更新 UI 控件。`ProgressChanged` 事件处理器完成剩余的工作。
- en: 'First, it updates the number of SMS messages encrypted with the line of code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它通过以下代码行更新加密的短信数量：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It then casts the `e.ProgressPercentage` property received as a parameter to
    an integer in order to obtain the last encrypted string, instead of a progress
    percentage.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将作为参数接收的 `e.ProgressPercentage` 属性转换为整数，以获取最后一个加密字符串，而不是进度百分比。
- en: 'Then, it appends each new string with a loop from `priOldLastEncryptedStringShown`
    (the previous last encrypted string shown) to the last encrypted string received
    (in the `e.ProgressPercentage` property). We access the `prlsEncryptedSMS` string
    list in an element number that the encryption thread is not modifying (because
    it is already encrypted). Therefore, we can append the string to the textbox without
    problems:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它通过一个循环将每个新的字符串从 `priOldLastEncryptedStringShown`（之前显示的最后一个加密字符串）追加到接收到的最后一个加密字符串（在
    `e.ProgressPercentage` 属性中）。我们通过加密线程未修改的元素编号访问 `prlsEncryptedSMS` 字符串列表（因为它已经加密了）。因此，我们可以将字符串追加到文本框而不会出现问题：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, the string previous to the last encrypted string is now the last encrypted
    string shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，上一个加密字符串之前的字符串现在是显示的最后一个加密字符串：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By using a `BackgroundWorker` component with some threads created using the
    `Thread` class, we can easily give feedback to the UI and achieve better performance
    with a responsive application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Thread` 类创建的一些线程和 `BackgroundWorker` 组件，我们可以轻松地向 UI 提供反馈，并实现响应式应用程序的更好性能。
- en: At this point, we should mention that the `BackgroundWorker` component is a
    little like the black sheep of the family. In the .NET framework, with the advent
    of the `Thread` class and now the Task Parallel Library and `Async` methods (to
    be covered later in the book), some .NET developers consider use of `BackgroundWorker`
    a little passé. While it might not be the latest cool feature of .NET, it is still
    a very easy-to-use, helpful, and powerful component. According to me all multithreaded
    options in .NET have their place and the `BackgroundWorker` component is still
    relevant.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该提到，`BackgroundWorker` 组件有点像家中的黑羊。在 .NET 框架中，随着 `Thread` 类的出现，现在有了任务并行库和
    `Async` 方法（本书稍后将会介绍），一些 .NET 开发者认为使用 `BackgroundWorker` 有点过时。虽然它可能不是 .NET 最酷的新特性，但它仍然是一个非常易于使用、有帮助且强大的组件。据我所知，.NET
    中的所有多线程选项都有其位置，而 `BackgroundWorker` 组件仍然相关。
- en: When we call the `Start` method, the thread is sent to the scheduler for execution.
    As mentioned earlier, it does not mean an immediate execution.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `Start` 方法时，线程被发送到调度器以执行。如前所述，这并不意味着立即执行。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we call the `Start` method for many threads, one after the other, or when
    combined with a `BackgroundWorker` thread as in our example, we are not sure which
    one is going to run faster. We cannot assume one of them will reach some statement
    first, because the execution speed will depend upon the processor or the core
    it is assigned to and its capabilities. If it needs more context switches than
    the other thread, it will take longer to reach the same statement.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们依次调用许多线程的 `Start` 方法，或者当与我们的示例中的 `BackgroundWorker` 线程结合使用时，我们不确定哪一个会更快地运行。我们不能假设它们中的任何一个会首先到达某个语句，因为执行速度将取决于分配给它的处理器或核心及其能力。如果它需要比其他线程更多的上下文切换，它将需要更长的时间才能到达相同的语句。
- en: This is one of the most important issues with concurrency. It all depends on
    something that we do not know how to predict sometimes. Therefore, we must consider
    every possible situation the code that will be executed concurrently might experience.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是并发性中最重要的问题之一。这完全取决于我们有时不知道如何预测的事情。因此，我们必须考虑将要并发执行的代码可能遇到的每一种可能的情况。
- en: When we call the `Join` method, the thread is attached to the thread that calls
    the `Join` method and it will not execute anything else until the thread method
    finishes its execution. This is one of the most difficult things to achieve for
    programmers used to traditional linear code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Join`方法时，线程将附加到调用`Join`方法的线程，并且它将不会执行任何其他操作，直到线程方法完成其执行。这对于习惯于传统线性代码的程序员来说是最难实现的事情之一。
- en: Passing parameters to threads
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: We have used the `BackgroundWorker` component combined with the `Thread` class
    to provide fast execution and UI feedback. Now, we will combine multiple `Thread`
    class instances with many `BackgroundWorker` components to create an application
    that runs as fast as possible on modern computer architectures. In fact, it will
    inspect the computer it is running on and create an encryption thread for each
    processing core the computer has. This will maximize the performance without creating
    extra threads that will not further improve performance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`BackgroundWorker`组件和`Thread`类来提供快速执行和UI反馈。现在，我们将多个`Thread`类实例与许多`BackgroundWorker`组件结合起来，创建一个在现代计算机架构上尽可能快速运行的应用程序。实际上，它将检查其正在运行的计算机，并为计算机的每个处理核心创建一个加密线程。这将最大化性能，而不会创建额外的线程，这些线程不会进一步提高性能。
- en: We will work with dynamic lists and the `Environment.ProcessorCount` property
    to create threads on the fly according to the number of cores on the machine.
    However, we need some technique to distribute the SMS messages that must be encrypted
    to the many encrypting threads. At the same time, we must provide feedback through
    many `BackgroundWorker` components. It sounds complex, and it is indeed complex.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用动态列表和`Environment.ProcessorCount`属性来根据机器上的核心数动态创建线程。然而，我们需要一些技术来将必须加密的短信消息分配到许多加密线程中。同时，我们必须通过许多`BackgroundWorker`组件提供反馈。这听起来很复杂，确实也很复杂。
- en: To achieve this goal, we must pass specific parameters to the common procedure
    that the many threads will run. We want to reuse the procedure because we want
    it to be dynamically organized according to the number of available cores at runtime.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个目标，我们必须将特定参数传递给许多线程将运行的公共过程。我们希望重用这个过程，因为我们希望它在运行时根据可用的核心数动态组织。
- en: How to do it
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Now, we are going to make some big changes to the application, modifying variables
    to be lists, or lists of lists, so they can be accessed by multiple threads created
    dynamically. In order to accomplish that, we must share data between the many
    threads:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对应用程序进行一些重大更改，将变量修改为列表，或列表的列表，以便它们可以被多个动态创建的线程访问。为了实现这一点，我们必须在许多线程之间共享数据：
- en: Open the `SMSEncryption` project.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SMSEncryption`项目。
- en: 'Add the following line in the `MainWindow` class definition to declare a new
    private variable that will tell us the number of cores on the machine:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类定义中添加以下行，以声明一个新的私有变量，该变量将告诉我们机器上的核心数：
- en: '[PRE33]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Change the definition for the following private variables in the `MainWindow`
    class definition to make them lists:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainWindow`类定义中以下私有变量的定义更改为使它们成为列表：
- en: '[PRE34]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following line in the `MainWindow` class definition to declare a new
    private variable that will hold the list of the `Thread` class instances:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类定义中添加以下行，以声明一个新的私有变量，该变量将保存`Thread`类实例的列表：
- en: '[PRE35]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The variables required to grow dynamically, according to the number of cores
    found in the computer, have been added to the application.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据计算机中找到的核心数动态增长的变量已经添加到应用程序中。
- en: Note
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One potential problem of manually assigning a value greater than the number
    of available cores to the `priProcessorCount` variable is that the increasing
    context switches needed by the operating system scheduler will degrade performance.
    Therefore, you must be wary of wrong fine-tuning.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 手动将大于可用核心数的值分配给`priProcessorCount`变量可能的一个潜在问题是，操作系统调度程序所需的增加的上下文切换将降低性能。因此，你必须小心不要进行错误的微调。
- en: Now, let's change the different methods to allow multiple threads to encrypt
    the strings as fast as possible.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改变不同的方法，以便尽可能快地让多个线程加密字符串。
- en: 'It is going to be easier rewriting these than making the changes, as we are
    replacing single variables by lists. In order to accomplish this, we must create
    a thread with a parameter indicating its number:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重写这些代码比进行更改要容易，因为我们正在用列表替换单个变量。为了实现这一点，我们必须创建一个带有参数的线程，该参数指示其编号：
- en: Open the `SMSEncryption` project.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SMSEncryption` 项目。
- en: 'Replace the definition for `ThreadEncryptProcedure` with the following (now
    it receives a parameter):'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ThreadEncryptProcedure` 的定义替换为以下内容（现在它接受一个参数）：
- en: '[PRE36]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Change the text in the labels from `Encrypted Message` to `Encrypted Message(by
    thread 1)` and `Number of Messages Encrypted` to `Number of Messages Encrypted(by
    thread 1)`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签中的文本从 `Encrypted Message` 更改为 `Encrypted Message(by thread 1)`，并将 `Number
    of Messages Encrypted` 更改为 `Number of Messages Encrypted(by thread 1)`。
- en: 'Replace the code in the `ThreadEncryptProcedure` procedure with the following:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ThreadEncryptProcedure` 过程中的代码替换为以下代码：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace the code where the threads were initialized and started in the `Click`
    event handler in the `butRunInThread` button, after the line `prlsSMSToEncrypt.AddRange(txtOriginalSMS.Lines);`,
    with the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在 `butRunInThread` 按钮的 `Click` 事件处理程序中初始化和启动线程的代码替换为以下代码，在 `prlsSMSToEncrypt.AddRange(txtOriginalSMS.Lines);`
    行之后：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Open the `DoWork` event in the `BackgroundWorker bakShowEncryptedStrings` and
    make the following code replacements to the existing code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BackgroundWorker bakShowEncryptedStrings` 的 `DoWork` 事件中打开，并对现有代码进行以下代码替换：
- en: Replace `priLastEncryptedString` with `priLastEncryptedString[0]`
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `priLastEncryptedString` 替换为 `priLastEncryptedString[0]`
- en: Replace `proThreadEncryption` with `prloThreadList[0]`
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `proThreadEncryption` 替换为 `prloThreadList[0]`
- en: 'Open the `ProgressChanged` event in the `BackgroundWorker bakShowEncryptedStrings`
    and make the following code replacements to the existing code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BackgroundWorker bakShowEncryptedStrings` 的 `ProgressChanged` 事件中打开，并对现有代码进行以下代码替换：
- en: Replace `priLastEncryptedString` with `priLastEncryptedString[0]`
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `priLastEncryptedString` 替换为 `priLastEncryptedString[0]`
- en: Replace `prlsEncryptedSMS[i]` with `prlsEncryptedSMS[0][i]`
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `prlsEncryptedSMS[i]` 替换为 `prlsEncryptedSMS[0][i]`
- en: Build and run the application.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: Enter or copy and paste a very long text (with more than 20,000 lines) in the
    textbox labeled **Original Messages** and click on the **Run in a Thread** button.
    You will see the strings representing the messages encrypted by thread 1 appearing
    in the textbox labeled **Encrypted Messages (by thread 1)**, while the number
    of messages encrypted by thread 1 increases. In this example, there were 119 lines
    in the text message with a `ProcessorCount` of `4`:![How to do it](img/8321EN_03_07.jpg)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标记为 **Original Messages** 的文本框中输入或复制粘贴一个非常长的文本（超过 20,000 行），然后点击 **Run in a
    Thread** 按钮。你将在标记为 **Encrypted Messages (by thread 1)** 的文本框中看到由线程 1 加密的字符串，同时线程
    1 加密的短信数量会增加。在这个例子中，文本消息中有 119 行，`ProcessorCount` 为 `4`：![如何操作](img/8321EN_03_07.jpg)
- en: How it works
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The code has become more complex. However, running this application in a quad-core
    computer improves the performance by almost a factor of four. We do not realize
    the full 4x performance gain because of the overhead of multithreading that we
    discussed in [Chapter 1](ch01.html "Chapter 1. Understanding Multiprocessing and
    Multiple Cores"), *Understanding Multiprocessing and Multiple Cores*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得更加复杂。然而，在四核计算机上运行此应用程序可以提高性能，几乎提高了四倍。我们没有实现 4 倍的性能提升，因为我们在 [第 1 章](ch01.html
    "第 1 章。理解多处理和多核心") 中讨论的多线程开销，*理解多处理和多核心*。
- en: Now, when the user clicks on the **Run in a Thread** button, the encryption
    runs in as many threads as there are available cores in the computer with an asynchronous
    execution. At the same time, the `BackgroundWorker` component starts running concurrently
    displaying the results just for the first thread.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击 **Run in a Thread** 按钮时，加密将在计算机中可用的核心数那么多线程中异步执行。同时，`BackgroundWorker`
    组件开始并行运行，仅显示第一个线程的结果。
- en: The private string list that works as an input for the many threads is the same
    as in the previous examples (`prlsSMSToEncrypt`), but is accessed in a different
    way by each thread.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多个线程输入的私有字符串列表与前面的示例相同（`prlsSMSToEncrypt`），但每个线程以不同的方式访问。
- en: The private string list that works as an output (`prlsEncryptedSMS`) is now
    a list of string lists. Thus, each thread can work in its own output.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出工作的私有字符串列表（`prlsEncryptedSMS`）现在是一个字符串列表的列表。因此，每个线程可以在自己的输出中工作。
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There is a new thread list that will be aligned with the value in the `priProcessorCount`
    variable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新的线程列表，将与 `priProcessorCount` 变量的值对齐：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This replaces the line that declared the `proThreadEncryption` variable with
    the `Thread` type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这替换了声明 `proThreadEncryption` 变量的 `Thread` 类型的行。
- en: 'When the user clicks on the **Run in a Thread** button, the following lines
    create an instance of the `Thread` class specifying the method it must execute
    in the new thread when started. In order to accomplish this, we use the `ParameterizedThreadStart`
    delegate because we need to send a parameter with the number of threads to identify
    each thread in the method it runs. This is an important change to note. Earlier,
    we just called the `ThreadStart` method. This new method allows us to start a
    thread that has a delegate method that takes a parameter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**在单独的线程中运行**按钮时，以下行创建了一个`Thread`类的实例，指定了在新线程启动时必须执行的方法。为了实现这一点，我们使用了`ParameterizedThreadStart`委托，因为我们需要发送一个带有线程数的参数来识别运行的方法中的每个线程。这是一个需要注意的重要变化。之前，我们只是调用了`ThreadStart`方法。这个新方法允许我们启动一个具有委托方法的线程，该方法接受一个参数：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once each thread is created, it does not start running the code in the specified
    `ThreadEncryptProcedure` procedure until we call the `Start` method. But first
    we initialize the threads, and then we call the `Start` method for each one. We
    want to send a parameter (the thread number) to the method. Therefore, we use
    the `Start` method with one parameter. Take a moment to make sure you understand
    how these methods operate.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了每个线程，它不会在指定的`ThreadEncryptProcedure`程序中开始运行代码，直到我们调用`Start`方法。但首先我们初始化线程，然后为每个线程调用`Start`方法。我们想要向方法发送一个参数（线程号）。因此，我们使用带有一个参数的`Start`方法。花点时间确保你理解这些方法是如何工作的。
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This method tells the scheduler to start running the code in the new threads
    (one per available core). Then, we want to run the `BackgroundWorker` thread concurrently
    to report the UI with feedback from the first created thread (thread number `0`):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法告诉调度器在新线程中开始运行代码（每个可用核心一个）。然后，我们想要并发运行`BackgroundWorker`线程，以从第一个创建的线程（线程号`0`）报告UI反馈：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In a dual-core or dual-processor computer, we will have two encrypting threads
    and one `BackgroundWorker` thread. In a quad-core computer, we will have four
    encrypting threads and one `BackgroundWorker` thread.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在双核或双处理器的计算机中，我们将有两个加密线程和一个`BackgroundWorker`线程。在四核计算机中，我们将有四个加密线程和一个`BackgroundWorker`线程。
- en: It makes the new threads run the `ThreadEncryptProcedure` method code (with
    the thread number as a parameter), and when they finish their execution, it returns
    the control to the main thread and goes on with the next statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 它使新线程运行`ThreadEncryptProcedure`方法代码（带线程号作为参数），当它们完成执行后，它将控制权返回给主线程，并继续执行下一个语句。
- en: Separating the code into many concurrent threads using the `Thread` class and
    sending parameters to them is easy if we follow this simple code pattern and we
    have a good knowledge of working with lists or dynamic arrays.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循这个简单的代码模式，并且对使用列表或动态数组有很好的了解，那么使用`Thread`类将代码分离成许多并发线程并向它们发送参数是很容易的。
- en: We did not want to use many methods, one for each new thread. We wanted to share
    the same method and differentiate among the threads using a parameter with a number
    that identifies each.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想为每个新线程使用很多方法。我们想要共享相同的方法，并通过一个带有识别每个线程的数字的参数来区分线程。
- en: There are many ways to distribute the work in many concurrent threads working
    on the same algorithm, taking the same input and producing almost the same output.
    We used one of them, and we will learn more in the following chapters using both
    the `Thread` and `Task` classes and the `Parallel` library.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多并发线程中分配工作，这些线程正在处理相同的算法，使用相同的输入并产生几乎相同的输出，有多种方法。我们使用了其中一种，在接下来的章节中，我们将通过使用`Thread`和`Task`类以及`Parallel`库来学习更多。
- en: 'The parameter that is sent when calling the `Start` method for the thread instance
    is received in the `object` parameter, `poThreadParameter`, as shown in the following
    declaration:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用线程实例的`Start`方法时发送的参数在以下声明中作为`object`参数`poThreadParameter`接收：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Therefore, we must use typecasting to convert it to an integer:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须使用类型转换将其转换为整数：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: With the thread number and the total number of threads (the value in the `priProcessorCount`
    variable) that will be sharing the work to be done, we can easily distribute the
    work of a list to be processed (encrypted). A simple way to do this is to make
    each thread take the input it must process and leave the rest untouched.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程号和将要共享要执行的工作的总线程数（`priProcessorCount`变量中的值），我们可以轻松地将要处理的列表的工作分配。一种简单的方法是让每个线程处理它必须处理的输入，并保持其余部分不变。
- en: 'This is done in the iteration, which goes through the string list from the
    thread number (hence, each thread will begin in a different number) to the total
    number of strings to encrypt, stepping up the value in the `priProcessorCount`
    variable (the total number of threads):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在迭代中完成的，它从线程号（因此，每个线程将从不同的数字开始）遍历字符串列表到要加密的字符串总数，步进`priProcessorCount`变量（线程总数）的值：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For example, let''s suppose that there are four threads. They will work on
    the following strings from the list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设有四个线程。它们将从列表中的以下字符串开始工作：
- en: '`Thread #1: 0; 4; 8; 12; 16; 20; …`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread #1: 0; 4; 8; 12; 16; 20; …`'
- en: '`Thread #2: 1; 5; 9; 13; 17; 21; …`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread #2: 1; 5; 9; 13; 17; 21; …`'
- en: '`Thread #3: 2; 6; 10; 14; 18; 22; …`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread #3: 2; 6; 10; 14; 18; 22; …`'
- en: '`Thread #4: 3; 7; 11; 15; 19; 23; …`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread #4: 3; 7; 11; 15; 19; 23; …`'
- en: Here, we will consider them running concurrently.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将考虑它们是并发运行的。
- en: 'The string list capacity for `prlsEncryptedSMS[liThreadNumber]` is determined
    by the total number of strings to be encrypted divided by the total number of
    threads (the value in the `priProcessorCount` variable):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`prlsEncryptedSMS[liThreadNumber]`的字符串列表容量由要加密的字符串总数除以线程总数（`priProcessorCount`变量中的值）确定：'
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It can be wrong by `1`, but it does not matter in this case (reserving capacity
    is better), because the thread increments a variable with the number of processed
    strings:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能错误`1`，但在这个情况下没有关系（保留容量更好），因为线程增加一个变量，该变量包含已处理的字符串数：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code in the `BackgroundWorker` component was modified to show only the progress
    of the first thread. This can be changed or additional `BackgroundWorker` components
    added to display the progress of all encryption threads.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackgroundWorker`组件中的代码被修改，只显示第一个线程的进度。这可以更改或添加额外的`BackgroundWorker`组件来显示所有加密线程的进度。'
- en: Have a go hero – concurrent UI feedback
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄式并发UI反馈
- en: As mentioned earlier, there is still some work to be done. The FBI wants to
    see all the code being encrypted and not just the work done by the first thread.
    Remember, they have a computer with 16 quad-core microprocessors (64 cores).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，还有一些工作要做。联邦调查局希望看到所有正在加密的代码，而不仅仅是第一个线程的工作。记住，他们有一台装有16个四核微处理器的计算机（64个核心）。
- en: Using everything we have learned, develop a new version of this application
    that shows the progress for each dynamically created thread. Show the progress
    in numbers, in a progress bar, and in textboxes (adding the encrypted SMS messages).
    For all these controls, as many concurrent threads as the number of available
    cores are running in the application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们所学的一切，开发这个应用程序的新版本，显示每个动态创建的线程的进度。以数字、进度条和文本框（添加加密短信）的形式显示进度。对于所有这些控件，应用程序中运行的并发线程数与可用核心数相同。
- en: Then, use the control procedures of the `Thread` class instances we learned
    in order to create a final collection procedure that takes the results of all
    the running threads and shows the complete list of encrypted messages.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用我们学习的`Thread`类实例的控制程序，创建一个最终收集程序，该程序接受所有运行线程的结果并显示加密消息的完整列表。
- en: 'Enhance the application changing the string lists with instances of a new class,
    using the following information:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下信息，通过将字符串列表更改为新类的实例来增强应用程序：
- en: Caller ID
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来电显示
- en: Destination number
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标号码
- en: SMS message
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信消息
- en: Encrypt all the fields and compute the total number of characters sent.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 加密所有字段并计算发送的总字符数。
- en: Show the incoming and outgoing SMS messages with their information in a grid
    with many columns, instead of using textboxes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多列的网格显示传入和传出的短信消息及其信息，而不是使用文本框。
- en: Switch off the webcam. The FBI is looking for you for a new mission!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭摄像头。联邦调查局正在寻找你执行新任务！
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned a lot in this chapter about working with threads and the `Thread`
    class. We learned how to create threads, coordinate them synchronously and asynchronously,
    and pass parameters to them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于使用线程和`Thread`类的大量知识。我们学习了如何创建线程、同步和异步地协调它们以及向它们传递参数。
- en: 'In this chapter, we learned about the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下内容：
- en: Developing applications that are able to provide greater control over multiple
    running threads, created using the `Thread` class
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发能够提供对使用`Thread`类创建的多个运行线程更多控制的程序
- en: Programming the code to be executed by the `Thread` class instance when started
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程代码，以便在`Thread`类实例启动时执行
- en: Creating independent and flexible threads using the powerful `Thread` class
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强大的`Thread`类创建独立且灵活的线程
- en: Starting, controlling, and coordinating multiple threads with great flexibility
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以极大的灵活性启动、控制和协调多个线程
- en: Sending parameters and retrieving data from independently running threads
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从独立运行的线程发送参数和检索数据
- en: Sharing data between many threads
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多线程之间共享数据
- en: Combining asynchronous and synchronous execution
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合异步和同步执行
- en: Matching the number of available cores with the number of concurrent threads
    to take full advantage of parallel processing capabilities in modern computers
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可用核心数与并发线程数相匹配，以充分利用现代计算机的并行处理能力
- en: In the next chapter, we will take an even deeper dive into the `Thread` class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨`Thread`类。
