- en: '*Chapter 9*: Story API – Observing and Reacting to Story Events'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore how changes in a running ink story can trigger
    events in Unity. We will learn how the `ObserveVariable()` and `ObserveVariables()`
    methods of the Story API, as provided by the ink-Unity Integration plugin, allow
    you to prepare functions to react to future events in Unity. We will begin by
    observing a single variable and then move on to learn how to watch multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123), *Story API
    – Accessing ink Variables and Functions*, the focus was on controlling an ink
    story by calling its functions and changing its values from Unity. This chapter
    reverses the emphasis between the two systems. In this chapter, we will explore
    how narrative events, such as variables changing because of a player's choices,
    can be used to control what information is presented in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for variable changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically responding to ink stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing multiple ink values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples used in this chapter, in the `*.ink` files, can be found on GitHub
    at [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter9).
  prefs: []
  type: TYPE_NORMAL
- en: Listening for variable changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables in ink are global. Once they are created, they can be accessed at
    any point in the story. In [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123),
    *Story API – Accessing ink Variables and Functions*, we learned how this functionality
    can be used with the `variablesState` property to access or change their values.
    However, instead of directly interfering in a running ink from Unity, we can also
    wait for something to happen in ink and then react in Unity. The verb used for
    this type of approach, as part of the Story API, is called *observing*.
  prefs: []
  type: TYPE_NORMAL
- en: When we observe an ink variable, we can write our own rules regarding what should
    happen when its value changes or meets a certain threshold. We are merely *observing*
    its value. What we do because of this observance is up to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will explore the `ObserveVariable()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you create a new Unity 2D project for this topic. Instructions
    regarding how to create a new Unity project and import the ink-Unity Integration
    plugin can be found in [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092),
    *Adding and Working with the ink Unity Plugin.*
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In a new Unity project, using the 2D template with the ink-Unity Integration
    plugin imported, create a new, empty game object and name it `InkStory`. This
    game object will hold the `script` component and react to changes in the Ink code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Ink file and name it `InkStoryStepCounter.ink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `InkStoryStepCounter.ink` for editing in Inky and update its contents to
    `Example 1 (InkStoryStepCounter.ink).`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `script` component inside the `InkStory` game object. Name the
    created file `InkStoryScript.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `InkStoryScript.cs` for editing in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update `InkStoryScript.cs` to `Example 1 (InkStoryScript.cs)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ObserveVariable()` method is a new method introduced in this chapter and
    accepts two parameters. The first parameter is the name of a variable to observe
    and the second is a function or a method to call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code used in this example also incorporates a C# concept known as a `ObserveVariable()`
    method watches a variable in ink. If its value changes at any point, the lambda
    expression will run. This operates outside the normal flow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Associate the compiled Ink JSON file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the project is run, the `ObserveVariable()` method, and the third will
    be the text produced as the first option chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Text output is shown in order of execution in Unity](img/Figure_9.1_B17597.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The Text output is shown in order of execution in Unity
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the second message shows the value before the third text of the
    option is because of the execution order. Within the running ink story, the `ObserveVariable()`
    method occurs *before* the text output is produced for the option and returned
    to Unity. The use of the delegated lambda expression occurs outside the normal
    flow of execution in this way. Whenever the value of the observed variable changes,
    the function is immediately called, regardless of any other code happening around
    it at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build on this pattern. Often, there are contexts
    in which Unity should only be told a variable has been changed when it happens.
    This frees up the execution time for other tasks in Unity and allows a developer
    to write more reactive code that only runs when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically responding to ink stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unity, multiple methods are called as part of the normal execution cycle
    when a project runs. Often, methods such as `Update()`, a common part of behavior
    scripts in Unity, include many lines of code. Even a method such as `FixedUpdate()`,
    called at the end of the physics calculations for each cycle in a running project,
    might include multiple parts. Any code that depends on other systems, such as
    those communicating with ink, can also add extra time per cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `ObserveVariable()` method allows data from ink to only update
    Unity when needed. Because the Story API will only call the delegated function
    when necessary, Unity will also only get the data when there is a change it needs
    to know about when it needs to know about it. This will also happen outside the
    use of an `Update()` method or even a `FixedUpdate()` method in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will examine how the `ObserveVariable()` method operates
    outside of other methods as part of Unity. It will only call the delegated function
    when a value changes allowing a dynamic response in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return to the project created in the previous section, and perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `InkStoryScript.cs` file to `Example 2 (InkStoryScript.cs)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `Update()` method, four different actions are taking place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *first* is the increase in the variable time with the most recent `Time.deltaTime`,
    which is the number of milliseconds between cycles as measured in a decimal (float)
    number. The *second* is a conversion between its float value into an integer.
    This operation removes the decimal part of the number. The *third* action is a
    mathematical operation called `%`, can be used to find the remainder from division.
    This operation is called *modulo*. However, many programming languages also use
    the term *remainder operator*. When this operation is performed, it will determine
    how many times one number can be divided into another. In this case, using the
    remainder of `60`, the `seconds` variable will always be equal to the number of
    seconds that have passed since the project began, as divided by the `time` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The *fourth* action within the `Update()` method is the assignment of the `seconds`
    variable to the number of seconds, as defined by the previously explained actions.
    In every cycle in Unity, this number will be updated, and the `seconds` variable
    will always be up to date.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One final action takes place in the delegated function, that is, the use of
    the `Destroy()` method. Within the code, once the value of the `steps` ink variable
    is equal to `3`, as determined by Unity, it will remove a button from the scene.
    This helps to keep the control of the button connected to a value changed outside
    of Unity. Once the ink variable changes and is reported to Unity, the button is
    removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the last line of the `Start()` method, a button is given a listener function
    for its `onClick` event. When the button is clicked on, any functions associated
    with the listeners will be called. In this example, clicking on the button will
    call the new `TakeStep()` method. This will load the next text content up to the
    next weave encountered in the ink code and then choose the first (`0`) option
    within the weave. This will cause the ink code to loop internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the code created, two more steps are required before the project can be
    played. First, a new `Button` game object needs to be added to the project. Then,
    once the `Button` game object exists, it must be associated with the `InkStory`
    property as part of the new code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new `Button` game object in Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate the `Button` game object with the `Button Step` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The created `Button` game object appears at the bottom of the scene. Clicking
    on the `Button` game object four times will cause it to disappear, and a message
    will appear in the **Console** window:![Figure 9.2 – A message in the Console
    window generated by a delegated function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B17597.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.2 – A message in the Console window generated by a delegated function
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the project first started, the `Update()` method of the code was called
    during each cycle. Internally, it updated the `time` and `seconds` variables in
    the Unity code. Whenever the `Button` game object was clicked on, it progressed
    the ink code, which looped itself internally. Because of the use of the `ObserveVariable()`
    method, any time the ink variable steps were updated, it called the delegated
    function and tested the new value passed to it. Once it reached `3` (based on
    a total of four clicks to move it from `0` to `3`), the delegated function created
    a message in the `Button` game object.
  prefs: []
  type: TYPE_NORMAL
- en: The example used in this section follows a common pattern where Unity performs
    its own calculations as part of a method, such as `Update()`, and dynamically
    responds to changes in an ink story as they happen. Instead of potentially checking
    the `steps` ink variable as part of the `variablesState` property every cycle,
    and wasting time if the value has not changed, the delegated function allows Unity
    to only act when needed. For more complicated projects, this is the preferred
    approach, and generally, it produces faster projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'More than a single variable can be observed in ink. Depending on the complexity
    of design, a Unity project might be interested in observing multiple ink values
    and updating onscreen areas with information on story progression or the current
    statistics of the player. For these contexts, a different method is needed: `ObserveVariables()`.
    In the next section, we will demonstrate how to work with this method.'
  prefs: []
  type: TYPE_NORMAL
- en: Observing multiple ink values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with the `ObserveVariable()` method is a sister method named `ObserveVariables()`.
    However, while the `ObserveVariable()` method accepts the name of a variable and
    a delegate function, the `ObserveVariables()` method accepts an `IList<string>`
    of variable names and a delegate function. Instead of responding when a single
    variable is changed, its delegate function is called when any of the variables
    passed as a list to the method are changed. While slightly more complicated to
    set up, the `ObserveVariables()` method provides the functionality to observe
    multiple ink variables.
  prefs: []
  type: TYPE_NORMAL
- en: Recommendation
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you create a new Unity 2D project for this section. Instructions
    regarding how to create a new Unity project and import the ink-Unity Integration
    plugin can be found in [*Chapter 6*](B17597_06_Final_PG_ePub.xhtml#_idTextAnchor092),
    *Adding and Working with the ink-Unity Integration Plugin*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In a new Unity 2D project with the ink-Unity Integration plugin imported, create
    a new, empty game object and name it `InkStory`. This game object will hold the
    `Script` component and react to any changes in the ink code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new ink file and name it `InkStoryPlayerStatistics.ink`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `InkStoryPlayerStatistics.ink` file for editing in Inky and update
    its content to `Example` `3` `(InkStoryPlayerStatistics.ink)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `script` component inside the `InkStory` game object. Name the
    created file `InkStoryPlayerStatisticsScript.cs`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the created `InkStoryPlayerStatisticsScript.cs` file in Visual Studio.
    Update it to `Example` `3` `(` `InkStoryPlayerStatisticsScript.cs)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The updated code begins by setting up the Story API. It does this by creating
    a new object based on the `Story` class. Next, a `List<string>` is created. This
    is used as a *list* of the variable names based on their string values. After
    creating the list, two values are added to it in an order, based on the names
    of the `mental_health` and `physcial_health` ink variables. This created list
    is then passed to the `ObserveVariables()` method, and a second parameter, that
    is, a delegated function in the form of a lambda expression, is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `Start()` method ends with a call to the created `ProgressStory()` method.
    Inside this created method, the story is progressed programmatically by using
    the `ContinueMaximally()` and `ChooseChoiceIndex()` methods. The first method
    loads all of the text content up to the first weave, while the second method selects
    the first (`0`) option in the weave. The final, second use of the `ContinueMaximally()`
    method loads the resulting text within the Ink code and is needed to cause the
    variable to change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Associate the compiled Ink JSON file with the `InkStory` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the project starts, it will programmatically progress the ink story used
    within this section. As a result, it will produce a message in the `List<string>`
    that was passed to the `ObserveVariables()` method. However, only one of them
    was changed because of the ink story progression. As a result, the variable changed,
    and its new value was passed back to Unity. When the change happened, the delegated
    function was called with the second parameter, the name of the variable (`variableName`),
    and its new value (`newValue`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `ObserveVariables()` method works similarly to its sister `ObserveVariable()`
    method. Both respond with the name of the variable and the changed value as soon
    as they happen in ink. The major difference between them is in their first parameter.
    The `ObserveVariables()` method accepts the name of a single variable name in
    ink, and the `ObserveVariables()` method is a list of which variables to observe
    and then respond to using the delegated function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Stop the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This section focused on the use of the `ObserveVariables()` method, echoing
    the pattern in the previous section where we used the `ObserveVariable()` sister
    method. In general, either approach offers a way to control how Unity reacts to
    ink, shifting the control of information between the two systems. Along with the
    `variablesState` property, the different approaches in this chapter, as covered
    in [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123), *Story API –
    Accessing ink Variables and Functions*, provide access to the variables in ink.
    They can be used in a project, depending on the needs of the developer, to either
    drive a Unity project more from the ink side or directly change values on the
    ink side from the Unity code as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored multiple examples. First, we started with the `ObserveVariable()`
    method and watched only one variable. In the second section, we dynamically responded
    to ink stories in Unity. Using delegated functions, we learned how parts of a
    piece of code will only be called when an ink variable changes. In the third section,
    we looked at the use of the `ObserveVariables()` method to watch multiple variables
    specified by name.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B17597_10_Final_PG_ePub.xhtml#_idTextAnchor145), *Dialogue
    Systems with ink*, we will move away from the individual properties and methods
    of the Story API and start to combine functionality into more complex use cases.
    Combining parts of the Unity API introduced in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Unity API – Making Choices and Story Progression*, along with the `ObserveVariable()`
    method covered in this chapter, we will examine how to create different dialogue
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the action of *observing*, and how does it apply to the methods provided
    by the `Story` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What roles do delegated functions serve when working with the `ObserveVariable()`
    and `ObserveVariables()` methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `ObserveVariable()` method and the `ObserveVariables()`
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between accessing ink variables using the `variablesState`
    property and using the `ObserveVariable()` method or the `ObserveVariables()`
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
