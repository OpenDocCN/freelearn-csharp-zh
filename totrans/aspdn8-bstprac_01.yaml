- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Control with Source Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control is a developer’s best friend and provides them with a way to
    experiment with code without losing important changes. Source control is the ability
    to track and maintain changes made to code throughout a development process. While
    this could include code, it can also be used for documentation, assets (such as
    images), and other resources. Being able to test certain conditions and the ability
    to refactor code without worrying about the code base is what most developers
    consider a superpower.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Source control is extremely important when working in a team environment. If
    a developer checks in code and later realizes they made a mistake, source control
    gives developers a way to revert changes or update a branch and re-commit. Companies
    not using some type of source control almost always raises a red flag.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll look at common practices developers use in the industry
    when using source control. We’ll also cover various ways to implement branching
    workflows for your code as well as examine the different types of branches in
    each workflow. To finish off the chapter, we’ll review common etiquette among
    developers when using source control.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Branching Strategies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating short-lived branches
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always “Get Latest” Before Committing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Common Practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned the best approach to creating
    a repository of your code in an organized fashion, along with common guidelines
    in the developer community.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this section touches on a number of guidelines regarding source control,
    the only requirement for this chapter is a computer with any OS. Git is optional.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t have Git installed, you can download and install it at the following
    URL:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[https://git-scm.com/](https://git-scm.com/)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We have used mermaid-js to visually show the branching strategies. As of February
    2022, GitHub pages now support Mermaid-js. Some of the sections will include mermaid
    diagrams to demonstrate the different branching hierarchies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on Mermaid-js, navigate to the following URL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mermaid-js.github.io](https://mermaid-js.github.io)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Branching Strategies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore various branching strategies, explaining how
    each one works, and highlighting the differences between them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: While every company has its unique workflow, we’ll focus on some commonly used
    strategies in the industry.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: With GitFlow being the initial workflow, everyone is familiar with it in the
    industry and its successors have improved by making minor changes to the workflow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we’ll discuss each workflow, but first, we have to understand
    the fundamentals of GitFlow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common and most mature workflows in the industry is GitFlow.
    It was created by *Vincent Driessen* in 2010.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'A minimal Git repository should have the following branches:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: main/master/trunk (referred to as main from this point on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: develop
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `main` branch is what you start with when creating a new repository. The
    purpose of this branch is to *always* have stable and production-ready code for
    release at any time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The `develop` branch is for writing new code and preventing untested code from
    being merged into `main`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a standalone developer working on a side project, this may be a suitable
    workflow. If everything works in `develop`, you merge your changes into `main`
    and deploy your first version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The good news is you can evolve your branching hierarchy even further. You can
    easily create additional branches, such as feature, release, or hotfix branches,
    for a better workflow, which we’ll cover later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that each branching workflow discussed as follows allows any team,
    whether it’s 1 developer or 50 developers, to have a solid understanding of GitFlow.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'In any source control system, there are usually three types of branches used
    to assist with managing a software workflow: feature, release, and hotfix branches.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Feature Branches
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feature branching isolates a new feature into a single branch so a developer
    can write code without worrying about affecting the core code in the `develop`
    branch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: In the following example (see *Figure 1**.1*), a team created a GitHub repository.
    It called its primary branch `main` and the development branch `develop`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1: Feature branches in GitFlow](img/Figure_1.01_B19493.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Feature branches in GitFlow'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Once everyone received their tasks, one developer was assigned to create the
    `feature/settings` from the `develop` branch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Another developer was assigned the `feature/printing` branch also from the `develop`
    branch.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Naming Branches
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the standardized main and develop branches, one common way to name
    branches is to prefix the names. Some examples include the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '* `feature/`, `features/`, or `feature-`: The branch name should be as descriptive
    and helpful as possible. For example, `feature/1234-settings` relates to the `feature/jd-settings`).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '* `"bug/<userstory/task number>-<problem>/"`: This example is helpful for immediately
    identifying bugs. An example of this technique could be `bug/1234-string-overflow`.
    Prefixing a branch with “bugfix” is also acceptable.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Once they are finished and everything’s approved, each developer merges their
    changes into the `develop` branch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Release Branches
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Release branches are meant for last-minute polishing, minor bug fixes, and/or
    preparing for a new release of your software (how exciting!)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine how a release branch fits into our previous example. The following
    diagram shows what a release branch in GitFlow looks like:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: Release branch in GitFlow](img/Figure_1.02_B19493.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Release branch in GitFlow'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Initially, developers create a feature branch based on what they were assigned.
    Once they merge their changes to `develop`, a new release is created from the
    `develop` branch. The release branch is merged into `main` and tagged with the
    version number. The main branch will now merge into the `develop` branch so developers
    have the latest changes in case there were code changes during the release process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: It’s exactly the same as the feature branch, but if you notice, we’re creating
    the `release` branch from the `develop` branch and not from the `main` branch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: After the `release` branch is created and confirmed to work as expected, the
    `release` branch is merged into the `main` branch.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Once merged into `main`, it’s recommended to somehow identify a successful release.
    By convention, a tag with the version number is the best approach.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Hotfix branches
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While most developers don’t make coding mistakes (uh-huh), there are times when
    immediate changes are required to the `main` branch.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our example, it seems there was a problem with a developer’s code.
    The application bombs when anyone selects the **Settings** option, making the
    application unusable. It requires a hotfix branch.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an example of how to implement a hotfix branch:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3: Hotfix branch in GitFlow](img/Figure_1.03_B19493.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Hotfix branch in GitFlow'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Hotfix branches are created from the `main` branch and, once the code is verified,
    need to be merged back into `main` and also the `develop` branch.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The long-running branches in GitFlow are main and develop. The short-lived branches
    include the features, hotfix, and bugfix branches.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered GitFlow and its branch types, we’ll look at the next
    workflow, called GitHub Flow, and how it’s different from GitFlow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over time, GitFlow has evolved into easier workflows. The first of these workflows
    was GitHub Flow, which was created in 2011.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow was meant to simplify things by removing the `develop` branch and
    creating features off the `main` branch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how feature branches work along with a hotfix branch.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4: Hotfix branch in GitHub flow](img/Figure_1.04_B19493.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Hotfix branch in GitHub flow'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1**.4*, two features were created and both features were merged back
    into `main`. Immediately, version 1.0.0 was released. After the release of 1.0.0,
    some text was wrong on the site and the legal team requested for it to be fixed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: One of the developers created a hotfix branch, changed the label, requested
    a PR, got it approved, merged the change into `main`, updated the version, and
    immediately deployed the code to production.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between a hotfix and a feature branch? A hotfix is a branch
    created from *main/master*, with the code checked in, reviewed, updated, and immediately
    merged back into main/master. A feature branch is more of an organized or scheduled
    approach. The feature branch is created from the *develop branch*, with the code
    checked in, reviewed, and merged back into the feature branch. The feature branch
    is scheduled to be merged into a release branch.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: So, where is the release branch? In each workflow, there is a release branch
    of some kind, which we’ll review as follows. The concept of this branch is to
    always have a version error-free, tested, and ready to deploy at any time. Some
    small start-up companies use this type of workflow when starting out. With GitFlow
    considered as a baseline in the industry, it’s easy to apply the GitFlow concepts
    when the team grows and is looking for a more structured workflow.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In GitHub flow, the long-running branch here is, again, main, where the short-lived
    branches are the features, hotfix, and bugfix branches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing GitHub flow, let’s move on to the last commonly used branching
    strategy, called GitLab Flow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Flow
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final workflow that we’ll cover is GitLab Flow. Created in 2014, GitLab
    Flow takes a different approach to the GitFlow workflow and combines feature branches
    with issue tracking using feature-driven development.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Flow takes release branches and turns them into stable environment branches,
    such as production and QA. Of course, you can create as many “environment branches”
    as necessary. If we had a QA environment branch, this may be used to test the
    final product. In *Figure 1**.5*, we see the standard `feature` branches created
    from the `main` branch along with two other environment branches (pre-production
    and production).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: GitLab Flow](img/Figure_1.05_B19493.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: GitLab Flow'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In GitLab Flow, main is considered a testing branch. Whether it’s QA or a manager,
    it’s a place to test the feature branches.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Similar to GitHub Flow, everything merges into the `main` branch. When the feature
    branch is committed, code reviews are conducted (these are mandatory), and merged
    to main, all tests (yes, *all*) run. If the tests run for longer than five minutes,
    configure them to run in parallel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Once the testing is complete in main, `main` is pushed to `pre-production` for
    further testing and, finally, pushed to production. Since releases in GitLab Flow
    are based on tags, each tag should create a new release.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: If a developer introduced a bug, it would have to be fixed in main first, then
    the environment branches second. The developer would have to create a bugfix branch,
    commit with a PR approval, conduct a code review, and merge the code along with
    running tests related to the bug before they could continue through the workflow.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Once tested in main, it’s tagged and automatically promoted to pre-production
    and then production. Long-running branches in this workflow include main and the
    environment branches. Short-lived branches are the features, hotfix, and bugfix
    branches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: With each strategy we discussed in this section, we’ve seen how each one evolved
    from the initial GitFlow and (excuse the pun) branched into a better workflow.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The next sections refer to common etiquette when using source control.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Creating short-lived branches
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have initialized your repository and created your first branch, you
    can start writing code for your feature.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: While this is exciting, this guideline is meant more for teams as opposed to
    an individual building a side project. The larger the team, the more critical
    this becomes to your workflow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example using multiple feature branches in *Figure 1**.6*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6: Long-lived feature branch (feature/settings)](img/Figure_1.06_B19493.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Long-lived feature branch (feature/settings)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Everyone is assigned their respective feature branches, which are created for
    them. As you can see, the developers are completing their features and checking
    them into `develop`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: However, the developer working on the settings feature (`feature/settings`)
    is behind. Their branch is becoming stale since they haven’t updated their code
    over the week. It only contains their feature from when they first created their
    branch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: What do you think will happen if they decide to commit their code to the repository
    without updating their branch? There will be a lot of unhappy developers. Why?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The `feature/settings` branch will be committed and overwrite everyone who merged
    into the `develop` branch’s changes. The shorter your branch’s life expectancy,
    the less likely you’ll experience merge conflicts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: It’s best to perform updates on a daily basis, if not twice a day, to keep your
    branch from becoming stale.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Common Practices
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technically, knowing how to use source control is only half the battle. The
    other half is working as a team player while using source control. The ability
    to keep your fellow teammates in mind will take you further in your career as
    you become a considerate and trusted developer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The following sections are meant as guidelines to help you succeed in working
    in a team environment. If you work as an individual developer on an open source
    project, it doesn’t hurt to implement these practices as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Rebase when Private, Merge when Public
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working on a feature branch privately, there may be times where multiple
    commits are necessary. These commits add unnecessary noise to the `main`/`master`
    branch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing your code takes a number of local commits and updates another branch
    with a single commit. It essentially rewrites the commit history. Of course, this
    differs from a merge. Merging is the process of taking all of the commits from
    one branch and merging the entire progress into another branch. Merging maintains
    the entire history of commits.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Think of rebasing as cleaning up your house before showing it to a potential
    buyer. If you make a number of mistakes in your local branch, you want your main/master
    branch to provide clear and concise comments as to what was applied to the code
    when committed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Always “Get Latest” Before Committing
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the topic of keeping branches fresh, it’s a good habit to “Get Latest” before
    you commit your code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: “Get Latest” pertains to you retrieving any updates from a central repository
    and applying updates to your local repository of code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re using Git, **Team Foundation Server** (**TFS**), or another source
    control system, you need to keep your team in mind by always retrieving the latest
    code updates. Each source control tool has its own way of getting the latest version
    of the code. No matter what tool you use, it’s always a good habit to get the
    latest version.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Since Git is considered the standard in the industry because of its flexibility
    and granular approach to source control, most development environments provide
    an interface (graphical or command line) out of the box for interacting with Git.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'With Git, there are a couple of ways to push and pull changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**Fetch**: Retrieves remote metadata to your local repository.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull**: Retrieves remote metadata *and* pulls a copy of those changes to
    the local repository.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push**: Pushes commits to your remote branch.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sync**: The process of performing a *pull* first, then a *push* second. Remember,
    get the latest changes and apply those changes to your own code, then push your
    committed changes to the server’s repository.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right before a commit, it’s best to issue a pull to retrieve everything before
    committing your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Always Build and Test Before Committing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this may seem like a simple concept after mentioning our previous guideline,
    there are a number of developers who continue to miss this step when committing
    code. Once you’ve pulled the latest, the next step is to compile the code and
    run your local unit tests against it. Don’t assume the code you pulled is error-free.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: It’s a common circumstance that on a Friday afternoon, Developer B performs
    a pull to update their code, commits their code without compiling, and runs for
    the door.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: What they didn’t know is Developer-A committed code before Developer-B. It didn’t
    compile and Developer-A already left for the weekend. Now Developer-B pulled the
    code and he was unable to compile it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: On Monday, they find out their code didn’t build at all and the unit tests didn’t
    pass.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Or worse, they receive a call on Friday night with this news.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Committing Binaries
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source control systems have been around for a while, and most are long in the
    tooth (SourceForge, anyone?), but all of them have been used as source code repositories.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Recently, there have been a number of **Content Management Systems** (**CMSes**)
    using source code systems as content repositories where they manage and version
    the assets of a website, such as images, MP3s, and videos.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of developers, our content is our source code. Most developer
    repositories aren’t even as big as a Word document.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If developers want to keep a “snapshot” of the system by committing everything,
    this defeats the purpose of source control.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For .NET applications, compiling an application means the `\bin` and `\obj`
    folders will contain assemblies. These assemblies are automatically created when
    compiled and *do not* need to be committed to a repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In most source control systems, an ignore file of some kind exists to filter
    and remove bloat from your repository before checking in your code. For example,
    in Git, there is a `.gitignore` file, which should include these `\bin` and `\obj`
    directories along with other file types not necessary for building your solution
    or project.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As a general guideline, when you clone a repository and immediately build it
    on a new machine, no errors should appear whether it’s an internal corporate project
    or an open source framework on GitHub.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: If committing assemblies to Git from either your own project or third-party
    projects is to keep it in a runnable state, you’re doing it wrong. It’s best not
    to commit any binaries into Git.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: If you need a specific version of a third-party library, consider NuGet package
    management. When adding a NuGet package to your project, it automatically connects
    and retrieves the specific version and places it into the `\bin` folder, making
    the application compile, build, and successfully run every time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Use tags for versioning
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tags are extremely helpful when using source control. As a matter of fact, they’re
    what drives GitLab Flow. While tags are awesome for source control, they can be
    used for evil as well. For example, some companies use tags as comments throughout
    the entire workflow process, which is not recommended. Tags provide a way to place
    a flag in the ground to say, “This is version x.x.x.” They’re a marker of a code
    snapshot of a solid release. This signifies the code at this tag should build,
    compile, be tested, and run *with no changes made to the code and* *no errors*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: It’s best to use tags strictly for versioning your releases throughout your
    workflow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the different types of branching workflows
    available, including GitFlow, GitHub Flow, and GitLab Flow, and how each one works.
    Along with the workflows, you learned the industry-standard branch names, such
    as main/trunk/master, develop, features, release, and hotfix branches, and how
    they work in each workflow. You also learned the proper way to work with source
    control, such as always getting the latest code, when to rebase your code versus
    merging, allowing your branches to have a short lifespan, compiling and testing
    your code before committing, never checking in assemblies, and the proper use
    of tagging.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了可用的不同分支工作流程，包括GitFlow、GitHub Flow和GitLab Flow，以及每个工作流程是如何运作的。除了工作流程，你还学习了行业标准化的分支名称，例如main/trunk/master、develop、features、release和hotfix分支，以及它们在每个工作流程中的运作方式。你还学习了与源代码控制一起工作的正确方法，例如始终获取最新代码，何时进行变基而不是合并，让分支拥有短暂的生命周期，在提交前编译和测试你的代码，永远不要提交程序集，以及正确使用标签。
- en: In the next chapter, we’ll take the source code in our repository and create
    an automated build to create artifacts. We’ll also cover how to automatically
    deploy it to a server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从我们的仓库中提取源代码，创建一个自动构建过程以生成工件。我们还将介绍如何自动将其部署到服务器上。
