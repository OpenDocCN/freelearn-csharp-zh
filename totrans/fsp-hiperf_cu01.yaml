- en: Chapter 1. Performing Common Optimizations in F#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 在 F# 中执行常见优化
- en: 'It''s quite well-known today that F# has been a first class citizen, a built-in
    part of programming language support in Visual Studio, starting from Visual Studio
    2010\. F# is a programming language that has its own unique trait: it is a functional
    programming language and at the same time it has object-oriented programming (OOP)
    support. F# from the start has run on .NET, although we can also run F# on cross-platform,
    such as Android (using Mono).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，F# 已经成为一等公民，从 Visual Studio 2010 开始成为编程语言支持的内置部分。F# 是一种具有独特特征的编程语言：它是一种函数式编程语言，同时具有面向对象编程（OOP）支持。从开始，F#
    就在 .NET 上运行，尽管我们也可以在跨平台上运行 F#，例如 Android（使用 Mono）。
- en: Although F# mostly runs faster than C# or VB when doing computations, its own
    performance characteristics and some not so obvious bad practices and subtleties
    may have led to performance bottlenecks. The bottlenecks may or may not be faster
    than the C#/VB counterparts, although some of the bottlenecks may share the same
    performance characteristics, such as the use of .NET APIs. The main goal of this
    book is to identify performance problems in F#, measuring and also optimizing
    F# code to run more efficiently, while also maintaining the functional programming
    style as appropriately as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在执行计算时，F# 通常比 C# 或 VB 运行得更快，但其自身的性能特征以及一些不太明显的坏习惯和微妙之处可能会导致性能瓶颈。这些瓶颈可能比 C#/VB
    对应版本更快，尽管一些瓶颈可能具有相同的性能特征，例如使用 .NET API。本书的主要目标是识别 F# 中的性能问题，测量并优化 F# 代码以更高效地运行，同时尽可能保持函数式编程风格。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A basic knowledge of F# (including the functional programming concept and basic
    OOP) is required as a prerequisite to start understanding the performance problems
    and the optimization of F#.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为先决条件，需要具备基本的 F# 知识（包括函数式编程概念和基本面向对象编程）以开始理解性能问题和 F# 的优化。
- en: 'There are many ways to define F# performance characteristics and at the same
    time to measure them, but understanding the mechanics of running F# code, especially
    on top of .NET, is crucial and is also a part of the performance characteristics
    itself. This includes other aspects of approaches to identify concurrency problems
    and language constructs. This chapter describes the optimization of F# code and
    will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以定义 F# 性能特征并测量它们，但理解运行 F# 代码的机制，尤其是在 .NET 之上，是至关重要的，这也是性能特征本身的一部分。这包括识别并发问题的方法和语言结构等方面的其他方面。本章将描述
    F# 代码的优化，并将涵盖以下主题：
- en: Understanding the nature of F# code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 F# 代码的本质
- en: Overview of common bottlenecks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见瓶颈概述
- en: Commonly misunderstood concurrency problems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的误解并发问题
- en: Overview of tooling in .NET including Visual Studio to help understanding the
    running code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 工具概述，包括 Visual Studio，以帮助理解运行中的代码
- en: Immediate testing of F# code in F# interactive
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 F# interactive 中立即测试 F# 代码
- en: Introduction to debugging in F#
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 调试简介
- en: Understanding the nature of F# code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 F# 代码的本质
- en: Understanding the nature of F# code is very crucial and is a definitive prerequisite
    before we begin to measure how long it runs and its effectiveness. We can measure
    a running F# code by running time, but to fully understand why it may run slow
    or fast, there are some basic concepts we have to consider first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 F# 代码的本质非常关键，在我们开始测量其运行时间和有效性之前，这是一个确定性的先决条件。我们可以通过运行时间来测量运行中的 F# 代码，但要完全理解为什么它可能运行得快或慢，我们必须首先考虑一些基本概念。
- en: Before we dive more into this, we must meet the basic requirements and setup.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，我们必须满足基本要求和设置。
- en: After the requirements have been set, we need to put in place the environment
    setting of Visual Studio 2015\. We have to set this because we need to maintain
    the consistency of the default setting of Visual Studio. The setting should be
    set to **General**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好要求后，我们需要设置 Visual Studio 2015 的环境设置。我们必须设置这一点，因为我们需要保持 Visual Studio 默认设置的连续性。设置应设置为
    **常规**。
- en: 'These are the steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是步骤：
- en: Select the **Tools** menu from Visual Studio's main menu.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Visual Studio 的主菜单中选择 **工具** 菜单。
- en: Select **Import and Export Settings...** and the **Import and Export Settings
    Wizard** screen is displayed:![Understanding the nature of F# code](img/image00237.jpeg)
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **导入和导出设置...**，将显示 **导入和导出设置向导** 屏幕：![理解 F# 代码的本质](img/image00237.jpeg)
- en: Select **Reset all Settings** and then **Next** to proceed.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **重置所有设置** 然后点击 **下一步** 以继续。
- en: Select **No, just reset my settings overwriting my current setting** and then
    **Next** to proceed
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **否，仅重置我的设置覆盖我的当前设置** 然后点击 **下一步** 以继续
- en: Select  **General** and then click on **Finish**:![Understanding the nature
    of F# code](img/image00238.jpeg)
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **常规** 然后点击 **完成**：![理解 F# 代码的本质](img/image00238.jpeg)
- en: After setting it up, we will have a consistent layout to be used throughout
    this book, including the menu locations and the look and feel of Visual Studio.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，我们将有一个一致的布局，可用于本书的整个过程中，包括菜单位置和 Visual Studio 的外观和感觉。
- en: Now, we are going to scratch the surface of F# runtime with an introductory
    overview of common F# runtime, which will give us some insights into F# performance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过介绍常见的 F# 运行时概览来深入了解 F# 运行时，这将为我们提供一些关于 F# 性能的见解。
- en: F# runtime characteristics
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 运行时特性
- en: The release of Visual Studio 2015 occurred at the same time as the release of
    .NET 4.6 and the rest of the tools, including the F# compiler. The compiler version
    of F# in Visual Studio 2015 is F# 4.0.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 的发布与 .NET 4.6 以及其他工具（包括 F# 编译器）的发布同时进行。Visual Studio 2015
    中 F# 的编译器版本是 F# 4.0。
- en: F# 4.0 has no large differences or notable new features compared to the previous
    version, F# 3.0 in Visual Studio 2013.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Visual Studio 2013 中的 F# 3.0 相比，F# 4.0 没有大的差异或显著的新特性。
- en: Its runtime characteristic is essentially the same as F# 4.0, although there
    are some subtle performance improvements and bug fixes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 它的运行时特性本质上与 F# 4.0 相同，尽管有一些细微的性能改进和错误修复。
- en: 'For more information on what''s new in F# 4.0 (described as release notes)
    visit:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 F# 4.0 的新信息（描述为发布说明）请访问：
- en: '[https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md](https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md](https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md)'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, the online and offline MSDN Library of F#
    in Visual Studio does not have F# 4.0 release notes documentation, but you can
    always go to the GitHub repository of F# to check the latest update.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Visual Studio 中的 F# 在线离线 MSDN 库没有 F# 4.0 发布说明文档，但您始终可以访问 F# 的 GitHub
    仓库以检查最新更新。
- en: 'These are the common characteristics of F# as part of managed programming language:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 F# 作为托管编程语言的一部分的常见特性：
- en: F# must conform to .NET CLR. This includes the compatibilities, the IL emitted
    after compilation, and support for .NET BCL (the basic class library). Therefore,
    F# functions and libraries can be used by other CLR-compliant languages such as
    C#, VB, and managed C++.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 必须符合 .NET CLR。这包括兼容性、编译后生成的 IL 以及对 .NET BCL（基本类库）的支持。因此，F# 函数和库可以被其他 CLR
    兼容语言（如 C#、VB 和托管 C++）使用。
- en: The debug symbols (PDB) have the same format and semantics as the other CLR-compliant
    languages. This is important because F# code must be able to be debugged from
    other CLR-compliant languages as well.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试符号（PDB）具有与其他 CLR 兼容语言相同的格式和语义。这很重要，因为 F# 代码必须能够从其他 CLR 兼容语言中进行调试。
- en: 'From the managed languages perspective, measuring the performance of F# is
    similar when measured by tools such as the CLR profiler. But from an F# unique
    perspective, the following are the unique characteristics of F#:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从托管语言的角度来看，使用 CLR 分析器等工具测量 F# 的性能与测量其他语言相似。但从 F# 的独特视角来看，以下是一些 F# 的独特特性：
- en: By default, all types in F# are immutable. Therefore, it's safe to assume it
    is intrinsically thread safe.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，F# 中的所有类型都是不可变的。因此，可以安全地假设它是固有的线程安全的。
- en: F# has a distinctive collection library, and it is immutable by default. It
    is also safe to assume it is intrinsically thread safe.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 具有独特的集合库，默认情况下是不可变的。也可以安全地假设它是固有的线程安全的。
- en: F# has a strong type inference model, and when a generic type is inferred without
    any concrete type, it automatically performs generalizations.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 具有强大的类型推断模型，当没有具体类型进行推断时，它会自动进行泛化。
- en: Default functions in F# are implemented internally by creating an internal class
    derived from F#'s `FSharpFunc`. This `FSharpFunc` is essentially a delegate that
    is used by F# to apply functional language constructs such as currying and partial
    application.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 中的默认函数通过创建一个从 F# 的 `FSharpFunc` 派生的内部类来内部实现。这个 `FSharpFunc` 实质上是一个委托，F# 使用它来应用诸如柯里化和部分应用之类的函数式语言结构。
- en: With **tail call recursive optimization** in the IL, the F# compiler may emit
    `.tail` IL, and then the CLR will recognize this and perform optimization at runtime.
    More on this in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IL 中使用**尾调用递归优化**时，F# 编译器可能会生成 `.tail` IL，然后 CLR 会识别这一点并在运行时进行优化。更多内容请参阅[第
    7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化")，*语言特性和结构优化*。
- en: F# has inline functions as options. More on this in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1
    "Chapter 7. Language Features and Constructs Optimization"), *Language Features
    and Constructs Optimization.*
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 有内联函数作为选项。更多内容请参阅[第 7 章](fsp-hiperf_cu07.html#aid-1ENBI1 "第 7 章。语言特性和结构优化")，*语言特性和结构优化*。
- en: F# has a computation workflow that is used to compose functions. This will be
    described in more detail in [Chapter 8](fsp-hiperf_cu08.html#aid-1JFUC2 "Chapter 8. Optimizing
    Computation Expressions"), *Optimizing Computation Expressions.*
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 有一种用于组合函数的计算工作流程。这将在[第 8 章](fsp-hiperf_cu08.html#aid-1JFUC2 "第 8 章。优化计算表达式")中更详细地描述，*优化计算表达式*。
- en: F# async computation doesn't need `Task<T>` to implement it.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 的异步计算不需要 `Task<T>` 来实现。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although F# async doesn't need the `Task<T>` object, it can operate well with
    the async-await model in C# and VB. The async-await model in C# and VB is inspired
    by F# async, but behaves semantically differently based on more things than just
    the usage of `Task<T>`. More on this in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 F# 的异步操作不需要 `Task<T>` 对象，但它可以很好地与 C# 和 VB 中的 async-await 模型一起工作。C# 和 VB 中的
    async-await 模型受到了 F# 异步操作的影响，但其语义行为在更多方面与 `Task<T>` 的使用不同。更多内容请参阅[第 4 章](fsp-hiperf_cu04.html#aid-11C3M2
    "第 4 章。F# 并发介绍")，*F# 并发介绍*。
- en: All of those characteristics are not only unique, but they can also have performance
    implications when used to interoperate with C# and VB.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性不仅独特，而且当用于与 C# 和 VB 交互时，也可能有性能影响。
- en: Relation between F# code and its generated assembly
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F# 代码与其生成的程序集之间的关系
- en: The F# assembly (commonly known as DLL or executable EXE in .NET running on
    Windows) is the same as the C#/VB assembly upon compilation. The end product of
    the compiler is a .NET assembly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: F# 程序集（通常在 Windows 上运行的 .NET 中的 DLL 或可执行 EXE）在编译后与 C#/VB 程序集相同。编译器的最终产品是一个 .NET
    程序集。
- en: An assembly may contain multiple namespaces, and each namespace may contain
    multiple files of modules, classes, or a mix of both.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序集可以包含多个命名空间，每个命名空间可以包含多个模块、类或两者的混合文件。
- en: 'The following table describes the F# relation of code and compiled code (assembly):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了 F# 代码与编译后的代码（程序集）之间的关系：
- en: '| **F# code** | **Description** | **Compiled code** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **F# 代码** | **描述** | **编译后的代码** |'
- en: '| Project | An organization of an F# project. It may contain F# script (FSX)
    and F# source files (FS).In the conceptual layout, a project may contain multiple
    namespaces that spawn across multiple files of FSX and F# script. | An assembly
    of either executable EXE or DLL class library |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 项目 | F# 项目的组织。它可能包含 F# 脚本（FSX）和 F# 源文件（FS）。在概念布局中，一个项目可能包含多个命名空间，这些命名空间跨越多个
    FSX 和 F# 脚本文件。 | 可执行 EXE 或 DLL 类库的程序集 |'
- en: '| Namespace | A logical organization of modules and classes to help organizing
    within an organization, company, or functionality.For example: the `System.Web`
    namespace that contains many classes related to enable browser/server communication,
    including HTTP and HTTPS. | A namespace may spawn across different assemblies
    instead of a namespace for only one assembly |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 模块和类的逻辑组织，有助于在组织、公司或功能内部进行组织。例如：包含许多与浏览器/服务器通信相关的类的 `System.Web` 命名空间，包括
    HTTP 和 HTTPS。 | 命名空间可能跨越不同的程序集，而不仅仅是单个程序集的命名空间 |'
- en: '| Module | A module in F# is equal to a C# static class or module in VB. An
    F# FS file may contain multiple modules, although it is not recommended to have
    this practice. | Part of a generated assembly |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | F# 中的模块等同于 C# 中的静态类或模块，或 VB 中的模块。一个 F# FS 文件可以包含多个模块，尽管不建议这样做。 | 生成程序集的一部分
    |'
- en: '| Classes and interfaces | A file can contain multiple classes and interfaces
    under different namespaces. It is recommended to have not more than one namespace
    for each file as this also minimizes compilation time when it tries to resolve
    references. | Part of a generated assembly |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 类和接口 | 一个文件可以在不同的命名空间下包含多个类和接口。建议每个文件不要超过一个命名空间，因为这也有助于减少编译时间，当它尝试解析引用时。|
    生成程序集的一部分 |'
- en: Immutability versus mutability
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变性与可变性的比较
- en: F# implementation of types and collection types are immutable. Immutable in
    this sense means it is read-only, and we can only initialize the object with an
    initial value and we can't change it afterwards.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的类型和集合类型实现是不可变的。在这个意义上，不可变意味着它是只读的，我们只能用初始值初始化对象，之后不能更改它。
- en: Mutability means once we initialize an object, it can be changed afterwards.
    This is why it is sometimes called a *mutating object value* instead of a changing
    object value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可变性意味着一旦我们初始化了一个对象，之后就可以对其进行更改。这就是为什么有时人们称其为 *可变对象值* 而不是 *变化对象值* 的原因。
- en: 'For example consider the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, `anynumber` is immutable and the value of it will always be `0`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`anynumber` 是不可变的，其值始终为 `0`。
- en: 'To mark a variable as mutable, F# has the `mutable` keyword and we can use
    `mutable` in the `let` declaration, as in this example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要将变量标记为可变，F# 有 `mutable` 关键字，我们可以在 `let` 声明中使用 `mutable`，如下例所示：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, changing the value requires the use of the `<-` symbol in F#, for
    example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更改值需要使用 F# 中的 `<-` 符号，例如：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since the nature of F# is functional, a symbol can be both a data and a function.
    The content of the symbol is read-only, so does a function in it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 F# 的本质是函数式的，一个符号可以既是数据又是函数。符号的内容是只读的，其中的函数也是如此。
- en: 'Immutability also has another advantage: it scales well across multiple threads
    or even in parallel, no matter whether it''s a value or a function. The immutability
    guarantee means that it is free of side effects. It is then safe to spawn multiple
    symbols in parallel because the result of an execution will be guaranteed to have
    the same result. This is also simply called **thread safe**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性还有一个优点：它可以在多个线程或甚至并行的情况下很好地扩展，无论是值还是函数。不可变性的保证意味着它是无副作用的。因此，可以并行生成多个符号，因为执行的结果将保证具有相同的结果。这通常被称为
    **线程安全**。
- en: The fact that F# has a mixed support for functional and OOP at the same time
    (including having support for the inherent mutable state of OOP) may lead to bottlenecks
    as described next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，F# 同时支持函数式和面向对象编程（包括对面向对象固有可变状态的支持），这可能导致以下所述的瓶颈。
- en: Overview of common bottlenecks
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见瓶颈概述
- en: F# has common bottlenecks although they might be subtle as well.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: F# 虽然可能存在一些微妙的问题，但仍然有常见的瓶颈。
- en: In order to be able to quickly understand the bottleneck factors in F#, we will
    categorize the shared general bottlenecks of .NET as managed bottlenecks (also
    in C#/VB), and F#-only bottlenecks (this includes when using F# with other languages).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够快速理解 F# 中的瓶颈因素，我们将把 .NET 的共享通用瓶颈分为托管瓶颈（也存在于 C#/VB 中），以及 F# 独有的瓶颈（这包括在使用
    F# 与其他语言一起使用时）。
- en: 'The following are managed .NET bottlenecks (from obvious to less obvious):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从明显到不那么明显的托管 .NET 瓶颈：
- en: String concatenations, such as using string `String.Concat` instead of `StringBuilder`.
    This is often overlooked because of a lack of awareness of the string's immutability.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接，例如使用 `String.Concat` 而不是 `StringBuilder`。这通常被忽视，因为缺乏对字符串不可变性的认识。
- en: Usage of non-generic collections such as `ArrayList`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非泛型集合，例如 `ArrayList`。
- en: Incorrectly handling side effects, such as exceptions and I/O.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理副作用，例如异常和 I/O。
- en: Mutable objects usage, including casting.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变对象的使用，包括类型转换。
- en: 'Complex objects that will be serialized and deserialized, for example: sending
    `DataSet` that has `DataTables` over HTTP.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要序列化和反序列化的复杂对象，例如：通过 HTTP 发送包含 `DataTables` 的 `DataSet`。
- en: Ignoring performance profiling.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略性能分析。
- en: 'Side effects mean all of the elements outside the formal computation (it is
    often called the *outside world*) that we interact with, and this includes the
    changing global state. The outside world can be all of the things that we cannot
    fully determine as the end result. Examples of the outside world include:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用意味着所有我们与之交互的正式计算之外（通常称为 *外部世界*）的元素，这包括改变全局状态。外部世界可以是我们无法完全确定作为最终结果的全部事物。外部世界的例子包括：
- en: 'I/O: This is included as being part of the outside world because you cannot
    determine or guarantee any kind of work you pass to I/O to be successfully completed.
    For example, when sending a command to a printer to print a document, we cannot
    guarantee 100% success of the printing operation. We cannot even guarantee that
    the process of sending the data to the printer will be successful or not before
    the printer receives the data and begins to print the document.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O：这被包括在内，因为它被视为外部世界的一部分，因为你无法确定或保证你传递给I/O的任何工作都能成功完成。例如，当向打印机发送命令以打印文档时，我们无法保证打印操作100%成功。甚至在打印机接收到数据并开始打印文档之前，我们甚至无法保证将数据发送到打印机的过程是成功还是失败。
- en: 'Global static mutable variables: A quick example of this is when we define
    a `public static` variable in the scope of ASP.NET. Every value change will always
    change the condition of any user of the ASP.NET application.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局静态可变变量：一个快速示例是当我们定义一个`public static`变量在ASP.NET的作用域内。任何值的变化都将始终改变ASP.NET应用程序任何用户的条件。
- en: Functions or properties that always have different results when they are invoked,
    such as `DateTime.Now`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当被调用时总是返回不同结果的功能或属性，例如`DateTime.Now`。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`DateTime.Now` will always return different results and this is as expected
    because the result *must* change every time it is called or instantiated. It is
    not free of side effects, but it is still expected to always return a different
    result.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime.Now`将始终返回不同的结果，这是预期的，因为每次调用或实例化时结果*必须*改变。它不是没有副作用的，但它仍然预期总是返回不同的结果。'
- en: Side effects are not just for functional programming developers, as many of
    us are now becoming quite aware. There are no absolute side effect-free computations
    because we should learn and be able to correctly handle them. For example, even
    printing a screen to a console is also a side effect because it involves I/O,
    and it changes the state of the outside world.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用不仅仅是面向函数式编程的开发者需要考虑的，因为现在我们中的许多人已经越来越意识到这一点。没有绝对的无副作用计算，因为我们应该学习和能够正确地处理它们。例如，甚至将屏幕打印到控制台也是一种副作用，因为它涉及到I/O操作，并且会改变外部世界的状态。
- en: 'The following are F#''s unique bottlenecks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是F#的独特瓶颈：
- en: Incorrect use of data structures and collections
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构和集合使用不当
- en: Incorrect use of auto generalization and other language constructs
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确地使用自动泛化和其他语言结构
- en: Incorrectly implemented concurrency problems, such as mixing synchronous and
    asynchronous although the original intention is asynchronous
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现并发问题时出现的不正确，例如虽然原始意图是异步，却混合了同步和异步
- en: Slow performance when having to interoperate with other languages' class libraries
    such as C#/VB
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要与其他语言的类库（如C#/VB）交互时，性能可能会变慢
- en: Scaling `MailboxProcessor` in F#
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在F#中扩展`MailboxProcessor`
- en: Identifying when **tail call optimization** should occur
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定何时应该进行**尾调用优化**
- en: Slow response when resolving type in type provider implementation
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型提供者实现中解析类型时的响应缓慢
- en: Slow performance when implementing computation workflow
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现计算工作流时的性能缓慢
- en: Common samples of misunderstood concurrent problems
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的被误解的并发问题示例
- en: Many of us, when dealing with concurrent problems, sometimes try to use a hammer
    for every nail. There is no silver bullet for all of the problems of implementing
    concurrency.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人，在处理并发问题时，有时会试图用锤子敲打每一个钉子。对于实现并发的所有问题，并没有一劳永逸的解决方案。
- en: It is also recommended to understand concurrency, as concurrency is now becoming
    more relevant because of the many core models in the releases of modern microprocessors
    (or simply processors) in the last 7 years. This fact is also becoming a trend
    as the clock speed of the latest processors has been usually limited to 3.2 GHz
    for the last 3 years.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也建议了解并发，因为随着过去7年中现代微处理器（或简称处理器）发布的许多核心模型，并发现在变得更加相关。这一事实也正在成为一种趋势，因为最新处理器的时钟速度在过去3年中通常被限制在3.2
    GHz。
- en: 'Microsoft''s Visual C++ architect, Herb Sutter, has written a very thorough
    article in the form of a whitepaper famously known as *The Free Lunch Is Over*:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的Visual C++架构师Herb Sutter撰写了一篇非常详尽的以白皮书形式著名的文章，名为*The Free Lunch Is Over*：
- en: '[http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.gotw.ca/publications/concurrency-ddj.htm](http://www.gotw.ca/publications/concurrency-ddj.htm)'
- en: Let's understand first what concurrency is and the F# supports.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解什么是并发以及F#支持哪些并发。
- en: Introduction to concurrency in F#
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#并发简介
- en: Before we dive deeper into concurrency in F#, we should understand the definition
    of concurrency.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 F# 中的并发之前，我们应该了解并发的定义。
- en: Concurrency is one of the main disciplines of computer science and it is still
    one of the main problems of computations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是计算机科学的主要学科之一，它仍然是计算的主要问题之一。
- en: Simply defined, concurrency is the composition of the order of independent process
    units or partially-ordered process units that can be executed in parallel or not
    in parallel, but not in sequential order. The term *order* in this context means
    ordered as sequentially.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，并发是指独立进程单元或部分有序进程单元的顺序组合，这些进程单元可以并行或非并行执行，但不是按顺序执行。这里的 *顺序* 指的是按顺序排列。
- en: 'The following diagram illustrates the concept of sequential (not concurrent)
    in action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了顺序（非并发）的概念在实际中的应用：
- en: '![Introduction to concurrency in F#](img/image00239.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![F# 并发简介](img/image00239.jpeg)'
- en: '**Process 1** to **Process 4** as shown in the preceding diagram is executed
    sequentially step by step. **Process 2** must wait for **Process 1** to be completed
    first, as do **Process 3** and **Process 4**.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**进程1** 到 **进程4** 是按顺序一步一步执行的。**进程2** 必须等待 **进程1** 完成后才能开始，**进程3** 和 **进程4**
    也是如此。
- en: This sequence is also called a synchronous process or is simply referred to
    as being synchronous.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序也被称为同步进程，或者简单地称为同步。
- en: 'The following figure is a sample illustration of a parallel concurrency combination
    of parallel and synchronous processes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是一个并行并发组合（并行和同步进程）的示例说明：
- en: '![Introduction to concurrency in F#](img/image00240.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![F# 并发简介](img/image00240.jpeg)'
- en: '**Processes ** **1A**, **2A**, and **3A** run in parallel, although each parallel
    lane has its own sequence of processes that are run sequentially.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程** **1A**、**2A** 和 **3A** 并行运行，尽管每个并行通道都有其自己的进程顺序，这些进程是顺序运行的。'
- en: The term parallel means that it is not just executing simultaneously in parallel,
    but parallel also means that it may run on many processors or on many cores, as
    is common in modern processors that have multiple cores.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 平行这个词意味着它不仅是在并行中同时执行，而且平行还意味着它可能运行在多个处理器或多个核心上，这在具有多个核心的现代处理器中很常见。
- en: Defining asynchronous
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步的定义
- en: A simple definition of asynchronous means *not synchronous*. This means that
    if we have an asynchronous flow, the process is not run synchronously.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的简单定义就是 *非同步*。这意味着如果我们有一个异步流程，进程不是同步运行的。
- en: 'These are the implications of an asynchronous flow:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是异步流程的启示：
- en: Processes run not sequentially. For example, if the first process is running
    asynchronously, the next process doesn't have to wait for the first process to
    be completed.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程不是按顺序运行的。例如，如果第一个进程是异步运行的，下一个进程不必等待第一个进程完成。
- en: There has to be a way of scheduling and telling the scheduler to inform that
    the asynchronous process is completed. Typically, the asynchronous process is
    usually related to blocking I/O or some long computations.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须有一种方式来调度并告诉调度器异步进程已完成。通常，异步进程通常与阻塞 I/O 或某些长时间计算有关。
- en: At first, the processes may look sequential, but the next process run may not
    be sequential at all.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起初，进程可能看起来是顺序的，但下一个运行的进程可能根本不是顺序的。
- en: 'This is a sample case of asynchronous: a customer is going to have dinner in
    a restaurant. The flows are:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个异步的示例案例：一位顾客将在餐厅用餐。流程如下：
- en: '*Customer A* orders some food or drinks, and the order is noted by *waiter
    X*. Usually, most restaurants have more than one waiter, but for this illustration,
    the waiter available currently to serve *customer A* is *waiter X*.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*顾客A* 订购了一些食物或饮料，订单由 *服务员X* 记录。通常，大多数餐厅都有不止一个服务员，但为了说明，目前为 *顾客A* 提供服务的服务员是
    *服务员X*。'
- en: '*Waiter X* then gives the list of the customer''s order to *chef Y*.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后 *服务员X* 将顾客的订单列表交给 *厨师Y*。
- en: '*Chef Y* accepts the order, and checks if he is currently occupied or not.
    If he is occupied, the order is registered as part of his cooking queue. Otherwise,
    he will start to cook the order.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*厨师Y* 接受订单，并检查他是否正在忙碌。如果他正在忙碌，订单将被注册为他的烹饪队列的一部分。否则，他将开始烹饪订单。'
- en: The waiter does not have to wait for the chef to complete his cooking. He can
    then serve other customers who have just arrived or there might be customers that
    want to add more food or drinks as well.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务员不必等待厨师完成烹饪。他可以随后为刚刚到达的其他顾客提供服务，或者可能还有顾客想要添加更多食物或饮料。
- en: '*Chef Y* finishes his cooking for *customer A*, and then gives a notification
    to *waiter X* to inform that his cooking for *customer A* is finished. Or he can
    inform all waiters to tell that the cooking for *customer A* is finished. This
    concept of informing to tell a process is finished is commonly called a callback.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*厨师Y*完成了对*顾客A*的烹饪，然后通知*服务员X*，告知他的*顾客A*的烹饪已完成。或者他可以通知所有服务员，告知*顾客A*的烹饪已完成。这种通知告知过程已完成的概念通常称为回调。'
- en: '*Waiter X* (or any other waiter) delivers the finished food to *customer A*.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*服务员X*（或任何其他服务员）将完成的食品递送给*顾客A*。'
- en: The asynchronous model that uses a notification to inform that a process is
    completed is called **asynchronous callback**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通知来通知过程完成的异步模型称为**异步回调**。
- en: The result returned at the end of the execution later (or in the future) is
    called a **Future**. It is also the future, in a sense, when many processes are
    executed in parallel, having results later.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行结束时（或未来）返回的结果称为**Future**。在许多过程并行执行并具有后续结果的情况下，它也是未来。
- en: 'This is the official documentation of Future in MSDN Library:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MSDN库中Future的官方文档：
- en: '[https://msdn.microsoft.com/en-us/library/ff963556.aspx](https://msdn.microsoft.com/en-us/library/ff963556.aspx)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ff963556.aspx](https://msdn.microsoft.com/en-us/library/ff963556.aspx)'
- en: For I/O operations, such as printing a document, we cannot determine whether
    the printing is successful or not, so the notification of the end process is not
    available. We can implement an asynchronous operation on I/O, and the fact that
    there is no observable notification of this is why this asynchronous model is
    called the asynchronous *fire and forget* model.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于I/O操作，例如打印文档，我们无法确定打印是否成功，因此没有结束过程的通告。我们可以在I/O上实现异步操作，而这一事实没有可观察到的通告，这就是为什么这种异步模型被称为异步*火和忘*模型。
- en: Misunderstood concurrency problems
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 被误解的并发问题
- en: Many developers, even seasoned or experienced developers, still think that concurrency
    and parallel programming are different. Actually, parallel programming is just
    one member within the concurrency discipline, together with the differentiation
    of asynchronous and synchronous processing models.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者，即使是经验丰富的开发者，仍然认为并发和并行编程是不同的。实际上，并行编程只是并发学科中的一个成员，与异步和同步处理模型的区分一起。
- en: This is also one of the most misunderstood concurrency concepts or problems,
    and there are many more regarding how we approach concurrency.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是被误解最多的并发概念或问题之一，关于我们如何处理并发的问题还有很多。
- en: 'These are some common organized sample cases of misunderstood concurrency problems:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些常见的误解并发问题的组织样本案例：
- en: Assuming all concurrent problems can be solved using parallel programming.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设所有并发问题都可以通过并行编程来解决。
- en: 'Fact: Not all concurrent problems are easily solved with parallelism.'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实：并非所有并发问题都可以通过并行性轻松解决。
- en: Assuming all implementation of asynchronous is asynchronous.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设所有异步实现都是异步的。
- en: 'Fact: This depends on how we implement async; sometimes the execution of an
    async construct is executed synchronously.'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实：这取决于我们如何实现异步；有时异步结构的执行是同步执行的。
- en: Ignoring blocking threads such as I/O.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略阻塞线程，如I/O。
- en: 'Fact: Blocking I/O threads should be handled asynchronously; otherwise, the
    current thread is always waiting indefinitely until the I/O thread is finished.'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实：应该异步处理阻塞I/O线程；否则，当前线程将无限期地等待，直到I/O线程完成。
- en: The synchronized lock is blocking.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步锁是阻塞的。
- en: 'Fact: The lock is not a blocking thread.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实：锁不是阻塞线程。
- en: Relying on the CPU speed.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖于CPU速度。
- en: 'Fact: The CPU speed increase is becoming less of an issue. The research and
    development of modern CPUs is focusing on multiple core CPUs.'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实：CPU速度的提高变得越来越不是问题。现代CPU的研究和开发正集中在多核CPU上。
- en: 'A few sample cases of concurrent problems are mentioned as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面提到了一些并发问题的样本案例：
- en: 'The case samples of the first case are:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一案例的案例样本如下：
- en: '**Ordering or sorting a collection**: Ordering is by default a sequential process,
    and it requires iterating all the elements of the collection. Therefore, it''s
    useless to use parallelism.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对集合进行排序或排序**：排序默认是顺序过程，它需要迭代集合的所有元素。因此，使用并行性是无用的。'
- en: '**Grouping data**: Grouping data is implicitly one of the sequential processes;
    it is also quite useless to use parallelism.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分组**：数据分组隐式地是顺序过程之一；使用并行性也是相当无用的。'
- en: '**Printing reports**: Printing is part of I/O and I/O is intrinsically without
    support for parallelism. Unless the I/O is part of I/O parallelism, it is useless
    to use parallelism in this context.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印报告**：打印是I/O的一部分，而I/O本身不支持并行性。除非I/O是I/O并行的一部分，否则在这个上下文中使用并行性是无效的。'
- en: 'Sample cases of the second case are listed as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况的示例案例如下：
- en: Mixing `Parallel.For` that has F# async in it. The implications of having `Parallel.For`
    is by default taking a multiple core or a CPU to run it is not the same as running
    asynchronously, as it is not guaranteed to run as a combined async in parallel.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合包含F#异步的`Parallel.For`。默认情况下，`Parallel.For`使用多个核心或CPU运行并不意味着它是异步的，因为它不能保证并行运行。
- en: Using `Thread.Sleep` instead of `Async.Sleep` to signify a *wait* operation.
    The call to `Thread.Sleep` will instead make the flow synchronous, as the `Sleep`
    method simply puts on hold the current thread as a *delay* synchronously.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Thread.Sleep`而不是`Async.Sleep`来表示*等待*操作。`Thread.Sleep`的调用将使流程同步，因为`Sleep`方法只是将当前线程同步地挂起作为*延迟*。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: RAID array in the storage I/O is one of the best samples of parallelism in I/O.
    It stores data in parallel across multiple disks. It is faster than common I/O
    because data is stored in parts (not whole data to a disk) to several disks in
    parallel.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 存储I/O中的RAID数组是I/O中并行性的最佳示例之一。它将数据并行存储在多个磁盘上。由于数据是并行存储在多个磁盘的部分（而不是整个数据存储到一个磁盘），因此它比常见的I/O更快。
- en: The third case is related to all of the I/O operations including sending data
    to a printer and saving large data into a disk. These operations are always blocking
    threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况与所有I/O操作相关，包括向打印机发送数据和将大量数据保存到磁盘。这些操作总是阻塞线程。
- en: For the case of `lock`, Microsoft has issued official statements that `lock`
    in .NET used by C# and VB is executed without any interruption, and it only locks
    an object until it has finished executing the block in the synchronized lock.
    It's still allowing other threads to run without waiting for the thread that has
    the lock to finish.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`lock`的情况，微软已经发布了官方声明，指出C#和VB在.NET中使用的`lock`执行时不会受到任何中断，并且它只锁定一个对象，直到它完成同步锁中的代码块执行。它仍然允许其他线程在没有等待持有锁的线程完成的情况下运行。
- en: 'This is the official thread synchronization of C# and VB in MSDN:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MSDN中C#和VB的官方线程同步：
- en: '[https://msdn.microsoft.com/en-us/library/ms173179.aspx](https://msdn.microsoft.com/en-us/library/ms173179.aspx)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/ms173179.aspx](https://msdn.microsoft.com/en-us/library/ms173179.aspx)'
- en: It is recommended to always check online the MSDN Library of the .NET class
    library, as this is always updated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 建议始终在线检查.NET类库的MSDN库，因为这是始终更新的。
- en: Introduction to concurrency support in .NET and F#
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET和F#中并发支持的介绍
- en: Concurrency support in F# is based on the existing work of concurrency support
    features in .NET BCL (the Base Class Library). It's also by design, since F# runs
    on top of .NET CLR and can use .NET BCL. F# also has its unique ways that bring
    more features other than just language features (for example, asynchronous computations).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: F#的并发支持基于.NET BCL（基础类库）中现有的并发支持功能。这也是设计上的考虑，因为F#运行在.NET CLR之上，可以使用.NET BCL。F#还有其独特的特性，除了语言特性之外，还带来了更多功能（例如，异步计算）。
- en: 'The .NET BCL part of concurrency has basic support for the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 并发部分的 BCL 对以下内容提供基本支持：
- en: Thread
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Lock
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁
- en: Mutex
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥锁
- en: 'Beginning with .NET 4.0, we have the **Task Parallel Library** (**TPL**). This
    library makes concurrent support easier. TPL consists of the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从.NET 4.0开始，我们有了**任务并行库**（**TPL**）。这个库使得并发支持变得更加容易。TPL包括以下内容：
- en: 'Data parallelism (for example: `Parallel.For` and `ForEach`)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并行（例如：`Parallel.For`和`ForEach`）
- en: Task parallelism
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务并行
- en: Asynchronous task (this is also the base foundation of C#/VB's async-await)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步任务（这也是C#/VB的async-await的基础）
- en: Parallel LINQ (often abbreviated as PLINQ)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行LINQ（通常缩写为PLINQ）
- en: For a more complete reference of concurrency support in .NET, please visit [https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取.NET中并发支持的更完整参考，请访问 [https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx)。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: .NET has no support yet for fiber API in Win32 API. Microsoft currently has
    no definite plan for fiber support.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: .NET在Win32 API中还没有对纤维API的支持。微软目前没有明确的纤维支持计划。
- en: 'F# has its own unique features of concurrency supports. They are:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: F#具有其独特的并发支持特性。它们是：
- en: Asynchronous workflow or computation
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步工作流或计算
- en: MailboxProcessor
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MailboxProcessor
- en: Parallel async
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行异步
- en: Parallel async combined with I/O
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行异步结合 I/O
- en: More on concurrency support in F# is available in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#* and [Chapter 5](fsp-hiperf_cu05.html#aid-164MG2 "Chapter 5. Advanced Concurrency
    Support in F#"), *Advanced Concurrency Support in F#*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: F# 中关于并发支持的更多信息可在 [第 4 章](fsp-hiperf_cu04.html#aid-11C3M2 "第 4 章。F# 并发简介")，*F#
    并发简介*和 [第 5 章](fsp-hiperf_cu05.html#aid-164MG2 "第 5 章。F# 高级并发支持")，*F# 高级并发支持*中找到。
- en: Now it's time to dive more into some codes. To start writing F# code, we can
    use F# and Visual Studio combined. This includes IDE supports for F#.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是深入一些代码的时候了。要开始编写 F# 代码，我们可以使用 F# 和 Visual Studio 的组合。这包括 F# 的 IDE 支持。
- en: Overview of F# tooling in Visual Studio
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 中 F# 工具的概述
- en: F# has been supported in Visual Studio since Visual Studio 2010, and in Visual
    Studio 2015 the support has improved with better syntax colorizations than Visual
    Studio 2010, not just IDE. This F# IDE support is officially called *Visual F#.*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: F# 自 Visual Studio 2010 起得到支持，在 Visual Studio 2015 中，支持得到了改善，语法着色比 Visual Studio
    2010 更好，不仅限于 IDE。这种 F# IDE 支持官方称为 *Visual F#*。
- en: This tooling is available as open source from Microsoft and it is available
    to be downloaded from GitHub at [https://github.com/Microsoft/visualfsharp/](https://github.com/Microsoft/visualfsharp/).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具作为开源项目由 Microsoft 提供，可以从 GitHub 下载：[https://github.com/Microsoft/visualfsharp/](https://github.com/Microsoft/visualfsharp/)。
- en: And the F# compiler itself is open source and it is also available from GitHub
    (including the design proposal discussions) at [https://github.com/fsharp](https://github.com/fsharp).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器本身也是开源的，并且可以从 GitHub 获取（包括设计提案讨论）：[https://github.com/fsharp](https://github.com/fsharp)。
- en: The tooling is under the governance of Microsoft, but it is welcoming community
    contributions as it is available on GitHub. All of the community participations
    of tooling, compilers and the language specifications are under the governance
    of the F# Software Foundation (FSSF).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 工具在 Microsoft 的治理下，但欢迎社区贡献，因为它可在 GitHub 上找到。所有工具、编译器和语言规范的社区参与都在 F# 软件基金会（FSSF）的治理之下。
- en: We can also support FSSF directly. For more information about FSSF, please visit
    [http://fsharp.org/](http://fsharp.org/).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接支持 FSSF。有关 FSSF 的更多信息，请访问 [http://fsharp.org/](http://fsharp.org/)。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The F# community projects are also managed by FSSF, and it is welcoming contributions
    as well. FSSF is an independent entity and it is not tied to Microsoft.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: F# 社区项目也由 FSSF 管理，并欢迎贡献。FSSF 是一个独立实体，与 Microsoft 无关。
- en: 'Visual F# in Visual Studio 2015 has mainly the following capabilities:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 中的 Visual F# 主要有以下功能：
- en: Project template support, including the NuGet package addition and references
    to other projects in the same solution file. The other projects can be VB or C#
    projects, not just F#.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板支持，包括 NuGet 包的添加和同一解决方案文件中其他项目的引用。其他项目可以是 VB 或 C# 项目，而不仅仅是 F#。
- en: '`AssemblyInfo` support in a separate file. This feature has been available
    since Visual Studio 2015\. Previously it was only available in C# and VB projects.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在单独的文件中支持 `AssemblyInfo`。此功能自 Visual Studio 2015 起可用。之前它仅在 C# 和 VB 项目中可用。
- en: The F# compiler, FSC, is used to compile F# into .NET executable and libraries
    in the form of DLL.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 编译器，FSC，用于将 F# 编译成 .NET 可执行文件和以 DLL 形式的库。
- en: Integration of the F# compiler, MSBuild infrastructure, and also Intellisense.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 编译器、MSBuild 基础设施和 Intellisense 的集成。
- en: F# libraries, a foundation to the functional programming constructs of F# and
    F# unique concurrency features such as asynchronous workflow and `MailboxProcessor`.
    It also contains many useful functions to further interoperate with C#/VB, including
    interoperating with .NET delegates.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 库，是 F# 函数式编程结构的基础，以及 F# 独特的并发特性，如异步工作流和 `MailboxProcessor`。它还包含许多有用的函数，以进一步与
    C#/VB 交互，包括与 .NET 代理的交互。
- en: Interactive support for the F# interactive (FSI) prompt in the IDE.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 IDE 中对 F# 交互式（FSI）提示符的交互式支持。
- en: 'For more information about F# tooling, this is the official MSDN Library link:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 F# 工具的更多信息，这是官方 MSDN 图书馆的链接：
- en: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp](https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp](https://msdn.microsoft.com/visualfsharpdocs/conceptual/visual-fsharp)'
- en: It is recommended to always consult the Visual F# documentation on GitHub first,
    then combine it with the online MSDN Library section of F#.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 建议首先查阅 GitHub 上的 Visual F# 文档，然后结合在线 MSDN 图书馆的 F# 部分。
- en: Microsoft has planned to rebuild all of the online MSDN Library to use the GitHub
    participation model, so developers can submit a pull request to modify or to amend
    any documentation page. Visual F# is now being reworked on as well, but there
    are some pages still left behind inside Visual F# GitHub repo.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 微软计划重建所有在线 MSDN 图书馆以使用 GitHub 参与模式，因此开发者可以向修改或修正任何文档页面提交拉取请求。Visual F# 也正在重新设计，但还有一些页面仍然留在
    Visual F# GitHub 仓库中。
- en: To always check the latest development of F# documentation on GitHub, visit
    [https://github.com/Microsoft/visualfsharpdocs](https://github.com/Microsoft/visualfsharpdocs).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要始终检查 GitHub 上 F# 文档的最新开发情况，请访问 [https://github.com/Microsoft/visualfsharpdocs](https://github.com/Microsoft/visualfsharpdocs)。
- en: Interactive support for F# interactive
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 F# 交互式支持
- en: F# interactive is a tool to interpret your F# code and run it immediately. It
    will also process and show the results, the types, and the syntax errors. The
    code can be run in the interactive prompt or taken from the source code and then
    run into F# interactive.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: F# 交互式是一个解释你的 F# 代码并立即运行的工具。它还会处理并显示结果、类型和语法错误。代码可以在交互式提示符中运行，或者从源代码中取出然后运行到
    F# 交互式中。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of having interpreted code, executing it, and seeing the results
    is called REPL. **REPL** is abbreviated from **Read-Eval-Print-Loop**, and it
    was first available as the system's command-line prompt. There is nothing new
    about this REPL concept, as other programming languages such as Python already
    have had REPL before F#.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 解释代码、执行它并查看结果的概念称为 REPL。**REPL** 是 **Read-Eval-Print-Loop** 的缩写，它最初作为系统的命令行提示符提供。这个
    REPL 概念并没有什么新意，因为像 Python 这样的其他编程语言在 F# 之前已经有了 REPL。
- en: Compared to C# and VB, F# interactive is the first to have interactive REPL
    support since Visual Studio 2010\. Unfortunately, there is no Visual Studio's
    Intellisense support for F# interactive yet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C# 和 VB 相比，F# 交互式是第一个自 Visual Studio 2010 起拥有交互式 REPL 支持的。不幸的是，F# 交互式还没有 Visual
    Studio 的 Intellisense 支持。
- en: 'There are two ways to use F# interactive:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 F# 交互式有两种方式：
- en: In Visual Studio IDE
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio IDE 中
- en: In Command Prompt
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令提示符中
- en: The most common usage of F# interactive is within Visual Studio IDE.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: F# 交互式在 Visual Studio IDE 中的最常见用法。
- en: We have to set up the **F# Interactive** window to be displayed in order to
    use F# interactive.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须设置 **F# 交互式** 窗口以便显示，才能使用 F# 交互式。
- en: 'These are the steps to display the **F# Interactive** window:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 **F# 交互式** 窗口的步骤如下：
- en: Open the **View** menu from the Visual Studio main menu.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Visual Studio 主菜单中打开 **视图** 菜单。
- en: Choose **Other Windows..** and then choose **F# Interactive**.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **其他窗口..** 然后选择 **F# 交互式**。
- en: 'A window that hosts the **F# Interactive** within Visual Studio will appear
    and it will be ready to interpret our F# code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将在 Visual Studio 中显示 **F# 交互式** 的窗口，并准备好解释我们的 F# 代码：
- en: '![Interactive support for F# interactive](img/image00241.jpeg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![F# 交互式支持](img/image00241.jpeg)'
- en: 'As a starter, type `#help` followed by `;;` to mark as closing statements to
    be evaluated. We now see some further options:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 作为入门，输入 `#help` 后跟 `;;` 作为要评估的结束语句。我们现在可以看到一些其他选项：
- en: '![Interactive support for F# interactive](img/image00242.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![F# 交互式支持](img/image00242.jpeg)'
- en: F# interactive can be used to not only interpret and run F# code but also as
    a way to see immediate results of a calculation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: F# 交互式不仅可以解释和运行 F# 代码，还可以作为一种查看计算即时结果的方式。
- en: Type `5 * 25;;` and press *Enter*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `5 * 25;;` 并按 *Enter*。
- en: 'We now see the result of that calculation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到该计算的结果：
- en: '![Interactive support for F# interactive](img/image00243.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![F# 交互式支持](img/image00243.jpeg)'
- en: We can also execute codes in the Visual Studio editor when we are opening F#
    source code file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打开 F# 源代码文件时，我们也可以在 Visual Studio 编辑器中执行代码。
- en: 'For example, create a new project using the F# tutorial project template:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 F# 教程项目模板创建一个新的项目：
- en: '![Interactive support for F# interactive](img/image00244.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![F# 交互式支持](img/image00244.jpeg)'
- en: You may find that your display of Visual Studio is different from the previous
    screenshot. Actually, the aforementioned display depends on what Visual Studio
    edition we have. For Visual Studio Enterprise, more templates are available for
    us to use, such as the **Modeling Projects** to create UML.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现你的 Visual Studio 显示与之前的截图不同。实际上，上述显示取决于我们拥有的 Visual Studio 版本。对于 Visual
    Studio Enterprise，我们有更多模板可供使用，例如创建 UML 的 **模型项目**。
- en: For the purpose of F#, the project templates of the F# projects are the same
    for the Community Edition and above.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了 F# 的目的，F# 项目的项目模板对于社区版及以上版本是相同的。
- en: After creating the project, an F# project contains `Tutorial.fsx`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，F# 项目包含 `Tutorial.fsx`。
- en: 'Before we use F# interactive, we should turn on the option for displaying line
    numbers. It is also recommended to have this option always turned on, as it will
    provide easier navigation to the code we write:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 F# 交互式之前，我们应该打开显示行号的选项。也建议始终打开此选项，因为它将提供更容易导航到我们编写的代码：
- en: Go to the **Tools** menu and choose **Options**. It is available in F# options
    in the **Options** dialog:![Interactive support for F# interactive](img/image00245.jpeg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 **工具** 菜单并选择 **选项**。它可在 **选项** 对话框中的 F# 选项中找到：![F#交互式支持](img/image00245.jpeg)
- en: Now double-click `Tutorial.fsx`, and highlight lines **44** to **61**:![Interactive
    support for F# interactive](img/image00246.jpeg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在双击 `Tutorial.fsx`，并突出显示第 **44** 到 **61** 行：![F#交互式支持](img/image00246.jpeg)
- en: Then press *Alt* + *Enter*. F# interprets the code. We can see the result of
    the interpretation in **F# Interactive**:![Interactive support for F# interactive](img/image00247.jpeg)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按 *Alt* + *Enter*。F# 解释代码。我们可以在 **F# 交互式**中看到解释的结果：![F#交互式支持](img/image00247.jpeg)
- en: We have tried F# interactive from within the Visual Studio IDE. Let's use F#
    interactive from Command Prompt.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尝试了在 Visual Studio IDE 中使用 F# 交互式。现在让我们从命令提示符使用 F# 交互式。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also use *Ctrl* + *Alt* + *F* to activate or open **F# Interactive**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 *Ctrl* + *Alt* + *F* 来激活或打开 **F# 交互式**。
- en: To use F# interactive from Command Prompt, we call the executable FSI directly
    from Command Prompt.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令提示符使用 F# 交互式，我们直接从命令提示符调用可执行文件 FSI。
- en: The best way to run FSI is from Visual Studio's developer Command Prompt. This
    developer Command Prompt is available under the `Visual Studio 2015` folder on
    the start menu of the Windows desktop menu bar.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 FSI 的最佳方式是从 Visual Studio 的开发者命令提示符。此开发者命令提示符位于 Windows 桌面菜单栏的“开始”菜单中的 `Visual
    Studio 2015` 文件夹下。
- en: 'Select it, and now we have the **Developer Command Prompt for VS2015**:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 选择它，现在我们有 **VS2015 开发者命令提示符**：
- en: '![Interactive support for F# interactive](img/image00248.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![F#交互式支持](img/image00248.jpeg)'
- en: Type `FSI` and press *Enter*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `FSI` 并按 *Enter* 键。
- en: 'We can try to write some code to evaluate, such as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试编写一些代码来评估，例如：
- en: '[PRE3]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Press *Enter*. The immediate result will be displayed:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Enter*。立即结果将显示：
- en: '![Interactive support for F# interactive](img/image00249.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![F#交互式支持](img/image00249.jpeg)'
- en: To quit the FSI, type `#quit;;` and press *Enter*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 FSI，输入 `#quit;;` 并按 *Enter* 键。
- en: Using F# interactive from Command Prompt is faster but it is also not quite
    so user-friendly because we cannot evaluate multiple lines of code easily. It
    is easier to evaluate this in Visual Studio IDE.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令提示符使用 F# 交互式更快捷，但也不太用户友好，因为我们不能轻松地评估多行代码。在 Visual Studio IDE 中评估它更容易。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For simplicity and ease of use, the rest of this book will always use FSI within
    the Visual Studio IDE.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和易用，本书的其余部分将始终在 Visual Studio IDE 中使用 FSI。
- en: For more information about F# FSI, consult the FSI reference from the MSDN Library
    at  [https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference](https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 F# FSI 的更多信息，请参阅 MSDN 库中的 FSI 参考 [https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference](https://msdn.microsoft.com/visualfsharpdocs/conceptual/fsharp-interactive-%5bfsi.exe%5d-reference)。
- en: FSI is also configurable. We can configure FSI further by leveraging the FSI
    class library in the `Microsoft.FSharp.Compiler.Interactive` namespace. More information
    on this library is also available at the F# FSI URL mentioned previously.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: FSI 也可以进行配置。我们可以通过利用 `Microsoft.FSharp.Compiler.Interactive` 命名空间中的 FSI 类库来进一步配置
    FSI。有关此库的更多信息，也可以在之前提到的 F# FSI 网址找到。
- en: Introduction to debugging in F#
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: F# 调试简介
- en: 'There is one aspect of understanding running F# code that is crucial: debugging
    F# code. We have to be able to debug F# code, especially when we have very large
    projects that have hundreds of F# code files, not to mention when each of the
    code files may have too many lines of code. For example, having to check a running
    F# code that has more than 2,000 lines.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 理解运行中的 F# 代码的一个关键方面是调试 F# 代码。我们必须能够调试 F# 代码，尤其是当我们有包含数百个 F# 代码文件的大型项目时，更不用说每个代码文件可能包含太多的代码行。例如，需要检查超过
    2,000 行的运行中的 F# 代码。
- en: 'The following are the advantages of the debug features:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些调试功能的优点：
- en: Isolating the error and focusing on it by inserting a breakpoint can ease the
    fixing of an error or bug. Developers are gaining more productivity because they
    can fix errors/bugs faster.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插入断点来隔离错误并集中关注它，可以简化错误或错误的修复。开发者因为可以更快地修复错误/错误而提高了生产力。
- en: Debugging can also provide insightful information about the correctness of any
    value returning from a function.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试还可以提供关于任何从函数返回的值的正确性的有洞察力的信息。
- en: Debugging can also be used to trace bugs further by examining the results from
    other referenced libraries as well. It is possible that we may use the referenced
    library incorrectly or the referenced library may also have bugs.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过检查其他引用库的结果，调试还可以用于进一步跟踪错误。我们可能使用引用库不正确，或者引用库本身也可能存在错误。
- en: Visual F# in Visual Studio 2015 also has debugging capabilities. It was not
    as powerful when it was introduced in Visual Studio 2008 as additional add-on,
    but now the debugging experience is much better. It has been integrated with the
    Visual Studio extensibility model nicely, providing, for example, faster execution
    while running in the debug mode and having conditional breakpoints.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2015 中的 Visual F# 也具有调试功能。当它在 Visual Studio 2008 中作为附加组件引入时，它并不像现在这样强大，但现在调试体验要好得多。它已经很好地集成到
    Visual Studio 扩展性模型中，例如，在调试模式下提供更快的执行速度和条件断点。
- en: It is different from the C#/VB debugger because F#, although being a strongly
    and strictly typed language, currently has no support for evaluating expressions
    in the debugger's immediate windows in Visual Studio 2015.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 C#/VB 调试器不同，因为尽管 F# 是一种强类型和严格类型的语言，但目前它不支持在 Visual Studio 2015 调试器的立即窗口中评估表达式。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some experienced F# developers may argue that this additional debug feature
    is not a big concern at all as F# has a tendency to enforce type restriction and
    correctness at the fabric of F# as a programming language. But for most other
    developers, especially those who jump from C#/VB to F#, the overall debugging
    experience is still lacking some features.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一些经验丰富的 F# 开发者可能会争论说，这个额外的调试功能根本不是什么大问题，因为 F# 作为一种编程语言，有强制类型限制和正确性的趋势。但对于大多数其他开发者，尤其是那些从
    C#/VB 跳转到 F# 的开发者来说，整体的调试体验仍然缺少一些功能。
- en: 'Currently these are the differences between the F# and C#/VB debugger in Visual
    Studio 2015:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这些是 Visual Studio 2015 中 F# 和 C#/VB 调试器的不同之处：
- en: '| **Feature** | **F#** | **C#/VB** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **F#** | **C#/VB** |'
- en: '| Breakpoint insertion | Yes. | Yes |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 断点插入 | 是。 | 是 |'
- en: '| Condition in breakpoint | Yes. | Yes |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 断点中的条件 | 是。 | 是 |'
- en: '| Intellisense in editing condition in breakpoint | Not supported because Intellisense
    is not yet linked to the whole infrastructure of the Visual Studio 2015 IDE extensibility
    and the F# compiler. There is a plan to have this feature for the next Visual
    Studio release after Visual Studio 2015. | Yes |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 断点中的编辑条件 Intellisense | 不支持，因为 Intellisense 尚未链接到 Visual Studio 2015 IDE
    扩展性和 F# 编译器的整个基础设施。有一个计划在 Visual Studio 2015 之后的下一个 Visual Studio 版本中实现此功能。 |
    是 |'
- en: '| Lightbulb assistant | Not available. There is a plan to have this feature
    for the next Visual Studio release after Visual Studio 2015, but the exact planned
    release is not quite clear. | Yes |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 轻量级辅助灯泡 | 不可用。有一个计划在 Visual Studio 2015 之后的下一个 Visual Studio 版本中实现此功能，但具体的计划发布日期尚不明确。
    | 是 |'
- en: '| Expression evaluation in immediate window | Not available. | Yes |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 立即窗口中的表达式评估 | 不可用。 | 是 |'
- en: '| Locals value | Yes. | Yes |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 本地值 | 是。 | 是 |'
- en: '| Auto watch value | Yes. | Yes |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 自动监视值 | 是。 | 是 |'
- en: Other than the features in the previous table, basic debugging with breakpoints
    in Visual F# is essentially the same as debugging in C#/VB.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前表格中的功能外，在 Visual F# 中使用断点进行的基本调试与 C#/VB 中的调试基本上是相同的。
- en: 'Let''s take some code to debug. To quickly have some code, we can use the F#
    3.0 sample from CodePlex at:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一些代码来调试。为了快速获取一些代码，我们可以使用 CodePlex 上的 F# 3.0 示例，地址为：
- en: '[http://fsharp3sample.codeplex.com/](http://fsharp3sample.codeplex.com/)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://fsharp3sample.codeplex.com/](http://fsharp3sample.codeplex.com/)'
- en: After downloading the ZIP file of the code samples, unzip it to a folder and
    open the `SampleProject.sln` solution file in Visual Studio.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下载代码示例的ZIP文件后，将其解压到一个文件夹中，并在Visual Studio中打开`SampleProject.sln`解决方案文件。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may read `Readme.txt` first before using the whole sample code. This readme
    guide is available in the `Solution Item` folder when opened in **Solution Explorer**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用整个示例代码之前，您可以首先阅读`Readme.txt`。当在**解决方案资源管理器**中打开时，此说明指南位于`Solution Item`文件夹中。
- en: 'Now, your screen should look like this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的屏幕应该看起来像这样：
- en: '![Introduction to debugging in F#](img/image00250.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![F# 调试简介](img/image00250.jpeg)'
- en: Some of the samples in F# 3.0 are not valid anymore. You have to register for
    Azure DataMarket to access the F# Type Provider of Azure DataMarket.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: F# 3.0中的一些示例已经不再有效。您必须注册Azure DataMarket才能访问Azure DataMarket的F#类型提供者。
- en: There are some compiler errors if we try to rebuild the solution without changing
    the code at all, and one of the sample type providers, ESRI DataMarket, is not
    working.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在不更改代码的情况下重新构建解决方案，将会出现一些编译错误，并且其中一个示例类型提供者，ESRI DataMarket，无法正常工作。
- en: 'Based on those invalid type provider conditions, to build this sample solution
    successfully, you have to follow these steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 基于那些无效的类型提供者条件，为了成功构建此示例解决方案，您必须遵循以下步骤：
- en: Register with Azure DataMarket. You need to have your own Azure account key
    to access Azure DataMarket.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure DataMarket上注册。您需要自己的Azure账户密钥才能访问Azure DataMarket。
- en: The ESRI sample has not been working since 2014\. Please comment the lines from
    line 135 to line 157 in the `Samples.TypeProviders.AzureMarketPlace.fs` file.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ESRI示例自2014年以来一直无法正常工作。请在`Samples.TypeProviders.AzureMarketPlace.fs`文件中从第135行到第157行注释掉这些行。
- en: Rebuild the solution. This will compile the whole solution and also resolve
    the type provider in the background for us to use.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建解决方案。这将编译整个解决方案，并在后台为我们解决类型提供者。
- en: Now open the `Samples.Beginners.fs` file. Put the debugger breakpoints at lines
    19 and 20 by clicking the line.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`Samples.Beginners.fs`文件。通过单击行号将调试器断点放在第19行和第20行。
- en: To add breakpoints, you can simply toggle the highlighted column on the left
    before the line number like this:![Introduction to debugging in F#](img/image00251.jpeg)
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加断点，您只需在行号左侧的高亮列上切换，如下所示：![F# 调试简介](img/image00251.jpeg)
- en: And we can also add breakpoints by right clicking and choosing **Breakpoints..**
    and then **Insert Breakpoint**.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过右键单击并选择**断点..**然后选择**插入断点**来添加断点。
- en: Compile the code by initiating the **Build Solution**. Then press *F5* to run.
    The window of **F# Micro Sample Explore** is displayed:![Introduction to debugging
    in F#](img/image00252.jpeg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过启动**构建解决方案**来编译代码。然后按*F5*键运行。将显示**F# 微型示例探索**窗口：![F# 调试简介](img/image00252.jpeg)
- en: This sample is actually a showcase of many F# features, from basic language
    constructs, units of measure, type providers, and LINQ, to concurrency such as
    async and parallelism.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个示例实际上展示了众多F#功能，从基本语言结构、度量单位、类型提供者到LINQ，再到异步和并行等并发性。
- en: Now expand the **Basic** node on the left and choose **Basic Data Types**, and
    then choose the last node of **Integer Arithmetic**, as illustrated here:![Introduction
    to debugging in F#](img/image00253.jpeg)
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，展开左侧的**基本**节点，选择**基本数据类型**，然后选择**整数算术**的最后节点，如图所示：![F# 调试简介](img/image00253.jpeg)
- en: 'Going back to the source code of `Samples.Beginner.fs`, we can see that the
    node name is also the same as the name of the attributes in the code to categorize:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Samples.Beginner.fs`的源代码，我们可以看到节点名称也与代码中用于分类的属性名称相同：
- en: '[PRE4]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Click the **Run Sample!** button and Visual Studio will stop the execution at
    the breakpoint:![Introduction to debugging in F#](img/image00254.jpeg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行示例！**按钮，Visual Studio将在断点处停止执行：![F# 调试简介](img/image00254.jpeg)
- en: Now we can debug our code easily. We can also look at the value of the variables
    or symbols that are currently in scope by checking the value at the **Locals**
    window.
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地调试我们的代码。我们还可以通过检查**局部变量**窗口中的值来查看当前作用域中的变量或符号的值。
- en: Press *F10* to step over, and now we see the evaluated value of `x` and `y`:![Introduction
    to debugging in F#](img/image00255.jpeg)
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*F10*键跳过，现在我们看到`x`和`y`的评估值：![F# 调试简介](img/image00255.jpeg)
- en: Any local variables in **Locals** and watch expressions displayed in the **Watch1**
    window always have the name, value, and type of the variables. The type displayed
    is using the F# keyword, not the full type name.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Locals**窗口和**Watch1**窗口中显示的监视表达式中的任何局部变量始终具有变量的名称、值和类型。显示的类型使用F#关键字，而不是完整的类型名称。
- en: For example, `int` is displayed instead of `System.Int32` as shown in **Locals**.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，显示的是`int`而不是如**Locals**中所示`System.Int32`。
- en: We can always check other values as well if we have another `global` or `static
    global` variable in the **Watch1** window. The values can contain immediate values
    from an expression, for example `DateTime.Now`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在**Watch1**窗口中还有另一个`global`或`static global`变量，我们也可以检查其他值。这些值可以包含来自表达式的即时值，例如`DateTime.Now`。
- en: 'Unfortunately, we have to write using the full namespace of `System.DateTime`,
    so we have to write the expression as `System.DateTime.Now`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们必须使用`System.DateTime`的全命名空间来编写代码，因此我们必须将表达式写成`System.DateTime.Now`：
- en: '![Introduction to debugging in F#](img/image00256.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![F#调试简介](img/image00256.jpeg)'
- en: This requirement to have the full namespace proves that debugger support in
    Visual F# still requires improvements compared to its C#/VB counterparts. Typing
    the full object name may be error prone, as F# watch does not support Intellisense
    yet.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种需要完整命名空间的要求证明了与C#/VB的对应版本相比，Visual F#中的调试器支持仍需要改进。键入完整对象名称可能会出错，因为F#监视器尚不支持Intellisense。
- en: After we have finished debugging and bug fixing, it is recommended to change
    the compilation to the **Release** mode. The **Release** mode will have a smaller
    compiled F# code and it executes faster because it does not contain debug symbols
    and any other debug information attached to the compiled code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成调试和错误修复后，建议将编译模式更改为**发布**模式。**发布**模式将生成更小的F#编译代码，并且执行速度更快，因为它不包含附加到编译代码的调试符号和其他调试信息。
- en: 'To change back and forth between **Debug** and **Release** is quite easy. We
    can simply change the mode at the drop-down menu in the Visual Studio toolbar:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在**调试**和**发布**模式之间来回切换相当简单。我们只需在Visual Studio工具栏的下拉菜单中更改模式即可：
- en: '![Introduction to debugging in F#](img/image00257.jpeg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![F#调试简介](img/image00257.jpeg)'
- en: There is no apparent distinction on the compiled DLL or EXE filename, other
    than the smaller size of the release mode.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发布模式文件大小更小之外，编译的DLL或EXE文件名没有明显的区别。
- en: 'To summarize, the following are the differences of the **Debug** mode and the
    **Release** mode:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是在**调试**模式和**发布**模式之间的区别：
- en: '| **Elements** | **Debug** | **Release** |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **调试** | **发布** |'
- en: '| Debug symbol (PDB) | Included | Not included. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 调试符号（PDB） | 包含 | 不包含。 |'
- en: '| Size of compiled code | Bigger than the release mode, excluding the PDB file
    | Smaller than the debug mode. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 编译代码大小 | 包括PDB文件在内，比发布模式大 | 比调试模式小。 |'
- en: '| Code optimization | Not optimized, as it is focused for debugging and it
    is also synchronized | Yes, but the code will not be able to be debugged easily,
    as the code is optimized for executions.In .NET 4.6 and Windows 10, it is optimized
    further by compiling into native code using the Ahead Of Time (AOT) model instead
    of Just In Time (JIT). |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 代码优化 | 未优化，因为它专注于调试，并且也是同步的 | 是的，但代码将无法轻松调试，因为代码是针对执行优化的。在.NET 4.6和Windows
    10中，它通过使用提前编译（AOT）模型而不是即时编译（JIT）进一步优化为本地代码。 |'
- en: '| Compilation symbol availability | `DEBUG` | Not applicable. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 编译符号可用性 | `DEBUG` | 不适用。 |'
- en: '| Execution | Slower than Release, as there is no optimization | Fast, since
    it is optimized for runtime, and there is no debug symbol overhead. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | 比发布模式慢，因为没有优化 | 快速，因为它针对运行时进行了优化，并且没有调试符号开销。 |'
- en: For more information about AOT and JIT, consult the MSDN Library at [https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 关于AOT和JIT的更多信息，请参阅MSDN库中的[https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dn807190(v=vs.110).aspx)。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed the introduction to performing common performance optimizations,
    from the performance characteristics of F# and .NET to the most commonly used
    optimization concepts such as concurrency. We also have a basic knowledge to start
    troubleshooting performance problems by debugging using Visual Studio. But debugging
    running F# code is still a small part of performance optimization because debugging
    only provides an insight of the values and the states of objects in our code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了执行常见性能优化的介绍，从 F# 和 .NET 的性能特性到最常用的优化概念，如并发。我们还具备使用 Visual Studio 进行调试以开始排查性能问题的基本知识。但调试运行中的
    F# 代码仍然是性能优化的一小部分，因为调试仅提供了我们代码中对象值和状态的了解。
- en: The debug support of F# tooling itself is not enough to fully understand the
    details of performance problems because most of the detailed performance optimization
    requires us to measure the benchmark of our code. The measurement of performance
    in order to objectively measure optimization will be described in [Chapter 2](fsp-hiperf_cu02.html#aid-K0RQ2
    "Chapter 2. Performance Measurement") , *Performance Measurement*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: F# 工具本身的调试支持不足以全面理解性能问题的细节，因为大多数详细的性能优化需要我们测量代码的基准。为了客观地衡量优化，性能测量的内容将在[第二章](fsp-hiperf_cu02.html#aid-K0RQ2
    "第二章. 性能测量")，*性能测量*中描述。
