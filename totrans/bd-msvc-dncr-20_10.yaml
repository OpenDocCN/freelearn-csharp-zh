- en: Creating a Complete Microservice Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On our journey down the lane of understanding microservices and their evolution,
    we continued through various phases. We explored what led to the advent of microservices
    and the various advantages of utilizing them. We also discussed various integration
    techniques and testing strategies. Let''s recap all that we have talked about
    thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectures before microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices were never designed from the ground up to be in the present form.
    Instead, there has been a gradual transition from other forms of prevalent architecture
    styles to microservices. Prior to microservices, we had the monolithic architecture
    and service-oriented architecture that reigned over the world of enterprise development.
  prefs: []
  type: TYPE_NORMAL
- en: Let's delve into these two before doing a quick recap of microservices and their
    various attributes and advantages.
  prefs: []
  type: TYPE_NORMAL
- en: The monolithic architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monolithic architecture has been around for quite some time and it results
    in self-contained software with a single .NET assembly. It consists of the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cost paid for being self-contained was that all the components were interconnected
    and interdependent. A minor change in any module had the capability to impact
    the entire piece of software. With all the components so tightly coupled in this
    manner, it made testing the entire application necessary. Also, another repercussion
    of being so tightly coupled was that the entire application had to be deployed
    once again. Let''s sum up all the challenges we faced as a result of adopting
    this style of architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Large interdependent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption of a new technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges in standardizing the .NET stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technology adoption is not easy when it comes to monolithic. It poses certain
    challenges. Security, response time, throughput rate, and technology adoption
    are some of them. It is not that this style of architecture does not fight back
    with solutions. The challenge is that in monolithic, code reusability is really
    low or absent, which makes technology adoption difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We also discussed how scaling is a viable option but with diminishing returns
    and increasing expenses. Both vertical and horizontal scaling have their own pros
    and cons. Vertical scaling is seemingly easier to begin with: investing in IT
    infrastructures, such as RAM upgrades and disk drives. However, the return plateaus
    out very quickly. The disadvantage of the downtime required for vertical scaling
    doesn''t exist in horizontal scaling. However, beyond a point, the cost of horizontal
    returns becomes too high.'
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another widely used architecture in the industry was a **service-oriented architecture**
    (**SOA**). This architecture was a move away from the monolithic architecture
    and was involved in resolving some of its challenges, mentioned in the preceding
    section. To begin with, it was based on a collection of services. Providing a
    service was the core concept of SOA.
  prefs: []
  type: TYPE_NORMAL
- en: A service is a piece of code, program, or software that provides some functionality
    to other system components. This piece of code was able to interact directly with
    the database or indirectly through other services. It was self-contained to the
    extent that it allowed services to be consumed easily by both desktop and mobile
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the definite advantages that SOA provided over monolithic were:'
  prefs: []
  type: TYPE_NORMAL
- en: Reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contract-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to upgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice-styled architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apart from some of the definite advantages of SOA, microservices provide certain
    additional differentiating factors that make them a clear winner. At the core,
    microservices were defined to be completely independent of other services in the
    system and run in their process. The attribute of being independent required a
    certain discipline and strategy in the application design. Some of the benefits they
    provide are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clear code boundaries: This resulted in easier code changes. Its independent
    modules provided an isolated functionality that led to a change in one microservice
    having little impact on others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Easy deployment: It is possible to deploy one microservice at a time if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Technology adaptation: The preceding attributes led to  this much sought-after
    benefit. This allows us to adopt different technologies in different modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Affordable scalability: This allows us to scale only chosen components/modules
    instead of the whole application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Distributed system: This is implicit, but a word of caution is necessary here.
    Make sure that your asynchronous calls are used well and the synchronous ones
    don''t block the whole flow of information. Use data partitioning well. We will
    come to this a little later, so don''t worry for now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quick market response: In a competitive world, this is a definite advantage
    as users tend to lose interest quickly if you are slow to respond to new feature
    requests or to adopt a new technology within your system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messaging in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another important area that needs its share of discussion. There are
    primarily two main types of messaging utilized in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolith transitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As part of our exercise, we decided to transition our existing monolithic application
    FlixOne to a microservice-styled architecture. We saw how to identify decomposition
    candidates within a monolith, based on the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Code complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technology adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are definite advantages it provides in regard to cost, security, and scalability,
    apart from technology independence. This also aligns the application more with
    the business goals.
  prefs: []
  type: TYPE_NORMAL
- en: The entire process of transitioning requires you to identify seams that act
    like boundaries of your microservices along which you can start the separation.
    You have to be careful about picking up seams on the right parameters. We have
    talked about how module interdependency, team structure, database, and technology
    are a few probable candidates. Special care is required to handle master data.
    It is more a choice of whether you want to handle master data through a separate
    service or through configurations. You will be the best judge for your scenario.
    The fundamental requirement of a microservice having its own database is that
    it removes many of the existing foreign key relationships. This would bring forth
    the need to pick your transaction-handling strategy intelligently to preserve
    data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Integration techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already explored synchronous and asynchronous ways of communication
    between microservices and discussed the collaboration style of the services. Those
    styles were request/response and event-based. Though request/response seems to
    be synchronous in nature, the truth is that it is the implementation that decides
    the outcome of the style of integration. Event-based style, on the other hand,
    is purely asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with a large number of microservices, it is important that we utilize
    an integration pattern in order to facilitate complex interaction among microservices.
    We explored the API Gateway along with an event-driven pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'API Gateway provides you with a plethora of services, some of which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing an API call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying API keys, JWT tokens, and certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing usage quotas and rate limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming APIs on the fly without code modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up caching backend responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging call metadata for analytic purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event-driven pattern works by some services publishing their events and
    some subscribing to those available events. The subscribing services simply react
    independently of the event-publishing services, based on the event and its metadata.
    The publisher is unaware of the business logic that the subscribers would be executing.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monolithic deployments for enterprise applications can be challenging for more
    than one reason. Having a central database, which is difficult to break down,
    only increases the overall challenge along with time to market.
  prefs: []
  type: TYPE_NORMAL
- en: For microservices, the scenario is very different. The benefits don't just come
    by virtue of the architecture being microservices. Instead, it is the planning
    from the initial stages itself. You can't expect an enterprise-scale microservice to
    be managed without **continuous delivery** (**CD**) and **continuous integration**
    (**CI**). So strong is the requirement for CI and CD right from the early stages
    that without it the production stage may never see the light of day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools such as CFEngine, Chef, Puppet, Ansible, and PowerShell DSC help you
    represent an infrastructure with code and let you easily make different environments
    exactly the same. Azure could be an ally here: the rapid and repeated provisioning
    required could easily be met.'
  prefs: []
  type: TYPE_NORMAL
- en: Isolation requirements could be met with containers far more effectively than
    their closest rival, virtual machines. We have already explored Docker as one
    of the popular candidates for containerization and have seen how to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know the importance of unit tests and why every developer should be writing
    them. Unit tests are a good means to verify the smallest functionality that contributes
    toward building larger systems.
  prefs: []
  type: TYPE_NORMAL
- en: However, testing microservices is not a routine affair like testing a monolith,
    since one microservice might interact with a number of other microservices. In
    that case, should we utilize the calls to the actual microservices to ensure that
    the complete workflow is working fine? The answer is no, as this would make developing
    a microservice dependent on another piece. If we do this, then the whole purpose
    of having a microservice-based architecture is lost. In order to get around this,
    we will use the mock-and-stub approach. This approach not only makes the testing
    independent of other microservices but also makes testing with databases much
    easier since, we can mock database interactions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a small isolated functionality with a unit test or testing a component
    by mocking the response from an external microservice has its scope and it works
    well within that scope. However, if you are already asking yourself the question
    about testing the larger context, then you are not alone. Integration testing
    and contract testing are the next steps in testing microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In integration testing, we're concerned about external microservices and communicate
    with them as part of the process. For this purpose, we mock external services.
    We take this further with contract testing, where we test each and every service
    call independently and then verify the response. An important concept worth spending
    time on is consumer-driven contracts. Refer to Chapter 4, *Testing Strategies*,
    to study this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional approach of having a single point of authentication and authorization
    worked well in the monolithic architecture. However, in the case of microservices,
    you would need to do this for each and every service. This would pose a challenge
    of not only implementing it but keeping it synchronized as well.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth 2.0 authorization framework and the OpenID Connect 1.0 specifications
    combined together can solve the problem for us. OAuth 2.0 describes all the roles
    involved in the authorization process that meets our needs pretty well. We just
    have to make sure that the right grant type is picked up; otherwise, the security
    will be compromised. OpenID Connect authentication is built on top of the OAuth
    2.0 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Active Directory** (**Azure AD**) is one of the providers of OAuth
    2.0 and OpenID Connect specifications. It is understood here that Azure AD scales
    very well with applications and integrates well with any organizational Windows
    Server Active Directory.'
  prefs: []
  type: TYPE_NORMAL
- en: As we have already discussed containers, it is important and interesting to
    understand that containers are very close to the host operating system's kernel.
    Securing them is another aspect that can't be overrated. Docker was the tool we
    considered, and it provides the necessary security by means of the least privilege
    principle.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The monolithic world has a few advantages of its own. Monitoring and logging
    is one of those areas where things are easier compared to microservices. The sheer
    number of microservices across which an enterprise system might be spread can
    be mind-boggling.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in Chapter 1, *An Introduction to Microservices*, in the *Prerequisites
    for a microservice architecture* section, an organization should be prepared for
    the profound change. The monitoring framework was one of the key requirements
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike a monolithic architecture, monitoring is very much required from the
    very beginning in a microservice-based architecture. There is a wide range of
    reasons why monitoring can be categorized:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Health: We need to preemptively know when a service failure is imminent. Key
    parameters, such as CPU and memory utilization, along with other metadata, could
    be a precursor to either the impending failure or just a flaw in the service that
    needs to be fixed. Just imagine an insurance company''s rate engine getting overloaded
    and going out of service or even performing slowly when a few hundred field executives
    try to share the cost with potential clients. Nobody likes to wait these days.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Availability: There might be a situation when the service may not perform extensive
    calculations, but the bare availability of the service itself might be crucial
    to the entire system. In such a scenario, I remember relying upon pings to listeners
    that would wait for a few minutes before shooting out emails to the system administrators.
    It worked for monoliths with one or two services to be monitored. However, with
    microservices, much more metadata comes into the picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Performance: For platforms receiving high footfall, such as banking and e-commerce,
    availability alone does not deliver the service required. Considering the number
    of people converging at their platforms in very short spans, ranging from a few
    minutes to even tens of seconds, performance is not a luxury anymore. You need
    to know how the system is responding by means of data, such as concurrent users
    being served, and compare that with the health parameters in the background. This
    might provide an e-commerce platform with the ability to decide whether upgrades
    are required before the upcoming holiday season. For more sales, you need to serve
    a higher number of people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security: In any system, you can plan resilience only up to a specific level.
    No matter how well designed a system is, there will be thresholds beyond which
    the system will falter, which can result in a domino effect. However, having a
    thoughtfully designed security system in place could easily avert DoS and SQL
    Injection attacks. This would really matter from system-to-system when dealing
    with microservices. So think ahead and think carefully when setting up trust levels
    between your microservices. The default strategy that I have seen people utilizing
    is securing the endpoints with microservices. However, covering this aspect increases
    your system''s security and is worth spending some time on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Auditing: Healthcare, financing, and banking are a few of the domains that
    have the strictest compliance standards concerning associated services. And it
    is pretty much the same the world over. Depending upon the kind of compliance
    you are dealing with, you might have a requirement to keep the data for a specific
    period of time as a record, keep the data in a specific format to be shared with
    regulatory authorities, or even sync with systems provided by the authority. Taxation
    systems could be another example here. With a distributed architecture, you don''t
    want to risk losing the data recordset related to even a single transaction since
    that would amount to a compliance failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Troubleshooting system failures: This, I bet, will be a favorite for a long
    time to come of anybody who is getting started with microservices. I remember
    the initial days when I used to try troubleshooting a scenario involving two Windows
    services. I never thought of recommending a similar design again. But the times
    have changed and so has the technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When providing a service to other clients, monitoring becomes all the more important.
    In today's competitive world, an SLA would be part of any deal and has a cost
    associated with it, in the event of both success and failure. Ever wondered how
    easily we assumed that the Microsoft Azure SLA would stand true come what may?
    I have grown so used to it that the queries from clients worried about cloud resource
    availability are answered with a flat reply of 99.9 per cent uptime without even
    the blink of an eye.
  prefs: []
  type: TYPE_NORMAL
- en: So unless you can be confident of agreeing an SLA with your clients when providing
    a service, they can't count on it to promise the same SLA going forward. As a
    matter of fact, no SLA might mean that your services are probably not stable enough
    to provide one.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There could be multiple key points that need to be addressed before you have
    a successful monitoring system in place. These need to be identified and assigned
    a solution. Some of the key points are discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a successfully running system with a few dozen microservices orchestrating
    successful transactions in perfect harmony, then you have won the first battle.
    Congratulations! However, you must plug in the necessary monitoring part if you
    haven't done so already. Ideally, this should be part of step one itself.
  prefs: []
  type: TYPE_NORMAL
- en: Component lifespan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the use of virtual machines and containers, we need to figure out what
    part is worth monitoring. Some of these components might be already nonexistent
    by the time you look at the data generated by monitoring them. So it becomes extremely
    important that you choose the information to be monitored wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Information visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are tools available, such as AppDynamics and New Relic, that would allow
    you to visualize the data for maybe up to 100 microservices. However, in real-world
    applications, this is just a fraction of the number. There has to be clarity about
    the purpose of this information and a well-designed visualization around it. This
    is one area where we can opt for reverse design. First, think about the report/visualization
    you want and then see what how it is to be monitored.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin with monitoring, you could think of different commonly implemented
    strategies as a solution to your problem. Some of the commonly implemented strategies
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Application/system monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-user monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic monitoring and synthetic transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just bear in mind that each one of these strategies is focused on solving a
    specific purpose. While one could be helpful in analyzing transaction propagation,
    the other could be suitable for testing purposes. So it is important for you to
    pick a combination of these when designing the whole system, since just using
    a single strategy won't meet the needs.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed in detail the scale-cube model of scalability and have found
    what scaling at each axis means. Note that *x *axis scaling is achieved through
    the use of load balancers between multiple instances and the users of the microservices.
    We also saw how *z *axis scaling based on the transaction origination suffered
    from some drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, scaling in the microservice world can be categorized into two separate
    heads:'
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual machines are an indispensable component of the microservice world. The
    features available as part of the Microsoft Azure platform enable you to perform
    this seemingly complex task without breaking a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: Through the scale set feature, which is integrated with Azure autoscale, we
    can easily manage a set of identical virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling lets you define thresholds for various supported parameters, such
    as CPU usage. Once the threshold is breached, the scale set kicks in, based on
    whether the parameters scale in or scale out.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the scale set predicts that it needs to add more virtual
    machines to cater for the increased load, it will continue to do so until the
    thresholds are back to normal. Similarly, if the demand for a resource being governed
    falls, it will decide to remove the virtual machine from the scale set. To me,
    this sounds like peace for the networking team. The options around auto-scaling
    can be explored further, as it is capable of taking care of complex scaling requirements,
    running into hundreds of virtual machines while scaling in or scaling out.
  prefs: []
  type: TYPE_NORMAL
- en: Service design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our microservices, we have already achieved the isolation of data for each
    microservice. However, the model for reading and writing the database is still
    the same. With the underlying relational databases enforcing the ACID model, this
    can be a costly affair. Or we can say that this approach can be slightly modified
    to implement the database read/write operation in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: We can employ the common query responsibility segregation, also referred to
    as CQRS, to make effective design changes in our microservices. Once the model-level
    separation is done, we will be free to optimize the read and write data models
    using a different strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have progressed well while transitioning our monolithic application to the
    microservice-styled architecture. We have also briefly touched upon the possibility
    of introducing reactive traits to our services. We now know what the key attributes
    of reactive microservices are:'
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autonomous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being message-driven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also saw the benefits of reactive microservices amounting to less work on
    our part when it comes to managing communication across/between the microservices.
    This benefit translates not just into reduced work but the capability to focus
    on the core job of executing the business logic instead of trying to grapple with
    the complexities of inter-service communication.
  prefs: []
  type: TYPE_NORMAL
- en: Greenfield application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's go ahead and create the FlixOne bookstore from scratch. First, we
    will scope out our microservices and their functionalities and identify inter-service
    interactions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our FlixOne bookstore will have the following set of functionalities available:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching through the available books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering books on the basis of categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding books to the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes to the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing an order from the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoping our services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand how these functionalities will map out as different microservices,
    we need to first understand, what it would take to support it, and what can be
    clubbed together as a microservice. We will see how the data store would start
    to look out of the window of microservices themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The book-listing microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's try to break down the first functionality of searching through books.
    In order to let our users browse through the store for books, we need to maintain
    a list of books on offer. Here we have our first candidate being carved out as
    a microservice. The book-catalog service would be responsible for not just searching
    through the available books, but also maintaining the data store that would house
    all the information pertaining to books. The microservice should be able to handle
    various updates required for the available books in the system. We will call it
    the book-catalog microservice. And, it will have its own book data store.
  prefs: []
  type: TYPE_NORMAL
- en: The book-searching microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examining the next functionality of filtering books seems to be coming under
    the purview of the book-catalog microservice itself. However, having said that,
    let''s confirm it by questioning our own understanding of the business domain
    here. The question that comes to my mind is related to the impact of all the searches
    that our users would perform bringing down the service. So should the book-search
    functionality be a different service? Here the answer lies in the fact that the
    microservice should have its own data store. Having the book catalog and the book-catalog
    search function as different services would require us to maintain a list of books
    in two different locations with additional challenges, such as having to sync
    them. The solution is simple: have a single microservice, and if required, scale
    up and load balance the book-catalog microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: The shopping-cart microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next candidate is the one made famous by the online shopping revolution
    brought around by the likes of Amazon and further fuelled by smartphones: the
    shopping-cart microservice. It should let us add or remove books to our cart before
    we finally decide to check out and pay for them. There is no doubt about whether
    this should be a separate microservice or not. However, this brings forth an interesting
    question of whether it deals with the product''s data store or not; it would need
    to do this in order to receive some fundamental details, such as availability
    in stock. Accessing the data store across the service is out of the question as
    that is one of the most fundamental prerequisites for microservices. The answer
    to our question is inter-service communication. It is OK for a microservice to
    use the service provided by another microservice. We will call this our shopping-cart
    microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: The order microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business functionality of placing an order is next in line. When a user
    decides that their shopping cart has just the right books, they decide to place
    an order. At that moment, some information related to the order has to be confirmed/conveyed
    to various other microservices. For example, before the order is confirmed, we
    need to confirm from the book catalog that there is enough quantity available
    in stock to fulfill the order. After this confirmation, the right number of items
    is supposed to be reduced from the book catalog. The shopping cart would also
    have to be emptied after the successful confirmation of the order.
  prefs: []
  type: TYPE_NORMAL
- en: Although our order microservice sounds more pervasive and in contradiction to
    the rules of non-sharing of data across microservices, it is not the case, as
    we will see shortly. All the operations will be completed while maintaining clear
    boundaries, with each microservice managing its own data store.
  prefs: []
  type: TYPE_NORMAL
- en: User-authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our last candidate is the user-authentication microservice that would validate
    the user credentials of customers who log in to our bookstore. The sole purpose
    of this microservice is to confirm whether or not the provided credentials are
    correct in order to restrict unauthorized access. This seems pretty simple for a
    microservice; however, we have to remember the fact that making this functionality
    a part of any other microservice would impact more than one business functionality
    if you decide to change your authentication mechanism. The change may come in
    the form of using JWT tokens being generated and validated based on the OAuth
    2.0 authorization framework and OpenID Connect 1.0 authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the final list of candidates for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: The book-catalog microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shopping-cart microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user-authentication microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following image we can visualize four services that are catalog, shopping
    cart, order, and authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9ac8893-2bd9-446a-9cd9-d3a4530dcaea.png)'
  prefs: []
  type: TYPE_IMG
- en: Synchronous versus asynchronous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with a brief introduction of the microservices, there
    is an important point to consider here. Our microservices will be communicating
    with each other, and there is a possibility that they will rely on a response
    to move further. This poses a dilemma for us, having gone through all the pain
    of unlearning the beloved monolithic and then getting into the same situation
    where a point of failure can be a cascading collapse of the system.
  prefs: []
  type: TYPE_NORMAL
- en: The book-catalog microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This microservice has six main functions exposed through an HTTP API component.
    It is the responsibility of this HTTP API component to handle all the HTTP requests
    for these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API resource description** | **API resource description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`book` | Gets a list of the available books |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`book{category}` | Gets a list of the books for a category |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`book{name}` | Gets a list of the books by name |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`book{isbn}` | Gets a book as per the ISBN number |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`bookquantity{id}` | Gets the available stock for the intended
    book |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` /`api`/`bookquantity{id, changecount}` | Increase or decrease the available
    stock quantity for a book |'
  prefs: []
  type: TYPE_TB
- en: 'The following image is visualizing tables of the catalog services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd32657b-5aa1-4ca3-a92c-6ba3e0c8a338.png)'
  prefs: []
  type: TYPE_IMG
- en: The shopping-cart microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API resource description** | **API resource description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` /`api`/`book {customerid }` | Adds the specific book to the shopping
    cart of the customer |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` /`api`/`book {customerid }` | Removes the book from the shopping
    cart of the customer |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`book{customerid}` | Gets the list of books in the shopping
    cart of the customer |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` /`api`/`empty` | Removes all the books currently contained in the shopping
    cart. |'
  prefs: []
  type: TYPE_TB
- en: 'The following image is visualizing all supporting tables for the shopping-cart
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e99e8356-0ac3-45c3-8aff-442655e8f63d.png)'
  prefs: []
  type: TYPE_IMG
- en: The order microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API resource description** | **API resource description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` /`api`/`order {customerid }` | Gets all the books in the shopping
    cart of the customer and creates an order for the same |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` /`api`/`order {customerid }` | Removes the book from the shopping
    cart of the customer |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`order{orderid}` | Gets all the books as part of the specific
    order |'
  prefs: []
  type: TYPE_TB
- en: 'The following image depicts all tables of the order service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/598e49f5-aca5-46e7-86fe-02c2b447c065.png)'
  prefs: []
  type: TYPE_IMG
- en: The user-authentication microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This microservice will have the following functions exposed as HTTP endpoints
    for consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **API resource description** | **API resource description** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` /`api`/`verifyuser{customerid, password}` | Verifies the user |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot shows the user table of the authentication service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36041ba3-4ca1-4b99-b021-aec19d71dab0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can look at the application source code and analyze it as required.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We hope that this book was able to introduce you to the fundamental concepts
    of the microservice-styled architecture and also helped you to dive deeply into
    the fine aspects of microservices with clear examples of the concepts. The final
    application is available for you to take a closer look and analyze what you have
    learned so far at your own pace. We wish you luck in utilizing the skills learned
    in this book and applying them to your real-world challenges.
  prefs: []
  type: TYPE_NORMAL
