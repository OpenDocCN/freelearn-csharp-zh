- en: '*Chapter 1*: Managed Threading Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*: 管理线程概念'
- en: '`async` and `await` keywords in C#. This book will cover all of these concepts
    in the chapters ahead.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的`async`和`await`关键字。本书将涵盖接下来的章节中所有这些概念。
- en: In this chapter, we will start with the basics of how to work with **managed
    threading** in .NET. You will learn how to create and destroy threads, handle
    exceptions, synchronize data, and utilize the objects provided by .NET to handle
    background operations. Additionally, you will gain a basic understanding of how
    threads can be managed in a .NET application. The practical examples in this chapter
    will illustrate how to leverage managed threading in C# projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从.NET中如何使用**托管线程**的基本知识开始。您将学习如何创建和销毁线程，处理异常，同步数据，并利用.NET提供的对象来处理后台操作。此外，您还将获得.NET应用程序中线程管理的基本理解。本章中的实际示例将说明如何在C#项目中利用托管线程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: .NET threading basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET线程基础知识
- en: Creating and destroying threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和销毁线程
- en: Handling threading exceptions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理线程异常
- en: Synchronizing data across threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程间同步数据
- en: Scheduling and canceling work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度和取消工作
- en: By starting with the core concepts of threading in .NET, you will gain a solid
    foundation as you move forward with your learning throughout this book. It is
    important to understand the basics to prevent common mistakes from being made
    while introducing threading and asynchrony to .NET applications. It is all too
    easy to exhaust resources or put the application’s data in an invalid state. Let’s
    get started with managed threading with C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从.NET线程的核心概念开始，您将在学习本书的过程中获得坚实的基础。理解基础知识对于在.NET应用程序中引入线程和异步操作时防止犯下常见错误非常重要。耗尽资源或将应用程序的数据置于无效状态是非常容易的。让我们从使用C#进行托管线程开始吧。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的应用程序中负责任地使用线程，您应该确切了解**线程**是什么以及您的应用程序的**进程**如何使用线程。
- en: Visual Studio 2022 version 17.0 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022版本17.0或更高版本
- en: .NET 6
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: While these are recommended, as long as you have .NET 6 installed, you can use
    your preferred editor. For example, Visual Studio 2022 for Mac, JetBrains Rider,
    or Visual Studio Code will work just as well.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然以下推荐是好的，但只要您安装了.NET 6，您就可以使用您喜欢的编辑器。例如，Visual Studio 2022 for Mac，JetBrains
    Rider或Visual Studio Code都将同样有效。
- en: All the code examples for this chapter can be found on GitHub at https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter01.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，网址为https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter01。
- en: .NET threading basics
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET线程基础知识
- en: It’s time to get started by learning about the basics of threading in C# and
    .NET. We will be covering the managed threading concepts that are available in
    .NET 6, but many of these features have been part of .NET since the beginning.
    The `System.Threading` namespace has been available since .NET Framework 1.0\.
    In the subsequent 20 years, there have been many useful features added for developers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候学习C#和.NET中线程的基本知识，开始我们的旅程了。我们将介绍.NET 6中可用的托管线程概念，但许多这些功能自.NET之初就已经存在。《System.Threading》命名空间自.NET
    Framework 1.0以来就可用。在随后的20年里，为开发者添加了许多有用的功能。
- en: In order to responsibly use threading in your applications, you should understand
    exactly what a **thread** is and how threads are used by your application’s **processes**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在您的应用程序中负责任地使用线程，您应该确切了解**线程**是什么以及您的应用程序的**进程**如何使用线程。
- en: Threads and processes
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和进程
- en: We will start our journey with the basic units of application processing, threads,
    and processes. A process encapsulates all the execution of an application. This
    is true for all platforms and frameworks. In .NET, you can think of a process
    as your `.exe` or hosted service.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从应用程序处理的基本单元，线程和进程开始我们的旅程。一个进程封装了一个应用程序的所有执行。这在所有平台和框架中都是正确的。在.NET中，您可以将进程视为您的`.exe`或托管服务。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In .NET Framework, the concept of **application domains** (or app domains),
    which create isolation units within a process, was introduced. These app domains
    provide security and reliability by isolating the execution of code loaded into
    a new app domain. App domains still exist but are not available for developers
    to create or unload in .NET Core and modern versions of .NET. To read more about
    app domains, check out this Microsoft Docs article at https://docs.microsoft.com/dotnet/framework/app-domains/application-domains.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Framework中，引入了**应用程序域**（或app domains）的概念，它在一个进程内创建隔离单元。这些应用程序域通过隔离加载到新应用程序域中的代码的执行来提供安全和可靠性。应用程序域仍然存在，但在.NET
    Core和.NET的现代版本中，开发人员无法创建或卸载它们。要了解更多关于应用程序域的信息，请查看Microsoft Docs上的这篇文章：https://docs.microsoft.com/dotnet/framework/app-domains/application-domains。
- en: A **thread** represents a single unit of execution within a process. By default,
    a .NET application will execute all its logic on a single thread (that is, the
    primary or main thread). Developers can leverage managed threads and other .NET
    constructs to move from a single-threaded to a multithreaded world, but how do
    you know when to take this step?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**代表进程中的一个单一执行单元。默认情况下，.NET应用程序将在单个线程上执行所有其逻辑（即主要或主线程）。开发人员可以利用托管线程和其他.NET结构从单线程世界迁移到多线程世界，但您如何知道何时采取这一步？'
- en: When should we use multithreading in .NET?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们应该在.NET中使用多线程的什么时候？
- en: There are multiple factors to consider when deciding whether to introduce threading
    to an application. These factors are both internal and external to the application.
    The external factors include the hardware in terms of where the application will
    be deployed, how powerful the processors are where the application will be running,
    and what other types of processes will be running on these systems?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否将线程引入应用程序时，需要考虑多个因素。这些因素既包括应用程序内部的，也包括外部的。外部因素包括硬件方面，例如应用程序将部署的位置、应用程序运行处的处理器有多强大，以及在这些系统上还将运行哪些其他类型的进程？
- en: If your application will be competing for limited resources, it is best to be
    judicious with the use of multiple threads. If users get the impression that your
    application is impacting the performance of their systems, you will need to scale
    back on the number of threads being consumed by your process. Another factor that
    comes into play is how critical your application is in relation to others on the
    system. Mission-critical applications will have more resources allocated to remain
    responsive when needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序将竞争有限的资源，最好在多线程的使用上保持谨慎。如果用户觉得您的应用程序正在影响他们系统的性能，您将需要减少您的过程所消耗的线程数量。另一个需要考虑的因素是您的应用程序相对于系统上其他应用程序的重要性。关键任务应用程序将分配更多资源，以便在需要时保持响应。
- en: Other common reasons for introducing threading relate to the application itself.
    Desktop and mobile applications need to keep the **user interface** (**UI**) responsive
    to user input. If the application needs to process a large amount of data or load
    it from a database, file, or network resource, executing on the main thread can
    cause the UI to freeze or lag. Also, executing long-running tasks in parallel
    on multiple threads can reduce the overall execution time of the task.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 引入线程的其他常见原因与应用程序本身有关。桌面和移动应用程序需要保持**用户界面**（**UI**）对用户输入的响应。如果应用程序需要处理大量数据或从数据库、文件或网络资源中加载数据，则在主线程上执行可能会导致UI冻结或延迟。此外，在多个线程上并行执行长时间运行的任务可以减少任务的整体执行时间。
- en: These operations can be offloaded to **background threads** if the execution
    of the tasks is not critical to the application state. Let’s look at the difference
    between foreground threads and background threads in .NET.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务的执行对应用程序状态不是至关重要的，这些操作可以卸载到**后台线程**。让我们看看.NET中前台线程和后台线程之间的区别。
- en: Background threads
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景线程
- en: The difference between foreground threads and background threads might not be
    what you think. A managed thread created as a foreground thread is not the UI
    thread or the main thread. Foreground threads are threads that will prevent the
    managed process from terminating if they are running. If an application is terminated,
    any running background threads will be stopped so that the process can shut down.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前台线程和后台线程之间的区别可能并非如您所想。作为前台线程创建的管理线程不是UI线程或主线程。前台线程是那些如果正在运行，将阻止托管进程终止的线程。如果一个应用程序被终止，任何正在运行的背景线程都将被停止，以便进程可以关闭。
- en: By default, newly created threads are foreground threads. To create a new background
    thread, set the `Thread.IsBackground` property to `true` before starting the thread.
    Additionally, you can use the `IsBackground` property to determine the background
    status of an existing thread. Let’s look at an example where you might want to
    use a background thread in your application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新创建的线程是前台线程。要创建一个新的后台线程，在启动线程之前将`Thread.IsBackground`属性设置为`true`。此外，您还可以使用`IsBackground`属性来确定现有线程的后台状态。让我们看看一个你可能想在应用程序中使用后台线程的例子。
- en: 'In this example, we will create a console application in Visual Studio that
    will continuously check the status of a network connection on a background thread.
    Create a new .NET 6 console app project, name it `BackgroundPingConsoleApp`, and
    in `Program.cs`, enter the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Visual Studio创建一个控制台应用程序，该应用程序将在后台线程上持续检查网络连接的状态。创建一个新的.NET 6控制台应用程序项目，命名为`BackgroundPingConsoleApp`，并在`Program.cs`中输入以下代码：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s discuss each part of the preceding code before we run it and examine
    the output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行并检查输出之前，让我们讨论前面代码的每个部分：
- en: The first `Console.WriteLine` statement was created by the project template.
    We’ll keep this here to help illustrate the order output in the console.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`Console.WriteLine`语句是由项目模板创建的。我们将保留它以帮助说明控制台输出的顺序。
- en: Next, we’re creating a new `Thread` type named `bgThread`. Inside the body of
    the thread, there is a `while` loop that will execute continuously until the thread
    is terminated. Inside the loop, we’re calling the `GetIsNetworkAvailable` method
    and outputting the result of that call to the console. Before starting over again,
    we’re using `Thread.Sleep` to inject a 100-millisecond delay.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的名为`bgThread`的`Thread`类型。在线程的主体内部，有一个将连续执行直到线程被终止的`while`循环。在循环内部，我们调用`GetIsNetworkAvailable`方法并将该调用的结果输出到控制台。在重新开始之前，我们使用`Thread.Sleep`注入100毫秒的延迟。
- en: 'The next line after creating the thread is the key part of this lesson:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建线程之后的下一行是本节课的关键部分：
- en: '[PRE21]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Setting the `IsBackground` property to `true` is what makes our new thread a
    background thread. This tells our application that the code executing inside the
    thread is not critical to the application, and the process can terminate without
    needing to wait for the thread to complete its work. That is a good thing here
    because the `while` loop we created will never be complete.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将`IsBackground`属性设置为`true`使得我们的新线程成为后台线程。这告诉我们的应用程序，线程内部执行的代码对应用程序不是关键的，进程可以在不需要等待线程完成其工作的情况下终止。在这里这是一个好事，因为我们所创建的`while`循环永远不会完成。
- en: On the next line, we start the thread with the `Start` method.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，我们使用`Start`方法启动线程。
- en: Next, the application kicks off some work inside the application’s primary thread.
    A `for` loop will execute 10 times and output `"Main thread working..."` to the
    console. At the end of each iteration of the loop, `Task.Delay` is used to wait
    500 milliseconds, hopefully providing some time for the background thread to perform
    some work.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，应用程序在其主线程内部启动一些工作。一个`for`循环将执行10次，并将`"Main thread working..."`输出到控制台。在循环的每次迭代结束时，使用`Task.Delay`等待500毫秒，希望为后台线程执行一些工作提供一些时间。
- en: After the `for` loop, the application will output `"Done"` to the console and
    wait for the user input to terminate the application with the `Console.ReadKey`
    method.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环之后，应用程序将输出`"Done"`到控制台，并等待用户输入以使用`Console.ReadKey`方法终止应用程序。
- en: 'Now, run the application and examine the console output. You can press any
    key to stop the application when you feel you have let it run for long enough:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序并检查控制台输出。当你觉得运行时间足够长时，可以按任意键停止应用程序：
- en: '![Figure 1.1 – Viewing the threaded console application output ](img/Figure_1.1_B18552.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 查看线程化控制台应用程序的输出](img/Figure_1.1_B18552.jpg)'
- en: Figure 1.1 – Viewing the threaded console application output
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 查看线程化控制台应用程序的输出
- en: The result might not be what you expected. You can see that the program executed
    all the logic on the primary thread before starting any of the background thread
    work. Later, we’ll see how to change the priority of the threads to manipulate
    which work will be processed first.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不是你所期望的。你可以看到程序在开始任何后台线程的工作之前，已经在主线程上执行了所有逻辑。稍后，我们将看到如何更改线程的优先级以操纵哪些工作将首先被处理。
- en: 'What is important to understand, in this example, is that we were able to stop
    the console application by pressing a key to execute the `Console.ReadKey` command.
    Even though the background thread is still running, the process does not consider
    the thread to be critical to the application. If you comment out the following
    line, the application will no longer terminate by pressing a key:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，重要的是要理解，我们能够通过按下一个键来执行 `Console.ReadKey` 命令来停止控制台应用程序。即使后台线程仍在运行，进程也不认为线程是应用程序的关键。如果你注释掉以下行，应用程序将不再通过按键来终止：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The application will have to be stopped by closing the command window or using
    the **Debug** | **Stop Debugging** menu item in Visual Studio. Later, in the *Scheduling
    and canceling work* section, we will learn how to cancel work in a managed thread.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序必须通过关闭命令窗口或使用 Visual Studio 中的 **调试** | **停止调试** 菜单项来停止。稍后，在 *调度和取消工作* 部分中，我们将学习如何在一个受管理的线程中取消工作。
- en: Before we look at any more examples of using managed threads, we will take some
    time to learn exactly what they are.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看更多使用受管理线程的示例之前，我们将花一些时间来了解它们究竟是什么。
- en: What is managed threading?
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是受管理的线程？
- en: In .NET, `System.Threading.Thread` class that we used in the previous example.
    The managed execution environment for the current process monitors all the threads
    that have been run as part of the process. `PInvoke`) calls from .NET code. If
    this thread is entering the managed environment for the first time, .NET will
    create a new `Thread` object to be managed by the execution environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，我们在上一个示例中使用的 `System.Threading.Thread` 类。当前进程的受管理执行环境监视了作为进程一部分运行的所有的线程。`.NET`
    代码中的 `PInvoke` 调用。如果这个线程是第一次进入受管理的环境，.NET 将创建一个新的 `Thread` 对象，由执行环境进行管理。
- en: A managed thread can be uniquely identified using the `ManagedThreadId` property
    of the `Thread` object. This property is an integer that is guaranteed to be unique
    across all threads and will not change over time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `Thread` 对象的 `ManagedThreadId` 属性唯一地标识一个受管理的线程。这个属性是一个整数，保证在整个线程中是唯一的，并且随着时间的推移不会改变。
- en: The `ThreadState` property is a read-only property that provides the current
    execution state of the `Thread` object. In the example in the *.NET threading
    basics* section, if we had checked the `ThreadState` property before calling `bgThread.Start()`,
    it would have been `Unstarted`. After calling `Start`, the state will change to
    `Background`. If it were not a background thread, calling `Start` would change
    the `ThreadState` property to `Running`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadState` 属性是一个只读属性，它提供了 `Thread` 对象当前的执行状态。在 *.NET 线程基础* 部分的示例中，如果我们调用
    `bgThread.Start()` 之前检查了 `ThreadState` 属性，它将是 `未启动`。调用 `Start` 后，状态将变为 `后台`。如果不是后台线程，调用
    `Start` 将将 `ThreadState` 属性更改为 `正在运行`。'
- en: 'Here is a full list of the `ThreadState` enum values:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `ThreadState` 枚举值的完整列表：
- en: '`Aborted`: The thread has been aborted.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已中止`：线程已被中止。'
- en: '`AbortRequested`: An abort has been requested but has not yet been completed.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求中止`：已请求中止但尚未完成。'
- en: '`Background`: The thread is running in the background (`IsBackground` has been
    set to true).'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`后台`：线程在后台运行（`IsBackground` 已设置为 `true`）。'
- en: '`Running`: The thread is currently running.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正在运行`：线程目前正在运行。'
- en: '`Stopped`: The thread has been stopped.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已停止`：线程已被停止。'
- en: '`StopRequested`: A stop has been requested but has not yet been completed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求停止`：已请求停止但尚未完成。'
- en: '`Suspended`: The thread has been suspended.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已挂起`：线程已被挂起。'
- en: '`SuspendRequested`: Thread suspension has been requested but has not yet been
    completed.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`请求挂起`：已请求挂起线程但尚未完成。'
- en: '`Unstarted`: The thread has been created but not yet started.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未启动`：线程已经被创建但尚未启动。'
- en: '`WaitSleepJoin`: The thread is currently blocked.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`等待/睡眠/加入`：线程目前被阻塞。'
- en: The `Thread.IsAlive` property is a less specific property that can tell you
    whether a thread is currently running. It is a `boolean` property that will return
    `true` if the thread has started and has not been stopped or aborted in some way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.IsAlive` 属性是一个较为通用的属性，可以告诉你一个线程是否正在运行。它是一个 `boolean` 类型的属性，如果线程已经开始并且没有被以某种方式停止或取消，它将返回
    `true`。'
- en: Threads also have a `Name` property that defaults to `null` if they have never
    been set. Once a `Name` property is set on a thread, it cannot be changed. If
    you attempt to set the `Name` property of a thread that is not null, it will throw
    `InvalidOperationException`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 线程还有一个`Name`属性，如果它们从未被设置，则默认为`null`。一旦在线程上设置了`Name`属性，它就不能再更改。如果你尝试设置非`null`线程的`Name`属性，它将抛出`InvalidOperationException`。
- en: We will cover additional aspects of managed threads in the remainder of this
    chapter. In the next section, we will dive deeper into the available methods and
    options for creating and destroying threads in .NET.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分介绍托管线程的更多方面。在下一节中，我们将深入了解.NET中创建和销毁线程的可用方法和选项。
- en: Creating and destroying threads
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和销毁线程
- en: '`Thread` class that should be discussed first. Also, we will look at a few
    methods of pausing or interrupting thread execution. Finally, we will cover some
    ways to destroy or terminate a thread’s execution.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先讨论的应该是`Thread`类。此外，我们还将查看一些暂停或中断线程执行的方法。最后，我们将介绍一些销毁或终止线程执行的方法。
- en: Let’s get started by going into more detail regarding creating and starting
    threads.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论创建和启动线程。
- en: Creating managed threads
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建托管线程
- en: 'Creating `Thread` object. The `Thread` class has four constructor overloads:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Thread`对象。`Thread`类有四个构造函数重载：
- en: '`Thread(ParameterizedThreadStart)`: This creates a new `Thread` object. It
    does this by passing a delegate with a constructor that takes an object as its
    parameter that can be passed when calling `Thread.Start()`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread(ParameterizedThreadStart)`: 这创建一个新的`Thread`对象。它是通过传递一个构造函数带有参数的对象的委托来实现的，该参数可以在调用`Thread.Start()`时传递。'
- en: '`Thread(ThreadStart)`: This creates a new `Thread` object that will execute
    the method to be invoked, which is provided as the `ThreadStart` property.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread(ThreadStart)`: 这将创建一个新的`Thread`对象，该对象将执行要调用的方法，该方法作为`ThreadStart`属性提供。'
- en: '`Thread(ParameterizedThreadStart, Int32):` This adds a `maxStackSize` parameter.
    Avoid using this overload because it is best to allow .NET to manage the stack
    size.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread(ParameterizedThreadStart, Int32):` 这添加了一个`maxStackSize`参数。避免使用这个重载，因为它最好让.NET管理堆栈大小。'
- en: '`Thread(ThreadStart, Int32):` This adds a `maxStackSize` parameter. Avoid using
    this overload because it is best to allow .NET to manage the stack size.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread(ThreadStart, Int32):` 这添加了一个`maxStackSize`参数。避免使用这个重载，因为它最好让.NET管理堆栈大小。'
- en: 'Our first example used the `Thread(ThreadStart)` constructor. Let’s look at
    a version of that code that uses `ParameterizedThreadStart` to pass a value by
    limiting the number of iterations of the `while` loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例使用了`Thread(ThreadStart)`构造函数。让我们看看使用`ParameterizedThreadStart`通过限制`while`循环的迭代次数来传递值的那个代码版本：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you run the application, it will run just like the last example, but the
    background thread should only output 12 lines to the console. You can try passing
    different integer values into the `Start` method to see how that impacts the console
    output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，它将像最后一个示例一样运行，但后台线程应该只输出12行到控制台。你可以尝试将不同的整数值传递给`Start`方法，以查看这对控制台输出的影响。
- en: 'If you want to get a reference to the thread that is executing the current
    code, you can use the `Thread.CurrentThread` static property:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取当前正在执行代码的线程的引用，你可以使用`Thread.CurrentThread`静态属性：
- en: '[PRE50]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This can be useful if your code needs to check the current thread’s `ManagedThreadId`,
    `Priority`, or whether it is running in the background.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码需要检查当前线程的`ManagedThreadId`、`Priority`或它是否在后台运行，这可能很有用。
- en: Next, let’s look at how we can pause or interrupt the execution of a thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何暂停或中断线程的执行。
- en: Pausing thread execution
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂停线程执行
- en: Sometimes, it is necessary to pause the execution of a thread. A common real-life
    example of this is a retry mechanism on a background thread. If you have a method
    that sends log data to a network resource, but the network is unavailable, you
    can call `Thread.Sleep` to wait for a specific interval before trying again. `Thread.Sleep`
    is a static method that will block the current thread for the number of milliseconds
    specified. It is not possible to call `Thread.Sleep` on a thread other than the
    current one.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，暂停线程的执行是必要的。一个常见的现实生活中的例子是在后台线程上的重试机制。如果你有一个将日志数据发送到网络资源的方法，但网络不可用，你可以调用`Thread.Sleep`来等待特定的时间间隔然后再尝试。`Thread.Sleep`是一个静态方法，它将阻塞当前线程指定的时间（毫秒数）。不可能在除了当前线程之外的线程上调用`Thread.Sleep`。
- en: 'We have already used `Thread.Sleep` in the examples in this chapter, but let’s
    change the code slightly to see how it can impact the order of events. Change
    the `Thread.Sleep` interval inside the thread to `10`, remove the code that makes
    it a background thread, and change the `Task.Delay()` call to `Thread.Sleep(100)`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的示例中使用了 `Thread.Sleep`，但让我们稍微修改一下代码，看看它如何影响事件顺序。将线程中的 `Thread.Sleep`
    间隔更改为 `10`，删除将其变为后台线程的代码，并将 `Task.Delay()` 调用更改为 `Thread.Sleep(100)`：
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When running the application again, you can see that putting a greater delay
    on the primary thread allows the process inside `bgThread` to begin executing
    before the primary thread completes its work:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序时，您可以看到，在主线程上放置更大的延迟可以让 `bgThread` 中的进程在主线程完成其工作之前开始执行：
- en: '![Figure 1.2 – Using Thread.Sleep to change the order of events ](img/Figure_1.2_B18552.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 使用 Thread.Sleep 改变事件顺序](img/Figure_1.2_B18552.jpg)'
- en: Figure 1.2 – Using Thread.Sleep to change the order of events
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 使用 Thread.Sleep 改变事件顺序
- en: The two `Thread.Sleep` intervals can be adjusted to see how they impact the
    console output. Give it a try!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整两个 `Thread.Sleep` 间隔以查看它们如何影响控制台输出。试一试！
- en: Additionally, it is possible to pass `Timeout.Infinite` to `Thread.Sleep`. This
    will cause the thread to pause until it is interrupted or aborted by another thread
    or the managed environment. Interrupting a blocked or paused thread is accomplished
    by calling `Thread.Interrupt`. When a thread is interrupted, it will receive a
    `ThreadInterruptedException` exception.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以将 `Timeout.Infinite` 传递给 `Thread.Sleep`。这将导致线程暂停，直到它被另一个线程或托管环境中断或终止。通过调用
    `Thread.Interrupt` 来中断阻塞或暂停的线程。当线程被中断时，它将接收到 `ThreadInterruptedException` 异常。
- en: The exception handler should allow the thread to continue working or clean up
    any remaining work. If the exception is unhandled, the runtime will catch the
    exception and stop the thread. Calling `Thread.Interrupt` on a running thread
    will have no effect until that thread has been blocked.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理程序应允许线程继续工作或清理任何剩余的工作。如果未处理异常，运行时会捕获异常并停止线程。在运行中的线程上调用 `Thread.Interrupt`
    不会有任何效果，直到该线程被阻塞。
- en: Now that you understand how to create an interrupt thread, let’s wrap up this
    section by learning how to destroy a thread.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建中断线程，让我们通过学习如何销毁线程来结束本节。
- en: Destroying managed threads
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁托管线程
- en: Generally, `Thread.Abort` method. In .NET Framework, calling `Thread.Abort`
    on a thread would raise a `ThreadAbortedException` exception and stop the thread
    from running. Aborting threads was not made available in .NET Core or any of the
    newer versions of .NET. If some code needs to be forcibly stopped, it is recommended
    that you run it in a separate process from your other code and use `Process.Kill`
    to terminate the other process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`Thread.Abort` 方法。在 .NET Framework 中，对线程调用 `Thread.Abort` 会引发 `ThreadAbortedException`
    异常并停止线程运行。在 .NET Core 或任何 .NET 的新版本中都没有提供终止线程的功能。如果某些代码需要被强制停止，建议您将其运行在与其他代码分开的进程中，并使用
    `Process.Kill` 来终止其他进程。
- en: Any other thread termination should be handled cooperatively using cancelation.
    We will see how to do this in the *Scheduling and canceling work* section. Next,
    let’s discuss some of the exceptions to handle when working with managed threads.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他线程终止都应通过取消合作来处理。我们将在 *调度和取消工作* 部分中看到如何做到这一点。接下来，让我们讨论一些在处理托管线程时需要处理的异常。
- en: Handling threading exceptions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理线程异常
- en: There are a couple of exception types that are specific to managed threading,
    including the `ThreadInterruptedException` exception that we covered in the previous
    section. Another exception type that is specific to threading is `ThreadAbortException`.
    However, as we discussed in the previous section, `Thread.Abort` is not supported
    in .NET 6, so, although this exception type exists in .NET 6, it is not necessary
    to handle it, as this type of exception is only possible in .NET Framework applications.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种异常类型是针对托管线程的特定类型，包括我们在上一节中提到的 `ThreadInterruptedException` 异常。另一种特定于线程的异常类型是
    `ThreadAbortException`。然而，正如我们在上一节中讨论的，.NET 6 中不支持 `Thread.Abort`，因此，尽管这种异常类型存在于
    .NET 6 中，但处理它并不是必要的，因为这种类型的异常仅在 .NET Framework 应用程序中是可能的。
- en: Two other exceptions are the `ThreadStartException` exception and the `ThreadStateException`
    exception. The `ThreadStartException` exception is thrown if there is a problem
    starting the managed thread before any user code in the thread can be executed.
    The `ThreadStateException` exception is thrown when a method on the thread is
    called that is not available when the thread is in its current `ThreadState` property.
    For example, calling `Thread.Start` on a thread that has already started is invalid
    and will cause a `ThreadStateException` exception. These types of exceptions can
    usually be avoided by checking the `ThreadState` property before acting on the
    thread.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个异常是`ThreadStartException`异常和`ThreadStateException`异常。如果在使用线程的用户代码执行之前启动托管线程存在问题，则会抛出`ThreadStartException`异常。当在当前`ThreadState`属性不可用的情况下调用线程上的方法时，会抛出`ThreadStateException`异常。例如，在一个已经启动的线程上调用`Thread.Start`是无效的，并会导致`ThreadStateException`异常。通常可以通过在操作线程之前检查`ThreadState`属性来避免这些类型的异常。
- en: It is important to implement comprehensive exception handling in multithreaded
    applications. If code in managed threads begins to fail silently without any logging
    or causing the process to terminate, the application can fall into an invalid
    state. This can also result in degrading performance and unresponsiveness. While
    this kind of degradation might be noticed quickly for many applications, some
    services, and other non-GUI-based applications, could continue for some time without
    any issues being noticed. Adding logging to the exception handlers along with
    a process to alert users when logs are reporting failures will help to prevent
    problems with undetected failing threads.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序中实现全面的异常处理非常重要。如果托管线程中的代码开始无声地失败，没有任何日志记录或导致进程终止，应用程序可能会进入无效状态。这也可能导致性能下降和响应迟钝。虽然许多应用程序的性能下降可能会很快被发现，但某些服务和基于非GUI的其他应用程序可能会在一段时间内没有任何问题被发现。在异常处理程序中添加日志记录，并有一个在日志报告失败时提醒用户的过程，将有助于防止未检测到的失败线程的问题。
- en: 'In the next section, we’ll discuss another challenge with multithreaded code:
    keeping data in-sync across multiple threads.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论多线程代码的另一个挑战：在多个线程间保持数据同步。
- en: Synchronizing data across threads
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程间同步数据
- en: In this section, we will look at some of the methods that are available in .NET
    for synchronizing data across multiple threads. Shared data across threads can
    be one of the primary pain points of multithreaded development if not handled
    properly. Classes in .NET that have protections in place for threading are said
    to be **thread-safe**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨.NET中用于在多个线程间同步数据的一些方法。如果处理不当，线程间的共享数据可能是多线程开发的主要痛点之一。在.NET中，具有线程保护机制的类被称为**线程安全**。
- en: 'Data in multithreaded applications can be synchronized in several different
    ways:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程应用程序中的数据可以通过几种不同的方式进行同步：
- en: '`Monitor` class or with some help from the .NET compiler.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Monitor`类或借助.NET编译器的帮助。'
- en: '**Manual synchronization**: There are several **synchronization primitives**
    in .NET that can be used to manually synchronize data.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动同步**：.NET中有几个可用于手动同步数据的**同步原语**。'
- en: '**Synchronized context**: This is only available in .NET Framework and Xamarin
    applications.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步上下文**：这仅在.NET Framework和Xamarin应用程序中可用。'
- en: '**System.Collections.Concurrent classes**: There are specialized .NET collections
    to handle concurrency. We will examine these in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**System.Collections.Concurrent类**：有一些专门的.NET集合用于处理并发。我们将在[*第9章*](B18552_09_ePub.xhtml#_idTextAnchor146)中探讨这些内容。'
- en: In this section, we’ll look at the first two methods. Let’s start by discussing
    how to synchronize code regions in your application.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨前两种方法。让我们首先讨论如何在您的应用程序中同步代码区域。
- en: Synchronizing code regions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步代码区域
- en: 'There are several techniques you can use to synchronize regions of your code.
    The first one we will discuss is the `Monitor` class. You can surround a block
    of code that can be accessed by multiple threads with calls to `Monitor.Enter`
    and `Monitor.Exit`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几种技术来同步代码区域。我们将首先讨论的是`Monitor`类。您可以使用`Monitor.Enter`和`Monitor.Exit`调用将多个线程可以访问的代码块包围起来：
- en: '[PRE77]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this example, imagine you have an `order` object that is being updated by
    multiple threads in parallel. The `Monitor` class will lock access from other
    threads while the current thread adds an `orderDetail` item to the `order` object.
    The key to minimizing the chance of introducing wait time to other threads is
    by only locking the lines of code that need to be synchronized.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设你有一个 `order` 对象，它正由多个线程并行更新。`Monitor` 类将在当前线程向 `order` 对象添加 `orderDetail`
    项目时锁定其他线程的访问。最小化向其他线程引入等待时间的关键是只锁定需要同步的代码行。
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Interlocked` class, as discussed in this section, performs atomic operations
    in user mode rather than kernel mode. If you want to read more about this distinction,
    I recommend checking out this blog post by Nguyen Thai Duong: https://duongnt.com/interlocked-synchronization/.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所述，`Interlocked` 类在用户模式下执行原子操作，而不是在内核模式下。如果你想了解更多关于这种区别的信息，我建议查看 Nguyen Thai
    Duong 的这篇博客文章：https://duongnt.com/interlocked-synchronization/。
- en: 'The `Interlocked` class provides several methods for performing atomic operations
    on objects shared across multiple threads. The following list of methods is part
    of the `Interlocked` class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Interlocked` 类提供了在多个线程间共享的对象上执行原子操作的方法。以下方法列表是 `Interlocked` 类的一部分：'
- en: '`Add`: This adds two integers, replacing the first one with the sum of the
    two'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`：这个方法将两个整数相加，用它们的和替换第一个'
- en: '`And`: This is a bitwise `and` operation for two integers'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`And`：这是两个整数的位与操作'
- en: '`CompareExchange`: This compares two objects for equality and replaces the
    first if they are equal'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompareExchange`：这个方法比较两个对象是否相等，如果相等则替换第一个'
- en: '`Decrement`: This decrements an integer'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decrement`：这个方法会递减一个整数'
- en: '`Exchange`: This sets a variable to a new value'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchange`：这个方法将变量设置为新的值'
- en: '`Increment`: This increments an integer'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Increment`：这个方法会递增一个整数'
- en: '`Or`: This is a bitwise `or` operation for two integers'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Or`：这是两个整数的位或操作'
- en: These `Interlocked` operations will lock access to the target object only for
    the duration of that operation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `Interlocked` 操作将仅在操作期间锁定对目标对象的访问。
- en: Additionally, the `lock` statement in C# can be used to lock access to a block
    of code to only a single thread. The `lock` statement is a language construct
    implemented using the .NET `Monitor.Enter` and `Monitor.Exit` operations.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 中的 `lock` 语句可以用来锁定对代码块的访问，使其只能由单个线程访问。`lock` 语句是一个使用 .NET 的 `Monitor.Enter`
    和 `Monitor.Exit` 操作实现的编程语言构造。
- en: There is some built-in compiler support for the `lock` and `Monitor` blocks.
    If an exception is thrown inside one of these blocks, the lock is automatically
    released. The C# compiler generates a `try/finally` block around the synchronized
    code and makes a call to `Monitor.Exit` in the `finally` block.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `lock` 和 `Monitor` 块，有一些内置的编译器支持。如果在这些块中抛出异常，锁会自动释放。C# 编译器在同步代码周围生成一个 `try/finally`
    块，并在 `finally` 块中调用 `Monitor.Exit`。
- en: Let’s finish up this section on synchronization by looking at some other .NET
    classes that provide support for manual data synchronization.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些其他提供手动数据同步支持的 .NET 类来结束本节关于同步的讨论。
- en: Manual synchronization
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动同步
- en: 'The use of **manual synchronization** is common when synchronizing data across
    multiple threads. Some types of data cannot be protected in other ways, such as
    these:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨多个线程同步数据时，使用**手动同步**是很常见的。某些类型的数据无法用其他方式保护，例如这些：
- en: '**Global fields**: These are variables that can be accessed globally across
    the application.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局字段**：这些是可以跨应用程序全局访问的变量。'
- en: '**Static fields**: These are static variables in a class.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态字段**：这些是类中的静态变量。'
- en: '**Instance fields**: These are instance variables in a class.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例字段**：这些是类中的实例变量。'
- en: These fields do not have method bodies, so there is no way to put a synchronized
    code region around them. With manual synchronization, you can protect all the
    areas where these objects are used. These regions can be protected with `lock`
    statements in C#, but some other synchronization primitives provide access to
    shared data and can coordinate the interactions between threads on a more granular
    level. The first construct we will examine is the `System.Threading.Mutex` class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段没有方法体，因此无法在它们周围放置同步代码区域。使用手动同步，你可以保护所有使用这些对象的地方。这些区域可以用 C# 中的 `lock` 语句进行保护，但某些其他同步原语提供了对共享数据的访问，并且可以在更细粒度级别上协调线程间的交互。我们将首先检查的构造是
    `System.Threading.Mutex` 类。
- en: 'The `Mutex` class is similar to the `Monitor` class in that it blocks access
    to a region of code, but it can also provide the ability to grant access to other
    processes. When using the `Mutex` class, use the `WaitOne()` and `ReleaseMutex()`
    methods to acquire and release the lock. Let’s look at the same order/order details
    example. This time, we’ll use a `Mutex` class declared at the class level:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutex` 类与 `Monitor` 类类似，它阻止对代码区域的访问，但它还可以提供授予其他进程访问的能力。当使用 `Mutex` 类时，使用 `WaitOne()`
    和 `ReleaseMutex()` 方法来获取和释放锁。让我们看看相同的顺序/顺序详情示例。这次，我们将使用在类级别声明的 `Mutex` 类：'
- en: '[PRE82]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you want to enforce a timeout period on the `Mutex` class, you can call
    the `WaitOne` overload with a timeout value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 `Mutex` 类上强制执行超时周期，你可以调用带有超时值的 `WaitOne` 重载：
- en: '[PRE88]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: It is important to note that `Mutex` is a `Dispose()` on the object when you
    are finished using it. Additionally, you can also enclose a disposable type within
    a `using` block to have it disposed of indirectly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，当你完成对对象的操作时，`Mutex` 是通过调用对象的 `Dispose()` 方法来释放的。此外，你还可以在 `using` 块中封装可释放的类型，以便间接地将其释放。
- en: In this section, the last .NET manual locking construct we are going to examine
    is the `ReaderWriterLockSlim` class. You can use this type if you have an object
    that is used across multiple threads, but most of the code is reading data from
    the object. You don’t want to lock access to the object in the blocks of code
    that are reading data, but you do want to prevent reading while the object is
    being updated or simultaneously written. This is referred to as "multiple readers,
    single writer."
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将要检查的最后一个 .NET 手动锁定结构是 `ReaderWriterLockSlim` 类。如果你有一个在多个线程间使用的对象，你可以使用这种类型；但大多数代码都是从该对象中读取数据。你不想在读取数据的代码块中锁定对对象的访问，但你确实想防止在对象被更新或同时写入时进行读取。这被称为“多个读取者，单个写入者”。
- en: 'This `ContactListManager` class contains a list of contacts that can be added
    to or retrieved by a phone number. The class assumes that these operations can
    be called from multiple threads and uses the `ReaderWriterLockSlim` class to apply
    a read lock in the `GetContactByPhoneNumber` method and a write lock in the `AddContact`
    method. The locks are released in a `finally` block to ensure they are always
    released, even when exceptions are encountered:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ContactListManager` 类包含一个可以按电话号码添加或检索的联系人类表。该类假设这些操作可以从多个线程调用，并在 `GetContactByPhoneNumber`
    方法中使用 `ReaderWriterLockSlim` 类应用读锁，在 `AddContact` 方法中使用写锁。锁在 `finally` 块中释放，以确保它们总是被释放，即使遇到异常也是如此：
- en: '[PRE89]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If you were to add a `DeleteContact` method to the `ContactListManager` class,
    you would leverage the same `EnterWriteLock` method to prevent any conflicts with
    the other operations in the class. If a lock is forgotten in one usage of `contacts`,
    it can cause any of the other operations to fail. Additionally, it is possible
    to apply a timeout to the `ReaderWriterLockSlim` locks:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向 `ContactListManager` 类添加一个 `DeleteContact` 方法，你会利用相同的 `EnterWriteLock`
    方法来防止与类中其他操作的冲突。如果在 `contacts` 的某个使用中忘记加锁，它可能导致其他任何操作失败。此外，还可以将超时应用于 `ReaderWriterLockSlim`
    锁：
- en: '[PRE126]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are several other synchronization primitives that we have not covered
    in this section, but we have discussed some of the most common types that you
    will use. To read more about the available types for manual synchronization, you
    can visit Microsoft Docs at https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还没有涵盖几个其他同步原语，但我们讨论了一些你将最常用的最常见类型。要了解更多关于手动同步可用类型的信息，你可以访问 Microsoft
    Docs，网址为 https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives。
- en: Now that we have examined different ways of synchronizing data when working
    with managed threads, let’s cover two more important topics before wrapping up
    this first chapter. We are going to discuss techniques to schedule work on threads
    and how to cancel managed threads cooperatively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了在处理托管线程时同步数据的不同方法，在结束第一章之前，让我们再讨论两个重要的话题。我们将讨论在线程上调度工作以及如何协作地取消托管线程的技术。
- en: Scheduling and canceling work
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度和取消工作
- en: When orchestrating multithreaded processing in an application, it is important
    to understand how to schedule and cancel work on managed threads.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中编排多线程处理时，了解如何调度和取消托管线程上的工作非常重要。
- en: Let’s start by looking at how scheduling works with managed threads in .NET.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看在 .NET 中如何使用托管线程进行调度开始。
- en: Scheduling managed threads
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度托管线程
- en: 'When it comes to managed threads, scheduling is not as explicit as it might
    sound. There is no mechanism to tell the operating system to kick off work at
    specific times or to execute within certain intervals. While you could write this
    kind of logic, it is probably not necessary. The process of scheduling managed
    threads is simply managed by setting priorities on the threads. To do this, set
    the `Thread.Priority` property to one of the available `ThreadPriority` values:
    `Highest`, `AboveNormal`, `Normal` (default), `BelowNormal`, or `Lowest`.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到托管线程时，调度并不像听起来那么明确。没有机制可以告诉操作系统在特定时间启动工作或在特定间隔内执行。虽然你可以编写这种逻辑，但这可能不是必要的。调度托管线程的过程只是通过设置线程的优先级来管理的。为此，将`Thread.Priority`属性设置为可用的`ThreadPriority`值之一：`Highest`、`AboveNormal`、`Normal`（默认）、`BelowNormal`或`Lowest`。
- en: Generally, higher priority threads will execute before those of lower priority.
    Usually, a thread of `Lowest` priority will not execute until all the higher priority
    threads have been completed. If the `Lowest` priority thread has started and a
    `Normal` thread kicks off, the `Lowest` priority thread will be suspended so that
    the `Normal` thread can be run. These rules are not absolute, but you can use
    them as a guide. Most of the time, you will leave the default of `Normal` for
    your threads.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，优先级较高的线程会先于优先级较低的线程执行。通常，优先级为`Lowest`的线程将不会执行，直到所有优先级更高的线程都已完成。如果`Lowest`优先级的线程已经开始执行，而一个`Normal`优先级的线程启动，则`Lowest`优先级的线程将被挂起，以便运行`Normal`优先级的线程。这些规则并非绝对，但你可以将它们作为参考。大多数情况下，你会为你的线程保留默认的`Normal`优先级。
- en: When there are multiple threads of the same priority, the operating system will
    cycle through them, giving each thread up to a maximum allotment of time before
    suspending work and moving on to the next thread of the same priority. The logic
    will vary by the operating system, and the prioritization of a process can change
    based on whether the application is in the foreground of the UI.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个相同优先级的线程时，操作系统将循环遍历它们，在挂起工作并移动到下一个相同优先级的线程之前，为每个线程分配一个最大时间配额。这种逻辑会因操作系统而异，并且进程的优先级可以根据应用程序是否在UI的前台而改变。
- en: 'Let’s use our network checking code to test thread priorities:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们的网络检查代码来测试线程优先级：
- en: Start by creating a new console application in Visual Studio
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在Visual Studio中创建一个新的控制台应用程序
- en: 'Add a new class to the project, named `NetworkingWork`, and add a method named
    `CheckNetworkStatus` with the following implementation:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为`NetworkingWork`的新类，并添加一个名为`CheckNetworkStatus`的方法，其实现如下：
- en: '[PRE127]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The calling code will be passing a parameter with the priority of the thread
    that is currently executing the message. That will be added as part of the console
    output inside the `for` loop, so users can see which priority threads are running
    first.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码将传递一个参数，该参数包含当前正在执行消息的线程的优先级。这将作为`for`循环内部控制台输出的一个部分被添加，这样用户可以看到哪些优先级的线程首先运行。
- en: 'Next, replace the contents of `Program.cs` with the following code:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Program.cs`的内容替换为以下代码：
- en: '[PRE128]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The code creates five `Thread` objects, each with a different `Thread.Priority`
    value. To make things a little more interesting, the threads are being started
    in reverse order of their priorities. You can try changing this on your own to
    see how the order of execution is impacted.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了五个`Thread`对象，每个对象都有一个不同的`Thread.Priority`值。为了使事情更有趣，线程是按照它们的优先级顺序相反的方式启动的。你可以自己尝试改变这个顺序，看看执行顺序是如何受到影响的。
- en: 'Now run the application and examine the output:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行应用程序并检查输出：
- en: '![Figure 1.3 – Console output from five different threads ](img/Figure_1.3_B18552.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 来自五个不同线程的控制台输出](img/Figure_1.3_B18552.jpg)'
- en: Figure 1.3 – Console output from five different threads
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 来自五个不同线程的控制台输出
- en: You can see that the operating system, which, in my case, is Windows 11, sometimes
    executes lower priority threads before all the higher priority threads have completed
    their work. The algorithm for selecting the next thread to run is a bit of a mystery.
    You should also remember that this is multithreading. Multiple threads are running
    at once. The exact number of threads that can run simultaneously will vary by
    the processor or virtual machine configuration.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在我的案例中，操作系统是Windows 11，有时会在所有优先级较高的线程完成工作之前执行优先级较低的线程。选择下一个要运行的线程的算法有点神秘。你还应该记住，这是多线程。多个线程同时运行。可以同时运行的线程的确切数量将因处理器或虚拟机配置而异。
- en: Let’s wrap things up by learning how to cancel a running thread.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习如何取消一个正在运行的线程来结束本次内容。
- en: Canceling managed threads
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消托管线程
- en: '**Canceling managed threads** is one of the more important concepts to understand
    about managed threading. If you have long-running operations running on foreground
    threads, they should support cancelation. There are times when you might want
    to allow users to cancel the processes through your application’s UI, or the cancelation
    might be part of a cleanup process while the application is closing.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**取消托管线程**是理解托管线程时需要了解的更重要概念之一。如果你在前台线程上运行长时间运行的操作，它们应该支持取消。有时你可能想通过你的应用程序的UI允许用户取消进程，或者取消可能是应用程序关闭时的清理过程的一部分。'
- en: 'To cancel an operation in a managed thread, you will use a `CancellationToken`
    parameter. The `Thread` object itself does not have built-in support for cancellation
    tokens like some of the modern threading constructs .NET. So, we will have to
    pass the token to the method running in the newly created thread. In the next
    exercise, we will modify the previous example to support cancelation:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要在托管线程中取消操作，你将使用`CancellationToken`参数。`Thread`对象本身并不像.NET中的一些现代线程构造函数那样内置对取消令牌的支持。因此，我们必须将令牌传递给在新创建的线程中运行的方法。在下一个练习中，我们将修改前面的示例以支持取消：
- en: 'Start by updating `NetworkingWork.cs` so that the parameter passed to `CheckNetworkStatus`
    is a `CancellationToken` parameter:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新`NetworkingWork.cs`，使得传递给`CheckNetworkStatus`的参数是一个`CancellationToken`参数：
- en: '[PRE129]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The code will keep checking the network status inside a while loop until `IsCancellationRequested`
    becomes `true`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将在`IsCancellationRequested`变为`true`之前，在`while`循环中持续检查网络状态。
- en: 'In `Program.cs`, we’re going to return to working with only one `Thread` object.
    Remove or comment out all of the previous background threads. To pass the `CancellationToken`
    parameter to the `Thread.Start` method, create a new `CancellationTokenSource`
    object, and name it `ctSource`. The cancellation token is available in the `Token`
    property:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中，我们将回到只使用一个`Thread`对象的工作方式。删除或注释掉所有之前的后台线程。为了将`CancellationToken`参数传递给`Thread.Start`方法，创建一个新的`CancellationTokenSource`对象，并将其命名为`ctSource`。取消令牌在`Token`属性中可用：
- en: '[PRE130]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Next, inside the `for` loop, add a `Thread.Sleep(100)` statement to allow `pingThread`
    to execute while the main thread is suspended:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`for`循环内部，添加一个`Thread.Sleep(100)`语句，以便在主线程挂起时允许`pingThread`执行：
- en: '[PRE131]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'After the `for` loop is complete, invoke the `Cancel()` method, join the thread
    back to the main thread, and dispose of the `ctSource` object. The `Join` method
    will block the current thread and wait for `pingThread` to complete using this
    thread:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环完成后，调用`Cancel()`方法，将线程重新连接到主线程，并销毁`ctSource`对象。`Join`方法将阻塞当前线程，等待`pingThread`使用此线程完成：
- en: '[PRE132]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, when you run the application, you will see the network checking stops
    shortly after the final `Thread.Sleep` statement on the main thread has been executed:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你将看到在主线程上的最后一个`Thread.Sleep`语句执行后不久，网络检查停止：
- en: '![Figure 1.4 – Canceling a thread in the console application ](img/Figure_1.4_B18552.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 控制台应用程序中取消线程](img/Figure_1.4_B18552.jpg)'
- en: Figure 1.4 – Canceling a thread in the console application
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 控制台应用程序中取消线程
- en: Now the network checker application is gracefully canceling the threaded work
    before listening for a keystroke to close the application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，网络检查应用程序在监听按键以关闭应用程序之前，优雅地取消了线程工作。
- en: When you have a long-running process on a managed thread, you should check for
    cancellation as the code iterates through loops, begins a new step in a process,
    and at other logical checkpoints in the process. If the operation uses a timer
    to periodically perform work, the token should be checked each time the timer
    executes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在托管线程上有一个长时间运行的过程时，你应该在代码遍历循环、开始过程的下一个步骤以及在过程中的其他逻辑检查点时检查取消。如果操作使用计时器定期执行工作，则应在计时器每次执行时检查令牌。
- en: 'Another way to listen for cancellation is by registering a `Token.Register`
    method inside the managed thread to receive a cancellation callback. The following
    `CheckNetworkStatus2` method will work exactly like the previous example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种监听取消的方式是在托管线程内部注册一个`Token.Register`方法以接收取消回调。下面的`CheckNetworkStatus2`方法将像前面的示例一样工作：
- en: '[PRE133]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Using a delegate like this is more useful if you have multiple parts of your
    code that need to listen for a cancellation request. A **callback** method can
    call several cleanup methods or set another flag that is monitored throughout
    the thread. It encapsulates the cleanup operation nicely.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码中有多个部分需要监听取消请求，使用这样的委托会更有用。一个**回调**方法可以调用几个清理方法或设置另一个在整个线程中被监控的标志。它很好地封装了清理操作。
- en: We will revisit cancellation in [*Chapter 11*](B18552_11_ePub.xhtml#_idTextAnchor173),
    as we introduce new parallelism and concurrency concepts. However, this section
    should provide a solid foundation for understanding what comes next.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第11章*](B18552_11_ePub.xhtml#_idTextAnchor173)中重新讨论取消操作，因为我们将介绍新的并行和并发概念。然而，本节应该为理解接下来要讨论的内容提供一个坚实的基础。
- en: That concludes the final section on managed threads. Let’s wrap things up and
    review what we have learned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于托管线程的最后一节。让我们总结一下，回顾一下我们已经学到的内容。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of managed threading and the `System.Threading.Thread`
    class. You should now have a good understanding of how to create and schedule
    a thread in .NET. You learned about some of the techniques for passing data to
    threads and how to use background threads for non-critical operations, so they
    don’t prevent your application from terminating. Finally, we used two different
    techniques for canceling threads in .NET.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了托管线程的基础和`System.Threading.Thread`类。你现在应该对如何在.NET中创建和调度线程有一个很好的理解。你学习了将数据传递给线程的一些技术以及如何使用后台线程进行非关键操作，这样它们就不会阻止你的应用程序终止。最后，我们使用了.NET中取消线程的两种不同技术。
- en: In the next chapter, [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034), we
    will learn how .NET has simplified and improved parallel programming and concurrency
    for developers over the last 20 years. Significant improvements were added in
    .NET 4.5 in the form of the `async` and `await` keywords, and .NET Core removed
    some of the legacy threading constructs of .NET Framework.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[*第2章*](B18552_02_ePub.xhtml#_idTextAnchor034)中，我们将学习.NET在过去20年中如何简化并改进了开发者的并行编程和并发。在.NET
    4.5中，通过添加`async`和`await`关键字，实现了重大改进，而.NET Core移除了一些.NET Framework的遗留线程结构。
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a managed thread?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是托管线程？
- en: How do you make a background thread?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何创建一个后台线程？
- en: What happens if you try to set the `IsBackground` property of a running thread?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试设置正在运行的线程的`IsBackground`属性会发生什么？
- en: How does .NET handle scheduling managed threads?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET是如何处理托管线程的调度的？
- en: What is the highest thread priority?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最大的线程优先级是什么？
- en: What happens to a thread when you call `Thread.Abort()` in .NET 6?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET 6中调用`Thread.Abort()`时，线程会发生什么？
- en: How can you pass data to a method in a new thread?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将数据传递给新线程中的方法？
- en: How do you register a callback to be invoked when a cancellation is requested
    on a thread?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何注册一个回调，以便在请求取消线程时被调用？
