<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Introduction to .NET Aspire and Microservices</h1>
			<p>Welcome to creating a solution consisting of Microservices. The first chapter provides the foundations for the microservices solution that will be developed in this book.</p>
			<p>Here, you will learn which features .NET Aspire offers for microservices. In this book, we create the <strong class="bold">Codebreaker</strong> solution. You <a id="_idIndexMarker000"/>will learn what Codebreaker is and the parts it consists of. In the last section of this chapter, you’ll learn which Azure services are used while we create the application on the tour up to the last chapter.</p>
			<p>The first chapter lays the foundation.</p>
			<p>In this chapter, you will learn about the advantages that are offered by .NET Aspire on creating microservices and you will gain the foundational knowledge needed to work with this technology, including how to define the app model, what it means for development and deployment, how service discovery is used, and how Azure resources are deployed while debugging the solution locally.</p>
			<p>You will get an overview of the application we built in this book, the parts of the solution, and how the different services are connected.</p>
			<p>In this chapter, you will learn about the following:</p>
			<ul>
				<li>Creating .NET Aspire projects</li>
				<li>The parts of the Codebreaker solution</li>
				<li>Using Microsoft Azure with .NET Aspire</li>
				<li>Azure services used by the Codebreaker solution</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>In this chapter, you need .NET 8 with the .NET Aspire workload, either Visual Studio or Visual Studio Code, Docker Desktop, and a Microsoft Azure subscription. Information about the installation is explained in this chapter and the readme file of the source code repository.</p>
			<p>The code for this chapter can be found in this GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure</a>.</p>
			<p>In the <code>ch01</code> folder, you’ll see the projects with the results of this chapter. You’ll see these folders:</p>
			<ul>
				<li><code>Aspire</code>: This folder contains four projects created with a .NET Aspire template to run a .NET Aspire project including one service and a web application</li>
				<li><code>Azure</code>: This folder contains the same four projects from the previous folder, enhanced by using an Azure resource</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Starting with .NET Aspire</h1>
			<p>.NET Aspire is <a id="_idIndexMarker001"/>a new .NET technology offering tools and libraries that help create, debug, and deploy .NET solutions built using microservices. With all the chapters of this book, we’ll take advantage of .NET Aspire.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this chapter, you’ll get a core understanding of how .NET Aspire works. In all the other chapters, we’ll make use of .NET Aspire and get into the details.</p>
			<p>You can install it using <a id="_idIndexMarker002"/>the .NET <strong class="bold">Command Line Interface</strong> (<strong class="bold">CLI</strong>) or using Visual Studio 2022. The first version of .NET Aspire is based on .NET 8, thus at least .NET 8 is required to use .NET Aspire.</p>
			<p>.NET Aspire requires .NET 8, and can be installed by installing a .NET workload:</p>
			<pre class="console">
dotnet workload install aspire</pre>
			<p>To see the workloads installed, and the version of .NET Aspire, use the following:</p>
			<pre class="console">
dotnet workload list</pre>
			<p>If you use Visual Studio, use the Visual Studio Installer, and select the <strong class="bold">.NET Aspire SDK</strong> component to install .NET Aspire.</p>
			<p>.NET Aspire apps <a id="_idIndexMarker003"/>are designed to run in containers. Running the application locally, projects run directly on the system without the need for a Docker engine. Docker containers are used when deploying the solution. We can (and will) use available Docker images as part of the application. Here, the container runtime is required to run locally. In this book, we use the most used container runtime – <strong class="bold">Docker Desktop</strong>. Docker Desktop is<a id="_idIndexMarker004"/> free for personal use and for small companies. .NET Aspire also supports running containers<a id="_idIndexMarker005"/> with <strong class="bold">Podman</strong>.</p>
			<p>After the installation of .NET Aspire, create a new project.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Creating a .NET Aspire project</h2>
			<p>When .NET Aspire <a id="_idIndexMarker006"/>is installed, you can create a new project containing an API service and a Blazor client application using the following:</p>
			<pre class="console">
dotnet new aspire-starter -o AspireSample</pre>
			<p>With this template, four projects are created:</p>
			<ul>
				<li><code>AspireSample.ApiService</code>: This project contains a REST service that uses ASP.NET Core minimal APIs</li>
				<li><code>AspireSample.Web</code>: An ASP.NET Core Blazor application that sends requests to the API service</li>
				<li><code>AspireSample.ServiceDefaults</code>: A library project with shared initialization code for all services of the solution</li>
				<li><code>AspireSample.AppHost</code>: The app host project defines the app model of the solution, and how all the resources are connected</li>
			</ul>
			<p>Let’s build and start the solution next.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>The .NET Aspire dashboard</h2>
			<p>When you start the<a id="_idIndexMarker007"/> newly created project (the AppHost project needs to be the starting project), a console opens, showing the logs of the AppHost, and the browser opens a dashboard that shows the resources of the project, as you can see in <em class="italic">Figure 1</em><em class="italic">.1</em>.</p>
			<div><div><img src="img/B21217_01_01.jpg" alt="Figure 1.1 – Aspire dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Aspire dashboard</p>
			<p>With the .NET Aspire dashboard, you can see the resources running (<code>apiservice</code> and <code>webfrontend</code> in this image), the state of the resources, and the endpoints, and can access details and logs. In the left pane, you have access to logs, traces, and metrics data. While<a id="_idIndexMarker008"/> the dashboard<a id="_idIndexMarker009"/> is typically not used in production environments (we have <strong class="bold">Prometheus</strong>, <strong class="bold">Grafana</strong>, <strong class="bold">Azure Application Insights</strong>, and other environments), it’s<a id="_idIndexMarker010"/> great to know all this information during development time. Are there memory leaks with services? How does the interaction with services happen? Where are the bottlenecks? You can find this information using the dashboard. This is discussed in detail in <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Because the .NET Aspire dashboard is that great, it’s available as a Docker image and can be used in small scenarios in production as well, but it has limitations outside of the development environment.</p>
			<p>When you click on the link of the <code>webfrontend</code>, the application opens. In case you already created Blazor applications, you <a id="_idIndexMarker011"/>already know the links from the application, as shown in <em class="italic">Figure 1</em><em class="italic">.2</em>.</p>
			<div><div><img src="img/B21217_01_02.jpg" alt="Figure 1.2 – webfrontend"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – webfrontend</p>
			<p>As you click the <code>webfrontend</code> makes a request to <code>apiservice</code> for random weather information.</p>
			<p>The app is running, so let’s get into the generated code for .NET Aspire next.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>The .NET Aspire app model</h2>
			<p>To <a id="_idIndexMarker012"/>start digging into .NET Aspire, you need to learn the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = <strong class="bold">DistributedApplication.CreateBuilder(args);</strong>
var apiService = builder.<strong class="bold">AddProject</strong>&lt;Projects.AspireSample_ApiService&gt;(<strong class="bold">"apiservice"</strong>);
// code removed for brevity</pre>
			<p>If you are used to the app builder pattern with .NET applications and the <code>Host</code> class to configure the DI container, app configuration, and logging, you can see some similarities. Here, a <code>DistributedApplication</code> class is used to create <code>IDistributedApplicationBuilder</code> with the <code>CreateBuilder</code> method. The returned builder is used to define all the resources needed by the solution. With the generated code, two projects are mapped using the <code>AddProject</code> method. The projects are referenced with a generic type, for example, <code>Projects.AspireSample_ApiService</code>. This type was created by adding a project reference to the <code>AspireSample.ApiService</code> project. You can see the reference when you open the <code>AspireSample.AppHost.csproj</code> project file.</p>
			<p>Using <a id="_idIndexMarker013"/>project types with <code>AddProject</code> is convenient, but it’s not a requirement. You can also pass a string of a directory where the project resides.</p>
			<p>Other than adding projects, it’s possible to add executables (<code>AddExecutable</code>) or Docker images (<code>AddContainer</code>).</p>
			<p>.NET Aspire also offers a huge list of predefined resources, for example, RabbitMQ, Kafka, Redis, and SQL Server, and resources running within Microsoft Azure, such as Azure Cosmos DB, Azure Key Vault, and Azure Event Hub. To add resources to the app model, NuGet packages are prefixed with <code>Aspire.Hosting</code> and <code>Aspire.Hosting.Azure</code> needs to be added.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this book, many new resources are added to the Codebreaker solution. <a href="B21217_03.xhtml#_idTextAnchor063"><em class="italic">Chapter 3</em></a> adds SQL Server and Azure Cosmos DB, <a href="B21217_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a> adds Docker containers, <a href="B21217_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a> adds Azure App Configuration and Azure Key Vault, <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a> adds Azure Log Analytics, Prometheus, and Grafana, <a href="B21217_13.xhtml#_idTextAnchor317"><em class="italic">Chapter 13</em></a> adds Azure SignalR Services, and so on.</p>
			<p>The name <code>"apiservice"</code> that’s passed as a parameter passed to the <code>AddProject</code> method defines the name of the resource. We’ll use this name later in the <em class="italic">Using service </em><em class="italic">discovery</em> section.</p>
			<p><code>AddProject</code> returns an object of the <code>IResourceBuilder&lt;ProjectResource&gt;</code> type. The <code>IResourceBuilder</code> objects can be used to connect multiple resources within the app model. The <code>ProjectResource</code> type derives from the <code>Aspire.Hosting.ApplicationModel.Resource</code> base class and implements several resource interface types, such as <code>IResourceWithEnvironment</code> and <code>IResourceWithServiceDiscovery</code>.</p>
			<p>Let’s use this<a id="_idIndexMarker014"/> resource object to connect another resource:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
// code removed for brevity
builder.<strong class="bold">AddProject</strong>&lt;Projects.AspireSample_Web&gt;("webfrontend")
<strong class="bold">  .WithExternalHttpEndpoints()</strong>
<strong class="bold">  .WithReference(apiService);</strong>
builder.Build().Run();</pre>
			<p>The <code>apiService</code> variable returned from the first <code>AddProject</code> method is referenced with the second project – a web frontend – using the <code>WithReference</code> method. This allows accessing the web frontend to access the API service. The URL of the API service is assigned as an environment variable to the web frontend – this is what the <code>IResourceWithServiceDiscovery</code> interface is used for. While the API service does not need to be accessed externally (only the web frontend needs access), the web frontend should be accessible from the outside. That’s why the <code>WithExternalHttpEndpoints</code> method is used with the web frontend project. This configuration information is used to specify how the Ingress controller added as a proxy to the resource is configured.</p>
			<p>Before looking into the projects that are referenced by the AppHost, let’s get into the shared <code>AspireSample.ServiceDefaults</code> project.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>The shared project for common configuration</h2>
			<p>The <code>AspireSample.ServiceDefaults</code> project is a library with a common configuration <a id="_idIndexMarker015"/>that can be used by all the resource projects:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.ServiceDefaults/Extensions.cs</p>
			<pre class="source-code">
public static class Extensions
{
<strong class="bold">  public static IHostApplicationBuilder AddServiceDefaults(this </strong>
<strong class="bold">    IHostApplicationBuilder builder)</strong>
  {
    builder.ConfigureOpenTelemetry();
    builder.AddDefaultHealthChecks();
<strong class="bold">    builder.Services.AddServiceDiscovery();</strong>
    builder.Services.<strong class="bold">ConfigureHttpClientDefaults</strong>(http =&gt;
    {
<strong class="bold">      http.AddStandardResilienceHandler();</strong>
<strong class="bold">      http.AddServiceDiscovery();</strong>
    });
    return builder;
  }
  // code removed for brevity</pre>
			<p>This shared <a id="_idIndexMarker016"/>project contains the <code>AddServiceDefaults</code> extension method that implements a common configuration for the resource applications. With the implementation, <code>ConfigureOpenTelemetry</code> is invoked, which is another extension method defined by the <code>Extensions</code> class. The parts that are common for logging, metrics, and distributed tracing are implemented here. This is covered in <a href="B21217_11.xhtml#_idTextAnchor263"><em class="italic">Chapter 11</em></a>. <code>AddDefaultHealthChecks</code> configures health checks for the services, which can include health checks for the .NET Aspire components that are used.</p>
			<p><code>AddServiceDiscovery</code> makes use of the <code>Microsoft.Extensions.ServiceDiscovery</code> library, which is also new since the first release of .NET Aspire, but can also be used independently of .NET Aspire. The <code>AddServiceDiscovery</code> method registers default service endpoint resolvers. Service discovery is not only configured with the DI container but also with the configuration of the HTTP client, with the lambda parameter of the <code>ConfigureHttpClientDefaults</code> method. Service discovery is discussed in the next section. <code>ConfigureHttpClientDefaults</code> is part of the <code>Microsoft.Extensions.Http</code> library, the HTTP client factory. The package that’s referenced from the <code>ServiceDefaults</code> library is <code>Microsoft.Extensions.Http.Resiliency</code>. This library is new since .NET 8 and offers<a id="_idIndexMarker017"/> extensions to the Polly library. With a distributed application, invocations sometimes fail on transient issues. Retrying invocations to these resources can succeed when invoked another time. This functionality is built into .NET Aspire with default resiliency configuration in <code>AddStandardResilienceHandler</code>.</p>
			<p>But now, let’s get into service discovery.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Using service discovery</h2>
			<p><code>webfrontend</code> needs<a id="_idIndexMarker018"/> to know about the link of <code>apiservice</code> to get the weather information. This link is different depending on the environment<a id="_idIndexMarker019"/> the solution is running with. Running the application locally on the development system, we use localhost links with different port numbers, and depending on the environments where the solution is running (for example, Azure Container App environments, Kubernetes, etc.), different configurations are required.</p>
			<p>With the new service discovery, logical names can be used for the services, which are resolved using different providers. Thus, the same functionality works in different environments.</p>
			<p>The Blazor client application configures <code>HttpClient</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.Web/Program.cs</p>
			<pre class="source-code">
builder.Services.AddHttpClient&lt;WeatherApiClient&gt;(client =&gt;
{
<strong class="bold">  client.BaseAddress = new("https+http://apiservice");</strong>
});
// code removed for brevity</pre>
			<p>The <code>apiservice</code> name<a id="_idIndexMarker020"/> comes from the app model definition – the name that has been passed to the <code>AddProject</code> method. Before the colon, the schema, for example, <code>http</code> or <code>https</code> can be specified. Separating schemas with <code>+</code> allows the use of multiple schemas, and the first one is preferred.</p>
			<p>The <code>AddServiceDiscovery</code> method<a id="_idIndexMarker021"/> that was added to the DI container earlier adds a configuration-based endpoint resolver by default. With this, the configuration can be added to a JSON configuration file, for example, as follows:</p>
			<pre class="source-code">
{
  "<strong class="bold">Services</strong>": {
    "<strong class="bold">apiservice</strong>": {
      "<strong class="bold">https</strong>": [
        "localhost:8087",
        "10.466.24.90:80"
      ]
    }
  }
}</pre>
			<p>With the configuration, the section needs to be named <code>Services</code>. Within the <code>Services</code> section, the named service is looked for (<code>apiservice</code>), and there, the values below the schema name (<code>https</code>) are resolved. The port numbers are randomly created and will differ with your environment.</p>
			<p>With the AppHost, as <code>apiservice</code> is referenced from the web frontend, the URIs to the API service are added as environment variables. Open the .NET Aspire dashboard, and in the <code>webfrontend</code>. There, you can see the <code>services__apiservice_http__0</code> and <code>services__apiservice_https_0</code> environment variables, and the <code>http://localhost:5395</code>, and <code>https://localhost:7313</code> values. The<a id="_idIndexMarker022"/> URIs are specified within <code>Properties/launchsettings.json</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.ApiService/Properties/launchSettings.json</p>
			<pre class="source-code">
"profiles": {
  "http": {
    "commandName": "Project",
    "dotnetRunMessages": true,
    "launchBrowser": true,
    "launchUrl": "weatherforecast",
<strong class="bold">    "applicationUrl": "http://localhost:5395",</strong>
    "environmentVariables": {
      "ASPNETCORE_ENVIRONMENT": "Development"
    }
  },
  "https": {
    "commandName": "Project",
    "dotnetRunMessages": true,
    "launchBrowser": true,
    "launchUrl": "weatherforecast",
<strong class="bold">    "applicationUrl": "https://localhost:7313;http://localhost:5395",</strong>
    "environmentVariables": {
      "ASPNETCORE_ENVIRONMENT": "Development"
    }
  }
}</pre>
			<p>The <code>applicationUrl</code> setting defines the URLs used on starting the application, and this is the link that is used to add it to the environment variable. Because environment variables are part of the .NET configuration, these values are retrieved by the service discovery configuration provider.</p>
			<p>Azure Container Apps<a id="_idIndexMarker023"/> and Kubernetes offer service <a id="_idIndexMarker024"/>discovery features without using a service discovery library. With applications deployed there, a pass-through provider is configured using <code>DnsEndPoint</code>.</p>
			<p>Running the .NET Aspire solution locally, the process of <code>webfrontend</code> and <code>apiservice</code> use random ports. A reverse proxy is automatically added before these processes, and the reverse proxy is accessible via the configured launch settings.</p>
			<p>This allows the changing of the number of replicas with the app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/Program.cs</p>
			<pre class="source-code">
var apiService = builder.AddProject&lt;Projects.AspireSample_ApiService&gt;("apiservice")
<strong class="bold">  .WithReplicas(3);</strong></pre>
			<p>With the app model configuration in the AppHost, using <code>WithReplicas(3)</code> starts three instances of the service using three random ports, and the same port number from the reverse proxy as shown in <em class="italic">Figure 1</em><em class="italic">.3</em>.</p>
			<div><div><img src="img/B21217_01_03.jpg" alt="Figure 1.3 – Multiple replicas"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Multiple replicas</p>
			<p>You can see three <code>apiservice-</code> services running with different postfixes, and three processes with the same port number, as shown with the endpoints. The endpoint defined from the<a id="_idIndexMarker025"/> launch settings is the endpoint of the reverse proxy. When you open <strong class="bold">Details</strong>, you<a id="_idIndexMarker026"/> can see different target ports with every service. The reverse proxy acts as a load balancer to choose one of the replicas.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To start the solution with the <code>http</code> launch profile, you need to add the <code>ASPIRE_ALLOW_UNSECURED_TRANSPORT</code> environment variable to the launch settings of the AppHost project and set it to <code>true</code>.</p>
			<p>This was an important core functionality from .NET Aspire. However, there’s more.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>.NET Aspire components</h2>
			<p>.NET Aspire components <a id="_idIndexMarker027"/>make it easy to use Microsoft and third-party features and services from within the applications that are configured. Azure Cosmos DB, Pomelo MySQL Entity Framework Core, and SQL Server are components available to access databases, and RabbitMQ, Apache Kafka, and Azure Service Bus are components for messaging. There’s a list available at <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview</a>.</p>
			<p>To use a component, typically with the AppHost, a resource needs to be configured by adding a host NuGet package, for example, for the Azure Cosmos DB EF Core component, you would add the <code>Aspire.Hosting.Azure.CosmosDB</code> package. The component itself is then used by adding the <code>Aspire.Microsoft.EntityFrameworkCore.Cosmos</code> package to the service that accesses the database, for example, the API service.</p>
			<p>What does a component have to offer? Do you know what names are used by a technology to turn on logging metrics data? Aspire components know this, and it’s easy to configure it. When an Azure Cosmos DB resource is added to the app model, and is referenced by a service project, the connection string is configured as an environment variable (or stored within a secret store) and can be accessed by the project that needs the connection.</p>
			<p>In many of the book chapters, we’ll add some new components, thus we don’t get into more details here.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Creating the app model manifest</h2>
			<p>With<a id="_idIndexMarker028"/> the app model defined in the <code>AppHost</code> project, we can create a JSON manifest file that describes the resources. You need to stop the project to allow a rebuild if it’s still running:</p>
			<pre class="console">
cd ApireSample.AppHost
dotnet run --publisher manifest --output-path aspire-manifest.json</pre>
			<p>An extract of this manifest file is shown in the following snippet:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Aspire/AspireSample.AppHost/aspire-manifest.json</p>
			<pre class="source-code">
"webfrontend": {
  "type": "project.v0",
  "path": "../AspireSample.Web/AspireSample.Web.csproj",
  "env": {
    "services__apiservice__http__0": "{apiservice.bindings.http.url}",
    "services__apiservice__https__0": "{apiservice.bindings.https.url}"
  },
  "bindings": {
    "https": {
      "scheme": "https",
      "protocol": "tcp",
      "transport": "http",
      "external": true
    }
  }
}</pre>
			<p>The <a id="_idIndexMarker029"/>manifest contains information about the resource type, environment variables, binding, and more. With the app model, we can also specify the use of Azure resources. This manifest file can now be used by tools to deploy the solution, (e.g., by using the Azure Developer CLI to deploy it to Microsoft Azure). Creating Azure resources is covered in <a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a> and continued from there in other chapters.</p>
			<p>Using Aspir8 (an open-source project, see <a href="https://github.com/prom3theu5/aspirational-manifests/">https://github.com/prom3theu5/aspirational-manifests/</a>), it’s possible to deploy the solution to a Kubernetes cluster. This is used in <a href="B21217_16.xhtml#_idTextAnchor373"><em class="italic">Chapter 16</em></a>.</p>
			<p>The app model can be customized based on different launch profiles. With this, different manifest files can be created to deploy to (e.g., Azure and use specific Azure resources and to an on-premises Kubernetes cluster).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The AppHost project containing the app model is used when starting and debugging the project during development. For deployment, the manifest of the app model is used. When running the solution in the production environment, the app host is no longer in action.</p>
			<p>.NET Aspire is used in this book from the first to the last chapter. Let’s look into what we are building.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Codebreaker – the solution</h1>
			<p>The <a id="_idIndexMarker030"/>Codebreaker solution is a traditional game to solve a set of colors. With one game type, the player needs to place four colors (which can be duplicates) from a list of six different colors. The correct colors are chosen randomly by the game service. With every move the player makes, an answer is returned: for every color that is correct and positioned at the correct place, a black peg is returned. For every color<a id="_idIndexMarker031"/> that is correct but wrongly positioned, a white peg is returned. The player now has up to 12 moves to find the correct solution. <em class="italic">Figure 1</em><em class="italic">.4</em> shows a game run using a Blazor client application.</p>
			<div><div><img src="img/B21217_01_04.jpg" alt="Figure 1.4 – Blazor client application"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Blazor client application</p>
			<p>This gameplay shows that the solution was found after five moves. In this case, the correct result was yellow – black – red – black. The first selection was red – green – blue – yellow, with a result of two white pegs. With the fifth move, yellow – black – red – black was selected and four black pegs were returned, which means this is the correct move.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Creating client applications is not part of this book (just a simple console application accessing the API is done in <a href="B21217_04.xhtml#_idTextAnchor092"><em class="italic">Chapter 4</em></a>). However, the source code for several client applications is available at <a href="https://github.com/codebreakerapp">https://github.com/codebreakerapp</a>.</p>
			<p>Creating a <a id="_idIndexMarker032"/>service to run some game rules seems like a simple task that doesn’t need a microservices architecture. However, there’s more, as shown in the sequence diagrams in <em class="italic">Figure 1</em><em class="italic">.5</em> and <em class="italic">Figure 1</em><em class="italic">.6</em>.</p>
			<div><div><img src="img/B21217_01_05.jpg" alt="Figure 1.5 – The Codebreaker play games sequence"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Codebreaker play games sequence</p>
			<p>Multiple services are needed with the solution. The game API service is not only invoked by UIs used by human players; a bot service, which can be triggered on receiving a message, plays multiple games on its own, and the game API service writes information about games and <a id="_idIndexMarker033"/>every move set to a database.</p>
			<div><div><img src="img/B21217_01_06.jpg" alt="Figure 1.6 – Codebreaker game completion sequence"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Codebreaker game completion sequence</p>
			<p>On completion of a game, the game API service not only writes this information to a database but also sends events. These events are received by a live service and a ranking service. The live service is used by live clients to monitor running games using ASP.NET Core SignalR. The ranking service writes completed games to its own database, which can be used by clients to get daily, weekly, and monthly game ranks. A service running Microsoft YARP is used as well to authenticate users and forward requests to the different services.</p>
			<p>The Codebreaker solution makes use of several Azure services, as discussed next.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Using Microsoft Azure</h1>
			<p>To create and <a id="_idIndexMarker034"/>run the code from this book, you also need to have an Azure subscription. You can activate Microsoft Azure for free at <a href="https://azure.microsoft.com/free">https://azure.microsoft.com/free</a>, which gives you an amount of about $200 Azure credits that are available for the first 30 days and several services that can be used for free for the time after.</p>
			<p>What many developers miss is that if you have a Visual Studio Professional or Enterprise subscription, you also have a free amount of Azure resources every month. You just need to activate this with your Visual Studio subscription: <a href="https://visualstudio.microsoft.com/subscriptions/">https://visualstudio.microsoft.com/subscriptions/</a>.</p>
			<p>To<a id="_idIndexMarker035"/> create and manage resources, we use the Azure Portal, the Azure CLI, and the Azure Developer CLI. On Windows, you can install them with the following:</p>
			<pre class="console">
winget install Microsoft.AzureCLI
winget install Microsoft.Azd</pre>
			<p>To install these tools on Mac and Linux, check <a href="https://learn.microsoft.com/en-us/cli/azure/install-azure-cli">https://learn.microsoft.com/en-us/cli/azure/install-azure-cli</a> and <a href="https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd">https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/install-azd</a>.</p>
			<p>Let’s look at the resources used with Microsoft Azure.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>Azure resources used by Codebreaker</h2>
			<p>To see<a id="_idIndexMarker036"/> what Azure resources are used, check <em class="italic">Figure 1</em><em class="italic">.7</em>.</p>
			<div><div><img src="img/B21217_01_07.jpg" alt="Figure 1.7 – Azure resources for Codebreaker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Azure resources for Codebreaker</p>
			<p>The <a id="_idIndexMarker037"/>compute services where the solution is running is an Azure Container App environment. This is a service that abstracts a Kubernetes cluster. The bot service, game APIs, live service, ranking service, and the gateway using YARP run within Azure Container Apps. The Azure Storage queue is used from the bot service: as a message arrives in the queue, the bot service is triggered to play a series of games. The bot service can be used from all client apps as well – indirectly via a gateway, implemented with YARP. The game API service writes games to the Azure Cosmos DB and caches games with a Redis cluster. As games are completed, game events are pushed to the Azure Event Hub. The live service and ranking service are subscribers to the Event Hub. The live service uses ASP.NET Core SignalR, and to reduce the load of this service, the Azure SignalR service is used.</p>
			<p>What’s commonly used is the Azure App Configuration for application configuration values and feature management, Azure Key Vault to store secrets, Azure Active Directory B2C for user registrations, and Log Analytics and Application Insights to monitor the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Starting with a small version of Codebreaker, not that many Azure services would be required to use. For a flexible and scalable solution, which might be accessed worldwide, and to learn about all the different aspects of microservices, all these services are in use. Don’t be afraid of the cost when deploying the services with your Azure subscription. As long as you don’t create a huge load (which we do in <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>), the cost stays very small, and by far you will not use the full $200 available with the free subscription when you delete the resources again after use.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Azure provisioning from the development environment</h2>
			<p>Your .NET Aspire solution can easily integrate with Microsoft Azure and deploy resources while debugging the solution.</p>
			<p>By<a id="_idIndexMarker038"/> debugging the solution locally, not all resources need to be deployed to Azure. The service projects can run locally while testing and don’t need to be deployed. With Azure Cosmos DB, a Docker container or a locally installed emulator is available. This is not possible with all resources, for example, Azure Key Vault or Azure Application Insights.</p>
			<p>To deploy these resources automatically, .NET Aspire needs access to your subscription. To do this, first, log in to your Azure subscription with the Azure CLI:</p>
			<pre class="console">
az login</pre>
			<p>This opens a browser, and you can log in with your Azure subscription.</p>
			<p>In case you have multiple subscriptions, check the Azure CLI is set to the current one:</p>
			<pre class="console">
az account show</pre>
			<p>This shows the current active subscription. In case a different one should be used, use <code>az account list</code> to list all subscriptions, and <code>az account set –subscription &lt;your subscription id&gt;</code> to set the current subscription to a different one. Remember the value that’s listed with <code>id</code> – this is the subscription ID that’s needed with the next steps.</p>
			<p>Now, we need to connect the project to the subscription and specify some settings. It’s best to put this information within user secrets; this shouldn’t be put into source code repositories.</p>
			<p>In case user secrets are not configured yet with the <code>AppHost</code>, initialize it:</p>
			<pre class="console">
cd AspireSample.AppHost
dotnet user-secrets init</pre>
			<p>The configurations we need are the following:</p>
			<pre class="console">
dotnet user-secrets set Azure:SubscriptionId &lt;your subscription id&gt;
dotnet user-secrets set Azure:AllowResourceGroupCreation true
dotnet user-secrets set Azure:ResourceGroup rg-firstsample
dotnet user-secrets set Azure:Location westeurope
dotnet user-secrets set Azure:CredentialSource AzureCli</pre>
			<p>With <code>SubscriptionId</code>, you specify the subscription where resources are created. The <a id="_idIndexMarker039"/>resource group you specify with the value for <code>ResourceGroup</code> is used to create all the resources needed. The resource group will be created if you set <code>AllowResourceGroupCreation</code> to <code>true</code>. Otherwise, you need to create the resource group first. With the <code>Location</code> setting, specify your preferred location. To see the locations available with your subscription, use <code>az account list-locations -</code><code>o table</code>.</p>
			<p>Setting the <code>CredentialSource</code> setting to <code>AzureCli</code> specifies that you are using the same account you just used to log in with the Azure CLI to create the resources. Without this setting, <code>DefaultAzureCredential</code> will be used, which tries to use multiple account types with a predefined list until one succeeds. This includes Visual Studio, Azure CLI, PowerShell, Azure Developer CLI, and other credentials. Here, credentials might be used which don’t have access to the subscription. In my experience, it’s better to supply the credentials explicitly.</p>
			<p>To see all the secrets, use the following:</p>
			<pre class="console">
dotnet user-secrets list</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Using Visual Studio, you can connect the project to Azure by using the Solution Explorer. Within the AppHost project, select <strong class="bold">Connected Services</strong>, open the context menu, and select <strong class="bold">Azure Resource Provisioning Settings</strong>. This opens a dialog to select the subscription, location, and resource group.</p>
			<p>Next, let’s add the <code>Aspire.Hosting.Azure.KeyVault</code> NuGet package to the AppHost<a id="_idIndexMarker040"/> project, and update the app model:</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
<strong class="bold">var keyVault = builder.AddAzureKeyVault("secrets");</strong>
var apiService = builder.AddProject&lt;Projects.AspireSample_ApiService&gt;("apiservice")
  .WithReplicas(3)
<strong class="bold">  .WithReference(keyVault);</strong></pre>
			<p>The <code>AddAzureKeyVault</code> method creates a key vault named <code>secrets</code>. This is referenced from the <code>apiservice</code> project.</p>
			<p>When you start the AppHost now, the key vault will be created within Azure. Opening the <a id="_idIndexMarker041"/>Azure portal at <a href="https://portal.azure.com">https://portal.azure.com</a>, you will see the resource group, and within the resource group, the Azure Key Vault is created.  If you check the user secrets again, an <code>Azure:Deployments</code> section is added, which contains links to the resources created. This information is used to find the resources again, and they don’t need to be published again the next time you start the application.</p>
			<p>When you are finished with this chapter, just delete the complete resource group from the portal, so no additional cost applies.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To publish all the resources including the projects to Azure, you can use the Azure Developer CLI. This is covered in <a href="B21217_06.xhtml#_idTextAnchor137"><em class="italic">Chapter 6</em></a>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Summary</h1>
			<p>In this chapter, you learned about the core features of .NET Aspire, which includes tooling, orchestration, and Aspire components. You learned how resources are connected by the Aspire app model, and how service discovery is done. You’ve seen how to create a manifest describing the app model, which can be used by tools to deploy the solution.</p>
			<p>With the Codebreaker solution, you learned about the rules of the game and the parts of the application that are created from the second to the last chapter.</p>
			<p>Now, you know the different Microsoft Azure services that are used by the Codebreaker solution when running in Azure. An alternative to these services is offered as well to run the complete solution in an on-premises environment (which can also be hosted in the Azure cloud this way).</p>
			<p>From the next chapter on, we’ll start developing the Codebreaker solution. In <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, we will create REST services using ASP.NET Core minimal APIs to play games. We’ll test this API using HTTP files.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Further reading</h1>
			<p>To learn more about the topics discussed in this chapter, you can refer to the following links:</p>
			<ul>
				<li><strong class="bold">.NET Aspire setup and </strong><strong class="bold">tooling</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling</a></li>
				<li><strong class="bold">.NET Aspire </strong><strong class="bold">components</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview">https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/components-overview</a></li>
				<li><strong class="bold">.NET Aspire manifest </strong><strong class="bold">format</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format">https://learn.microsoft.com/en-us/dotnet/aspire/deployment/manifest-format</a></li>
				<li><strong class="bold">GitHub repository for </strong><strong class="bold">Aspir8</strong>: <a href="https://github.com/prom3theu5/aspirational-manifests">https://github.com/prom3theu5/aspirational-manifests</a></li>
			</ul>
		</div>
	</body></html>