<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor296"/>8</h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor297"/>Exploring Graphs</h1>
<p>In the previous chapter, you learned about trees. However, did you know that such data structures also belong to graphs? But what is a graph and how can you use one in your applications? You’ll find the answers to these and many other questions in this chapter!</p>
<p>First, basic information about graphs will be presented, including an explanation of <strong class="bold">nodes</strong> and <strong class="bold">edges</strong>. As graphs are data structures that are commonly used in practice, you will also see some of their applications, such as for storing data of friends on social media or for finding a road in a city. Then, the topic of graph <strong class="bold">representation</strong> will be covered, namely using an adjacency list and matrix.</p>
<p>After this short introduction, you will learn how to implement a graph in the C# language. Moreover, you will learn about two modes of graph <strong class="bold">traversal</strong>, namely <strong class="bold">depth-first search</strong> (<strong class="bold">DFS</strong>) and <strong class="bold">breadth-first search</strong> (<strong class="bold">BFS</strong>). For both of them, the code and a detailed description will be shown.</p>
<p>Next, you will learn about the subject of <strong class="bold">minimum spanning trees</strong> (<strong class="bold">MSTs</strong>), as well as two algorithms for their<a id="_idIndexMarker719"/> creation, namely Kruskal’s and Prim’s. Such algorithms will be presented as descriptions, code snippets, and illustrations. Moreover, an example real-world application will be provided.</p>
<p>Another interesting graph-related problem is the <strong class="bold">coloring</strong> of nodes, which will be taken into account in the following part of this chapter. Finally, the topic of finding the <strong class="bold">shortest path</strong> in a graph will be analyzed using Dijkstra’s algorithm.</p>
<p>As you can see, the topic of graphs involves many interesting problems and only some of them will be mentioned in this book. However, the chosen subjects are suitable for presenting various graph-related aspects in the context of the C# language. Are you ready to dive into the topic of graphs? If so, start reading this chapter!</p>
<p>In this chapter, the following topics will be covered:</p>
<ul>
<li>The concept of graphs</li>
<li>Applications</li>
<li>Representations</li>
<li>Implementation</li>
<li>Traversal</li>
<li>Minimum spanning tree</li>
<li>Coloring</li>
<li>Shortest pat<a id="_idTextAnchor298"/>h<a id="_idTextAnchor299"/></li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor300"/>The concept of graphs</h1>
<p>Let’s start with the question <em class="italic">what is a graph?</em> Broadly speaking, <strong class="bold">a graph is a data structure that consists of </strong><strong class="bold">nodes</strong><strong class="bold"> (also called </strong><strong class="bold">vertices</strong><strong class="bold">) and </strong><strong class="bold">edges</strong><strong class="bold">. Each edge connects two nodes</strong>. A graph<a id="_idIndexMarker720"/> data structure does not require any specific <a id="_idIndexMarker721"/>rules regarding<a id="_idIndexMarker722"/> connections between nodes, as shown in the following diagram:</p>
<div><div><img alt="Figure 8.1 – Illustration of a graph" src="img/B18069_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Illustration of a graph</p>
<p>This concept seems very simple, doesn’t it? Let’s try to analyze the preceding graph to eliminate any doubts. It contains <strong class="bold">9 nodes</strong> with numbers between <strong class="bold">1</strong> and <strong class="bold">9</strong> as values. Such nodes are connected by <strong class="bold">11 edges</strong>, such as between nodes <strong class="bold">2</strong> and <strong class="bold">4</strong>. Moreover, a graph can contain <strong class="bold">cycles</strong> – for example, with<a id="_idIndexMarker723"/> nodes indicated by <strong class="bold">2</strong>, <strong class="bold">3</strong>, and <strong class="bold">4</strong> – as well as separate groups of nodes, which are not connected.</p>
<p>However, what about the topic of parent and child nodes, which you know from learning about trees? As there are no specific rules about connections in a graph, such concepts are not used in this case.</p>
<p class="callout-heading">Imagine a graph</p>
<p class="callout">If you want to better visualize a graph, take your eyes off this book for a moment and look at a map showing the most important roads in your country, such as highways or expressways. Each fragment of such a road connects two towns and has a certain length. Once you have drawn such a structure on a piece of paper, you will see that thanks to it, you can find a route between two towns, along with the total distance of the entire route. Did you know you just created a graph? Individual towns are nodes, and the lines connecting them are edges. The distance between the two towns is the edge weight. It’s so simple when you can relate theory to practice, isn’t it? Now, it’s high time to put the map aside and focus on learning about the last data structure that will be covered in this book, namely the graph.</p>
<p>Some more comments are necessary<a id="_idIndexMarker724"/> for edges in a graph. In the preceding diagram, you can <a id="_idIndexMarker725"/>see a graph where all the nodes are connected with <strong class="bold">undirected edges</strong> – that is, <strong class="bold">bidirectional edges</strong>. They indicate that <strong class="bold">it is possible to travel between nodes in both directions</strong> –  for example, from node <strong class="bold">2</strong> to <strong class="bold">3</strong> and from node <strong class="bold">3</strong> to <strong class="bold">2</strong>. Such edges <a id="_idIndexMarker726"/>are presented <a id="_idIndexMarker727"/>graphically as <strong class="bold">straight lines</strong>. When a graph contains undirected edges, it is an <strong class="bold">undirected graph</strong>.</p>
<p>However, what about a scenario when you need to indicate that <strong class="bold">traveling between nodes is possible only in one direction</strong>? In such a case, you can use <strong class="bold">directed edges</strong> – that is, <strong class="bold">unidirectional edges</strong> – which <a id="_idIndexMarker728"/>are presented graphically<a id="_idIndexMarker729"/> as <strong class="bold">straight lines with arrows indicating the direction of an edge</strong>. If a graph <a id="_idIndexMarker730"/>contains directed edges, it can be named a <strong class="bold">directed graph</strong>.</p>
<p class="callout-heading">What about self-loops?</p>
<p class="callout">A graph can also contain <strong class="bold">self-loops</strong>. Each is an <a id="_idIndexMarker731"/>edge that connects a given node with itself. However, such a topic is outside the scope of this book and won’t be taken into account in the examples shown in this chapter.</p>
<p>An example directed graph is presented in the following diagram on the right, while an undirected one is shown on the left:</p>
<div><div><img alt="Figure 8.2 – The difference between undirected and directed graphs" src="img/B18069_08_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The difference between undirected and directed graphs</p>
<p>As a short explanation, the directed graph (shown on the right in the preceding diagram) contains <strong class="bold">8 nodes</strong> connected by <strong class="bold">15 unidirectional edges</strong>. For example, they indicate that it is possible to travel between node <strong class="bold">1</strong> and <strong class="bold">2</strong> in both directions, but it is allowed to travel from the node <strong class="bold">1</strong> to <strong class="bold">3</strong> only<a id="_idIndexMarker732"/> in one direction, so it is impossible to reach node <strong class="bold">1</strong> from <strong class="bold">3</strong> directly.</p>
<p>The division between undirected and directed edges is not the only one. You can also specify <strong class="bold">weights</strong> (also referred to as <strong class="bold">costs</strong>) for <a id="_idIndexMarker733"/>particular edges to indicate the cost of traveling between nodes. Of course, such weights can be assigned to both undirected and directed edges. If weights are provided, an edge is<a id="_idIndexMarker734"/> named a <strong class="bold">weighted edge</strong>, and the whole graph is named a <strong class="bold">weighted graph</strong>. Similarly, if no weights are<a id="_idIndexMarker735"/> provided, <strong class="bold">unweighted edges</strong> are used in a graph. This<a id="_idIndexMarker736"/> graph is then<a id="_idIndexMarker737"/> called an <strong class="bold">unweighted graph</strong>.</p>
<p>Some example weighted graphs with undirected (on the left) and directed (on the right) edges are shown in the following diagram:</p>
<div><div><img alt="Figure 8.3 – Difference between weighted undirected and weighted directed graphs" src="img/B18069_08_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Difference between weighted undirected and weighted directed graphs</p>
<p>This graphical presentation of a weighted edge shows the weight of an edge next to the line. For example, the cost of traveling from node <strong class="bold">1</strong> to <strong class="bold">2</strong>, as well as from node <strong class="bold">2</strong> to <strong class="bold">1</strong>, is equal to <strong class="bold">3</strong> in the case of the undirected graph, shown on the left in the preceding diagram. The situation is a bit more complicated in the case of the directed graph (on the right). Here, you can <a id="_idIndexMarker738"/>travel from node <strong class="bold">1</strong> to <strong class="bold">2</strong> with a cost equal to <strong class="bold">9</strong>, while traveling in the opposite direction (from node <strong class="bold">2</strong> to <strong class="bold">1</strong>) is much cheaper <a id="_idTextAnchor301"/>a<a id="_idTextAnchor302"/>nd costs only <strong class="bold">3</strong>.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor303"/>Applications</h1>
<p>At this point, you know some basic information about graphs, especially regarding nodes and various kinds of edges. However, why is the topic of graphs so important and why does it take up a whole chapter in this book? Could you use this data structure in your applications? The answer is obvious: yes! Graphs are commonly used while solving algorithmic problems and have numerous real-world applications.</p>
<p>To start, let’s think about a <strong class="bold">structure of friends available on social media</strong>. Each user has many <a id="_idIndexMarker739"/>contacts, but they also have many friends, and so on. What data structure should you choose to store such data? A graph is the simplest answer. In such a scenario, the nodes represent contacts, while the edges depict relationships between people. As an example, let’s take a look at the following diagram of an undirected and unweighted graph:</p>
<div><div><img alt="Figure 8.4 – Illustration of a graph representing a structure of friends" src="img/B18069_08_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Illustration of a graph representing a structure of friends</p>
<p>As you can see, <strong class="bold">Jimmy Gold</strong> has five contacts, namely <strong class="bold">John Smith</strong>, <strong class="bold">Andy Wood</strong>, <strong class="bold">Eric Green</strong>, <strong class="bold">Ashley Lopez</strong>, and <strong class="bold">Paula Scott</strong>. In the meantime, <strong class="bold">Paula Scott</strong> has two other friends: <strong class="bold">Marcin Jamro</strong> and <strong class="bold">Tommy Butler</strong>. By using a graph as a data structure, you can easily check whether two people are friends or whether they have a common contact.</p>
<p>Another common application of graphs involves the problem of <strong class="bold">searching for the shortest path</strong>. Let’s imagine a program that should find a path between two points in the city, taking into account the time necessary for driving particular roads. In such a case, you can use a graph to present a map of a city, where nodes depict intersections and edges represent roads. Of course, you should assign weights to edges to indicate the time that’s necessary to drive a given road. The topic of searching the shortest path can be understood as finding the list of edges from the source to the target node, with the minimum total cost. A diagram of a city map, based on a graph, is shown here:</p>
<div><div><img alt="Figure 8.5 – Illustration of a graph representing a city map" src="img/B18069_08_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Illustration of a graph representing a city map</p>
<p>As you can see, the directed and <a id="_idIndexMarker740"/>weighted graph was chosen. Directed edges make it possible to support both two-way and one-way roads, while weighted edges allow you to specify the time necessary to travel between t<a id="_idTextAnchor304"/>w<a id="_idTextAnchor305"/>o intersections.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor306"/>Representations</h1>
<p>At this point, you know <a id="_idIndexMarker741"/>what a graph is and when one can be used, but how can you represent one in the memory of a computer? There are two popular approaches to solve this problem, namely using an <strong class="bold">adjacency list</strong> and an<a id="_idTextAnchor307"/> <a id="_idTextAnchor308"/><strong class="bold">adjacency matrix</strong>.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor309"/>Adjacency list</h2>
<p>The first approach<a id="_idIndexMarker742"/> requires you to <strong class="bold">extend the data of a node by specifying a list of its neighbors</strong>. Thus, you can easily get all the neighbors of a given node<a id="_idIndexMarker743"/> just by iterating through the adjacency list of a given node. Such a solution is space-efficient because you only store the data of adjacent edges. Let’s take a look at the diagram:</p>
<div><div><img alt="Figure 8.6 – ﻿Adjacency list representing an undirected and unweighted graph" src="img/B18069_08_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Adjacency list representing an undirected and unweighted graph</p>
<p>This example graph contains 8 nodes<a id="_idIndexMarker744"/> and 10 edges. For each node, a list of adjacent nodes (that is, <strong class="bold">neighbors</strong>) is created, as shown on the right-hand side of the diagram. For example, node <strong class="bold">1</strong> has two neighbors, namely nodes <strong class="bold">2</strong> and <strong class="bold">3</strong>, while node <strong class="bold">5</strong> has four <a id="_idIndexMarker745"/>neighbors, namely nodes <strong class="bold">4</strong>, <strong class="bold">6</strong>, <strong class="bold">7</strong>, and <strong class="bold">8</strong>. As you can see, the representation based<a id="_idIndexMarker746"/> on the adjacency list for an undirected and unweighted graph is straightforward, as well as easy to use, understand, and implement.</p>
<p>But how does the adjacency list work in the case of a directed graph? The answer is obvious because the list that’s assigned to each node just shows adjacent nodes that can be reached from the given node. Here’s an example diagram:</p>
<div><div><img alt="Figure 8.7 – Adjacency list representing a directed and unweighted graph" src="img/B18069_08_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Adjacency list representing a directed and unweighted graph</p>
<p>Let’s take a look at node <strong class="bold">3</strong>. Here, the adjacency list contains only one element – that is, node <strong class="bold">4</strong>. Node <strong class="bold">1</strong> is not included, because<a id="_idIndexMarker747"/> it cannot be reached directly from node <strong class="bold">3</strong>.</p>
<p>A bit more clarification may be <a id="_idIndexMarker748"/>useful in the case of a weighted graph. In such a case, it is also necessary to store weights for particular edges. You can achieve this by extending data stored in the adjacency list, as shown in the following diagram:</p>
<div><div><img alt="Figure 8.8 – Adjacency list representing a directed and weighted graph" src="img/B18069_08_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Adjacency list representing a directed and weighted graph</p>
<p>For example, the adjacency list for node <strong class="bold">7</strong> contains two elements, namely regarding an edge to node <strong class="bold">5</strong> (with a weight <a id="_idIndexMarker749"/>equal to <strong class="bold">4</strong>) and to node <strong class="bold">8</strong> (with<a id="_idTextAnchor310"/><a id="_idTextAnchor311"/> a weight equal to <strong class="bold">6</strong>).</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor312"/>Adjacency matrix</h2>
<p>Another approach to graph <a id="_idIndexMarker750"/>representation involves the adjacency matrix, which uses <strong class="bold">a two-dimensional array to show which nodes are connected by edges</strong>. The matrix contains the same number of rows and columns, which is equal to the number of nodes. The main idea is to <strong class="bold">store information about a particular edge in an element at a given row and column in the matrix</strong>. The <a id="_idIndexMarker751"/>index of the row and the column depends on the nodes connected with the edge. For example, if you want to get information about an edge between nodes with indices <strong class="bold">1</strong> and <strong class="bold">5</strong>, you must check the element in the row with an index set to <strong class="bold">1</strong> and in the column with an index set to <strong class="bold">5</strong>.</p>
<p>Such a solution provides you with a <strong class="bold">quick way of checking whether two particular nodes are connected by an edge</strong>. However, it may require you to store significantly more data than the adjacency list, especially if the graph does not contain many edges between nodes.</p>
<p>To start, let’s analyze the basic scenario of an undirected and unweighted graph. In such a case, the adjacency matrix may only store Boolean values. The <code>true</code> value that’s placed in the element at the <code>i</code> row <a id="_idIndexMarker752"/>and the <code>j</code> column indicates that there is a connection between a node with an<a id="_idIndexMarker753"/> index equal to <code>i</code> and the node with an index set to <code>j</code>. If this sounds complicated, take a look at the following figure:</p>
<div><div><img alt="Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph" src="img/B18069_08_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Adjacency matrix representing an undirected and unweighted graph</p>
<p>Here, the adjacency matrix contains 64 elements (for 8 rows and 8 columns) because there are 8 nodes in the graph. The values of many elements in the array are set to <code>false</code>, which is represented by missing indicators. The remaining are marked with crosses, representing <code>true</code> values. For example, such a value in the element at the fourth row and third column means that there is an edge between nodes <strong class="bold">4</strong> and <strong class="bold">3</strong>, as shown in the preceding diagram.</p>
<p class="callout-heading">Symmetric adjacency matrix</p>
<p class="callout">As the preceding graph is <a id="_idIndexMarker754"/>undirected, the adjacency matrix is symmetric. If there is an edge between nodes <code>i</code> and <code>j</code>, there is also an edge between nodes <code>j</code> and <code>i</code>.</p>
<p>The following example involves a directed and unweighted graph. In such a case, the same rules can be used, but the adjacency matrix does not need to be symmetric. Let’s take a look at the illustration of the<a id="_idIndexMarker755"/> graph, presented together with the adjacency matrix:</p>
<div><div><img alt="Figure 8.10 – Adjacency matrix representing a directed and unweighted graph" src="img/B18069_08_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Adjacency matrix representing a directed and unweighted graph</p>
<p>Within the shown adjacency<a id="_idIndexMarker756"/> matrix, you can find data of 15 edges, represented by 15 elements with <code>true</code> values, indicated by crosses in the matrix. For example, the unidirectional edge from node <strong class="bold">5</strong> to <strong class="bold">4</strong> is shown as the cross at the fifth row and the fourth column.</p>
<p>In both previous examples, you learned how to present an unweighted graph using an adjacency matrix. However, how you can store the data of the weighted graph, either undirected or directed? The answer is very simple – you just need to change the type of data stored in particular elements in the adjacency matrix from Boolean to numeric. Thus, you can specify the weight of edges, as shown in the following figure:</p>
<div><div><img alt="Figure 8.11 – Adjacency matrix representing a directed and weighted graph" src="img/B18069_08_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Adjacency matrix representing a directed and weighted graph</p>
<p>To eliminate any doubt, let’s take a look at the edge between nodes <strong class="bold">5</strong> and <strong class="bold">6</strong> with the weight set to <strong class="bold">2</strong>. Such an edge<a id="_idIndexMarker757"/> is represented by the element at<a id="_idIndexMarker758"/> the fifth row and the sixth column. The value of the element is equal to the cos<a id="_idTextAnchor313"/>t<a id="_idTextAnchor314"/> of traveling between nodes.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor315"/>Implementation</h1>
<p>You already know some basic information about graphs, including nodes, edges, and two methods of representation, namely using an adjacency list and matrix. However, how you can use such a data<a id="_idIndexMarker759"/> structure in your applications? In this section, you will learn how to implement a graph using the C# language. To make your understanding of this content easier, <a id="_idTextAnchor316"/>t<a id="_idTextAnchor317"/>wo examples will be provided.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor318"/>Node</h2>
<p>To start with, let’s take a look at the code of a generic class representing a single node in a graph. Such<a id="_idIndexMarker760"/> a class is named <code>Node</code> and its code is as follows:</p>
<pre class="source-code">
public class <strong class="bold">Node&lt;T&gt;</strong>
{
    public int <strong class="bold">Index</strong> { get; set; }
    public required T <strong class="bold">Data</strong> { get; set; }
    public List&lt;Node&lt;T&gt;&gt; <strong class="bold">Neighbors</strong> { get; set; } = [];
    public List&lt;int&gt; <strong class="bold">Weights</strong> { get; set; } = [];
    public override string <strong class="bold">ToString</strong>() =&gt; $"Index: {Index}.
        Data: {Data}. Neighbors: {Neighbors.Count}.";
}</pre> <p>The class contains four properties. Since all of these elements perform important roles in the code snippets shown in this chapter, let’s analyze them in detail:</p>
<ul>
<li>The first property (<code>Index</code>) stores an index of a particular node in a collection of nodes in a graph to simplify <a id="_idIndexMarker761"/>the process of accessing a particular element. Thus, it is possible to easily get an instance of the <code>Node</code> class by using an index.</li>
<li>The next property is named <code>Data</code> and just stores some data in the node. It is worth mentioning that the type of such data is consistent with the type specified while creating an instance of the generic class.</li>
<li>The <code>Neighbors</code> property represents the adjacency list for a particular node. Thus, it contains references to the <code>Node</code> instances representing adjacent nodes.</li>
<li>The last property is named <code>Weights</code> and stores weights assigned to adjacent edges. In the case of a weighted graph, the number of elements in the <code>Weights</code> list is the same as the number of neighbors (<code>Neighbors</code>). If a graph is unweighted, the <code>Weights</code> list is empty.</li>
</ul>
<p>Apart from the aforementioned properties, the class contains the overridden <code>ToString</code> method, which returns the textual representation of the object. Here, the string is returned in <code>"Index: [index]. Data: [dat<a id="_idTextAnchor319"/>a<a id="_idTextAnchor320"/>]. Neighbors: [</code><code>count]."</code> format.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor321"/>Edge</h2>
<p>As mentioned in the short introduction to the topic of graphs, a graph consists of nodes and edges. As a node is<a id="_idIndexMarker762"/> represented by an instance of the <code>Node</code> class, the generic <code>Edge</code> class can be used to represent an edge. The suitable part of the code is as follows:</p>
<pre class="source-code">
public class <strong class="bold">Edge&lt;T&gt;</strong>
{
    public required Node&lt;T&gt; <strong class="bold">From</strong> { get; set; }
    public required Node&lt;T&gt; <strong class="bold">To</strong> { get; set; }
    public int <strong class="bold">Weight</strong> { get; set; }
    public override string <strong class="bold">ToString</strong>() =&gt; $"{From.Data}
        -&gt; {To.Data}. Weight: {Weight}.";
}</pre> <p>The class contains three properties, namely representing nodes adjacent to the edge (<code>From</code> and <code>To</code>), as well as the weight of the edge (<code>Weight</code>). Moreover, the <code>ToString</code> method is overridden to present some <a id="_idTextAnchor322"/>b<a id="_idTextAnchor323"/>asic information about the edge.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor324"/>Graph</h2>
<p>The next class is named <code>Graph</code> and represents a whole graph, with either directed or undirected edges, as well as either weighted or <a id="_idIndexMarker763"/>unweighted edges. The implementation consists of various properties and methods. These are described in detail here.</p>
<p>Let’s take a look at the basic version of the <code>Graph</code> class:</p>
<pre class="source-code">
public class <strong class="bold">Graph&lt;T&gt;</strong>
{
    public required bool <strong class="bold">IsDirected</strong> { get; init; }
    public required bool <strong class="bold">IsWeighted</strong> { get; init; }
    public List&lt;Node&lt;T&gt;&gt; <strong class="bold">Nodes</strong> { get; set; } = [];
}</pre> <p>The class contains two properties indicating whether edges are directed (<code>IsDirected</code>) and weighted (<code>IsWeighted</code>). Moreover, the <code>Nodes</code> property is declared, which stores a list of nodes existing in the graph.</p>
<p>The next interesting <a id="_idIndexMarker764"/>member of the <code>Graph</code> class is the indexer, which takes two indices, namely indices of two nodes, to return an instance of the <code>Edge</code> class representing an edge between such nodes. The implementation is shown here:</p>
<pre class="source-code">
public Edge&lt;T&gt;? <strong class="bold">this[int from, int to]</strong>
{
    get
    {
        Node&lt;T&gt; nodeFrom = Nodes[from];
        Node&lt;T&gt; nodeTo = Nodes[to];
        int i = nodeFrom.Neighbors.IndexOf(nodeTo);
        if (i &lt; 0) { return null; }
        Edge&lt;T&gt; edge = new()
        {
            From = nodeFrom,
            To = nodeTo,
            Weight = i &lt; nodeFrom.Weights.Count
                ? nodeFrom.Weights[i] : 0
        };
        return edge;
    }
}</pre> <p>Within the indexer, you get instances of the <code>Node</code> class representing two nodes (<code>nodeFrom</code> and <code>nodeTo</code>) according to the indices. As you want to find an edge from the first node (<code>nodeFrom</code>) to the second one (<code>nodeTo</code>), you need to try to find the second node in the collection of neighbor nodes of the first node using the <code>IndexOf</code> method. If such a connection does not exist, the <code>IndexOf</code> method returns a negative value, and <code>null</code> is returned by the indexer. Otherwise, you create a new instance of the <code>Edge</code> class and set the values of its <a id="_idIndexMarker765"/>properties, including <code>From</code> and <code>To</code>. If the data regarding the weight of particular edges is provided, the value of the <code>Weight</code> property of the <code>Edge</code> class is set as well.</p>
<p>At this point, you know how to store data of nodes in the graph, but how can you add a new node? To do so, you can implement the <code>AddNode</code> method, as follows:</p>
<pre class="source-code">
public Node&lt;T&gt; <strong class="bold">AddNode</strong>(T value)
{
    Node&lt;T&gt; node = new() { Data = value };
    Nodes.Add(node);
    UpdateIndices();
    return node;
}</pre> <p>Within this method, you create a new instance of the <code>Node</code> class and set a value of the <code>Data</code> property, according to the value of the parameter. Then, the newly created instance is added to the <code>Nodes</code> collection, and the <code>UpdateIndices</code> method (described later) is called to update the indices of all the nodes stored in the collection. Finally, the <code>Node</code> instance, representing the newly added node, is returned.</p>
<p>You can remove the existing node as well. This operation is performed by the <code>RemoveNode</code> method, as shown in the following code snippet:</p>
<pre class="source-code">
public void <strong class="bold">RemoveNode</strong>(Node&lt;T&gt; nodeToRemove)
{
    Nodes.Remove(nodeToRemove);
    UpdateIndices();
    Nodes.ForEach(n =&gt; RemoveEdge(n, nodeToRemove));
}</pre> <p>This method takes one parameter, namely an instance of the node that should be removed. First, you remove it from the collection of nodes. Then, you update the indices of the remaining nodes. Finally, you iterate through all the nodes in the graph to remove all edges that are connected with the node that has been removed.</p>
<p>As you already know, a graph<a id="_idIndexMarker766"/> consists of nodes and edges. Thus, the implementation of the <code>Graph</code> class should provide developers with a method for adding a new edge. Of course, it should support various variants of edges, either directed, undirected, weighted, or unweighted. The proposed implementation is as follows:</p>
<pre class="source-code">
public void <strong class="bold">AddEdge</strong>(Node&lt;T&gt; from, Node&lt;T&gt; to, int w = 0)
{
    from.Neighbors.Add(to);
    if (IsWeighted) { from.Weights.Add(w); }
    if (!IsDirected)
    {
        to.Neighbors.Add(from);
        if (IsWeighted) { to.Weights.Add(w); }
    }
}</pre> <p>The <code>AddEdge</code> method takes three parameters, namely two instances of the <code>Node</code> class representing nodes connected by the edge (<code>from</code> and <code>to</code>), as well as the weight of the connection (<code>w</code>), which is set to <code>0</code> by default.</p>
<p>In the first line within the method, you add the <code>Node</code> instance representing the second node to the list of neighbor nodes of the first one. If the weighted graph is considered, a weight of the aforementioned edge is added as well.</p>
<p>The following part of the code is only taken into account when the graph is undirected. In such a case, you need to automatically add an edge in the opposite direction. To do so, you add the <code>Node</code> instance representing the first node to the list of neighbor nodes of the second one. If the edges are weighted, a weight of the aforementioned edge is added to the <code>Weights</code> list as <a id="_idIndexMarker767"/>well.</p>
<p>The process of removing an edge from the graph is supported by the <code>RemoveEdge</code> method. The code is as follows:</p>
<pre class="source-code">
public void <strong class="bold">RemoveEdge</strong>(Node&lt;T&gt; from, Node&lt;T&gt; to)
{
    int index = from.Neighbors.FindIndex(n =&gt; n == to);
    if (index &lt; 0) { return; }
    from.Neighbors.RemoveAt(index);
    if (IsWeighted) { from.Weights.RemoveAt(index); }
    if (!IsDirected)
    {
        index = to.Neighbors.FindIndex(n =&gt; n == from);
        if (index &lt; 0) { return; }
        to.Neighbors.RemoveAt(index);
        if (IsWeighted) { to.Weights.RemoveAt(index); }
    }
}</pre> <p>This method takes two parameters, namely two nodes (<code>from</code> and <code>to</code>), between which there is an edge that should be removed. To start, you try to find the second node in the list of neighbor nodes of the first one. If it is found, you remove it. You should also remove the weight data if the weighted graph is considered. In the case of an undirected graph, you automatically remove a node in an opposite direction, namely between the <code>to</code> and <code>from</code> nodes.</p>
<p>The last public method is named <code>GetEdges</code> and makes it possible to get a collection of all the edges that are available in the graph. The proposed implementation is as follows:</p>
<pre class="source-code">
public List&lt;Edge&lt;T&gt;&gt; <strong class="bold">GetEdges</strong>()
{
    List&lt;Edge&lt;T&gt;&gt; edges = [];
    foreach (Node&lt;T&gt; from in Nodes)
    {
        for (int i = 0; i &lt; from.Neighbors.Count; i++)
        {
            int weight = i &lt; from.Weights.Count
                ? from.Weights[i] : 0;
            Edge&lt;T&gt; edge = new()
            {
                From = from,
                To = from.Neighbors[i],
                Weight = weight
            };
            edges.Add(edge);
        }
    }
    return edges;
}</pre> <p>First, a new list of edges is initialized. Then, you iterate through all the nodes in the graph using a <code>foreach</code> loop. Within it, you use a <code>for</code> loop to create instances of the <code>Edge</code> class. The number of instances should be equal to the number of neighbors of the current node (the <code>from</code> variable <a id="_idIndexMarker768"/>in the <code>foreach</code> loop). In the <code>for</code> loop, the newly created instance of the <code>Edge</code> class is configured by setting values of its properties, namely the first node (the <code>from</code> variable – that is, the current node from the <code>foreach</code> loop), the second node (to the currently-analyzed neighbor), and the weight. Then, the newly created instance is added to the collection of edges, represented by the <code>edges</code> variable. Finally, the result is returned.</p>
<p>In various methods, you <a id="_idIndexMarker769"/>use the <code>UpdateIndices</code> method. Its code is as follows:</p>
<pre class="source-code">
private void <strong class="bold">UpdateIndices</strong>()
{
    int i = 0;
    Nodes.ForEach(n =&gt; n.Index = i++);
}</pre> <p>This method iterates through all the nodes in the graph and updates the values of the <code>Index</code> property to the consecutive number, starting from <code>0</code>. It is worth noting that the iteration is performed using the <code>ForEach</code> method, instead of using a <code>foreach</code> or <code>for</code> loop.</p>
<p>Now, you know how to create a basic implementation of a graph. The next step is to a<a id="_idTextAnchor325"/>pp<a id="_idTextAnchor326"/>ly it to represent some example graphs.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor327"/>Example – undirected and unweighted edges</h2>
<p>Let’s try to use the previous<a id="_idIndexMarker770"/> implementation to create an undirected and unweighted graph according to the following diagram:</p>
<div><div><img alt="Figure 8.12 – Illustration of the undirected and unweighted edges example" src="img/B18069_08_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Illustration of the undirected and unweighted edges example</p>
<p>As you can see, the graph contains 8 nodes and 10 edges. The implementation starts with the following line, which <a id="_idIndexMarker771"/>initializes a new undirected and unweighted graph:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { <code>Node&lt;int&gt;</code> type, as follows:</p>
<pre class="source-code">
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);</pre> <p>Finally, you only need to add edges between nodes, as shown in the preceding diagram. The necessary code is as follows:</p>
<pre class="source-code">
graph.AddEdge(n1, n2);
graph.AddEdge(n1, n3);
graph.AddEdge(n2, n4);
graph.AddEdge(n3, n4);
graph.AddEdge(n4, n5);
graph.AddEdge(n5, n6);
graph.AddEdge(n5, n7);
graph.AddEdge(n5, n8);
graph.AddEdge(n6, n7);
graph.AddEdge(n7, n8);</pre> <p>That’s all! As you can see, configuring a graph is very easy using the proposed implementation of this data <a id="_idIndexMarker772"/>structure. Now, let’s proceed to a slightly more complex <a id="_idTextAnchor328"/>s<a id="_idTextAnchor329"/>cenario with directed and weighted edges.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor330"/>Example – directed and weighted edges</h2>
<p>The following example involves a <a id="_idIndexMarker773"/>directed and weighted graph, as follows:</p>
<div><div><img alt="Figure 8.13 – Illustration of the directed and weighted edges example" src="img/B18069_08_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Illustration of the directed and weighted edges example</p>
<p>The implementation is similar to the one described previously. However, some modifications are necessary. To start with, different values of the properties are used to indicate that a directed and weighted variant of the edges is being considered:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { <strong class="bold">IsDirected = true, IsWeighted = true</strong> };</pre> <p>The part regarding adding nodes is the same as in the previous example:</p>
<pre class="source-code">
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);</pre> <p>Some changes are easily visible in the lines of code regarding the addition of edges. Here, you specify directed <a id="_idIndexMarker774"/>edges and their weights, as follows:</p>
<pre class="source-code">
graph.AddEdge(n1, n2, 9);
graph.AddEdge(n1, n3, 5);
graph.AddEdge(n2, n1, 3);
graph.AddEdge(n2, n4, 18);
graph.AddEdge(n3, n4, 12);
graph.AddEdge(n4, n2, 2);
graph.AddEdge(n4, n8, 8);
graph.AddEdge(n5, n4, 9);
graph.AddEdge(n5, n6, 2);
graph.AddEdge(n5, n7, 5);
graph.AddEdge(n5, n8, 3);
graph.AddEdge(n6, n7, 1);
graph.AddEdge(n7, n5, 4);
graph.AddEdge(n7, n8, 6);
graph.AddEdge(n8, n5, 3);</pre> <p>You’ve just completed the basic implementation of a graph, shown in two examples. So, let’s proceed t<a id="_idTextAnchor331"/>o<a id="_idTextAnchor332"/> another topic, namely traversing a graph.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor333"/>Traversal</h1>
<p>One of the operations that’s commonly performed on a graph is <strong class="bold">traversal</strong> – that is, <strong class="bold">visiting all of the nodes in some particular order</strong>. Of course, the aforementioned problem can be solved in various ways, such as using <strong class="bold">DFS</strong> or <strong class="bold">BFS</strong> approaches. It is worth mentioning that the <a id="_idIndexMarker775"/>traversal topic is strictly connected with the ta<a id="_idTextAnchor334"/>s<a id="_idTextAnchor335"/>k of <strong class="bold">searching for a given node in </strong><strong class="bold">a graph</strong>.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor336"/>Depth-first search</h2>
<p>The first graph<a id="_idIndexMarker776"/> traversal algorithm described in this chapter is named <strong class="bold">DFS</strong>. It tries to go as deep as possible<a id="_idIndexMarker777"/>. <strong class="bold">First, it proceeds to the next levels of the nodes instead of visiting all the neighbors of the current node</strong>. Its steps, in the context of the example graph, are as follows:</p>
<div><div><img alt="Figure 8.14 – Illustration of a DFS of a graph" src="img/B18069_08_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Illustration of a DFS of a graph</p>
<p>Of course, it can be a bit <a id="_idIndexMarker778"/>difficult to understand how the DFS algorithm operates<a id="_idIndexMarker779"/> just by looking at the preceding diagram. For this reason, let’s try to analyze its stages.</p>
<p>In <strong class="bold">Step 1</strong>, there’s the graph with 8 nodes. In <strong class="bold">Step 2</strong>, node <strong class="bold">1</strong> is marked with a gray background (indicating that the node was already visited), as well as with a bolder border (indicating that it is the node that is currently being visited). Moreover, an important role in the algorithm is performed by the neighbor nodes (shown as circles with dashed borders) of the current one. When you know the roles of particular indicators, it is clear that in <strong class="bold">Step 2</strong>, node <strong class="bold">1</strong> is visited. It has two neighbors, namely nodes <strong class="bold">2</strong> and <strong class="bold">3</strong>.</p>
<p>Then, the first <a id="_idIndexMarker780"/>neighbor (node <strong class="bold">2</strong>) is taken into account (<strong class="bold">Step 3</strong>) and the same operations are performed – that is, the node is visited and its neighbors (nodes <strong class="bold">1</strong> and <strong class="bold">4</strong>) are analyzed. As node <strong class="bold">1</strong> was visited, it is skipped. In <strong class="bold">Step 4</strong>, the first suitable neighbor of node <strong class="bold">2</strong> is taken into account, namely node <strong class="bold">4</strong>. It has two neighbors, namely node <strong class="bold">2</strong> (already visited) and <strong class="bold">8</strong>. Next, node <strong class="bold">8</strong> is visited (<strong class="bold">Step 5</strong>) and, according to the same rules, node <strong class="bold">5</strong> (<strong class="bold">Step 6</strong>). It has four neighbors, namely nodes <strong class="bold">4</strong> (already visited), <strong class="bold">6</strong>, <strong class="bold">7</strong>, and <strong class="bold">8</strong> (already visited). Thus, in <strong class="bold">Step 7</strong>, node <strong class="bold">6</strong> is taken into account. As it has only one neighbor (node <strong class="bold">7</strong>), it is <a id="_idIndexMarker781"/>visited next (<strong class="bold">Step 8</strong>).</p>
<p>Then, you check the neighbors of node <strong class="bold">7</strong>, namely nodes <strong class="bold">5</strong> and <strong class="bold">8</strong>. Both were already visited, so you return to the node with an unvisited neighbor. In this example, node <strong class="bold">1</strong> has one unvisited node, namely node <strong class="bold">3</strong>. When it is visited (<strong class="bold">Step 9</strong>), all nodes are traversed and no further operations are necessary.</p>
<p>Given this example, let’s try to create the implementation in the C# language. To start, the code of the public <code>DFS</code> method (in the <code>Graph</code> class) is presented as follows:</p>
<pre class="source-code">
public List&lt;Node&lt;T&gt;&gt; <strong class="bold">DFS</strong>()
{
    bool[] isVisited = new bool[Nodes.Count];
    List&lt;Node&lt;T&gt;&gt; result = [];
    <strong class="bold">DFS(isVisited, Nodes[0], result);</strong>
    return result;
}</pre> <p>The important role is performed by the <code>isVisited</code> array. It has the same number of elements as the number of nodes and stores values indicating whether a given node has already been visited. If so, the <code>true</code> value is stored. Otherwise, <code>false</code> is stored. The list of traversed nodes is represented as a list in the <code>result</code> variable. What’s more, another variant of the <code>DFS</code> method is called here, passing three parameters:</p>
<ul>
<li>A reference to the <code>isVisited</code> array</li>
<li>The first node to analyze</li>
<li>The list for storing results</li>
</ul>
<p>The code for the<a id="_idIndexMarker782"/> aforementioned<a id="_idIndexMarker783"/> variant of the <code>DFS</code> method is as follows:</p>
<pre class="source-code">
private void <strong class="bold">DFS</strong>(bool[] isVisited, Node&lt;T&gt; node,
    List&lt;Node&lt;T&gt;&gt; result)
{
    result.Add(node);
    isVisited[node.Index] = true;
    foreach (Node&lt;T&gt; neighbor in node.Neighbors)
    {
        if (!isVisited[neighbor.Index])
        {
            <strong class="bold">DFS(isVisited, neighbor, result);</strong>
        }
    }
}</pre> <p>First, the current node is added to the collection of traversed nodes, and the element in the <code>isVisited</code> array is updated. Then, you use the <code>foreach</code> loop to iterate through all the neighbors of the current node. For each of them, if they haven’t already been visited, the <code>DFS</code> method is called recursively.</p>
<p>To finish, let’s take a look at the code that can be placed in the <code>Program.cs</code> file. Its main parts are presented in the following code snippet:</p>
<pre class="source-code">
<strong class="bold">Graph&lt;int&gt; graph = new()</strong>
    <strong class="bold">{ IsDirected = true, IsWeighted = true };</strong>
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
<strong class="bold">List&lt;Node&lt;int&gt;&gt; nodes = graph.DFS();</strong>
nodes.ForEach(Console.WriteLine);</pre> <p>Here, you initialize a directed and weighted graph. It is worth noting that the missing lines of code (indicated by<a id="_idIndexMarker784"/> three dots) are the same as in the example where you created a graph with directed and weighted edges.</p>
<p>To start traversing the <a id="_idIndexMarker785"/>graph, you just need to call the <code>DFS</code> method, which returns a list of <code>Node</code> instances. Then, you can easily iterate through elements of the list to print some basic information about each node in the console:</p>
<pre class="console">
Index: 0. Data: 1. Neighbors: 2.
Index: 1. Data: 2. Neighbors: 2.
Index: 3. Data: 4. Neighbors: 2.
Index: 7. Data: 8. Neighbors: 1.
Index: 4. Data: 5. Neighbors: 4.
Index: 5. Data: 6. Neighbors: 1.
Index: 6. Data: 7. Neighbors: 2.
Index: 2. Data: 3. Neighbors: 1.</pre> <p>That’s all! As you can see, the algorithm tries to go as deep as possible and then goes back to find the next unvisited neighbor that can be traversed.</p>
<p>However, this algorithm is not the only approach to the p<a id="_idTextAnchor337"/>roblem of graph traversal. We’ll cover anothe<a id="_idTextAnchor338"/>r method and its implementation in the next section.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor339"/>Breadth-first search</h2>
<p>In the previous section, you learned about the DFS approach. Now, you will see another solution, namely <strong class="bold">BFS</strong>. Its <a id="_idIndexMarker786"/>main aim is to <strong class="bold">visit all the neighbors of the current node and then proceed to the next level </strong><strong class="bold">of nodes</strong>.</p>
<p>If the previous description <a id="_idIndexMarker787"/>sounds a bit complicated, take a look at this diagram, which depicts the steps of the BFS algorithm:</p>
<div><div><img alt="Figure 8.15 – Illustration of a BFS of a graph" src="img/B18069_08_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Illustration of a BFS of a graph</p>
<p>The algorithm starts by<a id="_idIndexMarker788"/> visiting node <strong class="bold">1</strong> (<strong class="bold">Step 2</strong>). It has two neighbors, namely nodes <strong class="bold">2</strong> and <strong class="bold">3</strong>, which<a id="_idIndexMarker789"/> are visited next (<strong class="bold">Step 3</strong> and <strong class="bold">Step 4</strong>). As node <strong class="bold">1</strong> does not have more neighbors, the neighbors of its first neighbor (node <strong class="bold">2</strong>) are considered. As it has only one unvisited neighbor (node <strong class="bold">4</strong>), it is visited in the next step. According to the same method, the remaining nodes are visited in this order: <strong class="bold">8</strong>, <strong class="bold">5</strong>, <strong class="bold">6</strong>, <strong class="bold">7</strong>.</p>
<p>It sounds very simple, doesn’t it? Let’s take a look at the implementation:</p>
<pre class="source-code">
public List&lt;Node&lt;T&gt;&gt; <code>BFS</code> public method is added to the <code>Graph</code> class and is used to start the traversal of a graph. It calls the<a id="_idIndexMarker790"/> private <code>BFS</code> method, passing the first node as the parameter. Its <a id="_idIndexMarker791"/><a id="_idIndexMarker792"/>code is as follows:</p>
<pre class="source-code">
private List&lt;Node&lt;T&gt;&gt; <strong class="bold">BFS</strong>(Node&lt;T&gt; node)
{
    bool[] isVisited = new bool[Nodes.Count];
    isVisited[node.Index] = true;
    List&lt;Node&lt;T&gt;&gt; result = [];
    Queue&lt;Node&lt;T&gt;&gt; queue = [];
    queue.Enqueue(node);
    while (queue.Count &gt; 0)
    {
        Node&lt;T&gt; next = queue.Dequeue();
        result.Add(next);
        foreach (Node&lt;T&gt; neighbor in next.Neighbors)
        {
            if (!isVisited[neighbor.Index])
            {
                isVisited[neighbor.Index] = true;
                queue.Enqueue(neighbor);
            }
        }
    }
    return result;
}</pre> <p>The important part of the code is performed by the <code>isVisited</code> array, which stores Boolean values indicating whether particular nodes were already visited. The array is initialized at the beginning of the <code>BFS</code> method, and the value of the element related to the current node is set to <code>true</code>, which<a id="_idIndexMarker793"/> indicates that this node was visited.</p>
<p>Then, the list for<a id="_idIndexMarker794"/> storing traversed nodes (<code>result</code>) and the queue for storing nodes that should be visited next (<code>queue</code>) are created. Just after the initialization of the queue, the current node is added to it.</p>
<p>The following operations are performed until the queue is empty: you get the first node from the queue (the <code>next</code> variable), add it to the collection of visited nodes, and iterate through the neighbors of the current node. For each of them, you check whether it has already been visited. If not, it is marked as visited by setting a proper value in the <code>isVisited</code> array, and the neighbor is added to the queue for analysis in one of the next iterations of the <code>while</code> loop.</p>
<p>Finally, the list of the visited nodes is returned. If you want to test this algorithm, you can use the following code:</p>
<pre class="source-code">
<strong class="bold">Graph&lt;int&gt; graph = new()</strong>
    <strong class="bold">{ IsDirected = true, IsWeighted = true };</strong>
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
<strong class="bold">List&lt;Node&lt;int&gt;&gt; nodes = graph.BFS();</strong>
nodes.ForEach(Console.WriteLine);</pre> <p>The preceding code calls the <code>BFS</code> public method to traverse the graph according to the BFS algorithm. The last line is responsible for iterating through the results to present the data of the nodes in the console, as shown here:</p>
<pre class="console">
Index: 0. Data: 1. Neighbors: 2.
Index: 1. Data: 2. Neighbors: 2.
Index: 2. Data: 3. Neighbors: 1.
Index: 3. Data: 4. Neighbors: 2.
Index: 7. Data: 8. Neighbors: 1.
Index: 4. Data: 5. Neighbors: 4.
Index: 5. Data: 6. Neighbors: 1.
Index: 6. Data: 7. Neighbors: 2.</pre> <p>You’ve just learned about two algorithms for traversing a graph, namely DFS and BFS. To make your understanding of such topics easier, this chapter contains detailed descriptions, illustrations, and <a id="_idIndexMarker795"/>examples. Now, let’s proceed to another<a id="_idIndexMarker796"/> important<a id="_idTextAnchor340"/> topic, namely the minimum spanning tree, which has many real-world applications.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">There are many online resources regarding traversing a graph. You can learn more about DFS at <a href="https://en.wikipedia.org/wiki/Depth-first_search">https://en.wikipedia.org/wiki/Depth-first_search</a>, while you can find more information about the BFS algorithm and its implementation at <a href="https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/">https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/</a>.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor342"/>Minimum spanning tree</h1>
<p>While talking about<a id="_idIndexMarker797"/> graphs, it is beneficial to introduce the subject of a <strong class="bold">spanning tree</strong>. What is it? <strong class="bold">A</strong><strong class="bold"><a id="_idIndexMarker798"/></strong><strong class="bold"> spanning tree is a subset of edges that connects all nodes in a graph without cycles</strong>. Of course, it is possible to have many spanning trees within the same graph. For example, let’s take a look at the following diagram:</p>
<div><div><img alt="Figure 8.16 – Illustration of spanning trees within a graph" src="img/B18069_08_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Illustration of spanning trees within a graph</p>
<p>On the left-hand side is a spanning tree<a id="_idIndexMarker799"/> that consists of the following edges: (<strong class="bold">1</strong>, <strong class="bold">2</strong>), (<strong class="bold">1</strong>, <strong class="bold">3</strong>), (<strong class="bold">3</strong>, <strong class="bold">4</strong>), (<strong class="bold">4</strong>, <strong class="bold">5</strong>), (<strong class="bold">5</strong>, <strong class="bold">6</strong>), (<strong class="bold">6</strong>, <strong class="bold">7</strong>), and (<strong class="bold">5</strong>, <strong class="bold">8</strong>). The total weight is equal to 40. On the right-hand side, another spanning tree is shown. Here, the following edges are chosen: (<strong class="bold">1</strong>, <strong class="bold">2</strong>), (<strong class="bold">1</strong>, <strong class="bold">3</strong>), (<strong class="bold">2</strong>, <strong class="bold">4</strong>), (<strong class="bold">4</strong>, <strong class="bold">8</strong>), (<strong class="bold">5</strong>, <strong class="bold">8</strong>), (<strong class="bold">5</strong>, <strong class="bold">6</strong>), and (<strong class="bold">6</strong>, <strong class="bold">7</strong>). The total weight is equal to 31.</p>
<p>However, neither of the preceding spanning trees is the <strong class="bold">minimum spanning tree (MST)</strong> of this graph. What does it mean that a spanning tree is <em class="italic">minimum</em>? The answer is really simple: it is <strong class="bold">a spanning tree with the minimum cost from all spanning trees available in the graph</strong>. You can get the MST by replacing the edge (<strong class="bold">6</strong>, <strong class="bold">7</strong>) with (<strong class="bold">5</strong>, <strong class="bold">7</strong>). Then, the cost is equal to 30. It is also worth mentioning that the number of edges in a spanning tree is equal to the number of nodes minus one.</p>
<p>Why is the topic of MST so important? Let’s imagine a scenario where you need to connect many buildings to a telecommunication cable. Of course, there are various possible connections, such as from one building to another, or using a hub. What’s more, environmental conditions can have a serious impact on the cost of the investment due to the necessity of crossing a road or even a river. Your task is to successfully connect all buildings to the telecommunication cable at the lowest possible cost. How should you design the connections? To answer this question, you just need to create a graph, where nodes represent connectors and edges indicate possible connections. Then, you find the MST, and<a id="_idIndexMarker800"/> that’s all!</p>
<p class="callout-heading">Do you want some examples?</p>
<p class="callout">The aforementioned problem of connecting many buildings to the telecommunication cable is presented in the example at the end of this section regarding the MST.</p>
<p>The next question is how to find the MST. There are various approaches to solving this problem, including the application of Kruskal’s or Prim’s algori<a id="_idTextAnchor343"/>t<a id="_idTextAnchor344"/>hms. These are presented and explained in the following sections.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor345"/>Kruskal’s algorithm</h2>
<p>One of the algorithms <a id="_idIndexMarker801"/>for finding the MST was discovered by <strong class="bold">Kruskal</strong>. Its operation is <a id="_idIndexMarker802"/>very simple to explain. <strong class="bold">The algorithm takes an edge with the minimum weight from the remaining ones and adds it to the MST, but only if adding it does not create a cycle</strong>. The algorithm stops when all the nodes are connected.</p>
<p>Let’s take a look at a diagram that presents the steps of finding the MST using <strong class="bold">Kruskal’s algorithm</strong>:</p>
<div><div><img alt="Figure 8.17 – Illustration of Kruskal’s algorithm" src="img/B18069_08_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Illustration of Kruskal’s algorithm</p>
<p>In <strong class="bold">Step 1</strong>, edge (<strong class="bold">5</strong>, <strong class="bold">8</strong>) is chosen <a id="_idIndexMarker803"/>because it has the minimum <a id="_idIndexMarker804"/>weight, namely <strong class="bold">1</strong>. Then, the following edges are selected: (<strong class="bold">1</strong>, <strong class="bold">2</strong>) in <strong class="bold">Step 2</strong>, (<strong class="bold">2</strong>, <strong class="bold">4</strong>) in <strong class="bold">Step 3</strong>, (<strong class="bold">5</strong>, <strong class="bold">6</strong>) in <strong class="bold">Step 4</strong>, (<strong class="bold">1</strong>, <strong class="bold">3</strong>) in <strong class="bold">Step 5</strong>, as well as (<strong class="bold">5</strong>, <strong class="bold">7</strong>) and (<strong class="bold">4</strong>, <strong class="bold">8</strong>) in <strong class="bold">Step 6</strong>. It is worth noting that before taking the (<strong class="bold">4</strong>, <strong class="bold">8</strong>) edge, (<strong class="bold">6</strong>, <strong class="bold">7</strong>) is considered due to its lower weight (6 instead of 8). However, adding it to the MST will introduce a cycle formed by the (<strong class="bold">5</strong>, <strong class="bold">6</strong>), (<strong class="bold">6</strong>, <strong class="bold">7</strong>), and (<strong class="bold">5</strong>, <strong class="bold">7</strong>) edges. For this reason, such an edge is ignored and the algorithm chooses (<strong class="bold">4</strong>, <strong class="bold">8</strong>). Finally, the number of edges in the MST is 7. The number of nodes is equal to 8, which means that the algorithm can stop operating and the MST has been found.</p>
<p>Let’s take a look at its<a id="_idIndexMarker805"/> implementation. It involves the <code>MSTKruskal</code> method, which should be added to the <code>Graph</code> class. The proposed <a id="_idIndexMarker806"/>code is as follows:</p>
<pre class="source-code">
public List&lt;Edge&lt;T&gt;&gt; <strong class="bold">MSTKruskal</strong>()
{
    List&lt;Edge&lt;T&gt;&gt; edges = GetEdges();
    edges.Sort((a, b) =&gt; a.Weight.CompareTo(b.Weight));
    Queue&lt;Edge&lt;T&gt;&gt; queue = new(edges);
    Subset&lt;T&gt;[] subsets = new Subset&lt;T&gt;[Nodes.Count];
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        subsets[i] = new() { Parent = Nodes[i] };
    }
    List&lt;Edge&lt;T&gt;&gt; result = [];
    while (result.Count &lt; Nodes.Count - 1)
    {
        Edge&lt;T&gt; edge = queue.Dequeue();
        Node&lt;T&gt; from = GetRoot(subsets, edge.From);
        Node&lt;T&gt; to = GetRoot(subsets, edge.To);
        if (from == to) { continue; }
        result.Add(edge);
        Union(subsets, from, to);
    }
    return result;
}</pre> <p>This method does not take any parameters. To start, a list of edges is obtained by calling the <code>GetEdges</code> method. Then, the edges are sorted in ascending order by weight. Such a step is crucial because you need to get an edge with the minimum cost in the following iterations of the algorithm. In the next line, a new queue is created and <code>Edge</code> instances are enqueued, using <a id="_idIndexMarker807"/>the constructor of the <code>Queue</code> class.</p>
<p>In the next block of code, an array with data of subsets is created. By default, each node is added to a separate subset. This is the reason why the number of elements in the <code>subsets</code> array is equal to the<a id="_idIndexMarker808"/> number of nodes. The subsets are used to check whether an addition of an edge to the MST causes the creation of a cycle.</p>
<p>Then, the list for storing edges from the MST is created (<code>result</code>). The most interesting part of the code is the <code>while</code> loop, which iterates until the correct number of edges is found in the MST. Within this loop, you get the edge with the minimum weight, just by calling the <code>Dequeue</code> method on the <code>Queue</code> instance. Then, you can check whether no cycles were introduced by adding the found edge to the MST. In such a case, the edge is added to the target list, and the <code>Union</code> method is called to union two subsets.</p>
<p>While analyzing the previous method, the <code>GetRoot</code> one is mentioned. It aims to update parents for subsets, as well as return the root node of the subset, as follows:</p>
<pre class="source-code">
private Node&lt;T&gt; <strong class="bold">GetRoot</strong>(Subset&lt;T&gt;[] subsets, Node&lt;T&gt; node)
{
    int i = node.Index;
    ss[i].Parent = ss[i].Parent != node
        ? GetRoot(ss, ss[i].Parent) : ss[i].Parent;
    return ss[i].Parent;
}</pre> <p>The last private method is named <code>Union</code> and performs the <em class="italic">union</em> operation (by a rank) of two sets. It takes three parameters, namely an array of <code>Subset</code> instances and two <code>Node</code> instances, representing root nodes for subsets on which the <em class="italic">union</em> operation should be performed. The suitable <a id="_idIndexMarker809"/>part of the code is as follows:</p>
<pre class="source-code">
private void <strong class="bold">Union</strong>(Subset&lt;T&gt;[] ss, Node&lt;T&gt; a, Node&lt;T&gt; b)
{
    ss[b.Index].Parent =
        ss[a.Index].Rank &gt;= ss[b.Index].Rank
            ? a : ss[b.Index].Parent;
    ss[a.Index].Parent =
        ss[a.Index].Rank &lt; ss[b.Index].Rank
            ? b : ss[a.Index].Parent;
    if (ss[a.Index].Rank == ss[b.Index].Rank)
    {
        ss[a.Index].Rank++;
    }
}</pre> <p>In the previous code <a id="_idIndexMarker810"/>snippets, you can see the <code>Subset</code> class, but what does it look like? Let’s take a look at its declaration:</p>
<pre class="source-code">
public class <strong class="bold">Subset&lt;T&gt;</strong>
{
    public required Node&lt;T&gt; <strong class="bold">Parent</strong> { get; set; }
    public int <strong class="bold">Rank</strong> { get; set; }
    public override string <strong class="bold">ToString</strong>() =&gt; $"Rank: {Rank}.
        Parent: {Parent.Data}. Index: {Parent.Index}.";
}</pre> <p>The class contains properties representing the parent node (<code>Parent</code>), as well as the rank of the subset (<code>Rank</code>). The class also contains the overridden <code>ToString</code> method, which presents some basic information about the subset in textual form.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">Did you know that the presented approach is representative of a <strong class="bold">greedy algorithm</strong>? The code shown here is based on the implementation available at <a href="https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/">https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/</a>. You can find there a lot of interesting information about Kruskal’s algorithm, as well as about many other algorithms regarding graphs, such as about a simple approach to coloring, which is also one of the topics waiting for you in the current chapter. <em class="italic">GeeksForGeeks</em> is a great resource for various algorithms with a huge collection of content, and it’s something I highly recommend!</p>
<p>Let’s<a id="_idIndexMarker811"/> take a look at the<a id="_idIndexMarker812"/> usage of the <code>MSTKruskal</code> method:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 3);
graph.AddEdge(n1, n3, 5);
graph.AddEdge(n2, n4, 4);
graph.AddEdge(n3, n4, 12);
graph.AddEdge(n4, n5, 9);
graph.AddEdge(n4, n8, 8);
graph.AddEdge(n5, n6, 4);
graph.AddEdge(n5, n7, 5);
graph.AddEdge(n5, n8, 1);
graph.AddEdge(n6, n7, 6);
graph.AddEdge(n7, n8, 20);
<strong class="bold">List&lt;Edge&lt;int&gt;&gt; edges = graph.MSTKruskal();</strong>
edges.ForEach(Console.WriteLine);</pre> <p>First, you initialize an undirected and<a id="_idIndexMarker813"/> weighted graph, as well as add nodes and edges. Then, you call the <code>MSTKruskal</code> method to find <a id="_idIndexMarker814"/>the MST using Kruskal’s algorithm. Finally, you use<a id="_idTextAnchor346"/> the <code>ForEach</code> method to write the data of each edge from the MST in the console. The exemplary output is shown here:</p>
<pre class="console">
8 -&gt; 5. Weight: 1.
1 -&gt; 2. Weight: 3.
2 -&gt; 4. Weight: 4.
5 -&gt; 6. Weight: 4.
1 -&gt; 3. Weight: 5.
7 -&gt; 5. Weight: 5.
8 -&gt; 4. Weight: 8.</pre> <p>As mentioned previously, you <a id="_idIndexMarker815"/>will learn about two algorithms for finding the MST in this chapter. <a id="_idTextAnchor347"/>Now, it is high time to take a look at the second one, namely Prim’s algorithm.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor348"/>Prim’s algorithm</h2>
<p>Another solution to solve the<a id="_idIndexMarker816"/> problem <a id="_idIndexMarker817"/>of finding the MST is <strong class="bold">Prim’s algorithm</strong>. <strong class="bold">It uses two sets of nodes that are disjointed, namely the nodes located in the MST and the nodes that are not placed there yet</strong>. In the following iterations, the algorithm <strong class="bold">finds an edge with the minimum weight that connects a node from the first group with a node from the second group. The node of the edge, which is not already in the MST, is added to </strong><strong class="bold">this set.</strong></p>
<p>The preceding description sounds quite simple, doesn’t it? Let’s see it in action by analyzing the diagram presenting the steps of finding the MST using Prim’s algorithm:</p>
<div><div><img alt="Figure 8.18 – Illustration of Prim’s algorithm" src="img/B18069_08_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Illustration of Prim’s algorithm</p>
<p>Let’s take a look at the additional indicators that have been added next to the nodes in the graph. They present the <a id="_idIndexMarker818"/>minimum weight necessary to reach such a node from any of its neighbors. By<a id="_idIndexMarker819"/> default, the starting node has such a value set to <strong class="bold">0</strong>, while all others are set to infinity, as presented in <strong class="bold">Step 1</strong>.</p>
<p>In <strong class="bold">Step 2</strong>, the starting node is added to the subset of nodes forming the MST, and the distance to its neighbors is updated, namely <strong class="bold">5</strong> for reaching node <strong class="bold">3</strong> and <strong class="bold">3</strong> for reaching node <strong class="bold">2</strong>. The values of the other nodes are still set to infinity.</p>
<p>In <strong class="bold">Step 3</strong>, the node with the minimum cost is chosen. In this case, node <strong class="bold">2</strong> is selected because the cost is equal to <strong class="bold">3</strong>. Its competitor (namely node <strong class="bold">3</strong>) has a cost equal to <strong class="bold">5</strong>. Next, you need to update the cost of reaching the neighbors of the current node, namely node <strong class="bold">4</strong> with the cost set to <strong class="bold">4</strong>.</p>
<p>The next chosen node is node <strong class="bold">4</strong> because it does not exist in the MST set and has the lowest reaching cost (<strong class="bold">Step 4</strong>). In the same way, you choose the next edges in the following order: (<strong class="bold">1</strong>, <strong class="bold">3</strong>) in <strong class="bold">Step 5</strong>, (<strong class="bold">4</strong>, <strong class="bold">8</strong>) in <strong class="bold">Step 6</strong>, (<strong class="bold">8</strong>, <strong class="bold">5</strong>) in <strong class="bold">Step 7</strong>, (<strong class="bold">5</strong>, <strong class="bold">6</strong>) in <strong class="bold">Step 8</strong>, and (<strong class="bold">5</strong>, <strong class="bold">7</strong>) in <strong class="bold">Step 9</strong>. Now, all the nodes are included in the MST and the algorithm can stop its operation.</p>
<p>Given this detailed description of the steps of the algorithm, let’s proceed to the C#-based implementation. The majority of operations are performed in the <code>MSTPrim</code> method, which should be added to the <code>Graph</code> class:</p>
<pre class="source-code">
public List&lt;Edge&lt;T&gt;&gt; <strong class="bold">MSTPrim</strong>()
{
    <strong class="bold">int[] previous = new int[Nodes.Count];</strong>
    previous[0] = -1;
    <strong class="bold">int[] minWeight = new int[Nodes.Count];</strong>
    Array.Fill(minWeight, int.MaxValue);
    minWeight[0] = 0;
    <strong class="bold">bool[] isInMST = new bool[Nodes.Count];</strong>
    Array.Fill(isInMST, false);
    for (int i = 0; i &lt; Nodes.Count - 1; i++)
    {
        <strong class="bold">int mwi = GetMinWeightIndex(minWeight, isInMST);</strong>
        isInMST[mwi] = true;
        for (int j = 0; j &lt; Nodes.Count; j++)
        {
            Edge&lt;T&gt;? edge = this[mwi, j];
            int weight = edge != null ? edge.Weight : -1;
            if (edge != null
                &amp;&amp; !isInMST[j]
                &amp;&amp; weight &lt; minWeight[j])
            {
                <strong class="bold">previous[j] = mwi;</strong>
                <strong class="bold">minWeight[j] = weight;</strong>
            }
        }
    }
    List&lt;Edge&lt;T&gt;&gt; result = [];
    for (int i = 1; i &lt; Nodes.Count; i++)
    {
        result.Add(this[previous[i], i]!);
    }
    return result;
}</pre> <p>The <code>MSTPrim</code> method does not<a id="_idIndexMarker820"/> take any parameters. It uses three auxiliary node-related arrays that assign<a id="_idIndexMarker821"/> additional data to the nodes of the graph:</p>
<ul>
<li>The first, namely <code>previous</code>, stores indices of the previous node, from which the given node can be reached. By default, the values of all elements are equal to <code>0</code>, except the first one, which is set to <code>-1</code>.</li>
<li>The <code>minWeight</code> array stores the minimum weight of the edge for accessing the given node. By default, all elements are set to the maximum value of the <code>int</code> type, while the value for the first element is set to <code>0</code>.</li>
<li>The <code>isInMST</code> array indicates whether the given node is already in the MST. To start with, the values of all the elements should be set to <code>false</code>.</li>
</ul>
<p>The most interesting part of the code is located in the <code>for</code> loop. Within it, you’ll find the index of the node from the set of nodes not located in the MST, which can be reached with the minimum cost. Such a task is performed by the <code>GetMinWeightIndex</code> method. Then, another <code>for</code> loop is used. Within it, you get an edge that connects nodes with the <code>mwi</code> index (this stands for <em class="italic">minimum weight index</em>) and <code>j</code>. You check whether the node is not already located in the MST and whether the cost of reaching the node is smaller than the previous minimum cost. If so, values of node-related elements in the <code>previous</code> and <code>minWeight</code> arrays are updated.</p>
<p>The remaining part of the code just prepares the final results. Here, you create a new instance of the list with the data of edges that form the MST. The <code>for</code> loop is used to get the data of the following edges and to add them to the <code>result</code> list.</p>
<p>While analyzing the code, the <code>GetMinWeightIndex</code> private method is mentioned. Its code is presented in the following block:</p>
<pre class="source-code">
private int <strong class="bold">GetMinWeightIndex</strong>(
    int[] weights, bool[] isInMST)
{
    int minValue = int.MaxValue;
    int minIndex = 0;
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        if (!isInMST[i] &amp;&amp; weights[i] &lt; minValue)
        {
            minValue = weights[i];
            minIndex = i;
        }
    }
    return minIndex;
}</pre> <p>The <code>GetMinWeightIndex</code> method just finds an index of the node, which is not located in the MST and can be reached <a id="_idIndexMarker822"/>with the minimum cost. To do so, you use a <code>for</code> loop to iterate through<a id="_idIndexMarker823"/> all the nodes. For each of them, you check whether the current node is not located in the MST and whether the cost of reaching it is smaller than the already-stored minimum value. If so, the values of the <code>minValue</code> and <code>minIndex</code> variables are updated. Finally, the index is returned.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">Similar to Kruskal’s algorithm, Prim’s variant is also representative of a <strong class="bold">greedy algorithm</strong>. I strongly encourage you<a id="_idIndexMarker824"/> to search for even more interesting information about this algorithm in books, research papers, and on the internet. It is worth noting that the presented code is based on the implementation shown at <a href="https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/">https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/</a>.</p>
<p>Let’s take a look at the usage of the <code>MSTPrim</code> method:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 3); (...)
graph.AddEdge(n7, n8, 20);
<strong class="bold">List&lt;Edge&lt;int&gt;&gt; edges = graph.MSTPrim();</strong>
edges.ForEach(Console.WriteLine);</pre> <p>The missing parts of<a id="_idIndexMarker825"/> the code are the same as in the case of the exemplary code regarding <a id="_idIndexMarker826"/>Kruskal’s algorithm. When you run the code, you will get the following result:</p>
<pre class="console">
1 -&gt; 2. Weight: 3.
1 -&gt; 3. Weight: 5.
2 -&gt; 4. Weight: 4.
8 -&gt; 5. Weight: 1.
5 -&gt; 6. Weight: 4.
5 -&gt; 7. Weight: 5.
4 -&gt; 8. Weight: 8.</pre> <p>Now <a id="_idTextAnchor349"/>that we’ve looked at various algorithms for finding the MST, let’s proceed to an example.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor350"/>Example – telecommunication cable</h2>
<p>As mentioned in the introduction to the topic of MSTs, this problem has some important real-world applications, such as creating a plan of connections between buildings to supply all of them with a<a id="_idIndexMarker827"/> telecommunication cable with the smallest cost. Of course, there are various possible connections, such as from one building to another or using a hub. What’s more, environmental conditions can have a serious impact on the cost of the investment due to the necessity of crossing a road or even a river.</p>
<p>For example, let’s create a program that solves this problem in the context of a set of buildings, as shown in the following figure:</p>
<div><div><img alt="Figure 8.19 – Illustration of the telecommunication cable example" src="img/B18069_08_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Illustration of the telecommunication cable example</p>
<p>As you can see, the estate community consists of six buildings. The buildings are located on two sides of a small river with only one bridge. Moreover, two roads exist. Of course, there are different costs of connections between various points, depending both on the distance and the environmental conditions. For example, the direct connection between two buildings (<strong class="bold">B1</strong> and <strong class="bold">B2</strong>) has a cost equal to <strong class="bold">2</strong>, while using the bridge (between <strong class="bold">R1</strong> and <strong class="bold">R5</strong>) involves a cost equal to <strong class="bold">75</strong>. If you need to cross the river without a bridge (between <strong class="bold">R3</strong> and <strong class="bold">R6</strong>), the cost is even higher and equal to <strong class="bold">100</strong>.</p>
<p>Your task is to find the MST. Within this example, you will apply both Kruskal’s and Prim’s algorithms to solve<a id="_idIndexMarker828"/> this problem. To start, let’s initialize the undirected and weighted graph, as well as add nodes and edges, as follows:</p>
<pre class="source-code">
Graph&lt;string&gt; graph = new()
    { IsDirected = false, IsWeighted = true };
Node&lt;string&gt; nodeB1 = graph.AddNode("B1");
Node&lt;string&gt; nodeB2 = graph.AddNode("B2");
Node&lt;string&gt; nodeB3 = graph.AddNode("B3");
Node&lt;string&gt; nodeB4 = graph.AddNode("B4");
Node&lt;string&gt; nodeB5 = graph.AddNode("B5");
Node&lt;string&gt; nodeB6 = graph.AddNode("B6");
Node&lt;string&gt; nodeR1 = graph.AddNode("R1");
Node&lt;string&gt; nodeR2 = graph.AddNode("R2");
Node&lt;string&gt; nodeR3 = graph.AddNode("R3");
Node&lt;string&gt; nodeR4 = graph.AddNode("R4");
Node&lt;string&gt; nodeR5 = graph.AddNode("R5");
Node&lt;string&gt; nodeR6 = graph.AddNode("R6");
graph.AddEdge(nodeB1, nodeB2, 2);
graph.AddEdge(nodeB1, nodeB3, 20);
graph.AddEdge(nodeB1, nodeB4, 30);
graph.AddEdge(nodeB2, nodeB3, 30);
graph.AddEdge(nodeB2, nodeB4, 20);
graph.AddEdge(nodeB2, nodeR2, 25);
graph.AddEdge(nodeB3, nodeB4, 2);
graph.AddEdge(nodeB4, nodeR4, 25);
graph.AddEdge(nodeR1, nodeR2, 1);
graph.AddEdge(nodeR2, nodeR3, 1);
graph.AddEdge(nodeR3, nodeR4, 1);
graph.AddEdge(nodeR1, nodeR5, 75);
graph.AddEdge(nodeR3, nodeR6, 100);
graph.AddEdge(nodeR5, nodeR6, 3);
graph.AddEdge(nodeR6, nodeB5, 3);
graph.AddEdge(nodeR6, nodeB6, 10);
graph.AddEdge(nodeB5, nodeB6, 6);</pre> <p>Now, you just need to call the <code>MSTKruskal</code> method to use Kruskal’s algorithm to find the MST. When the results are obtained, you can easily present them in the console, together with the total<a id="_idIndexMarker829"/> cost. The suitable part of the code is shown in the following block:</p>
<pre class="source-code">
Console.WriteLine("Minimum Spanning Tree - Kruskal:");
<strong class="bold">List&lt;Edge&lt;string&gt;&gt; kruskal = graph.MSTKruskal();</strong>
kruskal.ForEach(Console.WriteLine);
Console.WriteLine("Cost: " + kruskal.Sum(e =&gt; e.Weight));</pre> <p>The results presented in the console are shown here:</p>
<pre class="console">
Minimum Spanning Tree - Kruskal:
R4 -&gt; R3. Weight: 1.
R3 -&gt; R2. Weight: 1.
R2 -&gt; R1. Weight: 1.
B1 -&gt; B2. Weight: 2.
B3 -&gt; B4. Weight: 2.
R6 -&gt; R5. Weight: 3.
R6 -&gt; B5. Weight: 3.
B6 -&gt; B5. Weight: 6.
B1 -&gt; B3. Weight: 20.
R2 -&gt; B2. Weight: 25.
R1 -&gt; R5. Weight: 75.
Cost: 139</pre> <p>If you visualize such results<a id="_idIndexMarker830"/> on the map, you’ll find the following MST:</p>
<div><div><img alt="Figure 8.20 – Illustration of the result of the telecommunication cable example" src="img/B18069_08_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Illustration of the result of the telecommunication cable example</p>
<p>Similarly, you can apply Prim’s algorithm:</p>
<pre class="source-code">
Console.WriteLine("\nMinimum Spanning Tree - Prim:");
<strong class="bold">List&lt;Edge&lt;string&gt;&gt; prim = graph.MSTPrim();</strong>
prim.ForEach(Console.WriteLine);
Console.WriteLine("Cost: " + prim.Sum(e =&gt; e.Weight));</pre> <p>The results are <a id="_idIndexMarker831"/>as follows:</p>
<pre class="console">
Minimum Spanning Tree - Prim:
B1 -&gt; B2. Weight: 2.
B1 -&gt; B3. Weight: 20.
B3 -&gt; B4. Weight: 2.
R6 -&gt; B5. Weight: 3.
B5 -&gt; B6. Weight: 6.
R2 -&gt; R1. Weight: 1.
B2 -&gt; R2. Weight: 25.
R2 -&gt; R3. Weight: 1.
R3 -&gt; R4. Weight: 1.
R1 -&gt; R5. Weight: 75.
R5 -&gt; R6. Weight: 3.
Cost: 139</pre> <p>You’ve just completed an example related to the real-world appl<a id="_idTextAnchor351"/>i<a id="_idTextAnchor352"/>cation of MSTs. Are you ready to proceed to another graph-related subject known as coloring?</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor353"/>Coloring</h1>
<p>The topic of finding the MST is <a id="_idIndexMarker832"/>not the only graph-related<a id="_idIndexMarker833"/> problem. Among others, <strong class="bold">node coloring</strong> exists. It aims to <strong class="bold">assign colors (numbers) to all nodes to comply with the rule that there cannot be an edge between two nodes with the same color</strong>. Of course, the number of colors should be as low as possible. Such a problem has some real-world applications, such as for coloring a map. The implementation of the coloring algorithm, which is shown in this chapter, is quite simple and in some cases could use more colors than is necessary.</p>
<p class="callout-heading">Four-color theorem</p>
<p class="callout">Did you know that the nodes of each planar graph can be colored with no more than four colors? If you are interested in this topic, take<a id="_idIndexMarker834"/> a look at the <strong class="bold">four-color theorem</strong> (<a href="http://mathworld.wolfram.com/Four-ColorTheorem.html">http://mathworld.wolfram.com/Four-ColorTheorem.html</a>). Since I am talking about a planar graph, you should understand that it is a graph whose edges do not cross each other while it is drawn on the plane.</p>
<p>Let’s take a look at the following<a id="_idIndexMarker835"/> diagram:</p>
<div><div><img alt="Figure 8.21 – Illustration of graph coloring" src="img/B18069_08_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – Illustration of graph coloring</p>
<p>The left-hand side illustration presents a graph that is colored using four colors: red (index equal to <strong class="bold">0</strong>), green (<strong class="bold">1</strong>), blue (<strong class="bold">2</strong>), and yellow (<strong class="bold">3</strong>). As you can see, there are no nodes with the same colors connected by an edge. The graph shown on the right depicts the graph with two additional edges, namely (<strong class="bold">2</strong>, <strong class="bold">6</strong>) and (<strong class="bold">2</strong>, <strong class="bold">5</strong>). In such a case, the coloring has changed, but the number of colors remains the same.</p>
<p>The question is, how can you find colors for nodes to comply with the aforementioned rule? Fortunately, the algorithm is <a id="_idIndexMarker836"/>very simple and its implementation is presented here. Here is the code of the <code>Color</code> method, which should be added to the <code>Graph</code> class:</p>
<pre class="source-code">
public int[] <strong class="bold">Color</strong>()
{
    <strong class="bold">int[] colors = new int[Nodes.Count];</strong>
    Array.Fill(colors, -1);
    colors[0] = 0;
    <strong class="bold">bool[] available = new bool[Nodes.Count];</strong>
    for (int i = 1; i &lt; Nodes.Count; i++)
    {
        Array.Fill(available, true);
        foreach (Node&lt;T&gt; neighbor in Nodes[i].Neighbors)
        {
            int ci = colors[neighbor.Index];
            <strong class="bold">if (ci &gt;= 0) { available[ci] = false; }</strong>
        }
        <strong class="bold">colors[i] = Array.IndexOf(available, true);</strong>
    }
    return colors;
}</pre> <p>The <code>Color</code> method uses two auxiliary node-related arrays. The first is named <code>colors</code> and stores indices of colors chosen for particular nodes. By default, the values of all elements are set to <code>-1</code>, except the first one, which is set to <code>0</code>. This means that the color of the first node is automatically set to the first color (for example, red). The other auxiliary array (<code>available</code>) stores information about the availability of particular colors.</p>
<p>The most crucial part of the code is the <code>for</code> loop. Within it, you reset the availability of colors by setting <code>true</code> as the <a id="_idIndexMarker837"/>value of all elements within the <code>available</code> array. Then, you iterate through the neighbor nodes of the current node to read their colors and mark such colors as unavailable by setting <code>false</code> as a value of a particular element in the <code>available</code> array. Then, you find the first available color for the current node and use it.</p>
<p>Let’s take a look at the usage of the <code>Color</code> method:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { IsDirected = false, IsWeighted = false };
Node&lt;int&gt; n1 = graph.AddNode(1);
Node&lt;int&gt; n2 = graph.AddNode(2);
Node&lt;int&gt; n3 = graph.AddNode(3);
Node&lt;int&gt; n4 = graph.AddNode(4);
Node&lt;int&gt; n5 = graph.AddNode(5);
Node&lt;int&gt; n6 = graph.AddNode(6);
Node&lt;int&gt; n7 = graph.AddNode(7);
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2);
graph.AddEdge(n1, n3);
graph.AddEdge(n2, n4);
graph.AddEdge(n3, n4);
graph.AddEdge(n4, n5);
graph.AddEdge(n4, n8);
graph.AddEdge(n5, n6);
graph.AddEdge(n5, n7);
graph.AddEdge(n5, n8);
graph.AddEdge(n6, n7);
graph.AddEdge(n7, n8);
<strong class="bold">int[] colors = graph.Color();</strong>
for (int i = 0; i &lt; colors.Length; i++)
{
    Console.WriteLine(
        $"Node {graph.Nodes[i].Data}: {<strong class="bold">colors[i]</strong>}");
}</pre> <p>Here, you create a new undirected<a id="_idIndexMarker838"/> and unweighted graph, the same as shown in the preceding figure, on the left. Then, you add nodes and edges, as well as call the <code>Color</code> method to perform the node coloring. As a result, you receive an array with indices of colors for particular nodes. Then, you present the results in the console:</p>
<pre class="console">
Node 1: 0
Node 2: 1
Node 3: 1
Node 4: 0
Node 5: 1
Node 6: 0
Node 7: 2
Node 8: 3</pre> <p>With this short introductio<a id="_idTextAnchor354"/>n<a id="_idTextAnchor355"/>, you are ready to proceed to the real-world application, namely for coloring the<a id="_idIndexMarker839"/> voivodeship map.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor356"/>Example – voivodeship map</h2>
<p>Let’s create a program that represents the map of voivodeships in Poland as a graph, and color such areas so that two <a id="_idIndexMarker840"/>voivodeships with common borders aren’t the same color. Of course, you should try to limit the number of colors.</p>
<p>To start, let’s think about the graph’s representation. Here, nodes represent particular voivodeships, while edges represent common borders between voivodeships.</p>
<p>The map of Poland with the graph already colored is shown in the following diagram:</p>
<div><div><img alt="Figure 8.22 – Illustration of the voivodeship map example" src="img/B18069_08_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Illustration of the voivodeship map example</p>
<p>Your task is just to color nodes in the graph using the previously described algorithm. To do so, you create an undirected <a id="_idIndexMarker841"/>and unweighted graph, add nodes representing voivodeships, and add edges to indicate common borders. The code is as follows:</p>
<pre class="source-code">
Graph&lt;string&gt; graph = new()
    { IsDirected = false, IsWeighted = false };
List&lt;string&gt; borders =
[
    "PK:LU|SK|MA",
    "LU:PK|SK|MZ|PD",
    "SK:PK|MA|SL|LD|MZ|LU",
    "MA:PK|SK|SL",
    "SL:MA|SK|LD|OP",
    "LD:SL|SK|MZ|KP|WP|OP",
    "WP:LD|KP|PM|ZP|LB|DS|OP",
    "OP:SL|LD|WP|DS",
    "MZ:LU|SK|LD|KP|WM|PD",
    "PD:LU|MZ|WM",
    "WM:PD|MZ|KP|PM",
    "KP:MZ|LD|WP|PM|WM",
    "PM:WM|KP|WP|ZP",
    "ZP:PM|WP|LB",
    "LB:ZP|WP|DS",
    "DS:LB|WP|OP"
];
Dictionary&lt;string, Node&lt;string&gt;&gt; nodes = [];
foreach (string border in borders)
{
    string[] parts = border.Split(':');
    string name = parts[0];
    nodes[name] = graph.AddNode(name);
}
foreach (string border in borders)
{
    string[] parts = border.Split(':');
    string name = parts[0];
    string[] vicinities = parts[1].Split('|');
    foreach (string vicinity in vicinities)
    {
        Node&lt;string&gt; from = nodes[name];
        Node&lt;string&gt; to = nodes[vicinity];
        if (!from.Neighbors.Contains(to))
        {
            graph.AddEdge(from, to);
        }
    }
}</pre> <p>Then, the <code>Color</code> method is called<a id="_idIndexMarker842"/> on the <code>Graph</code> instance and the color indices for particular nodes are returned. Finally, you present the results in the console. The suitable part of the code is as follows:</p>
<pre class="source-code">
<strong class="bold">int[] colors = graph.Color();</strong>
for (int i = 0; i &lt; colors.Length; i++)
{
    Console.WriteLine(
        $"{graph.Nodes[i].Data}: {colors[i]}");
}</pre> <p>The results are as follows:</p>
<pre class="console">
PK: 0
LU: 1
SK: 2
MA: 1
SL: 0
LD: 1
WP: 0
OP: 2
MZ: 0
PD: 2
WM: 1
KP: 2
PM: 3
ZP: 1
LB: 2
DS: 1</pre> <p>You just learned how to color nodes in a graph! However, this is not the end of the interesting topics regardi<a id="_idTextAnchor357"/><a id="_idTextAnchor358"/>ng <a id="_idIndexMarker843"/>graphs that will be presented in this book. Next, we’ll search for the shortest path in the graph.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor359"/>Shortest path</h1>
<p>A graph is a great data structure for storing data <a id="_idIndexMarker844"/>of various maps, such as cities and the distances between them. For this reason, one of the obvious real-world applications of graphs is <strong class="bold">searching for the </strong><strong class="bold">shortest path</strong><strong class="bold"> between two nodes, which takes into account a specific cost</strong>, such as the distance, the necessary time, or even the amount of fuel required.</p>
<p>There are several approaches to the topic of searching for the shortest path in a graph. However, one of the common<a id="_idIndexMarker845"/> solutions is <strong class="bold">Dijkstra’s algorithm</strong>, which makes it possible to <strong class="bold">calculate the distance from a starting node to all nodes located in the graph</strong>. Then, you can easily get not only the cost of the connection between two nodes but also find nodes that are between the start and end nodes.</p>
<p>Dijkstra’s algorithm uses two auxiliary node-related arrays:</p>
<ul>
<li>One for storing <a id="_idIndexMarker846"/>an identifier of the previous node, which is the node from which the current node can be reached with the smallest overall cost</li>
<li>One for storing the minimum distance (cost), which is necessary for accessing the current node</li>
</ul>
<p>What’s more, it uses the queue<a id="_idIndexMarker847"/> for storing nodes that should be checked. <strong class="bold">During the consecutive iterations, the algorithm updates the minimum distances to particular nodes in the graph</strong>. Finally, the auxiliary arrays contain the minimum distance (cost) to reach all the nodes from the chosen starting node, as well as information on how to reach each node using the shortest path.</p>
<p class="callout-heading">Where can you find more information?</p>
<p class="callout">You can find a lot of content about Dijkstra’s algorithm on the internet. Just search for its name and you will see a huge number of results. As an example, you can find useful content related to the implementation presented in this chapter at <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm</a>.</p>
<p>Let’s take a look at the following diagram, which presents two various shortest paths that have been found using Dijkstra’s algorithm. The left-hand side shows the path from node <strong class="bold">8</strong> to <strong class="bold">1</strong>, while the right-hand side shows the path from node <strong class="bold">1</strong> to <strong class="bold">7</strong>:</p>
<div><div><img alt="Figure 8.23 – Illustration of the shortest paths in a graph" src="img/B18069_08_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Illustration of the shortest paths in a graph</p>
<p>It is high time that you see some<a id="_idIndexMarker848"/> C# code that can be used to implement Dijkstra’s algorithm. The main role is performed by the <code>GetShortestPath</code> method, which should be added to the <code>Graph</code> class. The code is as follows:</p>
<pre class="source-code">
using Priority_Queue; (...)
public List&lt;Edge&lt;T&gt;&gt; <strong class="bold">GetShortestPath</strong>(
    Node&lt;T&gt; source, Node&lt;T&gt; target)
{
    <strong class="bold">int[] previous = new int[Nodes.Count];</strong>
    Array.Fill(previous, -1);
    <strong class="bold">int[] distances = new int[Nodes.Count];</strong>
    Array.Fill(distances, int.MaxValue);
    distances[source.Index] = 0;
    <strong class="bold">SimplePriorityQueue&lt;Node&lt;T&gt;&gt; nodes = new();</strong>
    for (int i = 0; i &lt; Nodes.Count; i++)
    {
        nodes.Enqueue(Nodes[i], distances[i]);
    }
    <strong class="bold">while (nodes.Count != 0)</strong>
    {
        <strong class="bold">Node&lt;T&gt; node = nodes.Dequeue();</strong>
        for (int i = 0; i &lt; node.Neighbors.Count; i++)
        {
            Node&lt;T&gt; neighbor = node.Neighbors[i];
            int weight = i &lt; node.Weights.Count
                ? node.Weights[i] : 0;
            <strong class="bold">int wTotal = distances[node.Index] + weight;</strong>
            if (distances[neighbor.Index] &gt; wTotal)
            {
                <strong class="bold">distances[neighbor.Index] = wTotal;</strong>
                <strong class="bold">previous[neighbor.Index] = node.Index;</strong>
                <strong class="bold">nodes.UpdatePriority(neighbor,</strong>
                    <strong class="bold">distances[neighbor.Index]);</strong>
            }
        }
    }
    List&lt;int&gt; indices = [];
    int index = target.Index;
    while (index &gt;= 0)
    {
        indices.Add(index);
        index = previous[index];
    }
    indices.Reverse();
    List&lt;Edge&lt;T&gt;&gt; result = [];
    for (int i = 0; i &lt; indices.Count - 1; i++)
    {
        Edge&lt;T&gt; edge = this[indices[i], indices[i + 1]]!;
        result.Add(edge);
    }
    return result;
}</pre> <p>The <code>GetShortestPath</code> method takes two parameters, namely <code>source</code> and <code>target</code> nodes. First, it creates two node-related auxiliary arrays for storing the indices of previous nodes, from which the<a id="_idIndexMarker849"/> given node can be reached with the smallest overall cost (<code>previous</code>), as well as for storing the current minimum distances to the given node (<code>distances</code>). By default, the values of all elements in the <code>previous</code> array are set to <code>-1</code>, while in the <code>distances</code> array, they are set to the maximum value of the <code>int</code> type. Of course, the distance to the source node is set to <code>0</code>.</p>
<p>Then, you create a new priority queue and enqueue the data of all nodes. The priority of each element is equal to the current distance to such a node. Here, you use the same implementation of a priority queue, as presented in <a href="B18069_05.xhtml#_idTextAnchor165"><em class="italic">Chapter 5</em></a>, <em class="italic">Stacks and Queues</em>, namely from the <code>OptimizedPriorityQueue</code> NuGet package.</p>
<p>The most interesting part of the code is the <code>while</code> loop, which is executed until the queue is empty. Within this <code>while</code> loop, you get the first node from the queue and iterate through all of its neighbors using a <code>for</code> loop. Inside such a loop, you calculate the distance to a neighbor by taking the sum of the distance to the current node and the weight of the edge. If the calculated distance is smaller than the currently stored value, you update the values regarding the minimum distance to the given neighbor, as well as the index of the previous node, from <a id="_idIndexMarker850"/>which you can reach the neighbor. It’s worth noting that the priority of the element in the queue should be updated as well.</p>
<p>The remaining operations are used to resolve the path using the values stored in the <code>previous</code> array. To do so, you save the indices of the following nodes in the <code>indices</code> list. Then, you reverse it to achieve the order from the source node to the target one. Finally, you create the list of edges to present the result in a form that’s suitable for returning from the method.</p>
<p>Let’s take a look at the usage of the <code>GetShortestPath</code> method:</p>
<pre class="source-code">
Graph&lt;int&gt; graph = new()
    { IsDirected = true, IsWeighted = true };
Node&lt;int&gt; n1 = graph.AddNode(1); (...)
Node&lt;int&gt; n8 = graph.AddNode(8);
graph.AddEdge(n1, n2, 9); (...)
graph.AddEdge(n8, n5, 3);
<strong class="bold">List&lt;Edge&lt;int&gt;&gt; path = graph.GetShortestPath(n1, n5);</strong>
path.ForEach(Console.WriteLine);</pre> <p>Here, you create a new directed and weighted graph, as well as add nodes and edges. The missing parts of the code are the same as in the case of the <em class="italic">directed and weighted edges</em> example. Then, you call the <code>GetShortestPath</code> method to search for the shortest path between nodes <code>1</code> and <code>5</code>. As a result, you receive a list of edges forming the shortest path. Then, you just iterate through all the edges and present the results in the console:</p>
<pre class="console">
1 -&gt; 3. Weight: 5.
3 -&gt; 4. Weight: 12.
4 -&gt; 8. Weight: 8.
8 -&gt; 5. Weight: 3.</pre> <p>With this short introduction, together with<a id="_idTextAnchor360"/><a id="_idTextAnchor361"/> a simple example, let’s proceed to a more advanced and interesting <a id="_idIndexMarker851"/>application related to game development.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor362"/>Example – path in game</h2>
<p>The last example we’ll cover in this chapter involves the application of Dijkstra’s algorithm to find the shortest path in a game<a id="_idIndexMarker852"/> map. Let’s imagine that you have a board with various obstacles. For this reason, the player can use only part of the board to move. Your task is to find the shortest path between two places located on the board.</p>
<p>To start, let’s represent the board as a jagged array. The suitable part of the code is shown here:</p>
<pre class="source-code">
using System.Text;
string[] lines = new string[]
{
    "<strong class="bold">00</strong>111<strong class="bold">00000</strong>11111<strong class="bold">00000</strong>11111",
    "<strong class="bold">00</strong>111<strong class="bold">00000</strong>11111<strong class="bold">00000</strong>11111",
    "<strong class="bold">00</strong>111<strong class="bold">00000</strong>11111<strong class="bold">00000</strong>11111",
    "<strong class="bold">00000000000</strong>111<strong class="bold">000000</strong>11111",
    "<strong class="bold">000000</strong>111<strong class="bold">00000000000</strong>11111",
    "<strong class="bold">000</strong>1<strong class="bold">00</strong>111<strong class="bold">00</strong>111<strong class="bold">000000</strong>11111",
    "111111111111111<strong class="bold">0</strong>1111111<strong class="bold">00</strong>",
    "111111111111111<strong class="bold">0</strong>1111111<strong class="bold">0</strong>1",
    "111111111111111<strong class="bold">0</strong>1111111<strong class="bold">00</strong>",
    "<strong class="bold">0000000000000000</strong>11111111<strong class="bold">0</strong>",
    "<strong class="bold">0000000000000000</strong>1111111<strong class="bold">00</strong>",
    "<strong class="bold">000</strong>1111111<strong class="bold">00</strong>11<strong class="bold">0000000</strong>11<strong class="bold">0</strong>1",
    "<strong class="bold">000</strong>1111111<strong class="bold">00</strong>11<strong class="bold">0000000</strong>11<strong class="bold">00</strong>",
    "<strong class="bold">000</strong>11<strong class="bold">00000000000</strong>11111111<strong class="bold">0</strong>",
    "11111<strong class="bold">00000000000</strong>1111111<strong class="bold">00</strong>",
    "11111<strong class="bold">000</strong>11<strong class="bold">00</strong>11<strong class="bold">00</strong>1<strong class="bold">000</strong>1<strong class="bold">000</strong>1",
    "11111<strong class="bold">000</strong>11<strong class="bold">00</strong>11<strong class="bold">0000</strong>1<strong class="bold">000</strong>1<strong class="bold">00</strong>"
};
<strong class="bold">bool[][] map = new bool[lines.Length][];</strong>
for (int i = 0; i &lt; lines.Length; i++)
{
    <strong class="bold">map[i] = lines[i]</strong>
        <strong class="bold">.Select(c =&gt; int.Parse(c.ToString()) == 0)</strong>
        <strong class="bold">.ToArray();</strong>
}</pre> <p>To improve the readability of code, the map is represented as an array of <code>string</code> values. Each row is presented as text, with<a id="_idIndexMarker853"/> the number of characters equal to the number of columns. The value of each character indicates the availability of the point. If it is equal to <code>0</code>, the position is available. Otherwise, it is not. The <code>string</code>-based map representation should then be converted into the Boolean jagged array. Such a task is performed by a few lines of code, as shown in the preceding snippet.</p>
<p>The next step is to create the<a id="_idIndexMarker854"/> graph, as well as add the necessary nodes and edges. The suitable part of the code is as follows:</p>
<pre class="source-code">
<strong class="bold">Graph&lt;string&gt; graph = new()</strong>
    <strong class="bold">{ IsDirected = false, IsWeighted = true };</strong>
for (int i = 0; i &lt; map.Length; i++)
{
    for (int j = 0; j &lt; map[i].Length; j++)
    {
        if (!map[i][j]) { continue; }
        <strong class="bold">Node&lt;string&gt; from = graph.AddNode($"{i}-{j}");</strong>
        if (i &gt; 0 &amp;&amp; map[i - 1][j])
        {
            Node&lt;string&gt; to = graph.Nodes
                .Find(n =&gt; n.Data == $"{i - 1}-{j}")!;
            <strong class="bold">graph.AddEdge(from, to, 1);</strong>
        }
        if (j &gt; 0 &amp;&amp; map[i][j - 1])
        {
            Node&lt;string&gt; to = graph.Nodes
                .Find(n =&gt; n.Data == $"{i}-{j - 1}")!;
            <strong class="bold">graph.AddEdge(from, to, 1);</strong>
        }
    }
}</pre> <p>First, you initialize a new undirected and weighted graph. Then, you use two <code>for</code> loops to iterate through all the places on the board. Within such loops, you check whether the given place is available. If so, you create a new node (<code>from</code>). Then, you check whether the node placed immediately<a id="_idIndexMarker855"/> above the current one is also available. If so, a suitable edge is added with a weight equal to <code>1</code>. Similarly, you can check whether the node placed on the left of the current one is available and add an edge if necessary.</p>
<p>Now, you just need to get the <code>Node</code> instances representing the source and the target nodes. You can do so by using the <code>Find</code> method and providing the textual representation of the node – for example, <code>0-0</code> or <code>16-24</code>. Then, you call the <code>GetShortestPath</code> method. In this case, the algorithm will try to find the shortest path between the node in the first row and column and the node in the last row and column. The code is presented in the following block:</p>
<pre class="source-code">
Node&lt;string&gt; s = graph.Nodes.Find(n =&gt; n.Data == "0-0")!;
Node&lt;string&gt; t = graph.Nodes.Find(n =&gt; n.Data == "16-24")!;
<strong class="bold">List&lt;Edge&lt;string&gt;&gt; path = graph.GetShortestPath(s, t);</strong></pre> <p>The last part of the code is related to presenting the map in the console:</p>
<pre class="source-code">
Console.OutputEncoding = Encoding.UTF8;
for (int r = 0; r &lt; map.Length; r++)
{
    for (int c = 0; c &lt; map[r].Length; c++)
    {
        bool isPath = path.Any(e =&gt;
            e.From.Data == $"{r}-{c}"
            || e.To.Data == $"{r}-{c}");
        <strong class="bold">Console.ForegroundColor = isPath</strong>
            <strong class="bold">? ConsoleColor.White</strong>
            <strong class="bold">: map[r][c]</strong>
                <strong class="bold">? ConsoleColor.Green</strong>
                <strong class="bold">: ConsoleColor.Red;</strong>
        Console.Write("\u25cf ");
    }
    Console.WriteLine();
}
Console.ResetColor();</pre> <p>To start, you set the proper encoding in the console to be able to present Unicode characters as well. Then, you use two <code>for</code> loops to iterate through all the places on the board. Inside such loops, you choose a color that should be used to represent a point in the console, either green (the point is available) or red (unavailable). If the currently-analyzed point is a part of the <a id="_idIndexMarker856"/>shortest path, the white color is set. Finally, you write the Unicode character representing a bullet. When the program’s execution exits both loops, the console’s color is reset.</p>
<p>When you run the application, you will see the following result:</p>
<div><div><img alt="Figure 8.24 –﻿ ﻿Screenshot of the game map example" src="img/B18069_08_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 –<a id="_idTextAnchor363"/> <a id="_idTextAnchor364"/>Screenshot of the game map example</p>
<p>Great work! Now, let’s<a id="_idIndexMarker857"/> summarize the topics that were covered in this chapter.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor365"/>Summary</h1>
<p>This chapter was related to one of the most important data structures available while developing applications: graphs. As you learned, a <strong class="bold">graph</strong> is a data structure that consists of <strong class="bold">nodes</strong> and <strong class="bold">edges</strong>. Each edge connects two nodes. What’s more, there are various variants of edges, such as undirected and directed, as well as unweighted and weighted. All of them were described and explained in detail, and illustrations and code examples were provided. Two methods of graph representation, namely using an <strong class="bold">adjacency list</strong> and an <strong class="bold">adjacency matrix</strong>, were explained as well. You also learned how to implement a graph in the C# language.</p>
<p>While talking about graphs, it’s important to present some <strong class="bold">real-world applications</strong>, especially due to the common use of such a data structure. For example, this chapter explained the structure of friends that are available on social media or the problem of searching for the shortest path in a city.</p>
<p>Among the topics that were covered in this chapter, you learned how to traverse a graph to visit all of the nodes in some particular order. Two approaches were presented, namely <strong class="bold">DFS</strong> and <strong class="bold">BFS</strong>. It’s worth mentioning that the traversal topic can be also applied to searching for a given node in a graph.</p>
<p>Next, the subject of <strong class="bold">spanning trees</strong>, as well as <strong class="bold">minimum spanning trees</strong>, was introduced. As a reminder, a spanning tree is a subset of edges that connects all nodes in a graph without cycles, while an MST is a spanning tree with the minimum cost from all spanning trees available in the graph. There are a few approaches to finding the MST, including <strong class="bold">Kruskal’s</strong> and <strong class="bold">Prim’s algorithms</strong>.</p>
<p>Then, you learned how to solve the problem of <strong class="bold">coloring</strong>, where you assigned colors (numbers) to all the nodes to comply with the rule that there cannot be an edge between two nodes with the same color.</p>
<p>The other problem was searching for the <strong class="bold">shortest path between two nodes</strong>, which takes into account a specific cost, such as the distance, the necessary time, or even the amount of fuel required. There are several approaches to the topic of searching for the shortest path in a graph. However, one of the common solutions is <strong class="bold">Dijkstra’s algorithm</strong>, which makes it possible to calculate the distance from a starting node to all the nodes located in the graph. We covered this in detail in this chapter.</p>
<p>Now, i<a id="_idTextAnchor366"/>t is high time to proceed to the next chapter, which focuses on <strong class="bold">practical aspects of algorithms</strong> from various groups, including recursive, greedy, back-tracking, and even genetic. Let’s turn the page and see them in action!</p>
</div>
</body></html>