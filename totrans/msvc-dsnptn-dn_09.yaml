- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building Resilient Microservices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建弹性的微服务
- en: Coming off the heels of the Saga pattern, we can appreciate the value of having
    fail-safes built into our microservices application. We need to ensure that we
    adequately handle inevitable failures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Saga 模式之后，我们可以欣赏到在我们的微服务应用程序中内置安全措施的价值。我们需要确保我们充分处理不可避免的故障。
- en: We can’t assume that our distributed microservices will always be up and running.
    We also can’t assume that our supporting infrastructure will be reliable. These
    considerations lead us down a path where we must anticipate the occurrence of
    failures, whether prolonged or transient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能假设我们的分布式微服务始终处于运行状态。我们也不能假设我们的支持性基础设施将是可靠的。这些考虑让我们必须预测失败的发生，无论是长期的还是短暂的。
- en: A prolonged outage can be due to a downed server or service, some generally
    important part of the infrastructure. These tend to be easier to detect and mitigate
    since they have a more obvious impact on the runtime of the application. Transient
    failures are far more difficult to detect since they can last a few seconds to
    a few minutes at a time and aren’t usually tied to any obvious issue in the infrastructure.
    Something as simple as a service taking 5 seconds extra to respond can be seen
    as a transient failure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间的中断可能是由服务器或服务的故障，或基础设施的一些通常很重要的部分引起的。这些通常更容易检测和缓解，因为它们对应用程序的运行时间有更明显的影响。瞬态故障的检测要困难得多，因为它们可能持续几秒钟到几分钟，通常与基础设施中的任何明显问题无关。一个服务响应时间多出5秒的情况也可以被视为瞬态故障。
- en: It is very important that we not only write code that doesn’t break the application
    because of a transient issue but also know when to break that application when
    we have a more serious failure. This is an important part of gauging the user’s
    experience with our application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的一点是，我们不仅要编写不会因为瞬态问题而破坏应用程序的代码，还要知道在遇到更严重的故障时何时中断该应用程序。这是衡量用户对我们应用程序体验的重要部分。
- en: In this chapter, we will look at various scenarios and countermeasures that
    we can implement when navigating possible failures in our microservices architecture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在微服务架构中导航可能的故障时可以实施的多种场景和对策。
- en: 'After reading this chapter, we will understand how to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，我们将了解如何做以下事情：
- en: Build resilient microservice communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建弹性的微服务通信
- en: Implement a caching layer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施缓存层
- en: Implement retry and circuit breaker policies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施重试和断路器策略
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Code references used in this chapter can be found in the project repository,
    which is hosted on GitHub at this URL: [https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码参考可以在项目仓库中找到，该仓库托管在GitHub上，网址为：[https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09](https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch09)。
- en: The importance of service resiliency
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务弹性的重要性
- en: Before we get into technical explanations, let us try to understand what it
    means to be resilient. The word *resilient* is the base word for *resiliency*,
    and it refers to how impervious an entity is to negative factors. It refers to
    how well an entity reacts to an inevitable failure and how well an entity can
    resist future failures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入技术解释之前，让我们尝试理解什么是弹性。单词*resilient*是*resiliency*的基础词，它指的是实体对负面因素的抵抗力。它指的是实体对不可避免的故障的反应能力以及实体能够抵抗未来故障的能力。
- en: In the context of our microservices architecture, our entities are our services,
    and we know that failures will happen. A failure can be as simple as a timeout
    during an internal operation, a loss of communication, or an unexpected outage
    of an important resource for the service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务架构的背景下，我们的实体是我们的服务，我们知道故障会发生。故障可能很简单，比如内部操作中的超时，通信丢失，或者服务的重要资源意外中断。
- en: Possible failure scenarios and how to handle them
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能的故障场景及其处理方法
- en: 'Using the example of our healthcare booking system, let us say that our appointments
    service needs to retrieve the details of the related patient. The *appointments
    service* will make a synchronous HTTP call to the *patients service*. The steps
    in this communication step may look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的医疗预约系统为例，让我们假设我们的预约服务需要检索相关患者的详细信息。*预约服务*将对*患者服务*进行同步HTTP调用。在这个通信步骤中的步骤可能看起来像这样：
- en: The *appointments service* makes an HTTP request to the *patients service*,
    passing the patient ID (`AppointmentsController.cs`).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*预约服务*向*患者服务*发起HTTP请求，传递患者ID（`AppointmentsController.cs`）。'
- en: The *patients service* receives the HTTP request and executes a query to look
    up the patient’s record (`PatientsController.cs`).
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*患者服务*接收HTTP请求并执行查询以查找患者的记录（`PatientsController.cs`）。'
- en: The *patients service* responds to the *appointment booking service* with the
    appropriate data.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*患者服务*以适当的数据响应*预约服务*。'
- en: So far, we have come to expect this from our *synchronous service* communication
    flow. This, however, is the ideal flow where everything works as expected, and
    based on your infrastructure, you can guarantee a certain degree of success each
    time. What we need to account for is the balance—the few times that the flow might
    get interrupted and not complete the chain of operations successfully. It could
    be because of a failure, or maybe we just need a little more time. It could also
    be that we need to cut the call short because it is taking too long.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从我们的*同步服务*通信流程中期待这种情况。然而，这是一个一切按预期工作的理想流程，根据你的基础设施，你可以保证每次都能达到一定的成功率。我们需要考虑的是平衡——流程可能被中断的少数几次，并且没有成功完成操作链。这可能是因为失败，或者我们可能只需要更多一点时间。也可能是因为我们需要提前结束调用，因为它花费了太长时间。
- en: 'Now, let us review the same kind of service call where something fails along
    the way:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下在服务调用过程中出现失败的情况：
- en: The *patients service* makes an HTTP request to the *appointment booking service*,
    passing the patient ID.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*患者服务*向*预约服务*发起HTTP请求，传递患者ID。'
- en: The *appointment booking service* responds with a `BAD GATEWAY (502)` error
    code.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*预约服务*响应了一个`BAD GATEWAY (502)`错误代码。'
- en: The *patients service* throws an exception immediately when given the `BAD GATEWAY`
    response.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*患者服务*接收到`BAD GATEWAY`响应时，会立即抛出异常。
- en: The user receives an error message.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户收到错误消息。
- en: In this situation, we received a premature termination of the appointment booking
    service call. HTTP responses in the `5xx` range indicate that there is an issue
    with the resource or server associated with the appointment booking service. These
    `5xx` errors may be temporary, and an immediate follow-up request would work.
    A `BAD GATEWAY` error, specifically, can be due to poor server configuration,
    proxy server outage, or a simple response to one too many requests at that moment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们收到了预约服务调用提前终止的情况。`5xx`范围内的HTTP响应表明与预约服务相关的资源或服务器存在问题。这些`5xx`错误可能是临时的，立即的后续请求可能会成功。特别是`BAD
    GATEWAY`错误可能是由于服务器配置不良、代理服务器故障或当时对请求响应过多。
- en: In addressing these issues, sometimes we can retry the requests, or have an
    alternative data source on standby. While we will be discussing retry logic later
    in the book, we explore using some form of caching layer that allows us to maintain
    a stable data layer from which we can pull the information we require.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决这些问题时，有时我们可以重试请求，或者有一个备用的数据源。虽然我们将在本书的后面讨论重试逻辑，但我们探索使用某种形式的缓存层，使我们能够维护一个稳定的数据层，从中我们可以获取所需的信息。
- en: Let us review how we can implement a caching layer to assist with this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下如何实现一个缓存层来协助这个问题。
- en: Implementing resiliency with caching and message brokers
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓存和消息代理实现弹性
- en: We will be diving into how we can make our services resilient using **retry
    policies** and the **circuit breaker pattern**, but we are not limited to these
    methods in our microservices architecture. We can help to support service resiliency
    using **caching** and **message broker** mechanisms. Adding a caching layer allows
    us to create a temporary intermediary data store, which becomes useful when we
    are attempting to retrieve data from a service that is offline at the moment.
    Our message brokers help to ensure that messages will get delivered, which is
    mostly useful for write operations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨如何使用**重试策略**和**断路器模式**来使我们的服务具有弹性，但我们的微服务架构并不局限于这些方法。我们可以通过**缓存**和**消息代理**机制来支持服务的弹性。添加一个缓存层允许我们创建一个临时中间数据存储，这在尝试从当前离线的服务检索数据时非常有用。我们的消息代理有助于确保消息将被投递，这对于写操作尤其有用。
- en: Let us discuss message brokers and how they help us with our resiliency.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论消息代理以及它们如何帮助我们实现弹性。
- en: Using a message broker
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息代理
- en: '**Message brokers** have a higher guarantee of data delivery, which increases
    resiliency. This is built on the foundation that the message broker will not be
    unavailable for an extended period, but once a message is placed on the message
    bus, it will not matter if the listening service(s) is not online. As we discussed
    earlier, we can almost guarantee that data will be posted successfully through
    asynchronous communication, since message brokers are designed to retain the information
    until it is consumed.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息代理**提供了更高的数据交付保证，这增加了弹性。这是建立在消息代理不会长时间不可用的基础上的，一旦消息被放置在消息总线上，即使监听服务（或服务）离线，也不会有任何影响。正如我们之前讨论的，我们可以几乎保证数据将通过异步通信成功发布，因为消息代理被设计为保留信息，直到它被消费。'
- en: Message brokers also support retry logic where if a message is not processed
    successfully for whatever reason, it is returned to the queue for processing later.
    We want to manage the number of message delivery retries, so we should configure
    our message broker to transfer a message to a *dead-letter* queue, where we store
    *poisoned* messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理也支持重试逻辑，如果由于任何原因消息没有成功处理，它将被返回到队列以稍后处理。我们想要管理消息投递的重试次数，因此我们应该配置我们的消息代理将消息传输到*死信*队列，在那里我们存储*毒化*消息。
- en: We also need to consider how we handle message duplications. This could happen
    if we send a message to the queue that does not get processed immediately for
    some reason, and then the message gets sent to the queue again from a retry. This
    would result in the same message in the queue twice and not necessarily in the
    correct order, or one behind the other. We must ensure that our messages contain
    enough information to allow us to adequately develop redundancy checks in our
    message consumers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑如何处理消息重复。如果由于某种原因我们没有立即处理发送到队列的消息，然后消息再次从重试中发送到队列，这种情况就会发生。这会导致队列中出现两次相同消息，并且不一定按正确顺序排列，或者一个接一个。我们必须确保我们的消息包含足够的信息，以便我们能够在消息消费者中充分开发冗余检查。
- en: We explored integrating with message brokers in earlier chapters as we discussed
    asynchronous communication between services. Now, let us explore implementing
    a caching layer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中探讨了与消息代理的集成，因为我们讨论了服务之间的异步通信。现在，让我们探索实现缓存层。
- en: Using a caching layer
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存层
- en: '**Caching** can be a valuable part of the resiliency strategy. We can incorporate
    a caching strategy where we fall back on this cache if a service is offline. This
    means that we can use the caching layer as a fallback data source and create an
    illusion to the end user that all services are up and running. This cache would
    get periodically updated and maintained each time data is modified in the database
    of the source service. This will help with keeping the cached data fresh.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**可以是弹性策略中的一个宝贵部分。我们可以采用一种缓存策略，在服务离线时回退到这个缓存。这意味着我们可以将缓存层用作回退数据源，并给最终用户造成所有服务都在运行中的错觉。这个缓存将定期更新和维护，每次修改源服务数据库中的数据时都会进行。这将有助于保持缓存数据的更新。'
- en: Of course, with this strategy, we need to accept the implications of having
    potentially stale data. If the source service is offline and the supporting database
    is being updated (possibly by other jobs), then the cache will eventually become
    a stale data source. The more measures we put in place to ensure its freshness,
    the more complexity we introduce to our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，采用这种策略，我们需要接受可能存在过时数据的影响。如果源服务离线并且支持数据库正在更新（可能由其他作业进行），那么缓存最终会变成一个过时数据源。我们采取的确保其新鲜度的措施越多，我们引入的应用程序复杂性就越大。
- en: Notwithstanding the potential pros and cons of adding a caching layer, we can
    see where it will be a great addition to our microservices application and reduce
    the number of errors that a user might see, stemming from transient and even longer-term
    failures.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管添加缓存层可能有利有弊，但我们能看到它将极大地增强我们的微服务应用程序，并减少用户可能看到的错误数量，这些错误源于短暂甚至长期的故障。
- en: The most effective way to implement a caching layer is as a distributed cache.
    This means that all systems in the architecture will be able to access the central
    cache, which exists as an external and standalone service. This implementation
    can increase speed and support scaling. We can use Redis Cache as our distributed
    cache technology, and we will investigate how we can integrate this into an ASP.NET
    Core application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现缓存层最有效的方法是作为分布式缓存。这意味着架构中的所有系统都将能够访问中央缓存，该缓存作为一个外部独立服务存在。这种实现可以提高速度并支持扩展。我们可以使用
    Redis 缓存作为我们的分布式缓存技术，我们将研究如何将其集成到 ASP.NET Core 应用程序中。
- en: Using Redis Cache
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis 缓存
- en: '**Redis Cache** is a popular caching database technology. It is an open source
    in-memory data store that can also be used as a message broker. It can be implemented
    on a local machine for local development efforts but is also at times deployed
    on a central server for more distributed systems. Redis Cache is a key-value store
    that uses a unique key to index a value, and no two values can have the same key.
    This makes it very easy to store and retrieve data from this type of data store.
    In addition to that, values may be stored in very simple data types such as strings,
    numbers, and lists, but JSON format is popularly used for more complex object
    types. This way, we can serialize and deserialize this string in our code and
    proceed as needed.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis 缓存** 是一种流行的缓存数据库技术。它是一个开源的内存数据存储，也可以用作消息代理。它可以在本地机器上用于本地开发工作，但有时也会部署在中央服务器上以支持更分布式系统。Redis
    缓存是一个键值存储，使用唯一的键来索引值，且没有两个值可以具有相同的键。这使得从这种类型的数据存储中存储和检索数据变得非常容易。除此之外，值可以存储在非常简单的数据类型中，如字符串、数字和列表，但
    JSON 格式在更复杂的对象类型中更为流行。这样，我们可以在代码中序列化和反序列化这个字符串，并按需进行操作。'
- en: 'There is also extensive support for Redis Cache on cloud providers such as
    Microsoft Azure and **Amazon Web Services** (**AWS**). For this exercise, you
    may install the Redis Cache locally, or use a **Docker** container. To start using
    Redis Cache in our project, we need to run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在云提供商如 Microsoft Azure 和 **Amazon Web Services**（**AWS**）上对 Redis 缓存也有广泛的支持。对于这个练习，您可以在本地安装
    Redis 缓存，或者使用 **Docker** 容器。要开始在项目中使用 Redis 缓存，我们需要运行以下命令：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then need to register our cache in our `Program.cs` file, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在我们的 `Program.cs` 文件中注册我们的缓存，如下所示：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may configure your connection string in either the `appsettings.json` file
    or in application secrets. It will look something like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `appsettings.json` 文件或应用程序密钥中配置连接字符串。它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These steps add caching support to our application. Now, we can read from and
    write to the cache as needed in our application. Generally, we want to write to
    the cache when data is augmented. New data should be written to the cache—we can
    remove the old version and create a new version for modified data; for deleted
    data, we also delete the data from the cache.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤为我们的应用程序添加了缓存支持。现在，我们可以在应用程序中按需读取和写入缓存。通常，当数据被增强时，我们希望写入缓存——新数据应写入缓存——我们可以删除旧版本并为修改后的数据创建新版本；对于已删除的数据，我们也会从缓存中删除数据。
- en: 'We can create a singular `CacheProvider` interface and implementation as a
    wrapper around our desired cache operations. Our interface will look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个单一的 `CacheProvider` 接口和实现，作为我们所需缓存操作的包装器。我们的接口看起来像这样：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our implementation looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现看起来像这样：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code allows us to interact with our distributed caching service and retrieve,
    set, or remove values based on their associated key. This service can be registered
    in our **inversion of control** (**IoC**) container and injected into our controllers
    and repositories as needed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许我们与我们的分布式缓存服务交互，并根据其关联的键检索、设置或删除值。此服务可以在我们的 **控制反转**（**IoC**）容器中注册，并根据需要注入到我们的控制器和存储库中。
- en: The idea here is that we can use the `GetFromCache` method when we need to read
    the values from the cache. The key allows us to narrow down to the entry we are
    interested in, and the `T` generic parameter allows us to define the desired data
    type. If we need to update the data in the cache, we can clear the cache record
    associated with the appropriate key and then use `SetCache` to place new data
    with an associated key. We will parse the new data to JSON to ensure that we do
    not violate the supported data types while maintaining the ability to store complex
    data. When we are adding new data, we simply need to call `SetCache` and add the
    new data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，当我们需要从缓存中读取值时，我们可以使用`GetFromCache`方法。键允许我们缩小到我们感兴趣的条目，而`T`泛型参数允许我们定义所需的数据类型。如果我们需要更新缓存中的数据，我们可以清除与适当键关联的缓存记录，然后使用`SetCache`将带有相关键的新数据放置进去。我们将解析新数据到JSON，以确保我们不违反支持的数据类型，同时保持存储复杂数据的能力。当我们添加新数据时，我们只需调用`SetCache`并添加新数据。
- en: We also want to ensure that we maintain the freshness of the data as much as
    possible. A popular pattern involves clearing the cache and making a fresh entry
    each time data is entered or updated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望尽可能保持数据的 freshness。一个流行的模式是在数据输入或更新时清除缓存并创建一个新的条目。
- en: We can use these bits of code in our application and implement a caching layer
    to improve not only performance but resiliency and stability. We still have the
    issue of retrying operations when they fail the initial call. In the next section,
    we will look at how we can implement our retry logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的应用程序中使用这些代码片段并实现一个缓存层来提高性能、弹性和稳定性。我们仍然面临在操作失败初始调用时重试操作的问题。在下一节中，我们将探讨我们如何实现我们的重试逻辑。
- en: Implementing retry and circuit breaker policies
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现重试和断路器策略
- en: Services fail for various reasons. A typical response to a service failure is
    an HTTP response in the *5xx* range. These typically highlight an issue with the
    hosting server or a temporary outage in the network hosting the service. Without
    trying to pinpoint the exact cause of the failure at the time it happens, we need
    to add some fail-safes to ensure the continuity of the application when these
    types of errors occur.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 服务失败有多种原因。对服务失败的典型响应是HTTP响应在*5xx*范围内。这些通常突出显示托管服务器的问题或服务所在网络的暂时中断。在发生故障时，我们不尝试确定故障的确切原因，我们需要添加一些安全措施来确保在发生此类错误时应用程序的连续性。
- en: For this reason, we should use retry logic in our service calls. These will
    automatically resubmit the initial request if an error code is returned, which
    might be enough time for a transient error to resolve itself and reduce the effects
    that the initial error might have on the entire system and operation. In this
    policy, we generally allow for some time to pass between each request attempt.
    This sums up our retry policy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该在我们的服务调用中使用重试逻辑。如果返回错误代码，这些逻辑将自动重新提交初始请求，这可能足以让短暂错误自行解决，并减少初始错误可能对整个系统和操作产生的影响。在这个策略中，我们通常允许在每次请求尝试之间经过一段时间。这就是我们的重试策略的总结。
- en: What we don’t want to do with our retries is to continue to execute them without
    some form of exit condition. This would be like implementing an infinite loop
    if the target service remains unresponsive and inadvertently executing a **denial-of-service**
    (**DoS**) attack on our own service. For this reason, we implement the circuit
    breaker pattern, which acts as an orchestrator for our service calls.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在我们的重试中继续执行它们而没有某种形式的退出条件。如果目标服务保持无响应，这将类似于实现一个无限循环，并且无意中对我们自己的服务执行**拒绝服务**（**DoS**）攻击。因此，我们实现断路器模式，它充当我们服务调用的协调器。
- en: We will need to implement a **retry policy** to at least make the call several
    times before concluding a definite failure. This will make our service more resilient
    to a potentially fleeting error and allow the application to ensure that the user’s
    experience isn’t directly affected by such an issue. Now, retries are not always
    the answer. A retry here makes sense since the service is responding with a clear-cut
    failure, and we are deciding to try again. We need to decide how many retries
    are too many and stop accordingly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现一个**重试策略**，至少在得出明确的失败结论之前进行几次调用。这将使我们的服务更能抵抗潜在的短暂错误，并允许应用程序确保用户体验不会直接受到影响。现在，重试并不总是答案。在这里进行重试是有意义的，因为服务以明确的失败响应，我们决定再次尝试。我们需要决定重试次数过多，并相应地停止。
- en: We can use the **circuit breaker pattern** to control the number of retries
    and set parameters that will govern how long a connection should stay open and
    listen for a response. This simple technique helps to reduce the number of retries
    and provides better control over how retries occur.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **断路器模式** 来控制重试次数并设置将决定连接应保持打开并监听响应多长时间的参数。这种简单技术有助于减少重试次数，并更好地控制重试发生的方式。
- en: A *circuit breaker* sits in between the client and the server. In our microservices
    application, the service making the call is the client, and the target service
    is the server receiving the request. Initially, it allows all calls to go through.
    We call this the *closed state*. If an error is detected, which can be in the
    form of an error response or a delayed response, the *circuit breaker opens*.
    Once the circuit breaker is open, subsequent calls will fail faster. This will
    shorten the time spent waiting for a response. It will wait for a configured timeout
    period and then allow the calls again, in case the target service has recovered.
    If there is no improvement, then the circuit breaker will break the transmission.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*断路器* 位于客户端和服务器之间。在我们的微服务应用程序中，发起调用的服务是客户端，而接收请求的目标服务是服务器。最初，它允许所有调用通过。我们称这为
    *关闭状态*。如果检测到错误，可能是错误响应或延迟响应，则 *断路器打开*。一旦断路器打开，后续调用将更快失败。这将缩短等待响应的时间。它将等待配置的超时时间，然后如果目标服务已恢复，将再次允许调用。如果没有改进，则断路器将中断传输。'
- en: Using these two techniques, we can both counter transient failures and ensure
    that longer-term failures do not surface in the form of a poor user experience.
    In .NET Core, we have the benefit of **Polly**, which is a package that allows
    us to almost support natively both retry and circuit break policies and implement
    resilient web service calls. We will explore integrating Polly into our app next.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种技术，我们既可以应对瞬时故障，又确保长期故障不会以糟糕的用户体验的形式出现。在 .NET Core 中，我们有 **Polly** 的优势，这是一个允许我们几乎原生支持重试和断路器策略并实现弹性
    Web 服务调用的包。我们将在下一节中探讨将 Polly 集成到我们的应用程序中。
- en: Retry policy with Polly
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Polly 重试策略
- en: Polly is a framework that allows us to add a new layer of resilience to our
    applications. It acts as a layer between two services that stores the details
    of an initiated request and monitors the response time and/or the response code.
    It can be configured with parameters that it uses to determine what a failure
    looks like, and we can further configure the type of action we would like to take.
    This action can be in the form of a retry or a cancellation of the request.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Polly 是一个框架，允许我们为我们的应用程序添加一层新的弹性。它作为两个服务之间的一个层，存储已发起请求的详细信息并监控响应时间及/或响应代码。它可以配置用于确定失败外观的参数，并且我们可以进一步配置我们希望采取的操作类型。这种操作可以是重试或请求的取消。
- en: Polly is conveniently available in .NET Core and is widely used and trusted
    around the world. Let us review the steps needed to implement this framework in
    our application and monitor the calls the *Patients API* will make to the *Documents
    API*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Polly 在 .NET Core 中方便可用，并且在全球范围内被广泛使用和信任。让我们回顾一下在应用程序中实现此框架并监控 *Patients API*
    将对 *Documents API* 发起的调用的步骤。
- en: 'To add it to our .NET Core application and allow us to write extension code
    for our `HttpClient` objects, we start by adding these packages via NuGet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到我们的 .NET Core 应用程序中，并允许我们为我们的 `HttpClient` 对象编写扩展代码，我们首先通过 NuGet 添加这些包：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, in our `Program.cs` file, we can configure our typed HTTP client for our
    *Documents API* to use our extension code for its Polly-defined policies. In the
    `Program.cs` file, we can define the registration of our typed client like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的 `Program.cs` 文件中，我们可以配置我们的针对 *Documents API* 的类型化 HTTP 客户端以使用我们为 Polly
    定义的策略的扩展代码。在 `Program.cs` 文件中，我们可以定义类型化客户端的注册如下：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have added a policy handler to our HTTP client, so it will automatically
    be invoked for all calls made using this client. We now need to define a method
    called `GetRetryPolicy()` that will build our policy:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的 HTTP 客户端添加了一个策略处理器，因此它将自动为使用此客户端发出的所有调用调用。我们现在需要定义一个名为 `GetRetryPolicy()`
    的方法来构建我们的策略：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It may seem complicated because of the use of the builder pattern, but it is
    simple to understand and flexible enough to customize to your needs. Firstly,
    we define the return type or the method to be `IAsyncPolicy<HttpResponseMessage>`,
    which corresponds with the return type of our calls from our HTTP client. We then
    allow the policy to observe for transient HTTP errors, which the framework can
    determine by default, and we can extend that logic with more conditions such as
    observing the value of `IsSuccessStatusCode`, which returns `true` or `false`
    for the success of an operation, or even if `HttpRequestException` has been returned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了构建器模式，这可能会显得有些复杂，但它很容易理解，并且足够灵活，可以定制以满足您的需求。首先，我们定义返回类型或方法为`IAsyncPolicy<HttpResponseMessage>`，这与我们的HTTP客户端调用返回的类型相对应。然后，我们允许策略观察瞬态HTTP错误，框架可以默认确定这些错误，并且我们可以通过添加更多条件来扩展这种逻辑，例如观察`IsSuccessStatusCode`的值，它返回操作成功或失败的`true`或`false`，或者如果返回了`HttpRequestException`。
- en: These few parameters cover the general worst-case scenarios of an HTTP response.
    We then set the parameters for our retries. We want to retry at most 5 more times,
    and each retry should be done at a rolling interval starting at 2 seconds from
    the previous call. This way, we allow a little time between each retry. This is
    the concept of a *backoff*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这几个参数涵盖了HTTP响应的一般最坏情况。然后，我们设置重试的参数。我们希望最多重试5次，并且每次重试都应该在前一次调用后的2秒开始，以滚动间隔进行。这样，我们在每次重试之间允许一些时间。这就是*退避*的概念。
- en: Finally, we can define what action would like to take between each retry. This
    could include some error handling or reauthentication logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义在每次重试之间想要采取的操作。这可能包括一些错误处理或重新认证逻辑。
- en: Retry policies can have negative effects on your system where we might have
    high concurrency and high contention for resources. We need to ensure that we
    have a solid policy and define our delays and retries efficiently. Recall that
    a carelessly configured retry policy may well result in a DoS attack on your own
    service, opening the application to significant performance issues.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重试策略可能会对您的系统产生负面影响，尤其是在我们可能存在高并发和高资源竞争的情况下。我们需要确保我们有一个稳固的策略，并有效地定义我们的延迟和重试。回想一下，一个配置不当的重试策略可能会导致对您自己服务的DoS攻击，使应用程序面临重大的性能问题。
- en: Given the possibility of implementing something that could have negative effects
    in this manner, we now need a defense barrier that will mitigate this risk and
    break the retry cycle if the errors never stop. The best defense strategy comes
    in the form of the circuit breaker, which we will configure using Polly next.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到有可能实现某种可能以这种方式产生负面影响的方案，我们现在需要一个防御屏障来减轻这种风险，并在错误持续不断的情况下打破重试循环。最佳的防御策略是使用断路器，我们将使用Polly来配置它。
- en: Circuit breaker policy with Polly
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Polly的断路器策略
- en: As we have discussed for this chapter, we should handle faults that take a bit
    longer to resolve and define a policy that abandons retry calls to a service when
    we have concluded that it is unresponsive for a longer term than hoped for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中讨论的那样，我们应该处理那些需要较长时间才能解决的问题，并在我们得出结论，服务在比预期更长的时间内无响应时，定义一个放弃对服务重试调用的策略。
- en: 'We can continue from our code that added the retry policy using Polly by defining
    a circuit breaker policy and adding it as an HTTP handler to our client. We modify
    the client’s registration in the `Program.cs` file, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义断路器策略并将其添加为HTTP处理程序到我们的客户端中，从使用Polly添加重试策略的代码继续。我们修改客户端在`Program.cs`文件中的注册，如下所示：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we can add the `GetCircuitBreakerPolicy()` method as this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加`GetCircuitBreakerPolicy()`方法如下：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This policy defines a circuit breaker that opens the circuit when there have
    been `5` consecutive retry failures. Once that threshold is reached, the circuit
    will break for 30 seconds and automatically fail all subsequent calls, which will
    be interpreted as HTTP failure responses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此策略定义了一个断路器，当连续发生`5`次重试失败时，它会打开电路。一旦达到这个阈值，电路将断开30秒，并自动失败所有后续调用，这些调用将被解释为HTTP失败响应。
- en: With these two policies in place, you can orchestrate your service retries and
    significantly reduce the effects that unplanned outages might have on your application
    and the end user’s experience. The circuit breaker policy also adds a layer of
    protection from any potential adverse effects of the retry policy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个策略到位后，您可以编排您的服务重试，并显著减少计划外停机对您的应用程序和最终用户体验的影响。断路器策略还增加了一层保护，以防止重试策略可能产生的任何潜在不利影响。
- en: Now, let us summarize what we have learned about implementing resilient web
    services.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下我们关于实现弹性网络服务所学到的东西。
- en: Summary
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The contents of this chapter help us to be more mindful of the potential for
    failures in our microservices application. These concepts help us not only construct
    powerful and stable web services but also supercharge the communication mechanisms
    that exist between them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容帮助我们更加关注微服务应用程序中潜在失败的可能性。这些概念不仅帮助我们构建强大且稳定的网络服务，还极大地增强了它们之间的通信机制。
- en: We see that service outages are not always due to faulty code or the database
    and server of the initial web service, but we are facilitating inter-service communication
    as well, which leads to greater dependence on the network, third-party service,
    and general infrastructure uptime. This leads down a path where we implement contingencies
    that assist in ensuring that our application gives our users as good an experience
    as possible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，服务中断并不总是由于初始网络服务的代码错误或数据库和服务器，我们还促进了服务间的通信，这导致了对网络、第三方服务和一般基础设施正常运行时间的更大依赖。这导致我们实施应急措施，以确保我们的应用程序尽可能为用户提供良好的体验。
- en: We looked at several techniques for increasing service reliability, such as
    using a caching layer with technology such as Redis Cache for our `GET` operations,
    a message broker for our write operations, and writing more foolproof code using
    frameworks such as Polly. With Polly, we looked at how we can automatically retry
    service calls and use a circuit breaker to prevent these retries from being too
    liberal and causing other problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了提高服务可靠性的几种技术，例如使用Redis Cache等技术为我们的`GET`操作添加缓存层，为我们的写入操作使用消息代理，以及使用Polly等框架编写更健壮的代码。使用Polly，我们探讨了如何自动重试服务调用，并使用断路器来防止这些重试过于宽松并引起其他问题。
- en: Since services fail and we need a retry method, we also need a way to monitor
    the health of the services so that we can be aware of why the retries are not
    effective. This means that we need to introduce *health checks* that alert us
    to outages in a service’s infrastructure. We will explore this in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务可能会失败，我们需要重试方法，因此我们还需要一种方法来监控服务的健康状态，以便我们能够了解为什么重试不有效。这意味着我们需要引入*健康检查*，以便在服务基础设施出现故障时提醒我们。我们将在下一章中探讨这一点。
