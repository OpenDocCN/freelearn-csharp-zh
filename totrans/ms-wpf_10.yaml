- en: Completing that Great User Experience
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成卓越的用户体验
- en: As we have seen, it is easy to add form fields to a View and produce visually
    appealing and functionally adequate applications. However, it can take a lot more
    work to provide the end user with an interface that truly ticks all of the boxes.
    For example, how many times have you clicked on a button in an application and
    had the whole application freeze while it does some work?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，向视图中添加表单字段并生成视觉上吸引人且功能足够的应用程序很容易。然而，要为最终用户提供一个真正满足所有要求的界面则需要更多的工作。例如，你有多少次点击应用程序中的按钮，而整个应用程序在执行某些工作时会冻结？
- en: In this chapter, we'll look into solving this problem by using asynchronous
    programming, along with a number of other ways of improving the user experience
    for the end user. For example, we'll investigate enabling the users to customize
    their versions of the application using their own user preference settings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨通过使用异步编程以及许多其他提高最终用户体验的方法来解决此问题。例如，我们将研究启用用户使用他们自己的用户偏好设置自定义应用程序版本的方法。
- en: We'll discuss keeping the users informed by providing user feedback, and update
    our application framework by adding a feedback system. We'll explore a few alternative
    methods of providing in-application help files and documentation and a number
    of other ways of making the application more user friendly and the life of the
    users that much easier.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论通过提供用户反馈来保持用户知情，并通过添加反馈系统来更新我们的应用程序框架。我们将探讨提供应用程序内帮助文件和文档的几种替代方法，以及许多使应用程序更用户友好并使用户生活更加轻松的其他方法。
- en: Providing user feedback
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供用户反馈
- en: One essential facet of a great application is keeping the end users up to date
    with what's going on in the application. If they click on a function button, they
    should be informed as to the progress or the status of the operation. Without
    adequate feedback, the user can be left wondering whether a particular operation
    worked and may attempt to run it several times, possibly causing errors.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀应用程序的一个基本方面是让最终用户了解应用程序中的情况。如果他们点击一个功能按钮，他们应该被告知操作的进度或状态。如果没有足够的反馈，用户可能会感到困惑，不知道某个特定操作是否成功，并可能尝试多次运行它，这可能会导致错误。
- en: 'It is, therefore, essential to implement a feedback system in our application
    framework. So far in this book, we''ve seen the name of the `FeedbackManager`
    class in a few places, although we''ve seen very little implementation. Let''s
    now see how we can implement a working feedback system in our application framework,
    starting with the `Feedback` class that holds the individual feedback messages:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的应用程序框架中实现一个反馈系统是至关重要的。到目前为止，在这本书中，我们在几个地方看到了 `FeedbackManager` 类的名称，尽管我们看到的实现非常少。现在让我们看看我们如何在应用程序框架中实现一个有效的反馈系统，从包含单个反馈消息的
    `Feedback` 类开始：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that our `Feedback` class implements the `IAnimatable` interface, which
    we saw earlier, along with the `INotifyPropertyChanged` interface. After declaring
    the private fields, we declare a number of useful constructor overloads.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的 `Feedback` 类实现了我们之前看到的 `IAnimatable` 接口，以及 `INotifyPropertyChanged` 接口。在声明私有字段之后，我们声明了多个有用的构造函数重载。
- en: In this example, we have hardcoded a default feedback display duration of four
    seconds for the `duration` field. In the main constructor, we set the `Duration`
    property dependent upon the value of the `duration` input parameter; if the input
    parameter is the `TimeSpan.Zero` field, then the default value is used, but if
    the input parameter is a non-zero value, it will be used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们为 `duration` 字段硬编码了一个默认的反馈显示时长为四秒。在主构造函数中，我们根据 `duration` 输入参数的值设置 `Duration`
    属性；如果输入参数是 `TimeSpan.Zero` 字段，则使用默认值，但如果输入参数是非零值，则使用该值。
- en: The `Message` property will hold the feedback message; the `Duration` property
    specifies the length of time that the message will be displayed; the `Type` property
    uses the `FeedbackType` enumeration that we saw earlier to specify the type of
    the message, and the `IsPermanent` property dictates whether the message should
    be permanently displayed until the user manually closes it or not.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 属性将保存反馈信息；`Duration` 属性指定了消息显示的时长；`Type` 属性使用我们之前看到的 `FeedbackType`
    枚举来指定消息的类型，而 `IsPermanent` 属性决定了消息是否应该永久显示，直到用户手动关闭它为止。'
- en: The implementation of our `IAnimatable` class is shown beneath the other properties,
    and simply consists of the `Animatable` property, but our implementation of the
    `INotifyPropertyChanged` interface has been omitted for brevity, as we are using
    the default implementation that we saw earlier.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`IAnimatable`类的实现显示在其他属性下方，它仅由`Animatable`属性组成，但为了简洁起见，我们省略了`INotifyPropertyChanged`接口的实现，因为我们正在使用之前看到的默认实现。
- en: 'Let''s now see the `FeedbackCollection` class that will contain the individual
    `Feedback` instances:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将包含单个`Feedback`实例的`FeedbackCollection`类：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `FeedbackCollection` class extends the `BaseAnimatableCollection` class,
    which we saw earlier, and sets its generic type parameter to the `Feedback` class.
    This is a very simple class and declares a couple of constructors, passing any
    input parameters straight through to the base class constructors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackCollection`类扩展了我们之前看到的`BaseAnimatableCollection`类，并将它的泛型类型参数设置为`Feedback`类。这是一个非常简单的类，声明了几个构造函数，将任何输入参数直接传递给基类构造函数。'
- en: In addition to this, it declares two `Add` methods, with the second simply creating
    a `Feedback` object from its input parameters and passing it to the first method.
    The first method first checks that the feedback message is not `null` or empty
    and that an identical message is not already contained in the feedback collection,
    before adding the new message to the collection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它声明了两个`Add`方法，第二个方法只是从其输入参数创建一个`Feedback`对象，并将其传递给第一个方法。第一个方法首先检查反馈消息不是`null`或空，并且相同的消息尚未包含在反馈集合中，然后再将新消息添加到集合中。
- en: Note that our current implementation uses the base class `Add` method to add
    the new items to the end of the feedback collection. We could alternatively use
    the `Insert` method from the base class here to add new items to the start of
    the collection instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们当前的实现使用基类`Add`方法将新项目添加到反馈集合的末尾。我们也可以选择在这里使用基类的`Insert`方法，将新项目添加到集合的开头。
- en: 'Let''s now look at the `FeedbackManager` class that uses these two classes
    internally:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用这两个类的`FeedbackManager`类：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `FeedbackManager` class also implements the `INotifyPropertyChanged` interface,
    and in it we see the static `FeedbackCollection` field. Next, we see the static
    `instance` field, the private constructor, and the static `Instance` property
    of type `FeedbackManager`, which instantiates the `instance` field on the first
    use and tells us that this class follows the Singleton pattern.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeedbackManager`类还实现了`INotifyPropertyChanged`接口，在其中我们看到静态的`FeedbackCollection`字段。接下来，我们看到静态的`instance`字段、私有构造函数以及类型为`FeedbackManager`的静态`Instance`属性，它首次使用时实例化`instance`字段，并告诉我们这个类遵循单例模式。'
- en: The `Feedback` property follows and is the class access to the `FeedbackCollection`
    field. After that, we see a number of convenient overloads of the `Add` method
    that enables developers to add feedback using different parameters. Our implementation
    of the `INotifyPropertyChanged` interface here has again been omitted for brevity,
    but it uses our default implementation that we saw earlier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Feedback`属性随后是类对`FeedbackCollection`字段的访问。之后，我们看到一系列方便的重载的`Add`方法，它允许开发者使用不同的参数添加反馈。在这里，为了简洁起见，我们再次省略了`INotifyPropertyChanged`接口的实现，但它使用我们之前看到的默认实现。'
- en: 'Let''s now focus on the XAML of the `FeedbackControl` object:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们关注`FeedbackControl`对象的XAML：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We start by adding a number of XAML namespace prefixes for some of our application
    projects. Using the `Converters` prefix, we add instances of the `FeedbackTypeToImageSourceConverter`
    and `BoolToVisibilityConverter` classes that we saw earlier into the `UserControl.Resources`
    section. We also reuse our `AnimatedStackPanel` class from [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml),
    *Mastering Practical Animations*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为我们的应用程序项目的一些部分添加了多个XAML命名空间前缀。使用`Converters`前缀，我们将之前看到的`FeedbackTypeToImageSourceConverter`和`BoolToVisibilityConverter`类的实例添加到`UserControl.Resources`部分。我们还重用了来自[第7章](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml)，《精通实用动画》的`AnimatedStackPanel`类。
- en: Next, we see the `SmallImageInButtonStyle` style, which is based on the `ImageInButtonStyle`
    style that we also saw earlier, and adds some sizing properties. After that, we
    see the `FeedbackStyle` style that defines what each feedback message will look
    like in our feedback control.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到的是`SmallImageInButtonStyle`样式，它基于我们之前也看到过的`ImageInButtonStyle`样式，并添加了一些尺寸属性。之后，我们看到的是`FeedbackStyle`样式，它定义了在我们的反馈控制中每个反馈消息的外观。
- en: 'Each `Feedback` object will be rendered in three columns: the first contains
    an image that specifies the type of feedback, using the `FeedbackTypeToImageSourceConverter`
    class that we saw earlier; the second displays the message with a `TextWrapping`
    value of `Wrap`; the third holds a button with an image, using our `SmallImageInButtonStyle`
    style, which users can use to remove the message.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Feedback`对象将在三列中渲染：第一列包含一个指定反馈类型的图像，使用我们之前看到的`FeedbackTypeToImageSourceConverter`类；第二列显示消息，具有`TextWrapping`值为`Wrap`；第三列包含一个带有图像的按钮，使用我们的`SmallImageInButtonStyle`样式，用户可以使用它来删除消息。
- en: Note that, as this is purely a UI control with no business logic in, we are
    able to use the code behind the file, even when using MVVM. As such, we attach
    event handlers for the `MouseEnter` and `MouseLeave` events to the `Grid` panel
    containing each `Feedback` object, and another for the `PreviewMouseLeftButtonDown`
    event to the delete button. The final resource that we have here is a `DropShadowEffect`
    instance that defines a small shadow effect.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这是一个纯UI控件，其中没有业务逻辑，因此即使在使用MVVM的情况下，我们也能使用文件背后的代码。因此，我们将`MouseEnter`和`MouseLeave`事件的事件处理器附加到包含每个`Feedback`对象的`Grid`面板上，并将另一个用于`PreviewMouseLeftButtonDown`事件的处理器附加到删除按钮上。我们这里最后的资源是一个定义了小阴影效果的`DropShadowEffect`实例。
- en: For the feedback control, we define a `Border` element that uses a semi-transparent
    border brush and has a `BorderThickness` value of `1,0,1,1` and a `CornerRadius`
    value of `0,0,5,5`. These four values work like the `Margin` property and enable
    us to set different values for each of the four sides, or corners in the case
    of the `CornerRadius` property. In this way, we can display a rectangle that is
    only bordered on three sides, with rounded corners on two.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于反馈控制，我们定义了一个使用半透明边框画笔，`BorderThickness`值为`1,0,1,1`，`CornerRadius`值为`0,0,5,5`的`Border`元素。这四个值就像`Margin`属性一样工作，使我们能够为四个侧面或`CornerRadius`属性的情况下的每个角落设置不同的值。这样，我们可以显示一个只有三边有边框，两个角落是圆角的矩形。
- en: Note that the `Visibility` property on this border is determined by the `HasFeedback`
    property of the `FeedbackControl` class via an instance of our `BoolToVisibilityConverter`
    class. Therefore, when there are no feedback objects to display, the border will
    be hidden. Also note that our `Shadow` resource is applied to the border `Effect`
    property.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个边框上的`Visibility`属性是通过`FeedbackControl`类的`HasFeedback`属性以及我们`BoolToVisibilityConverter`类的一个实例来确定的。因此，当没有要显示的反馈对象时，边框将被隐藏。另外，请注意，我们的`Shadow`资源被应用到边框的`Effect`属性上。
- en: Inside the border, we declare a `ListBox` control, with its `ItemsSource` property
    set to the `Feedback` property of the `FeedbackControl` class and its height restricted
    to a maximum of three feedback items, after which vertical scrollbars will be
    shown. Its `ItemTemplate` property is set to the `FeedbackTemplate` that we defined
    in the resources section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在边框内部，我们声明了一个`ListBox`控件，其`ItemsSource`属性被设置为`FeedbackControl`类的`Feedback`属性，其高度限制为最多三个反馈项，之后将显示垂直滚动条。其`ItemTemplate`属性被设置为我们在资源部分定义的`FeedbackTemplate`。
- en: Its `ItemsPanel` property is set to the `AnimatedPanel` resource that we declared
    to animate the entrance and exit of the feedback items. Next, we remove the default
    border of the `ListBox` by setting the `BorderThickness` property to `0` and stretch
    the autogenerated `ListBoxItem` objects to fit the width of the `ListBox` control
    by setting the `HorizontalContentAlignment` property to `Stretch`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其`ItemsPanel`属性被设置为我们在资源中声明的用于动画反馈项进入和退出的`AnimatedPanel`资源。接下来，我们通过将`BorderThickness`属性设置为`0`来移除`ListBox`的默认边框，并通过将`HorizontalContentAlignment`属性设置为`Stretch`来拉伸自动生成的`ListBoxItem`对象以适应`ListBox`控件宽度。
- en: 'Let''s now see the code behind our feedback control:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看反馈控制的代码：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We start by declaring the collection of `DispatcherTimer` instances that will
    be responsible for timing when each feedback object should be removed from the
    collection, according to its `Duration` property. We then see the declaration
    of the `Feedback` and `HasFeedback` Dependency Properties, along with their CLR
    wrappers and the `Feedback` property's `CollectionChanged` handler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明了一个`DispatcherTimer`实例的集合，这些实例将负责根据每个反馈对象的`Duration`属性来计时，以确定何时从集合中移除每个反馈对象。然后我们看到`Feedback`和`HasFeedback`依赖属性的声明，以及它们的CLR包装和`Feedback`属性的`CollectionChanged`处理程序。
- en: In the attached `Feedback_CollectionChanged` handler method, we call the `InitializeTimer`
    method, passing in each new non-permanent feedback item. Note that we need to
    use the `OfType` LINQ Extension Method to cast each item in the `NewItems` property
    of the `NotifyCollectionChangedEventArgs` class from type `object` to `Feedback`.
    Before returning control to the caller, we set the `HasFeedback` property accordingly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加的`Feedback_CollectionChanged`处理方法中，我们调用`InitializeTimer`方法，传入每个新的非永久反馈项。请注意，我们需要使用`OfType`
    LINQ扩展方法将`NotifyCollectionChangedEventArgs`类的`NewItems`属性中的每个项从类型`object`转换为`Feedback`。在将控制权返回给调用者之前，我们相应地设置`HasFeedback`属性。
- en: In the `InitializeTimer` method, we initialize a `DispatcherTimer` instance
    and set its interval to the value from the `Duration` property of the `feedback`
    input parameter. We then attach the `Timer_Tick` event handler, add the current
    time and the feedback object into the `Tag` property of the timer for later use,
    start the timer, and add it into the `timers` collection.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InitializeTimer`方法中，我们初始化一个`DispatcherTimer`实例，并将其间隔设置为`feedback`输入参数的`Duration`属性中的值。然后我们附加`Timer_Tick`事件处理程序，将当前时间和反馈对象添加到计时器的`Tag`属性中以便后续使用，启动计时器，并将其添加到`timers`集合中。
- en: In the `Timer_Tick` method, we access the timer from the `sender` input parameter,
    and the `Feedback` instance from its `Tag` property. The feedback item is then
    removed from the `Feedback` collection, the timer is stopped and removed from
    the `timers` collection, and the `Tick` event handler is detached.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Timer_Tick`方法中，我们从`sender`输入参数访问计时器，并从其`Tag`属性访问`Feedback`实例。然后，反馈项从`Feedback`集合中移除，计时器停止并从`timers`集合中移除，并且`Tick`事件处理程序被断开连接。
- en: In the `DeleteButton_PreviewMouseLeftButtonDown` method, we first cast the delete
    button from the `sender` input parameter. We then cast the `Feedback` object from
    the button's `DataContext` property and remove it from the `Feedback` collection.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DeleteButton_PreviewMouseLeftButtonDown`方法中，我们首先将删除按钮从`sender`输入参数转换。然后，我们将`Feedback`对象从按钮的`DataContext`属性转换，并将其从`Feedback`集合中移除。
- en: In the `Border_MouseEnter` method, we iterate through the `timers` collection
    and stop each timer. The interval of each timer and duration of each associated
    `Feedback` object is then set to the remaining time that they should be displayed
    for, in effect, pausing their durations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Border_MouseEnter`方法中，我们遍历`timers`集合，并停止每个计时器。然后，每个计时器的间隔和每个相关联的`Feedback`对象的持续时间被设置为它们应该显示的剩余时间，实际上暂停了它们的持续时间。
- en: Finally, we see the `Border_MouseLeave` method, which re-initializes the `Tag`
    property of each timer in the timers collection, with the same feedback item and
    the current date and time, and restarts it when the user's mouse pointer leaves
    the feedback control.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到`Border_MouseLeave`方法，它重新初始化`timers`集合中每个计时器的`Tag`属性，使用相同的反馈项和当前日期和时间，并在用户将鼠标指针移出反馈控件时重新启动它。
- en: 'This means that the length of time that temporary feedback messages are displayed
    can be extended if the user moves their mouse pointer over the feedback control.
    This feature will hold the feedback messages in the control for as long as the
    user keeps their mouse pointer over the control, giving them ample time to read
    the messages. Let''s now see what this control looks like:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果用户将鼠标指针移到反馈控件上，临时反馈消息的显示时间可以延长。这个功能将保持反馈消息在控件中，直到用户将鼠标指针保持在控件上，从而给他们足够的时间阅读消息。现在让我们看看这个控件的样子：
- en: '![](img/50b658f8-1c36-4560-9489-144e8d742180.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/50b658f8-1c36-4560-9489-144e8d742180.png)'
- en: If you have menu buttons at the top of your Views, then you could alternatively
    have the feedback appear at the bottom of the application, or even sliding in
    from one of the sides. Also note that the delete buttons have not been styled,
    so as to shorten this example, but they should be styled in line with the other
    controls in a real application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的视图顶部有菜单按钮，那么反馈可以出现在应用程序的底部，或者甚至从一侧滑入。此外，请注意，删除按钮尚未样式化，以缩短此示例，但在实际应用程序中，它们应该与其它控件保持一致的风格。
- en: 'If you remember from [Chapter 3](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml),
    *Writing Custom Application Frameworks*, all of our View Models will have access
    to our new `FeedbackManager` class through the `FeedbackManager` property in our
    `BaseViewModel` class, and so we can replicate the feedback in the preceding image
    from any View Model like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第3章](b969e38f-19c3-49f6-a8f0-44f3f928b4c7.xhtml)中的内容，即*编写自定义应用程序框架*，那么我们所有的视图模型都将通过`BaseViewModel`类中的`FeedbackManager`属性访问我们新的`FeedbackManager`类，因此我们可以像这样从任何视图模型中复制前面的反馈图像：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's now move on to discover how we can make our applications more responsive
    by maximizing the utilization of the CPU.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续探索如何通过最大化CPU的利用率来使我们的应用程序更加响应。
- en: Utilizing multiple threads
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用多线程
- en: Traditionally, all applications were developed as single threaded applications.
    However, when long running background processes were running, the application
    UI would freeze and become unresponsive, because the single thread was busy elsewhere.
    This problem and other performance bottlenecks led to the current era of asynchronous
    programming and multi threaded applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，所有应用程序都是作为单线程应用程序开发的。然而，当长时间运行的后台进程正在运行时，应用程序的用户界面会冻结并变得无响应，因为单个线程正忙于其他地方。这个问题以及其他性能瓶颈导致了当前异步编程和多线程应用程序的时代。
- en: In days gone by, creating multi-threaded applications was a complicated matter.
    With each successive version of the .NET Framework, Microsoft has striven to make
    this task easier. Originally, we only had the `Thread` class and then the `BackgroundWorker`
    class in .NET 2.0, but in .NET 4.0 they introduced the `Task` class, and in .NET
    4.5 they introduced the `async` and `await` keywords.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的日子里，创建多线程应用程序是一件复杂的事情。随着.NET Framework每个后续版本的推出，微软一直努力使这项任务变得更简单。最初，我们只有`Thread`类，然后在.NET
    2.0中引入了`BackgroundWorker`类，但在.NET 4.0中，他们引入了`Task`类，而在.NET 4.5中，他们引入了`async`和`await`关键字。
- en: In this section, we will explore the latter methods of multithreading and add
    functionality to our application framework that will enable us to perform our
    data retrieval and update actions asynchronously. Let's start by looking at the
    `async` and `await` keywords first.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨多线程的后继方法，并为我们应用程序框架添加功能，使我们能够异步执行我们的数据检索和更新操作。让我们首先看看`async`和`await`关键字。
- en: Discovering the Async and Await keywords
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现Async和Await关键字
- en: Along with these new keywords, Microsoft also added a plethora of methods across
    the .NET Framework that end with the suffix `Async`. As the suffix hints, these
    methods are all asynchronous and they are used in conjunction with the new keywords.
    Let's start with the basic rules.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些新关键字一起，微软还在.NET Framework中添加了许多以`Async`后缀结尾的方法。正如后缀所暗示的，这些方法都是异步的，并且与新的关键字一起使用。让我们从基本规则开始。
- en: First of all, in order to use the `await` keyword in a method, the method signature must
    be declared with the `async` keyword. The `async` keyword enables us to use the
    `await` keyword in the method without error and is responsible for returning just
    the `T` generic type parameter from asynchronous methods whose signatures declare
    a return type of `Task<T>`. A method that is modified with the `async` keyword
    is known as an async method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在方法中使用`await`关键字，方法签名必须用`async`关键字声明。`async`关键字使我们能够在方法中使用`await`关键字而不会出错，并且负责从异步方法返回仅`T`泛型类型参数，这些方法的签名声明了返回类型为`Task<T>`。修改了`async`关键字的方法被称为异步方法。
- en: Async methods actually execute in a synchronous manner, until they reach an
    `await` expression. If there is no `await` keyword in the method, then the whole
    method will run synchronously and the compiler will output a warning.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法实际上是以同步方式执行的，直到它们达到一个`await`表达式。如果方法中没有`await`关键字，那么整个方法将以同步方式运行，编译器将输出一个警告。
- en: While a portion of async methods run asynchronously, they don't in fact run
    on their own threads. No additional threads are created using the `async` and
    `await` keywords. Instead, they give the appearance of multithreading by using
    the current synchronization context, but only when the method is active and not
    when it is paused, while running an `await` expression.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然部分异步方法以异步方式运行，但实际上它们并不是在它们自己的线程上运行的。使用`async`和`await`关键字不会创建额外的线程。相反，它们通过使用当前的同步上下文来提供多线程的外观，但只有在方法活动时，而不是在方法暂停并运行`await`表达式时。
- en: When execution reaches an `await` keyword, the method is suspended until the
    awaited task has completed asynchronously. During this time, execution returns
    to the method caller. When the asynchronous action is complete, program execution
    returns to the method and the remainder of the code in it is run synchronously.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到达一个`await`关键字时，方法将挂起，直到所等待的任务异步完成。在这段时间内，执行返回到方法调用者。当异步操作完成时，程序执行返回到方法，并同步运行其中的剩余代码。
- en: Async methods are required to have a particular signature. They all need to
    use the `async` modifier keyword, and in addition to this the names of async methods
    should end with the `Async` suffix to clearly signify that they are asynchronous
    methods. Another requirement of declaring async methods is that they cannot contain
    any `ref` or `out` input parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法需要具有特定的签名。它们都需要使用`async`修饰符关键字，并且除了这一点之外，异步方法的名称应该以`Async`后缀结尾，以清楚地表明它们是异步方法。声明异步方法的另一个要求是，它们不能包含任何`ref`或`out`输入参数。
- en: The final requirement is that async methods can only use one of three return
    types: `Task`, the generic `Task<TResult>`, or `void`. Note that the generic type `TResult` parameter
    is the same as and can be replaced with `T`, but Microsoft refers to it as `TResult`
    simply because it specifies a return type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要求是，异步方法只能使用三种返回类型之一：`Task`、泛型`Task<TResult>`或`void`。请注意，泛型类型参数`TResult`与`T`相同，可以被替换，但Microsoft将其称为`TResult`，因为它指定了返回类型。
- en: 'All async methods that return some meaningful result will use type `Task<TResult>`,
    where the actual type of the return value will be specified by the `TResult` generic
    type parameter. Therefore, if we want to return a `string` from our async method,
    we declare that our async method returns a parameter of type `Task<string>`. Let''s
    see an example of this in action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有返回一些有意义结果的异步方法都将使用类型`Task<TResult>`，其中实际返回值的类型将由`TResult`泛型类型参数指定。因此，如果我们想从我们的异步方法返回一个`string`，我们声明我们的异步方法返回一个类型为`Task<string>`的参数。让我们看看这个动作的例子：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we have a simple async method that returns a `string` that represents the
    contents of the text file specified by the `filePath` input parameter. Note that
    the actual return type of the method is in fact `Task<string>`. In it, we first
    initialize the `fileContents` variable and then attempt to create a `StreamReader`
    instance from the `File.OpenText` method within the `using` statement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个简单的异步方法，它返回一个表示由`filePath`输入参数指定的文本文件内容的`string`。请注意，方法的实际返回类型实际上是`Task<string>`。在其中，我们首先初始化`fileContents`变量，然后尝试在`using`语句中从`File.OpenText`方法创建一个`StreamReader`实例。
- en: Inside the `using` statement, we attempt to populate the `fileContents` variable
    by awaiting the result of the `ReadToEndAsync` method of the `StreamReader` class.
    Up until this point, the method will run synchronously. The `ReadToEndAsync` method
    will be called, and then control will immediately return to the caller of our
    async method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`using`语句内部，我们尝试通过等待`StreamReader`类的`ReadToEndAsync`方法的结果来填充`fileContents`变量。直到这一点，方法将以同步方式运行。将调用`ReadToEndAsync`方法，然后控制将立即返回到我们的异步方法的调用者。
- en: When the return value of the `ReadToEndAsync` method is ready, execution returns
    to our async method and continues where it left off. In our example, there is
    nothing else to do but return the result string, although async methods can contain
    any number of lines after the `await` keyword, or even multiple `await` keywords.
    Note that in a real-world application, we would log any exceptions that might
    be thrown from this method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ReadToEndAsync`方法的返回值准备好时，执行将返回到我们的异步方法，并从上次离开的地方继续。在我们的例子中，除了返回结果字符串之外，没有其他事情要做，尽管异步方法可以在`await`关键字之后包含任意数量的行，甚至多个`await`关键字。请注意，在实际应用中，我们会记录从这个方法抛出的任何异常。
- en: 'If our async method just performs some function asynchronously, but does not
    return anything, then we use a return type of `Task`. That is, the task-based
    async method will return a `Task` object that enables it to be used with the `await`
    keyword, but the actual method will not return anything to the caller of that
    method. Let''s see an example of this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的异步方法只是异步执行某些功能，但不返回任何内容，那么我们使用返回类型`Task`。也就是说，基于任务的异步方法将返回一个`Task`对象，使其能够与`await`关键字一起使用，但实际的方法不会向该方法的调用者返回任何内容。让我们看看这个例子：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `SetTextFileContentsAsync` method, we first need to convert our input
    string to a byte array. For this reason, we now need to add a `using` directive
    for the `System.Text` namespace in addition to the three originally specified.
    Note that in this particular example, we are using `Unicode` encoding, but you
    are free to use any other encoding value here.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SetTextFileContentsAsync`方法中，我们首先需要将我们的输入字符串转换为字节数组。因此，我们现在需要添加一个`using`指令来指定`System.Text`命名空间，除了最初指定的三个之外。请注意，在这个特定的例子中，我们使用的是`Unicode`编码，但你也可以使用任何其他的编码值。
- en: After using the `GetBytes` method to obtain a byte array from the `contents`
    input parameter, we initialize a new `FileStream` object within another `using`
    statement. Apart from the `bool` `useAsync` input parameter, the remaining parameters
    used in the `FileStream` constructor in this example are unimportant, and you
    are free to replace them with values that suit your requirements better.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`GetBytes`方法从`contents`输入参数获取字节数组之后，我们在另一个`using`语句中初始化一个新的`FileStream`对象。除了`bool`类型的`useAsync`输入参数之外，在这个示例中用于`FileStream`构造函数的其他参数并不重要，你可以自由地用更适合你需求的值替换它们。
- en: Inside the `using` statement, we see the `await` keyword used with the `WriteAsync`
    method. Up until this point, this method will run synchronously, and on this line
    it will start execution of the `WriteAsync` method and then return control to
    the method caller.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`using`语句内部，我们看到`await`关键字与`WriteAsync`方法一起使用。到目前为止，此方法将以同步方式运行，并且在这一行上，它将开始执行`WriteAsync`方法，然后返回控制权给方法调用者。
- en: As execution leaves the `using` statement, the `FileStream` instance will be
    closed and disposed of. As this method has nothing to return, the return type
    of the async method is `Task`, which enables it to be awaited by the calling code.
    Again, we would typically log any exceptions that might be thrown from this method,
    but this is omitted here for brevity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行离开`using`语句时，`FileStream`实例将被关闭并释放。由于此方法没有返回值，异步方法的返回类型是`Task`，这使得它能够被调用代码挂起。再次提醒，我们通常会记录可能从这个方法抛出的任何异常，但在这里为了简洁省略了这一步骤。
- en: Most of us will never use the third return type option of `void` when using
    MVVM, because it is primarily used in event handling methods. Note that async
    methods that return `void` cannot be awaited and that calling code cannot catch
    exceptions thrown from such async methods.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用MVVM时，我们中的大多数人永远不会使用`void`的第三个返回类型选项，因为它主要用于事件处理方法。请注意，返回`void`的异步方法不能被挂起，并且调用代码不能捕获此类异步方法抛出的异常。
- en: 'One of the most commonly asked questions regarding async methods is "How can
    I create an async method from a synchronous method?" Luckily, there is a very
    simple solution to this using the `Task.Run` method, so let''s take a quick look
    at it now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异步方法最常问的问题之一是“我如何从一个同步方法创建一个异步方法？”幸运的是，使用`Task.Run`方法有一个非常简单的解决方案，现在让我们快速看一下它：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here we use a Lambda expression to specify the synchronous method to run in
    an asynchronous context. That''s all that we have to do to run a synchronous method
    asynchronously. However, what about the opposite requirement? Let''s now see how
    we can run an asynchronous method synchronously. Again, the `Task` class provides
    us with a solution:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Lambda表达式来指定在异步上下文中运行的同步方法。这就是我们运行同步方法异步所需做的全部。然而，对于相反的要求呢？现在让我们看看我们如何可以同步地运行异步方法。同样，`Task`类为我们提供了一个解决方案：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we saw at the end of [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working with WPF*, in order to run an asynchronous method synchronously,
    we first need to instantiate a `Task` instance from our asynchronous method. Then,
    all we have to do is call the `RunSynchronously` method on that instance, and
    it will run synchronously.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第一章](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml)的结尾所看到的，*使用WPF的更智能的工作方式*，为了同步地运行异步方法，我们首先需要从我们的异步方法中实例化一个`Task`对象。然后，我们只需调用该实例上的`RunSynchronously`方法，它就会同步运行。
- en: Building asynchrony into our framework
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将异步性构建到我们的框架中
- en: Using the `Task` class, we can add functionality into our application framework
    that will enable us to call any data access method asynchronously. Furthermore,
    it will also enable us to run our data operations asynchronously when the application
    is running, and synchronously while testing. In order to achieve this, we will
    need to implement several parts, that go together to provide this functionality.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Task`类，我们可以将功能添加到我们的应用程序框架中，使我们能够异步调用任何数据访问方法。此外，它还将使我们能够在应用程序运行时异步执行数据操作，在测试时同步执行。为了实现这一点，我们需要实现几个部分，它们共同提供这一功能。
- en: 'Let''s look at the first part that will wrap each data operation and hold the
    result value, if applicable, along with any feedback messages or error details:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一部分，它将包装每个数据操作，如果适用，则包含结果值、任何反馈消息或错误详情：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In our abstract `DataOperationResult` class, we have a number of properties
    and constructor overloads. The first constructor is used for a successful set
    data operation and merely takes the `successText` input parameter, which is used
    to populate the `Description` property, unless it is `null` or empty, in which
    case a default successful operation message is used instead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的抽象`DataOperationResult`类中，我们有许多属性和构造函数重载。第一个构造函数用于成功的设置数据操作，仅接受`successText`输入参数，该参数用于填充`Description`属性，除非它是`null`或空，在这种情况下，将使用默认的成功操作消息。
- en: The second constructor is to be used when an exception has been thrown during
    the data operation, and takes the exception and an error message as input parameters.
    In it, we first set the `Exception` property to the exception specified by the
    `exception` input parameter, and then we have a chance to catch common exceptions
    and replace the error messages with custom messages in plain English.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数用于在数据操作过程中抛出异常时使用，它接受异常和错误信息作为输入参数。在其中，我们首先将`Exception`属性设置为`exception`输入参数指定的异常，然后我们有机会捕获常见的异常，并用简单的英语替换错误信息。
- en: Although we are only checking for exceptions of type `SqlException` in this
    example, we could easily extend this to capture other well-known or expected exceptions,
    and replace their messages with custom messages using laymen terms, by adding
    the further `else...if` conditions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个例子中只检查`SqlException`类型的异常，但我们很容易将其扩展以捕获其他已知或预期的异常，并使用通俗易懂的语言替换它们的消息，通过添加额外的`else...if`条件。
- en: Note that the `Error` property of enumeration type `DataOperationError` is used
    here to set and output the predefined error messages, and we'll see that in a
    moment. If the exception is not one that we were expecting, then we could choose
    to output the actual exception message, although that would mean little to the
    users and could be deemed confusing or even worrying.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里使用枚举类型`DataOperationError`的`Error`属性来设置和输出预定义的错误信息，我们稍后会看到。如果异常不是我们预期的类型，那么我们可以选择输出实际的异常信息，尽管这对用户来说意义不大，可能会被认为是混淆的，甚至令人担忧。
- en: Instead, we could log the exception in the database and output the message from
    the `errorText` input parameter. We check whether the `Error` property has been
    set, and if it has, we call our `GetDescription` Extension Method to retrieve
    the message that relates to the set enumeration member, and set it to the `Description`
    property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以在数据库中记录异常，并从`errorText`输入参数输出消息。我们检查`Error`属性是否已设置，如果已设置，则调用我们的`GetDescription`扩展方法来检索与设置枚举成员相关的消息，并将其设置为`Description`属性。
- en: Otherwise, we set the `Error` property to the `UndeterminedDataOperationError`
    member and the `Description` property to the value of the `errorText` input parameter
    if it is not `null` or empty, or the text associated with the selected enumeration
    member if it is. The third constructor is also used when an exception has been
    thrown, but when there is no predefined feedback message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将`Error`属性设置为`UndeterminedDataOperationError`成员，如果`errorText`输入参数不是`null`或空，则将`Description`属性设置为`errorText`的值，如果是，则设置为所选枚举成员关联的文本。第三个构造函数也用于抛出异常的情况，但没有预定义的反馈信息。
- en: 'After the constructors, we see the properties of the `DataOperationResult`
    class, most of which are self-explanatory. Of particular note is the `IsSuccess`
    property, which can be used by the calling code to determine what to do with the
    result. Let''s now take a look at the `DataOperationError` enumeration class that
    is used to hold the error descriptions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们看到 `DataOperationResult` 类的属性，其中大部分都是不言自明的。特别值得注意的是 `IsSuccess` 属性，它可以被调用代码用来确定如何处理结果。现在让我们看看用于保存错误描述的
    `DataOperationError` 枚举类：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we utilize the `DescriptionAttribute` class to relate a humanized
    error message with each enumeration member. We can use the `GetDescription` Extension
    Method that we saw earlier to access the text values from the attributes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们利用 `DescriptionAttribute` 类将人性化错误消息与每个枚举成员相关联。我们可以使用之前看到的 `GetDescription`
    扩展方法来访问属性中的文本值。
- en: 'Each enumeration member is assigned a number, and this could work well with
    the SQL Server error numbers if you were using SQL stored procedures or queries
    directly. For example, we could cast the SQL error code to the particular enumeration
    member to get the custom message for each error. Let''s now take a look at the
    two classes that extend the `DataOperationResult` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举成员都被分配了一个数字，如果你直接使用 SQL 存储过程或查询，这可以很好地与 SQL Server 错误号配合使用。例如，我们可以将 SQL
    错误代码转换为特定的枚举成员，以获取每个错误的自定义消息。现在让我们看看扩展 `DataOperationResult` 类的两个类：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We start with the `GetDataOperationResult` class, which is used to return the
    result of get data operations, or the exception details if an error occurred.
    It adds a `ReturnValue` property of the generic type `T` to hold the return value
    of the data operation. Apart from this single member, it simply adds a number
    of constructors that each call the base class constructors.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `GetDataOperationResult` 类开始，该类用于返回获取数据操作的结果，或者在发生错误时返回异常详细信息。它添加了一个泛型类型
    `T` 的 `ReturnValue` 属性来保存数据操作的返回值。除了这个单一成员外，它还简单地添加了多个构造函数，每个构造函数都调用基础类构造函数。
- en: The first is used when an exception has been thrown and sets the `ReturnValue`
    property to its default value, rather than leaving it as `null`. The second constructor
    is also used when an exception has been thrown, but when there is no predefined
    error message.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于抛出异常时，并将 `ReturnValue` 属性设置为默认值，而不是将其保留为 `null`。第二个构造函数也用于抛出异常时，但没有预定义的错误消息。
- en: 'The third constructor is used for a successful data operation and sets the
    `ReturnValue` property to the returned value. The fourth is also used for a successful
    data operation, but when there is no predefined success message. It calls the
    third constructor, passing the returned value and an empty string for the success
    message. Let''s now see the other class that extends the `DataOperationResult`
    class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个构造函数用于成功的数据操作，并将 `ReturnValue` 属性设置为返回值。第四个也用于成功的数据操作，但没有预定义的成功消息。它调用第三个构造函数，传递返回值和一个空字符串作为成功消息。现在让我们看看扩展
    `DataOperationResult` 类的另一个类：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `SetDataOperationResult` class is used for set operations and so has no
    return value. Like the `GetDataOperationResult` class, its two constructors call
    the relevant base class constructors. The first is used when an exception has
    been thrown, and the second is used for a successful data operation and accepts
    an input parameter for the operation's success message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetDataOperationResult` 类用于设置操作，因此没有返回值。与 `GetDataOperationResult` 类类似，它的两个构造函数调用相关的基础类构造函数。第一个用于抛出异常时，第二个用于成功的数据操作，并接受一个输入参数用于操作的成功消息。'
- en: 'We''ll need to add a new method into our `FeedbackManager` class to enable
    us to add the feedback messages from our `GetDataOperationResult` and `SetDataOperationResult`
    classes directly. We''ll also include a parameter that allows us to override whether
    each message will be displayed for its set duration, or until the user closes
    it manually. Let''s take a look at that now:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `FeedbackManager` 类中添加一个新的方法，以便我们能够直接从 `GetDataOperationResult` 和 `SetDataOperationResult`
    类添加反馈消息。我们还将包括一个参数，允许我们覆盖每个消息是否会在其设定的持续时间显示，或者直到用户手动关闭它。现在让我们看看这个：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we use the `DataOperationResult` base class as the input parameter
    here, so that either of our derived classes can be used with it. This method simply
    initializes a `Feedback` object from the `Description` and `IsSuccess` properties
    of the `DataOperationResult` class and passes it to the `Add` method that actually
    adds it to the `Feedback` collection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用`DataOperationResult`基类作为输入参数，这样我们的任何派生类都可以与它一起使用。此方法简单地从`DataOperationResult`类的`Description`和`IsSuccess`属性初始化一个`Feedback`对象，并将其传递给实际将其添加到`Feedback`集合的`Add`方法。
- en: If we're going to be making asynchronous calls to the UI feedback control, then
    we'll also need to ensure that they are made on the UI thread, so as to avoid
    the common `calling thread cannot access this object because a different thread
    owns it` exception.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将要对UI反馈控件进行异步调用，那么我们还需要确保它们在UI线程上执行，以避免常见的`调用线程无法访问此对象，因为不同的线程拥有它`异常。
- en: 'To enable this, we need to add a reference to the `UiThreadManager` class,
    which we discussed earlier, into our `FeedbackManager` class, although here we
    add a reference to the `IUiThreadManager` interface instead to enable us to use
    a different implementation while testing:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用此功能，我们需要将之前讨论过的`UiThreadManager`类引用添加到我们的`FeedbackManager`类中，尽管在这里我们添加了对`IUiThreadManager`接口的引用，以便在测试时使用不同的实现：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using the `IUiThreadManager` interface, we simply need to wrap our single call
    to add feedback to the `FeedbackManager.Feedback` collection property with the
    `RunOnUiThread` method to run it on the UI thread. However, our `uiThreadManager`
    field needs to be initialized before any feedback is displayed, and we can do
    that from the first use of the `BaseViewModel` class:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`IUiThreadManager`接口，我们只需用`RunOnUiThread`方法包装添加反馈到`FeedbackManager.Feedback`集合属性的单一调用，以在UI线程上运行它。然而，我们的`uiThreadManager`字段需要在显示任何反馈之前初始化，并且我们可以从`BaseViewModel`类的第一次使用中完成这一点：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first time that any View Model is instantiated, this base class constructor
    will be called and the instance of the `IUiThreadManager` interface in the `FeedbackManager`
    class will be initialized. Of course, in order to correctly resolve our instance
    of the `IUiThreadManager` interface at runtime, we'll first need to register it
    in the `App.xaml.cs` file, along with the other registrations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次实例化任何ViewModel时，将调用此基类构造函数，并且`FeedbackManager`类中的`IUiThreadManager`接口实例将被初始化。当然，为了在运行时正确解析我们的`IUiThreadManager`接口实例，我们首先需要在`App.xaml.cs`文件中注册它，以及其他注册项。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s take a look at this interface and the classes that implement it now:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看这个接口及其实现它的类：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `IUiThreadManager` interface is a very simple affair and declares just
    three methods. The `RunOnUiThread` method is used to run code on the UI thread;
    the first `RunAsynchronously` method is used to run code asynchronously, and the
    second `RunAsynchronously` method is used to run methods that return something
    asynchronously. Let''s now see the classes that implement it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUiThreadManager`接口是一个非常简单的事情，只声明了三个方法。`RunOnUiThread`方法用于在UI线程上运行代码；第一个`RunAsynchronously`方法用于异步运行代码，第二个`RunAsynchronously`方法用于异步运行返回某些内容的方法。现在让我们看看实现它的类：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `UiThreadManager` class, the `RunOnUiThread` method calls the `Invoke`
    method on the `Application.Current.Dispatcher` object to ensure that the method
    that is passed to it is queued to run on the UI thread.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UiThreadManager`类中，`RunOnUiThread`方法调用`Application.Current.Dispatcher`对象的`Invoke`方法，以确保传递给它的方法被排队在UI线程上运行。
- en: Basically, a dispatcher is responsible for maintaining the queue of work items
    for a particular thread, and each thread will have its own dispatcher. The `Application.Current`
    property returns the `Application` object for the current `AppDomain` object,
    and its `Dispatcher` property returns the dispatcher of the thread that was running
    when the application started – the UI thread.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，分发器负责维护特定线程的工作项队列，每个线程都将有自己的分发器。`Application.Current`属性返回当前`AppDomain`对象的`Application`对象，其`Dispatcher`属性返回在应用程序启动时运行的线程的分发器——UI线程。
- en: 'As was seen earlier, the `RunAsynchronously` methods simply pass the methods
    specified by the `method` input parameters to the `Task.Run` method. We also saw
    an example of mocking the `RunAsynchronously` method in [Chapter 1](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml),
    *A Smarter Way of Working With WPF*, but now let''s see the whole `MockUiThreadManager`
    class that we could use while testing our application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`RunAsynchronously` 方法只是将 `method` 输入参数指定的方法传递给 `Task.Run` 方法。我们还在 [第 1
    章](b2021d5b-c625-4403-9609-724ff89b9e0c.xhtml) 中看到了模拟 `RunAsynchronously` 方法的示例，*一种更智能的
    WPF 工作方式*，但现在让我们看看整个 `MockUiThreadManager` 类，我们可以在测试我们的应用程序时使用它：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the `RunOnUiThread` method, we simply call the `DynamicInvoke` method of
    the `Delegate` class to run the method specified by the `method` input parameter.
    As we saw earlier, the `RunAsynchronously` methods use the `RunSynchronously`
    method of the `Task` class to run the methods specified by the `method` input
    parameters synchronously to avoid timing problems during testing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RunOnUiThread` 方法中，我们只是调用 `Delegate` 类的 `DynamicInvoke` 方法来运行由 `method` 输入参数指定的方法。正如我们之前看到的，`RunAsynchronously`
    方法使用 `Task` 类的 `RunSynchronously` 方法来同步运行由 `method` 输入参数指定的方法，以避免在测试期间出现时间问题。
- en: In them, we first create a new `Task` object with the method specified by the
    `method` input parameter, then call the `RunSynchronously` method on it, and finally
    return the task. When called using the `await` keyword, this will actually return
    the result of the method instead.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们首先使用由 `method` 输入参数指定的方法创建一个新的 `Task` 对象，然后调用其上的 `RunSynchronously` 方法，最后返回该任务。当使用
    `await` 关键字调用时，这实际上会返回方法的返回结果。
- en: 'Let''s now see, perhaps the most important part of this functionality, where
    the `IUiThreadManager` interface is used, the `DataOperationManager` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个功能可能最重要的部分，即使用 `IUiThreadManager` 接口的地方，`DataOperationManager` 类：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `DataOperationManager` class starts with a couple of private fields, which
    represent the maximum number of attempts to retry each data operation in case
    there is a problem, and the instance of the `IUiThreadManager` interface to use
    to run our functions asynchronously when running the application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataOperationManager` 类开始于几个私有字段，这些字段代表在出现问题时重试每个数据操作的最大尝试次数，以及用于在运行应用程序时异步运行我们的函数的
    `IUiThreadManager` 接口实例。'
- en: The constructor enables us to inject the `IUiThreadManager` dependency into
    the class and sets it to the private `UiThreadManager` property, which can only
    be accessed from within the class. Likewise, the `FeedbackManager` property is
    also private and enables us to pass feedback messages to the manager class to
    display them in the UI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使我们能够将 `IUiThreadManager` 依赖项注入到类中，并将其设置为私有的 `UiThreadManager` 属性，该属性只能在类内部访问。同样，`FeedbackManager`
    属性也是私有的，使我们能够将反馈信息传递给管理类以在 UI 中显示。
- en: Next, we see the generic `TryGet<TResult>` method that returns an object of
    the type `GetDataOperationResult<TResult>`. More specifically, it returns a generic
    object of the type `TResult` wrapped in one of our `GetDataOperationResult` objects.
    It first asserts that the `method` input parameter is not `null`, as this class
    is based around the required parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到通用的 `TryGet<TResult>` 方法，它返回一个类型为 `GetDataOperationResult<TResult>`
    的对象。更具体地说，它返回一个类型为 `TResult` 的泛型对象，被我们自己的 `GetDataOperationResult` 对象包装。它首先断言
    `method` 输入参数不是 `null`，因为这个类是基于必需参数的。
- en: In this method, we create a loop, with the number of its iterations determined
    by the value of the `maximumRetryCount` field, and inside the loop we try to run
    the function specified by the `method` input parameter. If the data operation
    is successful, we initialize a `GetDataOperationResult` object, passing the return
    value and success feedback message, and return it via the `WithFeedback` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建一个循环，其迭代次数由 `maximumRetryCount` 字段的值确定，并在循环中尝试运行由 `method` 输入参数指定的函数。如果数据操作成功，我们初始化一个
    `GetDataOperationResult` 对象，传递返回值和成功反馈信息，并通过 `WithFeedback` 方法返回它。
- en: If an error occurs and the maximum number of attempts have not yet been reached,
    then we use the asynchronous `Task.Delay` method to wait before attempting to
    run the method again. If the maximum number of errors has been reached, then the
    exception and error feedback message are wrapped in a `GetDataOperationResult`
    object and returned via the `WithFeedback` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误且尚未达到最大尝试次数，那么我们使用异步的 `Task.Delay` 方法等待，然后再尝试再次运行该方法。如果达到最大错误次数，则将异常和错误反馈信息包装在
    `GetDataOperationResult` 对象中，并通过 `WithFeedback` 方法返回。
- en: One improvement that we could implement here would be to increase this delay
    time each time we retry the data operation. We could implement a function that
    returns an exponentially increasing number, based on the `maximumRetryCount` field,
    representing the millisecond value that will be passed to the `Task.Delay` method.
    This would be more likely to handle short network drop outs better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里实现的一个改进是，每次重试数据操作时增加这个延迟时间。我们可以实现一个函数，该函数返回一个基于`maximumRetryCount`字段的指数增长数，表示将传递给`Task.Delay`方法的毫秒值。这将更有可能更好地处理短暂的网络中断。
- en: The `WithFeedback` method enables developers to suppress successful feedback
    messages, as they might not always need the users to receive feedback. For example,
    we may not need to inform them that their data objects were fetched from the database
    successfully, if they have been, or are soon to be, displayed on the screen.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`WithFeedback`方法允许开发者抑制成功反馈消息，因为他们可能并不总是需要用户接收反馈。例如，如果我们已经显示在屏幕上，或者即将显示在屏幕上，我们可能不需要通知他们他们的数据对象已成功从数据库中检索出来。'
- en: Therefore, if the data operation was successful and the `isMessageSupressed`
    input parameter is `true`, the data operation result is returned directly, without
    feedback. Otherwise, the `dataOperationResult` input parameter object is passed
    to the `FeedbackManager` class to display the associated message, using the new
    methods that we added earlier.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果数据操作成功并且`isMessageSupressed`输入参数为`true`，则直接返回数据操作结果，不提供反馈。否则，将`dataOperationResult`输入参数对象传递给`FeedbackManager`类以显示相关消息，使用我们之前添加的新方法。
- en: Next, we see the asynchronous `TryGetAsync` method that simply calls the `TryGet`
    method via the `RunAsynchronously` method of the `UiThreadManager` class. After
    that, we have the `TrySet` method that is responsible for running all set data
    operations, and returns an object of the type `SetDataOperationResult`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到异步的`TryGetAsync`方法，它只是通过`UiThreadManager`类的`RunAsynchronously`方法调用`TryGet`方法。之后，我们有`TrySet`方法，它负责运行所有设置数据操作，并返回类型为`SetDataOperationResult`的对象。
- en: This method is very similar to the `TryGet` method, except that it works for
    set data operations. Similarly, it first asserts that the `method` input parameter
    is not `null` and then runs the remainder of the code within a for loop. This
    again enables our retry capability, and is limited by the value of the `maximumRetryCount`
    field.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与`TryGet`方法非常相似，除了它适用于设置数据操作。同样，它首先断言`method`输入参数不是`null`，然后在for循环中运行剩余的代码。这再次使我们的重试能力成为可能，并且受`maximumRetryCount`字段值的限制。
- en: In the method, we try to run the function specified by the `method` input parameter,
    and if the data operation is successful, we initialize a `SetDataOperationResult`
    object, passing just the success feedback message and return it via the `WithFeedback`
    method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法中，我们尝试运行由`method`输入参数指定的函数，如果数据操作成功，则初始化一个`SetDataOperationResult`对象，仅传递成功反馈消息，并通过`WithFeedback`方法返回它。
- en: If an error occurs and the number of attempts specified by the `maximumRetryCount`
    field has not yet been reached, then we use the `Task.Delay` method to wait before
    attempting to run the method again. If the maximum number of errors has been reached,
    then the exception and error feedback message are wrapped in a `SetDataOperationResult`
    object and returned via the `WithFeedback` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误并且尚未达到由`maximumRetryCount`字段指定的尝试次数，那么我们将使用`Task.Delay`方法等待，然后再尝试再次运行该方法。如果达到最大错误数，则将异常和错误反馈信息封装在`SetDataOperationResult`对象中，并通过`WithFeedback`方法返回。
- en: The `WithFeedback` method used with the `SetDataOperationResult` objects works
    exactly the same as the earlier one that works with the generic `GetDataOperationResult`
    objects. Finally, we have some overloaded `TrySetAsync` methods that end up calling
    the `TrySet` method asynchronously via the `RunAsynchronously` method of the `UiThreadManager`
    class.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SetDataOperationResult`对象一起使用的`WithFeedback`方法与之前用于通用`GetDataOperationResult`对象的方法完全相同。最后，我们有一些重载的`TrySetAsync`方法，它们最终通过`UiThreadManager`类的`RunAsynchronously`方法异步调用`TrySet`方法。
- en: One point to note here is that, currently, this class is located in the `Managers`
    project. If we were at all likely to need to swap out our data access technology,
    then we might prefer to move this class to the data access project for ease of
    removal. As it stands, we don't have that requirement, and so it is fine where
    it is.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点需要注意，目前这个类位于`Managers`项目中。如果我们有可能需要更换我们的数据访问技术，那么我们可能更愿意将这个类移动到数据访问项目中以便于移除。按照现状，我们没有这样的需求，所以它现在所在的位置是合适的。
- en: 'We can make use of this `DataOperationManager` class in the `DataController`
    class that we saw earlier, with just a few changes. We can also replace its previous
    `SetAuditCreateFields` and `SetAuditUpdateFields` methods with some new methods
    that also update our data models that implement the `ISynchronizableDataModel`
    interface. Let''s take a look at the new code in there:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在之前看到的`DataController`类中使用这个`DataOperationManager`类，只需进行一些修改。我们还可以用一些新的方法替换它之前的`SetAuditCreateFields`和`SetAuditUpdateFields`方法，这些新方法也会更新实现`ISynchronizableDataModel`接口的数据模型。让我们看看那里的新代码：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We start this class with the `dataOperationManager` field of the type `DataOperationManager`.
    We don't need to use an interface here, as this class is safe to be used during
    testing. However, it contains a member of the type `IUiThreadManager`, and we
    need to be able to use different implementations of this, depending on whether
    we're running or testing the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个类`DataOperationManager`的`dataOperationManager`字段开始，这个字段属于`DataOperationManager`类型。在这里我们不需要使用接口，因为这个类在测试期间是安全的。然而，它包含一个`IUiThreadManager`类型的成员，我们需要能够根据我们是在运行还是测试应用程序来使用这个成员的不同实现。
- en: Therefore, we still need to inject the instance of the `dataOperationManager`
    field to use through the constructor, so that its instance of the `IUiThreadManager`
    interface can be resolved in the calling code. After the constructor, we see the
    private `DataOperationManager` property that can only be set from within the class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然需要通过构造函数注入`dataOperationManager`字段的实例，以便在调用代码中解决其`IUiThreadManager`接口的实例。在构造函数之后，我们看到一个私有的`DataOperationManager`属性，它只能从类内部设置。
- en: The first of the new methods is the `AddProductAsync` method, and as a set operation
    it returns a `Task` of the type `SetDataOperationResult`. Internally, and like
    all async set operations here, it calls the `TrySetAsync` method of the `DataOperationManager`
    class. It passes the method to run asynchronously and the success and unspecified
    error text to be displayed as user feedback.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法中的第一个是`AddProductAsync`方法，作为一个集合操作，它返回一个类型为`SetDataOperationResult`的`Task`。内部，就像这里所有的异步集合操作一样，它调用`DataOperationManager`类的`TrySetAsync`方法。它传递要异步运行的方法以及要显示为用户反馈的成功和未指定的错误文本。
- en: Note that we pass the `product` input parameter to the `InitializeDataModel`
    method, before passing it to the `AddProduct` method of the `IDataProvider` instance,
    to initialize the base class `Auditable` property before it is stored in the database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在将`product`输入参数传递给`IDataProvider`实例的`AddProduct`方法之前，先传递给`InitializeDataModel`方法，以便在它存储到数据库之前初始化基类`Auditable`属性。
- en: If the current instance also extends the `ISynchronizableDataModel` interface,
    then its `ObjectState` property will be set to the `Active` member of the `ObjectState`
    enumeration. This idea could easily be extended; if we had an `IIdentifiable`
    interface with a single identification property, we could initialize that here
    as well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前实例也扩展了`ISynchronizableDataModel`接口，那么它的`ObjectState`属性将被设置为`ObjectState`枚举中的`Active`成员。这个想法可以很容易地扩展；如果我们有一个带有单个标识属性的`IIdentifiable`接口，我们也可以在这里初始化它。
- en: The `DeleteProductAsync` method also returns a `Task` of the type `SetDataOperationResult` and
    calls the `TrySetAsync` method of the `DataOperationManager` class, but it uses
    a different overload, which enables the feedback message to be displayed permanently
    or until the user manually closes it. In this example, it is used to ensure that
    the user is aware that the product was deleted.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteProductAsync`方法也返回一个类型为`SetDataOperationResult`的`Task`，并调用`DataOperationManager`类的`TrySetAsync`方法，但它使用了一个不同的重载，这使得反馈信息可以永久显示或直到用户手动关闭它。在这个例子中，它被用来确保用户知道产品已被删除。'
- en: In this method, we pass the `product` input parameter to the `DeleteDataModel`
    method, before passing it to the `DeleteProduct` method of the `IDataProvider`
    instance. This sets the `UpdatedOn` property of the `Auditable` class to the current
    date and time and the `UpdatedBy` property to the currently logged-in user. If
    the current instance extends the `ISynchronizableDataModel` interface, then its
    `ObjectState` property will also be set to a state of `Deleted`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们在将其传递给`IDataProvider`实例的`DeleteProduct`方法之前，将`product`输入参数传递给`DeleteDataModel`方法。这会将`Auditable`类的`UpdatedOn`属性设置为当前日期和时间，并将`UpdatedBy`属性设置为当前登录用户。如果当前实例扩展了`ISynchronizableDataModel`接口，则其`ObjectState`属性也将设置为`Deleted`状态。
- en: The next new method is the `GetProductsAsync` method, which is a get operation
    and returns a `Task` of the type `GetDataOperationResult<Products>`. Internally,
    and like all async get operations, it calls the `TryGetAsync` method of the `DataOperationManager`
    class. It passes the method to run asynchronously and the unspecified error text
    to be displayed as user feedback.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新方法是`GetProductsAsync`方法，它是一个获取操作，返回类型为`Task<GetDataOperationResult<Products>>`的`Task`。内部，就像所有异步获取操作一样，它调用`DataOperationManager`类的`TryGetAsync`方法。它传递异步运行的方法以及要显示为用户反馈的未指定错误文本。
- en: Of particular note here is the `bool` parameter that it passes, which suppresses
    any successful feedback message from being displayed. If there is an error, either
    the provided error message or a more well-defined custom error message will be
    displayed, but as no successful message is displayed, we simply pass an empty
    string through for that parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 特别值得注意的是它传递的`bool`参数，该参数会抑制任何成功的反馈信息显示。如果发生错误，则显示提供的错误信息或更明确的自定义错误信息，但由于没有显示成功信息，我们只需为该参数传递一个空字符串。
- en: The final new data operation method is the `UpdateProduct` method, which is
    not asynchronous, and returns a `SetDataOperationResult` directly. Instead of
    the `TrySetAsync` method, it calls the `TrySet` method of the `DataOperationManager`
    class and passes the method to run the success and error messages and two `bool`
    parameters to signify that it should display the feedback normally.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个新数据操作方法是`UpdateProduct`方法，它不是异步的，并直接返回`SetDataOperationResult`。它不调用`TrySetAsync`方法，而是调用`DataOperationManager`类的`TrySet`方法，并将运行成功和错误消息的方法以及两个`bool`参数传递，表示应该正常显示反馈。
- en: Internally, it passes the `product` input parameter to the `UpdateDataModel`
    method, before passing it to the `UpdateProduct` method of the `IDataProvider`
    instance. This sets the `UpdatedOn` property of the `Auditable` class to the current
    date and time and the `UpdatedBy` property to the currently logged-in user.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，它将`product`输入参数传递给`UpdateDataModel`方法，然后再将其传递给`IDataProvider`实例的`UpdateProduct`方法。这会将`Auditable`类的`UpdatedOn`属性设置为当前日期和时间，并将`UpdatedBy`属性设置为当前登录用户。
- en: This gives an example of how we might build up our data operation methods, predominantly
    using asynchronous access methods but not restricted to having to do so. Of course,
    there are many ways of accessing data in an application, and you should experiment
    with the way that suits you best. This way would suit larger scale applications
    best, as there is a fair amount of overhead in creating this system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个示例，说明了我们可能构建我们的数据操作方法，主要使用异步访问方法，但并不限制必须这样做。当然，在应用程序中访问数据有许多方法，你应该尝试最适合你的方法。这种方法最适合大规模应用程序，因为创建此系统需要相当多的开销。
- en: 'However, there''s still one piece of the puzzle missing. Now that we''ve changed
    the constructor of the `DataController` class, we''ll also need to update our
    `BaseViewModel` class, which exposes it, again:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然缺少一个拼图。现在我们已经更改了`DataController`类的构造函数，我们还需要更新我们的`BaseViewModel`类，它再次公开它：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the `IDataProvider` implementation is resolved by the `DependencyManager`
    instance, along with the `IUiThreadManager` implementation that gets injected
    into the `DataOperationManager` object. In addition to this, we pass the value
    of the `StateManager.CurrentUser` property to the `DataController` class constructor
    to instantiate it each time it is requested.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`IDataProvider`实现由`DependencyManager`实例解析，同时将`IUiThreadManager`实现注入到`DataOperationManager`对象中。此外，我们将`StateManager.CurrentUser`属性的值传递给`DataController`类构造函数，以便每次请求时都实例化它。
- en: Now we have a system in place that can run our data operations either synchronously
    or asynchronously and retry our data operations a specified number of times if
    they fail, before finally reporting custom feedback messages to the user.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了一个系统，该系统可以同步或异步地运行我们的数据操作，如果数据操作失败，可以在最终向用户报告自定义反馈消息之前重试指定次数。
- en: We can customize how long these messages remain visible before automatically
    disappearing, or whether they will automatically disappear or not, or even whether
    they are displayed in the first place or not. Even with these options, the system
    remains lightweight and can be easily added to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自定义这些消息在自动消失之前保持可见的时间长度，或者是否将自动消失，或者甚至是否一开始就显示。即使有这些选项，系统仍然保持轻量级，并且可以轻松添加。
- en: Going the extra mile
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 走得更远
- en: Most privately developed applications are primarily functional, with little
    time and effort spent on design concerns and even less on usability. How many
    times have we seen applications that throw out a stack trace to the end user when
    an error occurs, or validation messages that highlight errors with the camel case
    code names for fields, rather than the labels used in the UI?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数私人开发的应用程序主要是功能性的，在设计关注点和可用性方面投入的时间和精力很少。我们有多少次看到当发生错误时，应用程序向最终用户抛出堆栈跟踪，或者用驼峰命名法突出显示字段错误的验证消息，而不是在UI中使用的标签？
- en: In a good application, the end user should never be presented with any code-based
    terminology. If we were writing an English based application, we wouldn't output
    error messages in Spanish, so *why* output them in C#? This can confuse the user
    and even alarm them in some cases.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个好的应用程序中，最终用户不应该遇到任何基于代码的术语。如果我们正在编写基于英语的应用程序，我们不会输出西班牙语的错误消息，那么*为什么*要输出C#的错误消息呢？这可能会让用户困惑，甚至在某些情况下使他们感到惊慌。
- en: How many times have you used an application that has an awkward process flow
    to perform each task that involves far more mouse clicks than is necessary? This
    section is dedicated to avoiding these kinds of situations and suggests a number
    of ways of improving the usability of our applications.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次使用过执行每个涉及比必要的鼠标点击更多的任务的应用程序？本节致力于避免这些情况，并提出了一些改进我们应用程序可用性的方法。
- en: Producing in-application help
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成应用程序内帮助
- en: In an ideal world, we would all create applications that were so intuitive that
    we wouldn't need to provide in-application help. However, with the complexity
    of some of today's applications, this is not always possible. It is therefore
    often helpful to provide the end users of our applications with some form of help
    that they can refer to when necessary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，我们都会创建出如此直观的应用程序，以至于我们不需要提供应用程序内的帮助。然而，由于一些现代应用程序的复杂性，这并不总是可能的。因此，为我们的应用程序的最终用户提供一些形式上的帮助，以便他们在需要时可以参考，通常是有帮助的。
- en: There are a number of ways of doing this, with the first simply being to provide
    a link to a separate help file from the application. If we have a PDF, or other
    type of file that contains help for the users, we can add it to our solution in
    Visual Studio as a resource.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以实现这一点，其中第一种简单的方法是从应用程序提供指向单独的帮助文件的链接。如果我们有一个包含用户帮助的PDF或其他类型的文件，我们可以在Visual
    Studio中将它作为资源添加到我们的解决方案中。
- en: To do this, we can add a `Resources` folder into our solution and then select
    the Add New Item option in the new folder's context menu. After navigating to
    the help file in the Add New Item dialog and successfully adding it, we can view
    its properties by selecting it in the Solution Explorer and pressing *F4*, or
    right clicking it and selecting Properties from the context menu.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以在我们的解决方案中添加一个`资源`文件夹，然后在新建文件夹的上下文菜单中选择“添加新项”选项。在“添加新项”对话框中导航到帮助文件并成功添加后，我们可以在解决方案资源管理器中选择它并按*F4*键查看其属性，或者右键单击它并从上下文菜单中选择“属性”。
- en: Once the properties are displayed, we can verify that the file has been added
    with a Build Action of Content and a Copy to Output Directory value of Copy always
    or Copy if newer, which ensures that our help file and its `Resources` folder
    will be copied to the folder that contains the application executable file, and
    that the newest version will always be used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 属性显示后，我们可以验证文件是否已添加，其构建操作为内容，并将输出目录的值设置为“始终复制”或“如果较新则复制”，这确保我们的帮助文件及其`资源`文件夹将被复制到包含应用程序可执行文件的文件夹中，并且始终使用最新版本。
- en: 'We can then add a menu item or button to our application, which the users can
    select to open the document directly. In our View Model command that is data bound
    to this control, we can call the `Start` method of the `Process` class, passing
    the path of the help file, to open the file in the default application on the
    user''s computer:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的应用程序中添加一个菜单项或按钮，用户可以选择它来直接打开文档。在我们的数据绑定到这个控件的观点模型命令中，我们可以调用`Process`类的`Start`方法，传递帮助文件的路径，以在用户的计算机上使用默认应用程序打开文件：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can get the folder path of the application executable file, using the following
    code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码获取应用程序可执行文件的文件夹路径：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Therefore, if our `Resources` folder is in the startup project, we could attain
    its folder path like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们的`Resources`文件夹位于启动项目中，我们可以这样获取其文件夹路径：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This utilizes the `DirectoryInfo` class to access the parent folder of the executable
    file, or the root directory of the project, and the `Combine` method of the `Path`
    class to create a file path that combines the new `Resources` folder with that
    path.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了`DirectoryInfo`类来访问可执行文件的上层文件夹，或者项目的根目录，以及`Path`类的`Combine`方法来创建一个文件路径，该路径将新的`Resources`文件夹与该路径合并。
- en: 'If we don''t have a complete documentation file for our application, a quick
    and simple alternative would be to add an information icon to each View. This
    image control could display pertinent information to the users in a tooltip when
    they place their mouse pointer over it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有我们应用程序的完整文档文件，一个快速简单的方法是在每个视图中添加一个信息图标。这个图像控件可以在用户将鼠标指针放在它上面时显示相关信息提示：
- en: '![](img/8383fe40-40bb-48f9-b5c2-4b12b43f1548.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8383fe40-40bb-48f9-b5c2-4b12b43f1548.png)'
- en: 'Using the information icon from the Visual Studio Image Library that was discussed
    in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating Visually
    Appealing User Interfaces*, we can create these help points like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[第8章](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml)“创建视觉吸引力的用户界面”中讨论的Visual
    Studio图像库中的信息图标，我们可以这样创建这些帮助点：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Either way, the idea is to provide the users of the application with any help
    that they may need right from the application itself. This not only improves the
    usability of our applications but also reduces user errors and increases data
    quality.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，我们的想法是向应用程序用户提供他们可能需要的任何帮助，直接从应用程序本身开始。这不仅提高了我们应用程序的可用性，还减少了用户错误并提高了数据质量。
- en: Enabling user preferences
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用用户偏好
- en: The users of our applications are likely to be very different to each other,
    or at least have their individual preferences. One user may prefer to work in
    one way, while another may have different preferences. Providing the ability for
    them to customize the application to suit the way they work will increase the
    usability of the application for them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的用户可能彼此非常不同，或者至少有他们各自的偏好。一个用户可能更喜欢以某种方式工作，而另一个可能有不同的偏好。提供他们能够根据他们工作的方式自定义应用程序的能力将提高他们对应用程序的可用性。
- en: This may relate to the View that they prefer to see when the application starts,
    or to which particular options in each View that they prefer to use, or even to
    the size and position of the application when it was last used. There are any
    number of preferences that we can offer each user.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与他们在应用程序启动时希望看到的视图有关，或者与每个视图中他们希望使用的特定选项有关，甚至可能与应用程序上次使用时的尺寸和位置有关。我们可以为每个用户提供无数种偏好设置。
- en: Luckily, we can offer this customization functionality with minimal work, as
    the .NET Framework provides us with settings files for just this purpose. These
    settings can either have application or user scope and can be mixed and matched
    in each settings file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过最小的工作量提供这种自定义功能，因为.NET Framework为我们提供了用于此目的的设置文件。这些设置可以是应用程序范围或用户范围，并且可以在每个设置文件中混合使用。
- en: Application settings are the same for each user and are suited to storing configuration
    settings, such as email server details or credentials. User settings can be different
    for each user and are suited to the kind of personal customizations just discussed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设置对每个用户都是相同的，适合存储配置设置，例如电子邮件服务器详情或凭据。用户设置对每个用户可能不同，适合于刚才讨论的个人定制。
- en: 'Typically, the startup project will already have a settings file named `Settings.settings`.
    It can be found by opening the `Properties` folder in the Solution Explorer in
    Visual Studio, and opened by double-clicking on it. Alternatively, you can right-click
    on the project in the Solution Explorer, select the Properties option, and then
    select the Settings tab:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，启动项目已经有一个名为 `Settings.settings` 的设置文件。可以在 Visual Studio 中的解决方案资源管理器中打开 `Properties`
    文件夹来找到它，并通过双击它来打开。或者，您可以在解决方案资源管理器中右键单击项目，选择“属性”选项，然后选择“设置”选项卡：
- en: '![](img/1c19c851-ed84-4e7b-91d5-6289d9a0095c.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1c19c851-ed84-4e7b-91d5-6289d9a0095c.png)'
- en: Settings files can also be added to other projects although they are not typically
    available by default. In order to add a settings file to another project, we first
    need to open the project properties by right clicking on the project in the Solution
    Explorer and selecting the Properties option.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件也可以添加到其他项目中，尽管它们默认情况下通常不可用。为了将设置文件添加到其他项目，我们首先需要通过在解决方案资源管理器中右键单击项目并选择“属性”选项来打开项目属性。
- en: 'In the project properties window, select the Settings tab and click the link
    that says This project does not contain a default settings file. Click here to
    create one. A settings file will be created within the project `Properties` folder
    in the Solution Explorer. We are then free to start adding our user preferences:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目属性窗口中，选择“设置”选项卡，并单击显示“此项目不包含默认设置文件”的链接。点击此处创建一个。设置文件将在解决方案资源管理器中项目的 `Properties`
    文件夹内创建。然后我们可以开始添加我们的用户偏好设置：
- en: '![](img/d80b38d1-0f81-44f9-85fe-cb1d23184363.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d80b38d1-0f81-44f9-85fe-cb1d23184363.png)'
- en: To add our custom settings, click a blank row in the settings file and enter
    the name, data type, scope, and default value of the setting. The name will be
    used in code, and so it cannot contain spaces. We can select our own custom data
    types, although whichever type we select must be serializable. The default value
    is the initial value that the setting will have before the user changes it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加我们的自定义设置，请在设置文件中点击一个空白行，并输入设置的名称、数据类型、作用域和默认值。名称将在代码中使用，因此它不能包含空格。我们可以选择自己的自定义数据类型，尽管我们选择的任何类型都必须是可序列化的。默认值是用户更改之前设置将具有的初始值。
- en: 'Settings will usually be loaded upon application startup and saved just before
    application shutdown. As such, it is customary to attach event handlers to the
    `Loaded` and `Closed` events in the `MainWindow.xaml.cs` file, although we can
    also do it in the `App.xaml.cs` file if we have configured the application to
    use it. We can see a typical example here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 设置通常在应用程序启动时加载，并在应用程序关闭前保存。因此，在 `MainWindow.xaml.cs` 文件中附加到 `Loaded` 和 `Closed`
    事件是惯例，尽管如果我们已经配置应用程序使用它，我们也可以在 `App.xaml.cs` 文件中这样做。这里有一个典型的例子：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We attach the two event handlers in the constructor, right after the components
    are initialized. In the `MainWindow_Loaded` method, we instantiate an instance
    of the `MainWindowViewModel` class, call its `LoadSettings` method, and set it
    as the window's `DataContext` property value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中附加这两个事件处理器，在组件初始化之后立即进行。在 `MainWindow_Loaded` 方法中，我们实例化 `MainWindowViewModel`
    类的一个实例，调用它的 `LoadSettings` 方法，并将其设置为窗口的 `DataContext` 属性值。
- en: 'In the `MainWindow_Closed` method, we access the instance of the `MainWindowViewModel`
    class from the `DataContext` property, but, this time, call its `SaveSettings`
    method. Now, let''s see these methods in the `MainWindowViewModel.cs` file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow_Closed` 方法中，我们从 `DataContext` 属性访问 `MainWindowViewModel` 类的实例，但这次调用它的
    `SaveSettings` 方法。现在，让我们在 `MainWindowViewModel.cs` 文件中查看这些方法：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first thing that we need to do in the `L``oadSettings` method is to call
    the `Reload` method on the default instance of the settings file. This loads the
    settings from the settings file into the `Default` object. From there, we set
    each settings property to its corresponding property that we created in our `StateManager`
    class, for use in the application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `LoadSettings` 方法中，我们首先需要做的是调用设置文件的默认实例上的 `Reload` 方法。这将从设置文件中加载设置到 `Default`
    对象中。从那里，我们将每个设置属性设置为我们在 `StateManager` 类中创建的相应属性，以便在应用程序中使用。
- en: 'Note that the values of each user''s personal settings are not stored in the
    `Settings.settings` file. Instead, they are stored in their `AppData` folder,
    which is hidden by default. The exact file path can be found using the `ConfigurationManager`
    class, but to find it we''ll need to add a reference to the `System.Configuration`
    DLL and use the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个用户的个人设置值不是存储在`Settings.settings`文件中。相反，它们存储在他们的`AppData`文件夹中，该文件夹默认隐藏。确切文件路径可以使用`ConfigurationManager`类找到，但为了找到它，我们需要添加对`System.Configuration`
    DLL的引用并使用以下代码：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In my case, that resolves to the following file path:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，这对应以下文件路径：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the folder in the `CompanyName` folder is named using a particular
    identification number that relates to the current settings and application version.
    Over time and after making changes, new folders will appear here with new identification
    numbers, but this is all totally transparent to the users as their previous settings
    will be safely transferred.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`CompanyName`文件夹中的文件夹使用特定的识别号命名，该识别号与当前设置和应用程序版本相关。随着时间的推移和做出更改后，这里将出现带有新识别号的新文件夹，但这一切对用户来说都是完全透明的，因为他们的先前设置将被安全地迁移。
- en: Extending common courtesies
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展常规礼仪
- en: One area of application development where we can easily make great improvements
    is usability. Many applications these days are created with little or no concern
    for the end users that will be using the application each day.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用开发领域，我们可以轻松地提高的一个方面是可用性。如今，许多应用在创建时很少或根本不考虑每天将使用该应用的用户。
- en: We've probably all seen applications that spew out exception stack traces when
    errors occur, and while we, as developers, may find that useful, it can be confusing
    or even alarming for the end users. Instead of worrying the end users unnecessarily,
    we can output stack traces and any other pertinent information about each error
    to an `Errors` table in our database.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能都见过当发生错误时，应用程序会抛出异常堆栈跟踪的情况，虽然作为开发者，我们可能觉得这很有用，但对于最终用户来说，这可能会令人困惑，甚至令人恐慌。为了避免不必要地让最终用户感到担忧，我们可以将堆栈跟踪和任何其他与每个错误相关的信息输出到我们数据库中的`Errors`表中。
- en: Extending this idea further, it is good working practice to totally avoid using
    any development terms or phrases anywhere in the application that the users can
    see. That includes all UI labels along with any additional external help files
    and documentation. Using terms of this kind will make the application more difficult
    to use, especially for new users. All but the best known abbreviations should
    also be avoided.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步扩展这个想法，完全避免在任何用户可以看到的应用程序中使用任何开发术语或短语是一个好的工作习惯。这包括所有UI标签以及任何额外的外部帮助文件和文档。使用这类术语会使应用程序更难使用，尤其是对于新用户。除了最知名的缩写外，也应避免使用。
- en: 'We can further humanize our application by paying attention to the small details.
    How often have you come across an application that displays a label that says
    something like "1 passengers" or "2 item." While this is a very simple problem
    to fix, it is commonly found in many applications. Let''s create a new Extension
    Method to encapsulate this useful functionality in an `IntegerExtensions` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注细节，我们可以进一步使我们的应用程序人性化。你有多经常遇到一个显示类似“1乘客”或“2项目”标签的应用程序？虽然这是一个非常简单的问题，但在许多应用程序中都很常见。让我们创建一个新的扩展方法，将这个有用的功能封装在`IntegerExtensions`类中：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we simply use String Interpolation to append an `s` to the
    end of the `wordToAdjust` input parameter when the value of the this `input` parameter
    is not `1`. While this will work for most words that we are likely to use, it
    is worth noting that there are some groups of words that this will not work with.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们简单地使用字符串插值将`s`追加到`wordToAdjust`输入参数的末尾，当`this`输入参数的值为`1`时。虽然这对我们可能使用的多数单词都适用，但值得注意的是，有一些单词组这种方法不适用。
- en: For example, some words, such as "Activity," ending with a "y" in their singular
    form, will end with "ies" when pluralized. However, this problem can be easily
    addressed by either adding a new overload of our `Pluralize` method or an additional
    input parameter that enables the users of our code to specify the transformation
    that they require.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一些单词，如以“y”结尾的单数形式“Activity”，在复数形式时将以“ies”结尾。然而，这个问题可以通过添加我们`Pluralize`方法的新重载或一个额外的输入参数来解决，该参数允许我们的代码用户指定他们所需的转换。
- en: 'With this method, we now have a really simple way to always ensure that our
    spelling is correct when dealing with quantities. Let''s see how we might use
    this method to pluralize the word `Ticket`, but only when the amount of tickets
    in the `Tickets` collection is not `1`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，我们现在有一个非常简单的方法来确保在处理数量时我们的拼写总是正确的。让我们看看我们如何使用此方法来复数化单词`Ticket`，但仅当`Tickets`集合中的票数不是`1`时：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An extension to this method could combine this functionality with the actual
    number to output `6 Tickets` , for example. Let''s take a look at this new method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的扩展可以将此功能与实际数字结合，例如输出`6 Tickets`。让我们看看这个新方法：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Combine` method is very similar to the `Pluralize` method, except that
    it also includes the value of the `input` input parameter in the text output.
    We could also extend this method in the same way that we could extend the `Pluralize`
    method to handle the pluralization of words other than those that just require
    an `s` to be appended. We can also use it in the same way:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Combine`方法与`Pluralize`方法非常相似，不同之处在于它还包括`input`输入参数的值在文本输出中。我们也可以以相同的方式扩展此方法，就像我们可以扩展`Pluralize`方法来处理除了只需附加`s`以外的单词的复数化。我们也可以以相同的方式使用它：'
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Another way that we could humanize our textual output would be to provide a
    selection summary field that displays a comma-separated list of the selected items
    in a collection control. Clearly, this wouldn''t be required for controls that
    only allow single selections to be made; however, it could be a useful confirmation
    for those using multiple selection collection controls. Let''s see how we could
    declare a `ToCommaSeparatedString` method now:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使文本输出更人性化的另一种方法是为集合控件提供一个选择摘要字段，该字段显示所选项目的逗号分隔列表。显然，对于只允许进行单选的控件来说，这并不是必需的；然而，对于使用多选集合控件的用户来说，这可能是一个有用的确认。现在让我们看看我们如何声明一个`ToCommaSeparatedString`方法：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we have a method that we can call on any collection that is either of
    the type of, or extends, the `IEnumerable<T>` interface and receives a string
    back that contains a comma-separated list of each contained element. We can either
    call it with a string collection or implement the `object.ToString` method in
    our classes, as that will be called on each element.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个可以在任何类型为或扩展`IEnumerable<T>`接口的集合上调用的方法，并返回一个包含每个包含元素的逗号分隔列表的字符串。我们可以用字符串集合调用它，或者在我们的类中实现`object.ToString`方法，因为这将针对每个元素被调用。
- en: This method uses the `StringBuilder` class to build the comma-separated list.
    As the `StringBuilder` class has a slight overhead when being initialized and
    when exporting the constructed string, tests have shown that it only really offers
    an improvement in time over basic string concatenation when appending 10 or more
    strings.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`StringBuilder`类构建逗号分隔列表。由于`StringBuilder`类在初始化和导出构建的字符串时略有开销，测试表明，它只有在附加10个或更多字符串时，相对于基本字符串连接才能真正提供时间上的改进。
- en: You may therefore prefer to refactor this method to remove the `StringBuilder`
    object, although you may also find that the difference in milliseconds is negligible.
    Returning to the method, after declaring the `StringBuilder` object, we initialize
    the `index` variable, which is used to specify which separator to join each string
    with.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能更喜欢重构此方法以删除`StringBuilder`对象，尽管你也可能发现毫秒级的差异微不足道。回到方法本身，在声明`StringBuilder`对象之后，我们初始化`index`变量，该变量用于指定将哪个分隔符与每个字符串连接。
- en: When the `index` variable equals zero and no strings have yet been added to
    the `StringBuilder` object, no separator will be appended. After that, we check
    whether the current string is the last in the collection, and if it is, we prepend
    `" and "` to it; otherwise, we prepend a comma and a space to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当`index`变量等于零且尚未向`StringBuilder`对象添加任何字符串时，不会附加任何分隔符。之后，我们检查当前字符串是否是集合中的最后一个，如果是，则在它前面添加`“ and ”`；否则，在它前面添加一个逗号和一个空格。
- en: 'After each iteration, we increment the `index` variable, and when finished,
    we return the output from the `StringBuilder` object. It could be used to display
    a comma-separated list of the products that a user has selected like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代之后，我们增加`index`变量，完成后，我们从`StringBuilder`对象返回输出。它可以用来显示用户所选产品的逗号分隔列表，如下所示：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, there are many ways that we can humanize our output for the
    end users, to make them feel more at ease when using our applications. Let's now
    move on to see other ways that we can provide that great user experience for our
    users.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们有多种方法可以使我们的输出对最终用户更人性化，使他们在使用我们的应用程序时感到更加轻松。现在让我们继续看看我们还可以提供哪些其他方式来为我们的用户提供出色的用户体验。
- en: Unburdening the end user
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减轻最终用户的负担
- en: There are many things that we can do to make the life of the end users easier.
    One simple example would be to set the focus in a form to the first field, so
    that users can start typing as soon as they load a View, without first needing
    to focus it manually.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的很多事情来使最终用户的生活更加轻松。一个简单的例子就是在表单中设置焦点到第一个字段，这样用户就可以在加载视图后立即开始输入，而无需首先手动聚焦它。
- en: 'We saw one way to do this using an Attached Property in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*, but we can also achieve this easily,
    by first adding a new `bool` property into our `BaseViewModel` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml)中看到了使用附加属性来完成这一任务的方法，*精通数据绑定*，但我们也可以通过首先在我们的`BaseViewModel`类中添加一个新的`bool`属性来轻松实现这一点：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next we can add a style resource into the application resources in the `App.xaml`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`App.xaml`文件中的应用程序资源中添加一个样式资源：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This assumes that we already have a default style that we want to use for our
    `TextBox` controls and that our new style will be based on that, but add this
    additional focusable functionality. It simply consists of a single data trigger
    that uses the `FocusedElement` property of the `FocusManager` class to focus the
    `TextBox` element that has this style applied to it when the `IsFocused` property
    is set to `true`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设我们已经有了一个我们想要为我们的`TextBox`控件使用的默认样式，并且我们的新样式将基于这个样式，但添加了额外的可聚焦功能。它仅由一个使用`FocusManager`类的`FocusedElement`属性的数据触发器组成，当`IsFocused`属性设置为`true`时，将聚焦应用了此样式的`TextBox`元素。
- en: 'Therefore, all we need to do to focus a particular `TextBox` control in a View
    is to apply this style to it and set the `IsFocused` property from the `BaseViewModel`
    class to `true` in the appropriate place in the related View Model:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们只需要在视图中应用此样式，并在相关的视图模型中适当的位置将`BaseViewModel`类的`IsFocused`属性设置为`true`，就可以聚焦特定的`TextBox`控件。
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the `TextBox` control will become focused as the property becomes
    `true` , and so if the property is already `true`, we may need to first set it
    to `false` before again setting it to `true` to get this to work. For example,
    if the property was `true` before the View was loaded, then the `TextBox` control
    would not become focused.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当属性变为`true`时，`TextBox`控件将获得焦点，因此如果属性已经是`true`，我们可能需要首先将其设置为`false`，然后再将其设置为`true`以使其工作。例如，如果属性在视图加载之前是`true`，那么`TextBox`控件将不会获得焦点。
- en: 'Another simple example of making our application users'' lives easier would
    be to pre-populate any form fields that we may be able to. For example, if our
    application has a login screen that uses the users'' Windows username, we could
    fill in the user name field in the form after accessing it from the `WindowsIdentity`
    class like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的应用程序用户的生活更加简单的一个简单例子可能是预先填充我们可能能够填充的任何表单字段。例如，如果我们的应用程序有一个使用用户Windows用户名的登录屏幕，我们可以在从`WindowsIdentity`类访问它后，像这样填写用户名字段：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Another example of this might be to pre-populate form fields with the most commonly
    used values. We could perhaps fill in a date field with today's date or an Amount
    Paid field to the total amount, if that is what the users typically do.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的另一个例子可能是预先填充表单字段，使用最常用的值。我们可能会用今天的日期填充日期字段，或者将已支付金额字段填充为总金额，如果这是用户通常的做法。
- en: We do, however, need to be careful when doing this because if we get the default
    value(s) wrong, it could backfire and actually take the users longer to delete
    the default value and replace it with the value that they want than to just input
    the value directly. Remember, the idea is to save the users time and make them
    more productive.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们这样做时，我们需要小心，因为如果我们得到默认值（们）错误，可能会适得其反，实际上让用户删除默认值并替换为想要的值比直接输入值花费的时间更长。记住，我们的想法是节省用户的时间并提高他们的生产力。
- en: Quite often, we can save the users of our applications a great amount of time.
    If we have the chance to ask them exactly what they do and how they would use
    the application on a day-to-day basis, then we can usually program a lot of their
    operations into functions in the application.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 很经常，我们可以为我们应用程序的用户节省大量的时间。如果我们有机会了解他们具体做什么以及他们如何在日常使用中利用应用程序，那么我们通常可以将他们的许多操作编程到应用程序的功能中。
- en: For example, if any users have to repeatedly edit a number of files with the
    same data, perhaps to add, remove, or update a particular field, then we could
    build that functionality straight into the application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果任何用户需要反复编辑多个具有相同数据的文件，可能是为了添加、删除或更新特定字段，那么我们可以在应用程序中直接构建该功能。
- en: Instead of making them edit a single record at a time, we could provide a View
    where they set the field, or fields to change, and the new value(s), along with
    the ability to select multiple records, and therefore save them a great deal of
    time and effort.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个视图，让他们设置要更改的字段或字段，以及新的值，同时具备选择多个记录的能力，从而为他们节省大量的时间和精力。
- en: All menial, or repetitive tasks can be programmed into functions, and so writing
    a good application is not just restricted to making pretty and asynchronous UIs but
    also to making it highly usable. Furthermore, the more useful the application
    is, the more productive the users will become, and the more lavish the praise
    that will be bestowed on us and our development teams, if applicable.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所有琐碎的或重复的任务都可以编程到函数中，因此编写一个好的应用程序不仅限于创建漂亮和异步的UI，还要使其高度可用。此外，应用程序越有用，用户的生产力就越高，我们和我们的开发团队（如果适用）将获得的赞誉也越慷慨。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed further ways to improve our applications, making
    them as useful to the end users as possible. We investigated how we could implement
    a custom user feedback system to keep the users informed with the status of the
    operations that they perform.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了进一步改进我们应用程序的方法，使它们尽可能对最终用户有用。我们研究了如何实现一个定制的用户反馈系统，以使用户了解他们执行的操作的状态。
- en: We also examined how to make our applications asynchronous, so that our UI won't
    freeze when the application is performing long running operations. We then looked
    at one way of building this asynchronous behavior right into our application framework
    so that we can run any data access operation asynchronously with minimal code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何使我们的应用程序异步，这样当应用程序执行长时间运行的操作时，我们的UI不会冻结。然后我们查看了一种将这种异步行为直接构建到我们的应用程序框架中的方法，这样我们就可以以最少的代码异步运行任何数据访问操作。
- en: We ended with a short section dedicated to improving the way that our applications
    are perceived by the end users. In it, we detailed a number of ways of accomplishing
    this, from providing in-application help and user preferences to paying attention
    to the smaller details and implementing work-heavy functions to save the users
    from having to manually do the same.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个简短的章节结束，该章节致力于改善我们的应用程序在最终用户眼中的形象。在其中，我们详细介绍了实现这一目标的各种方法，从提供应用程序内的帮助和用户偏好设置，到关注细节并实现工作密集型功能，以节省用户手动执行相同操作的时间。
- en: In the next chapter, we'll be looking at a number of ways to improve the performance
    of our applications, from utilizing the power of installed graphics cards to writing
    more efficient code. We'll also look into how we can improve the efficiency of
    our data bindings and resources, and investigate other techniques, such as data
    virtualization.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多种提高我们应用程序性能的方法，从利用已安装的显卡到编写更高效的代码。我们还将研究如何提高我们的数据绑定和资源效率，并调查其他技术，如数据虚拟化。
