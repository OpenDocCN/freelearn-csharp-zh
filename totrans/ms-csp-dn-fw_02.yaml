- en: Chapter 2. Core Concepts of C# and .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the core concepts of C# and .NET, starting from the initial
    version and principal motivations behind its creation, and covering also the new
    aspects of the language, that appeared in versions 2.0 and 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: We'll illustrate all the main concepts with small code snippets, short enough
    to facilitate its understanding and easy reproduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: C# and its role in the Microsoft Development ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difference between strongly typed and weakly typed languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution in versions 2.0 and 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C# – what's different in the language?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I had the chance to chat with Hejlsberg a couple of times about the C # language
    and what the initial purposes and requirements imposed in its creation were and
    which other languages inspired him or contributed to his ideas.'
  prefs: []
  type: TYPE_NORMAL
- en: The first time we talked, in Tech-Ed 2001 (at Barcelona, Spain), I asked him
    about the principles of *his* language and what makes it different from others.
    He first said that it was not only him who created the language, but also a group
    of people, especially *Scott Wiltamuth*, *Peter Golde*, *Peter Sollich*, and *Eric
    Gunnerson*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first books ever published on the subject was, *A Programmer's Introduction
    to C#*, *Gunnerson's.E.*, APress, 2000).
  prefs: []
  type: TYPE_NORMAL
- en: 'About the principles, he mentioned this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"One of the key differences between C# and these other languages, particularly
    Java, is that we tried to stay much closer to C++ in our design. C# borrows most
    of its operators, keywords, and statements directly from C++. But beyond these
    more traditional language issues, one of our key design goals was to make the
    C# language component-oriented, to add to the language itself all of the concepts
    that you need when you write components. Concepts such as properties, methods,
    events, attributes, and documentation are all first-class language constructs."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'He stated also this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"When you write code in C#, you write everything in one place. There is no
    need for header files, IDL files (Interface Definition Language), GUIDs and complicated
    interfaces."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that you can write code that is self-descriptive in this way given
    that you're dealing with a self-contained unit (let's remember the role of the
    manifest, optionally embedded in assemblies). In this mode, you can also extend
    existing technologies in a variety of ways, as we'll see in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Languages: strongly typed, weakly typed, dynamic, and static'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C# language is a strongly typed language: this means that any attempt to
    pass a wrong kind of parameter as an argument, or to assign a value to a variable
    that is not implicitly convertible, will generate a compilation error. This avoids
    many errors that only happen at runtime in other languages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, by dynamic, we mean those languages whose rules are applied at
    runtime, while static languages apply their rules at compile time. JavaScript
    or PHP are good examples of the former case, and C/C++ of the latter. If we make
    a graphic representation of this situation, we might come up with something like
    what is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Languages: strongly typed, weakly typed, dynamic, and static](img/image00431.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the figure, we can see that C# is clearly strongly typed, but it's much more
    dynamic than C++ or Scala, to mention a few. Of course, there are several criteria
    to catalog languages for their typing (weak versus strong) and for their dynamism
    (dynamic versus static).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this has implications in the IDE as well. Editors can tell us which
    type is expected in every case, and if you use a dynamic declaration such as `var`,
    the right side of the equality (if any) will be evaluated, and we will be shown
    the calculated value for every declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Languages: strongly typed, weakly typed, dynamic, and static](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even outside of the .NET world, Visual Studio's IDE is now able to provide strongly
    typed and Intellisense experiences when using languages such as TypeScript, a
    superset of JavaScript that transpiles (converts into) pure JavaScript but can
    be written using the same coding experience as what we would have in C# or any
    other .NET language.
  prefs: []
  type: TYPE_NORMAL
- en: It's available as a separate type of project, if you're curious about it, and
    the latest up-to-date version is TypeScript 2.0, and it was recently published
    (you can take a look at a detailed description of its new capabilities at [https://blogs.msdn.microsoft.com/typescript/](https://blogs.msdn.microsoft.com/typescript/)).
  prefs: []
  type: TYPE_NORMAL
- en: As we'll see later in this chapter, Intellisense is key for the LINQ syntax,
    in which many expressions return a new (non-existing) type, which can be automatically
    assigned to the correct type by the compiler if we use a var declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The main differences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, going back to the title, what made C# different? I''ll point out five core
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is an object (we mentioned this in [Chapter 1](part0015.xhtml#aid-E9OE2
    "Chapter 1. Inside the CLR"), *Inside the CLR*). Other languages, such as Smalltalk,
    Lisp, among others, have done this earlier, but due to different reasons, the
    performance penalty was pretty hard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you know, it's enough to take a look at the Object Explorer to be able to
    check where an object comes from. It's a good practice to check the very basic
    values, such as `int` or `String`, which are nothing but aliases of `System.Int32`
    and `System.String`, and both come from object, as shown in the following screenshot:![The
    main differences](img/image00433.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Boxing and Unboxing techniques, any value type can be converted into
    an object, and the value of an object can be converted into a simple value type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These conversions are made by simply casting the type to an object (and vice
    versa) in this manner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Reflection (the technique that allows you to read a component's metadata),
    an application can call itself or other applications, creating new instances of
    their containing classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a short demo, this simple code launches another instance of a WPF application
    (a very simple one with just one button, but that doesn''t matter):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, every time we click on the button, a new instance of the window is created
    and launched, indicating its creation order in the title's window:![The main differences](img/image00434.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can have access to other components through a technology called Platform
    Invoke, which means you can call operating systems'' functions by importing the
    existing DLLs using the `DllImport` attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, you can make an external program's window the child of your own
    window using the `SetParent` API, which is part of `User32.dll`, or you can control
    operating system events, such as trying to shut down the system while our application
    is still active.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, once the permissions are given, your application can call any function
    located in any of the system's DLL if you need access to native resources.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The schema that gives us access to these resources looks like what is shown
    in the following figure:![The main differences](img/image00435.jpeg)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to try out some of these possibilities, the mandatory resource to
    keep in mind is [http://www.PInvoke.net](http://www.PInvoke.net), where you have
    most of the useful system APIs, with examples of how to use them in C#.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These interoperation capabilities are extended to interactions with applications
    that admit Automation, such as those in the Microsoft Office Suite, AutoCAD, and
    so on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, unsafe code allows you to write inline C code with pointers, perform
    unsafe casts, and even pin down memory in order to avoid accidental garbage collection.
    However, unsafe does not mean that it is unmanaged. Unsafe code is deeply tied
    into the security system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many situations in which this is very useful. It might be an algorithm
    that's difficult to implement or a method whose execution is so CPU-intensive
    that performance penalties become unacceptable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: While all this is important, I was surprised by the fact that every event handler
    in C# (as also in other .NET languages) would have two and only two arguments.
    So, I asked Anders about it, and his answer was one of the most clear and logical
    ones that I've ever heard.
  prefs: []
  type: TYPE_NORMAL
- en: The true reason for delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It so happens that besides these architectural considerations that we''ve mentioned,
    there was another reason that was key to the design: ensuring that a .NET program
    would never produce a **BSOD** (**Blue Screen of Death**).'
  prefs: []
  type: TYPE_NORMAL
- en: So, the team tackled the problem scientifically and made a statistical analysis
    of their causes (more than 70,000 of these screens were used in the analysis).
    It turned out that around 90% of the causes for this problem were due to drivers,
    and the only thing they could do was get serious with manufacturers, asking them
    to pass the **Hardware Compatibility List** (**HCL**) and little else.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current HCL page for Windows can be found at [https://sysdev.microsoft.com/en-us/hardware/lpl/](https://sysdev.microsoft.com/en-us/hardware/lpl/).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, they had a remaining 10% problem due to their own software, but the big
    surprise was that instead of finding five or 10 core causes for these failures,
    the problem focused mainly on just two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Pointer to functions that get lost, which I represent in the graphic by **p*
    -> f(x)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting problems (trying to convert types passed to a function; failing could
    drive to unpredictable results)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The results, expressed in a simple Gaussian curve, look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The true reason for delegates](img/image00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, covering these two issues, more than 95% (or more) of the problems, were
    solved. The first goal was achieved: focusing on the problem and reducing it to
    the maximum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, he had to find a solution that could possibly resolve both issues.
    This is where the genius of this Danish man came in. He thought back to the origins
    of the two problems and realized that both cases were related to method calls.
    Given a twist and a return to rethink the foundations of General Information Theory
    in order to identify the specific problem within the theoretical model (the first
    pages of any book on the subject), we would find something like what is shown
    in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The true reason for delegates](img/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But, wait! ...this is also the core architecture of the event system! So, there
    is a correspondence between the two schemas in the four elements implied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Issuer**: It is the method that makes the call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receiver**: Another class (or the same) responding in another method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Channel**: It is the environment, replaced by a managed environment in .NET'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message**: The information sent to the receiver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the second problem is solved: the model of the target is identified as
    a case of the general pattern of information theory as well as its parts: the
    channel and the information expected to be received.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What was missing? What has always been done in computer science to solve problems
    of direct calls? That would be calling in an intermediary. Or if you prefer otherwise,
    applying the fifth principle of the SOLID design: Dependency Inversion.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll talk in more detail about dependency inversion when we cover *Design
    patterns* in [Chapter 10](part0055.xhtml#aid-1KEEU1 "Chapter 10. Design Patterns"),
    *Design Patterns*, but for now, suffice to say what the principle states (in short):
    modules should not depend on low-level modules or on details but on abstractions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the factor responsible for this solution comes in: the delegate.
    Calls are never made directly but always through the delegate, which is administered
    by CLR and will not attempt to call something that is not available (it''s managed,
    remember). The function pointer problem is solved via the channel (and the elimination
    of function pointers, of course).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the official (Wikipedia''s) article explaining this principle
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)),
    you''ll discover that the recommended solution of the pattern is to change from
    scenario 1 (at the left-hand side of the figure) to scenario 2 (at the right-hand
    side), in which it is proposed that the method that is called (in object B) inherits
    (implements) an interface to make sure that the call is realized with no risks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The true reason for delegates](img/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The solution to the second cause, as Hejlsberg said, *seemed trivial, once turned
    above*. He just had to make the delegate's signature equal to the receiving method
    (remember, the same types of parameters and return value), and bid goodbye to
    the problems of casting, since CLR is strongly typed and the compiler (and even
    the IDE) will mark any violation of this principle, indicating that it won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: This architecture avoids the problems of BSOD originated by these causes. Can
    we look at this structure in code? Sure. Actually, I'm pretty sure you have seen
    it often, only not from this point of view maybe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back a second to the previous case with our Reflected window. And
    let''s identify the protagonists. The emitter is clearly the `bntLaunch` button
    member, and the receiver is the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we see the click''s event handler method''s definition, we also see
    two of the members of scenario 2: the sender (the emitter) and the information
    passed in (an instance of the `RoutedEventArgs` class).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, a delegate in charge of the call should have the same signature as
    that in this method. Just right-click on the name of the method, **Search all
    references**, and you''ll find out where the connection between the method and
    the delegate is established (the usual syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the click member of `btnLaunch` is connected to the `btnLaunch_Click` method
    by means of a new instance of a delegate of type `RoutedEventHandler`. Once again,
    right-click on **RoutedEventHandler** and select **Go to definition** in order
    to take a look at the delegate''s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Voilà, the signature is exactly the same as the receiver. No more casting problems,
    and if the CLR does its work, no calls will be made unless the receiver method
    is not accessible. This is because only a kernel-level component can cause a BSOD,
    never a user mode component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a delegate is a very special class that can be declared outside or inside
    any other class and has the ability to target any method as long as their signatures
    are compatible. The `+=` syntax also tell us something important: they are multicast.
    That is, they can target more than one method in a single call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s place this in a scenario where we need to evaluate which numbers are
    divisible by another sequence of numbers. To put it simply, let''s start with
    two methods, checking the divisibility by 2 and 3, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to evaluate the list and fill a Listbox including those numbers
    that comply with the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We declare a delegate, `DivisibleBy`, which receives a number and performs an
    action (later, we'll find that this is renamed to `Action`). So, the same delegate
    can call both methods in a sequence (note that this can make the sequence pretty
    long).
  prefs: []
  type: TYPE_NORMAL
- en: 'The delegate is invoked using another button that will call the following code
    when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we don''t include the implementation of `PrintResults`, which you can
    imagine and which is also included in the `Chapter02_02` demo. The following result
    is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The true reason for delegates](img/image00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The evolution in versions 2.0 and 3.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we see, even from the very beginning, the Hejlsberg's team started with a
    complete, flexible, and modern platform, capable of being extended in many ways
    as technology evolves. This intention became clear since version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: The first actual fundamental change that took place in the language was the
    incorporation of Generics. Don Syme, who would later on lead the team that created
    the F# language, was very active and led this team as well, so it was ready for
    version 2.0 of the .NET Framework (not just in C# but in C++ and VB.NET as well).
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of generics was mainly to facilitate the creation of more reusable
    code (one of the principles of OOP, by the way). The name refers to a set of language
    features that allow classes, structures, interfaces, methods, and delegates to
    be declared and defined with unspecified or generic type parameters instead of
    specific types (see [https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx](https://msdn.microsoft.com/en-us/library/ms379564(v=vs.80).aspx),
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: So, you can define members in a sort of abstract definition, and later on, at
    the time of using it, a real, concrete type will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: The basic .NET classes (BCL) were enhanced in the `System` namespace and a new
    `System.Collections.Generic` namespace was created to support this new feature
    in depth. In addition, new support methods were added to ease the use of this
    new type, such as `Type.IsGenericType` (obviously, to check types), `Type.GetGenericArguments`
    (self-descriptive), and the very useful `Type.MakeGenericType`, which can create
    a generic type of any kind from a previous nonspecified declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code uses the generic type definition for a Dictionary (`Dictionary<,>`)
    and creates an actual (build) type using this technique. The relevant code is
    the following (the rest, including the output to the console is included in `Demo_02_03`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, `MakeGenericType` expects an array of (concrete) types. Later on
    (not in the preceding code), we use `GetGenericTypeDefinition`, `IsGenericType`,
    and `GetGenericArguments` in order to introspect the resulting types and present
    the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generics](img/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, we have different ways to declare generics with identical results as far
    as the operations in the code are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, manipulating already constructed generic types is not the only possibility,
    since one of the main goals of generics is to avoid casting operations by simplifying
    the work with collections. Up until version 2.0, collections could only hold basic
    types: integers, longs, strings, and so on, along with emulating different types
    of data structures, such as stacks, queues, linked lists, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides this, Generics have another big advantage: you can write methods that
    support working with different types of arguments (and return values) as long
    as you provide a correct way to handle all possible cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the notion of contract will be crucial here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom generic types and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other useful feature is the possibility to use custom generic types. Generic
    types and the support for optional values through the `System.Nullable<T>` type
    were, for many developers, two of the most important features included in version
    2.0 of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you have a `Customer` class, which your application manages. So, in
    different use cases, you will read collections of customers and perform operations
    with them. Now, what if you need an operation such as `Compare_Customers`? What
    would be the criteria to use in this case? Even worse, what if we would like to
    use the same criteria with different types of entities, such as `Customer` and
    `Provider`?
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, some characteristics of generics come in handy. To start with,
    we can build a class that has an implementation of the `IComparer` interface,
    so we establish beyond any uncertainty what the criteria to be used is in order
    to consider customer `C1` bigger or smaller than customer `C2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if the criteria is only `Balance`, we can start with a basic
    `Customer` class, to which we add a static method in order to generate a list
    of random customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, we build another `CustomerComparer` class, which implements the `IComparer`
    interface. The difference is that this comparison method is a generic instantiation
    customized for the `Customer` objects, so we have the freedom of implementing
    this scenario just in the way that seems convenient for our logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''re using `Balance` as an ordering criteria, so that we would
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the criteria used to compare is just the one we decided for
    our business logic. Finally, another class, `GenericCustomer`, which implements
    an entry point of the application, uses both classes in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces an output of random customers order by their balance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom generic types and methods](img/image00441.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is even better: we can change the method so that it supports both customers
    and providers indistinctly. To do this, we need to abstract a common property
    of both entities that we can use for comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If our implementation of `Provider` has different or similar fields (but they''re
    not the same), it doesn''t matter as long as we have the common factor: a `Balance`
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we begin with a simple definition of this common factor, an interface called
    `IPersonBalance`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as our `Provider` class implements this interface, we can later create
    a common method that''s able to compare both objects, so, let''s assume our `Provider`
    class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we rewrite the `Comparer` method to be a `GenericComparer` class, capable
    of dealing with both types of entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this implementation, `IComparer` depends on an interface, not on
    an actual class, and that this interface simply defines the common factor of these
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our new entry point will put everything together in order to obtain an
    ordered list of random `Provider` classes that uses the common comparison method
    just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we obtain an output like what is shown in the following figure
    (note that we didn''t take much care of formatting in order to focus on the process):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom generic types and methods](img/image00442.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The example shows how generics (and interfaces: also generic) come to our rescue
    in these types of situations, and—as we''ll have the opportunity to prove when
    talking about implementations of design patterns—this is key to facilitating good
    practice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, some of the most critical concepts behind generics have been discussed.
    In up coming chapters, we''ll see how other aspects related to generics show up.
    However, the real power comes from joining these capabilities with two new features
    of the language: lambda expressions and the LINQ syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions and anonymous types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a bit, let''s review what happens when we create a new, anonymous type
    by invoking the `new` operator, followed by a description of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler correctly infers the non-declared type to be anonymous. Actually,
    if we use the disassembler tool we saw in the previous chapter, we''ll discover
    how the compiler assigns a default name to this class (``f_AnonymousType0`2``):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lambda expressions and anonymous types](img/image00443.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, we can see that a special constructor has been created along with two
    private fields and two access methods (`get_Age` and `get_Name`).
  prefs: []
  type: TYPE_NORMAL
- en: These kind of objects are especially suitable when we deal with data coming
    from any source, and we filter the information vertically (that is, we don't require
    all fields but just a few, or maybe even one).
  prefs: []
  type: TYPE_NORMAL
- en: The resulting objects coming from such a query are not previously defined anywhere
    in our code, since every different query would required a customized definition.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With that in mind, a lambda expression is just an anonymous function, which
    is expressed in a different syntax that allows you to pass such a function as
    an argument, much in the style of functional programming languages, such as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C# 3.0, lambda expressions appeared with a simplified syntax that uses a
    lambda operator (`=>`). This operator divides the defined function into two parts:
    the arguments to the left and the body to the right; for example, take a look
    at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This admits certain variations, such as the omission of parenthesis in the list
    of arguments and the omission of curly brackets in the body as long as the compiler
    is able to infer the details, types involved, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the preceding declaration is a delegate''s definition, we can assign
    it to any delegate''s variable, and so we can express the condition used when
    finding the divisible numbers by 3 or 7 in a much neater way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That is, variable `ed3` is assigned a lambda expression that receives an element
    (an `int`, in this case) and evaluates the body function, which calculates the
    same numbers as we did earlier. Note that the body function is not enclosed in
    curly brackets because the definition is clear enough for the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: So, operating in this manner, there is no need to declare separated methods,
    and we can even pass one of these expressions as an argument to a method that
    accepts it like many of the generic collections do.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we start to see the power of all this when used in conjunction
    with generic collections. From version 3.0 of .NET framework, generic collections
    include a bunch of methods that admit lambda expressions as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: It's all about signatures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The .NET framework team, however, went a bit deeper. If you abstract the possible
    signatures behind any delegate, you can categorize them in three blocks depending
    on the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegates with no return value (called actions and defined with the `Action`
    keyword)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delegates that return a Boolean (now called predicates, such as in logic, but
    defined with the `Func` keyword)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of delegates, returning any type (also defined with the `Func` keyword)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, these three reserved words became part of the C# syntax, and all the generic
    methods we find in collections will ask us for one of these three types of delegates.
    A simple look at one of these in Visual Studio will show us this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s all about signatures](img/image00444.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The screenshot shows the definition of the `Where<T>` method. Just think about
    it: the idea is to allow us to filter collection data in a manner similar to how
    the `where` clause does in the SQL syntax. What we express in a `where` clause
    is a Boolean condition, just like in Mathematical Logic, a predicate is an assertion
    that is always evaluated to be `true` or `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can recode the previous scenario using `numberList` directly,
    with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Same results are obtained with much less plumbing, so we can focus more on the
    problem to be solved and less on the algorithm required.
  prefs: []
  type: TYPE_NORMAL
- en: Many more methods were added and immediately accepted by the programmer's community
    due to the productivity linked to them. For the case with no return values, the
    body code is supposed to act over something external to the method. In our example,
    it could be something like adding a number to the list of selected values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this way, we can handle more complex situations, such as the case where
    we need to calculate multiples of two numbers starting with a certain digit, such
    as in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this variation, we use the `ForEach` method, which receives an `Action`
    delegate argument, as we can see in the tooltip definition offered by the IDE''s
    Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s all about signatures](img/image00445.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How do these sentences translate into real code? It might be a bit surprising
    for the curious reader to take a look at the MSIL code produced by this code.
    Even a simple lambda expression can become more complex than one might think a
    priori.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the syntax of our previous `x => x % 3 == 0` lambda expression
    that we have been using. The trick here is that (internally) this is converted
    to a tree expression, and if you assign that expression to a variable of type
    `Expression<TDelegate>`, the compiler generates the code to build an expression
    tree representing that lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, consider that we express the lambda in its alternative syntax using an
    `Expression` object, such as in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, you can check the disassembly code and find the equivalent in
    the MSIL code, which is made up of several declarations of individual expressions,
    as shown in the following screenshot (just a fragment of what is inside):'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s all about signatures](img/image00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This equivalence becomes more evident if we translate the code of one of these
    expressions into its individual parts. The official MSDN documentation gives us
    the clue by comparing a simple lambda built using expressions with its generated
    parts. So, they start by saying something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the decomposition of this expression tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the result of this decomposition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![It''s all about signatures](img/image00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is equivalent to the lambda expression, but now we can see that internally,
    operating with the individual components of the tree is equivalent to the shorten
    lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: The LINQ syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal of all this, besides making things easier for the way we deal with
    collections, is to facilitate data management. That means reading information
    from a source and converting it into a collection of objects of the desired type,
    thanks to these generic collections.
  prefs: []
  type: TYPE_NORMAL
- en: However, what if I want to express a query in a similar syntax to a SQL query?
    Or, simply, what if the complexity of the query doesn't make it easy to express
    it with the generic methods indicated so far?
  prefs: []
  type: TYPE_NORMAL
- en: The solution came in form of a new syntax, inherent to the C# (and other .NET
    languages), called **LINQ** (**Language-Integrated Query**). The official definition
    presents this extension as *a set of features introduced in Visual Studio 2008
    that extends powerful query capabilities to the language syntax of C#*. Specifically,
    the authors highlight this feature as something that takes the form of *LINQ provider
    assemblies that enable the use of LINQ with .NET Framework collections, SQL Server
    databases, ADO.NET Datasets, and XML documents*.
  prefs: []
  type: TYPE_NORMAL
- en: So, we are given a new SQL-like syntax to generate any kind of query in such
    a way that the same sentence structure is valid for very different data sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that previously, data queries had to be expressed as strings without
    type checking at compile time or any kind of IntelliSense support, and it was
    mandatory to learn a different query language depending on the type of data source:
    SQL databases, XML documents, Web services, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: LINQ syntax is based on the SQL language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, as Hejlsberg mentioned many times, they had to change the order
    of the clauses if they wanted to provide any kind of Intellisense, so a query
    of this type adopts the form of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, once the user specifies the source (a collection), Visual Studio
    is able to provide you with Intellisense for the rest of the sentence. For instance,
    in order to select a few numbers from a number list, such as the ones used in
    previous examples, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have used the `&&` operator to concatenate both conditions (we''ll
    go further into this in a bit), and there is no problem with using the LINQ syntax
    in conjunction with lambda expressions. Furthermore, it is recommended that you
    express the query in the more suitable, readable, and maintainable way. Of course,
    the output is still what is expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![LINQ syntax is based on the SQL language](img/image00448.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The only condition required for the collection is that it should support `IEnumerable`
    or the generic `IEnumerable<T>` interfaces (or any other interface that inherits
    from it).
  prefs: []
  type: TYPE_NORMAL
- en: As you may expect, often, the collection is just a previously obtained collection
    of business logic objects as the result of a query to a database table.
  prefs: []
  type: TYPE_NORMAL
- en: Deferred execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'However, there is a very important point to remember: the LINQ syntax itself
    uses a model called *deferred execution* or *lazy loaded*. This means that a query
    is not executed until the first bit of data is required by another sentence.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, we can force the execution by converting the resulting collection into
    a concrete collection, for example, by calling the `ToList()` method or requiring
    other data linked to the actual use of the collection, such as counting the number
    of rows returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is something we can do by enclosing the LINQ query in parenthesis and
    applying the solicited operation (note that the value returned is automatically
    converted into the appropriate type), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deferred execution](img/image00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a similar way, we can order the resulting collection in an ascending (the
    default) or descending manner using the `ad-hoc` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Joining and grouping collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the same way as we mimic the syntax of SQL for other queries, it's perfectly
    possible to use other advanced features of the SQL language, such as grouping
    and joining several collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first case (grouping), the syntax is fairly simple. We just have to
    indicate the grouping factor using the group / by / into clause in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use a nested loop to print the results (one for the groups of
    words and another for the words themselves). The previous code generates the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining and grouping collections](img/image00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the case of joining, we use the `join` clause together with the `equals`,
    `as`, and `is` operators to express conditions for the junction.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example could be the joining of two different sets of numbers in the
    search for common elements of any kind. Every set would express a unique condition
    and the join would establish the common factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, starting with our selected numbers (divisible by 3 and 7), let''s
    add another subset of those that start with 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two different subsets with different conditions. We can find out
    which among them fulfills both conditions, expressing the requirement by means
    of a join between both subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We find a total of five numbers that start with 7, both being multiples of
    3 and 7, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining and grouping collections](img/image00451.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Type projections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another option (and a very interesting one) is the capability of projecting
    the required output to an anonymous type (inexistent), which is the result of
    a selection or which includes the creation of another calculated field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We perform this action by creating the anonymous output type in the `select`
    declaration of the LINQ query, with the capability of naming the desired results
    the way we want (just like when we create another anonymous type). For instance,
    if we need another column indicating the even or odd character of the resulting
    numbers, we can add the following expression to the previous query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows the `select` clause is an anonymous type composed of two fields,
    `Num` and `DivBy2`, using a simple `?` operator expression, which checks the integer
    division by 2, the same way we did it earlier. The results look like what is shown
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type projections](img/image00452.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Besides auxiliary operations like these, the LINQ syntax is especially useful
    when dealing with databases. Just think of the source collections as return values
    obtained by querying a valid data origin, which—in all cases—will implement the
    `IEnumerable` and/or `IQueryable` interfaces, which is what happens when we access
    a real database engine using Entity framework, for example.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover database access in the upcoming chapters, so just keep in mind
    this methodology that will be applied when we query real data.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can extend existing classes' functionality. This means extending
    even the .NET Framework base types, such as `int` or `String`. This is a very
    useful feature, and it's performed in the way it is recommended by the documentation;
    no violation of basic principles of OOP occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure is fairly simple. We need to create a new public static top level
    (not nested) class containing a public static method with an initial argument
    declaration especially suited for the compiler to assume that the compiled code
    will be appended to the actual functionality of the type.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure can be used with any class, either belonging to the .NET framework
    or a customized user or class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the declaration, its usage is fairly simple, as shown in this
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the first argument, referred with the `this` keyword, references
    the string to be used; so, in this example, we will call the method without any
    extra arguments (although we can pass as many arguments as we need for other extensions).
    To put it to work, we just have to add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the extended output with the word enclosed in double brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extension methods](img/image00453.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some of the most relevant enhancements made to the C#
    language in versions 2 and 3.
  prefs: []
  type: TYPE_NORMAL
- en: We started by reviewing the main differences between C# and other languages
    and understanding the meaning of strongly typed, in this case, together with the
    concepts of static and dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explained some of the main reasons behind the creation of the concept
    of delegates—absolutely crucial in .NET—and whose origins were motivated by very
    serious and solid architectural reasons. We also revised .NET usage in several
    common programming scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We followed this up with an examination of the generics feature that appeared
    in version 2.0 of the framework and analyzed some samples to illustrate some typical
    use cases, including the creation of custom generic methods.
  prefs: []
  type: TYPE_NORMAL
- en: From generics, we moved on to Lambda expressions, which appeared in the version
    that follows, allowing us to simplify calls to generic methods by passing anonymous
    methods expressed in a very elegant syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered the LINQ syntax, which permits the implementation of complex
    queries to a collection in a way that strongly reminds you about the SQL syntax
    you surely know and use.
  prefs: []
  type: TYPE_NORMAL
- en: We ended with a simple extension method to check how we can use the existing
    functionality in order to extend its default methods in a way that suits our programming
    requirements without affecting the original definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at news and enhancements that appeared in the
    recent versions of the framework (4, 4.5, and 4.6), which include dynamic definitions,
    improved logical expressions, new operators, and so on.
  prefs: []
  type: TYPE_NORMAL
