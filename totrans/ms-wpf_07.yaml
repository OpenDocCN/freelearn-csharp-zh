- en: Mastering Practical Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握实用动画
- en: WPF offers a wide range of animation possibilities, from the simple to the really
    quite complex. In this chapter, we will thoroughly explore the WPF property animation
    system, yet focus primarily on those parts that can be suitably applied to real-world
    business applications. We'll investigate how to control running animations in
    real time and predominantly concentrate on XAML-based syntax. We'll then see how
    we can build animations right into our application framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WPF提供了从简单到非常复杂的广泛动画可能性。在本章中，我们将彻底探索WPF属性动画系统，但主要关注那些可以适用于现实世界商业应用的部分。我们将研究如何实时控制运行中的动画，并主要关注基于XAML的语法。然后我们将看到如何将动画直接构建到我们的应用程序框架中。
- en: 'In WPF, animations are created by repeatedly altering individual property values
    at regular intervals. Animations are comprised of a number of components: we need
    a timing system, an animation object that is responsible for updating the values
    of a particular type of object and a suitable property to animate.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中，动画是通过在固定间隔内重复更改单个属性值来创建的。动画由多个组件组成：我们需要一个时间系统、一个负责更新特定类型对象值的动画对象以及一个合适的属性来进行动画化。
- en: In order to be able to animate a property, it must be a Dependency Property
    of a `DependencyObject` and its type must implement the `IAnimatable` interface.
    As most UI controls extend the `DependencyObject` class, this enables us to animate
    the properties of most controls.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够动画化一个属性，它必须是`DependencyObject`的依赖属性，并且其类型必须实现`IAnimatable`接口。由于大多数UI控件扩展了`DependencyObject`类，这使得我们可以动画化大多数控件属性。
- en: Furthermore, an animation object for the relevant type of property must exist.
    In WPF, the animation objects also double up as the timing system, as they extend
    the `Timeline` class. Before investigating the various animation objects, let's
    first examine the timing system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还必须存在相关类型的动画对象。在WPF中，动画对象也充当时间系统，因为它们扩展了`Timeline`类。在研究各种动画对象之前，让我们首先检查时间系统。
- en: Investigating timelines
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究时间线
- en: Animations require some kind of timing mechanism that is responsible for updating
    the relevant property values at the right time. In WPF, this timing mechanism
    is catered for by the abstract `Timeline` class, which in short, represents a
    period of time. All of the available animation classes extend this class and add
    their own animation functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 动画需要某种时间机制，负责在正确的时间更新相关属性值。在WPF中，这种时间机制由抽象的`Timeline`类提供，简而言之，它代表一段时间。所有可用的动画类都扩展了这个类，并添加了自己的动画功能。
- en: When a `Timeline` class is used for animations, an internal copy is made and
    frozen, so that it is immutable. Additionally, a `Clock` object is created to
    preserve the runtime timing state of the `Timeline` object and is responsible
    for the actual timing of the animated property updates. The `Timeline` object
    itself does little other than define the relevant period of time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`Timeline`类进行动画时，会创建一个内部副本并冻结，使其不可变。此外，会创建一个`Clock`对象来保存`Timeline`对象的运行时时间状态，并负责实际的时间更新。`Timeline`对象本身除了定义相关的时间段外，几乎不做其他事情。
- en: The `Clock` object will be automatically created for us when we define a `Storyboard`
    object, or call one of the `Animatable.BeginAnimation` methods. Note that we do
    not typically need to concern ourselves with these `Clock` objects directly, but
    it can be helpful to know about them in order to understand the bigger picture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`Storyboard`对象或调用`Animatable.BeginAnimation`方法之一时，`Clock`对象将自动为我们创建。请注意，我们通常不需要直接关注这些`Clock`对象，但了解它们对于理解整体情况可能有所帮助。
- en: There are a number of different types of `Timeline` objects, from the `AnimationTimeline`
    class to the `TimelineGroup` and `ParallelTimeline` classes. However, for animation
    purposes, we predominantly utilize the `Storyboard` class, which extends the `ParallelTimeline`
    and the `TimelineGroup` classes and adds animation-targeting properties and methods
    for controlling the timeline. Let's first investigate the main properties of the
    base `Timeline` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种不同的`Timeline`对象类型，从`AnimationTimeline`类到`TimelineGroup`和`ParallelTimeline`类。然而，对于动画目的，我们主要使用`Storyboard`类，它扩展了`ParallelTimeline`和`TimelineGroup`类，并添加了动画目标属性和方法来控制时间线。让我们首先研究基类`Timeline`的主要属性。
- en: The `Duration` property specifies the time that is represented by the associated
    `Timeline` object. However, a timeline can have repetitions, so a more accurate
    description of the `Duration` property might be that it specifies the time of
    a single iteration of the associated `Timeline` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration` 属性指定由相关 `Timeline` 对象表示的时间。然而，时间线可以有重复，因此 `Duration` 属性的更准确描述可能是它指定了相关
    `Timeline` 对象的单次迭代的持续时间。'
- en: 'The duration property is of type `Duration`, which contains a `TimeSpan` property
    that contains the actual time that specifies the value of the duration. However,
    WPF includes a type converter that enables us to specify this `TimeSpan` value
    in XAML in the following formats, where the square brackets highlight optional
    segments:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration` 属性的类型是 `Duration`，它包含一个 `TimeSpan` 属性，该属性包含指定持续时间值的实际时间。然而，WPF 包含一个类型转换器，它使我们能够在以下格式中指定
    XAML 中的 `TimeSpan` 值，其中方括号突出显示可选部分：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the `Duration` structure also accepts other values in addition to the
    `TimeSpan` duration. There is a value of `Automatic`, which is the default value
    for component timelines that contain other timelines. In these cases, this value
    simply means that the parent timeline's duration will be as long as the longest
    duration of its children timelines. There is little purpose for us to explicitly
    use this value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Duration` 结构还接受除了 `TimeSpan` 持续时间之外的其他值。有一个 `Automatic` 值，这是包含其他时间线的组件时间线的默认值。在这些情况下，此值仅意味着父时间线的持续时间将与它的子时间线中最长持续时间相同。我们明确使用此值几乎没有意义。
- en: 'However, there is one further value that is very useful to us. The `Duration`
    structure also defines a `Forever` property that represents an infinite period
    of time. We can use this value to make an animation continue indefinitely, or
    more accurately, as long as its related View is being displayed:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个对我们非常有用的额外价值。`Duration` 结构还定义了一个表示无限时间段的 `Forever` 属性。我们可以使用这个值使动画无限期地继续，或者更准确地说，只要其相关的视图正在显示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A `Timeline` object will stop playing when it reaches the end of its duration.
    If it has any child timelines associated with it, then they will also stop playing
    at this point. However, the natural duration of a timeline can be extended or
    shortened using other properties, as we will see shortly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Timeline` 对象达到其持续时间结束时，它将停止播放。如果它与任何关联的子时间线相关联，那么它们也将在此点停止播放。然而，时间线的自然持续时间可以通过其他属性进行扩展或缩短，我们将在稍后看到。
- en: 'Some timelines, such as the `ParallelTimeline` and `Storyboard` classes, are
    able to contain other timelines and can affect their durations by setting their
    own values for the `Duration` property, which will override those set by the child
    timelines. Let''s alter an earlier animation example from [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job* to demonstrate this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些时间线，如 `ParallelTimeline` 和 `Storyboard` 类，能够包含其他时间线，并且可以通过设置自己的 `Duration`
    属性值来影响它们的持续时间，这将覆盖子时间线设置的值。让我们通过修改 [第 5 章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)
    的早期动画示例，*使用正确的控件完成任务* 来演示这一点：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this preceding example, we have a `Rectangle` object with its dimensions
    initially set to zero. The `Storyboard` object contains two separate animation
    objects that will animate its dimensions from zero to three hundred pixels. The
    animation object that will animate the rectangle's width has a duration of two
    and a half seconds, while the animation object that will animate the height has
    a duration of five seconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个先前的示例中，我们有一个初始尺寸设置为零的 `Rectangle` 对象。`Storyboard` 对象包含两个独立的动画对象，将动画其尺寸从零到三百像素。将动画矩形宽度的动画对象的持续时间设置为两秒半，而将动画高度的动画对象的持续时间设置为五秒。
- en: However, the containing `Storyboard` object has a duration of two and a half
    seconds and so this will stop the timelines of the two child animation objects
    after two and a half seconds, regardless of their declared durations. The result
    of this will be that after the animation is complete, our `Rectangle` object will
    appear as a rectangle, instead of a square with equal height and width values.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，包含的 `Storyboard` 对象的持续时间是两秒半，因此这将停止两个子动画对象的时间线在两秒半后，无论它们声明的持续时间如何。这将导致动画完成后，我们的
    `Rectangle` 对象将显示为一个矩形，而不是具有相等高度和宽度值的正方形。
- en: If we had changed the duration of the storyboard to match that of the longer
    child animation, or changed that animation duration to match that of the shorter
    child animation, then our animated shape would end as a square, rather than as
    a rectangle.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变了故事板的持续时间以匹配较长的子动画，或者改变了该动画持续时间以匹配较短的子动画，那么我们的动画形状将结束为一个正方形，而不是一个矩形。
- en: 'Another way to adjust the assigned duration of an animation element is to set
    its `AutoReverse` property. In effect, setting this property to `True` will usually
    double the length of time that is specified by the `Duration` property, as the
    timeline will play in reverse after it has completed its normal forwards iteration.
    Let''s alter the storyboard from the previous example to demonstrate this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 调整动画元素分配的持续时间的另一种方法是设置其 `AutoReverse` 属性。实际上，将此属性设置为 `True` 通常会将 `Duration`
    属性指定的长度加倍，因为时间线在完成正常的正向迭代后将以反向播放。让我们修改上一个示例中的故事板来演示这一点：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, both child timelines will have the same overall duration, as the first,
    previously shorter, timeline has effectively been doubled in length. However,
    this will result in the first timeline animating the width of the rectangle to
    three hundred pixels and then back to zero, so it will be invisible when the animations
    have completed. Also note that we had to set the parent storyboard duration to
    five seconds in order to see the difference in the child timelines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个子时间线将具有相同的时间线整体持续时间，因为第一个，之前较短的时间线实际上已经加倍了长度。然而，这将导致第一个时间线将矩形的宽度动画化到三百像素，然后回到零，因此在动画完成后将不可见。此外，请注意，我们必须将父故事板持续时间设置为五秒钟，才能看到子时间线中的差异。
- en: 'Note again that properties set on timelines that contain other timelines will
    affect the values of those properties on the child timelines. As such, setting
    the `AutoReverse` property to `True` on the parent timeline (the `Storyboard`
    object) will double the total length of time that the child animations will run
    for; in our case, using the following example, the rectangle will now be animated
    for ten seconds in total:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，设置在包含其他时间线的时间线上的属性将影响子时间线上这些属性的值。因此，在父时间线（`Storyboard` 对象）上设置 `AutoReverse`
    属性为 `True` 将使子动画的总运行时间加倍；在我们的例子中，使用以下示例，矩形现在将总共动画化十秒钟：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `RepeatBehavior` property is of type `RepeatBehavior` and can also affect
    the overall duration of a timeline. Unlike the `AutoReverse` property, it can
    also shorten the overall duration as well as lengthen it. Using the `RepeatBehavior`
    property, we can specify the value in a number of ways using different behaviors.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepeatBehavior` 属性的类型为 `RepeatBehavior`，并且也可以影响时间线的整体持续时间。与 `AutoReverse`
    属性不同，它既可以缩短整体持续时间，也可以延长它。通过使用 `RepeatBehavior` 属性，我们可以以多种方式指定值，使用不同的行为。'
- en: 'The most simple is to provide a count of how many times we would like to multiply
    the original duration of the timeline. A pre-existing XAML type converter enables
    us to set the repeat count in XAML by specifying an `x` after the count, as can
    be seen in the following example. Note that we can also specify numbers with decimal
    places here, including values less than one:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是提供一个乘数，表示我们希望将时间线的原始持续时间乘以多少次。一个现有的 XAML 类型转换器使我们能够在 XAML 中通过在计数后指定一个
    `x` 来设置重复计数，如下面的示例所示。请注意，我们还可以在此处指定带有小数点的数字，包括小于一的值：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the normal duration would be five seconds, but the `AutoReverse`
    property is set to `True` and so that duration is doubled. However, the `RepeatBehavior`
    property is set to `2x` and this will multiply the doubled ten seconds to twenty
    seconds. This multiplier value of two will be stored in the `Count` property of
    the `RepeatBehavior` structure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，正常持续时间应该是五秒钟，但 `AutoReverse` 属性被设置为 `True`，因此该持续时间被加倍。然而，`RepeatBehavior`
    属性被设置为 `2x`，这将把加倍后的十秒钟乘以二十秒钟。这个乘数值为二将被存储在 `RepeatBehavior` 结构的 `Count` 属性中。
- en: An alternative to using the count option is to simply set the duration that
    we would like the animation to last for. The same XAML syntax that is used to
    set the `Duration` property can also be used to set the `RepeatBehavior` property.
    Similarly, the `RepeatBehavior` structure also defines a `Forever` property that
    represents an infinite period of time and we can use this value to make an animation
    continue indefinitely.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计数选项的另一种选择是简单地设置我们希望动画持续的时间。用于设置`Duration`属性的相同XAML语法也可以用于设置`RepeatBehavior`属性。同样，`RepeatBehavior`结构还定义了一个`Forever`属性，表示无限的时间段，我们可以使用这个值使动画无限期地继续。
- en: 'One further property that can affect the duration of an animation is the `SpeedRatio`
    property. This value is multiplied by the other related duration properties and
    so can both speed up and slow down the associated timeline. Let''s update our
    example again to help to explain this property now:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以影响动画持续时间的额外属性是`SpeedRatio`属性。这个值会乘以其他相关的持续时间属性，因此可以加快或减慢相关的时间线。让我们再次更新我们的示例，以帮助解释这个属性：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, the normal duration here would be five seconds and the `AutoReverse`
    property is set to `True`, so the duration is doubled. However, the `SpeedRatio`
    property is set to `0.5` and so the doubled duration is again doubled to twenty
    seconds. Note that a `SpeedRatio` value of `0.5` represents half the normal speed
    and therefore twice the normal duration.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里的正常持续时间应该是五秒，`AutoReverse`属性设置为`True`，因此持续时间加倍。然而，`SpeedRatio`属性设置为`0.5`，因此加倍后的持续时间再次加倍，达到二十秒。请注意，`SpeedRatio`值为`0.5`表示正常速度的一半，因此是正常持续时间的两倍。
- en: The second child timeline also sets the `SpeedRatio` property, but it is set
    to `2` and so its speed is doubled and its duration halved. As its specified duration
    is twice that of its sibling timeline and its speed is now twice as fast, this
    has the effect of re-synchronizing the two child animations, so that the two dimensions
    now grow together, as a square, rather than as a rectangle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子时间线也设置了`SpeedRatio`属性，但设置为`2`，因此其速度加倍，持续时间减半。由于其指定的时间是其兄弟时间线时间的一半，且其速度现在是正常速度的两倍，这起到了重新同步两个子动画的效果，因此两个维度现在作为一个正方形而不是矩形一起增长。
- en: 'There are two more speed-related properties that we can use to fine-tune our
    animations: the `AccelerationRatio` and `DecelerationRatio` properties. These
    properties adjust the proportion of time that the related animation takes to speed
    up and slow down respectively. While this effect can be subtle at times, it can
    also give our animations that professional touch when used correctly.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用两个与速度相关的属性来微调我们的动画：`AccelerationRatio`和`DecelerationRatio`属性。这些属性调整相关动画加速和减速所需的时间比例。虽然这种效果有时可能很微妙，但正确使用时也可以给我们的动画带来专业的触感。
- en: 'Acceptable values for both of these properties exist between zero and one.
    If both properties are used together, then the total sum of their values must
    still remain between zero and one. Failure to adhere to this rule will result
    in the following exception being thrown at runtime:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性的可接受值介于零和一之间。如果同时使用这两个属性，则它们值的总和必须仍然介于零和一之间。如果违反此规则，则在运行时将抛出以下异常：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Entering values outside the acceptable range on either of these properties
    individually will also result in an error, although doing this will cause a compilation
    error instead:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个属性中的任何一个上输入超出可接受范围的值也会导致错误，尽管这样做将导致编译错误：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s look at an example that highlights the difference between the different
    values of these two properties:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，突出这两个属性不同值之间的差异：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code defines a number of `Rectangle` objects in a `StackPanel` control,
    each with its own associated `DoubleAnimation` element, that increases its width
    from zero to three hundred pixels over one and a half seconds.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在`StackPanel`控件中定义了多个`Rectangle`对象，每个对象都与其自己的`DoubleAnimation`元素相关联，该元素在1.5秒内将宽度从零增加到三百像素。
- en: Here, we've used the `Storyboard.TargetName` and `Storyboard.TargetProperty`
    properties to target the rectangles from a single `EventTrigger` to reduce the
    amount of code in the preceding example. We'll cover these Attached Properties
    in detail shortly, but for now, we'll just say that they are used to specify the
    target element and property to animate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`Storyboard.TargetName`和`Storyboard.TargetProperty`属性从单个`EventTrigger`中定位矩形，以减少前面示例中的代码量。我们将在稍后详细介绍这些附加属性，但现在，我们只需说它们用于指定要动画化的目标元素和属性。
- en: Each animation targets a different rectangle and has different values set for
    the `AccelerationRatio` and `DecelerationRatio` properties. The top rectangle's
    animation has its `AccelerationRatio` property set to `1.0` and the animation
    for the bottom rectangle has its `DecelerationRatio` property set to `1.0`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动画都针对不同的矩形，并为`AccelerationRatio`和`DecelerationRatio`属性设置了不同的值。顶部矩形的动画将`AccelerationRatio`属性设置为`1.0`，而底部矩形的动画将`DecelerationRatio`属性设置为`1.0`。
- en: The animations for the rectangles in between have varying values. The higher
    the rectangle, the higher the values for the `AccelerationRatio` property and
    the lower the values for the `DecelerationRatio` property and the lower the rectangle,
    the lower the values of the `AccelerationRatio` property and the higher the values
    for the `DecelerationRatio` property.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 介于这些矩形之间的动画具有不同的值。矩形越高，`AccelerationRatio`属性的值就越高，`DecelerationRatio`属性的值就越低；而矩形越低，`AccelerationRatio`属性的值就越低，`DecelerationRatio`属性的值就越高。
- en: 'When this example is run, we can clearly see the differences between the various
    ratio values. At one point near the start of each iteration, we can see that the
    top rectangles that are animated with higher `AccelerationRatio` values have not
    grown in size as much as the lower rectangles that are animated with higher `DecelerationRatio`
    values; however, all rectangles reach 300 pixels at approximately the same time:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个示例运行时，我们可以清楚地看到各种比率值之间的差异。在每个迭代的开始附近，我们可以看到使用较高`AccelerationRatio`值的顶部矩形增长的大小不如使用较高`DecelerationRatio`值的底部矩形；然而，所有矩形在大约相同的时间内达到300像素：
- en: '![](img/f33a30c5-755c-4809-bba8-e632617ebdf1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f33a30c5-755c-4809-bba8-e632617ebdf1.png)'
- en: Another useful property in the `Timeline` class is the `BeginTime` property.
    As the name suggests, it sets the time to begin the animation; it can be thought
    of as a delay time that delays the start of its animation with relation to parent
    and sibling timelines.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Timeline`类中，另一个有用的属性是`BeginTime`属性。正如其名所示，它设置动画开始的时间；它可以被视为一个延迟时间，它相对于父级和兄弟时间轴延迟其动画的开始。
- en: 'The default value of this property is zero seconds and when it is set with
    a positive value, the delay occurs just once at the start of the timeline and
    is not affected by other properties that may be set on it. It is often used to
    delay the start of one or more animations until another animation has completed.
    Let''s adjust our earlier example again to demonstrate this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性的默认值是零秒，当它被设置为正值时，延迟只在时间轴的开始处发生一次，并且不受可能设置在其上的其他属性的影响。它通常用于延迟一个或多个动画的启动，直到另一个动画完成。让我们再次调整之前的示例来演示这一点：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we have a single pixel high rectangle with a width that grows
    outward until it is three hundred pixels wide and then grows vertically until
    it is three hundred pixels high. At that point, its dimensions equally reduce
    in size until the shape shrinks to nothing.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个单像素高的矩形，其宽度向外扩展直到达到三百像素宽，然后垂直扩展直到达到三百像素高。在这一点上，其尺寸均匀减小，直到形状缩小到无。
- en: This is achieved by delaying the last three animations while the width-increasing
    animation runs and then delaying the last two animations while the height-increasing
    animation runs. The `BeginTime` properties of the last two animations are set
    to the same value, so that they both start and run in synchronization with each
    other.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在宽度增加动画运行时延迟最后三个动画，然后在高度增加动画运行时延迟最后两个动画来实现的。最后两个动画的`BeginTime`属性被设置为相同的值，这样它们就可以相互同步开始和运行。
- en: The last really useful timeline property is the `FillBehavior` property, which
    specifies what should happen to the data bound property value when the timeline
    reaches the end of its total duration, or its fill period. This property is of
    type `FillBehavior` and has just two values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个非常有用的时间线属性是`FillBehavior`属性，它指定当时间线达到其总持续时间或填充周期结束时，数据绑定属性值应该发生什么。此属性的类型为`FillBehavior`，并且只有两个值。
- en: 'If we set this property to a value of `HoldEnd`, the data bound property value
    will remain at the final value that was reached just before the animation ended.
    Conversely, if we set this property to a value of `Stop`, which is the default
    value, the data bound property value will revert to the value that the property
    originally had before the animation started. Let''s illustrate this with a simple
    example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此属性设置为`HoldEnd`值，数据绑定属性值将保持在动画结束前刚刚达到的最终值。相反，如果我们将此属性设置为默认值`Stop`，数据绑定属性值将恢复到动画开始之前属性原有的值。让我们用一个简单的例子来说明这一点：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the difference between the two `FillBehavior` enumeration instances
    is clearly demonstrated. We have two rectangles of identical size that have identical
    timelines set up to animate their `Opacity` property values, with the exception
    of their `FillBehavior` property values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，两个`FillBehavior`枚举实例之间的差异得到了清晰的展示。我们有两个大小相同的矩形，它们设置了相同的时间线来动画化它们的`Opacity`属性值，除了它们的`FillBehavior`属性值不同。
- en: Both rectangles fade from being opaque to being invisible in the same amount
    of time, but once the two timelines are complete, the rectangle with the `FillBehavior`
    property set to `Stop` immediately becomes visible again, as it was prior to the
    start of the animation, while the other with the `FillBehavior` property set to
    `HoldEnd` remains invisible, as it was at the end of the animation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 两个矩形以相同的时间从不透明淡出到不可见，但一旦两个时间线完成，将`FillBehavior`属性设置为`Stop`的矩形会立即再次变得可见，就像动画开始之前一样，而将`FillBehavior`属性设置为`HoldEnd`的另一个矩形则保持不可见，就像动画结束时一样。
- en: While this covers the main properties that are exposed by the `Timeline` class
    directly, there are a few more properties that are declared by many of the animation
    classes that extend the `Timeline` class and are essential to fully understand.
    They are the `From`, `By` and `To` properties, which specify the start and end
    points of the animations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这涵盖了`Timeline`类直接暴露的主要属性，但还有一些属性是由扩展`Timeline`类的许多动画类声明的，这些属性对于完全理解是必不可少的。它们是`From`、`By`和`To`属性，这些属性指定了动画的起始点和结束点。
- en: Because the animation classes generate property values, there are different
    types of animation classes for different property types. For example, the animation
    class that generates `Point` values is called the `PointAnimation` class and all
    of the normal animation classes follow the same naming pattern, using the name
    of the related type in the form of `<TypeName>Animation`, for example `ColorAnimation`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动画类生成属性值，因此针对不同的属性类型有不同的动画类。例如，生成`Point`值的动画类称为`PointAnimation`类，所有正常的动画类都遵循相同的命名模式，即使用相关类型的名称，形式为`<TypeName>Animation`，例如`ColorAnimation`。
- en: The normal animation classes, often referred to as the `From`, `By` and `To`
    animations, usually require two values to be specified, although one of these
    can sometimes be implicitly provided. The relevant property will then be animated
    along a path of automatically interpolated values between the two specified values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正常的动画类，通常被称为`From`、`By`和`To`动画，通常需要指定两个值，尽管其中之一有时可以隐式提供。然后，相关的属性将沿着两个指定值之间的自动插值值路径进行动画化。
- en: It is most common to provide a starting value using the `From` property and
    an ending value using the `To` property. However, we can also specify a single
    starting, ending, or offset value and the second value will be taken from the
    current value of the animated property. We can set the offset value using the
    `By` property and this represents the exact amount the property value will change
    over the duration.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是使用`From`属性提供起始值，使用`To`属性提供结束值。然而，我们也可以指定一个单一的起始值、结束值或偏移值，第二个值将取自动画属性的当前值。我们可以使用`By`属性设置偏移值，这表示属性值将在整个持续时间内的确切变化量。
- en: Specifying values for these different properties can have dramatically different
    effects on the resulting animations. Using the `From` property alone will start
    the animation at the desired value and will animate the property until it reaches
    the property's base value.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些不同的属性指定值可以对最终动画产生截然不同的效果。仅使用`From`属性将使动画从所需值开始，并动画化该属性，直到它达到属性的基本值。
- en: Using the `To` property alone will start animating the property from its current
    value and end at the specified value. Using only the `By` property will animate
    the property from its current value until the sum of that value with the specified
    offset amount has been reached.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`To`属性将使属性从其当前值开始动画化，并结束在指定的值。仅使用`By`属性将使属性从其当前值动画化，直到该值与指定的偏移量之和达到。
- en: Combinations of the three properties can be used to target just the right range
    of property values. Setting the `From` and `By` properties will start the animations
    from the value specified by the `From` property and animate the property until
    the offset specified by the `By` property has been reached.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性的组合可以用来针对正确的属性值范围。设置`From`和`By`属性将使动画从`From`属性指定的值开始，并动画化该属性，直到达到`By`属性指定的偏移量。
- en: Setting the `From` and `To` properties together will start the animations from
    the value specified by the `From` property and animate the property until the
    value specified by the `To` property. As the `By` and `To` properties both specify
    the ending value of the animation, the value specified by the `By` property will
    be ignored if they are both set on an animation element.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同时设置`From`和`To`属性将使动画从`From`属性指定的值开始，并动画化该属性，直到达到`To`属性指定的值。由于`By`和`To`属性都指定了动画的结束值，如果它们都设置在动画元素上，则`By`属性指定的值将被忽略。
- en: While these more common animations use one or two of the `From`, `By`, and `To`
    properties together to specify the range of values of the related property to
    be animated, there is another way to specify the target values. Let's now take
    a look at key-frame animations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些更常见的动画使用一个或两个`From`、`By`和`To`属性组合来指定要动画化的相关属性的值范围时，还有另一种指定目标值的方法。现在让我们来看看关键帧动画。
- en: Introducing key-frames
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入关键帧
- en: Key-frame animations enable us to do a number of things that we cannot do with
    the `From`, `By`, and `To` animations. Unlike those animations, with key-frame
    animations, we are able to specify more than two target values and animate objects
    in discrete steps that cannot normally be animated. As such, there are more `<TypeName>AnimationUsingKeyFrames`
    classes than `<TypeName>Animation` classes, for example: `RectAnimationUsingKeyFrames`, `SizeAnimationUsingKeyFrames`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关键帧动画使我们能够执行一些使用`From`、`By`和`To`动画无法做到的事情。与那些动画不同，使用关键帧动画，我们能够指定超过两个目标值，并以离散的步骤动画化通常无法动画化的对象。因此，`<TypeName>AnimationUsingKeyFrames`类的数量比`<TypeName>Animation`类多，例如：`RectAnimationUsingKeyFrames`、`SizeAnimationUsingKeyFrames`。
- en: Each `<TypeName>AnimationUsingKeyFrames` class has a `KeyFrames` property that
    we populate with key-frames to specify various values that must be passed during
    the animation. Each key-frame has a `KeyTime` and a `Value` property to specify
    the value and the relative time that it should be reached.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`<TypeName>AnimationUsingKeyFrames`类都有一个`KeyFrames`属性，我们通过填充关键帧来指定动画过程中必须传递的各种值。每个关键帧都有一个`KeyTime`和`Value`属性，用于指定值和应达到的相对时间。
- en: If no key-frame is declared with a key time of zero seconds, the animation will
    start from the relevant property's current value. The animation will order the
    key-frames by the values of their `KeyTime` property, rather than the order that
    they were declared in, and will create transitions between the various values
    according to their interpolation methods, which we'll find out about momentarily.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有声明带有零秒关键时间的键帧，动画将从相关属性的当前值开始。动画将根据其`KeyTime`属性的值对关键帧进行排序，而不是它们声明的顺序，并根据它们的插值方法在各个值之间创建过渡，我们稍后会了解到这一点。
- en: Note that the `KeyTime` property is of type `KeyTime` and this enables us to
    set it using types of values, other than `TimeSpan` values. We are also able to
    specify percentage values, which determine the percentage of the specified animation
    duration that each key-frame will be allotted. Note that we need to use cumulative
    values, so that the final key-frame key time value will always be `100%`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`KeyTime`属性是`KeyTime`类型，这使我们能够使用除`TimeSpan`值以外的类型设置它。我们还可以指定百分比值，这些值确定每个关键帧将分配的指定动画持续时间的百分比。请注意，我们需要使用累积值，以确保最终的关键帧关键时间值始终为`100%`。
- en: Alternatively, there are a number of special values that we can use. When we
    want an animation with a constant velocity, regardless of the specified values,
    we can specify the `Paced` value for each of the key-frames. This takes the change
    between each key-frame's value into consideration before spacing them across the
    duration of the parent timeline and creating a smooth, even transition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一些特殊的值。当我们想要一个具有恒定速度的动画，无论指定的值如何，我们都可以为每个关键帧指定`Paced`值。这会在将它们分配到父时间线的持续时间之前，考虑每个关键帧值之间的变化，从而创建一个平滑、均匀的过渡。
- en: In contrast to this method, we can also specify the `Uniform` value for each
    key-frame, which basically spaces the key-frames out evenly across the duration
    of the parent animation. To do this, it simply counts the number of key-frames
    and divides that number by the total duration length, so that each key-frame will
    last for the same amount of time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与此方法相反，我们还可以为每个关键帧指定`Uniform`值，这基本上会在父动画的持续时间内在关键帧之间均匀分配。为此，它只需计算关键帧的数量，并将该数量除以总持续时间长度，这样每个关键帧将持续相同的时间。
- en: There are different kinds of key-frames for different `<TypeName>AnimationUsingKeyFrames`
    classes and there are also different kinds of interpolation methods used. The
    naming convention of these key-frames follows the format, `<InterpolationMethod><TypeName>KeyFrame`,
    for example: `LinearDoubleKeyFrame`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的`<TypeName>AnimationUsingKeyFrames`类，存在不同种类的关键帧，也使用了不同的插值方法。这些关键帧的命名约定遵循格式`<插值方法><TypeName>KeyFrame`，例如：`LinearDoubleKeyFrame`。
- en: There are three kinds of interpolation methods. The first is `Discrete`, which
    performs no interpolation and simply jumps from one value to another. This method
    is useful for setting `bool` or `object` values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种插值方法。第一种是`Discrete`，它不执行插值，只是从一个值跳到另一个值。这种方法对于设置`bool`或`object`值很有用。
- en: The next method is `Linear`, which performs a linear interpolation between the
    key-frame's value and the previous key-frame's value. This means that the animation
    will appear smooth, but speed up and slow down if your key-frame times are not
    evenly spaced out.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种方法是`Linear`，它在关键帧的值和前一个关键帧的值之间执行线性插值。这意味着动画看起来将是平滑的，但如果你的关键帧时间不均匀分布，动画速度会加快和减慢。
- en: The last and most complicated interpolation method is `Spline`, but it also
    provides the user with the most control over the animation timing. It adds a further
    property named `KeySpline`, which enables us to specify two control points on
    a Bezier curve that extends from `0.0,0.0` to `1.0,1.0`. The first control point
    affects the first half of the curve, while the second point affects the second
    half.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后也是最复杂的一种插值方法是`Spline`，但它也提供了对动画时间控制的最大灵活性。它添加了一个名为`KeySpline`的额外属性，使我们能够指定一个从`0.0,0.0`延伸到`1.0,1.0`的贝塞尔曲线上的两个控制点。第一个控制点影响曲线的前半部分，而第二个点影响后半部分。
- en: Using these two control points, we can adjust the speed of the animation over
    its duration. As an example, using the first control point set to `0.0,1.0` and
    the second set to `1.0,0.0` will cause maximum distortion to the original linear
    curve and result in an animation that will quickly accelerate, before slowing
    almost to a stop in the middle and then dramatically speeding up again at the
    end.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个控制点，我们可以调整动画在其持续时间内的速度。例如，将第一个控制点设置为`0.0,1.0`并将第二个设置为`1.0,0.0`将导致原始线性曲线的最大扭曲，并导致动画迅速加速，然后在中间几乎停止，然后在结束时再次急剧加速。
- en: With these two points, we can have full control over the speed of value change
    between each pair of key-frame values. This type of interpolation is most useful
    when attempting to create animations that are more realistic looking. Note that
    we are free to mix and match key-frames with different interpolation methods within
    each key-frame animation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个点，我们可以完全控制每对关键帧值之间值变化的速率。这种插值类型在尝试创建更逼真的动画时非常有用。请注意，我们可以在每个关键帧动画内部自由混合和匹配不同的插值方法的关键帧。
- en: As an example, let's say that we wanted to animate a `Point` element. In this
    case we'd need to use the `PointAnimationUsingKeyFrames` class and would then
    have a choice of key-frame classes that represent the different interpolation
    methods. With this example, we could use any combination of the `DiscretePointKeyFrame`,
    `LinearPointKeyFrame`, and `SplinePointKeyFrame` classes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想动画化一个`Point`元素，在这种情况下我们需要使用`PointAnimationUsingKeyFrames`类，然后我们可以选择代表不同插值方法的关键帧类。在这个例子中，我们可以使用`DiscretePointKeyFrame`、`LinearPointKeyFrame`和`SplinePointKeyFrame`类的任何组合。
- en: 'Note that, as the `KeyFrames` property is set as the `name` input parameter
    in the `ContentPropertyAttribute` attribute that forms part of the declared class
    signature in each of the `<TypeName>AnimationUsingKeyFrames` classes, we do not
    need to explicitly declare this property in XAML and can declare the various key-frames
    directly inside these elements as shown in the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`KeyFrames`属性被设置为`ContentPropertyAttribute`属性中的`name`输入参数，该属性是每个`<TypeName>AnimationUsingKeyFrames`类中声明的类签名的一部分，因此我们不需要在XAML中显式声明这个属性，可以直接在这些元素内部声明各种关键帧，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we declare an `Ellipse` shape with its `Fill` property set
    to an instance of the `RadialGradientBrush` class. The brush has a yellow center
    and is orange around the edges. Note that these brushes have a property named
    `GradientOrigin` that specifies the center point of the gradient and defaults
    to the point `0.5,0.5`. In this example, we animate this property, which has a
    similar effect to moving a light source around a 3D ball:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们声明了一个`Ellipse`形状，其`Fill`属性设置为`RadialGradientBrush`类的实例。这个画刷中心是黄色，边缘是橙色。请注意，这些画刷有一个名为`GradientOrigin`的属性，它指定了渐变的中心点，默认值为点`0.5,0.5`。在这个例子中，我们动画化了这个属性，这相当于在3D球体周围移动光源的效果：
- en: '![](img/f8f14b19-6725-462a-83a9-1c62ec016528.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f14b19-6725-462a-83a9-1c62ec016528.png)'
- en: We use an `EventTrigger` with the `Loaded` event to start our animation and
    set the `RepeatBehavior` property to `Forever` on the associated storyboard. As
    mentioned, we set the `TargetProperty` property to the `GradientOrigin` property
    of the brush that is set as the `Fill` property.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个带有`Loaded`事件的`EventTrigger`来启动我们的动画，并将关联的故事板的`RepeatBehavior`属性设置为`Forever`。正如之前提到的，我们将`TargetProperty`属性设置为画刷的`GradientOrigin`属性，该画刷被设置为`Fill`属性。
- en: Inside the storyboard, we declare a `PointAnimationUsingKeyFrames` element and
    directly inside it, we declare a number of various `<InterpolationMethod><Type>KeyFrame`
    objects. As mentioned, we do not need to explicitly declare the `KeyFrames` property
    in order to declare these key-frame elements within it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在故事板内部，我们声明了一个`PointAnimationUsingKeyFrames`元素，并且直接在其内部，我们声明了多个不同类型的`<InterpolationMethod><Type>KeyFrame`对象。正如之前提到的，我们不需要显式声明`KeyFrames`属性，就可以在它内部声明这些关键帧元素。
- en: Note that the `DiscretePointKeyFrame` element that is used here is entirely
    optional and would not change anything if removed. This is because the point `0.5,0.5` is
    both the starting value of the animation and default value of the gradient brush
    and also the ending value of the animation. Furthermore, if we omit a zero time
    key-frame, one will be implicitly added for us with this value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里使用的`DiscretePointKeyFrame`元素完全是可选的，如果移除它，也不会有任何变化。这是因为点`0.5,0.5`既是动画的起始值也是渐变画刷的默认值，同时也是动画的结束值。此外，如果我们省略一个零时间的关键帧，系统会隐式地为我们添加一个具有该值的关键帧。
- en: Next, we declare a `LinearPointKeyFrame` element, that will animate the gradient
    origin from the point `0.5,0.5` to the point `1.0,1.0` in a linear, even fashion.
    Following that, we have a `SplinePointKeyFrame` element that will animate the
    gradient origin from the previous point to the point `1.0,0.0`. Note the `KeySpline`
    property that adjusts the speed of the animation as it progresses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个`LinearPointKeyFrame`元素，它将以线性、均匀的方式将渐变中心从点`0.5,0.5`动画化到点`1.0,1.0`。随后，我们有一个`SplinePointKeyFrame`元素，它将渐变中心从上一个点动画化到点`1.0,0.0`。注意`KeySpline`属性，它调整动画过程中的速度。
- en: From there, we use another `LinearPointKeyFrame` element to smoothly and evenly
    transition to the point `0.0,0.0` over one second. Finally, we use a second `SplinePointKeyFrame`
    element to animate the gradient origin back to the center of the circle and its
    starting position, taking the last three seconds of the total duration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们使用另一个`LinearPointKeyFrame`元素，在一秒钟内平滑且均匀地过渡到点`0.0,0.0`。最后，我们使用第二个`SplinePointKeyFrame`元素来将渐变起点动画化回圆的中心及其起始位置，占用总持续时间的最后三秒。
- en: When this example is run, we can clearly see it animating the gradient origin
    point evenly during the periods of the two `LinearPointKeyFrame` elements and
    changing the speed during the periods of the two `SplinePointKeyFrame` elements.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个示例运行时，我们可以清楚地看到它在这两个`LinearPointKeyFrame`元素期间均匀地动画化渐变起点，并在两个`SplinePointKeyFrame`元素期间改变速度。
- en: Telling stories
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讲述故事
- en: While the various animation classes that extend the `Timeline` class can be
    used to animate control properties directly in code, in order to declare and trigger
    animations using XAML alone, we need to use the `Storyboard` class. This is what
    is known as a container timeline, as it extends the abstract `TimelineGroup` class
    that enables it to contain child timelines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然扩展`Timeline`类的各种动画类可以直接在代码中动画化控件属性，但为了仅使用XAML声明和触发动画，我们需要使用`Storyboard`类。这被称为容器时间线，因为它扩展了抽象的`TimelineGroup`类，这使得它能够包含子时间线。
- en: Another container timeline class that the `Storyboard` class extends is the
    `ParallelTimeline` class and these classes enable us to group child timelines
    and to set properties on them as a group. When creating more complex animations,
    if all we need to do is to delay the start of a group of child timelines, we should
    use the `ParallelTimeline` class rather than the `Storyboard` class, as it is
    more efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Storyboard`类扩展的另一个容器时间线类是`ParallelTimeline`类，这些类使我们能够对子时间线进行分组，并作为一组设置它们的属性。当创建更复杂的动画时，如果我们只需要延迟一组子时间线的开始，我们应该使用`ParallelTimeline`类而不是`Storyboard`类，因为它更高效。'
- en: 'We could rewrite our earlier `BeginTime` example to use a `ParallelTimeline`
    element to delay the start of our last two timelines. Let''s see what that might
    look like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将之前的`BeginTime`示例重写为使用`ParallelTimeline`元素来延迟最后两个时间线的开始。让我们看看它可能是什么样子：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As the `Storyboard` class is a `Timeline` object, it also has the same properties
    as the various animation objects. One additional property that it inherits from
    the `ParallelTimeline` class is the `SlipBehavior` property. This property is
    only really useful when we want to synchronize an animation timeline with the
    playback of a `MediaTimeline` element, but it's worth knowing about.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Storyboard`类是一个`Timeline`对象，它也具有各种动画对象相同的属性。它从`ParallelTimeline`类继承的一个额外属性是`SlipBehavior`属性。这个属性只有在我们要将动画时间线与`MediaTimeline`元素的播放同步时才真正有用，但了解这一点是值得的。
- en: This property is of the enumeration type `SlipBehavior` and it only has two
    members. A value of `Grow` specifies that we do not need our animation timelines
    to be synchronized with our media timeline(s) and is the default value of this
    property.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是枚举类型`SlipBehavior`，它只有两个成员。`Grow`的值表示我们不需要我们的动画时间线与我们的媒体时间线同步，并且是这个属性的默认值。
- en: Conversely, a value of `Slip` indicates that we want our animation timelines
    to slip, either forwards or backwards, whenever necessary in order to keep them
    in sync with the playing media. If the media takes time to load when using this
    setting, then the animation timelines within the storyboard will wait until the
    media is ready and continue at that point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Slip`的值表示我们希望在必要时使我们的动画时间线向前或向后滑动，以保持它们与播放的媒体同步。如果使用此设置时媒体需要时间来加载，那么故事板中的动画时间线将等待媒体准备好，并在该点继续。
- en: In addition to the properties that have been inherited from the various base
    classes, the `Storyboard` class also declares three important Attached Properties
    that are essential for targeting animations to individual UI elements and/or their
    properties.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从各种基类继承的属性外，`Storyboard`类还声明了三个重要的附加属性，这些属性对于将动画定位到单个UI元素及其属性至关重要。
- en: The `Storyboard.Target` Attached Property specifies the UI control that should
    be animated, although setting this property alone is not enough, as it does not
    specify the target property. This property is of type `object`, although it can
    only be used with objects of type `DependencyObject`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Storyboard.Target`附加属性指定了应该被动画化的UI控件，尽管仅设置此属性是不够的，因为它没有指定目标属性。此属性的类型为`object`，尽管它只能与类型为`DependencyObject`的对象一起使用。'
- en: 'In order to use this property, we need to specify a binding path that references
    the target UI control. If the target element extends the `FrameworkElement` or
    `FrameworkContentElement` classes, then one way would be to name the target element
    and to use an `ElementName` binding to reference it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个属性，我们需要指定一个绑定路径，该路径引用目标UI控件。如果目标元素扩展了`FrameworkElement`或`FrameworkContentElement`类，那么一种方法是为目标元素命名，并使用`ElementName`绑定来引用它：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Most UI elements extend one of these two classes that declare the `Name` property.
    However, if we provide a name for the target control, then there is a simpler
    way to target it. Instead of using the `Storyboard.Target` property, we could
    use the `Storyboard.TargetName` Attached Property to specify the target element
    using just their declared name, without any binding:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数UI元素扩展了声明了`Name`属性的这两个类之一。然而，如果我们为目标控件提供了一个名称，那么有一个更简单的方式来针对它。我们不需要使用`Storyboard.Target`属性，而是可以使用`Storyboard.TargetName`附加属性，仅通过它们声明的名称来指定目标元素，而不需要任何绑定：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We do not always need to specify this property value, as on occasion, the target
    element can be worked out implicitly. If the relevant storyboard was started with
    a `BeginStoryboard` element, the UI element that declared it will be targeted.
    Additionally, if the relevant storyboard is a child of another timeline, then
    the target of the parent timeline will be inherited.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是需要指定这个属性值，因为有时目标元素可以隐式地确定。如果相关的故事板是通过`BeginStoryboard`元素启动的，那么声明它的UI元素将被针对。另外，如果相关的故事板是另一个时间线的子项，那么父时间线的目标将被继承。
- en: The most important property that the `Storyboard` class declares is the `TargetProperty`
    Attached Property. We use this property to specify which property we want to animate
    on the target element. Note that in order for this to work, the target property
    must be a Dependency Property.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Storyboard`类声明的最重要的属性是`TargetProperty`附加属性。我们使用这个属性来指定我们想在目标元素上动画化的属性。请注意，为了使这生效，目标属性必须是一个依赖属性。'
- en: Occasionally, we may want to target objects that do not extend either of the
    framework classes mentioned earlier; in WPF, we are also able to target freezable
    classes that extend the `Freezable` class. In order to target one of these classes
    in XAML, we need to specify the name of the object using the `x:Name` directive
    instead, as they have no `Name` property.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要针对之前提到的框架类中任何一个都没有扩展的对象；在WPF中，我们同样能够针对扩展了`Freezable`类的可冻结类。为了在XAML中针对这些类之一，我们需要使用`x:Name`指令来指定对象名称，因为它们没有`Name`属性。
- en: As a side note, WPF classes that declare their own `Name` property actually
    map the name value through to the `x:Name` directive, which is part of the XAML
    specification. In these cases, we are free to use either of these to register
    a name for an element, but we must not set both.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，WPF类如果声明了自己的`Name`属性，实际上会通过`x:Name`指令映射名称值，这是XAML规范的一部分。在这些情况下，我们可以自由使用这两个中的任何一个来为元素注册名称，但我们不能同时设置两个。
- en: 'Note that unnamed elements can still be referenced by our animations, although
    they need to be indirectly referenced. Instead of referencing them directly, we
    need to specify the name of the parent property or freezable object and then chain
    properties in the `TargetProperty` Attached Property until we reach the desired
    element. We used this method in the last example of the previous section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无名称的元素仍然可以被我们的动画引用，尽管它们需要间接引用。我们不是直接引用它们，而是需要指定父属性或可冻结对象的名称，然后在`TargetProperty`附加属性中链式调用属性，直到达到所需的元素。我们在上一节的最后一个示例中使用了这种方法：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we reference the `Fill` property, which is of type `RadialGradientBrush`,
    and then we chain to the `GradientOrigin` property of the brush from there. Note
    that if we had used an instance of the `SolidColorBrush` class here instead, this
    reference would fail, because there is no `GradientOrigin` property in that brush.
    However, while the animation would fail to work, this would not cause any errors
    to be raised.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们引用了 `Fill` 属性，它属于 `RadialGradientBrush` 类型，然后从那里链接到画刷的 `GradientOrigin`
    属性。请注意，如果我们在这里使用 `SolidColorBrush` 类的实例而不是这个，这个引用将会失败，因为那个画刷中没有 `GradientOrigin`
    属性。然而，尽管动画无法工作，这不会引发任何错误。
- en: Controlling storyboards
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制故事板
- en: In order to start a storyboard in XAML, we need to use a `BeginStoryboard` element.
    This class extends the `TriggerAction` class and if you remember, that is the
    type that we need to use in the `TriggerActionCollection` of the `EventTrigger`
    class and the `TriggerBase.EnterActions` and `TriggerBase.ExitActions` properties.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 XAML 中开始一个故事板，我们需要使用一个 `BeginStoryboard` 元素。这个类扩展了 `TriggerAction` 类，如果你还记得，那就是我们在
    `EventTrigger` 类的 `TriggerActionCollection` 以及 `TriggerBase.EnterActions` 和 `TriggerBase.ExitActions`
    属性中需要使用的类型。
- en: We specify the storyboard to use with the `BeginStoryboard` element by setting
    it to the `Storyboard` property in code. When using XAML, the `Storyboard` property
    is implicitly set to the storyboard that is declared within the `BeginStoryboard`
    element.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将 `Storyboard` 属性设置为代码中的 `Storyboard` 属性来指定要使用的 storyboard。当使用 XAML 时，`Storyboard`
    属性隐式设置为在 `BeginStoryboard` 元素内声明的 storyboard。
- en: The `BeginStoryboard` action is responsible for connecting the animation timelines
    with the animation targets and their targeted properties and is also responsible
    for starting the various animation timelines within its storyboard. It does this
    by calling the `Begin` method of the associated `Storyboard` object, once its
    parent's trigger condition has been met.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeginStoryboard` 动作负责将动画时间线与动画目标及其目标属性连接起来，并且还负责在其故事板内启动各种动画时间线。它是通过调用关联的
    `Storyboard` 对象的 `Begin` 方法来做到这一点的，一旦其父级的触发条件得到满足。'
- en: If an already running storyboard is asked to begin again, either indirectly,
    using a `BeginStoryboard` action, or directly, using the `Begin` method, what
    happens will depend upon the value set by the `HandoffBehavior` property.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个已经运行的故事板被要求再次开始，无论是通过 `BeginStoryboard` 动作间接地，还是通过 `Begin` 方法直接地，所发生的情况将取决于
    `HandoffBehavior` 属性设置的值。
- en: 'This property is of the enumeration type `HandoffBehavior` and has two values.
    The default value is `SnapshotAndReplace` and this will renew the internal clocks
    and essentially have the effect of replacing one copy of the timeline with another.
    The other value is more interesting: the `Compose` value will retain the original
    clocks when restarting the animation and append the new animation after the current
    one, performing some interpolation between them, resulting in a smoother join.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是枚举类型 `HandoffBehavior`，有两个值。默认值是 `SnapshotAndReplace`，这将重新启动内部时钟，本质上具有用另一个时间线替换一个时间线的效果。另一个值更有趣：`Compose`
    值将在重新启动动画时保留原始时钟，并在当前动画之后附加新的动画，在它们之间执行一些插值，从而实现更平滑的连接。
- en: 'One problem with this method is that the retained clocks will continue to use
    system resources and this can end in memory problems if not handled correctly.
    However, this method produces much smoother and more natural and fluid animations
    that can be worth the extra resources. This is best demonstrated with a small
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是保留的时钟将继续使用系统资源，如果处理不当，这可能会导致内存问题。然而，这种方法产生的动画更加平滑、自然和流畅，这可能值得额外的资源。这最好用一个小的例子来演示：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we have two rectangles, each with its own animation. The only
    difference between them is that the `BeginStoryboard` element that starts the
    animation for the right rectangle has a `HandoffBehavior` of `Compose`, while
    the other uses the default value of `SnapshotAndReplace`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个矩形，每个矩形都有自己的动画。它们之间的唯一区别是，启动右侧矩形动画的 `BeginStoryboard` 元素有一个 `HandoffBehavior`
    的值为 `Compose`，而另一个使用默认值 `SnapshotAndReplace`。
- en: When the example is run, each rectangle will move upwards when the mouse cursor
    is placed over it and move back downwards when the cursor is moved away from it.
    If we keep the mouse cursor within the bounds of each rectangle, moving it up
    to the top of the screen with the rectangle and then move the cursor away to let
    the rectangle fall, the two animations will appear identical.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当示例运行时，当鼠标光标放置在矩形上方时，每个矩形都会向上移动；当光标从矩形上移开时，矩形会向下移动。如果我们保持鼠标光标在每个矩形的边界内，将光标移动到屏幕顶部与矩形一起，然后移开光标让矩形落下，这两个动画将看起来完全相同。
- en: However, if we move the mouse cursor from side to side across the two rectangles,
    we will start to see a difference between the two animations. We'll see that as
    the cursor enters the bounds of each rectangle, they each start their upwards
    movement. But once the cursor leaves the rectangle bounds, we see the difference.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把鼠标光标从一边移动到另一边，穿过两个矩形，我们将会看到两个动画之间的差异。我们会看到，当光标进入每个矩形的边界时，它们各自开始向上移动。但一旦光标离开矩形边界，我们就看到了差异。
- en: The rectangle on the left, with the default value of `SnapshotAndReplace`, will
    stop moving up and immediately begin its downwards animation, while the other
    rectangle will continue to move upwards for a short time before commencing its
    downwards animation. This results in a much smoother, more natural looking transition
    between the two animations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的矩形，具有默认值`SnapshotAndReplace`，将停止向上移动并立即开始其向下动画，而另一个矩形将在开始向下动画之前继续向上移动一段时间。这导致两个动画之间的转换看起来更加平滑、自然。
- en: The difference between these two handoff behaviors though, is most clearly demonstrated
    by simply placing the mouse cursor on one of the rectangles and leaving it there.
    Doing this to the rectangle on the left will cause the rectangle to move upwards
    until the mouse cursor is no longer within its bounds and then it will immediately
    begin to move downwards again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种交手行为的区别，最清楚地通过简单地放置鼠标光标在一个矩形上并保持在那里来演示。这样做左边的矩形会导致矩形向上移动，直到鼠标光标不再在其边界内，然后它将立即开始再次向下移动。
- en: However, as the mouse cursor will then be within the bounds of the rectangle
    again, it will begin the upwards animation once more. This will cause the rectangle
    to move away from the mouse cursor again and so we will end with a repetitive
    loop of this behavior and it will result in what looks like a quick shaking, or
    stuttering, of the rectangle just above the position of the mouse.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于鼠标光标将再次位于矩形的边界内，它将再次开始向上动画。这将导致矩形再次远离鼠标光标，因此我们将结束一个重复的行为循环，这会导致矩形在鼠标光标上方看起来像快速震动或卡顿。
- en: On the other hand, the rectangle on the right, with the `HandoffBehavior` of
    `Compose`, will move upwards until the mouse cursor is no longer within its bounds,
    but will then continue to move upwards for a short time before starting to move
    downwards again. Once more, this creates a far smoother animation and will result
    in the rectangle bouncing gently above the mouse cursor, in sharp contrast to
    the other, stuttering rectangle.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，右边的矩形，具有`HandoffBehavior`的`Compose`，将向上移动直到鼠标光标不再在其边界内，但随后会继续向上移动一段时间，然后开始向下移动。这再次创建了一个远更平滑的动画，并将导致矩形在鼠标光标上方轻轻弹跳，与另一个卡顿的矩形形成鲜明对比。
- en: There are several related `TriggerAction` derived classes that are suffixed
    with the word `Storyboard` and enable us to control various aspects of the related
    `Storyboard` element. By specifying the `Name` property value of the `BeginStoryboard`
    element in the `BeginStoryboardName` property of the other actions, we are able
    to further control the running storyboard.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个相关的`TriggerAction`派生类，它们以单词`Storyboard`结尾，使我们能够控制相关`Storyboard`元素的各种方面。通过在其它动作的`BeginStoryboardName`属性中指定`BeginStoryboard`元素的`Name`属性值，我们能够进一步控制正在运行的Storyboard。
- en: We can use the `PauseStoryboard` element to pause a running storyboard and the
    `ResumeStoryboard` to resume a paused storyboard. The `PauseStoryboard` element
    does nothing if the related storyboard is not running and, similarly, the `ResumeStoryboard`
    action does nothing if the related storyboard is not already paused. Therefore,
    a storyboard cannot be started with a `ResumeStoryboard` trigger action.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`PauseStoryboard`元素暂停正在运行的动画故事板，使用`ResumeStoryboard`来恢复暂停的动画故事板。如果相关的动画故事板没有在运行，`PauseStoryboard`元素将不执行任何操作，同样，如果相关的动画故事板尚未暂停，`ResumeStoryboard`动作也不会执行任何操作。因此，不能使用`ResumeStoryboard`触发动作来启动动画故事板。
- en: The `StopStoryboard` action will stop a running storyboard, but does nothing
    if the related storyboard is not already running. Finally, there is a `RemoveStoryboard`
    trigger action that will remove a storyboard when its parent's trigger condition
    has been met. As storyboards consume resources, we should remove them when they
    are no longer required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopStoryboard`动作将停止正在运行的动画故事板，但如果相关的动画故事板尚未运行，则不执行任何操作。最后，有一个`RemoveStoryboard`触发动作，当其父级触发条件满足时，将移除动画故事板。由于动画故事板消耗资源，当它们不再需要时，我们应该移除它们。'
- en: For example, if we use an `EventTrigger` with the `Loaded` event to start a
    timeline that has its `RepeatBehavior` property set to `Forever`, then we should
    use another `EventTrigger` element with a `RemoveStoryboard` action in the `Unloaded`
    event to remove the storyboard. This is somewhat analogous to calling the `Dispose`
    method on an `IDisposable` implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用带有`Loaded`事件的`EventTrigger`来启动一个其`RepeatBehavior`属性设置为`Forever`的时间线，那么我们应该在`Unloaded`事件中使用另一个带有`RemoveStoryboard`动作的`EventTrigger`元素来移除动画故事板。这有点类似于在`IDisposable`实现上调用`Dispose`方法。
- en: 'Note that it is essential to remove a storyboard that was started by a `BeginStoryboard`
    action with its `HandoffBehavior` property set to `Compose`, as it could end with
    many internal clocks being instantiated, but not disposed of. Removing the storyboard
    will also result in the internally used clocks being disposed of. Let''s see a
    practical example of how we might use these elements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，删除由`BeginStoryboard`动作启动的动画故事板非常重要，其`HandoffBehavior`属性设置为`Compose`，因为它可能会导致许多内部时钟被实例化但未释放。删除动画故事板还将导致内部使用的时钟被释放。让我们看看我们如何使用这些元素的实用示例：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This example has two textboxes, with the lower one existing solely to enable
    us to remove focus from the first one. The first textbox is data bound to a `Name`
    property in our View Model. Let''s imagine that we have some validation code that
    will update a property named `IsValid` when the `Name` property is changed. We''ll
    cover validation in depth in [Chapter 9](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml),
    *Implementing Responsive Data Validation*, but for now, let''s keep it simple:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例有两个文本框，下方的文本框仅用于使我们能够从第一个文本框中移除焦点。第一个文本框绑定到我们的视图模型中的`Name`属性。让我们假设我们有一些验证代码，当`Name`属性发生变化时，它将更新一个名为`IsValid`的属性。我们将在[第9章](549ddd97-63f4-4e6c-8df3-6455ede31a4c.xhtml)中深入探讨验证，*实现响应式数据验证*，但现在让我们保持简单：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we simply verify that the `Name` property has a value that has three or
    more characters in it. The basic idea in this example is that we have an animation
    that highlights the fact that a particular form field requires a valid value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是验证`Name`属性是否有三个或更多字符的值。在这个例子中的基本思想是，我们有一个动画，突出显示特定表单字段需要有效值的事实。
- en: It could be a shaking, or growing and shrinking of the form field, or the animation
    of an adjacent element, but in our case, we have used a `DropShadowEffect` element
    to create a glowing effect around it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个抖动，或者表单字段的增长和缩小，或者相邻元素的动画，但在我们的情况下，我们使用了一个`DropShadowEffect`元素来创建围绕它的发光效果。
- en: In the `Triggers` collection of our style, we have declared a number of triggers.
    The first one is a `DataTrigger` and it data binds to the `IsValid` property in
    the View Model and uses the `BeginStoryboard` trigger action element named `GlowStoryboard`
    to make the glowing effect around the textbox grow and shrink when the property
    value is `false`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们风格的`Triggers`集合中，我们声明了多个触发器。第一个是一个`DataTrigger`，它将数据绑定到视图模型中的`IsValid`属性，并使用名为`GlowStoryboard`的`BeginStoryboard`触发动作元素来使文本框周围的发光效果在属性值为`false`时增长和缩小。
- en: While animations are great at attracting the eye, they can also be quite distracting.
    Skipping over the `MultiDataTrigger` momentarily, our animation will therefore
    be paused when the textbox is focused, so that the user can enter the details
    without distraction. We achieve this by declaring a `PauseStoryboard` action in
    the trigger with the condition that the `IsFocused` property is `true`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然动画在吸引眼球方面很出色，但它们也可能相当分散注意力。暂时跳过`MultiDataTrigger`，因此当文本框获得焦点时，我们的动画将暂停，以便用户可以不受干扰地输入详细信息。我们通过在触发器中声明一个带有`IsFocused`属性为`true`条件的`PauseStoryboard`动作来实现这一点。
- en: Using the `EnterActions` collection of the trigger ensures that the `PauseStoryboard`
    action is run as the `IsFocused` property is set to `true`. Declaring the `ResumeStoryboard`
    action in the `ExitActions` collection of the trigger ensures that it will be
    run as the `IsFocused` property is set to `false`, or in other words, when the
    control loses focus.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用触发器的`EnterActions`集合确保当`IsFocused`属性设置为`true`时运行`PauseStoryboard`动作。在触发器的`ExitActions`集合中声明`ResumeStoryboard`动作确保当`IsFocused`属性设置为`false`时运行，换句话说，当控件失去焦点时。
- en: When the user has entered a value, our View Model validates whether the provided
    value is indeed valid and, if so, it sets the `IsValid` property to `true`. In
    our example, we just verify that the entered string contains three or more characters
    in order for it to be valid. Setting the `UpdateSourceTrigger` property to `PropertyChanged`
    on the binding ensures this validation occurs on each keystroke.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入一个值时，我们的视图模型验证提供的值是否确实有效，如果是这样，它将`IsValid`属性设置为`true`。在我们的例子中，我们只是验证输入的字符串是否包含三个或更多字符，以便它是有效的。将`UpdateSourceTrigger`属性设置为`PropertyChanged`确保了每次按键时都会进行验证。
- en: Our example uses a `DataTrigger` to data bind to this property and when it is
    `true`, it triggers the `StopStoryboard` action, which stops the storyboard from
    running any further. As the `FillBehavior` property of our storyboard is not explicitly
    set, it will default to the `Stop` value and the animated property value will
    return to the original value that it had prior to being animated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子使用`DataTrigger`来数据绑定到这个属性，当它为`true`时，它触发`StopStoryboard`动作，停止故事板继续运行。由于我们的故事板的`FillBehavior`属性没有明确设置，它将默认为`Stop`值，动画属性值将返回到动画之前拥有的原始值。
- en: '*However, what should happen if the user entered three or more characters and
    then deleted them?* The data trigger would trigger the `StopStoryboard` action
    and the storyboard would be stopped. As they deleted the characters and the `IsValid`
    property would be set to `false` and the condition of the first `DataTrigger`
    would then trigger the initial `BeginStoryboard` action to start the storyboard
    again.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*然而，如果用户输入了三个或更多字符然后删除它们会发生什么？* 数据触发器将触发`StopStoryboard`动作，并停止故事板。随着字符的删除和`IsValid`属性被设置为`false`，第一个`DataTrigger`的条件将触发初始的`BeginStoryboard`动作，再次启动故事板。'
- en: But this would occur while the focus was still on the textbox and while the
    animation on the effect should not be running. It is for this reason that we declared
    the `MultiDataTrigger` element that we skipped over earlier. In this trigger,
    we have two conditions. One is that the `IsFocused` property should be `true`
    and for this alone, we could have used a `MultiTrigger` instead.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但这将在文本框仍然获得焦点且效果上的动画不应运行时发生。这就是我们之前跳过的`MultiDataTrigger`元素的原因。在这个触发器中，我们有两个条件。一个是`IsFocused`属性应该是`true`，仅为此，我们本可以使用一个`MultiTrigger`。
- en: However, the other condition requires that we data bind to the `IsValid` property
    from the View Model and for that, we need to use the `MultiDataTrigger` element.
    So, this trigger will run its `PauseStoryboard` action when the textbox is focused
    and as soon as the data bound value becomes invalid, or in other words, as the
    user deletes the third character.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，另一个条件要求我们将数据绑定到视图模型的`IsValid`属性，为此，我们需要使用`MultiDataTrigger`元素。因此，当文本框获得焦点并且数据绑定的值变为无效时，或者换句话说，当用户删除第三个字符时，这个触发器将运行其`PauseStoryboard`动作。
- en: The triggers are evaluated from top to bottom in the declared order in the XAML
    and as the user deletes the third character, the first trigger begins the animation.
    The `MultiDataTrigger` has to be declared after the first trigger, so that the
    storyboard will be started before it pauses it. In this case, the glow effect
    will start again once the user has moved focus from the first textbox as required.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器按照在XAML中声明的顺序从上到下进行评估，并且当用户删除第三个字符时，第一个触发器开始动画。`MultiDataTrigger`必须在第一个触发器之后声明，这样故事板就会在暂停之前开始。在这种情况下，当用户将焦点从第一个文本框移开时，所需的辉光效果将再次开始。
- en: Finally, this example demonstrates how we can use a `RemoveStoryboard` trigger
    action to remove the storyboard when it is no longer needed, freeing up its resources.
    The usual way to do this is by utilizing an `EventTrigger` in the `Unloaded` event
    of the relevant control.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个示例演示了我们可以如何使用`RemoveStoryboard`触发动作在不再需要故事板时将其移除，从而释放其资源。通常的做法是利用相关控制的`Unloaded`事件中的`EventTrigger`来完成此操作。
- en: While these are the only trigger action elements that control the running state
    of their associated storyboard elements, there are a further three actions that
    can control other aspects of, or set other properties of the storyboard.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是控制其相关故事板元素运行状态的唯一触发动作元素，但还有另外三个动作可以控制故事板的其它方面或设置其它属性。
- en: The `SetStoryboardSpeedRatio` trigger action can set the `SpeedRatio` of the
    associated storyboard. We specify the desired ratio in its `SpeedRatio` property
    and this value will be applied when the action's related trigger condition is
    met. Note that this element can only work on a storyboard that has already been
    started, although it can work at any time after this point.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetStoryboardSpeedRatio`触发动作可以设置相关故事板的`SpeedRatio`。我们在其`SpeedRatio`属性中指定所需的比率，并在满足动作的相关触发条件时应用此值。请注意，此元素只能作用于已经启动的故事板，尽管它可以在这一点之后任何时候工作。'
- en: The `SkipStoryboardToFill` trigger action will move the current position of
    a storyboard to its fill period, if it has one. Remember that the `FillBehavior`
    property determines what should happen during the fill period. If the storyboard
    has child timelines, then their positions will also be forwarded to their fill
    periods at this point.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`SkipStoryboardToFill`触发动作将故事板的当前位置移动到其填充周期，如果有的话。记住，`FillBehavior`属性决定了填充周期期间应该发生什么。如果故事板有子时间轴，那么它们的当前位置也将在此点前移到它们的填充周期。'
- en: Last, but not least, there is a `SeekStoryboard` trigger action, which enables
    us to move the current position of storyboard to a location, relative to the position
    specified by the `Origin` property, which has a begin time of zero seconds by
    default. When declaring the `SeekStoryboard` action, we specify the desired seek
    position in the `Offset` property and optionally set the `Origin` property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，存在一个`SeekStoryboard`触发动作，它使我们能够将故事板的当前位置移动到相对于由`Origin`属性指定的位置的某个位置，该属性的默认开始时间为零秒。在声明`SeekStoryboard`动作时，我们在`Offset`属性中指定所需的查找位置，并可选择设置`Origin`属性。
- en: The `Offset` property is of type `TimeSpan` and we can use the time notation
    highlighted earlier to specify its value in XAML. The `Origin` property is of
    type `TimeSeekOrigin` and we can specify one of two values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Offset`属性是`TimeSpan`类型，我们可以在XAML中使用前面突出显示的时间表示法来指定其值。`Origin`属性是`TimeSeekOrigin`类型，我们可以指定两个值之一。'
- en: The first is the default value of `BeginTime`, which places the origin at the
    start of the timeline, while the second is `Duration`, which places it at the
    end of a single iteration of the timeline's natural duration. Note that the various
    speed ratio values are not taken into consideration when seeking through a timeline's
    duration.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是`BeginTime`的默认值，它将时间轴的起点定位在时间轴的开始处，而第二个是`Duration`，它将时间轴定位在自然持续时间的单个迭代结束时。请注意，在遍历时间轴持续时间时，不会考虑各种速度比值的设置。
- en: That completes our look at the range of trigger actions that we can use to control
    our storyboards. Each of these trigger actions have corresponding methods in the
    `Storyboard` class that they call when their related trigger conditions are met.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对可以使用来控制故事板的触发动作范围的探讨。这些触发动作中的每一个在满足其相关触发条件时都会在`Storyboard`类中调用相应的方法。
- en: Easing functions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓动函数
- en: When declaring animations with WPF, we are able to utilize a powerful capability
    that helps us to define more specialized animations. While we normally provide
    a start and end value for our animations and let WPF interpolate the intermediate
    values, there is a way that we can affect this interpolation process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用WPF声明动画时，我们能够利用一种强大的功能，帮助我们定义更专业的动画。虽然我们通常为动画提供起始值和结束值，让WPF插值中间值，但有一种方法可以影响这个插值过程。
- en: There are a number of mathematical functions that provide complex animation
    paths and are known as easing functions. For example, these can accurately replicate
    the movement of a spring, or the bounce of a ball.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数学函数提供了复杂的动画路径，被称为缓动函数。例如，这些可以精确地复制弹簧的运动或球体的弹跳。
- en: We can simply declare the appropriate easing function within the `EasingFunction`
    property of the animation. Each easing function extends the `EasingFunctionBase`
    class and has its own specific properties. For example, the `BounceEase` element
    provides `Bounces` and `Bounciness` properties, while the `ElasticEase` class
    declare the `Oscillations` and `Springiness` properties.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在动画的`EasingFunction`属性中简单地声明适当的缓动函数。每个缓动函数都扩展了`EasingFunctionBase`类，并具有其特定的属性。例如，`BounceEase`元素提供了`Bounces`和`Bounciness`属性，而`ElasticEase`类声明了`Oscillations`和`Springiness`属性。
- en: All easing functions inherit the `EasingMode` property from the base class.
    This property is of the enumeration type `EasingMode` and gives us three options.
    The `EaseIn` option follows the normal mathematical formula associated with each
    easing function. The `EaseOut` option uses the inverse of the mathematical formula.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有缓动函数都从基类继承了`EasingMode`属性。这个属性是枚举类型`EasingMode`，并提供了三个选项。`EaseIn`选项遵循与每个缓动函数相关的正常数学公式。`EaseOut`选项使用数学公式的逆。
- en: 'The `EaseInOut` option uses the standard formula for the first half and the
    inverse formula for the second half. While not strictly true, this can be somewhat
    thought of as `EaseIn` affects the start of the animation, `EaseOut` affects the
    end of the animation, and `EaseInOut` affects both the start and the end of the
    animation. Let''s see an example of a bouncing ball animation to demonstrate this
    ability:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`EaseInOut`选项在第一半使用标准公式，在第二半使用逆公式。虽然不是严格正确，但可以大致理解为`EaseIn`影响动画的开始，`EaseOut`影响动画的结束，而`EaseInOut`则影响动画的开始和结束。让我们通过一个弹跳球动画的例子来展示这个功能：'
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we have a `Canvas` panel that contains two shapes: an ellipse and a line.
    The line is simply to give the impression of the ground. The `Ellipse` element
    defines some basic appearance properties and then an `EventTrigger` element that
    starts our eased animation when the shape object is loaded. We have an outer `Storyboard`
    element that is set to repeat forever and contains two inner storyboards.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含两个形状的`Canvas`面板：一个椭圆和一个线条。线条只是为了让人们有地面的印象。`Ellipse`元素定义了一些基本的外观属性，然后是一个`EventTrigger`元素，当形状对象加载时启动我们的缓动动画。我们有一个设置为无限重复的外部`Storyboard`元素，它包含两个内部故事板。
- en: The first of these inner storyboards targets the `Canvas.Top` Attached Property
    using the `Storyboard.TargetProperty`, while the second targets its `Canvas.Left`
    Attached Property. Note that we do not need to specify the `Storyboard.Target` property
    value here, as the storyboard resides within the target element, which will be
    implicitly set as the target for us. Also, remember that we need to wrap the Attached
    Property name with its class name in brackets for this to work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内部故事板中的第一个使用`Storyboard.TargetProperty`针对`Canvas.Top`附加属性，而第二个则针对其`Canvas.Left`附加属性。请注意，我们在这里不需要指定`Storyboard.Target`属性值，因为故事板位于目标元素内，这将隐式地设置为我们的目标。此外，请记住，为了使其生效，我们需要用方括号将附加属性名称及其类名称括起来。
- en: The first storyboard is responsible for the vertical movement of our ball and
    so this is the animation that we want to use the `BounceEase` function with. In
    order to utilize this functionality, we simply declare the `BounceEase` object
    within the `DoubleAnimation.EasingFunction` property and set the desired property
    values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个故事板负责我们球体的垂直运动，因此这是我们想要使用`BounceEase`函数的动画。为了利用这个功能，我们只需在`DoubleAnimation.EasingFunction`属性中声明`BounceEase`对象，并设置所需的属性值。
- en: The `Bounces` property determines how many times the ball should bounce, or
    rebound off the lower extent of the animation. Note that this does not include
    the final half-bounce that this easing function will perform. The `Bounciness`
    property specifies how bouncy the ball is. Strangely, the higher this value is,
    the less bouncy the ball will be. Also note that this value must be positive.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bounces`属性决定了球应该弹跳多少次，或者从动画的下限反弹多少次。请注意，这不包括这个缓动函数将执行的最终半弹跳。`Bounciness`属性指定了球的弹跳程度。奇怪的是，这个值越高，球的弹跳性就越小。此外，请注意这个值必须是正数。'
- en: As physics determines that the horizontal velocity of the ball should remain
    constant for the most part, we do not need to apply an easing function to the
    second animation. Instead, we have added a small value for its `DecelerationRatio`
    property, which nicely simulates the sideways friction on the ball.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物理学决定球的水平速度在大多数情况下应该保持恒定，我们不需要对第二个动画应用缓动函数。相反，我们为其`DecelerationRatio`属性添加了一个小值，这很好地模拟了球侧面的摩擦力。
- en: 'As can be seen, it is very easy to take advantage of these mathematical formulae
    to greatly increase the movement of our animations. While there is not enough
    space in this book for us to cover all of these easing functions, it is well worth
    investigating them yourselves. Let''s take a look at another example, to see how
    we can simulate the movement of a spring using the `ElasticEase` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，利用这些数学公式来大大增加动画的运动是非常容易的。虽然这本书中没有足够的空间让我们涵盖所有这些缓动函数，但自己调查它们是非常值得的。让我们看看另一个例子，看看我们如何使用`ElasticEase`类来模拟弹簧的运动：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we have a thin `Rectangle` element that simulates the movement
    of a coiled spring using an `ElasticEase` function. The `Oscillations` property
    specifies the number of times that the rectangle will grow and shrink over the
    lifetime of the animation effect and the `Springiness` property determines the
    stiffness of the spring, where larger values equal more springiness.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个细长的`Rectangle`元素，使用`ElasticEase`函数模拟弹簧的运动。`Oscillations`属性指定了矩形在动画效果的生命周期内将增长和收缩的次数，而`Springiness`属性决定了弹簧的刚度，其中较大的值等于更大的弹力。
- en: While the two demonstrated easing functions are rather specialized and unsuitable
    to use in many cases, the vast majority of the remaining functions are all variations
    on standard circular, or exponential curves, or curves that use the formula *f(t)
    = t^n*, where *n* is either determined by the exact easing function used, or by
    the `Power` property of the `PowerEase` function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个演示的缓动函数相当专业，不适用于许多情况，但剩余的大多数函数都是标准圆形、指数曲线或使用公式 *f(t) = t^n* 的曲线的变体，其中 *n*
    要么由所使用的确切缓动函数确定，要么由`PowerEase`函数的`Power`属性确定。
- en: For example, the `QuadraticEase` function uses the formula *f(t) = t²*, the
    `CubicEase` function uses the formula *f(t) = t³*, the `QuarticEase` function
    uses the formula *f(t) = t⁴*, the `QuinticEase` function uses the formula *f(t)
    = t⁵*, while the `PowerEase` function uses the formula *f(t) = t^n*, where *n*
    is determined by its `Power` property.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`QuadraticEase`函数使用公式 *f(t) = t²*，`CubicEase`函数使用公式 *f(t) = t³*，`QuarticEase`函数使用公式
    *f(t) = t⁴*，`QuinticEase`函数使用公式 *f(t) = t⁵*，而`PowerEase`函数使用公式 *f(t) = t^n*，其中
    *n* 由其`Power`属性确定。
- en: 'Apart from these variations of the standard acceleration/deceleration curve,
    there is one final useful easing function named `BackEase`. This has the effect
    of overshooting its starting or ending `From` or `To` values, dependent upon the
    value of the `EasingMode` property, and then reversing back to it. This is one
    of the more usable easing functions, so let''s see an example of a `TextBox` element
    sliding on screen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些标准加速度/减速度曲线的变体之外，还有一个非常有用的缓动函数名为`BackEase`。它根据`EasingMode`属性的值，会超出其起始或结束的`From`或`To`值，然后反转回它。这是更可用的缓动函数之一，让我们看看一个`TextBox`元素在屏幕上滑动的例子：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this example, we start with a `Canvas` object that has its `ClipToBounds`
    property set to `true`. This ensures that elements that are outside the bounds
    of the canvas will not be visible. Inside the canvas, we have declared a `TextBox`
    control that is initially placed totally outside the bounds of the canvas and
    so it will be invisible.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个`Canvas`对象开始，其`ClipToBounds`属性设置为`true`。这确保了超出画布边界的元素将不可见。在画布内部，我们声明了一个`TextBox`控件，它最初放置在画布的完全外部，因此它是不可见的。
- en: When the control is loaded, the `EventTrigger` element will start the animation
    that targets the `Canvas.Left` Attached Property. Note that the duration on the
    storyboard is one second longer than the duration on the animation and so the
    storyboard will wait for one second after the animation has completed before restarting.
    This gives us time to appreciate the effect of the applied easing function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当控件加载时，`EventTrigger`元素将启动针对`Canvas.Left`附加属性的动画。请注意，故事板上的持续时间比动画上的持续时间长一秒，因此故事板将在动画完成后等待一秒再重新启动。这给了我们时间去欣赏应用缓动函数的效果。
- en: The animation will slide the textbox to its ending position from its initial
    off-screen position. By using the `BackEase` function, the textbox will slightly
    slide past its ending position and then reverse back into it. The amount past
    its ending position that it will slide to is determined by the value of its `Amplitude`
    property, with higher values extending the overshoot distance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 动画将使文本框从其初始的离屏位置滑动到结束位置。通过使用`BackEase`函数，文本框将稍微滑动过其结束位置，然后反向回到它。它将滑过结束位置的距离由其`Amplitude`属性的值决定，更高的值会延长超调距离。
- en: 'While we have only discussed using these easing functions with `From`, `By` and
    `To` animations so far, it is also possible to use them with key-frame animations
    as well. There are a number of classes that follow the `Easing<Type>KeyFrame`
    naming convention, such as the `EasingColorKeyFrame` class. These classes have
    an `EasingFunction` property that enables us to specify which function to use:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们迄今为止只讨论了使用这些缓动函数与`From`、`By`和`To`动画一起使用，但也可以将它们与关键帧动画一起使用。有一些类遵循`Easing<Type>KeyFrame`命名约定，例如`EasingColorKeyFrame`类。这些类有一个`EasingFunction`属性，使我们能够指定要使用哪个函数：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we animate the size of the text in a `TextBlock` element using
    a number of key-frames. This creates the kind of transition effect that we might
    see on lines of text in Microsoft PowerPoint presentations and could be suitable
    to use in an application that presents textual information to the user.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用多个关键帧来动画化`TextBlock`元素中的文本大小。这创建了类似于我们在Microsoft PowerPoint演示文稿中的文本行上看到的过渡效果，并且可能适合用于向用户展示文本信息的应用程序。
- en: We start by targeting the `FontSize` property and specifying a total duration
    of two and a half seconds. Our first key-frame simply sets our starting font size
    at zero seconds and so we can use a `DiscreteDoubleKeyFrame` for that. The second
    key-frame is an `EasingDoubleKeyFrame` element with a `BounceEase` easing function
    and a duration, or key time, of one second.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先针对`FontSize`属性，并指定总共两秒半的持续时间。我们的第一个关键帧简单地设置我们的起始字体大小为零秒，因此我们可以使用一个`DiscreteDoubleKeyFrame`。第二个关键帧是一个具有`BounceEase`缓动函数和一秒持续时间或关键时间的`EasingDoubleKeyFrame`元素。
- en: Following that, we have another `EasingDoubleKeyFrame` element that lasts for
    one second, but this one uses an `ElasticEase` function. Finally, we finish with
    one further `EasingDoubleKeyFrame` element with a `BackEase` easing function and
    a duration of half a second. Note that we have used small values for the `Bounces`
    and `Oscillations` properties, to keep the animation more usable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们还有一个持续一秒的`EasingDoubleKeyFrame`元素，但这个元素使用的是`ElasticEase`函数。最后，我们用一个具有`BackEase`缓动函数和半秒持续时间的`EasingDoubleKeyFrame`元素结束。请注意，我们使用了小的`Bounces`和`Oscillations`属性值，以保持动画更易于使用。
- en: Using these easing functions with key-frames enable us to chain any number of
    them together to create more complicated animated effects. However, it is easy
    to go overboard and create effects that are too much, as can be seen by increasing
    the values set for the `Bounces` and `Oscillations` properties in this example.
    In reality, even the modest values used here could be considered to be too much
    for practical use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些缓动函数与关键帧一起，使我们能够将任意数量的它们串联起来，以创建更复杂的动画效果。然而，很容易过度使用并创建过于复杂的动画效果，正如在这个示例中通过增加`Bounces`和`Oscillations`属性设置的值所看到的那样。实际上，这里使用的即使是适度的值也可能被认为对于实际应用来说太多了。
- en: Animating along a path
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沿路径动画
- en: There is one further method of animating property values in WPF. Using `PathFigure`
    and `PathSegment` objects, we can construct a `PathGeometry` object and then animate
    a property value according to the `X`, `Y` and/or rotation angle values of the
    path.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在WPF中还有另一种动画属性值的方法。使用`PathFigure`和`PathSegment`对象，我们可以构建一个`PathGeometry`对象，然后根据路径的`X`、`Y`和/或旋转角度值来动画化属性值。
- en: As this method is primarily used for animating objects along a complex path
    and therefore not aimed at typical business applications, we will cover only the
    basics of this functionality here. As with the other kinds of animation classes,
    there are different path animation types that manipulate different CLR types.
    Path animation classes follow the naming convention `<Type>AnimationUsingPath`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种方法主要用于沿复杂路径动画化对象，因此并不针对典型的商业应用，我们在这里只介绍这种功能的基本内容。与其他类型的动画类一样，存在不同的路径动画类型，它们操作不同的CLR类型。路径动画类遵循命名约定`<Type>AnimationUsingPath`。
- en: 'Each `<Type>AnimationUsingPath` class has a `PathGeometry` property that we
    can use to specify a path to animate along, using an object of type `PathGeometry`.
    In order to take advantage of the ability to animate the path `X` and `Y` values
    in addition to the rotation angle, we need to use a `MatrixTransform` element.
    Let''s see an example of this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`<Type>AnimationUsingPath`类都有一个`PathGeometry`属性，我们可以使用它来指定一个动画路径，使用类型为`PathGeometry`的对象。为了利用除了旋转角度之外还能动画化路径`X`和`Y`值的能力，我们需要使用一个`MatrixTransform`元素。让我们看看这个示例：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we animate a `TextBlock` element around a circular path using
    a `MatrixAnimationUsingPath` element. The circular path is defined by a single
    `ArcSegment` element within a single `PathFigure` element. We set the `PathFigure.StartPoint`
    property value to almost match the `ArcSegment.Point` value so that the two ends
    of the ellipse meet.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`MatrixAnimationUsingPath`元素围绕圆形路径动画化一个`TextBlock`元素。圆形路径由单个`PathFigure`元素内的单个`ArcSegment`元素定义。我们将`PathFigure.StartPoint`属性的值设置为几乎与`ArcSegment.Point`值相匹配，以便椭圆的两端相遇。
- en: In order to animate the rotation of the text element from the `MatrixAnimationUsingPath`
    element, we need to set its `DoesRotateWithTangent` property to `true`. If this
    property was set to `false`, or simply omitted, then the text element would still
    be animated in a circular motion, but it would no longer rotate in line with the
    tangent of the circular path, instead remaining upright.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`MatrixAnimationUsingPath`元素动画化文本元素的旋转，我们需要将其`DoesRotateWithTangent`属性设置为`true`。如果这个属性被设置为`false`，或者简单地省略，那么文本元素仍然会以圆形运动进行动画化，但它将不再与圆形路径的切线方向旋转，而是保持直立。
- en: In addition to the `MatrixAnimationUsingPath` class, we can also use either
    of the `DoubleAnimationUsingPath` or `PointAnimationUsingPath` classes to animate
    objects on a path. However, rather than providing examples for these alternative
    methods, let's now move on to find out how we can include every day animations
    in our application framework.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`MatrixAnimationUsingPath`类之外，我们还可以使用`DoubleAnimationUsingPath`或`PointAnimationUsingPath`类之一来沿路径动画化对象。然而，而不是提供这些替代方法的示例，我们现在继续了解如何将日常动画包含到我们的应用程序框架中。
- en: Creating everyday animations
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建日常动画
- en: After covering the wide range of animations that WPF provides, we can see that
    many of them were designed to enable us to perform animations that emulate real-world
    situations, rather than to animate form fields in a standard business application.
    As such, some of the techniques discussed in this chapter are inappropriate for
    use in our application framework.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了WPF提供的广泛动画之后，我们可以看到许多动画都是设计来使我们能够执行模拟现实世界情况的动画，而不是在标准商业应用中动画化表单字段。因此，本章中讨论的一些技术不适合用于我们的应用程序框架。
- en: 'However, this does not mean that we cannot create animations to use in our
    everyday applications. As long as we remember that less is more when it comes
    to animations in business applications, we can certainly build simple animations
    into our application framework. One of the best ways to encapsulate these basic
    animations in our framework is to write one or more custom-animated panels. Let''s
    look at a simple example of an animated `StackPanel`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着我们不能创建动画用于我们的日常应用。只要我们记住在商业应用中动画越少越好，我们当然可以将简单的动画构建到我们的应用程序框架中。在框架中封装这些基本动画的最好方法之一是编写一个或多个自定义动画面板。让我们看看一个简单的`StackPanel`动画示例：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with all custom panels, we just need to provide the implementation for the
    `MeasureOverride` and `ArrangeOverride` methods. However, in our case, we want
    to recreate the functionality of the original `StackPanel` control and so we have
    also declared an `Orientation` Dependency Property of type `System.Windows.Controls.Orientation`,
    with a default value of `Vertical`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有自定义面板一样，我们只需要提供`MeasureOverride`和`ArrangeOverride`方法的实现。然而，在我们的情况下，我们想要重新创建原始`StackPanel`控件的功能，因此我们还声明了一个类型为`System.Windows.Controls.Orientation`的`Orientation`依赖属性，其默认值为`Vertical`。
- en: In the `MeasureOverride` method, we iterate through each of the panel's children,
    calling their `Measure` method, passing in the `availableSize` input parameter.
    Note that this sets their `DesiredSize` property, which will be set to a size
    of `0,0` until this point.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MeasureOverride`方法中，我们遍历面板的每个子元素，调用它们的`Measure`方法，传入`availableSize`输入参数。请注意，这设置了它们的`DesiredSize`属性，直到这一点之前，它将被设置为`0,0`。
- en: After calling the `Measure` method on each child, we are able to use their `DesiredSize`
    property values to calculate the total size required to properly display the rendered
    items, depending on the value of the `Orientation` property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用每个子元素的`Measure`方法之后，我们能够使用它们的`DesiredSize`属性值来计算根据`Orientation`属性的值，正确显示渲染项目所需的总尺寸。
- en: If the `Orientation` property is set to `Vertical`, we use the `Math.Max` method
    to ensure that we keep account of the size of the widest element and if it is
    set to `Horizontal`, then we use it to find the height of the tallest element.
    Once each child has been measured and the overall required size of the panel has
    been calculated, we return this size value from the `MeasureOverride` method.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`Orientation`属性设置为`Vertical`，我们使用`Math.Max`方法来确保我们考虑到最宽元素的尺寸；如果设置为`Horizontal`，则使用它来找到最高元素的尺寸。一旦每个子元素都被测量，并且计算出了面板的整体所需尺寸，我们就从`MeasureOverride`方法返回这个尺寸值。
- en: In the `ArrangeOverride` method, we again iterate through the collection of
    children, but this time we call the `Arrange` method on each child, positioning
    each just outside the bounds of the panel, which will be the starting point of
    their animations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrangeOverride`方法中，我们再次遍历子元素集合，但这次我们在每个子元素上调用`Arrange`方法，将每个子元素定位在面板外部，这将成为它们动画的起点。
- en: If the `Orientation` property is set to `Horizontal`, we position the children
    one child’s width to the left of the origin point and set their height to the
    height of the panel. If the `Orientation` property is set to `Vertical`, we position
    them one child’s height above the origin point and set their width to the width
    of the panel.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`Orientation`属性设置为`Horizontal`，我们将子元素定位在原点左侧一个子元素宽度处，并将它们的高度设置为面板的高度。如果将`Orientation`属性设置为`Vertical`，我们将它们定位在原点上方一个子元素高度处，并将它们的宽度设置为面板的宽度。
- en: This has the effect of stretching each item across the height or width of the
    panel, depending upon the value of the `Orientation` property, as neatly aligned
    items with uniform dimensions look tidier and more professional than items with
    uneven edges. In this way, we can build these kinds of decisions right into our
    framework controls.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生在每个面板的高度或宽度上拉伸每个项目的效果，具体取决于`Orientation`属性的值，因为整齐排列且尺寸均匀的项目比边缘不齐的项目看起来更整洁、更专业。通过这种方式，我们可以将这些决策直接构建到我们的框架控件中。
- en: Next, we calculate the desired end position of each child after animation with
    the `endPosition` variable and then call the `AnimatePosition` method, passing
    in the child, the end position and the duration of the animation. We end the method
    by returning the unchanged `finalSize` input parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`endPosition`变量计算每个子元素动画后的期望位置，然后调用`AnimatePosition`方法，传入子元素、结束位置和动画持续时间。我们通过返回未改变的`finalSize`输入参数来结束该方法。
- en: In the `AnimatePosition` method, we call the `GetTranslateTransform` method
    to get the `TranslateTransform` object that we will use to move each child across
    the panel. If the `Orientation` property is set to `Vertical`, we animate the
    `TranslateTransform.YProperty` property to the value of the `endPosition.Y` property,
    otherwise we animate the `TranslateTransform.XProperty` property to the value
    of the `endPosition.X` property.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AnimatePosition`方法中，我们调用`GetTranslateTransform`方法来获取我们将用于移动每个子元素穿过面板的`TranslateTransform`对象。如果`Orientation`属性设置为`Vertical`，我们动画`TranslateTransform.YProperty`属性到`endPosition.Y`属性的值；否则，我们动画`TranslateTransform.XProperty`属性到`endPosition.X`属性的值。
- en: In order to animate these property values, we use the `BeginAnimation` method
    on the `UIElement` object with the property to be added. There are two overloads
    of this method, but we are using one that accepts the key of the Dependency Property
    to animate and the animation object. The other overload enables us to specify
    the `HandoffBehavior` to use with the animation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化这些属性值，我们在具有要添加的属性的`UIElement`对象上使用`BeginAnimation`方法。这个方法有两个重载版本，但我们使用的是接受要动画化的依赖属性的键和动画对象的那个。另一个重载使我们能够指定与动画一起使用的`HandoffBehavior`。
- en: For our animation, we are using a `DoubleAnimation`, with a constructor that
    accepts the `To` value and the duration of the animation, although there are several
    other overloads that we could have used, had we needed to specify further properties,
    such as the `From` and `FillBehavior` values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的动画，我们正在使用一个`DoubleAnimation`，其构造函数接受动画的`To`值和持续时间，尽管我们还可以使用其他几个重载版本，如果我们需要指定更多的属性，例如`From`和`FillBehavior`值。
- en: In order to animate the movement of the items in the panel, we need to ensure
    that they have a `TranslateTransform` element applied to the `RenderTransform`
    property of the container item of each child. Remember that different `ItemsControl`
    classes will use different container items, for example, a `ListBox` control will
    use `ListBoxItem` container elements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画化面板中项的移动，我们需要确保它们在容器的`RenderTransform`属性上应用了`TranslateTransform`元素。记住，不同的`ItemsControl`类将使用不同的容器项，例如，`ListBox`控件将使用`ListBoxItem`容器元素。
- en: Therefore, if an item does not already have a `TranslateTransform` element applied,
    we must add one. Once each element has a `TranslateTransform` element, we can
    use its `X` and `Y` properties to move the item.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个项还没有应用`TranslateTransform`元素，我们必须添加一个。一旦每个元素都有一个`TranslateTransform`元素，我们就可以使用它的`X`和`Y`属性来移动项。
- en: In the `GetTranslateTransform` method, we simply return the existing `TranslateTransform`
    element from the `RenderTransform` property of each child if one exists, or call
    the `AddTranslateTransform` method to return a new one otherwise. In the `AddTranslateTransform`
    method, we just initialize a new `TranslateTransform` element and set it to the
    `RenderTransform` property of the `child` input parameter, before returning it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetTranslateTransform`方法中，我们只需从每个子项的`RenderTransform`属性中返回现有的`TranslateTransform`元素，如果存在的话，或者如果没有，就调用`AddTranslateTransform`方法来返回一个新的。在`AddTranslateTransform`方法中，我们只是初始化一个新的`TranslateTransform`元素，并将其设置为`child`输入参数的`RenderTransform`属性，然后返回它。
- en: 'We''ve now created a basic animated panel and with just around seventy lines
    of code. The developers that use our application framework can now animate the
    entry of items in any `ItemsControl`, or any of its derived collection controls,
    by simply specifying it in a `ItemsPanelTemplate` as the `ItemsPanel` value:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个基本的动画面板，并且只需要大约七十行代码。现在，使用我们的应用程序框架的开发者可以通过在`ItemsPanelTemplate`中指定它作为`ItemsPanel`值，简单地动画化任何`ItemsControl`或其派生集合控件中项的进入：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, our panel currently only provides one type of animation, albeit in
    two possible directions, and only works as new items are added. Animating objects'
    exit is somewhat trickier, because they are normally removed immediately from
    the panel's `Children` collection when the `Remove` method is called on the data
    bound collection.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的面板目前只提供一种类型的动画，尽管有两种可能的方向，并且仅在添加新项时工作。动画对象的退出有些复杂，因为当在数据绑定集合上调用`Remove`方法时，它们通常会被立即从面板的`Children`集合中移除。
- en: In order to accomplish working exit animations, we'll need to implement a number
    of things. We'll need to update our data Model classes to provide them with new
    properties to identify which stage of the animation that they're currently in
    and new events to raise when the current status changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现工作的退出动画，我们需要实现一些功能。我们需要更新我们的数据模型类，为它们提供新的属性来标识它们当前处于动画的哪个阶段，并在当前状态改变时引发新的事件。
- en: 'We''ll need an `IAnimatable` interface and an `Animatable` class that provides
    the implementation for each data Model. Let''s first see the interface:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`IAnimatable`接口和一个为每个数据模型提供实现的`Animatable`类。让我们首先看看接口：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that there is already an `Animatable` class and an `IAnimatable` interface
    defined in the `System.Windows.Media.Animation` namespace. While it can be unwise
    to create classes and interfaces with the same names as existing ones, for the
    limited purposes of this book, we will use these names and be mindful to prevent
    conflicts.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`System.Windows.Media.Animation`命名空间中已经定义了一个`Animatable`类和一个`IAnimatable`接口。虽然创建与现有类和接口同名的新类和接口可能不明智，但出于本书有限的目的，我们将使用这些名称，并注意防止冲突。
- en: 'Now let''s move on, to see the implementation of our `Animatable` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续前进，看看我们`Animatable`类的实现：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This class needs little explanation, other than to note that the `OnTransitionStatusChanged`
    and `OnRemovalStatusChanged` events get raised when the values of the `TransitionStatus`
    and `RemovalStatus` properties are changed respectively and that the class passes
    itself in as the `sender` input parameter in each case. Let''s see the three new
    enumeration classes that are used in our `Animatable` class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类不需要太多解释，只需注意，当`TransitionStatus`和`RemovalStatus`属性的值分别改变时，`OnTransitionStatusChanged`和`OnRemovalStatusChanged`事件会被触发，并且在这个情况下，类将自身作为`sender`输入参数传递。让我们看看在`Animatable`类中使用的三个新枚举类：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We then need to implement this interface in each data Model class that we want
    to animate:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后需要在每个我们想要动画化的数据模型类中实现这个接口：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The next thing that we need to do is to stop the `Remove` method from actually
    removing each item when called. We''ll need to update our `BaseCollection<T>`
    class, or add a new `BaseAnimatableCollection<T>` class, so that it triggers the
    animation instead of removing the item directly. Here is a cut down example showing
    one way that we might do this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要做的是停止`Remove`方法在调用时实际移除每个项目。我们需要更新我们的`BaseCollection<T>`类，或者添加一个新的`BaseAnimatableCollection<T>`类，以便它触发动画而不是直接移除项目。以下是一个简化的例子，展示了我们可能实现这一点的几种方法之一：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Bear in mind that this is a basic example that could be improved in many ways,
    such as adding checks for `null`, enabling addition, removal and insertion capabilities
    that do not trigger animations and adding other useful properties.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是一个基本的例子，可以从许多方面进行改进，例如添加对`null`的检查、启用不触发动画的添加、移除和插入功能，以及添加其他有用的属性。
- en: In this class, we start by specifying that the generic `T` type parameter must
    implement the `IAnimatable` interface. As with our other base collection classes,
    we ensure that all added and inserted items call a new `Add` method that attaches
    our animation related handlers. We show an example of this in the constructor,
    but skip the other constructor declarations to save space.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们首先指定泛型`T`类型参数必须实现`IAnimatable`接口。正如我们其他的基础集合类一样，我们确保所有添加和插入的项目都会调用一个新的`Add`方法，该方法附加我们的动画相关处理程序。我们在构造函数中展示了这个例子，但跳过了其他构造函数声明以节省空间。
- en: We then declare an `IsAnimatable` property that we can use to make this collection
    work without animation. This property is used in the overridden (or `new`) `Count`
    property, to ensure that items that are due to be removed are not included in
    the count of the collection's children.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后声明了一个`IsAnimatable`属性，我们可以使用这个属性来使这个集合在没有动画的情况下工作。这个属性在重写的（或`new`）`Count`属性中使用，以确保那些即将被移除的项目不会被包含在集合子项的计数中。
- en: In the new `Add` method, we attach a reference of our `Item_OnRemovalStatusChanged`
    handler to the `OnRemovalStatusChanged` event of the `Animatable` object of the
    item being added. We then set the `AdditionStatus` property of the `Animatable`
    object to the `ReadyToAnimate` member to signal that the object is ready to begin
    its entrance animation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的`Add`方法中，我们将我们的`Item_OnRemovalStatusChanged`处理程序的引用附加到被添加项目的`Animatable`对象的`OnRemovalStatusChanged`事件上。然后我们将`Animatable`对象的`AdditionStatus`属性设置为`ReadyToAnimate`成员，以表示该对象已准备好开始其入场动画。
- en: As this base collection is extending another base class, we need to remember
    to call its `Add` method, passing in the item, so that it can attach its own handler
    for the item's `PropertyChanged` event. The other `Add` overloads enable multiple
    items to be added to the collection, but both internally call the first `Add`
    method. The `Insert` method does the same as the first `Add` method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个基础集合扩展了另一个基础类，我们需要记住调用它的`Add`方法，传入项目，以便它可以附加自己的处理程序来处理项目的`PropertyChanged`事件。其他`Add`重载允许将多个项目添加到集合中，但两者都内部调用第一个`Add`方法。`Insert`方法与第一个`Add`方法做相同的事情。
- en: The `ClearItems` method iterates through each item in the collection, detaching
    the reference to the `Item_OnRemovalStatusChanged` handler from each before calling
    the `ClearItems` method of the base class. As it is, this method could be reserved
    for removing all items from the collection without animation, but it would be
    easy to call the `Remove` method with each item to include animations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearItems` 方法遍历集合中的每个项目，在调用基类的 `ClearItems` 方法之前，从每个项目移除对 `Item_OnRemovalStatusChanged`
    处理器的引用。实际上，这个方法可以保留用于从集合中移除所有项目而不使用动画，但通过为每个项目调用 `Remove` 方法可以包括动画效果。'
- en: The `Remove` method in this class enables us to animate the exit of each item;
    it doesn't actually remove the item from the collection, but instead sets the
    `RemovalStatus` property of the item's `Animatable` object to the `ReadyToAnimate`
    member to signal that the object is ready to begin its exit animation. It then
    returns true from the method to signify successful removal of the item.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的 `Remove` 方法使我们能够为每个项目的退出进行动画处理；它实际上并没有从集合中移除项目，而是将项目的 `Animatable` 对象的
    `RemovalStatus` 属性设置为 `ReadyToAnimate` 成员，以表示该对象已准备好开始其退出动画。然后，该方法返回 `true` 以表示成功移除项目。
- en: Finally, we get to the `Item_OnRemovalStatusChanged` event handler, which is
    the next major part in enabling exit animations. In it, we cast the `sender` input
    parameter to an instance of our `Animatable` class. Remember that it passes itself
    as the `sender` parameter when raising the event.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了 `Item_OnRemovalStatusChanged` 事件处理器，这是启用退出动画的下一个重要部分。在其中，我们将 `sender`
    输入参数转换为我们的 `Animatable` 类的实例。记住，当引发事件时，它将自身作为 `sender` 参数传递。
- en: We then check whether the `RemovalStatus` property of the `Animatable` instance
    is set to the `ReadyToRemove` member, or both its `RemovalStatus` property is
    set to `ReadyToAnimate` and the collection is not animatable. If either condition
    is true, we finally call the `Remove` method of the base class to actually remove
    the item from the collection and set the `RemovalStatus` property to `None`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查 `Animatable` 实例的 `RemovalStatus` 属性是否设置为 `ReadyToRemove` 成员，或者其 `RemovalStatus`
    属性设置为 `ReadyToAnimate` 且集合不可动画化。如果任一条件为真，我们最终调用基类的 `Remove` 方法来实际从集合中移除项目并将 `RemovalStatus`
    属性设置为 `None`。
- en: In this way, when the collection is set to be not animatable and the `Remove`
    method is called, the item is immediately removed and the `Animatable` object's
    `RemovalStatus` property is set to the `None` member in the `Item_OnRemovalStatusChanged`
    handler. If you remember, the `OnRemovalStatusChanged` event gets raised when
    the `RemovalStatus` property value is changed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，当集合被设置为不可动画化并且调用 `Remove` 方法时，项目会立即被移除，并且在 `Item_OnRemovalStatusChanged`
    处理器中将 `Animatable` 对象的 `RemovalStatus` 属性设置为 `None` 成员。如果你还记得，当 `RemovalStatus`
    属性值改变时，会引发 `OnRemovalStatusChanged` 事件。
- en: 'However, we''re still missing part of this puzzle. *What sets the* `Animatable`
    *object''s* `RemovalStatus` *property to the* `ReadyToRemove` *member to remove
    each item?* We will need to update our animated panel to accomplish this task,
    and to do this, it will need to maintain a collection of the elements that need
    to be removed and signal the collection to remove them once their exit animations
    complete:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然缺少这个谜题的一部分。*是什么将* `Animatable` *对象的* `RemovalStatus` *属性设置为* `ReadyToRemove`
    *成员以移除每个项目？* 我们需要更新我们的动画面板来完成这个任务，为此，它需要维护一个需要移除的元素集合，并在它们的退出动画完成后通知该集合移除它们：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use the `Storyboard.Completed` event to notify us when the animation
    is complete and then signal to remove the item at that point, by setting the `Animatable`
    object''s `RemovalStatus` property to the `ReadyToRemove` member. Let''s take
    a look at the required changes to our animated panel. First, we need to add the
    following using declarations:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Storyboard.Completed` 事件来通知我们动画何时完成，然后通过将 `Animatable` 对象的 `RemovalStatus`
    属性设置为 `ReadyToRemove` 成员，在该点发出移除项目的信号。让我们看看我们动画面板所需的更改。首先，我们需要添加以下 `using` 声明：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we need to replace the call to the `AnimatePosition` method from the
    original `ArrangeOverride` method with the following line:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将原始 `ArrangeOverride` 方法中的 `AnimatePosition` 方法的调用替换为以下行：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then need to add the following additional methods after the `ArrangeOverride`
    method:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在 `ArrangeOverride` 方法之后添加以下附加方法：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's examine this new code. First, we have the `BeginAnimations` method, in
    which we cast the container control to a `FrameworkElement`, so that we can access
    its `DataContext` property. Our data object is accessed from this property and
    we cast it to an `IAnimatable` instance, so that we can access the `Animatable`
    object via its `Animatable` property.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这段新代码。首先，我们有`BeginAnimations`方法，在这个方法中，我们将容器控件强制转换为`FrameworkElement`类型，以便我们可以访问其`DataContext`属性。我们的数据对象通过这个属性访问，并将其转换为`IAnimatable`实例，这样我们就可以通过其`Animatable`属性访问`Animatable`对象。
- en: We then remove our `Item_OnRemovalStatusChanged` event handler from the `OnRemovalStatusChanged`
    event before re-attaching it, to ensure that only a single handler is attached,
    regardless of how many times each child passes through this method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新附加之前，我们从`OnRemovalStatusChanged`事件中移除我们的`Item_OnRemovalStatusChanged`事件处理器，以确保无论每个子项通过此方法的次数如何，都只附加一个处理器。
- en: If the `AdditionStatus` property is set to `DoNotAnimate`, we arrange the item
    at its end position immediately and without animation, while if it is set to `ReadyToAnimate`,
    we call the `AnimateEntry` method and then set the `AdditionStatus` property to
    `Added`. Finally, if the `RemovalStatus` property is set to `ReadyToAnimate`,
    we call the `AnimateExit` method.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`AdditionStatus`属性被设置为`DoNotAnimate`，我们将立即且无动画地安排项目到其结束位置，而如果它被设置为`ReadyToAnimate`，我们将调用`AnimateEntry`方法，然后将`AdditionStatus`属性设置为`Added`。最后，如果`RemovalStatus`属性被设置为`ReadyToAnimate`，我们将调用`AnimateExit`方法。
- en: In the `Item_OnRemovalStatusChanged` event handler, we call the panel's `InvalidateArrange`
    method if the `RemovalStatus` property is set to `ReadyToAnimate`. This is another
    essential part of the exit animation strategy and it requests the layout system
    to call the `ArrangeOverride` method, thereby triggering the starting of the exit
    animation(s).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Item_OnRemovalStatusChanged`事件处理器中，如果`RemovalStatus`属性被设置为`ReadyToAnimate`，我们会调用面板的`InvalidateArrange`方法。这是退出动画策略的另一个重要部分，它请求布局系统调用`ArrangeOverride`方法，从而触发退出动画的开始。
- en: Remember that the `OnRemovalStatusChanged` event gets raised when the value
    of the `RemovalStatus` property is changed. Also recall that the `RemovalStatus` property
    is set to the `ReadyToAnimate` member in the `Remove` method of the `BaseAnimatableCollection<T>`
    class. That raises the event and this event handler starts the animations in response.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当`RemovalStatus`属性的值发生变化时，会触发`OnRemovalStatusChanged`事件。同时，回忆一下，`RemovalStatus`属性在`BaseAnimatableCollection<T>`类的`Remove`方法中被设置为`ReadyToAnimate`成员。这会引发事件，并且这个事件处理器会启动动画。
- en: The `AnimateEntry` method simply calls the original, unchanged `AnimatePosition`
    method from our first animated panel attempt. The `AnimateExit` method takes an
    additional `startPosition` input parameter, which represents the current position
    of each item within the panel.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimateEntry`方法简单地调用我们第一次动画尝试中的原始、未更改的`AnimatePosition`方法。`AnimateExit`方法接受一个额外的`startPosition`输入参数，它表示每个项目在面板中的当前位置。'
- en: We start by setting the `Panel.SetZIndex` Attached Property to a value of `100`
    for each child, to ensure that their animated departure is rendered above, or
    over the top of, the remaining items. We then calculate the end position of the
    animation using the start position and the size of the panel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将每个子项的`Panel.SetZIndex`附加属性设置为`100`，以确保它们的动画离开被渲染在剩余项目之上或覆盖其上。然后，我们使用起始位置和面板的大小计算动画的结束位置。
- en: Next, we call an overload of the `AnimatePosition` method, passing in our child,
    start and end positions, animation duration and an event handler as parameters.
    After the child item's position animation has been started, the child is added
    to the `elementsToBeRemoved` collection.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`AnimatePosition`方法的另一个重载版本，传入我们的子项、起始位置、结束位置、动画持续时间和事件处理器作为参数。在子项的位置动画开始后，我们将子项添加到`elementsToBeRemoved`集合中。
- en: In the `AnimatePosition` method, we first check that our start and end positions
    are different, before creating and starting our `DoubleAnimation` objects. If
    the `X` values are different and the event handler input parameter is not `null`,
    then we attach it to the `Completed` event of the `xAnimation` object before starting
    its animation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AnimatePosition`方法中，我们首先检查我们的起始位置和结束位置是否不同，然后创建并启动我们的`DoubleAnimation`对象。如果`X`值不同且事件处理器输入参数不是`null`，则在开始其动画之前，我们将它附加到`xAnimation`对象的`Completed`事件上。
- en: If the `Y` values are different and the event handler input parameter is not
    `null` and the event handler was not already attached to the `xAnimation` object,
    then we attach it to the `Completed` event of the `yAnimation` object before starting
    its animation. Note that we only need to attach one handler to this event, because
    we only have one object to remove from the collection.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Y`值不同，并且事件处理程序输入参数不是`null`，并且事件处理程序尚未附加到`xAnimation`对象上，那么在开始其动画之前，我们将它附加到`yAnimation`对象的`Completed`事件。请注意，我们只需要将一个处理程序附加到该事件，因为我们只有一个对象需要从集合中移除。
- en: Also note that we set the `AccelerationRatio` property to `1.0` in this overload,
    so that the item accelerates off screen. However, in a business application framework,
    we would want to keep our animation properties in sync and so, we would probably
    set the `AccelerationRatio` property to `1.0` on the animation objects in the
    original `AnimatePosition` method as well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们在本重载中设置`AccelerationRatio`属性为`1.0`，以便项目加速离开屏幕。然而，在一个商业应用程序框架中，我们希望保持我们的动画属性同步，因此，我们可能会在原始的`AnimatePosition`方法中的动画对象上也将`AccelerationRatio`属性设置为`1.0`。
- en: The last piece of the puzzle is the `RemovalAnimation_Completed` event handling
    method. This method gets called when the exit animation has completed and iterates
    through the `elementsToBeRemoved` collection. If any element to remove implements
    the `IAnimatable` interface, its `Animatable` object's `RemovalStatus` property
    is set to the `ReadyToRemove` member.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图碎片是`RemovalAnimation_Completed`事件处理方法。当退出动画完成后，该方法会被调用，并遍历`elementsToBeRemoved`集合。如果任何要移除的元素实现了`IAnimatable`接口，则将其`Animatable`对象的`RemovalStatus`属性设置为`ReadyToRemove`成员。
- en: If you remember, this raises the `OnRemovalStatusChanged` event, which is handled
    by the `Item_OnRemovalStatusChanged` event handler in the `BaseAnimatableCollection`
    class. In that method, the `Animatable` object's `RemovalStatus` property is checked
    for the `ReadyToRemove` member and if found, the owning item is actually removed
    from the collection.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，这会引发`OnRemovalStatusChanged`事件，该事件由`BaseAnimatableCollection`类中的`Item_OnRemovalStatusChanged`事件处理程序处理。在那个方法中，会检查`Animatable`对象的`RemovalStatus`属性中的`ReadyToRemove`成员，如果找到，则实际从集合中移除拥有该项目的项。
- en: And so, to summarize; the `Remove` method of the animation collection is called,
    but instead of removing the item, it sets a property on it, which raises an event
    that is handled by the animated panel; the panel then starts the exit animation
    and when completed, it raises an event that is handled by the collection class
    and results in the item actually being removed from the collection.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下；动画集合的`Remove`方法被调用，但不是移除项目，而是在其上设置一个属性，这会引发一个由动画面板处理的事件；面板随后开始退出动画，当动画完成后，它引发一个由集合类处理的事件，导致项目实际上被从集合中移除。
- en: While this animated panel is entirely usable as it is, there are many ways that
    it could be further improved. One important thing that we could do would be to
    extract all of the properties and animation code from this class and put them
    into a base `AnimatedPanel` class. In this way, we could reuse this class when
    creating other types of animated panel, such as an `AnimatedWrapPanel`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个动画面板已经完全可用，但它可以通过多种方式进一步改进。我们可以做的一件重要的事情是将所有属性和动画代码从此类中提取出来，并将它们放入一个基`AnimatedPanel`类中。这样，我们就可以在创建其他类型的动画面板时重用此类，例如`AnimatedWrapPanel`。
- en: We could then further extend the base class by exposing additional animation
    properties, so that users of our panel could have more control over the animations
    that it provides. For example, we could declare `VerticalContentAlignment` and
    `HorizontalContentAlignment` properties to dictate how our panel items should
    be aligned in the panel.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过公开额外的动画属性进一步扩展基类，以便我们的面板用户可以更多地控制它提供的动画。例如，我们可以声明`VerticalContentAlignment`和`HorizontalContentAlignment`属性来指定我们的面板项应在面板中如何对齐。
- en: Additionally, we could add `EntryAnimationDirection` and `ExitAnimationDirection`
    properties to specify which direction to animate our panel items as they are added
    and removed from the panel. We could also enable different types of animation,
    such as fading or spinning, by animating the `Opacity` property, or the `Angle`
    property of a `RotationTransform` element.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以添加`EntryAnimationDirection`和`ExitAnimationDirection`属性来指定在将面板项添加到或从面板中移除时动画的方向。我们还可以通过动画`Opacity`属性或`RotationTransform`元素的`Angle`属性来启用不同类型的动画，例如淡入或旋转。
- en: Furthermore, we could add `EntryAnimationDuration` and `ExitAnimationDuration`
    properties to specify the length of time that each animation should take, rather
    than hardcoding values directly into our panel. There really is no limit to what
    functionality that we can provide with our application framework panels, other
    than the limitations dictated by the end users' computer hardware.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以添加 `EntryAnimationDuration` 和 `ExitAnimationDuration` 属性来指定每个动画应该持续的时间长度，而不是直接将值硬编码到我们的面板中。实际上，我们使用应用程序框架面板所能提供的功能几乎没有任何限制，除了由最终用户的计算机硬件所规定的限制。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've investigated the variety of animation possibilities that
    WPF provides us with, primarily focusing on XAML and the more usable options.
    We've discovered the finer details of timelines and also explored how we can incorporate
    animation into our application framework, so that its users can easily leverage
    the power of animations without having to know anything about them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了 WPF 提供的动画可能性，主要关注 XAML 和更易用的选项。我们发现了时间线的细节，还探讨了如何将动画融入我们的应用程序框架，以便用户可以轻松利用动画的力量，而无需了解任何关于动画的知识。
- en: In the next chapter, we will look at a number of ways that we can improve the
    overall look and feel of our applications, from providing consistent application
    styles and icons to examining a number of techniques for creating rich graphics.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨多种方法来改善我们应用程序的整体外观和感觉，从提供一致的应用程序样式和图标到检查创建丰富图形的多种技术。
