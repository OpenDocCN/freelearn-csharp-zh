<html><head></head><body>
		<div><p><a id="_idTextAnchor1801"/><a id="_idTextAnchor1802"/></p>
			<h1 id="_idParaDest-281"><em class="italic"><a id="_idTextAnchor1803"/>Chapter 15</em>: Testing</h1>
			<p>The success of any application depends on how easy it is for users to use it. The longevity of any software product depends directly on the quality of the product.</p>
			<p>Testing is an important aspect of the <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>) and ensures that a product meets the customer's requirements and the quality requirements. Testing is also important, as the cost of fixing bugs increases as we move toward the later stages of the SDLC.</p>
			<p>In this chapter, we will learn about the different types of testing and the tools that Visual Studio provides for testing, as well as looking at third-party tools that we can use to ensure the quality of the products we build in .NET 6.</p>
			<p>In this chapter, we will learn about the following:</p>
			<ul>
				<li>Types of testing</li>
				<li>Unit testing</li>
				<li>Functional testing</li>
				<li>Understanding the importance of load testing</li>
			</ul>
			<p>By the end of this chapter, you will know everything you need to know about ensuring the quality of a product.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor1804"/><a id="_idTextAnchor1805"/>Technical requirements</h1>
			<p>You will need Visual Studio 2022 Community Edition. (Certain sections require Enterprise Edition.)</p>
			<p>Along with Visual Studio, you will need JMeter, which can be downloaded from here: <a href="https://jmeter.apache.org/download_jmeter.cgi">https://jmeter.apache.org/download_jmeter.cgi</a>. You will also need a basic understanding of Microsoft .NET.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor1806"/><a id="_idTextAnchor1807"/>Introducing testing</h1>
			<p>Software testing is a way to check <a id="_idTextAnchor1808"/>whether an application is performing according to expectations. These expectations could be to do with functionality, responsiveness, or the resources that the software <a id="_idIndexMarker1331"/>consumes while running.</p>
			<p>Software testing can be broadly categorized into the following two categories based on the way it is performed:</p>
			<ul>
				<li><strong class="bold">Manual testing</strong>: In manual<a id="_idIndexMarker1332"/> testing, tester<a id="_idTextAnchor1809"/>s execute test case<a id="_idTextAnchor1810"/>s manually by using the application under test and validating <a id="_idIndexMarker1333"/>the expected outcome. Manual testing requires more effort than the alternative.</li>
				<li><strong class="bold">Automated testing</strong>: Automated<a id="_idIndexMarker1334"/> test<a id="_idTextAnchor1811"/>ing is performed by special automated testing software. This automa<a id="_idTextAnchor1812"/>ted software<a id="_idIndexMarker1335"/> runs on the application under test in a specialized environment and validates the expected output. Automated testing saves a lot of time and manpower. In some cases, it might take a lot of effort to have 100% automation and<a id="_idIndexMarker1336"/> maintain the <a id="_idTextAnchor1813"/>autom<a id="_idTextAnchor1814"/>ation with considerably less <strong class="bold">Return on Investment</strong> (<strong class="bold">ROI</strong>).</li>
			</ul>
			<p>In terms of the information known about the internals of the application under test (such as the code flow and dependent modules integration), software testing can also be broadly categorized in the following ways:</p>
			<ul>
				<li><strong class="bold">Black-box testing</strong>: In blac<a id="_idTextAnchor1815"/>k-box testing, the<a id="_idIndexMarker1337"/> indi<a id="_idTextAnchor1816"/>vidual responsible for testing does not have information about the internals of the system. The focus <a id="_idIndexMarker1338"/>here is on the behavior of the system.</li>
				<li><strong class="bold">White-box testing</strong>: In white-box testi<a id="_idTextAnchor1817"/>ng, the<a id="_idIndexMarker1339"/> tester has information <a id="_idIndexMarker1340"/>about the internal structure, de<a id="_idTextAnchor1818"/>sign, and implementation of the system. The focus of white-box testing is testing the alternate paths that exist in the implementation.</li>
			</ul>
			<p>In software testing, we validate different aspects of an application. Software testing also has the following variants, based on the aspect of an application that it validates and the tools or frameworks it uses:</p>
			<ul>
				<li><strong class="bold">Unit testing</strong>: Unit testing focus<a id="_idTextAnchor1819"/>es on the smallest u<a id="_idTextAnchor1820"/>nit of an application. Here, we validate individual <a id="_idIndexMarker1341"/>classes or functions. This is mostly done during the development phase.</li>
				<li><strong class="bold">Functional testing</strong>: Thi<a id="_idTextAnchor1821"/>s is often termed <strong class="bold">integration testing</strong>. The main<a id="_idTextAnchor1822"/> objective of this is to ensure that<a id="_idIndexMarker1342"/> an <a id="_idTextAnchor1823"/>application is performing as per the<a id="_idIndexMarker1343"/> requirements.</li>
				<li><strong class="bold">Regression testing</strong>: <a id="_idTextAnchor1824"/>A regression test ensu<a id="_idTextAnchor1825"/>res that any recent changes have not adversely affected application performance and that the existing functionality is not affected by <a id="_idIndexMarker1344"/>any changes. In regression testing, all or some of the functional test cases are executed, depending upon the change introduced in the application.</li>
				<li><strong class="bold"><a id="_idTextAnchor1826"/>Smoke test</strong>: A smoke test <a id="_idTextAnchor1827"/>is done <a id="_idIndexMarker1345"/>after every deployment to ensure that the application is stable and<a id="_idIndexMarker1346"/> ready for r<a id="_idTextAnchor1828"/>ollout. This is also known as a <strong class="bold">Build Verification Test</strong> (<strong class="bold">BVT</strong>).</li>
				<li><strong class="bold">Lo<a id="_idTextAnchor1829"/>ad test</strong>: A load test is used to <a id="_idIndexMarker1347"/>deter<a id="_idTextAnchor1830"/>mine the overall effectiveness of the system. During a load test, we simulate the projected load on an integrated system.</li>
				<li><strong class="bold">Stress testing</strong>: In <a id="_idTextAnchor1831"/>stress tests, we<a id="_idIndexMarker1348"/> push the <a id="_idTextAnchor1832"/>system beyond the intended capacity or load. This helps us identify the bottlenecks in the system and identify the points of failure. Performance testing is the umbrella term used for both stress and load testing.</li>
				<li><strong class="bold">Security testing</strong>: Se<a id="_idTextAnchor1833"/>curity testing is<a id="_idIndexMarker1349"/> perfo<a id="_idTextAnchor1834"/>rmed to ensure the flawless execution of the application. In security testing, we focus on evaluating various elements of security aspects such as integrity, confidentiality, and authenticity, among others.</li>
				<li><strong class="bold">Accessibility test<a id="_idTextAnchor1835"/>ing</strong>: Accessibility testing is designed to determine whether differently<a id="_idTextAnchor1836"/>-abled individuals will be <a id="_idIndexMarker1350"/>able to use an application.</li>
			</ul>
			<p>Now that we have seen the different types of testing, in the sections ahead, we will be covering unit testing, functional testing, and load testing in detail, as they are critical to ensuring the stability of an applicati<a id="_idTextAnchor1837"/>on.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To explore more on security, try<a id="_idIndexMarker1351"/> security testing with static code analysis tools: <a href="https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview">https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview</a>. M<a id="_idTextAnchor1838"/>ore on accessibility can be found here: <a href="https://accessibilityinsights.io/">https://accessibilityinsights.io/</a>.</p>
			<p>Performance tests, accessibility tests, and security tests are the tests that we perform to assess the non-functional aspects of the application, such as performance, usability, reliability, security, and accessibility.</p>
			<p>Now, let's see how to perform unit testing for our e-c<a id="_idTextAnchor1839"/><a id="_idTextAnchor1840"/>ommerce application.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor1841"/>Unit testing</h1>
			<p>Unit<a id="_idTextAnchor1842"/> testing is a way to test the <a id="_idIndexMarker1352"/>smallest isolated unit of an application. It is an important step in software development that helps isolate a problem early.</p>
			<p>Unit testing has a direct impact on the quality of the software we build. It is always recommended to<a id="_idTextAnchor1843"/> write a unit test as soon as you write any<a id="_idTextAnchor1844"/> method. If we follow the methodology of <strong class="bold">test-driven development </strong>(<strong class="bold">TDD</strong>), we write the<a id="_idIndexMarker1353"/> test case first and then proceed to implement the functionality.</p>
			<p>In the next section, we will learn about creating unit tests and running th<a id="_idTextAnchor1845"/><a id="_idTextAnchor1846"/>em from Visual Studio.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor1847"/>Unit testing in Visual Studio</h2>
			<p><a id="_idTextAnchor1848"/>We chose to use Visual Studio<a id="_idIndexMarker1354"/> as it has powerful tooling to create and manage test cases.</p>
			<p>With Visual Studio, we can create, debug, and<a id="_idIndexMarker1355"/> run unit test cases. We can also check the code coverage of the tests that are executed. Additionally, it has a <strong class="bold">Live <a id="_idTextAnchor1849"/>Unit</strong> test feature, which runs unit test cases while we modify the code and shows the results in real time.</p>
			<p>We will explore all these features in the subsequent sections.</p>
			<h3>Creating and run<a id="_idTextAnchor1850"/>ning unit tests</h3>
			<p>Let's go ahead and creat<a id="_idTextAnchor1851"/>e a unit test <a id="_idIndexMarker1356"/>project to perform unit testing on the <code>Packt.ECommerce.Order</code> project.</p>
			<p>Perform the following steps to <a id="_idIndexMarker1357"/>create unit test cases:</p>
			<ol>
				<li>Add a new project of the <code>Tests</code> folder, and name the project <code>Packt.<a id="_idTextAnchor1852"/>ECommerce.Order.UnitTest</code>:</li>
			</ol>
			<div><div><img src="img/Figure_15.1_B18507.jpg" alt="Figure 15.1 – Visual Studio xUnit test project &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.1 – Visual Studio xUnit test project </p>
			<ol>
				<li value="2">Add a project reference of <code>Packt.ECommerce.Order</code> to the newly created test pr<a id="_idTextAnchor1853"/>oject.</li>
				<li>Add a new <a id="_idTextAnchor1854"/>class to the test <a id="_idIndexMarker1358"/>project and name it <code>OrdersControllerTest</code>. We are <a id="_idIndexMarker1359"/>going to add all the test cases related to <code>OrdersController</code> in this class.</li>
				<li>Now, let's add a simple test to test the constructor of the <code>OrdersController</code> controller. The test we will be performing is to assert the successful creation of the <code>OrderController</code> controller. Let's now add the test, as shown in the following code:<pre><strong class="bold">[Fact]</strong>
public async Task Create_Object_OfType_OrderController ()
{
<strong class="bold">      OrdersController testObject = new </strong>
<strong class="bold">        OrdersController(null);</strong>
<strong class="bold">      Assert.NotNull(testObject);</strong>
}</pre></li>
			</ol>
			<p>The <code>Create_Object_OfType_OrderController</code> test method is attributed <a id="_idTextAnchor1855"/>with <code>Fact</code>; this is required<a id="_idTextAnchor1856"/> for the <code>xUnit</code> framework to discover the test method. Here, we are <a id="_idIndexMarker1360"/>asserting by checking the <code>null</code> condition of the object created.</p>
			<ol>
				<li value="5">Visual Studio provides <strong class="bold">Test Explorer</strong> to manage and run tests. Let's open it by going to <strong class="bold">Test</strong> | <strong class="bold">Test Explorer</strong>.</li>
				<li>Build the solution to see the<a id="_idIndexMarker1361"/> tests in <strong class="bold">Test Explorer</strong>.</li>
				<li>In <code>OrderController_Constructor</code> test we created by right-clicking on it and selectin<a id="_idTextAnchor1857"/>g <strong class="bold">Run</strong> from the context menu:</li>
			</ol>
			<div><div><img src="img/Figure_15.2_B18507.jpg" alt="Figure 15.2 – Test Run context menu from the Test Explorer window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2 – Test Run context menu from the Test Explorer window</p>
			<ol>
				<li value="8">O<a id="_idTextAnchor1858"/>nce the test is executed<a id="_idTextAnchor1859"/>, we<a id="_idIndexMarker1362"/> can see the test result in the right pane. From the result, we <a id="_idIndexMarker1363"/>can see that the test was executed and <a id="_idTextAnchor1860"/>run successfully, as follows:</li>
			</ol>
			<div><div><img src="img/Figure_15.3_B18507.jpg" alt="Figure 15.3 – Test results from Test Explorer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3 – Test results from Test Explorer</p>
			<p>We have created and executed a simple test in Visual Studio. In the next section, we will learn how to mock the dependencies of <code>OrdersController</code> to validate the functionality.</p>
			<h3>Mocking dependencies with M<a id="_idTextAnchor1861"/>oq</h3>
			<p>Often, a method under<a id="_idIndexMarker1364"/> tes<a id="_idTextAnchor1862"/>t calls other external <a id="_idIndexMarker1365"/>methods or services, which we call dependencies. To ensure the functionality of the method under test, we isolate the behavior of dependencies by creating mock objects for the dependencies.</p>
			<p>In an application, classes may be dependent on other classes; for instance, our <code>OrdersController</code> class is dependent on <code>OrderService</code>. While testing <code>OrdersController</code>, we should be isolating the behavior of <code>OrderService</code>.</p>
			<p>To understand mocking, let's create the unit <a id="_idIndexMarker1366"/>test for the <code>GetOrdersAsync</code> action method of <code>OrdersController</code>.</p>
			<p>Let's have a look at the <code>GetOrderById</code> method for <a id="_idIndexMarker1367"/>which we are writing the unit test case:</p>
			<pre class="source-code">//This is the GetOrderById action method in OrdersController.cs</pre>
			<pre class="source-code">[HttpGet]</pre>
			<pre class="source-code">[Route("{id}")]</pre>
			<pre class="source-code">public async Task&lt;IActionResult&gt; GetOrderById(string id)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">     var order = await </pre>
			<pre class="source-code">       this.orderService.GetOrderByIdAsync(id)</pre>
			<pre class="source-code">       .ConfigureAwait(false);</pre>
			<pre class="source-code">     if (order != null)</pre>
			<pre class="source-code">     {</pre>
			<pre class="source-code">          return this.Ok(order);</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">     else</pre>
			<pre class="source-code">     {</pre>
			<pre class="source-code">          return this.NotFound();</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">}</pre>
			<p>In this method, the call is made to <code>GetOrderByIdAsync</code> of <code>orderService</code> in order to fetch the orders based on the <code>id</code> instance passed in. The controller action will return the order <code>id</code> retrieved from <code>OrderService</code>; otherwise, the <code>NotFound</code> action is returned.</p>
			<p>As we have seen, there are two paths for the code flow: </p>
			<ul>
				<li>One path is for when the order is present.</li>
				<li>The other is for when the order is not present. </li>
			</ul>
			<p>With a unit test, we should be able to cover both paths. So, now, the question that arises is, how do we simulate these two cases?</p>
			<p>What we want here is to mock the<a id="_idIndexMarker1368"/> response of <code>OrderService</code>. To mock the response of <code>OrderService</code>, we can leverage <a id="_idIndexMarker1369"/>the <code>Moq</code> library. To leverage Moq, we need to add a NuGet reference to the <code>Moq</code> package to the <code>Packt.ECommerce.Order.UnitTest</code> test pr<a id="_idTextAnchor1863"/>oject.</p>
			<p>Let's add the test method in the <code>O<a id="_idTextAnchor1864"/>rdersControllerTest</code> class, as shown in the following code, to test <code>GetOrderById</code> of <code>OrdersController</code> to validate the case where the order object is returned by <code>OrderService</code>:</p>
			<pre class="source-code">[TestMethod]</pre>
			<pre class="source-code">public async Task When_GetOrdersAsync_with_ExistingOrder_receive_OkObjectResult()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code"><strong class="bold">     var stub = new Mock&lt;IOrderService&gt;();</strong></pre>
			<pre class="source-code"><strong class="bold">    stub.Setup(x =&gt; x.GetOrderByIdAsync(</strong></pre>
			<pre class="source-code"><strong class="bold">      It.IsAny&lt;string&gt;())).Returns(Task.FromResult(new </strong></pre>
			<pre class="source-code"><strong class="bold">      OrderDetailsViewModel { Id = "1" }));</strong></pre>
			<pre class="source-code">    OrdersController testObject = new </pre>
			<pre class="source-code">      OrdersController(stub.Object);</pre>
			<pre class="source-code">    var order = await </pre>
			<pre class="source-code">      testObject.GetOrderById("1").ConfigureAwait(false);</pre>
			<pre class="source-code">    <strong class="bold">Assert.IsType&lt;OkObjectResult&gt;(order, </strong></pre>
			<pre class="source-code"><strong class="bold">      typeof(OkObjectResult));</strong></pre>
			<pre class="source-code">}</pre>
			<p>From the code, we can observe the following:</p>
			<ul>
				<li>Since <code>IOrderService</code> is injected to <code>OrderController</code> via controller injection, we can inject a mocked <code>OrderService</code> to <code>OrderController</code>, which will help us to test all the code paths of <code>OrderController</code> by altering the mock object behavior.</li>
				<li>We leverage the <code>Mock</code> clas<a id="_idTextAnchor1865"/>s to create a<a id="_idIndexMarker1370"/> stub (also known as a mock) for <code>IOrderService</code> and overwrite the <code>GetOrderByIdAsync</code> behavior, as shown<a id="_idTextAnchor1866"/> in the preceding code.</li>
				<li>We c<a id="_idTextAnchor1867"/>reate an instance <a id="_idIndexMarker1371"/>of the <code>Mock</code> object for the <code>IOrderService</code> interface and set up the behavior for <code>GetOrderByIdAsync</code> by calling the <code>Setup</code> method on the <code>Mock</code> object.</li>
				<li>The <code>GetOrderByIdAsync</code> method<a id="_idIndexMarker1372"/> is mocked such that for any parameter value that it receives, the <code>mock</code> object will return the object of <code>OrderDetailsViewModel</code> with <code>Id</code> as <code>1</code>.</li>
				<li>Since we injected the mocked object into <code>OrderService</code> via constructor injection, whenever there is a call to any method in <code>IOrderService</code>, the call will go to the mocked implementation of <code>IOrderService</code>.</li>
				<li>Finally, we assert the test result by validating the type of result that is returned from <code>OrderController</code> to <code>OkObjectResult</code>.</li>
			</ul>
			<p>Now, let's add a test case to validate the behavior, where we receive the <code>NotFound</code> result if the order is not present, as shown in the following code:</p>
			<pre class="source-code">[TestMethod]</pre>
			<pre class="source-code">public async Task When_GetOrdersAsync_with_No_ExistingOrder_receive_NotFoundResult()</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">     var stub = new Mock&lt;IOrderService&gt;();</pre>
			<pre class="source-code"><strong class="bold">     stub.Setup(x =&gt; </strong></pre>
			<pre class="source-code"><strong class="bold">     x.GetOrderByIdAsync(It.IsAny&lt;string&gt;()))</strong></pre>
			<pre class="source-code"><strong class="bold">    .Returns(Task.FromResult&lt;OrderDetailsViewModel&gt;(null));</strong></pre>
			<pre class="source-code">     OrdersController testObject = new </pre>
			<pre class="source-code">       OrdersController(stub.Object);</pre>
			<pre class="source-code">     var order = await testObject</pre>
			<pre class="source-code">       .GetOrderById("1").ConfigureAwait(false);</pre>
			<pre class="source-code"><strong class="bold">     Assert.IsType&lt;NotFoundResult&gt;(order, </strong></pre>
			<pre class="source-code"><strong class="bold">       typeof(Not<a id="_idTextAnchor1868"/>FoundResult));</strong></pre>
			<pre class="source-code">}</pre>
			<p>In this test case, <a id="_idTextAnchor1869"/>we simulated the<a id="_idIndexMarker1373"/> behavior of the order not being present by<a id="_idIndexMarker1374"/> returning a <code>null</code> value from the <code>OrderService</code> stub. This will make the <code>GetOrderById</code> action method of <code>OrdersController</code> return <code>NotFoundResult</code>, and this is validated in the test case.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>OrderService</code> class depends on <code>IHttpClientFactory</code>, <code>IOptions</code>, <code>Mapper</code>, and <code>DistributedCacheService</code>. So, to add a unit test for this, we should be mocking them all. You can take a look at the <code>When_GetOrderByIdAsync_with_ExistingOrder_receive_Order</code> test method in the <code>OrderServiceTest</code> test class of the GitHub code samples for more details.</p>
			<p>In this section, we have seen how to leverage the <code>xUnit</code> framework to create unit tests. There are several other test frameworks available to create unit tests in .NET. Two such frameworks worth mentioning here are MSTest and NUnit. Though there are a few differences in the way the tests are executed between these frameworks, all these frameworks are brilliant and provide features such as mocking and parallel execution. Because of its simplicity and extensibility, xUnit has a little advantage over competing frameworks. We can also write data-driven tests using <code>Theory</code> in xUnit, as shown in the following code snippet:</p>
			<pre class="source-code">[Theory]</pre>
			<pre class="source-code">[InlineData(999, 19.98)]</pre>
			<pre class="source-code">[InlineData(2000, 100)]</pre>
			<pre class="source-code">public void When_ComputeTotalDiscount_with_OrderTotalAmount(double number, double expectedResult)</pre>
			<pre class="source-code">{</pre>
			<pre class="source-code">&lt;&lt;Code removed for brevity&gt;&gt;</pre>
			<pre class="source-code">   OrdersService testObject = new </pre>
			<pre class="source-code">     OrdersService(httpClientFactory, mockOptions, mapper, </pre>
			<pre class="source-code">     mockCacheService.Object);</pre>
			<pre class="source-code">   var result = testObject.ComputeTotalDiscount(number);</pre>
			<pre class="source-code">   Assert.Equal(result, expectedResult);</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code snippet, the test <a id="_idIndexMarker1375"/>method is executed with the test data passed through the <code>InlineData</code> attribute.</p>
			<p>In unit testing, our aim is to test a<a id="_idIndexMarker1376"/> specific class by mocking the behavior of dependent classes. If we test these classes along with other dependent classes, we<a id="_idIndexMarker1377"/> call that <strong class="bold">integration testing</strong>. We write integration tests at various levels: at the lev<a id="_idTextAnchor1870"/>el of a specific module or <a id="_idTextAnchor1871"/>assembly, at the microservice level, or the entire application level.</p>
			<p>Now that we have added unit test cases to our e-commerce solution, in the next section, we wi<a id="_idTextAnchor1872"/><a id="_idTextAnchor1873"/>ll check the code coverage for th<a id="_idTextAnchor1874"/>ese tests.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor1875"/>Code coverage</h2>
			<p>Code coverage is a measure to desc<a id="_idTextAnchor1876"/>ribe how <a id="_idIndexMarker1378"/>much of the code is covered by our test cases. Visual Studio provides a tool to find the code coverage of unit tests. We can run <strong class="bold">Test</strong> | <strong class="bold">Analyze <a id="_idTextAnchor1877"/>Code Coverage</strong> for all tests, as shown here:</p>
			<div><div><img src="img/Figure_15.4_B18507.jpg" alt="Figure 15.4 – The Analyze Code Coverage context option in Text Explorer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4 – The Analyze Code Coverage context option in Text Explorer</p>
			<p>This can also be done from the <strong class="bold">Context</strong> menu in <strong class="bold">Test Explorer</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="bold">Analyze Code Coverage</strong> feature is only available in the Enterprise Edition of Visual Studio. If you are using the Community Edition, you can use the Visual Studio free extension, <a href="https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage">https://marketplace.visualstudio.com/items?itemName=FortuneNgwenya.FineCodeCoverage</a>, to view the code coverage results.</p>
			<p>This will run all the test cases and identify any code blocks that are not tested. We can see the code coverage results in t<a id="_idTextAnchor1878"/>he following <strong class="bold">Code Coverage Results</strong> window:</p>
			<div><div><img src="img/Figure_15.5_B18507.jpg" alt="Figure 15.5 – Visual Studio Code Coverage Results window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5 – Visual Studio Code Coverage Results window</p>
			<p><code>GetOrderByIdAsync</code>, the <a id="_idTextAnchor1880"/>code coverage for that method is <code>GetOrdersAsync</code> is <strong class="bold">0.00%</strong>, as we did not<a id="_idIndexMarker1379"/> have any test cases to test it. The code coverage gives us a good indication of how effective our unit testing is.</p>
			<p>It is recommended to create unit test cases for all the classes in a solution. By adding unit tests to validate all the classes and functionality, a higher percentage of code will be covered by unit test cases. With higher code coverage, we will be able to catch more errors early in the development while making changes to a solution. We should ensure that all the test cases pass before we commit changes. In the next chapter, <a href="B18507_16_Epub.xhtml#_idTextAnchor1932"><em class="italic">Chapter 16</em></a>, <em class="italic">Deploying the Application in Azure</em>, we will learn how to integrate running test cases with Azure DevOps pipelines.</p>
			<p>So far, we have tested individual modules or classes by mocking dependencies and writing unit test cases. It is also important to test functionality after integ<a id="_idTextAnchor1881"/>rating and deploying an entire solution. In t<a id="_idTextAnchor1882"/>he next section, we will learn about how to perform functional testing for our e-commerce application.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Visual Studio's code metrics and code analysis tools are useful to ensure the <a id="_idTextAnchor1883"/>maintainability and<a id="_idIndexMarker1380"/> readability of the code that we write. You can find details on code metrics here: <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022">https://docs.microsoft.com/en-us/visualstudio/code-quality/code-metrics-values?view=vs-2022</a>.</p>
			<p class="callout">For code <a id="_idIndexMarker1381"/>analysis, go here: <a href="https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview">https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/overview</a>.</p>
			<h1 id="_idParaDest-287">Function<a id="_idTextAnchor1887"/>al testing</h1>
			<p>In functional testing, we validate the <a id="_idIndexMarker1382"/>application we have built against the functional requirements. Functional testing is performed by providing some input and asserting the response or output of the application. While performing functional testing, we consider the application as a whole; we are not validating individual internal components.</p>
			<p>Functional testing can be split into<a id="_idIndexMarker1383"/> three tasks: </p>
			<ol>
				<li value="1">Identifying the functionalities of the system to be tested</li>
				<li>Determining the input with the expected output</li>
				<li>Executing these tests to assess whether the system is responding according to expectations </li>
			</ol>
			<p>The execution of functional tests can be done manually by performing the test steps on the application, or we can automate them using tools. The time to market for an application can be drastically reduced by automating functional tests.</p>
			<p>In the next section, we wil<a id="_idTextAnchor1888"/><a id="_idTextAnchor1889"/>l learn about automating functional test cases.</p>
			<h2 id="_idParaDest-288">Automa<a id="_idTextAnchor1890"/>ting functional test cases</h2>
			<p>Executing functional test cases <a id="_idIndexMarker1384"/>manually is still relevant in application testing. However, given the fact of shorter deployment cycles and customers expecting new features quickly, manual testing can be prohibitively time-consuming and inefficient in terms of identifying bugs early. Using automation, we can gain new efficiencies, accelerate the testing process, and improve software quality. There are multiple tools and frameworks available to automate functional test cases.</p>
			<p>In this section, we will learn about the most popular automation framework, <strong class="bold">Selenium</strong>. Let's begin:</p>
			<ol>
				<li value="1">To start with, let's create an <code>MSTest</code> project and name it <code>Packt.ECommerce.FunctionalTest</code>.</li>
				<li>To this project, add the <code>Selenium.WebDriver</code>, <code>Selenium.WebDriver.ChromeDriver</code>, and <code>WebDriverManager</code> NuGet packages. These <a id="_idIndexMarker1385"/>packages are required for us<a id="_idTextAnchor1891"/> to run Selenium tests.</li>
				<li>Let's start with a simple test that validates the title of our e-commerce application. To do this, create a <code>HomePageTest</code> test class and a <code>When_Application_Launched_Title_Should_be_ECommerce_Packt</code> test method, as we did in the <em class="italic">Unit testing</em> section, as shown in the following code:<pre>[TestClass]
public class HomePageTest
{
   [TestMethod]
    public void When_Application_Launched_Title
      _Should_be_ECommerce_Packt()
{
}
}</pre></li>
				<li>To execute our functional tests, we should launch a browser and use that browser to navigate to the e-commerce application. The <code>MSTest</code> framework provides a special function to perform the initialization and cleanup operations required for our tests. We will be creating a Chrome web driver to perf<a id="_idTextAnchor1892"/>orm a functional test.</li>
			</ol>
			<p>Let's go ahead and add the initialize and cleanup methods, as shown in the following <a id="_idIndexMarker1386"/>code:</p>
			<pre>[TestClass]
public class HomePageTest
{
     ChromeDriver _webDriver = null;
     <strong class="bold">[TestInitialize]</strong>
<strong class="bold">public void InitializeWebDriver()</strong>
<strong class="bold">     {</strong>
<strong class="bold">            var d = new DriverManager();</strong>
<strong class="bold">            d.SetUpDriver(new ChromeConfig());</strong>
<strong class="bold">            _webDriver = new ChromeDriver();</strong>
<strong class="bold">     }</strong>
     [TestMethod]
     public void When_Application_Launched_Title
       _Should_be_ECommerce_Packt()
     {
     }
<strong class="bold">     [TestCleanup]</strong>
<strong class="bold">     public void WebDriverCleanup()</strong>
<strong class="bold">     {</strong>
<strong class="bold">            _webDriver.Quit();</strong>
<strong class="bold">     }</strong>
}</pre>
			<p>In the preceding code, the <code>InitializeDriver</code> method is attributed with <code>TestInitialize</code> to notify the framework that this is the test initialization method. In test initialization, we are creating <code>ChromeDriver</code> and initializing the class variable. After the completion of the test case, we should close the browser instance; we do this in the <code>WebDriverCleanup</code> method by calling the <code>Quit</code> method. To notify the test framework that it is the cleanup method, it should b<a id="_idTextAnchor1893"/>e attributed as <code>TestCleanup</code>.</p>
			<ol>
				<li value="5">Now, let's go and add the<a id="_idIndexMarker1387"/> test case to navi<a id="_idTextAnchor1894"/>gate to the e-commerce application and validate the title, as shown in the following code:<pre>[TestMethod]
public void When_Application_Launched_Title_Should_be_ECommerce_Packt()
{
<strong class="bold">     _webDriver.Navigate().GoToUrl("https://localhost:</strong>
<strong class="bold">       44365/");</strong>
<strong class="bold">     Assert.AreEqual("Ecommerce Packt", </strong>
<strong class="bold">       _webDriver.Title);</strong>
}</pre></li>
			</ol>
			<p>Call <code>GoToUrl</code> on our Chrome web driver to navigate to the e-commerce application. Once navigated, we can validate the title of the page by asserting the <code>Title</code> property of the web driver.</p>
			<ol>
				<li value="6">Go ahead and run the test case from <code>When_Application_Launched_Title_Should_be_ECommerce_Pact</code> test case and selecting <strong class="bold">Run</strong>. This will open the Chrome browser and navigate to the specified e-commerce URL, and then it will assert the title of the page. After the execution of the test case, the browser will be closed. We see the results in <strong class="bold">Te<a id="_idTextAnchor1895"/>st Explorer</strong>, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_15.6_B18507.jpg" alt="Figure 15.6 – Solution structure after the creation of the test project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.6 – Solution structure after the creation of the test project</p>
			<ol>
				<li value="7">Now, we will extend the functional test to validate the search function<a id="_idTextAnchor1896"/>ality. To test this functionality, we should enter text in the search box and click on the <strong class="bold">Search</strong> button. Then, check<a id="_idIndexMarker1388"/> the results to see whether the returned test results are only for the searched product.</li>
				<li>Let's automate the t<a id="_idTextAnchor1897"/>est case by adding the <code>When_Searched_For_Item</code> test method, as shown in the following code:<pre>[TestMethod]
public void When_Searched_For_Item()
{
      _webDriver.Navigate().GoToUrl("https://localhost
        :44365/");
      var searchTextBox = 
      _webDriver.FindElement(By.Name("SearchString"));
       searchTextBox.SendKeys("Orange Shirt");
       _webDriver.FindElement(By.Name("searchButton"))
         .Click();
       var items = 
        _webDriver.FindElements(By.ClassName("product-
        description"));
       var invaidProductCout = items.Where(e =&gt; e.Text 
        != "Orange Shirt").Count();
       Assert.AreEqual(0, invaidProductCout);
}</pre></li>
			</ol>
			<p>In this test case, after navigating to the home page, enter the search text in the <code>search</code> string.</p>
			<p>Selenium makes it so easy to write functional tests. We should try to automate all functional test cases, such as user management, adding products to the cart, and placing an order. With all the functional test cases automated, we will be in a better position to test and validate<a id="_idIndexMarker1389"/> the functionality of new releases and maintain the quality of our application. There are other functional testing tools available, such as QTP<a id="_idTextAnchor1898"/> and Visual Studio Coded UI tests.</p>
			<p>We have looked at functional testing, which validates the functionality of an application. It is equally important to assess the responsiveness of an application to see how it responds to a particular load. In the next section, we will learn how we can perform performance testing on our e-commerce application. We can leverage automated functional test cases to perform BVT or re<a id="_idTextAnchor1899"/>gression testing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Refer to the documentation to<a id="_idIndexMarker1390"/> explore more about Selenium<a id="_idTextAnchor1900"/><a id="_idTextAnchor1901"/> testing: <a href="https://www.selenium.dev/documentation/en/">https://www.selenium.dev/documentation/en/</a>.</p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor1903"/>Load testing</h1>
			<p>Users expect an application to<a id="_idIndexMarker1391"/> respond quickly to their actions. Any sluggishness in response will lead to user frustration, and ultimately, we will lose them. Even if an application works fine under a normal load, we should know how our application behaves when there is a sudden peak in demand and be prepared for it.</p>
			<p>The main goal of load testing is not to find bugs but to eradi<a id="_idTextAnchor1904"/>cate the performance bottlenecks of the application. A load test is done to provide stakeholders with information about the speed, scalability, and stability of their application. In the next section, <a id="_idTextAnchor1905"/><a id="_idTextAnchor1906"/>we will learn how to perform a load test using JMe<a id="_idTextAnchor1907"/>ter.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor1908"/>Load testing with JMeter</h2>
			<p><strong class="bold">JMeter</strong> is an open source testi<a id="_idTextAnchor1909"/>ng tool <a id="_idIndexMarker1392"/>built by the Apache Software Foundation. It is one of the most popular tools available to perform load testing. JMeter can simulate a heavy load on an application by creating virtual concurrent users of a web server.</p>
			<p>Let's go ahead and create a <a id="_idIndexMarker1393"/>JMeter load test for our e-commerce application.</p>
			<p>To learn how to use JMeter to do a load test, we will be creating a test with two home pages and product search pages. Try the following steps to create the load test:</p>
			<ol>
				<li value="1">Launch Apache JMeter from th<a id="_idTextAnchor1910"/>e download location. We will see the window as follo<a id="_idTextAnchor1911"/>ws:</li>
			</ol>
			<div><div><img src="img/Figure_15.7_B18507.jpg" alt="Figure 15.7 – Apache JMeter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.7 – Apache JMeter</p>
			<ol>
				<li value="2">Add a threa<a id="_idTextAnchor1912"/>d group by right-clicking on <strong class="bold">Test Plan</strong> in the left pane and selecting <strong class="bold">Add</strong> | <strong class="bold">Threads (Users)</strong> | <strong class="bold">Thread Group</strong>. The thread group defines the pool of users that will execute the test case against our application. With it, we can configure the number of users <a id="_idIndexMarker1394"/>simulated, the time to start all the users, and the number of times to<a id="_idIndexMarker1395"/> perform the test.</li>
				<li>Let's name the thread group <code>Load and Query Products</code> and set the number of users to <code>30</code>. Set <code>5</code> seconds, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/Image87474.jpg" alt="Figure 15.8 – Adding a thread group in Apache JMeter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.8 – Add<a id="_idTextAnchor1914"/>ing a thread group in Apache JMeter</p>
			<p>This will simulate a user<a id="_idTextAnchor1915"/> load of <code>30</code> within <code>5</code> seconds. Using <strong class="bold">Thread Group</strong>, we can also control the number of times the test should run.</p>
			<ol>
				<li value="4">To add the test request, right-click on <strong class="bold">Thread Group</strong> and select <strong class="bold">Add</strong> | <strong class="bold">Sampler</strong> | <strong class="bold">HTTP Request</strong>.</li>
			</ol>
			<p>Let's set <code>https</code>, <code>localhost</code>, and <code>44365</code> (the port number of the locally running e-commerce portal). Name thi<a id="_idTextAnchor1916"/>s test <code>Home Page</code>, as shown in the following screenshot:</p>
			<div><div><img src="img/Image87486.jpg" alt="Figure 15.9 – Adding the Home Page HTTP request in JMeter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.9 – Adding <a id="_idTextAnchor1917"/>the Home Page HTTP request in JMeter</p>
			<p><a id="_idTextAnchor1918"/>Let's also add one more HTTP<a id="_idIndexMarker1396"/> request sampler to get the details of a specific product. For <a id="_idIndexMarker1397"/>this request, set the <code>productId</code> query parameter as <code>Cloth.3</code> and <code>productName</code> <a id="_idTextAnchor1919"/>as <code>Orange%20Shirt</code>, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_15.10_B18507.jpg" alt="Figure 15.10 – Adding the Product Details page HTTP request in JMeter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10 – Adding the Pr<a id="_idTextAnchor1920"/>oduct Details page HTTP request in JMete<a id="_idTextAnchor1921"/>r</p>
			<ol>
				<li value="5">Save this test plan by clicking <a id="_idIndexMarker1398"/>on the <code>ECommerce</code>.</li>
				<li>To view the results, we<a id="_idIndexMarker1399"/> should add a listener to this test. Right-click on the test group and select <strong class="bold">Add</strong> | <strong class="bold">Listener</strong> | <strong class="bold">View Results in Table</strong>.</li>
				<li>Once the listener is added, go ahead and run the test by selecting <strong class="bold">Run</strong> | <strong class="bold">Start</strong>.</li>
				<li>After the test run is complete, you will see the results as shown in the following screensh<a id="_idTextAnchor1922"/>ot. This will give us the response time for each request:</li>
			</ol>
			<div><div><img src="img/Figure_15.11_B18507.jpg" alt="Figure 15.11 – Test results table in JMeter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11 – Test results table in JMeter</p>
			<p>There are multiple listeners available in JMeter to view the results, such as <strong class="bold">Summary report</strong> and <strong class="bold">Graph results</strong>, which will give another representation of the test res<a id="_idTextAnchor1923"/>ults. We can configure different kinds of<a id="_idIndexMarker1400"/> sampl<a id="_idTextAnchor1924"/>ers easily with JMeter, as well as configuring requests with different HTTP methods<a id="_idIndexMarker1401"/> and dynamic tests, where requests are dependent on another API's response. Once a test plan is in JMeter, we can leverage the JMeter command-line utility to run it from multiple data centers to simulate a load across geographies and collate the results.</p>
			<p>The flexibility that JMeter provides, along with its extensive documentation, makes it the most-used performance testing tool. JMeter can also be leveraged to perform functional testing.</p>
			<p>We can use the Azure Load Testing service to generate high-scale load using the JMeter test that we created in this section. The infrastructure required to execute your JMeter script and load test your application is abstracted by Azure Load Testing. Azure Load Testing gathers precise resource data for Azure-based applications to assist you in identifying performance bottlenecks across your Azure application components.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing this book, Azure Load Testing is in preview. More details about load testing can be found in the Azure documentation at <a href="https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing">https://docs.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing</a>. It is recommended to run a load test with<a id="_idIndexMarker1402"/> one and a half to two times the anticipated load. After running the performance test, it is<a id="_idIndexMarker1403"/> recommended to use <strong class="bold">Application Insights</strong> to analyze the server response time of requests, how dependent APIs are responding<a id="_idIndexMarker1404"/> during the load conditions, and more importantly, any failures that occur while the test is in progress.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is recommended to run automated tests using Azure DevOps pipelines. Use<a id="_idTextAnchor1925"/> the documentation to<a id="_idIndexMarker1405"/> see how to integrate tests with an Azure DevOps pipeline:</p>
			<p class="callout">Selenium: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/pipelines/test/continuous-test-selenium?view=azure-devops</a></p>
			<p class="callout">JMet<a id="_idTextAnchor1926"/><a id="_idTextAnchor1927"/>er<a id="_idIndexMarker1406"/> tests: <a href="https://github.com/Azure-Samples/jmeter-aci-terraform">https://github.com/Azure-Samples/jmeter-aci-terraform</a></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor1928"/>Summary</h1>
			<p>In this chapter, we explored a very important aspect of software development: testing. We have learned about the different kinds of testing and the stages at which we should be using them in the SDLC.</p>
			<p>We learned about the concepts of unit testing and how to focus our testing on specific calls by mocking dependencies using the <code>Moq</code> framework. We were also introduced to the creation of automated functional tests using Selenium to test the functionality of our e-commerce application before releasing it to production.</p>
			<p>Toward the end, we learned about JMeter, which is the most-used tool for performing load testing.<a id="_idTextAnchor1929"/><a id="_idTextAnchor1930"/> The next chapter will focus on deploying applications in Azure.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor1931"/>Questions</h1>
			<ol>
				<li value="1">True or false? We should only start to think about testing an application after the completion of its development.</li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: b</strong></p>
			<ol>
				<li value="2">Which of the following is a kind of software testing?</li>
			</ol>
			<p>a. Security testing</p>
			<p>b. Functional testing</p>
			<p>c. Accessibility testing</p>
			<p>d. All of the above</p>
			<p><strong class="bold">Answer: d</strong></p>
			<ol>
				<li value="3">True or false? A higher code coverage percentage for unit tests is desirable to achieve a shorter time to market. </li>
			</ol>
			<p>a. True</p>
			<p>b. False</p>
			<p><strong class="bold">Answer: a</strong></p>
		</div>
	</body></html>