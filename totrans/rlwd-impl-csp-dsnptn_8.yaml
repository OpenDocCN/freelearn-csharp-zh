- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Now You Know Some Patterns, What Next?
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些图案，接下来是什么？
- en: 'Over the course of writing this book, I asked a few friends, colleagues, and
    at least one of my many archenemies for input. Invariably, they would ask about
    a pattern they had studied in school or used on a project wondering why it wasn’t
    included in this wonderful tome. The short answer to their question: the goal
    of the book is to focus on patterns that you can add quickly to your coding arsenal.
    Patterns that have a quick return on your investment of time and money.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的过程中，我向几位朋友、同事以及至少一位我的许多死敌征求了意见。他们无一例外地会询问他们在学校学习或在一个项目中使用的某个图案，想知道为什么它没有被包括在这本精彩的著作中。对他们问题的简短回答是：本书的目标是专注于你可以快速添加到你的编码工具库中的图案。这些图案能快速回报你的时间和金钱的投资。
- en: Many of the patterns I chose to omit are very similar to the ones I included
    in this book. The patterns that made the cut were strictly my own preferences.
    These patterns have proven the most useful to me during my 25 years of experience
    as a celebrated and award-winning software engineer using C#.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择省略的许多图案与我在这本书中包含的图案非常相似。被选中的图案完全是我个人的偏好。这些图案在我作为获奖的软件工程师使用C#的25年经验中证明是最有用的。
- en: 'By the end of this chapter, we will have covered the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，我们将涵盖以下主题：
- en: The GoF patterns we didn’t cover will be discussed very briefly.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有涵盖的GoF图案将简要讨论。
- en: Patterns outside of **object-oriented programming** (**OOP**). There are patterns
    that are not applicable to OOP—for example, patterns designed to describe database
    or network structure.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）之外的图案。有一些图案不适用于OOP——例如，设计用来描述数据库或网络结构的图案。'
- en: How to create your own patterns. The GoF book documents a format for creating
    your own patterns.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建你自己的图案。GoF书为创建你自己的图案提供了一个格式。
- en: Please note that I am only using diagrams. There is no code for this chapter.
    Likewise, there aren’t any technical requirements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我仅使用图表。本章没有代码。同样，也没有任何技术要求。
- en: Patterns we didn’t discuss
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们没有讨论的图案
- en: I didn’t cover all 23 patterns in the GoF book. I only covered about half. A
    number of factors went into deciding what to include and what to leave for a tacit
    discussion in this chapter. Some of the patterns are more troublesome than they
    are worth. The **Memento pattern** solves a problem that can easily be solved
    with a few .NET features. Some patterns were not included because they are very
    similar to another pattern we covered. Some are patterns you are never likely
    to need. The **Interpreter pattern** is only useful if you are inventing a new
    programming language. This is rarely done anymore owing to the popularity of **domain-specific
    languages** (**DSLs**). Tools exist for the construction of DSLs that preclude
    the need for the Interpreter pattern.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有涵盖GoF书中的所有23个图案。我只涵盖了一半左右。许多因素都影响了决定包含哪些图案以及在本章中隐含讨论哪些图案。有些图案比它们的价值更麻烦。**备忘录模式**解决了一个可以用几个.NET特性轻松解决的问题。有些图案没有被包括，因为它们与我们覆盖的另一个图案非常相似。有些是你可能永远不会需要的图案。**解释器模式**只有在你在发明一种新的编程语言时才有用。由于**领域特定语言**（**DSLs**）的流行，这很少再做了。存在用于构建DSL的工具，这排除了需要解释器模式的需求。
- en: 'Here are the patterns from the original GoF book we didn’t cover in this book:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是原始GoF书中我们没有在这本书中涵盖的图案：
- en: Prototype
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Adapter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器
- en: Flyweight
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元
- en: Chain of Responsibility
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Proxy
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理
- en: Interpreter
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Mediator
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中介者
- en: Memento
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: State
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Template Method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: I’ll discuss each of these patterns at a high level in the following sections.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在以下章节中从高层次讨论这些图案。
- en: Prototype
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: Making copies of objects can be tricky but if your object is flat, with no composition
    and just a few fields, it’s no problem at all. However, making a deep copy of
    a complicated object that was built using composition and inheritance—and it’s
    got a few layers of each—is harder. *Deep copying* refers to making an exact copy
    of an object from the highest level to the lowest level. The first step is to
    instantiate a new object from the same class. Then, you need to copy the values
    from all the properties and fields into the new object. You can only do this if
    every field or property in the object you want to copy is `public`. This includes
    all the objects used to compose the object you’re copying. Even if you manage
    to do this, the copy you create is subsequently of the dependent class used to
    make the copy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的复制可能很棘手，但如果你的对象是平的，没有组成，只有几个字段，那就没问题了。然而，复制一个使用组合和继承构建的复杂对象的深度副本——它有每一层的几个层次——就更加困难了。*深度复制*指的是从最高层到最低层对对象进行精确复制。第一步是从相同的类中实例化一个新对象。然后，你需要将所有属性和字段中的值复制到新对象中。只有在你想要复制的对象中的每个字段或属性都是
    `public` 的情况下，你才能这样做。这包括用于组成你正在复制对象的全部对象。即使你设法做到了这一点，你创建的副本也将是用于复制所使用的依赖类。
- en: 'Let’s look at it another way. You’re beginning a project with the *Transylvanian
    Historical Society*. Your job is to copy, brick by brick, a castle owned by one
    Vlad von Dracula. The castle’s copy will be a museum in another town. There’s
    a catch: the castle’s drawbridge is up and you’re not allowed inside.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从另一个角度来看。你开始了一个与 *Transylvanian Historical Society* 的项目。你的任务是逐块复制由一个名为 Vlad
    von Dracula 的人拥有的城堡。城堡的复制品将是一个位于另一个城镇的博物馆。有一个问题：城堡的吊桥是升起的，你不被允许进入。
- en: It isn’t hard to make a copy of the outside parts of the castle you can see,
    but it is impossible to duplicate the interior—especially that creepy crypt in
    the basement. That is, unless you had inside help. A man named Renfield offers
    his help. He has full knowledge of the castle’s interior because he never leaves
    its walls. If you can get Renfield to help you from the inside, making a copy
    of the castle isn’t going to be difficult.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 复制城堡的外部部分并不难，但复制内部——尤其是地下室里那个令人毛骨悚然的墓穴——是不可能的。除非你有内部帮助。一个名叫 Renfield 的人提供了帮助。因为他从未离开过城堡的墙壁，所以他完全了解城堡的内部。如果你能让
    Renfield 从内部帮助你，复制城堡就不会那么困难。
- en: Prototype is a Creational pattern that enables you to copy an object brick by
    brick. It works by delegating the copy job to the object itself. In short, it’s
    an inside job. The copy operation itself is called **cloning**. An object capable
    of cloning itself is called a prototype.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Prototype 是一种创建型模式，它使你能够逐块复制对象。它通过将复制任务委托给对象本身来实现。简而言之，这是一项内部工作。复制操作本身被称为 **克隆**。能够自我克隆的对象被称为原型。
- en: 'Have a look at the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图示：
- en: '![Figure 8.1: The Prototype pattern is used when you want to be able to make
    deep copies of an object. ](img/B18605_Figure_8.1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：当你想要能够对对象进行深度复制时，使用 Prototype 模式。](img/B18605_Figure_8.1.jpg)'
- en: 'Figure 8.1: The Prototype pattern is used when you want to be able to make
    deep copies of an object.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：当你想要能够对对象进行深度复制时，使用 Prototype 模式。
- en: 'Let’s review the Prototype pattern diagram by the numbers displayed on it,
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据图上的数字来回顾一下 Prototype 模式图，如下所示：
- en: The `Prototype` interface defines the method that will perform the cloning operation.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Prototype` 接口定义了执行克隆操作的方法。'
- en: The `ConcretePrototype` implements the Prototype interface and provides the
    implementation of the `Clone` method. If your object structure is complicated,
    this method is positioned to be able to see everything inside the object where
    it lives. This method might be refactored so that its name is *Renfield*. He’s
    the guy inside the castle who can help you clone it. The `Clone` method likewise
    can provide you with details needed to copy the object without losing any blood.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ConcretePrototype` 实现了 Prototype 接口，并提供了 `Clone` 方法的实现。如果你的对象结构复杂，这个方法定位为能够看到对象内部的所有内容。这个方法可能被重构，使其名称变为
    *Renfield*。他是城堡内部可以帮助你克隆的人。`Clone` 方法同样可以提供复制对象所需的所有细节，而不会损失任何数据。'
- en: The Prototype pattern can be very useful if you need a bunch of classes copied
    from a small set of objects defined by concrete subclasses. Think back to our
    bicycle factory. Let’s say there are half a dozen bicycle configurations that
    are very popular. Let’s further presume that Phoebe’s robots need a new instance
    of the `bicycle` object in order to manufacture a physical bicycle. In this case,
    a `bicycle` object is instantiated, the bicycle is manufactured, and the object
    is destroyed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从由具体子类定义的一小套对象中复制大量类，原型模式可以非常有用。回想一下我们的自行车工厂。假设有几种非常受欢迎的自行车配置。进一步假设菲比的机器人需要一个新的`bicycle`对象来制造一辆实物自行车。在这种情况下，会实例化一个`bicycle`对象，制造自行车，然后销毁该对象。
- en: It would make sense in these circumstances to make a collection of “master copies”
    of the popular bicycle models and configurations. These masters could be cloned
    instead of the software needing to run an expensive builder method to generate
    a new bicycle conforming to a commonly ordered configuration.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，制作一组“主副本”的流行自行车型号和配置是有意义的。这些主副本可以被克隆，而不是软件需要运行昂贵的构建方法来生成符合常见配置的新自行车。
- en: Adapter
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: I keep two sets of wrenches in the back of my Jeep. One set is a common 3/8”
    mechanical ratchet set. One time I was driving home through Oklahoma from vacation
    in the Ozark mountain range. We had opted to take a scenic route by driving the
    back roads through a forested area of the state. We were cruising along, and I
    ran over a board in the middle of the road. It was unavoidable. I immediately
    switched my car’s display to the tires, and over the course of a few miles, I
    could see the pressure in one tire gradually decreasing. I had a nail in one of
    my tires. I pulled over at the first opportunity and found some level ground so
    that I could safely jack my car and change the tire.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的吉普车后备箱里放了两套扳手。一套是常见的3/8英寸机械棘轮扳手套装。有一次我从奥扎克山脉的度假地开车回家经过俄克拉荷马州。我们选择了一条风景优美的路线，通过州内的森林小道行驶。我们正开着车，突然在路中间压到了一块木板。这是不可避免的。我立即切换了汽车显示屏到轮胎，在接下来的几英里里，我看到一个轮胎的压力逐渐下降。我的一个轮胎里扎了钉子。我在第一个机会停车，找到了一块平坦的地面，这样我就可以安全地升起我的车并更换轮胎。
- en: My wife and two girls were with me. We had to take all the luggage out of the
    car to get to the jack. If you’ve ever tried to change a tire with factory-supplied
    tools, then you understand I was hot, frustrated, and stuck on the side of the
    road. A pickup truck pulled up behind us, and the driver, wearing a cowboy hat,
    jeans, and a t-shirt, offered to help us out. I could see an array of expensive
    power tools in the back of his truck. I accepted his offer. We loosened the tire’s
    lug nuts with his power wrench, and in minutes, we were back on the road. I vowed
    the first thing I’d do when I got home was to get me the same kit he had.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我的妻子和两个女儿和我在一起。我们必须把所有的行李从车里拿出来才能到达千斤顶。如果你曾经尝试过用工厂提供的工具换轮胎，那么你就明白我当时有多热、多沮丧，而且被困在路边。一辆皮卡停在了我们后面，司机戴着牛仔帽、牛仔裤和T恤，主动提出要帮助我们。我能看到他车后有一系列昂贵的电动工具。我接受了他的提议。我们用他的电动扳手松开了轮胎的螺母，几分钟内我们就回到了路上。我发誓回到家后第一件事就是买一套和他一样的工具箱。
- en: 'The minute I brought my new power wrench home, I wanted to use it on more than
    just changing a tire. After all, flat tires don’t happen all the time. I wanted
    to use it with my other ratchet set. Unfortunately, the 3/8” sockets from my other
    set don’t work with the ½” power tool. If you’re not familiar with these tools,
    check out the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我一回到家，就迫不及待地想用我的新电动扳手做更多的事情，而不仅仅是换轮胎。毕竟，爆胎并不是经常发生。我想用它来配合我的另一套棘轮扳手。不幸的是，我另一套工具中的3/8英寸套筒不能与½英寸的电动工具配合使用。如果你不熟悉这些工具，可以查看以下截图：
- en: '![Figure 8.2:  My power impact wrench can only use the socket wrench sockets
    if I use an adapter. ](img/B18605_Figure_8.2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：我的电动冲击扳手只有在使用适配器的情况下才能使用套筒扳手。](img/B18605_Figure_8.2.jpg)'
- en: Figure 8.2:  My power impact wrench can only use the socket wrench sockets if
    I use an adapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：我的电动冲击扳手只有在使用适配器的情况下才能使用套筒扳手。
- en: The power wrench is like a normal wrench, except that the drive square is bigger
    on the power tool. The drive square is the part of the tool where you attach the
    sockets, which have a square hole in them. There’s no way a 3/8” socket can fit
    onto a ½” drive square. That is, it didn’t fit until I found an adapter. An adapter
    lets me use one interface—such as a 3/8” socket—with a different interface, such
    as the drive square of a ½” power socket tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 动力扳手就像一个普通的扳手，只不过动力工具上的驱动方头更大。驱动方头是工具上你安装套筒的部分，套筒上有方孔。3/8英寸的套筒根本无法安装在½英寸的驱动方头上。也就是说，直到我找到了适配器，它才适配。适配器让我可以使用一个接口——比如3/8英寸的套筒——与另一个接口，比如½英寸动力套筒工具的驱动方头。
- en: 'The Adapter pattern does the same thing for your classes. An adapter implementation
    allows two classes with different interfaces to be used together. If my wrench
    problem were expressed in **Unified Modeling Language** (**UML**), it might look
    like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式对你的类也做了同样的事情。适配器实现允许具有不同接口的两个类一起使用。如果我的扳手问题用**统一建模语言**（**UML**）来表示，可能看起来像这样：
- en: '![Figure 8.3: A class structure following the Adapter pattern is used to allow
    a class following one interface to work seamlessly with a different interface.
    ](img/B18605_Figure_8.3.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：遵循适配器模式的类结构用于允许遵循一个接口的类与不同接口无缝工作。](img/B18605_Figure_8.3.jpg)'
- en: 'Figure 8.3: A class structure following the Adapter pattern is used to allow
    a class following one interface to work seamlessly with a different interface.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：遵循适配器模式的类结构用于允许遵循一个接口的类与不同接口无缝工作。
- en: 'Let’s break this down, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样分解一下：
- en: The power wrench is the client and we need a way to attach the smaller 3/8”
    sockets to the ½” drive square. To do this, we need an adapter.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动力扳手是客户端，我们需要一种方法将较小的3/8英寸套筒连接到½英寸驱动方头上。为此，我们需要一个适配器。
- en: The adapter should be described with an interface to prevent tight coupling.
    This interface calls for an `AttachSocket` method, which is implemented in the
    concrete adapter class.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配器应该用接口来描述，以防止紧密耦合。这个接口要求一个`AttachSocket`方法，该方法在具体适配器类中实现。
- en: The concrete adapter class implements the interface and contains a method that
    accepts something from the client that can be adapted.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体适配器类实现了接口，并包含一个接受客户端可以适配的东西的方法。
- en: The `ThreeEighthsInchSocket` class represents the incompatible interface you’d
    like to connect to your client.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ThreeEighthsInchSocket`类代表你想要连接到客户端的不兼容接口。'
- en: In short, the adapter implements the client interface—`ISocketWrenchAdapter`
    in this example. It also wraps the class with which we are interfacing—in this
    case, `ThreeEighthsInchSocket`. The adapter receives the drive square from the
    power tool when it calls the `AttachSocket` method in the adapter class. The internals
    of this method perform the logical operations needed to convert that input into
    something the adaptee can use. In software parlance, the client would be making
    a call to the adapter class. The method called would provide conversion logic
    that converts what was passed into the method so as to be compatible with the
    adaptee.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，适配器实现了客户端接口——在这个例子中是`ISocketWrenchAdapter`。它还包装了我们与之交互的类——在这种情况下，是`ThreeEighthsInchSocket`。适配器在适配器类中调用`AttachSocket`方法时，从动力工具接收驱动方头。这个方法内部的逻辑操作将输入转换为适配者可以使用的东西。在软件术语中，客户端会调用适配器类。被调用的方法会提供转换逻辑，以便将传递给方法的内容转换为与适配者兼容。
- en: This can be a very useful pattern when you need to leverage third-party or legacy
    with new work.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要利用第三方或遗留系统与新工作结合时，这个模式可以非常有用。
- en: Flyweight
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flyweight
- en: Have you ever had a thought that keeps you awake at night? Or maybe you have
    a thought that wakes you up? You’re sound asleep and then you awake with a jolt.
    Your half-slumbering brain just figured out what’s wrong with line 37.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有想过某个想法让你整夜无法入睡？或者也许你有一个让你醒来的想法？你正睡得很香，然后突然醒来。你的半睡半醒的大脑刚刚想出了第37行的问题所在。
- en: Late one night in a fit of heuristic frenzy, Kitty wonders what would happen
    if one day, demand for Bumble Bikes exploded. What if the small company was inundated
    with thousands of orders? The robotic manufacturing system Phoebe built instantiates
    a bicycle object each time it builds a bicycle. Each bicycle object takes up space
    in the server’s **random-access memory** (**RAM**). Kitty decides to try a simulation
    using a development server. After a few load tests, she determines she can load
    1,000 instances of a bicycle object complete with the bridged painter system.
    Once the object count goes above 1,000 concurrent objects, the server starts to
    slow down. Once she reaches 2,000 objects in memory, the system nearly grinds
    to a halt and is unusable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个晚上的启发式狂热中，Kitty想知道如果有一天，Bumble Bikes的需求爆炸了会怎样。如果这家小公司被数千个订单淹没怎么办？Phoebe构建的机器人制造系统每次构建自行车时都会实例化一个自行车对象。每个自行车对象都会占用服务器**随机存取存储器**（**RAM**）的空间。Kitty决定尝试使用开发服务器进行模拟。经过几次负载测试后，她确定她可以加载1,000个带有桥接画家系统的自行车对象实例。一旦对象计数超过1,000个并发对象，服务器开始变慢。一旦她在内存中达到2,000个对象，系统几乎完全停止运行，变得不可用。
- en: One obvious solution to this problem is to order more RAM for the server. Of
    course, this makes it a hardware problem. We are software developers. Maybe there
    is a way to solve this problem by strictly using software patterns. Maybe a small
    adjustment will prevent us from having to ask the pointy-haired boss for several
    thousand dollars in upgrades.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的明显方法是为服务器订购更多的RAM。当然，这使其成为硬件问题。我们是软件开发者。也许有一种方法可以通过严格使用软件模式来解决这个问题。也许一个小调整可以防止我们不得不向那个爱拍马屁的老板要求几千美元的升级。
- en: The Flyweight pattern is used to move some of the shared elements of each object’s
    state into one shared object. Sometimes, you can shift a large amount of data
    out of memory and into one shared object. You see this anywhere you have a high
    object count. For example, if you use C# with Unity to develop game software,
    your game might have hundreds, or even thousands, of enemies. Maybe you’re leveraging
    a homemade particle system with thousands of shiny moving particles, or maybe
    you’re doing a factory simulation where thousands of bicycles are being manufactured
    by a small cadre of robots.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 享元模式用于将每个对象状态的一些共享元素移动到一个共享对象中。有时，你可以将大量数据从内存中移出并放入一个共享对象中。你在任何有高对象计数的地方都会看到这一点。例如，如果你使用C#与Unity开发游戏软件，你的游戏可能会有数百甚至数千个敌人。也许你正在利用一个自制的粒子系统，有数千个闪亮的移动粒子，或者也许你正在进行一个工厂模拟，数千辆自行车由一小批机器人制造。
- en: 'Consider the following diagram:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示：
- en: '![Figure 8.4: The Flyweight pattern entails shifting duplicated state variables
    into a separate object that can be shared to reduce memory footprint.  ](img/B18605_Figure_8.4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：享元模式涉及将重复的状态变量移入一个单独的对象中，以便可以共享以减少内存占用。](img/B18605_Figure_8.4.jpg)'
- en: 'Figure 8.4: The Flyweight pattern entails shifting duplicated state variables
    into a separate object that can be shared to reduce memory footprint.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：享元模式涉及将重复的状态变量移入一个单独的对象中，以便可以共享以减少内存占用。
- en: 'Let’s break it down by the numbers in the diagram, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据图中的数字来分解它，如下所示：
- en: Here, we have a `Bicycle` class with all its parts. For our simulation, we’re
    just going to make road bikes. The ordering system lets customers customize the
    bicycle frame with a special paint job, or pick from one of the standard colors.
    The seat can also be swapped out for one of several models. However, the rest
    of the properties offer no customization options. They will be the same for every
    road bike we build.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有一个包含所有部件的`Bicycle`类。对于我们的模拟，我们只将制造公路自行车。定序系统允许客户使用特殊的喷漆定制自行车车架，或者从标准颜色中选择一种。座椅也可以更换为几种型号中的一种。然而，其余的属性没有提供定制选项。它们将是我们制造的每辆公路自行车都相同的。
- en: Now, watch what happens if we shift the parts of the state that don’t vary into
    a separate class. Here, our `Bicycle` class only contains those properties that
    might be different between each bicycle we make.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，看看如果我们把那些不变化的状态部分移入一个单独的类会发生什么。在这里，我们的`Bicycle`类只包含我们制造的每辆自行车之间可能不同的那些属性。
- en: The elements of state that are common for all objects are called the extrinsic
    state and are represented in the `BicycleFlyweightCommonState` class. It’s a bit
    of a mouthful, but I wanted to be sure you recognized which part was the flyweight.
    We can make one instance of this class and share it with all 1 million of the
    `Bicycle` classes in Phoebe’s simulation.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有对象共有的状态元素被称为外显状态，并在`BicycleFlyweightCommonState`类中表示。这个名字有点长，但我想要确保你能识别出哪部分是轻量级。我们可以创建这个类的一个实例，并与Phoebe模拟中的所有一百万个`Bicycle`类共享。
- en: Let’s say the `Bicycle` class weighs in at 16 **kilobytes** (**KB**) of memory
    usage upon instantiation. If Phoebe wants to generate 1 million of them, that’s
    going to consume 16 **gigabytes** (**GB**) of memory. Once we shift the repeated
    state to the flyweight object, we chop out 14 KB for one object. Since we only
    instantiate it once, the memory footprint comprises only the intrinsic state.
    We instantiate 1 million bicycle objects at 2 KB, or total consumption is 2 GB
    plus the negligible 14 KB for a single instance of the extrinsic state in the
    flyweight class. That’s a nearly 8X reduction! I don’t know about you, but I would
    strut for a week if I could reduce my software’s memory footprint by 8X just by
    rearranging some classes!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`Bicycle`类在实例化时占用16 **千字节**（**KB**）的内存。如果Phoebe想要生成一百万个，那将消耗16 **千兆字节**（**GB**）的内存。一旦我们将重复的状态转移到轻量级对象中，我们就可以为单个对象节省14
    KB。由于我们只实例化一次，内存占用只包括内在状态。我们以2 KB的实例化1百万个自行车对象，总消耗是2 GB加上轻量级类中单个外显状态的微不足道的14 KB。这几乎减少了8倍！我不知道你怎么样，但如果我们能通过重新排列一些类来将软件的内存占用减少8倍，我会高兴一周！
- en: Chain of Responsibility
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 责任链
- en: The success of Bumble Bikes isn’t owed entirely to Kitty’s designs nor Phoebe’s
    brilliant robotics. Bumble Bikes also has a focus on quality and **quality assurance**
    (**QA**) is completely automated. A system of cameras does a series of inspections
    using **artificial intelligence** (**AI**) via OpenCV. The inspection begins with
    the frame, then moves to the handlebars, the drivetrain components, the brakes,
    the wheels, the tires, and finally the seat. The logic used by the AI to perform
    the inspection is not contained in a single method. That would violate the **single-responsibility
    principle** (**SRP**). Instead, each inspection’s logic is encapsulated within
    a separate method for each inspection. The inspection happens sequentially, beginning
    with the frame. If any of the inspections fail, the bicycle is flagged as a defect
    and set aside for remediation performed by a human bicycle mechanic.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Bumble Bikes的成功并不完全归功于Kitty的设计或Phoebe的卓越机器人技术。Bumble Bikes还注重质量，**质量保证**（**QA**）是完全自动化的。一套摄像头通过OpenCV使用**人工智能**（**AI**）进行一系列检查。检查从车架开始，然后移动到把手，传动部件，刹车，车轮，轮胎，最后是座椅。AI执行检查所使用的逻辑不包含在单个方法中。那样会违反**单一职责原则**（**SRP**）。相反，每个检查的逻辑都封装在每个单独的检查方法中。检查是顺序发生的，从车架开始。如果任何检查失败，自行车将被标记为缺陷，并放置一旁，由人类自行车技师进行修复。
- en: 'You can see an overview of the QA checks in the following diagram:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图中看到QA检查的概述：
- en: '![Figure 8.5: Sequential quality assurance checks on a bicycle are one example
    of Chain of Responsibility.  ](img/B18605_Figure_8.5.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：自行车上的顺序质量保证检查是责任链的一个例子。](img/B18605_Figure_8.5.jpg)'
- en: 'Figure 8.5: Sequential quality assurance checks on a bicycle are one example
    of Chain of Responsibility.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：自行车上的顺序质量保证检查是责任链的一个例子。
- en: This sequentially ordered set of inspections uses the Chain of Responsibility
    pattern. If any of the inspections fail, the remainder of the inspections is not
    run. This is how Toyota makes cars. If a defect is found on the assembly line,
    everything stops until the problem is corrected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序排列的检查集使用责任链模式。如果任何检查失败，剩余的检查将不会执行。这就是丰田制造汽车的方式。如果在装配线上发现缺陷，一切都会停止，直到问题得到纠正。
- en: 'The pattern itself takes on the form seen here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 模式本身采取的形式如下：
- en: '![Figure 8.6: The Chain of Responsibility pattern is used anytime you need
    a stateful sequence of events.  ](img/B18605_Figure_8.6.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：责任链模式在需要状态化的事件序列时被使用。](img/B18605_Figure_8.6.jpg)'
- en: 'Figure 8.6: The Chain of Responsibility pattern is used anytime you need a
    stateful sequence of events.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：责任链模式在需要状态化的事件序列时被使用。
- en: 'Let’s break it down, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式分解它：
- en: An interface, usually called `IHandler`, defines two methods. The `Handle` method
    defines the method signature for the implementation of the inspection logic. The
    `Next` method allows us to move to the next inspection, assuming the current step
    passes.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个接口，通常称为`IHandler`，定义了两个方法。`Handle`方法定义了实现检查逻辑的方法签名。`Next`方法允许我们在当前步骤通过的情况下移动到下一个检查。
- en: An abstract handler class defines the next handler, which is a common property
    among the concrete classes.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象处理类定义了下一个处理程序，这是具体类之间的一个共同属性。
- en: The concrete classes inherit from `Handler` and implement their inspection logic
    with the `Handle` method, which overrides the base class method. Similarly, the
    `Next` method overrides the base and is used to pass the torch on to the next
    runner or, in our case, pass the current inspection and move to the next.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体类从`Handler`继承，并使用`Handle`方法实现它们的检查逻辑，该方法覆盖了基类方法。同样，`Next`方法覆盖了基类，并用于将接力棒传递给下一个跑步者，或者在我们的案例中，将当前的检查传递给下一个。
- en: Flowchart logic has been around since the Turing machine. It should come as
    no surprise there is a pattern to encapsulate this universal concept.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图逻辑自图灵机以来就存在了。因此，有一个模式来封装这个普遍概念并不令人惊讶。
- en: Proxy
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: One day, Kitty and Phoebe get a call from Dr. Eloise Swanson. Dr. Swanson has
    started a new business called *U.S. Robots and Mechanical Men*. Her company’s
    newest product is a high-end **software development kit** (**SDK**) for robotic
    control. Dr. Swanson had studied Phoebe’s designs while in graduate school at
    the **Massachusetts Institute of Technology** (**MIT**) and thought Bumble Bikes
    would make a good partner for beta testing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一天，Kitty和Phoebe接到Eloise Swanson博士的电话。Swanson博士成立了一家名为“美国机器人及机械人”的新公司。她公司的新产品是一款高端的用于机器人控制的**软件开发工具包**（**SDK**）。Swanson博士在麻省理工学院（**MIT**）的硕士研究生期间研究了Phoebe的设计，并认为Bumble
    Bikes是进行beta测试的良好合作伙伴。
- en: The SDK was very effective and easy to use. However, it wasn’t a drop-in replacement
    for the software Kitty and Phoebe had written. First, there’s no way an SDK can
    fully replace custom-tailored software for any business. The second problem was
    bloat because the SDK was designed to work with any robotic system. A great deal
    of code was used to account for every possibility.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该SDK非常有效且易于使用。然而，它并不能完全替代Kitty和Phoebe编写的软件。首先，任何SDK都无法完全替代任何业务的定制软件。第二个问题是膨胀，因为SDK被设计成可以与任何机器人系统协同工作。大量的代码被用来考虑每一种可能性。
- en: Kitty and Phoebe found that the SDK was a good fit to control their painting
    robots. However, it was only needed when a custom paint job was ordered that had
    never done before. Once a paint job was performed, it was cataloged and the color
    formula could be reused. The SDK from *U.S. Robots* made much shorter work of
    the paint jobs, at the cost of slow initialization and a large memory footprint.
    If the girls were to couple their code to the SDK, which of course they wouldn’t,
    all their work would be slowed down by an expensive initialization process they
    would rarely use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Kitty和Phoebe发现SDK非常适合控制他们的喷漆机器人。然而，只有在需要定制从未进行过的喷漆工作时才需要它。一旦完成喷漆工作，它就会被编目，颜色公式就可以重复使用。来自“美国机器人”的SDK使喷漆工作大大缩短，但代价是初始化缓慢和占用大量内存。如果女孩们要将她们的代码与SDK结合，当然她们不会这样做，那么所有的工作都会因为一个昂贵的初始化过程而变慢，而这个过程她们很少会用到。
- en: The solution is to lazy load the SDK objects only when they are needed. The
    P roxy pattern allows you to define and use a placeholder for an object. The proxy
    could then load the big, slow SDK classes only when they were needed. The rest
    of the production process would remain unhampered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在需要时才懒加载SDK对象。代理模式允许你定义并使用一个对象占位符。然后，代理可以在需要时仅加载大而慢的SDK类。其余的生产过程将不受影响。
- en: 'Let’s examine the structure of the Proxy pattern in the following diagram:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以下面的图为例，检查代理模式的结构：
- en: '![Figure 8.7: The Proxy pattern can substitute a simple object for a more complicated
    one until the complicated one is actually needed.  ](img/B18605_Figure_8.7.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：代理模式可以在需要之前用一个简单的对象替换一个更复杂的对象。](img/B18605_Figure_8.7.jpg)'
- en: 'Figure 8.7: The Proxy pattern can substitute a simple object for a more complicated
    one until the complicated one is actually needed.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：代理模式可以在需要之前用一个简单的对象替换一个更复杂的对象。
- en: 'Breaking it down will help us understand further, so we’ll do just that:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将其分解将有助于我们进一步理解，所以我们将这样做：
- en: We have this SDK from a third-party vendor. We know tightly coupling to a third-party
    vendor’s SDK is a bad idea in the first place. In this case, the SDK has a method
    we want to use, but its containing class has a big, slow constructor, and the
    object is rarely used. We need a way to lazily load this object only when it is
    needed while also preventing a tight coupling.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从第三方供应商那里有这个 SDK。我们知道与第三方供应商的 SDK 紧密耦合从一开始就是一个坏主意。在这种情况下，SDK 有一个我们想要使用的方法，但它的包含类有一个大而慢的构造函数，并且对象很少被使用。我们需要一种方法，在需要时才懒加载这个对象，同时防止紧密耦合。
- en: We create an interface to prevent tight coupling. Our client software can require
    the interface, and any changes in the future are fine as long as we can keep the
    interface.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个接口以防止紧密耦合。我们的客户端软件可以要求这个接口，只要我们能够保持接口，未来的任何变化都是可以接受的。
- en: Then, we create a wrapper that holds the SDK instance. The wrapper holds an
    instance of `BigSlowButVeryUsefulPaintService`, which might take several minutes
    to instantiate. That’s a long time, considering we only need one method. Our wrapper
    instantiates `BigSlowButVeryUsefulPaintService`, then calls the expensive `InitializeSystem`
    method only when it is really needed. Since we bore the instantiation cost, we
    can store the instance in a private property and use it again if the need arises.
    That might sound like a singleton, but singletons ensure only one instance is
    ever created. Here, we are just reusing what we have already made, which isn’t
    quite the same thing.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包装器来持有 SDK 实例。包装器持有 `BigSlowButVeryUsefulPaintService` 的一个实例，这个实例可能需要几分钟才能实例化。这已经是很长时间了，考虑到我们只需要一个方法。我们的包装器实例化
    `BigSlowButVeryUsefulPaintService`，然后在真正需要时才调用昂贵的 `InitializeSystem` 方法。由于我们承担了实例化成本，我们可以将实例存储在私有属性中，并在需要时再次使用。这听起来可能像单例模式，但单例模式确保只创建一个实例。在这里，我们只是在重复使用我们已经制作好的东西，这并不完全相同。
- en: Remember, usese the Proxy pattern anytime you need a placeholder for a third-party,
    legacy, or overly expensive object. This will to prevent tight coupling and defer
    expensive operations that might happen on instantiation for when they are needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，任何需要第三方、遗留或过于昂贵的对象占位符的时候，都要使用代理模式。这将防止紧密耦合，并推迟在实例化时可能发生的昂贵操作，直到它们真正需要时。
- en: Interpreter
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Interpreter
- en: The Interpreter pattern is one you will likely never need. This pattern is used
    when you have a custom language you need to interpret that can be expressed using
    **abstract syntax trees** (**ASTs**). With the rise in popularity of **domain-specific
    languages** (**DSLs**), entire toolkits, such as JetBrains Meta Programming System
    and Visual Studio Enterprise’s Modeling SDK, make creating a custom language interpreter
    a relatively simple project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式是你可能永远不会需要的一种模式。当需要解释一种可以用**抽象语法树**（**ASTs**）表示的自定义语言时，会使用这种模式。随着**领域特定语言**（**DSLs**）的流行，整个工具包，如
    JetBrains Meta Programming System 和 Visual Studio Enterprise 的建模 SDK，使得创建自定义语言解释器成为一个相对简单的项目。
- en: Since DSLs are well beyond the scope of a book on patterns, I will list a reference
    to the DSL tools I’ve mentioned here in the *Further reading* section at the end
    of the chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DSLs 超出了本书关于模式的范围，我将在本章末尾的“进一步阅读”部分列出我提到的 DSL 工具的参考。
- en: Mediator
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mediator
- en: It isn’t difficult to imagine a future for Bumble Bikes where their automated
    manufacturing system might expand and become more complex. Right now, we have
    the Builder pattern controlling the robotics that build bicycles and wheelchairs.
    There are two physical factories, and each factory specializes in just a few products.
    All that could change in the future.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 想象 Bumble Bikes 的未来并不困难，他们的自动化制造系统可能会扩展并变得更加复杂。目前，我们有建造模式控制着制造自行车和轮椅的机器人。有两个物理工厂，每个工厂只专注于几种产品。所有这些在未来都可能改变。
- en: I worked for an aircraft manufacturer on a joint venture with another aircraft
    manufacturer. Our company made the powerplant (engine) and assembled the final
    aircraft. The partner company built the body of the aircraft. Other partner companies
    supplied avionics, which are the electronic flight-control systems present in
    modern aircraft. Another company still manufactures military components that I’m
    not allowed to talk about.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾在一家飞机制造商与另一家飞机制造商的合资企业工作。我们的公司制造动力装置（发动机）并组装最终的飞机。合作伙伴公司制造飞机机身。其他合作伙伴公司提供航空电子设备，这些是现代飞机中存在的电子飞行控制系统。还有一家公司制造我不得谈论的军事组件。
- en: Imagine if Bumble Bikes had a slew of manufacturing operations like that. Even
    if they were all collocated in one plant, the level of signal communications between
    all the different robotic manufacturing systems could become very chaotic. If
    each system were to communicate with all the other systems directly, we’d very
    quickly find ourselves in trouble.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Bumble Bikes有如此多的制造操作。即使它们都集中在一个工厂里，所有不同机器人制造系统之间的信号通信水平可能会变得非常混乱。如果每个系统都要直接与其他系统通信，我们很快就会陷入麻烦。
- en: If you’ve ever created a large web application using HTML and JavaScript, you
    have run into a similar problem. You have dozens of different pieces of code modifying
    the **Document Object Model** (**DOM**) in response to potentially hundreds of
    signals emanating from user interactions, timers, **Representational State Transfer**
    (**REST**) **application programming interface** (**API**) calls, third-party
    SDKs such as jQuery, and third-party advertising sites injecting code into your
    site for monetization. When a system such as this reaches critical mass in terms
    of signal complexity, it becomes slow and nearly impossible to debug and maintain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用HTML和JavaScript创建过大型网络应用程序，你可能会遇到类似的问题。你有数十种不同的代码片段在响应来自用户交互、计时器、**表示状态传输**（**REST**）**应用程序编程接口**（**API**）调用、第三方SDK（如jQuery）和第三方广告网站注入到你的网站以进行货币化的数百个信号时修改**文档对象模型**（**DOM**）。当这样一个系统在信号复杂度方面达到临界质量时，它就会变得缓慢，几乎无法调试和维护。
- en: 'Let’s consider one more example: a natural disaster such as a hurricane or
    tornado. What if all the **first responders** (**FRs**) were able to contact each
    other directly? Every firefighter could radio every policeman, who could radio
    every **emergency medical service** (**EMS**) unit. The EMS responders could talk
    directly to triage nurses and Red Cross volunteers. All this happens on one big
    open communication channel. What are your odds of surviving a disaster in this
    environment? Open direct communications can sometimes be a good thing, but I think
    we all realize it doesn’t scale. Now, imagine hundreds of objects in a piece of
    software that all have direct access to all the other objects on the stack. You
    see the problem, right?'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再考虑一个例子：自然灾害，如飓风或龙卷风。如果所有**第一响应者**（**FRs**）都能直接相互联系呢？每位消防员都可以通过无线电与每位警察联系，警察可以与每位**紧急医疗服务**（**EMS**）单位联系。EMS响应者可以直接与分级护士和红十字会志愿者交谈。所有这些都在一个大的开放通信渠道上发生。在这种环境下，你生存下来的机会有多大？开放直接通信有时可能是一件好事，但我认为我们所有人都意识到它无法扩展。现在，想象一下，在一个软件片段中有数百个对象，它们都可以直接访问堆栈上所有其他对象。你看到了问题，对吧？
- en: 'What’s needed in all these circumstances is some form of dispatcher: a central
    hub for communications. The Mediator pattern embodies this role. A mediator acts
    as a central hub for all communications and routes requests to the objects that
    need them in a controlled manner. Let’s examine the diagram shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，都需要某种形式的调度器：一个通信的中心枢纽。中介者模式体现了这个角色。中介者充当所有通信的中心枢纽，并以受控的方式将请求路由到需要它们的对象。让我们看看这里显示的图：
- en: '![Figure 8.8: The Mediator pattern involves a single centralized object that
    directs calls between objects. ](img/B18605_Figure_8.8.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：中介者模式涉及一个单一的中心对象，该对象在对象之间指导调用。](img/B18605_Figure_8.8.jpg)'
- en: 'Figure 8.8: The Mediator pattern involves a single centralized object that
    directs calls between objects.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：中介者模式涉及一个单一的中心对象，该对象在对象之间指导调用。
- en: 'By the numbers in the diagram, it works like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 根据图中的数字，它的工作方式如下：
- en: This is a base class for the colleague objects.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是同事对象的基础类。
- en: You have a bunch of colleague objects that need a centralized way to communicate.
    Here, I just have four, which is probably no cause to run to the Mediator pattern.
    But imagine 400 objects all communicating directly with each other! Like I said
    before, direct communications don’t scale!
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你有一群同事对象，需要一种集中的通信方式。这里我只有四个，这可能不足以导致我们转向中介者模式。但想象一下，400个对象都在直接相互通信！就像我之前说的那样，直接通信无法扩展！
- en: We make an interface called `IMediator`, which sounds cool when you say it out
    loud. This, as usual, prevents tight coupling.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`IMediator`的接口，当你大声说出来时听起来很酷。这通常可以防止紧密耦合。
- en: Now for the good part. A central object based on the `IMediator` interface contains
    instances of all the objects and has defined communications channels between them
    in the form of methods that I called `ReactWithX`, where X is the number corresponding
    with the object sending the signal. `ReactWith1` calls an appropriate method on
    `Colleague1`, and so on.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来说说好的部分。一个基于`IMediator`接口的中心对象包含所有对象的实例，并在它们之间定义了通信通道，这些通道以我称为`ReactWithX`的方法的形式存在，其中X是与发送信号的对象相对应的数字。`ReactWith1`会在`Colleague1`上调用一个适当的方法，依此类推。
- en: This pattern is designed to simplify the communications process, but it usually
    results in a very large object with lots of internalized component instances and
    methods for communicating. You have to weigh the complexity of the `Mediator`
    class against the benefits of the centralization it offers. On the one hand, as
    a developer, it’s nice to have one class where you can drop a breakpoint in your
    IDE. Like a lion scoping out the local watering hole, eventually, all message
    traffic passes through this one class, making it simpler to find bugs.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式旨在简化通信过程，但它通常会导致一个非常大的对象，其中包含大量的内部组件实例和方法用于通信。您必须权衡`Mediator`类的复杂性与其提供的集中化好处。一方面，作为一个开发者，有一个类可以在您的IDE中设置断点是很不错的。就像一头狮子在观察当地的饮水点一样，最终，所有消息流量都会通过这个类，这使得查找错误变得简单。
- en: On the downside, the class itself can become unwieldy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个类本身可能会变得难以控制。
- en: Memento
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memento
- en: Have you ever saved a game or used undo in your favorite editor? If so, then
    you’ve likely interacted with the Memento pattern. The best analogy for a memento
    is a cool but outdated technology. When I was in grade school, the hottest camera
    was called a Polaroid. Most cameras back then involved a roll of film. You would
    shoot your pictures on the camera, then take the film to a drug store to be developed.
    It took about a week to get your pictures back. However, with a Polaroid, you
    could take your pictures, which were ejected from the camera and self-developed
    within a few minutes. The development process seemed to go a little faster if
    you shook the picture, which gave rise to a popular song lyric, and accompanying
    dance move, “Shake it like a Polaroid picture”.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经保存过游戏或在您最喜欢的编辑器中使用过撤销功能？如果是这样，那么您可能已经与Memento模式互动过。对于记忆点的最佳类比是一种酷但过时的技术。当我还在上小学的时候，最热门的相机被称为宝丽来。那时的相机大多使用胶卷。您会在相机上拍照，然后把胶卷拿到药店去冲洗。大约需要一周的时间才能拿到您的照片。然而，使用宝丽来，您可以在几分钟内拍照，照片从相机中弹出并自行冲洗。如果您摇动照片，冲洗过程似乎会更快一些，这引发了一首流行的歌词和相应的舞蹈动作，“像宝丽来照片一样摇动它”。
- en: 'Back then, we called these pictures *snapshots*. This term is used today in
    conjunction with the Memento pattern. A snapshot, like a Polaroid picture, is
    a representation of an event or place at a particular point in time. So it is
    with software as well: a snapshot represents the state of an object at a point
    in time. Like a photo, a software snapshot can be saved as a memento—something
    to remind you of that one time when your object was in that state.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那时候，我们把这些图片称为*快照*。今天，这个术语与Memento模式一起使用。一个快照，就像宝丽来照片一样，是特定时间点的事件或地点的表示。同样，在软件中也是如此：快照表示对象在某个时间点的状态。就像照片一样，软件快照可以保存为记忆点——提醒您对象处于该状态的那一次。
- en: Text editors such as your IDE or Microsoft Word are constantly tracking the
    state of your documents and saving mementos as you type. When you hit *Ctrl*/*Command
    + Z* on your keyboard, you can go back sequentially to earlier and earlier mementos.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑器，例如您的IDE或Microsoft Word，会持续跟踪您文档的状态，并在您键入时保存记忆点。当您在键盘上按下*Ctrl*/*Command
    + Z*时，您可以按顺序回到越来越早的记忆点。
- en: At first glance, this seems easy. All you’d need to do is create a `List<>`
    object to hold, say, the last 100 state changes your user has made. Maybe you
    store a memento every 30 seconds or so. That’s easy. It’s that easy only if every
    object in your state and every object used in inheritance and composition has
    100% public properties. If the entire state is public, you wouldn’t need a pattern
    for this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这似乎很简单。您只需创建一个`List<>`对象来保存，比如说，用户最近做的100个状态更改。也许您每30秒左右存储一个记忆点。这很简单。只有当您的状态中的每个对象以及用于继承和组合的每个对象都有100%的公共属性时，这才会变得简单。如果整个状态都是公共的，您就不需要这个模式了。
- en: 'The real impediment here is the same one we encountered with the Prototype
    pattern earlier. We were trying to copy Count Dracula’s castle, but we weren’t
    allowed inside the front gate. Making a shallow copy of the outside of the castle
    is straightforward, to make a full copy of the whole castle requires an inside
    actor. This is equally true in the Memento pattern. In the memento’s case, the
    inside actor is a nested class. The nested class has access to the outer class’s
    state and can store our suggested `List<>` object containing our undo history.
    Let’s look at the diagram shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正的障碍与我们在之前的原型模式中遇到的相同。我们试图复制德古拉伯爵的城堡，但我们不允许进入前门。复制城堡的外部是简单的，但要复制整个城堡需要内部演员。这在备忘录模式中同样适用。在备忘录的情况下，内部演员是一个嵌套类。嵌套类可以访问外部类的状态，并可以存储我们的建议`List<>`对象，包含我们的撤销历史。让我们看看这里显示的图表：
- en: '![Figure 8.9: The Memento pattern. ](img/B18605_Figure_8.9.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：备忘录模式](img/B18605_Figure_8.9.jpg)'
- en: 'Figure 8.9: The Memento pattern.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：备忘录模式。
- en: 'Since the most familiar example is a text editor, I used that for the diagram.
    Let’s review the numbered parts of the diagram, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最熟悉的例子是文本编辑器，我使用了它来绘制图表。让我们回顾一下图表的编号部分，如下：
- en: This class represents the `DocumentEditor` class, which is our client. The memento
    pattern calls this the originator since this is where the stored state comes from.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类代表的是`DocumentEditor`类，即我们的客户端。备忘录模式称这个类为发起者，因为存储的状态来自这里。
- en: 'When the editor needs to save an undo state—or, for that matter, a file—it
    can use the `Memento` class for storage. Note that all the internals are private.
    The `Memento` class is nested inside the originator; it is defined *inside* the
    `DocumentEditor` class as a nested class. Besides being locked down, you should
    consider `Memento` classes immutable: once you create them, you should never change
    them. The private properties are set via the constructor and subsequently never
    modified. This means when you implement, there should not be any setter accessor
    methods for these properties.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编辑器需要保存撤销状态——或者，更确切地说，保存文件时——它可以使用`Memento`类进行存储。请注意，所有内部内容都是私有的。`Memento`类嵌套在发起者内部；它定义为`DocumentEditor`类内部的嵌套类。除了被锁定外，你还应该考虑`Memento`类是不可变的：一旦创建，就不应该再改变它们。私有属性通过构造函数设置，随后不再修改。这意味着在实现时，不应该为这些属性提供任何setter访问器方法。
- en: There isn’t a standard way to draw internal classes in UML, so I put the `Caretaker`
    class outside the dashed box as a visual clue that there’s something different
    about this class. Remember, `Memento` is inside the `DocumentEditor`, and not
    via composition. The `Caretaker` class, in turn, contains the `DocumentEditor`
    object inside the `Originator` field. The `Caretaker` class, then is responsible
    for creating and restoring mementos, as well as the undo history.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UML中绘制内部类没有标准的方法，所以我将`Caretaker`类放在虚线框外面，作为一个视觉提示，表明这个类有所不同。记住，`Memento`位于`DocumentEditor`内部，而不是通过组合。`Caretaker`类反过来包含`Originator`字段中的`DocumentEditor`对象。因此，`Caretaker`类负责创建和恢复备忘录，以及撤销历史。
- en: The Memento pattern can be difficult to get right, and you might go a long way
    in your career without needing it. Even if you land a job at a company that makes
    a document editor, chances are you’ll be using one of the many excellent third-party
    **user interface** (**UI**) controls, such as those from Telerik, that have already
    implemented this for you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式可能很难正确实现，你可能在职业生涯中走得很远都不需要它。即使你在一家人文编辑器公司找到工作，你也很可能使用许多优秀的第三方**用户界面**（**UI**）控件，例如来自Telerik的控件，这些控件已经为你实现了这一功能。
- en: The other point worth mentioning is that you can achieve a nearly identical
    effect using C#’s serialization libraries. Usually, saving the application state
    also entails persistence. Good editors let you undo the last 100 changes. Great
    editors let you do that between editing sessions. You can turn off your laptop,
    fly across the world, boot back up, and your undo history is still available because
    it’s serialized (saved) to a file somewhere on your hard drive.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你可以使用C#的序列化库实现几乎相同的效果。通常，保存应用程序状态也涉及持久化。好的编辑器让你可以撤销最后100次更改。伟大的编辑器让你可以在编辑会话之间这样做。你可以关闭笔记本电脑，飞越世界，重新启动，你的撤销历史仍然可用，因为它们被序列化（保存）到你的硬盘上的某个文件中。
- en: The .NET Framework gives us a slew of serialization options, including `System.Runtime.Serialization`,
    `System.Runtime.Serialization.Json`, and `System.Text.Json.Serialization`. Each
    contains a set of classes designed to make serializing your objects to files fairly
    trivial. However, you’ll still have problems with private properties. Thankfully,
    Microsoft has supplied us with the `DataContractSerializer` class that helps you
    get around this limitation without resorting to an intricate class structure or
    worrying about the memento’s immutability.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架为我们提供了一系列序列化选项，包括`System.Runtime.Serialization`、`System.Runtime.Serialization.Json`和`System.Text.Json.Serialization`。每个都包含一组旨在使将对象序列化到文件变得相当简单的类。然而，你仍然会面临私有属性的问题。幸运的是，微软为我们提供了`DataContractSerializer`类，它可以帮助你绕过这个限制，而无需使用复杂的类结构或担心备忘录的不可变性。
- en: State
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: I’ll confess looking back at the last eight chapters, I probably should have
    covered this pattern. You’ll use it, especially if you work in game development
    with Unity 3D. If you’re not familiar with this tool kit, it’s essentially a game
    engine capable of creating AAA games for consoles, PC, Mac, mobile, and the web.
    I taught game development with Unity for many years at a local college and so
    I have a soft spot for it, despite never having worked as a professional game
    developer. The Unity 3D game engine uses a finite state machine to control the
    animation of your game characters. It uses a visual editor to define the states
    and the animation to use when the game character’s state changes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我得承认，回顾过去八章，我可能应该介绍这种模式。你会用到它，尤其是如果你在Unity 3D游戏开发中工作。如果你不熟悉这个工具包，它本质上是一个能够为游戏机、PC、Mac、移动设备和网络创建AAA游戏的引擎。我在当地学院教授Unity游戏开发多年，因此我对它有着特殊的感情，尽管我从未作为职业游戏开发者工作过。Unity
    3D游戏引擎使用有限状态机来控制游戏角色的动画。它使用可视化编辑器来定义状态以及当游戏角色状态改变时使用的动画。
- en: The State pattern entails changing an object’s behavior based on changes to
    its internal state. An object’s state is conceptually just the values of all its
    properties at a point in time. If you make a game where you run around the countryside
    fighting zombies, you might define your zombies with different behaviors. Most
    of the time, they’re just shambling around randomly looking for fresh BRAINS!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式涉及根据对象内部状态的变化来改变对象的行为。一个对象的状态在概念上只是它在某个时间点所有属性值的集合。如果你制作一个你在乡村四处奔跑与僵尸战斗的游戏，你可能会用不同的行为来定义你的僵尸。大多数时候，它们只是在随机地四处游荡，寻找新鲜的BRAINS！
- en: When something with a brain comes into view, the zombie’s behavior changes.
    It shambles towards the brain-toting organism while hissing “BRAINS!” over and
    over. Once the zombie is within arm’s reach, its behavior changes again. The zombie
    attacks!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当有大脑的东西出现在视野中时，僵尸的行为会改变。它一边拖着脚步向携带大脑的生物走去，一边反复地嘶吼“BRAINS！”一旦僵尸进入手臂可触及的范围，它的行为再次改变。僵尸攻击！
- en: 'We have one object with three behaviors, all controlled by the internal state.
    When we put the behaviors and states together, we form what’s called a finite-state
    machine. It is finite because zombies have a finite number of behaviors. In this
    case, the number is 3\. The finite state machine can be diagrammed as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个对象，具有三种行为，所有这些行为都由内部状态控制。当我们把行为和状态结合起来时，我们就形成了所谓的有限状态机。它是有限的，因为僵尸的行为数量是有限的。在这种情况下，数量是3。有限状态机可以像下面这样绘制：
- en: '![Figure 8.11: A finite state machine representing zombie behavior in a video
    game.  ](img/B18605_Figure_8.10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：表示视频游戏中僵尸行为的有限状态机。](img/B18605_Figure_8.10.jpg)'
- en: 'Figure 8.11: A finite state machine representing zombie behavior in a video
    game.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：表示视频游戏中僵尸行为的有限状态机。
- en: 'This state diagram shows the transitions between the different states. The
    zombie can’t randomly attack a victim that is too far away. It has to see the
    victim and close the distance first. A diagram of the pattern appears here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个状态图显示了不同状态之间的转换。僵尸不能随机攻击一个距离太远的受害者。它必须先看到受害者，然后缩短距离。模式的图示如下：
- en: '![Figure 8.12: The State pattern.  ](img/B18605_Figure_8.11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：状态模式。](img/B18605_Figure_8.11.jpg)'
- en: 'Figure 8.12: The State pattern.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：状态模式。
- en: 'Let’s break it down, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解如下：
- en: The `IState` interface defines the behaviors that are possible. Our zombie can
    patrol, close distance to a visible victim, and attack.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IState`接口定义了可能的行为。我们的僵尸可以巡逻、接近可见的受害者，并攻击。'
- en: The `Context` class holds a reference to an object implementing the `IState`
    interface, which is used to communicate with concrete state objects.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Context`类持有实现`IState`接口的对象的引用，用于与具体状态对象通信。'
- en: Concrete state objects contain state-specific methods.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体状态对象包含特定状态的方法。
- en: The context object can be used to change the state by swapping concrete state
    objects held in the private state property. This means the context can enforce
    any logic for state transitions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文对象可以通过交换在私有状态属性中持有的具体状态对象来改变状态。这意味着上下文可以强制执行任何状态转换的逻辑。
- en: I didn’t include the State pattern earlier because it is very similar to the
    Strategy pattern covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). Kitty
    and Phoebe used the Strategy pattern to create a navigation system for bicycles.
    The behavior of the system changed depending on what type of terrain the user
    requested.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有包括状态模式，因为它与我们在[*第五章*](B18605_05.xhtml#_idTextAnchor089)中介绍的策略模式非常相似。凯蒂和菲比使用策略模式为自行车创建了一个导航系统。系统的行为根据用户请求的地形类型而改变。
- en: Template Method
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法
- en: The Template Method pattern is very similar to the Strategy pattern, which we
    covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). This is a behavioral
    pattern that allows you to define the structure of an algorithm but defer the
    implementation to subclasses that override the actual logic but not the structure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式与我们在[*第五章*](B18605_05.xhtml#_idTextAnchor089)中介绍的策略模式非常相似。这是一种行为模式，它允许你定义算法的结构，但将实现推迟到子类，这些子类覆盖了实际的逻辑而不是结构。
- en: In [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089), Phoebe designed a navigational
    computer for bicycles. It used the Strategy pattern to compute navigational routes
    depending on whether the rider wanted a route via paved roads, unpaved gravel
    roads, or extreme terrain. We could have done the same thing with the Template
    Method pattern, which is why I didn’t feel the need to cover both.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18605_05.xhtml#_idTextAnchor089)中，菲比为自行车设计了一个导航计算机。它使用策略模式来计算导航路线，取决于骑行者是否想要通过铺砌的道路、未铺砌的砾石道路还是极端地形。我们也可以用模板方法模式做到同样的事情，这就是为什么我没有觉得有必要介绍两者。
- en: 'The structure can be seen in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结构可以在以下图中看到：
- en: '![Figure 8.13: The Template pattern.  ](img/B18605_Figure_8.12.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：模板模式。](img/B18605_Figure_8.12.jpg)'
- en: 'Figure 8.13: The Template pattern.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：模板模式。
- en: 'Let’s look at the numbered parts, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编号的部分，如下所示：
- en: The abstract template class defines the structure of a class that forms an algorithm.
    The steps to the algorithm are defined as abstract and can be overridden by a
    concrete implementation in a child class. The steps, however, are called in a
    method within the template class. In my example, I called it `ExecuteTemplate()`,
    which is not overridden. `ExecuteTemplate()` calls the steps in order, and this
    never changes. The template defines overrideable logic, but the structure is consistent
    each time the template is used.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象模板类定义了一个形成算法的类的结构。算法的步骤被定义为抽象的，可以在子类中的具体实现中覆盖。然而，这些步骤是在模板类中的方法中调用的。在我的例子中，我称之为`ExecuteTemplate()`，这个方法没有被覆盖。`ExecuteTemplate()`按顺序调用步骤，这永远不会改变。模板定义了可覆盖的逻辑，但每次使用模板时结构都是一致的。
- en: These are the concrete classes that override the algorithm steps. Note the `AlgoImplementationA`
    class overrides all the steps in the parent class. The `AlgoImplementationB` class
    just overrides a few.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是覆盖算法步骤的具体类。注意`AlgoImplementationA`类覆盖了父类中的所有步骤。`AlgoImplementationB`类只覆盖了几个步骤。
- en: This pattern allows you to make very flexible algorithm implementations using
    nothing more than common household inheritance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式允许你使用普通的继承来创建非常灵活的算法实现。
- en: Visitor
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访客
- en: The Visitor pattern is another Behavioral pattern designed to help you “bolt
    on” new behaviors to existing objects. Its motivations are focused on SOLID principles
    (head back to [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036) if you need an explanation
    of this acronym). The open-closed principle is honored because you are adding
    behavior without modifying existing classes. The SRP is honored because usually,
    the behavior you are adding is new and may have little to nothing to do with the
    purpose of the original class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式是另一种行为模式，旨在帮助你“附加”新的行为到现有对象上。其动机集中在SOLID原则（如果你需要这个缩写的解释，请回到[*第2章*](B18605_02.xhtml#_idTextAnchor036)）。开放封闭原则得到了尊重，因为你是在不修改现有类的情况下添加行为的。单一职责原则也得到了尊重，因为通常你添加的行为是新的，可能几乎与原始类的目的无关。
- en: The idea behind the name comes from the idea that an object encapsulating new
    behavior can visit an existing, established class, allowing it to perform the
    new behavior. You’re literally teaching an old dog object new tricks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字背后的想法来源于这样一个观点：一个封装了新行为的对象可以访问现有的、已建立的类，从而允许它执行新的行为。你实际上是在教一只老狗新把戏。
- en: Imagine a world where your body has an ability slot. You can slot in a new behavior
    as easily as slotting a memory card into a camera. Need to learn to fly a helicopter
    to escape evil secret agents? Slot the card with flight training and you can instantly
    fly any civilian or military aircraft! Do you need to cook like a 5-star chef?
    Slot a card with cooking skills and you’ll be able to defeat Gordon Ramsay or
    Bobby Flay in any cooking competition! Do you need moves at the nightclub? Slot
    a card with nightclub skills and you’ll dance the night away! Just be careful
    with that last one. There’s no telling what other skills might be on the card.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个你的身体有一个能力插槽的世界。你可以像将记忆卡插入相机一样轻松地插入新的行为。需要学会开直升机来逃离邪恶的秘密特工吗？插入飞行训练的卡片，你就可以瞬间驾驶任何民用或军用飞机！需要像五星级厨师一样烹饪吗？插入烹饪技能的卡片，你就能在任何烹饪比赛中击败戈登·拉姆齐或博比·弗莱！需要在夜总会施展舞技吗？插入夜总会技能的卡片，你就可以尽情跳舞！只是要注意最后一个。你无法知道卡片上可能还有什么其他技能。
- en: 'Let’s shake that last example off and look at the following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们抛开最后一个例子，看看下面的图示：
- en: '![Figure 8.14: The Visitor pattern. ](img/B18605_Figure_8.13.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14：访问者模式。](img/B18605_Figure_8.13.jpg)'
- en: 'Figure 8.14: The Visitor pattern.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：访问者模式。
- en: 'Let’s break it down, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把它分解如下：
- en: Our `Visitor` interface defines a set of methods required to implement a new
    superpower you wish to confer on an existing object graph. We’re fortunate that
    C# supports method overloading. Method overloading refers to a language’s ability
    to reuse method names as long as the method signature is different. If you’re
    not sure what this means, check out [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    at the end of this book. We cover it there. Not every OOP language supports this
    capability, but C# does. Our interface defines several methods with the same name
    but with different argument types.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`Visitor`接口定义了一组方法，这些方法必须实现以向现有的对象图授予新的超级能力。我们很幸运，C#支持方法重载。方法重载指的是只要方法签名不同，语言就可以重用方法名称。如果你不确定这是什么意思，请查看本书末尾的[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)。我们将在那里介绍它。并非所有的面向对象语言都支持这种功能，但C#支持。我们的接口定义了具有相同名称但具有不同参数类型的方法。
- en: A second interface called the `Element` interface defines how visitors are accepted.
    If you want new abilities in our future world, you’ll have to get a slot added
    to your skull so that we have someplace to insert our ability cards. Likewise,
    your class will need an additional method based on this interface. You don’t need
    to change any existing methods or logic in the class. You just need to add a method
    to accept visitors.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个名为`Element`的接口定义了如何接受访问者。如果你想在未来的世界中获得新的能力，你将不得不在你的头骨上添加一个插槽，以便我们有一个地方可以插入我们的能力卡。同样，你的类将需要根据这个接口添加一个额外的方法。你不需要更改类中的任何现有方法或逻辑。你只需要添加一个接受访问者的方法。
- en: Concrete visitor classes implement our interface and provide the new behavioral
    logic. Note that we did not use the `IElement` interface as the argument type.
    The concrete object type passed in determines which method is run based on method
    overloading.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具体的访问者类实现了我们的接口并提供新的行为逻辑。请注意，我们没有使用`IElement`接口作为参数类型。传入的具体对象类型决定了基于方法重载运行哪个方法。
- en: These are your existing classes implementing the `Element` interface.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是实现了`Element`接口的现有类。
- en: A few things come to mind when I think of the Visitor pattern in C#. First,
    it feels a lot like the Decorator pattern, but with a focus on object graphs instead
    of individual classes. Maybe that’s just me?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我想起C#中的访问者模式时，有几个想法浮现在脑海中。首先，它感觉非常像装饰者模式，但重点是对象图而不是单个类。这可能只是我个人的感觉？
- en: Another similar pattern is the Composite pattern covered in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089),
    and again in *Chapters 7* and *8*. Kitty and Phoebe used the Composite pattern
    to perform a set of calculations for weight and cost on a graph of objects used
    to comprise a bicycle drivetrain. Tom improved the design by weaving the Composite
    pattern into the object graph at design time. The difference is that the Composite
    pattern operates from outside the objects in the graph whereas the Visitor pattern
    is inserting new behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的模式是第5章中提到的组合模式，再次在第7章和第8章中提到。Kitty和Phoebe使用组合模式对一个用于组成自行车传动系统的对象图进行了一系列的计算，以计算重量和成本。Tom通过在设计时将组合模式编织到对象图中来改进了设计。区别在于，组合模式在图外的对象上操作，而访问者模式是在插入新的行为。
- en: Finally, the first time I read about the Visitor pattern, I immediately thought
    of extension methods. Extension methods are unique to C#. They allow you to add
    behaviors to existing classes using a separate class file. They are not an implementation
    of the Visitor pattern, but if your needs are simple, you might want to start
    with extension methods. If extension methods come up short, then try the more
    complex Visitor pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我第一次读到访问者模式时，立刻想到了扩展方法。扩展方法是C#独有的。它们允许你使用一个单独的类文件向现有类添加行为。它们不是访问者模式的实现，但如果你的需求很简单，你可能想从扩展方法开始。如果扩展方法不够用，那么尝试更复杂的访问者模式。
- en: Patterns beyond the realm of OOP
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越OOP领域的模式
- en: The field of OOP was really just the start. There are patterns beyond the realm
    of OOP that you have very likely heard of, but perhaps didn’t know were codified
    patterns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程领域只是起点。还有一些超越OOP领域的模式，你很可能听说过，但可能不知道它们是编码化的模式。
- en: Software architecture patterns
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件架构模式
- en: An obvious area for finding more patterns is within the domain of software architecture.
    It may seem like we’ve been talking about software architecture this whole time.
    We have. However, software architecture isn’t bound to OOP. Every pattern in this
    book relies on using C# because it is an OOP language. Software architecture patterns
    span every language and really help us define systems, not just enhance the structure
    of our code. Let’s look at some examples you have probably heard of before now.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件架构领域寻找更多模式的一个明显区域。这似乎像是我们一直在谈论软件架构。是的，我们一直在谈论。然而，软件架构并不局限于面向对象编程（OOP）。本书中的每个模式都依赖于使用C#，因为它是一种面向对象编程语言。软件架构模式跨越了所有语言，并真正帮助我们定义系统，而不仅仅是增强我们代码的结构。让我们看看一些你可能之前已经听说过的例子。
- en: Client-server pattern
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端-服务器模式
- en: We actually covered this one—we just didn’t call it out as a pattern. This pattern
    involves **peer-to-peer** (**P2P**) architecture consisting of a server, and usually
    many clients. The clients make requests to the server and do something with the
    result. This is pretty much how the internet works.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经涵盖了这一点——我们只是没有将其称为模式。这个模式涉及**对等网络**（**P2P**）架构，包括一个服务器和通常许多客户端。客户端向服务器发出请求并对结果进行处理。这基本上就是互联网的工作方式。
- en: Microservices pattern
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务模式
- en: The Microservices pattern entails breaking large, monolithic applications into
    small, self-contained but interdependent services. The idea is to take the SRP
    to its ultimate implementation. Imagine a REST API with a handful of endpoints
    that together serve only one purpose such as password reset. Instead of password
    reset being built into a bigger API that does dozens of other things, the password
    reset becomes a microservice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务模式包括将大型、单体应用程序分解成小型、自包含但相互依赖的服务。这个想法是将单一责任原则（SRP）推向其最终实现。想象一下，一个带有少量端点的REST
    API，这些端点共同只服务于一个目的，比如密码重置。而不是将密码重置构建到一个更大的API中，该API执行数十个其他操作，密码重置变成了一个微服务。
- en: The idea is that it is easier to maintain tiny single-purpose APIs. The trade-off
    comes from the latency introduced between interdependent system calls and the
    resulting complexity of your network topology.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，维护小型单用途API更容易。权衡来自于依赖系统调用之间的延迟以及网络拓扑结构的结果复杂性。
- en: Model-View-Controller (MVC) pattern
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）模式
- en: 'Surely you’ve heard of this one! You see it in web applications when you split
    the application code into three layers, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定听说过这个！你会在将应用程序代码分为三个层次时在Web应用程序中看到它，如下所示：
- en: A model layer that contains code that represents the data model, usually via
    an **object-relational mapper** (**ORM**).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含表示数据模型的代码的模型层，通常通过**对象关系映射器**（**ORM**）实现。
- en: A view layer that represents the **user experience** (**UX**).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示**用户体验**（**UX**）的视图层。
- en: A controller layer that represents the logic needed to accept requests from
    the view and process data returned from the model layer. This configuration embodies
    the ideals behind the **separation of concerns** (**SoC**).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器层，它代表接受视图请求和处理从模型层返回的数据所需的逻辑。这种配置体现了**关注点分离**（**SoC**）的理想。
- en: Publish-subscribe (pub-sub) pattern
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布-订阅（pub-sub）模式
- en: This is another popular pattern you’ll see in many guises. Sometimes you’ll
    see object-level implementations such as what we saw in the Observer pattern covered
    in [*Chapter 5*](B18605_05.xhtml#_idTextAnchor089). You’ll also see higher-level
    architectural implementations in software such as Redis, RabbitMQ, and Apache
    Kafka.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是另一个在许多形式中都很受欢迎的模式。有时你会看到对象级别的实现，比如我们在[*第5章*](B18605_05.xhtml#_idTextAnchor089)中讨论的观察者模式。你也会在Redis、RabbitMQ和Apache
    Kafka等软件中看到更高层次的架构实现。
- en: In every case, the idea is to allow communication from a central source. Messages
    are sent to a publisher who in turn publishes the messages to relevant subscribers.
    This is vital to distributed architectures.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，想法是允许从中央源进行通信。消息被发送到一个发布者，然后发布者将消息发布给相关的订阅者。这对于分布式架构至关重要。
- en: Command Query Responsibility Segregation (CQRS) pattern
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令查询责任分离（CQRS）模式
- en: This pattern is meant to solve the situation that arises when database queries
    for data occur far more frequently than database updates. If you have a reporting
    system where reports are generated but rarely subsequently modified, this is a
    good pattern to learn. Its solution generally entails segregating data that rarely
    changes but is commonly queried into a separate database called a data warehouse.
    This can boost performance on reads and writes because the responsibilities are
    segregated. The trade-off comes from the implementation cost, which often involves
    standing up a separate database server to handle the segregated loads.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式旨在解决数据库查询数据发生的频率远高于数据库更新的情况。如果你有一个报告系统，其中报告被生成但很少随后修改，这是一个值得学习的模式。其解决方案通常涉及将很少更改但经常查询的数据分离到一个称为数据仓库的单独数据库中。这可以提高读写性能，因为责任是分离的。权衡来自于实施成本，这通常涉及建立一个单独的数据库服务器来处理分离的负载。
- en: Data access patterns
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据访问模式
- en: 'Data access patterns occur wherever you have traditional code interacting with
    a relational, or even non-relational, database. Since relational databases have
    been around since 1970 and are largely unchanged and completely ubiquitous, it
    shouldn’t be surprising that they have their own set of patterns. I cut my teeth
    with a book by Clifton Nock titled *Data Access Patterns: Database Interactions
    in Object-Oriented Applications*. I’ll list the book’s details in the *Further
    reading* section at the end of the chapter.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问模式出现在你与关系型数据库或甚至非关系型数据库的传统代码交互的任何地方。由于关系型数据库自1970年以来一直存在，并且基本上没有变化，并且完全无处不在，因此它们有自己的模式集并不令人惊讶。我在Clifton
    Nock所著的《数据访问模式：面向对象应用程序中的数据库交互》一书中磨练了我的技能。我将在本章末尾的“进一步阅读”部分列出这本书的详细信息。
- en: Here are just a few patterns from that book you’ll probably recognize.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是书中的一些模式，你可能会认识。
- en: ORM
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM
- en: Ever heard of **Entity Framework** (**EF**)? As a C# developer, you’d have to
    have lived beneath some sort of highly academic rock to have never heard of Microsoft’s
    flagship ORM. An ORM’s job is to map data between relational structures in **Structured
    Query Language** (**SQL**) databases such as SQL Server to objects in C#. If a
    pattern is a solution to a problem that occurs frequently, this might be the most
    important pattern in software development.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你听说过**实体框架**（**EF**）吗？作为一名C#开发者，你必须生活在某种高度学术性的岩石之下，才没有听说过微软的旗舰ORM。ORM的工作是在SQL数据库（如SQL
    Server）中的关系结构到C#中的对象之间映射数据。如果一个模式是解决频繁发生的问题的解决方案，那么这可能是软件开发中最重要的模式之一。
- en: Implementations of this pattern, usually encapsulated in a third-party library,
    or in our case, within the .NET Framework, allow developers to work solely with
    C# objects. With an ORM, you never need to create or update table structures in
    your application’s database. You never need to figure out complicated joins or
    concatenate long SQL statements in your code. You create a set of objects that
    represent your database structure. You then query those model classes and work
    with data operations to manipulate your database.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的实现，通常封装在第三方库中，或者在我们的案例中，在.NET框架中，允许开发者仅使用C#对象进行工作。使用ORM，你永远不需要在应用程序数据库中创建或更新表结构。你永远不需要在代码中解决复杂的连接或连接长SQL语句。你创建一组代表你的数据库结构的对象。然后查询这些模型类，通过数据操作来操作你的数据库。
- en: The upside is if you don’t know—or don’t like—SQL, you never need to work with
    it directly. The trade-off is in application performance. EF code is known to
    run significantly slower at scale than direct connections to the database. It
    also adds one more layer of dependencies to your application. It’s just one more
    thing that can go wrong. If you’re sensing I’m not a fan, you’d be right. I like
    ORMs for small projects with a limited number of users. For example, if you’re
    making an app for internal use and you have limited time to create it, using an
    ORM might help you get the job done more quickly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，如果你不知道——或者不喜欢——SQL，你永远不需要直接与之打交道。权衡之处在于应用程序的性能。EF代码在扩展规模上比直接连接到数据库运行得慢得多。它还给你的应用程序增加了一层依赖。这只是可能出错的一个额外因素。如果你觉得我不是它的粉丝，那你就对了。我喜欢ORM用于小型项目，用户数量有限。例如，如果你正在制作一个供内部使用的应用程序，并且你有有限的时间来创建它，使用ORM可能会帮助你更快地完成任务。
- en: If on the other hand you are making an application for a large user base, eschewing
    the convenience of an ORM in favor of implementing our next pattern directly gives
    you tremendous control over performance by allowing you to leverage the full capabilities
    of your database software.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果你正在为大量用户制作应用程序，放弃ORM的便利性，直接实现我们的下一个模式，这将给你巨大的性能控制权，允许你利用数据库软件的全部功能。
- en: Active Domain Object
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Active Domain Object
- en: The **Active Domain Object** (**ADO**) pattern is a fun one because when you
    see ADO, you probably think of either Microsoft’s **ActiveX Data Objects** (**ADO**)
    or ADO’s older cousin **Data Access Object** (**DAO**). Then again, that might
    only be if you’re over 35 years old. It’s been a good while since those technologies
    were front and center.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Active Domain Object**（**ADO**）模式很有趣，因为当你看到ADO时，你可能想到的是微软的**ActiveX数据对象**（**ADO**）或者ADO的更老前辈**数据访问对象**（**DAO**）。然而，这可能只适用于35岁以上的人。这些技术已经有一段时间没有处于前沿了。'
- en: The ADO pattern encapsulates data access and relevant object implementations.
    Their aim is to remove any direct interaction with the database outside the pattern
    implementation. Sound familiar? That’s pretty much what Microsoft ADO and DAO
    were designed to do. I doubt this is a coincidence.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ADO模式封装了数据访问和相关对象实现。他们的目标是消除模式实现之外的任何与数据库的直接交互。听起来熟悉吗？这正是微软ADO和DAO被设计来做的。我怀疑这不是巧合。
- en: Most developers don’t use this pattern, having generally moved to working with
    ORMs such as EF. However, if you have SQL skills, you can often make a more performant
    application by accessing the database directly via native drivers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者不使用这种模式，他们通常已经转向使用EF等ORM。然而，如果你有SQL技能，通过直接通过原生驱动程序访问数据库，你通常可以创建一个性能更好的应用程序。
- en: Demand cache
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需求缓存
- en: My wife and kids do this all the time. Just kidding, but not really. There are
    quite a few cache patterns. A demand cache is embodied by a cache that is populated
    lazily “on demand”. The main force at play here is you don’t know when the data
    will be needed, but you would like to only pay the price of retrieving the data
    once.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我的妻子和孩子经常这样做。开玩笑的，但也不是。有很多缓存模式。需求缓存体现在一个按需懒加载的缓存中。这里起主要作用的是你不知道数据何时会被需要，但你希望只支付一次检索数据的代价。
- en: My application includes a demand cache as part of a web application. Some of
    the queries in my application return large recordsets or include considerable
    processing that can take several seconds to complete. That doesn’t sound bad,
    but for a web application, it is an eternity. My demand cache method checks the
    cache (which in my case is Redis) first when data is requested. If it’s there,
    the data is served from the cache. If it isn’t there, I retrieve and cache it.
    The first customer to request the data pays the performance penalty, but every
    customer after that gets the data very quickly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我的应用程序包括一个需求缓存，作为Web应用程序的一部分。我的应用程序中的一些查询返回大型记录集或包括相当多的处理，可能需要几秒钟才能完成。这听起来可能并不糟糕，但对于Web应用程序来说，这是一个漫长的过程。我的需求缓存方法在请求数据时首先检查缓存（在我的情况下是Redis）。如果它在缓存中，数据就从缓存中提供。如果不在，我就检索并缓存它。第一个请求数据的客户承担性能惩罚，但之后的每个客户都能非常快速地获取数据。
- en: Transaction
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事务
- en: This is another ubiquitous data processing term that is really a pattern. In
    database lingo, a transaction refers to multiple SQL statements that must be completed
    as a unit. For example, if you have an automatic teller machine and you want to
    withdraw money from one account and add it to another, you need this to occur
    as one unit of work—a transaction.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是另一个无处不在的数据处理术语，实际上是一个模式。在数据库术语中，事务指的是必须作为一个单元完成的多个SQL语句。例如，如果你有一个自动取款机，并且你想从一个账户取款并转到另一个账户，你需要这个操作作为一个工作单元——事务。
- en: You withdraw $100 from account A and add $100 to account B. If either SQL statement
    fails, you need to consider the whole transaction a failure and roll back all
    the changes entirely.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你从账户A中取出100美元，并将100美元存入账户B。如果任一SQL语句失败，你需要考虑整个事务失败，并完全回滚所有更改。
- en: Optimistic and pessimistic lock
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乐观锁和悲观锁
- en: Nothing drives application developers crazier than dealing with locks in the
    database. An optimistic lock takes place in order to prevent missing database
    updates. You find this pattern used in **inventory management systems** (**IMSs**)
    where up-to-the-second, on-hand stock data is vital to selling that inventory.
    Last weekend, I bought a new clothes dryer at a popular store. My wife picked
    out the perfect dryer and the sign above the dryer said, “Order now and you’ll
    receive it in 3 days”. The salesman went to enter the order and found the units
    were not only out of stock, but the manufacturer wasn’t accepting back orders.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比在数据库中处理锁更让应用程序开发者抓狂的了。乐观锁的使用是为了防止错过数据库更新。你会在**库存管理系统（IMSs**）中找到这种模式的使用，在这些系统中，最新的库存数据对于销售库存至关重要。上周末，我在一家热门商店买了一台新的衣物烘干机。我妻子挑选了一台完美的烘干机，烘干机上面的标牌写着，“现在订购，您将在3天内收到”。销售员去输入订单时发现，这些产品不仅缺货，而且制造商不接受退货订单。
- en: The sign assumed stock at the warehouse and was based on stale information.
    Now, replace the sign with a database query. The sales application queries to
    see if any dryers are in stock. At the exact same moment, at a store across town,
    someone else has just purchased the same model of dryer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 标牌假设仓库有库存，并基于过时的信息。现在，用数据库查询替换标牌。销售应用程序查询以查看是否有烘干机库存。在同一个时刻，在城里的另一家商店，有人刚刚购买了同一型号的烘干机。
- en: How can the clerk at the first store know whether there really is a dryer available?
    The optimistic lock pattern entails creating a version number on each row in a
    database table. The database in this scenario will optimistically assume the dryer
    is available if the row version number hasn’t changed since the transaction started
    and doesn’t lock the database row for update.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一家商店的店员如何知道是否真的有烘干机可用？乐观锁模式包括在数据库表的每一行上创建一个版本号。在这种情况下，如果行版本号自事务开始以来没有改变，并且不锁定数据库行以进行更新，数据库将乐观地假设烘干机可用。
- en: By contrast, in the same scenario, a pessimistic lock will prevent the clerk’s
    sale from going through if the second clerk’s transaction was in the middle of
    updating the inventory row data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在相同的场景中，如果第二个销售员的交易正在进行中更新库存行数据，悲观锁将阻止销售员的销售交易进行。
- en: Creating your own patterns
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的模式
- en: 'Do you think you have an idea for your own design pattern? The GoF book presents
    a boilerplate documentation framework for publishing your own patterns. I won’t
    duplicate it fully here, but I will outline it for you. It involves four essential
    elements, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你有一个自己设计模式的想法吗？GoF 书籍提供了一个模板文档框架，用于发布你自己的模式。我不会在这里完全重复它，但我会为你概述它。它包括以下四个基本要素：
- en: Name and classification
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称和分类
- en: The problem description
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题描述
- en: The solution description
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决方案描述
- en: Consequences of using the pattern
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该模式的后果
- en: Let’s talk a little about each section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要谈谈每个部分。
- en: Name and classification
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称和分类
- en: Every pattern needs a name that describes the pattern. Most of the patterns
    out there have names that make you think of general words from normal language.
    The word *memento* refers to a physical object that invokes memories of times
    past. The word *singleton* invokes the idea there’s a single thing. Come up with
    a short, memorable name that invokes the idea behind the pattern.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式都需要一个描述该模式的名称。大多数现有的模式名称都让人联想到日常语言中的通用词汇。单词*memento*指的是一个能够唤起过去时光记忆的物理对象。单词*singleton*则唤起了只有一个事物的想法。想出一个简短、易于记忆的名称，能够唤起模式背后的理念。
- en: 'You also need a classification. In this book, we observed the three classifications
    in the GoF book: Creational patterns, Structural patterns, and Behavioral patterns.
    You saw in the previous sections that other knowledge domains that use patterns
    have their own lists of classifications. Maybe your pattern fits into an existing
    classification. If not, you’ll need to invent a new classification.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个分类。在这本书中，我们观察到了GoF书中的三种分类：创建型模式、结构型模式和行为型模式。在前几节中，你看到了其他使用模式的领域也有自己的分类列表。也许你的模式适合现有的分类。如果不适合，你需要发明一个新的分类。
- en: It is also possible your pattern might have an alias; an “**also known as**”
    (**AKA**) name. The Decorator pattern is also known as a wrapper. Document any
    aliases for your pattern if any exist.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你的模式可能还有一个别名；一个“**也称为**”(**AKA**)的名称。装饰者模式也被称为包装器。如果有任何别名，请记录下来。
- en: The problem description
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题描述
- en: 'This section of your documentation describes the problem your pattern aims
    to solve. When the GoF describe the problem, they break it into several smaller
    sections, as outlined here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 本节文档描述了你的模式旨在解决的问题。当GoF描述问题时，他们会将其分解为几个更小的部分，如下所述：
- en: '*Intent* refers to the overall goal of your pattern.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*意图*指的是你的模式的整体目标。'
- en: '*Motivation*/*Forces* outlines why someone would use your pattern. This is
    deeper than “because it’s cool” or because it solves a particular problem. When
    we discussed antipatterns in the first chapter, we described a set of forces that
    caused the antipattern to come into being. In this section, we’re looking for
    similar driving factors around why your new pattern is relevant and useful.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动机*/*驱动力*说明了为什么有人会使用你的模式。这比“因为它很酷”或因为它解决了特定问题要深入。当我们讨论第一章中的反模式时，我们描述了一组导致反模式出现的驱动力。在本节中，我们正在寻找类似的原因，以了解你的新模式为何相关且有用。'
- en: '*Applicability* lists the context for the pattern. Make a short list of situations
    where the pattern is useful.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*适用性*列出模式的上下文。列出模式有用的简短情况列表。'
- en: While it isn’t necessary to fill in every single niche, you’ll recognize elements
    we’ve used in this book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有必要填充每一个空缺，但你将认识到我们在本书中使用的元素。
- en: The solution description
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案描述
- en: 'When describing the solution, you need to describe the elements used to construct
    the design. Expound on the relationships between the elements. Describe how the
    elements collaborate, and make sure to explain the responsibilities of each element.
    You might consider breaking this section into smaller chunks as well, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述解决方案时，你需要描述用于构建设计的元素。阐述元素之间的关系。描述元素如何协作，并确保解释每个元素的责任。你可能还需要将这一部分分成更小的部分，如下所示：
- en: '*Participants* list classes, objects, interfaces, enumerations, and so on that
    participate in the pattern solution.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参与者*列出参与模式解决方案的类、对象、接口、枚举等。'
- en: '*Collaboration* describes how the participants collaborate.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协作*描述了参与者之间的协作方式。'
- en: '*Structure* will contain UML diagrams of a generic form of the pattern, and
    perhaps a diagram of a more real-life concrete use case. This is the format I
    have used in every pattern I covered in this book. I find the generic diagrams
    less useful by themselves. If a concrete example follows, developers can look
    at both diagrams and more easily relate them to their work.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构*将包含模式的通用形式的UML图，也许还有更贴近现实的具体用例图。这是我在这本书中涵盖的每个模式所使用的格式。我发现通用图单独使用时不太有用。如果后面跟着一个具体示例，开发者可以查看这两个图，并更容易地将它们与他们的工作联系起来。'
- en: '*Implementation* contains a description of how to implement the pattern. In
    this book, I’ve used numbered diagrams to describe how the pieces fit together.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现*部分包含如何实现该模式的描述。在这本书中，我使用了编号图来描述各个部分是如何组合在一起的。'
- en: '*Sample Code* or *Pseudocode* mostly speaks for itself. I would recommend real-world
    examples instead of class A inheriting from class B, which uses class C in composition.
    That’s too abstract. If you want people to use your pattern, find ways to make
    it relevant to their work.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*示例代码*或*伪代码*通常不言自明。我建议使用现实世界的例子，而不是类A从类B继承，类B又组合了类C。这太抽象了。如果你想让人们使用你的模式，找到使其与他们的工作相关的方法。'
- en: Consequences of using the pattern
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用该模式的结果
- en: You should always discuss the positive outcomes and trade-offs that come with
    using your pattern. Most patterns have defenders and detractors. If you read up
    on patterns on the internet, you’ll see a healthy debate about how some patterns
    might be antipatterns. We presented such a case when we discussed the Singleton
    pattern in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063). The more complex a
    pattern, the more likely it is to have trade-offs. The Template Method pattern
    is extremely simple. I doubt whoever came up with that one lost any sleep over
    thinking about possible negative outcomes. In contrast, the Façade pattern presented
    in [*Chapter 4*](B18605_04.xhtml#_idTextAnchor078)presents a trade-off between
    the complexity of the third-party framework and ease of use for developers that
    don’t need everything the third-party framework exposes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终讨论使用你的模式所带来的积极成果和权衡。大多数模式都有支持者和反对者。如果你在网上阅读有关模式的资料，你会看到关于某些模式可能成为反模式的健康辩论。我们在讨论[*第3章*](B18605_03.xhtml#_idTextAnchor063)中的Singleton模式时，就提出了这样一个案例。模式越复杂，出现权衡的可能性就越大。模板方法模式极其简单。我怀疑提出这个模式的人是否曾因考虑可能的负面结果而失眠。相比之下，[*第4章*](B18605_04.xhtml#_idTextAnchor078)中提出的外观模式（Façade
    pattern）在第三方框架的复杂性和不需要第三方框架暴露的所有内容的开发者的易用性之间提供了一个权衡。
- en: Not everybody likes patterns
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并非每个人都喜欢模式
- en: We demonstrated in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)’s coverage
    of the Singleton pattern that not everybody agrees that patterns are a positive
    contribution to the field of software development. The usual argument is design
    patterns are simply workarounds for incapable, inefficient, or incomplete OOP
    languages. Academic literature has shown as many as 17 of the 23 patterns within
    the GoF book become unnecessary when you use languages such as **List Processing**
    (**LISP**) or Dylan. What? Who even uses those?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第3章*](B18605_03.xhtml#_idTextAnchor063)中对Singleton模式的讨论中展示了，并不是每个人都认为模式是对软件开发领域的积极贡献。通常的论点是设计模式只是对无能、低效或不完整的OOP语言的权宜之计。学术文献表明，在GoF书中，当使用诸如**列表处理**（List
    Processing）或Dylan之类的语言时，多达17个模式变得不再必要。什么？谁甚至使用这些？
- en: Another group of academic detractors advocates switching your paradigm from
    OOP to **aspect-oriented programming** (**AOP**) as a solution to all your problems.
    As you’re hopefully aware, OOP aims to solve problems by modeling things in the
    real world. AOP aims to model behavior as crosscutting concerns. AOP is not supposed
    to be a competitor with OOP, yet some arguments place it that way.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组学术上的反对者主张将你的范式从面向对象编程（OOP）切换到**面向方面编程**（AOP）作为解决所有问题的方案。你可能已经知道，OOP旨在通过在现实世界中建模事物来解决问题。AOP旨在将行为建模为横切关注点。AOP不应该与OOP竞争，但有些论点将其定位为竞争关系。
- en: The bottom line is there will always be a debate that says “If you would only
    switch to language X, framework Y, or paradigm Z, all your pattern problems will
    be solved!” My retort to that is to remind you to beware of the Golden Hammer!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 核心观点是，总会有辩论说：“如果你只是切换到语言X、框架Y或范式Z，你所有的模式问题都会得到解决！”我对这种说法的回答是提醒你要警惕“黄金锤”！
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Patterns are everywhere. There is a field called biomimicry that aims to study
    technology inspired by patterns in nature. It’s difficult to talk about software
    development anymore without bringing up **artificial intelligence** (**AI**),
    whose main job is to find patterns in massive amounts of data using techniques
    called **machine learning** (**ML**). The software industry has been humming along
    now since 1843 when Ada Lovelace wrote what most consider to be the first computer
    program. In that time, we have collectively run into the same challenges and frustrations
    over and over again. Eventually, we got smart enough to start writing things down
    and talking about them.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 模式无处不在。有一个名为仿生学的领域，旨在研究受自然界模式启发的技术。现在谈论软件开发而不提及**人工智能**（**AI**）是很困难的，其主要任务是使用称为**机器学习**（**ML**）的技术在大量数据中寻找模式。自1843年Ada
    Lovelace编写了大多数人认为的第一个计算机程序以来，软件行业一直在嗡嗡作响。在那段时间里，我们反复遇到了相同的挑战和挫折。最终，我们足够聪明，开始把它们写下来并谈论它们。
- en: We’ve been learning patterns, which at their core are really just a way of communicating
    our best ideas as they relate to organizing and optimizing our code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在学习模式，其核心实际上仅仅是一种方式，通过这种方式我们可以传达与组织优化代码相关的最佳想法。
- en: 'In this chapter, we briefly covered the patterns from the original GoF book
    that we didn’t cover in the earlier chapters as part of this book’s story. I left
    these patterns out for one or two reasons in each case, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了原始GoF书中的一些模式，这些模式在本书的前几章中没有涉及，作为本书故事的一部分。在每个案例中，我出于一两个原因省略了这些模式，如下所述：
- en: If a pattern was remarkably similar to another pattern already covered, I didn’t
    cover it. The State pattern is very similar to the Strategy pattern. The Strategy
    pattern fit my story, so that’s the one I used.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个模式与已经介绍过的另一个模式非常相似，我就没有介绍它。状态模式与策略模式非常相似。策略模式适合我的故事，所以我使用了它。
- en: If a pattern was very complicated and rarely used, I didn’t cover it. The Memento
    pattern is a good example. There are easier ways to handle the use case of representing
    snapshots of objects such as .NET’s serialization features that negate the need
    for a complicated Memento pattern implementation.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个模式非常复杂且很少使用，我就没有介绍它。备忘录模式是一个很好的例子。有更简单的方法来处理表示对象快照的使用案例，例如.NET的序列化功能，这否定了复杂备忘录模式实现的需要。
- en: We went beyond GoF patterns, and even beyond OOP patterns to list some common
    and highly familiar patterns in other domains of software and database architecture.
    We concluded with a synopsis of how you might go about documenting your own patterns
    should you ever discover a new one. I left you in this chapter with a final warning.
    You’re going to be tempted to close this book and run through the office like
    a crazy person yelling “PATTERNS!” everywhere you go. Don’t laugh. I’ve seen it
    happen. If you do this, expect some eye rolls. Not everybody thinks patterns are
    a good idea, and sometimes they are right. Patterns themselves can easily succumb
    to the Golden Hammer antipattern. Remember—patterns are here to simplify and improve
    your software. If they make things slower or more complicated, you must abandon
    them in those cases. Patterns are tools, not dogma.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们超越了GoF模式，甚至超越了面向对象模式，列出了软件和数据库架构其他领域的一些常见且高度熟悉的模式。我们以如何记录你自己的模式（如果你发现了新的模式）的概述作为结尾。我在本章中给你留下了最后的警告。你可能会想关上这本书，像疯子一样在办公室里到处大喊“模式！”不要笑。我见过这种情况发生。如果你这样做，预期会有一些翻白眼。并不是每个人都认为模式是个好主意，有时他们是对的。模式本身很容易陷入黄金锤反模式。记住——模式是为了简化并改进你的软件。如果它们使事情变得更慢或更复杂，你必须在这些情况下放弃它们。模式是工具，而不是教条。
- en: There’s just one loose end to tie up.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一处 loose end（未了结的尾巴）需要解决。
- en: Sundance Square – Fort Worth, Texas
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 萨恩迪斯广场 – 德克萨斯州沃斯堡
- en: It was a hot spring day in Fort Worth, Texas. And it was the last day of the
    MS-150 bicycle rally. The MS-150 is an event that generates millions of dollars
    per year toward research into a cure for **multiple sclerosis** (**MS**). Thousands
    of cyclists in the Dallas area ride in the 150-mile, 2-day event. Most of the
    local bike shops have tents set up in Sundance Square, a shopping and entertainment
    district in the heart of Fort Worth. Bumble Bikes, being a platinum sponsor, has
    a large tent set up at the finish line.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在德克萨斯州沃斯堡，那是一个温泉天。那是MS-150自行车拉力赛的最后一天。MS-150是一项每年为治疗**多发性硬化症**（**MS**）的研究筹集数百万美元的活动。达拉斯地区的数千名自行车手参加了这场150英里、为期两天的活动。大多数当地自行车店都在沃斯堡市中心的购物和娱乐区Sundance
    Square设立了帐篷。作为白金赞助商，Bumble Bikes在终点线处搭建了一个大型帐篷。
- en: Tom, Lexi, and Karina are working the tent, giving water and high-fives to the
    intrepid few that cross the finish line. While upward of 3,000 riders start the
    rally, fewer than 10% actually finish. Most quit along the way when their knees
    give out or their equipment breaks. Tom and Lexi are watching keenly for a group
    of riders who they fully expect to finish dead last. It’s a rally, not a race.
    The people who ride aren’t competing against each other—they’re competing with
    themselves to see if they have what it takes to complete the course. They start
    in Plano on day 1 and pedal 75 miles to Texas Motor Speedway where local **National
    Association for Stock Car Auto Racing** (**NASCAR**) races are held. The next
    day they start again but first, they do a lap on the speedway, then ride 75 more
    miles into Fort Worth.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 汤姆、莱克西和卡瑞娜正在帐篷里工作，向冲过终点的勇敢者们提供水和击掌。虽然超过3,000名骑手开始这场拉力赛，但不到10%的人真正完成。大多数人因为膝盖疼痛或设备故障而中途放弃。汤姆和莱克西密切注视着一群骑手，他们完全预期他们会是最后一名完成比赛的。这是一个拉力赛，而不是比赛。骑手们不是在相互竞争——他们是在与自己竞争，看看自己是否有完成全程的能力。他们在第一天从普莱诺出发，骑行75英里到达德克萨斯州赛车场，那里举行当地的**全国汽车赛车协会**（**NASCAR**）比赛。第二天他们再次出发，但首先在赛车场跑了一圈，然后骑行75英里到达沃斯堡。
- en: '“*There they are!*”Lexi yells as she squints toward the top of a hill in the
    distance. *Team Bumbles* is cresting the hill, all riding brand new Hillcrest
    bicycles: Kitty, Phoebe, and most of the Bumble Bikes employees, along with Kitty
    and Phoebe’s father.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “*他们就在那里!*”莱克西喊道，她眯着眼睛朝远处的一个小山丘看去。“Bumbles队”正在翻越这座山丘，所有人都在骑全新的Hillcrest自行车：凯蒂、菲比，以及大多数Bumble
    Bikes的员工，还有凯蒂和菲比的父亲。
- en: 10 years have passed since his diagnosis. The chemotherapy and steroids had
    been ineffective in treating the disease. In fact, the steroids had caused a severe
    case of osteoporosis. The doctors had given up, saying there was nothing further
    that could be done. Kitty and Phoebe had prayed countless times, ultimately joined
    by an informal coalition of local churches.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 自从他确诊以来已经过去了10年。化疗和类固醇治疗对治疗这种疾病无效。事实上，类固醇导致了严重的骨质疏松症。医生们已经放弃了，说已经没有更多的办法可以尝试。凯蒂和菲比无数次地祈祷，最终得到了当地教堂非正式联盟的支持。
- en: The wheelchairs Kitty and Phoebe built were extremely helpful. They had built
    and distributed over 1,000 wheelchairs free of charge to children’s hospitals
    all over the world. Bicycle and wheelchair sales at Bumble Bikes grew steadily
    until it became the number 3 bicycle manufacturer in the world, and the only company
    to produce its products in the **United States** (**US**). MegaBikeCorp, the company
    where Kitty and Phoebe interned all those years ago, was ranked at number 19.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 凯蒂和菲比制作的轮椅非常有帮助。他们免费为世界各地的儿童医院制作并分发了超过1,000辆轮椅。Bumble Bikes的自行车和轮椅销售稳步增长，直到成为世界上第三大自行车制造商，也是唯一一家在其产品中标注**美国**（**US**）的公司。MegaBikeCorp，凯蒂和菲比多年前实习的公司，排名第19位。
- en: Their father had been using his *Texas Tank* for many years. The design had
    proved too expensive to mass produce, so they only made one. As much as he loved
    his *Tank*, every day he made it a practice to try to stand up. Most days he fell
    down. Until one day, he didn’t.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的父亲多年来一直在使用他的“Texas Tank”。这种设计证明生产成本太高，无法大规模生产，所以他们只制作了一辆。尽管他非常喜欢他的“Tank”，但他每天都会尝试站起来。大多数日子他会摔倒。直到有一天，他没有摔倒。
- en: As suddenly as it had started, one day it stopped. The doctors could not explain
    it. They had run out of ideas years ago. Kitty and Phoebe knew their prayers had
    been answered.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它突然开始一样，有一天它停止了。医生们无法解释这一点。他们多年前就已经用尽了所有的想法。凯蒂和菲比知道他们的祈祷得到了回应。
- en: It took years of physical therapy. Electrical shock therapy was needed to get
    their father’s voice box working again after the disease had nearly destroyed
    the muscles in his throat. He took shots in the stomach every day for 2 years
    to cure the osteoporosis. He took short walks—a few blocks at first, but later
    it was a few miles. Month after month, and year after year, he got a little stronger.
    He traded his *Texas Tank* for one of Bumble Bikes’ new electric bicycles with
    a motor. Tom was happy to take the *Tank* off his hands. The new electric bike
    offered a motor to assist with pedaling. The motor didn’t do all the work—it just
    helped.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要多年的物理治疗。在疾病几乎摧毁了他喉咙中的肌肉之后，需要电击疗法来让他的声带恢复工作。他每天在胃部注射以治疗骨质疏松症。他每天进行短距离散步——最初是几块街区，但后来是几英里。月复一月，年复一年，他变得越来越强壮。他将他的*德克萨斯坦克*换成了Bumble
    Bikes的新款带电机的电动自行车。汤姆很高兴将*坦克*从他的手中拿走。这款新电动自行车提供了一种助力踏车的电机。电机并不是做所有的工作——它只是帮助。
- en: Eventually, he was able to ride a normal bicycle again, and today, he had ridden
    it 75 miles to the finish line with his daughters and a small armada of handicapped
    riders. Bumble Bikes had produced a hand-cranked bicycle for riders who couldn’t
    use their legs and invited any rider who didn’t have such a bicycle to ride with
    *Team Bumbles*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，他能够再次骑上普通自行车了，今天，他和他的女儿们以及一支小型残疾人骑行队伍一起骑行了75英里到达终点线。Bumble Bikes为无法使用双腿的骑行者生产了手摇自行车，并邀请任何没有这种自行车的骑行者加入*Team
    Bumbles*。
- en: Everyone in the square stopped what they were doing and cheered as they saw
    the *back of the pack*, followed by a police escort crossing the line. It had
    been a very long road, not just because 75 miles is a long way to ride a bicycle
    in 1 day. The finish line meant so much more than the end of the rally. Most importantly,
    they crossed it as a family.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们看到队伍的*最后一名*，随后是警察护送通过终点线时，广场上所有人停止了手中的事情，为他们欢呼。这是一条非常漫长的道路，不仅仅是因为一天内骑行75英里是很长的距离。终点线意味着的不仅仅是拉力的结束。最重要的是，他们作为一个家庭一起跨过了终点线。
- en: Further reading
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.redhat.com/architect/14-software-architecture-patterns](https://www.redhat.com/architect/14-software-architecture-patterns)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.redhat.com/architect/14-software-architecture-patterns](https://www.redhat.com/architect/14-software-architecture-patterns)'
- en: '*Nock, Clifton. Data Access Patterns: Database Interactions in Object-Oriented
    Applications. Boston: Addison-Wesley, 2004.*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*诺克，克利夫顿。数据访问模式：面向对象应用程序中的数据库交互。波士顿：Addison-Wesley，2004.*'
- en: 'The companion website for this book: [https://csharppatterns.dev](https://csharppatterns.dev)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书配套网站：[https://csharppatterns.dev](https://csharppatterns.dev)
- en: 'Appendix 1: A Brief Review of OOP Principles in C#'
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录1：C#中OOP原则的简要回顾
- en: The landscape of programming languages contains hundreds of choices. If you’re
    reading this book, you have probably come across C# at some point along your journey.
    For some, C# is the only language they’ve ever learned. For others, it’s the third
    or fourth. Maybe you develop in C# every day and have for many years, or maybe
    you’ve just picked it up, and it’s now your new best friend.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的领域中有数百种选择。如果你正在阅读这本书，你可能在旅途中某个时刻遇到过C#。对于一些人来说，C#是他们唯一学过的语言。对于其他人来说，它是第三或第四种语言。也许你每天都在用C#开发，已经很多年了，或者你可能刚刚开始学习，现在它成了你的新好朋友。
- en: I realize that readers will be coming to this book with different levels of
    experience, different backgrounds, and different career objectives. I used to
    have a very popular video series published on LinkedIn Learning that was designed
    to teach C# to beginners. To be honest, this has always been my favorite audience.
    Teaching software development to newbies is like teaching magic in a jaded world
    sadly short of vision. I get to see *Aha!* moments nearly every week with my students
    at Southern Methodist University, where I teach at the Full Stack Code boot camp.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我意识到读者们带着不同的经验水平、不同的背景和不同的职业目标来到这本书。我过去在LinkedIn Learning上发布了一个非常受欢迎的视频系列，旨在教授C#入门。说实话，这始终是我最喜欢的受众。教新手软件开发就像在一个缺乏远见的世界上教授魔法。我每周几乎都能在我的学生中看到“啊哈！”的时刻，我在南方卫理公会大学的全栈代码训练营教授。
- en: One of the things that excited me about the prospect of writing this book is
    this book helps you take the next step. Either you’ve just learned how to code
    or maybe you’ve been using the same magic tricks for many years with success,
    but you realize there’s still more to learn. Patterns are a great next step. Learning
    patterns makes you better at almost everything else in programming.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我对撰写这本书的前景感到兴奋的一件事是这本书能帮助你迈出下一步。要么你刚刚学会了如何编码，要么你可能已经成功使用了多年的魔法技巧，但你现在意识到还有更多东西要学。模式是一个很好的下一步。学习模式会使你在编程的几乎所有其他方面都变得更好。
- en: The problem here is that I don’t know where you are in your journey. If you’re
    a student of mine from SMU, you’ve learned JavaScript really well and you want
    to take the next step. C# is radically different from JavaScript. Jumping into
    this book from only knowing JavaScript would be hard, but not impossible. If you’re
    self-taught, you’ve probably focused on what I call “survival skills.” They include
    basic OOP plus how to work with a database and probably web technologies. If you’re
    in a university, and you’re learning how to code, your textbooks are likely not
    very illuminating. I know. I’ve taught at colleges and universities for 25 years.
    Usually, I write my own material because of the dearth of good books out there.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我不知道你在你的旅程中处于什么位置。如果你是我的 SMU 学生，你已经非常擅长 JavaScript，并想迈出下一步。C# 与 JavaScript
    完全不同。仅知道 JavaScript 就跳入这本书会有难度，但并非不可能。如果你是自学成才的，你可能专注于我所说的“生存技能”。它们包括基本的面向对象编程以及如何与数据库和可能的技术工作。如果你在大学里学习如何编码，你的教科书可能不太有启发性。我知道。我在大学和学院里教了
    25 年书。通常，我写自己的材料，因为市面上好的书籍很少。
- en: No matter where you are right now, or where you came from, this chapter is here
    to orient you. Originally, I had intended this to be the second chapter of this
    book. My editor wisely suggested we get into working with patterns as quickly
    as possible. She suggested an appendix, which we’ve mentioned throughout the book.
    You’ll either get a good review or a crash course in C#.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你现在身处何地，无论你来自何方，这一章都是为了指引你。最初，我打算将这作为本书的第二章。我的编辑明智地建议我们尽快开始使用模式。她建议添加一个附录，我们在整本书中都提到了。你将获得良好的复习或
    C# 的快速课程。
- en: 'In this appendix, you can expect to learn the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个附录中，你可以期待学习以下内容：
- en: A quick background on C# and how the language can be defined along a number
    of lines of taxonomy. That sounds fancy, but you’ll see it’s fairly basic.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 C# 的快速背景介绍以及如何沿着一系列分类学线条定义这种语言。这听起来很复杂，但你会发现它相当基础。
- en: The syntax mechanics of C# with enough length and detail to get you through
    this book. Since this book mainly deals with plain old C# objects (POCOs) and
    a few common types from .NET Framework such as Lists, this section is possible.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的语法机制，长度和细节足够让你通过这本书。由于这本书主要处理普通的 C# 对象（POCOs）和来自 .NET Framework 的几个常见类型，如列表，这一节是可能的。
- en: 'How to set up the projects in the book using three common IDEs in Windows.
    There are two project types we use: command-line projects and libraries.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Windows 中的三个常见 IDE 设置本书中的项目。我们使用了两种项目类型：命令行项目和库。
- en: How to clone the sample code projects covered in the book.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何克隆本书中涵盖的示例代码项目。
- en: Let’s get started!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This appendix is largely an overview of basic topics rather than a collection
    of projects. With that said, at the end of the appendix, you are guided in the
    use of the three most popular C# IDEs on the market today. You’ll have a choice
    to make. Regardless of which IDE you choose, you’ll need a computer running the
    Windows operating system. I’m using Windows 10\. The projects used in this book
    probably work fine on a Mac or in Linux, but I didn’t test them there, so your
    mileage might vary.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录主要是基本主题的概述，而不是项目集合。话虽如此，在附录的末尾，你将指导使用目前市场上最流行的三个 C# IDE。你将有一个选择。无论你选择哪个
    IDE，你都需要一台运行 Windows 操作系统的计算机。我使用的是 Windows 10。本书中使用的项目可能在 Mac 或 Linux 上也能正常工作，但我没有在那里测试过，所以你的体验可能会有所不同。
- en: 'To follow the IDE tutorials at the end of this chapter, you’ll need the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章末尾的 IDE 教程，你需要以下内容：
- en: 'One of these IDEs:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些 IDE 之一：
- en: Visual Studio
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: '**Visual Studio Code** (**VS Code**)'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code** (**VS Code**)'
- en: JetBrains Rider
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains Rider
- en: .NET Core 6 SDK
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 6 SDK
- en: You can find the completed project files for this chapter on GitHub at [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章的完整项目文件，网址为 [https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1](https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/appendix-1)。
- en: A quick background of C#
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 的简要背景
- en: 'Let me just say it out loud right off the bat: C# is a knock-off of Java. If
    you know Java, but not C#, you’re going to have a very easy time. Now, pretend
    I didn’t lead with that and allow me to slip on my corduroy sport coat. The one
    with the patches on the elbows. I have a tobacco pipe in the front pocket of the
    jacket sticking up so that you can see it. Naturally, in this day and age, nobody
    would dream of putting tobacco or anything else into it. That’d be wrong. But
    I need to look as much like a college professor as possible, so I can go all historical
    on you for a bit.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我直接大声说出来：C# 是 Java 的仿制品。如果你知道 Java 但不知道 C#，你将会非常容易上手。现在，假装我没有先提到这一点，让我穿上我的灯芯绒运动夹克。夹克上有肘部的补丁。我在夹克的正面口袋里放了一根烟斗，让它竖起来，这样你可以看到它。当然，在这个时代，没有人会想到把烟草或其他东西放进去。那是不对的。但为了尽可能看起来像一位大学教授，我可以稍微讲一些历史。
- en: The C# language is Microsoft’s flagship language product for corporate and game
    programming. It was designed by Anders Hjlsberg in the year 2000 AD. Some of my
    students claim I am ancient, so I figured I’d clarify by stating that it is, in
    fact, AD and not BC. The language was submitted and approved as a standardized
    language via the **European Computer Manufacturers Association** (**ECMA**). You
    might know this is as the same body that standardized JavaScript, which is really
    called ECMAScript. Many languages are standardized. This simply means that there
    is an open specification available for the language and that it is possible for
    others to create a competing implementation of a language based on the specification.
    C# is Microsoft’s implementation. There is an open source competitor called Mono
    that used to be popular in several arenas, including cross-platform mobile and
    game development.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: C# 语言是微软为企业和游戏编程的旗舰语言产品。它由安德斯·赫尔伯格于公元 2000 年设计。我的有些学生声称我非常古老，所以我通过指出它是公元 AD
    而不是 BC 来澄清这一点。该语言通过 **欧洲计算机制造商协会**（**ECMA**）提交并获得批准，作为标准化语言。你可能知道这个机构也标准化了 JavaScript，它实际上被称为
    ECMAScript。许多语言都是标准化的。这仅仅意味着语言有一个公开的规范可用，其他人可以根据规范创建基于该语言的竞争性实现。C# 是微软的实现。有一个开源的竞争对手叫做
    Mono，它曾经在一些领域非常流行，包括跨平台移动和游戏开发。
- en: When Microsoft introduced C#, it also released .NET Framework and Visual Studio.
    .NET Framework is a massive set of libraries that provides a language support
    infrastructure for C# along with other Microsoft languages. Each language supported
    can compile its code into an intermediate format. The intermediate form at, called
    **Microsoft Intermediate Language** (**MSIL**), can then execute using the .NET
    runtime. This makes the overall language architecture very similar to Java, which
    compiles to an intermediate form called bytecode, which is then executed on a
    **Java Virtual Machine** (**JVM**).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软推出 C# 时，它还发布了 .NET Framework 和 Visual Studio。.NET Framework 是一套庞大的库，为 C#
    以及其他微软语言提供了语言支持基础设施。每个支持的语言都可以将其代码编译成中间格式。这种中间形式称为 **Microsoft Intermediate Language**（**MSIL**），然后可以使用
    .NET 运行时执行。这使得整体语言架构与 Java 非常相似，Java 编译成中间形式称为字节码，然后在 **Java 虚拟机**（**JVM**）上执行。
- en: 'The stated design goals for the language include the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言的声明性设计目标包括以下内容：
- en: A simple, general-purpose, object-oriented language
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种简单、通用、面向对象的语言
- en: Support for a strong, statically typed variable system
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持强大的静态类型变量系统
- en: Automatic bounds checking on array types and the detection of uninitialized
    variables
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组类型上的自动边界检查和未初始化变量的检测
- en: Automated garbage collection
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动垃圾回收
- en: Source code portability; code should be executable in a variety of environments
    without changing the code significantly and without recompiling
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码的可移植性；代码应在各种环境中执行，无需显著更改代码且无需重新编译
- en: Let’s expand on these ideas.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨这些想法。
- en: C# is a general-purpose language
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 是一种通用编程语言
- en: 'Pretty much everyone has heard of an invention created by Richard Clyburn in
    1842\. I present you with an adjustable wrench in *Figure A.1*:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个人都听说过理查德·克莱本在 1842 年发明的东西。我在图 A.1 中向你展示了一个可调节扳手：
- en: '![Figure A1.1: An adjustable wrench. You can use this for almost any wrenching
    job. If you’re in a jam, you can also use it to open bottles and drive nails.
    It’s a general-purpose tool just like the C# language, which can be used to make
    almost any kind of software ](img/Figure_A1.1_B18605.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.1：一个可调节扳手。你可以用它来做几乎所有需要扳手的活儿。如果你遇到麻烦，你也可以用它来开瓶盖和钉钉子。它是一个多用途的工具，就像 C#
    语言一样，可以用来制作几乎任何类型的软件](img/Figure_A1.1_B18605.png)'
- en: 'Figure A1.1: An adjustable wrench. You can use this for almost any wrenching
    job. If you’re in a jam, you can also use it to open bottles and drive nails.
    It’s a general-purpose tool just like the C# language, which can be used to make
    almost any kind of software'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.1：一个可调节扳手。你可以用它来做几乎所有需要扳手的活儿。如果你遇到麻烦，你也可以用它来开瓶盖和钉钉子。它是一个多用途的工具，就像 C# 语言一样，可以用来制作几乎任何类型的软件
- en: We call them *crescent wrenches* in the US, while many other countries refer
    to them as *spanners*. This wrench is a general-purpose wrench. It can be used
    for a variety of tasks befitting a wrench from the loosening and tightening of
    metal fasteners on your IKEA furniture to installing a new engine in your ‘57
    Chevy, to installing a new garbage disposal for your kitchen sink.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国，我们称之为 *crescent 扳手*，而许多其他国家称之为 *spanners*。这个扳手是一个通用扳手。它可以用于各种适合扳手的任务，从松开和拧紧
    IKEA 家具上的金属紧固件到在你的 1957 年雪佛兰汽车中安装新引擎，再到为你的厨房水槽安装新的垃圾处理器。
- en: 'Now consider the wrench in *Figure A1.2*:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑图 A1.2 中的扳手：
- en: '![Figure A1.2: This is a basin wrench. It’s only good for one thing: tightening
    down fastening nuts on faucet hardware under a sink. It is a special-purpose tool
    just like SQL is a special-purpose language. Both can only be used for one purpose
    ](img/B18605_Figure_A1.2.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.2：这是一个 basin 扳手。它只适用于一件事：在洗碗池下拧紧水龙头硬件上的固定螺母。它是一个专用工具，就像 SQL 是一种专用语言一样。两者都只能用于一个目的](img/B18605_Figure_A1.2.jpg)'
- en: 'Figure A1.2: This is a basin wrench. It’s only good for one thing: tightening
    down fastening nuts on faucet hardware under a sink. It is a special-purpose tool
    just like SQL is a special-purpose language. Both can only be used for one purpose'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.2：这是一个 basin 扳手。它只适用于一件事：在洗碗池下拧紧水龙头硬件上的固定螺母。它是一个专用工具，就像 SQL 是一种专用语言一样。两者都只能用于一个目的
- en: You might have never encountered one of these before. This odd-looking contraption
    is called a *basin wrench*. It has only one job. It is used to tighten the faucet
    coupling when installing a new kitchen or bathroom sink. The wrench head pivots
    across 180 degrees, so you can maneuver it around all the pipes. The long handle
    helps you deal with the sink bowl that protrudes downward, blocking your access
    were you to attempt this with a general-purpose wrench.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以前从未遇到过这样的东西。这个看起来奇怪的装置被称为 *basin 扳手*。它只有一个任务。它用于在安装新的厨房或浴室水槽时拧紧水龙头连接。扳手头可以旋转
    180 度，这样你就可以在所有管道周围操作。长把手帮助你处理向下突出的水槽碗，如果你用通用扳手尝试这样做，这会阻挡你的操作。
- en: Likewise, there exist a few special-purpose languages, the most popular being
    **Structured Query Language** (**SQL**). SQL is only used to query relational
    databases. You can’t make a video game or an operating system with it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，存在一些专用语言，其中最流行的是**结构化查询语言**（**SQL**）。SQL 只用于查询关系型数据库。你不能用它来制作视频游戏或操作系统。
- en: On the other hand, C# is a general-purpose language. It can be used to make
    just about anything from line-of-business software to AAA video games. And yes,
    someone did once try to make an operating system with C# called *SharpOS,* showing
    us that it is possible to write an operating system with C#.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，C# 是一种通用语言。它可以用来制作从企业级软件到 AAA 级视频游戏几乎任何东西。是的，有人曾经尝试用 C# 制作一个名为 *SharpOS*
    的操作系统，这表明用 C# 编写操作系统是可能的。
- en: The biggest reason to choose C# as your main language of choice is the flexibility.
    Coupled with .NET Framework, you have thousands of building blocks. You can use
    them to build whatever software you might need.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 C# 作为你的首选语言的最大原因是其灵活性。结合 .NET 框架，你拥有数千个构建块。你可以使用它们来构建你可能需要的任何软件。
- en: C# is purely and fully object-oriented
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 是纯粹且完全面向对象的
- en: 'There are two major paradigms that you’ll see in programming languages: OOP
    and functional programming languages. Perhaps a third paradigm occurs when it
    is possible to mix the two within a single language. Let’s cover the differences:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在编程语言中看到两种主要的范式：面向对象编程和函数式编程语言。也许当有可能在单一语言中混合这两种范式时，会出现第三种范式。让我们来看看它们之间的区别：
- en: '| **OOP** | **Functional programming** |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| **面向对象编程** | **函数式编程** |'
- en: '| Code is organized into classes as the primary building block of your program.
    | Code is organized into distinct functions, which use their arguments in place
    of properties. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 代码被组织成类，作为程序的主要构建块。 | 代码被组织成不同的函数，这些函数使用它们的参数代替属性。|'
- en: '| Methods often have side effects. They can change the state of the object
    from within the method. | Pure functions never have side effects. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 方法通常具有副作用。它们可以在方法内部改变对象的状态。 | 纯函数永远不会产生副作用。|'
- en: '| In OOP, we have support for mutable and immutable objects. | Function programming
    never supports mutable variables. If you want to change something, you have to
    create a new variable. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 在面向对象编程中，我们支持可变和不可变对象。 | 函数式编程从不支持可变变量。如果你想改变某物，你必须创建一个新的变量。|'
- en: '| Data is stored in properties within the object and is prioritized from a
    design perspective above methods that often serve only to mutate the state of
    the object. | The design goals are focused on functions. They take immutable inputs
    and produce an output. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 数据存储在对象的属性中，并且从设计角度来看，它们比通常只用于改变对象状态的函数具有更高的优先级。 | 设计目标集中在函数上。它们接受不可变输入并产生输出。|'
- en: 'Figure A1.3: The difference between OOP and functional programming.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.3：面向对象编程和函数式编程之间的区别。
- en: Some languages, such as C# and Java, are strictly object-oriented. Languages
    such as Haskell and F# are strictly functional, while languages such as JavaScript,
    Python, and PHP can support either or both paradigms. The original **Gang of Four**
    (**GoF**) software design patterns, which are the focus of this book, were built
    around OOP using a language called *SmallTalk*. Naturally, we’ll keep our focus
    strictly on OOP.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如C#和Java，是严格面向对象的。像Haskell和F#这样的语言是严格函数式的，而像JavaScript、Python和PHP这样的语言可以支持其中一种或两种范式。本书重点介绍的原始**四人帮**（**GoF**）软件设计模式，是围绕面向对象编程使用SmallTalk语言构建的。自然地，我们将严格关注面向对象编程。
- en: C# uses a static, strong type system
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#使用静态、强类型系统
- en: 'There are three schools of thought with respect to type systems. First, let
    me tell you what I mean by a **type system**. Programming languages share a common
    purpose: they all take some sort of input and turn it into some sort of output.
    The input and output for the program are called **data**. There are three basic
    types of data as far as your computer is concerned.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型系统，存在三种不同的观点。首先，让我告诉你我所说的**类型系统**是什么意思。编程语言有一个共同的目的：它们都接受某种输入并将其转换为某种输出。程序的输入和输出被称为**数据**。就你的计算机而言，存在三种基本的数据类型。
- en: '**Strings** are alphanumeric data – think letters and numbers. If you can type
    it on your keyboard, it is alphanumeric.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**是字母数字数据——想想字母和数字。如果你能在键盘上输入它，它就是字母数字的。'
- en: The second type of data is **numbers**. I think you know what this means. While
    numbers can be alphanumeric strings, you can’t use strings to do math. This distinction
    is at the heart of a strong type system, so remember this for just a moment.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种数据类型是**数字**。我想你知道这是什么意思。虽然数字可以是字母数字字符串，但你不能使用字符串进行数学运算。这种区别是强类型系统的核心，所以请记住这一点。
- en: The third basic type of data is **booleans**. Booleans are binary, meaning they
    can have a value of either true or false. Sometimes, the value is expressed as
    0 (false) and 1 (true), or 0 (false) and not 0 (true).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种基本的数据类型是**布尔值**。布尔值是二进制的，这意味着它们可以具有真或假的值。有时，这个值会表示为0（假）和1（真），或者0（假）和非0（真）。
- en: The three basic types are called **primitive data types**. In a **strong type
    system**, you have to tell your program what kind of data you will be using when
    you declare a variable or create a function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种基本类型被称为**原始数据类型**。在**强类型系统**中，当你声明变量或创建函数时，你必须告诉你的程序你将使用什么类型的数据。
- en: Beyond primitive types, C# supports the ability to create your own types as
    objects. Like primitives, these types are strong. They are also static. A **static
    type system** means that when you say you are going to use a variable to hold
    a string, you can never change the variable to any other type. It is static, meaning
    it can never change its type.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 除了原始类型之外，C# 支持创建自己的类型作为对象。像原始类型一样，这些类型是强的，也是静态的。**静态类型系统**意味着当你说你将使用一个变量来存储字符串时，你永远不能将变量更改为任何其他类型。它是静态的，意味着它永远不会改变其类型。
- en: While C# and many other languages use a strong and static type of system, other
    languages do not. JavaScript took the opposite approach. JavaScript uses a weak
    and dynamic type of system. In such a system, it is perfectly fine and normal
    to create a variable and assign a value of any type. Let’s say we create a variable
    called *foo* and set it equal to “this is a string.”
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 和许多其他语言使用强静态类型系统，但其他语言并不如此。JavaScript 采取了相反的方法。JavaScript 使用弱动态类型系统。在这种系统中，创建一个变量并赋予任何类型的值是完全正常和合理的。比如说，我们创建一个名为
    *foo* 的变量并将其设置为“这是一个字符串。”
- en: The very next line can assign a value of 9 to the variable of *foo*. The fact
    that you didn’t have to declare a type with the variable indicates a **weak type
    system**. The fact you can change the type any time you’d like indicates a dynamic
    type system. JavaScript is incredibly powerful and flexible, but it also feels
    very foreign for developers who learn a strong static system leading to the idea
    that JavaScript is a “toy language” and not for serious work. This is, of course,
    wholly false.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的那一行可以将值 9 赋予名为 *foo* 的变量。你不需要用变量声明类型的事实表明这是一个 **弱类型系统**。你可以随时更改类型的事实表明这是一个动态类型系统。JavaScript
    非常强大和灵活，但它对于学习过强静态系统的开发者来说感觉非常陌生。这种想法认为 JavaScript 是一种“玩具语言”，不适合严肃的工作。这当然是完全错误的。
- en: The third type of system that you’ll encounter is called duck typing. Likely
    the most famous system using duck typing is Python. In Python, you see the middle
    ground between strong static typing in C# and the weak dynamic system in JavaScript.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到第三种类型系统，这被称为鸭子类型。最著名的使用鸭子类型的系统可能是 Python。在 Python 中，你看到了 C# 中的强静态类型和 JavaScript
    中的弱动态系统之间的中间地带。
- en: In Python, you don’t declare a type with your variables. However, the Python
    interpreter observes how the variable is used, and it infers a strong type. This
    kind of system is called duck typing because the designers who created this type
    of system claimed “If it walks like a duck and quacks like a duck, it’s a duck.”
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你不需要用变量声明类型。然而，Python 解释器会观察变量是如何使用的，并推断出一个强类型。这种系统被称为鸭子类型，因为创建这种类型系统的设计者声称：“如果它像鸭子走路，像鸭子嘎嘎叫，那么它就是一只鸭子。”
- en: Later versions of C# support also duck typing, so we’ll see some examples later.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的后续版本也支持鸭子类型，所以我们将在稍后看到一些示例。
- en: C# has automatic bounds checking and detection for uninitialized variables
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 具有自动边界检查和未初始化变量的检测功能。
- en: C# was created to correct deficiencies in other languages. You hear that for
    pretty much every new language created in the last 20 years. Some group hates
    the way something works in C or Java, so they make a new language. Usually, they
    are an amalgamation of the so-called good parts of other languages. If you don’t
    believe me, read up on Apple’s *Swift* language, the *Rust* language, or the *Golang*
    languages created by Google. C# isn’t any different.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的创建是为了纠正其他语言的不足。你几乎可以听到在过去 20 年中创建的每一种新语言都是如此。某个团体讨厌 C 或 Java 中某些工作的方式，因此他们创建了一种新的语言。通常，它们是其他语言所谓好部分的混合体。如果你不相信我，可以了解一下苹果的
    *Swift* 语言，谷歌创建的 *Rust* 语言或 *Golang* 语言。C# 并无不同。
- en: Studies have shown that the lack of bounds checking and uninitialized variables
    are both major sources of software bugs. Really, then, the objective here is to
    create a language that makes it harder for developers to make mistakes. In the
    next few features, we’ll discuss embodying this goal.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 研究表明，缺乏边界检查和未初始化变量都是软件错误的主要来源。实际上，这里的目的是创建一种让开发者更难犯错的编程语言。在接下来的几个特性中，我们将讨论实现这一目标的方法。
- en: Bounds checking refers to arrays. An array is a special type that allows you
    to store multiple values in a single variable. Since C# is strongly typed, array
    elements must all be of the same type. You can have an array of strings, an array
    of numbers, or an array of objects. Furthermore, in C# when you define an array,
    you must tell your program how many elements you will put into the array. Once
    you set it, the size is fixed and you can’t change it without jumping through
    some proverbial hoops.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 边界检查是指数组。数组是一种特殊类型，允许你在单个变量中存储多个值。由于C#是强类型，数组元素必须都是同一类型。你可以有一个字符串数组、数字数组或对象数组。此外，在C#中，当你定义一个数组时，你必须告诉你的程序你将放入数组中的元素数量。一旦设置，大小就固定了，你不能不跳过一些比喻性的障碍来改变它。
- en: Uninitialized variables are not just representative of sloppy work – in some
    programming languages they can be dangerous. The C programming language comes
    to mind here. C went through some drastic changes over the last 10 years, but
    back when I was your age, the mantra of C was “With great power comes great responsibility.”
    I think that’s also Spiderman’s mantra. Maybe Peter Parker should have been a
    coder instead of a photographer.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 未初始化的变量不仅仅是代表工作马虎——在某些编程语言中，它们可能是危险的。C编程语言在这里值得一提。C在过去10年中经历了一些剧烈的变化，但在我你这个年纪的时候，C的座右铭是“权力越大，责任越大。”我认为这也是蜘蛛侠的座右铭。也许彼得·帕克应该成为一名程序员而不是摄影师。
- en: In C, as in most languages, a variable is just a pointer to an address in memory.
    Computer memory is a lot like an apartment complex. In fact, older versions of
    C# and Visual Basic called their memory models “apartment threading.” Apartments
    are containers for you and your stuff. Some apartments are small and economical
    (unless you live in New York City, in which case they are simply small). Others
    are larger and more expensive. Regardless of their size, shape, and decor, their
    function is to hold you and your stuff.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，就像在大多数语言中一样，一个变量只是一个指向内存地址的指针。计算机内存就像一个公寓楼。实际上，C#和Visual Basic的早期版本将它们的内存模型称为“公寓线程”。公寓是你和你的东西的容器。有些公寓小而经济（除非你住在纽约市，在这种情况下，它们只是小）。其他公寓更大，也更贵。无论它们的大小、形状和装饰如何，它们的职能是容纳你和你的东西。
- en: Each apartment in an apartment complex has an apartment address number. So,
    you can effectively say *I want to put my stuff in apartment 122*. If you get
    a raise at work, and you decide to upgrade, you can move your stuff into apartment
    300, which is larger. The address tells us where your stuff is located, and the
    manager of your apartment building knows how big each apartment is and how much
    it costs.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公寓楼中的公寓都有一个公寓地址号码。因此，你可以有效地表示“我想把我的东西放在122号公寓*”。如果你在工作中得到加薪，并决定升级，你可以把你的东西搬到更大的300号公寓。地址告诉我们你的东西在哪里，而你的公寓楼经理知道每个公寓的大小和价格。
- en: Computer memory works the same way. There are registers of addresses (such as
    the apartment complex) that can be told to store stuff of varying sizes. We can
    extend our analogy to say the apartment manager is the computer running your program.
    It knows where the containers are since it keeps a list of each apartment’s address
    and how much space each apartment occupies.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存以同样的方式工作。有一些地址寄存器（如公寓楼）可以存储不同大小的物品。我们可以扩展我们的类比，说公寓管理员是运行你的程序的计算机。因为它保留了一个每个公寓地址和每个公寓占用空间的列表，所以它知道容器在哪里。
- en: The addresses are not simple numbers such as 122 or 300\. They are a bit more
    complicated and are not easy to work with. So, instead of dealing with addresses,
    we can give our apartments, or containers, a straightforward human-sounding name
    that describes how your variable is being used in your program.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 地址不是像122或300这样的简单数字。它们更复杂，不容易处理。因此，我们不是处理地址，而是可以给我们的公寓或容器一个简单易懂的名字，这个名字描述了你的变量在程序中的使用方式。
- en: When you create a container, such as an apartment, of a defined size (small
    and cheap versus big and expensive), it has an address. But instead of using that,
    you use whatever name you think is easy to use and remember.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个定义大小的容器，比如一个公寓（小而便宜与大而昂贵），它有一个地址。但你不使用那个地址，而是使用你认为容易使用和记忆的任何名字。
- en: Now imagine an apartment that was built as part of the building, but it is full
    of construction debris and trash left over from when it was built. Nobody has
    ever rented the apartment, so nobody has ever cleaned up the mess. This is an
    uninitialized variable. If someone wanted to rent the apartment and move in on
    the same day, that is, access the address, they would find it’s full of trash.
    When a running program with a strong static type system encounters trash that
    it doesn’t expect, the program crashes. If you have ever encountered a **blue
    screen of death** (**BSOD**) in Windows, you know what this looks like. Uninitialized
    variables will have whatever junk was left over from the last time that memory
    address was used. Back in the day, a major headache of working with C was manually
    allocating and deallocating memory. If you did it wrong, things crashed in the
    least graceful way possible. What the C developers really need is some way to
    handle garbage collection.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个作为建筑一部分建造的公寓，但它充满了建造时留下的建筑垃圾和垃圾。没有人租过这个公寓，所以没有人清理过这个混乱。这是一个未初始化的变量。如果有人想租这个公寓并在同一天搬进去，也就是说访问地址，他们会发现里面都是垃圾。当一个具有强大静态类型系统的运行程序遇到它不期望的垃圾时，程序会崩溃。如果你曾经遇到过Windows中的**蓝屏死机**（**BSOD**），你就知道这看起来像什么。未初始化的变量将保留上次使用该内存地址时留下的任何垃圾。在C语言中，手动分配和释放内存是工作中的一个主要头痛问题。如果你做错了，事情会以最不优雅的方式崩溃。C开发者真正需要的是一种处理垃圾回收的方法。
- en: C# supports automated garbage collection
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#支持自动垃圾回收
- en: The nightmare scenario we just covered shows the need for language improvements.
    C# is meant to be simple and useful. In C, back when C# was conceived, we were
    manually allocating memory addresses. This meant executing a statement that defined
    your allocation using a hexadecimal value. Most humans are doing well working
    in base 10\. Our old environments had us mentally converting decimal (base 10)
    numbers into base 8 (octal) and base 16 (hexadecimal) to do our memory allocations.
    Then, we used that memory, and when we were done, we needed to remember to deallocate
    the memory. In our apartment metaphor, this would entail moving out of the apartment
    and giving it thorough cleaning in the process. The apartment should be move-in
    ready when we deallocate.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论的噩梦场景显示了语言改进的必要性。C#旨在简单且实用。在C语言中，当C#被构想出来时，我们手动分配内存地址。这意味着执行一个使用十六进制值定义你的分配的语句。大多数人在以10为基数的情况下工作得很好。我们的旧环境让我们在心理上将十进制（基数10）数字转换为基数8（八进制）和基数16（十六进制）来进行内存分配。然后，我们使用那个内存，当我们完成时，我们需要记得释放内存。在我们的公寓比喻中，这相当于搬出公寓并在过程中彻底打扫。当我们释放内存时，公寓应该准备好供人入住。
- en: What if we had a language that handled allocation and deallocation automatically?
    We do. C# has a garbage collection system that handles everything for you. You
    create a variable, and the details are taken care of by the .NET runtime. When
    your variable goes out of scope, it gets marked for cleanup and, ultimately, the
    garbage collection process in the runtime deallocates and cleans up the memory
    for you. As you can imagine, the manual allocation and deallocation of memory
    in a system that had no safety net was also a major source of bugs.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个自动处理分配和释放的语言会怎样？我们有。C#有一个垃圾回收系统，为你处理一切。你创建一个变量，细节由.NET运行时处理。当你的变量超出作用域时，它会被标记为清理，最终运行时的垃圾回收过程会为你释放和清理内存。正如你可以想象的那样，在一个没有安全网的系统中进行手动分配和释放内存也是错误的主要来源。
- en: C# code is highly portable
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#代码具有高度的便携性
- en: The C# language specification aims at having portable code. In the earliest
    versions of C# and .NET, we weren’t very portable. Windows was all we had. You
    couldn’t run C# code on a Mac, Linux, or a phone. Gaming consoles were also out.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言规范旨在拥有可移植的代码。在C#和.NET的最早版本中，我们并不非常可移植。我们只有Windows。你无法在Mac、Linux或手机上运行C#代码。游戏机也不行。
- en: The open source community created Mono, an open source version of C# designed
    to run on Linux operating systems, but it has always been several years behind
    Microsoft’s implementation in C#. Eventually, Mono became a very popular way for
    C# developers to leverage their language skills to create mobile applications
    for the Android and iPhone platforms using Mono alongside a framework called Xamarin.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 开源社区创建了Mono，这是C#的开源版本，旨在在Linux操作系统上运行，但它始终落后于微软在C#中的实现几年。最终，Mono成为C#开发者利用他们的语言技能，使用Mono和名为Xamarin的框架创建移动应用程序，为Android和iPhone平台提供了一种非常流行的途径。
- en: A game development engine called Unity 3D also leveraged Mono and brought a
    AAA quality game engine to the mass market. Up until then, game engines such as
    Unreal were strictly in-house. The only way to develop a quality game was to work
    at a company that could afford the very expensive SDKs. Unity 3D busted the game
    development industry wide open, and they used C#/Mono to do it.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 Unity 3D 的游戏开发引擎也利用了 Mono，并将 AAA 级别的游戏引擎带到了大众市场。在此之前，像 Unreal 这样的游戏引擎都是严格内部使用的。唯一开发高质量游戏的方法是在能够负担得起非常昂贵的
    SDK 的公司工作。Unity 3D 打开了游戏开发行业的门户，他们使用 C#/Mono 来实现这一点。
- en: As time moved on, Microsoft made each iteration of the language more portable.
    We saw a big shift when Microsoft announced its Azure cloud platform. They wisely
    understood most IT professionals were never going to use a system that limited
    them to Microsoft products. Linux owns the majority share of web servers. When
    cloud computing started to reach critical mass in terms of popularity, we saw
    a huge proliferation of open source compatibility introduced into Microsoft’s
    landscapes including .NET Core, which allows us to compile and run C#, or any
    .NET language, to run on nearly any type of hardware environment making your code
    truly portable. The portability comes from the .NET runtime. Let me explain what
    that means.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，微软使每种语言的迭代都更加便携。当微软宣布其 Azure 云平台时，我们看到了一个巨大的转变。他们明智地认识到，大多数 IT 专业人士永远不会使用限制他们使用微软产品的系统。Linux
    拥有大多数网络服务器的份额。当云计算在受欢迎程度上达到临界质量时，我们看到微软的生态系统中引入了大量的开源兼容性，包括 .NET Core，它允许我们编译和运行
    C# 或任何 .NET 语言，在几乎任何类型的硬件环境中运行，使你的代码真正便携。这种便携性来自 .NET 运行时。让我解释一下这意味着什么。
- en: There are a few different ways any given programming language is able to execute
    code. First, there is code that can be compiled into native machine code. For
    this, you need a language such as C, C,++, or Rust. Programs that can be compiled
    this way run on “the bare metal,” making them very fast in terms of execution,
    but the languages required for this are typically more demanding to use. C and
    C++ require you to keep tabs on your memory utilization, which is the primary
    source of bugs written in these tools. Rust aims to eliminate memory errors with
    very strict compile time restrictions. Using these languages can be frustrating,
    and your time to market is usually slower, especially when adopting these languages
    for the first time. There’s a trade-off between developer productivity and the
    performance of the software when it runs for the users.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言执行代码的方式都有几种。首先，有可以编译成原生机器代码的代码。为此，你需要像 C、C++ 或 Rust 这样的语言。以这种方式编译的程序在“裸机”上运行，这使得它们在执行速度上非常快，但用于此的语言通常更难使用。C
    和 C++ 要求你监控你的内存使用情况，这是这些工具中编写的主要错误来源。Rust 通过非常严格的编译时间限制来消除内存错误。使用这些语言可能会很沮丧，而且你的上市时间通常较慢，尤其是在首次采用这些语言时。在开发者的生产力和软件运行时的性能之间有一个权衡。
- en: The second camp is languages that use interpreters. Usually, these languages
    are scripting languages such as Python, PERL, and Lua. These languages are built
    around developer productivity and, typically, sacrifice execution speed and efficiency.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阵营是使用解释器的语言。通常，这些语言是脚本语言，例如 Python、PERL 和 Lua。这些语言围绕开发者生产力构建，通常牺牲执行速度和效率。
- en: The third group is sort of in-between. All .NET languages, in a similar fashion
    to Java, compile to an intermediary binary format. Java calls this byte code.
    C# and other .NET languages call it **Common Intermediate Language** (**CIL**).
    These binary formats execute faster and more efficiently than an interpreted language,
    but they do require a runtime to execute the intermediate form.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组处于中间位置。所有 .NET 语言，与 Java 类似，都编译成中间二进制格式。Java 称之为字节码。C# 和其他 .NET 语言称之为**公共中间语言**（**CIL**）。这些二进制格式比解释语言执行得更快、更高效，但它们确实需要一个运行时来执行中间形式。
- en: It is important to remember how the published version of code in any given language
    might perform. On the whole, compiled C# code is generally slower than the “bare
    metal” compiled languages, but not by much.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 记住任何给定语言的代码发布版本可能的表现是很重要的。总的来说，编译后的 C# 代码通常比“裸机”编译语言慢，但差距并不大。
- en: Language mechanics in C#
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 的语言机制
- en: We’ve mentioned already that C# is strictly an **object-oriented programming**
    (**OOP**) language. OOP languages support a set of abstract features, which you
    need to understand before we can continue. Firstly, OOP languages organize code
    differently than procedural languages. In OOP, we model elements from the real-world
    using code. The real-world elements are described using **properties**, **methods**,
    and **events**.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到C#是一种严格的**面向对象编程**（**OOP**）语言。OOP语言支持一系列抽象特性，在我们继续之前，你需要理解这些特性。首先，OOP语言与过程式语言组织代码的方式不同。在OOP中，我们使用代码来模拟现实世界中的元素。现实世界元素使用**属性**、**方法**和**事件**来描述。
- en: 'For example, if I were modeling a circle, I might give it a set of properties
    as seen in Figure A1.3:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我要模拟一个圆，我可能会给它一组如图A1.3所示的属性：
- en: '![Figure A1.4: A circle, like anything else, can be represented by describing
    it as a set of properties ](img/B18605_Figure_A1.3.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.4：一个圆，就像其他任何事物一样，可以通过描述其属性集来表示](img/B18605_Figure_A1.3.jpg)'
- en: 'Figure A1.4: A circle, like anything else, can be represented by describing
    it as a set of properties'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.4：一个圆，就像其他任何事物一样，可以通过描述其属性集来表示
- en: Using these properties, I can describe any circle I might want to draw on the
    screen in my program.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些属性，我可以描述我在程序屏幕上想要绘制的任何圆。
- en: Effectively, properties are variables that belong to the circle. They contain
    the data that describes the circle. When describing a variable that belongs to
    an object, you refer to these as *properties*, *member variables*, or *members*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，属性是属于圆的变量。它们包含描述圆的数据。当描述属于对象的变量时，我们称之为*属性*、*成员变量*或*成员*。
- en: 'Additionally, objects describe the actions they might perform. When we talk
    about functions in the context of OOP, we call them methods. We could say our
    circle object has a method called `draw()` that draws the circle to the screen
    given the properties that describe it. We could also add a method to resize the
    circle. Methods are the same thing as functions, so we can pass in arguments.
    Our resize method will need to know the new radius of the circle. It might be
    called this way: `resize(100)`. This would change the radius of the circle from
    200 to 100\.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对象还描述了它们可能执行的动作。当我们从OOP的角度谈论函数时，我们称之为方法。我们可以说我们的圆对象有一个名为`draw()`的方法，它根据描述圆的属性将圆绘制到屏幕上。我们还可以添加一个调整圆大小的方法。方法与函数是同一件事，因此我们可以传递参数。我们的调整大小方法需要知道圆的新半径。它可能这样被调用：`resize(100)`。这将把圆的半径从200改为100。
- en: Objects also commonly have a specialized set of methods designed to respond
    to events. Events can be described as *things that happen* while your program
    is running. Common examples might include the user clicking on the circle, hovering
    a cursor over the circle, right-clicking on the circle with your mouse, long-tapping
    the circle on a touch screen, or the passage of time. Maybe you want the circle
    to disappear after 10 seconds.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通常还有一组专门的方法，用于响应事件。事件可以描述为程序运行期间发生的*事情*。常见的例子可能包括用户点击圆圈、将光标悬停在圆圈上、用鼠标右键点击圆圈、在触摸屏上长按圆圈，或者时间的流逝。也许你希望圆圈在10秒后消失。
- en: It isn’t necessary for an object to have all of these pieces. Some objects only
    represent data using properties. Some are just used for constants and methods,
    such as the `Math` class in C#. However, most of the time, there is a mixture.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对象并不需要具备所有这些部分。有些对象仅使用属性来表示数据。有些则仅用于常量和方法，例如C#中的`Math`类。然而，大多数情况下，它们是混合使用的。
- en: 'In addition to objects being organized with properties and methods, there are
    a few other buzzwords to learn:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象通过属性和方法组织之外，还有一些其他术语需要学习：
- en: Encapsulation
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Composition
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Inheritance
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Open recursion
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放递归
- en: All of this sounds horribly complicated, but don’t worry, that’s what I’m here
    for. We’ll touch on all of these concepts within this chapter.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都听起来非常复杂，但别担心，这正是我在这里的原因。我们将在本章中涉及所有这些概念。
- en: OOP first surfaced in the 1980s with the Ada programming language. Ada was named
    for programming pioneer August a Ada King, Countess of Lovelace. You’ve probably
    heard of her as Ada Lovelace. The language that bears her name was created under
    contract for the US **Department of Defense** (**DoD**) and was designed to replace
    over 450 disparate programming languages that were in use at the DoD at the time.
    As you can imagine, it had some big shoes to fill. The Ada language is to programming
    what the Tucker automobile was to the American automotive industry. The 1948 Tucker
    automobile was the first to offer standard seat belts, a water-cooled aluminum
    engine, disk brakes, fuel injection, and an independent suspension. These are
    all standard features of modern cars, and we’d be hard-pressed to consider buying
    a car today without them. However, they didn’t exist on cars designed and built
    in the 1940s, or certainly not all on one car.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程首次在20世纪80年代通过Ada编程语言出现。Ada是以编程先驱Augusta Ada King，Countess of Lovelace的名字命名的。你可能听说过她，她是Ada
    Lovelace。以她的名字命名的语言是在与美国国防部（**DoD**）签订的合同下创建的，旨在取代当时在DoD使用的450多种不同的编程语言。正如你可以想象的那样，它有一些很大的挑战。Ada语言对编程的影响，就像Tucker汽车对美国汽车工业的影响一样。1948年的Tucker汽车是第一个提供标准安全带、水冷铝制发动机、碟刹、燃油喷射和独立悬挂的汽车。这些都是现代汽车的标准功能，我们很难想象今天没有这些功能就购买汽车。然而，在20世纪40年代设计和制造的汽车上，这些功能并不存在，或者至少不是在单一汽车上。
- en: The original Ada language supported object orientation, design by contract,
    strong typing, an explicit syntax for concurrency, tasks, message passing, encapsulation
    using private and protected classes, and code safety enforced by a compiler. Sound
    familiar? Many modern languages, including C#, include these features out of the
    box owing largely to the virtues embodied in Ada.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的Ada语言支持面向对象、基于合同的编程、强类型、显式的并发语法、任务、消息传递、使用私有和受保护类进行封装，以及由编译器强制执行的代码安全性。听起来熟悉吗？许多现代语言，包括C#，都包含这些特性，这主要归功于Ada所体现的优点。
- en: OOP became popular because it allows you to organize your software in a way
    that makes sense and is easy to comprehend. Developers who learn OOP first have
    trouble switching away from it. Having worked with both kinds of thinking for
    many years, I believe OOP is the best way to create large-scale software projects
    because it forces you to think a certain way. The main tenets of OOP, some of
    which are covered in SOLID principles, are like a built-in way to make your software
    maintainable, testable, and extensible in the safest way possible. I believe it
    is important to use an object-oriented language when you initially learn patterns.
    The original work on patterns was based on Java, which is remarkably similar to
    C#. Many of the ideas presented in this book won’t work or must be shoehorned
    into working with non-object-oriented, multi-paradigm, or dynamic languages. For
    example, JavaScript ES5 is considered object-oriented, but objects are dynamic.
    By this, I mean you can change the structure of any object, including those internally
    supported by the language at any time while your code is running. You can even
    alter all instances of an object owing to JavaScript’s use of prototype inheritance.
    JavaScript is weakly typed, and the list of types it supports is limited. Classes
    and encapsulation simply don’t exist in ES5\. It is difficult to study patterns
    in a language such as this because patterns require a foundational set of restrictive
    rules, which don’t fully exist in many other languages.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）之所以流行，是因为它允许你以有意义且易于理解的方式组织你的软件。首先学习OOP的开发者很难切换到其他方式。在与这两种思维方式共事多年后，我认为OOP是创建大型软件项目的最佳方式，因为它迫使你以某种特定的方式思考。面向对象编程的主要原则，其中一些在SOLID原则中有所涉及，就像内置的方式，以最安全的方式使你的软件可维护、可测试和可扩展。我认为在最初学习模式时使用面向对象的语言很重要。模式的原作是基于Java的，这与C#非常相似。这本书中提出的许多想法在非面向对象、多范式或动态语言中可能无法工作或必须强行适应。例如，JavaScript
    ES5被认为是面向对象的，但对象是动态的。通过这种方式，我的意思是，在代码运行期间，你可以随时更改任何对象的结构，包括语言内部支持的任何对象。你甚至可以因为JavaScript使用原型继承而改变一个对象的所有实例。JavaScript是弱类型，它支持的类型列表有限。类和封装在ES5中根本不存在。在像这样的语言中研究模式是困难的，因为模式需要一个基础的限制规则集，而在许多其他语言中并不完全存在。
- en: By choosing to work with C#, you align yourself with all the key tenets of developing
    software with well-known, battle-tested patterns.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择使用C#，你将自己与开发软件时使用已知、经过实战检验的模式的所有关键原则对齐。
- en: Variables in C#
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C#中的变量
- en: 'I consider the simplest definition of a variable to be as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为变量的最简单定义如下：
- en: '*A variable is a named container that holds data in computer memory.*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量是一个命名容器，它在计算机内存中存储数据。*'
- en: When you learn a programming language, you need to know whether the language
    is strongly or weakly typed.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习一种编程语言时，你需要知道该语言是强类型还是弱类型。
- en: In a **strongly typed** language, also referred to as a statically typed language,
    you must define your variables’ data type. You have to tell your program what
    kind of data you are storing in any given variable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在**强类型**语言中，也称为静态类型语言，你必须定义变量的数据类型。你必须告诉程序你正在给定的变量中存储什么类型的数据。
- en: 'In a **weakly typed language**, you don’t need to declare a type because, effectively,
    there is only one type: everything is an object.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在**弱类型语言**中，你不需要声明类型，因为实际上只有一个类型：一切都是对象。
- en: Here is a great way to think of it. Data can have a shape, as can a container.
    Containers also have a definite size. You cannot fit one pound of sugar into a
    container designed to hold no more than a quarter of a pound. However, you can
    fit that same pound of sugar into a 5-gallon bucket with room to spare.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很好的思考方式。数据可以有一个形状，容器也可以。容器也有一个确定的大小。你不能把一磅糖放进只能容纳四分之一磅的容器里。然而，你可以把同样的一磅糖放进一个有空间的5加仑桶里。
- en: 'C# is statically typed with support for **implicit typing**, also known as
    **duck typing**. In a strongly typed language such as C#, you would see something
    like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种静态类型语言，它支持**隐式类型**，也称为**鸭子类型**。在像 C# 这样的强类型语言中，你会看到如下这样的代码：
- en: '`int myNumber = 5;`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`int myNumber = 5;`'
- en: Here, we’re creating a variable called `myNumber`, of type `int`, and setting
    it to an initial value of `5`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个名为 `myNumber` 的变量，类型为 `int`，并将其初始值设置为 `5`。
- en: 'Implicit typing allows us to make a small change:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型允许我们进行一个小小的改动：
- en: '`var myNumber = 5;`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`var myNumber = 5;`'
- en: 'Instead of the type declaration appearing before the name, you use a one-size-fits-all
    keyword, `var`. The compiler will see these statements as identical. The compiler
    can figure out what type your variable is supposed to be based on its initial
    assignment. Here, we see an initial assignment of 5, so the compiler will assume
    you meant this to be an integer (`int`). If that’s not what you wanted, you can
    give the compiler a hint. Let’s say we really wanted `myNumber` to be the `decimal`
    type. Since there is no mathematical difference between 5 and 5.0, the compiler
    gets it wrong and, eventually, you get red wavy lines in your code indicating
    you have a problem. How can you specify the type and still use the `var` keyword
    syntax? Behold:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型声明出现在名称之前不同，你使用一个通用的关键字 `var`。编译器会将这些语句视为相同。编译器可以根据其初始赋值来确定变量的类型。在这里，我们看到初始赋值为
    5，因此编译器会假设你想要这是一个整数（`int`）。如果你不是这个意思，你可以给编译器一个提示。比如说，我们真正想要 `myNumber` 是 `decimal`
    类型。由于 5 和 5.0 之间没有数学上的区别，编译器会出错，最终你会在代码中得到红色的波浪线，表明你有问题。你如何指定类型并仍然使用 `var` 关键字语法？看这里：
- en: '`var myNumber = 5d;`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`var myNumber = 5d;`'
- en: We add a *d* as a suffix to the number. Just like that, the compiler now knows
    you want this to be a decimal. But I’m getting ahead of myself.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数字后面添加一个 *d* 作为后缀。就这样，编译器现在知道你想要这是一个十进制数。但我跑题了。
- en: Signed numeric types delineated by memory size usage
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由内存大小使用的有符号数值类型
- en: 'C# supports signed and unsigned numeric types. Numbers in programming languages
    are handled in memory using a mathematical operation on binary numbers called
    two’s complement as seen in Figure A1.4:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: C# 支持有符号和无符号数值类型。编程语言中的数字在内存中使用二进制补码的数学运算来处理，如图 A1.4 所示：
- en: '![Figure A1.5: Integer representation on computers happens using a mathematical
    concept called two’s-complement. One year, I went to the office Halloween party
    as an integer. I had this figure printed on a t-shirt. The best costumes are the
    ones you have to explain ](img/B18605_Figure_A1.4.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.5：计算机中整数的表示使用一个称为二进制补码的数学概念。有一年，我以一个整数的身份参加了办公室的万圣节派对。我把这个图印在了T恤上。最好的服装是那些需要解释的](img/B18605_Figure_A1.4.jpg)'
- en: 'Figure A1.5: Integer representation on computers happens using a mathematical
    concept called two’s-complement. One year, I went to the office Halloween party
    as an integer. I had this figure printed on a t-shirt. The best costumes are the
    ones you have to explain'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.5：计算机中整数的表示使用一个称为二进制补码的数学概念。有一年，我以一个整数的身份参加了办公室的万圣节派对。我把这个图印在了T恤上。最好的服装是那些需要解释的
- en: If you’re a math geek, check out the Wikipedia page for this topic provided
    in the further reading section.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个数学爱好者，可以查看进一步阅读部分提供的维基百科页面。
- en: For the rest of us, this concept can be explained simply. Any variable that’s
    meant to store a number will have a minimum and maximum size for the number. For
    example, a common 32-bit integer (`int32`) has a range of -2,147,483,648 at the
    minimum end and a maximum value of 2,147,483,647\. We had to chop one off the
    maximum to account for zero. The size ranges are dictated by two’s complement
    given the amount of memory space used. The range I just showed you represents
    the capacity for a **signed** type, meaning it supports numbers less than zero.
    If you don’t care about negative values, C# allows you to use **unsigned** types
    that extend the range from 0 to 4,294,967,295.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们其他人来说，这个概念可以简单地解释。任何打算存储数字的变量都将有一个数字的最小和最大大小。例如，常见的32位整数（`int32`）在最小端有-2,147,483,648的范围，最大值为2,147,483,647。我们必须从最大值中减去一个来考虑零。大小范围由使用的内存空间量决定。我刚才展示的范围代表**有符号**类型的容量，这意味着它支持小于零的数字。如果你不关心负值，C#
    允许你使用**无符号**类型，这些类型将范围扩展到0到4,294,967,295。
- en: 'C# allows you to control memory usage by selecting from a myriad of signed
    and unsigned ranges. In other words, signed numeric types are delineated by memory
    size usage. I think this is a point that most developers forget or ignore since
    most of us, when we need an integer, just use `int`. I used an analogy earlier:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许你通过选择众多有符号和无符号的范围来控制内存使用。换句话说，有符号数值类型由内存大小使用来界定。我认为这是大多数开发者忘记或忽视的一个点，因为我们大多数人需要整数时，只是使用
    `int`。我之前使用了一个类比：
- en: '*You cannot fit one pound of sugar into a container designed to hold no more
    than a quarter of a pound. You can, however, fit that same pound of sugar into
    a 5-gallon bucket with room to spare.*'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*你不可能把一磅糖放入只能装四分之一磅的容器中。然而，你却可以把同样的一磅糖放入一个5加仑的桶中，还有富余的空间。*'
- en: 'There is a lot of wasted space in the 5-gallon bucket. You can control the
    waste by selecting a type that has a range that is compatible with how it’s used.
    Think about how many times have you either seen or done this:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在5加仑的桶中有很多浪费的空间。你可以通过选择一个与使用方式兼容的范围来控制浪费。想想看，你有多少次看到或做过这样的事情：
- en: '`int myAge = 54;`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`int myAge = 54;`'
- en: 'That’s a huge waste of space. First, a person’s age can’t be a negative number.
    It makes sense to change this to the following:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种巨大的空间浪费。首先，一个人的年龄不可能是负数。将其改为以下内容是有意义的：
- en: '`uint myAge = 54;`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint myAge = 54;`'
- en: 'Here, we’re using the unsigned version of the 32-bit integer. See if you can
    pick a more appropriate type from the following table:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用32位整数的无符号版本。看看你能否从以下表格中选择一个更合适的类型：
- en: '| **Type** | **Description** | **Minimum** | **Maximum** | **Bits** |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **描述** | **最小值** | **最大值** | **位数** |'
- en: '| `bool` | Boolean | False (0) | True (1) | 1 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 布尔值 | False (0) | True (1) | 1 |'
- en: '| `byte` | Unsigned byte | 0 | 255 | 8 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 无符号字节 | 0 | 255 | 8 |'
- en: '| `sbyte` | Signed byte | -128 | 127 | 8 |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | 有符号字节 | -128 | 127 | 8 |'
- en: '| `short` | Signed short integer | -32,768 | 32,767 | 16 |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 有符号短整数 | -32,768 | 32,767 | 16 |'
- en: '| `ushort` | Unsigned short integer | 0 | 65,535 | 16 |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | 无符号短整数 | 0 | 65,535 | 16 |'
- en: '| `int` | Signed integer | -2,147,483,648 | 2,147,483,647 | 32 |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 有符号整数 | -2,147,483,648 | 2,147,483,647 | 32 |'
- en: '| `uint` | Unsigned integer | 0 | 4,294,967,295 | 32 |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | 无符号整数 | 0 | 4,294,967,295 | 32 |'
- en: '| `long` | Signed long integer | -9e18 | 9e18 | 64 |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 有符号长整数 | -9e18 | 9e18 | 64 |'
- en: '| `ulong` | Unsigned long integer | 0 | 1.8e19 | 64 |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | 无符号长整数 | 0 | 1.8e19 | 64 |'
- en: 'Figure A1.6: A list of C# integer types with ranges and how much memory each
    consumes.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.6：C#整数类型列表及其范围和每种类型消耗的内存量。
- en: As you can see, as we move down the chart, we use more and more memory. A bit
    is the smallest thing a computer can work with. A 64-bit integer can only be understood
    using the term *±9 kajillion* or *18 kajillion* depending on whether it’s signed.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，随着我们向下查看图表，我们使用的内存越来越多。位是计算机可以处理的最小单位。64位整数只能用*±9 kajillion*或*18 kajillion*这样的术语来理解，这取决于它是有符号的还是无符号的。
- en: Why would we use a 32-bit unsigned integer with a maximum value of 8 billion
    for a person’s age? Either we don’t know about numeric type delineations or we’re
    simply lazy, which is one of those debilitating forces we talked about in [*Chapter
    1*](B18605_01.xhtml#_idTextAnchor016). We’ve just broken a window that leads us
    into a big ball of mud. We should be using an unsigned byte that has a minimum
    value of 0 and a maximum value of 255\. Most normal humans, aside from Elvis,
    who is living on a secret island in Hawaii, and Chuck Norris, who is obviously
    immortal, don’t live past 100 years. When you consider the earth is about 4.5
    billion years old, you begin to see the folly of this common practice. If you
    do this, you’re in good company. Microsoft does it too throughout its C# documentation.
    I am tempted to quip writers make bad coders, but I’d be shooting myself in the
    foot if I did. I won’t fault you if you don’t immediately change all your production
    code from `int` to `byte` so long as you now realize you’re wasting a lot of memory.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要用一个最大值为80亿的32位无符号整数来表示一个人的年龄？要么我们不了解数值类型的划分，要么我们只是懒惰，这是我们之前在[*第一章*](B18605_01.xhtml#_idTextAnchor016)中提到的那种令人衰弱的力之一。我们刚刚打破了一扇窗户，把我们引入了一个大泥球。我们应该使用一个最小值为0，最大值为255的无符号字节。除了在夏威夷的一个秘密岛屿上生活的猫王，以及显然永生的Chuck
    Norris之外，大多数正常人类都不会活过100岁。当你考虑到地球大约有45亿年的历史时，你开始看到这种常见做法的愚蠢。如果你这样做，你并不孤单。微软在其
    C# 文档中也这样做。我差点开玩笑说写作者是糟糕的程序员，但如果我这样做，那我就自讨苦吃。只要你现在意识到你在浪费很多内存，我不会责怪你立即将所有生产代码从
    `int` 改为 `byte`。
- en: '*Figure A1.7* shows us all the valid integer types. There are similar names
    and ranges for floating-point numbers and text types. All of these types are considered
    `int` keyword mapping to the `Int32` class.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A1.7* 展示了我们所有的有效整数类型。对于浮点数和文本类型，有类似的名字和范围。所有这些类型都被认为是 `int` 关键字映射到 `Int32`
    类。'
- en: 'The real list turns out to be something like the list in *Figure A1.7*:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 实际列表最终变成了类似于 *图 A1.7* 中的列表：
- en: '| **Alias/primitive keyword** | **.NET type** |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| **别名/原始关键字** | **.NET 类型** |'
- en: '| `bool` | System.Boolean |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | System.Boolean |'
- en: '| `byte` | System.Byte |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | System.Byte |'
- en: '| `sbyte` | System.Sbyte |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `sbyte` | System.Sbyte |'
- en: '| `short` | System.Int16 |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `short` | System.Int16 |'
- en: '| `ushort` | System.Uint16 |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `ushort` | System.Uint16 |'
- en: '| `int` | System.Int32 |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `int` | System.Int32 |'
- en: '| `uint` | System.Uint32 |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | System.Uint32 |'
- en: '| `long` | System.Int64 |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `long` | System.Int64 |'
- en: '| `ulong` | System.UInt64 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | System.UInt64 |'
- en: 'Figure A1.7: The full list of C# integer ranges with the alias in the first
    column and the real implementation class in the second column.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.7：C# 整数范围的完整列表，第一列是别名，第二列是实际实现类。
- en: C# allows for aliases, and often the alias points to the same class name expressed
    with an uppercase letter. All the primitive types are in the .NET `System` object.
    Almost every project you create in Visual Studio has a `using System` statement
    at the top. This is why you can see strings being created in several different
    ways.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许使用别名，并且通常别名指向用大写字母表示的相同类名。所有原始类型都在 .NET 的 `System` 对象中。你创建的几乎每个 Visual
    Studio 项目都在顶部有一个 `using System` 语句。这就是为什么你可以看到字符串以多种不同的方式创建。
- en: 'A string defined using all lowercase characters works because of the alias:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全部小写字母定义的字符串之所以有效，是因为别名：
- en: '`var string foo = "bar";`'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`var string foo = "bar";`'
- en: 'A string defined with a capitalized `String` keyword works because of the `using
    System` statement that is likely at the top of your project:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大写 `String` 关键字定义的字符串之所以有效，是因为你项目顶部可能存在的 `using System` 语句：
- en: '`var String bar = "baz";`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`var String bar = "baz";`'
- en: 'Of course, you can also write the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以这样写：
- en: '`var System.String fooBarBaz = "foo bar baz";`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`var System.String fooBarBaz = "foo bar baz";`'
- en: Honestly, I’ve never seen anybody do this. Years ago, when I taught introductory
    programming courses in C# at a nearby college, the difference between `String`
    and `string` was a widely asked question, especially coming from students who
    had previously studied Java. Java lacked these kinds of aliases.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我从未见过有人这样做。多年前，我在附近的一所大学教授 C# 初级编程课程时，`String` 和 `string` 之间的区别是一个广泛询问的问题，尤其是来自之前学习过
    Java 的学生。Java 缺乏这些类型的别名。
- en: Separate character and string classes with different quotation marks used for
    each
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同引号分隔字符和字符串类
- en: This point is short, but worth mentioning if you are coming from another language,
    or if you switch languages frequently. C# has separate class types for strings
    and characters. The string type is `System.String`. It’s an alias that is used
    far more frequently, which is just `string`. The character type, which is a single
    character string, is created using the `System.Char` class or just `char`. The
    quotation marks used in the assignment of values matter, too. Many languages,
    such as JavaScript and Python, allow you to use single and double quotes interchangeably.
    In C#, strings are denoted with double quotes, while characters are assigned using
    single quotes. They are not interchangeable.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个点很短，但如果你是从其他语言过来的，或者如果你经常切换语言，那么它值得提一下。C# 有用于字符串和字符的单独的类类型。字符串类型是 `System.String`。它是一个使用频率很高的别名，就是
    `string`。字符类型，即单个字符字符串，是通过使用 `System.Char` 类或简单地使用 `char` 创建的。赋值时使用的引号也很重要。许多语言，如
    JavaScript 和 Python，允许你单引号和双引号互换使用。在 C# 中，字符串用双引号表示，而字符使用单引号赋值。它们是不可互换的。
- en: Collections
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收藏
- en: JavaScript has `Arrays` (a.k.a. what I’m hoping I get at work for writing a
    book). Python has `Lists`. Java has `ArrayLists`. C# has a broad set of **Collections**.
    C# has arrays such as JavaScript, but they are more limited. You have to set the
    number of items you are putting into the array in advance, and once set, that
    number can’t be easily changed. A more useful form of array in C# is the .NET
    List class.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有 `数组`（也就是我希望在工作中能用来写书的东西）。Python 有 `列表`。Java 有 `ArrayLists`。C# 有一个广泛的
    **集合**。C# 有类似于 JavaScript 的数组，但它们更有限。你必须提前设置你要放入数组中的项目数量，一旦设置，这个数量就不能轻易改变。C# 中更有用的数组形式是
    .NET List 类。
- en: 'List classes are like arrays, except you can add and remove items any time
    you need to. They are a lot more flexible. Lists are strongly typed, like everything
    else in C#. This means all the items in the List have to be the same type. C#
    has a system for this called `<>`). In the book, you’ll see references to `List<>`.
    This indicates a generic list, and once again, that just means you can put anything
    into the list as long as everything you put into it is of the same type. If you
    wanted to create a list of strings, it might look like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 列表类类似于数组，除了你可以在需要的时候随时添加和删除项目。它们要灵活得多。列表在 C# 中是强类型的，就像其他所有东西一样。这意味着列表中的所有项目都必须是同一类型。C#
    有一个名为 `<>` 的系统来处理这个问题。在书中，你会看到对 `List<>` 的引用。这表示一个泛型列表，再次强调，这意味着只要你放入列表中的所有东西都是同一类型，你就可以把任何东西放入列表。如果你想创建一个字符串列表，它可能看起来像这样：
- en: '[PRE0]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To use these generic collections, you have to add a statement at the top of
    your class file like this:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些泛型集合，你必须在类文件顶部添加一个语句，如下所示：
- en: '[PRE1]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Generic collections are some of the most versatile and widely used classes in
    .NET Framework. You will definitely encounter them early and often.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型集合是 .NET 框架中最灵活和最广泛使用的类之一。你肯定会很早很频繁地遇到它们。
- en: Classes
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: So far, my assumptions regarding your exposure to OOP have presupposed you know
    what a class is and its purpose. Just in case that’s an invalid assumption, let’s
    clear it up now. A *class* can be thought of as a blueprint for a house. The blueprint
    describes everything you need to know to build the house. You can use the blueprint
    to make as many houses as you need, and as you build them, you can change the
    individual properties on each house. It isn’t necessary that they all be the same
    size or color, or that they all have a certain number of windows. You can alter
    any of these properties when you build the house.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我关于你对面向对象编程（OOP）了解的假设是，你知道类是什么以及它的用途。万一这是一个无效的假设，我们现在就澄清一下。一个 *类* 可以被看作是房子的蓝图。蓝图描述了建造房子所需知道的一切。你可以使用这个蓝图建造你需要的任何数量的房子，在你建造它们的时候，你可以改变每座房子的个别属性。它们不必都是相同的大小或颜色，也不必都有一定数量的窗户。在你建造房子的时候，你可以改变这些属性中的任何一个。
- en: In most OOP languages, the class is the main form for defining how objects are
    constructed. There are even special methods called constructors, which run when
    an object is instantiated, which is to say when you create an instance of an object
    using the new keyword.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数面向对象编程语言中，类是定义对象构造的主要形式。甚至还有称为构造函数的特殊方法，当对象被实例化时运行，也就是说，当你使用 new 关键字创建对象实例时。
- en: 'Here is the example of the `Person` class I used earlier. This time, I added
    all the parts so that I can show them to you:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是之前我使用的 `Person` 类的例子。这次，我添加了所有部分，这样我就可以向你展示了：
- en: '[PRE2]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A class has a few main parts:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类有几个主要部分：
- en: Using statements to define dependencies
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语句来定义依赖项
- en: The namespace
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The class name
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名
- en: Constructors
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Properties
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Methods
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Let’s go over each part.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍每个部分。
- en: Using statements
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用语句
- en: The `using` keyword has a double meaning in C#. When you see it at the top of
    a class, it refers to the class’ dependencies. This is common in most languages.
    In Java and Python, the word is `import`. In JavaScript, it’s either `require`
    or `import` depending on which convention you use. In C#, the keyword is `using`.
    The statement signals to the compiler that some of the classes we’re going to
    reference in this class exist in other parts of our project, or even outside our
    project, which is the case when we use third-party libraries.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`using`关键字有两个含义。当你在一个类的顶部看到它时，它指的是类的依赖项。这在大多数语言中都很常见。在Java和Python中，这个词是`import`。在JavaScript中，根据你使用的约定，它可以是`require`或`import`。在C#中，关键字是`using`。这个语句向编译器发出信号，表明我们将要引用的某些类存在于我们项目的其他部分，甚至可能存在于项目外部，这就是当我们使用第三方库时的情况。
- en: 'For example, in order to use the `Console.WriteLine` method, which prints text
    to the console, first, we must declare that we will be using the `System` namespace.
    We do this with the following statement:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使用`Console.WriteLine`方法，该方法将文本打印到控制台，首先，我们必须声明我们将使用`System`命名空间。我们通过以下语句来完成：
- en: '[PRE3]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Console` object is in the `System` namespace. The `using` statement tells
    the compiler we’ll be using classes from that namespace. That last statement makes
    for a natural segue into the next topic.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`Console`对象位于`System`命名空间中。`using`语句告诉编译器我们将使用该命名空间中的类。最后一个语句很自然地过渡到下一个主题。'
- en: Namespaces
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are a way of organizing your code in C#. If you’re coming from Java,
    you’ve used packages. In Python, they’re called modules. In JavaScript, you export
    objects you want to expose in modular code. In C#, a namespace appears at the
    top of your class files. Usually, it corresponds to the name of your project.
    If you create folders inside your project to break up your code, usually, the
    namespace mirrors the folder structure.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是组织C#代码的一种方式。如果你来自Java，你使用过包。在Python中，它们被称为模块。在JavaScript中，你导出你想要在模块化代码中公开的对象。在C#中，命名空间出现在你的类文件顶部。通常，它对应于你的项目名称。如果你在项目中创建文件夹来分割你的代码，通常，命名空间会反映文件夹结构。
- en: In the preceding sample code, we have a namespace called `MyProject`, which
    would be the name of the C# project. If I made a folder called helpers to hold
    some helper objects, the namespace in those folders would be `MyProject.helpers`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，我们有一个名为`MyProject`的命名空间，这将是C#项目的名称。如果我创建一个名为`helpers`的文件夹来存放一些辅助对象，这些文件夹中的命名空间将是`MyProject.helpers`。
- en: Namespaces are not an absolute requirement. Most IDEs put them in automatically,
    so you’ll usually see them. Five years ago, when I last worked with the Unity
    3D game engine, the IDE didn’t put namespaces in the class code automatically.
    It’s possible to work without namespaces, but it’s rare. Visual Studio and Rider
    add the namespace automatically when you create the class. In VS Code, everything
    is manual, so you might have to add it yourself.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间不是绝对必需的。大多数集成开发环境（IDE）会自动将它们添加进去，所以你通常会看到它们。五年前，当我最后一次使用Unity 3D游戏引擎时，IDE没有自动在类代码中添加命名空间。虽然没有命名空间也可以工作，但这种情况很少见。Visual
    Studio和Rider在创建类时会自动添加命名空间。在VS Code中，一切都是手动的，所以你可能需要自己添加。
- en: The class name
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类名
- en: 'The line that names the class is not difficult to spot:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 命名类的行并不难找：
- en: '[PRE4]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You just use the keyword class followed by the name of the class. By convention,
    class names use the Pascal case convention, which means each word in the class
    name is represented by a capital letter. If we wanted to create a class to represent
    a floor manager at a retail outlet, we would call it `FloorManager`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需使用关键字`class`后跟类的名称。按照惯例，类名使用Pascal大小写约定，这意味着类名中的每个单词都由一个大写字母表示。如果我们想要创建一个表示零售店楼层经理的类的类，我们会称它为`FloorManager`。
- en: Classes, like properties and methods, can use access modifiers to define how
    they can be accessed. We’ll talk more about this later.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 类，就像属性和方法一样，可以使用访问修饰符来定义它们可以被如何访问。我们稍后会更多地讨论这个问题。
- en: Constructors and instantiation
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数和实例化
- en: A constructor is a special method designed to run when you `Create an instance`
    = `instantiation`. See? It’s a fancy word every software developer needs to understand.
    Instantiation happens when you put the `new` keyword in front of a constructor
    method. This is why there is always a parenthesis at the end of your `new` statement.
    The constructor returns the instance of the object set up per any code in the
    constructor. If you don’t supply a constructor, the .NET compiler adds an empty
    one when you compile.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一种特殊的方法，当您`创建实例`（即实例化）时运行。看吧？这是一个每个软件开发者都需要理解的术语。实例化发生在您在构造函数方法前加上`new`关键字时。这就是为什么您的`new`语句后面总是有一个括号的原因。构造函数返回根据构造函数中的任何代码设置的实例。如果您没有提供构造函数，.NET
    编译器在编译时会添加一个空的构造函数。
- en: There are defining rules that govern the constructors. First, the constructor’s
    method name must match the name of the class. Second, you can’t define a return
    type since it is fixed to returning an instance of the class it is constructing.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数有一些定义规则。首先，构造函数的方法名必须与类的名称匹配。其次，您不能定义返回类型，因为它固定为返回正在构建的类的实例。
- en: 'C# allows you to have multiple overloaded constructors. This means you can
    have more than one constructor as long as the type and number of arguments are
    different. Our code example from earlier features three constructors:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: C# 允许您拥有多个重载的构造函数。这意味着只要类型和参数数量不同，您就可以有多个构造函数。我们之前提供的代码示例包含三个构造函数：
- en: '[PRE5]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下事项：
- en: All of the constructors are named `Person` because that is the name of the class.
    They must match the name of the class or they aren’t valid constructors.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有构造函数都命名为 `Person`，因为这是类的名称。它们必须与类的名称匹配，否则它们不是有效的构造函数。
- en: There is no return type specified. The return type would be between the public
    keyword and the name of the constructor method.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有指定返回类型。返回类型应该在 `public` 关键字和构造函数方法名称之间。
- en: Even though all three functions have the same name because they have different
    numbers of arguments, it’s legal. The first constructor has zero arguments, the
    second has one, and the third has two. This is called *method overloading* and
    is a form of polymorphism.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这三个函数因为参数数量不同而具有相同的名称，但这在语法上是允许的。第一个构造函数没有参数，第二个有一个参数，第三个有两个参数。这被称为*方法重载*，它是一种多态形式。
- en: Constructors are a very useful way to establish the initial state of your object
    the instant the object is created. I often say that the number one job of a software
    developer is to make sure no object within your program is capable of entering
    an invalid state.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是建立对象初始状态的一种非常有用的方式，即在对象创建的瞬间。我经常说，软件开发者的首要任务是确保程序中的任何对象都无法进入无效状态。
- en: In the preceding example, the constructor is syntactic overkill. C# will initialize
    the age property to 0 automatically. I initialize strings to empty strings because
    I don’t like the ambiguity of dealing with null values. Sometimes, your language
    of choice, in this case, C#, will try to handle things such as initialization
    for you. Relying on automatic language features will lead to mental laziness,
    one of the destructive forces I talk about in [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016)
    that leads to chaotic, unmaintainable code. If you don’t believe me, go to YouTube
    and find videos on JavaScript’s automatic semicolon insertion “feature.” You need
    to remember that your code is a set of instructions to be executed by one of the
    dumbest things on planet earth. Computers take everything literally, and if your
    instructions contain any ambiguity, bad comedy always ensues. Granted, some people
    call that job security, and everybody needs good war stories to tell. It’s like
    that one time someone on the team pasted an incomplete SQL update statement into
    SSMS pointed to a production database and updated all the customer records to
    one account. A system with a million users a day was down for 7 hours. To be clear,
    no, it wasn’t me. If it were, I would never speak of it. I’m making a point. That
    painful experience happened because someone was too lazy to do their job the right
    way. Personally, I’d rather do things right and keep my weekends free. When I
    write code, I am always explicit and intentional. It keeps me out of trouble.
    Always pay attention to your object’s state and write your code to guard against
    invalid states. Your constructors are the first line of defense. The second line
    of defense is encapsulation, which we’ll talk about shortly.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，构造函数的语法有些过度。C# 会自动将 age 属性初始化为 0。我将字符串初始化为空字符串，因为我不喜欢处理 null 值的歧义。有时，你选择的语言，在这个例子中是
    C#，会尝试为你处理一些事情，比如初始化。依赖自动的语言特性会导致精神上的懒惰，这是我在[*第一章*](B18605_01.xhtml#_idTextAnchor016)中提到的具有破坏性的力量之一，它会导致混乱、难以维护的代码。如果你不相信我，去
    YouTube 上找找关于 JavaScript 自动分号插入“功能”的视频。你需要记住，你的代码是一组将被地球上最愚蠢的东西之一执行的指令。计算机会字面地处理一切，如果你的指令中包含任何歧义，总会出现糟糕的喜剧。当然，有些人把这称为工作保障，每个人都需要好的战争故事来讲述。就像有一次，团队里的某个人将一个不完整的
    SQL 更新语句粘贴到 SSMS 中，指向了一个生产数据库，并将所有客户记录更新到了一个账户。每天有百万用户使用的系统瘫痪了 7 个小时。为了清楚起见，不，那不是我。如果是我，我永远不会提起这件事。我是在指出一个观点。那次痛苦的经历发生是因为有人太懒惰，没有正确地完成他们的工作。就我个人而言，我宁愿做正确的事情，让我的周末保持空闲。当我编写代码时，我总是明确且有意。这让我远离麻烦。始终关注你的对象状态，并编写代码以防止无效状态。你的构造函数是第一道防线。第二道防线是封装，我们很快就会谈到。
- en: Properties
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'Objects consist of state variables and functions capable of doing work on those
    state variables. This is a fancy way of saying an object is like a marriage between
    two common programming concepts: variables and functions. Classes are designed
    to represent real-world objects. Any object in the real world is defined by its
    descriptive properties. What color is it? Is it bigger than a breadbox? Physical
    objects are further defined by what they can do. A car can go, a dog can bark,
    and so on.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 对象由状态变量和能够对这些状态变量执行工作的函数组成。这是一种说法，即对象就像两个常见编程概念的结合：变量和函数。类被设计用来表示现实世界中的对象。现实世界中的任何对象都是由其描述性属性定义的。它是什么颜色？它比面包箱大吗？物理对象进一步由它们能够做什么来定义。一辆车可以行驶，一只狗可以吠叫，等等。
- en: 'For now, let’s focus on the objects’ descriptors. It’s easy to call them properties.
    A basketball has properties such as its circumference, its orange color, its black
    lines, and how much air it is holding. These are properties of the basketball.
    In C# classes, properties look like this:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于对象的描述符。很容易称它们为属性。一个篮球有周长、橙色、黑色线条和它所含空气量等属性。这些都是篮球的属性。在 C# 类中，属性看起来像这样：
- en: '[PRE6]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The word `public` is an access modifier. We described this earlier in the appendix.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `public` 是一个访问修饰符。我们之前在附录中描述过。
- en: Every property has a name. This property’s name is `Name`, and it is defined
    as a string.  The part that says `{ get; set; }` makes it an auto-implemented
    property, which is an easy form of encapsulation that I’ll explain later.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都有一个名称。这个属性的名称是 `Name`，它被定义为字符串。说 `{ get; set; }` 的部分使其成为一个自动实现的属性，这是一种我稍后会解释的简单封装形式。
- en: 'You access a property on an instantiated object using dot notation. For example,
    to set the `Name` property on a `Person` object, you instantiate and then set
    it like this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用点符号来访问实例化对象上的属性。例如，要设置`Person`对象的`Name`属性，你需要实例化然后像这样设置它：
- en: '[PRE7]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Access modifiers define the availability of properties, methods, and even classes
    in C#.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符定义了C#中属性、方法和甚至类的可用性。
- en: Methods
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: Methods are functions attached to objects. Since C# is strictly object-oriented,
    we should probably always refer to them as methods rather than functions, but
    the words are effectively synonymous. Even the strongest adherent to OOP will
    occasionally slip and say *function*. With that out of the way, there are a few
    things to remember with respect to methods in C#. First, they follow the same
    rules as variables in that they are strongly typed. They need any arguments passed
    in to be typed as well as the return value to be typed. Like variables, the method
    names need to be unique within scope.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是附加到对象上的函数。由于C#是严格面向对象的，我们可能应该始终将它们称为方法而不是函数，但这两个词实际上是同义的。即使是OOP（面向对象编程）的坚定支持者有时也会不小心说出*函数*这个词。把这个问题放一边，关于C#中的方法，有几个要点需要记住。首先，它们遵循与变量相同的规则，即它们是强类型的。它们需要传入的任何参数都应该是已类型化的，以及返回值也应该是已类型化的。像变量一样，方法名需要在作用域内是唯一的。
- en: 'C# uses C-like method signatures common to all C-based languages. A method
    signature consists of the parts of the method that define it as unique:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用类似于C语言的C-like方法签名，这是所有基于C的语言的共同特点。方法签名由定义方法独特性的部分组成：
- en: The name of the function
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的名称
- en: The number and types of arguments
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的数量和类型
- en: The type of the return value
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值的类型
- en: 'In the preceding example, we have this method:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有这个方法：
- en: '[PRE8]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this method signature, we can see this method is public. It can be accessed
    by any class in our program. We can see that its name is `ToString` and that it
    takes no arguments. Furthermore, we can see this method is expected to return
    a string.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法签名中，我们可以看到这个方法是公开的。它可以被程序中的任何类访问。我们可以看到它的名字是`ToString`，并且它不接受任何参数。此外，我们可以看到这个方法预期返回一个字符串。
- en: This one has an extra keyword stuck between the access modifier and the return
    type. It says `override`. The `ToString()` method is on every object in C# because
    that method is in the Object base class. It is always inherited from the base
    class in every object you make. The base class implementation isn’t very useful.
    It is very common to override the function with something more useful. That is
    what’s happening in the preceding example. We’ve changed the implementation in
    the base class by overriding the implementation with our own. We do this in plenty
    of places within the projects covered in this book.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在访问修饰符和返回类型之间有一个额外的关键字。它说`override`。`ToString()`方法在C#中的每个对象上都有，因为该方法在Object基类中。它总是从基类继承到每个你创建的对象中。基类实现并不非常有用。非常常见的是用更有用的东西来覆盖函数。这正是前面例子中发生的事情。我们通过用我们自己的实现覆盖基类实现来更改基类实现。我们在本书涵盖的项目中做了很多这样的地方。
- en: Encapsulation
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: 'This concept entails one of the most important aspects of OOP: the maintenance
    of the object’s state.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念涉及到OOP（面向对象编程）最重要的方面之一：维护对象的状态。
- en: 'Earlier, in *Figure A1.3*, I presented a circle with a set of properties with
    values that describe the circle you’re seeing. As your program runs, it’s likely
    those properties will change in response to events within that program. If you
    take a snapshot of that circle at any point in time during your program’s execution,
    you can talk about its current state. It’s currently sporting a radius of 200
    pixels, with a line color of black, and fill color of dark gray. Let’s create
    some code to represent our circle in the simplest way possible, without any encapsulation,
    so we can see it added later:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的*图A1.3*中，我展示了一个具有一组描述你所看到的圆的属性值的圆。随着你的程序运行，这些属性可能会根据程序中的事件而改变。如果你在程序执行过程中的任何时刻对这个圆进行快照，你就可以谈论它的当前状态。它目前有一个200像素的半径，黑色线条颜色和深灰色填充颜色。让我们编写一些代码，以最简单的方式表示我们的圆，没有任何封装，这样我们就可以稍后看到它被添加：
- en: '[PRE9]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this listing, we create a `Circle` class, and within it, we define the fields
    based on our earlier discussion. Note that I did not say properties. Properties
    and fields are different in C#. Fields are simply member variables. These fields
    are wide open. Effectively, any other class can directly modify the fields at
    any time. Why is this bad? Remember, it’s all about guarding the state. It really
    doesn’t make sense to have a negative radius, which is why I used an unsigned
    short. Likewise, graphics coordinate systems on a computer are usually strictly
    positive, with 0,0 located in the upper-left corner of the screen. To that end,
    I used unsigned shorts here because we don’t need values beneath zero, and the
    upper value seems reasonable. So far, I’ve done everything right, except I haven’t
    guarded the state beyond limiting invalid values based on types.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们创建了一个 `Circle` 类，并在其中定义了基于我们之前讨论的字段。请注意，我没有说属性。在 C# 中，属性和字段是不同的。字段仅仅是成员变量。这些字段是开放的。实际上，任何其他类都可以在任何时候直接修改这些字段。为什么这是不好的呢？记住，这全部都是为了保护状态。有一个负半径真的没有意义，这就是为什么我使用了无符号短整型。同样，计算机上的图形坐标系统通常严格为正，0,0
    位于屏幕的左上角。因此，我这里使用了无符号短整型，因为我们不需要负值，而且上限看起来是合理的。到目前为止，我做得一切都很正确，除了我没有在限制基于类型的无效值的基础上保护状态。
- en: Let’s imagine that you’re working on a program such as *Adobe Illustrator* or
    the open source program *Inkscape*. These programs deal with vector graphics,
    and they most definitely need a structure to handle a circle. Both programs are
    pretty big in terms of lines of code and the number of classes. I realize neither
    program is written in C#, but if they were, imagine all the different objects
    each program would have flying around at any given moment. If any one of them
    has the ability to, at any time, modify the properties of our circle object, finding
    and debugging odd behavior changes in the circle becomes nigh impossible. Usually,
    lack of encapsulation is caused by the cardinal sin of sloth, a lack of imagination,
    or both.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，你正在编写一个像 *Adobe Illustrator* 或开源程序 *Inkscape* 这样的程序。这些程序处理矢量图形，并且它们肯定需要一个结构来处理圆形。从代码行数和类的数量来看，这两个程序都相当庞大。我意识到这两个程序都不是用
    C# 编写的，但如果它们是的话，想象一下每个程序在任何给定时刻都会有成千上万的不同的对象在飞舞。如果其中任何一个对象有在任意时刻修改我们圆形对象属性的能力，那么在圆形中找到和调试奇怪的行为变化几乎是不可能的。通常，缺乏封装是由于懒惰的致命罪过、缺乏想象力，或者两者兼而有之。
- en: Our program could change any of these properties at any time. Encapsulation
    aims to prevent you from entering your object into an invalid state. For example,
    what if I try to specify a negative number for the radius? That doesn’t really
    make sense.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序可以在任何时候更改这些属性。封装的目的是防止你将你的对象置于一个无效的状态。例如，如果我尝试指定一个负数的半径，这实际上是没有意义的。
- en: To protect our object from entering an invalid state, we can hide the properties
    behind access modifiers. Access modifiers are keywords that define “who or what”
    is allowed to make changes to an object’s state. In an ideal program, the object
    should always solely be in charge of its own state. A different object in the
    program shouldn’t be directly manipulating the radius. Aside from access problems,
    there’s nothing policing the type of data being passed in, other than our strongly
    typed variable system. To improve things, let’s start with the radius. Earlier,
    I mentioned that I thought `ushort` was an appropriate type because being unsigned,
    it doesn’t support negative values. Further, I think the next lowest unsigned
    type, byte, which tops out at 256, is too small. I can easily see needing the
    ability to make a circle larger than 256 pixels in diameter. But 65K is probably
    too big. Let’s say I want to limit the maximum radius to 1,000 pixels. This is
    probably smart because, in a large graphical composition, we might have thousands
    of circles and we should be thinking about our memory consumption. We can hide
    the radius field behind a special function that checks to see whether the radius
    you are setting is valid, in this case, a number between 0 and 1,000.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的对象不进入无效状态，我们可以使用访问修饰符隐藏属性。访问修饰符是定义“谁或什么”可以更改对象状态的关键字。在一个理想程序中，对象应该始终只负责自己的状态。程序中的不同对象不应该直接操作半径。除了访问问题之外，除了我们的强类型变量系统之外，没有其他东西在监控传入数据的类型。为了改进事情，让我们从半径开始。早些时候，我提到我认为`ushort`是一个合适的类型，因为它是无符号的，不支持负值。此外，我认为下一个最低的无符号类型`byte`，最大值为256，太小了。我很容易就能看到需要能够制作直径大于256像素的圆。但是65K可能太大。假设我想将最大半径限制为1,000像素。这可能很明智，因为在大型图形组合中，我们可能有成千上万的圆，我们应该考虑我们的内存消耗。我们可以通过一个特殊函数来隐藏半径字段，该函数检查你设置的半径是否有效，在这种情况下，是一个介于0和1,000之间的数字。
- en: 'There are two steps at play here. First, you have to hide the radius with an
    access modifier. The most common access modifiers are listed as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个步骤。首先，你必须使用访问修饰符隐藏半径。最常见的访问修饰符如下所示：
- en: '**Public**: Anything can access the property or method.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：任何内容都可以访问属性或方法。'
- en: '**Private**: Only this object can access the property or method.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：只有这个对象可以访问属性或方法。'
- en: '**Protected**: Only this object and its descendants can access the property
    or method. More on this after we talk about inheritance.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护**：只有这个对象及其后代可以访问属性或方法。在讨论继承之后，我们将进一步讨论这个问题。'
- en: 'You’ll find these available in most object-oriented languages. C# has a few
    additional access modifiers:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在大多数面向对象的语言中找到这些。C#有一些额外的访问修饰符：
- en: '**Internal**: Anything within the same assembly can access the property or
    method.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：同一程序集内的任何内容都可以访问属性或方法。'
- en: '**Protected internal**: The property or method can only be accessed by code
    within the assembly wherein it was declared or from a subclass of the class where
    it was created.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的内部**：属性或方法只能由声明它的程序集内的代码或从创建它的类的子类访问。'
- en: '**Private protected**: The property or method can be accessed by subclasses
    that are declared within the same assembly.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有受保护**：属性或方法可以被声明在同一程序集中的子类访问。'
- en: 'You can visualize this using the following table:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下表格来可视化这一点：
- en: '![Figure A1.8: Relative access levels by the caller’s location. ](img/B18605_Figure_A1.5.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.8：调用者位置的相对访问级别](img/B18605_Figure_A1.5.jpg)'
- en: 'Figure A1.8: Relative access levels by the caller’s location.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.8：调用者位置的相对访问级别
- en: 'Let’s go back to improving the `Circle` class. The first improvement we’ll
    make is adding a private access modifier to the radius field. I’ll also move `radius`
    to the top just so that it is easier to see for this discussion:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到改进`Circle`类。我们将做的第一个改进是给半径字段添加一个私有访问修饰符。我还会将`radius`移到顶部，这样在讨论中更容易看到：
- en: '[PRE10]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The private access modifier tells us that only methods in “this particular
    object” are allowed to change the radius. That’s perfect, except now the radius
    field is totally hidden. There isn’t any way to set it from the outside, and we’ll,
    of course, need to do that at some point. Let’s change the access modifier to
    something more permissive:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 私有访问修饰符告诉我们，只有“这个特定对象”中的方法可以更改半径。这很完美，但现在半径字段完全隐藏了。没有从外部设置它的方法，我们当然需要在某个时候这样做。让我们将访问修饰符更改为更宽容的：
- en: '[PRE11]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: OK. Now we’re back to where we started. The public access modifier means that
    anything can alter the radius. That’s not good! Dagnabbit!
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们回到了起点。公共访问修饰符意味着任何东西都可以更改半径。这不好！该死！
- en: 'We need private back, but we need it to be a little better. We need accessor
    methods to allow us to get and set the field’s value from outside this object,
    but in a manner we control. When I do this, I use a common convention of renaming
    the field so that it starts with an underscore. This is done so that we can easily
    remember it’s a private backing field:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要私有回退，但我们需要它更好一些。我们需要访问器方法来允许我们从对象外部获取和设置字段值，但以一种我们控制的方式。当我这样做时，我使用一个常见的约定，将字段重命名，使其以下划线开头。这样做是为了我们可以轻松记住它是一个私有回退字段：
- en: '[PRE12]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, let’s add an accessor method that allows us to get the radius. The `get`
    method is commonly called a *getter*. We don’t need any restrictions on this one:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个访问器方法，以便我们可以获取半径。`get` 方法通常被称为 *getter*。我们不需要对这个方法有任何限制：
- en: '[PRE13]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let’s deal with the real problem at hand, which is controlling how the
    radius is set. Another accessor method can be used:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理手头的真正问题，即控制半径的设置方式。另一个访问器方法可以用来：
- en: '[PRE14]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we have a `set` method, commonly called a *setter*, that can set the value.
    Note that its access modifier is public, which we just learned means anything
    can access it. This setter method contains code that checks to see whether the
    new radius conforms to the required range. If it does, it goes ahead and changes
    the radius to the new value. The object is now in command of its own state. You
    can’t just randomly set the value to an invalid number. You have to *ask* the
    object to change its radius value, and it doesn’t automatically say *OK* – it
    checks to make sure you didn’t pass something that doesn’t make sense.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `set` 方法，通常被称为 *setter*，可以设置值。请注意，它的访问修饰符是公共的，这是我们刚刚学到的意味着任何东西都可以访问它。这个设置器方法包含检查新半径是否符合所需范围的代码。如果符合，它就会将半径更改为新值。现在对象控制着自己的状态。你不能随意将值设置为无效的数字。你必须
    *请求* 对象更改其半径值，而且它不会自动说 *好的* – 它会检查确保你没有传递一些没有意义的东西。
- en: Additionally, accessor methods can be used to define a read-only property. By
    simply neglecting to create a public setter method, you limit the ability to set
    the value of the private field to other methods within this class.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，访问器方法还可以用来定义只读属性。通过简单地忽略创建公共设置器方法，你限制了将私有字段值设置给这个类中其他方法的权限。
- en: C# auto-implemented properties
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 自动实现属性
- en: If you’re a C# veteran, you’re no doubt yelling at this book right now. Don’t
    do that. First, it makes you look crazy unless you have your earbuds in, then
    at least people around you will think you’re just yelling at your mother-in-law.
    Second, this book is very sensitive. You might hurt its feelings. I get it. The
    earlier example is definitely not how we usually make accessor methods in C# –
    at least not these days. Back when I was your age, gas was 35 cents per gallon,
    and that’s exactly how we did it. I like showing it to you that way because I
    think just throwing `int foo { get; set; }` at someone without explaining how
    it works is kind of mean, which is to say that’s how the average C# book might
    cover it. As we all know, *mean* is the average. Was that a math pun? Yes, I think
    it was.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 C# 老兵，你现在可能正在对这本书大喊大叫。不要这样做。首先，除非你戴着耳机，否则这会让你看起来很疯狂，然后至少你周围的人会认为你只是在对着岳母大喊大叫。其次，这本书非常敏感。你可能会伤害它的感情。我明白。早期的例子绝对不是我们通常在
    C# 中创建访问器方法的方式 – 至少不是现在。在我和你一样大的时候，汽油是每加仑 35 美分，我们就是这样做的。我喜欢这样展示给你，因为我认为如果不解释它是如何工作的就把
    `int foo { get; set; }` 丢给某人，那有点残忍，也就是说，这就是平均的 C# 书籍可能会涵盖它的方式。众所周知，*残忍* 是平均的。那是一个数学双关语吗？是的，我认为是。
- en: Modern C# has a different syntax for defining properties predicated on the idea
    that most properties are really fields. But if you leave them as fields, your
    OOP professor will give you a B because you didn’t encapsulate them. We can’t
    have that. I could climb back up on my soapbox and decry their existence, but
    I have a page count I need to stay under, so let’s just see how they work and
    you can decide whether they are a good idea or not.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C#定义属性有不同的语法，基于这样一个观点：大多数属性实际上都是字段。但如果你把它们当作字段，你的面向对象教授会给你一个 B，因为你没有封装它们。我们不能这样。我可以回到我的肥皂箱上，谴责它们的存在，但我有一个页数限制需要遵守，所以我们来看看它们是如何工作的，你可以决定它们是否是一个好主意。
- en: 'If you want to say your class is fully encapsulated, but you don’t need any
    logic to control state, your code winds up with a lot of boilerplate code like
    this:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要说明你的类是完全封装的，但不需要任何逻辑来控制状态，你的代码最终会变成很多像这样的样板代码：
- en: '[PRE15]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That’s a lot of code that doesn’t do anything. It only exists in the service
    of calling the class members *encapsulated*. In this case, there might not be
    a need to control the first and last name fields. I can’t think of any restrictions
    you might put on the kind of data, aside from it being a required field within
    a user interface. Let’s say the boilerplate is legitimate but we want to be modern
    and use auto-implemented properties. Your code can be reduced to this:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆不做什么的代码。它只存在于调用类成员 *封装* 的服务中。在这种情况下，可能没有必要控制姓名字段的第一和最后部分。我想不出你可能会对数据类型施加的任何限制，除了它必须是一个用户界面中的必填字段。假设样板代码是合法的，但我们想现代化并使用自动实现的属性。你的代码可以简化为这样：
- en: '[PRE16]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Auto-implemented properties allow you to use this shortened syntax if you don’t
    have logic to put in the getter and setter methods.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现的属性允许你在不需要在获取器和设置器方法中放入逻辑的情况下使用这种简化的语法。
- en: Accessor logic with backing variables
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有后备变量的访问器逻辑
- en: 'The real power of encapsulation happens when you use the accessor methods to
    control the state of your object. Your biggest job as a developer is making sure
    your object is incapable of entering into an invalid state. For example, take
    `Age`. A negative number in the age property doesn’t make sense. Neither does
    a billion years. The oldest human lifespan ever recorded that I know of was Methuselah,
    in the Old Testament, who live to be about 970 years old. Since there is no accessor
    logic, I can make the age 100 years or 1,000,000,000 years. If I want the controlling
    logic to limit the input values, I need to create something like this:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的实际力量在于你使用访问器方法来控制对象的状态。作为开发者，你的最大任务是确保你的对象无法进入无效状态。例如，考虑 `Age` 属性。年龄属性中的负数没有意义。同样，一亿年也没有意义。据我所知，有史以来最长寿的人类是《旧约》中的玛土撒拉，他活到了大约
    970 岁。由于没有访问器逻辑，我可以将年龄设置为 100 岁或 1,000,000,000 年。如果我想让控制逻辑限制输入值，我需要创建类似这样的东西：
- en: '[PRE17]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we create a private backing variable called `_age`. We need this to hold
    the value since the property is now under the control of accessor logic. It is
    common to name private variables beginning with an underscore.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `_age` 的私有后备变量。我们需要这个变量来保存值，因为属性现在处于访问器逻辑的控制之下。通常，以下划线开头的私有变量命名是常见的。
- en: 'Next, we add the logic. We don’t really need anything special on the getter:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加逻辑。在获取器上我们实际上并不需要任何特殊的东西：
- en: '[PRE18]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The setter is where the magic happens:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 设置器是魔法发生的地方：
- en: '[PRE19]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, we make the property with the auto-implemented method syntax, but this
    time, there’s more to it. Essentially, the syntax for the getter is a fat-arrow
    function that returns the `_age` backing variable. The setter is straightforward
    except for the value variable. Where does that come from? It’s magic. It’s part
    of the language for use in this scenario. It holds the value of whatever was passed
    into the setter.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用自动实现的方法语法来创建属性，但这次内容更丰富。本质上，获取器的语法是一个返回 `_age` 后备变量的胖箭头函数。设置器除了值变量外都很直接。这个值变量从哪里来？这是魔法。它是语言的一部分，用于这种场景。它保存了传递给设置器的任何值。
- en: Inheritance
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'C# is a statically compiled language that supports a classical inheritance
    model. By statically compiled, I mean the structure of your objects can’t change
    unless you stop your running program, alter the source code for the class, recompile,
    and rerun. You can contrast C#’s static nature with a language designed to be
    dynamic: JavaScript.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种静态编译的语言，支持经典继承模型。我所说的静态编译是指你的对象结构不能改变，除非你停止运行程序，修改类的源代码，重新编译，然后再次运行。你可以将
    C# 的静态特性与设计为动态的语言（如 JavaScript）进行对比。
- en: JavaScript breaks from a great many conventions, not the least of which is that
    it uses prototypes for inheritance instead of classes. For that matter, it doesn’t
    support encapsulation. It is based heavily on the idea of Lambda functions, which
    was also novel when JavaScript was invented. JavaScript uses lexical scope instead
    of the more conventional block scope we find in C#. In short, JavaScript is really
    weird when compared with C# if C# is the only language you know.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript与许多约定不同，其中最不寻常的是它使用原型进行继承而不是类。就这个而言，它不支持封装。它基于Lambda函数的概念，这在JavaScript被发明时也是新颖的。JavaScript使用词法作用域而不是我们在C#中找到的更传统的块作用域。简而言之，如果你只了解C#，JavaScript与C#相比真的很奇怪。
- en: Now that we’ve established there’s more than one way to do inheritance, let’s
    switch back over to how it works in C#.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了有不止一种继承方式，让我们回到C#中看看它是如何工作的。
- en: 'Let’s suppose you are writing software to track the faculty and student body
    at a school, or university. You need to model a student class – maybe something
    like this:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写软件来跟踪学校或大学的教师和学生群体。你需要建模一个学生类——可能像这样：
- en: '[PRE20]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, you need to model a `professor` class – maybe something like
    this:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要建模一个`professor`类——可能像这样：
- en: '[PRE21]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a problem here. There are a lot of properties that are redundant since
    they are used in both classes. OOAD would have us redesign these two classes by
    abstracting the common properties into a superclass. This leaves only those elements
    that are unique to the `Student` and `Professor` classes. The obvious targets
    for hoisting to the superclass are the following common properties:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们遇到了一个问题。由于这些属性在两个类中都被使用，所以有很多属性是冗余的。面向对象分析（OOAD）会让我们通过将公共属性抽象成超类来重新设计这两个类。这留下了只有`Student`和`Professor`类中独特的元素。提升到超类中的明显目标属性如下：
- en: '`FirstName`'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstName`'
- en: '`LastName`'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LastName`'
- en: '`Email`'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email`'
- en: '`Courses`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Courses`'
- en: Less obvious targets for hoisting include the `AskParentsForMoney()` method
    in the student class and the `BegForResearchFunding()` method in the professor
    class. They effectively do the same thing. The only difference is who is being
    asked to part with cash.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的目标提升包括学生类中的`AskParentsForMoney()`方法和教授类中的`BegForResearchFunding()`方法。它们实际上做的是同一件事。唯一的区别是询问谁放弃现金。
- en: 'Let’s make a superclass:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个超类：
- en: '[PRE22]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I’ve dubbed the superclass `Person`. It has the common elements between the
    student and the professor. Now, let’s make the `Student` class inherit from the
    `Person` class. To signal inheritance, I’ll add a colon followed by the superclass
    on the first line:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我把超类命名为`Person`。它包含学生和教授之间的公共元素。现在，让我们让`Student`类从`Person`类继承。为了表示继承，我将在第一行添加一个冒号后跟超类：
- en: '[PRE23]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now I’ll only keep the properties that aren’t defined in the superclass. There
    is just one:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只保留在超类中未定义的属性。只有一个：
- en: '[PRE24]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The same goes for methods. I only need those that are not in the superclass:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法也是如此。我只需要那些不在超类中的方法：
- en: '[PRE25]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I can do the same thing with the `Professor` class:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以用同样的方式对`Professor`类做同样的事情：
- en: '[PRE26]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, the class only contains the properties and methods unique to the `Professor`
    class. The common properties and methods are in the `Person` superclass.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类只包含`Professor`类中独特的属性和方法。公共属性和方法在`Person`超类中。
- en: The key to understanding inheritance is to vocalize the relationship between
    `Person`, `Student`, and `Professor`. We can say a `Student` *IS A* `Person` (debatable
    in their freshman and sophomore years), and we can say a `Professor` *IS A* `Person`
    (debatable after they get tenure). This vocalization both defines and illustrates
    the relationship between the superclass, sometimes called the parent class, and
    its descendants, called subclasses or children.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 理解继承的关键是口头表达`Person`、`Student`和`Professor`之间的关系。我们可以说一个`Student`*是*一个`Person`（在他们的大学一年级和二年级可能存在争议），我们也可以说一个`Professor`*是*一个`Person`（在他们获得终身教职后可能存在争议）。这种口头表达既定义了又说明了超类（有时称为父类）与其后代（称为子类或孩子）之间的关系。
- en: 'This leads us to a question: would it ever make sense to instantiate the `Person`
    class? The answer is no. `Person` is designed to be a parent class. It isn’t intended
    to be used directly. Classes that are not meant to be instantiated are called
    `Person` class was this:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个问题：是否有可能实例化`Person`类？答案是：不会。`Person`类被设计成是一个父类。它不打算被直接使用。那些不打算被实例化的类被称为`Person`类，如下所示：
- en: '[PRE27]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `abstract` keyword will prevent direct instantiation.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`关键字将防止直接实例化。'
- en: Just remember that inheritance is a vital part of your OOP toolbox. Inheritance
    is like eggs. It’s part of a balanced breakfast, but a really good breakfast has
    some fiber in it too. Let’s get some metaphorical fiber in our code by learning
    about interfaces. Interfaces do nothing to lessen your risk of heart disease like
    a good bowl of low-sugar oatmeal does. Using them might lower your stress levels
    later when you discover how flexible your code will be once you incorporate them,
    which is just as good. If you eat low-sugar oatmeal *and* use interfaces in your
    code, maybe you’ll give Elvis a run for his money in terms of lifespan.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，继承是OOP工具箱中的一个重要部分。继承就像鸡蛋一样。它是均衡早餐的一部分，但一个真正好的早餐还应该有一些纤维。让我们通过学习接口来给我们的代码增加一些比喻性的纤维。接口并不能像一碗低糖燕麦粥那样减少你患心脏病的风险。使用它们可能会在你发现一旦将它们纳入其中，你的代码将多么灵活时降低你的压力水平，这同样很好。如果你吃低糖燕麦粥*并且*在代码中使用接口，也许你会在寿命上与猫王一较高下。
- en: Interfaces
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An **interface** defines all or part of the structure a class must take by defining
    the public method signatures and properties that must be present in the class.
    This is a powerful tool that allows you to create a specification for an object’s
    behavior. The power of interfaces is multiplied by the fact that you are not limited
    to implementing a single interface versus using subclassing where you are only
    allowed a single parent.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**通过定义类必须具有的公共方法签名和属性来定义类必须采取的结构的一部分或全部。这是一个强大的工具，它允许你为对象的行为创建一个规范。接口的力量通过这样一个事实而倍增，即你不仅限于实现单个接口，与使用子类化的情况相比，在子类化中你只允许有一个父类。'
- en: 'Interfaces serve to loosely define behavior or type. Here’s a shout-out to
    all the *Unity 3D* developers in the crowd: imagine creating a video game where
    the player battles zombies and ancient creatures conjured by the imagination of
    H.P. Lovecraft – oh, and cats because cats are scary. Each monster could have
    its own class. You could create an interface to define behaviors such as fighting,
    running, eating humans, and more. Such a video game might look like *Figure A1.9*:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 接口用于松散地定义行为或类型。向所有在场的*Unity 3D*开发者致敬：想象一下创建一个玩家与僵尸和H.P. Lovecraft想象中的古老生物战斗的视频游戏——哦，还有猫，因为猫很可怕。每个怪物都可以有自己的类。你可以创建一个接口来定义诸如战斗、奔跑、吃人等行为。这样的视频游戏可能看起来像*图A1.9*：
- en: '![Figure A1.9: A terrible video game design that masterfully uses interfaces
    to map behaviors to characters in the game. ](img/B18605_Figure_A1.6.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.9：一个巧妙使用接口将行为映射到游戏角色中的角色设计糟糕的视频游戏](img/B18605_Figure_A1.6.jpg)'
- en: 'Figure A1.9: A terrible video game design that masterfully uses interfaces
    to map behaviors to characters in the game.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.9：一个巧妙使用接口将行为映射到游戏角色中的角色设计糟糕的视频游戏。
- en: With these interfaces, you could define behaviors on objects that don’t necessarily
    fit together in an inheritance chain and wind up with game code that is very easy
    to extend.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些接口，你可以在不必要地适合继承链的对象上定义行为，并最终得到非常容易扩展的游戏代码。
- en: The key benefit to interfaces versus inheritance is flexibility. In [*Chapter
    2*](B18605_02.xhtml#_idTextAnchor036), we learn about SOLID principles and we
    learn about techniques for avoiding tightly coupling your classes together. If
    you define a property on a class with a type of `Monster`, then only `Monster`
    or a subclass of `Monster` will work. Your class is tightly coupled to `Monster`.
    If you define it by an interface, such as `IEatHumans`, you can pass any object
    that implements the interface as long as all you need are the methods defined
    by that interface.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承相比，接口的关键优势在于灵活性。在[*第二章*](B18605_02.xhtml#_idTextAnchor036)中，我们学习了SOLID原则，并了解了避免将类紧密耦合在一起的技术。如果你在一个具有`Monster`类型的类上定义一个属性，那么只有`Monster`或`Monster`的子类才能工作。你的类与`Monster`紧密耦合。如果你通过一个接口，例如`IEatHumans`，来定义它，那么只要所有你需要的是该接口定义的方法，你就可以传递任何实现该接口的对象。
- en: Defining interfaces
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义接口
- en: 'Practically speaking, if next week the game director decides to add a new monster
    to the game, we don’t have to reshuffle our object hierarchy if the new monster
    doesn’t happen to fit the structure we’ve created. We just make a new class and
    use the interfaces to define its structure. Let’s code out what we have in *Figure
    A1.9* in C#, so we can see what this looks like in code instead of just a diagram.
    There are three interfaces used by the four characters:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果下周游戏导演决定在游戏中添加一个新的怪物，如果新怪物不符合我们创建的结构，我们不需要重新调整我们的对象层次结构。我们只需创建一个新的类，并使用接口来定义其结构。让我们用
    C# 编写我们在 *图 A1.9* 中看到的内容，这样我们就可以看到代码中的样子，而不仅仅是图表。四个角色使用了三个接口：
- en: '`IRun`'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IRun`'
- en: '`IFight`'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IFight`'
- en: '`IEatHumans`'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEatHumans`'
- en: 'Let’s start with the `IRun` interface. Making interfaces is pretty easy. All
    you need to do is specify the basics of the method signature – specifically, the
    return type, the name of the method, and the names and types of the arguments:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `IRun` 接口开始。创建接口相当简单。你所需要做的只是指定方法签名的基本要素——具体来说，是返回类型、方法名称以及参数的名称和类型：
- en: '[PRE28]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That was easy. What we’ve done here is to specify that any class implementing
    this interface must have two methods, both of which have a `void` return type.
    One must be called `Jog()`, which takes no arguments, and the other must be called
    `Sprint()`, which also takes no arguments. If you’re using a good IDE, any class
    you create that implements an interface will mark your code with red squiggles
    until you meet all the requirements of the interfaces. Let’s do `IFight` next:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。我们在这里所做的是指定任何实现此接口的类都必须有两个方法，这两个方法都有 `void` 返回类型。其中一个必须命名为 `Jog()`，它不接受任何参数，另一个必须命名为
    `Sprint()`，它也不接受任何参数。如果你使用的是一个好的 IDE，任何实现接口的类都会在你的代码中用红色波浪线标记，直到你满足接口的所有要求。让我们接下来做
    `IFight`：
- en: '[PRE29]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`IFight` says any class that implements this interface must have a method called
    `Attack()`, which returns `void` and takes no arguments:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`IFight` 表示任何实现此接口的类都必须有一个名为 `Attack()` 的方法，该方法返回 `void` 并且不接受任何参数：'
- en: '[PRE30]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`IEatHumans` requires the implementing class to have a method called `Chomp()`,
    which takes no arguments and returns `void`. Interfaces are easy. Let’s look at
    how they’re used.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEatHumans` 要求实现类必须有一个名为 `Chomp()` 的方法，该方法不接受任何参数并返回 `void`。接口很简单。让我们看看它们是如何使用的。'
- en: Implementing interfaces
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'First, let’s make a class for `HelplessVictim`. The class implements the `IRun`
    interface. The syntax is the same as it is for inheritance. We use a colon to
    indicate the interface implementation, which would be the same if we were inheriting
    from a superclass:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为 `HelplessVictim` 创建一个类。该类实现了 `IRun` 接口。语法与继承相同。我们使用冒号来表示接口实现，这与从超类继承时相同：
- en: '[PRE31]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To satisfy the interface, we must implement two methods, `Jog()` and `Sprint()`,
    exactly as specified in the interface. That’s nice. What if we need to implement
    more than one interface? It’s not possible for a class to have two parent classes.
    C# mercifully doesn’t support multiple inheritance, which is the leading cause
    of clinical insanity among C++ programmers. However, classes can implement as
    many interfaces as you’d like. Let’s make the `AncientTerror` class, which implements
    three interfaces – `IRun`, `IFight`, and `IEatHumans`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足接口，我们必须实现两个方法，`Jog()` 和 `Sprint()`，它们必须与接口中指定的完全一致。这很好。如果我们需要实现多个接口怎么办？一个类不能有两个父类。幸运的是，C#
    不支持多重继承，这是 C++ 程序员临床疯狂的主要原因之一。然而，类可以实现任意数量的接口。让我们创建一个 `AncientTerror` 类，它实现了三个接口——`IRun`、`IFight`
    和 `IEatHumans`：
- en: '[PRE32]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`IRun` requires the same `Jog()` and `Sprint()` methods to be implemented.
    Note that it isn’t necessary to have the exact same implementation for the different
    classes. The instance methods simply have to conform to the interface. `IFight`
    requires the addition of a method called `Attack()`, which returns `void` and
    takes no arguments. `IEatHumans` requires us to add a `Chomp()` method per the
    interface.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`IRun` 要求实现相同的 `Jog()` 和 `Sprint()` 方法。请注意，对于不同的类，不需要有完全相同的实现。实例方法只需符合接口即可。`IFight`
    要求添加一个名为 `Attack()` 的方法，该方法返回 `void` 并且不接受任何参数。`IEatHumans` 要求我们根据接口添加一个 `Chomp()`
    方法。'
- en: I’ll save the scariest monsters, the zombie and the house cat, as an exercise
    in the questions section at the end. Challenge yourself and see whether you can
    come up with the basic implementation for these remaining two classes!
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我会把最可怕的怪物，僵尸和家猫，留到最后的问答部分作为一个练习。挑战自己，看看你是否能想出这两个剩余类的基本实现！
- en: IDEs for C# development
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 开发的 IDE
- en: Whenever I work in a new or unfamiliar language, the first thing I want to know
    about is the tools used to work in that language. Good tools make learning and
    working with the language much easier. Microsoft realized this, and when they
    released the C# language and the accompanying .NET runtime, they also released
    Visual Studio – an IDE written specifically for use with C# and another very popular
    programming language called Visual Basic.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我使用一种新的或不熟悉的语言时，我最想了解的是用于该语言工作的工具。好的工具可以使学习和使用该语言变得容易得多。微软意识到了这一点，在发布C#语言和相应的.NET运行时后，他们也发布了Visual
    Studio——这是一个专门为C#和另一种非常流行的编程语言Visual Basic编写的IDE。
- en: Visual Basic was Visual Studio’s predecessor. During the 1990s, Visual Basic
    was the most widely used development language product from Microsoft. The company
    also sold an IDE geared for C++ development called Visual C++, and briefly and
    ineffectively dabbled in Java with Visual J++. Of these toolkits, Visual Basic
    was by far the most important. At the time, Visual C++ was used by “serious” developers.
    Microsoft Windows is written in C and C++, so naturally, the tooling in Visual
    C++ was first and foremost designed to support that effort. Corporate software
    really became possible and mainstream with the BASIC language. In fact, the BASIC
    language formed the cornerstone of Microsoft itself. Bill Gates bought the rights
    for a BASIC compiler, and along with the **Microsoft Disk Operating System** (**MS-DOS**),
    he formed what would become one of the largest software companies in the world.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic是Visual Studio的前身。在20世纪90年代，Visual Basic是微软最广泛使用的开发语言产品。该公司还销售了一个针对C++开发的IDE，称为Visual
    C++，并短暂而无效地尝试了Java，推出了Visual J++。在这些工具包中，Visual Basic无疑是其中最重要的。当时，Visual C++被“严肃”的开发者使用。由于微软Windows是用C和C++编写的，因此Visual
    C++的工具首先是为了支持这项工作而设计的。企业级软件真正成为可能并主流化，这要归功于BASIC语言。事实上，BASIC语言构成了微软自身的基石。比尔·盖茨购买了BASIC编译器的权利，并与**微软磁盘操作系统**（**MS-DOS**）一起，形成了将成为世界上最大的软件公司之一的实体。
- en: Visual Basic was designed by Alan Cooper. Cooper was a visionary. The Visual
    Basic UI was the first WYSIWYG design platform for computer software. Before the
    World Wide Web, we built software that ran solely on the desktop, and Visual Basic
    was the innovation that drove the industry.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Basic是由艾伦·库珀设计的。库珀是一位有远见的人。Visual Basic的用户界面是计算机软件的第一个所见即所得设计平台。在万维网出现之前，我们构建的软件仅能在桌面上运行，而Visual
    Basic是推动行业创新的力量。
- en: 'But that’s enough history. Today, there are three important IDEs I want to
    tell you about. Chances are you’ve used one of them already. These tools include
    the following:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 但历史就讲到这里。今天，我想介绍三个重要的集成开发环境（IDE）。很可能你已经使用过其中之一。这些工具包括以下内容：
- en: Visual Studio
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio
- en: VS Code
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code
- en: Rider
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rider
- en: There are other IDEs out there, but these three are the most popular, complete,
    and frankly, important. If you use a Mac, it is worth mentioning that Visual Studio
    for Mac is not a port of Visual Studio. Earlier, I mentioned the open source version
    of C# called Mono. The team that developed Mono created an IDE called *Monodevelop*.
    It looks a lot like Apple’s X-Code IDE, and it was designed to allow Linux developers
    to write C# programs. *Monodevelop* was open source and was ultimately forked
    to become *Xamarin Studio*. *Xamarin Studio* is an IDE geared toward mobile development.
    Microsoft bought out Xamarin several years ago. A separate fork of the technology
    became Visual Studio for Mac. I mention it because it looks nothing like the IDEs
    we’ll be covering, so if you’re on a Mac, my screenshots won’t help much.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他IDE，但这三个是最受欢迎、最完整，坦白说，最重要的。如果你使用Mac，值得一提的是，Visual Studio for Mac并不是Visual
    Studio的移植版。之前我提到了C#的开源版本Mono。开发Mono的团队创建了一个名为*Monodevelop*的IDE。它看起来很像苹果的X-Code
    IDE，并且被设计成允许Linux开发者编写C#程序。"Monodevelop"是开源的，并最终分叉成为*Xamarin Studio*。"Xamarin
    Studio"是一个面向移动开发的IDE。几年前，微软收购了Xamarin。该技术的另一个分支成为了Visual Studio for Mac。我提到它是因为它与我们将要讨论的IDE看起来完全不同，所以如果你使用Mac，我的截图可能不会很有帮助。
- en: 'To learn patterns, you only need a fraction of the functionality these IDEs
    provide. In this section, I wanted to walk you through creating the two project
    types found in this book: the command-line project and the library project.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习模式，你只需要使用这些IDE提供功能的一小部分。在本节中，我想带你了解本书中提到的两种项目类型：命令行项目和库项目。
- en: Command-line programs are the simplest programs you can make that will actually
    run. They have no user interface and are run from, you guessed it, the command
    line. Libraries are code projects used to house objects meant to be shared between
    projects. In [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063), I create a shared
    library that is used across many other chapters because they share a lot of the
    same code, as typing the same classes over and over would get very tedious.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行程序是您可以创建的最简单的程序，实际上可以运行。它们没有用户界面，并且从，您猜对了，命令行中运行。库是用于存放要在项目之间共享的对象的代码项目。在
    [*第 3 章*](B18605_03.xhtml#_idTextAnchor063) 中，我创建了一个共享库，它被许多其他章节使用，因为它们有很多相同的代码，重复输入相同的类会非常乏味。
- en: Let’s take a look at these IDEs starting with Visual Studio.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从 Visual Studio 开始看看这些 IDE。
- en: Visual Studio
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio
- en: 'Visual Studio needs no further introduction. You can get a copy at [https://www.visualstudio.com](https://www.visualstudio.com).
    The IDE comes in three editions:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 无需进一步介绍。您可以在 [https://www.visualstudio.com](https://www.visualstudio.com)
    获取一份。IDE 有三个版本：
- en: Visual Studio Community
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Community
- en: Visual Studio Professional
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Professional
- en: Visual Studio Enterprise
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise
- en: The first two are effectively identical except for how they are licensed. The
    Community Edition is free assuming you meet the licensing requirements. These
    things tend to change over time, so I’m not going to try to quote those requirements
    here. Review the Visual Studio website to see whether you qualify for a free license.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个版本在许可方式上实际上是一样的，只是许可方式不同。社区版在满足许可要求的情况下是免费的。这些事情会随着时间的推移而变化，所以我不想在这里引用那些要求。请查看
    Visual Studio 网站，看看您是否符合免费许可证的资格。
- en: Visual Studio Professional is the paid version of the same tool. If you work
    for a company with a certain number of developers, or that makes a certain amount
    of revenue, you need to buy a subscription.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Professional 是同一工具的付费版本。如果您为拥有一定数量开发人员或收入达到一定数额的公司工作，您需要购买订阅。
- en: Visual Studio Enterprise is a more expensive version of the paid editions and
    ships with a myriad of extra features not present in the Professional Edition.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Enterprise 是付费版本中更昂贵的一种，它包含了许多专业版中不存在的额外功能。
- en: Any of these editions will be fine for use with this book. I’ll be demonstrating
    the Community Edition, which, again, is indistinguishable from the Professional
    Edition.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些版本都可以与本书一起使用。我将演示社区版，它再次与专业版没有区别。
- en: Creating a command-line project
  id: totrans-627
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命令行项目
- en: Having downloaded, installed, registered, and launched the IDE, you are greeted
    with a screen that looks something like *Figure A1.10:*
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 下载、安装、注册并启动 IDE 后，您将看到一个类似于 *图 A1.10* 的屏幕。
- en: '![Figure A1.10: The opening screen for Visual Studio 2022\. ](img/B18605_Figure_A1.7.jpg)'
  id: totrans-629
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.10：Visual Studio 2022 的启动屏幕。](img/B18605_Figure_A1.7.jpg)'
- en: 'Figure A1.10: The opening screen for Visual Studio 2022.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.10：Visual Studio 2022 的启动屏幕。
- en: 'Click on the **Create a new project** button in the lower-right corner of the
    window. Doing this presents you with *Figure A1.11*:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 点击窗口右下角的 **创建新项目** 按钮。这样做会显示 *图 A1.11*：
- en: '![Figure A1.11: Create a new project in Visual Studio using this dialog. ](img/B18605_Figure_A1.8.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.11：使用此对话框在 Visual Studio 中创建一个新项目。](img/B18605_Figure_A1.8.jpg)'
- en: 'Figure A1.11: Create a new project in Visual Studio using this dialog.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.11：使用此对话框在 Visual Studio 中创建一个新项目。
- en: 'You’re looking for the *Console App* project in C#. If you did a full install
    of Visual Studio, beware that the tool might show you Visual Basic projects as
    well as C#. Make sure you pick the C# version of the project template. Note that
    the icons on the templates denote the language they use, as shown in *Figure A1.12*:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，您正在寻找的是 *控制台应用程序* 项目。如果您完整安装了 Visual Studio，请注意，该工具可能会同时显示 Visual Basic
    和 C# 项目。请确保您选择 C# 版本的模板。请注意，模板上的图标表示它们使用的语言，如图 *图 A1.12* 所示：
- en: '![Figure A1.12: Watch the icons on the project templates; it is easy to accidentally
    generate a new project in the wrong language. ](img/B18605_Figure_A1.9.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.12：注意项目模板上的图标；很容易不小心在错误的语言中生成新项目。](img/B18605_Figure_A1.9.jpg)'
- en: 'Figure A1.12: Watch the icons on the project templates; it is easy to accidentally
    generate a new project in the wrong language.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.12：注意项目模板上的图标；很容易不小心在错误的语言中生成新项目。
- en: 'If you don’t see the **Console App** project template, you can search for it
    using the search dialog at the top, as shown in *Figure A.13*:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到**控制台应用程序**项目模板，可以使用顶部的搜索对话框进行搜索，如图 A.13 所示：
- en: '![Figure A1.13: You can search for the console app template if you don’t see
    it listed. ](img/B18605_Figure_A1.10.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.13：如果您没有看到控制台应用程序模板，可以搜索它](img/B18605_Figure_A1.10.jpg)'
- en: 'Figure A1.13: You can search for the console app template if you don’t see
    it listed.'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.13：如果您没有看到控制台应用程序模板，可以搜索它
- en: 'Click on the **Console App** template, and click on **Next** in the lower-right
    corner of the dialog. This takes you to a dialog titled **Configure your new project**,
    as shown in *Figure A1.14*:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**控制台应用程序**模板，然后在对话框的右下角点击**下一步**。这将带您到一个标题为**配置您的项目**的对话框，如图 A1.14 所示：
- en: '![Figure A1.14: Configuring your new project by giving it a name and location
    ](img/B18605_Figure_A1.11.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.14：通过命名和指定位置来配置您的项目](img/B18605_Figure_A1.11.jpg)'
- en: 'Figure A1.14: Configuring your new project by giving it a name and location'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.14：通过命名和指定位置来配置您的项目
- en: This dialog allows you to name your project and specify its location on your
    hard drives. You can also choose to name your solution differently than your project.
    A solution is a collection of projects bound into one set of files. This allows
    you to work on multiple related projects in a convenient way. Maybe you have a
    web application and a related command-line program that belong together. A solution
    allows you to store the related projects together. If you are storing related
    projects together, you might not want to name the solution the same as the project.
    For the exercises in this book, it doesn’t matter.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 此对话框允许您为项目命名并指定其在硬盘上的位置。您还可以选择将解决方案命名为与项目不同的名称。解决方案是一组项目绑定在一起的一组文件。这允许您以方便的方式处理多个相关项目。也许您有一个属于同一组的Web应用程序和相关的命令行程序。解决方案允许您将相关项目存储在一起。如果您将相关项目存储在一起，可能不想将解决方案命名为与项目相同的名称。对于本书中的练习，这并不重要。
- en: 'We’re going to name the project `BicycleConsoleApp`. We’re going to name the
    solution `BicycleSolution`. Use a location on your computer that is convenient.
    The checkbox at the bottom specifies a folder structure. You can just leave it
    unchecked. Your project configuration should resemble *Figure A1.15*. Click on
    the **Next** button in the lower-right corner of the dialog:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目命名为 `BicycleConsoleApp`。我们将解决方案命名为 `BicycleSolution`。请使用您计算机上方便的位置。底部的复选框指定文件夹结构。您可以保持它未选中。您的项目配置应类似于图
    A1.15。点击对话框右下角的**下一步**按钮：
- en: '![Figure A1.15: The Additional information dialog lets you set the framework
    for the project. ](img/B18605_Figure_A1.12.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.15：附加信息对话框允许您设置项目的框架](img/B18605_Figure_A1.12.jpg)'
- en: 'Figure A1.15: The Additional information dialog lets you set the framework
    for the project.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.15：附加信息对话框允许您设置项目的框架
- en: 'The **Additional information** dialog allows you to pick the .NET Framework
    type that you’ll use for development. The default at the time of this writing
    is **.NET 6.0 (Long-term support)**. Just accept the defaults as they are and
    click on the **Create** button. This will complete project creation, and you’ll
    see the full IDE, as shown in *Figure A1.16*:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加信息**对话框允许您选择用于开发的 .NET Framework 类型。在撰写本文时，默认值为**.NET 6.0（长期支持）**。只需接受默认设置并点击**创建**按钮。这将完成项目创建，您将看到完整的
    IDE，如图 A1.16 所示：'
- en: '![Figure A1.16: The new project is created and ready in Visual Studio. ](img/B18605_Figure_A1.13.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.16：新项目已在 Visual Studio 中创建并准备就绪](img/B18605_Figure_A1.13.jpg)'
- en: 'Figure A1.16: The new project is created and ready in Visual Studio.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.16：新项目已在 Visual Studio 中创建并准备就绪
- en: Your project is ready! You can start developing your code.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目已准备就绪！您现在可以开始编写代码了。
- en: Adding a new class
  id: totrans-651
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新类
- en: 'Once your project has been created, you’ll be needing to add new classes. To
    add a class, right-click on the `BicycleConsoleApp` project, and you’ll find a
    context menu. Find the **Add** option and hover over it. A second menu expands.
    Find **Class...** at the bottom of the menu and click on it. You can see the menu
    layout in *Figure A1.17*:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建项目，您将需要添加新类。要添加类，右键单击 `BicycleConsoleApp` 项目，您将找到一个上下文菜单。找到**添加**选项，将其悬停。第二个菜单展开。在菜单底部找到**类...**并点击它。您可以在图
    A1.17 中看到菜单布局：
- en: '![Figure A1.17: The menu item for adding a class accessed from Solution Explorer
    in Visual Studio. ](img/B18605_Figure_A1.14.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.17：从 Visual Studio 的解决方案资源管理器访问的添加类菜单项。](img/B18605_Figure_A1.14.jpg)'
- en: 'Figure A1.17: The menu item for adding a class accessed from Solution Explorer
    in Visual Studio.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.17：从 Visual Studio 的解决方案资源管理器访问的添加类菜单项。
- en: 'The next step is to specify what you wish to add using the dialog in *Figure
    A1.18*. In this case, we’re adding a class. Note there is also an option for adding
    an interface. You’ll need both, but right now, let’s focus on adding a class:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 *图 A1.18* 中的对话框指定你想要添加的内容。在这种情况下，我们正在添加一个类。注意，还有一个添加接口的选项。你可能需要两者，但现在，让我们专注于添加类：
- en: '![Figure A1.18: The Add New Item dialog in Visual Studio can be used to add
    anything, including classes and interfaces. ](img/B18605_Figure_A1.15.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.18：Visual Studio 中的“添加新项”对话框可以用来添加任何东西，包括类和接口。](img/B18605_Figure_A1.15.jpg)'
- en: 'Figure A1.18: The Add New Item dialog in Visual Studio can be used to add anything,
    including classes and interfaces.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.18：Visual Studio 中的“添加新项”对话框可以用来添加任何东西，包括类和接口。
- en: Click on **Class**, then give the file a name that matches the name of the class
    you want to create. Usually, I honor the age-old Java convention of having one
    class per file. Click on the **Add** button, and the class will be created and
    added to your project.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **类**，然后给文件起一个与你要创建的类名相同的名字。通常，我会遵循古老的 Java 习惯，每个文件一个类。点击 **添加** 按钮，类就会被创建并添加到你的项目中。
- en: To add an interface, follow the same procedure, but select **Interface** instead
    of **Class**. By convention, C# interfaces always start with the letter I (as
    in “Interface”), so name your file the same as what you plan to name your interface.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加接口，遵循相同的步骤，但选择 **接口** 而不是 **类**。按照惯例，C# 接口总是以字母 I 开头（如“接口”），因此将你的文件命名为你计划命名的接口名。
- en: Adding a library project to the solution
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向解决方案添加库项目
- en: When you created the command-line app project, Visual Studio also created a
    solution. Solutions are containers for projects. Even if you only have one project,
    it will be inside a solution. You can add more projects to the solution. This
    is a handy way of keeping related projects together.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建了命令行应用程序项目时，Visual Studio 也创建了一个解决方案。解决方案是项目的容器。即使你只有一个项目，它也会在解决方案内部。你可以向解决方案中添加更多项目。这是一种方便地将相关项目放在一起的方法。
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目用于存放可重用的代码，这些代码旨在在项目之间访问。在这本书的 *第 3-5 章* 中，我使用库来存放常见的类，例如那些模拟我们在这些章节中构建的自行车类的基本部分。在现实世界中，你通常将你的业务逻辑放在库中。当你这样做时，你可以在
    Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。
- en: 'Creating a library project is easy. Right-click on the solution in the solution
    explorer. Locate the **Add** option, hover over it, and click on **New Project**.
    A new project dialog appears, as shown in *Figure A1.19*:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 创建库项目很容易。在解决方案资源管理器中右键单击解决方案。找到 **添加** 选项，将其悬停，然后点击 **新建项目**。会出现一个新的项目对话框，如图
    *图 A1.19* 所示：
- en: '![Figure A1.19: The context menu in Visual Studio used to add a new project
    to the solution. ](img/B18605_Figure_A1.16.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.19：在 Visual Studio 中用于向解决方案添加新项目的上下文菜单。](img/B18605_Figure_A1.16.jpg)'
- en: 'Figure A1.19: The context menu in Visual Studio used to add a new project to
    the solution.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.19：在 Visual Studio 中用于向解决方案添加新项目的上下文菜单。
- en: Locate the `Library` into the search box at the top of the dialog. Make sure
    the class library template is using the C# language and not some other language
    such as Visual Basic or F#. Click on the `BicycleLibrary`. The location should
    be defaulting to the location of the solution and, by extension, the console app
    project we just made. Click on the **Next** button.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话框顶部的搜索框中定位到 `Library`。确保类库模板使用的是 C# 语言，而不是其他语言，如 Visual Basic 或 F#。点击 `BicycleLibrary`。位置应默认为解决方案的位置，以及由此扩展的我们刚刚创建的控制台应用程序项目。点击
    **下一步** 按钮。
- en: The next dialog allows you to select the .NET runtime for your project. Generally,
    you want these to match. We picked .NET 6.0 for the console app, so we should
    pick the same thing here. Click on the **Create** button, and Visual Studio will
    generate the project’s files for you.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个对话框允许你为项目选择.NET运行时。通常，你希望这些匹配。我们为控制台应用程序选择了.NET 6.0，所以这里也应该选择相同的东西。点击**创建**按钮，Visual
    Studio将为你生成项目的文件。
- en: Linking the library project to the console project
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将库项目链接到控制台项目
- en: 'Before you can use the library, you must create a reference to it in the `BicycleConsoleApp`
    project. To create the reference, right-click on the **Dependencies** option in
    the console app, and then click on **Add Project Reference**. This reveals a dialog,
    as shown in *Figure A1.20*:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用库之前，你必须在该`BicycleConsoleApp`项目中创建对其的引用。要创建引用，右键单击控制台应用程序中的**依赖项**选项，然后点击**添加项目引用**。这将显示一个对话框，如图*A1.20*所示：
- en: '![Figure A1.20: The menu used to add project dependencies to a project in Visual
    Studio. ](img/B18605_Figure_A1.17.jpg)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.20：在Visual Studio中向项目中添加项目依赖项所用的菜单。](img/B18605_Figure_A1.17.jpg)'
- en: 'Figure A1.20: The menu used to add project dependencies to a project in Visual
    Studio.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.20：在Visual Studio中向项目中添加项目依赖项所用的菜单。
- en: The **Projects** option is at the top of the dialog and is probably already
    selected. You should see the name of your library project in the list. Click on
    the checkbox next to the library project you just made, and then click on **OK**.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目**选项位于对话框的顶部，可能已经选中。你应该能在列表中看到你的库项目名称。点击你刚刚创建的库项目旁边的复选框，然后点击**确定**。'
- en: Your library is now available within your console app project.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 你的库现在在你的控制台应用程序项目中可用。
- en: Referencing the library
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用库
- en: When you created the library project, Visual Studio created a file called `Class1.cs`.
    Let’s add a method to that class and then see how to reference it in the console
    app.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建库项目时，Visual Studio创建了一个名为`Class1.cs`的文件。让我们向该类添加一个方法，然后看看如何在控制台应用程序中引用它。
- en: 'Open the `Class1.cs` file in the class library project. Add this code:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 在类库项目中打开`Class1.cs`文件。添加以下代码：
- en: '[PRE33]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save the file.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Now, open the `Program.cs` file in the console app project. You should see
    a “Hello World” program. Replace the starter code with this:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开控制台应用程序项目中的`Program.cs`文件。你应该看到一个“Hello World”程序。用以下代码替换起始代码：
- en: '[PRE34]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that as you type the code (type it, don’t copy and paste – copy and paste
    teaches you nothing!), you’ll find that IntelliSense is giving you hints on the
    method you added in the library. Effectively, you are using the code in the library
    as if it were part of the console app project!
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你输入代码（输入代码，不要复制粘贴——复制粘贴学不到任何东西！）时，你会发现IntelliSense会为你提供关于你在库中添加的方法的提示。实际上，你就像使用控制台应用程序项目的一部分一样使用库中的代码！
- en: 'There’s just one thing left to do: build the project.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一一件事就是：构建项目。
- en: Building and running the console project
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和运行控制台项目
- en: C# applications are compiled. If you’re used to an interpreted language such
    as JavaScript or Python, you might not be familiar with this step. The C# compiler,
    code-named `foo`, where `foo` is any given object, an augmented text editor will
    probably give you every possible option that could come after that dot. Really
    good editors might use probability or AI to narrow the field. Visual Studio only
    shows you viable options based on introspection. The latest versions of Visual
    Studio are starting to include AI features. When AI is combined with IntelliSense,
    the results are frightening. You can expect Visual Studio to write entire blocks
    of code for you, not just boilerplate; the actual methods in your code.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: C#应用程序会被编译。如果你习惯于像JavaScript或Python这样的解释型语言，你可能不熟悉这一步。C#编译器，代号`foo`（`foo`可以是任何给定的对象），增强型文本编辑器可能会为你提供所有可能的选项。真正优秀的编辑器可能会使用概率或AI来缩小范围。Visual
    Studio只会根据自省显示可行的选项。最新的Visual Studio版本开始包含AI功能。当AI与IntelliSense结合时，结果令人恐惧。你可以期待Visual
    Studio为你编写整个代码块，而不仅仅是样板代码；你的代码中的实际方法。
- en: Better code hints and early warnings about code mistakes are among the benefits
    of working with compiled languages. The compiler doesn’t allow the most common
    types of mistakes, so you find and fix them early because you must. The product
    of a compiled language is also generally faster in terms of execution speed.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 与编译型语言一起工作的好处之一是更好的代码提示和关于代码错误的早期警告。编译器不允许最常见的错误类型，因此你必须尽早找到并修复它们，因为你必须这样做。编译型语言的产品在执行速度方面通常也更快。
- en: 'Building in Visual Studio is very simple, and there are a few ways to do it.
    The most straightforward is to run your program. To do this, just click on the
    green arrow in the toolbar. *Figure A1.21* shows the location of the **Run** button.
    Unfortunately, *Figure A1.21* isn’t in color. The book editor’s bosses muttered
    something about budgets and money not growing on trees. I haven’t met the boss
    of bosses at Packt, but I suspect they used to hang out with my father (God rest
    his soul) *A LOT*. The good news is you really can’t miss it in the IDE:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中构建非常简单，有几种方法可以做到。最直接的方法是运行你的程序。要这样做，只需在工具栏中点击绿色箭头。*图 A1.21*
    显示了**运行**按钮的位置。不幸的是，*图 A1.21* 没有彩色。书籍编辑的老板们咕哝着关于预算和钱不是从树上长出来的话。我还没有见过 Packt 的老板，但我怀疑他们以前经常和我父亲（愿他在天堂安息）*很多*次一起出去玩。好消息是，你真的在
    IDE 中找不到它：
- en: '![Figure A1.21: Locate the green triangle in the IDE; this is the Run button.
    ](img/B18605_Figure_A1.18.jpg)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.21：在 IDE 中找到绿色三角形；这是运行按钮。](img/B18605_Figure_A1.18.jpg)'
- en: 'Figure A1.21: Locate the green triangle in the IDE; this is the Run button.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.21：在 IDE 中找到绿色三角形；这是运行按钮。
- en: 'When you click on the **Run** button, your program builds, and it is then executed
    with an attached debugger. You’ll see your running program, as shown in *Figure
    A1.22*:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**运行**按钮时，你的程序将构建，然后与附加的调试器一起执行。你将看到你的运行程序，如图 *A1.22* 所示：
- en: '![Figure A1.22: The program runs in a window. ](img/B18605_Figure_A1.19.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.22：程序在窗口中运行。](img/B18605_Figure_A1.19.jpg)'
- en: 'Figure A1.22: The program runs in a window.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.22：程序在窗口中运行。
- en: 'To stop the program, press your computer’s *Any* key in the running console
    app window:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止程序，请在运行的控制台应用程序窗口中按你的电脑的**任意**键：
- en: '![Figure A1.23: Press the Any key to exit Visual Studio’s program run; if your
    computer doesn’t have an Any key like mine, you can use the spacebar. ](img/B18605_Figure_A1.20.jpg)'
  id: totrans-693
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.23：按任意键退出 Visual Studio 的程序运行；如果你的电脑没有像我一样的任意键，你可以使用空格键。](img/B18605_Figure_A1.20.jpg)'
- en: 'Figure A1.23: Press the Any key to exit Visual Studio’s program run; if your
    computer doesn’t have an Any key like mine, you can use the spacebar.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.23：按任意键退出 Visual Studio 的程序运行；如果你的电脑没有像我一样的任意键，你可以使用空格键。
- en: The *Any* key is common on older keyboards. It does limit your ability to write
    code using the letter *H*. Since I live in Texas, I just use *J* instead. It’s
    a small price to pay for being able to quickly exit from your running programs.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**任意**键在较旧的键盘上很常见。它确实限制了使用字母 *H* 编写代码的能力。由于我住在德克萨斯州，我只用 *J*。为了能够快速退出运行中的程序，这是微不足道的代价。'
- en: If your computer doesn’t have an *Any* key, just press the spacebar. Note that
    the pause message isn’t part of your program, and it won’t be there if you publish
    your application. This is Visual Studio pausing the application. Console apps
    tend to run and exit in under a second. If something goes wrong, the program will
    finish, display an error, then kill the window before you have a chance to see
    anything. So, Visual Studio does you a solid and freezes the window before the
    program exits so that you can inspect it. Your program should have run without
    any errors.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑没有**任意**键，只需按空格键。请注意，暂停信息不是你程序的一部分，如果你发布应用程序，它将不会出现。这是 Visual Studio 暂停应用程序。控制台应用程序通常在一秒内运行并退出。如果出现问题，程序将完成，显示错误，然后在你有机会看到任何内容之前关闭窗口。因此，Visual
    Studio 为你做了件好事，在程序退出之前冻结窗口，以便你可以检查它。你的程序应该没有错误地运行。
- en: This concludes our brief tour of Visual Studio. If you’re interested in a video
    walk-through that coaches you through setting up a Visual Studio development environment
    in Windows, you’ll find links for this at [https://csharppatterns.dev](https://csharppatterns.dev).
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Visual Studio 的简要游览。如果你对在 Windows 中设置 Visual Studio 开发环境的视频教程感兴趣，你可以在
    [https://csharppatterns.dev](https://csharppatterns.dev) 找到相关链接。
- en: VS Code
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code
- en: 'VS Code bears a similar name to Visual Studio but is an entirely different
    beast. Rather than being a full-fledged IDE, VS Code is really an augmented text
    editor rather than a true IDE. We just covered Microsoft’s Gold Standard for editing
    tools. Why should I even talk about VS Code? The answer: VS Code currently has
    over 50% of the market share, making it the most popular tool used by most developers
    every day. There are some good reasons for this:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 的名字与 Visual Studio 很相似，但它完全是另一种生物。它不是完整的 IDE，而是一个增强型文本编辑器，而不是真正的 IDE。我们刚刚介绍了微软的黄金标准编辑工具。我为什么要谈论
    VS Code 呢？答案是：VS Code 目前拥有超过 50% 的市场份额，成为大多数开发者每天使用的最受欢迎的工具。这有一些很好的理由：
- en: VS Code takes a fraction of the space as Visual Studio, which all-in requires
    nearly 45 GB of space. You can reduce the footprint of Visual Studio, but VS Code
    is still going to boast a smaller footprint.
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 占用的空间比 Visual Studio 小得多，Visual Studio 所需的总空间接近 45 GB。您可以减小 Visual Studio
    的占用空间，但 VS Code 仍然会保持更小的占用空间。
- en: VS Code launches very quickly. Visual Studio doesn’t. You can use VS Code to
    quickly look at a repository you pulled off GitHub or some folder a colleague
    shared with you. Launching Visual Studio is a commitment. If you’re on a less
    powerful computer, you can likely catch up on your emails, take a quick peek at
    social media, get some coffee, and call your mother before you get the IDE’s opening
    screen. By the way, call your mother! She misses you.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 启动非常快。Visual Studio 则不然。您可以使用 VS Code 快速查看从 GitHub 拉取的存储库或同事共享的某个文件夹。启动
    Visual Studio 是一种承诺。如果您使用的是性能较低的计算机，您可能可以在 IDE 的启动屏幕出现之前处理电子邮件、快速浏览社交媒体、喝咖啡，甚至给母亲打电话。顺便说一句，给母亲打电话！她想念您。
- en: VS Code works with nearly any programming language. Naturally, it works well
    with Microsoft-supported languages and other popular languages such as Golang
    or Rust. Also, you’ll find extensions that allow you to use it with oddball languages.
    The original GoF book used the SmallTalk programming language, which is offered
    by two extension vendors. You can find Ada, Haskell, and many more. Visual Studio
    is mainly used for mainstream work in Microsoft language products.
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 与几乎所有编程语言都兼容。自然，它与 Microsoft 支持的语言以及其他流行的语言（如 Golang 或 Rust）配合得很好。此外，您会发现扩展程序允许您使用它来处理一些奇怪的语言。原始的
    GoF 书籍使用了 SmallTalk 编程语言，由两家扩展供应商提供。您还可以找到 Ada、Haskell 以及更多。Visual Studio 主要用于
    Microsoft 语言产品的主流工作。
- en: VS Code has a consistent user experience across all operating systems. Visual
    Studio is a Windows-only program. It won’t run in Linux. Visual Studio Mac is
    a completely different program and looks nothing like the Windows version. This
    consistency makes the tool a popular choice for schools, universities, and code
    boot camps like the one I teach at Southern Methodist University.
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code 在所有操作系统上提供一致的用户体验。Visual Studio 是一个仅适用于 Windows 的程序。它无法在 Linux 上运行。Visual
    Studio Mac 是一个完全不同的程序，外观与 Windows 版本截然不同。这种一致性使得该工具成为学校、大学和像我所在南方卫理公会大学那样的代码训练营的流行选择。
- en: VS Code has a lot going for it. Like Visual Studio, VS Code can also be downloaded
    at [https://www.visualstudio.com](https://www.visualstudio.com).
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 有很多优点。像 Visual Studio 一样，VS Code 也可以在 [https://www.visualstudio.com](https://www.visualstudio.com)
    下载。
- en: If VS Code is going to be your editor of choice, you’re going to need to install
    the .NET Core SDK to give you the tools and compilers to work with C#.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 VS Code 将成为您首选的编辑器，那么您需要安装 .NET Core SDK 以提供用于与 C# 一起工作的工具和编译器。
- en: Installing .NET Core
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 .NET Core
- en: You need the .NET Core SDK if you are going to work with VS Code. You can download
    it from [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download).
    Naturally, that web address might change after this book is published, in which
    case you’ll have to be resourceful. Installing it is straightforward.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用 VS Code，则需要安装 .NET Core SDK 以获得用于与 C# 一起工作的工具和编译器。您可以从 [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)
    下载它。当然，这本书出版后，该网址可能会发生变化，在这种情况下，您将需要变得机智。安装它很简单。
- en: With VS Code and .NET Core SDK installed, you’re ready to get started. If you
    read the steps for setting up a project in Visual Studio, the steps for VS Code
    are very different.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了 VS Code 和 .NET Core SDK 之后，您就可以开始使用了。如果您阅读了在 Visual Studio 中设置项目的步骤，VS
    Code 的步骤则非常不同。
- en: Creating a new solution
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的解决方案
- en: Visual Studio creates a project and a solution in one step. This is VS Code.
    Each step is performed separately, and it is all done from the command line. Technically
    speaking, VS Code isn’t really involved. You use the `dotnet` command-line tool
    that was installed when you installed the .NET Core SDK. You can do all of this
    in Windows Terminal.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 一步即可创建项目和解决方案。这是 VS Code。每个步骤都是单独执行的，并且所有操作都通过命令行完成。从技术上讲，VS Code
    并未真正参与其中。您使用的是在安装 .NET Core SDK 时安装的 `dotnet` 命令行工具。您可以在 Windows Terminal 中完成所有这些操作。
- en: 'Since Windows Terminal comes with Windows 11, there is nothing further to install.
    If you’ve never used it, click on `Terminal`, as shown in *Figure A1.24*. Launch
    the app. If you’re still using Windows 10, search for `PowerShell` instead of
    `Terminal`:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Windows Terminal 随 Windows 11 一起提供，因此无需安装任何其他软件。如果您从未使用过它，请点击如图 A1.24 所示的
    `Terminal`。启动应用程序。如果您仍在使用 Windows 10，请搜索 `PowerShell` 而不是 `Terminal`：
- en: '![Figure A1.24: Most of the project setup work with VS Code happens in the
    Terminal window. ](img/B18605_Figure_A1.21.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.24：使用 VS Code 进行的大多数项目设置工作都在终端窗口中完成。](img/B18605_Figure_A1.21.jpg)'
- en: 'Figure A1.24: Most of the project setup work with VS Code happens in the Terminal
    window.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.24：使用 VS Code 进行的大多数项目设置工作都在终端窗口中完成。
- en: 'With Terminal (or PowerShell) open, type this command:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开终端（或 PowerShell）的情况下，输入此命令：
- en: '[PRE35]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here, `-o` is for *output*. This tells the command to create a folder for the
    solution. In addition to creating the folder, the command generates a set of files
    in the `BicycleSolution` folder. Let’s take a look. Type this:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-o` 是用于 *输出* 的。这告诉命令为解决方案创建一个文件夹。除了创建文件夹外，该命令在 `BicycleSolution` 文件夹中生成一组文件。让我们看看。输入以下内容：
- en: '[PRE36]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, type in this:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下内容：
- en: '[PRE37]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `dir` (directory) command will list all the files in the current working
    directory. You should see something like *Figure A1.25*:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`dir`（目录）命令将列出当前工作目录中的所有文件。您应该会看到类似于 *图 A1.25* 的内容：'
- en: '![Figure A1.25: The result of our new solution command. ](img/B18605_Figure_A1.22.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.25：我们新解决方案命令的结果](img/B18605_Figure_A1.22.jpg)'
- en: 'Figure A1.25: The result of our new solution command.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.25：我们新解决方案命令的结果。
- en: We have a solution, but there’s nothing in it. We need some projects to make
    the solution useful.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个解决方案，但里面什么都没有。我们需要一些项目来使解决方案变得有用。
- en: Creating a command-line project
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命令行项目
- en: Next, we’ll add a console application to the current solution folder. First,
    `cd` into the `BicycleSolution` folder. Going forward, the commands I’m giving
    you are based on the assumption that your present working directory is the `BicycleSolution`
    folder.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向当前解决方案文件夹添加一个控制台应用程序。首先，使用 `cd` 命令进入 `BicycleSolution` 文件夹。从现在开始，我给出的命令基于这样一个假设，即您的当前工作目录是
    `BicycleSolution` 文件夹。
- en: 'To add the console app to the solution, type this command into the Terminal
    window:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 要将控制台应用程序添加到解决方案中，请在终端窗口中输入以下命令：
- en: '[PRE38]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This creates a new console app. Again, `-o` is for output. This tells the command
    what to call the project. The `dotnet` command generates the boilerplate files
    for the console app project, as shown in *Figure A1.27*:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的控制台应用程序。同样，`-o` 是用于输出的。这告诉命令将项目命名为什么。`dotnet` 命令为控制台应用程序项目生成样板文件，如图
    A1.27 所示：
- en: '![Figure A1.27: Our command generated your file structure for the command-line
    project. ](img/B18605_Figure_A1.23.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.27：我们的命令为您生成了命令行项目的文件结构。](img/B18605_Figure_A1.23.jpg)'
- en: 'Figure A1.27: Our command generated your file structure for the command-line
    project.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.27：我们的命令为您生成了命令行项目的文件结构。
- en: 'Once you have the app created, you need to add it to your solution using this
    command:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了应用程序，您需要使用此命令将其添加到您的解决方案中：
- en: '[PRE39]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result of the command can be seen in *Figure A1.28*:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的结果可以在 *图 A1.28* 中看到：
- en: '![Figure A1.28: The console app was successfully added to the solution. ](img/B18605_Figure_A1.24.jpg)'
  id: totrans-734
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.28：控制台应用程序已成功添加到解决方案。](img/B18605_Figure_A1.24.jpg)'
- en: 'Figure A1.28: The console app was successfully added to the solution.'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.28：控制台应用程序已成功添加到解决方案中。
- en: There won’t be a visible change to the folder structure. The command alters
    the `BicycleSolution.sln` file to include the `BicycleConsoleApp` project. Your
    command-line project is ready to use.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹结构不会有明显的变化。该命令修改了 `BicycleSolution.sln` 文件以包含 `BicycleConsoleApp` 项目。您的命令行项目已准备好使用。
- en: Creating a library project
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建库项目
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目用于存放可重用的代码，这些代码旨在在项目之间访问。在本书的第 3-5 章*中，我使用库来存储常见的类，例如那些模拟我们在这些章节中构建的自行车类的基本部分的类。在现实世界中，您通常将业务逻辑放在库中。当您这样做时，您可以在
    Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。
- en: 'To create a library project in your solution folder, type the following command
    into your Terminal window:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 要在解决方案文件夹中创建一个库项目，请在您的终端窗口中输入以下命令：
- en: '[PRE40]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As before, the command creates a new project within the current solution. The
    `-o` switch tells the command what to name the output, which, in this case, is
    the name of the library project. Having created the library project, you need
    to add the project to your solution using this command:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，该命令在当前解决方案中创建一个新的项目。`-o`开关告诉命令输出什么名称，在这种情况下，是库项目的名称。创建了库项目后，你需要使用以下命令将项目添加到你的解决方案中：
- en: '[PRE41]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Use the `dir` command to confirm that your folder structure looks like mine
    in *Figure A1.29*:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dir`命令确认你的文件夹结构看起来像图 A1.29 中的我的结构：
- en: '![Figure A1.29: The project structure after creating the solution, the console
    app, and the library project. ](img/B18605_Figure_A1.25.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.29：创建了解决方案、控制台应用程序和库项目后的项目结构。](img/B18605_Figure_A1.25.jpg)'
- en: 'Figure A1.29: The project structure after creating the solution, the console
    app, and the library project.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.29：创建了解决方案、控制台应用程序和库项目后的项目结构。
- en: Now that you have the library project, you need to set up a reference between
    the console app and the library project.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了库项目，你需要设置控制台应用程序和库项目之间的引用。
- en: Linking the library to the console project
  id: totrans-747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将库链接到控制台项目
- en: 'To link the console project to the library project, type in this command:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 要将控制台项目链接到库项目，请输入以下命令：
- en: '[PRE42]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The library is linked to the console app project. We’ve spent a lot of time
    in the Terminal window. It’s time to start working in VS Code.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 库已链接到控制台应用程序项目。我们在终端窗口中花费了很多时间。现在是时候开始在 VS Code 中工作了。
- en: Launching VS Code and adding the C# extension
  id: totrans-751
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动 VS Code 并添加 C# 扩展
- en: 'Adding a class or an interface is easy in VS Code. You can launch VS Code from
    the Terminal window we’ve been using by typing in the following:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中添加类或接口很容易。你可以通过在终端窗口中输入以下内容来启动 VS Code，我们一直在使用这个窗口：
- en: '[PRE43]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You read it correctly: type in `code`, add a space and a period, and then press
    *Enter*. This command launches VS Code with the solution folder loaded. You’ll
    be greeted by your usual security warning, as shown in *Figure A1.30*:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 你读得对：输入`code`，然后输入一个空格和一个句号，然后按*Enter*。这个命令会启动 VS Code 并加载解决方案文件夹。你会看到你通常的安全警告，如图
    A1.30 所示：
- en: '![Figure A1.30: Do you trust the files you just made? ](img/B18605_Figure_A1.26.jpg)'
  id: totrans-755
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.30：你信任你刚刚创建的文件吗？](img/B18605_Figure_A1.26.jpg)'
- en: 'Figure A1.30: Do you trust the files you just made?'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.30：你信任你刚刚创建的文件吗？
- en: 'Assuming you trust your own work, click on **Yes**. If you don’t, briefly close
    this book and ponder deeply on this. Consider whether it’s better to live in a
    beautiful boring secure world where no harm will ever come to you; a world filled
    with beautiful flowers whose aroma reminds you of only the best moments of your
    life. Or would you rather live in a world filled with high adventure and the possibility
    of total ruin? Pirate ships are safe hiding in port. But they are not meant to
    stay there! This is your moment! Go for it! Click on the **Yes, I trust the authors**
    button! I promise that if you do, you’ll turn a corner in your life. Grow a spine
    already and click on the button! Side note: my attorney wants me to remind you
    the author is not responsible for malware, computer damage, damage to your reputation,
    or pirate attacks resulting from clicking on this button.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你信任自己的工作，点击**是**。如果你不信任，请简要关闭这本书，深入思考。考虑你是否宁愿生活在一个美丽而无聊的安全世界，那里永远不会对你造成伤害；一个充满美丽花朵的世界，它们的香气只会让你想起生活中最好的时刻。或者你更愿意生活在一个充满高风险和彻底毁灭可能性的世界？海盗船在港口里是安全的藏身之处。但它们不是用来在那里停留的！这是你的时刻！去做吧！点击**是的，我信任作者**按钮！我保证，如果你这样做，你将在生活中转一个弯。已经长出脊椎了，点击按钮吧！顺便说一句：我的律师希望我提醒你，作者不对恶意软件、计算机损坏、声誉损害或点击此按钮导致的海盗袭击负责。
- en: With your personal issues resolved, if you had them, let’s continue.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了个人问题（如果你有的话）后，让我们继续。
- en: 'I have mentioned that VS Code isn’t considered a full-fledged IDE. It is meant
    as a general-purpose coding tool and doesn’t assume anything about how you will
    use it. As such, VS Code doesn’t come with C# support baked in. Naturally, Microsoft
    has a plugin to help you with C#. You’ll probably be prompted to install the plugin
    as soon as the project opens. In case you aren’t, you can install it by following
    the steps shown in *Figure A1.30*:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，VS Code 并不被视为一个完整的 IDE。它是一个通用编码工具，不假设你将如何使用它。因此，VS Code 并没有内置 C# 支持。自然地，Microsoft
    有一个插件可以帮助你处理 C#。项目打开时，你可能会被提示安装此插件。如果你没有，你可以按照图 A1.30 中显示的步骤进行安装：
- en: '![Figure A1.30: Microsoft makes a free extension for VS Code that makes working
    with C# more enjoyable. ](img/B18605_Figure_A1.27.jpg)'
  id: totrans-760
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.30：Microsoft为VS Code提供了一个免费的扩展，使使用C#更加愉快。](img/B18605_Figure_A1.27.jpg)'
- en: 'Figure A1.30: Microsoft makes a free extension for VS Code that makes working
    with C# more enjoyable.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.30：Microsoft为VS Code提供了一个免费的扩展，使使用C#更加愉快。
- en: 'First, click on the **Extensions** button in the menu on the left-hand side
    of the interface (1). Then, search for this extension in the search bar (2):'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，单击界面左侧菜单上的**扩展**按钮（1）。然后，在搜索栏中搜索此扩展（2）：
- en: '[PRE44]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will narrow the list to a single extension. Click on it, and then click
    on the install button. VS Code is now fully aware of the C# language and the structure
    of your project.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使列表缩小到单个扩展。单击它，然后单击安装按钮。现在VS Code完全了解C#语言和你的项目结构。
- en: Adding a class or interface
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加类或接口
- en: 'Right-click on the `BicycleConsoleApp` folder in the explorer view and click
    on **New File**, as shown in *Figure A1.31*:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源管理器视图中右键单击“BicycleConsoleApp”文件夹，然后单击**新建文件**，如*图A1.31*所示：
- en: '![Figure A1.31: Right-click on the explorer area, and click on New File to
    create a new file. ](img/B18605_Figure_A1.28.jpg)'
  id: totrans-767
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.31：在资源管理器区域右键单击，然后单击“新建文件”以创建新文件。](img/B18605_Figure_A1.28.jpg)'
- en: 'Figure A1.31: Right-click on the explorer area, and click on New File to create
    a new file.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.31：在资源管理器区域右键单击，然后单击“新建文件”以创建新文件。
- en: Once you click on `.cs` extension. For example, I’m calling my file `Class1.cs`.
    If you’re creating an interface, it is standard practice to begin the filename
    with a capital I (as in “Interface”).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了`.cs`扩展。例如，我把我文件命名为`Class1.cs`。如果你正在创建一个接口，通常的做法是将文件名以大写I开头（例如，“Interface”）。
- en: Adding code to the BicycleLibrary project
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向BicycleLibrary项目添加代码
- en: Let’s add a method to the `BicycleLibrary` project so that we can verify it
    is linked and working correctly.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在“BicycleLibrary”项目中添加一个方法，以便我们可以验证它是否已链接并正确工作。
- en: 'Find the `Class1.cs` file in the `BicycleLibrary` project. This file was generated
    for you when you created the project. Click on the file, and it will open in the
    editor. Add the following code:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在“BicycleLibrary”项目中找到“Class1.cs”文件。当你创建项目时，该文件为你生成。单击文件，它将在编辑器中打开。添加以下代码：
- en: '[PRE45]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Be sure to save the file! Compare your project with mine, as shown in *Figure
    A1.32*:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要保存文件！将你的项目与我的项目进行比较，如*图A1.32*所示：
- en: '![Figure S1.32: The library code has been added to Class1.cs in the BicycleLibrary
    project. ](img/B18605_Figure_A1.29.jpg)'
  id: totrans-775
  prefs: []
  type: TYPE_IMG
  zh: '![图S1.32：库代码已添加到BicycleLibrary项目中的Class1.cs文件。](img/B18605_Figure_A1.29.jpg)'
- en: 'Figure S1.32: The library code has been added to Class1.cs in the BicycleLibrary
    project.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 图S1.32：库代码已添加到BicycleLibrary项目中的Class1.cs文件。
- en: 'Next, let’s switch to the `Program.cs` file in the `BicycleConsoleApp` project.
    Replace the line `dotnet` generated with the following:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们切换到“BicycleConsoleApp”项目中的“Program.cs”文件。替换掉由`dotnet`生成的行，使用以下内容：
- en: '[PRE46]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you type, IntelliSense will show you the library method we added to the
    `BicycleLibrary` project as if it was within the `BicycleConsoleApp` project.
    Check your work against *Figure A1.33*:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入时，IntelliSense会显示我们添加到“BicycleLibrary”项目的库方法，就像它在“BicycleConsoleApp”项目中一样。将你的工作与*图A1.33*进行核对：
- en: '![Figure A1.33: The updated Program.cs file with our test code. ](img/B18605_Figure_A1.30.jpg)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.33：带有我们的测试代码的更新后的Program.cs文件。](img/B18605_Figure_A1.30.jpg)'
- en: 'Figure A1.33: The updated Program.cs file with our test code.'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.33：带有我们的测试代码的更新后的Program.cs文件。
- en: 'Our mission has been accomplished! There is just one thing left to do: build
    the project.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使命已经完成！只剩下一件事要做：构建项目。
- en: Building and running the console project
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和运行控制台项目
- en: We could switch back to our Terminal window, but VS Code has an integrated Terminal
    window. Using it is more convenient than constantly switching windows.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以切换回我们的终端窗口，但VS Code有一个集成的终端窗口。使用它比不断切换窗口更方便。
- en: 'To activate it, use the keyboard shortcut *Ctrl* + *`* (control + backtick).
    Additionally, you can click on **View** and then **Terminal** from the main menu,
    as shown in *Figure A1.34*:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活它，使用键盘快捷键*Ctrl* + *`*（控制+反引号）。此外，你可以从主菜单中选择**视图**然后**终端**，如*图A1.34*所示：
- en: '![Figure A1.34: You can open the integrated Terminal window in VS Code using
    this menu item, or Ctrl + ` as a keyboard shortcut. ](img/B18605_Figure_A1.31.jpg)'
  id: totrans-786
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.34：您可以使用此菜单项或Ctrl + `作为键盘快捷键在VS Code中打开集成的终端窗口。](img/B18605_Figure_A1.31.jpg)'
- en: 'Figure A1.34: You can open the integrated Terminal window in VS Code using
    this menu item, or Ctrl + ` as a keyboard shortcut.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.34：您可以使用此菜单项在VS Code中打开集成终端窗口，或者使用Ctrl + `作为键盘快捷键。
- en: 'Running the project will build the project and then execute the `BicycleConsoleApp`
    project’s executable file, which consists of the code in the `Program.cs` file.
    To run the program in the Terminal window, enter this command:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目将会构建项目，然后执行`BicycleConsoleApp`项目的可执行文件，该文件由`Program.cs`文件中的代码组成。要在终端窗口中运行程序，请输入以下命令：
- en: '[PRE47]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You’ll see the program being built, and the command-line project will run.
    You should see the “Hello from the Bicycle Library!” message in the Terminal window
    just like you see it in *Figure A1.35*:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到程序正在构建，命令行项目将会运行。您应该在终端窗口中看到“来自自行车库的问候！”消息，就像您在*图A1.35*中看到的那样：
- en: '![Figure A1.35: This is the result of our test run. ](img/B18605_Figure_A1.32.jpg)'
  id: totrans-791
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.35：这是我们测试运行的结果。](img/B18605_Figure_A1.32.jpg)'
- en: 'Figure A1.35: This is the result of our test run.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.35：这是我们测试运行的结果。
- en: This concludes our brief tour of VS Code. If you’re interested in a video walk-through
    that coaches you through setting up a VS Code development environment in Windows,
    you’ll find links for this at [https://csharppatterns.dev](https://csharppatterns.dev).
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对VS Code的简要游览。如果您对在Windows中设置VS Code开发环境感兴趣，并希望有一个视频教程来指导您，您可以在[https://csharppatterns.dev](https://csharppatterns.dev)找到相关链接。
- en: Rider
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rider
- en: JetBrains Rider is the most recent addition to the world of C# IDEs. JetBrains
    is known for making amazing IDEs for Java (*IntelliJ Idea*), Python (*Pycharm*),
    PHP (*PHPStorm*), and JavaScript (*WebStorm*) among others. They also built Google’s
    IDE for Android Development, *Android Studio*. In addition to IDEs, the company
    has a very popular add-in product for Visual Studio called *Resharper*. The tools
    in *Resharper* give you many similar features you’ll find in *Visual Studio Enterprise*
    at a fraction of the cost.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains Rider是C# IDE世界中的最新成员。JetBrains以其为Java（*IntelliJ Idea*）、Python（*Pycharm*）、PHP（*PHPStorm*）和JavaScript（*WebStorm*）等语言制作出色的IDE而闻名。他们还构建了谷歌的Android开发IDE，*Android
    Studio*。除了IDE之外，该公司还拥有一个非常受欢迎的Visual Studio插件产品，名为*Resharper*。*Resharper*中的工具为您提供了许多在*Visual
    Studio Enterprise*中找到的类似功能，但成本却低得多。
- en: I used Rider to create this book, mainly because of the code formatting and
    refactoring tools available in the program. Also, I use several of their other
    IDEs regularly, and I have my keyboard shortcuts configured to be common in every
    language IDE I use. This is purely a personal preference. I knew I could produce
    this book more quickly with Rider.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用Rider创建这本书，主要是因为程序中提供的代码格式化和重构工具。此外，我经常使用他们的一些其他IDE，并且我已经将键盘快捷键配置为在每种语言IDE中都是通用的。这纯粹是个人偏好。我知道我可以使用Rider更快地完成这本书。
- en: Rider is not a free product. There is a lower-cost version available for solo
    developers, and the same product is sold at a higher rate for use in companies.
    Check out [https://www.jetbrains.com/rider](https://www.jetbrains.com/rider) for
    more information if you’re interested in using this tool.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: Rider不是一个免费产品。对于独立开发者有一个较低成本的版本，而在公司使用时，同样的产品会以更高的价格出售。如果您对使用这个工具感兴趣，请查看[https://www.jetbrains.com/rider](https://www.jetbrains.com/rider)获取更多信息。
- en: Since I used Rider to create the book, I think it would be strange if I didn’t
    at least show you around. Let’s do this exercise one more time using Rider.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用Rider创建了这本书，如果我不至少带您参观一下，那就显得有些奇怪了。让我们再次使用Rider来做这个练习。
- en: Creating a command-line project
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命令行项目
- en: 'When you launch Rider, you are greeted with the **Welcome** screen dialog.
    Click on the **New Project** button in the upper-right portion of the dialog box,
    as shown in *Figure A1.36*:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动Rider时，您将看到一个**欢迎**屏幕对话框。在对话框右上角单击**新项目**按钮，如图*图A1.36*所示：
- en: '![Figure A1.36: The welcoming screen in Rider with the New Project button highlighted.
    ](img/B18605_Figure_A1.33.jpg)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.36：Rider中的欢迎屏幕，新项目按钮被突出显示。](img/B18605_Figure_A1.33.jpg)'
- en: 'Figure A1.36: The welcoming screen in Rider with the New Project button highlighted.'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.36：Rider中的欢迎屏幕，新项目按钮被突出显示。
- en: 'Clicking on the button gives you another dialog, as shown in *Figure A1.37*:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 单击按钮会弹出一个新的对话框，如图*图A1.37*所示：
- en: '![Figure A1.37: Project creation in Rider. ](img/B18605_Figure_A1.34.jpg)'
  id: totrans-804
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.37：Rider中的项目创建。](img/B18605_Figure_A1.34.jpg)'
- en: 'Figure A1.37: Project creation in Rider.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.37：Rider中的项目创建。
- en: With Rider, everything is on one screen. Find the `BicycleSolution` and `ProjectName`
    to `BicycleConsoleApp`. Click on the **Create** button and your project will be
    generated. The full IDE will appear, and you’ll find your project hierarchy in
    the explorer panel on the left-hand side of the IDE window.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rider，所有内容都在一个屏幕上。找到 `BicycleSolution` 和 `ProjectName` 为 `BicycleConsoleApp`。点击**创建**按钮，您的项目将被生成。完整的
    IDE 将会显示，您将在 IDE 窗口的左侧的探索器面板中找到您的项目层次结构。
- en: Adding a class or interface
  id: totrans-807
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加类或接口
- en: Adding a class is the same as it is in the other two IDEs we’ve talked about
    so far. Right-click on the `BicycleSolution` project. A context menu appears,
    as shown in *Figure A1.38:*
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 添加类与我们在前面提到的其他两个 IDE 中的操作相同。右键单击 `BicycleSolution` 项目。出现一个上下文菜单，如图 A1.38 所示：
- en: '![Figure A1.38: The ability to add a class or interface to your project can
    be found in the context menu when you right-click on the project. ](img/B18605_Figure_A1.35.jpg)'
  id: totrans-809
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.38：将类或接口添加到项目中的功能可以在您右键单击项目时在上下文菜单中找到。](img/B18605_Figure_A1.35.jpg)'
- en: 'Figure A1.38: The ability to add a class or interface to your project can be
    found in the context menu when you right-click on the project.'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.38：将类或接口添加到项目中的功能可以在您右键单击项目时在上下文菜单中找到。
- en: Hover over the **Add** menu item, and then find **Class/Interface** in the sub-menu.
    Click on it. You will see a small dialog asking you to name the class or interface.
    There are a few more possibilities evident in the list, but this book is only
    concerned with classes and interfaces. Choose the **Class** option and name your
    class whatever you would like. As soon as you press *Enter*, you’ll see the class
    file added to your project.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在**添加**菜单项上，然后在子菜单中找到**类/接口**。点击它。您将看到一个小的对话框，要求您命名类或接口。列表中还有一些其他可能性，但本书只关注类和接口。选择**类**选项，并为您想要的类命名。一旦按下*Enter*，您将看到类文件已添加到您的项目中。
- en: When you need an interface, follow the same procedure, but instead of **Class**,
    select **Interface**. Don’t forget that in C#, the name convention for interfaces
    stipulates naming the interface starting with the letter I (as in “Interface”).
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要一个接口时，遵循相同的程序，但不要选择**类**，而是选择**接口**。不要忘记，在 C# 中，接口的命名约定规定以字母 I（如“Interface”）开头命名接口。
- en: Next, we’ll look at adding a library project to our solution so that we can
    maximize code reuse between projects.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何将库项目添加到我们的解决方案中，以便在项目之间最大化代码重用。
- en: Creating a library project
  id: totrans-814
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建库项目
- en: Library projects are used to house reusable code designed to be accessible between
    projects. In *Chapters 3–5* of this book, I use a library for common classes like
    those that model the basic parts of the bicycle classes we’re building in those
    chapters. In the real world, you generally put your business logic in a library.
    When you do this, you can leverage that logic in a web application, a mobile application,
    and a desktop application without repeating your code in three places.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 库项目用于存放可重用的代码，这些代码旨在在项目之间可访问。在本书的第 3-5 章，我使用库来存放常见的类，例如那些模拟我们在这些章节中构建的自行车基本部分的类。在现实世界中，您通常将业务逻辑放在库中。当您这样做时，您可以在
    Web 应用程序、移动应用程序和桌面应用程序中利用该逻辑，而无需在三个地方重复代码。
- en: 'Right-click on the `BicycleSolution` in the explorer menu. Hover over the **Add**
    option and select **New Project...**. You can see this in *Figure A1.39*:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索器菜单中右键单击 `BicycleSolution`。将鼠标悬停在**添加**选项上，并选择**新建项目...**。您可以在图 A1.39 中看到这一点：
- en: '![Figure A1.39: Adding a project to the solution in Rider is done by right-clicking
    on the solution, then hovering over Add, and then clicking on New Project. ](img/B18605_Figure_A1.36.jpg)'
  id: totrans-817
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.39：在 Rider 中将项目添加到解决方案的操作是通过右键单击解决方案，然后悬停在**添加**上，然后点击**新建项目**。](img/B18605_Figure_A1.36.jpg)'
- en: 'Figure A1.39: Adding a project to the solution in Rider is done by right-clicking
    on the solution, then hovering over Add, and then clicking on New Project.'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.39：在 Rider 中将项目添加到解决方案的操作是通过右键单击解决方案，然后悬停在**添加**上，然后点击**新建项目**。
- en: 'You get the same project dialog we started with. Locate the `BicycleLibrary`.
    Your project should match mine, as shown in *Figure A1.40*:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到我们最初开始的相同项目对话框。定位到 `BicycleLibrary`。您的项目应该与我的项目一致，如图 A1.40 所示：
- en: '![Figure A1.40: Set up your new library project as shown. ](img/B18605_Figure_A1.37.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![图 A1.40：按照所示设置您的新的库项目](img/B18605_Figure_A1.37.jpg)'
- en: 'Figure A1.40: Set up your new library project as shown.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A1.40：按照所示设置您的新的库项目。
- en: 'Click on the **Create** button, and you’ll find a new project added to the
    solution. Your explorer pane should look something like *Figure A1.41*:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**创建**按钮，你会在解决方案中找到一个新项目。你的资源管理器窗格应该看起来像*图A1.41*：
- en: '![Figure A1.41: The explorer pane shows both projects in our solution. ](img/B18605_Figure_A1.38.jpg)'
  id: totrans-823
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.41：资源管理器窗格显示了解决方案中的两个项目。](img/B18605_Figure_A1.38.jpg)'
- en: 'Figure A1.41: The explorer pane shows both projects in our solution.'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.41：资源管理器窗格显示了解决方案中的两个项目。
- en: Before we can use the library in our console app project, we need to link the
    two projects with a reference.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在控制台应用程序项目中使用库之前，我们需要通过引用将两个项目链接起来。
- en: Linking the library project to the console project
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将库项目链接到控制台项目
- en: 'In the explorer pane, locate the `BicycleConsoleApp` project and right-click
    on the `Dependencies` item in the project hierarchy. A context menu appears, as
    shown in *Figure A1.42*:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源管理器窗格中，定位到`BicycleConsoleApp`项目，并在项目层次结构中右键单击`Dependencies`项。会出现一个上下文菜单，如图A1.42所示：
- en: '![Figure A1.42: The context menu is displayed when you  right-click on the
    Dependencies item in the explorer pane. ](img/B18605_Figure_A1.39.jpg)'
  id: totrans-828
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.42：在资源管理器窗格中右键单击依赖项时显示上下文菜单。](img/B18605_Figure_A1.39.jpg)'
- en: 'Figure A1.42: The context menu is displayed when you right-click on the Dependencies
    item in the explorer pane.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.42：在资源管理器窗格中右键单击依赖项时显示上下文菜单。
- en: 'Click on **Add Reference**. A dialog appears like the one in *Figure A1.43*:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加引用**。会出现一个对话框，如图A1.43所示：
- en: '![Figure A1.43: The Add Reference dialog in Rider. ](img/B18605_Figure_A1.40.jpg)'
  id: totrans-831
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.43：Rider中的添加引用对话框。](img/B18605_Figure_A1.40.jpg)'
- en: 'Figure A1.43: The Add Reference dialog in Rider.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.43：Rider中的添加引用对话框。
- en: You should see the library project listed. Check the box next to the library,
    and then click on **Add**. You can now reference the library project from your
    console app project. Let’s try it out.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到库项目被列出。勾选库旁边的复选框，然后点击**添加**。你现在可以从控制台应用程序项目中引用库项目。让我们试试看。
- en: Testing the linked library
  id: totrans-834
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试链接库
- en: 'Open the `Class1.cs` file in the `BicycleLibrary` project. Add this code:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BicycleLibrary`项目中打开`Class1.cs`文件。添加以下代码：
- en: '[PRE48]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: That’s the third time I’ve typed in the same code. Thank goodness the English
    language doesn’t require authors to be DRY.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我第三次输入相同的代码。谢天谢地，英语语言不需要作者遵循DRY原则。
- en: 'Next, open the `Program1.cs` file in the `BicycleConsoleApp` project. Change
    the code in that file to this:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`BicycleConsoleApp`项目中打开`Program1.cs`文件。将该文件中的代码更改为以下内容：
- en: '[PRE49]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you type the code, you should see the code hints showing you that you have
    access to the library. Once the code has been entered, we’re ready to run a test.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入代码时，你应该会看到代码提示显示你能够访问该库。一旦输入了代码，我们就准备好运行测试。
- en: Building and running the console project
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建和运行控制台项目
- en: As with Visual Studio, you’re looking for a big green arrow that indicates the
    **Run** button in the toolbar. You can see this button highlighted, alas, not
    in color, in *Figure A1.44*.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 与Visual Studio一样，你正在寻找一个表示工具栏中**运行**按钮的大绿箭头。你可以在*图A1.44*中看到这个按钮被突出显示，遗憾的是，不是以颜色显示。
- en: 'When you click on the **Run** button, your project builds and runs with an
    attached debugger just as it does in Visual Studio. Unlike Visual Studio, your
    program runs within Rider’s integrated Terminal just like it did in VS Code. You
    can see the result of my run in *Figure A1.44*:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**运行**按钮时，你的项目会像在Visual Studio中一样构建并运行，并附加调试器。与Visual Studio不同，你的程序在Rider的集成终端中运行，就像在VS
    Code中一样。你可以在*图A1.44*中看到我运行的结果：
- en: '![Figure A1.44: The completed run of our test program in Rider; the Terminal
    window has been pointed out. ](img/B18605_Figure_A1.41.jpg)'
  id: totrans-844
  prefs: []
  type: TYPE_IMG
  zh: '![图A1.44：在Rider中完成测试程序的运行；已指出终端窗口。](img/B18605_Figure_A1.41.jpg)'
- en: 'Figure A1.44: The completed run of our test program in Rider; the Terminal
    window has been pointed out.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 图A1.44：在Rider中完成测试程序的运行；已指出终端窗口。
- en: This concludes our brief tour of *Rider*. If you’re interested in a video walk-through
    that coaches you through setting up a *Rider* development environment in Windows,
    you’ll find links at [https://csharppatterns.dev](https://csharppatterns.dev).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对*Rider*的简要游览。如果你对在Windows中设置*Rider*开发环境的视频教程感兴趣，你可以在[https://csharppatterns.dev](https://csharppatterns.dev)找到链接。
- en: Summary
  id: totrans-847
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This appendix was meant to be a short summary of working with C#. I almost didn’t
    include it in the book. There are many other places you can get training and orientation
    for the language. I felt, though, having taught C# for decades that I might be
    able to more concisely, yet thoroughly, get you up to speed if you’re coming from
    a different language, have limited experience with C#, or if it’s been a while
    and you’re a little rusty.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这个附录原本打算是一个关于使用C#的简要总结。我几乎没把它包括在书中。你可以在很多其他地方获得关于该语言的培训和指导。然而，鉴于我几十年来一直在教授C#，我觉得如果是从其他语言转过来的，或者对C#的经验有限，或者有一段时间没有接触了，我可能能够更简洁、更全面地帮助你入门。
- en: 'Along the way, we learned the following:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们学习了以下内容：
- en: C# is a standardized general-purpose, strictly OOP language.
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#是一种标准化的通用、严格面向对象的语言。
- en: C# uses a strong, static type system.
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#使用强、静态类型系统。
- en: C# is designed with features designed to limit the most common problems found
    in C and C++ development such as bounds checking, effortless memory allocation,
    and automated garbage collection.
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的设计旨在通过一些特性来限制在C和C++开发中最常见的错误，例如边界检查、轻松的内存分配和自动垃圾回收。
- en: C# supports many different kinds of numeric types, including signed and unsigned
    variants.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#支持许多不同的数值类型，包括有符号和无符号变体。
- en: How to make auto-implemented properties and methods and work with encapsulation.
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建自动实现的属性和方法，以及如何处理封装。
- en: How to use the basic building blocks of OOP in C#, including inheritance and
    working with interfaces.
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在C#中使用面向对象的基石，包括继承和与接口一起工作。
- en: 'At the end of all that we were treated to a basic tutorial on the three most
    popular IDE choices for C#: Visual Studio, VS Code, and Rider. I called this appendix
    concise. I wouldn’t call it short, but consider the size of most C# books that
    only orient you in Visual Studio, and I think you’ll agree this is a bargain.
    If you have found yourself wanting more, head over to [https://csharppatterns.dev](https://csharppatterns.dev)
    where I have links to additional resources.'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，我们得到了一个关于C#最流行的三个IDE选择的基本教程：Visual Studio、VS Code和Rider。我称这个附录为简洁。我不会说它很短，但考虑到大多数只介绍Visual
    Studio的C#书籍的大小，我认为这是一个物有所值的交易。如果你还想了解更多，请访问[https://csharppatterns.dev](https://csharppatterns.dev)，那里我提供了额外的资源链接。
- en: Further reading
  id: totrans-857
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C# Object-Oriented Programming for Beginners in C# and .NET* by Praveenkumar
    Bouna.'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C#面向对象编程入门：C#和.NET》*，作者Praveenkumar Bouna。'
- en: '*Visual Studio Code for C# Developers* by Praveenkumar Bouna.'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C#开发者用Visual Studio Code》*，作者Praveenkumar Bouna。'
- en: '*Hands-On Visual Studio 2022* by Hector Uriel Perez Rojas and Miguel Angel
    Teheran Garcia.'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《动手实践Visual Studio 2022》*，作者Hector Uriel Perez Rojas和Miguel Angel Teheran
    Garcia。'
- en: '[https://csharppatterns.dev](https://csharppatterns.dev) has links to additional
    resources.'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://csharppatterns.dev](https://csharppatterns.dev) 提供了额外的资源链接。'
- en: 'Appendix 2: A Primer on the Unified Modeling Language (UML)'
  id: totrans-862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录2：统一建模语言（UML）入门
- en: You don’t have to look hard to realize that designing software is a lot like
    designing anything else. In [*Chapter 1*](B18605_01.xhtml#_idTextAnchor016), *There’s
    a Big Ball of Mud on Your Plate of Spaghetti*, we talked about the underpinning
    of software patterns coming from a pioneer in the field of architecture – not
    software architecture, but the traditions, engineering, and design practices involved
    in the architecture of buildings and cities. In 1977, Christopher Alexander documented
    a pattern language designed to form the basis for the best practices for building
    towns. His book described 253 patterns that were presented as the paragon of architectural
    design. The book broke everything down into objects.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要仔细思考就能意识到，设计软件与设计其他事物有很多相似之处。在[*第一章*](B18605_01.xhtml#_idTextAnchor016)《你的意大利面盘上有一个大泥球》中，我们讨论了来自建筑领域先驱的软件模式的底层，不是软件架构，而是涉及建筑和城市架构的传统、工程和设计实践。1977年，Christopher
    Alexander记录了一种旨在形成城镇最佳实践基础的模式语言。他的书描述了253个模式，这些模式被视为建筑设计的典范。这本书把所有东西都分解成了对象。
- en: '**Object-Oriented Analysis and Design** (**OOAD**), a practice that is adjunctive
    to **Object-Oriented Programming** (**OOP**), involves the design of an object
    structure separate from the exercise of writing code. This is usually the job
    of a software architect or a senior developer. Software architects are similar
    to architects of buildings: they design the structure of an application. This
    can be done before the implementation team, which is the team that is going to
    build what the architect designs, picks the programming language for a project.'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象分析设计**（**OOAD**），作为一种与 **面向对象编程**（**OOP**）相关的实践，涉及独立于编写代码的练习来设计对象结构。这通常是由软件架构师或高级开发者负责的工作。软件架构师类似于建筑的建筑师：他们设计应用程序的结构。这可以在实施团队选择项目编程语言之前完成，实施团队是负责构建建筑师设计的内容的团队。'
- en: OOAD makes use of a set of documentation conventions codified as the **Unified
    Modeling Language** (**UML**). It sounds like a programming language, but it isn’t.
    Instead, it is a standard for creating diagrams that explains the structure and
    relationships between components in a software system.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: OOAD 利用一组编码为 **统一建模语言**（**UML**）的文档规范。它听起来像是一种编程语言，但它不是。相反，它是一个创建图例的标准，用于解释软件系统中组件的结构和关系。
- en: Think of it this way. If you are a musical composer, you can write your notes
    in a musical score. You can do this without ever touching an instrument. If you
    are skillful in composition, you can write entire orchestral works on paper using
    sheet music notation. You can then hand your sheet music to an orchestra and a
    conductor, and assuming the orchestra comprises competent musicians, they should
    be able to play your music. Architects are like composers. Programmers are musicians,
    and the team lead or lead developer is the conductor.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想。如果你是一个音乐作曲家，你可以在乐谱上写下你的音符。你可以在不接触任何乐器的情况下做到这一点。如果你在作曲方面很在行，你可以在纸上使用乐谱符号创作完整的管弦乐作品。然后你可以把乐谱交给一个乐团和指挥，假设乐团由合格的乐手组成，他们应该能够演奏你的音乐。建筑师就像作曲家一样。程序员就像音乐家，而团队领导或主要开发者就像指挥。
- en: Throughout this book, UML class diagrams are used to convey the structure of
    the pattern code to be implemented in our real-world projects. If you’ve never
    worked with the UML before, you’re going to need a short primer. This appendix
    is designed to be that primer. It isn’t a substitute for a graduate-level OOAD
    course, or even for reading a whole book on UML. I’m just going to cover the diagram
    conventions for the one type of diagram we use throughout the book so that you
    can understand the diagrams, and how they are converted to code.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，UML 类图被用来传达将要在我们现实世界项目中实现的设计模式代码的结构。如果你之前从未使用过 UML，你可能需要一个简短的入门指南。本附录旨在成为那个指南。它不能替代研究生级别的
    OOAD 课程，甚至也不能替代阅读一本关于 UML 的整本书。我只会涵盖我们全书所使用的图例规范，以便你能够理解这些图例，以及它们是如何转换为代码的。
- en: Again, UML isn’t a coding language; it’s a specification for diagramming your
    code. There are 14 types of diagram in the UML 2.5 specification. We only need
    one; the most common among the different diagrams is the *class diagram*.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，UML 不是一个编程语言；它是一个用于绘制代码规范的规范。UML 2.5 规范中有 14 种类型的图。我们只需要一种；在所有不同的图例中，最常见的是
    *类图*。
- en: Technical requirements
  id: totrans-869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'There are many tools for drawing UML diagrams, and although I have presented
    many such diagrams, I’ve taken the tool used to make them for granted. In the
    real world, this exercise often happens on a whiteboard. A whiteboard is fine
    for ephemeral drawings that get erased later. For this book, my diagrams need
    to be a bit more permanent, so here’s what I’m using:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以绘制 UML 图，尽管我已经展示了众多这样的图，但我对制作它们的工具却视而不见。在现实世界中，这种练习通常是在白板上进行的。白板适合那些后来会被擦除的临时绘图。对于这本书，我的图例需要更加持久，所以我使用的是：
- en: A computer running the **Windows** operating system. I’m using **Windows 10**.
    Honestly, this doesn’t matter, since diagramming tools are plentiful for all operating
    systems, and there are many that will work in your browser.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 **Windows** 操作系统的计算机。我使用的是 **Windows 10**。说实话，这并不重要，因为所有操作系统中都有大量的绘图工具，而且有很多可以在你的浏览器中工作。
- en: A diagramming tool. I’m using **Microsoft Visio**.
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个绘图工具。我使用的是 **Microsoft Visio**。
- en: 'There are quite a few UML tools on the market. Here is a short list of tools
    I’ve used over the years:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有很多 UML 工具。以下是我多年来使用过的一些工具的简要列表：
- en: '**Microsoft Visio**'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Visio**'
- en: '**StarUML**'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StarUML**'
- en: '**Altova UModel**'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Altova UModel**'
- en: '**Dia**'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dia**'
- en: '**Umbrello**'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Umbrello**'
- en: '**Umlet**'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Umlet**'
- en: '**Omnigraffle** (**Mac** only)'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Omnigraffle**（仅限 **Mac**）'
- en: There are many more on the web. I tend to prefer apps that run on my computer
    versus browser-based solutions.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 网上还有很多。我倾向于使用运行在我电脑上的应用程序，而不是基于浏览器的解决方案。
- en: The structure of a class diagram
  id: totrans-882
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类图的构成
- en: 'Class diagrams consist of several types of structures, and a set of connecting
    lines that express the relationship between the structures. The structures are
    as follows:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 类图由几种类型的结构和一组表示结构之间关系的连接线组成。结构如下：
- en: A class (obviously)
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类（显然）
- en: An interface
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: An enumeration
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Packages (expanded and collapsed)
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包（展开和折叠）
- en: 'Connecting lines between the structures show how those structures are related.
    The relationships we can express include the following:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 结构之间的连接线显示了这些结构是如何相关的。我们可以表达的关系包括以下内容：
- en: Inheritance
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Interface realization
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口实现
- en: Composition
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合
- en: Association
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联
- en: Dependency
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖
- en: Aggregation
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Directed association
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向关联
- en: The last possible element on a UML diagram are the notes. Notes are just what
    you think they are. Sometimes, an architect needs to add a little more information
    than what the standard UML allows. Notes let you do that. You shouldn’t use them
    to write an epistle. Short notes in implementation logic are what you see most
    commonly.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: UML 图上最后可能出现的元素是注释。注释就是你所想的那样。有时，架构师需要添加比标准 UML 允许的更多一点的信息。注释让你可以做到这一点。你不应该用它们来写一封信。在实现逻辑中，最常见的短注释。
- en: To understand the patterns in this book, you need to understand class diagrams.
    Every pattern in this book is expressed with at least one UML diagram. The most
    important patterns are covered with two diagrams each.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这本书中的模式，你需要理解类图。这本书中的每个模式至少用到一个 UML 图表达。最重要的模式每个都有两个图覆盖。
- en: Let’s take a look at the parts of a UML diagram. They aren’t that hard to decipher
    once you realize the meaning of all the diagram’s pieces. Let’s start with the
    structures.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 UML 图的各个部分。一旦你意识到所有图块的含义，它们就不难理解。让我们从结构开始。
- en: Classes
  id: totrans-899
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'A class diagram is a visual representation of an object’s class. Let’s say
    our program requires us to model a circle like the one in *Figure A2.1*:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 类图是对象类的视觉表示。假设我们的程序需要我们像 *图 A2.1* 中的那样建模一个圆：
- en: '![Figure A2.1: This is not a UML diagram of a circle.  ](img/B18605_Figure_A2.01.jpg)'
  id: totrans-901
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.1：这不是一个圆的 UML 图。](img/B18605_Figure_A2.01.jpg)'
- en: 'Figure A2.1: This is not a UML diagram of a circle.'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.1：这不是一个圆的 UML 图。
- en: If we want to model this in UML, the class diagram would look like *Figure A2.2*.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 UML 中建模这个，类图将看起来像 *图 A2.2*。
- en: '![Figure A2.2: This is an example of a UML diagram. The class name, Circle,
    is at the top, followed by a list of properties, a dividing line, and a list of
    methods. The + indicates that they’re all public.  ](img/B18605_Figure_A2.02.jpg)'
  id: totrans-904
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.2：这是一个 UML 图的例子。类名 Circle 在顶部，后面跟着属性列表、分隔线和方法列表。+ 表示它们都是公共的。](img/B18605_Figure_A2.02.jpg)'
- en: 'Figure A2.2: This is an example of a UML diagram. The class name, Circle, is
    at the top, followed by a list of properties, a dividing line, and a list of methods.
    The + indicates that they’re all public.'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.2：这是一个 UML 图的例子。类名 Circle 在顶部，后面跟着属性列表、分隔线和方法列表。+ 表示它们都是公共的。
- en: That’s not too difficult, right? It is a box split into three sections.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 那不是太难，对吧？它是一个分成三个部分的框。
- en: The top section contains the name of the class. The class is simply the codified
    version of what I put in my UML diagram. Understanding these details is central
    to the coverage in [*Chapter 3*](B18605_03.xhtml#_idTextAnchor063)*, Getting Creative
    with Creational Patterns,* of creation patterns. These are patterns that revolve
    around object creation.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分包含类的名称。类只是我在 UML 图中放入的编码版本。理解这些细节对于 [*第 3 章*](B18605_03.xhtml#_idTextAnchor063)
    中关于“用创造模式发挥创意”的覆盖至关重要。这些模式围绕着对象创建。
- en: The middle box in *Figure A2.2* contains a list of the properties that are members
    of the class. Note they do not have types. Some people put types in the diagram.
    I was taught not to because that is an implementation detail. The architect simply
    designs; they don’t constrain the builder any more than necessary. The programmer
    that implements the diagram picks the types. If it happens that you are the architect
    and the developer, feel free to specify the types if that is helpful.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A2.2* 中间的框包含了这个类成员的属性列表。注意它们没有类型。有些人会在图中添加类型。我被告知不要这样做，因为这只是一个实现细节。建筑师只是设计；他们不会比必要的更多地去约束建造者。实现这个图画的程序员选择类型。如果你既是建筑师又是开发者，如果你觉得这样有帮助，可以自由地指定类型。'
- en: Beneath the list of properties, we draw a line to separate the properties section
    from the next section. Visio made this a dashed line for my drawings. The dashed
    line has no significance. It can be solid or whatever line style that appeals
    to you.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性列表下方，我们画一条线来区分属性部分和下一部分。Visio在我的绘图中使用的是虚线。虚线没有意义。它可以是一条实线或任何你喜欢的线条样式。
- en: The bottom box in *Figure A2.2* is a list of methods. It doesn’t include details
    on how to implement the methods, or what they do – just the names, and any arguments.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A2.2* 底部的框是一个方法列表。它不包括实现方法的细节或它们的功能——只是名称和任何参数。'
- en: You might have noticed there are `+` signs in the diagrams. These refer to your
    access modifiers. As with types, some architects put them in and some don’t. Others
    put them in when it is vitally important – when the class just won’t work unless
    that detail is honored. I succumbed to the temptation to make a cute diagram to
    show you what the access modifiers look like in *Figure A2.3*.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到图中有一些 `+` 符号。这些指的是你的访问修饰符。与类型一样，有些建筑师会添加它们，而有些则不会。其他人会在至关重要的地方添加它们——当类如果不尊重这个细节就无法工作时。我屈服于诱惑，制作了一个可爱的图来展示访问修饰符在*图A2.3*
    中的样子。
- en: '![Figure A2.3: Access modifiers.  ](img/B18605_Figure_A2.03.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.3：访问修饰符。](img/B18605_Figure_A2.03.jpg)'
- en: 'Figure A2.3: Access modifiers.'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.3：访问修饰符。
- en: The plus sign (`internal`, but they are unique to C#, so UML won’t have a symbol
    for them. If you don’t understand these access modifiers, refer to [*Appendix
    1*](B18605_Appendix_1.xhtml#_idTextAnchor178).
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 加号（`内部`，但它们是C#特有的，所以UML不会有它们的符号。如果你不理解这些访问修饰符，请参阅[*附录1*](B18605_Appendix_1.xhtml#_idTextAnchor178)）。
- en: That’s it! UML class diagrams are very simple in nature. We’re not done yet
    though. UML diagrams can show different levels of detail. This really depends
    on your preferences and the audience for your diagrams. When I studied OOAD in
    graduate school, my instructor wanted me to put as few implementation details
    in the diagram as I could. This habit has stuck with me. I’ve seen other people
    diagram everything to the smallest detail. I’ve never been one for micromanaging,
    so I’m going to stick with leaving as much as possible up to the developer.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！UML类图在本质上非常简单。我们还没有完成。UML图可以显示不同级别的细节。这完全取决于你的偏好和你的图目的受众。当我研究生阶段的OOAD（面向对象分析与设计）时，我的教授希望我在图中尽可能少地包含实现细节。这个习惯一直伴随着我。我看到其他人把所有细节都绘制到最小。我从未是那种微观管理的人，所以我打算尽可能地把事情留给开发者。
- en: Abstract classes
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: Abstract classes are classes we aren’t allowed to instantiate directly. You
    can only instantiate subclasses of an abstract class. Diagramming them requires
    one tiny change to the diagram. Here’s an example in *Figure A2.4*.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是我们不允许直接实例化的类。你只能实例化抽象类的子类。绘制它们需要对图进行微小的修改。*图A2.4* 中有一个例子。
- en: '![Figure A2.4: When diagramming abstract classes, type the name of the class
    in italics.  ](img/B18605_Figure_A2.04.jpg)'
  id: totrans-918
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.4：当绘制抽象类时，用斜体字写出类的名称。](img/B18605_Figure_A2.04.jpg)'
- en: 'Figure A2.4: When diagramming abstract classes, type the name of the class
    in italics.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.4：当绘制抽象类时，用斜体字写出类的名称。
- en: Here, we can see that the `Shape` class is abstract and the `Circle` class is
    not. To specify a class as abstract, you need to type the name of the class in
    the top box in italics. Watch out for this! Sometimes, it can be hard to see,
    especially if your diagramming tool uses a cute font that makes italics difficult
    to spot.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`Shape`类是抽象的，而`Circle`类不是。要指定一个类为抽象类，你需要在顶部的框中用斜体字写出类的名称。注意这一点！有时，这可能会很难看到，特别是如果你的绘图工具使用了一种可爱的字体，使得斜体难以辨认。
- en: Diagramming required types
  id: totrans-921
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制所需类型
- en: There are times when you absolutely must define a property type, method argument,
    or return type because the implementation absolutely requires it. In those cases,
    you can specify the types in a diagram, as I have in *Figure A2.5*.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你绝对必须定义属性类型、方法参数或返回类型，因为实现确实需要它。在这些情况下，你可以在图中指定类型，就像我在 *图 A2.5* 中所做的那样。
- en: '![Figure A2.5: You can specify particular types using a colon followed by the
    type.  ](img/B18605_Figure_A2.05.jpg)'
  id: totrans-923
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.5：你可以使用冒号后跟类型来指定特定类型。](img/B18605_Figure_A2.05.jpg)'
- en: 'Figure A2.5: You can specify particular types using a colon followed by the
    type.'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.5：你可以使用冒号后跟类型来指定特定类型。
- en: The `Image` class has a property here that absolutely must be of type `Shape`.
    It’s represented with a colon separating the property name and its type. Likewise,
    I can specify a return type for a method. The `Image` class has a method called
    `GetCircle()` that must return `Circle`. It is similarly specified with a colon
    and the type after the method signature is defined.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image` 类在这里有一个属性，它绝对必须是 `Shape` 类型。它用冒号分隔属性名称和其类型来表示。同样，我可以为方法指定返回类型。`Image`
    类有一个名为 `GetCircle()` 的方法，它必须返回 `Circle`。它也用冒号和位于方法签名之后类型来类似地指定。'
- en: Constructors
  id: totrans-926
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: A constructor is a special method that is called when an object is instantiated.
    [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178) covers this in detail
    if you’re not sure what I mean. A constructor must have the same name as the class
    where it is defined. For a lot of people, just seeing a method with the same name
    as the class is enough. It can also be drawn more formally, as shown in *Figure
    A2.6*.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个在对象实例化时被调用的特殊方法。[*附录 1*](B18605_Appendix_1.xhtml#_idTextAnchor178) 详细介绍了这一点，如果你不确定我的意思的话。构造函数必须与定义它的类的名称相同。对于很多人来说，仅仅看到与类名相同的名称就足够了。它也可以更正式地绘制，如图
    *图 A2.6* 所示。
- en: '![Figure A2.6: Constructors in a UML diagram are difficult to miss.  ](img/B18605_Figure_A2.06.jpg)'
  id: totrans-928
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.6：UML 图中的构造函数难以错过](img/B18605_Figure_A2.06.jpg)'
- en: 'Figure A2.6: Constructors in a UML diagram are difficult to miss.'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.6：UML 图中的构造函数难以错过。
- en: You can’t miss it. It’s the method with the obnoxious `<<constructor>>` in front
    of it. Since obnoxious things are very pedagogical, this is the convention I’ll
    be using.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 你不可能错过它。它是前面带有令人讨厌的 `<<constructor>>` 的方法。由于令人讨厌的东西非常有教育意义，这就是我将使用的约定。
- en: Don’t diagram every tiny detail
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要绘制每个微小的细节
- en: In the world of web design, designers use a trick when dealing with their clients
    that has been around for centuries. When working with initial designs, the objective
    is to get the layout right and not focus on copy. The difficulty arises when you
    try to put fake copy in a web page design. Your clients will focus on what the
    copy says, and they’ll try to word-smith the text on the page. The objective is
    to get buy-in on the design, but that can’t happen because all the stakeholders
    are wrapped up in what the placeholder text says.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页设计的世界里，设计师在与客户打交道时使用了一个已经存在了几个世纪的技巧。在处理初步设计时，目标是确保布局正确，不要专注于文案。当你试图在网页设计中放入虚假文案时，问题就出现了。客户会关注文案的内容，他们会试图润色页面上的文字。目标是获得对设计的认可，但这是不可能的，因为所有利益相关者都陷入了占位文本的内容。
- en: 'To get around this, designers use *lorem ipsum* text. *Lorem ipsum* are words
    from a famous book on ethics attributed to the Roman statesman and poet Marcus
    Tullius Cicero. The text looks like this:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，设计师使用 *lorem ipsum* 文本。*lorem ipsum* 是归功于罗马政治家和诗人马尔库斯·图利乌斯·西塞罗的一本著名伦理学书籍中的单词。文本看起来像这样：
- en: “Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
    incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud
    exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute
    irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
    deserunt mollit anim id est laborum.”
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: “Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
    incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud
    exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute
    irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla
    pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
    deserunt mollit anim id est laborum。”
- en: This text is placed in a design draft as a placeholder for the actual copy.
    Since the text is unintelligible, anyone looking at the design with this text
    in place isn’t tempted to critique the content. They focus on the design.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文本被放置在设计草案中，作为实际副本的占位符。由于文本难以理解，任何查看带有此文本的设计的人都不会被诱惑去评论内容。他们专注于设计。
- en: In UML, when you want to do this, you can use empty, or nearly empty, classes
    to encourage stakeholders, namely the developers, to focus on the pattern design
    instead of what you’ve named the properties.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，当你想要这样做时，你可以使用空或几乎空的类来鼓励利益相关者，即开发者，专注于模式设计而不是你命名的属性。
- en: I do this a lot within this book. The projects aren’t real, and the code doesn’t
    really matter beyond being pedagogical. We’re here to learn the patterns. You
    can expect to see a lot of diagrams like *Figure A2.7*.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这本书中做了很多这样的事情。项目不是真实的，代码在作为教学工具之外并不重要。我们在这里是为了学习模式。你可以期待看到很多像*图A2.7*这样的图表。
- en: '![Figure A2.7: When designing with patterns, it is normal to see classes without
    all the details filled in. The point is to design and critique the structure,
    not the content.  ](img/B18605_Figure_A2.07.jpg)'
  id: totrans-938
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.7：在设计模式时，看到没有填写所有细节的类是正常的。重点是设计和评论结构，而不是内容。](img/B18605_Figure_A2.07.jpg)'
- en: 'Figure A2.7: When designing with patterns, it is normal to see classes without
    all the details filled in. The point is to design and critique the structure,
    not the content.'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.7：在设计模式时，看到没有填写所有细节的类是正常的。重点是设计和评论结构，而不是内容。
- en: In the `Person` and `Teacher` classes, I used placeholders. In the `Student`
    class, I didn’t specify anything. Both notations are valid. When you have the
    structure down, you can choose to either fill in the missing properties, methods,
    and relationships or leave them as implementation details for the developers.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Person`和`Teacher`类中，我使用了占位符。在`Student`类中，我没有指定任何内容。这两种表示法都是有效的。当你确定了结构，你可以选择填写缺失的属性、方法和关系，或者将它们留给开发者作为实现细节。
- en: If you choose the former, be careful. When you’re first getting used to working
    with UML, it is tempting to use it as a tool to specify minutiae. Resist this
    temptation. If you don’t, your diagrams will become so complicated that they lose
    their meaning.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择前者，要小心。当你刚开始习惯使用UML时，很容易将其用作指定细节的工具。抵制这种诱惑。如果不这样做，你的图表会变得如此复杂，以至于失去了意义。
- en: Interfaces
  id: totrans-942
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Interfaces are extremely important to OOAD and pattern diagramming. Drawing
    them is not very different from drawing classes. They look the same except for
    an obnoxious `<<Interface>>` expressed in the title box on the diagram. You can
    see one in *Figure A2.7*.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 接口对于面向对象分析和模式绘图非常重要。绘制它们与绘制类没有太大区别。它们看起来一样，只是在图表标题框中表达了一个令人讨厌的`<<Interface>>`。
- en: '![Figure A2.7: An interface in UML.  ](img/B18605_Figure_A2.08.jpg)'
  id: totrans-944
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.7：UML中的一个接口。](img/B18605_Figure_A2.08.jpg)'
- en: 'Figure A2.7: An interface in UML.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.7：UML中的一个接口。
- en: 'Some languages only allow you to implement methods in interfaces. Interfaces
    in C# can specify public properties in addition to the usual public methods, so
    it is legitimate to see properties defined on an interface. To reiterate: all
    properties in methods in an interface have to be public. You’ll only ever see
    `+` symbols for the access modifiers.'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言只允许你在接口中实现方法。C#中的接口可以指定除了通常的公共方法之外的公共属性，因此可以在接口上定义属性是合法的。再次强调：接口中方法的所有属性都必须是公共的。你只会看到`+`符号作为访问修饰符。
- en: Enumerations
  id: totrans-947
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enumerations refer to a finite set of values that rarely change. For example,
    the list of states in the United States hasn’t changed in 70 years. The days of
    the week haven’t changed in thousands of years. These are good candidates for
    enumerations. Let’s look at a quick example:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举指的是一组很少改变的有限值。例如，美国各州名单70年来没有变化。一周中的日子在数千年来也没有变化。这些都是枚举的好候选者。让我们看看一个快速示例：
- en: '[PRE50]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'They can be used as types, with the effect of preventing spurious data from
    being passed into a property or variable:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用作类型，其效果是防止虚假数据被传递到属性或变量中：
- en: '[PRE51]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is better than just making it a string:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这比仅仅将其作为字符串要好：
- en: '[PRE52]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I set the variable to “`Wednesday"`, but as my `enum` reveals, my program is
    expecting a very specific value. The `"Wednesday"` string isn’t right. I could
    easily set any value as long as it is a string. If my class needs a day of the
    week, and I use an enumeration as the type, it would be impossible to pass in
    *Bruceday* as a day of the week. *Bruceday* only occurs in my house where every
    day is a beautiful, beautiful *Bruceday*. I’ve been trying to standardize it as
    an internationally recognized day off for years. I figured it was a lock when
    country superstar Alan Jackson recorded, “It’s Bruceday Somewhere.” At the last
    minute, he changed the title to “It’s Five O’Clock Somewhere.” I think it was
    a mistake. Apparently, you have to be a Nordic or Greek god, a main sequence star,
    or a planetary body before you are taken seriously.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 我将变量设置为“`Wednesday"`”，但正如我的`enum`显示的那样，我的程序期望一个非常具体的值。字符串“`Wednesday`”是不正确的。只要是一个字符串，我就可以轻松地设置任何值。如果我的类需要一个星期中的某一天，并且我使用枚举作为类型，那么就不可能传入*Bruceday*作为星期中的某一天。*Bruceday*只出现在我的家里，那里每一天都是美丽、美丽的*Bruceday*。我已经尝试了多年将其标准化为国际上公认的休息日。我想这应该是肯定的，当国家超级巨星Alan
    Jackson录制了“`It’s Bruceday Somewhere.`”这首歌时。但在最后一刻，他将其标题改为“`It’s Five O’Clock Somewhere.`”。我认为这是一个错误。显然，你必须是一个北欧或希腊神，一个主序星，或者一个行星体，你才会被认真对待。
- en: An enumeration, like interfaces, features an obnoxious notation added to the
    title box, as seen in *Figure A2.8*.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 列表，就像接口一样，在标题框中添加了一个令人讨厌的符号，如*图A2.8*所示。
- en: '![Figure A2.8: An enumeration in UML.  ](img/B18605_Figure_A2.09.jpg)'
  id: totrans-956
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.8：UML中的枚举。](img/B18605_Figure_A2.09.jpg)'
- en: 'Figure A2.8: An enumeration in UML.'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.8：UML中的枚举。
- en: When you draw an enumeration, the properties represent the values that go into
    the enumeration. Enumerations don’t have methods, so there won’t be anything in
    the lower part of the diagram. There aren’t any access modifiers either. Just
    the contents are shown.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 当你绘制一个枚举时，属性代表枚举中包含的值。枚举没有方法，所以图的下部不会有任何内容。也没有访问修饰符。只显示内容。
- en: Packages
  id: totrans-959
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: 'Packages are collections of the preceding structures. In C#, you would call
    it a namespace. There are two ways to draw packages: expanded and collapsed. Expanded
    packages are drawn with a rectangle around the classes and structures that belong
    to that namespace. They are used to show the contents of the package.'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 包是前面结构的集合。在C#中，你会称它为命名空间。有两种方式来绘制包：展开和折叠。展开的包会用一个矩形框住属于该命名空间的类和结构。它们用来显示包的内容。
- en: Collapsed packages don’t show the contents. They are just a representation of
    the namespace. You can see an example of both expanded and collapsed packages
    in *Figure A2.9*.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠的包不显示内容。它们只是命名空间的表示。你可以在*图A2.9*中看到展开和折叠包的示例。
- en: '![Figure A2.9: Expanded and collapsed packages in UML.  ](img/B18605_Figure_A2.10.jpg)'
  id: totrans-962
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.9：UML中的展开和折叠包。](img/B18605_Figure_A2.10.jpg)'
- en: 'Figure A2.9: Expanded and collapsed packages in UML.'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.9：UML中的展开和折叠包。
- en: I only used the expanded package once in the book to express a dependency on
    a third-party library.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中只使用了一次展开的包来表示对第三方库的依赖。
- en: Connectors
  id: totrans-965
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接器
- en: In business, one of the most important factors to success is the relationships
    between the people you work with. The same can be said of a system of classes,
    interfaces, enumerations, and packages. In addition to the structures in a class
    diagram, the diagrams perhaps more importantly express the relationships between
    the structures, using a standardized set of lines and symbols. These lines connect
    structures together. Let’s look at the relationships expressed in UML class diagrams.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业中，成功的一个重要因素是与你共事的人之间的关系。对于类、接口、枚举和包的系统来说，也是如此。除了类图中的结构外，图也许更重要的是表达结构之间的关系，使用一套标准化的线条和符号。这些线条将结构连接在一起。让我们看看UML类图中表达的关系。
- en: Inheritance
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance between two classes is presented with a solid line with an open
    triangular arrow on one end. For example, if I have a class called `Person`, and
    another class called `Student` that inherits from `Person`, the diagram would
    look like *Figure A2.10*.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类之间的继承用一端带有开放三角箭头的实线表示。例如，如果我有一个名为`Person`的类，另一个名为`Student`的类继承自`Person`，则图表将看起来像*图A2.10*。
- en: '![Figure A2.10: Inheritance is represented with a solid line with an empty
    triangular arrow pointing to the based class.  ](img/B18605_Figure_A2.11.jpg)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.10：继承用实线和一个指向基类的空三角箭头表示。](img/B18605_Figure_A2.11.jpg)'
- en: 'Figure A2.10: Inheritance is represented with a solid line with an empty triangular
    arrow pointing to the based class.'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.10：继承用带有空心三角形箭头指向基类的实线表示。
- en: The arrow should point from the inheriting class to the base class. You are
    expressing that a student **IS A** person. As a best practice, the base classes
    are always drawn above the subclasses, so the arrows should always be pointing
    up.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头应指向继承类到基类的方向。你表达的是学生 **IS A** 人的关系。作为一个最佳实践，基类总是绘制在子类之上，因此箭头应始终向上。
- en: Interface realization
  id: totrans-972
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口实现
- en: We discussed interfaces in [*Appendix 1*](B18605_Appendix_1.xhtml#_idTextAnchor178)
    if you’re not sure what these are about. Interfaces are the most flexible way
    to pass around dependencies without tightly coupling two objects together. This
    makes them very important to our study of patterns.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定这些是什么，我们已在 [*附录 1*](B18605_Appendix_1.xhtml#_idTextAnchor178) 中讨论了接口。接口是传递依赖关系最灵活的方式，而不会将两个对象紧密耦合在一起。这使得它们对我们研究模式非常重要。
- en: When a class implements an interface, you draw a dashed line from the class
    implementing the interface to the interface itself. The end of the line has a
    hollow arrow pointing to the interface, as shown in *Figure A2.11*.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现一个接口时，你从实现接口的类到接口本身画一条虚线。线的末端有一个空心箭头指向接口，如 *图 A2.11* 所示。
- en: '![Figure A2.11: An interface realization line is dashed, with a hollow arrow
    pointing from the implementing class to the interface.  ](img/B18605_Figure_A2.12.jpg)'
  id: totrans-975
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.11：接口实现线是虚线，有一个空心箭头从实现类指向接口。](img/B18605_Figure_A2.12.jpg)'
- en: 'Figure A2.11: An interface realization line is dashed, with a hollow arrow
    pointing from the implementing class to the interface.'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.11：接口实现线是虚线，有一个空心箭头从实现类指向接口。
- en: Composition
  id: totrans-977
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: Composition refers to creating an object out of other objects. You are expressing
    a relationship by saying **HAS A**. To make a car object, you might need an engine
    object and a hood ornament object. You would say a car *has a* hood ornament,
    and you would be expressing composition. See *Figure A.12* for an example of composition.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 组合指的是由其他对象创建一个对象。你通过说 **HAS A** 来表达一个关系。要创建一个 `car` 对象，你可能需要一个 `engine` 对象和一个车标对象。你会说一辆车
    *有一个* 车标，你就是在表达组合。参见 *图 A.12* 了解组合的示例。
- en: '![Figure A2.12: Composition in UML is shown using a solid line, with a diamond
    on the end of the containing class.  ](img/B18605_Figure_A2.13.jpg)'
  id: totrans-979
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.12：UML 中的组合使用实线表示，包含类的末端有一个菱形。](img/B18605_Figure_A2.13.jpg)'
- en: 'Figure A2.12: Composition in UML is shown using a solid line, with a diamond
    on the end of the containing class.'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.12：UML 中使用实线表示组合，包含类的末端有一个菱形。
- en: In UML, composition is expressed as a solid line drawn between classes, with
    a filled diamond on one end. The diamond should be pointing to the class that
    has whatever you’re putting into it. In our `Car` class.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UML 中，组合用实线在类之间绘制，一端有一个实心菱形。菱形应指向放入其中的类。在我们的 `Car` 类中。
- en: Association
  id: totrans-982
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联
- en: Association between two classes indicates that they interact with each other.
    A `driver` object interacts with a `car` object. The driver puts gas in the car.
    The car transports the driver to another place. To draw an association in UML,
    you use a solid line with no arrow, as seen in *Figure A2.13*.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类之间的关联表示它们相互交互。一个 `driver` 对象与一个 `car` 对象交互。司机往车里加油。汽车将司机带到另一个地方。要在 UML 中绘制关联，你使用没有箭头的实线，如
    *图 A2.13* 所示。
- en: '![Figure A2.13: Associations show objects that interact with each other.  ](img/B18605_Figure_A2.14.jpg)'
  id: totrans-984
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.13：关联显示了相互交互的对象。](img/B18605_Figure_A2.14.jpg)'
- en: 'Figure A2.13: Associations show objects that interact with each other.'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.13：关联显示了相互交互的对象。
- en: Aggregation
  id: totrans-986
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregations are a type of association involving multiplicity. A `warehouse`
    object will have a relationship with inventory items expressed as “An order has
    many inventory items.” Don’t confuse it with composition. Not only does it seem
    like the same thing, but the symbols are also nearly identical. Aggregation is
    an empty diamond on a solid line, as seen in *Figure A2.14*.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一种涉及多重性的关联类型。一个 `warehouse` 对象将与库存项目有“一个订单有许多库存项目”的关系。不要将其与组合混淆。它不仅看起来像同一件事，而且符号也几乎相同。聚合在实线上表现为一个空心的菱形，如
    *图 A2.14* 所示。
- en: '![Figure A2.14: Aggregation is an empty diamond on a solid line.  ](img/B18605_Figure_A2.15.jpg)'
  id: totrans-988
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.14：聚合在实线上表现为一个空心的菱形。](img/B18605_Figure_A2.15.jpg)'
- en: 'Figure A2.14: Aggregation is an empty diamond on a solid line.'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.14：聚合在实线上用一个空心的菱形表示。
- en: Aggregation and composition are different. Composition refers to the construction
    of an object from other objects. Aggregation refers to a relationship where there
    is a one-to-one, one-to-many, or many-to-many relationship between objects, but
    the objects can stand alone. If we had a `CollegeCourse` object, we could express
    aggregation with `student` objects. There are many students in one class. If the
    college cancels the class, the students don’t instantly vanish. You can have a
    student without a class.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合和组合是不同的。组合指的是从其他对象构建一个对象。聚合指的是对象之间存在一对一、一对多或多对多的关系，但对象可以独立存在。如果我们有一个`CollegeCourse`对象，我们可以用`student`对象来表示聚合。一个班级中有很多学生。如果大学取消了课程，学生不会立即消失。你可以有一个没有班级的学生。
- en: Directed association
  id: totrans-991
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**有向关联**'
- en: A directed association shows a container relationship. A `spaceship` object
    is related to `passenger` objects in this way. Passengers are contained within
    the spaceship. Note that the spaceship is not composed of passengers, so it’s
    not the same thing as composition. A directed association can be diagramed as
    seen in *Figure A2.15*.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有向关联显示了容器关系。一个`spaceship`对象以这种方式与`passenger`对象相关联。乘客被包含在飞船内。请注意，飞船不是由乘客组成的，所以它不同于组合。有向关联可以像在*图A2.15*中看到的那样绘制。
- en: '![Figure A2.15: Directed association between two classes.  ](img/B18605_Figure_A2.16.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.15：两个类之间的有向关联。](img/B18605_Figure_A2.16.jpg)'
- en: 'Figure A2.15: Directed association between two classes.'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.15：两个类之间的有向关联。
- en: The line is solid and the arrowhead is two lines rather than a triangle.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 线是实线，箭头是两条线而不是三角形。
- en: Dependency
  id: totrans-996
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**依赖**'
- en: When one class depends on another, you will find yourself changing both classes
    when modifications are needed. If you change one, you have to change the other.
    Imagine an electrical plug and an electrical socket. They are truly designed to
    be physically dependent on one another. If you had to change the design for the
    plug, you’d probably have to change the socket design too, and vice versa. A dependency
    relationship between two classes is something we usually strive to avoid, even
    though they are unavoidable. That might sound very Zen, but I’m referring to a
    relationship between two classes. A dependency is expressed using a dashed line
    with a non-triangular arrowhead on the end, as seen in *Figure A.16*.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类依赖于另一个类时，你会发现当需要修改时，你将不得不同时修改这两个类。如果你改变一个，你就必须改变另一个。想象一下一个电源插头和一个电源插座。它们确实是设计成相互物理依赖的。如果你不得不改变插头的形状，你可能也必须改变插座的设计，反之亦然。两个类之间的依赖关系是我们通常力求避免的，尽管它们是不可避免的。这可能听起来很禅宗，但我指的是两个类之间的关系。依赖关系用带有非三角形箭头的虚线表示，如图*A.16*所示。
- en: '![Figure A2.16: Dependencies between classes are drawn with a dashed line and
    an angular arrowhead pointing from the dependent to the dependence.  ](img/B18605_Figure_A2.17.jpg)'
  id: totrans-998
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.16：类之间的依赖关系用虚线和指向依赖关系的锐角箭头绘制。](img/B18605_Figure_A2.17.jpg)'
- en: 'Figure A2.16: Dependencies between classes are drawn with a dashed line and
    an angular arrowhead pointing from the dependent to the dependence.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.16：类之间的依赖关系用虚线和指向依赖关系的锐角箭头绘制。
- en: These relationships can be vocalized as A **depends on** B changing as little
    as possible. I added the last part to remind me of the SOLID principle discussed
    in [*Chapter 2*](B18605_02.xhtml#_idTextAnchor036)*,* *Prepping for Practical
    Real-World Applications of Patterns in C#* . The O in SOLID refers to the open-closed
    principle. Classes should be open for extension but closed for modification. Dependencies
    are unavoidable, but when you see them in the diagram, scrutinize them and implement
    them with care.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系可以用“A **依赖于** B 尽可能地少变化”来表述。我添加了最后一部分来提醒我讨论在[*第2章*](B18605_02.xhtml#_idTextAnchor036)*，*《为C#中模式的实际应用做准备》*中的SOLID原则。SOLID中的O代表开闭原则。类应该对扩展开放但对修改封闭。依赖是不可避免的，但当你看到图中的依赖关系时，要仔细审查它们并小心实现。
- en: Notes
  id: totrans-1001
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**笔记**'
- en: Notes are just what you think they are. Sometimes, an architect needs to add
    a little more information than what standard UML allows. Notes let you do that.
    You can see an example in *Figure A2.17*.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '**笔记**就是你所想的那样。有时，架构师需要添加比标准UML允许的更多一点的信息。笔记让你可以做到这一点。你可以在*图A2.17*中看到一个例子。'
- en: '![Figure A2.17: This is what a note looks like in UML.  ](img/B18605_Figure_A2.18.jpg)'
  id: totrans-1003
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.17：这是UML中笔记的样子。](img/B18605_Figure_A2.18.jpg)'
- en: 'Figure A2.17: This is what a note looks like in UML.'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.17：这是UML中笔记的样子。
- en: You shouldn’t use them to write an epistle. Short notes in implementation logic
    are what you see most commonly.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该用它们来写一封长信。在实现逻辑中的简短笔记是你最常见到的。
- en: Best practices
  id: totrans-1006
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: UML class diagrams are easy to create and understand, or at least they should
    be. Unfortunately, many diagrams fall victim to the same forces I covered in [*Chapter
    1*](B18605_01.xhtml#_idTextAnchor016). They can be a Golden Hammer, and they can
    grow uncontrollably to become too complicated to be useful. Software succumbs
    to these forces slowly over time. Sometimes, it takes years to make a repository
    full of spaghetti. Diagrams tend to fall apart over the space of days. UML is
    a plan. If your plan is a messy disaster, how can your software be anything else?
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: UML类图易于创建和理解，或者至少它们应该是这样的。不幸的是，许多图表都成为了我在[*第1章*](B18605_01.xhtml#_idTextAnchor016)中提到的相同力量的受害者。它们可能成为金锤，而且它们可能不受控制地变得过于复杂，以至于不再有用。软件随着时间的推移逐渐屈服于这些力量。有时，需要数年才能使一个仓库充满意大利面。图表往往在几天内就会变得支离破碎。UML是一个计划。如果你的计划是一团糟的灾难，那么你的软件怎么可能不是呢？
- en: To curb the tide of these destructive forces, I’m going to give you four hints
    to keep your diagrams useful, easy to read, and hopefully, keep you out of analysis
    paralysis.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遏制这些破坏性力量的潮流，我将给你四个提示，以保持你的图表有用、易于阅读，并希望这能帮助你避免分析瘫痪。
- en: Less is more – don’t try to put everything in one big diagram
  id: totrans-1009
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 少即是多——不要试图将所有内容都放入一个大的图表中
- en: 'UML diagrams are meant to be used by the development team, but they are often
    shared with other project stakeholders. If you go to a meeting with a diagram
    that looks like the guidance system schematic for the Patriot missile system,
    you shouldn’t expect to be well received. The developers won’t appreciate you
    and management will not think highly of you. The UML for the project in [*Chapter
    6*](B18605_06.xhtml#_idTextAnchor110)*, Step Away from the IDE! Designing with
    Patterns Before You Code,* and [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136),
    *Nothing Left but the Typing: Implementing the Wheelchair Project*, could easily
    become way too big if you try to diagram the entire project in one diagram. Check
    out *Figure A2.18*. Even if I printed it on a plotter 3 feet wide by 2 feet tall,
    the diagram would still be hard to read.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: UML图表原本是供开发团队使用的，但它们经常与其他项目利益相关者共享。如果你带着一个看起来像爱国者导弹系统引导系统图样的图表参加会议，你 shouldn’t
    expect to be well received. 开发者不会欣赏你，管理层也不会对你有很高的评价。在[*第6章*](B18605_06.xhtml#_idTextAnchor110)*，远离IDE！在编码前使用模式*和[*第7章*](B18605_07.xhtml#_idTextAnchor136)*，*除了打字外别无他物：轮椅项目的实现*中，如果你试图在一个图表中绘制整个项目，UML图可能会变得过于庞大。查看*图A2.18*。即使我在3英尺宽、2英尺高的绘图仪上打印它，图表仍然难以阅读。
- en: '![Figure A2.18: Don’t do this! This diagram covers the entire project presented
    in Chapter 7\. It is too big, too complicated, and it won’t fit on one page.  ](img/B18605_Figure_A2.19.jpg)'
  id: totrans-1011
  prefs: []
  type: TYPE_IMG
  zh: '![图A2.18：不要这样做！这个图表涵盖了第7章中展示的整个项目。它太大、太复杂，而且无法在一页纸上显示。](img/B18605_Figure_A2.19.jpg)'
- en: 'Figure A2.18: Don’t do this! This diagram covers the entire project presented
    in [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136). It is too big, too complicated,
    and it won’t fit on one page.'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 图A2.18：不要这样做！这个图表涵盖了[*第7章*](B18605_07.xhtml#_idTextAnchor136)中展示的整个项目。它太大、太复杂，而且无法在一页纸上显示。
- en: It’s better to break the system down into small parts and diagram those. You’ll
    see this done in [*Chapter 7*](B18605_07.xhtml#_idTextAnchor136). Make diagrams
    of small systems and keep them simple. As a rule, I try to keep to one or two
    pages at most. If the diagram won’t fit on two standard sheets of paper, it is
    probably too big, and you will need to find a way to break it down into smaller
    pieces.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是把系统分解成小块，并绘制这些小块。你会在[*第7章*](B18605_07.xhtml#_idTextAnchor136)中看到这一点。绘制小型系统的图表并保持它们简单。一般来说，我尽量保持最多一页或两页。如果图表无法适应两页标准纸张，那么它可能太大，你需要找到一种方法将其分解成更小的部分。
- en: Don’t cross the lines
  id: totrans-1014
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要越界
- en: In the classic movie *Ghostbusters*, the heroes of the story invent a dangerous,
    high-tech proton accelerator that fires a stream of energy capable of trapping
    and holding ghosts. In the movie, the chief scientist who invented the technology
    warns his comrades to never cross the streams, meaning they should never let the
    bolts of energy from two proton packs cross one another. Try to imagine all life
    as you know it instantly coming to an end as all the atomic particles in your
    body explode at the speed of light. They called it a *total protonic reversal*.
    That’s bad.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典电影 *鬼怪猎人* 中，故事的主角发明了一种危险的、高科技的质子加速器，它能发射一束能量流，能够捕捉并保持鬼魂。在电影中，发明这项技术的首席科学家警告他的同志们永远不要让能量流交叉，这意味着他们永远不应该让两个质子包的能量脉冲相互交叉。试着想象你所知道的所有生命瞬间结束，因为你的身体中的所有原子粒子以光速爆炸。他们称之为
    *完全质子反转*。这很糟糕。
- en: Now, apply the same caution to crossing lines in your UML diagrams. Crossed
    lines are ambiguous. The best you can do is to make it look like a circuit diagram
    and have one line hop over another. You can see an example in *Figure A2.19*.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将同样的谨慎应用于你的 UML 图中的交叉线。交叉线是模糊的。你能做的最好的事情就是让它看起来像电路图，让一条线跳过另一条线。你可以在 *图 A2.19*
    中看到一个例子。
- en: '![Figure A2.19: The connector between Class D and Class E crosses the line
    between Class C and Class A.  ](img/B18605_Figure_A2.20.jpg)'
  id: totrans-1017
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.19：D 类和 E 类的连接器跨越了 C 类和 A 类之间的界限](img/B18605_Figure_A2.20.jpg)'
- en: 'Figure A2.19: The connector between Class D and Class E crosses the line between
    Class C and Class A.'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.19：D 类和 E 类的连接器跨越了 C 类和 A 类之间的界限
- en: You’re not sure where they originate and where they terminate. If there is no
    way to draw a class diagram without crossing lines, it is probably too big.
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 你不确定它们的起源和终止位置。如果没有办法不交叉线条绘制类图，那么它可能太大了。
- en: This doesn’t apply if the lines are going to the same place. Class B and Class
    C are both inheriting from Class A. Technically, their lines join rather than
    cross. When this happens, I make an effort to join the lines together so that
    they look like one line.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线是通往同一地方，则不适用。B 类和 C 类都继承自 A 类。技术上，它们的线是连接而不是交叉。当这种情况发生时，我会努力将线连接在一起，使它们看起来像一条线。
- en: The most direct path for lines leads to a mess
  id: totrans-1021
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线条的最直接路径会导致混乱
- en: This best practice is baked into the better UML diagramming tools you’ll find
    online. Even Visio does it by default. Drawing straight lines between classes
    leads to a messy diagram. You can see what I mean in *Figure A2.20*.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最佳实践已经融入了你在网上找到的更好的 UML 绘图工具中。即使是 Visio 也默认这样做。在类之间绘制直线会导致图表混乱。你可以在 *图 A2.20*
    中看到我的意思。
- en: '![Figure A2.20: Circuitous lines with right angles instantly make a diagram
    look better.  ](img/B18605_Figure_A2.21.jpg)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.20：带有直角的迂回线瞬间使图表看起来更好。](img/B18605_Figure_A2.21.jpg)'
- en: 'Figure A2.20: Circuitous lines with right angles instantly make a diagram look
    better.'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.20：带有直角的迂回线瞬间使图表看起来更好。
- en: It is better to draw a more circuitous line that is easy to follow and, as we
    already noted, doesn’t cross other lines.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 最好绘制一条更迂回但易于跟随的线，正如我们之前提到的，它不会与其他线交叉。
- en: Parents go above children
  id: totrans-1026
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父元素位于子元素之上
- en: When you are diagramming any sort of inheritance or interface implementation,
    you should always draw the parent element above, or at least higher than, the
    child element, as depicted in *Figure A2.21*.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在绘制任何类型的继承或接口实现图时，你应该始终将父元素绘制在子元素之上，或者至少与子元素一样高，如图 *图 A2.21* 所示。
- en: '![Figure A2.21: Parent elements should always be above child elements, which
    means your arrows should always point up.  ](img/B18605_Figure_A2.22.jpg)'
  id: totrans-1028
  prefs: []
  type: TYPE_IMG
  zh: '![图 A2.21：父元素应该始终位于子元素之上，这意味着你的箭头应该始终向上。](img/B18605_Figure_A2.22.jpg)'
- en: 'Figure A2.21: Parent elements should always be above child elements, which
    means your arrows should always point up.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A2.21：父元素应该始终位于子元素之上，这意味着你的箭头应该始终向上。
- en: This makes your diagram easier to follow as long as you are consistent.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你保持一致，这会使你的图表更容易跟随。
- en: Keep your diagrams neat
  id: totrans-1031
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持你的图表整洁
- en: Spend time keeping your diagrams tidy. I’d give you the same advice for your
    code. Clean up things you aren’t using anymore. Correct your spelling. Details
    matter! I would add that you should pick fonts that are easy to read. Fonts in
    your diagram should show italics very well so that you can always see abstract
    classes.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间保持你的图表整洁。我还会给你同样的建议，用于你的代码。清理不再使用的部分。纠正你的拼写。细节很重要！我还会补充说，你应该选择易于阅读的字体。你的图表中的字体应该很好地显示斜体，这样你就可以始终看到抽象类。
- en: Summary
  id: totrans-1033
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This appendix covered the UML. While it sounds like a programming language,
    it is really a standard way of drawing diagrams to represent structures and patterns
    of code. We only need 1 of the 14 recognized UML documents to get through this
    book, but the one we do use is used quite extensively.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录涵盖了 UML。虽然它听起来像是一种编程语言，但实际上它是一种绘制图表的标准方式，用于表示结构和代码模式。我们只需要 14 个认可的 UML 文档中的
    1 个就能通过这本书，但我们使用的这个文档被广泛使用。
- en: The class diagram shows the structures of a system along with the relationships
    between those structures. The structures may be classes, interfaces, enumerations,
    and packages. Common relationships include inheritance, interface realization,
    composition, association, and more. Notes can be added to a diagram to add more
    details but should be kept concise.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 类图显示了系统的结构以及这些结构之间的关系。结构可能是类、接口、枚举和包。常见的关系包括继承、接口实现、组合、关联等。可以在图表中添加注释以提供更多细节，但应保持简洁。
- en: We learned the best practices for UML class diagrams, including keeping a diagram
    as legible as possible. Avoid clutter in the diagram that comes from trying to
    define every single possible relationship between structures. Focus instead on
    those that are vital to the implementation of the diagram. A good diagram isn’t
    necessarily one that definitely conforms to the standards of UML. A good diagram
    is one that communicates quickly, with just enough detail to allow a developer
    to successfully implement the intent of the diagram, without micromanaging every
    detail.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 UML 类图的最佳实践，包括尽可能使图表清晰易读。避免图表中出现因试图定义结构之间所有可能的关系而产生的杂乱。相反，应专注于对图表实现至关重要的那些关系。一个好的图表不一定必须完全符合
    UML 的标准。一个好的图表是能够快速传达信息，只包含足够细节以便开发者能够成功实现图表意图，而不需要过度管理每个细节。
- en: Further reading
  id: totrans-1037
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Baumann, Henriette, Patrick Grassle, and Philippe Baumann. *UML 2.0 in action:
    A project-based tutorial*. Packt Publishing, 2005.'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: Baumann, Henriette, Patrick Grassle, and Philippe Baumann. 《UML 2.0 实战：基于项目的教程》.
    Packt Publishing, 2005.
