- en: Consistency Boundary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In monolithic systems, everything seems to be fully consistent. To achieve consistency,
    a lot of logic is **outsourced** to the database engine and becomes implicit,
    hard to figure out at a glance, and hard to test. Database transactions are frequently
    used to ensure that multiple-state mutations are executed at once. If the data
    becomes inconsistent, that usually means failure, and that requires an extensive
    investigation to fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Domain-Driven Design** (**DDD**) means avoiding complex graphs of entities.
    Instead, developers need to find a minimal logical set of entities that belong
    together and therefore need to be updated together to ensure consistency. Such
    a group of entities is called an **aggregate**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Command handling as a unit of work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency and transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregates and aggregate root patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints and invariants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the `Chapter07` folder of the book
    repository on GitHub. Since we aren't using any infrastructure components yet
    (we will start using some in the next chapter), you still need nothing other than
    the IDE or code editor. The code in the repository represents the final version
    for the chapter, and if you want to follow along, you can use the previous chapter
    code as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Domain model consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to modeling, we often hear that data models need to be at the
    center of any system. *If you want a good system, you need a good data model*.I
    have heard that saying countless times in my career as a software engineer. One
    of my colleagues once said this, and then added: "*I participated in a large project
    where we started with defining the data model, and, after eighteen months, the
    project was shut down because the model wasn''t complete*." Strangely, these two
    statements created no causal relationship for him, since the first statement was
    an axiom, and the project failure seemed to be caused by numerous reasons, but
    not by the fact that designing a single data model for complex systems is always
    a death march—many tables, directly and indirectly, connected to one another by
    foreign keys, an endless push for the third normal form to avoid data duplication
    that results in heavy queries to retrieve a meaningful set of data—these are the
    realities of taking this approach.'
  prefs: []
  type: TYPE_NORMAL
- en: If we create a data model first and then try to create our code around it, it
    is very hard to understand why some rules are being enforced, why those columns
    in that table are mandatory, and why one table has a many-to-many relationship
    with another table. These relationships are also hard to test, and even if we
    have tests, we can only run them if we have a properly configured database with
    a pre-populated set of data, so our tests are also becoming database-oriented.
  prefs: []
  type: TYPE_NORMAL
- en: DDD advocates a different approach when the domain model is essentially detached
    from the persistence, and it is primarily designed to serve specific business
    rules. When we deal with domain models, we pursue different goals with the design.
    We need to encapsulate just enough information in our classes so we can ensure
    that our model keeps being consistent after any state transition. The kind of
    consistency we mean there is not the relational database consistency that can
    be **outsourced **to the database engine. Instead, we want to ensure that our
    objects cannot violate the rules that are defined by the business, and these rules
    need to be explicitly defined in code. Let's look at what kind of principles we
    can apply, and how we can define different types of consistency boundaries in
    a domain model-centric design approach.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed before, commands express the intent of a user to do something
    with the system. It could be the case that command comes from another system or
    even from a timer, but it still expresses some intent. Before the command is handled,
    our domain model finds itself in a valid state. When the command is handled, the
    domain model should also be in a valid state. This can be a new state if the command
    handling resulted in an operation being executed, or the same state as before,
    if the command handling has failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code for handling commands that we created in the previous
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a generic handler for any operation that does not create a new instance
    of the `ClassifiedAd` entity and doesn''t remove an existing instance. The only
    reason we were able to generalize the command handling like this was because all
    the commands are handled in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve an entity from the store by means of the entity ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute an operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit changes back to the store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the operation fails, or the store cannot find anything by a given ID, the
    handler will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, the most important thing in the preceding code and in this
    list of steps that are performed when our application service is handling commands
    is that we execute an operation on *one single entity* only.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at why this is so, and, for this purpose, we need to reflect on a
    very common way of implementing business applications, where the database is the
    center of everything that the application does. We will use the e-commerce domain
    as an example since it is reasonably complex and the code won't interfere with
    our ongoing work with the `Marketplace` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have several year''s experience of developing software in .NET, you
    might have seen many codebases with methods such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the controller seems to be completing a single logical operation, and
    it might look like a command handling directly in the HTTP endpoint request-handling
    method. The operation seems to be isolated and concise. To be honest, during my
    career, I have seen much worse code, where one request of a user results in many
    unrelated database operations, but let's stick to this example since it seems
    quite reasonable at first. So, this code uses the **unit of work** pattern, and
    `DbContext` of the entity framework wrapped in the `using` block implements this
    pattern perfectly because it accumulates all changes in the database elements
    and commits those changes all at once when we call `context.SaveChangesAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the data model that is associated with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1aeaf441-0fd5-4dda-b8d3-14f356eecca4.png)'
  prefs: []
  type: TYPE_IMG
- en: Simplified eCommerce data model
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we could expect a lot more tables in the overall model. It could
    include things such as `Product`, `Supplier`, and `Shipment`. For our purposes,
    it is enough to have these four tables only. These tables all have relations to
    other tables, and those relations are all one-to-many (or zero-to-many). Our Entity
    Framework model uses an object reference between `Order` and `Customer`. This
    kind of reference is very popular when using ORM frameworks because it brings
    convenience to developers. We can access the `Customer` object that is associated
    with a particular order just by using the `order.Customer` property and modify
    any of the `Customer` properties as we wish, and this is exactly what the code
    does. It changes properties for both the order and the customer in one logical
    operation. This operation needs to either complete entirely, or fail. We cannot
    tolerate the fact that the customer''s credit amount gets decreased but the order
    remains unpaid. Such behavior is typically associated with database transactions.
    A transaction is characterized by four principles, known as **ACID**:'
  prefs: []
  type: TYPE_NORMAL
- en: Atomicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Durability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, let's concentrate on atomicity. This characteristic means that all
    operations within a transaction must be complete or nothing happens at all, and
    it is often referred to as an **all-or-nothing** proposition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we can see that the transaction is wrapping the whole
    operation for paying an order using customer credit. This is correct, and what
    we are dealing with here is a** transactional boundary**. For that particular
    method, `TakeOnCustomerCredit`, the transactional boundary would include two tables—`Customer` and `Order`.
    If we imagine another operation on the same model, that could be something such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method still uses the same model, and it has a few worrying concerns. But,
    for now, let's see what transaction boundary we are dealing with here. In this
    unit of work, we have records in `Order` and `OrderLine` tables changed in one
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two code snippets show that in *traditional* layered architecture, with
    no real domain model in place, transactional boundaries are being deliberately
    decided by any piece of code that performs changes in the database. The model
    itself does not enforce any kind of boundary. Two methods, which could even be
    located in one controller class, operate on two different transactional boundaries,
    although the `Order` table that both methods change will be a part of both transactions.
    It is quite easy to imagine that processing the remaining order payment on a customer''s
    credit by calling the `TakeOnCustomerCredit` method could happen in parallel,
    with one order line being marked as shipped by the `ShipOrderLine` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92515a7b-5908-4033-9423-cb2462af3047.png)'
  prefs: []
  type: TYPE_IMG
- en: Updates for different reasons cause unjustified conflicting transactions
  prefs: []
  type: TYPE_NORMAL
- en: From the business logic point of view, these are two different operations, but
    because of the *consistency* part of ACID, one of these methods will fail. It
    would be very weird for users of this system to know that credit and payment processing
    is somehow related to shipment and delivery.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the appearance of this kind of model is quite clear. The very
    definition of the object-oriented approach in programming declares that objects
    in software programs represent objects in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Data models follow a similar approach. Very often, we see a system with one
    global data model that closely represents the model of the real world, covering
    all aspects of the domain that the system implements. It naturally results in
    large object graphs in code that reflect such a holistic data model. Nevertheless,
    DDD advocates another approach when we need to concentrate on modeling; only those
    aspects of the real-world models that are absolutely required to implement a set
    of use cases for the system. We already touched upon this essential aspect of
    the modeling in [Chapter 4](bea6a7db-f270-4c0b-a3c3-bedb4182cafb.xhtml), *Designing
    the Model*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what we can do to build our model in a way that we can define transactional
    boundaries such that different use cases will not conflict with one another when
    our software needs to execute operations on the same real-world objects that,
    however, can be represented by different objects in the software model, or even
    belong to different models.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the case of the data model that we were dealing with earlier in this chapter,
    we have one composition—`Order` is a composition of the `OrderLine` elements.
    You probably know how this model would look if we moved from a data model to a
    class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b8187e0-a6ca-4f64-bcf4-d8f4cb04c4a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation in UML
  prefs: []
  type: TYPE_NORMAL
- en: In UML, composition implies that child elements cannot exist without their parent
    element. Indeed, having order lines that aren't linked to any order makes no sense.
    Such a composition as a whole forms a logical indivisible structure, although,
    inside this structure, we can find individual elements. For the outside world,
    an order includes its order lines and is seen as one thing, although the order
    can have many order lines. In DDD, such constructs are known as **aggregates**.
    Since we were using UML for a short while, it can create some confusion, because,
    in UML, aggregation means something else, and the closest analogy to a DDD aggregate is
    the UML concept of composition. Aggregates share the same propositions as UML
    compositions that the parent object consists of or owns all child objects, and
    when the parent object is removed, all child objects must be removed too, because
    it doesn't make sense for those objects to exist anymore. The parent object of
    an aggregate is called an **aggregate root**. Complex object graphs with a single
    parent could be visualized like a tree, where the parent object is where all the tree
    branches are growing from, so the root analogy makes perfect sense.
  prefs: []
  type: TYPE_NORMAL
- en: However, an aggregate is more than just a composition of classes. Aggregate
    boundaries also serve as transaction boundaries. For the purpose of this chapter,
    we will concentrate on two aspects of it—**atomicity** and **consistency**. As
    mentioned before, transactions imply the all-or-nothing principle of operations.
    An aggregate changes its state as a whole, no matter how the aggregate is persisted.
    If we use an ORM tool and our aggregate spans multiple database tables, all operations
    on those tables need to be wrapped in a database transaction. Furthermore, the
    consistency aspect requires an aggregate to ensure that the aggregate state is
    being validated across all operations that are executed on that aggregate. Hence,
    it is not a database or a code that is not part of the aggregate itself, such
    as an API controller or an application service. Unlike the preceding code, all
    these validity checks need to be a part of the aggregate code, and therefore they
    need to be implemented inside the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: We already have quite a few characteristics of aggregates, so we can see how
    this pattern would apply to our preceding sample. If we start looking from the
    data model, we could suspect that `Order` and `OrderLine` form some sort of composition,
    since `OrderLine` records cannot exist without a parent `Order`. It applies both
    to atomicity and consistency. If we change the order status because one line of
    that order is marked as shipped—these changes need to be executed together; otherwise,
    the order state would become invalid—we might get an order with the status *pending*
    when one order line has already been marked as shipped. So, we would expect such
    an order to have a *partially delivered* status, and if that isn't the case, then
    our order state is not valid. Since we know that an order line is a child object,
    we don't really want to expose any operations on order lines directly from outside
    the domain model. It would make much more sense if the order lines are manipulated
    by the `Order` class itself. In this case, the `Order` class becomes our aggregate
    root, and it will have methods that change the state of its lines.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, an aggregate does not guarantee any consistency constraints
    that are external to the aggregate. For the relational data model, it would mean
    that we cannot have referential integrity between the table that is used to persist
    our aggregate root (`Order`) and anything that is outside the aggregate boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make some changes in the data model to reflect the new insight, it would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/648435b5-247f-492a-9454-da3944bdd6d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing references create explicit boundaries
  prefs: []
  type: TYPE_NORMAL
- en: Note that relations between `Order` and `Customer` tables and `OrderLine` and
    `Product` table are now gone, but we kept the reference fields—`CustomerId` and
    `ProductId`. We still need to know whether the customer has placed the order and
    what products we are selling. However, as regards the normal operation of our
    system, we don't need object references in ORM, and a lack of referential integrity
    that some developers might perceive as a negative side-effect of isolating the
    aggregate, in fact, gives us a new degree of freedom. For example, order lines
    need to stay intact if the product that was used for those lines goes out of sales
    and is then removed from the `Product` table. We won't discuss flags and other
    soft-delete methods since I am making a point of keeping these things separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how the code for the API controller would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s quite a change, isn''t it? Of course, the logic has not disappeared;
    it has moved to the `Order` class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the accidental complexity of two-way object reference for order
    lines can now be removed. On the other hand, we have to change the API because
    we cannot just ask for an order line's ID. We need to know the order ID as well,
    because the order line's ID is internal to a given order, and we are using our
    aggregate root to access its child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, more complex operations would now require more work. How would we
    perform something such as what the `TakeOnCustomerCredit` method does? Since we
    do not have object relations between our `Customer` and `Order` objects, and we
    have decided that our aggregate is wrapping all about the `order` handling, but
    not `Customer`, we cannot complete one transaction on these two distinct objects.
    This might sound like an impossible task, and often, such dilemmas lead to workaround
    and shortcuts, and then the aggregate pattern is seen as something that gets in
    the way and needs to be ignored in one or two specific cases. In fact, we need
    to do quite the opposite. We have to go back to the modeling space to find out
    more about this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back at the method code, we can see that it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether the customer has enough credit to cover what remains unpaid in
    relation to an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreases the customer's credit amount for the unpaid amount of the order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases the order's paid amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreases the order's unpaid amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the order status to *paid* if the unpaid amount is zero (for that code,
    it will always be true)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increases the customer's total spent amount by the payment amount
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrades the customer to *preferred* status if this customer has spent over
    a certain threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's quite a lot, and now we are going to use the power of aggregates to make
    more sense of the whole flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to check what does not belong here. The first candidate would
    be to evaluate the last two actions on the list: updating the total spent amount
    and upgrading the customer. It seems as if something has happened not only after
    taking a credit payment but also for the credit card, cash, and any other sorts
    of payments. Keeping the code here means that we need to either copy and paste
    it or have some shared code. None of these alternatives are really appealing.
    Most importantly, these two actions have no relation to the order processing.
    Imagine one of these actions failing. Such a failure should have no effect on
    the order processing.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to check what we have to know and do in order to complete the
    operation. In our case, we must ensure that the remaining credit limit is higher
    or equal to the order unpaid amount. For our code to make a decision regarding
    whether to proceed with the payment on credit, we need to have the information
    about the available credit limit for the ordering customer. But these details
    are now out of our aggregate scope, so what can we do about it to ensure that
    an order cannot violate the consistency rule?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here comes another aspect of emerging aggregate boundaries, where we need to
    evaluate the speed of change in objects that our system works with. The `Customer`
    object now contains some information that forms a customer profile—name, address,
    and so on. At the same time, it contains some financial details that potentially
    change for every order that we process. It is clear from our code that when we
    process orders, we do not have any rules that give a discount for customers that
    have their name starting with *A*, or their location in Belgium. We could imagine
    such a requirement due to logistics reasons, but it is not relevant to our example.
    Our conclusion should be that the customer profile information changes very rarely,
    while the remaining customer credit limit changes quite often. At the same time,
    information about the total allowed credit limit might still belong to the customer
    profile, and it changes rarely too. This means that we are dealing with two different
    aspects of customer details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Customer profile | Customer running credit |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Name, address, total credit limit | Available credit limit |'
  prefs: []
  type: TYPE_TB
- en: '| Changes now and then | Changes for each credit order |'
  prefs: []
  type: TYPE_TB
- en: '| No rules for order processing | Required for the consistency of order processing
    |'
  prefs: []
  type: TYPE_TB
- en: 'We finally come to the conclusion that our *holistic* `Customer` object is
    not suitable for these different use cases. The solution for our model would be
    to move the information that is required to ensure order processing consistency
    and that the business rules need to be moved closer to the order processing logic.
    We can do this by splitting our `Customer` entity into two, each of which is responsible
    for its own set of use cases. We can even give the new entity a more explicit
    name: `CustomerCredit`, to express the specific use of this information. Our diagram
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6e2409f-849a-48c0-a98a-e6d4879fff07.png)'
  prefs: []
  type: TYPE_IMG
- en: Moving all related concerns to one boundary
  prefs: []
  type: TYPE_NORMAL
- en: In fact, what we did here belongs more to finding linguistic and contextual
    boundaries, and this topic will be covered in more detail in [Chapter 9](6f50ee65-024a-4c46-89c8-343183b05b8f.xhtml),
    *CQRS - The Read Side*. For now, we will continue discussing the aggregate boundaries
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Our new model looks better, but it has one issue—the aggregation has now shifted
    to the `CustomerCredit` entity, and it seems to become our aggregate root. From
    the relational consistency point of view, this is perfectly fine. From another
    point of view, it looks weird to process all orders by calling methods on the
    `CustomerCredit` entity. Another negative aspect is that the ownership of objects
    has also changed. Before, we had `Order`, which is responsible for its `OrderLine`.
    Now, we have `CustomerCredit`, which is responsible for everything. It looks as
    though if we remove the `CustomerCredit` object from the system, we also need
    to remove all of its orders. This is definitely not what we need. Customers come
    and go, but we definitely need to keep track of all our orders, including the
    completed ones, and not remove them. In this case, we clearly see the downside
    of having a larger aggregate with the dubious responsibility of the supportive
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to remember that despite having a constraint, we need
    to have enough credit to cover the order total before we can proceed with it,
    as the order itself can be valid even if this constraint is violated. The order
    has its own invariants—a set of unbreakable rules that guarantee the consistency
    of each order. Let''s see what invariants the `Order` aggregate has:'
  prefs: []
  type: TYPE_NORMAL
- en: The sum of `PaidAmount` and `UnpaidAmount` should be equal to `TotalAmount`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeliveryStatus` of an order can only be set to `Delivered` if, for all order
    lines of the `IsShipped` property, this is set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TotalAmount` of an order must be equal to the sum of the `LineTotal` of
    all the order lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each order line, `LineTotal` must equal the `ProductPrice` multiplied by
    `Quantity`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is nothing in these invariants that requires us to know
    the customer's available credit or any information about the product, and so on.
    So, for us to decide whether an order is consistent, it is sufficient to have
    the details pertaining to the order itself and all of its lines.
  prefs: []
  type: TYPE_NORMAL
- en: As regards ownership, it is also obvious that individual order lines cannot
    exist without the order they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, our final move would be to break the relationship between orders
    and customers, even for the more explicit `CustomerCredit` entity, while keeping
    the aggregation between `Order` and the `OrderLine` entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b1c5fc1-92f4-40ee-8d9c-260eaad67fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Making the boundaries smaller decrease transaction scopes
  prefs: []
  type: TYPE_NORMAL
- en: In this model, we have two aggregates inside an isolated part of the system.
    We know that these aggregates need to be inside the same contextual boundaries,
    but they need to be separated and form different transactional and consistency
    boundaries for the reason we discussed previously. Now, the question arises of
    how can we enforce our constraints if orders have no information about the available
    credit for the ordering customer, from inside the aggregate object graph. We will
    use the power of domain services to perform this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our domain project, we can define an interface for such a domain service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have the `EnsureEnoughCredit` method that returns a Boolean value,
    instead of returning the available credit limit itself. By doing this, we enforce
    the utilization of the ubiquitous language and shift the credit limit check logic
    to the domain service. The service might, for example, decide that for preferred
    customers, we can allow an overdraft above the available limit. Of course, in
    such an instance, we'd also need to move the `Preferred` attribute to the `CustomerCredit`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use our application service to handle the `TakeOnCustomerCredit`
    command, where it will use the domain service to check whether this command can
    be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I have to mention that moving the customer credit to a separate entity can cause
    situations when the credit amount goes below zero due to race conditions. When
    applying the credit limit change in a separate transaction, you might want to
    check if the operation results in the negative value and then decide what to do
    if the result is negative. One possible technique is to inform the account manager
    by email about the situation and let them resolve it with the customer. From a
    technical side, it is possible to create a compensating action to put the order
    on hold until the issue is resolved. Overall, those decisions should never be
    seen as technical. Talk to domain experts and ask them what solution would they
    prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach moves some domain logic to the application service, and that
    might not be desirable in some cases. To solve this, we could use the double dispatch
    pattern and let the `Order` aggregate decide on the constraint. If we decide to
    use double dispatch, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the application service will pass the dependency when calling the aggregate
    root method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It might look as if we are creating a dependency between our domain model and
    the infrastructure since it is clear that the domain service needs to fetch the
    `CustomerCredit` entity to get the data. However, our `Order` aggregate root only
    gets the interface dependency, and, as you remember, the interface itself is defined
    inside the domain project. Its implementation is indeed located inside the application
    itself, but this is perfectly normal.
  prefs: []
  type: TYPE_NORMAL
- en: We have still not seen how our aggregate is protecting its invariants, but now
    it is time to get back to our `Marketplace` application and add some code there,
    based on what we have learned about aggregates so far. We also need to cover the
    aggregate persistence, since we already used the `IOrderRepository` interface
    that is responsible for getting the aggregate state from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting invariants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](034423e8-8080-4073-bd08-b98a129384a4.xhtml), *Implementing the
    Model*, we went through using value objects to protect invalid values from even
    being used as parameters for entity constructors and methods. This technique allows
    us to move a lot of checks to value objects, provides nice encapsulation, and
    enables type safety. Then, when we create a new entity or execute some behavior
    using entity methods, we need to execute further checks. Since we can be quite
    sure that all parameters already contain valid individual values, we need to ensure
    that a given combination of parameters, the current entity state, and the executed
    behavior are not going to bring the entity to an invalid state.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the internal state from being invalid and, as a result, bringing
    the model into an inconsistent state, is one of the most important characteristics
    of aggregates. Aggregate invariants must be satisfied for each operation that
    triggers a state change; thus, we need to ensure that we control the aggregate
    state when calling any command method on the aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what complex rules we have for our classified ad entity. To
    find such rules, we can use some sticky notes from our detailed EventStorming
    session in [Chapter 3](07ee37fb-0189-467c-865d-18e72868b137.xhtml), *EventStorming*,
    and put them on a chart, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6384d06-e912-4801-8f1b-eae2c188752c.png)'
  prefs: []
  type: TYPE_IMG
- en: Business rules can prevent the command execution
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing constraints for a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We put the command to the left side, the event to the right side, and try to
    find out what could prevent our command from being executed in a way that it produces
    the desired outcome (the event). In our case here, we need to ensure that before
    an ad can be put to the review queue, it must have a non-empty title, text, and
    price.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot put these checks combined with the value object, since before the
    ad is sent to review, it can have an empty title and text, and it can have no
    price. Only when a given command is being executed do we need to check whether
    these constraints are satisfied. It is what we can call an invariant for this
    entity—an ad that is in a pending review cannot have an empty title, empty text,
    or zero price.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two ways of ensuring that our entity never gets to an invalid
    state. The first and most obvious way is to add checks to the operation code.
    There is no way of requesting that the ad be published, so let''s add it and make
    some changes related to the fact of using value objects for the entity state as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the new entity code, we enforce the constraints that became visible from
    our detailed model, so the operation is only executed if all constraints are satisfied.
    To let the caller know if our entity is not ready to be published when some of
    those checks fail, we use our custom exception, which is implemented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method of checking constraints before executing the operation, in the operation
    method itself, has one disadvantage. If, now, we change the price to zero, it
    will go through, because the `UpdatePrice` method is not checking the price value.
    We could, of course, copy the price check to the `UpdatePrice` method too, but
    there might be more methods that need the same tests and we will keep copying
    the control blocks. This will lead to a situation where, if we need to change
    any of those rules, we need to go to numerous places to replace all of the checks.
    This approach is very error prone.
  prefs: []
  type: TYPE_NORMAL
- en: To combine rules in one place, we can use contract programming techniques. Part
    of contract programming can be seen in value objects, since we evaluate pre-conditions
    for each parameter of the operation method. When we execute the operation without
    doing any additional checks, we will need to do a combined test (post-condition
    control). This check can be implemented in one place for the whole entity, and
    each operation will need to call it at the last line in the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our classified ad entity, it could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added a method called `EnsureValidState`, which checks
    that in any situation, the entity state is valid, and if it is not valid, an exception
    will be thrown. When we call this method from any operation method, we can be
    sure that no matter what we are trying to do, our entity will always be in a valid
    state or the caller will get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an exception when the entity becomes invalid is the easiest way to
    prevent inconsistencies, but it has its downsides. The whole application needs
    to be able to handle such exceptions gracefully so the user gets properly informed.
  prefs: []
  type: TYPE_NORMAL
- en: The web API code for this chapter, for example, doesn't do it and expects all
    operations to be successfully executed. As a result, when we try executing commands
    that bring the entity to some incorrect state, will crash the API method and return
    the exception via HTTP.  The web API code will be improved as we move along and
    we will start returning proper errors results from the API.
  prefs: []
  type: TYPE_NORMAL
- en: When using Event Sourcing one of the techniques to expose incorrect operations
    is to emit domain events like `PriceChangeDenied`, which include all values that
    the application tried to apply to an entity but failed. Using this method gives
    developers a powerful tool to find out why certain commands weren't executed and
    even potentially discover malicious behavior of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we converted all private fields to public read-only properties. We need
    public properties to write tests, although we don't necessarily need to expose
    the internal entity state. To prevent setting values of these properties outside
    operation methods, all properties have private setters, or no setters for properties
    that are set in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write some tests to ensure that our constraints work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This spec contains several tests for one operation (publish, or submit for review)
    with different pre-conditions. Here, we test a happy path when all necessary details
    are correctly set before the ad can be sent for review; we also test several negative
    cases when publishing is not allowed due to missing mandatory information. Perhaps
    testing negative scenarios is even more essential, since it is straightforward
    to find out when the happy path does not work—your users will immediately complain.
    Testing negative scenarios prevents bugs in controlling entity invariants, which,
    in turn, prevent entities from becoming invalid.
  prefs: []
  type: TYPE_NORMAL
- en: When we moved the entity state checks to one method, we effectively set up a
    holistic set of rules that need to be executed for each operation. This means
    that those rules aren't command-specific any more, and our `EnsureValidState`
    method has become a guardian for the entire object. It protects the invariants
    of our `ClassifiedAd` entity so it can never become invalid. The ability to protect
    its own invariants is one of the main aspects of the aggregate pattern. By executing
    each command for the `ClassifiedAd` entity within individual transactions, and
    by establishing invariant protection, we created our first aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have learned how to protect our entity from becoming invalid. But we
    expect more entities to appear in our application, and the code of the `ClassifiedAd`
    entity becomes quite verbose because we have to call the `EnsureValidState` method
    in each operation. Also, it is certainly possible to forget to put the call in
    an entity method and then get a chance to get the entity in an invalid state without
    getting any exceptions. However, this cannot possibly happen if we want to have
    a true aggregate, so let's see how we can use the power of events to ensure the
    state validity for all operations.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing the rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now examine how we execute operations on the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the entity method for operation (the CQS command)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method emits an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event is then applied to the entity state to perform the state transition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we want to ensure that all state transitions do not break our invariants,
    we can move the call to `EnsureValidState` to the `Apply` method. The need to
    protect its state only applies to the aggregate root entity because it must ensure
    that the whole aggregate state is correct, and not just its own state validity.
    Therefore, we can make a new base class for this special type of entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have renamed the `_events` collection to `_changes` to make the naming
    more explicit. We also added a call to `EnsureValidState` to the `Apply` method.
    This means that whenever we execute an operation that is supposed to change the
    aggregate root entity state, we apply a new event and the state changes in the
    `When` method. However, before adding the new event to the list of changes, we
    check whether the new state is valid and that no invariants are broken. If the
    new state violates the invariants, we throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we refactor our `ClassifiedAd` class to use the new base class, the code
    becomes simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the conditions are now consolidated in one place, and no
    matter what we do, we cannot publish an ad that has no price or no text. Also,
    it is impossible to have a hidden bug in any other places of the application that
    could make an ad active and visible without being approved first. This technique
    to ensure the validity of the state is consistently very powerful, and it also
    improves the readability of our code by giving developers a clue as to where they
    can look when trying to figure out all the rules that an entity must adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: Entities inside an aggregate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might seem weird that we just added a base class called `AggregateRoot` and
    used it instead of the `Entity` class that we already had before. We could have
    just added new code to the `Entity` base class. However, this was done on purpose,
    because, as you might remember, aggregates can potentially form larger object
    graphs, and, in addition to the root entity, we might have several entities that
    will be the children of the root. We already discussed the ownership strategy,
    so when an aggregate is removed, the aggregate root and all its children are also
    removed from the system.
  prefs: []
  type: TYPE_NORMAL
- en: For all the child objects, we would be talking about value objects or entities,
    as the rule of the aggregate pattern is strict. None of those child objects should
    be referenced, accessed, or manipulated outside the aggregate boundary. All operations
    on an aggregate need to be performed by calling methods on the aggregate root.
    Also, accessing any child objects inside the aggregate needs to go via the aggregate
    root as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's illustrate this principle by adding an entity to our `ClassifiedAd` aggregate.
    One of our EventStorming sessions helped us to discover that we need pictures
    to be added to ads since, without pictures, people are really hesitant to buy
    anything. An ad can have multiple pictures, and we could think of these pictures
    as value objects because users cannot *change* images. They can either upload
    new ones or remove existing ones. However, it seems as if users need to be able
    to choose in what order those images appear and what image is shown in the search
    results, as the *main* image. We can solve this issue by using a value object
    called `ImageOrder`, which will be replaced each time the user changes the order
    of the pictures. But, even in this case, we would need to reference images somehow,
    using some sort of identity. It makes us certain that our future `Picture` objects
    will be entities so we can reference them by an identity inside the aggregate.
    If we do that, we do not need to have an `ImageOrder` object, since we can keep
    the ordering attribute inside the `Picture` object itself. So, our entity will
    have the option of a state change, and we need to handle that too.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Entity` base class to create our new `Picture` class in the
    `Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we do not expect to hold the image itself inside the entity as a byte
    array. The physical image itself is not a concern for our domain. Within the domain
    model, we assume that all images are stored somewhere and we just need to have
    an image location (a URL to an external resource) to be connected to the classified
    ad.
  prefs: []
  type: TYPE_NORMAL
- en: 'We still need to remember that all operations are executed by calling the aggregate
    root, so we add an operation to the `ClassifiedAd` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to create a class for the `PictureAddedToAClassifiedAd`
    event as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the event class, `ClassifiedAdId` is the ID of our aggregate root. The picture
    ID is externally generated, and it will be sent to the application service by
    the client, but we will never use this ID to directly reference the picture from
    outside the aggregate boundaries. Also, we assume that pictures are always added
    to the end of the list, so we don't need to send the order number since it will
    be assigned by the aggregate logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used two value objects as parameters for the `AddPicture` method. The `System.Uri`
    type is a .NET framework standard type, and we only need to define the `PictureSize`
    value object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use the power of value objects and ensure the validity of input values
    inside it, so we don't need to spread this logic everywhere. We still need an
    internal constructor that will allow us to create this object without validating
    values because we need to be able to unconditionally retrieve the existing object
    from the database, and we cannot rely on the idea that validation rules will not
    change over time.
  prefs: []
  type: TYPE_NORMAL
- en: Also here, throwing an exception is not the only way you can use to protect
    value objects from becoming invalid. One alternative way is to create a property
    `IsValid` for the value object but then you need to check it everywhere when using
    the value, probably in the application service. Another alternative is to create
    a special static object instance that would indicate an incorrect value. You can
    then check if the value you are trying to apply is valid or not. Although you'd
    need more code to implement both of those methods, you will avoid throwing exceptions.
    Remember that unlike Java, C# has no way to explicitly inform those who call your
    objects that the method can throw an exception.  Therefore, some callers won't
    be considering wrapping the call in a try-catch block and the application can
    blow up at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to change the aggregate state after we apply the new event to
    the aggregate root. We do this by adding a new case to our pattern matching `case`
    in the `When` method of the `ClassifiedAd` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have noticed, we referenced a new property called `Pictures`.
    It is the list of entities that are held inside the aggregate, so they are child
    objects of our aggregate root. We declare it as a list. We also need to initialize
    the list in the aggregate root constructor, so we don''t get a null reference
    exception when we don''t have any pictures and try to add one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This all seems fine, except it isn't. Our aggregate root performs the logic
    that belongs to the `Picture` entity itself. For now, it is just one operation,
    but we definitely expect at least the re-ordering functionality. The entity needs
    to be responsible for updating its own state, and since we do it using events,
    it needs to get the events that concern that entity. Notice that our `Picture`
    class implements the `When` method from the base class, but it is completely empty.
    We need to find a way to empower our entities to handle their own events. In addition,
    entities can have their own methods, so the aggregate root doesn't contain the
    logic that belongs to entities, and instead calls entity methods. When we add
    methods to an entity class, it will produce events to change the entity state.
    But those events can be of interest for the aggregate root as well, so we need
    to have some code that will traverse events from the entity level to the aggregate
    root level. Finally, we need events that are raised on the entity level to be
    added to the list of changes for the whole aggregate, and this list is maintained
    by the aggregate root. All those things require us to change the base classes,
    and that is what we are going to do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add a new interface that both our entity base classes will implement.
    This interface has one method that applies domain events to an entity state (currently,
    we use the `When` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we make a number of changes to the `AggregateRoot` base class. This will
    implement the new interface using a private explicit method. In addition, we add
    the `ApplyToEntity` method, which will allow us to push domain events to entities.
    This method does nothing when we pass `null` as the entity parameter because we
    plan to call it from the `When` method of the aggregate root and it should *never*
    fail. We will elaborate on why that is so in [Chapter 8](4eea9289-d77e-4568-a9c0-c5e1265e3b4e.xhtml), *Aggregate
    Persistence*, when we''ll talk about Event Sourcing. For now, we shall assume
    that our action method in the aggregate root will ensure that the child entity
    is present before producing an event that we will be propagating to the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to change the `Entity` base class code in a way that it implements
    the new interface as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also added a constructor to this class that will accept an `applier` delegate.
    Since we always instantiate entities from the aggregate root, we will pass the
    `Apply` method of the root to all entities. Then, an entity will use double dispatch
    to inform the aggregate root of events that the entity will be producing. By doing
    this, we'll make sure that the aggregate root can also handle events from its
    child entities, that it calls the `EnsureValidState` method to ensure that there
    is no consistency violation within the aggregate boundaries, and that it adds
    new events to the single list of changes for the whole aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: We use private methods to implement the new interface, so these methods will
    not be exposed when we use a class that is inherited from the `AggregateRoot`
    or `Entity` base classes, and this is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our `Picture` entity now requires a little refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We changed two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We added the constructor that accepts a reference to the `applier` delegate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We changed the `When` method, so it can now handle the creation of new pictures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You perhaps noticed that the order is now coming from the event, so we need
    to add a new property to the event class. Currently, we don't use the `applier`
    delegate, because we have not added any operations to the entity yet, but we will
    be using it in the future. Also, it is important to stress that we are not using
    the public constructor for our `PictureSize` value object in the `When` method
    because the public constructor always applies business rules and can potentially
    fail, but it happens when we construct the value object in our application service
    before it even reaches the aggregate. In the `When` method, we need to process
    the event without checking those rules, because the `When` method should never
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can change the aggregate root code. First, we change the `AddPicture`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we change the event handling in the `When` method (only changes are shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's now demonstrate how can we add some logic to the `Picture` entity and
    make sense of the `applier` delegate. One thing that can happen with an image
    is that it could be resized and we get new sizes. Out page, cannot be smaller
    than 800 x 600 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we need to add a new event to our `Events` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add a `ResizePicture` method to the aggregate root. Since
    the command will get a picture `id`, we need to be able to find this picture in
    the list. To avoid spreading LINQ queries, we can add the following method to
    the `ClassifiedAd` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the action method to the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is done, we can add a new `Resize` method to the `Picture` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add some code to change the `Picture` state when the event is raised
    to the `When` method of the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we are done with these changes, we can add an additional invariant to
    our aggregate. We can define the picture size rule directly in each check inside
    the `EnsureValidState` method, but it will be quite verbose and not very clear
    from the language perspective. Instead, let''s create a new extension method for
    the `Picture` entity, using a new `PictureRules` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use an extension method instead of putting this logic inside the entity itself
    because it is not really a rule for the entity. Perhaps the class name `PictureRules`
    is not very good and we need to fix it. On the other hand, we will never use the
    class name itself because it will only contain extension methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the invariant check code to include a new rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we need one more piece of code to make things more explicit.
    Instead of using a LINQ expression in every call to find the *first* picture (we
    might need a better domain name for that too), we will use the `FirstPicture`
    property of the aggregate root. Now the check became less technical and more explicit
    in terms of the domain language. We might also create some more methods to enforce
    the language for other rules as well, and we will do this later throughout the
    course of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we composed a few aggregates and performed operations on them
    via the aggregate root. We also evaluated possible persistence methods for aggregates
    and learned about the concept of the repository—a place where the aggregate state
    is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to find a way to store our domain objects in a database and
    see our application working for the first time. In the next chapter, we will take
    a deep dive into the topic of aggregate persistence.
  prefs: []
  type: TYPE_NORMAL
