- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Is the MVVM Design Pattern?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **MVVM** or **Model-View-ViewModel** pattern is a very commonly used design
    pattern in the .NET ecosystem, where it has proven to be a good fit for front-end
    frameworks that utilize **XAML** to build graphical user interfaces. And it’s
    not hard to see why.
  prefs: []
  type: TYPE_NORMAL
- en: This book will provide a good understanding of the MVVM design pattern and how
    to effectively apply it in **.NET MAUI** projects. It’s important to note that
    while we will focus on applying MVVM in the context of .NET MAUI, the MVVM pattern
    itself is not exclusive to the .NET ecosystem. It is a widely used design pattern
    that has gained popularity across various software development ecosystems, including
    frameworks like WPF, WinUI, and others. We’ll delve into various aspects of .NET
    MAUI to understand how it supports and enables the use of MVVM. Throughout the
    book, we’ll be building the “*Recipes!*” app as a practical example, showcasing
    various aspects of the MVVM pattern applied in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about the MVVM design pattern and its core components.
    We will look into what added value the pattern brings in terms of separation of
    concerns and why this is so important. A sample application will demonstrate the
    added value MVVM can bring to your code. Finally, we’ll discuss some common misconceptions
    about MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand what MVVM is, what its main
    components are, and what each component’s role is. You will also see what value
    MVVM adds in terms of the testability and maintainability of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: MVVM’s core components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of concerns matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVVM in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common misconceptions about MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before diving into the details of MVVM in .NET MAUI, it’s essential to familiarize
    ourselves with the core components of the MVVM pattern. In the following section,
    we’ll define the key terminologies to ensure we have a solid foundation and a
    shared understanding moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although this chapter gives a theoretical overview of MVVM, later there is
    some code showing MVVM in action so you can start seeing the value this pattern
    brings. To implement this sample yourself, you’ll need the following: *Visual
    Studio 2022 (17.3 or greater), or any IDE that allows you to create .NET MAUI
    apps*. Near the end of [*Chapter 2*](B20941_02.xhtml#_idTextAnchor036)*, What
    Is .NET MAUI?*, we’ll be looking at how to get your machine ready for developing
    .NET MAUI apps. The sample code can also be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI).'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at MVVM’s core components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVVM provides a very clear way to separate UI from business logic, promoting
    code reusability, maintainability, and testability while allowing flexible UI
    design and changes.
  prefs: []
  type: TYPE_NORMAL
- en: Having business logic living in the code-behind quickly becomes challenging
    as applications grow in size and complexity. Code-behind refers to the practice
    of placing the business logic within the same file as the user interface elements,
    often resulting in a significant amount of code being invoked through event handlers.
    This frequently results in a tight coupling between UI elements and the underlying
    business logic, as UI elements are directly referenced and manipulated within
    the code. As a result, making adjustments to the UI and performing unit testing
    can become more difficult. Later on in this chapter, in the *MVVM in action* section,
    we will see what it means to have business logic in the code-behind and how that
    complicates maintainability, testing, et cetera.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, MVVM might be slightly overwhelming or confusing. In order
    to fully understand what the pattern is all about and why it is so popular with
    XAML developers, we first need to dissect the MVVM pattern and look at its core
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the pattern already gives away three essential core components:
    the **Model**, the **View**, and the **ViewModel**. There are also two supporting
    elements that are crucial for efficiently using MVVM: **Commands** and **data
    binding**. Each of these elements has its own distinct role and responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows MVVM’s core components and how they interact with
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Core components of MVVM](img/B20941_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Core components of MVVM
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use the MVVM pattern effectively, it’s important that you understand
    not only the responsibilities of each component but also how they interact with
    each other. At a high level, the View knows about the ViewModel, and the ViewModel
    knows about the Model, but the Model is unaware of the ViewModel. This separation
    prevents tight coupling between the UI and business logic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the MVVM pattern efficiently and effectively, it is important
    that you understand how to organize your app code into suitable classes and how
    these classes interact with each other. Now, let’s look into the core components.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Model is responsible for representing the data and business logic of the
    application. It encapsulates the data and provides a way to manipulate it. The
    Model can communicate with other components within the application, such as a
    database or a web service.
  prefs: []
  type: TYPE_NORMAL
- en: It is often implemented using classes that represent the objects in the application’s
    domain, such as customers, orders, or products. These classes typically contain
    properties that represent the attributes of the objects and methods that define
    the behavior of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Model is designed to be independent of the UI framework used in the application.
    As a result, it can be reused in other applications if needed. It can be maintained
    and tested in isolation, separately from the application’s UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, it’s unclear to developers who are new to MVVM what type of object the
    Model can or should be: **Data Transfer Objects** (**DTOs**), **Plain Old CLR
    Objects** (**POCOs**), domain entities, proxy objects, services, and so on. All
    these types of objects can be seen as the Model.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, in most cases, the Model is a combination of different types of objects.
    Don’t see the Model as a single thing. In fact, it’s everything ‘outside’ the
    View and ViewModel – it’s the application’s domain and business logic. Ultimately,
    the choice of Model type will depend on the specific requirements, use case, and
    architecture of the application. Some developers may prefer to use DTOs for simplicity
    and ease of use, while others may prefer to use domain entities for better encapsulation
    and consistency with the domain model.
  prefs: []
  type: TYPE_NORMAL
- en: However, regardless of the specific type of Model being used, it’s important
    to keep the business logic within the Model ‘layer’ and avoid it in the ViewModel.
    This helps to maintain separation of concerns and keeps the ViewModel focused
    on presentation logic, while the Model focuses on business logic.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The View is responsible for presenting the data to the user. It consists of
    (UI) elements, such as buttons, labels, collections, and inputs. The View receives
    input or actions from the user and communicates with the ViewModel so it can react
    to those interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET MAUI, the View is often implemented using XAML, which is a markup language
    used to define the UI elements and layouts. The XAML file defines the structure
    of the UI and its bindings to the ViewModel. It’s important to note that while
    the MVVM pattern is often associated with XAML-based UIs, its principles are not
    limited to a specific UI framework. The MVVM pattern can be applied in other UI
    frameworks as well. In .NET MAUI, most apps use XAML for defining the UI, but
    it’s also possible to create the UI entirely in C#. Even when taking this approach,
    developers can still effectively apply the MVVM pattern to separate the concerns
    of the View, ViewModel, and Model.
  prefs: []
  type: TYPE_NORMAL
- en: The most important aspect of the View is that it should be designed to be as
    simple as possible, without any business rules or logic. Its main purpose is to
    present data to the user and receive input from them. The View’s focus should
    be on presentation logic, including formatting and layout, and it should not include
    any business logic or application logic to maintain proper separation of concerns
    in MVVM.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: By keeping the View simple and focused on presentation logic, the code can be
    easier to maintain and test. It also enables the UI to be changed without affecting
    the underlying business logic, allowing for greater flexibility in adapting and
    evolving the application over time.
  prefs: []
  type: TYPE_NORMAL
- en: The View, whether it is implemented using XAML or C#, is the application’s UI
    layer. Essentially, it is the collection of UI components, such as pages and controls,
    that make up the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ViewModel sits in between the Model and the View. It’s the “glue” between
    the UI and the business logic. Its responsibility is to expose data to the View
    for display and to handle any user input or UI events. It provides an interface
    for the View to interact with the Model, which contains the actual data and business
    logic of the application. Let’s delve into what the ViewModel does, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exposing data**: The ViewModel retrieves data from the Model and exposes
    it to the View through public properties. These properties are usually bound to
    elements in the View, such as text boxes or labels. This way, the data from the
    Model gets displayed on the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reflecting changes**: Now, you might be wondering what happens when the user
    changes something on the screen. That’s where data binding comes in. Data binding
    is like a live channel of communication between the View and the ViewModel. When
    the user modifies data in the View, the ViewModel is instantly notified and updates
    its properties accordingly. Similarly, if something changes in the ViewModel,
    the View gets updated too.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling user interactions**: The ViewModel doesn’t just passively provide
    data; it’s also responsible for dealing with user interactions, such as button
    clicks and text input. For example, if there’s a **Save** button on the View,
    the ViewModel needs to know what to do when the user clicks on it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Updating the Model**: When the user interacts with the UI and makes changes,
    the ViewModel plays an essential role in updating the Model. The ViewModel takes
    the user’s changes and translates them into actions that the Model can understand
    and process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ViewModel acts as an intermediary that handles the flow of data and actions
    between the View and the Model, ensuring that the user interface accurately represents
    the underlying data and responds correctly to user interactions. This modular
    approach, where it handles specific responsibilities separately from the View
    and Model, contributes to cleaner and more maintainable code. Finally, it’s essential
    to understand that the ViewModel should not be tied to any specific UI framework.
    Being independent of a UI framework allows it to be shared across different applications
    and facilitates easier testing in isolation from the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commands are an important concept used to represent actions that can be triggered
    by the UI. They are a way for the View to communicate user actions to the ViewModel.
    A Command is an object that implements the `ICommand` interface, which defines
    two methods: `Execute` and `CanExecute`. The `Execute` method is called when the
    Command is triggered, while the `CanExecute` method is used to determine whether
    the Command can be executed in its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commands can be seen as the equivalent of events in traditional event-driven
    programming. Both Commands and events serve as mechanisms to handle user actions
    or other triggers in an application. For instance, when the user clicks a button
    in the View, a Command in the ViewModel gets triggered, and the ViewModel takes
    appropriate actions such as saving data or fetching new information. Commands
    are highly versatile and are not limited to buttons. They can be associated with
    various UI elements such as menu items, toolbar buttons, or even gesture controls.
    Let’s take a practical example: suppose you have a text editor application. You
    could have a Command associated with the `Execute` method is called and then performs
    the necessary action.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the key benefits of using Commands in the MVVM pattern is that they allow
    for better separation of concerns between the View and the ViewModel. By using
    Commands, the View can be designed without knowing anything about the underlying
    functionality that is associated with a particular UI element. This means that
    the ViewModel can handle the entire logic associated with the Command, without
    having to be tightly coupled to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In order to bind a Command to a UI element in the View, the Command needs to
    be exposed by the ViewModel as a public property. The View can then bind to this
    property using data binding. When a Command is bound to a UI element in the View,
    the UI element is listening for an event such as a button click to occur. When
    that event is triggered, the Command’s `Execute` method, which contains the code
    that should be executed in response to the event, is called.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Commands are a powerful and flexible concept in the MVVM pattern, which
    enables better separation of concerns between the View and the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: More about Commands
  prefs: []
  type: TYPE_NORMAL
- en: We’ll dive into much more detail about Commands and how to use them in practice
    in [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*, Data Binding Building Blocks
    in .**NET MAUI*.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data binding is a core feature of MVVM that enables the ViewModel to communicate
    with the View and the View with the ViewModel in a loosely coupled manner. Data
    binding allows you to bind data properties in the ViewModel to UI elements in
    the View, such as entry fields, labels, and list views. It is used to synchronize
    the data between the View and the ViewModel. When the data in the ViewModel changes,
    the data binding engine updates the View, and vice versa, depending on how the
    binding is configured. This allows the UI to reflect the current state of the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The binding process involves three components: a **source** object (the ViewModel),
    a **target** object (the UI element), and a **binding expression** that specifies
    how the two objects should be connected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Data can flow in different directions: from the ViewModel to the View, the
    other way around, or both. Here are the ways data can flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-way**: From the ViewModel to the View, this allows the values of the
    properties on the ViewModel to be displayed on the View. This type of binding
    is typically used when updates on the ViewModel should automatically update the
    value on the View.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-way-to-source**: The exact opposite of one-way, the data only flows from
    the View to the ViewModel. Values entered in the View will automatically be reflected
    on the ViewModel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One-time**: Like one-way, the data flows from the ViewModel to the View,
    but the data binding engine will not listen for any changes that occur on the
    bound property. Once the initial value is displayed on the UI, any subsequent
    changes to the property will not be reflected on the View. This can have a significant
    positive performance impact when doing a lot of data binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-way**: Data flows in two ways; from the View to the ViewModel and from
    the ViewModel to the View. Changes made to the data in the UI are automatically
    propagated back to the ViewModel. A common scenario for using two-way data binding
    is when displaying a property in the View that the user can modify. In this case,
    the property is typically bound to an input field using two-way data binding.
    This allows the initial value of the property to be displayed in the input field,
    and any changes made by the user to be automatically reflected to the ViewModel,
    without the need for additional event handling or manual updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding is a very powerful concept and an essential component in the MVVM
    pattern. It allows the ViewModel to expose data and behavior as simple properties
    to the View, in a way that is independent of the UI framework. Through data binding,
    these properties can be bound to the UI in a loosely coupled manner. By using
    data binding, the View and ViewModel in MVVM can be synchronized seamlessly without
    the need for any manual code. The binding mode determines how changes in the data
    are propagated between the View and ViewModel. Additionally, data binding allows
    the View to communicate user input back to the ViewModel through Commands, which
    can then update the Model.
  prefs: []
  type: TYPE_NORMAL
- en: More about data binding
  prefs: []
  type: TYPE_NORMAL
- en: Everything you need to know about data binding and how to effectively use it
    in .NET MAUI is covered thoroughly in [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*,
    Data Binding Building Blocks in .NET MAUI*, and [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069)*,
    Data Binding in .**NET MAUI*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good understanding of MVVM’s core components and have gained
    insights into each component’s responsibility, let’s discuss in a bit more detail
    why MVVM matters and what value it adds.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Separation of concerns** is an important principle in software development
    that aims to divide software design and implementation into distinct parts, each
    with a specific and well-defined responsibility. This principle helps developers
    create more maintainable and flexible applications by reducing the complexity
    of each individual component and allowing for more modular and reusable code.'
  prefs: []
  type: TYPE_NORMAL
- en: In practical terms, separation of concerns means that different aspects of a
    system are separated and dealt with independently, without overlapping concerns.
    This is achieved by creating distinct layers or modules, each with its own well-defined
    responsibilities and interfaces, and minimizing the dependencies between them.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the example of a restaurant’s management system. In such a system,
    there could be several concerns like table reservation, order taking, kitchen
    operations, and billing. According to the principle of separation of concerns,
    each of these areas should be handled by a separate module.
  prefs: []
  type: TYPE_NORMAL
- en: Each module has its own set of responsibilities and would communicate with others
    through well-defined interfaces. For example, when a customer orders a dish, the
    order-taking module communicates with the kitchen operations module so that the
    dish can be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: This separation means that if you need to make changes to how table reservations
    work, you can do so without affecting kitchen operations or billing. This separation
    keeps the codebase more organized, easier to maintain, and allows for focused
    testing of individual modules.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how separation of concerns enhances both maintainability and testability.
    These are the two crucial aspects that are vital to the long-term success of any
    software application.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By applying MVVM, we are separating the UI from the business logic and loosely
    coupling the ViewModel with the View. This improves maintainability greatly as
    each component has its distinct role and its distinct concern.
  prefs: []
  type: TYPE_NORMAL
- en: The View, for example, can be easily altered or updated. UI elements can be
    moved around or replaced with newer, more modern ones without requiring changes
    to the ViewModel, as long as no additional data needs to be displayed. This is
    because the only interface between the View and the ViewModel is through data
    binding. Therefore, updating the View should not affect the ViewModel unless additional
    or altered data needs to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the View requires additional data to be displayed or a UI
    element is updated and requires further data, the ViewModel may need to be updated
    as well. However, if the required data is already available in the Model, the
    ViewModel can translate it between the Model and the View without affecting the
    Model itself. The ViewModel is responsible for managing data flow between the
    Model and the View, ensuring a clear separation of concerns between the different
    layers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, any changes in the Model’s business logic should not have a significant
    impact on the ViewModel or the View. Since the ViewModel acts as a mediator between
    the Model and the View, it’s responsible for translating the data from the Model
    to be used by the View. Therefore, if any underlying business logic should change,
    the ViewModel can handle the translation without affecting the View, ensuring
    that any changes made to the Model are transparent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Even when an update to the Model or ViewModel is needed, thanks to the nature
    of the MVVM pattern, these changes can be easily tested in isolation from each
    other and, most importantly, independently of the UI. This separation enables
    efficient and focused testing.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testability is a very important factor in software development. Not only do
    tests ensure that the tested code performs its intended function, but it also
    guarantees that it continues to operate as initially designed. When a successful
    set of tests is run, feedback is provided immediately after a code update inadvertently
    breaks the functionality. This is undoubtedly vital for maintaining the quality
    and stability of the codebase. In essence, comprehensive testing plays a crucial
    role in preserving the code’s maintainability, allowing for efficient modifications
    and improvements over time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By designing an application with testability in mind, developers can create
    code that is more reliable, maintainable, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns is crucial to achieving testability because it allows
    developers to isolate and test individual components of the application without
    worrying about dependencies on other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the MVVM design pattern, separation of concerns and
    testability are closely related. As the View, ViewModel, and Model are being treated
    as distinct components, each component is able to be written and tested independently
    of the others. Because the ViewModel is decoupled from the View and is agnostic
    of any specific UI framework, it is very easy to write automated unit tests for
    it. These automated tests are faster and more reliable than manual or automated
    UI testing, which allows developers to identify errors and regressions early in
    the development process before they become more difficult and expensive to fix.
    Similarly, the Model logic can also be effectively tested in isolation, independently
    of the ViewModel and the View.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the theory. Now, let’s take a look at an MVVM example!
  prefs: []
  type: TYPE_NORMAL
- en: MVVM in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at a very simple application that shows the user a quote of the day
    on the screen. When the user clicks a button on the screen, the application will
    fetch a quote of the day from an API and show it onscreen. Once the button is
    clicked, it should be hidden. The code-behind approach will show you how this
    app can be written without using the MVVM pattern, whereas the second example
    shows the same functionality implemented using MVVM with testability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The code-behind approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following code snippet, there is no separation of concerns; all the code
    is handled in the code-behind of the XAML page. While this code seems to be doing
    what is expected, there is no easy, fast, or robust way to test whether it works.
    This is because all the logic is handled in the click event handler of the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainPage.xaml`, we define a `Button` and a `Label`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Both button and label controls have a `Name` so that they can be referenced
    from the code-behind. The label, is not visible by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code-behind (`MainPage.xaml.cs`), we handle the button click event as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On the button click, the `GetQuoteButton` is being hidden and a call to fetch
    a quote is being made. The `QuoteLabel`’s `Text` property is assigned the value
    of the retrieved quote.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there’s a subtle bug in this code: if the API call fails, the exception
    being thrown would be silently caught, but the `GetQuoteButton`’s visibility won’t
    be restored to being visible, leaving the application unusable. But as there is
    no easy way to test this code, chances are high that this scenario is left unnoticed
    until the application gets to QA where, hopefully, a manual test might pick this
    issue up.'
  prefs: []
  type: TYPE_NORMAL
- en: Using MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s look at how we could transform this application using the MVVM pattern,
    keeping separation of concerns and testability in mind. It might be that not everything
    in this example is clear yet and that’s perfectly fine. While going through this
    book, all of these aspects should become clear very rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start off by looking at what the Model in this app would be.
  prefs: []
  type: TYPE_NORMAL
- en: The Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our sample application, the primary data we are working with is the quote
    that we fetch from an API. The logic that communicates with this API to fetch
    the data can be thought of as the Model. Instead of making the HTTP request directly
    in the code-behind as we previously did, we can encapsulate this logic into a
    separate class. This class will be responsible for fetching the quote and will
    act as our Model. Here’s what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have created a `QuoteService` class, which contains the logic
    for fetching the quote from the API. This class implements an interface called
    `IQuoteService`. By defining an interface, we are making it easier to swap out
    the implementation or mock this service for testing purposes later.
  prefs: []
  type: TYPE_NORMAL
- en: By having this logic, which was previously in our code-behind, encapsulated
    in a dedicated class already gives us a cleaner separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: This covers the Model part of the Model-View-ViewModel pattern. Let’s see what
    the ViewModel could look like.
  prefs: []
  type: TYPE_NORMAL
- en: The ViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ViewModel acts as an intermediary between the View and the Model. It holds
    the data and the Commands that the View will bind to. For our simple application,
    we need the following things in our ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: A property to hold the quote of the day once it is retrieved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two properties to control the visibility of the button and the label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Command that will be triggered when the button is clicked; this will be responsible
    for fetching the quote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to have a constructor that takes a parameter of type `IQuoteService`.
    This is where dependency injection comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: More about dependency injection
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is key to making classes testable and modular, and is used
    very commonly in MVVM. [*Chapter 7*](B20941_07.xhtml#_idTextAnchor119)*, Dependency
    Injection, Services, and Messaging*, covers this concept in depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at what this might look like in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The constructor takes an instance of `IQuoteService` as a parameter. This instance
    is assigned to the `quoteService` field within the class. This way, the ViewModel
    has access to the quote-fetching service, allowing it to retrieve quotes when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this class implements the `INotifyPropertyChanged` interface,
    and therefore needs to implement the `PropertyChanged` event. Its purpose is essentially
    to make sure the UI gets notified when data on the ViewModel changes so the View
    and ViewModel stay in sync. [*Chapter 3*](B20941_03.xhtml#_idTextAnchor051)*,
    Data Binding Building Blocks in .NET MAUI,* covers this in much more depth!
  prefs: []
  type: TYPE_NORMAL
- en: '`QuoteOfTheDay` is the property that holds the retrieved quote. This is just
    a simple property holding a string value. The only thing “special” about it is
    that it triggers the `PropertyChanged` event to inform the data binding engine
    about the updated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The two properties that control the visibility of the button and the label
    are `IsButtonVisible` and `IsLabelVisible`, respectively. Again, these are simple
    public properties that trigger the `PropertyChanged` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we implement the Command that should be invoked when the user clicks
    the buttons, let’s first implement the logic that needs to be executed by said
    Command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `GetQuote` method is asynchronous, meaning it allows for non-blocking execution,
    which is especially important when fetching data from a network source. It starts
    by setting the `IsButtonVisible` property to `false`, which should hide the button
    on the screen. Next, we’re calling the `GetQuote` method of the `quoteService`
    field, which will go out and fetch a quote. What this service actually does to
    retrieve the quote isn’t important here, as that isn’t the concern of our ViewModel.
    Once we receive a quote back from the `GetQuote` method of `quoteService`, we
    assign this value to the `QuoteOfTheDay` property. The `IsLabelVisible` property
    is set to `true` so that the label displaying the quote becomes visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can create a Command that triggers this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Through `GetQuoteCommand`, we can now call the `GetQuote` method defined on
    the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: With the Model and the ViewModel in place, let’s finally have a look at the
    View.
  prefs: []
  type: TYPE_NORMAL
- en: The View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Essentially, not a lot of changes are needed to the UI: we still need a button
    that should trigger the retrieval of the `QuoteOfTheDay` and a label to show it.
    As we are no longer going to be accessing the label from the code-behind, there
    is no need to set the `x:Name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `Button_Clicked` event handler that we had earlier can be removed
    from the code-behind. And while we are there, we can also assign the `BindingContext`
    of the page to an instance of `MainPageViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`BindingContext` is essentially the source that we are going to bind to. With
    this in place, we make some final adjustments to our XAML to include data-binding
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These binding statements ‘link’ the public properties exposed on our ViewModel
    to the properties on the UI elements. When the user clicks the button, `GetQuoteCommand`
    on `MainPageViewModel` will be invoked, which in turn will execute the `GetQuote`
    method. While the `GetQuote` method is executed, the `IsButtonVisible` and `IsLabelVisible`
    properties are being updated, and a quote retrieved from `QuoteService` will be
    set as the value of the `QuoteOfTheDay` property. Through data binding, these
    changes will instantly and automatically be reflected on the View.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! This is basically the same application as we had before. However,
    this time it is written using the MVVM pattern while keeping separation of concerns
    and testability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that immediately stands out is the fact that the MVVM example
    has more code to it. That’s mostly because of the ViewModel. Luckily, ViewModels
    should be pretty simple. They should not contain any business logic. In this example,
    the business logic is inside the `QuoteService` class, which the ViewModel calls
    into to get the `QuoteOfTheDay` value. The properties on the ViewModel are there
    to represent the state of the View, such as for controlling the visibility of
    the button and the label, and for holding the `Quote` that `QuoteService` will
    return.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be clear by now that every piece in this example has its own responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: The View – `MainPage_MVVM` – is responsible for the UI layer. It contains the
    visual elements such as a `Label` and a `Button` and lays them out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single responsibility of `QuoteService` – the Model in this scenario – is
    to fetch a `Quote`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainPageViewModel` glues it all together. It provides the properties and values
    that the View needs to display, as well as any Commands for handling interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every component has only one reason to change, which makes this code much more
    maintainable, compared to having everything in the code-behind. Not only maintainability,
    but also testability is improved a lot compared to the previous example. Don’t
    take my word for it; let’s explore how we can test the functionality of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your ViewModel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let’s take a quick look at what this means for testability. The following
    code sample shows some unit tests for `MainPageViewModel`. Again, not everything
    in here might be clear, but everything will be covered thoroughly throughout this
    book. Moreover, [*Chapter 13*](B20941_13.xhtml#_idTextAnchor223)*, Unit Testing*,
    is entirely dedicated to writing unit tests for your ViewModels. In these tests,
    we’re using the `IQuoteService` interface. Mocking is a technique used in unit
    testing to create a fake or simulated object that mimics the behavior of a real
    object. This is especially useful for isolating the code being tested and removing
    dependencies on external elements such as databases or APIs. In the constructor
    of our test class, which runs before each test, we create a new mock instance
    that returns an empty string as a result of the `GetQuote` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This mocked instance can be passed in as a parameter when creating a new instance
    of the `MainPageViewModel` class. This allows us to test the ViewModel without
    any external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first snippet shows two tests that test the value of the `IsButtonVisible`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first of the preceding tests checks whether the initial value of the `IsButtonVisible`
    property is `true`. We create a new instance of `MainPageViewModel`, passing in
    the mocked `IQuoteService` instance. We can now use our `sut` variable (for system
    under test) to do assertions and see whether everything works as expected. The
    second test checks that as soon as `GetQuoteCommand` is invoked, the `IsButtonVisible`
    property is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next test checks whether the `Quote` value returned by the injected `IQuoteService`’s
    `GetQuote` method is being set as the value of the `QuoteOfTheDay` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding test, we define that the `GetQuote` method of the mocked `IQuoteSerivce`
    should return a particular value. After executing `GetQuoteCommand`, the `QuoteOfTheDay`
    property should have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we have a test that doesn’t test the application’s happy path.
    Instead, it tests whether the `IsButtonVisible` property is set to `true` after
    the `quoteService` failed to retrieve a quote, allowing the user to try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This test fails, revealing an issue in the implementation: the `GetQuote` method
    of the ViewModel handles any exception from `IQuoteService` silently, but fails
    to re-enable the button, leaving the app in a useless state. Without even running
    the app once, needing to deploy any other components, or needing to rely on the
    availability of the quote of the day API, the app’s behavior is effectively being
    tested and a simple bug could already be identified very early on in the development
    process. These tests ensure that the application is behaving as it was intended
    to, but also that it keeps working like this in the future. If a change to the
    code would introduce different (unexpected) behavior, automated tests would fail,
    informing the developer that they have broken something and need to fix it before
    publishing the app. Unit tests like these are so valuable and very easy to write,
    as long as there is a clear separation of concerns and the application is written
    with testability in mind. The MVVM pattern is perfect for this! Like in this example,
    the ViewModel can be tested in complete isolation as it isn’t tied to the View
    or any specific UI framework. This ViewModel will work in any kind of .NET application!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to the previous example with code-behind implementation, testing becomes
    significantly more challenging: the app has to be deployed, and a UI testing framework
    must be used to launch the app, interact with the UI controls, and validate whether
    the UI shows what is expected. Automated UI tests can be time-consuming to write,
    run, and maintain. However, would you instead want to depend exclusively on manual
    testing and QA, rather than leveraging the benefits of automated testing to ensure
    the quality and reliability of your app’s behavior?'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the MVVM pattern, it becomes very easy to write unit tests that
    test different areas of the application, as it promotes separation of concerns
    and should be UI framework independent. Testing business logic through automated
    UI tests when everything is in the code-behind becomes very complex, hard to maintain,
    and error-prone very fast. UI tests have their purpose as they can test whether
    the user interface of an application behaves as expected. Both types of tests
    are important and serve different purposes in ensuring the quality of an application.
    But (automated) UI tests should just do that: test the UI. Your ViewModels and
    business logic should already be tested by other automated tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Common misconceptions about MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several common misconceptions about MVVM that can lead to misunderstandings
    of its principles and best practices. Let’s dispel some of these and provide clarity
    on the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: There should be no code in the code-behind
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is true that the main purpose of MVVM is to separate the presentation
    logic from the application logic, it is not necessarily the case that there should
    be *no* code in the code-behind. The code-behind can still be used to handle simple
    UI-related events or for any logic that is tightly coupled with the View.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, there are scenarios where putting some code in the code-behind can
    be more efficient and maintainable than trying to move everything to the ViewModel.
    For example, handling UI animations, scrolling, and controlling focus or complex
    visual behaviors may be easier to implement in the code-behind rather than trying
    to do it through data binding.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure proper separation of concerns in MVVM, it is imperative to avoid including
    business logic in the code-behind of the View. The code-behind should be kept
    to a minimum and remain as simple as possible to maintain the separation between
    the View and the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: The Model should exclusively be a DTO, a domain entity, or a POCO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the type of object used for the Model in MVVM has been a topic of debate,
    in my opinion, it is not a critical factor. The main principle of MVVM is to keep
    the business logic out of the View and only have simple validation logic in the
    ViewModel. Thus, the Model can be any object type and is often a combination of
    different types of objects. The Model isn’t a single type of thing; it is everything
    ‘outside’ the View and ViewModel that contains the application’s entities, business
    logic, repositories, and so on. The important thing to remember is that the View
    and ViewModel should not contain any business or persistence logic.
  prefs: []
  type: TYPE_NORMAL
- en: The View and the ViewModel should not know each other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the ViewModel should not have any knowledge of the View in order to maintain
    separation of concerns, the View can have a reference to the ViewModel. It is
    important to note that this does not violate the principles of MVVM, as long as
    the ViewModel is not dependent on the View. The use of ‘compiled bindings’ in
    platforms such as .NET MAUI can provide significant performance improvements,
    but in order for them to work, the View must have knowledge of the type it is
    binding to.
  prefs: []
  type: TYPE_NORMAL
- en: More about compiled bindings
  prefs: []
  type: TYPE_NORMAL
- en: Curious to find out more about compiled bindings? [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069)*,
    Data Binding in .NET MAUI*, has got you covered.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there may be some situations where it’s necessary for the View to directly
    invoke a method on the ViewModel from the code-behind. This can be necessary in
    cases where the UI is very complex, and the Command can’t be easily bound.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM is too complex and used only for large applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM itself is not necessarily complex, but it may require some learning and
    practice to become proficient with it. Understanding the concept of the separation
    of concerns and implementing it in MVVM can be a bit challenging for developers
    who are not used to working with this design pattern. Additionally, getting the
    bindings right can require some effort, especially when working with large and
    complex Views. However, once you understand it, you will notice that the development
    process becomes simpler and the code becomes more maintainable and testable. Even
    though there might be a learning curve, it is worthwhile to adopt MVVM in application
    development, even for small and simple applications. These kinds of apps need
    to be maintained and updated over time. In the course of time, their business
    logic would also benefit from unit testing, right?
  prefs: []
  type: TYPE_NORMAL
- en: That said, MVVM might be overkill for applications that have a very minimal
    UI, with only a handful of UI elements and little to no business logic being reflected
    on the UI. But then again, looking at the previous sample that only had two UI
    controls, we noticed that it benefited from being testable through applying the
    MVVM design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, the MVVM pattern separates the concerns of data, UI, and logic,
    which makes the application easier to test, modify, and extend. By using the Model
    to represent the data and business logic, the View to present the data to the
    user, and the ViewModel to mediate between the Model and the View, the MVVM pattern
    promotes a clear separation of responsibilities that makes it easier to develop
    and maintain complex applications. Additionally, the use of Commands and data
    binding provides a powerful way to handle user input and keep the UI in sync with
    the application’s state. Understanding the components of MVVM is crucial for building
    successful .NET MAUI applications that are maintainable, scalable, and easy to
    test.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B20941_02.xhtml#_idTextAnchor036)*, What Is .NET MAUI?*, we’ll
    dive into .NET MAUI so that you have a good understanding of this framework. If
    you already have a thorough knowledge of .NET MAUI, you can skip this chapter.
    If you know the basics of it, it should be a good refresher.
  prefs: []
  type: TYPE_NORMAL
