<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>10. Pattern Implementation Using Object/Functional Programming</title>
    <link href="epub.css" rel="stylesheet" type="text/css"/>
    <link href="8afe24fba552.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content">
      <div class="chapter" title="Chapter&#160;10.&#160;Pattern Implementation Using Object/Functional Programming">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch10"></a>Chapter&#160;10.&#160;Pattern Implementation Using Object/Functional Programming</h1>
            </div>
          </div>
        </div>
        <p>Most modern programming languages (partially or completely) support <span class="strong"><strong>Functional Programming</strong></span> (<span class="strong"><strong>FP</strong></span>) constructs these days. As outlined in the previous chapters, the advent of many-core computing is a factor in this progressive evolution. In some cases, we can encode a solution using OOP, and there can be a functional version of the solution as well. The most pragmatic use of the FP constructs can be undertaken by judiciously mixing them with OOP code. This is also called object/functional programming, and is becoming a dominant paradigm in languages such as F#, Scala, Ruby, and so on. The C# programming language is not an exception. There are instances where programmers abuse FP constructs to make themselves appear modern, often resulting in unreadable code. Programming being a social activity (in addition to its intellectual appeal), the readability of code is as important as its elegance and performance. In this chapter, we will take a closer look at this popular paradigm by applying it in the context of GoF patterns.</p>
        <p>We will cover the following topics in this chapter:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist">
            <li class="listitem" style="list-style-type: disc">A strategy pattern implementation using FP/OOP</li>
            <li class="listitem" style="list-style-type: disc">A fresh look at the iterator pattern using FP/OOP</li>
            <li class="listitem" style="list-style-type: disc">MapReduce programming idiom</li>
            <li class="listitem" style="list-style-type: disc">A new spin on the template method pattern using FP/OOP</li>
          </ul>
        </div>
        <div class="section" title="A strategy pattern implementation using FP/OOP">
          <div class="titlepage">
            <div>
              <div>
                <h1 class="title"><a id="ch10lvl1sec74"></a>A strategy pattern implementation using FP/OOP</h1>
              </div>
            </div>
          </div>
          <p>To focus on the programming model aspect, let us write a bubble sort routine to sort an array of the&#160;<code class="literal">int</code>, <code class="literal">double</code>, or <code class="literal">float</code> types. In a sort routine, we need to compare adjacent elements to decide whether one should swap the position of the elements. In computer science literature, this is called a <span class="strong"><strong>comparator</strong></span>. Since we are using generic programming techniques, we can write a generic comparator interface to model the comparison action that would need to be performed while sorting is happening, and we will apply the strategy pattern to provide comparators based on types.</p>
          <pre class="programlisting">    interface IComparatorStrategy&lt;T&gt; 
    { int Execute(T a, T b); } 
</pre>
          <p>Even though we can use a single generic implementation for comparing elements, in real life we might need concrete classes that are specific to the types. We will implement two concrete classes for the comparison of integers and doubles.</p>
          <pre class="programlisting">    class IntComparator : IComparatorStrategy&lt;int&gt; { 
      public int Execute(int a, int b) { 
        return a &gt; b ? 1 : (b &gt; a ) ? -1 : 0; 
      } 
    } 
 
    class DoubleComparator : IComparatorStrategy&lt;double&gt; { 
      public int Execute(double a, double b){ 
        return a &gt; b ? 1 : (b &gt; a) ? -1 : 0; 
      } 
    } 
</pre>
          <p>Armed with the comparison classes, we can write a generic sort routine by parameterizing the comparison classes, as follows:</p>
          <pre class="programlisting">    private static void BSort&lt;T&gt;(this T[] arr,  
    IComparatorStrategy&lt;T&gt; test) where T : struct 
    { 
      int n = arr.Length; 
      for(int i = 0; i&lt;n; ++i) 
      for (int j = 0; j &lt; n-i-1; j++) 
      if (test.Execute(arr[j],arr[j + 1]) &gt; 0){ 
        T temp = arr[j]; arr[j] = arr[j + 1]; 
        arr[j + 1] = temp; 
      } 
    } 
</pre>
          <p>The following code snippets show how the bubble sort routine can be invoked for sorting integers:</p>
          <pre class="programlisting">    int [] s= {  -19,20,41, 23, -6}; 
    s.BSort(new IntComparator()); 
    foreach( var n in s )  
    Console.WriteLine(n); 
</pre>
          <p>The equivalent version for sorting doubles is given next:</p>
          <pre class="programlisting">    double[] s2 = { -19.3, 20.5, 41.0, 23.6, -6.0 }; 
    s2.BSort(new DoubleComparator()); 
    foreach (var n in s2) 
    Console.WriteLine(n); 
</pre>
          <p>The OOP version of the code is simple and intuitive. But we need to resort to interface declaration and its implementation to write our code.</p>
          <div class="note" title="Note" style="">
            <div class="inner">
              <h3 class="title"><a id="note49"></a>Note</h3>
              <p>In most cases, the comparison logic can be given at the call site, using lambda.</p>
            </div>
          </div>
          <div class="section" title="Using FP constructs to make the code better">
            <div class="titlepage">
              <div>
                <div>
                  <h2 class="title"><a id="ch10lvl2sec43"></a>Using FP constructs to make the code better</h2>
                </div>
              </div>
            </div>
            <p>Lambda functions can be used to write a comparison strategy routine in a much terser and intuitive manner. We can leverage the C# function type <code class="literal">Func&lt;TIn,TResult&gt;</code> construct to do this. Let's rewrite the sort routine to leverage this idiom. We could also&#160;impart this sort capability to the array types using extension methods.</p>
            <pre class="programlisting">    private static void BSort2&lt;T&gt;(this T[] arr,  
    Func&lt;T,T,int&gt; test) where T : struct 
    { 
      int n = arr.Length; 
      for (int i = 0; i &lt; n; ++i) 
      for (int j = 0; j &lt; n - i - 1; j++) 
      if (test(arr[j], arr[j + 1]) &gt; 0) { 
        T temp = arr[j]; arr[j] = arr[j + 1]; 
        arr[j + 1] = temp; 
      } 
    } 
</pre>
            <p>We can invoke the routine by explicitly defining a <code class="literal">Func&lt;T1,T2,TReturn&gt;</code> method to do the comparison. The following code snippet demonstrates this method:</p>
            <pre class="programlisting">    int[] s3 = { -19, 20, 41, 23, -6 }; 
    Func&lt;int ,int ,int&gt; fn = (int a, int b ) =&gt; { 
      return (a &gt; b) ? 1 : -1; 
    }; 
    s3.BSort2(fn); 
    foreach (var n in s3) 
    Console.WriteLine(n); 
</pre>
            <p>We can also invoke the routine by writing a call site lambda, as follows:</p>
            <pre class="programlisting">    s3.BSort2( (int a, int b ) =&gt;  (a &gt; b ) ? 1 : -1); 
</pre>
            <p>If you want to sort a double array, the following code snippet will do the trick:</p>
            <pre class="programlisting">    s4.BSort2( (double  a, double  b ) =&gt;  (a &gt; b ) ? 1 : -1); 
</pre>
            <p>The strategy routine, implemented as lambda expressions, made the code much terse and readable as well.</p>
          </div>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="A fresh look at the iterator pattern using FP/OOP">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch10lvl1sec75"></a>A fresh look at the iterator pattern using FP/OOP</h1>
            </div>
          </div>
        </div>
        <p>The C# programming language has&#160;built-in support for the iterator pattern using the <code class="literal">foreach</code> loop construct. Any programmer worth his salt might have written code to iterate over a collection and apply some kind of transformation. To get things in perspective, let's globally write some code to compute the arithmetic mean (average) of a set of numbers.</p>
        <pre class="programlisting">    double[] arr = { 2, 4, 4, 4 ,5, 5, 7, 9}; 
    List&lt;double&gt; arrlist = arr.ToList(); 
    double nsum = 0; 
    foreach (var n in arr) { 
      nsum += n;  
    } 
    double avg = nsum / arrlist.Count; 
    Console.WriteLine(avg); 
</pre>
        <p>The preceding imperative code does the job really well, and it is quite readable. Let us explore whether we can improve the situation further. If you take a closer look, the code iterates through a collection, and applies some logic which is context-dependent. If we want to calculate the product of numbers, we need to write the same code by slightly changing the operation. While computing the geometric mean, we compute the product of the numbers. To parametrize the computation, we will use a lambda expression or function.</p>
        <p>Let us write an&#160;aggregator function, which&#160;will&#160;iterate through an array of numbers and perform an operation we specify at the call site. We will use the function to compute&#160;the&#160;arithmetic sum (called <span class="strong"><strong>sigma</strong></span>) or the multiplicative sum (called <span class="strong"><strong>PI</strong></span>) by passing the transformer function as a parameter:</p>
        <pre class="programlisting">    private static double Aggregate( double [] p ,  
    double init,Func&lt;double,double,double&gt; fn)  
    { 
      double temp = init; 
      foreach (var n in p) 
      temp =  fn(n,temp); 
      return temp; 
    } 
</pre>
        <p>Let us see how we can write the arithmetic mean function using our aggregator function. The following code uses a lambda expression to specify the computation:</p>
        <pre class="programlisting">    private static double AMEAN(double[] p) 
    { 
      return Aggregate(p, 0, (double a, double b) =&gt;  
      { return b += a; }) / p.Length; 
    } 
</pre>
        <p>The geometric mean can be computed in the following way (for brevity, we have ignored robustness concerns such as the presence of a zero, empty, or null array):</p>
        <pre class="programlisting">    private static double GMEAN(double[] p) 
    { 
      double pi = Aggregate(p, 1,  
      (double a, double accum) =&gt; { return accum *= a; }); 
      return Math.Exp(Math.Log(pi)*(1 / p.Length)); 
    } 
</pre>
        <p>To put everything together, we will write a standard deviation (<code class="literal">STD</code>) method to compute the standard deviation of the elements in an array:</p>
        <pre class="programlisting">    private static double STD(double[] p) 
    { 
      double avg = Aggregate(p, 0,(double a, double b) =&gt;  
      { return b += a; }) / p.Length; 
      double var = Aggregate(p, 0, (double a, double b) =&gt;  
      { return b += ((a - avg)*(a-avg)); }) / p.Length; 
      return Math.Sqrt(var); 
    } 
</pre>
        <p>The <code class="literal">STD</code> method takes the average of the list of numbers as a first step, and uses the value (<code class="literal">avg</code>) to compute the variance. For variance computation, the average is subtracted from each number and squared to make the resulting value positive, before accumulating it to a running sum (<code class="literal">b</code>) variable. Finally, the square root function is invoked to compute the standard deviation. The resulting code is readable, and can be used as a basis for other transformations on the list.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="MapReduce programming idiom">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch10lvl1sec76"></a>MapReduce programming idiom</h1>
            </div>
          </div>
        </div>
        <p>In the FP world, <span class="strong"><strong>MapReduce</strong></span> is considered as a programming idiom.</p>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note50"></a>Note</h3>
            <p>The process of mapping can be described as the application of a function or computation on each element of a sequence to produce a new sequence. Reduction gathers computed elements to produce the result of a process, algorithm, or a functional transformation.</p>
          </div>
        </div>
        <p>In 2003, two Google engineers (Sanjay Ghemawat and Jeff Dean) published a paper about how the company used the MapReduce programming model to simplify their distributed programming tasks. The paper entitled&#160;<span class="emphasis"><em>MapReduce: Simplified Data Processing on Large Clusters</em></span> is available on the public domain. This particular paper was very influential, and the Hadoop distributed programming model was based on the ideas outlined in the paper. You can search the Internet to find the details of the paper and the origin of the Hadoop data operating system.</p>
        <p>To reduce the complexity, we are going to implement a MapReduce function to apply the computation on an array of doubles. The following <code class="literal">Map</code> function applies a lambda on each element of the array, and returns another array; this actually transforms the original array without mutating it. For large arrays, in order to speed up the operation, we can leverage the <code class="literal">Parallel.For</code> construct in the code.</p>
        <pre class="programlisting">    public static double []  Map( double []  src,  
    Func&lt;double,double&gt; fnapply) 
    { 
      double[] ret = new double[src.Length]; 
      Parallel.For(0,ret.Length, 
      new ParallelOptions {  
        MaxDegreeOfParallelism =Environment.ProcessorCount }, 
        (i) =&gt; { ret[i] = fnapply(src[i]); 
      }); 
      return ret; 
    } 
</pre>
        <p>The MapReduce model can also be considered as the scatter/gather model of computation. In the last example, we leveraged parallel programming techniques to scatter the computation into different tasks, which would be scheduled in different threads. This way, computation for large arrays can be made faster. In the distributed version scenario, we scatter the computation to different machines. In the reduce scenario, we accumulate or aggregate the result of computation that occurred at the map stage. The following code shows the use of a serial operation in aggregating the value to an accumulator:</p>
        <pre class="programlisting">    public static double Reduce( double[] arr, 
    Func&lt;double,double,double&gt; reducer,double init) 
    { 
      double accum = init; 
      for(int i=0; i&lt; arr.Length; ++i) 
      accum = reducer(arr[i], accum); 
      return accum; 
    } 
</pre>
        <p>The preceding two functions can be used to compute standard deviation as follows:</p>
        <pre class="programlisting">    double[] arr = { 2, 4, 4, 4 ,5,5,7,9}; 
    double avg = Reduce( Map(arr,(double a) =&gt; {return a;}),  
    (double a, double b) =&gt;  
    {return b +=a;},0)/arr.Length; 
    double var = Reduce(Map(arr, (double a) =&gt;  
    {return (a-avg)*(a-avg); }), 
    (double a, double b) =&gt;  
    {return b += a; }, 1) / arr.Length; 
    Console.WriteLine(Math.Sqrt(var)); 
</pre>
        <p>For the time being, we are parking our discussion on the MapReduce programming model. It is a very vast topic, at least in the context of distributed computing environments. The Microsoft Azure platform offers a MapReduce implementation as part of its services. To be a modern developer, one should understand the MapReduce programming model and its stream processing counterparts available as part of various offerings.</p>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="A new spin on the template method pattern using FP/OOP">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch10lvl1sec77"></a>A new spin on the template method pattern using FP/OOP</h1>
            </div>
          </div>
        </div>
        <p>In this section, we will demonstrate how the template method pattern can be implemented using imperative programming techniques, and we will refactor the code to write an FP one. As a concrete example, we plan to use the computation of <span class="strong"><strong>Internal rate of return</strong></span> (<span class="strong"><strong>IRR</strong></span>) as a running example.</p>
        <p>To focus on the essentials, let us quickly hack an engine to compute the IRR, given a series of payments (<code class="literal">List&lt;double&gt;</code>), the rate, and the period. As a first step, we need to compute the present value of a series of payments by using the technique of discounting. The following routine computes the present value of the series of payments:</p>
        <pre class="programlisting">    public static double CashFlowPVDiscreteAnnual( 
    List&lt;double&gt; arr, double rate, double period) 
    { 
      int len = arr.Count; 
      double PV = 0.0; 
      for (int i = 0; i &lt; len; ++i) 
      PV += arr[i] / Math.Pow((1+rate/100), i); 
      return PV; 
    } 
</pre>
        <div class="note" title="Note" style="">
          <div class="inner">
            <h3 class="title"><a id="note51"></a>Note</h3>
            <p>
<span class="strong"><strong>The definition of IRR goes as follows</strong></span>:</p>
            <p>An IRR is a computation that maps a series of payments that are supposed to accrue to the present value by finding the rate at which the series of payments has to be discounted to make the future value equivalent to the present value.</p>
          </div>
        </div>
        <p>The following routine has been ported from the book, <span class="emphasis"><em>Financial Numerical Recipes in C++</em></span>, Bernt Arne Odegard. For details, one can consult section 3.2.1 (material on IRR) of the book available on the Internet.</p>
        <pre class="programlisting">    public static double CashFlow_IRR_Annual(List&lt;double&gt; arr, 
    double rate,double period)  
    { 
      const double ACCURACY = 1.0e-5; 
      const int MAX_ITERATIONS = 50; 
      const double ERROR = -1e30; 
      double x1 = 0.0; 
      double x2 = 20.0; 
      // create an initial bracket,  
      // with a root somewhere between bot,top 
      double f1 = CashFlowPVDiscreteAnnual(arr,x1,period); 
      double f2 = CashFlowPVDiscreteAnnual(arr,x2,period); 
 
      for (int j = 0; j &lt; MAX_ITERATIONS; ++j) 
      { 
        if ( (f1*f2) &lt; 0.0)  {break; } 
 
        if (Math.Abs(f1) &lt; Math.Abs(f2))  
          f1 = CashFlowPVDiscreteAnnual(arr, 
          x1+= 1.06*(x1-x2),period ); 
        else  
          f2 = CashFlowPVDiscreteAnnual(arr, 
          x2+=1.06*(x2-x1),period); 
        if (f2*f1&gt;0.0) 
          return ERROR; 
      } 
      double f = CashFlowPVDiscreteAnnual(arr,x1,period); 
      double rtb; 
      double dx=0; 
      if (f&lt;0.0) { 
        rtb = x1;dx=x2-x1; 
      } 
      else { 
        rtb = x2; dx = x1-x2; 
      } 
      for (int i=0;i&lt;MAX_ITERATIONS;i++) 
      { 
        dx *= 0.5; 
        double x_mid = rtb+dx; 
        double f_mid = CashFlowPVDiscreteAnnual(arr,x_mid,period); 
        if (f_mid&lt;=0.0) { rtb = x_mid; } 
        if ( (Math.Abs(f_mid)&lt;ACCURACY) ||  
        (Math.Abs(dx)&lt;ACCURACY) ) 
        return x_mid; 
      } 
      return ERROR; // error. 
    } 
</pre>
        <p>With the routine under our belt, we can create an IRR calculation class that will use the template method pattern to receive the input for the computation of IRR, based on the series of future payments.</p>
        <p>Let us create a&#160;class for the purpose of specifying inputs to the IRR computation sub system:</p>
        <pre class="programlisting">    public class IRR_PARAMS 
    { 
      public List&lt;double&gt; revenue { get; set; } 
      public double rate { get; set; } 
      public double period { get; set; } 
    } 
</pre>
        <p>In the template method pattern implementation, we define an <code class="literal">abstract</code> base class, which does the bulk of the computation, and an <code class="literal">abstract</code> method, which the concrete class has to override to create an object out of it:</p>
        <pre class="programlisting">    public abstract class IRRComputationEngine 
    { 
      public abstract IRR_PARAMS Compute(); 
      public double Evaluate() 
      { 
        IRR_PARAMS par = Compute(); 
        if (par == null) return -1; 
        return CashFlow_IRR_Annual(par.revenue, 
        par.rate, par.period);  
      } 
      private static double CashFlow_IRR_Annual( 
      List&lt;double&gt; arr,double rate,double period) 
      { //----- Code Omitted } 
    } 
  } 
</pre>
        <p>Since the compute method is flagged as abstract, we cannot instantiate an object. The main thing which we can do is override the class and provide the content of the <code class="literal">abstract</code> method.</p>
        <pre class="programlisting">    public class BridgeIRR :IRRComputationEngine { 
      IRR_PARAMS ps = new IRR_PARAMS(); 
      public BridgeIRR(List&lt;double&gt; rev, double period, double rate){ 
        ps.period = period; ps.rate = rate; ps.revenue = rev; 
      } 
      public override IRR_PARAMS Compute() { return ps;} 
    } 
</pre>
        <p>We can use the preceding class as follows:</p>
        <pre class="programlisting">    double[] ns = { 10, 12, 13, 14, 20 }; 
    BridgeIRR test = new BridgeIRR(ns.ToList(),10,5); 
    double irr = test.Evaluate(); 
    Console.WriteLine(irr); 
</pre>
        <div class="section" title="Using FP for the template method pattern implementation">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch10lvl2sec44"></a>Using FP for the template method pattern implementation</h2>
              </div>
            </div>
          </div>
          <p>We will use lambda functions to simplify the template method pattern implementation. Instead of overriding a method after sub-classing the abstract class, we will use anonymous delegates to achieve the same objective. The resulting code, given next, is very simple and easy to understand:</p>
          <pre class="programlisting">    public class IRRComputationEngine2 
    { 
      public delegate IRR_PARAMS Compute(); 
      public Compute comp{get;set;}  
 
      public double Evaluate() 
      { 
        if (comp == null) return -1; 
        IRR_PARAMS par = comp(); 
        return CashFlow_IRR_Annual(par.revenue, 
        par.rate, par.period); 
      } 
      private static double CashFlow_IRR_Annual( 
        List&lt;double&gt; arr,double rate,double period) 
      { //--- Code Omitted } 
    } 
</pre>
          <p>The class can be leveraged as follows:</p>
          <pre class="programlisting">    IRRComputationEngine2 n = new IRRComputationEngine2(); 
    double[] ns = { 10, 12, 13, 14, 20 }; 
    n.comp = () =&gt; { 
      IRR_PARAMS par = new IRR_PARAMS(); 
      par.revenue = ns.ToList(); 
      par.rate = 10; par.period = 5; 
      return par; 
    }; 
    double r = n.Evaluate(); 
    Console.WriteLine(r);</pre>
        </div>
        <div class="section" title="A quick note on the observer pattern">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch10lvl2sec45"></a>A quick note on the observer pattern</h2>
              </div>
            </div>
          </div>
          <p>The functional programming model is well suited for implementing the observer pattern. Microsoft Corporation has already created a library, christened Rx, to exploit this synergy. This library implements a subset of features that falls under the category of compositional event streams. We will be covering the relationship between the observer pattern and functional programming from the next chapter onwards.</p>
        </div>
        <div class="section" title="Does FP replace GoF patterns?">
          <div class="titlepage">
            <div>
              <div>
                <h2 class="title"><a id="ch10lvl2sec46"></a>Does FP replace GoF patterns?</h2>
              </div>
            </div>
          </div>
          <p>There is a notion among some programmers that functional programming can help to keep us away from GoF patterns. As far as the authors of this book are concerned, it is bit of an overstatement. In this chapter, we have already seen how GoF implementations can be made simple and better using functional language idioms. But the examples in this book are mostly written using C#. If we are using F# or Haskell, there are techniques available, in the rich type system of those languages, to do away with some of the GoF patterns.</p>
          <p>Two examples are:</p>
          <div class="itemizedlist">
            <ul class="itemizedlist">
              <li class="listitem" style="list-style-type: disc">Partial function applications have made the builder pattern unnecessary for FP programming languages</li>
              <li class="listitem" style="list-style-type: disc">Functional pattern matching helps us to eliminate the visitor pattern</li>
            </ul>
          </div>
          <p>If you take a closer look at the scheme of things, the GoF pattern was a solution for the static and rigid type system of C++. After that, languages such as Java node C#, on reflection, came to the fore to simplify the implementation of GoF patterns. The FP can be treated as yet another enhancement. A dynamic language with FP support can help us implement GoF patterns better, or sometimes completely do away with patterns. But, completely replacing GoF patterns is bit of a shot in the dark!
</p>
        </div>
      </div>
    </div>


    <div id="sbo-rt-content">
      <div class="section" title="Summary">
        <div class="titlepage">
          <div>
            <div>
              <h1 class="title"><a id="ch10lvl1sec78"></a>Summary</h1>
            </div>
          </div>
        </div>
        <p>In this chapter, you saw how imperative code (aka OOP code) can be mixed with FP constructs to write implementations of some of the GoF design patterns. Some functional programmers say that the GoF design patterns were conceived as a mechanism to overcome the limitations of an OOP in general (C++ in particular). If a language supports good FP constructs, most pattern implementations are unnecessary. According to&#160;our understanding, this view is a bit extreme and a middle path between FP and OOP seems to be a better option. In the coming days, FP idioms will become more and more popular and the progress will be a smooth transition. In the next chapter, we will delve&#160;into the nuances of functional reactive programming techniques. This is a very important paradigm where FP and events come together to provide us with frameworks such as .NET <span class="strong"><strong>Reactive Extensions</strong></span> (<span class="strong"><strong>Rx</strong></span>).</p>
      </div>
    </div>
</body>
</html>