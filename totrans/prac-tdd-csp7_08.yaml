- en: Abstract Away Problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These days, it is quite easy to find resources on the internet to integrate
    into your application. Many provide functionality that would be perfectly suited
    to any number of applications. After all, why spend time reinventing the wheel
    when someone else has already done the bulk of the work for you?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting a Gravatar service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the repository pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a generic repository and Entity Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracting away problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an abundance of utilities and libraries these days to help make a full-featured
    application. It can be quite easy to integrate these third-party systems within
    your application. At times, however, you may need to replace one third-party library
    with another. Alternatively, you may find yourself relying on the implementation
    that a third-party system provides, only to find that the implementation has changed
    with a later update. How can you avoid these potential problems?
  prefs: []
  type: TYPE_NORMAL
- en: Creating a dependency on code that is outside your control can create problems
    for you in the future. If a change is introduced in a library that you depend
    on, it could potentially break your system. Or, if your requirements change and
    the system no longer fits your specific needs you may have to rewrite large portions
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Don't depend directly on any third-party system. Abstract away the details so
    that your application depends only on an interface that you define. If you define
    the interface and expose only the functionality that you need, it can become trivial
    to make changes when they are required. Changes could include minor updates or
    replacing whole libraries. You want these changes to have minimal impact on the
    rest of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Don't rely on third-party implementations; focus on test driving your code.
  prefs: []
  type: TYPE_NORMAL
- en: While developing an application with Test-Driven Development in mind, it can
    often be tempting to test third-party software. While it is important to ensure
    that any third-party library or utility works well when integrated into your system,
    it is best to focus on the behavior of your system. Ensure that your system behaves
    well with the functionality that you wish to expose.
  prefs: []
  type: TYPE_NORMAL
- en: This means that you should handle the *happy path* as well as any possible *exceptions*
    that may be thrown. Gracefully recovering from an error that crops up will allow
    your application to continue to function in the event that a third-party service
    is not functioning as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Gravatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Speaker Meet application uses Gravatar to display speaker, community, and
    conference avatar images. Gravatar is an online service that associates an email
    address with an image. Users can create an account and add an image that they
    wish to be shown by any service that requests their image. The image is retrieved
    from the Gravatar service by creating an MD5 hash of the user's email address
    and requesting an image from Gravatar by supplying the hashed value. By relying
    on the hashed value, the user's email address is not exposed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gravatar service allows the consumer to supply optional parameters to the
    HTTP call in order to request a specific size, rating, or default image if none
    is found. Some of these options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**s**: The requested size of the image; by default, this is 80 x 80 pixel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**d**: The default image if none is found; options include 404, **mm** (**mystery-man**) ,
    identicon, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**f**: Force default; always return the default icon, even if an image is found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r**: Rating; users can label their image as G, PG, R, and X'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By supplying these values, you have some control over the size and types of
    image you wish to display within your application. The Speaker Meet application
    relies on the default offerings from Gravatar.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at the Gravatar site, it appears that there a number of options available.
    In order to shield the rest of the application, the functionality of Gravatar
    will be exposed through a class contained within the Speaker Meet application.
    This functionality will first be defined by an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The desired interface might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To get started, you must first write some tests. Remember, you should not write
    a line of production code without a failing unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a test version of the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create an interface named `IGravatarService`, there first must
    be a need within the application. Create a test within a `SpeakerServiceTests`
    `Get` class entitled `ItTakesGravatarService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will cause a compilation error. Create an `IGravatarService` and modify
    the constructor of the `SpeakerService` so that this is a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`SpeakerService` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to get the tests to compile, create a `FakeGravatarService` that can
    be supplied to the `SpeakerService` under test. Remember, you're not testing the
    `FakeGravatarService`, merely that the `SpeakerService` accepts an `IGravatarService`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, ensure that the `FakeGravatarServiceGetGravatar` method is called when
    an individual *Speaker* is requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the interface to add a `GetGravatar` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And implement this method in the `FakeGravatarService.` This is similar to
    the `GetCalled` check of the `FakeRepository` from [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195),
    *Test Driving C# Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, ensure that the `GetGravatar` function is executed when the `SpeakerService`
    `Get(id)` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The test should now pass. However, the `FakeGravatarService` isn''t providing
    any real value at the moment. The `GetGravatar` method should be executed with
    a provided email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You will need to modify the `SpeakerFactory` to accept an email address and
    the `Speaker` model class to house an email address property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `GetGravatar` method in the `FakeGravatarService` and the `IGravatarService` interface
    to accept a string `emailAddress`. Make sure you set the `CalledWith` property
    when the `GetGravatar` is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And ensure the `GetGravatar` method is called with the speaker''s email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, set the return value of the `GetGravatar` method to a new property
    on the `SpeakerDetail` object `Gravatar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to modify the `FakeGravatarService` and its interface, and the
    `SpeakerService` `Get` method to return a string, and the `SpeakerDetail` class
    to add a `Gravatar` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The return value of the `GetGravatar` method doesn't matter, so long as it is
    a known value. Remember, you're not testing that the `FakeGravatarService` returns
    a valid Gravatar image URL, just that the method returns something and that the
    return value is set to the `Gravatar` property on the `SpeakerDetail` object.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the production version of the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, an `IGravatarService` interface has been created with one method, `GetGravatar`.
    There are a number of options available to interact with Gravatar. You could choose
    to write your own methods to communicate directly with its public API. The Speaker
    Meet application uses one of the available `NuGet` packages, `GravatarHelper.NetStandard`.
  prefs: []
  type: TYPE_NORMAL
- en: Install the latest version of `GravatarHelper.NetStandard` through `NuGet` in
    order to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'While reviewing the Gravatar website, it appears that they offer a variety
    of optional parameters. To grow the `IGravatarService` interface and its implementation,
    create a new test class, `GetGravatar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now test that the `GravatarService` exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Make this test pass by creating a `GravatarService` class in the same location
    as the `SpeakerService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, ensure that the `GravatarService` implements the `IGravatarInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous set of tests, a `GetGravatar` method has already been defined
    within the interface. Make the test pass by implementing the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the `GetGravatar` method exists with a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow this test to pass by returning an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following tests are classified as *integration tests* as they''re testing
    how the Speaker Meet application interacts with a third-party system. Decorate
    the class as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Many test runners will allow you to conditionally run or exclude these tests
    based on trait categories. Once the integration tests are defined and known to
    run successfully, you may choose to ignore or disable them on change or only run
    them before check-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, test that the Gravatar service returns a known value when an email address
    is supplied. If you have a Gravatar account, feel free to supply your own email
    address and test for your Gravatar URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make this test pass by calling the static method supplied by the `GravatarHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The test should now pass. You can see how the implementation has been hidden
    from the rest of the application. The interface was designed out of necessity
    through a series of tests in the `SpeakerService`.
  prefs: []
  type: TYPE_NORMAL
- en: So, why not just call the `GravatarHelper` methods directly from the `SpeakerService`
    and elsewhere? Remember, you shouldn't rely on third-party implementations. If
    the `GravatarHelper` is changed or swapped out for something else entirely, then
    any class that is calling it directly may need to change. By using an interface
    and a façade, the only class that would potentially need to change is the `GravatarService`.
  prefs: []
  type: TYPE_NORMAL
- en: Future planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Future planning can be bad. If you're writing code now in anticipation of future
    problems, you could be wasting effort. Don't write code you don't need. This could
    add complexity that can slow development.
  prefs: []
  type: TYPE_NORMAL
- en: Remember the term **YAGNI** (**you ain't gonna need it**) as this applies to
    any code written without an immediate need. The additional `GravatarService` methods
    previously, could be used as an illustration of exactly that. Of the examples
    provided so far, none require the additional methods that were just created. If
    for some reason the implementation of the `GravatarHelper` changes*,* the code
    that has already been written may need to change. If it is not currently being
    used, this is a waste of effort.
  prefs: []
  type: TYPE_NORMAL
- en: So, where does future planning start and good abstraction end? Abstract away
    third-party systems. Only expose methods and functionalities that are an immediate
    need. Minimize the pain of change by shielding the rest of the application from
    the details of any third-party system. That includes things such as the .NET Framework
    and ORMs such as Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting the data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data layer abstraction has already begun with the implementation of a repository
    pattern. In this section, we will work to create a valid abstraction for connecting
    to an Entity Framework. After we can communicate with the Entity Framework, we
    will then focus on making the repository more generic and able to work with multiple
    data models.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in creating a valid data layer abstraction is to make sure CRUD
    has been handled. **CRUD** (**Create**, **Read**, **Update**, and **Delete**)
    are the basic operations that can be performed on any dataset. The `IRepository`
    does not yet provide access to all of these capabilities so we will begin by extending
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create a folder to contain the tests for a `SpeakerRepository`. The folder
    should be named in line with the folders containing the `SpeakerService` tests
    and `SpeakerController` tests. As usual, we start with a failing test. In this
    case, the test is failing to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `SpeakerRepository` and the test should pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SpeakerRepository` needs to inherit from `IRepository` so either transform
    the existence test into a test for type, or create a new test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, make the test pass by inheriting from `IRepository`. We don''t have tests
    for functionality at this point, so leave the repository methods as not implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Get method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that `SpeakerRepository` properly inherits from `IRepository`, the two
    methods currently defined by `IRepository` need to be implemented. As we did for
    `SpeakerService`, we need to create a new test class specifically for the `Get`
    method. Again, while it might seem to be overkill at this point, creating a file
    per method will help with organization as the test suite grows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the class exists, the first test method that can be written is a simple
    exists method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially this test will fail because the stub implementation provided by Visual
    Studio just throws a `NotImplementedException`. To fix this, we have to return
    something; so what should be returned? There is no test to explain what result
    is expected so we must go with something that will compile but is almost certainly
    incorrect. In this situation the correct, incorrect value to return is probably
    `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The GetAll method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test now passes. Let us pause here and get the same amount of testing around
    the `GetAll` method enforced by the interface. As previously, create a new class
    for `GetAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an exists method which will just ensure the method doesn''t throw when
    called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Create method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will probably be easier to test the repository pattern if all the repository
    methods are assumed to exist. Unfortunately, a repository presents a chicken and
    egg scenario. How can we test `Get` or `GetAll` without some way of creating entries
    in the repository? At the same time, how can we test `Create` or `Delete` without
    some way of retrieving entries from the repository?
  prefs: []
  type: TYPE_NORMAL
- en: 'Next create a new class for `Create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, write a method to check for existence. In this test, we need to
    be sure to test against the repository, not the `Create` class implementation.
    This will force us to add to the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed, in this test, that we receive a result from the `Create`
    method. This may not be obvious since we received values from the `Get` and `GetAll`
    methods, but we are choosing to break **CQRS** (**Command Query Responsibility
    Separation**) in favor of a more RESTful approach. In **REST** (**Representational
    State Transfer**), because it must remain stateless and cannot provide information
    about an action that has already finished, a service will generally return either
    the object created or a way to retrieve that object in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you might think that we are now providing a leaky abstraction
    of the web. It could be interpreted that way. I prefer to look at this choice
    as opening options instead of limiting them. It will be easier to hide a CQRS
    implementation behind a RESTful interface than it would be to work things the
    other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to pass the currently failing test, a method definition will need to be
    added to the `IRepository` interface, a method implementation will need to be
    added to the `SpeakerRepository`, and the `SpeakerRepository` implementation will
    need to be amended to not throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`Speaker Save` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A stub implementation will also have to be added to the `FakeRepository` that
    was defined in [Chapter 7](part0252.html#7GADO0-d186949d2da74f5c95dd1712efae1195), *Test
    Driving C# Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: The Delete method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will add the `Delete` method. Just as before, create a new test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like for the `Create` method, we need to treat the `SpeakerRepository`
    as an `IRepository`. Create a `Delete` exists method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Implementing this method will be slightly easier as it is a void method and
    we are not expecting a result. There are some decisions that will have to be made
    later regarding how the method should behave when it is passed to a speaker that
    does not exist. For now, we can just assume that nothing happens and the method
    is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, modify the `IRepository` to contain a `Delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And now create the stub method in the `SpeakerRepository` and the `FakeRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The Update method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last method required for a valid repository pattern and any useful
    system. We need the ability to update the models we are working with. As with
    the last two methods, this one does not yet exist in the repository, so let's
    add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, begin by creating a test class for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the others, create an `ItExists` test referencing the `IRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As before, we are just stubbing functionality here so we don't yet have an actual
    speaker to update. This test, and the others, will almost certainly have to change
    as we begin testing for actual functionality. For now, they will suffice to ensure
    the interface and class have the appropriate methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, add the method to the interface and then to the `SpeakerRepository`
    and the `FakeRepository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`Speaker Update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that all the methods have been defined, we can begin writing tests for functionality.
    We will begin with `Create` and work our way down to `Delete`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a speaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chicken and egg scenario mentioned earlier has us in a predicament. We can't
    read a speaker from the repository if no speakers have been created. We also can't
    verify that a speaker has in fact been created unless we can retrieve a speaker
    from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this problem is by using a special kind of test double that
    exposes the internal functionality of a class for the purposes of asserting on
    that information. For `Create`, we will use this approach. In the `Create.cs`
    file, let''s add a test that assumes the testable class already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To get past the compilation error, the testable class must be created. Create
    this class in the same file, for now, to make working with it more efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the class is created and the initial compilation error is resolved, but
    a new error has risen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is slightly more difficult to resolve. In reality, we want a collection
    of speakers to exist in the real repository. However, we have had no reason to
    expose that collection. No collection has actually been created as a result. Now,
    in this test we are asking whether a collection exists. The test requires that
    a collection exists for the `TestableSpeakerRepository` but we know we need one
    for the real `SpeakerRepository`. Let''s play devil''s advocate and actually do
    the thing we know is not quite right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This change doesn''t quite make the test pass; when writing the test we hastily
    accessed the `Count` property on Speakers. The `Count` property is only on a list,
    but to limit the exposure of an interface until we actually can require it with
    tests, we should really be using an `IQueryable`. We can quickly update the test
    to reflect this choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the tests and it finally fails with an actual message. The solution
    to this failure is to add an entry to the speakers collection when `Create` is
    called. The problem is that Speakers is in a different class from `Create`. So,
    we must have a collection in `SpeakerRepository` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: What's important to note is the scope and type of `_speakers`. It is an `IList`,
    because we need to add an item to it; an `IQueryable` will not do. It is also
    protected; `_speakers` must be hidden from the outside world but also must be
    accessible from the testable class. The scope operator that gives us this functionality
    is protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also make changes in the testable class in order to make this test
    pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with `Create`, we now need to verify that, when a new speaker is
    created, it  receives a unique ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this test pass, we must come up with some kind of ID generation system.
    There are many options, but one of the simplest is to create a private field and
    increment the value each time `Create` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: With that test passing, we can now turn our attention to a leak in the abstraction.
    We are simply placing the passed-in object into the dataset. This could cause
    an issue in an application that needs to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The repository should isolate its object from the rest of the application by
    passing and storing clones, instead of directly accessing and providing objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this test pass, we will need some cloning mechanism. To make this test
    pass as soon as possible, we can simply use a new object and object initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must handle the other direction for reference passing. The value stored
    in the speakers collection should not directly be handed back to us from the `Create`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice the extra auditing step. Sometimes, you will need to take an action and
    then assert on a deeply nested value or a distant value. In those cases, you can
    keep a clean single-step action by adding an audit step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, we must take a similar action to what we are already
    doing at the top of the `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: That completes the functionality required for the `Create` method. Now we should
    really do some long overdue refactoring. Firstly, let's focus on the tests and
    reduce the duplicated calls to create a new repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a constructor and a private `repo` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Then replace all repository references in the tests with `_repo`. After reducing
    the number of repositories being created in the tests, the tests look pretty good.
    Now we can focus on the `SpeakerRepository` class.
  prefs: []
  type: TYPE_NORMAL
- en: One of the immediate standouts in the `SpeakerRepository` is the code we are
    using to clone a speaker. The same code has essentially been typed twice in the
    same method. Let's abstract this to a private function inside the repository for
    now. We may end up making a more sophisticated solution later on, but for now
    that should be good enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the class, after all the public methods, we can create a `CloneSpeaker`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the `CloneSpeaker` method in `Create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Getting a single speaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the existence of `Create`, we can now very easily assert on the retrieval
    of an existing or non-existing speaker. According to Uncle Bob's Transformation
    Priority Premise, it is easier and simpler to test a singular item rather than
    a plural item, so while it doesn't completely fulfil the intent of the premise,
    we will test the retrieval of a singular speaker next.
  prefs: []
  type: TYPE_NORMAL
- en: We already have an exists test, so what will the next test be? The simplest
    test would be the retrieval of a single speaker, but if we are trying to avoid
    the gold standard, the most appropriate test would be examining what happens when
    a speaker does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: For non-existing speakers, we have a few immediately apparent options. We could
    throw an error stating that the requested speaker is not in the system. Another
    option would be returning a `null` object. And the last would be simply returning
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throwing an error is probably the most straightforward, so let''s examine this
    option first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this test pass, first we must make it compile. The `SpeakerNotFoundException`
    in this case is not the same as the one we are using in the `SpeakerService`.
    So, it will need to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the test is correctly compiling and failing, we can add the appropriate
    code to the repository to make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Another guideline for tests, to help you know you are on the right path and
    not digging yourself into a hole, is again from Uncle Bob, *A*s the tests get
    more specific the code gets more generic. If we look at the code we just wrote,
    it seems more specific then generic. Let''s refactor it to maintain a trend towards
    generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The change here is subtle, but important. Thinking about the operation of this
    method in production, the default case really is to throw. There is only a small
    subset in the set containing all the integers that we actually have a speaker
    for, so the generic case is to throw. The specific case is actually to find a
    speaker.
  prefs: []
  type: TYPE_NORMAL
- en: One issue with the method of throwing when a speaker is not found is that it
    brings a possibly unexpected and abrupt end to the application flow. The entire
    logic path the application took to get to this method is now destroyed and the
    exception must be handled. Even when we handle the exception, C# uses extra CPU
    cycles on the first-chance exception error handling process. Sometimes throwing
    is definitely the right decision; however, exceptions should be reserved for truly
    exceptional events. As discussed earlier, it is far more likely that a `Get` could
    be called with an invalid ID than with a valid one. So, in this case it is not
    necessarily a properly exceptional event for an invalid speaker to be requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the alternative of a NullObject. First, we need to revert our
    code to where it was when we started working on the `Get` method. We are using
    source control so we can very simply revert our code. If you are not using source
    control, I would suggest you start. Here is the state the `Get` method should
    be in before we begin again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can just delete the test that asserts an exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The NullObject pattern is a simple pattern with a slightly more complicated
    implementation. Basically, you create an object that inherits from the class needed,
    but it does absolutely nothing in just the right way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about this from our eventual website usage, a speaker null object
    would possibly have a name such as "Mr. Unknown" and would speak at conferences
    like "Mid-Nowhere Tech Fest." We could create a funny profile picture and fill
    out harmless user information that would let the user know they had requested
    a non-existent speaker. All of that information could be determined and filled
    out later. The important part of a null object is that it represents a fully capable
    object, but does absolutely nothing in the right way to not cause harm within
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the compilation error, create the `NullSpeaker` class and have it inherit
    from `Speaker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Making the test pass is fairly simple. In this case we don''t have to worry
    about existing tests that could break from returning the null object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Superficially, the null object pattern seems like a pretty good solution. In
    reality, this is not always the case. It is very difficult to properly do nothing
    within a system. In the case of getting a speaker, the null object pattern would
    probably work just fine. We have one more option to explore though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option is to simply return `null`. Well, simply may not be the best
    word choice. `Null` can cause a lot of trouble within a system. It will wreak
    havoc if you do not handle the null that was received and a distant part of the
    system tries to use the null as if it weren''t null. Earlier, when we were designing
    the service, we decided to expect null as a possible result from calling the repository;
    thus, in this case the range of effects should be short and null should not cause
    significant negative side-effects within the system. Let''s revert the code one
    more time and explore simply returning `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing to do in the `SpeakerRepository` because we are already returning
    `null`. Normally, this test would not be written here. We would wait to write
    this test until we had a test that was returning a valid speaker. The reason we
    want to delay this test is because we can't fail it. You will not see this test
    go red and that is generally a problem. Either the test is not needed because
    it is extraneous and covered elsewhere or the test is flawed because it can't
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test we should write before this one is a test that should retrieve a valid
    value. For the moment, ignore this test and we will come back and watch it fail
    after the next test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So, if we are about to test the retrieval of an existing speaker, which we called
    the gold standard before, why did we avoid it in the first place? The reason we
    are going to test the gold standard first now is solely because of implementation
    choices. If we were going to use either as an exception or a null object, we would
    have done those first. The problem right now is that our code is already returning
    `null` so testing for null would not have done us any good.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test for an existing speaker, a speaker must first exist. In the arrange
    section of our test, we will need to make sure we create a speaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to simply assert that the result is not null. This of course
    fails because all we are doing right now is returning `null`. Let''s fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Even though we are now forced to go down the gold-standard path, we can still
    avoid it as much as possible. One way to do this is by playing devil's advocate,
    which we can do by returning a speaker, just not the right speaker.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must now modify the test to make sure the values we care about are correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to modify the code. We could continue to play devil''s advocate, but at
    this point that would only cause more unnecessary work in the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are left with a conundrum. We can't call `Single` or `First`
    because they will throw an exception if the requested speaker is not found. We
    do have a system rule to return `null` when the speaker is not found though. The
    system is behaving correctly by default. We could simply put our test back into
    play and accept that the null test just won't be properly verifiable. Another
    option is to purposely write code to return a new speaker in the event that the
    speakers collection is missing the requested speaker. Taking the second option
    would allow us to see the null test fail, but we would just be removing it to
    make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the second option is probably the most appropriate. Many of you
    will probably think that there is no reason to add the code that forces a non-null;
    many others will probably think that the test is not needed as it doesn''t seem
    to provide value. Both groups are correct and incorrect at the same time. They
    are correct: putting in code just to remove it two seconds later is stupid. Adding
    a test that can''t really fail is stupid too.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we need the test because at some point in the future a requirement
    could come in that would cause a null to be accidentally impossible and we need
    a record of the business requirement stating that the value should be null. We
    also need to see every test fail. In this particular case, we could probably get
    away with skipping that part, but if we get into a habit of skipping test failures
    it will quickly bite you.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's make the appropriate change to force the null test to fail and then
    fix our "error:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We can now remove the skip attribute on the null test and then come back here
    and remove the null coalescing operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more test needed for `Get`. We must ensure the pointer for the
    returned speaker is not the same as the speaker in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This test is significantly harder to follow, but necessary. We first have to
    create a speaker. Then we retrieve the speaker we created, update the retrieved
    speaker's name, and  retrieve the speaker again. Finally, we verify that the modified
    speaker is not the same as the retrieved speaker. They should not be the same
    because we have not saved the data, so no updates should have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix for this issue has already been created and just needs to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we should refactor. Follow the same steps as you did for create and
    extract the repository creation into the constructor. The simplicity of this test
    class means it doesn't require any further refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Getting multiple speakers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting many speakers is much easier than getting a single speaker. We are not
    going to have to worry about not finding speakers. We are not going to have to
    handle any error conditions. All we have to test for is retrieving the correct
    number of speakers, and ensuring data safety the same as we have done for the
    other methods so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with retrieving all the speakers when there are no speakers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an easy fix in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Remember, we are playing devil's advocate; this is the correct response for
    its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to assert the type and size of the method''s response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: I know we have already mentioned the single assert rule and how it doesn't mean
    what it sounds like it means. This test is still following the rule because we
    are asserting that `GetAll` returns a non-null empty collection of speakers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test for a single speaker present in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, making the appropriate adjustment in the repository is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Next, we want to close off this line of testing by making sure that the speaker
    returned is the speaker we created. We expect this to pass right way because we
    already know that is the case. This assertion is important to ensure the future
    integrity of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Notice the change to the action. Executing a count and retrieving the first
    element in the collection both cause an enumeration. Enumerations equal CPU cycles.
    To reduce test time and production execution time, we want to reduce the number
    of enumerations. Converting the `IQueryable` to a list will enforce a single enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do one final test to ensure the proper return values and check that
    multiple speakers come back correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This test is just a sanity check and passes right away. Our next test is going
    to check data integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The update in the repository is similar to what we have done for the other
    methods with one exception. We are operating on an entire collection, instead
    of just a single item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of you may have seen this syntax before. What we have done is to pass
    the function pointer of the `CloneSpeaker` method in as the Lambda expression
    required by the `Select` method in linq. The preceding line is exactly the same,
    functionally, as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Time to clean up. We have the same clean-up steps as before. The only real refactoring
    needed is extracting the repository creation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a speaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now create and retrieve speakers. We have also ensured that we cannot
    update them by accident. So, let''s make sure we can update them on purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Playing devil''s advocate again, this is a simple update to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is clearly the wrong solution; let''s write another, more specific test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Making this test pass is a little tricky, but not too bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'However, making this change causes the exists test to fail. Looking at that
    test, it is failing for a good reason and should not really pass given our current
    understanding of how `Update` is supposed to work. Let''s make a small but significant
    update to that test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up on our testing timeline, is handling the error that was highlighted
    by the failure of the exists test. If someone asks to update a speaker that doesn''t
    exist, the repository blows up. This could be the required behavior, but it should
    blow up with an informative exception, not an index out of bounds exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'A `SpeakerNotFoundException` already exists within the system, but this comes
    from a different layer so we need to create a new exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, see if you can cover this exception with tests. Being able to
    work backwards and write tests after the fact, as we will discuss in upcoming
    chapters, is a valuable skill to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s continue and make this test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other tests, we must now ensure data integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We are bordering on test complexity that is too high. If these tests get much
    more complex, we will want to consider rethinking our approach. This test confirms
    what we thought: the returned speaker is not protected against change. Let''s
    fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'A fairly simple solution: just wrap the return with a `CloneSpeaker` call.
    Do you see another potential data integrity issue? What are we doing to protect
    against further changes to the speaker that was passed? Let''s write a test to
    ensure that changes after the fact to the speaker that was passed in don''t affect
    the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This test looks almost identical to the previous test. The only significant
    change is the action. Instead of changing the value on the `updatedSpeaker`, we
    are now changing the value on the original speaker. To make this test pass, the
    change to the repository is similar to the previous fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: All that is left to refactor and clean up are the tests and repository.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a speaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finally at the last method in this repository. For Speaker Meet, we don't
    really want to delete the speakers; we might flag a speaker as deleted, but we
    don't really want to remove them from the dataset. So, our `Delete` method will
    be more like an update.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have any strange behavior or constraints for `Delete`, so we should
    start with the failure case. What should happen if we ask to delete a user that
    doesn't exist? Should we throw an exception? In this case, we can actually just
    assume that the job is done. If there is no speaker with the given ID then the
    deletion of that speaker could be considered a success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, now that we have considered the failure case, we see that it does have
    special behavior that would cause the failure case to simply pass straight away.
    Let''s take a look at the success case and see if it would cause a failing test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Making this test pass should be fairly easy: we can just call into the local
    update method after changing the `isDeleted` flag to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to fix any other tests that fail as a result of adding this code,
    after making sure the failure is for a valid reason. If tests fail while we are
    writing more tests we need to check the requirements and make sure they are not
    in disagreement with each other. We never want to break existing requirements
    unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have to deal with what happens if the speaker didn''t exist in the context.
    As decided earlier, we are okay with just ignoring this request as a failure to
    delete a non-existing speaker results in the same situation as successfully deleting
    an existing speaker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass this one we have to do something that is normally not recommended or
    preferred. We have to swallow an exception. Before taking a step like this and
    ignoring an exception, make sure you only ignore a specific exception and make
    sure you have thought it through thoroughly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the last test for this method, we must make sure that we don''t accidently
    pollute the object that was passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the same method we have been using to ensure data integrity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Genericizing the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This repository is great, but do we really want to repeat this logic and all
    these tests for every single data model that we need to be retrieved from some
    data source? The answer is no; if you find yourself doing the same thing over
    and over as a developer, you are doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we protect ourselves from that drudgery?
  prefs: []
  type: TYPE_NORMAL
- en: One way is to use generics. Let's refactor the `SpeakerRepository` to use generics,
    this will also involve refactoring many of the tests to make them apply to the
    `GenericRepository` instead of the concrete `SpeakerRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: Step one – abstract interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `IRepository`, everywhere we use `Speaker` we need to replace it with
    C# generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This change will cause a break in the `SpeakerRepository` that we need to fix.
    Right now, we are chasing the compiler and leaning on it to tell us what we are
    breaking. Once the tests pass again, we will know we are back to good:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to make some changes in the SpeakerService as it is no longer able
    to reference a simple IRepository but instead needs an `IRepository<Speaker>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We must update the fake repository to use the correct generic repository type.
  prefs: []
  type: TYPE_NORMAL
- en: '`public class FakeRepository : IRepository<Speaker>`'
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, we have several tests that need to be updated. No secret code there;
    just update `IRepository` to `IRepository<Speaker>`.
  prefs: []
  type: TYPE_NORMAL
- en: Step two – abstract the concrete class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the interface is generic, we can start to work on the `SpeakerRepository`.
    First let''s rename it to `InMemorySpeakerRepository`. Now, we want to start using
    generics. Create a new class, `InMemoryRepository<T>` and have the speaker repository
    inherit from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In order to move slow and have the tests passing as much as possible, we are
    using abstract and will have to have each method in the speaker repository override
    the base class methods. This gives us the ability to move each method individually
    into the abstract as we discover what needs to be done, instead of trying to tackle
    the whole problem all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inherit from the in-memory repository and add override to each inherited method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Converting Create to a generic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin our generic method journey with `Create`. The first step is to
    copy the body of the `Create` method from the speaker repository to the generic
    repository. In order to do this, we must change the abstract `Create` method to
    a virtual `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Instantly, we run into trouble. We don't have a generic clone method. For now
    let's fake it until we make it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following protected abstract method to the generic repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make similar changes in the code we copied from the speaker repository''s
    `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Its''s looking much better now, but we still have one issue. We can''t expect
    `Id` to exist on just any object. The compiler is quite mad about this right now.
    There are several solutions, but we are going to create a simple data model interface
    and place a constraint on `T` that it must inherit from that interface. The only
    thing in the interface will be a property of `Id` with an integer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This causes a break in the speaker repository. We must also have Speaker inherit
    from `IIdentity`. Now, we have relocated all of the logic in the `Create` method
    into the generic repository. Delete the `Create` method in the speaker repository.
  prefs: []
  type: TYPE_NORMAL
- en: Many tests fail because we need to repoint the other methods in the speaker
    repository to use the backing objects from the generic repository. Go through
    the speaker repository and update all the references to Speakers to Entities,
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to make an adjustment to the `TestableSpeakerRepository` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Converting Get to a generic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next on the list is the `Get` method. Just like with the `Create` method, copy
    all the contents into the generic repository and fix any errors that occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: This method turns out to be an easy one to copy. Now, delete the existing method
    in the speaker repository. No tests break this time so we can move on to the next
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Converting GetAll to a generic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GetAll` is the easiest of the methods to convert. It doesn''t even reference
    speakers textually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Delete the existing method in the speaker repository and move on to the next
    method, update.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Update to a generic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The process for update is the same as with the other methods. Copy the body
    of the existing code, rename any speaker references to entity references, and
    then delete the existing method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Converting Delete to a generic method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Delete` is a different story: every object is likely to have different requirements
    for deleting it. Some will actually be deleted and others, such as Speaker, will
    merely be flagged as deleted. For this and many other reasons, we choose to leave
    the `Delete` implementation up to concrete repositories and the generic repository
    will throw a not implemented exception instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `Delete` test class just for this functionality. It should be
    short and quick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing this test also makes us change the generic repository from an abstract
    class to a normal class. Changing the class type makes us change the `CloneEntity`
    method from abstract to virtual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write the method that will pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Step three – reorient the tests to use the generic repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this process when we dealt with the `Delete` method. But let's continue
    with the other methods. All the methods that were moved into the generic repository
    can have most of their tests moved as well.
  prefs: []
  type: TYPE_NORMAL
- en: We will be leaving the data integrity tests because they are directly tied to
    the functionality in the speaker repository. We will leave all the delete tests
    for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: InMemoryRepository Create tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the rest of the functionality for the `InMemoryRepository`, we
    will start with the tests for the `Create` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: InMemoryRepository Get tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can create using the `InMemoryRepository`, we should be able to
    accurately test the `Get` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: InMemoryRepository GetAll tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With getting a single object working, lets test getting all the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: InMemoryRepository Update tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, we will add the ability to update records using the `InMemoryRepository:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: We now have a generic repository that can be used with any data model as long
    as that data model has an ID. We also have a way to ensure data integrity if we
    need to, by inheriting and creating a method to clone the data object that we
    need to protect.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Relation Mapping** (**ORM**) frameworks such as Entity Framework help
    increase productivity and optimize code reuse and maintainability. However, you
    should not tightly couple your application to the ORM. Abstract away ORMs such
    as Entity Framework just as you would any third-party library or system.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaker Meet uses Entity Framework through a generic repository; in order to
    get started, add a NuGet reference to Entity Framework – Sql Server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a connection string to the `appsettings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: DbContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest version of Entity Framework, EF Core 2.0, has added DbContext pooling,
    which helps improve performance by saving some of the cost of initializing a new
    instance of the `DbContext` with each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Startup.cs` ConfigureServices to reference the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `DbContext` to your application. Create a new file named `SpeakerMeetContext`
    with options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Entity Framework models may contain additional information that you might not
    necessarily want to expose to other parts of the system or application consumers.
    Create a new model named `Speaker`. This will be the model used by Entity Framework
    and the generic repository. The services or business layer will be responsible
    for converting the Entity Framework models to **Data Transfer Objects** (**DTOs**)
    or ViewModels used by the rest of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Generic repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to see the Entity Framework specific Generic repository run you may
    want to add the following class to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to wire everything up, the Speaker Meet application leverages the built
    in **Dependency Injection** (**DI**) container. Dependency Injection allows the
    system to be loosely coupled. There are ways to achieve this without the use of
    a container (poor man’s DI, and so on) which will be covered in a later chapter.
    The tests themselves do not rely on DI, instead opting to instantiate classes
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Wire it all up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to configure the DI container, add the following to ConfigureServices
    in `Startup.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: This will avoid the need to instantiate the `SpeakerService` from within the
    `SpeakerController`. The DI container handles this for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you've created your database and populated the speaker table, you now should
    be able to run the application and hit the `SpeakerController` endpoints. Give
    it a shot!
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:41436/api/speaker/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:41436/api/speaker/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:41436/api/speaker/search?searchString=test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a variety of tools available for manually exercising an API. Postman
    is just one such tool and is a favorite in the industry. Postman offers a lot
    of functionality to help you with your API development and testing. It's worth
    a look if you're interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Postman, simply visit the website ([http://www.getpostman.com](http://www.getpostman.com))
    and follow the instructions. With the Speaker Meet application running, enter
    the URL (example: `http://localhost:41436/api/speaker/search`) into the box, add
    params (example: `[{"key":"searchString","value":"te","description":""}]`), and
    hit Send. The response shows as JSON by default in the body of the message.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be an extremely powerful tool. As the complexity and feature set of
    the Speaker Meet API grows, more complex messages can be sent with `POST`, `PUT`,
    `PATCH`, and `DELETE`. These will be covered in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter was all about abstraction: when and how to use it. You should
    now see why it''s so important to create abstractions between code you write yourself
    and that of a third party. You should also have a good idea of how those abstractions
    can be achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we abstracted a Gravatar service, extended the repository pattern,
    and used a generic repository for Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](part0318.html#9F8IS0-d186949d2da74f5c95dd1712efae1195), *Testing
    JavaScript Applications*, we'll focus on testing JavaScript applications. We'll
    walk through creating a React application and discuss different approaches to
    testing a JavaScript application.
  prefs: []
  type: TYPE_NORMAL
