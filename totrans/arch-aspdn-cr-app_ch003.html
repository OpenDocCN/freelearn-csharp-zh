<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>2 Automated Testing</title>
<link href="../styles/stylesheet1.css" rel="stylesheet" type="text/css"/>
<link href="../styles/stylesheet2.css" rel="stylesheet" type="text/css"/>
<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>
<section class="level1 pkt" data-number="3" id="automated-testing">
<h1 data-number="3"><span class="koboSpan" id="kobo.1.1" xmlns="http://www.w3.org/1999/xhtml">2 Automated Testing</span></h1>
<section class="level2" data-number="3.1" id="before-you-begin-join-our-book-community-on-discord-1">
<h2 data-number="3.1"><span class="koboSpan" id="kobo.2.1" xmlns="http://www.w3.org/1999/xhtml">Before you begin: Join our book community on Discord</span></h2>
<p><span class="koboSpan" id="kobo.3.1" xmlns="http://www.w3.org/1999/xhtml">Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</span></p>
<p><a href="https://packt.link/EarlyAccess"><span class="koboSpan" id="kobo.4.1" xmlns="http://www.w3.org/1999/xhtml">https://packt.link/EarlyAccess</span></a></p>
<p><span class="koboSpan" id="kobo.5.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Qr code Description automatically generated" src="../media/file2.png" style="width:10em"/></span></p>
<p><span class="koboSpan" id="kobo.6.1" xmlns="http://www.w3.org/1999/xhtml">This chapter focuses on automated testing and how helpful it can be for crafting better software. </span><span class="koboSpan" id="kobo.6.2" xmlns="http://www.w3.org/1999/xhtml">It also covers a few different types of tests and the foundation of </span><strong><span class="koboSpan" id="kobo.7.1" xmlns="http://www.w3.org/1999/xhtml">test-driven development</span></strong><span class="koboSpan" id="kobo.8.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.9.1" xmlns="http://www.w3.org/1999/xhtml">TDD</span></strong><span class="koboSpan" id="kobo.10.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.10.2" xmlns="http://www.w3.org/1999/xhtml">We also outline how testable ASP.NET Core is and how much easier it is to test ASP.NET Core applications than old ASP.NET MVC applications. </span><span class="koboSpan" id="kobo.10.3" xmlns="http://www.w3.org/1999/xhtml">This chapter overviews automated testing, its principles, xUnit, ways to sample test values, and more. </span><span class="koboSpan" id="kobo.10.4" xmlns="http://www.w3.org/1999/xhtml">While other books cover this topic more in-depth, this chapter covers the foundational aspects of automated testing. </span><span class="koboSpan" id="kobo.10.5" xmlns="http://www.w3.org/1999/xhtml">We are using parts of this throughout the book, and this chapter ensures you have a strong enough base to understand the samples.In this chapter, we cover the following topics:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1" xmlns="http://www.w3.org/1999/xhtml">An overview of automated testing</span></li>
<li><span class="koboSpan" id="kobo.12.1" xmlns="http://www.w3.org/1999/xhtml">Testing .NET applications</span></li>
<li><span class="koboSpan" id="kobo.13.1" xmlns="http://www.w3.org/1999/xhtml">Important testing principles</span></li>
</ul>
</section>
<section class="level2" data-number="3.2" id="introduction-to-automated-testing">
<h2 data-number="3.2"><span class="koboSpan" id="kobo.14.1" xmlns="http://www.w3.org/1999/xhtml">Introduction to automated testing</span></h2>
<p><span class="koboSpan" id="kobo.15.1" xmlns="http://www.w3.org/1999/xhtml">Testing is an integral part of the development process, and automated testing becomes crucial in the long run. </span><span class="koboSpan" id="kobo.15.2" xmlns="http://www.w3.org/1999/xhtml">You can always run your ASP.NET Core website, open a browser, and click everywhere to test your features. </span><span class="koboSpan" id="kobo.15.3" xmlns="http://www.w3.org/1999/xhtml">That’s a legitimate approach, but it is harder to test individual rules or more complex algorithms that way. </span><span class="koboSpan" id="kobo.15.4" xmlns="http://www.w3.org/1999/xhtml">Another downside is the lack of automation; when you first start with a small app containing a few pages, endpoints, or features, it may be fast to perform those tests manually. </span><span class="koboSpan" id="kobo.15.5" xmlns="http://www.w3.org/1999/xhtml">However, as your app grows, it becomes more tedious, takes longer, and increases the likelihood of making a mistake. </span><span class="koboSpan" id="kobo.15.6" xmlns="http://www.w3.org/1999/xhtml">Of course, you will always need real users to test your applications, but you want those tests to focus on the UX, the content, or some experimental features you are building instead of bug reports that automated tests could have caught early on.There are multiple types of tests and techniques in the testing space. </span><span class="koboSpan" id="kobo.15.7" xmlns="http://www.w3.org/1999/xhtml">Here is a list of three broad categories that represent how we can divide automated testing from a code correctness standpoint:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1" xmlns="http://www.w3.org/1999/xhtml">Unit tests</span></li>
<li><span class="koboSpan" id="kobo.17.1" xmlns="http://www.w3.org/1999/xhtml">Integration tests</span></li>
<li><span class="koboSpan" id="kobo.18.1" xmlns="http://www.w3.org/1999/xhtml">End-to-end (E2E) tests</span></li>
</ul>
<p><span class="koboSpan" id="kobo.19.1" xmlns="http://www.w3.org/1999/xhtml">Usually, you want a mix of those tests, so you have fast unit tests testing your algorithms, slower tests that ensure the integrations between components are correct, and slow E2E tests that ensure the correctness of the system as a whole.The test pyramid is a good way of explaining a few concepts around automated testing. </span><span class="koboSpan" id="kobo.19.2" xmlns="http://www.w3.org/1999/xhtml">You want different granularity of tests and a different number of tests depending on their complexity and speed of execution. </span><span class="koboSpan" id="kobo.19.3" xmlns="http://www.w3.org/1999/xhtml">The following test pyramid shows the three types of tests stated above. </span><span class="koboSpan" id="kobo.19.4" xmlns="http://www.w3.org/1999/xhtml">However, we could add other types of tests in there as well. </span><span class="koboSpan" id="kobo.19.5" xmlns="http://www.w3.org/1999/xhtml">Moreover, that’s just an abstract guideline to give you an idea. </span><span class="koboSpan" id="kobo.19.6" xmlns="http://www.w3.org/1999/xhtml">The most important aspect is the </span><strong><span class="koboSpan" id="kobo.20.1" xmlns="http://www.w3.org/1999/xhtml">return on investment</span></strong><span class="koboSpan" id="kobo.21.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.22.1" xmlns="http://www.w3.org/1999/xhtml">ROI</span></strong><span class="koboSpan" id="kobo.23.1" xmlns="http://www.w3.org/1999/xhtml">) and execution speed. </span><span class="koboSpan" id="kobo.23.2" xmlns="http://www.w3.org/1999/xhtml">If you can write one integration test that covers a large surface and is fast enough, this might be worth doing instead of multiple unit tests.</span></p>
<figure>
<span class="koboSpan" id="kobo.24.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.1: The test pyramid" src="../media/file3.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.25.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.1: The test pyramid</span></figcaption>
</figure>
<blockquote>
<p><span class="koboSpan" id="kobo.26.1" xmlns="http://www.w3.org/1999/xhtml">I cannot stress this enough; the execution speed of your tests is essential to receive fast feedback and know immediately that you have broken something with your code changes. </span><span class="koboSpan" id="kobo.26.2" xmlns="http://www.w3.org/1999/xhtml">Layering different types of tests allows you to execute only the fastest subset often, the not-so-fast occasionally, and the very slow tests infrequently. </span><span class="koboSpan" id="kobo.26.3" xmlns="http://www.w3.org/1999/xhtml">If your test suite is fast-enough, you don’t even have to worry about it. </span><span class="koboSpan" id="kobo.26.4" xmlns="http://www.w3.org/1999/xhtml">However, if you have a lot of manual or E2E UI tests that take hours to run, that’s another story (that can cost a lot of money).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.27.1" xmlns="http://www.w3.org/1999/xhtml">Finally, on top of running your tests using a test runner, like in Visual Studio, VS Code, or the CLI, a great way to ensure code quality and leverage your automated tests is to run them in a CI pipeline, validating code changes for issues.Tech-wise, back when .NET Core was in pre-release, I discovered that the .NET team was using xUnit to test their code and that it was the only testing framework available. </span><span class="koboSpan" id="kobo.27.2" xmlns="http://www.w3.org/1999/xhtml">xUnit has become my favorite testing framework since, and we use it throughout the book. </span><span class="koboSpan" id="kobo.27.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, the ASP.NET Core team made our life easier by designing ASP.NET Core for testability; testing is easier than before.Why are we talking about tests in an architectural book? </span><span class="koboSpan" id="kobo.27.4" xmlns="http://www.w3.org/1999/xhtml">Because testability is a sign of a good design. </span><span class="koboSpan" id="kobo.27.5" xmlns="http://www.w3.org/1999/xhtml">It also allows us to use tests instead of words to prove some concepts. </span><span class="koboSpan" id="kobo.27.6" xmlns="http://www.w3.org/1999/xhtml">In many code samples, the test cases are the consumers, making the program lighter without building an entire user interface and focusing on the patterns we are exploring instead of getting our focus scattered over some boilerplate UI code.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.28.1" xmlns="http://www.w3.org/1999/xhtml">To ensure we do not deviate from the matter at hand, we use automated testing moderately in the book, but I strongly recommend that you continue to study it, as it will help improve your code and design</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.29.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have covered all that, let’s explore those three types of tests, starting with unit testing.</span></p>
<section class="level3" data-number="3.2.1" id="unit-testing">
<h3 data-number="3.2.1"><span class="koboSpan" id="kobo.30.1" xmlns="http://www.w3.org/1999/xhtml">Unit testing</span></h3>
<p><span class="koboSpan" id="kobo.31.1" xmlns="http://www.w3.org/1999/xhtml">Unit tests focus on individual units, like testing the outcome of a method. </span><span class="koboSpan" id="kobo.31.2" xmlns="http://www.w3.org/1999/xhtml">Unit tests should be fast and not rely on any infrastructure, such as a database. </span><span class="koboSpan" id="kobo.31.3" xmlns="http://www.w3.org/1999/xhtml">Those are the kinds of tests you want the most because they run fast, and each one tests a precise code path. </span><span class="koboSpan" id="kobo.31.4" xmlns="http://www.w3.org/1999/xhtml">They should also help you design your application better because you use your code in the tests, so you become its first consumer, leading to you finding some design flaws and making your code better. </span><span class="koboSpan" id="kobo.31.5" xmlns="http://www.w3.org/1999/xhtml">If you don’t like using your code in your tests, that is a good indicator that nobody else will. </span><span class="koboSpan" id="kobo.31.6" xmlns="http://www.w3.org/1999/xhtml">Unit tests should focus on testing algorithms (the ins and outs) and domain logic, not the code itself; how you wrote the code should have no impact on the intent of the test. </span><span class="koboSpan" id="kobo.31.7" xmlns="http://www.w3.org/1999/xhtml">For example, you are testing that a </span><code><span class="koboSpan" id="kobo.32.1" xmlns="http://www.w3.org/1999/xhtml">Purchase</span></code><span class="koboSpan" id="kobo.33.1" xmlns="http://www.w3.org/1999/xhtml"> method executes the logic required to purchase one or more items, not that you created the variable </span><code><span class="koboSpan" id="kobo.34.1" xmlns="http://www.w3.org/1999/xhtml">X</span></code><span class="koboSpan" id="kobo.35.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.36.1" xmlns="http://www.w3.org/1999/xhtml">Y</span></code><span class="koboSpan" id="kobo.37.1" xmlns="http://www.w3.org/1999/xhtml">, or </span><code><span class="koboSpan" id="kobo.38.1" xmlns="http://www.w3.org/1999/xhtml">Z</span></code><span class="koboSpan" id="kobo.39.1" xmlns="http://www.w3.org/1999/xhtml"> inside that method.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.40.1" xmlns="http://www.w3.org/1999/xhtml">Don’t discourage yourself if you find it challenging; writing a good test suite is not as easy as it sounds.</span></p>
</blockquote>
</section>
<section class="level3" data-number="3.2.2" id="integration-testing">
<h3 data-number="3.2.2"><span class="koboSpan" id="kobo.41.1" xmlns="http://www.w3.org/1999/xhtml">Integration testing</span></h3>
<p><span class="koboSpan" id="kobo.42.1" xmlns="http://www.w3.org/1999/xhtml">Integration tests focus on the interaction between components, such as what happens when a component queries the database or what happens when two components interact with each other.Integration tests often require some infrastructure to interact with, which makes them slower to run. </span><span class="koboSpan" id="kobo.42.2" xmlns="http://www.w3.org/1999/xhtml">By following the classic testing model, you want integration tests, but you want fewer of them than unit tests. </span><span class="koboSpan" id="kobo.42.3" xmlns="http://www.w3.org/1999/xhtml">An integration test can be very close to an E2E test but without using a production-like environment.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.43.1" xmlns="http://www.w3.org/1999/xhtml">We will break the test pyramid rule later, so always be critical of rules and principles; sometimes, breaking or bending them can be better. </span><span class="koboSpan" id="kobo.43.2" xmlns="http://www.w3.org/1999/xhtml">For example, having one good integration test can be better than </span><em><span class="koboSpan" id="kobo.44.1" xmlns="http://www.w3.org/1999/xhtml">N</span></em><span class="koboSpan" id="kobo.45.1" xmlns="http://www.w3.org/1999/xhtml"> unit tests; don’t discard that fact when writing your tests. </span><span class="koboSpan" id="kobo.45.2" xmlns="http://www.w3.org/1999/xhtml">See also Grey-box testing.</span></p>
</blockquote>
</section>
<section class="level3" data-number="3.2.3" id="end-to-end-testing">
<h3 data-number="3.2.3"><span class="koboSpan" id="kobo.46.1" xmlns="http://www.w3.org/1999/xhtml">End-to-end testing</span></h3>
<p><span class="koboSpan" id="kobo.47.1" xmlns="http://www.w3.org/1999/xhtml">End-to-end tests focus on application-wide behaviors, such as what happens when a user clicks on a specific button, navigates to a particular page, posts a form, or sends a </span><code><span class="koboSpan" id="kobo.48.1" xmlns="http://www.w3.org/1999/xhtml">PUT</span></code><span class="koboSpan" id="kobo.49.1" xmlns="http://www.w3.org/1999/xhtml"> request to some web API endpoint. </span><span class="koboSpan" id="kobo.49.2" xmlns="http://www.w3.org/1999/xhtml">E2E tests are usually run on infrastructure to test your application and deployment.</span></p>
</section>
<section class="level3" data-number="3.2.4" id="other-types-of-tests">
<h3 data-number="3.2.4"><span class="koboSpan" id="kobo.50.1" xmlns="http://www.w3.org/1999/xhtml">Other types of tests</span></h3>
<p><span class="koboSpan" id="kobo.51.1" xmlns="http://www.w3.org/1999/xhtml">There are other types of automated tests. </span><span class="koboSpan" id="kobo.51.2" xmlns="http://www.w3.org/1999/xhtml">For example, we could do load testing, performance testing, regression testing, contract testing, penetration testing, functional testing, smoke testing, and more. </span><span class="koboSpan" id="kobo.51.3" xmlns="http://www.w3.org/1999/xhtml">You can automate tests for anything you want to validate, but some tests are more challenging to automate or more fragile than others, such as UI tests.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.52.1" xmlns="http://www.w3.org/1999/xhtml">If you can automate a test in a reasonable timeframe, think ROI: do it! </span><span class="koboSpan" id="kobo.52.2" xmlns="http://www.w3.org/1999/xhtml">In the long run, it should pay off.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.53.1" xmlns="http://www.w3.org/1999/xhtml">One more thing; don’t blindly rely on metrics such as code coverage. </span><span class="koboSpan" id="kobo.53.2" xmlns="http://www.w3.org/1999/xhtml">Those metrics make for cute badges in your GitHub project’s </span><code><span class="koboSpan" id="kobo.54.1" xmlns="http://www.w3.org/1999/xhtml">readme.md</span></code><span class="koboSpan" id="kobo.55.1" xmlns="http://www.w3.org/1999/xhtml"> file but can lead you off track, resulting in you writing useless tests. </span><span class="koboSpan" id="kobo.55.2" xmlns="http://www.w3.org/1999/xhtml">Don’t get me wrong, code coverage is a great metric when used correctly, but remember that one good test can be better than a lousy test suite covering 100% of your codebase. </span><span class="koboSpan" id="kobo.55.3" xmlns="http://www.w3.org/1999/xhtml">If you are using code coverage, ensure you and your team are not gaming the system.Writing good tests is not easy and comes with practice.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.56.1" xmlns="http://www.w3.org/1999/xhtml">One piece of advice: keep your test suite healthy by adding missing test cases and removing obsolete or useless tests. </span><span class="koboSpan" id="kobo.56.2" xmlns="http://www.w3.org/1999/xhtml">Think about use case coverage, not how many lines of code are covered by your tests.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.57.1" xmlns="http://www.w3.org/1999/xhtml">Before moving forward to testing styles, let’s inspect a hypothetical system and explore a more efficient way to test it.</span></p>
</section>
<section class="level3" data-number="3.2.5" id="picking-the-right-test-style">
<h3 data-number="3.2.5"><span class="koboSpan" id="kobo.58.1" xmlns="http://www.w3.org/1999/xhtml">Picking the right test style</span></h3>
<p><span class="koboSpan" id="kobo.59.1" xmlns="http://www.w3.org/1999/xhtml">Next is a dependency map of a hypothetical system. </span><span class="koboSpan" id="kobo.59.2" xmlns="http://www.w3.org/1999/xhtml">We use that diagram to pick the most meaningful type of test possible for each piece of the program. </span><span class="koboSpan" id="kobo.59.3" xmlns="http://www.w3.org/1999/xhtml">In real life, that diagram will most likely be in your head, but I drew it out in this case. </span><span class="koboSpan" id="kobo.59.4" xmlns="http://www.w3.org/1999/xhtml">Let’s inspect that diagram before I explain its content:</span></p>
<figure>
<span class="koboSpan" id="kobo.60.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.2: Dependency map of a hypothetical system" src="../media/file4.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.61.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.2: Dependency map of a hypothetical system</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.62.1" xmlns="http://www.w3.org/1999/xhtml">In the diagram, the </span><strong><span class="koboSpan" id="kobo.63.1" xmlns="http://www.w3.org/1999/xhtml">Actor</span></strong><span class="koboSpan" id="kobo.64.1" xmlns="http://www.w3.org/1999/xhtml"> can be anything from a user to another system. </span><strong><span class="koboSpan" id="kobo.65.1" xmlns="http://www.w3.org/1999/xhtml">Presentation</span></strong><span class="koboSpan" id="kobo.66.1" xmlns="http://www.w3.org/1999/xhtml"> is the piece of the system that the </span><strong><span class="koboSpan" id="kobo.67.1" xmlns="http://www.w3.org/1999/xhtml">Actor</span></strong><span class="koboSpan" id="kobo.68.1" xmlns="http://www.w3.org/1999/xhtml"> interacts with and forwards the request to the system itself (this could be a user interface). </span><strong><span class="koboSpan" id="kobo.69.1" xmlns="http://www.w3.org/1999/xhtml">D1</span></strong><span class="koboSpan" id="kobo.70.1" xmlns="http://www.w3.org/1999/xhtml"> is a component that has to decide what to do next based on the user input. </span><strong><span class="koboSpan" id="kobo.71.1" xmlns="http://www.w3.org/1999/xhtml">C1</span></strong><span class="koboSpan" id="kobo.72.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><strong><span class="koboSpan" id="kobo.73.1" xmlns="http://www.w3.org/1999/xhtml">C6</span></strong><span class="koboSpan" id="kobo.74.1" xmlns="http://www.w3.org/1999/xhtml"> are other components of the system (could be classes, for example). </span><strong><span class="koboSpan" id="kobo.75.1" xmlns="http://www.w3.org/1999/xhtml">DB</span></strong><span class="koboSpan" id="kobo.76.1" xmlns="http://www.w3.org/1999/xhtml"> is a database.D1 must choose between three code paths: interact with the components C1, C4, or C6. </span><span class="koboSpan" id="kobo.76.2" xmlns="http://www.w3.org/1999/xhtml">This type of logic is usually a good subject for unit tests, ensuring the algorithm yields the correct result based on the input parameter. </span><span class="koboSpan" id="kobo.76.3" xmlns="http://www.w3.org/1999/xhtml">Why pick a unit test? </span><span class="koboSpan" id="kobo.76.4" xmlns="http://www.w3.org/1999/xhtml">We can quickly test multiple scenarios, edge cases, out-of-bound data cases, and more. </span><span class="koboSpan" id="kobo.76.5" xmlns="http://www.w3.org/1999/xhtml">We usually mock the dependencies away in this type of test and assert that the subject under test made the expected call on the desired component.Then, if we look at the other code paths, we could write one or more integration tests for component C1, testing the whole chain in one go (C1, C5, and C3) instead of writing multiple mock-heavy unit tests for each component. </span><span class="koboSpan" id="kobo.76.6" xmlns="http://www.w3.org/1999/xhtml">If there is any logic that we need to test in components C1, C5, or C3, we can always add a few unit tests; that’s what they are for.Finally, C4 and C6 are both using C2. </span><span class="koboSpan" id="kobo.76.7" xmlns="http://www.w3.org/1999/xhtml">Depending on the code (that we don’t have here), we could write integration tests for C4 and C6, testing C2 simultaneously. </span><span class="koboSpan" id="kobo.76.8" xmlns="http://www.w3.org/1999/xhtml">Another way would be to unit test C4 and C6, and then write integration tests between C2 and the DB. </span><span class="koboSpan" id="kobo.76.9" xmlns="http://www.w3.org/1999/xhtml">If C2 has no logic, the latter could be the best and the fastest, while the former will most likely yield results that give you more confidence in your test suite in a continuous delivery model.When it is an option, I recommend evaluating the possibility of writing fewer meaningful integration tests that assert the correctness of a use case over a suite of mock-heavy unit tests. </span><span class="koboSpan" id="kobo.76.10" xmlns="http://www.w3.org/1999/xhtml">Remember always to keep the execution speed in mind.That may seem to go “against” the test pyramid, but does it? </span><span class="koboSpan" id="kobo.76.11" xmlns="http://www.w3.org/1999/xhtml">If you spend less time (thus lower costs) testing more use cases (adding more value), that sounds like a win to me. </span><span class="koboSpan" id="kobo.76.12" xmlns="http://www.w3.org/1999/xhtml">Moreover, we must not forget that mocking dependencies tends to make you waste time fighting the framework or other libraries instead of testing something meaningful and can add up to a high maintenance cost over time.Now that we have explored the fundamentals of automated testing, it is time to explore testing approaches and TDD, which is a way to apply those testing concepts.</span></p>
</section>
</section>
<section class="level2" data-number="3.3" id="testing-approaches">
<h2 data-number="3.3"><span class="koboSpan" id="kobo.77.1" xmlns="http://www.w3.org/1999/xhtml">Testing approaches</span></h2>
<p><span class="koboSpan" id="kobo.78.1" xmlns="http://www.w3.org/1999/xhtml">There are various approaches to testing, such as </span><strong><span class="koboSpan" id="kobo.79.1" xmlns="http://www.w3.org/1999/xhtml">behavior-driven development</span></strong><span class="koboSpan" id="kobo.80.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.81.1" xmlns="http://www.w3.org/1999/xhtml">BDD</span></strong><span class="koboSpan" id="kobo.82.1" xmlns="http://www.w3.org/1999/xhtml">), </span><strong><span class="koboSpan" id="kobo.83.1" xmlns="http://www.w3.org/1999/xhtml">acceptance test-driven development</span></strong><span class="koboSpan" id="kobo.84.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.85.1" xmlns="http://www.w3.org/1999/xhtml">ATDD</span></strong><span class="koboSpan" id="kobo.86.1" xmlns="http://www.w3.org/1999/xhtml">), and </span><strong><span class="koboSpan" id="kobo.87.1" xmlns="http://www.w3.org/1999/xhtml">test-driven development</span></strong><span class="koboSpan" id="kobo.88.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.89.1" xmlns="http://www.w3.org/1999/xhtml">TDD)</span></strong><span class="koboSpan" id="kobo.90.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.90.2" xmlns="http://www.w3.org/1999/xhtml">The DevOps culture brings a mindset that embraces automated testing in line with its </span><strong><span class="koboSpan" id="kobo.91.1" xmlns="http://www.w3.org/1999/xhtml">continuous integration</span></strong><span class="koboSpan" id="kobo.92.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.93.1" xmlns="http://www.w3.org/1999/xhtml">CI</span></strong><span class="koboSpan" id="kobo.94.1" xmlns="http://www.w3.org/1999/xhtml">) and </span><strong><span class="koboSpan" id="kobo.95.1" xmlns="http://www.w3.org/1999/xhtml">continuous deployment</span></strong><span class="koboSpan" id="kobo.96.1" xmlns="http://www.w3.org/1999/xhtml"> (</span><strong><span class="koboSpan" id="kobo.97.1" xmlns="http://www.w3.org/1999/xhtml">CD</span></strong><span class="koboSpan" id="kobo.98.1" xmlns="http://www.w3.org/1999/xhtml">) ideals. </span><span class="koboSpan" id="kobo.98.2" xmlns="http://www.w3.org/1999/xhtml">We can enable CD with a robust and healthy suite of tests that gives a high degree of confidence in our code, high enough to deploy the program when all tests pass without fear of introducing a bug.</span></p>
<section class="level3" data-number="3.3.1" id="tdd">
<h3 data-number="3.3.1"><span class="koboSpan" id="kobo.99.1" xmlns="http://www.w3.org/1999/xhtml">TDD</span></h3>
<p><span class="koboSpan" id="kobo.100.1" xmlns="http://www.w3.org/1999/xhtml">TDD is a software development method that states that you should write one or more tests before writing the actual code. </span><span class="koboSpan" id="kobo.100.2" xmlns="http://www.w3.org/1999/xhtml">In a nutshell, you invert your development flow by following the </span><strong><span class="koboSpan" id="kobo.101.1" xmlns="http://www.w3.org/1999/xhtml">Red-Green-Refactor</span></strong><span class="koboSpan" id="kobo.102.1" xmlns="http://www.w3.org/1999/xhtml"> technique, which goes like this:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.103.1" xmlns="http://www.w3.org/1999/xhtml">You write a failing test (red).</span></li>
<li><span class="koboSpan" id="kobo.104.1" xmlns="http://www.w3.org/1999/xhtml">You write just enough code to make your test pass (green).</span></li>
<li><span class="koboSpan" id="kobo.105.1" xmlns="http://www.w3.org/1999/xhtml">You refactor that code to improve the design by ensuring all the tests pass.</span></li>
</ol>
<blockquote>
<p><span class="koboSpan" id="kobo.106.1" xmlns="http://www.w3.org/1999/xhtml">We explore the meaning of </span><strong><span class="koboSpan" id="kobo.107.1" xmlns="http://www.w3.org/1999/xhtml">refactoring</span></strong><span class="koboSpan" id="kobo.108.1" xmlns="http://www.w3.org/1999/xhtml"> next.</span></p>
</blockquote>
</section>
<section class="level3" data-number="3.3.2" id="atdd">
<h3 data-number="3.3.2"><span class="koboSpan" id="kobo.109.1" xmlns="http://www.w3.org/1999/xhtml">ATDD</span></h3>
<p><span class="koboSpan" id="kobo.110.1" xmlns="http://www.w3.org/1999/xhtml">ATDD is similar to TDD but focuses on acceptance (or functional) tests instead of software units and involves multiple parties like customers, developers, and testers.</span></p>
</section>
<section class="level3" data-number="3.3.3" id="bdd">
<h3 data-number="3.3.3"><span class="koboSpan" id="kobo.111.1" xmlns="http://www.w3.org/1999/xhtml">BDD</span></h3>
<p><span class="koboSpan" id="kobo.112.1" xmlns="http://www.w3.org/1999/xhtml">BDD is another complementary technique originating from TDD and ATDD. </span><span class="koboSpan" id="kobo.112.2" xmlns="http://www.w3.org/1999/xhtml">BDD focuses on formulating test cases around application behaviors using spoken language and involves multiple parties like customers, developers, and testers. </span><span class="koboSpan" id="kobo.112.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, practitioners of BDD often leverage the </span><em><span class="koboSpan" id="kobo.113.1" xmlns="http://www.w3.org/1999/xhtml">given–when–then</span></em><span class="koboSpan" id="kobo.114.1" xmlns="http://www.w3.org/1999/xhtml"> grammar to formalize their test cases. </span><span class="koboSpan" id="kobo.114.2" xmlns="http://www.w3.org/1999/xhtml">Because of that, BDD output is in a human-readable format allowing stakeholders to consult such artifacts.The given–when–then template defines the way to describe the behavior of a user story or acceptance test, like this:</span></p>
<ul>
<li><em><span class="koboSpan" id="kobo.115.1" xmlns="http://www.w3.org/1999/xhtml">Given</span></em><span class="koboSpan" id="kobo.116.1" xmlns="http://www.w3.org/1999/xhtml"> one or more preconditions (context)</span></li>
<li><em><span class="koboSpan" id="kobo.117.1" xmlns="http://www.w3.org/1999/xhtml">When</span></em><span class="koboSpan" id="kobo.118.1" xmlns="http://www.w3.org/1999/xhtml"> something happens (behavior)</span></li>
<li><em><span class="koboSpan" id="kobo.119.1" xmlns="http://www.w3.org/1999/xhtml">Then</span></em><span class="koboSpan" id="kobo.120.1" xmlns="http://www.w3.org/1999/xhtml"> one or more observable changes are expected (measurable side effects)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1" xmlns="http://www.w3.org/1999/xhtml">ATDD and BDD are great areas to dig deeper into and can help design better apps; defining precise user-centric specifications can help build only what is needed, prioritize better, and improve communication between parties. </span><span class="koboSpan" id="kobo.121.2" xmlns="http://www.w3.org/1999/xhtml">For the sake of simplicity, we stick to unit testing, integration testing, and a tad of TDD in the book. </span><span class="koboSpan" id="kobo.121.3" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, let’s go back to the main track and define refactoring.</span></p>
</section>
<section class="level3" data-number="3.3.4" id="refactoring">
<h3 data-number="3.3.4"><span class="koboSpan" id="kobo.122.1" xmlns="http://www.w3.org/1999/xhtml">Refactoring</span></h3>
<p><span class="koboSpan" id="kobo.123.1" xmlns="http://www.w3.org/1999/xhtml">Refactoring is about (continually) improving the code without changing its behavior.An automated test suite should help you achieve that goal and should help you discover when you break something. </span><span class="koboSpan" id="kobo.123.2" xmlns="http://www.w3.org/1999/xhtml">No matter whether you do TDD or not, I do recommend refactoring as often as possible; this helps clean your codebase, and it should also help you get rid of some technical debt at the same time.Okay, but what is </span><strong><span class="koboSpan" id="kobo.124.1" xmlns="http://www.w3.org/1999/xhtml">technical debt</span></strong><span class="koboSpan" id="kobo.125.1" xmlns="http://www.w3.org/1999/xhtml">?</span></p>
</section>
<section class="level3" data-number="3.3.5" id="technical-debt">
<h3 data-number="3.3.5"><span class="koboSpan" id="kobo.126.1" xmlns="http://www.w3.org/1999/xhtml">Technical debt</span></h3>
<p><strong><span class="koboSpan" id="kobo.127.1" xmlns="http://www.w3.org/1999/xhtml">Technical debt</span></strong><span class="koboSpan" id="kobo.128.1" xmlns="http://www.w3.org/1999/xhtml"> represents the corners you cut short while developing a feature or a system. </span><span class="koboSpan" id="kobo.128.2" xmlns="http://www.w3.org/1999/xhtml">That happens no matter how hard you try because life is life, and there are delays, deadlines, budgets, and people, including developers (yes, that’s you and me).The most crucial point is understanding that you cannot avoid technical debt altogether, so it’s better to embrace that fact and learn to live with it instead of fighting it. </span><span class="koboSpan" id="kobo.128.3" xmlns="http://www.w3.org/1999/xhtml">From that point forward, you can only try to limit the amount of technical debt you, or someone else, generate and ensure to always refactor some of it over time each sprint (or the unit of time that fits your projects/team/process).One way to limit the piling up of technical debt is to refactor the code often. </span><span class="koboSpan" id="kobo.128.4" xmlns="http://www.w3.org/1999/xhtml">So, factor the refactoring time into your time estimates. </span><span class="koboSpan" id="kobo.128.5" xmlns="http://www.w3.org/1999/xhtml">Another way is to improve collaboration between all the parties involved. </span><span class="koboSpan" id="kobo.128.6" xmlns="http://www.w3.org/1999/xhtml">Everyone must work toward the same goal if you want your projects to succeed.You will sometimes cut the usage of best practices short due to external forces like people or time constraints. </span><span class="koboSpan" id="kobo.128.7" xmlns="http://www.w3.org/1999/xhtml">The key is coming back at it as soon as possible to repay that technical debt, and automated tests are there to help you refactor that code and eliminate that debt elegantly. </span><span class="koboSpan" id="kobo.128.8" xmlns="http://www.w3.org/1999/xhtml">Depending on the size of your workplace, there will be more or less people between you and that decision.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.129.1" xmlns="http://www.w3.org/1999/xhtml">Some of these things might be out of your control, so you may have to live with more technical debt than you had hoped. </span><span class="koboSpan" id="kobo.129.2" xmlns="http://www.w3.org/1999/xhtml">However, even when things are out of your control, nothing stops you from becoming a pioneer and working toward improving the enterprise’s culture. </span><span class="koboSpan" id="kobo.129.3" xmlns="http://www.w3.org/1999/xhtml">Don’t be afraid to become an agent of change and lead the charge.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.130.1" xmlns="http://www.w3.org/1999/xhtml">Nevertheless, don’t let the technical debt pile up too high, or you may not be able to pay it back, and at some point, that’s where a project begins to break and fail. </span><span class="koboSpan" id="kobo.130.2" xmlns="http://www.w3.org/1999/xhtml">Don’t be mistaken; a project in production can be a failure. </span><span class="koboSpan" id="kobo.130.3" xmlns="http://www.w3.org/1999/xhtml">Delivering a product does not guarantee success, and I’m talking about the quality of the code here, not the amount of generated revenue (I’ll leave that to other people to evaluate).Next, we look at different ways to write tests, requiring more or less knowledge of the inner working of the code.</span></p>
</section>
</section>
<section class="level2" data-number="3.4" id="testing-techniques">
<h2 data-number="3.4"><span class="koboSpan" id="kobo.131.1" xmlns="http://www.w3.org/1999/xhtml">Testing techniques</span></h2>
<p><span class="koboSpan" id="kobo.132.1" xmlns="http://www.w3.org/1999/xhtml">Here we look at different ways to approach our tests. </span><span class="koboSpan" id="kobo.132.2" xmlns="http://www.w3.org/1999/xhtml">Should we know the code? </span><span class="koboSpan" id="kobo.132.3" xmlns="http://www.w3.org/1999/xhtml">Should we test user inputs and compare them against the system results? </span><span class="koboSpan" id="kobo.132.4" xmlns="http://www.w3.org/1999/xhtml">How to identify a proper value sample? </span><span class="koboSpan" id="kobo.132.5" xmlns="http://www.w3.org/1999/xhtml">Let’s start with white-box testing.</span></p>
<section class="level3" data-number="3.4.1" id="white-box-testing">
<h3 data-number="3.4.1"><span class="koboSpan" id="kobo.133.1" xmlns="http://www.w3.org/1999/xhtml">White-box testing</span></h3>
<p><span class="koboSpan" id="kobo.134.1" xmlns="http://www.w3.org/1999/xhtml">White-box testing is a software testing technique that uses knowledge of the internal structure of the software to design tests. </span><span class="koboSpan" id="kobo.134.2" xmlns="http://www.w3.org/1999/xhtml">We can use white-box testing to find defects in the software’s logic, data structures, and algorithms. </span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.135.1" xmlns="http://www.w3.org/1999/xhtml">This type of testing is also known as clear-box testing, open-box testing, transparent-box testing, glass-box testing, and code-based testing.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.136.1" xmlns="http://www.w3.org/1999/xhtml">Another benefit of white-box testing is that it can help optimize the code. </span><span class="koboSpan" id="kobo.136.2" xmlns="http://www.w3.org/1999/xhtml">By reviewing the code to write tests, developers can identify and improve inefficient code structures, improving overall software performance. </span><span class="koboSpan" id="kobo.136.3" xmlns="http://www.w3.org/1999/xhtml">The developer can also improve the application design by finding architectural issues while testing the code.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.137.1" xmlns="http://www.w3.org/1999/xhtml">White-box testing encompasses most unit and integration tests.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.138.1" xmlns="http://www.w3.org/1999/xhtml">Next, we look at black-box testing, the opposite of white-box testing.</span></p>
</section>
<section class="level3" data-number="3.4.2" id="black-box-testing">
<h3 data-number="3.4.2"><span class="koboSpan" id="kobo.139.1" xmlns="http://www.w3.org/1999/xhtml">Black-box testing</span></h3>
<p><span class="koboSpan" id="kobo.140.1" xmlns="http://www.w3.org/1999/xhtml">Black-box testing is a software testing method where a tester examines an application’s functionality without knowing the internal structure or implementation details. </span><span class="koboSpan" id="kobo.140.2" xmlns="http://www.w3.org/1999/xhtml">This form of testing focuses solely on the inputs and outputs of the system under test, treating the software as a “black box” that we can’t see into.The main goal of black-box testing is to evaluate the system’s behavior against expected results based on requirements or user stories. </span><span class="koboSpan" id="kobo.140.3" xmlns="http://www.w3.org/1999/xhtml">Developers writing the tests do not need to know the codebase or the technology stack used to build the software.We can use black-box testing to assess the correctness of several types of requirements, like:</span></p>
<ol>
<li><strong><span class="koboSpan" id="kobo.141.1" xmlns="http://www.w3.org/1999/xhtml">Functional testing</span></strong><span class="koboSpan" id="kobo.142.1" xmlns="http://www.w3.org/1999/xhtml">: This type of testing is related to the software’s functional requirements, emphasizing what the system does, a.k.a. </span><span class="koboSpan" id="kobo.142.2" xmlns="http://www.w3.org/1999/xhtml">behavior verification.</span></li>
<li><strong><span class="koboSpan" id="kobo.143.1" xmlns="http://www.w3.org/1999/xhtml">Non-functional testing</span></strong><span class="koboSpan" id="kobo.144.1" xmlns="http://www.w3.org/1999/xhtml">: This type of testing is related to non-functional requirements such as performance, usability, reliability, and security, a.k.a. </span><span class="koboSpan" id="kobo.144.2" xmlns="http://www.w3.org/1999/xhtml">performance evaluation.</span></li>
<li><strong><span class="koboSpan" id="kobo.145.1" xmlns="http://www.w3.org/1999/xhtml">Regression testing</span></strong><span class="koboSpan" id="kobo.146.1" xmlns="http://www.w3.org/1999/xhtml">: This type of testing ensures the new code does not break existing functionalities, a.k.a. </span><span class="koboSpan" id="kobo.146.2" xmlns="http://www.w3.org/1999/xhtml">change impact.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.147.1" xmlns="http://www.w3.org/1999/xhtml">Next, let’s explore a hybrid between white-box and black-box testing.</span></p>
</section>
<section class="level3" data-number="3.4.3" id="grey-box-testing">
<h3 data-number="3.4.3"><span class="koboSpan" id="kobo.148.1" xmlns="http://www.w3.org/1999/xhtml">Grey-box testing</span></h3>
<p><span class="koboSpan" id="kobo.149.1" xmlns="http://www.w3.org/1999/xhtml">Grey-box testing is a blend between white-box and black-box testing. </span><span class="koboSpan" id="kobo.149.2" xmlns="http://www.w3.org/1999/xhtml">Testers need only partial knowledge of the application’s internal workings and use a combination of the software’s internal structure and external behavior to craft their tests.We implement grey-box testing use cases in </span><em><span class="koboSpan" id="kobo.150.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 16</span></em><span class="koboSpan" id="kobo.151.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.152.1" xmlns="http://www.w3.org/1999/xhtml">Request-Endpoint-Response (REPR)</span></em><span class="koboSpan" id="kobo.153.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.153.2" xmlns="http://www.w3.org/1999/xhtml">Meanwhile, let’s compare the three techniques.</span></p>
</section>
<section class="level3" data-number="3.4.4" id="white-box-vs.-black-box-vs.-grey-box-testing">
<h3 data-number="3.4.4"><span class="koboSpan" id="kobo.154.1" xmlns="http://www.w3.org/1999/xhtml">White-box vs. </span><span class="koboSpan" id="kobo.154.2" xmlns="http://www.w3.org/1999/xhtml">Black-box vs. </span><span class="koboSpan" id="kobo.154.3" xmlns="http://www.w3.org/1999/xhtml">Grey-box testing</span></h3>
<p><span class="koboSpan" id="kobo.155.1" xmlns="http://www.w3.org/1999/xhtml">To start with a concise comparison, here’s a table that compares the three broad techniques:</span></p>
<table>
<tbody>
<tr class="odd">
<td><strong><span class="koboSpan" id="kobo.156.1" xmlns="http://www.w3.org/1999/xhtml">Feature</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.157.1" xmlns="http://www.w3.org/1999/xhtml">Whitebox Testing</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.158.1" xmlns="http://www.w3.org/1999/xhtml">Blackbox Testing</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.159.1" xmlns="http://www.w3.org/1999/xhtml">Gray-box Testing</span></strong></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.160.1" xmlns="http://www.w3.org/1999/xhtml">Definition</span></td>
<td><span class="koboSpan" id="kobo.161.1" xmlns="http://www.w3.org/1999/xhtml">Testing based on the internal design of the software</span></td>
<td><span class="koboSpan" id="kobo.162.1" xmlns="http://www.w3.org/1999/xhtml">Testing based on the behavior and functionality of the software</span></td>
<td><span class="koboSpan" id="kobo.163.1" xmlns="http://www.w3.org/1999/xhtml">Testing that combines the internal design and behavior of the software</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.164.1" xmlns="http://www.w3.org/1999/xhtml">Knowledge of code required</span></td>
<td><span class="koboSpan" id="kobo.165.1" xmlns="http://www.w3.org/1999/xhtml">Yes</span></td>
<td><span class="koboSpan" id="kobo.166.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
<td><span class="koboSpan" id="kobo.167.1" xmlns="http://www.w3.org/1999/xhtml">Yes</span></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.168.1" xmlns="http://www.w3.org/1999/xhtml">Types of defects found</span></td>
<td><span class="koboSpan" id="kobo.169.1" xmlns="http://www.w3.org/1999/xhtml">Logic, data structure, architecture, and performance issues</span></td>
<td><span class="koboSpan" id="kobo.170.1" xmlns="http://www.w3.org/1999/xhtml">Functionality, usability, performance, and security issues</span></td>
<td><span class="koboSpan" id="kobo.171.1" xmlns="http://www.w3.org/1999/xhtml">Most types of issues</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.172.1" xmlns="http://www.w3.org/1999/xhtml">Coverage per test</span></td>
<td><span class="koboSpan" id="kobo.173.1" xmlns="http://www.w3.org/1999/xhtml">Small; targeted on a unit</span></td>
<td><span class="koboSpan" id="kobo.174.1" xmlns="http://www.w3.org/1999/xhtml">Large; targeted on a use case</span></td>
<td><span class="koboSpan" id="kobo.175.1" xmlns="http://www.w3.org/1999/xhtml">Up to large; can vary in scope</span></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.176.1" xmlns="http://www.w3.org/1999/xhtml">Testers</span></td>
<td><span class="koboSpan" id="kobo.177.1" xmlns="http://www.w3.org/1999/xhtml">Usually performed by developers.</span></td>
<td><span class="koboSpan" id="kobo.178.1" xmlns="http://www.w3.org/1999/xhtml">Testers can write the tests without specific technical knowledge of the application’s internal structure.</span></td>
<td><span class="koboSpan" id="kobo.179.1" xmlns="http://www.w3.org/1999/xhtml">Developers can write the tests, while testers also can with some knowledge of the code.</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.180.1" xmlns="http://www.w3.org/1999/xhtml">When to use each style?</span></td>
<td><span class="koboSpan" id="kobo.181.1" xmlns="http://www.w3.org/1999/xhtml">Write unit tests to validate complex algorithms or code that yields multiple results based on many inputs. </span><span class="koboSpan" id="kobo.181.2" xmlns="http://www.w3.org/1999/xhtml">These tests are usually high-speed so you can have many of them.</span></td>
<td><span class="koboSpan" id="kobo.182.1" xmlns="http://www.w3.org/1999/xhtml">Write if you have specific scenarios you want to test, like UI tests, or if testers and developers are two distinct roles in your organization. </span><span class="koboSpan" id="kobo.182.2" xmlns="http://www.w3.org/1999/xhtml">These usually run the slowest and require you to deploy the application to test it. </span><span class="koboSpan" id="kobo.182.3" xmlns="http://www.w3.org/1999/xhtml">You want as few as possible to improve the feedback time.</span></td>
<td><span class="koboSpan" id="kobo.183.1" xmlns="http://www.w3.org/1999/xhtml">Write to avoid writing black-box or white-box tests. </span><span class="koboSpan" id="kobo.183.2" xmlns="http://www.w3.org/1999/xhtml">Layer the tests to cover as much as possible with as few tests as possible. </span><span class="koboSpan" id="kobo.183.3" xmlns="http://www.w3.org/1999/xhtml">Depending on the application’s architecture, this type of test can yield optimal results for many scenarios.</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.184.1" xmlns="http://www.w3.org/1999/xhtml">Let’s conclude next and explore a few advantages and disadvantages of each technique.</span></p>
</section>
<section class="level3" data-number="3.4.5" id="conclusion">
<h3 data-number="3.4.5"><span class="koboSpan" id="kobo.185.1" xmlns="http://www.w3.org/1999/xhtml">Conclusion</span></h3>
<p><span class="koboSpan" id="kobo.186.1" xmlns="http://www.w3.org/1999/xhtml">White-box testing includes unit and integration tests. </span><span class="koboSpan" id="kobo.186.2" xmlns="http://www.w3.org/1999/xhtml">Those tests run fast, and developers use them to improve the code and test complex algorithms. </span><span class="koboSpan" id="kobo.186.3" xmlns="http://www.w3.org/1999/xhtml">However, writing a large quantity of those tests takes time. </span><span class="koboSpan" id="kobo.186.4" xmlns="http://www.w3.org/1999/xhtml">Writing brittle tests that are tightly coupled with the code itself is easier due to the proximity to the code, increasing the maintenance cost of such test suites. </span><span class="koboSpan" id="kobo.186.5" xmlns="http://www.w3.org/1999/xhtml">It also makes it prone to overengineering your application in the name of testability.Black-box testing encompasses different types of tests that tend towards end-to-end testing. </span><span class="koboSpan" id="kobo.186.6" xmlns="http://www.w3.org/1999/xhtml">Since the tests target the external surface of the system, they are less likely to break when the system changes. </span><span class="koboSpan" id="kobo.186.7" xmlns="http://www.w3.org/1999/xhtml">Moreover, they are excellent at testing behaviors, and since each test tests an end-to-end use case, we need fewer of them, leading to a decrease in writing time and maintenance costs. </span><span class="koboSpan" id="kobo.186.8" xmlns="http://www.w3.org/1999/xhtml">Testing the whole system has drawbacks, including the slowness of executing each test, so combining black-box testing with other types of tests is very important to find the right balance between the number of tests, test case coverage, and speed of execution of the tests.Grey-box testing is a fantastic mix between the two others; you can treat any part of the software as a black box, leverage your inner-working knowledge to mock or stub parts of the test case (like to assert if the system persisted a record in the database), and test end-to-end scenarios more efficiently. </span><span class="koboSpan" id="kobo.186.9" xmlns="http://www.w3.org/1999/xhtml">It brings the best of both worlds, significantly reducing the number of tests while increasing the test surface considerably for each test case. </span><span class="koboSpan" id="kobo.186.10" xmlns="http://www.w3.org/1999/xhtml">However, doing grey-box testing on smaller units or heavily mocking the system may yield the same drawbacks as white-box testing. </span><span class="koboSpan" id="kobo.186.11" xmlns="http://www.w3.org/1999/xhtml">Integration tests or almost-E2E tests are good candidates for grey-box testing. </span><span class="koboSpan" id="kobo.186.12" xmlns="http://www.w3.org/1999/xhtml">We implement grey-box testing use cases in </span><em><span class="koboSpan" id="kobo.187.1" xmlns="http://www.w3.org/1999/xhtml">Chapter 16</span></em><span class="koboSpan" id="kobo.188.1" xmlns="http://www.w3.org/1999/xhtml">, </span><em><span class="koboSpan" id="kobo.189.1" xmlns="http://www.w3.org/1999/xhtml">Request-Endpoint-Response (REPR)</span></em><span class="koboSpan" id="kobo.190.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.190.2" xmlns="http://www.w3.org/1999/xhtml">Meanwhile, let’s explore a few techniques to help optimize our test case creation by applying different techniques, like testing a small subset of values to assert the correctness of our programs by writing an optimal number of tests.</span></p>
</section>
</section>
<section class="level2" data-number="3.5" id="test-case-creation">
<h2 data-number="3.5"><span class="koboSpan" id="kobo.191.1" xmlns="http://www.w3.org/1999/xhtml">Test case creation</span></h2>
<p><span class="koboSpan" id="kobo.192.1" xmlns="http://www.w3.org/1999/xhtml">Multiple ways exist to break down and create test cases to help find software defects with a minimal test count. </span><span class="koboSpan" id="kobo.192.2" xmlns="http://www.w3.org/1999/xhtml">Here are some techniques to help minimize the number of tests while maximizing the test coverage:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.193.1" xmlns="http://www.w3.org/1999/xhtml">Equivalence Partitioning</span></li>
<li><span class="koboSpan" id="kobo.194.1" xmlns="http://www.w3.org/1999/xhtml">Boundary Value Analysis</span></li>
<li><span class="koboSpan" id="kobo.195.1" xmlns="http://www.w3.org/1999/xhtml">Decision Table Testing</span></li>
<li><span class="koboSpan" id="kobo.196.1" xmlns="http://www.w3.org/1999/xhtml">State Transition Testing</span></li>
<li><span class="koboSpan" id="kobo.197.1" xmlns="http://www.w3.org/1999/xhtml">Use Case Testing</span></li>
</ul>
<p><span class="koboSpan" id="kobo.198.1" xmlns="http://www.w3.org/1999/xhtml">I present the techniques theoretically. </span><span class="koboSpan" id="kobo.198.2" xmlns="http://www.w3.org/1999/xhtml">They apply to all sorts of tests and should help you write better test suites. </span><span class="koboSpan" id="kobo.198.3" xmlns="http://www.w3.org/1999/xhtml">Let’s have a quick look at each.</span></p>
<section class="level3" data-number="3.5.1" id="equivalence-partitioning">
<h3 data-number="3.5.1"><span class="koboSpan" id="kobo.199.1" xmlns="http://www.w3.org/1999/xhtml">Equivalence Partitioning</span></h3>
<p><span class="koboSpan" id="kobo.200.1" xmlns="http://www.w3.org/1999/xhtml">This technique divides the input data of the software into different equivalence data classes and then tests these classes rather than individual inputs. </span><span class="koboSpan" id="kobo.200.2" xmlns="http://www.w3.org/1999/xhtml">An equivalence data class means that all values in that partition set should lead to the same outcome or yield the same result. </span><span class="koboSpan" id="kobo.200.3" xmlns="http://www.w3.org/1999/xhtml">Doing this allows for limiting the number of tests considerably.For example, consider an application that accepts an integer value between 1 and 100 (inclusive). </span><span class="koboSpan" id="kobo.200.4" xmlns="http://www.w3.org/1999/xhtml">Using equivalence partitioning, we can divide the input data into two equivalence classes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.201.1" xmlns="http://www.w3.org/1999/xhtml">Valid</span></li>
<li><span class="koboSpan" id="kobo.202.1" xmlns="http://www.w3.org/1999/xhtml">Invalid</span></li>
</ul>
<p><span class="koboSpan" id="kobo.203.1" xmlns="http://www.w3.org/1999/xhtml">To be more precise, we could further divide it into three equivalence classes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.204.1" xmlns="http://www.w3.org/1999/xhtml">Class 1: Less than 1 (Invalid)</span></li>
<li><span class="koboSpan" id="kobo.205.1" xmlns="http://www.w3.org/1999/xhtml">Class 2: Between 1 and 100 (Valid)</span></li>
<li><span class="koboSpan" id="kobo.206.1" xmlns="http://www.w3.org/1999/xhtml">Class 3: Greater than 100 (Invalid)</span></li>
</ul>
<p><span class="koboSpan" id="kobo.207.1" xmlns="http://www.w3.org/1999/xhtml">Then we can write three tests, picking one representative from each class (e.g., 0, 50, and 101) to create our test cases. </span><span class="koboSpan" id="kobo.207.2" xmlns="http://www.w3.org/1999/xhtml">Doing so ensures a broad coverage with minimal test cases, making our testing process more efficient.</span></p>
</section>
<section class="level3" data-number="3.5.2" id="boundary-value-analysis">
<h3 data-number="3.5.2"><span class="koboSpan" id="kobo.208.1" xmlns="http://www.w3.org/1999/xhtml">Boundary Value Analysis</span></h3>
<p><span class="koboSpan" id="kobo.209.1" xmlns="http://www.w3.org/1999/xhtml">This technique focuses on the values at the boundary of the input domain rather than the center. </span><span class="koboSpan" id="kobo.209.2" xmlns="http://www.w3.org/1999/xhtml">This technique is based on the principle that errors are most likely to occur at the boundaries of the input domain.The </span><strong><span class="koboSpan" id="kobo.210.1" xmlns="http://www.w3.org/1999/xhtml">input domain</span></strong><span class="koboSpan" id="kobo.211.1" xmlns="http://www.w3.org/1999/xhtml"> represents the set of all possible inputs for a system. </span><span class="koboSpan" id="kobo.211.2" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.212.1" xmlns="http://www.w3.org/1999/xhtml">boundaries</span></strong><span class="koboSpan" id="kobo.213.1" xmlns="http://www.w3.org/1999/xhtml"> are the edges of the input domain, representing minimum and maximum values.For example, if we expect a function to accept an integer between 1 and 100 (inclusive), the boundary values would be 1 and 100. </span><span class="koboSpan" id="kobo.213.2" xmlns="http://www.w3.org/1999/xhtml">With Boundary Value Analysis, we would create test cases for these values, values just outside the boundaries (like 0 and 101), and values just inside the boundaries (like 2 and 99).Boundary Value Analysis is a very efficient testing technique that provides good coverage with a relatively small number of test cases. </span><span class="koboSpan" id="kobo.213.3" xmlns="http://www.w3.org/1999/xhtml">However, it’s unsuitable for finding errors within the boundaries or for complex logic errors. </span><span class="koboSpan" id="kobo.213.4" xmlns="http://www.w3.org/1999/xhtml">Boundary Value Analysis should be used on top of other testing methods, such as equivalence partitioning and decision table testing, to ensure the software is as defect-free as possible.</span></p>
</section>
<section class="level3" data-number="3.5.3" id="decision-table-testing">
<h3 data-number="3.5.3"><span class="koboSpan" id="kobo.214.1" xmlns="http://www.w3.org/1999/xhtml">Decision Table Testing</span></h3>
<p><span class="koboSpan" id="kobo.215.1" xmlns="http://www.w3.org/1999/xhtml">This technique uses a decision table to design test cases. </span><span class="koboSpan" id="kobo.215.2" xmlns="http://www.w3.org/1999/xhtml">A decision table is a table that shows all possible combinations of input values and their corresponding outputs.It’s handy for complex business rules that can be expressed in a table format, enabling testers to identify missing and extraneous test cases.For example, our system only allows access to a user with a valid username and password. </span><span class="koboSpan" id="kobo.215.3" xmlns="http://www.w3.org/1999/xhtml">Moreover, the system denies access to users when it is under maintenance. </span><span class="koboSpan" id="kobo.215.4" xmlns="http://www.w3.org/1999/xhtml">The decision table would have three conditions (username, password, and maintenance) and one action (allow access). </span><span class="koboSpan" id="kobo.215.5" xmlns="http://www.w3.org/1999/xhtml">The table would list all possible combinations of these conditions and the expected action for each combination. </span><span class="koboSpan" id="kobo.215.6" xmlns="http://www.w3.org/1999/xhtml">Here is an example:</span></p>
<table>
<tbody>
<tr class="odd">
<td><strong><span class="koboSpan" id="kobo.216.1" xmlns="http://www.w3.org/1999/xhtml">Valid Username</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.217.1" xmlns="http://www.w3.org/1999/xhtml">Valid Password</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.218.1" xmlns="http://www.w3.org/1999/xhtml">System under Maintenance</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.219.1" xmlns="http://www.w3.org/1999/xhtml">Allow Access</span></strong></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.220.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.221.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.222.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.223.1" xmlns="http://www.w3.org/1999/xhtml">Yes</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.224.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.225.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.226.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.227.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.228.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.229.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.230.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.231.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.232.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.233.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.234.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.235.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.236.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.237.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.238.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.239.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.240.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.241.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.242.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.243.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="even">
<td><span class="koboSpan" id="kobo.244.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.245.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.246.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.247.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
<tr class="odd">
<td><span class="koboSpan" id="kobo.248.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.249.1" xmlns="http://www.w3.org/1999/xhtml">False</span></td>
<td><span class="koboSpan" id="kobo.250.1" xmlns="http://www.w3.org/1999/xhtml">True</span></td>
<td><span class="koboSpan" id="kobo.251.1" xmlns="http://www.w3.org/1999/xhtml">No</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.252.1" xmlns="http://www.w3.org/1999/xhtml">The main advantage of Decision Table Testing is that it ensures we test all possible input combinations. </span><span class="koboSpan" id="kobo.252.2" xmlns="http://www.w3.org/1999/xhtml">However, it can become complex and challenging to manage when systems have many input conditions, as the number of rules (and therefore test cases) increases exponentially with the number of conditions.</span></p>
</section>
<section class="level3" data-number="3.5.4" id="state-transition-testing">
<h3 data-number="3.5.4"><span class="koboSpan" id="kobo.253.1" xmlns="http://www.w3.org/1999/xhtml">State Transition Testing</span></h3>
<p><span class="koboSpan" id="kobo.254.1" xmlns="http://www.w3.org/1999/xhtml">We usually use State Transition Testing to test software with a state machine since it tests the different system states and their transitions. </span><span class="koboSpan" id="kobo.254.2" xmlns="http://www.w3.org/1999/xhtml">It’s handy for systems where the system behavior can change based on its current state. </span><span class="koboSpan" id="kobo.254.3" xmlns="http://www.w3.org/1999/xhtml">For example, a program with states like “logged in” or “logged out”.To perform State Transition Testing, we need to identify the states of the system and then the possible transitions between the states. </span><span class="koboSpan" id="kobo.254.4" xmlns="http://www.w3.org/1999/xhtml">For each transition, we need to create a test case. </span><span class="koboSpan" id="kobo.254.5" xmlns="http://www.w3.org/1999/xhtml">The test case should test the software with the specified input values and verify that the software transitions to the correct state. </span><span class="koboSpan" id="kobo.254.6" xmlns="http://www.w3.org/1999/xhtml">For example, a user with the state “logged in” must transition to the state “logged out” after signing out.The main advantage of State Transition Testing is that it tests sequences of events, not just individual events, which could reveal defects not found by testing each event in isolation. </span><span class="koboSpan" id="kobo.254.7" xmlns="http://www.w3.org/1999/xhtml">However, State Transition Testing can become complex and time-consuming for systems with many states and transitions.</span></p>
</section>
<section class="level3" data-number="3.5.5" id="use-case-testing">
<h3 data-number="3.5.5"><span class="koboSpan" id="kobo.255.1" xmlns="http://www.w3.org/1999/xhtml">Use Case Testing</span></h3>
<p><span class="koboSpan" id="kobo.256.1" xmlns="http://www.w3.org/1999/xhtml">This technique validates that the system behaves as expected when used in a particular way by a user. </span><span class="koboSpan" id="kobo.256.2" xmlns="http://www.w3.org/1999/xhtml">Use cases could have formal descriptions, be user stories, or take any other form that fits your needs.A use case involves one or more actors executing steps or taking actions that should yield a particular result. </span><span class="koboSpan" id="kobo.256.3" xmlns="http://www.w3.org/1999/xhtml">A use case can include inputs and expected outputs. </span><span class="koboSpan" id="kobo.256.4" xmlns="http://www.w3.org/1999/xhtml">For example, when a user (actor) that is “signed in” (precondition) clicks the “sign out” button (action), then navigates to the profile page (action), the system denies access to the page and redirects the users to the sign in page, displaying an error message (expected behaviors).Use case testing is a systematic and structured approach to testing that helps identify defects in the software’s functionality. </span><span class="koboSpan" id="kobo.256.5" xmlns="http://www.w3.org/1999/xhtml">It is very user-centric, ensuring the software meets the users’ needs. </span><span class="koboSpan" id="kobo.256.6" xmlns="http://www.w3.org/1999/xhtml">However, creating test cases for complex use cases can be difficult. </span><span class="koboSpan" id="kobo.256.7" xmlns="http://www.w3.org/1999/xhtml">In the case of a user interface, the time to execute end-to-end tests of use cases can take a long time, especially as the number of tests grows.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.257.1" xmlns="http://www.w3.org/1999/xhtml">It is an excellent approach to think of your test cases in terms of functionality to test, whether using a formal use case or just a line written on a napkin. </span><span class="koboSpan" id="kobo.257.2" xmlns="http://www.w3.org/1999/xhtml">The key is to test behaviors, not code.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.258.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have explored these techniques, it is time to introduce the xUnit library, ways to write tests, and how tests are written in the book. </span><span class="koboSpan" id="kobo.258.2" xmlns="http://www.w3.org/1999/xhtml">Let’s start by creating a test project.</span></p>
</section>
</section>
<section class="level2" data-number="3.6" id="how-to-create-an-xunit-test-project">
<h2 data-number="3.6"><span class="koboSpan" id="kobo.259.1" xmlns="http://www.w3.org/1999/xhtml">How to create an xUnit test project</span></h2>
<p><span class="koboSpan" id="kobo.260.1" xmlns="http://www.w3.org/1999/xhtml">To create a new xUnit test project, you can run the </span><code><span class="koboSpan" id="kobo.261.1" xmlns="http://www.w3.org/1999/xhtml">dotnet new xunit</span></code><span class="koboSpan" id="kobo.262.1" xmlns="http://www.w3.org/1999/xhtml"> command, and the CLI does the job for you by creating a project containing a </span><code><span class="koboSpan" id="kobo.263.1" xmlns="http://www.w3.org/1999/xhtml">UnitTest1</span></code><span class="koboSpan" id="kobo.264.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.264.2" xmlns="http://www.w3.org/1999/xhtml">That command does the same as creating a new xUnit project from Visual Studio.For unit testing projects, name the project the same as the project you want to test and append </span><code><span class="koboSpan" id="kobo.265.1" xmlns="http://www.w3.org/1999/xhtml">.Tests</span></code><span class="koboSpan" id="kobo.266.1" xmlns="http://www.w3.org/1999/xhtml"> to it. </span><span class="koboSpan" id="kobo.266.2" xmlns="http://www.w3.org/1999/xhtml">For example, </span><code><span class="koboSpan" id="kobo.267.1" xmlns="http://www.w3.org/1999/xhtml">MyProject</span></code><span class="koboSpan" id="kobo.268.1" xmlns="http://www.w3.org/1999/xhtml"> would have a </span><code><span class="koboSpan" id="kobo.269.1" xmlns="http://www.w3.org/1999/xhtml">MyProject.Tests</span></code><span class="koboSpan" id="kobo.270.1" xmlns="http://www.w3.org/1999/xhtml"> project associated with it. </span><span class="koboSpan" id="kobo.270.2" xmlns="http://www.w3.org/1999/xhtml">We explore more details in the </span><em><span class="koboSpan" id="kobo.271.1" xmlns="http://www.w3.org/1999/xhtml">Organizing your tests</span></em><span class="koboSpan" id="kobo.272.1" xmlns="http://www.w3.org/1999/xhtml"> section below.The template already defines all the required NuGet packages, so you can start testing immediately after adding a reference to your project under test.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.273.1" xmlns="http://www.w3.org/1999/xhtml">You can also add project references using the CLI with the </span><code><span class="koboSpan" id="kobo.274.1" xmlns="http://www.w3.org/1999/xhtml">dotnet add reference</span></code><span class="koboSpan" id="kobo.275.1" xmlns="http://www.w3.org/1999/xhtml"> command. </span><span class="koboSpan" id="kobo.275.2" xmlns="http://www.w3.org/1999/xhtml">Assuming we are in the </span><code><span class="koboSpan" id="kobo.276.1" xmlns="http://www.w3.org/1999/xhtml">./test/MyProject.Tests</span></code><span class="koboSpan" id="kobo.277.1" xmlns="http://www.w3.org/1999/xhtml"> directory and the project file we want to reference is in the </span><code><span class="koboSpan" id="kobo.278.1" xmlns="http://www.w3.org/1999/xhtml">./src/MyProject</span></code><span class="koboSpan" id="kobo.279.1" xmlns="http://www.w3.org/1999/xhtml"> directory; we can execute the following command to add a reference:</span></p>
</blockquote>
<pre><code><span class="koboSpan" id="kobo.280.1" xmlns="http://www.w3.org/1999/xhtml">dotnet add reference ../../src/MyProject.csproj.</span></code></pre>
<p><span class="koboSpan" id="kobo.281.1" xmlns="http://www.w3.org/1999/xhtml">Next, we explore some xUnit features that will allow us to write test cases.</span></p>
</section>
<section class="level2" data-number="3.7" id="key-xunit-features">
<h2 data-number="3.7"><span class="koboSpan" id="kobo.282.1" xmlns="http://www.w3.org/1999/xhtml">Key xUnit features</span></h2>
<p><span class="koboSpan" id="kobo.283.1" xmlns="http://www.w3.org/1999/xhtml">In xUnit, the </span><code><span class="koboSpan" id="kobo.284.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]</span></code><span class="koboSpan" id="kobo.285.1" xmlns="http://www.w3.org/1999/xhtml"> attribute is the way to create unique test cases, while the </span><code><span class="koboSpan" id="kobo.286.1" xmlns="http://www.w3.org/1999/xhtml">[Theory]</span></code><span class="koboSpan" id="kobo.287.1" xmlns="http://www.w3.org/1999/xhtml"> attribute is the way to make data-driven test cases. </span><span class="koboSpan" id="kobo.287.2" xmlns="http://www.w3.org/1999/xhtml">Let’s start with facts, the simplest way to write a test case.</span></p>
<section class="level3" data-number="3.7.1" id="facts">
<h3 data-number="3.7.1"><span class="koboSpan" id="kobo.288.1" xmlns="http://www.w3.org/1999/xhtml">Facts</span></h3>
<p><span class="koboSpan" id="kobo.289.1" xmlns="http://www.w3.org/1999/xhtml">Any method with no parameter can become a test method by decorating it with a </span><code><span class="koboSpan" id="kobo.290.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]</span></code><span class="koboSpan" id="kobo.291.1" xmlns="http://www.w3.org/1999/xhtml"> attribute, like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.292.1" xmlns="http://www.w3.org/1999/xhtml">public class FactTest
{
    [Fact]
    public void Should_be_equal()
    {
        var expectedValue = 2;
        var actualValue = 2;
        Assert.Equal(expectedValue, actualValue);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.293.1" xmlns="http://www.w3.org/1999/xhtml">You can also decorate asynchronous methods with the fact attribute when the code under test needs it:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.294.1" xmlns="http://www.w3.org/1999/xhtml">public class AsyncFactTest
{
    [Fact]
    public async Task Should_be_equal()
    {
        var expectedValue = 2;
        var actualValue = 2;
        await Task.Yield();
        Assert.Equal(expectedValue, actualValue);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.295.1" xmlns="http://www.w3.org/1999/xhtml">In the preceding code, the highlighted line conceptually represents an asynchronous operation and does nothing more than allow using the </span><code><span class="koboSpan" id="kobo.296.1" xmlns="http://www.w3.org/1999/xhtml">async</span></code><span class="koboSpan" id="kobo.297.1" xmlns="http://www.w3.org/1999/xhtml">/</span><code><span class="koboSpan" id="kobo.298.1" xmlns="http://www.w3.org/1999/xhtml">await</span></code><span class="koboSpan" id="kobo.299.1" xmlns="http://www.w3.org/1999/xhtml"> keywords.When we run the tests from Visual Studio’s Test Explorer, the test run result looks like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.300.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.3: Test results in Visual Studio" src="../media/file5.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.301.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.3: Test results in Visual Studio</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.302.1" xmlns="http://www.w3.org/1999/xhtml">You may have noticed from the screenshot that the test classes are nested in the </span><code><span class="koboSpan" id="kobo.303.1" xmlns="http://www.w3.org/1999/xhtml">xUnitFeaturesTest</span></code><span class="koboSpan" id="kobo.304.1" xmlns="http://www.w3.org/1999/xhtml"> class, part of the </span><code><span class="koboSpan" id="kobo.305.1" xmlns="http://www.w3.org/1999/xhtml">MyApp</span></code><span class="koboSpan" id="kobo.306.1" xmlns="http://www.w3.org/1999/xhtml"> namespace, and under the </span><code><span class="koboSpan" id="kobo.307.1" xmlns="http://www.w3.org/1999/xhtml">MyApp.Tests</span></code><span class="koboSpan" id="kobo.308.1" xmlns="http://www.w3.org/1999/xhtml"> project. </span><span class="koboSpan" id="kobo.308.2" xmlns="http://www.w3.org/1999/xhtml">We explore those details later in the chapter.Running the </span><code><span class="koboSpan" id="kobo.309.1" xmlns="http://www.w3.org/1999/xhtml">dotnet test</span></code><span class="koboSpan" id="kobo.310.1" xmlns="http://www.w3.org/1999/xhtml"> CLI command should yield a result similar to the following:</span></p>
<div class="C0-SHConPACKT">
<pre><code><span class="koboSpan" id="kobo.311.1" xmlns="http://www.w3.org/1999/xhtml">Passed!  </span><span class="koboSpan" id="kobo.311.2" xmlns="http://www.w3.org/1999/xhtml">- Failed:     0, Passed:    23, Skipped:     0, Total:    23, Duration: 22 ms - MyApp.Tests.dll (net8.0)</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.312.1" xmlns="http://www.w3.org/1999/xhtml">As we can read from the preceding output, all tests are passing, none have failed, and none were skipped. </span><span class="koboSpan" id="kobo.312.2" xmlns="http://www.w3.org/1999/xhtml">It is as simple as that to create test cases using xUnit.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.313.1" xmlns="http://www.w3.org/1999/xhtml">Learning the CLI can be very helpful in creating and debugging CI/CD pipelines, and you can use them, like the </span><code><span class="koboSpan" id="kobo.314.1" xmlns="http://www.w3.org/1999/xhtml">dotnet test</span></code><span class="koboSpan" id="kobo.315.1" xmlns="http://www.w3.org/1999/xhtml"> command, in any script (like bash and PowerShell).</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.316.1" xmlns="http://www.w3.org/1999/xhtml">Have you noticed the </span><code><span class="koboSpan" id="kobo.317.1" xmlns="http://www.w3.org/1999/xhtml">Assert</span></code><span class="koboSpan" id="kobo.318.1" xmlns="http://www.w3.org/1999/xhtml"> keyword in the test code? </span><span class="koboSpan" id="kobo.318.2" xmlns="http://www.w3.org/1999/xhtml">If you are not familiar with it, we will explore assertions next.</span></p>
</section>
<section class="level3" data-number="3.7.2" id="assertions">
<h3 data-number="3.7.2"><span class="koboSpan" id="kobo.319.1" xmlns="http://www.w3.org/1999/xhtml">Assertions</span></h3>
<p><span class="koboSpan" id="kobo.320.1" xmlns="http://www.w3.org/1999/xhtml">An assertion is a statement that checks whether a particular condition is </span><code><span class="koboSpan" id="kobo.321.1" xmlns="http://www.w3.org/1999/xhtml">true</span></code><span class="koboSpan" id="kobo.322.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.323.1" xmlns="http://www.w3.org/1999/xhtml">false</span></code><span class="koboSpan" id="kobo.324.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.324.2" xmlns="http://www.w3.org/1999/xhtml">If the condition is </span><code><span class="koboSpan" id="kobo.325.1" xmlns="http://www.w3.org/1999/xhtml">true</span></code><span class="koboSpan" id="kobo.326.1" xmlns="http://www.w3.org/1999/xhtml">, the test passes. </span><span class="koboSpan" id="kobo.326.2" xmlns="http://www.w3.org/1999/xhtml">If the condition is </span><code><span class="koboSpan" id="kobo.327.1" xmlns="http://www.w3.org/1999/xhtml">false</span></code><span class="koboSpan" id="kobo.328.1" xmlns="http://www.w3.org/1999/xhtml">, the test fails, indicating a problem with the subject under test.Let’s visit a few ways to assert correctness. </span><span class="koboSpan" id="kobo.328.2" xmlns="http://www.w3.org/1999/xhtml">We use barebone xUnit functionality in this section, but you can bring in the assertion library of your choice if you have one.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.329.1" xmlns="http://www.w3.org/1999/xhtml">In xUnit, the assertion throws an exception when it fails, but you may never even realize that. </span><span class="koboSpan" id="kobo.329.2" xmlns="http://www.w3.org/1999/xhtml">You do not have to handle those; that’s the mechanism to propagate the failure result to the test runner.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.330.1" xmlns="http://www.w3.org/1999/xhtml">We won’t explore all possibilities, but let’s start with the following shared pieces:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.331.1" xmlns="http://www.w3.org/1999/xhtml">public class AssertionTest
{
    [Fact]
    public void Exploring_xUnit_assertions()
    {
        object obj1 = new MyClass { Name = "Object 1" };
        object obj2 = new MyClass { Name = "Object 1" };
        object obj3 = obj1;
        object? </span><span class="koboSpan" id="kobo.331.2" xmlns="http://www.w3.org/1999/xhtml">obj4 = default(MyClass);
        //
        // Omitted assertions
        // 
        static void OperationThatThrows(string name)
        {
            throw new SomeCustomException { Name = name };
        }
    }
    private record class MyClass
    {
        public string? </span><span class="koboSpan" id="kobo.331.3" xmlns="http://www.w3.org/1999/xhtml">Name { get; set; }
    }
    private class SomeCustomException : Exception
    {
        public string? </span><span class="koboSpan" id="kobo.331.4" xmlns="http://www.w3.org/1999/xhtml">Name { get; set; }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.332.1" xmlns="http://www.w3.org/1999/xhtml">The two preceding record classes, the </span><code><span class="koboSpan" id="kobo.333.1" xmlns="http://www.w3.org/1999/xhtml">OperationThatThrows</span></code><span class="koboSpan" id="kobo.334.1" xmlns="http://www.w3.org/1999/xhtml"> method, and the variables are utilities used in the test to help us play with xUnit assertions. </span><span class="koboSpan" id="kobo.334.2" xmlns="http://www.w3.org/1999/xhtml">The variables are of type </span><code><span class="koboSpan" id="kobo.335.1" xmlns="http://www.w3.org/1999/xhtml">object</span></code><span class="koboSpan" id="kobo.336.1" xmlns="http://www.w3.org/1999/xhtml"> for exploration purposes, but you can use any type in your test cases. </span><span class="koboSpan" id="kobo.336.2" xmlns="http://www.w3.org/1999/xhtml">I omitted the assertion code that we are about to see to keep the code leaner.The following two assertions are very explicit:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.337.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal(expected: 2, actual: 2);
Assert.NotEqual(expected: 2, actual: 1);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.338.1" xmlns="http://www.w3.org/1999/xhtml">The first compares whether the actual value equals the expected value, while the second compares if the two values are different. </span><code><span class="koboSpan" id="kobo.339.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal</span></code><span class="koboSpan" id="kobo.340.1" xmlns="http://www.w3.org/1999/xhtml"> is probably the most commonly used assertion method.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.341.1" xmlns="http://www.w3.org/1999/xhtml">As a rule of thumb, it is better to assert equality (</span><code><span class="koboSpan" id="kobo.342.1" xmlns="http://www.w3.org/1999/xhtml">Equal</span></code><span class="koboSpan" id="kobo.343.1" xmlns="http://www.w3.org/1999/xhtml">) than assert that the values are different (</span><code><span class="koboSpan" id="kobo.344.1" xmlns="http://www.w3.org/1999/xhtml">NotEqual</span></code><span class="koboSpan" id="kobo.345.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.345.2" xmlns="http://www.w3.org/1999/xhtml">Except in a few rare cases, asserting equality will yield more consistent results and close the door to missing defects.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.346.1" xmlns="http://www.w3.org/1999/xhtml">The next two assertions are very similar to the equality ones but assert that the objects are the same instance or not (the same instance means the same reference):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.347.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Same(obj1, obj3);
Assert.NotSame(obj2, obj3);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.348.1" xmlns="http://www.w3.org/1999/xhtml">The next one validates that the two objects are equal. </span><span class="koboSpan" id="kobo.348.2" xmlns="http://www.w3.org/1999/xhtml">Since we are using record classes, it makes it super easy for us; </span><code><span class="koboSpan" id="kobo.349.1" xmlns="http://www.w3.org/1999/xhtml">obj1</span></code><span class="koboSpan" id="kobo.350.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.351.1" xmlns="http://www.w3.org/1999/xhtml">obj2</span></code><span class="koboSpan" id="kobo.352.1" xmlns="http://www.w3.org/1999/xhtml"> are not the same (two instances) but are equal (see </span><em><span class="koboSpan" id="kobo.353.1" xmlns="http://www.w3.org/1999/xhtml">Appendix A</span></em><span class="koboSpan" id="kobo.354.1" xmlns="http://www.w3.org/1999/xhtml"> for more information on record classes):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.355.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal(obj1, obj2);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.356.1" xmlns="http://www.w3.org/1999/xhtml">The next two are very similar and assert that the value is </span><code><span class="koboSpan" id="kobo.357.1" xmlns="http://www.w3.org/1999/xhtml">null</span></code><span class="koboSpan" id="kobo.358.1" xmlns="http://www.w3.org/1999/xhtml"> or not:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.359.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Null(obj4);
Assert.NotNull(obj3);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.360.1" xmlns="http://www.w3.org/1999/xhtml">The next line asserts that </span><code><span class="koboSpan" id="kobo.361.1" xmlns="http://www.w3.org/1999/xhtml">obj1</span></code><span class="koboSpan" id="kobo.362.1" xmlns="http://www.w3.org/1999/xhtml"> is of the </span><code><span class="koboSpan" id="kobo.363.1" xmlns="http://www.w3.org/1999/xhtml">MyClass</span></code><span class="koboSpan" id="kobo.364.1" xmlns="http://www.w3.org/1999/xhtml"> type and then returns the argument (</span><code><span class="koboSpan" id="kobo.365.1" xmlns="http://www.w3.org/1999/xhtml">obj1</span></code><span class="koboSpan" id="kobo.366.1" xmlns="http://www.w3.org/1999/xhtml">) converted to the asserted type (</span><code><span class="koboSpan" id="kobo.367.1" xmlns="http://www.w3.org/1999/xhtml">MyClass</span></code><span class="koboSpan" id="kobo.368.1" xmlns="http://www.w3.org/1999/xhtml">). </span><span class="koboSpan" id="kobo.368.2" xmlns="http://www.w3.org/1999/xhtml">If the type is incorrect, the </span><code><span class="koboSpan" id="kobo.369.1" xmlns="http://www.w3.org/1999/xhtml">IsType</span></code><span class="koboSpan" id="kobo.370.1" xmlns="http://www.w3.org/1999/xhtml"> method will throw an exception:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.371.1" xmlns="http://www.w3.org/1999/xhtml">var instanceOfMyClass = Assert.IsType&lt;MyClass&gt;(obj1);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.372.1" xmlns="http://www.w3.org/1999/xhtml">Then we reuse the </span><code><span class="koboSpan" id="kobo.373.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal</span></code><span class="koboSpan" id="kobo.374.1" xmlns="http://www.w3.org/1999/xhtml"> method to validate that the value of the </span><code><span class="koboSpan" id="kobo.375.1" xmlns="http://www.w3.org/1999/xhtml">Name</span></code><span class="koboSpan" id="kobo.376.1" xmlns="http://www.w3.org/1999/xhtml"> property is what we expect:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.377.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal(expected: "Object 1", actual: instanceOfMyClass.Name);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.378.1" xmlns="http://www.w3.org/1999/xhtml">The following code block asserts that the </span><code><span class="koboSpan" id="kobo.379.1" xmlns="http://www.w3.org/1999/xhtml">testCode</span></code><span class="koboSpan" id="kobo.380.1" xmlns="http://www.w3.org/1999/xhtml"> argument throws an exception of the </span><code><span class="koboSpan" id="kobo.381.1" xmlns="http://www.w3.org/1999/xhtml">SomeCustomException</span></code><span class="koboSpan" id="kobo.382.1" xmlns="http://www.w3.org/1999/xhtml"> type:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.383.1" xmlns="http://www.w3.org/1999/xhtml">var exception = Assert.Throws&lt;SomeCustomException&gt;(
    testCode: () =&gt; OperationThatThrows("Toto")
);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.384.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.385.1" xmlns="http://www.w3.org/1999/xhtml">testCode</span></code><span class="koboSpan" id="kobo.386.1" xmlns="http://www.w3.org/1999/xhtml"> argument executes the </span><code><span class="koboSpan" id="kobo.387.1" xmlns="http://www.w3.org/1999/xhtml">OperationThatThrows</span></code><span class="koboSpan" id="kobo.388.1" xmlns="http://www.w3.org/1999/xhtml"> inline function we saw initially. </span><span class="koboSpan" id="kobo.388.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.389.1" xmlns="http://www.w3.org/1999/xhtml">Throws</span></code><span class="koboSpan" id="kobo.390.1" xmlns="http://www.w3.org/1999/xhtml"> method allows us to test some exception properties by returning the exception in the specified type. </span><span class="koboSpan" id="kobo.390.2" xmlns="http://www.w3.org/1999/xhtml">The same behavior as the </span><code><span class="koboSpan" id="kobo.391.1" xmlns="http://www.w3.org/1999/xhtml">IsType</span></code><span class="koboSpan" id="kobo.392.1" xmlns="http://www.w3.org/1999/xhtml"> method happens here; if the exception is of the wrong type or no exception is thrown, the </span><code><span class="koboSpan" id="kobo.393.1" xmlns="http://www.w3.org/1999/xhtml">Throws</span></code><span class="koboSpan" id="kobo.394.1" xmlns="http://www.w3.org/1999/xhtml"> method will fail the test.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.395.1" xmlns="http://www.w3.org/1999/xhtml">It is a good idea to ensure that not only the proper exception type is thrown, but the exception carries the correct values as well.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.396.1" xmlns="http://www.w3.org/1999/xhtml">The following line asserts that the value of the </span><code><span class="koboSpan" id="kobo.397.1" xmlns="http://www.w3.org/1999/xhtml">Name</span></code><span class="koboSpan" id="kobo.398.1" xmlns="http://www.w3.org/1999/xhtml"> property is what we expect it to be, ensuring our program would propagate the proper exception:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.399.1" xmlns="http://www.w3.org/1999/xhtml">Assert.Equal(expected: "Toto", actual: exception.Name);</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.400.1" xmlns="http://www.w3.org/1999/xhtml">We covered a few assertion methods, but many others are part of xUnit, like the </span><code><span class="koboSpan" id="kobo.401.1" xmlns="http://www.w3.org/1999/xhtml">Collection</span></code><span class="koboSpan" id="kobo.402.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.403.1" xmlns="http://www.w3.org/1999/xhtml">Contains</span></code><span class="koboSpan" id="kobo.404.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.405.1" xmlns="http://www.w3.org/1999/xhtml">False</span></code><span class="koboSpan" id="kobo.406.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.407.1" xmlns="http://www.w3.org/1999/xhtml">True</span></code><span class="koboSpan" id="kobo.408.1" xmlns="http://www.w3.org/1999/xhtml"> methods. </span><span class="koboSpan" id="kobo.408.2" xmlns="http://www.w3.org/1999/xhtml">We use many assertions throughout the book, so if these are still unclear, you will learn more about them.Next, let’s look at data-driven test cases using theories.</span></p>
</section>
<section class="level3" data-number="3.7.3" id="theories">
<h3 data-number="3.7.3"><span class="koboSpan" id="kobo.409.1" xmlns="http://www.w3.org/1999/xhtml">Theories</span></h3>
<p><span class="koboSpan" id="kobo.410.1" xmlns="http://www.w3.org/1999/xhtml">For more complex test cases, we can use theories. </span><span class="koboSpan" id="kobo.410.2" xmlns="http://www.w3.org/1999/xhtml">A theory contains two parts:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.411.1" xmlns="http://www.w3.org/1999/xhtml">A </span><code><span class="koboSpan" id="kobo.412.1" xmlns="http://www.w3.org/1999/xhtml">[Theory]</span></code><span class="koboSpan" id="kobo.413.1" xmlns="http://www.w3.org/1999/xhtml"> attribute that marks the method as a theory.</span></li>
<li><span class="koboSpan" id="kobo.414.1" xmlns="http://www.w3.org/1999/xhtml">At least one data attribute that allows passing data to the test method: </span><code><span class="koboSpan" id="kobo.415.1" xmlns="http://www.w3.org/1999/xhtml">[InlineData]</span></code><span class="koboSpan" id="kobo.416.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.417.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.418.1" xmlns="http://www.w3.org/1999/xhtml">, or </span><code><span class="koboSpan" id="kobo.419.1" xmlns="http://www.w3.org/1999/xhtml">[ClassData]</span></code><span class="koboSpan" id="kobo.420.1" xmlns="http://www.w3.org/1999/xhtml">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.421.1" xmlns="http://www.w3.org/1999/xhtml">When writing a theory, your primary constraint is ensuring that the number of values matches the parameters defined in the test method. </span><span class="koboSpan" id="kobo.421.2" xmlns="http://www.w3.org/1999/xhtml">For example, a theory with one parameter must be fed one value. </span><span class="koboSpan" id="kobo.421.3" xmlns="http://www.w3.org/1999/xhtml">We look at some examples next.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.422.1" xmlns="http://www.w3.org/1999/xhtml">You are not limited to only one type of data attribute; you can use as many as you need to suit your needs and feed a theory with the appropriate data.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.423.1" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.424.1" xmlns="http://www.w3.org/1999/xhtml">[InlineData]</span></code><span class="koboSpan" id="kobo.425.1" xmlns="http://www.w3.org/1999/xhtml"> attribute is the most suitable for constant values or smaller sets of values. </span><span class="koboSpan" id="kobo.425.2" xmlns="http://www.w3.org/1999/xhtml">Inline data is the most straightforward way of the three because of the proximity of the test values and the test method.Here is an example of a theory using inline data:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.426.1" xmlns="http://www.w3.org/1999/xhtml">public class InlineDataTest
{
    [Theory]
    [InlineData(1, 1)]
    [InlineData(2, 2)]
    [InlineData(5, 5)]
    public void Should_be_equal(int value1, int value2)
    {
        Assert.Equal(value1, value2);
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.427.1" xmlns="http://www.w3.org/1999/xhtml">That test method yields three test cases in the Test Explorer, where each can pass or fail individually. </span><span class="koboSpan" id="kobo.427.2" xmlns="http://www.w3.org/1999/xhtml">Of course, since 1 equals 1, 2 equals 2, and 5 equals 5, all three test cases are passing, as shown here:</span></p>
<figure>
<span class="koboSpan" id="kobo.428.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.4: Inline data theory test results" src="../media/file6.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.429.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.4: Inline data theory test results</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.430.1" xmlns="http://www.w3.org/1999/xhtml">We can also use the </span><code><span class="koboSpan" id="kobo.431.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.432.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.433.1" xmlns="http://www.w3.org/1999/xhtml">[ClassData]</span></code><span class="koboSpan" id="kobo.434.1" xmlns="http://www.w3.org/1999/xhtml"> attributes to simplify the test method’s declaration when we have a large set of data to tests. </span><span class="koboSpan" id="kobo.434.2" xmlns="http://www.w3.org/1999/xhtml">We can also do that when it is impossible to instantiate the data in the attribute. </span><span class="koboSpan" id="kobo.434.3" xmlns="http://www.w3.org/1999/xhtml">We can also reuse the data in multiple test methods or encapsulate the data away from the test class.Here is a medley of examples of the </span><code><span class="koboSpan" id="kobo.435.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.436.1" xmlns="http://www.w3.org/1999/xhtml"> attribute usage:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.437.1" xmlns="http://www.w3.org/1999/xhtml">public class MemberDataTest
{
    public static IEnumerable&lt;object[]&gt; Data =&gt; new[]
    {
        new object[] { 1, 2, false },
        new object[] { 2, 2, true },
        new object[] { 3, 3, true },
    };
    public static TheoryData&lt;int, int, bool&gt; TypedData =&gt;new TheoryData&lt;int, int, bool&gt;
    {
        { 3, 2, false },
        { 2, 3, false },
        { 5, 5, true },
    };
    [Theory]
    [MemberData(nameof(Data))]
    [MemberData(nameof(TypedData))]
    [MemberData(nameof(ExternalData.GetData), 10, MemberType = typeof(ExternalData))]
    [MemberData(nameof(ExternalData.TypedData), MemberType = typeof(ExternalData))]
    public void Should_be_equal(int value1, int value2, bool shouldBeEqual)
    {
        if (shouldBeEqual)
        {
            Assert.Equal(value1, value2);
        }
        else
        {
            Assert.NotEqual(value1, value2);
       }
    }
    public class ExternalData
    {
        public static IEnumerable&lt;object[]&gt; GetData(int start) =&gt; new[]
        {
            new object[] { start, start, true },
            new object[] { start, start + 1, false },
            new object[] { start + 1, start + 1, true },
        };
        public static TheoryData&lt;int, int, bool&gt; TypedData =&gt; new TheoryData&lt;int, int, bool&gt;
        {
            { 20, 30, false },
            { 40, 50, false },
            { 50, 50, true },
        };
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.438.1" xmlns="http://www.w3.org/1999/xhtml">The preceding test case yields 12 results. </span><span class="koboSpan" id="kobo.438.2" xmlns="http://www.w3.org/1999/xhtml">If we break it down, the code starts by loading three sets of data from the </span><code><span class="koboSpan" id="kobo.439.1" xmlns="http://www.w3.org/1999/xhtml">Data</span></code><span class="koboSpan" id="kobo.440.1" xmlns="http://www.w3.org/1999/xhtml"> property by decorating the test method with the </span><code><span class="koboSpan" id="kobo.441.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData(nameof(Data))]</span></code><span class="koboSpan" id="kobo.442.1" xmlns="http://www.w3.org/1999/xhtml"> attribute. </span><span class="koboSpan" id="kobo.442.2" xmlns="http://www.w3.org/1999/xhtml">This is how to load data from a member of the class the test method is declared in.Then, the second property is very similar to the </span><code><span class="koboSpan" id="kobo.443.1" xmlns="http://www.w3.org/1999/xhtml">Data</span></code><span class="koboSpan" id="kobo.444.1" xmlns="http://www.w3.org/1999/xhtml"> property but replaces </span><code><span class="koboSpan" id="kobo.445.1" xmlns="http://www.w3.org/1999/xhtml">IEnumerable&lt;object[]&gt;</span></code><span class="koboSpan" id="kobo.446.1" xmlns="http://www.w3.org/1999/xhtml"> with a </span><code><span class="koboSpan" id="kobo.447.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData&lt;…&gt;</span></code><span class="koboSpan" id="kobo.448.1" xmlns="http://www.w3.org/1999/xhtml"> class, making it more readable and type-safe. </span><span class="koboSpan" id="kobo.448.2" xmlns="http://www.w3.org/1999/xhtml">Like with the first attribute, we feed those three sets of data to the test method by decorating it with the </span><code><span class="koboSpan" id="kobo.449.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData(nameof(TypedData))]</span></code><span class="koboSpan" id="kobo.450.1" xmlns="http://www.w3.org/1999/xhtml"> attribute. </span><span class="koboSpan" id="kobo.450.2" xmlns="http://www.w3.org/1999/xhtml">Once again, it is part of the test class.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.451.1" xmlns="http://www.w3.org/1999/xhtml">I strongly recommend using </span><code><span class="koboSpan" id="kobo.452.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData&lt;…&gt;</span></code><span class="koboSpan" id="kobo.453.1" xmlns="http://www.w3.org/1999/xhtml"> by default.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.454.1" xmlns="http://www.w3.org/1999/xhtml">The third data feeds three more sets of data to the test method. </span><span class="koboSpan" id="kobo.454.2" xmlns="http://www.w3.org/1999/xhtml">However, that data originates from the </span><code><span class="koboSpan" id="kobo.455.1" xmlns="http://www.w3.org/1999/xhtml">GetData</span></code><span class="koboSpan" id="kobo.456.1" xmlns="http://www.w3.org/1999/xhtml"> method of the </span><code><span class="koboSpan" id="kobo.457.1" xmlns="http://www.w3.org/1999/xhtml">ExternalData</span></code><span class="koboSpan" id="kobo.458.1" xmlns="http://www.w3.org/1999/xhtml"> class, sending </span><code><span class="koboSpan" id="kobo.459.1" xmlns="http://www.w3.org/1999/xhtml">10</span></code><span class="koboSpan" id="kobo.460.1" xmlns="http://www.w3.org/1999/xhtml"> as an argument during the execution (the </span><code><span class="koboSpan" id="kobo.461.1" xmlns="http://www.w3.org/1999/xhtml">start</span></code><span class="koboSpan" id="kobo.462.1" xmlns="http://www.w3.org/1999/xhtml"> parameter). </span><span class="koboSpan" id="kobo.462.2" xmlns="http://www.w3.org/1999/xhtml">To do that, we must specify the </span><code><span class="koboSpan" id="kobo.463.1" xmlns="http://www.w3.org/1999/xhtml">MemberType</span></code><span class="koboSpan" id="kobo.464.1" xmlns="http://www.w3.org/1999/xhtml"> instance where the method is located so xUnit knows where to look. </span><span class="koboSpan" id="kobo.464.2" xmlns="http://www.w3.org/1999/xhtml">In this case, we pass the argument </span><code><span class="koboSpan" id="kobo.465.1" xmlns="http://www.w3.org/1999/xhtml">10</span></code><span class="koboSpan" id="kobo.466.1" xmlns="http://www.w3.org/1999/xhtml"> as the second parameter of the </span><code><span class="koboSpan" id="kobo.467.1" xmlns="http://www.w3.org/1999/xhtml">MemberData</span></code><span class="koboSpan" id="kobo.468.1" xmlns="http://www.w3.org/1999/xhtml"> constructor. </span><span class="koboSpan" id="kobo.468.2" xmlns="http://www.w3.org/1999/xhtml">However, in other cases, you can pass zero or more arguments there.Finally, we are doing the same for the </span><code><span class="koboSpan" id="kobo.469.1" xmlns="http://www.w3.org/1999/xhtml">ExternalData.TypedData</span></code><span class="koboSpan" id="kobo.470.1" xmlns="http://www.w3.org/1999/xhtml"> property, which is represented by the </span><code><span class="koboSpan" id="kobo.471.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData(nameof(ExternalData.TypedData), MemberType = typeof(ExternalData))]</span></code><span class="koboSpan" id="kobo.472.1" xmlns="http://www.w3.org/1999/xhtml"> attribute. </span><span class="koboSpan" id="kobo.472.2" xmlns="http://www.w3.org/1999/xhtml">Once again, the only difference is that the property is defined using </span><code><span class="koboSpan" id="kobo.473.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData</span></code><span class="koboSpan" id="kobo.474.1" xmlns="http://www.w3.org/1999/xhtml"> instead of </span><code><span class="koboSpan" id="kobo.475.1" xmlns="http://www.w3.org/1999/xhtml">IEnumerable&lt;object[]&gt;</span></code><span class="koboSpan" id="kobo.476.1" xmlns="http://www.w3.org/1999/xhtml">, which makes its intent clearer.When running the tests, the data provided by the </span><code><span class="koboSpan" id="kobo.477.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.478.1" xmlns="http://www.w3.org/1999/xhtml"> attributes are combined, yielding the following result in the Test Explorer:</span></p>
<figure>
<span class="koboSpan" id="kobo.479.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.5: Member data theory test results" src="../media/file7.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.480.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.5: Member data theory test results</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.481.1" xmlns="http://www.w3.org/1999/xhtml">These are only a few examples of what we can do with the </span><code><span class="koboSpan" id="kobo.482.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.483.1" xmlns="http://www.w3.org/1999/xhtml"> attribute.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.484.1" xmlns="http://www.w3.org/1999/xhtml">I understand that’s a lot of condensed information, but the goal is to cover just enough to get you started. </span><span class="koboSpan" id="kobo.484.2" xmlns="http://www.w3.org/1999/xhtml">I don’t expect you to become an expert in xUnit by reading this chapter.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.485.1" xmlns="http://www.w3.org/1999/xhtml">Last but not least, the </span><code><span class="koboSpan" id="kobo.486.1" xmlns="http://www.w3.org/1999/xhtml">[ClassData]</span></code><span class="koboSpan" id="kobo.487.1" xmlns="http://www.w3.org/1999/xhtml"> attribute gets its data from a class implementing </span><code><span class="koboSpan" id="kobo.488.1" xmlns="http://www.w3.org/1999/xhtml">IEnumerable&lt;object[]&gt;</span></code><span class="koboSpan" id="kobo.489.1" xmlns="http://www.w3.org/1999/xhtml"> or inheriting from </span><code><span class="koboSpan" id="kobo.490.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData&lt;…&gt;</span></code><span class="koboSpan" id="kobo.491.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.491.2" xmlns="http://www.w3.org/1999/xhtml">The concept is the same as the other two. </span><span class="koboSpan" id="kobo.491.3" xmlns="http://www.w3.org/1999/xhtml">Here is an example:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.492.1" xmlns="http://www.w3.org/1999/xhtml">public class ClassDataTest
{
    [Theory]
    [ClassData(typeof(TheoryDataClass))]
    [ClassData(typeof(TheoryTypedDataClass))]
    public void Should_be_equal(int value1, int value2, bool shouldBeEqual)
    {
        if (shouldBeEqual)
        {
            Assert.Equal(value1, value2);
        }
        else
        {
            Assert.NotEqual(value1, value2);
        }
    }
    public class TheoryDataClass : IEnumerable&lt;object[]&gt;
    {
        public IEnumerator&lt;object[]&gt; GetEnumerator()
        {
            yield return new object[] { 1, 2, false };
            yield return new object[] { 2, 2, true };
            yield return new object[] { 3, 3, true };
        }
        IEnumerator IEnumerable.GetEnumerator() =&gt; GetEnumerator();
    }
    public class TheoryTypedDataClass : TheoryData&lt;int, int, bool&gt;
    {
        public TheoryTypedDataClass()
        {
            Add(102, 104, false);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.493.1" xmlns="http://www.w3.org/1999/xhtml">These are very similar to </span><code><span class="koboSpan" id="kobo.494.1" xmlns="http://www.w3.org/1999/xhtml">[MemberData]</span></code><span class="koboSpan" id="kobo.495.1" xmlns="http://www.w3.org/1999/xhtml">, but we point to a type instead of pointing to a member.In </span><code><span class="koboSpan" id="kobo.496.1" xmlns="http://www.w3.org/1999/xhtml">TheoryDataClass</span></code><span class="koboSpan" id="kobo.497.1" xmlns="http://www.w3.org/1999/xhtml">, implementing the </span><code><span class="koboSpan" id="kobo.498.1" xmlns="http://www.w3.org/1999/xhtml">IEnumerable&lt;object[]&gt;</span></code><span class="koboSpan" id="kobo.499.1" xmlns="http://www.w3.org/1999/xhtml"> interface makes it easy to </span><code><span class="koboSpan" id="kobo.500.1" xmlns="http://www.w3.org/1999/xhtml">yield return</span></code><span class="koboSpan" id="kobo.501.1" xmlns="http://www.w3.org/1999/xhtml"> the results. </span><span class="koboSpan" id="kobo.501.2" xmlns="http://www.w3.org/1999/xhtml">On the other hand, in the </span><code><span class="koboSpan" id="kobo.502.1" xmlns="http://www.w3.org/1999/xhtml">TheoryTypedDataClass</span></code><span class="koboSpan" id="kobo.503.1" xmlns="http://www.w3.org/1999/xhtml"> class, by inheriting </span><code><span class="koboSpan" id="kobo.504.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData</span></code><span class="koboSpan" id="kobo.505.1" xmlns="http://www.w3.org/1999/xhtml">, we can leverage a list-like </span><code><span class="koboSpan" id="kobo.506.1" xmlns="http://www.w3.org/1999/xhtml">Add</span></code><span class="koboSpan" id="kobo.507.1" xmlns="http://www.w3.org/1999/xhtml"> method. </span><span class="koboSpan" id="kobo.507.2" xmlns="http://www.w3.org/1999/xhtml">Once again, I find inheriting from </span><code><span class="koboSpan" id="kobo.508.1" xmlns="http://www.w3.org/1999/xhtml">TheoryData</span></code><span class="koboSpan" id="kobo.509.1" xmlns="http://www.w3.org/1999/xhtml"> more explicit, but either way works with xUnit. </span><span class="koboSpan" id="kobo.509.2" xmlns="http://www.w3.org/1999/xhtml">You have many options, so choose the best one for your use case.Here is the result in the Test Explorer, which is very similar to the other attributes:</span></p>
<figure>
<span class="koboSpan" id="kobo.510.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.6: Test Explorer" src="../media/file8.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.511.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.6: Test Explorer</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.512.1" xmlns="http://www.w3.org/1999/xhtml">That’s it for the theories—next, a few last words before organizing our tests.</span></p>
</section>
<section class="level3" data-number="3.7.4" id="closing-words">
<h3 data-number="3.7.4"><span class="koboSpan" id="kobo.513.1" xmlns="http://www.w3.org/1999/xhtml">Closing words</span></h3>
<p><span class="koboSpan" id="kobo.514.1" xmlns="http://www.w3.org/1999/xhtml">Now that facts, theories, and assertions are out of the way, xUnit offers other mechanics to allow developers to inject dependencies into their test classes. </span><span class="koboSpan" id="kobo.514.2" xmlns="http://www.w3.org/1999/xhtml">These are named fixtures. </span><span class="koboSpan" id="kobo.514.3" xmlns="http://www.w3.org/1999/xhtml">Fixtures allow dependencies to be reused by all test methods of a test class by implementing the </span><code><span class="koboSpan" id="kobo.515.1" xmlns="http://www.w3.org/1999/xhtml">IClassFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.516.1" xmlns="http://www.w3.org/1999/xhtml"> interface. </span><span class="koboSpan" id="kobo.516.2" xmlns="http://www.w3.org/1999/xhtml">Fixtures are very helpful for costly dependencies, like creating an in-memory database. </span><span class="koboSpan" id="kobo.516.3" xmlns="http://www.w3.org/1999/xhtml">With fixtures, you can create the dependency once and use it multiple times. </span><span class="koboSpan" id="kobo.516.4" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.517.1" xmlns="http://www.w3.org/1999/xhtml">ValuesControllerTest</span></code><span class="koboSpan" id="kobo.518.1" xmlns="http://www.w3.org/1999/xhtml"> class in the </span><code><span class="koboSpan" id="kobo.519.1" xmlns="http://www.w3.org/1999/xhtml">MyApp.IntegrationTests</span></code><span class="koboSpan" id="kobo.520.1" xmlns="http://www.w3.org/1999/xhtml"> project shows that in action.It is important to note that xUnit creates an instance of the test class for every test run, so your dependencies are recreated every time if you are not using the fixtures.You can also share the dependency provided by the fixture between multiple test classes by using </span><code><span class="koboSpan" id="kobo.521.1" xmlns="http://www.w3.org/1999/xhtml">ICollectionFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.522.1" xmlns="http://www.w3.org/1999/xhtml">, </span><code><span class="koboSpan" id="kobo.523.1" xmlns="http://www.w3.org/1999/xhtml">[Collection]</span></code><span class="koboSpan" id="kobo.524.1" xmlns="http://www.w3.org/1999/xhtml">, and </span><code><span class="koboSpan" id="kobo.525.1" xmlns="http://www.w3.org/1999/xhtml">[CollectionDefinition]</span></code><span class="koboSpan" id="kobo.526.1" xmlns="http://www.w3.org/1999/xhtml"> instead. </span><span class="koboSpan" id="kobo.526.2" xmlns="http://www.w3.org/1999/xhtml">We won’t get into the details here, but at least you know it’s possible and know what types to look for when you need something similar.Finally, if you have worked with other testing frameworks, you might have encountered </span><strong><span class="koboSpan" id="kobo.527.1" xmlns="http://www.w3.org/1999/xhtml">setup</span></strong><span class="koboSpan" id="kobo.528.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><strong><span class="koboSpan" id="kobo.529.1" xmlns="http://www.w3.org/1999/xhtml">teardown</span></strong><span class="koboSpan" id="kobo.530.1" xmlns="http://www.w3.org/1999/xhtml"> methods. </span><span class="koboSpan" id="kobo.530.2" xmlns="http://www.w3.org/1999/xhtml">In xUnit, there are no particular attributes or mechanisms for handling setup and teardown code. </span><span class="koboSpan" id="kobo.530.3" xmlns="http://www.w3.org/1999/xhtml">Instead, xUnit uses existing OOP concepts:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.531.1" xmlns="http://www.w3.org/1999/xhtml">To set up your tests, use the class constructor.</span></li>
<li><span class="koboSpan" id="kobo.532.1" xmlns="http://www.w3.org/1999/xhtml">To tear down (clean up) your tests, implement </span><code><span class="koboSpan" id="kobo.533.1" xmlns="http://www.w3.org/1999/xhtml">IDisposable</span></code><span class="koboSpan" id="kobo.534.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.535.1" xmlns="http://www.w3.org/1999/xhtml">IAsyncDisposable</span></code><span class="koboSpan" id="kobo.536.1" xmlns="http://www.w3.org/1999/xhtml"> and dispose of your resources there.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.537.1" xmlns="http://www.w3.org/1999/xhtml">That’s it, xUnit is very simple and powerful, which is why I adopted it as my main testing framework several years ago and chose it for this book.Next, we learn to write readable test methods.</span></p>
</section>
</section>
<section class="level2" data-number="3.8" id="arrange-act-assert">
<h2 data-number="3.8"><span class="koboSpan" id="kobo.538.1" xmlns="http://www.w3.org/1999/xhtml">Arrange, Act, Assert</span></h2>
<p><span class="koboSpan" id="kobo.539.1" xmlns="http://www.w3.org/1999/xhtml">Arrange, Act, Assert (AAA or 3A) is a well-known method for writing readable tests. </span><span class="koboSpan" id="kobo.539.2" xmlns="http://www.w3.org/1999/xhtml">This technique allows you to clearly define your setup (arrange), the operation under test (act), and your assertions (assert). </span><span class="koboSpan" id="kobo.539.3" xmlns="http://www.w3.org/1999/xhtml">One efficient way to use this technique is to start by writing the 3A as comments in your test case and then write the test code in between. </span><span class="koboSpan" id="kobo.539.4" xmlns="http://www.w3.org/1999/xhtml">Here is an example:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.540.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]
public void Should_be_equals()
{
    // Arrange
    var a = 1;
    var b = 2;
    var expectedResult = 3;
    // Act
    var result = a + b;
    // Assert
    Assert.Equal(expectedResult, result);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.541.1" xmlns="http://www.w3.org/1999/xhtml">Of course, that test case cannot fail, but the three blocks are easily identifiable with the 3A comments.In general, </span><strong><span class="koboSpan" id="kobo.542.1" xmlns="http://www.w3.org/1999/xhtml">you want the Act block of your unit tests to be a single line</span></strong><span class="koboSpan" id="kobo.543.1" xmlns="http://www.w3.org/1999/xhtml">, making the test focus clear. </span><span class="koboSpan" id="kobo.543.2" xmlns="http://www.w3.org/1999/xhtml">If you need more than one line, the chances are that something is wrong in the test or the design.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.544.1" xmlns="http://www.w3.org/1999/xhtml">When the tests are very small (only a few lines), removing the comments might help readability. </span><span class="koboSpan" id="kobo.544.2" xmlns="http://www.w3.org/1999/xhtml">Furthermore, when you have nothing to set up in your test case, delete the Arrange comment to improve its readability further.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.545.1" xmlns="http://www.w3.org/1999/xhtml">Next, we learn how to organize tests into projects, directories, and files.</span></p>
</section>
<section class="level2" data-number="3.9" id="organizing-your-tests">
<h2 data-number="3.9"><span class="koboSpan" id="kobo.546.1" xmlns="http://www.w3.org/1999/xhtml">Organizing your tests</span></h2>
<p><span class="koboSpan" id="kobo.547.1" xmlns="http://www.w3.org/1999/xhtml">There are many ways of organizing test projects inside a solution, and I tend to create a unit test project for each project in the solution and one or more integration test projects.A unit test is directly related to a single unit of code, whether it’s a method or a class. </span><span class="koboSpan" id="kobo.547.2" xmlns="http://www.w3.org/1999/xhtml">It is straightforward to associate a unit test project with its respective code project (assembly), leading to a one-on-one relationship. </span><span class="koboSpan" id="kobo.547.3" xmlns="http://www.w3.org/1999/xhtml">One unit test project per assembly makes them portable, easier to navigate, and even more so when the solution grows.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.548.1" xmlns="http://www.w3.org/1999/xhtml">If you have a preferred way to organize yours that differs from what we are doing in the book, by all means, use that approach instead.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.549.1" xmlns="http://www.w3.org/1999/xhtml">Integration tests, on the other hand, can span multiple projects, so having a single rule that fits all scenarios is challenging. </span><span class="koboSpan" id="kobo.549.2" xmlns="http://www.w3.org/1999/xhtml">One integration test project per solution is often enough. </span><span class="koboSpan" id="kobo.549.3" xmlns="http://www.w3.org/1999/xhtml">Sometimes we can need more than one, depending on the context.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.550.1" xmlns="http://www.w3.org/1999/xhtml">I recommend starting with one integration test project and adding more as needed during development instead of overthinking it before getting started. </span><span class="koboSpan" id="kobo.550.2" xmlns="http://www.w3.org/1999/xhtml">Trust your judgment; you can always change the structure as your project evolves.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.551.1" xmlns="http://www.w3.org/1999/xhtml">Folder-wise, at the solution level, creating the application and its related libraries in an </span><code><span class="koboSpan" id="kobo.552.1" xmlns="http://www.w3.org/1999/xhtml">src</span></code><span class="koboSpan" id="kobo.553.1" xmlns="http://www.w3.org/1999/xhtml"> directory helps isolate the actual solution code from the test projects created under a </span><code><span class="koboSpan" id="kobo.554.1" xmlns="http://www.w3.org/1999/xhtml">test</span></code><span class="koboSpan" id="kobo.555.1" xmlns="http://www.w3.org/1999/xhtml"> directory, like this:</span></p>
<figure>
<span class="koboSpan" id="kobo.556.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.7: The Automated Testing Solution Explorer, displaying how the projects are organized" src="../media/file9.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.557.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.7: The Automated Testing Solution Explorer, displaying how the projects are organized</span></figcaption>
</figure>
<p><span class="koboSpan" id="kobo.558.1" xmlns="http://www.w3.org/1999/xhtml">That’s a well-known and effective way of organizing a solution in the .NET world.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.559.1" xmlns="http://www.w3.org/1999/xhtml">Sometimes, it is not possible or unwanted to do that. </span><span class="koboSpan" id="kobo.559.2" xmlns="http://www.w3.org/1999/xhtml">One such use case would be multiple microservices written under a single solution. </span><span class="koboSpan" id="kobo.559.3" xmlns="http://www.w3.org/1999/xhtml">In that case, you might want the tests to live closer to your microservices and not split them between </span><code><span class="koboSpan" id="kobo.560.1" xmlns="http://www.w3.org/1999/xhtml">src</span></code><span class="koboSpan" id="kobo.561.1" xmlns="http://www.w3.org/1999/xhtml"> and </span><code><span class="koboSpan" id="kobo.562.1" xmlns="http://www.w3.org/1999/xhtml">test</span></code><span class="koboSpan" id="kobo.563.1" xmlns="http://www.w3.org/1999/xhtml"> folders. </span><span class="koboSpan" id="kobo.563.2" xmlns="http://www.w3.org/1999/xhtml">So you could organize your solution by microservice instead, like one directory per microservice that contains all the projects, including tests.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.564.1" xmlns="http://www.w3.org/1999/xhtml">Let’s now dig deeper into organizing unit tests.</span></p>
<section class="level3" data-number="3.9.1" id="unit-tests">
<h3 data-number="3.9.1"><span class="koboSpan" id="kobo.565.1" xmlns="http://www.w3.org/1999/xhtml">Unit tests</span></h3>
<p><span class="koboSpan" id="kobo.566.1" xmlns="http://www.w3.org/1999/xhtml">How you organize your test projects may make a big difference between searching for your tests or making it easy to find them. </span><span class="koboSpan" id="kobo.566.2" xmlns="http://www.w3.org/1999/xhtml">Let’s look at the different aspects, from the </span><code><span class="koboSpan" id="kobo.567.1" xmlns="http://www.w3.org/1999/xhtml">namespace</span></code><span class="koboSpan" id="kobo.568.1" xmlns="http://www.w3.org/1999/xhtml"> to the test code itself.</span></p>
<section class="level4" data-number="3.9.1.1" id="namespace">
<h4 data-number="3.9.1.1"><span class="koboSpan" id="kobo.569.1" xmlns="http://www.w3.org/1999/xhtml">Namespace</span></h4>
<p><span class="koboSpan" id="kobo.570.1" xmlns="http://www.w3.org/1999/xhtml">I find it convenient to create unit tests in the same namespace as the subject under test when creating unit tests. </span><span class="koboSpan" id="kobo.570.2" xmlns="http://www.w3.org/1999/xhtml">That helps get tests and code aligned without adding any additional using statements. </span><span class="koboSpan" id="kobo.570.3" xmlns="http://www.w3.org/1999/xhtml">To make it easier when creating files, you can change the default namespace used by Visual Studio when creating a new class in your test project by adding </span><code><span class="koboSpan" id="kobo.571.1" xmlns="http://www.w3.org/1999/xhtml">&lt;RootNamespace&gt;[Project under test namespace]&lt;/RootNamespace&gt;</span></code><span class="koboSpan" id="kobo.572.1" xmlns="http://www.w3.org/1999/xhtml"> to a </span><code><span class="koboSpan" id="kobo.573.1" xmlns="http://www.w3.org/1999/xhtml">PropertyGroup</span></code><span class="koboSpan" id="kobo.574.1" xmlns="http://www.w3.org/1999/xhtml"> of the test project file (</span><code><span class="koboSpan" id="kobo.575.1" xmlns="http://www.w3.org/1999/xhtml">*.csproj</span></code><span class="koboSpan" id="kobo.576.1" xmlns="http://www.w3.org/1999/xhtml">), like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.577.1" xmlns="http://www.w3.org/1999/xhtml">&lt;PropertyGroup&gt;
  ...
  </span><span class="koboSpan" id="kobo.577.2" xmlns="http://www.w3.org/1999/xhtml">&lt;RootNamespace&gt;MyApp&lt;/RootNamespace&gt;
&lt;/PropertyGroup&gt;</span></code></pre>
</div>
</section>
<section class="level4" data-number="3.9.1.2" id="test-class-name">
<h4 data-number="3.9.1.2"><span class="koboSpan" id="kobo.578.1" xmlns="http://www.w3.org/1999/xhtml">Test class name</span></h4>
<p><span class="koboSpan" id="kobo.579.1" xmlns="http://www.w3.org/1999/xhtml">By convention, I name test classes </span><code><span class="koboSpan" id="kobo.580.1" xmlns="http://www.w3.org/1999/xhtml">[class under test]Test.cs</span></code><span class="koboSpan" id="kobo.581.1" xmlns="http://www.w3.org/1999/xhtml"> and create them in the same directory as in the original project. </span><span class="koboSpan" id="kobo.581.2" xmlns="http://www.w3.org/1999/xhtml">Finding tests is easy when following that simple rule since the test code is in the same location of the file tree as the code under test but in two distinct projects.</span></p>
<figure>
<span class="koboSpan" id="kobo.582.1" xmlns="http://www.w3.org/1999/xhtml"><img alt="Figure 2.8: The Automated Testing Solution Explorer, displaying how tests are organized" src="../media/file10.png"/></span><figcaption aria-hidden="true"><span class="koboSpan" id="kobo.583.1" xmlns="http://www.w3.org/1999/xhtml">Figure 2.8: The Automated Testing Solution Explorer, displaying how tests are organized</span></figcaption>
</figure>
</section>
<section class="level4" data-number="3.9.1.3" id="test-code-inside-the-test-class">
<h4 data-number="3.9.1.3"><span class="koboSpan" id="kobo.584.1" xmlns="http://www.w3.org/1999/xhtml">Test code inside the test class</span></h4>
<p><span class="koboSpan" id="kobo.585.1" xmlns="http://www.w3.org/1999/xhtml">For the test code itself, I follow a multi-level structure similar to the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.586.1" xmlns="http://www.w3.org/1999/xhtml">One test class is named the same as the class under test.</span></li>
<li><span class="koboSpan" id="kobo.587.1" xmlns="http://www.w3.org/1999/xhtml">One nested test class per method to test from the class under test.</span></li>
<li><span class="koboSpan" id="kobo.588.1" xmlns="http://www.w3.org/1999/xhtml">One test method per test case of the method under test.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.589.1" xmlns="http://www.w3.org/1999/xhtml">This technique helps organize tests by test case while keeping a clear hierarchy, leading to the following hierarchy:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.590.1" xmlns="http://www.w3.org/1999/xhtml">Class under test</span></li>
<li><span class="koboSpan" id="kobo.591.1" xmlns="http://www.w3.org/1999/xhtml">Method under test</span></li>
<li><span class="koboSpan" id="kobo.592.1" xmlns="http://www.w3.org/1999/xhtml">Test case using that method</span></li>
</ul>
<p><span class="koboSpan" id="kobo.593.1" xmlns="http://www.w3.org/1999/xhtml">In code, that translates to the following:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.594.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyApp.IntegrationTests.Controllers;
public class ValuesControllerTest
{
    public class Get : ValuesControllerTest
    {
        [Fact]
        public void Should_return_the_expected_strings()
        {
            // Arrange
            var sut = new ValuesController();
            // Act
            var result = sut.Get();
            // Assert
            Assert.Collection(result.Value,
                x =&gt; Assert.Equal("value1", x), 
                x =&gt; Assert.Equal("value2", x) 
            );
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.595.1" xmlns="http://www.w3.org/1999/xhtml">This convention allows you to set up tests step by step. </span><span class="koboSpan" id="kobo.595.2" xmlns="http://www.w3.org/1999/xhtml">For example, by inheriting the outer class (the </span><code><span class="koboSpan" id="kobo.596.1" xmlns="http://www.w3.org/1999/xhtml">ValuesControllerTest</span></code><span class="koboSpan" id="kobo.597.1" xmlns="http://www.w3.org/1999/xhtml"> class here) from the inner class (the </span><code><span class="koboSpan" id="kobo.598.1" xmlns="http://www.w3.org/1999/xhtml">Get</span></code><span class="koboSpan" id="kobo.599.1" xmlns="http://www.w3.org/1999/xhtml"> nested class), you can create top-level private mocks or classes shared by all nested classes and test methods. </span><span class="koboSpan" id="kobo.599.2" xmlns="http://www.w3.org/1999/xhtml">Then, for each method to test, you can modify the setup or create other private test elements in the nested classes. </span><span class="koboSpan" id="kobo.599.3" xmlns="http://www.w3.org/1999/xhtml">Finally, you can do more configuration per test case inside the test method (the </span><code><span class="koboSpan" id="kobo.600.1" xmlns="http://www.w3.org/1999/xhtml">Should_return_the_expected_strings</span></code><span class="koboSpan" id="kobo.601.1" xmlns="http://www.w3.org/1999/xhtml"> method here).</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.602.1" xmlns="http://www.w3.org/1999/xhtml">Don’t go too hard on reusability inside your test classes, as it can make tests harder to read from an external eye, such as a reviewer or another developer that needs to play there. </span><span class="koboSpan" id="kobo.602.2" xmlns="http://www.w3.org/1999/xhtml">Unit tests should remain focused, small, and easy to read: a unit of code testing another unit of code. </span><span class="koboSpan" id="kobo.602.3" xmlns="http://www.w3.org/1999/xhtml">Too much reusability may lead to a brittle test suite.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.603.1" xmlns="http://www.w3.org/1999/xhtml">Now that we have explored organizing unit tests, let’s look at integration tests.</span></p>
</section>
</section>
<section class="level3" data-number="3.9.2" id="integration-tests">
<h3 data-number="3.9.2"><span class="koboSpan" id="kobo.604.1" xmlns="http://www.w3.org/1999/xhtml">Integration tests</span></h3>
<p><span class="koboSpan" id="kobo.605.1" xmlns="http://www.w3.org/1999/xhtml">Integration tests are harder to organize because they depend on multiple units, can cross project boundaries, and interact with various dependencies.We can create one integration test project for most simple solutions or many for more complex scenarios.When creating one, you can name the project </span><code><span class="koboSpan" id="kobo.606.1" xmlns="http://www.w3.org/1999/xhtml">IntegrationTests</span></code><span class="koboSpan" id="kobo.607.1" xmlns="http://www.w3.org/1999/xhtml"> or start with the entry point of your tests, like a REST API project, and name the project </span><code><span class="koboSpan" id="kobo.608.1" xmlns="http://www.w3.org/1999/xhtml">[Name of the API project].IntegrationTests</span></code><span class="koboSpan" id="kobo.609.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.609.2" xmlns="http://www.w3.org/1999/xhtml">At this point, how to name the integration test project depends on your solution structure and intent.When you need multiple integration projects, you can follow a convention similar to unit tests and associate your integration projects one-to-one: </span><code><span class="koboSpan" id="kobo.610.1" xmlns="http://www.w3.org/1999/xhtml">[Project under test].IntegrationTests</span></code><span class="koboSpan" id="kobo.611.1" xmlns="http://www.w3.org/1999/xhtml">.Inside those projects, it depends on how you want to attack the problem and the structure of the solution itself. </span><span class="koboSpan" id="kobo.611.2" xmlns="http://www.w3.org/1999/xhtml">Start by identifying the features under test. </span><span class="koboSpan" id="kobo.611.3" xmlns="http://www.w3.org/1999/xhtml">Name the test classes in a way that mimics your requirements, organize those into sub-folders (maybe a category or group of requirements), and code test cases as methods. </span><span class="koboSpan" id="kobo.611.4" xmlns="http://www.w3.org/1999/xhtml">You can also leverage nested classes, as we did with unit tests.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.612.1" xmlns="http://www.w3.org/1999/xhtml">We write tests throughout the book, so you will have plenty of examples to make sense of all this if it’s not clear now.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.613.1" xmlns="http://www.w3.org/1999/xhtml">Next, we implement an integration test by leveraging ASP.NET Core features.</span></p>
</section>
</section>
<section class="level2" data-number="3.10" id="writing-asp.net-core-integration-tests">
<h2 data-number="3.10"><span class="koboSpan" id="kobo.614.1" xmlns="http://www.w3.org/1999/xhtml">Writing ASP.NET Core integration tests</span></h2>
<p><span class="koboSpan" id="kobo.615.1" xmlns="http://www.w3.org/1999/xhtml">When Microsoft built ASP.NET Core from the ground up, they fixed and improved so many things that I cannot enumerate them all here, including testability.Nowadays, there are two ways to structure a .NET program:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.616.1" xmlns="http://www.w3.org/1999/xhtml">The classic ASP.NET Core </span><code><span class="koboSpan" id="kobo.617.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.618.1" xmlns="http://www.w3.org/1999/xhtml"> and the </span><code><span class="koboSpan" id="kobo.619.1" xmlns="http://www.w3.org/1999/xhtml">Startup</span></code><span class="koboSpan" id="kobo.620.1" xmlns="http://www.w3.org/1999/xhtml"> classes. </span><span class="koboSpan" id="kobo.620.2" xmlns="http://www.w3.org/1999/xhtml">This model might be found in existing projects (created before .NET 6).</span></li>
<li><span class="koboSpan" id="kobo.621.1" xmlns="http://www.w3.org/1999/xhtml">The minimal hosting model introduced in .NET 6. </span><span class="koboSpan" id="kobo.621.2" xmlns="http://www.w3.org/1999/xhtml">This may look familiar to you if you know Node.js, as this model encourages you to write the start-up code in the Program.cs file by leveraging top-level statements. </span><span class="koboSpan" id="kobo.621.3" xmlns="http://www.w3.org/1999/xhtml">You will most likely find this model in new projects (created after the release of .NET 6).</span></li>
</ul>
<p><span class="koboSpan" id="kobo.622.1" xmlns="http://www.w3.org/1999/xhtml">No matter how you write your program, that’s the place to define how the application’s composition and how it boots. </span><span class="koboSpan" id="kobo.622.2" xmlns="http://www.w3.org/1999/xhtml">Moreover, we can leverage the same testing tools more or less seamlessly.In the case of a web application, the scope of our integration tests is often to call the endpoint of a controller over HTTP and assert the response. </span><span class="koboSpan" id="kobo.622.3" xmlns="http://www.w3.org/1999/xhtml">Luckily, in .NET Core 2.1, the .NET team added the </span><code><span class="koboSpan" id="kobo.623.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;TEntry&gt;</span></code><span class="koboSpan" id="kobo.624.1" xmlns="http://www.w3.org/1999/xhtml"> class to make the integration testing of web applications easier. </span><span class="koboSpan" id="kobo.624.2" xmlns="http://www.w3.org/1999/xhtml">With that class, we can boot up an ASP.NET Core application in memory and query it using the supplied </span><code><span class="koboSpan" id="kobo.625.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.626.1" xmlns="http://www.w3.org/1999/xhtml"> in a few lines of code. </span><span class="koboSpan" id="kobo.626.2" xmlns="http://www.w3.org/1999/xhtml">The test classes also provide extension points to configure the server, such as replacing implementations with mocks, stubs, or other test-specific elements.Let’s start by booting up a classic web application test.</span></p>
<section class="level3" data-number="3.10.1" id="classic-web-application">
<h3 data-number="3.10.1"><span class="koboSpan" id="kobo.627.1" xmlns="http://www.w3.org/1999/xhtml">Classic web application</span></h3>
<p><span class="koboSpan" id="kobo.628.1" xmlns="http://www.w3.org/1999/xhtml">In a classic ASP.NET Core application, the </span><code><span class="koboSpan" id="kobo.629.1" xmlns="http://www.w3.org/1999/xhtml">TEntry</span></code><span class="koboSpan" id="kobo.630.1" xmlns="http://www.w3.org/1999/xhtml"> generic parameter of the </span><code><span class="koboSpan" id="kobo.631.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;TEntry&gt;</span></code><span class="koboSpan" id="kobo.632.1" xmlns="http://www.w3.org/1999/xhtml"> class is usually the </span><code><span class="koboSpan" id="kobo.633.1" xmlns="http://www.w3.org/1999/xhtml">Startup</span></code><span class="koboSpan" id="kobo.634.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.635.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.636.1" xmlns="http://www.w3.org/1999/xhtml"> class of your project under test.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.637.1" xmlns="http://www.w3.org/1999/xhtml">The test cases are in the </span><code><span class="koboSpan" id="kobo.638.1" xmlns="http://www.w3.org/1999/xhtml">Automated Testing</span></code><span class="koboSpan" id="kobo.639.1" xmlns="http://www.w3.org/1999/xhtml"> solution under the </span><code><span class="koboSpan" id="kobo.640.1" xmlns="http://www.w3.org/1999/xhtml">MyApp.IntegrationTests</span></code><span class="koboSpan" id="kobo.641.1" xmlns="http://www.w3.org/1999/xhtml"> project.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.642.1" xmlns="http://www.w3.org/1999/xhtml">Let’s start by looking at the test code structure before breaking it down:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.643.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyApp.IntegrationTests.Controllers;
public class ValuesControllerTest : IClassFixture&lt;WebApplicationFactory&lt;Startup&gt;&gt;
{
    private readonly HttpClient _httpClient;
    public ValuesControllerTest(
        WebApplicationFactory&lt;Startup&gt; webApplicationFactory)
    {
        _httpClient = webApplicationFactory.CreateClient();
    }
    public class Get : ValuesControllerTest
    {
        public Get(WebApplicationFactory&lt;Startup&gt; webApplicationFactory)
            : base(webApplicationFactory) { }
        [Fact]
        public async Task Should_respond_a_status_200_OK()
        {
            // Omitted Test Case 1
        }
        [Fact]
        public async Task Should_respond_the_expected_strings()
        {
            // Omitted Test Case 2
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.644.1" xmlns="http://www.w3.org/1999/xhtml">The first piece of the preceding code that is relevant to us is how we get an instance of the </span><code><span class="koboSpan" id="kobo.645.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;Startup&gt;</span></code><span class="koboSpan" id="kobo.646.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.646.2" xmlns="http://www.w3.org/1999/xhtml">We inject a </span><code><span class="koboSpan" id="kobo.647.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;Startup&gt;</span></code><span class="koboSpan" id="kobo.648.1" xmlns="http://www.w3.org/1999/xhtml"> object into the constructor by implementing the </span><code><span class="koboSpan" id="kobo.649.1" xmlns="http://www.w3.org/1999/xhtml">IClassFixture&lt;T&gt;</span></code><span class="koboSpan" id="kobo.650.1" xmlns="http://www.w3.org/1999/xhtml"> interface (a xUnit feature). </span><span class="koboSpan" id="kobo.650.2" xmlns="http://www.w3.org/1999/xhtml">We can also use the factory to configure the test server, but we don’t need to here, so we can only keep a reference on the </span><code><span class="koboSpan" id="kobo.651.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.652.1" xmlns="http://www.w3.org/1999/xhtml">, preconfigured to connect to the in-memory test server.Then, we may have noticed we have the nested </span><code><span class="koboSpan" id="kobo.653.1" xmlns="http://www.w3.org/1999/xhtml">Get</span></code><span class="koboSpan" id="kobo.654.1" xmlns="http://www.w3.org/1999/xhtml"> class that inherits the </span><code><span class="koboSpan" id="kobo.655.1" xmlns="http://www.w3.org/1999/xhtml">ValuesControllerTest</span></code><span class="koboSpan" id="kobo.656.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.656.2" xmlns="http://www.w3.org/1999/xhtml">The </span><code><span class="koboSpan" id="kobo.657.1" xmlns="http://www.w3.org/1999/xhtml">Get</span></code><span class="koboSpan" id="kobo.658.1" xmlns="http://www.w3.org/1999/xhtml"> class contains the test cases. </span><span class="koboSpan" id="kobo.658.2" xmlns="http://www.w3.org/1999/xhtml">By inheriting the </span><code><span class="koboSpan" id="kobo.659.1" xmlns="http://www.w3.org/1999/xhtml">ValuesControllerTest</span></code><span class="koboSpan" id="kobo.660.1" xmlns="http://www.w3.org/1999/xhtml"> class, we can leverage the </span><code><span class="koboSpan" id="kobo.661.1" xmlns="http://www.w3.org/1999/xhtml">_httpClient</span></code><span class="koboSpan" id="kobo.662.1" xmlns="http://www.w3.org/1999/xhtml"> field from the test cases we are about to see.In the first test case, we use </span><code><span class="koboSpan" id="kobo.663.1" xmlns="http://www.w3.org/1999/xhtml">HttpClient</span></code><span class="koboSpan" id="kobo.664.1" xmlns="http://www.w3.org/1999/xhtml"> to query the </span><code><span class="koboSpan" id="kobo.665.1" xmlns="http://www.w3.org/1999/xhtml">http://localhost/api/values</span></code><span class="koboSpan" id="kobo.666.1" xmlns="http://www.w3.org/1999/xhtml"> URI, accessible through the in-memory server. </span><span class="koboSpan" id="kobo.666.2" xmlns="http://www.w3.org/1999/xhtml">Then, we assert that the status code of the HTTP response was a success (</span><code><span class="koboSpan" id="kobo.667.1" xmlns="http://www.w3.org/1999/xhtml">200 OK</span></code><span class="koboSpan" id="kobo.668.1" xmlns="http://www.w3.org/1999/xhtml">):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.669.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]
public async Task Should_respond_a_status_200_OK()
{
    // Act
    var result = await _httpClient
        .GetAsync("/api/values");
    // Assert
    Assert.Equal(HttpStatusCode.OK, result.StatusCode);
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.670.1" xmlns="http://www.w3.org/1999/xhtml">The second test case also sends an HTTP request to the in-memory server but deserializes the body’s content as a string[] to ensure the values are the same as expected instead of validating the status code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.671.1" xmlns="http://www.w3.org/1999/xhtml">[Fact]
public async Task Should_respond_the_expected_strings()
{
    // Act
    var result = await _httpClient
        .GetFromJsonAsync&lt;string[]&gt;("/api/values");
    // Assert
    Assert.Collection(result,
        x =&gt; Assert.Equal("value1", x),
        x =&gt; Assert.Equal("value2", x)
    );
}</span></code></pre>
</div>
<blockquote>
<p><span class="koboSpan" id="kobo.672.1" xmlns="http://www.w3.org/1999/xhtml">As you may have noticed from the test cases, the </span><code><span class="koboSpan" id="kobo.673.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.674.1" xmlns="http://www.w3.org/1999/xhtml"> preconfigured the </span><code><span class="koboSpan" id="kobo.675.1" xmlns="http://www.w3.org/1999/xhtml">BaseAddress</span></code><span class="koboSpan" id="kobo.676.1" xmlns="http://www.w3.org/1999/xhtml"> property for us, so we don’t need to prefix our requests with </span><code><span class="koboSpan" id="kobo.677.1" xmlns="http://www.w3.org/1999/xhtml">http://localhost</span></code><span class="koboSpan" id="kobo.678.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
</blockquote>
<p><span class="koboSpan" id="kobo.679.1" xmlns="http://www.w3.org/1999/xhtml">When running those tests, an in-memory web server starts. </span><span class="koboSpan" id="kobo.679.2" xmlns="http://www.w3.org/1999/xhtml">Then, HTTP requests are sent to that server, testing the complete application. </span><span class="koboSpan" id="kobo.679.3" xmlns="http://www.w3.org/1999/xhtml">The tests are simple in this case, but you can create more complex test cases in more complex programs.Next, we explore how to do the same for minimal APIs.</span></p>
</section>
<section class="level3" data-number="3.10.2" id="minimal-hosting">
<h3 data-number="3.10.2"><span class="koboSpan" id="kobo.680.1" xmlns="http://www.w3.org/1999/xhtml">Minimal hosting</span></h3>
<p><span class="koboSpan" id="kobo.681.1" xmlns="http://www.w3.org/1999/xhtml">Unfortunately, we must use a workaround to make the </span><code><span class="koboSpan" id="kobo.682.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.683.1" xmlns="http://www.w3.org/1999/xhtml"> class discoverable when using minimal hosting. </span><span class="koboSpan" id="kobo.683.2" xmlns="http://www.w3.org/1999/xhtml">Let’s explore a few workarounds that leverage minimal APIs, allowing you to pick the one you prefer.</span></p>
<section class="level4" data-number="3.10.2.1" id="first-workaround">
<h4 data-number="3.10.2.1"><span class="koboSpan" id="kobo.684.1" xmlns="http://www.w3.org/1999/xhtml">First workaround</span></h4>
<p><span class="koboSpan" id="kobo.685.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.686.1" xmlns="http://www.w3.org/1999/xhtml">first workaround</span></strong><span class="koboSpan" id="kobo.687.1" xmlns="http://www.w3.org/1999/xhtml"> is to use any other class in the assembly as the </span><code><span class="koboSpan" id="kobo.688.1" xmlns="http://www.w3.org/1999/xhtml">TEntryPoint</span></code><span class="koboSpan" id="kobo.689.1" xmlns="http://www.w3.org/1999/xhtml"> of </span><code><span class="koboSpan" id="kobo.690.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;TEntryPoint&gt;</span></code><span class="koboSpan" id="kobo.691.1" xmlns="http://www.w3.org/1999/xhtml"> instead of the </span><code><span class="koboSpan" id="kobo.692.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.693.1" xmlns="http://www.w3.org/1999/xhtml"> or </span><code><span class="koboSpan" id="kobo.694.1" xmlns="http://www.w3.org/1999/xhtml">Startup</span></code><span class="koboSpan" id="kobo.695.1" xmlns="http://www.w3.org/1999/xhtml"> class. </span><span class="koboSpan" id="kobo.695.2" xmlns="http://www.w3.org/1999/xhtml">This makes what </span><code><span class="koboSpan" id="kobo.696.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.697.1" xmlns="http://www.w3.org/1999/xhtml"> does a little less explicit, but that’s all. </span><span class="koboSpan" id="kobo.697.2" xmlns="http://www.w3.org/1999/xhtml">Since I tend to prefer readable code, I do not recommend this.</span></p>
</section>
<section class="level4" data-number="3.10.2.2" id="second-workaround">
<h4 data-number="3.10.2.2"><span class="koboSpan" id="kobo.698.1" xmlns="http://www.w3.org/1999/xhtml">Second workaround</span></h4>
<p><span class="koboSpan" id="kobo.699.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.700.1" xmlns="http://www.w3.org/1999/xhtml">second workaround</span></strong><span class="koboSpan" id="kobo.701.1" xmlns="http://www.w3.org/1999/xhtml"> is to add a line at the bottom of the </span><code><span class="koboSpan" id="kobo.702.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.703.1" xmlns="http://www.w3.org/1999/xhtml"> file (or anywhere else in the project) to change the autogenerated </span><code><span class="koboSpan" id="kobo.704.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.705.1" xmlns="http://www.w3.org/1999/xhtml"> class visibility from </span><code><span class="koboSpan" id="kobo.706.1" xmlns="http://www.w3.org/1999/xhtml">internal</span></code><span class="koboSpan" id="kobo.707.1" xmlns="http://www.w3.org/1999/xhtml"> to </span><code><span class="koboSpan" id="kobo.708.1" xmlns="http://www.w3.org/1999/xhtml">public</span></code><span class="koboSpan" id="kobo.709.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.709.2" xmlns="http://www.w3.org/1999/xhtml">Here is the complete </span><code><span class="koboSpan" id="kobo.710.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.711.1" xmlns="http://www.w3.org/1999/xhtml"> file with that added line (highlighted):</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.712.1" xmlns="http://www.w3.org/1999/xhtml">var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();
public partial class Program { }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.713.1" xmlns="http://www.w3.org/1999/xhtml">Then, the test cases are very similar to the ones of the classic web application explored previously. </span><span class="koboSpan" id="kobo.713.2" xmlns="http://www.w3.org/1999/xhtml">The only difference is the program itself, both programs don’t do the same thing.</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.714.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyMinimalApiApp;
public class ProgramTest : IClassFixture&lt;WebApplicationFactory&lt;Program&gt;&gt;
{
    private readonly HttpClient _httpClient;
    public ProgramTest(
        WebApplicationFactory&lt;Program&gt; webApplicationFactory)
    {
        _httpClient = webApplicationFactory.CreateClient();
    }
    public class Get : ProgramTest
    {
        public Get(WebApplicationFactory&lt;Program&gt; webApplicationFactory) 
            : base(webApplicationFactory) { }
        [Fact]
        public async Task Should_respond_a_status_200_OK()
        {
            // Act
            var result = await _httpClient.GetAsync("/");
            // Assert
            Assert.Equal(HttpStatusCode.OK, result.StatusCode);
        }
        [Fact]
        public async Task Should_respond_hello_world()
        {
            // Act
            var result = await _httpClient.GetAsync("/");
            // Assert
            var contentText = await result.Content.ReadAsStringAsync();
            Assert.Equal("Hello World!", contentText);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.715.1" xmlns="http://www.w3.org/1999/xhtml">The only change is the expected result as the endpoint returns the </span><code><span class="koboSpan" id="kobo.716.1" xmlns="http://www.w3.org/1999/xhtml">text/plain</span></code><span class="koboSpan" id="kobo.717.1" xmlns="http://www.w3.org/1999/xhtml"> string </span><code><span class="koboSpan" id="kobo.718.1" xmlns="http://www.w3.org/1999/xhtml">Hello World!</span></code><span class="koboSpan" id="kobo.719.1" xmlns="http://www.w3.org/1999/xhtml"> instead of a collection of strings serialized as JSON. </span><span class="koboSpan" id="kobo.719.2" xmlns="http://www.w3.org/1999/xhtml">The test cases would be identical if the two endpoints produced the same result.</span></p>
</section>
<section class="level4" data-number="3.10.2.3" id="third-workaround">
<h4 data-number="3.10.2.3"><span class="koboSpan" id="kobo.720.1" xmlns="http://www.w3.org/1999/xhtml">Third workaround</span></h4>
<p><span class="koboSpan" id="kobo.721.1" xmlns="http://www.w3.org/1999/xhtml">The </span><strong><span class="koboSpan" id="kobo.722.1" xmlns="http://www.w3.org/1999/xhtml">third workaround</span></strong><span class="koboSpan" id="kobo.723.1" xmlns="http://www.w3.org/1999/xhtml"> is to instantiate </span><code><span class="koboSpan" id="kobo.724.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.725.1" xmlns="http://www.w3.org/1999/xhtml"> manually instead of leveraging a fixture. </span><span class="koboSpan" id="kobo.725.2" xmlns="http://www.w3.org/1999/xhtml">We can use the </span><code><span class="koboSpan" id="kobo.726.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.727.1" xmlns="http://www.w3.org/1999/xhtml"> class, which requires changing its visibility by adding the following line to the </span><code><span class="koboSpan" id="kobo.728.1" xmlns="http://www.w3.org/1999/xhtml">Program.cs</span></code><span class="koboSpan" id="kobo.729.1" xmlns="http://www.w3.org/1999/xhtml"> file:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.730.1" xmlns="http://www.w3.org/1999/xhtml">public partial class Program { }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.731.1" xmlns="http://www.w3.org/1999/xhtml">However, instead of injecting the instance using the </span><code><span class="koboSpan" id="kobo.732.1" xmlns="http://www.w3.org/1999/xhtml">IClassFixture</span></code><span class="koboSpan" id="kobo.733.1" xmlns="http://www.w3.org/1999/xhtml"> interface, we instantiate the factory manually. </span><span class="koboSpan" id="kobo.733.2" xmlns="http://www.w3.org/1999/xhtml">To ensure we dispose the </span><code><span class="koboSpan" id="kobo.734.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.735.1" xmlns="http://www.w3.org/1999/xhtml"> instance, we also implement the </span><code><span class="koboSpan" id="kobo.736.1" xmlns="http://www.w3.org/1999/xhtml">IAsyncDisposable</span></code><span class="koboSpan" id="kobo.737.1" xmlns="http://www.w3.org/1999/xhtml"> interface.Here’s the complete example, which is very similar to the previous workaround:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.738.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyMinimalApiApp;
public class ProgramTestWithoutFixture : IAsyncDisposable
{
    private readonly WebApplicationFactory&lt;Program&gt; _webApplicationFactory;
    private readonly HttpClient _httpClient;
    public ProgramTestWithoutFixture()
    {
        _webApplicationFactory = new WebApplicationFactory&lt;Program&gt;();
        _httpClient = _webApplicationFactory.CreateClient();
    }
    public ValueTask DisposeAsync()
    {
        return ((IAsyncDisposable)_webApplicationFactory)
            .DisposeAsync();
    }
    // Omitted nested Get class
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.739.1" xmlns="http://www.w3.org/1999/xhtml">I omitted the test cases in the preceding code block because they are the same as the previous workarounds. </span><span class="koboSpan" id="kobo.739.2" xmlns="http://www.w3.org/1999/xhtml">The full source code is available on GitHub: </span><a href="https://adpg.link/vzkr"><span class="koboSpan" id="kobo.740.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/vzkr</span></a><span class="koboSpan" id="kobo.741.1" xmlns="http://www.w3.org/1999/xhtml">.</span></p>
<blockquote>
<p><span class="koboSpan" id="kobo.742.1" xmlns="http://www.w3.org/1999/xhtml">Using class fixtures is more performant since the factory and the server get created only once per test run instead of recreated for every test method.</span></p>
</blockquote>
</section>
<section class="level4" data-number="3.10.2.4" id="creating-a-test-application">
<h4 data-number="3.10.2.4"><span class="koboSpan" id="kobo.743.1" xmlns="http://www.w3.org/1999/xhtml">Creating a test application</span></h4>
<p><span class="koboSpan" id="kobo.744.1" xmlns="http://www.w3.org/1999/xhtml">Finally, we can create a dedicated class that instantiates </span><code><span class="koboSpan" id="kobo.745.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory</span></code><span class="koboSpan" id="kobo.746.1" xmlns="http://www.w3.org/1999/xhtml"> manually. </span><span class="koboSpan" id="kobo.746.2" xmlns="http://www.w3.org/1999/xhtml">It leverages the other workarounds but makes the test cases more readable. </span><span class="koboSpan" id="kobo.746.3" xmlns="http://www.w3.org/1999/xhtml">By encapsulating the setup of the test application in a class, you will improve the reusability and maintenance cost in most cases.First, we need to change the </span><code><span class="koboSpan" id="kobo.747.1" xmlns="http://www.w3.org/1999/xhtml">Program</span></code><span class="koboSpan" id="kobo.748.1" xmlns="http://www.w3.org/1999/xhtml"> class visibility by adding the following line to the </span><code><span class="koboSpan" id="kobo.749.1" xmlns="http://www.w3.org/1999/xhtml">Project.cs</span></code><span class="koboSpan" id="kobo.750.1" xmlns="http://www.w3.org/1999/xhtml"> file:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.751.1" xmlns="http://www.w3.org/1999/xhtml">public partial class Program { }</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.752.1" xmlns="http://www.w3.org/1999/xhtml">Now that we can access the Program class without the need to allow internal visibility to our test project, we can create our test application like this:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.753.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyMinimalApiApp;
public class MyTestApplication : WebApplicationFactory&lt;Program&gt; {}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.754.1" xmlns="http://www.w3.org/1999/xhtml">Finally, we can reuse the same code to test our program but instantiate </span><code><span class="koboSpan" id="kobo.755.1" xmlns="http://www.w3.org/1999/xhtml">MyTestApplication</span></code><span class="koboSpan" id="kobo.756.1" xmlns="http://www.w3.org/1999/xhtml"> instead of </span><code><span class="koboSpan" id="kobo.757.1" xmlns="http://www.w3.org/1999/xhtml">WebApplicationFactory&lt;Program&gt;</span></code><span class="koboSpan" id="kobo.758.1" xmlns="http://www.w3.org/1999/xhtml">, highlighted in the following code:</span></p>
<div class="C0-CodePACKT">
<pre><code><span class="koboSpan" id="kobo.759.1" xmlns="http://www.w3.org/1999/xhtml">namespace MyMinimalApiApp;
public class MyTestApplicationTest
{
    public class Get : ProgramTestWithoutFixture
    {
        [Fact]
        public async Task Should_respond_a_status_200_OK()
        {
            // Arrange
            await using var app = new MyTestApplication();
            var httpClient = app.CreateClient();
            // Act
            var result = await httpClient.GetAsync("/");
            // Assert
            Assert.Equal(HttpStatusCode.OK, result.StatusCode);
        }
    }
}</span></code></pre>
</div>
<p><span class="koboSpan" id="kobo.760.1" xmlns="http://www.w3.org/1999/xhtml">You can also leverage fixtures, but for the sake of simplicity, I decided to show you how to instantiate our new test application manually.And that’s it. </span><span class="koboSpan" id="kobo.760.2" xmlns="http://www.w3.org/1999/xhtml">We have covered multiple ways to work around integration testing minimal APIs simplistically and elegantly. </span><span class="koboSpan" id="kobo.760.3" xmlns="http://www.w3.org/1999/xhtml">Next, we explore a few testing principles before moving to architectural principles in the next chapter.</span></p>
</section>
</section>
</section>
<section class="level2" data-number="3.11" id="important-testing-principles">
<h2 data-number="3.11"><span class="koboSpan" id="kobo.761.1" xmlns="http://www.w3.org/1999/xhtml">Important testing principles</span></h2>
<p><span class="koboSpan" id="kobo.762.1" xmlns="http://www.w3.org/1999/xhtml">One essential thing to remember when writing tests is to test use cases, not the code itself; we are testing features’ correctness, not code correctness. </span><span class="koboSpan" id="kobo.762.2" xmlns="http://www.w3.org/1999/xhtml">Of course, if the expected outcome of a feature is correct, that also means the codebase is correct. </span><span class="koboSpan" id="kobo.762.3" xmlns="http://www.w3.org/1999/xhtml">However, it is not always true the other way around; correct code may yield an incorrect outcome. </span><span class="koboSpan" id="kobo.762.4" xmlns="http://www.w3.org/1999/xhtml">Also, remember that code costs money to write, while features deliver value.To help with that, test requirements should revolve around </span><strong><span class="koboSpan" id="kobo.763.1" xmlns="http://www.w3.org/1999/xhtml">inputs and outputs</span></strong><span class="koboSpan" id="kobo.764.1" xmlns="http://www.w3.org/1999/xhtml">. </span><span class="koboSpan" id="kobo.764.2" xmlns="http://www.w3.org/1999/xhtml">When specific values go into your subject under test, you expect particular values to come out. </span><span class="koboSpan" id="kobo.764.3" xmlns="http://www.w3.org/1999/xhtml">Whether you are testing a simple </span><code><span class="koboSpan" id="kobo.765.1" xmlns="http://www.w3.org/1999/xhtml">Add</span></code><span class="koboSpan" id="kobo.766.1" xmlns="http://www.w3.org/1999/xhtml"> method where the ins are two or more numbers, and the out is the sum of those numbers, or a more complex feature where the ins come from a form, and the out is the record getting persisted in a database, most of the time, we are testing that inputs produced an output or an outcome.Another concept is to divide those units as a query or a command. </span><span class="koboSpan" id="kobo.766.2" xmlns="http://www.w3.org/1999/xhtml">No matter how you organize your code, from a simple single-file application to a microservices architecture-base Netflix clone, all simple or compounded operations are queries or commands. </span><span class="koboSpan" id="kobo.766.3" xmlns="http://www.w3.org/1999/xhtml">Thinking about a system this way should help you test the ins and outs. </span><span class="koboSpan" id="kobo.766.4" xmlns="http://www.w3.org/1999/xhtml">We discuss queries and commands in several chapters, so keep reading to learn more.Now that we have laid this out, what if a unit must perform multiple operations, such as reading from a database, and then send multiple commands? </span><span class="koboSpan" id="kobo.766.5" xmlns="http://www.w3.org/1999/xhtml">You can create and test multiple smaller units (individual operations) and another unit that orchestrates those building blocks, allowing you to test each piece in isolation. </span><span class="koboSpan" id="kobo.766.6" xmlns="http://www.w3.org/1999/xhtml">We explore how to achieve this throughout the book.In a nutshell, when writing automated tests:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.767.1" xmlns="http://www.w3.org/1999/xhtml">In case of a query, we assert the output of the unit undergoing testing based on its input parameters.</span></li>
<li><span class="koboSpan" id="kobo.768.1" xmlns="http://www.w3.org/1999/xhtml">In case of a command, we assert the outcome of the unit undergoing testing based on its input parameters.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.769.1" xmlns="http://www.w3.org/1999/xhtml">We explore numerous techniques throughout the book to help you achieve that level of separation, starting with architectural principles in the next chapter.</span></p>
</section>
<section class="level2" data-number="3.12" id="summary-1">
<h2 data-number="3.12"><span class="koboSpan" id="kobo.770.1" xmlns="http://www.w3.org/1999/xhtml">Summary</span></h2>
<p><span class="koboSpan" id="kobo.771.1" xmlns="http://www.w3.org/1999/xhtml">This chapter covered automated testing, such as unit and integration tests. </span><span class="koboSpan" id="kobo.771.2" xmlns="http://www.w3.org/1999/xhtml">We also briefly covered end-to-end tests, but covering that in only a few pages is impossible. </span><span class="koboSpan" id="kobo.771.3" xmlns="http://www.w3.org/1999/xhtml">Nonetheless, how to write integration tests can also be used for end-to-end testing, especially in the REST API space.We explored different testing approaches from a bird’s eye view, tackled technical debt, and explored multiple testing techniques like black-box, white-box, and grey-box testing. </span><span class="koboSpan" id="kobo.771.4" xmlns="http://www.w3.org/1999/xhtml">We also peaked at a few formal ways to choose the values to test, like equivalence partitioning and boundary value analysis.We then looked at xUnit, the testing framework used throughout the book, and a way of organizing tests. </span><span class="koboSpan" id="kobo.771.5" xmlns="http://www.w3.org/1999/xhtml">We explored ways to pick the correct type of test and some guidelines about choosing the right quantity for each kind of test. </span><span class="koboSpan" id="kobo.771.6" xmlns="http://www.w3.org/1999/xhtml">Then we saw how easy it is to test our ASP.NET Core web applications by running it in memory. </span><span class="koboSpan" id="kobo.771.7" xmlns="http://www.w3.org/1999/xhtml">Finally, we explored high-level concepts that should guide you in writing testable, flexible, and reliable programs.Now that we have talked about testing, we are ready to explore a few architectural principles to help us increase programs’ testability. </span><span class="koboSpan" id="kobo.771.8" xmlns="http://www.w3.org/1999/xhtml">Those are a crucial part of modern software engineering and go hand in hand with automated testing.</span></p>
</section>
<section class="level2" data-number="3.13" id="questions-1">
<h2 data-number="3.13"><span class="koboSpan" id="kobo.772.1" xmlns="http://www.w3.org/1999/xhtml">Questions</span></h2>
<p><span class="koboSpan" id="kobo.773.1" xmlns="http://www.w3.org/1999/xhtml">Let’s take a look at a few practice questions:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.774.1" xmlns="http://www.w3.org/1999/xhtml">Is it true that in TDD, you write tests before the code to be tested?</span></li>
<li><span class="koboSpan" id="kobo.775.1" xmlns="http://www.w3.org/1999/xhtml">What is the role of unit tests?</span></li>
<li><span class="koboSpan" id="kobo.776.1" xmlns="http://www.w3.org/1999/xhtml">How big can a unit test be?</span></li>
<li><span class="koboSpan" id="kobo.777.1" xmlns="http://www.w3.org/1999/xhtml">What type of test is usually used when the subject under test has to access a database?</span></li>
<li><span class="koboSpan" id="kobo.778.1" xmlns="http://www.w3.org/1999/xhtml">Is doing TDD required?</span></li>
<li><span class="koboSpan" id="kobo.779.1" xmlns="http://www.w3.org/1999/xhtml">Do you need to know the inner working of the application to do black-box testing?</span></li>
</ol>
</section>
<section class="level2" data-number="3.14" id="further-reading-1">
<h2 data-number="3.14"><span class="koboSpan" id="kobo.780.1" xmlns="http://www.w3.org/1999/xhtml">Further reading</span></h2>
<p><span class="koboSpan" id="kobo.781.1" xmlns="http://www.w3.org/1999/xhtml">Here are some links to build upon what we have learned in the chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.782.1" xmlns="http://www.w3.org/1999/xhtml">xUnit: </span><a href="https://xunit.net/"><span class="koboSpan" id="kobo.783.1" xmlns="http://www.w3.org/1999/xhtml">https://xunit.net/</span></a></li>
<li><span class="koboSpan" id="kobo.784.1" xmlns="http://www.w3.org/1999/xhtml">If you use Visual Studio, I have a few handy snippets to help improve productivity. </span><span class="koboSpan" id="kobo.784.2" xmlns="http://www.w3.org/1999/xhtml">They are available on GitHub: </span><a href="https://adpg.link/5TbY"><span class="koboSpan" id="kobo.785.1" xmlns="http://www.w3.org/1999/xhtml">https://adpg.link/5TbY</span></a></li>
</ul>
</section>
</section>
</body>
</html>
