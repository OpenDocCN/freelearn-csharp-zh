<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>13 Understanding the Operation Result Design Pattern</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="14">13 Understanding the Operation Result Design Pattern</h1>

<h2 data-number="14.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file71.png" style="width:10em"/></p>
<p>This chapter explores the <strong>Operation Result</strong> pattern, starting simple and progressing to more complex cases. An operation result aims to communicate the success or failure of an operation to its caller. It also allows that operation to return both a value and one or more messages to the caller.Imagine any system where you want to display user-friendly error messages, achieve some small speed gain, or even handle failure easily and explicitly. The <strong>Operation Result</strong> design pattern can help you achieve these goals. One way to use it is to handle the result of a remote operation, such as after querying a remote web service.This pattern builds upon foundational object-oriented programming concepts. In this chapter, we iterate and design different possibilities incrementally. Of course, you should always base your final design on your needs, so learning multiple options will help you make the right choices.</p>
<blockquote>
<p>The Operation Result pattern is also known as the <strong>Result Object Pattern</strong>. I prefer Operation Result because the name specifies that it represents the result of an operation, while the Result Object has a broader meaning. Nonetheless, both are basically the same.</p>
</blockquote>
<p>In this chapter, we cover the following topics:</p>
<ul>
<li>The Operation Result design pattern basics</li>
<li>The Operation Result design pattern returning a value</li>
<li>The Operation Result design pattern returning error messages</li>
<li>The Operation Result design pattern returning messages with severity levels</li>
<li>Using sub-classes and static factory methods for better isolation of successes and failures</li>
</ul>


<h2 data-number="14.2">The Operation Result pattern</h2>
<p>The Operation Result design pattern can be very simple to more complex. In this section, we explore multiple ways to use this pattern. We start with its simplest form and build on that until we can return messages and values and add severity levels as the result of an operation.</p>

<h3 data-number="14.2.1">Goal</h3>
<p>The role of the <strong>Operation Result</strong> pattern is to give an operation (a method) the possibility to return a complex result (an object), which allows the consumer to:</p>
<ul>
<li>[Mandatory] Access the success indicator of the operation (that is, whether the operation succeeded or not).</li>
<li>[Optional] Access the operation result if there is one (the method's return value).</li>
<li>[Optional] Access the cause of the failure if the operation was unsuccessful (error messages).</li>
<li>[Optional] Access other information that documents the operation’s result. This could be as simple as a list of messages or as complex as multiple properties.</li>
</ul>
<p>This can go even further, such as returning the severity of a failure or adding any other relevant information for the specific use case. The success indicator could be binary (<code>true</code> or <code>false</code>), or there could be more than two states, such as success, partial success, and failure.</p>
<blockquote>
<p>Always focus on your needs first, then use your imagination and knowledge to find the best solution. Software engineering is not only about applying techniques that others tell you to. It’s an art! The difference is that you are crafting software instead of painting or woodworking. And that most people won’t see any of that art (code) or get it even if they do.</p>
</blockquote>


<h3 data-number="14.2.2">Design</h3>
<p>It is easy to rely on throwing exceptions when an operation fails. However, the Operation Result pattern is an alternative way of communicating success or failure between components when you don’t want to use exceptions. One such reason could be that the messages are not errors or that treating an erroneous result is part of the main flow, not part of a side <code>catch</code> flow.A method must return an object containing one or more elements presented in the <em>Goal</em> section to be used effectively. As a rule of thumb, a method returning an operation result should not throw exceptions. This way, consumers don’t have to handle anything other than the operation result itself.</p>
<blockquote>
<p>You can throw exceptions for special cases, but at this point, it is a judgment call based on clear specifications or facing a real problem. For example, a critical event that happens, like the disk is full, would be a valid use case for an exception because it has nothing to do with the main flow, and the code must alert the rest of the program about the system failure.</p>
</blockquote>
<p>Instead of walking you through all of the possible UML diagrams, let’s jump into the code and explore multiple smaller examples after taking a look at the basic sequence diagram that describes the simplest form of this pattern, applicable to all examples:</p>
<figure>
<img alt="Figure 13.1: Sequence diagram of the Operation Result design pattern" src="img/file72.png"/><figcaption aria-hidden="true">Figure 13.1: Sequence diagram of the Operation Result design pattern</figcaption>
</figure>
<p>The preceding diagram shows that an operation returns a result (an object), and then the caller handles that result. The following examples cover what we can include in that result object.</p>


<h3 data-number="14.2.3">Project – Implementing different Operation Result patterns</h3>
<p>In this project, a consumer (REST API) routes the HTTP requests to the correct handler. We are visiting each of those handlers one by one to create an incremental learning flow from simple to more complex operation results. This project shows you many ways to implement the Operation Result pattern to help you understand it, make it your own, and implement it as required in your projects.Let’s start with the REST API.</p>

<h4 data-number="14.2.3.1">The consumer</h4>
<p>The consumer of all examples is the <code>Program.cs</code> file. The following code from <code>Program.cs</code> routes the HTTP requests toward a handler:</p>
<div><pre><code>app.MapGet("/simplest-form", ...);
app.MapGet("/single-error", ...);
app.MapGet("/single-error-with-value", ...);
app.MapGet("/multiple-errors-with-value", ...);
app.MapGet("/multiple-errors-with-value-and-severity", ...);
app.MapGet("/static-factory-methods", ...);</code></pre>
</div>
<p>Next, we cover each use case one by one.</p>


<h4 data-number="14.2.3.2">The simplest form of the Operation Result pattern</h4>
<p>The following diagram represents the simplest form of the Operation Result pattern:</p>
<figure>
<img alt="Figure 13.2: Class diagram of the Operation Result design pattern" src="img/file73.png"/><figcaption aria-hidden="true">Figure 13.2: Class diagram of the Operation Result design pattern</figcaption>
</figure>
<p>We can translate that class diagram into the following blocks of code:</p>
<div><pre><code>app.MapGet(
    "/simplest-form",
    (OperationResult.SimplestForm.Executor executor) =&gt;
    {
        var result = executor.Operation();
        if (result.Succeeded)
        {
            // Handle the success
            return "Operation succeeded";
        }
        else
        {
            // Handle the failure
            return "Operation failed";
        }
    }
);</code></pre>
</div>
<p>The preceding code handles the <code>/simplest-form</code> HTTP requests. The highlighted code consumes the following operation:</p>
<div><pre><code>namespace OperationResult.SimplestForm;
public class Executor
{
    public OperationResult Operation()
    {
        // Randomize the success indicator
        // This should be real logic
        var randomNumber = Random.Shared.Next(100);
        var success = randomNumber % 2 == 0;
        // Return the operation result
        return new OperationResult(success);
    }
}
public record class OperationResult(bool Succeeded);</code></pre>
</div>
<p>The <code>Executor</code> class contains the operation to execute represented by the <code>Operation</code> method. That method returns an instance of the <code>OperationResult</code> class. The implementation is based on a random number. Sometimes it succeeds, and sometimes it fails. You would usually code real application logic in that method instead. Moreover, in an actual application, the method should have a proper name representing the operation, like <code>PayRegistrationFees</code> or <code>CreateConcert</code>.The <code>OperationResult</code> record class represents the result of the operation. In this case, a simple read-only Boolean value is stored in the <code>Succeeded</code> property.</p>
<blockquote>
<p>I chose a record class because there is no reason for the result to change. To know more about record classes, have a look at <em>Appendix A</em>.</p>
</blockquote>
<p>In this form, the difference between the <code>Operation</code> method returning a <code>bool</code> and an instance of <code>OperationResult</code> is small, but it exists nonetheless. By returning an <code>OperationResult</code> object, you can extend the return value over time, adding properties and methods to it, which you cannot do with a <code>bool</code> without updating all consumers.Next, we add an error message to the result.</p>


<h4 data-number="14.2.3.3">A single error message</h4>
<p>Now that we know whether the operation succeeded or not, we want to know what went wrong. To do that, we add an <code>ErrorMessage</code> property to the <code>OperationResult</code> record class.With that in place, we no longer need to set whether the operation succeeded or not; we can compute that using the <code>ErrorMessage</code> property instead. The logic behind this improvement goes as follows:</p>
<ul>
<li>When there is no error message, the operation succeeded.</li>
<li>When there is an error message, the operation failed.</li>
</ul>
<p>The <code>OperationResult</code> record class implementing this logic looks like the following:</p>
<div><pre><code>namespace OperationResult.SingleError
public record class OperationResult
{
    public bool Succeeded =&gt; string.IsNullOrWhiteSpace(ErrorMessage);
    public string? ErrorMessage { get; init; }
}</code></pre>
</div>
<p>In the preceding code, we have the following:</p>
<ul>
<li>The <code>Succeeded</code> property checks for an error message.</li>
<li>The <code>ErrorMessage</code> property contains an error message settable when instantiating the object.</li>
</ul>
<p>The executor of that operation looks similar but uses the new constructor, setting an error message instead of directly setting the success indicator:</p>
<div><pre><code>namespace OperationResult.SingleError
public class Executor
{
    public OperationResult Operation()
    {
        // Randomize the success indicator
        // This should be real logic
        var randomNumber = Random.Shared.Next(100);
        var success = randomNumber % 2 == 0;
        // Return the operation result
        return success
            ? new()
            : new() { ErrorMessage = $"Something went wrong with the number '{randomNumber}'." };
    }
}</code></pre>
</div>
<p>The consuming code does the same as in the previous sample but writes the error message in the response output instead of a generic failure string:</p>
<div><pre><code>app.MapGet(
    "/single-error",
    (OperationResult.SingleError.Executor executor) =&gt;
    {
        var result = executor.Operation();
        if (result.Succeeded)
        {
            // Handle the success
            return "Operation succeeded";
        }
        else
        {
            // Handle the failure
            return result.ErrorMessage;
        }
    }
);</code></pre>
</div>
<p>When looking at this example, we can begin to comprehend the Operation Result pattern’s usefulness. It furthers us from the simple success indicator that looked like an overcomplicated Boolean.Next, we add the possibility of setting a value when the operation succeeds.</p>


<h4 data-number="14.2.3.4">Adding a return value</h4>
<p>Now that we have a reason for failure, we may want the operation to return a value. To achieve this, let’s build over the previous example and add a <code>Value</code> property to the <code>OperationResult</code> class:</p>
<div><pre><code>namespace OperationResult.SingleErrorWithValue;
public record class OperationResult
{
    public bool Succeeded =&gt; string.IsNullOrWhiteSpace(ErrorMessage);
    public string? ErrorMessage { get; init; }
    public int? Value { get; init; }
}</code></pre>
</div>
<p>By adding a second <code>init</code>-only property, we can set the <code>Value</code> property when the operation succeeds and fails.</p>
<blockquote>
<p>In a real-world scenario, that <code>Value</code> property could be <code>null</code> in the case of an error, hence the nullable <code>int</code> property.</p>
</blockquote>
<p>The operation is also very similar, but we are setting the <code>Value</code> property as well as using the object initializer in both cases (highlighted lines):</p>
<div><pre><code>namespace OperationResult.SingleErrorWithValue;
public class Executor
{
    public OperationResult Operation()
    {
        // Randomize the success indicator
        // This should be real logic
        var randomNumber = Random.Shared.Next(100);
        var success = randomNumber % 2 == 0;
        // Return the operation result
        return success
            ? new() { Value = randomNumber }
            : new()
            {
                ErrorMessage = $"Something went wrong with the number '{randomNumber}'.",
                Value = randomNumber,
            };
    }
}</code></pre>
</div>
<p>With that in place, the consumer can use the <code>Value</code> property. In our case, the program displays it when the operation succeeds:</p>
<div><pre><code>app.MapGet(
    "/single-error-with-value",
    (OperationResult.SingleErrorWithValue.Executor executor) =&gt;
    {
        var result = executor.Operation();
        if (result.Succeeded)
        {
            // Handle the success
            return $"Operation succeeded with a value of '{result.Value}'.";
        }
        else
        {
            // Handle the failure
            return result.ErrorMessage;
        }
    }
);</code></pre>
</div>
<p>The preceding code displays the <code>ErrorMessage</code> property when the operation fails or uses the <code>Value</code> property when it succeeds. With this, the power of the Operation Result pattern continues to emerge.But we are not done yet, so let’s jump into the next evolution.</p>


<h4 data-number="14.2.3.5">Multiple error messages</h4>
<p>Now we are at the point where we can transfer a <code>Value</code> and an <code>ErrorMessage</code> to the operation consumers; what about transferring multiple errors, such as validation errors? To achieve this, we can convert our <code>ErrorMessage</code> property from a <code>string</code> to an <code>IEnumerable&lt;string&gt;</code> or another type of collection that fits your needs better. Here I chose the <code>IReadOnlyCollection&lt;string&gt;</code> interface and the <code>ImmutableList&lt;string&gt;</code> class so we know that external actors can’t mutate the results:</p>
<div><pre><code>namespace OperationResult.MultipleErrorsWithValue;
public record class OperationResult
{
    public OperationResult()
    {
        Errors = ImmutableList&lt;string&gt;.Empty;
    }
    public OperationResult(params string[] errors)
    {
        Errors = errors.ToImmutableList();
    }
    public bool Succeeded =&gt; !HasErrors();
    public int? Value { get; init; }
    public IReadOnlyCollection&lt;string&gt; Errors { get; init; }
    public bool HasErrors()
    {
        return Errors?.Count &gt; 0;
    }
}</code></pre>
</div>
<p>Let’s look at the new pieces in the preceding code before continuing:</p>
<ul>
<li>The errors are now stored in <code>ImmutableList&lt;string&gt;</code> object and returned as an <code>IReadOnlyCollection&lt;string&gt;</code>.</li>
<li>The <code>Succeeded</code> property accounts for a collection instead of a single message and follows the same logic.</li>
<li>The <code>HasErrors</code> method improves readability.</li>
<li>The default constructor represents the successful state.</li>
<li>The constructor that takes error messages as parameters represents a failed state and populates the <code>Errors</code> property.</li>
</ul>
<p>Now that the operation result is updated, the operation itself can stay the same. The consumer stays almost the same as well (see the highlight in the code below), but we need to tell ASP.NET how to serialize the result:</p>
<div><pre><code>app.MapGet(
    "/multiple-errors-with-value",
    object (OperationResult.MultipleErrorsWithValue.Executor executor)
    =&gt; {
        var result = executor.Operation();
        if (result.Succeeded)
        {
            // Handle the success
            return $"Operation succeeded with a value of '{result.Value}'.";
        }
        else
        {
            // Handle the failure
            return result.Errors;
        }
    }
);</code></pre>
</div>
<p>We must specify the method returns an object (the highlighted code) so ASP.NET understands that the return value of our delegate can be anything. Without this, the return type could not be inferred, and the code would not compile. That makes sense since the function is returning a <code>string</code> in one path and an <code>IReadOnlyCollection&lt;string&gt;</code> in another.During the executing, ASP.NET serializes the <code>IReadOnlyCollection&lt;string&gt; Errors</code> property to JSON before outputting it to the client to help visualize the collection.</p>
<blockquote>
<p>Returning a <code>plain/text</code> string when the operation succeeds and an <code>application/json</code> array when it fails is not a good practice. I suggest avoiding this in real applications. Either return JSON or plain text. Do not mix content types in a single endpoint unless necessary per specifications. Mixing content types only creates avoidable complexity and confusion. Moreover, it is way easier for the consumers of the API to always expect the same content type.</p>
<blockquote>
<p>When designing system contracts, consistency and uniformity are usually better than incoherency, ambiguity, and variance.</p>
</blockquote>
</blockquote>
<p>Our Operation Result pattern implementation is getting better and better but still lacks a few features. One of those features is the possibility to propagate messages that are not errors, such as information messages and warnings, which we implement next.</p>


<h4 data-number="14.2.3.6">Adding message severity</h4>
<p>Now that our operation result structure is materializing, let’s update our last iteration to support message severity.First, we need a severity indicator. An <code>enum</code> is a good candidate for this kind of work, but it could also be something else. In our case, we leverage an <code>enum</code> that we name <code>OperationResultSeverity</code>.Then we need a message class to encapsulate both the message and the severity level; let’s name that class <code>OperationResultMessage</code>. The new code looks like this:</p>
<div><pre><code>namespace OperationResult.WithSeverity;
public record class OperationResultMessage
{
    public OperationResultMessage(string message, OperationResultSeverity severity)
    {
        Message = message ?? throw new ArgumentNullException(nameof(message));
        Severity = severity;
    }
    public string Message { get; }
    public OperationResultSeverity Severity { get; }
}
public enum OperationResultSeverity
{
    Information = 0,
    Warning = 1,
    Error = 2
}</code></pre>
</div>
<p>As you can see, we have a simple data structure to replace our <code>string</code> messages.To ensure the enum gets serialized as string and make the output easier to read and consume, we must register the following converter:</p>
<div><pre><code>builder.Services
    .Configure&lt;JsonOptions&gt;(o
        =&gt; o.SerializerOptions.Converters.Add(
            new JsonStringEnumConverter()))
;</code></pre>
</div>
<p>Then we need to update the <code>OperationResult</code> class to use that new <code>OperationResultMessage</code> class instead. We then need to ensure that the operation result indicates a success only when there is no <code>OperationResultSeverity.Error</code>, allowing it to transmit the <code>OperationResultSeverity.Information</code> and <code>OperationResultSeverity.Warnings</code> messages:</p>
<div><pre><code>namespace OperationResult.WithSeverity;
public record class OperationResult
{
    public OperationResult()
    {
        Messages = ImmutableList&lt;OperationResultMessage&gt;.Empty;
    }
    public OperationResult(params OperationResultMessage[] messages)
    {
        Messages = messages.ToImmutableList();
    }
    public bool Succeeded =&gt; !HasErrors();
    public int? Value { get; init; }
    public ImmutableList&lt;OperationResultMessage&gt; Messages { get; init; }
    public bool HasErrors()
    {
        return FindErrors().Any();
    }
    private IEnumerable&lt;OperationResultMessage&gt; FindErrors()
        =&gt; Messages.Where(x =&gt; x.Severity == OperationResultSeverity.Error);
}</code></pre>
</div>
<p>The highlighted lines represent the updated logic that sets the success state of the operation. The operation is successful only when no error exists in the <code>Messages</code> list. The <code>FindErrors</code> method returns messages with an <code>Error</code> severity, while the <code>HasErrors</code> method bases its decision on that method’s output.</p>
<blockquote>
<p>The <code>HasErrors</code> method logic can be anything. In this case, this works.</p>
</blockquote>
<p>With that in place, the <code>Executor</code> class is also revamped. Let’s have a look at those changes:</p>
<div><pre><code>namespace OperationResult.WithSeverity;
public class Executor
{
    public OperationResult Operation()
    {
        // Randomize the success indicator
        // This should be real logic
        var randomNumber = Random.Shared.Next(100);
        var success = randomNumber % 2 == 0;
        // Some information message
        var information = new OperationResultMessage(
            "This should be very informative!",
            OperationResultSeverity.Information
        );
        // Return the operation result
        if (success)
        {
            var warning = new OperationResultMessage(
                "Something went wrong, but we will try again later automatically until it works!",
                OperationResultSeverity.Warning
            );
            return new OperationResult(information, warning) { Value = randomNumber };
        }
        else
        {
            var error = new OperationResultMessage(
                $"Something went wrong with the number '{randomNumber}'.",
                OperationResultSeverity.Error
            );
            return new OperationResult(information, error) { Value = randomNumber };
        }
    }
}</code></pre>
</div>
<p>In the preceding code, we removed the tertiary operator. The <code>Operation</code> method also uses all severity levels.</p>
<blockquote>
<p>You should always aim to write code that is easy to read. It is OK to use language features, but nesting statements over statements on a single line has limits and can quickly become a mess.</p>
</blockquote>
<p>In that last code block, both successes and failures return two messages:</p>
<ul>
<li>When the operation succeeds, the method returns an information and a warning message.</li>
<li>When the operation fails, the method returns an information and an error message.</li>
</ul>
<p>From the consumer standpoint, we have a placeholder if-else block and return the operation result directly. Of course, we could handle this differently in a real application that needs to know about those messages, but in this case, all we want to see are those results, so this does it:</p>
<div><pre><code>app.MapGet("/multiple-errors-with-value-and-severity", (OperationResult.WithSeverity.Executor executor) =&gt;
{
    var result = executor.Operation();
    if (result.Succeeded)
    {
        // Handle the success
    }
    else
    {
        // Handle the failure
    }
    return result;
});</code></pre>
</div>
<p>As you can see, it is still as easy to use, but now with more flexibility added to it. We can do something with the different types of messages, such as displaying them to the user, retrying the operation, and more.For now, when running the application and calling this endpoint, successful calls return a JSON string that looks like the following:</p>
<div><pre><code>{
    "succeeded": true,
    "value": 56,
    "messages": [
        {
            "message": "This should be very informative!",
            "severity": "Information"
        },
        {
            "message": "Something went wrong, but we will try again later automatically until it works!",
            "severity": "Warning"
        }
    ]
}</code></pre>
</div>
<p>Failures return a JSON string that looks like this:</p>
<div><pre><code>{
    "succeeded": false,
    "value": 19,
    "messages": [
        {
            "message": "This should be very informative!",
            "severity": "Information"
        },
        {
            "message": "Something went wrong with the number '19'.",
            "severity": "Error"
        }
    ]
}</code></pre>
</div>
<p>Another idea to improve this design would be adding a <code>Status</code> property that returns a complex success result based on each message’s severity level. To do that, we could create another <code>enum</code>:</p>
<div><pre><code>public enum OperationStatus { Success, Failure, PartialSuccess }</code></pre>
</div>
<p>Then we could access that value through a new property named <code>Status</code>, on the <code>OperationResult</code> class. With this, a consumer could handle partial success without digging into the messages. I will leave you to play with this one on your own; for example, the <code>Status</code> property could replace the <code>Succeeded</code> property, or the <code>Succeeded</code> property could leverage the <code>Status</code> property similarly to what we did with the errors. The most important part is to define what would be a success, a partial success, and a failure. Think of a database transaction, for example; one failure could lead to the rollback of the transaction, while in another case, one failure could be acceptable.Now that we’ve expanded our simple example into this, what happens if we want the <code>Value</code> to be optional? To do that, we could create multiple operation result classes holding more or less information (properties); let’s try that next.</p>


<h4 data-number="14.2.3.7">Sub-classes and factories</h4>
<p>In this iteration, we keep all the properties but instantiate the <code>OperationResult</code> objects using static factories. Moreover, we hide certain properties in the sub-classes, so each result type only contains the data it needs. The <code>OperationResult</code> class itself only exposes the <code>Succeeded</code> property in this scenario.A <strong>static factory method</strong> is nothing more than a static method that creates objects. It is handy and easy to use but less flexible.</p>
<blockquote>
<p>I cannot stress this enough: be careful when designing something <code>static</code>, or it could haunt you later; <code>static</code> members are not extensible and can make their consumers harder to test.</p>
</blockquote>
<p>The <code>OperationResultMessage</code> class and the <code>OperationResultSeverity</code> <code>enum</code> remain unchanged. In the following code block, we do not consider the severity when computing the operation’s success or failure state. Instead, we create an abstract <code>OperationResult</code> class with two sub-classes:</p>
<ul>
<li>The <code>SuccessfulOperationResult</code> class represents successful operations.</li>
<li>The <code>FailedOperationResult</code> class represents failed operations.</li>
</ul>
<p>Then the next step is to force the use of the specifically designed classes by creating two static factory methods:</p>
<ul>
<li>The static <code>Success</code> method returns a <code>SuccessfulOperationResult</code> object.</li>
<li>The static <code>Failure</code> returns a <code>FailedOperationResult</code> object.</li>
</ul>
<p>This technique moves the responsibility of deciding whether the operation is a success from the <code>OperationResult</code> class to the <code>Operation</code> method that explicitly creates the expected result.The following code block shows the new <code>OperationResult</code> implementation (the static factories are highlighted):</p>
<div><pre><code>namespace OperationResult.StaticFactoryMethod;
public abstract record class OperationResult
{
    private OperationResult() { }
    public abstract bool Succeeded { get; }
    public static OperationResult Success(int? value = null)
    {
        return new SuccessfulOperationResult { Value = value };
    }
    public static OperationResult Failure(params OperationResultMessage[] errors)
    {
        return new FailedOperationResult(errors);
    }
    private record class SuccessfulOperationResult : OperationResult
    {
        public override bool Succeeded { get; } = true;
        public virtual int? Value { get; init; }
    }
    private record class FailedOperationResult : OperationResult
    {
        public FailedOperationResult(params OperationResultMessage[] errors)
        {
            Messages = errors.ToImmutableList();
        }
        public override bool Succeeded { get; } = false;
        public ImmutableList&lt;OperationResultMessage&gt; Messages { get; }
    }
}</code></pre>
</div>
<p>After analyzing the code, there are a few closely related particularities:</p>
<ul>
<li>The <code>OperationResult</code> class has a private constructor.</li>
<li>Both the <code>SuccessfulOperationResult</code> and <code>FailedOperationResult</code> classes are nested inside the <code>OperationResult</code> class, inherit from it, and are <code>private</code>.</li>
</ul>
<p>Nested classes are the only way to inherit from the <code>OperationResult</code> class because, like other members of the class, nested classes have access to their private members, including the constructor. Otherwise, it is impossible to inherit from <code>OperationResult</code>. Moreover, as private classes, they can only be accessed internally from the <code>OperationResult</code> class for the same reason and become inaccessible from the outside.</p>
<blockquote>
<p>Since the beginning of the book, I have repeated <strong>flexibility</strong> many times; but you don’t always want flexibility. Even if most of the book is about improving flexibility, sometimes you want control over what you expose and what you allow consumers to do, whether to protect internal mechanisms (encapsulation) or for maintainability reasons.</p>
<blockquote>
<p>For example, allowing consumers to change the internal state of an object can lead to unexpected behaviors. Another example would be when managing a library; the larger the public API, the more chances of introducing a breaking change. Nonetheless, over-hiding elements can be a detrimental experience for the consumers; if you need something somewhere, the chances are that someone else will too (eventually).</p>
</blockquote>
<blockquote>
<p>In this case, we could have used a protected constructor instead or implemented a fancier way of instancing success and failure instances. Nonetheless, I decided to use this opportunity to show you how to lock a class in place without the sealed modifier, making extending by inheritance from the outside impossible. We could have built mechanisms in our classes to allow controlled extensibility (like the Template Method pattern), but for this one, let’s keep it locked in tight!</p>
</blockquote>
</blockquote>
<p>From here, the only missing pieces are the operation itself and the consumer of the operation. Let’s look at the operation first:</p>
<div><pre><code>namespace OperationResult.StaticFactoryMethod;
public class Executor
{
    public OperationResult Operation()
    {
        // Randomize the success indicator
        // This should be real logic
        var randomNumber = Random.Shared.Next(100);
        var success = randomNumber % 2 == 0;
        // Return the operation result
        if (success)
        {
            return OperationResult.Success(randomNumber);
        }
        else
        {
            var error = new OperationResultMessage(
                $"Something went wrong with the number '{randomNumber}'.",
                OperationResultSeverity.Error
            );
            return OperationResult.Failure(error);
        }
    }
}</code></pre>
</div>
<p>The two highlighted lines in the preceding code block show the elegance of this new improvement. I find this code very easy to read, which was the objective. We now have two methods that clearly define our intentions when using them: <code>Success</code> or <code>Failure</code>.The consumer uses the same code that we saw before in other examples, so I’ll omit it here. However, the output is different for a successful or a failed operation. Here is a successful output:</p>
<div><pre><code>{
    "succeeded": true,
    "value": 80
}</code></pre>
</div>
<p>Here is a failed output:</p>
<div><pre><code>{
    "succeeded": false,
    "messages": [
        {
            "message": "Something went wrong with the number '37'.",
            "severity": "Error"
        }
    ]
}</code></pre>
</div>
<p>As the two preceding JSON outputs show, each object's properties are different. The only shared property of the two is the <code>Succeeded</code> property. Beware that this type of class hierarchy is harder to consume directly since the interface (the <code>OperationResult</code> class) has a minimal API surface, which is good in theory, and each sub-class adds different properties, which are hidden from the consumers. For example, it would be hard to use the <code>Value</code> property of a successful operation directly in the endpoint handler code. Therefore, when hiding properties, as we did here, ensure those additional properties are optional. For example, we can use this technique when sending the result to another system over HTTP (like this project does) or publish the operation result as an event (see <em>Chapter 19</em>, <em>Introduction to Microservices Architecture</em>, where we introduce event-driven architecture). Nevertheless, learning to manipulate classes using polymorphism will be helpful the day you need it.Next, let’s peek at some advantages and disadvantages of the Operation Result pattern.</p>



<h3 data-number="14.2.4">Advantages and disadvantages</h3>
<p>Here are a few advantages and disadvantages of the Operation Result design pattern.</p>

<h4 data-number="14.2.4.1">Advantages</h4>
<p>It is more explicit than throwing an <code>Exception</code> since the operation result type is specified explicitly as the method’s return type. That makes it more evident than knowing what type of exceptions the operation and its dependencies can throw.Another advantage is the execution speed; returning an object is faster than throwing an exception. Not that much faster, but faster nonetheless.Using operation results is more flexible than exceptions and gives us design flexibility; for example, we can manage different message types like warnings and information.</p>


<h4 data-number="14.2.4.2">Disadvantages</h4>
<p>Using operation results is more complex than throwing exceptions because we must <em>manually propagate it up the call stack</em> (i.e., the result object is returned by the callee and handled by the caller). This is especially true if the operation result must go up multiple levels, suggesting this pattern may not be the most suitable.It is easy to expose members not used by all scenarios, creating a bigger API surface than needed, where some parts are used only in some cases. But, between this and spending countless hours designing the perfect system, sometimes exposing an <code>int? Value { get; }</code> property is the best option. Nonetheless, always try to reduce that surface to a minimum and use your imagination and design skills to overcome those challenges!</p>




<h2 data-number="14.3">Summary</h2>
<p>In this chapter, we visited multiple forms of the Operation Result pattern, from an augmented Boolean to a complex data structure containing messages, values, and success indicators. We also explored static factories and private constructors to control external access. Furthermore, after all that exploration, let’s conclude that there are almost endless possibilities around the Operation Result pattern. Each specific use case should dictate how to make it happen. From here, I am confident you have enough information about the pattern to explore the many possibilities yourself, and I highly encourage you to.The Operation Result pattern is perfect for crafting strongly typed return values that self-manage multiple states (error and success) or support complex states (like partial success). It is also ideal for transporting messages that are not necessarily errors, like information messages. Even in its simplest form, we can leverage the Operation Result pattern as a base for extensibility since we can add members to the result class over time, which would be impossible for a primitive type (or any type we don’t control).</p>
<blockquote>
<p>The <code>HttpResponseMessage</code> class returned by the methods of the <code>HttpClient</code> class is an excellent example of a concrete implementation of the Operation Result pattern. It contains a single message exposed through the <code>ReasonPhrase</code> property. It exposes a complex success state through the <code>StatusCode</code> property and a simple success indicator through its <code>IsSuccessStatusCode</code> property. It also contains more information about the request and response through other properties.</p>
</blockquote>
<p>At this point, we would usually explore how the <strong>Operation Result</strong> pattern can help us follow the SOLID principles. However, it depends too much on the implementation, so here are a few key points instead:</p>
<ul>
<li>The <code>OperationResult</code> class encapsulates the result, extracting that responsibility from the other system’s components (SRP).</li>
<li>We violated the ISP with the <code>Value</code> property in multiple examples. This infringement has a minor impact that we fixed as an example of overcoming this challenge.</li>
<li>We could compare an operation result to a DTO but returned by an operation (method) instead of a REST API endpoint. From there, we could add an abstraction or stick with returning a concrete class, but sometimes using concrete types makes the system easier to understand and maintain. Depending on the implementation, this may break different principles.</li>
</ul>
<blockquote>
<p>When the advantages surpass the minor impacts of those kinds of violations, it is acceptable to let them slide. Principles are ideals and are not applicable in every scenario—principles are not laws.</p>
<blockquote>
<p>Most design decisions are trade-offs between two imperfect solutions, so you must choose which downsides you prefer to live with to gain the upsides.</p>
</blockquote>
</blockquote>
<p>This chapter concludes <em>Section 3:</em> <em>Components Patterns</em> and leads to <em>Section 4: Application Patterns</em>, where we explore higher-level design patterns.</p>


<h2 data-number="14.4">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>Is returning an operation result when doing an asynchronous call, such as an HTTP request, a good idea?</li>
<li>What is the name of the pattern that we implemented using static methods?</li>
<li>Is it faster to return an operation result than throw an exception?</li>
<li>In what scenario might the Operation Result pattern come in handy?</li>
</ol>


<h2 data-number="14.5">Further reading</h2>
<p>Here are some links to build on what we learned in this chapter:</p>
<ul>
<li>An article on my blog about exceptions (title: <em>A beginner guide to exceptions</em> | <em>The basics</em>): <a href="https://adpg.link/PpEm">https://adpg.link/PpEm</a></li>
<li>An article on my blog about Operation Result (title<em>: Operation result</em> | <em>Design Pattern</em>): <a href="https://adpg.link/4o2q">https://adpg.link/4o2q</a></li>
</ul>


<h2 data-number="14.6">Answers</h2>
<ol>
<li>Yes, asynchronous operations like HTTP are great candidates for the Operation Result pattern. For example, in the BCL, the <code>HttpResponseMessage</code> instance returned by the <code>Send</code> method of the <code>HttpClient</code> class is an operation result.</li>
<li>We implemented two <strong>static factory methods</strong>.</li>
<li>Yes, returning an object is marginally faster than throwing an exception.</li>
<li>The Operation Result pattern comes in handy when we want to return the state of the operation along with its return value as part of the main consumption flow. It is very suitable to return multiple properties describing the result of the process and is extensible.</li>
</ol>


</body>
</html>
