- en: Chapter 2. Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 内存管理
- en: 'This chapter investigates how memory is managed on iOS and Android with Xamarin
    runtime. Whilst drawing parallels to the .NET platform, it will provide examples
    of memory management problems and issues that can cause leaks, and also look at
    useful patterns that can help developers save valuable resources. This chapter
    is divided into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了使用Xamarin运行时在iOS和Android上如何管理内存。虽然与.NET平台进行类比，但它将提供可能导致泄漏的内存管理问题和问题的示例，并查看有助于开发者节省宝贵资源的有效模式。本章分为以下部分：
- en: Application Component lifecycle
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用组件生命周期
- en: Garbage collection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Platform-specific concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定概念
- en: Troubleshooting and diagnosis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除和诊断
- en: Patterns and best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: Application Component lifecycle
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用组件生命周期
- en: Each platform in the Xamarin ecosystem has certain processes and states that
    the applications go through during their execution lifetime. Developers can implement
    certain methods and subscribe to lifecycle events such as application start, suspension,
    termination, and backgrounding to handle much needed application state and release
    resources which are no longer required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin生态系统中的每个平台在应用程序的执行生命周期中都有一定的过程和状态。开发者可以实现某些方法并订阅生命周期事件，如应用程序启动、挂起、终止和后台运行，以处理所需的应用程序状态并释放不再需要的资源。
- en: Activity lifecycle (Android)
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动生命周期（Android）
- en: In Android applications, contrary to the conventional application development
    model, any activity can be the access point to the application (as long as it
    is designated as such). Any activity in the application can be initialized at
    start-up or can be resumed directly when the application is resuming or restarting
    from a crash.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android应用程序中，与传统的应用程序开发模型相反，任何活动都可以作为应用程序的入口点（只要它被指定为这样的入口点）。应用程序中的任何活动都可以在启动时初始化，也可以在应用程序恢复或从崩溃中重新启动时直接恢复。
- en: In order to manage the lifecycle of the activities, there are distinct states
    and events which help developers organize memory resources and program features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理活动的生命周期，存在不同的状态和事件，这些可以帮助开发者组织内存资源和程序功能。
- en: Active/Running
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动/运行
- en: An activity is said to be in the active state when an application is the application
    in focus and the activity is in the foreground. At this state, unless extraordinary
    measures are required by the operating system (for example, in case of system
    out of memory or application becoming unresponsive), the developer does not need
    to worry about the memory and resources, as the application has the highest priority.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序是焦点应用程序且活动处于前台时，称活动处于活动状态。在此状态下，除非操作系统需要采取特殊措施（例如，系统内存不足或应用程序无响应），否则开发者无需担心内存和资源，因为应用程序具有最高优先级。
- en: In a creation cycle, `OnCreate` is the first method that is called by the application.
    This is the initialization step where the views are created, the variables are
    introduced, and static data resources are loaded.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建周期中，`OnCreate`是应用程序调用的第一个方法。这是初始化步骤，其中创建视图、引入变量和加载静态数据资源。
- en: '`OnStart` or `OnRestart` (if the activity is restarting after it was backgrounded)
    is the second event method in a creation cycle. This method(s) can be overridden
    if specific data reload procedures need to be implemented. This is the last method
    called before the activity becomes visible.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnStart`或`OnRestart`（如果活动在后台后重新启动）是创建周期中的第二个事件方法。如果需要实现特定的数据重新加载过程，则可以重写此方法（们）。这是在活动变得可见之前最后调用的方法。'
- en: The `OnResume` method is called after a successful launch of the activity. This
    method is the indication that the application is ready for user interaction. It
    can be used to (re)subscribe to external events, display alerts/user messages,
    and communicate with device peripherals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在活动成功启动后，会调用`OnResume`方法。此方法表明应用程序已准备好与用户交互。它可以用来（重新）订阅外部事件、显示警报/用户消息以及与设备外围设备通信。
- en: Paused
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暂停
- en: An activity is paused when either the device goes to sleep having this activity
    in the foreground, or the activity is partially hidden by another dialog or activity.
    In this state, the activity is still "alive" but cannot interact with the user.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备进入睡眠状态且此活动处于前台，或者活动被另一个对话框或活动部分隐藏时，活动会被暂停。在此状态下，活动仍然是“活跃”的，但不能与用户交互。
- en: The `OnPause` event method is called right before the activity goes into the
    Paused state. This event method is the ideal place to unsubscribe from any external
    event providers, commit any unsaved changes and clean up any objects consuming
    memory resources since the user interaction is not possible in the Paused state.
    The activity will call only the `OnResume` method when once again the activity
    has the highest priority, it will not go through the full creation cycle.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPause`事件方法在活动进入暂停状态之前被调用。这个事件方法是在任何外部事件提供者取消订阅、提交任何未保存的更改以及清理消耗内存资源的对象的理想位置，因为在暂停状态下用户交互是不可能的。当活动再次获得最高优先级时，它将只调用`OnResume`方法，而不会经历完整的创建周期。'
- en: Backgrounded
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: An activity goes into the Backgrounded state when the user presses the home
    button or uses the app switcher. In this state, it is not guaranteed that the
    activity will stay alive until the user "restarts" the application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下主页按钮或使用应用切换器时，活动进入后台状态。在此状态下，不能保证活动会一直存活到用户“重新启动”应用程序。
- en: The `OnStop` method is called when the application is backgrounded or stopped.
    The difference between the Backgrounded and Stopped states is that the activity
    is in the Stopped state when it is being prepared for destruction and it will
    be followed by the `OnDestroy` method since the application is dismissed and will
    not be used by the user anymore. If the user resumes the application, the activity
    will call the `OnRestart` method and a full creation process will follow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序进入后台或停止时，会调用`OnStop`方法。背景化和停止状态之间的区别在于，当活动正在准备销毁时，它处于停止状态，随后将调用`OnDestroy`方法，因为应用程序已被关闭且不再被用户使用。如果用户恢复应用程序，活动将调用`OnRestart`方法，然后跟随完整创建过程。
- en: Stopped
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 停止
- en: The Stopped state represents the end of the lifecycle for the activity. The
    activity enters this state when the user presses the back button signifying that
    the application is not needed anymore. However, it is also possible that the activity
    is taken into this state because the system is starved of memory resources and
    it needs to take down activities that are on the lower priority states like paused
    or backgrounded.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 停止状态代表活动的生命周期结束。当用户按下返回按钮，表示应用程序不再需要时，活动进入此状态。然而，也有可能活动是因为系统内存资源不足，需要关闭处于较低优先级状态（如暂停或后台）的活动而进入此状态。
- en: The `OnDestroy` method follows the Stopped state and it is the last lifecycle
    event method that is called. It is the last chance for the application to stop
    long running processes that might cause leaks or clean up other persistent resources.
    It is advisable to implement most of the resource clean up in `OnPause` and `OnStop`
    methods, since `OnDestroy` can be called unexpectedly by the system contrary to
    the user initiated `OnPause` and `OnStop` methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDestroy`方法跟随停止状态，是最后被调用的生命周期事件方法。这是应用程序停止可能引起泄漏的长运行进程或清理其他持久资源的最后机会。建议在`OnPause`和`OnStop`方法中实现大部分资源清理，因为与由用户触发的`OnPause`和`OnStop`方法不同，`OnDestroy`可能被系统意外调用。'
- en: Restarted
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新启动
- en: An activity is said to be "restarted" when it comes back to user interaction
    after it was backgrounded. Restarted activities can reload any saved state information
    and create an uninterrupted user experience. After going through the initialization
    steps, the application goes into the Running state again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动在后台之后返回用户交互时，我们称其为“重新启动”。重新启动的活动可以重新加载任何保存的状态信息，并创建一个不间断的用户体验。经过初始化步骤后，应用程序再次进入运行状态。
- en: Application lifecycle (iOS)
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序生命周期（iOS）
- en: On iOS, the application lifecycle is handled through UI application delegates.
    Once the delegate methods are implemented and registered, the methods will be
    invoked by the execution context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，应用程序生命周期是通过UI应用程序代理来处理的。一旦实现了代理方法并进行了注册，这些方法将由执行上下文调用。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Application events on iOS are a little more complicated than the top-down execution
    of events on Android. Developers can insert their methods into transitive states
    using the state-related methods implemented in the `AppDelegate`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS上，应用程序事件比Android上事件自上而下的执行要复杂一些。开发者可以使用在`AppDelegate`中实现的状态相关方法将他们的方法插入到传递状态。
- en: '![Application lifecycle (iOS)](img/B04693_02_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序生命周期（iOS）](img/B04693_02_01.jpg)'
- en: 'Figure 1: iOS Application State Transitions'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：iOS应用程序状态转换
- en: 'The most important state-related methods are the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的状态相关方法是以下这些：
- en: '`WillFinishLaunching` is the first chance of the application to execute code
    at launch time. It indicates the application has started to launch but the state
    has not yet been restored.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WillFinishLaunching` 是应用程序在启动时执行代码的第一个机会。它表示应用程序已经开始启动，但状态尚未恢复。'
- en: '`FinishedLaunching` is called once the state restoration occurs after the `WillFinishLaunching`
    is completed.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FinishedLaunching` 在 `WillFinishLaunching` 完成后，状态恢复发生时被调用。'
- en: '`OnActivated` and `OnResignActivation` are similar to `OnPause` and `OnResume`
    event methods on the Android platform.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnActivated` 和 `OnResignActivation` 与 Android 平台上的 `OnPause` 和 `OnResume`
    事件方法类似。'
- en: '`DidEnterBackground` is called when the application enters the Backgrounded
    state. It is similar to the `OnStop` method on Android but there is a time constriction
    on this method; the method should execute in less than 5 seconds, and the method
    exits without notification after the allocated time. If more time is needed to
    execute certain methods in this delegate, applications can start a background
    task to complete the execution.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序进入后台状态时，会调用 `DidEnterBackground`。它类似于 Android 上的 `OnStop` 方法，但此方法有时间限制；该方法应在少于
    5 秒内执行，并在分配的时间后无通知退出。如果需要更多时间执行某些方法，应用程序可以启动后台任务来完成执行。
- en: '`WillEnterForeground` and `WillTerminate` can follow the `DidEnterBackground`
    execution. If the former method is called, the application is about to be brought
    back to foreground and active state, otherwise, the application is prepared to
    be terminated because the system needs more memory, or the user is closing a backgrounded
    application.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WillEnterForeground` 和 `WillTerminate` 可以跟随 `DidEnterBackground` 执行。如果调用前者方法，应用程序即将被带回前台和活动状态，否则，应用程序准备被终止，因为系统需要更多内存，或者用户正在关闭后台应用程序。'
- en: Garbage collection
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: '**Garbage collection** (**GC**) is one of the most effective automated memory
    management techniques on modern application development platforms. In simple terms,
    with automated garbage collection, memory resources are allocated for objects
    used by the application and reclaimed for resources no longer needed by the application.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**垃圾回收**（**GC**）是现代应用程序开发平台中最有效的自动化内存管理技术之一。简单来说，通过自动垃圾回收，为应用程序使用的对象分配内存资源，并回收不再需要的资源。'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In spite of the fact that garbage collection, as an automated process, takes
    over the burden of managing memory allocations, it can have a significant impact
    on performance. This performance handicap is one of the main reasons why there
    is no garbage collection mechanism on the iOS platform.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管垃圾回收作为一个自动化过程接管了内存分配的管理负担，但它可能会对性能产生重大影响。这种性能劣势是 iOS 平台上没有垃圾回收机制的主要原因之一。
- en: In theory, GC is responsible for reclaiming memory resources occupied by runtime
    elements that cannot be reached by the current executing application. However,
    this mechanism cannot always identify these unreachable resources correctly and/or
    have unexpected results while purging the identified memory pointers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，GC 负责回收当前执行的应用程序无法访问的运行时元素占用的内存资源。然而，此机制不能总是正确地识别这些不可达资源，并且在清除已识别的内存指针时可能会产生意外的结果。
- en: Memory leaks occur when an application fails to identify and/or free the resources
    occupied by unreachable code elements, which can lead to memory exhaustion problems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序未能识别和/或释放由不可达代码元素占用的资源时，就会发生内存泄漏，这可能导致内存耗尽问题。
- en: Dangling pointers happen when a memory region is freed while references still
    exist in the execution context. These references are then removed and memory can
    be re-allocated for another use.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当在执行上下文中还存在引用时释放内存区域，就会发生悬挂指针。然后这些引用被移除，内存可以重新分配给其他用途。
- en: Double free bugs occur when a memory region is already reclaimed and the application
    or garbage collector tries to free this region once more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存区域已经被回收，而应用程序或垃圾收集器试图再次释放这个区域时，会发生双重释放错误。
- en: GC on Xamarin projects
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin 项目的垃圾回收
- en: Managed code, as defined by the Common Language Runtime in the .NET framework,
    is application code where the memory resources are managed by the native garbage
    collector. GC, on initialization, allocates a segment of the memory to store and
    manage memory resources, which is called the "managed heap". The garbage collection
    in CLR happens on three different generations where objects with different lifespans
    live in the heap. Promotion between the generation and survival of objects depend
    on which generation they are placed in and how they survived prior GC cycles.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 框架中，由公共语言运行时定义的托管代码是内存资源由本地垃圾收集器管理的应用程序代码。GC 在初始化时分配内存的一个段来存储和管理内存资源，这被称为“托管堆”。CLR
    中的垃圾收集发生在三个不同的代上，不同生命周期的对象分别位于堆中。代之间的提升和对象的存活取决于它们被放置的代以及它们在之前的垃圾收集周期中的存活情况。
- en: SGen garbage collector
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SGen 垃圾收集器
- en: SGen garbage collector is the generational garbage collector used in most Xamarin
    projects (both Xamarin.iOS and Xamarin.Android). SGen performs more frequent garbage
    collections over smaller sets of objects which makes it more efficient over the
    conservative Boehm GC.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SGen 垃圾收集器是大多数 Xamarin 项目（包括 Xamarin.iOS 和 Xamarin.Android）使用的代式垃圾收集器。SGen 在更小的对象集上执行更频繁的垃圾收集，这使得它在保守的
    Boehm GC 上更有效率。
- en: SGen utilizes three heaps, namely The Nursery, Major Heap, and Large Object
    Space, to allocate memory segments for objects according to their memory requirements,
    and objects are promoted between the heaps when they survive through GC cycles.
    In this setup, The Nursery, similar to Generation 0 in CLR on .NET, is where most
    objects are created and destroyed and most of the GC cycles occur to release memory
    resources. Objects surviving the minor GC cycles can be promoted to the major
    heap. The major heap only has major GC passes in case the heap itself is running
    out of memory. The last heap is only for larger objects that have higher memory
    requirements, and does not accept promotion from other heaps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SGen 使用三个堆，即幼崽堆、主要堆和大对象空间，根据对象的内存需求分配内存段，当对象在垃圾收集周期中存活时，它们在堆之间进行提升。在这个配置中，幼崽堆类似于
    .NET CLR 中的第 0 代，是大多数对象被创建和销毁的地方，大多数的垃圾收集周期都发生在这里以释放内存资源。经过小周期垃圾收集后存活的对象可以被提升到主要堆。主要堆只有在堆本身即将耗尽内存时才会进行主要垃圾收集周期。最后一个堆仅用于具有更高内存需求的大对象，并且不接受来自其他堆的提升。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to remember that during a garbage collection cycle all the threads
    registered with the runtime, including the main run loop thread are paused. One
    exception to this execution pause is the separate process that continues to run
    the iOS animations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，在垃圾收集周期中，所有注册到运行时的线程，包括主运行循环线程，都会暂停。对此执行暂停的一个例外是继续运行 iOS 动画的独立进程。
- en: Boehm garbage collector (iOS only)
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Boehm 垃圾收集器（仅限 iOS）
- en: Boehm GC (aka Boehm-Demers-Weiser garbage collector) is an open-source garbage
    collector implementation that was initially created for C/C++ language implementations.
    As a conservative garbage collector, it still has procedures for leak detection,
    supports "finalized" semantics, and has limited support for generational implementations
    which makes it an attractive candidate for implementations and ports on various
    platforms.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Boehm GC (也称为 Boehm-Demers-Weiser 垃圾收集器) 是一个开源的垃圾收集器实现，最初是为 C/C++ 语言实现创建的。作为一个保守的垃圾收集器，它仍然有泄漏检测的程序，支持“已终结”语义，并且对代式实现的有限支持使其成为在各种平台上实现和移植的吸引人候选者。
- en: An implementation of Boehm GC is only available for Xamarin.iOS applications
    using the Classic API, in which it is the default garbage collector.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Boehm GC 的实现仅适用于使用 Classic API 的 Xamarin.iOS 应用程序，其中它是默认的垃圾收集器。
- en: Platform-specific concepts
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台特定概念
- en: In order to understand the memory management techniques and pitfalls, one must
    understand some platform-related concepts. Even though Xamarin provides an almost
    platform agnostic development experience, iOS and Android platforms deal with
    memory allocations and references slightly differently from .NET CLR and each
    other.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解内存管理技术和陷阱，必须了解一些与平台相关的概念。尽管 Xamarin 提供了几乎与平台无关的开发体验，但 iOS 和 Android 平台在内存分配和引用处理上与
    .NET CLR 以及彼此略有不同。
- en: Object reference types
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象引用类型
- en: Referred objects can be classified according to application needs. This classification
    helps the garbage collector decide whether the memory allocation can be released
    for the referred objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用需求，引用对象可以被分类。这种分类有助于垃圾收集器决定是否可以释放引用对象的内存分配。
- en: A strong reference protects the object from being "garbage collected". A referred
    object is said to be strongly referenced/reachable when the class instance is
    directly used by the current execution context.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用（Strong Reference）保护对象不被“垃圾回收”。当类实例直接由当前执行上下文使用时，引用的对象被称为强引用/可达。
- en: 'Weak references can be used for class instances when the need for the reference
    does not interfere with garbage collection. When the referred object is weakly
    reachable, the dependent section of code has to check whether the object is still
    alive before using the referenced object. Weak references have two types in CLR
    according to the dispose and finalization processes implemented by the declaring
    types: long and short weak references. Long weak references are types that can
    live on to be recreated and can be finalized by a destructor rather than being
    disposed or garbage collected.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要的引用会干扰垃圾收集时，可以使用弱引用（Weak References）来引用类实例。当引用的对象是弱可达的时，依赖的代码部分在使用引用对象之前必须检查该对象是否仍然存活。根据声明类型实现的释放和终结过程，弱引用在CLR中有两种类型：长弱引用和短弱引用。长弱引用是那些可以继续存在并可以被析构函数终结而不是被释放或垃圾回收的类型。
- en: Soft and phantom references are specific to Android runtime. Soft references,
    in simple terms, are a little more persistent than the weak references, and would
    only be cleared up by the garbage collector under memory pressure even though
    the object is no longer strongly reachable. Phantom references are the weakest
    reference in Android runtime. They are only used to implement specialized object
    finalization methods and have to be associated with a reference queue for processing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 软引用（Soft References）和虚引用（Phantom References）是Android运行时的特定内容。简单来说，软引用比弱引用更持久，只有在内存压力下，即使对象不再是强可达的，垃圾收集器才会清除它们。虚引用是Android运行时中最弱的引用。它们仅用于实现特殊对象终结方法，并且必须与引用队列关联以进行处理。
- en: Automatic Reference Counting (ARC)
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动引用计数（Automatic Reference Counting，简称ARC）
- en: Automatic Reference Counting is a compiler feature that was introduced in iOS
    5\. It is referred to as a compiler feature since it cannot be classified as a
    garbage collection implementation. It is a static analysis implementation where
    the compiler analyses the code execution tree and inserts retain and release messages
    according to the object persistence requirements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 自动引用计数（Automatic Reference Counting，简称ARC）是iOS 5中引入的编译器功能。它被称为编译器功能，因为它不能被归类为垃圾回收实现。它是一种静态分析实现，其中编译器分析代码执行树，并根据对象持久性要求插入保留和释放消息。
- en: With ARC, traditional memory management calls are not allowed to be inserted
    in the application to allocate memory and release memory addresses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARC中，不允许在应用程序中插入传统的内存管理调用以分配内存和释放内存地址。
- en: Troubleshooting and diagnosis
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除和诊断
- en: Profiling is the term used to describe the dynamic system analysis while the
    target application is running. Profilers generally collect data about metrics
    such as CPU utilization, framerate values, and most importantly data about memory
    allocations. Especially with Xamarin projects, since we are dealing with multiple
    platforms, profiling becomes an important part of testing and diagnostics.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 分析（Profiling）是描述在目标应用程序运行时进行的动态系统分析的术语。分析器通常收集有关CPU利用率、帧率值以及最重要的是内存分配数据等指标的数据。特别是在Xamarin项目中，由于我们处理多个平台，分析成为测试和诊断的重要部分。
- en: There are numerous tools that one can use to profile memory usage on Xamarin
    projects, Xamarin Profiler being the only one that can be used both for Xamarin.iOS
    and Xamarin.Android applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以用来分析Xamarin项目的内存使用情况，其中Xamarin Profiler是唯一一个可以用于Xamarin.iOS和Xamarin.Android应用程序的工具。
- en: Xamarin Profiler
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Xamarin Profiler
- en: Xamarin Profiler is the newest addition to the Xamarin Suite. This profiler
    has the advantage over other platform-specific applications since it can be run
    either on OS X or Windows targeting Xamarin.Android or Xamarin.iOS applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Profiler是Xamarin Suite中的最新成员。与其他平台特定应用程序相比，这个分析器具有优势，因为它可以在OS X或Windows上运行，针对Xamarin.Android或Xamarin.iOS应用程序。
- en: '![Xamarin Profiler](img/B04693_02_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Xamarin Profiler](img/B04693_02_02.jpg)'
- en: 'Figure 2: Xamarin Profiler'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：Xamarin Profiler
- en: It was designed to give developers almost real time (depending on the sampling
    rate) information about the memory heaps for Xamarin applications. It can also
    save memory allocation snapshots which can later on be accessed and analyzed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它被设计用来为开发者提供几乎实时的（取决于采样率）关于Xamarin应用程序内存堆的信息。它还可以保存内存分配快照，稍后可以访问和分析。
- en: It can be started directly from Visual Studio or Xamarin Studio and can be used
    with both emulator and real device build/run configurations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以直接从Visual Studio或Xamarin Studio启动，并且可以使用模拟器和真实设备构建/运行配置。
- en: Currently there are two instruments you can select in the initial popup window.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在初始弹出窗口中可以选择两个工具。
- en: Allocations instrument
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配工具
- en: The first instrument is the Allocations template which provides detailed information
    on the memory segments and allocations. In this view, developers can see a generalized
    list of allocations grouped by the class name under the **Summary** tab. The **Call
    Tree** tab gives a list of threads in the application and how they relate to the
    memory objects. Allocation list provides live data about the object allocations,
    and the **Snapshots** tab gives information about the memory snapshots stored.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项工具是分配模板，它提供了关于内存段和分配的详细信息。在这个视图中，开发者可以在**摘要**选项卡下看到按类名分组的分配的通用列表。**调用树**选项卡提供了应用程序中线程的列表以及它们与内存对象的关系。分配列表提供了关于对象分配的实时数据，而**快照**选项卡提供了存储的内存快照的信息。
- en: Time Profiler
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间分析器
- en: Time Profiler is the second instrument that can be used in Xamarin Profiler.
    It provides valuable information on how much time the application spent executing
    a certain method. Developers can see a whole stack trace on each method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 时间分析器是Xamarin Profiler中可以使用的第二项工具。它提供了关于应用程序执行特定方法花费多少时间的宝贵信息。开发者可以查看每个方法的整个堆栈跟踪。
- en: Device Monitor (Android only)
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备监控器（仅限Android）
- en: Android Device Monitor is hitherto the main diagnostic tool for Android development.
    And for Xamarin developers, when Android SDK is installed, device monitor can
    be accessed directly from a tool box item on Visual Studio and under the tools
    menu on Xamarin Studio.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备监控器迄今为止一直是Android开发的 主要诊断工具。对于Xamarin开发者来说，当安装了Android SDK后，可以直接从Visual
    Studio的工具箱项或Xamarin Studio的工具菜单中访问设备监控器。
- en: On the main page of the device monitor there is a tree-view displaying each
    device or simulator that can be attached to with the device monitor.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备监控器的主页上，有一个树形视图显示可以连接到设备监控器的每个设备或模拟器。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Only a single debugger can be attached to any device at a time, therefore other
    debuggers have to be detached before using the device monitor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只能连接一个调试器到任何设备，因此在使用设备监控器之前，其他调试器必须断开连接。
- en: Once the device is selected, developers can get allocation information and the
    heap state using the graphical interface. It is also possible to trigger garbage
    collection cycles using the device monitor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了设备，开发者可以使用图形界面获取分配信息和堆状态。使用设备监控器还可以触发垃圾回收周期。
- en: '![Device Monitor (Android only)](img/B04693_02_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![设备监控器（仅限Android）](img/B04693_02_03.jpg)'
- en: 'Figure 3: Android Device Monitor attached to Visual Studio Emulator'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：Android设备监控器连接到Visual Studio模拟器
- en: Instruments (iOS only)
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具（仅限iOS）
- en: Instruments is a valuable application that is installed together with the Xcode
    toolset. In this application developers are provided with a big set of diagnostic
    tools varying from energy consumption, graphic resources, to memory allocations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments是一个非常有价值的应用程序，它随Xcode工具集一起安装。在这个应用程序中，开发者可以提供一套从能耗、图形资源到内存分配的各种诊断工具。
- en: The allocations instrument has a very similar interface to Xamarin Profiler,
    and gives almost real-time data about memory objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 分配工具的界面与Xamarin Profiler非常相似，并提供几乎实时的内存对象数据。
- en: '![Instruments (iOS only)](img/B04693_02_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![工具（仅限iOS）](img/B04693_02_04.jpg)'
- en: 'Figure 4: Instruments Profiling Xamarin Application'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：Instruments分析Xamarin应用程序
- en: The Xcode Instruments tool can be used both together with an actual device or
    the iOS simulator. It can be started directly from Xamarin Studio. Once the application
    is started on the iOS simulator or on the actual device, it becomes available
    in the target selection window.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode Instruments工具可以与实际设备或iOS模拟器一起使用。它可以直接从Xamarin Studio启动。一旦应用程序在iOS模拟器或实际设备上启动，它就会在目标选择窗口中可用。
- en: '![Instruments (iOS only)](img/B04693_02_05.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![工具（仅限iOS）](img/B04693_02_05.jpg)'
- en: 'Figure 5: Instruments with iOS Simulator set as target'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5：以 iOS 模拟器为目标设备的 Instruments
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are developing Xamarin.iOS applications on Microsoft Windows with an
    OS X build machine, you will not be able to access the Instruments directly from
    the development station. Once the application is either on the test device or
    the simulator, you can start the instruments on the build machine and choose the
    correct target to analyze.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Microsoft Windows 开发 Xamarin.iOS 应用程序，并且有一个 OS X 构建机器，你将无法直接从开发站访问 Instruments。一旦应用程序在测试设备或模拟器上，你可以在构建机器上启动
    instruments 并选择正确的目标进行分析。
- en: Monotouch Profiler (iOS only)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Monotouch Profiler（仅限 iOS）
- en: Monotouch Profiler was the Xamarin tool used to diagnose memory issues with
    Xamarin.iOS applications before it was superseded by Xamarin Profiler. It can
    still be accessed using the **Run with Mono HeapShot** menu item under the **Project**
    menu in Xamarin Studio. While providing useful information about memory allocations
    and the heap, it currently does not go further than being a lightweight application
    to take memory snapshots.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Monotouch Profiler 是在它被 Xamarin Profiler 取代之前，用于诊断 Xamarin.iOS 应用程序内存问题的 Xamarin
    工具。它仍然可以通过在 Xamarin Studio 的 **项目** 菜单下使用 **运行与 Mono HeapShot** 菜单项来访问。虽然它提供了有关内存分配和堆的有用信息，但目前它仅限于作为一个轻量级应用程序来获取内存快照。
- en: Patterns and best practices
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和最佳实践
- en: While dealing with managed runtime and garbage collection, there are certain
    patterns and anti-patterns developers must be careful with. If not handled properly,
    both managed and native objects can produce noncollectable traces, which in turn
    can cause memory leaks and unnecessary resource consumption.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理托管运行时和垃圾回收时，开发者必须注意某些模式和反模式。如果不妥善处理，托管和本地对象都可能产生不可收集的跟踪，这反过来又可能导致内存泄漏和不必要的资源消耗。
- en: Disposable objects
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可释放对象
- en: The resources managed by the garbage collector are generally limited to memory
    allocations. Other resources like network sockets, database handles, UI elements,
    and file/device descriptors need to have additional definitions or mechanisms.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收器管理的资源通常限于内存分配。其他资源，如网络套接字、数据库句柄、UI 元素和文件/设备描述符需要额外的定义或机制。
- en: In managed runtime, these object resources can be cleaned up in two different
    ways. The first, less efficient, unpredictable way is to implement a destructor/finalizer.
    With a finalizer implementation, once the garbage collector decides the object
    is no longer strongly reachable, the resources such as network sockets can be
    disposed. However, finalizable objects have to wait for the following GC cycle
    to be cleaned up and cannot be finalized with developers' initiatives.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管运行时，这些对象资源可以通过两种不同的方式清理。第一种，效率较低、不可预测的方式是实现析构器/最终化器。一旦垃圾回收器决定对象不再被强引用，资源如网络套接字可以被释放。然而，可最终化的对象必须等待下一个
    GC 周期才能被清理，并且不能由开发者的主动操作来最终化。
- en: Another way to clean-up application resources is to implement the `IDisposable`
    interface in the class that has the references to the resources. This interface
    requires only a single `Dispose` method implementation to get rid of managed resources.
    The garbage collector also offers a method (`GC.SuppressFinalize`) to avoid finalization
    since the object is going to be disposed using the `IDisposable` interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 清理应用程序资源的另一种方法是，在具有资源引用的类中实现 `IDisposable` 接口。此接口只需要实现单个 `Dispose` 方法即可释放托管资源。垃圾回收器还提供了一个方法
    (`GC.SuppressFinalize`) 来避免最终化，因为对象将使用 `IDisposable` 接口进行处置。
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The fact that disposable objects can be used together with `using` blocks, gives
    a deterministic way for developers to release associated resources as soon as
    the object is no longer needed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可释放对象可以与 `using` 块一起使用，这为开发者提供了一种确定性的方法，以便在对象不再需要时立即释放相关资源。
- en: The lapsed listener problem
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过期监听器问题
- en: One of the most common patterns used with UI elements or legacy API implementations
    is the observer pattern. As you might know, there are two stakeholders in this
    pattern, the observer and provider. The observer subscribes to the event provided
    by the provider to receive updates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UI 元素或遗留 API 实现一起使用的最常见模式之一是观察者模式。正如你可能知道的，此模式中有两个利益相关者，观察者和提供者。观察者订阅提供者提供的事件以接收更新。
- en: The lapsed listener problem occurs when the observer pattern is implemented
    incorrectly or better yet incompletely. In this pattern, after the subscription,
    the provider keeps a strong reference to the observer. If this subscription is
    not removed before the subscriber goes out of context, the application will leak
    the subscriber object since it cannot be garbage collected (for example, an Android
    activity, or a view model).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当观察者模式实现不正确或不完整时，会出现已失效的监听器问题。在这个模式中，订阅后，提供者会保持对观察者的强引用。如果在这个订阅没有被移除之前订阅者离开了上下文，应用程序将无法回收订阅者对象（例如，Android活动或视图模型），从而导致内存泄漏。
- en: In order to demonstrate this problem, we will use a singleton implementation
    of Fibonacci sequence with asynchronous methods as the event provider.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个问题，我们将使用斐波那契序列的单例实现，并使用异步方法作为事件提供者。
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will implement two separate view models using MvvmCross and use associated
    views to invoke the asynchronous methods, then navigate back to the main view
    using the `Close` method on the view models. In the constructor of each view model,
    we will be subscribing to the respective event on the `FibonacciSource`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用MvvmCross实现两个独立的视图模型，并使用关联的视图来调用异步方法，然后使用视图模型上的`Close`方法返回到主视图。在每个视图模型的构造函数中，我们将订阅`FibonacciSource`上的相应事件。
- en: '![The lapsed listener problem](img/B04693_02_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![已失效的监听器问题](img/B04693_02_06.jpg)'
- en: 'Figure 6: Fibonacci Calculator App'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：斐波那契计算器应用
- en: In order to investigate any memory leaks, we navigate back and forth between
    the main and the calculation views. After a couple of iterations on both of the
    views (that is, single and range), we have the results shown below on the Xamarin
    Profiler (just using the "Allocations" template.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查任何内存泄漏，我们在主视图和计算视图之间来回导航。在两个视图（即单个和范围）上迭代几次之后（即，单次和范围），我们在Xamarin Profiler上得到了以下结果（仅使用“分配”模板）。
- en: '![The lapsed listener problem](img/B04693_02_07.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![已失效的监听器问题](img/B04693_02_07.jpg)'
- en: 'Figure 7: Xamarin Profiler Results'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：Xamarin Profiler结果
- en: You will notice that none of the instances of `SingleCalculationViewModel` are
    alive after garbage collection (you can trigger a GC run with `GC.Collect()`),
    however `RangeCalculationViewModel` instances are persistent. The reason for this
    is the missing unsubscribe call in the close command of the `RangeCalculationViewModel`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在垃圾回收（你可以通过`GC.Collect()`触发GC运行）之后，`SingleCalculationViewModel`的实例都不再存活，然而`RangeCalculationViewModel`的实例是持久的。这是因为`RangeCalculationViewModel`的关闭命令中缺少取消订阅的调用。
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We could have also used the `OnPause` event on this Android application or any
    other relevant event on other platforms to get rid of the subscription before
    the subscriber or the view component that holds the subscriber goes out of context.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个Android应用程序的`OnPause`事件或任何其他平台上的相关事件，在订阅者或持有订阅的视图组件离开上下文之前取消订阅。
- en: In this scenario, another solution would be to use a `TaskCompletionSource`
    to convert the observable pattern to an awaitable one. Wrapping up the observable
    Fibonacci source would give you a better control over the subscription and the
    resulting asynchronous task would be better suited for mobile development and
    MVVM pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，另一个解决方案是使用`TaskCompletionSource`将可观察模式转换为可等待模式。包装可观察的斐波那契源将给你更好的订阅控制，并且产生的异步任务更适合移动开发和MVVM模式。
- en: '[PRE4]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, this async task would be called with a `ContinueWith` statement to
    set the result in the view model.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个异步任务会通过`ContinueWith`语句被调用，以在视图模型中设置结果。
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Weak references
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弱引用
- en: Weak references can be of great assistance while dealing with loosely coupled
    application layers. In these type of scenarios, where objects need to be managed
    outside the class domain, weak referencing can be used to remove these instances
    from the GC protection based on the notion of reachability because of the strong
    references they have to other layers of the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用在处理松散耦合的应用层时可以提供很大的帮助。在这些类型的场景中，当对象需要在类域之外进行管理时，可以使用弱引用根据可达性概念从GC保护中移除这些实例，因为这些实例对应用的其他层有强引用。
- en: Let us assume in the previous example that the Fibonacci sequence items are
    handled as reference values with a class called `FibonacciItem`. This class carries
    the value calculated and the time it was calculated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设在前面的例子中，斐波那契序列项被处理为具有名为`FibonacciItem`的类的引用值。这个类携带计算出的值和计算的时间。
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To decrease the processing time, we can now implement a caching mechanism which
    would force the source to recalculate the value according to the ordinal if it
    does not already exist in the cache or just does not sound right is disposed of
    in favor of memory resources. For this purpose we can use the `WeakReference`
    to cache Fibonacci items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少处理时间，我们现在可以实施一个缓存机制，该机制将强制源根据序号重新计算值，如果它尚未存在于缓存中，或者如果它被废弃以节省内存资源。为此，我们可以使用`WeakReference`来缓存斐波那契项。
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Cross-domain objects
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨域对象
- en: In Xamarin applications, one of the most common memory issues, cross-heap references,
    occur when there is a cross-over between the native runtime and mono runtime.
    This issue stems from the fact that mono runtime is almost handled as a separate
    domain and managed in a heap only with GC handles to the native domain.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin应用程序中，最常见的一个内存问题，跨堆引用，发生在原生运行时和mono运行时之间发生交叉时。这个问题源于mono运行时几乎被视为一个独立的域，并且仅通过GC句柄在原生域的堆中进行管理。
- en: In an Android scenario, where Java objects are referenced by managed C# objects
    or vice versa, the communication between the two runtimes becomes expensive. For
    instance, if we were implementing the Fibonacci calculator without using the ViewModel
    pattern, we would want to create a data adaptor to load the range calculation
    results into a list view.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android场景中，当Java对象被托管C#对象引用或反之亦然时，两个运行时之间的通信变得昂贵。例如，如果我们不使用ViewModel模式实现斐波那契计算器，我们希望创建一个数据适配器，将范围计算结果加载到列表视图中。
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This implementation has a higher cost of being garbage collected. It also has
    performance penalties considering the language crossing, not to mention the fact
    that objects from each world are effectively mirrored increasing the memory allocation
    costs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现具有更高的垃圾收集成本。考虑到语言交叉，它还有性能惩罚，更不用说每个世界中的对象实际上被镜像，这增加了内存分配成本。
- en: The solution here would be to do as much work as possible in the managed world
    and let the runtime take care of the rest. So instead of using the native `ArrayAdapter`,
    we could implement a base adapter that would feed the `FibonacciItem` instances
    to the `ListView`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的解决方案是在托管世界中尽可能多地完成工作，让运行时处理其余部分。因此，我们不是使用本地的`ArrayAdapter`，而是可以实现一个基适配器，将`FibonacciItem`实例传递给`ListView`。
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By implementing the adapter we removed the usage of Java type `ArrayAdapter`,
    `ArrayList` and the Java references to the `FibonacciItem` instances.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现适配器，我们移除了Java类型`ArrayAdapter`、`ArrayList`以及Java对`FibonacciItem`实例的引用。
- en: The same applies to scenarios where native objects are being inherited in the
    managed domain. These, so-called, "special objects" are handled differently by
    the garbage collector. They have to be rescanned for all the references they carry
    with each garbage collection cycle.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于在托管域中继承原生对象的情况。这些所谓的“特殊对象”由垃圾收集器以不同的方式处理。它们必须在每次垃圾回收周期中重新扫描它们携带的所有引用。
- en: Cyclic references (cycles)
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环引用（循环）
- en: Cyclic references occur, in general terms, when the underlying platform uses
    some type of reference counting as memory management strategy and the memory is
    cleaned up according to the number of references to that specific object instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，当底层平台使用某种类型的引用计数作为内存管理策略，并且根据对该特定对象实例的引用数量来清理内存时，会发生循环引用。
- en: Reference counting was abandoned by Microsoft with the release of .NET and the
    introduction of the generational tracing garbage collection. SGen in mono runtime
    on Android devices also uses some form of a mark and sweep algorithm. In both
    runtimes, the references are traced from so called "application roots". These
    objects are the ones that are "presumed" to be alive at the time of a garbage
    collection cycle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Microsoft发布.NET和引入代际跟踪垃圾回收，Microsoft放弃了引用计数。在Android设备上的mono运行时，SGen也使用某种形式的标记和清除算法。在这两个运行时中，引用都是从所谓的“应用程序根”进行追踪的。这些对象是在垃圾回收周期时“假定”为存活的对象。
- en: 'The roots can be:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根可以是：
- en: References to global objects
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对全局对象的引用
- en: References to static objects
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对静态对象的引用
- en: References to static fields
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对静态字段的引用
- en: References on the stack to local objects
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对栈上局部对象的引用
- en: References to objects waiting to be finalized
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等待最终化的对象的引用
- en: References in CPU registers to objects on the managed heap
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对CPU寄存器中托管堆上对象的引用
- en: However, as mentioned before, on iOS, garbage collection was abandoned in favor
    of performance and yet ARC (automatic reference counting) fails to deal with what
    is called a retain cycle. Retain cycle occurs when the lower elements (aka children)
    in the creation hierarchy require references to the parent items. In this scenario,
    when the child or the parent sends a `release`, the `dealloc` methods never get
    to run since there is an extra reference keeping each of the items alive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如前所述，在iOS上，为了性能而放弃了垃圾回收，而ARC（自动引用计数）却无法处理所谓的保留周期。保留周期发生在创建层次结构中的较低元素（即子元素）需要引用父元素时。在这种情况下，当子或父发送`release`时，由于存在额外的引用保持每个项目存活，`dealloc`方法永远不会运行。
- en: '![Cyclic references (cycles)](img/B04693_02_08.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![循环引用（循环）](img/B04693_02_08.jpg)'
- en: 'Figure 8: Retain Cycle'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：保留周期
- en: This native iOS problem becomes a problem in Xamarin applications when managed
    objects derive from native objects (that is, any object deriving from `NSObect`)
    such as UI controls. When managed classes are inheriting from native objects,
    in order to keep them from getting garbage collected, Xamarin.iOS creates a GCHandle.
    These GCHandles, together with the managed references between the objects, create
    the described (indirect) retain cycle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当托管对象从原生对象（即从`NSObect`派生的任何对象）派生时，例如UI控件，这种本地的iOS问题就会成为Xamarin应用程序的问题。当托管类从原生对象继承时，为了防止它们被垃圾回收，Xamarin.iOS创建了一个GCHandle。这些GCHandles以及对象之间的托管引用共同创建了所描述的（间接）保留周期。
- en: 'If we were dealing with a parent `UIView` that holds an array of children and
    the child view objects that were retaining a reference to the parent object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是一个包含子视图数组的父`UIView`，并且子视图对象保留了对父对象的引用：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following piece of code would create a retain cycle and would cause memory
    leaks in the application:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将创建一个保留周期，并导致应用程序中的内存泄漏：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If we were to execute this code in the constructor of a view, every time the
    application navigates to this view, we would be creating a new parent object,
    never to be garbage collected.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在视图的构造函数中执行此代码，每次应用程序导航到这个视图时，我们都会创建一个新的父对象，它永远不会被垃圾回收。
- en: '![Cyclic references (cycles)](img/B04693_02_09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![循环引用（循环）](img/B04693_02_09.jpg)'
- en: 'Figure 9: Instruments view for retained objects'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：保留对象的工具视图
- en: In this case, the easiest fix would be to use a `WeakReference` while we are
    creating a reference to the parent object from the child one. Using the weak reference
    avoids the retain cycle situations and does not interfere with the garbage collection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最简单的修复方法是，当我们从子对象创建对父对象的引用时使用`WeakReference`。使用弱引用可以避免保留周期情况，并且不会干扰垃圾回收。
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another option would be to implement `IDisposable` interface to remove the strong
    link between the objects by setting the references to null before GC.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是实现`IDisposable`接口，通过在GC之前将引用设置为null来移除对象之间的强链接。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In order to manage application resources, one must have a deeper understanding
    of the application lifecycle. Application lifecycle events, outlined in this chapter,
    are the main access points to underlying platform runtime on both iOS and Android.
    If used properly, the event delegates and event methods on both platforms can
    help developers save valuable resources and avoid memory problems.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理应用程序资源，必须对应用程序生命周期有更深入的了解。本章概述的应用程序生命周期事件是iOS和Android平台上访问底层平台运行时的主要入口点。如果使用得当，两个平台上的事件委托和事件方法可以帮助开发者节省宝贵的资源并避免内存问题。
- en: Other concepts discussed were garbage collection, object references, and automatic
    reference counting. These concepts make up the foundation of memory management
    on target Xamarin platforms.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的其他概念包括垃圾回收、对象引用和自动引用计数。这些概念构成了目标Xamarin平台内存管理的基础。
- en: We also had a closer look at the diagnostic and profiling tools for target platforms
    and how they can be used effectively. While iOS and Android platforms each have
    a native app to analyze memory allocations, Xamarin Profiler provides a unified
    solution for both platforms.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更详细地研究了目标平台的诊断和性能分析工具以及如何有效地使用它们。虽然iOS和Android平台各自都有一个用于分析内存分配的本地应用程序，但Xamarin
    Profiler为这两个平台提供了一个统一的解决方案。
- en: Finally, useful patterns were outlined for different memory related issues and
    pitfalls. To analyze these patterns, Xamarin Profiler and Instruments were used
    for Android and iOS applications respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，针对不同记忆相关问题和陷阱，概述了一些有用的模式。为了分析这些模式，分别使用了Xamarin Profiler和Instruments来分析Android和iOS应用程序。
- en: In the next chapter, we will be looking at asynchronous implementation techniques
    and investigate various patterns of multi-threading and background execution.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨异步实现技术，并研究多线程和后台执行的各种模式。
