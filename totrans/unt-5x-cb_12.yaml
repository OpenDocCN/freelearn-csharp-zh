- en: Chapter 12. Editor Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。编辑器扩展
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，允许在设计时通过自定义检查器UI更改拾取类型（和参数）
- en: An editor extension to add 100 randomly located copies of a prefab with one
    menu click
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，通过一个菜单点击添加100个随机位置的预制体副本
- en: A progress bar to display proportion completed of Editor extension processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进度条来显示编辑器扩展处理完成的百分比
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，拥有一个对象创建器GameObject，带有按钮在场景中十字准星对象位置实例化不同的拾取
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One aspect of game development in general (and inventories as our particular
    examples in this chapter) is the distinction about *when* we undertake an activity.
    **Run-time** is when the game is running (and when all our software and UI choices
    take affect). However, **design-time** is the time when different members of our
    game design team work on constructing a wide range of game components, including
    the scripts, audio and visual assets, and the process of constructing each game
    level (or "scene" in Unity-speak).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发的一般方面（以及在本章中作为特定例子的库存）的一个方面是关于*何时*我们进行活动的区分。**运行时**是游戏运行时（以及我们所有的软件和UI选择生效时）。然而，**设计时**是我们游戏设计团队的不同成员在构建各种游戏组件的时间，包括脚本、音频和视觉资产，以及构建每个游戏关卡（或Unity中的“场景”）的过程。
- en: In this chapter, we will introduce several recipes that make use of Unity's
    Editor extensions; these are scripting and multimedia components that enable a
    game software engineer to make design-time work easier and less likely to introduce
    errors. Editor extensions allow workflow improvements, thus allowing designers
    to achieve their goals quicker and more easily; for example, removing the need
    for any scripting knowledge when generating many randomly located inventory pickups
    in a scene via a menu choice, or editing the type or properties of pickups being
    hand-placed in different locations in a level.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几个使用Unity编辑器扩展的食谱；这些是脚本和多媒体组件，使游戏软件工程师能够使设计时工作更容易，更不容易出错。编辑器扩展允许工作流程改进，从而让设计师更快、更轻松地实现目标；例如，通过菜单选择在场景中生成许多随机位置的库存拾取时，无需任何脚本知识，或者编辑在关卡中不同位置手动放置的拾取的类型或属性。
- en: While Editor extensions are quite an advanced topic, having someone on your
    team who can write custom editor components, such as those we illustrate, can
    greatly increase the productivity of a small team with only one or two members
    who are confident at scripting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编辑器扩展是一个相当高级的话题，但如果你团队中有能够编写自定义编辑器组件的人，例如我们展示的那些，可以大大提高只有一两个成员且对脚本有信心的小型团队的效率。
- en: An editor extension to allow pickup type (and parameters) to be changed at design
    time via a custom Inspector UI
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，允许在设计时通过自定义检查器UI更改拾取类型（和参数）
- en: The use of **enums** and corresponding drop-down menus in the Inspector panel
    to restrict changes to one of a limited set often works fine (for example, pickup
    types for a pickup object). However, the trouble with this approach is, when two
    or more properties are related and need to be changed together, there is a danger
    of changing one property, for example, pickup type from **Heart** to **Key**,
    but forgetting to change corresponding properties; for example, leaving the **Sprite
    Renderer** component still showing a **Heart sprite**. Such mismatches cause problems
    both in terms of messing up intended level design and, of course, the frustration
    for the player when they collide with something showing one pickup image, but
    a different kind of pickup type is added to the inventory!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器面板中使用**枚举**和相应的下拉菜单来限制更改到有限集中的一个，通常效果不错（例如，拾取对象的拾取类型）。然而，这种方法的麻烦在于，当两个或多个属性相关且需要一起更改时，存在更改一个属性的风险，例如，将拾取类型从**心形**更改为**钥匙**，但忘记更改相应的属性；例如，让**精灵渲染器**组件仍然显示**心形精灵**。这种不匹配既会搞乱预期的关卡设计，当然，当玩家与显示一个拾取图像但实际添加到库存中的拾取类型不同时，也会让玩家感到沮丧！
- en: If a class of GameObject has several related properties or components, which
    all need to be changed together, then a good strategy is to use Unity Editor extensions
    to do all the associated changes each time a different choice is made from a drop-down
    menu showing the defined set of enumerated choices.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GameObject有一个或多个相关的属性或组件，并且所有这些都需要一起更改，那么一个很好的策略是使用Unity编辑器扩展，每次从显示定义的枚举选择集的下拉菜单中选择不同的选项时，都执行所有相关的更改。
- en: In this recipe, we introduce an Editor extension for PickUp components of GameObjects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们介绍了一个用于GameObject的PickUp组件的编辑器扩展。
- en: '![An editor extension to allow pickup type (and parameters) to be changed at
    design time via a custom Inspector UI](img/1362OT_12_41.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![允许在设计时通过自定义检查器UI更改拾取类型（和参数）的编辑器扩展](img/1362OT_12_41.jpg)'
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with project `Simple2Dgame_SpaceGirl` setup
    from the first recipe in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"), *Inventory
    GUIs*. A copy of this Unity project is provided in a folder named `unityProject_spaceGirlMiniGame`
    in the `1362_12_01` folder.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱假设您从[第2章](ch02.html "第2章。库存GUI")中第一个菜谱设置的`Simple2Dgame_SpaceGirl`项目开始，该项目的设置在*库存GUI*中。在`1362_12_01`文件夹中提供了一个Unity项目的副本，文件夹名为`unityProject_spaceGirlMiniGame`。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an editor extension to allow pickup type (and parameters) to be changed
    at design-time via a custom Inspector UI, follow these steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个编辑器扩展，允许在设计时通过自定义检查器UI更改拾取类型（和参数），请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从迷你游戏`Simple2Dgame_SpaceGirl`的新副本开始。
- en: 'In the **Project** panel, create a new folder named `EditorSprites`. Move the
    following images from folder `Sprites` into this new folder: `star`, `healthheart`,
    `icon_key_green_100`, `icon_key_green_32`, `icon_star_32`, and `icon_heart_32`.![How
    to do it...](img/1362OT_12_55.jpg)'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，创建一个名为`EditorSprites`的新文件夹。将以下图像从`Sprites`文件夹移动到这个新文件夹：`star`、`healthheart`、`icon_key_green_100`、`icon_key_green_32`、`icon_star_32`和`icon_heart_32`。![如何操作...](img/1362OT_12_55.jpg)
- en: In the **Hierarchy** panel, rename GameObject `star` to be named `pickup`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将GameObject `star`重命名为`pickup`。
- en: Edit the tags, changing tag **Star** to **Pickup**. Ensure the `pickup` GameObject
    now has the tag **Pickup**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑标签，将标签**Star**更改为**Pickup**。确保`pickup` GameObject现在具有标签**Pickup**。
- en: 'Add the following C# script `PickUp` to GameObject `pickup` in the **Hierarchy**:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本`PickUp`添加到`pickup` GameObject的**层次结构**中：
- en: '[PRE0]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `PickUpEditor`, with the following
    code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中，创建一个名为`Editor`的新文件夹。在此新文件夹中，创建一个名为`PickUpEditor`的新C#脚本类，代码如下：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the **Inspector** panel, select GameObject `pickup` and choose different
    values of the drop-down menu **PickUp Type**. You should see corresponding changes
    in the image and icons in the **Inspector** for the **Pick Up (Script)** component
    (three icons with the name of the type in between). The **Sprite** property of
    the **Sprite Renderer** component for this GameObject should change. Also, in
    the **Scene** panel, you'll see the image in the scene change to the appropriate
    image for the pickup type you have chosen.![How to do it...](img/1362OT_12_42.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**面板中，选择GameObject `pickup`并选择**拾取类型**下拉菜单的不同值。你应该在**检查器**的**拾取（脚本）**组件中的图像和图标中看到相应的更改（三个带有类型名称的图标）。此GameObject的**Sprite
    Renderer**组件的**Sprite**属性应该更改。此外，在**场景**面板中，你会看到场景中的图像更改为你选择的拾取类型的适当图像。![如何操作...](img/1362OT_12_42.jpg)
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Our script class `PickUp` has the enum `PickUpType` with the three values:
    `Star`, `Health`, and `Key`. Also, there is the variable `type`, storing the type
    of the parent GameObject. Finally, there is a `SetSprite(…)` method that sets
    the **Sprite Renderer** component of the parent GameObject to be set to the provided
    `Sprite` parameter. It is this method that is called from the editor script each
    time the pickup type is changed from the drop-down menu (with the corresponding
    sprite for the new type being passed).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本类`PickUp`有一个枚举`PickUpType`，包含三个值：`Star`、`Health`和`Key`。此外，还有一个变量`type`，用于存储父GameObject的类型。最后，有一个`SetSprite(…)`方法，用于将父GameObject的**Sprite
    Renderer**组件设置为提供的`Sprite`参数。每次从编辑器脚本中调用此方法时，都会更改拾取类型，并传递对应新类型的相应精灵。
- en: 'The vast majority of the work for this recipe is the responsibility of the
    script class `PickUpEditor`. While there is a lot in this script, its work is
    relatively straightforward: for each frame, via method `OnInspectorGUI()`, a dropdown
    list of `PickUpType` values is presented to the user. Based on the value selected
    from this drop-down list, one of three methods is executed: `InspectorGUI_HEALTH()`,
    `InspectorGUI_KEY()`, `InspectorGUI_STAR()`. Each of these methods displays three
    icons and the name of the type in the Inspector beneath the drop-down menu and
    ends by calling the `SetSprite(…)` method of the GameObject being edited in the
    Inspector to update the **Sprite Renderer** component of the parent GameObject
    with the appropriate sprite.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的大部分工作都由脚本类 `PickUpEditor` 负责。虽然这个脚本中有很多内容，但其工作相对简单：对于每一帧，通过 `OnInspectorGUI()`
    方法，向用户展示一个 `PickUpType` 值的下拉列表。根据从下拉列表中选择的值，执行三种方法之一：`InspectorGUI_HEALTH()`、`InspectorGUI_KEY()`、`InspectorGUI_STAR()`。这些方法在每个方法中都在下拉菜单下方显示三个图标和类型名称，并在最后调用正在编辑的
    GameObject 的 `SetSprite(…)` 方法来更新父 GameObject 的 **Sprite Renderer** 组件。
- en: The C# attribute `[CustomEditor(typeof(PickUp))]` appearing before our class
    is declared, tells Unity to use this special editor script to display component
    properties in the **Inspector** panel for **Pick Up (Script)** components of GameObjects,
    rather than Unity's default **Inspector** which displays public variables of such
    scripted components.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类声明之前出现的 C# 属性 `[CustomEditor(typeof(PickUp))]` 告诉 Unity 使用这个特殊的编辑脚本来显示
    GameObject 的 **Inspector** 面板中的组件属性，而不是 Unity 的默认 **Inspector**，后者显示此类脚本组件的公共变量。
- en: Before and after its main work, the `OnInspectorGUI()` method first ensures
    that any variables relating to the object being edited in the Inspector have been
    updated —`serializedObject.Update()`. The last statement of this method correspondingly
    ensures that any changes to variables in the editor script have been copied back
    to the GameObject being edited—`serializedObject.ApplyModifiedProperties()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnInspectorGUI()` 方法的主要工作之前和之后，首先确保与检查器中正在编辑的对象相关的任何变量都已更新——`serializedObject.Update()`。这个方法中的最后一条语句相应地确保将编辑脚本中变量的任何更改复制回正在编辑的
    GameObject——`serializedObject.ApplyModifiedProperties()`。
- en: The `OnEnable()` method of script class `PickUpEditor` loads the three small
    icons (for display in the **Inspector**) and the three larger sprite images (to
    update the **Sprite Renderer** for display in the **Scene/Game** panels). The
    `pickupObject` variable is set to be a reference to the `PickUp` scripted component,
    allowing us to call the `SetSprite(…)` method. The `pickUpType` variable is set
    to be linked to the type variable of the `PickUp` scripted component whose special
    **Inspector** editor view makes this script possible—`serializedObject.FindProperty
    ("type")`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类 `PickUpEditor` 的 `OnEnable()` 方法加载三个小图标（用于在 **Inspector** 中显示）和三个较大的精灵图像（用于更新在
    **Scene/Game** 面板中显示的 **Sprite Renderer**）。`pickupObject` 变量被设置为对 `PickUp` 脚本组件的引用，允许我们调用
    `SetSprite(…)` 方法。`pickUpType` 变量被设置为与 `PickUp` 脚本组件的类型变量链接，该组件的特殊 **Inspector**
    编辑器视图使此脚本成为可能——`serializedObject.FindProperty ("type")`。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Here are some details you don't want to miss.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些细节你不希望错过。
- en: Offer the custom editing of pickup parameters via Inspector
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过检查器提供拾取参数的自定义编辑
- en: Many pickups have additional properties, rather than simply being an item being
    carried. For example, a health pickup may add health "points" to the player's
    character, a coin pickup may add money "points" to the characters bank balance,
    and so on. So, let's add an integer `points` variable to our `PickUp` class and
    offer the user the ability to easily edit this points value via a GUI slider in
    our customer Inspector editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多拾取项具有额外的属性，而不仅仅是携带的物品。例如，一个健康拾取项可能向玩家的角色添加“点数”，一个硬币拾取项可能向角色的银行余额添加“点数”，等等。因此，让我们在我们的
    `PickUp` 类中添加一个整数 `points` 变量，并允许用户通过我们的自定义检查器编辑器中的 GUI 滑块轻松编辑此点数值。
- en: '![Offer the custom editing of pickup parameters via Inspector](img/1362OT_12_49.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![通过检查器提供拾取参数的自定义编辑](img/1362OT_12_49.jpg)'
- en: 'To add an editable points property to our `PickUp` objects, follow these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的 `PickUp` 对象添加可编辑的点属性，请按照以下步骤操作：
- en: 'Add the following extra line into C# script `PickUp` to create our new integer
    `points` variable:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下额外行添加到 C# 脚本 `PickUp` 中，以创建我们新的整数 `points` 变量：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `points` variable:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#脚本`PickUpEditor`中添加以下额外行，以处理我们新的整数`points`变量：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following extra line into the `OnEnable()` method in C# script `PickUpEditor`
    to associate our new `points` variable with its corresponding value in the `PickUp`
    scripted component of the GameObject being edited:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#脚本`PickUpEditor`中的`OnEnable()`方法中添加以下额外行，以将我们的新`points`变量与其对应的GameObject的`PickUp`脚本组件中的值关联起来：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can add an extra line into each GUI method for the different PickUp
    types. For example, we can add a statement to display an **IntSlider** to the
    user to be able to see and modify the points value for a **Health PickUp** object.
    We add a new statement at the end of the `InspectorGUI_HEALTH()`method in C# script
    `PickUpEditor` to display a modifiable **IntSlider** representing our new `points`
    variable as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以为不同类型的PickUp添加额外的行到每个GUI方法中。例如，我们可以添加一个语句向用户显示一个**IntSlider**，以便他们能够查看和修改**Health
    PickUp**对象的点值。我们在C#脚本`PickUpEditor`中的`InspectorGUI_HEALTH()`方法末尾添加了一个新的语句，如下所示，以显示一个可修改的**IntSlider**，代表我们新的`points`变量：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We provide four parameters to the `IntSlider(…)` method. The first is the text
    label the user will see next to the slider. The second is the initial value the
    slider displays. The last two are the maximum and minimum values. In our example,
    we are permitting values from 0 to 100, but if health pickups only offer one,
    two, or three health points, then we'd just call with `EditorGUILayout.IntSlider
    ("Health points", points.intValue, 1, 5)`. This method returns a new integer value
    based on where the slider has been positioned, and this new value is stored back
    into the integer value part of our `SerializedProperty` variable points.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`IntSlider(…)`方法提供了四个参数。第一个是用户将在滑块旁边看到的文本标签。第二个是滑块显示的初始值。最后两个是最大值和最小值。在我们的例子中，我们允许从0到100的值，但如果健康拾取只提供一、二或三个健康点，那么我们只需调用`EditorGUILayout.IntSlider
    ("Health points", points.intValue, 1, 5)`。此方法返回一个基于滑块位置的新整数值，并将此新值存储回我们的`SerializedProperty`变量`points`的整数部分。
- en: Note that the loading and saving of values from the scripted component in the
    GameObject and our editor script is all part of the work undertaken by our calls
    to the `Update()` method and the `ApplyModifiedProperties()` method on the serialized
    object in the `OnInspectorGUI()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从GameObject中的脚本组件和我们的编辑器脚本中加载和保存值，都是我们调用`OnInspectorGUI()`方法中的`Update()`方法和`ApplyModifiedProperties()`方法在序列化对象上执行的工作的一部分。
- en: Note that since points may not have any meaning for some pickups, for example,
    keys, then we simply would not display any slider for the GUI Inspector editor
    when the user is editing **PickUp** objects of that type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于对于某些拾取（例如钥匙）点数可能没有任何意义，因此当用户正在编辑该类型的**PickUp**对象时，我们不会在GUI Inspector编辑器中显示任何滑块。
- en: Offer a drop-down list of tags for key-pickup to fit via Inspector
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为关键拾取通过Inspector提供标签下拉列表
- en: While the concept of "points" may have no meaning for a key pickup, the concept
    of the type of lock that a given key fits is certainly something we may wish to
    implement in a game. Since Unity offers us a defined (and editable) list of string
    tags for any GameObject, often it is sufficient, and straightforward, to represent
    the type of lock or door corresponding to a key via its tag. For example, a green
    key might fit all objects tagged **LockGreen** and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于钥匙拾取，“点数”可能没有意义，但给定钥匙适合的锁的类型肯定是我们希望在游戏中实现的东西。由于Unity为我们提供了任何GameObject的字符串标签的（定义和可编辑）列表，通常通过标签表示与钥匙对应的锁或门类型是足够简单和直接的。例如，绿色钥匙可能适合所有标记为**LockGreen**的对象等等。
- en: '![Offer a drop-down list of tags for key-pickup to fit via Inspector](img/1362OT_12_50.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![为关键拾取提供标签下拉列表以通过Inspector适配](img/1362OT_12_50.jpg)'
- en: Therefore, it is very useful to be able to offer a custom Inspector editor for
    a string property of key pickups that stores the tag of the lock(s) the key can
    open. This task combines several actions, including using C# to retrieve an array
    of tags from the Unity editor, then the building and offering of a drop-down list
    of these tags to the user, with the current value already selected in this list.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，能够为关键拾取的字符串属性提供一个自定义的Inspector编辑器，以存储可以打开的锁的标签，是非常有用的。这个任务结合了几个动作，包括使用C#从Unity编辑器检索一个标签数组，然后构建并提供一个包含这些标签的下拉列表给用户，当前值已在此列表中选中。
- en: 'To add a selectable list of strings for the tag for lock(s) that a key fits,
    follow these steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要为适合锁的标记添加一个可选择的字符串列表，请按照以下步骤操作：
- en: 'Add the following extra line into C# Script `PickUp` to create our new integer
    `fitsLockTag` variable:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#脚本`PickUp`中添加以下额外行以创建我们的新整数`fitsLockTag`变量：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following extra line into C# script `PickUpEditor` to work with our
    new integer `fitsLockTag` variable:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#脚本`PickUpEditor`中添加以下额外行以处理我们的新整数`fitsLockTag`变量：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following extra line into the `OnEnable()`method in C# script `PickUpEditor`
    to associate our new `fitsLockTag` variable with its corresponding value in the
    PickUp scripted component of the GameObject being edited:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#脚本`PickUpEditor`的`OnEnable()`方法中添加以下额外行，以将我们的新`fitsLockTag`变量与其对应的GameObject正在编辑的拾取脚本组件中的值关联起来：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to add some extra lines of code into the GUI method for key PickUps.
    We need to add several statements to the end of method `InspectorGUI_KEY()` in
    C# script `PickUpEditor` to set up and display a selectable popup drop-down list
    representing our new `fitsLockTag` variable as follows. Replace the `InspectorGUI_KEY()`
    method with the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在用于关键拾取的GUI方法中添加一些额外的代码行。我们需要在C#脚本`PickUpEditor`中的`InspectorGUI_KEY()`方法末尾添加几个语句来设置并显示一个可选择的弹出下拉列表，表示我们的新`fitsLockTag`变量，如下所示。用以下代码替换`InspectorGUI_KEY()`方法：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've added several statements to the end of this method. First `tags`, an array
    of strings, is created (and sorted), containing the list of tags currently available
    in the Unity editor for the current game. We then attempt to find the location
    in this array of the current value of `fitsLockTag` — we can use the `BinarySearch(…)`
    method of built-in script class `Array` because we have alphabetically sorted
    our array (which also makes it easier for the user to navigate). If the string
    in `fitsLockTag` cannot be found in array `tags`, then the first item will be
    selected by default (index 0).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在这个方法的末尾添加了几个语句。首先创建了一个字符串数组`tags`（并排序），包含当前游戏在Unity编辑器中可用的标记列表。然后我们尝试在数组中找到`fitsLockTag`当前值的定位——由于我们已经按字母顺序排序了数组（这也使得用户更容易导航），我们可以使用内置脚本类`Array`的`BinarySearch(…)`方法。如果`fitsLockTag`中的字符串在`tags`数组中找不到，则默认选择第一个项目（索引0）。
- en: The user is then shown the drop-down list via the `GUILayout` method `EditorGUILayout.Popup(…)`,
    and this method returns the index of whichever item is selected. The selected
    index is stored into `selectedTagIndex`, and the last statement in the method
    extracts the corresponding string and stores that string into the `fitsLockTag`
    variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用户通过`GUILayout`方法的`EditorGUILayout.Popup(…)`看到下拉列表，此方法返回所选项目的索引。所选索引存储到`selectedTagIndex`中，方法中的最后一个语句提取相应的字符串并将其存储到`fitsLockTag`变量中。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Rather than displaying all possible tags, a further refinement might
    remove all items from array ''tags'' that do not have the prefix ''Lock''. So
    the user is only presented with tags such as ''LockBlue'' and ''LockGreen'', and
    so on.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：而不是显示所有可能的标记，进一步的改进可能移除数组'tags'中所有没有前缀'Lock'的项目。因此，用户只会看到像'LockBlue'和'LockGreen'这样的标记，等等。
- en: Logic to open doors with keys based on fitsLockTag
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于fitsLockTag打开门的逻辑
- en: In our player collision logic, we can now search through our inventory to see
    if any key items fit the lock we have collided with. For example, if a green door
    was collided with, and the player was carrying a key that could open such doors,
    then that item should be removed from the inventory `List<>` and the door should
    be opened.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的玩家碰撞逻辑中，我们现在可以搜索我们的库存，看看是否有任何钥匙物品适合我们与之碰撞的锁。例如，如果与绿色门发生碰撞，并且玩家携带的钥匙可以打开这样的门，那么该物品应该从库存`List<>`中移除，并且门应该被打开。
- en: 'To implement this, you would need to add an `if` test inside the `OnTriggerEnter()`
    method to detected collision with the item tagged `Door`, and then logic to attempt
    to open the door, and, if unsuccessful, do the appropriate action (for example,
    play sound) to inform the player they cannot open the door yet (we''ll assume
    we have written a door animation controller that plays the appropriate animation
    and sounds and when a door is to be opened):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要在`OnTriggerEnter()`方法中添加一个`if`测试来检测与标记为`Door`的物品的碰撞，然后添加逻辑来尝试打开门，如果失败，则执行适当的动作（例如，播放声音）来通知玩家他们现在还不能打开门（我们假设我们已经编写了一个门动画控制器，当门要打开时，它会播放适当的动画和声音）：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `OpenDoor()` method would need to identify which item (if any) in the inventory
    can open such a door, and, if found, then that item should be removed from the
    `List<>` and the door should be opened by the appropriate method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenDoor()` 方法需要识别库存中哪些项目（如果有的话）可以打开这样的门，如果找到，则应该从 `List<>` 中移除该物品，并通过适当的方法打开门：'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the code for a method to find the inventory list key item
    fitting a door tag:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个查找适合门标签的库存列表关键项目的代码方法：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The need to add [SerializeField] for private properties
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要在私有属性中添加 [SerializeField]
- en: Note that if we wished to create editor extensions to work with private variables,
    then we'd need to explicitly add `[SerializeField]` in the line immediately before
    the variable to be changed by the editor script. Public variables are serialized
    by default in Unity, so this was not required for our public `type` variable in
    script class `PickUp`, although it's good practice to flag ALL variables that
    are changeable via an Editor Extension in this way.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们希望创建用于处理私有变量的编辑器扩展，那么我们需要在编辑器脚本将要更改的变量所在行的前面显式添加 `[SerializeField]`。在
    Unity 中，公共变量默认会进行序列化，因此对于脚本类 `PickUp` 中的公共 `type` 变量来说，这并不是必需的，尽管将所有可以通过编辑器扩展更改的变量以这种方式标记为良好实践。
- en: Learn more from the Unity documentation
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Unity 文档中了解更多信息
- en: Unity provides documentation pages about editor scripts at [http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了有关编辑器脚本的文档页面，位于 [http://docs.unity3d.com/ScriptReference/Editor.html](http://docs.unity3d.com/ScriptReference/Editor.html)。
- en: An editor extension to add 100 randomly located copies of a prefab with one
    menu click
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过一次菜单点击添加 100 个随机位置预制件的编辑器扩展
- en: Sometimes we want to create "lots" of pickups, randomly in our scene. Rather
    than doing this by hand, it is possible to add a custom menu and item to the Unity
    editor, which, when selected, will execute a script. In this recipe, we create
    a menu item that calls a script to create 100 randomly positioned star pickup
    prefabs in the Scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在场景中随机创建“大量”拾取物品。而不是手动这样做，我们可以在 Unity 编辑器中添加一个自定义菜单和项目，当选择它时，将执行一个脚本。在这个菜谱中，我们创建了一个调用脚本的菜单项，该脚本在场景中创建
    100 个随机位置的天星拾取预制件。
- en: '![An editor extension to add 100 randomly located copies of a prefab with one
    menu click](img/1362OT_12_43.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![通过一次菜单点击添加 100 个随机位置预制件的编辑器扩展](img/1362OT_12_43.jpg)'
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方假设您是从本章第一道菜谱中设置的 `Simple2Dgame_SpaceGirl` 项目开始的。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create an editor extension to add 100 randomly located copies of a prefab
    with one menu click, follow these steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个通过一次菜单点击添加 100 个随机位置预制件的编辑器扩展，请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的副本开始 mini-game `Simple2Dgame_SpaceGirl`。
- en: In the **Project** panel, create a new folder named `Prefabs`. Inside this new
    folder, create a new empty prefab named `prefab`_`star`. Populate this prefab
    by dragging GameObject `star` from the **Hierarchy** panel over `prefab`_`star`
    in the **Project** panel. The prefab should now turn blue and have a copy of all
    of GameObject star's properties and components.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 面板中，创建一个名为 `Prefabs` 的新文件夹。在这个新文件夹内，创建一个名为 `prefab`_`star` 的新空预制件。通过将
    **层次结构** 面板中的 GameObject `star` 拖动到 **项目** 面板中的 `prefab`_`star` 上来填充这个预制件。现在预制件应该变成蓝色，并包含
    GameObject star 的所有属性和组件的副本。
- en: Delete GameObject `star` from the **Hierarchy**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **层次结构** 中删除 GameObject `star`。
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `MyGreatGameEditor`, with the following
    code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目** 面板中，创建一个名为 `Editor` 的新文件夹。在这个新文件夹内，创建一个名为 `MyGreatGameEditor` 的新 C#
    脚本类，代码如下：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After 20 to 30 seconds, depending on the speed of your computer, you should
    now see a new menu appear, **My Great Game**, with a single menu item, **Make
    100 stars**. Chose this menu item and, as if by magic, you should now see 100
    new **prefab_star(Clone)** GameObjects appear in the scene!![How to do it...](img/1362OT_12_44.jpg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您电脑的速度，大约 20 到 30 秒后，您应该会看到一个新菜单出现，**我的伟大游戏**，其中有一个菜单项，**制作 100 颗星星**。选择此菜单项，就像魔法一样，您现在应该会看到
    100 个新的 **prefab_star(Clone)** GameObjects 出现在场景中！！[如何做到这一点...](img/1362OT_12_44.jpg)
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core aim of this recipe is to add a new menu, containing a single menu item
    that will execute the action we desire. C# attribute `[MenuItem("<menuName>/<menuItemName>")]`
    declares the menu name and the menu item name, and Unity will execute the static
    method that follows in the code listing, each time the menu item is selected by
    the user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的核心目的是添加一个新的菜单，其中包含一个将执行我们所需操作的菜单项。C# 属性 `[MenuItem("<menuName>/<menuItemName>")]`
    声明了菜单名称和菜单项名称，Unity 将在代码列表中执行每次用户选择菜单项时跟在后面的静态方法。
- en: In this recipe, the `[MenuItem("My-Great-Game/Make 100 stars")]` statement declares
    the menu name as `My-Great-Game` and the menu item as `Make 100 stars`. The method
    immediately following this attribute is the `PlacePrefabs()` method. When this
    method is executed, it makes the `starPrefab` variable become a reference to the
    prefab found via the `Assets/Prefabs/prefab_star.prefab` path. Then, a `for` loop
    is executed 100 times, each time calling the `CreateRandomInstance()` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，`[MenuItem("My-Great-Game/Make 100 stars")]` 语句声明了菜单名称为 `My-Great-Game`，菜单项为
    `Make 100 stars`。紧随此属性之后的方法是 `PlacePrefabs()` 方法。当此方法执行时，它使 `starPrefab` 变量成为通过
    `Assets/Prefabs/prefab_star.prefab` 路径找到的预制体的引用。然后，执行一个循环 100 次，每次调用 `CreateRandomInstance()`
    方法。
- en: The `CreateRandomInstance()` method creates a Vector3 `randomPosition` variable,
    making use of `X_MAX` and `Y_MAX` constants. The `Instantiate(...)` built-in method
    is then used to create a new GameObject in the scene, making a clone of the prefab
    and locating it at the position defined by `randomPosition`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateRandomInstance()` 方法创建一个 Vector3 `randomPosition` 变量，使用 `X_MAX` 和 `Y_MAX`
    常量。然后使用内置方法 `Instantiate(...)` 在场景中创建一个新的 GameObject，创建预制体的副本并将其定位在由 `randomPosition`
    定义的位'
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Child each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将每个新的 GameObject 子对象链接到单个父对象，以避免在 Hierarchy 中填充 100 多个新对象
- en: Rather than having hundreds of new object clones fill up our **Hierarchy** panel,
    a good way to keep things tidy is to have an empty "parent" GameObject and child
    a collection of related GameObjects to it. Let's have a GameObject in the **Hierarchy**
    named **Star-container** and child all the new stars to this object.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免让我们的 **Hierarchy** 面板充满数百个新对象克隆，一个好的方法是有一个空的 "父" GameObject，并将相关的一组 GameObjects
    作为其子对象。让我们在 **Hierarchy** 中有一个名为 **Star-container** 的 GameObject，并将所有新的星星子对象链接到这个对象。
- en: '![Child each new GameObject to a single parent, to avoid filling up the Hierarchy
    with 100s of new objects](img/1362OT_12_46.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![将每个新的 GameObject 子对象链接到单个父对象，以避免在 Hierarchy 中填充 100 多个新对象](img/1362OT_12_46.jpg)'
- en: 'We need a variable that will be a reference to our container object, `starContainerGO`.
    We also need a new method, `CreateStarContainerGO()`, which will find a reference
    to GameObject **star-container**, if such an object already exists it is deleted,
    and then the method will create a new empty GameObject and give it this name.
    Add the following variable and method to our script class:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个变量，它将是我们容器对象的引用，`starContainerGO`。我们还需要一个新的方法，`CreateStarContainerGO()`，它将找到
    GameObject **star-container** 的引用，如果已经存在这样的对象，它将被删除，然后该方法将创建一个新的空 GameObject 并给它这个名称。将以下变量和方法添加到我们的脚本类中：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Before we create the prefab clones, we need to first ensure we have created
    our star container GameObject. So we need to call our new method as the first
    thing we do when the `PlacePrefabs()` method is executed, so add a statement to
    call this method at the beginning of the `PlacePrefabs()` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建预制体克隆之前，我们首先需要确保我们已经创建了我们的星容器 GameObject。因此，我们需要在执行 `PlacePrefabs()` 方法时首先调用我们的新方法，所以请在
    `PlacePrefabs()` 方法的开始处添加一个调用此方法的语句：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to modify the `CreateRandomInstance()` method so that it gets a
    reference to the new GameObject it has just created and can then child this new
    object to our **star-container** GameObject variable `starContainerGO`. Modify
    the `CreateRandomInstance()` method so that it looks as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改 `CreateRandomInstance()` 方法，使其能够获取它刚刚创建的新 GameObject 的引用，然后可以将这个新对象作为我们的
    **star-container** GameObject 变量 `starContainerGO` 的子对象。修改 `CreateRandomInstance()`
    方法，使其看起来如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A progress bar to display proportion completed of Editor extension processing
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个进度条来显示编辑器扩展处理的完成比例
- en: If an Editor task is going to take more than half a second or so, then we should
    indicate progress complete/remaining to the user via a progress bar so that they
    understand that something is actually happening and the application has not crashed
    and frozen.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编辑器任务需要超过半秒或更长时间，那么我们应该通过进度条向用户显示进度完成/剩余情况，以便他们了解实际上正在发生某些事情，并且应用程序没有崩溃和冻结。
- en: '![A progress bar to display proportion completed of Editor extension processing](img/1362OT_12_45.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![显示编辑器扩展处理完成比例的进度条](img/1362OT_12_45.jpg)'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe adds to the previous one, so make a copy of that project folder
    and do your work for this recipe with that copy.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱在先前的菜谱基础上进行了扩展，所以请复制那个项目文件夹，并使用该副本来完成这个菜谱的工作。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To add a progress bar during the loop (and then remove it after the loop is
    complete), replace the `PlacePrefabs()` method with the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要在循环期间添加进度条（然后在循环完成后将其移除），将`PlacePrefabs()`方法替换为以下代码：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As can be seen, inside the `for` loop, we call the `EditorUtility.DisplayProgressBar(...)`
    method, passing three parameters. The first is a string title for the progress
    bar dialog window, the second is a string to show below the bar itself (usually
    a percentage is sufficient), and the final parameter is a value between 0.0 and
    1.0, indicating the percentage complete to be displayed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在`for`循环内部，我们调用`EditorUtility.DisplayProgressBar(...)`方法，传递三个参数。第一个是进度条对话框窗口的字符串标题，第二个是在条形本身下方显示的字符串（通常百分比就足够了），最后一个参数是介于0.0和1.0之间的值，表示要显示的完成百分比。
- en: Since we have loop variable `i` that is a number from 1 to 100, we can display
    this integer followed by a percentage sign for our second parameter and just divide
    this number by 100 to get the decimal value needed to specify how much of the
    progress bar should be shown as completed. If the loop were running for some other
    number, we'd just divide the loop counter by the loop total to get our decimal
    progress value. Finally, after the loop has finished, we remove the progress bar
    with statement `EditorUtility.ClearProgressBar()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个从1到100的循环变量`i`，我们可以显示这个整数，然后跟一个百分号作为第二个参数，并将这个数字除以100以得到所需的十进制值，以指定进度条应该显示多少已完成的进度。如果循环运行的是其他数字，我们只需将循环计数器除以循环总数以获得我们的十进制进度值。最后，在循环完成后，我们使用语句`EditorUtility.ClearProgressBar()`移除进度条。
- en: An editor extension to have an object-creator GameObject, with buttons to instantiate
    different pickups at cross-hair object location in scene
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个编辑器扩展，用于创建一个对象创建器GameObject，带有按钮，可以在场景中十字准星对象位置实例化不同的拾取物
- en: If a level designer wishes to place each pickup carefully "by hand", we can
    still make this easier than having to drag copies of prefabs manually from the
    **Projects** panel. In this recipe, we provide a "cross-hairs" GameObject, with
    buttons in the Inspector allowing the game designer to create instances of three
    different kinds of prefab at precise locations by clicking the appropriate button
    when the center of the cross-hairs is at the desired location.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关卡设计师希望手动“逐个”放置每个拾取物，我们仍然可以使这个过程比手动从**项目**面板拖动预制件副本更容易。在这个菜谱中，我们提供了一个“十字准星”GameObject，在检查器中有按钮，允许游戏设计师通过点击适当的按钮，当十字准星的中心位于所需位置时，在精确位置创建三种不同类型的预制件的实例。
- en: A Unity Editor extension is at the heart of this recipe and illustrates how
    such extensions can allow less technical members of a game development team to
    take an active role in level creation within the Unity Editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器扩展是这个菜谱的核心，展示了这样的扩展如何允许游戏开发团队中不太技术的人员在Unity编辑器中积极参与关卡创建。
- en: '![An editor extension to have an object-creator GameObject, with buttons to
    instantiate different pickups at cross-hair object location in scene](img/1362OT_12_47.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![一个编辑器扩展，用于创建一个对象创建器GameObject，带有按钮，可以在场景中十字准星对象位置实例化不同的拾取物](img/1362OT_12_47.jpg)'
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you are starting with the project `Simple2Dgame_SpaceGirl`
    setup from the first recipe in [Chapter 2](ch02.html "Chapter 2. Inventory GUIs"),
    *Inventory GUIs*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱假设你是从[第2章](ch02.html "第2章。库存GUI")中第一个菜谱设置的`Simple2Dgame_SpaceGirl`项目开始的，*库存GUI*。
- en: For this recipe, we have prepared the cross-hairs image you need in a folder
    named `Sprites` in the `1362_12_04` folder.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在`1362_12_04`文件夹中的`Sprites`文件夹中准备了所需的十字准星图像。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create an object-creator GameObject, follow these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象创建器GameObject，请按照以下步骤操作：
- en: Start with a new copy of mini-game `Simple2Dgame_SpaceGirl`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的迷你游戏 `Simple2Dgame_SpaceGirl` 的副本开始。
- en: In the **Project** panel, rename GameObject `star` as `pickup`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 面板中，将 GameObject `star` 重命名为 `pickup`。
- en: In the **Project** panel, create a new folder named `Prefabs`. Inside this new
    folder, create three new empty prefabs named `star, heart`, and `key`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 面板中，创建一个名为 `Prefabs` 的新文件夹。在这个新文件夹中，创建三个新的空预制件，分别命名为 `star`、`heart`
    和 `key`。
- en: Populate the `star` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `star` in the **Project** panel. The prefab should now turn blue and
    have a copy of all of the star GameObject's properties and components.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 **Hierarchy** 面板中的 GameObject `pickup` 拖动到 **Project** 面板中的 `star` 上，来填充
    `star` 预制件。现在，预制件应该变成蓝色，并复制了星形 GameObject 的所有属性和组件。
- en: Add a new tag `Heart` in the Inspector. Select GameObject `pickup` in the **Hierarchy**
    panel and assign it the tag `Heart`. Also, drag from the **Project** panel (folder
    `Sprites`) the **healthheart** image into the Sprite property of GameObject `pickup`
    so that the player sees the heart image on screen for this pickup item.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中添加一个新的标签 `Heart`。在 **Hierarchy** 面板中选择 GameObject `pickup`，并分配标签 `Heart`。此外，从
    **Project** 面板（文件夹 `Sprites`）将 **healthheart** 图像拖动到 GameObject `pickup` 的 Sprite
    属性中，以便玩家在屏幕上看到这个拾取物品的心形图像。
- en: Populate the `heart` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `heart` in the `Prefabs` folder in the **Project** panel. The prefab
    should now turn blue and have a copy of all of the pickup GameObject's properties
    and components.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 **Hierarchy** 面板中的 GameObject `pickup` 拖动到 **Project** 面板中的 `Prefabs` 文件夹下的
    `heart` 上，来填充 `heart` 预制件。现在，预制件应该变成蓝色，并复制了拾取 GameObject 的所有属性和组件。
- en: Add a new tag `Key` in the Inspector. Select GameObject's `pickup` in the **Hierarchy**
    panel and assign it this tag `Key`. Also, drag from the **Project** panel (folder
    `Sprites`) image **icon_key_green_100** into the Sprite property of GameObject's
    `pickup` so that the player sees the key image on screen for this pickup item.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中添加一个新的标签 `Key`。在 **Hierarchy** 面板中选择 GameObject 的 `pickup`，并分配这个标签 `Key`。此外，从
    **Project** 面板（文件夹 `Sprites`）将图像 **icon_key_green_100** 拖动到 GameObject 的 `pickup`
    的 Sprite 属性中，以便玩家在屏幕上看到这个拾取物品的钥匙图像。
- en: Populate the `key` prefab by dragging GameObject `pickup` from the **Hierarchy**
    panel over `key` in the `Prefabs` folder in the **Project** panel. The prefab
    should now turn blue and have a copy of all of the pickup GameObject's properties
    and components.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 **Hierarchy** 面板中的 GameObject `pickup` 拖动到 **Project** 面板中的 **Prefabs**
    文件夹下的 `key` 上，来填充 `key` 预制件。现在，预制件应该变成蓝色，并复制了拾取 GameObject 的所有属性和组件。
- en: Delete GameObject's `pickup` from the **Hierarchy**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 中删除 GameObject 的 `pickup`。
- en: 'In the **Project** panel, create a new folder named `Editor`. Inside this new
    folder, create a new C# script class named `ObjectBuilderEditor`, with the following
    code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Project** 面板中，创建一个名为 `Editor` 的新文件夹。在这个新文件夹中，创建一个名为 `ObjectBuilderEditor`
    的新 C# 脚本类，代码如下：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our Editor script is expecting to find the three icons in a folder named `EditorSprites`,
    so let's do this. First create a new folder named `EditorSprites`. Next drag the
    three 32 x 32 pixel icons from the `Sprites` folder into this new `EditorSprites`
    folder. Our Editor script should now be able to load these icons for image-based
    buttons that it will be drawing in the Inspector, from which the user chooses
    which pickup prefab object to clone into the scene.![How to do it...](img/1362OT_12_56.jpg)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的编辑器脚本期望在名为 `EditorSprites` 的文件夹中找到三个图标，所以让我们这样做。首先创建一个名为 `EditorSprites`
    的新文件夹。接下来，将三个 32 x 32 像素的图标从 `Sprites` 文件夹拖动到这个新的 `EditorSprites` 文件夹中。现在，我们的编辑器脚本应该能够加载这些图标，用于在检查器中绘制的基于图像的按钮，用户可以通过这些按钮选择要克隆到场景中的拾取预制对象。![如何操作...](img/1362OT_12_56.jpg)
- en: From the **Project** panel, drag sprite **cross_hairs.fw** into the **Scene**.
    Rename this gameObject `object-creator-cross-hairs,` and in its **Sprite Renderer**
    component in the **Inspector,** set **Sorting Layer** to **Foreground**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Project** 面板中，将精灵 **cross_hairs.fw** 拖动到 **Scene** 中。将这个 gameObject 重命名为
    `object-creator-cross-hairs`，并在 **Inspector** 中的其 **Sprite Renderer** 组件中，将 **Sorting
    Layer** 设置为 **Foreground**。
- en: 'Attach the following C# script to GameObject `object-creator-cross-hairs`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本附加到 GameObject `object-creator-cross-hairs` 上：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Select the **Rect Tool** (shortcut key *T*), and as you drag gameObject `object-creator-cross-hairs`
    and click on the desired icon in the **Inspector**, new pickup GameObjects will
    be added to the scene's **Hierarchy**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Rect Tool**（快捷键 *T*），当你拖动 gameObject `object-creator-cross-hairs` 并在 **Inspector**
    中点击所需的图标时，新的拾取 GameObject 将被添加到场景的 **Hierarchy** 中。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The script class `ObjectBuilderScript` has just two methods, one of which has
    just one statement—the `Awake()` method simply makes this GameObject become inactive
    when the game is running (since we don't want the user to see our cross-hairs
    created tool during gameplay). The `AddObjectToScene(…)` method receives a reference
    to a prefab as a parameter and instantiates a new clone of the prefab in the scene
    at the location of GameObject `object-creator-cross-hairs` at that point in time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类`ObjectBuilderScript`只有两个方法，其中一个方法只有一个语句——`Awake()`方法简单地将这个GameObject在游戏运行时变为非活动状态（因为我们不希望用户在游戏过程中看到我们创建的工具十字准星）。`AddObjectToScene(…)`方法接收一个预制体的引用作为参数，并在该时刻在GameObject
    `object-creator-cross-hairs`的位置在场景中实例化预制体的新克隆。
- en: Script class `ObjectBuilderEditor` has a C# attribute `[CustomEditor(typeof(ObjectBuilderScript))]`
    immediately before the class is declared, telling Unity to use this class to control
    how `ObjectBuilderScript` GameObject properties and components are shown to the
    user in the **Inspector**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本类`ObjectBuilderEditor`在类声明之前立即有一个C#属性`[CustomEditor(typeof(ObjectBuilderScript))]`，告诉Unity使用这个类来控制`ObjectBuilderScript`
    GameObject的属性和组件在**检查器**中如何显示给用户。
- en: There are six variables, three textures for the icons to form the buttons in
    the Inspector, and three GameObject references to the prefabs of which instances
    will be created. The `OnEnable()` method assigns values to these six variables
    using the built-in method `Resources.LoadAssetAtPath()`, retrieving the icons
    from the **Project** folder `EditorSprites` and getting references to the prefabs
    in the **Project** folder `Prefabs`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有六个变量，三个用于在检查器中形成按钮的图标纹理，以及三个GameObject引用，这些引用将创建实例的预制体。`OnEnable()`方法使用内置方法`Resources.LoadAssetAtPath()`将这些六个变量赋值，从**项目**文件夹`EditorSprites`中检索图标，并从**项目**文件夹`Prefabs`中获取预制体的引用。
- en: The `OnInspectorGUI()` method has a variable `myScript`, which is set to be
    a reference to the instance of scripted component `ObjectBuilderScript` in GameObject
    `object-creator-cross-hairs` (so we can call its method when a prefab has been
    chosen). The method then displays a mixture of empty text `Labels` (to get some
    vertical spacing) and `FlexibleSpace` (to get some horizontal spacing and centering)
    and displays three buttons to the user, with icons of star, heart, and key. The
    scripted GUI technique for Unity custom **Inspector** GUIs wraps an `if` statement
    around each button, and on the frame the user clicks the button, the statement
    block of the `if` statement will be executed. When any of the three buttons is
    clicked, a call is made to `AddObjectToScene(…)` of scripted component `ObjectBuilderScript`,
    passing the prefab corresponding to the button that was clicked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnInspectorGUI()`方法有一个变量`myScript`，它被设置为指向GameObject `object-creator-cross-hairs`中脚本组件`ObjectBuilderScript`的实例（这样我们就可以在选择了预制体时调用其方法）。然后，该方法显示了一些空文本`Labels`（为了获得一些垂直间距）和`FlexibleSpace`（为了获得一些水平间距和居中对齐），并向用户显示三个带有星星、心形和钥匙图标的按钮。Unity自定义**检查器**GUI的脚本GUI技术将一个`if`语句包裹在每个按钮周围，当用户点击按钮时，`if`语句的代码块将被执行。当点击任意一个按钮时，都会调用脚本组件`ObjectBuilderScript`的`AddObjectToScene(…)`方法，传递与被点击按钮对应的预制体。'
- en: Conclusion
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we introduced recipes demonstrating some Unity Editor extension
    scripts, illustrating how we can make things easier, less script based, and less
    prone to errors, by limiting and controlling the properties of objects and how
    they are selected or changed via the **Inspector**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了展示一些Unity编辑器扩展脚本的食谱，说明了我们如何通过限制和控制对象的属性以及它们如何通过**检查器**被选择或更改，使事情变得更简单、更少依赖于脚本，并减少出错的可能性。
- en: 'The concept of serialization was raised in the Editor extension recipes, whereby
    we need to remember that when we are editing item properties in the Inspector,
    each change needs to be saved to disk so that the updated property is correct
    when we next use or edit that item. This is achieved in the `OnInspectorGUI()`
    method by first calling the `serializedObject.Update()` method, and after all
    changes have been made in the Inspector, finally calling the `serializedObject.ApplyModifiedProperties()`
    method. Some sources for more information and examples about custom Editor extensions
    include:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器扩展食谱中提出了序列化的概念，我们需要记住，当我们正在检查器中编辑项目属性时，每次更改都需要保存到磁盘，以确保下次使用或编辑该项目时更新的属性是正确的。这是通过在`OnInspectorGUI()`方法中首先调用`serializedObject.Update()`方法，然后在检查器中完成所有更改后，最终调用`serializedObject.ApplyModifiedProperties()`方法来实现的。有关更多信息和示例，以下是一些自定义编辑器扩展的资源：
- en: For more about custom Unity Editors in Ryan Meier's blog, refer to [http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Ryan Meier博客中自定义Unity编辑器的信息，请参阅[http://www.ryan-meier.com/blog/?p=72](http://www.ryan-meier.com/blog/?p=72)
- en: For more custom Unity Editor scripts/tutorials, including grids and color pickers,
    refer to [http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多自定义Unity编辑器脚本/教程，包括网格和颜色选择器，请参阅[http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047](http://code.tutsplus.com/tutorials/how-to-add-your-own-tools-to-unitys-editor--active-10047)
