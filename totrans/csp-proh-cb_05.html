<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Create Microservices on Azure Service Fabric</h1></div></div></div><p>This chapter deals with the exciting world of microservices and <strong>Azure Service Fabric</strong>. In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Downloading and installing Service Fabric</li><li class="listitem" style="list-style-type: disc">Creating a Service Fabric application with a stateless actor service</li><li class="listitem" style="list-style-type: disc">Using Service Fabric Explorer</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Introduction</h1></div></div></div><p>Traditionally, developers wrote applications in a monolithic manner. This means one single executable that is broken up into components via classes and so on. Monolithic applications require a great deal of testing, and deployment is tedious due to the bulkiness of the monolithic application. Even though you might have multiple developer teams, they all need to have a solid understanding of the application as a whole.</p><p>Microservices is a<a class="indexterm" id="id303"/> technology that aims to address the issues surrounding monolithic applications and the traditional way of developing applications. With microservices, you can break the application into smaller bits (services) that can function on their own without being dependent on any of the other services. These smaller services can be stateless or stateful and are also smaller in scale in terms of functionality, making them easier to develop, test, and deploy. You can also version each microservice independently from the others. If one microservice is receiving more load than the others, you can scale only that service up to meet the demands placed on it. With monolithic applications, you would have to try and scale the whole application up in order to meet the demands for a single component within the application.</p><p>Take, for example, the workings of a popular online web store. It could consist of a shopping cart, shopper profile, order management, backend login, inventory management, billing, returns, and much more. Traditionally, a single web application is created to provide all these services. With microservices, you can isolate each service as a standalone, self-contained bit of functionality and code base. You can also dedicate a team of developers to work on a single portion of the web store. If this team is responsible for the inventory-management microservice, they would handle every aspect of it. This, for example, means everything from writing code and enhancing functionality, to testing and deployment.</p><p>Another excellent side<a class="indexterm" id="id304"/> effect of microservices is that it allows you to easily isolate any faults you might come across. Finally, you can also create microservices in any technology you want (C#, Java, VB.NET), as they are language independent.</p><p>Azure Service Fabric allows you to scale your microservices easily and increases application availability because it implements failover. When microservices are used with Fabric, microservices<a class="indexterm" id="id305"/> become a very powerful technology. Think of Azure Service Fabric as a <strong>Platform as a Service</strong> (<strong>PaaS</strong>) solution, on top of which your microservices sit. We call the collection that the microservices live on a Service Fabric cluster. Each microservice lives on a virtual machine, which is referred to as a node in the Service Fabric cluster. This Service Fabric cluster can live in the cloud or on a local machine. If a node becomes unavailable for any reason, the Service Fabric cluster will automatically redistribute the microservices to the other nodes so that the application remains available.</p><p>Finally, here is a word on the differences between stateful and stateless microservices. You are able to create a microservice as stateless or stateful. When a microservice relies on an external data store to persist data, it is stateless in nature. This simply means that the microservice does not maintain its state internally. A stateful microservice, on the other hand, maintains its own state by storing it locally on the server it resides on.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Downloading and installing Service Fabric</h1></div></div></div><p>You will have to install <a class="indexterm" id="id306"/>and set up a local Service Fabric cluster on your PC before you can <a class="indexterm" id="id307"/>create and test Service Fabric applications.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec87"/>Getting ready</h2></div></div></div><p>We will download and install the <a class="indexterm" id="id308"/>
<strong>software development kit</strong> (<strong>SDK</strong>) from the Azure site. This will allow us to create a local Service Fabric cluster on your local development machine.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec88"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">From the Microsoft Azure site, download the SDK and access other resources, such as <a class="indexterm" id="id309"/>documentation, via the Service Fabric learning path, from <a class="ulink" href="https://azure.microsoft.com/en-us/documentation/learning-paths/service-fabric/">https://azure.microsoft.com/en-us/documentation/learning-paths/service-fabric/</a>:<div><img alt="How to do it…" src="img/B05391_05_01.jpg"/></div></li><li class="listitem">You <a class="indexterm" id="id310"/>will need to<a class="indexterm" id="id311"/> accept the license terms before the installation begins:<div><img alt="How to do it…" src="img/B05391_05_02.jpg"/></div></li><li class="listitem">The web <a class="indexterm" id="id312"/>platform installer then starts downloading the<a class="indexterm" id="id313"/> Microsoft Azure Service Fabric runtime. Allow this process to complete:<div><img alt="How to do it…" src="img/B05391_05_03.jpg"/></div></li><li class="listitem">After the <a class="indexterm" id="id314"/>download has completed, the install process <a class="indexterm" id="id315"/>will begin:<div><img alt="How to do it…" src="img/B05391_05_04.jpg"/></div></li><li class="listitem">When the installation has <a class="indexterm" id="id316"/>completed, the following products would<a class="indexterm" id="id317"/> have been installed, which is also evident in the following screenshot:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Microsoft Azure Service Fabric Runtime</li><li class="listitem" style="list-style-type: disc">Microsoft Azure Service Fabric Core SDK Preview</li><li class="listitem" style="list-style-type: disc">Microsoft Azure Service Fabric Visual Studio 2015 Tools Preview</li><li class="listitem" style="list-style-type: disc">Microsoft Azure Service Fabric SDK Preview</li></ul></div><div><img alt="How to do it…" src="img/B05391_05_05.jpg"/></div></li><li class="listitem">The next task is to<a class="indexterm" id="id318"/> open PowerShell as the administrator. In the<a class="indexterm" id="id319"/> Windows 10 Start menu, type the word <code class="literal">PowerShell</code>, and the search will immediately return the desktop application as a result. Right-click on the desktop application and select <strong>Run as administrator</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_05_06.jpg"/></div></li><li class="listitem">Once Windows PowerShell has opened up, run the <code class="literal">Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Scope CurrentUser</code> command. The<a class="indexterm" id="id320"/> reason for this is that Service Fabric uses PowerShell<a class="indexterm" id="id321"/> scripts for the creation of the local development cluster. It is also used for the deployment of Visual Studio developed apps. Running this command prevents Windows from blocking those scripts:<div><img alt="How to do it…" src="img/B05391_05_07.jpg"/></div></li><li class="listitem">Next, create the local Service Fabric cluster. Enter the <code class="literal">&amp; "$ENV:ProgramFiles\Microsoft SDKs\Service Fabric\ClusterSetup\DevClusterSetup.ps1"</code> command.<p>This will create the local cluster needed to host Service Fabric applications:</p><div><img alt="How to do it…" src="img/B05391_05_08.jpg"/></div></li><li class="listitem">After the cluster is created, PowerShell will start the service:<div><img alt="How to do it…" src="img/B05391_05_09.jpg"/></div></li><li class="listitem">The process<a class="indexterm" id="id322"/> might take several minutes. Be sure to let it <a class="indexterm" id="id323"/>complete:<div><img alt="How to do it…" src="img/B05391_05_10.jpg"/></div></li><li class="listitem">Once the naming service is ready, you can close PowerShell:<div><img alt="How to do it…" src="img/B05391_05_11.jpg"/></div></li><li class="listitem">To view the<a class="indexterm" id="id324"/> created cluster, you can navigate to <code class="literal">http://localhost:19080/Explorer</code> on your local machine.<p>This will give you a <a class="indexterm" id="id325"/>snapshot of the cluster's health and state. It will also show any applications running in the cluster:</p><div><img alt="How to do it…" src="img/B05391_05_12.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec89"/>How it works…</h2></div></div></div><p>As you can see, the<a class="indexterm" id="id326"/> Service Fabric cluster is essential for creating and running<a class="indexterm" id="id327"/> applications created in Visual Studio. This will allow us to test applications directly on your local machine before publishing them to the cloud.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Creating a Service Fabric application with a stateless actor service</h1></div></div></div><p>As part of the<a class="indexterm" id="id328"/> introduction to this chapter, we looked <a class="indexterm" id="id329"/>at the difference between stateful and stateless microservices. The <a class="indexterm" id="id330"/>Service Fabric application templates available are then further divided into <strong>Reliable Services</strong> (stateful/stateless) and <strong>Reliable Actors</strong> (stateful/stateless). When to use which one is something that will depend on the specific business requirement of your <a class="indexterm" id="id331"/>application.</p><p>To put it simply though, if you wanted to create a service that should be exposed to many users of your application at any one time, a Reliable Service would probably be a good fit. Think of a service exposing the latest exchange rates that can be consumed by many users or applications at once.</p><p>Again, looking back to the introduction of this chapter, we used the example of an online web store with a shopping cart. A Reliable Actor could be a good fit for every customer buying items, so you could have a shopping cart actor. The<a class="indexterm" id="id332"/> Reliable Actor as <a class="indexterm" id="id333"/>part of the Service Fabric framework is based on the Virtual Actor pattern. Have a look at the article on the <a class="indexterm" id="id334"/>Virtual Actor pattern at <a class="ulink" href="http://research.microsoft.com/en-us/projects/orleans/">http://research.microsoft.com/en-us/projects/orleans/</a>.</p><p>To show you how easy it is to create a microservice using a stateless actor service as an example, we will use Visual Studio to publish a service to the Service Fabric cluster and call that service from a console (client) application.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec90"/>Getting ready</h2></div></div></div><p>To complete this recipe, you must ensure that you have installed your local Service Fabric cluster on your local machine.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec91"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">In Visual Studio, create a new project by going to <strong>File</strong> | <strong>New</strong> | <strong>Project</strong>:<div><img alt="How to do it…" src="img/B05391_05_13.jpg"/></div></li><li class="listitem">From the <strong>Visual C#</strong> node, expand the nodes until you see the <strong>Cloud</strong> node. When you click on it, you<a class="indexterm" id="id335"/> will see<a class="indexterm" id="id336"/> that Visual Studio now lists a new <strong>Service Fabric Application</strong> template. Select the <strong>Service Fabric Application</strong> template, call it <code class="literal">sfApp</code>, and click on <strong>OK</strong>:<div><img alt="How to do it…" src="img/B05391_05_14.jpg"/></div></li><li class="listitem">Next, select <a class="indexterm" id="id337"/><strong>Stateless Reliable </strong><a class="indexterm" id="id338"/><strong>Actor</strong> from the <strong>Create a Service</strong> window that pops up. We just called ours <code class="literal">UtilitiesActor</code>:<div><img alt="How to do it…" src="img/B05391_05_15.jpg"/></div></li><li class="listitem">Once your solution is <a class="indexterm" id="id339"/>created, you will <a class="indexterm" id="id340"/>notice that it consists of three projects. These are:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sfApp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UtilitiesActor</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">UtilitiesActor.Interfaces</code></li></ul></div><div><img alt="How to do it…" src="img/B05391_05_22.jpg"/></div></li><li class="listitem">We will start <a class="indexterm" id="id341"/>off by modifying the <code class="literal">IUtilitiesActor</code> interface. This interface will simply require that <code class="literal">UtilitiesActor</code> implements a method called <code class="literal">ValidateEmailAsync</code> that takes<a class="indexterm" id="id342"/> an e-mail address as a parameter and returns a Boolean value indicating whether it is a valid email address or not:<div><pre class="programlisting">namespace UtilitiesActor.Interfaces
{
    public interface IUtilitiesActor : IActor
    {
        Task&lt;bool&gt; ValidateEmailAsync(string emailToValidate);
    }
}</pre></div></li><li class="listitem">Next, open up your <code class="literal">UtilitiesActor</code> project and view the class. It will be underlined<a class="indexterm" id="id343"/> with a red squiggly line because it does not implement the interface member <code class="literal">ValidateEmailAsync()</code>:<div><img alt="How to do it…" src="img/B05391_05_16.jpg"/></div></li><li class="listitem">Using <em>Ctrl</em> + <em>.</em> (period), implement<a class="indexterm" id="id344"/> the interface. Remove all the other unnecessary default code (if any):<div><img alt="How to do it…" src="img/B05391_05_17.jpg"/></div></li><li class="listitem">The implemented interface code inserted for you should look like this. At the moment, it only contains <code class="literal">NotImplementedException</code>. It is here that we will implement the code to validate the e-mail address:<div><pre class="programlisting">namespace UtilitiesActor
{
    internal class UtilitiesActor : StatelessActor, IUtilitiesActor
    {
        public Task&lt;bool&gt; ValidateEmailAsync(string emailToValidate)
        {
            throw new NotImplementedException();
        }        
    }
}</pre></div></li><li class="listitem">We will use a regular expression to validate the e-mail address passed to this method via the <a class="indexterm" id="id345"/>parameter. Regular expressions are very powerful. I have, however, in all my years of programming, never written my own expression. These are readily available on the Internet, and you can create a utilities class (or extension methods class) for<a class="indexterm" id="id346"/> your own projects to reuse. You can make use of regular expressions and other code that is often used.<p>Finally, you will notice the <code class="literal">ActorEventSource</code> code. This is simply just to create <a class="indexterm" id="id347"/>
<strong>Event Tracing for Windows</strong> (<strong>ETW</strong>) events that will help you see what is happening in your application from the diagnostic events window in Visual Studio. To open the diagnostic events window, go to <strong>View</strong>, <strong>Other Windows</strong> and click on <strong>Diagnostic Events Viewer</strong>:</p><div><pre class="programlisting">internal class UtilitiesActor : StatelessActor, IUtilitiesActor
{
    public async Task&lt;bool&gt; ValidateEmailAsync(string emailToValidate)
    {
        ActorEventSource.Current.ActorMessage(this, "Email Validation");

        return await Task.FromResult(Regex.IsMatch(emailToValidate, @"\A(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\.[a-z0- 9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9- ]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0- 9])?)\Z", RegexOptions.IgnoreCase));
    }        
}</pre></div></li><li class="listitem">Be sure to add a reference to the <code class="literal">System.Text.RegularExpressions</code> namespace. Without it, you will not be able to use the regular expressions. If you added the regular expression in your code without adding the reference, Visual Studio will display a red squiggly line under the <code class="literal">Regex</code> method:<div><img alt="How to do it…" src="img/B05391_05_18.jpg"/></div></li><li class="listitem">Using <em>Ctrl</em> + <em>.</em> (period), add the <code class="literal">using</code> statement to your project. This will bring the regular <a class="indexterm" id="id348"/>expression namespace into scope:<div><img alt="How to do it…" src="img/B05391_05_19.jpg"/></div></li><li class="listitem">Now that we have created the interface and also added the implementation of that interface, it is time to <a class="indexterm" id="id349"/>add a client application that we will use for testing. Right-click on your solution and add a new project:<div><img alt="How to do it…" src="img/B05391_05_20.jpg"/></div></li><li class="listitem">The easiest <a class="indexterm" id="id350"/>way is to add a simple<a class="indexterm" id="id351"/> console application. Call your client application <code class="literal">sfApp.Client</code> and click on the <strong>OK</strong> button:<div><img alt="How to do it…" src="img/B05391_05_21.jpg"/></div></li><li class="listitem">After you<a class="indexterm" id="id352"/> have added your <a class="indexterm" id="id353"/>console application to your solution, your solution should look like this:<div><img alt="How to do it…" src="img/B05391_05_23.jpg"/></div></li><li class="listitem">You will now<a class="indexterm" id="id354"/> need to add<a class="indexterm" id="id355"/> references to your client application. Right-click the <strong>References</strong> node in your <code class="literal">sfApp.Client</code> project and select <strong>Add Reference</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_05_24.jpg"/></div></li><li class="listitem">Start off by <a class="indexterm" id="id356"/>adding a<a class="indexterm" id="id357"/> reference to the <code class="literal">UtilitiesActor.Interfaces</code> project:<div><img alt="How to do it…" src="img/B05391_05_25.jpg"/></div></li><li class="listitem">You will also need to add<a class="indexterm" id="id358"/> references to several Service Fabric <strong>dynamic link libraries</strong> (<strong>DLLs</strong>). When you created your Service Fabric application, it should have added a<a class="indexterm" id="id359"/> folder <a class="indexterm" id="id360"/>called <code class="literal">packages</code> to your project folder structure. Browse to this folder and add your Service Fabric DLLs from there. After you have added the required DLLs, your project should look like this:<div><img alt="How to do it…" src="img/B05391_05_29.jpg"/></div></li><li class="listitem">In the <code class="literal">Program.cs</code> file of your console application, you need to add the following code to<a class="indexterm" id="id361"/> the <code class="literal">Main</code> <a class="indexterm" id="id362"/>method:<div><pre class="programlisting">namespace sfApp.Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var actProxy = ActorProxy.Create&lt;IUtilitiesActor&gt; (ActorId.NewId(), "fabric:/sfApp");

            WriteLine("Utilities Actor {0} - Valid Email?: {1}", actProxy.GetActorId(), actProxy.ValidateEmailAsync ("validemail@gmail.com").Result);
            WriteLine("Utilities Actor {0} - Valid Email?: {1}", actProxy.GetActorId(), actProxy.ValidateEmailAsync ("invalid@email@gmail.com").Result);
            ReadLine();
        }
    }
}</pre></div><p>All we are doing is creating<a class="indexterm" id="id363"/> a proxy for our actor and writing the output of the e-mail validation to the console window. Your client application is now ready.</p></li><li class="listitem">Before we can run the <a class="indexterm" id="id364"/>client application, however, we need to publish our service first. In <strong>Solution Explorer</strong>, right-click on the <code class="literal">sfApp</code> service and click on <strong>Publish</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_05_26.jpg"/></div></li><li class="listitem">The <strong>Publish </strong><a class="indexterm" id="id365"/><strong>Service Fabric Application</strong><a class="indexterm" id="id366"/> window will now be displayed. Click on the <strong>Select…</strong> button next to the <strong>Connection endpoint</strong> text box:<div><img alt="How to do it…" src="img/B05391_05_27.jpg"/></div></li><li class="listitem">Select <strong>Local Cluster</strong> as your <strong>Connection endpoint</strong> and click on <strong>OK</strong>:<div><img alt="How to do it…" src="img/B05391_05_28.jpg"/></div></li><li class="listitem">Change <strong>Target profile</strong> <a class="indexterm" id="id367"/>and <strong>Application</strong><a class="indexterm" id="id368"/><strong> Parameters File</strong> to <code class="literal">Local.xml</code>. When you are done, click on the <strong>Publish</strong> button:<div><img alt="How to do it…" src="img/B05391_05_30.jpg"/></div></li><li class="listitem">If you <a class="indexterm" id="id369"/>navigate to <code class="literal">http://localhost:19080/Explorer</code>, you will notice that the service you created has been<a class="indexterm" id="id370"/> published to your local Service Fabric cluster:<div><img alt="How to do it…" src="img/B05391_05_31.jpg"/></div></li><li class="listitem">You are now<a class="indexterm" id="id371"/> ready to run your<a class="indexterm" id="id372"/> client application. Right-click on the <code class="literal">sfApp.Client</code> project, and select <strong>Debug</strong> and <strong>Start new instance</strong> from the context menu:<div><img alt="How to do it…" src="img/B05391_05_32.jpg"/></div></li><li class="listitem">The console application <a class="indexterm" id="id373"/>calls the validate method to check the e-mail addresses, and displays the results to the console window. The results are as expected:<div><img alt="How to do it…" src="img/B05391_05_33.jpg"/></div></li><li class="listitem">We can, however, be more specific when creating the actor ID. We can give it a specific<a class="indexterm" id="id374"/> name. Modify your proxy code and create a new <code class="literal">ActorId</code> method, and give it any string value:<div><pre class="programlisting">var actProxy = ActorProxy.Create&lt;IUtilitiesActor&gt;(new ActorId("Utilities"), "fabric:/sfApp");

WriteLine("Utilities Actor {0} - Valid Email?: {1}", actProxy.GetActorId(), actProxy.ValidateEmailAsync("validemail@gmail.com").Result) ;
WriteLine("Utilities Actor {0} - Valid Email?: {1}", actProxy.GetActorId(), actProxy.ValidateEmailAsync("invalid@email@gmail.com").Resu lt);
ReadLine();</pre></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>The <code class="literal">ActorId</code> method can take a parameter of type <code class="literal">Guid</code>, <code class="literal">long</code> or <code class="literal">string</code>.</p></div></div></li><li class="listitem">When you debug your client application again, you will notice that <code class="literal">Utilities Actor</code> now has a logical name (the same name you passed as a string value when creating a new <code class="literal">ActorId</code> method):<div><img alt="How to do it…" src="img/B05391_05_34.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec92"/>How it works…</h2></div></div></div><p>Creating your Service <a class="indexterm" id="id375"/>Fabric application and publishing it locally is a perfect solution for testing your application before publishing it to the cloud. Creating small independent microservices allows developers many benefits<a class="indexterm" id="id376"/> related to testing, debugging, and deploying efficient and robust code that your applications can leverage to ensure maximum availability.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Using Service Fabric Explorer</h1></div></div></div><p>There is another tool that<a class="indexterm" id="id377"/> you can use to visualize the Service Fabric cluster. It is a standalone tool that you can find by navigating to the local installation path at <code class="literal">%Program Files%\Microsoft SDKs\Service Fabric\Tools\ServiceFabricExplorer</code> and clicking on <code class="literal">ServiceFabricExplorer.exe</code>. When you run the application, it will automatically connect to your local Service Fabric cluster. It can display rich information regarding the applications on the cluster, the cluster nodes, the heath status of the applications and nodes, and any load on the applications in the cluster.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec93"/>Getting ready</h2></div></div></div><p>You must have already<a class="indexterm" id="id378"/> completed the installation of Service Fabric on your local machine for the Service Fabric Explorer to work. If you have not done so yet, follow the <em>Downloading and installing Service Fabric</em> recipe in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec94"/>How to do it…</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">When you start the Service Fabric Explorer, the following window will appear:<div><img alt="How to do it…" src="img/B05391_05_35.jpg"/></div></li><li class="listitem">Note that the tree view to the left displays <strong>Application View</strong> and <strong>Node View</strong>:<div><img alt="How to do it…" src="img/B05391_05_36.jpg"/></div></li><li class="listitem">The pane on the<a class="indexterm" id="id379"/> right-hand side will display information regarding the local cluster. This makes it easy for you to see the overall health of the local Service cluster:<div><img alt="How to do it…" src="img/B05391_05_37.jpg"/></div></li><li class="listitem">When you expand <a class="indexterm" id="id380"/><strong>Application View</strong>, you will notice that our <code class="literal">sfApp</code> service has been published. Expanding it even further, you will see that the <code class="literal">sfApp</code> service has been published on <strong>Node.2</strong>. Expand <strong>Node View</strong> and <strong>Node.2</strong> to see the service active on that node:<div><img alt="How to do it…" src="img/B05391_05_38.jpg"/></div></li><li class="listitem">To illustrate the scalability of microservices, right-click on <strong>Node.2</strong>, and from the context menu, stop the node. Then, click on the Refresh button at the top of the window to refresh the nodes and applications.</li><li class="listitem">If you now<a class="indexterm" id="id381"/> had to go ahead and expand <strong>Application View</strong>, and looked at the service again, you will notice that the Service Fabric cluster noticed that <strong>Node.2</strong> was down. It then automatically pushed the service on to a new, healthy node (in this case, <strong>Node.5</strong>):<div><img alt="How to do it…" src="img/B05391_05_40.jpg"/></div></li><li class="listitem">The local cluster <a class="indexterm" id="id382"/>nodes view in the right panel of the Service Fabric Explorer also reports that <strong>Node.2</strong> is down:<div><img alt="How to do it…" src="img/B05391_05_41.jpg"/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec95"/>How it works…</h2></div></div></div><p>The Service Fabric Explorer will allow you to see information on the selected node, and you will be able to drill<a class="indexterm" id="id383"/> down and see a rich amount of information regarding the Service Fabric cluster applications.</p></div></div></body></html>