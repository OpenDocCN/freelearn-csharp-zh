- en: '*Chapter 13*: Distributed Systems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about distributed applications and how you can
    improve their performance. You will understand how to build performant applications
    using the **Command Query Responsibility Separation** (**CQRS**) software design
    pattern, event sourcing, and microservices. You will learn how to use cloud providers
    such as Microsoft Azure to build scalable distributed solutions using Cosmos DB,
    Azure Functions, and the open source Pulumi infrastructure tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementing the CQRS design pattern**: In this section, we will implement
    the CQRS design pattern with a sample project that demonstrates the separation
    of commands and queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing event sourcing**: Many resources always show event sourcing
    with CQRS. But in this section, we will write a sample project that demonstrates
    pure event sourcing without CQRS. By doing this, you will know how to implement
    CQRS and event sourcing individually and be able to combine them to work together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Microsoft Azure for distributed systems**: In this section, we will
    provide a high-level overview of Azure Functions – specifically Durable Azure
    Functions – for providing robust, secure, and scalable serverless code that performs
    well in a distributed environment. We will also look at the difference between
    containers and serverless, and when to use one over the other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managing your cloud infrastructure with Pulumi**: Managing Azure resources
    can become unwieldy, especially when the number of microservices you deploy increases.
    So, in this section, we will look at how Pulumi allows you to manage your cloud
    infrastructure and resources using pure C# that you can include in your build,
    test, and deploy pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By completing this chapter, you will gain the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to separate commands and queries into different services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to persist state changes as sequences of state-changing events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to understand the difference between containers and serverless,
    and you will be able to know when to use one over the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will understand the different types of Durable Azure Function types and
    design patterns so that you can use them to build serverless functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to manage your cloud using Pulumi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll need the following components to follow along with this chapter and
    perform the necessary programming tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This book’s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: A Microsoft Azure account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: A Pulumi subscription'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the CQRS design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the **Command Query Responsibility Separation**
    (**CQRS**) design pattern. In simple terms, a command is a method that performs
    an action, while a query is a method that returns data. Commands do not perform
    queries, and queries do not perform commands. Commands can have separate models
    for queries. Now, let’s write a simple console application that demonstrates how
    easy it is to implement this pattern, which is used extensively in microservice
    development:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new console application called `CH13_CQRSPattern`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new class called `CQRSBasedClass`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `SleepCommand` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `SleepCommand` method is an example of a command. It takes in a parameter
    that is several milliseconds in length. A command is then executed that causes
    the current thread to sleep for the number of milliseconds specified by the caller.
    This particular command does not return a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DateTimeQuery` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `DateTimeQuery` method is an example of a query. It is a parameterless query,
    although queries can have parameters. The query does not perform any commands.
    It simply returns the current date and time to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Program` class, add the `ExecuteCommand` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ExecuteCommand` method executes `SleepCommand` in our `CQRSBasedClass`,
    which causes the current thread to sleep for 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ExecuteQuery` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ExecuteQuery` method executes `DateTimeQuery` in our `CQRSBasedClass`,
    which queries the current date and time and returns the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Program.cs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start our program by writing a message to the console. Then, we call `ExecuteCommand`.
    Finally, we write a message to the console that includes the current date and
    time that is returned by the call to `ExecuteQuery`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in its most basic form, the CQRS pattern is really simple. A
    command performs an action and nothing else, while a query performs a query and
    nothing else. We can shift commands into their own command class so that the only
    purpose of the class is to execute commands. We can do the same with queries by
    placing them in their own query class so that all the query class does is returns
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: If you study this book’s source code, you will see that we have done this. We
    have a `CommandClass` with a command called `Sleep`. We also have a `QueryClass`
    with a query called `Now`. CQRS is the enabling pattern that’s used in microservice
    development. It is often used in conjunction with message brokers, message buses,
    message sending and receiving, domain modeling, domain events, event sourcing,
    eventual consistency, separate read and write models, and **domain-driven design**
    (**DDD**). This is where people tend to become lost. But even though the CQRS
    pattern is used alongside all these, the pattern itself is very simple, and it
    enables these other patterns and technologies to gel nicely together.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of database operations, you can think of the `add`, `edit`, `delete`,
    and `update` operations as commands, and you can think of `select` operations
    as queries.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a simple understanding of the CQRS pattern, in the next section,
    we will turn our attention to understanding and implementing event sourcing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing event sourcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you consider documents in a document store and records in a database, these
    are normally a business’s point of truth. Their state is the source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing record events become your source of truth rather than the state
    of data in tables, or the state of documents in document stores.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of using the state as a point of truth, we can use recorded events
    as a source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: In the old days of programming, this was known as an audit trail. I remember
    working on a database several years ago. It had an audit table. In that table,
    there was a record of all the actions that were carried out on the database and
    by whom. We could tell when data operations took place, what those data operations
    were, and who or what process was carried out those data operations. Then, if
    anything went wrong with the database, we could analyze that table and know which
    operation caused the resulting problems. To store this information, we would use
    database triggers that fired on every `add`, `update`, `delete`, and `read` operation.
    These triggers were events that fired upon a data operation that recorded what
    data modifications had taken place, who made those modifications, why they made
    the changes, and at what date and time those modifications took place.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at event sourcing, which records events that become
    your source of truth. Events allow you to understand how you arrived at a particular
    state at a particular point in time.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to understand the benefits of event sourcing is to have a look at
    your bank statement. When you receive your bank statement, you start with the
    balance that was carried over from the previous month. Then, you see a list of
    transactions that took place during the period covered by the statement, which
    consists of money entering your account and money leaving your account. Each of
    these transactions is an event. These events can be money transfer in, money transfer
    out, direct debit payment, interest payment, standing order payment, bank charge
    payment, payment of goods, salary/wages being paid in, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: When you consider this scenario, your bank statement shows how you came to have
    the money come in and leave your account. But from a database point of view, just
    by looking at the data, this is not so easy. When you look at the data, you usually
    have to write a query that joins multiple tables in a relational database together
    to reveal the facts of how the state of your account changed. But you don’t necessarily
    know the context that led to those changes being made.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the same scenario, when you store events, you are storing facts.
    These facts are based on true events that happened in the past, and that is why
    they can be trusted.
  prefs: []
  type: TYPE_NORMAL
- en: As for transactional logs, they inform you of what state changes took place.
    However, they don’t necessarily tell you why those state changes were made. On
    the other hand, when you store events, they inform you of what state changes were
    made, and the reason why those state changes were made.
  prefs: []
  type: TYPE_NORMAL
- en: Events are stored as aggregates in an append-only form. An aggregate is a consistency
    guard. You can see the state changes and the context that led to those changes.
    This means that you can revert the state to the last known consistent state at
    a particular point in time by replaying events forward or backward. You can use
    the event log to provide an audit trail. Information such as why and when can
    be very useful to various business functions, such as senior management, marketing,
    finance, and resource planning, since event logs are full of very valuable business
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our example scenario, an event represents a fact that took place
    in our banking domain. Each event in our banking system is a source of truth from
    which our bank account’s current state is derived. Such facts are immutable business
    facts.
  prefs: []
  type: TYPE_NORMAL
- en: Our banking events will follow the normal methodology of providing state information,
    metadata that provides contextual information, the date and time when it happened,
    and other information that is necessary and appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how we can aggregate events so that they arrive
    at a specific state for our bank account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dividend of £39 was issued by the investment firm to the customer at 12:43
    A.M. on June 12, 2021.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A dividend of £39 was paid into the customer’s bank account by the investment
    firm at 12:45 A.M. on June 12, 2021.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A salary of £2,300 paid was into the customer’s bank account by the employer
    at 12:00 A.M. on July 25, 2021, using BACS.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A standing order of £230 was transferred from the customer’s bank account into
    their savings account to build up an emergency stash at 09:11 A.M. on July 26,
    2021.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A direct debit of £432 was paid to the local authority for rent from the customer’s
    bank account at 07:00 P.M. on July 25, 2021, using the relevant Android banking
    app.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A direct debit of £103 was paid to the local authority for council tax at 08:29
    P.M. on July 26, 2021, using online banking.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: £23.79 was paid for groceries to the merchant by the customer using contactless
    payment at 09:35 P.M. on July 27, 2021.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from our banking scenario, when we use events as our fact-based
    points of truth, we see the full context of where the money is coming from, where
    the money is going, and by which method, what the amount is, and the precise date
    and time when it takes place.
  prefs: []
  type: TYPE_NORMAL
- en: These events ensure the data is in a consistent state, that there is an audit
    trail, and that valuable information is provided that allows business decisions
    to be made based on trustworthy facts.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our banking scenario, each bank account would have a stream
    and unique identifier. All events that occur against that bank account will be
    recorded via its stream. So, we end up with one stream per aggregate. In our banking
    scenario, our aggregate is the group of events that take place against a specific
    bank account.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing example project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will write a simple event sourcing application that also
    provides examples of usage. To implement the project, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET 6.0 console application and call it `CH13_EventSourcing`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a public interface called `IEvent` with an empty method body. This is a
    convenient interface for marking any object an event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new public interface called `IRegisterable` and add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method allows registerable objects to register themselves with an event
    aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new public interface called `IEventAggregator` and add the following
    methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Register` method is used for registering objects of the `IRegisterable`
    type with the event aggregator. The `Register<T>` method registers an event handler
    of the `T` type for the specified object type. Finally, the `RaiseEvent` executes
    the event that was passed in as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `EventHandler` and replace its contents with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This delegate defines our event handler, which is of the `T` type, for events
    of the `IEvent` type.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class called `SingleThreadedEventAggregator` that implements the `IEventAggregator`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dictionary field to hold our event handlers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This dictionary defines a list of event handlers of the `IEvent` type for objects
    of a specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we instantiate our dictionary of event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Register` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method registers our event aggregator with the registerable type that was
    passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Register<T>` method, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method checks our dictionary to see if it contains a key of the specified
    type; if it doesn’t, it adds one. Then, it creates a new event handler list of
    the specified type and adds the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `RaiseEvent` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets a list of event handlers for the event that was passed in and
    loops through them, invoking them.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class called `MultiThreadedEventAggregator` that implements the `IEventAggregator`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following dictionary to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This dictionary will hold a list of event handlers and their events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our constructor initializes our list of event handlers. Notice that we are using
    a concurrent dictionary to handle multi-threaded scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method registers the event handlers of the registerable object with the
    multi-threaded event aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `Register` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method checks our dictionary to see if it contains a key of the specified
    type; if it doesn’t, it adds one. Then, it creates a new event handler list of
    the specified type and adds the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `RaiseEvent` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method loops through all our event handlers stored in the event handler
    list and invokes them for the specified event that was passed in as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: This is the completed base project. Now, let’s look at an example of using our
    event sourcing code.
  prefs: []
  type: TYPE_NORMAL
- en: Add a folder called `BankApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `DividendPayment` class to the `BankApp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class defines our dividend payment event. This event provides information
    on a dividend payment regarding who sent the payment, to whom the payment was
    made, the date of the payment, and the amount of the payment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `InvalidDateException` class to the `BankApp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class implements the `System.Exception` class and will be used to inform
    others that an exception occurred due to an incorrect date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `StandingOrderPayment` class to the `BankApp` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class defines our standing order payment event, which informs us of who
    pays the standing order and to whom, the start date of the standing order, and
    the amount to be paid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `EventHandlers` class to the `BankApp` folder, and update it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our class implements the `IRegisterable` interface and will be used to register
    our events with the event aggregator that was used for those events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property and constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property is set in the constructor to label the `EventHandlers` class for
    easy human reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following registration code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method registers the events and the event handlers for the dividend payments
    and standing orders with the event aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following handler method for dividend payments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time a dividend payment is made, this event handler is called, and the
    properties of the dividend payment event are logged to the console window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following handler method for standing order payments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every time a standing order payment is paid, this event handler is called. The
    properties of the standing order payment event are written out on the console.
    During this process, the payment date is checked to see if it is valid; if it’s
    not, then an `InvalidDateException` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetStandingOrderDate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes the start date of the standing order and checks the date against
    the current date. An exception is thrown if the date is before the standing order
    start date or is not on or after the payment date for the month. Otherwise, the
    current date and time are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the text in the `Program.cs` class with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is our application entry point. We create an event aggregator that is single-threaded.
    Then, we create an instance of the `EventHandlers` class and pass it in the text
    that shows these event handlers are used to handle payment events. Next, we create
    two events – one for dividend payments and the other being for standing order
    payments. The instance of the `EventHandlers` class is then passed into the event
    aggregator so that the event handlers can be registered. Finally, the events for
    the dividend payment and standing order are raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the program. You should see something similar to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The output of our event source application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_13.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – The output of our event source application
  prefs: []
  type: TYPE_NORMAL
- en: With that, you have coded and run an event sourcing application. Before that,
    you did the same with a CQRS application. By writing these two applications, you
    have seen pure CQRS and pure event sourcing at work. With this knowledge, you
    can now write applications that use these patterns individually or that combine
    them so that they work together. In the next section, we will provide a high-level
    overview of Microsoft Azure in terms of writing distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Using Microsoft Azure for distributed systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to use Azure to implement durable microservices
    using serverless features, namely Azure Functions.
  prefs: []
  type: TYPE_NORMAL
- en: What is Azure? As I am sure you are aware by now, Microsoft Azure is Microsoft’s
    cloud offering for hosting your databases, APIs, and data resources. It also has
    many other forms of cloud offerings. Microsoft Azure consists of paid services,
    free for 1-year services, and always free services. You are advised to review
    their different cloud services and compare them with other providers to suit your
    needs. Pay particular attention to which services are free, along with their usage
    limits, and which services you will have to pay for.
  prefs: []
  type: TYPE_NORMAL
- en: Let's name some good reasons to host your applications and databases in the
    cloud instead of on-premises. Well, you don’t have to pay for hardware or electricity
    costs for a start. Then, there is the aspect of scaling up and scaling out when
    your existing infrastructure meets the maximum capacity. Hardware can become obsolete
    very quickly as the complexity of the needs of software and its users grows. So,
    there are many reasons to use the cloud that you will need to carefully consider,
    and with those reasons, there will be both pros and cons. Therefore, when deciding
    to use the cloud, make sure you research, document, and price everything so that
    you start on the right footing. This will make system management, maintenance,
    and business growth much easier in the long run. If you get things right from
    the start of your endeavors, then you will save yourself potential headaches further
    down the line!
  prefs: []
  type: TYPE_NORMAL
- en: A microservice is normally a simple web service that receives a request and
    sends a response. Many kinds of microservices exist, such as film and music streaming
    services and document upload and retrieval services. In the DDD of microservices,
    the microservice will normally have a data source. On Azure, this could be a file
    held in blob storage, data stored in an Azure SQL Server relational database,
    or even data stored in an Azure Cosmos DB NoSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Modern microservice implementations are relying less on containerization that
    uses tools such as Docker and Kubernetes and more on pure serverless options such
    as Azure Functions. The beauty of an Azure Function is that it is only active
    for the period of the call. Once the function has done what it is required to
    do, it simply goes to sleep. An Azure Function also uses fewer computing resources
    and power compared to containerized solutions. The only downside is that you must
    manage many Azure Functions. And so, just like with containerization, you will
    need some way to orchestrate all your Azure Functions in an easy-to-maintain,
    extended, and useful way.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Azure Function is a unit of work. When you implement Azure Functions, you
    do not have to concern yourself with provisioning and managing infrastructure,
    since Azure Functions is one of Microsoft’s serverless computing offerings.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless computing is managed by the serverless provider. This means that
    the serverless computing provider is responsible for investing heavily into provisioning
    and managing the infrastructure that hosts your serverless computing services,
    such as Azure Functions. This means you get to save money on hardware and electricity
    costs, and can fully concentrate your efforts on developing, testing, deploying,
    and maintaining your serverless projects.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s investment into serverless computing provides your Azure Functions
    with networking, service discovery, routing, and events to facilitate high-performance
    communication between your functions and other aspects of your software system
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'An Azure Function normally consists of one or more inputs that you can bind
    and trigger, and outputs that you can bind to, with your custom code sitting between
    the inputs and outputs, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – High-level Microsoft Azure Functions concept diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_13.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – High-level Microsoft Azure Functions concept diagram
  prefs: []
  type: TYPE_NORMAL
- en: Azure Functions are excellent tools to use when developing distributed systems.
    But the complexity of using Azure Functions begins to materialize when the number
    of Azure Functions in your projects starts to grow. Managing large numbers of
    Azure Functions requires a form of orchestration. Orchestration makes managing
    many Azure Functions more straightforward for the infrastructure team. The orchestration
    to employ for Azure Functions is Durable Azure Function.
  prefs: []
  type: TYPE_NORMAL
- en: Durable Azure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can execute Azure Functions with stateful orchestration using durable functions.
    Azure Functions provide an extension known as Durable Functions. Durable function
    applications consist of multiple Azure Functions. Each function in a durable function
    orchestration can perform a different role and/or function. The different types
    of durable functions are activity, orchestrator, entity, and client. Let’s take
    a brief look at each type of durable function.
  prefs: []
  type: TYPE_NORMAL
- en: Durable function type – activity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A basic unit of work is defined as an activity function within the orchestration
    of a durable function. This means that when an orchestrated function performs
    multiple tasks, such as data validation, reading data, and updating data, each
    of these tasks will be executed by a durable activity function. Once a durable
    activity function has been completed, it may return data to the function that
    orchestrated the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Activity functions are defined by activity triggers. `DurableActivityContext`
    is passed in as a parameter. Event triggers can be bound to JSON-serializable
    objects that can be used to pass input data into functions. Since an activity
    function can only have single values passed to them, you can overcome this limitation
    by using arrays, complex types, and tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Activity functions can only be triggered from an orchestrator function and are
    only guaranteed to run at least once by the Durable Task Framework. Because we
    don’t know how many times an activity might be called, Microsoft recommends that
    you make durable activity functions idempotent whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Durable function type – orchestrator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the orchestrator function type when you need to control what actions are
    executed, and the order that you need to execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Durable function type – entity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A durable entity can be invoked by client and orchestrator functions and is
    triggered by an entity trigger. A durable entity function is used to read and
    update an object’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Durable function type – client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A durable client function is defined using a durable client output binding.
    Client functions are used to start orchestrator and entity functions since, on
    the Azure portal, these functions cannot be triggered by button clicks.
  prefs: []
  type: TYPE_NORMAL
- en: Durable function patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several patterns that you can use to manage your durable functions.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregator (stateful entities)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async HTTP APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fan-out/fan-in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aggregator (stateful entities) pattern
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this pattern, a single addressable entity is used to aggregate event data
    that takes place over a certain period. The data that’s passed into an aggregator
    can come from multiple sources. Data may be spread over time and can be delivered
    in batches. You can process data upon arrival and make the aggregated data available
    for querying by external clients.
  prefs: []
  type: TYPE_NORMAL
- en: In the aggregator pattern, the aggregator function should be run in a single
    process or VM. The main reason is due to the complexity of concurrency control
    when it’s used with normal functions that are stateless.
  prefs: []
  type: TYPE_NORMAL
- en: Async HTTP APIs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Factors that affect the time it takes for an API call to complete include volume
    and latency, as well as other factors beyond your control. Durable functions have
    a built-in mechanism for working with the execution of long-running functions,
    and the durable function’s runtime is also responsible for managing the state.
  prefs: []
  type: TYPE_NORMAL
- en: Fan-out/fan-in
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Durable functions allow you to execute functions in parallel and on the results
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Function chaining
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using ordinary functions with service bus queues, you have more complexity
    when it comes to error handling, and it can be hard to visualize the relationship
    between a function and a queue.
  prefs: []
  type: TYPE_NORMAL
- en: However, when you use a durable function, you have one location where you can
    set the order of your functions, storage queues are automatically managed by the
    durable function, and if errors occur in any of the activities, they get propagated
    back to the orchestration function.
  prefs: []
  type: TYPE_NORMAL
- en: Human interaction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Durable functions can be used to escalate processes that have not received human
    interaction within an agreed timeline.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring (actors)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you need to perform a recurring task, such as releasing system resources,
    durable functions provide a flexible way for you to manage recurrence intervals,
    use a single orchestration to manage multiple monitor processes, and manage the
    lifetime of a task.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and serverless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Container and serverless technologies all have a valid place in the microservice
    ecosystem. The primary thought process is to know their strengths and weaknesses
    to help you choose the best option for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Containers are a good option for you if you have legacy code that you want to
    migrate to a more modern platform and code base. You do not have to rewrite your
    legacy code base, such as web services and batch processes, immediately. You can
    place them within a container and deploy them to the cloud. Then, when time, money,
    and resources become available, you can plan for and implement the rewriting of
    your legacy projects.
  prefs: []
  type: TYPE_NORMAL
- en: When you rely on third-party dependencies, cost and PaaS availability can be
    an issue. Sites such as Docker Hub provide access to many readily available containers
    for various third-party dependencies that you can pull and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Local development of multiple microservices can be simplified with Docker Compose
    files. You can add as many services as you need to a Docker Compose file and start
    them all up when they are required.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes clusters, an ingress controller is used to expose only those
    services you want to be exposed to. This allows you to provide secure code with
    a limited footprint that makes life hard for hackers.
  prefs: []
  type: TYPE_NORMAL
- en: Some downsides to containers are that they can encourage the use of older development
    techniques that are more heavyweight and require more computing power. This can
    lead to an increase in computing costs. Containers also need a core number of
    cluster nodes that are always running, adding to your costs.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: External services can be integrated with serverless technology such as Azure
    Functions. Rapid application development is promoted by the simplified programming
    model of serverless computing.
  prefs: []
  type: TYPE_NORMAL
- en: When programming serverless code, you are encouraged to use an event-driven
    approach to your functions. Such code is easily scalable and can be easily rewritten
    or discarded as your business evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless code supports *scale to zero* as functions only ever run when they
    are needed and do not run when they are not needed. This helps reduce running
    costs as resource consumption is very minimal compared to services such as cluster
    nodes, which are always running.
  prefs: []
  type: TYPE_NORMAL
- en: Rapid scale-out of serverless code is another advantage of such technologies,
    as you only ever pay for the running time of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions can pose a security risk, so you must take steps to ensure
    your functions are safe and secure.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the strengths and weaknesses of containers and serverless
    functions, and you have reviewed the various types of durable functions available
    in Microsoft Azure, as well as some durable function patterns, let’s look at managing
    our cloud infrastructures in C# with Pulumi.
  prefs: []
  type: TYPE_NORMAL
- en: Managing your cloud infrastructure with Pulumi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to manage your cloud infrastructure using
    Pulumi. With cloud infrastructure, it is important to be consistent. One way to
    achieve this is to remove the human element, which is prone to error, and automate
    as much as you can. An important aspect of the cloud that can be readily automated
    is infrastructure provisioning tasks. And that’s where Pulumi comes in.
  prefs: []
  type: TYPE_NORMAL
- en: With Pulumi, you can code **Infrastructure as Code** (**IaC**) solutions. Code
    and configuration files are used to manage and provision the infrastructure that
    your software will run on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pulumi projects can be written in various programming languages such as Python,
    VB.NET, F#, and C#. We are interested in using C# for our Pulumi projects. You
    can use Pulumi to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify your infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate how cloud resources are created, updated, and deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use IDEs and code editors such as Visual Studio and Visual Studio Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch mistakes during compilation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforce security, compliance, and best practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use existing NuGet libraries as well as code your own libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Kubernetes, Docker containers, Azure Functions, and Cosmos DB to build applications
    that are easy to scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To follow along, you will need to have Chocolatey installed since it will be
    used as the package manager for installing Pulumi. You will also need to have
    a Microsoft Azure account to deploy your IaC. On Windows, when using the command
    line, make sure you are using PowerShell and that you are running it as an Administrator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s look at a very simple example of provisioning blob storage, adding
    files to blob storage, and destroying our provisioned resources. The following
    steps will provision, use, and delete Azure blob storage:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Pulumi with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ensure that you have .NET 6 SDK or higher installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure Pulumi’s access to your Microsoft Azure account by typing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your credentials will never be sent to pulumi.com, and they will only be used
    by Pulumi for authentication purposes when managing and provisioning resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, you are ready to start using Pulumi. If the `az` term is not
    recognized, try the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new project using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be asked to enter your token, or you can simply press *Enter* to log
    into Pulumi and have Pulumi obtain your token for you. If you don’t have one,
    you can create one quite easily at this stage. Once you are logged in, you will
    be asked a series of questions in PowerShell. You can simply accept all the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in Visual Studio. Let’s review the project files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Pulumi.yaml` is used to define the project.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Pulumi.dev.yaml` is used to store configuration values for your stack.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Program.cs` is the entry point for your project.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MyStack.cs` is used to define your stack resources.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: This class creates an Azure resource group and a storage account. The primary
    key for the storage account is then exported. You will find the location for the
    resource group in the `Pulumi.dev.yaml` file with the `azure-native:location`
    property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, deploy your stack with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When prompted, select **Yes** to deploy your stack to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you should be able to log into your Azure account and see the
    newly created resource, and that it is a storage account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an HTML file to your project called `index.html` and edit the file by adding
    some HTML content and saving it. Here is some sample content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `MyStack.cs` class immediately after the code
    block that creates the Azure storage account resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have created a new static website resource that utilizes the storage
    account we’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code after the code shown in *Step 10*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used our cloud resources and a local `FileAsset` to upload our `index.html`
    file to blob storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the constructor, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code configures the web endpoint to our static website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property just above the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This property provides our static website endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to deploy our changes by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will upload the `index.html` file to blob storage and make our static website
    available to the public. You should see a URL that you can use to view the web
    page that you created and uploaded. The file should be visible in your blob storage,
    which you can view via the Azure portal or Azure Storage Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are satisfied that the preceding code has worked for you, it is time
    to destroy the resources. Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to destroy the entire stack, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With that, the stack has been completely removed from Pulumi.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to manage your Azure stack with Pulumi. By
    using Visual Studio and the PowerShell command line, you created an Azure resource
    account and assigned blob storage to it. Then, you created a static website resource
    and used the cloud resources and local `FileAsset` to upload the static website,
    which consisted of a single file called `index.html`. You were able to view the
    file in blob storage and view the web page in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at some performance considerations for distributed
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations for distributed computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to develop distributed systems. But what about their performance?
    What kinds of things should we be aware of in terms of the performance of distributed
    systems?
  prefs: []
  type: TYPE_NORMAL
- en: The first consideration is the network connection between clients and servers.
    TCP collisions can result in lost packets of information. This can corrupt communication
    between multiple devices and cause connections to time out. The most common reason
    for TCP collisions is when two or more computers share the same IP address.
  prefs: []
  type: TYPE_NORMAL
- en: No computer on the same network should have the same address as another computer
    on the same network. This results in unpredictable network behavior that is detrimental
    to the performance and stability of a networked application. If you experience
    this situation, simply change the IP address of one of the computers to a different
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem that can result in slow network communication is **Domain Name
    Resolution** (**DNS**). If DNS is not correctly set, then accessing a network
    resource such as a web page or web service may take longer than expected and cause
    a connection or request to time out. It is worth noting that there is usually
    more than one DNS on a distributed network. You have the DNS server of the external
    network and your router, which has a DNS for your local network. Either of these
    could be responsible for slow DNS resolution. Some steps you can take to resolve
    DNS issues are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check your network connectivity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that your DNS addresses are correct and in the right order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ping the computer name, IP address, or base URL, such as google.co.uk, that
    you are trying to access to see if it responds or times out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the nameservers in use using `nslookup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the DNS suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the DNS settings have been configured to pull the DNS IP address
    from the DHCP server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `ipconfig` to release and renew the DHCP address and DNS information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the DNS server to see if any services need to be restarted or if the server
    needs to be rebooted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes, the information on the router becomes stale, so a quick solution
    is to reboot the router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every so often, an ISP will run into problems of their own that affect you.
    In these cases, you will need to communicate with them to understand the problem
    and get some indication of when things will be back to normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Distributed firewalls may be employed to protect business networks. Misconfiguration
    of firewalls can result in resource access being denied or invisible. If machines
    are unable to access distributed resources, then the distributed firewall is a
    good place to start. If the distributed firewall is configured correctly, then
    check client and server firewalls to see if they are enabled or disabled and whether
    they are correctly configured or not.
  prefs: []
  type: TYPE_NORMAL
- en: For example, I have dealt with a lot of SQL Server problems. Some have been
    DNS and DHCP issues, but the most common issues are SQL Server configuration and
    firewall configurations. SQL Server uses dynamic ports. But sometimes, these can
    clash, as can fixed ports. Also, I have found that for SQL Server to work on many
    networks, the Named Pipes and TCP protocols must be enabled. Once these protocols
    have been changed within SQL Server Configuration Manager, you need to restart
    the instance of SQL Server they apply to, followed by the SQL Server Browser service.
    If you have firewalls in place, then the SQL Server executable for the instance
    will need to be added to the firewall as an application exception. If you need
    to use specific ports, then you would need to add port exceptions. Standard port
    exceptions for SQL Server are `1433` for TCP and `1434` for UDP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, even after the aforementioned SQL Server troubleshooting has been
    completed, networked applications can still not see the SQL Server instance. When
    this happens, a workaround is to recreate the database connection string with
    the following format: `IP_ADDRESS,PORT_NUMBER\INSTANCE_NAME`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that can affect SQL Server connectivity in a distributed setting
    is the SQL Server driver that is installed and used. If you use specific versions
    of a SQL Server native client, then you will need to ensure that that particular
    version of the native client is installed on all computers for them to be able
    to connect to SQL Server. The way around this is to realize that the SQL Server
    driver is installed by default on all Windows computers, both server and client.
    If you use this driver, then you do not have to worry about rolling out SQL Server
    Native Clients to various computers that are part of your distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Another area of performance is the database querying aspect. The same query
    to obtain a set of results can be written in so many different ways to obtain
    the required results. This is especially true with larger result sets that have
    more joins. Dynamic SQL can also perform slowly. Therefore, speeding up queries
    can improve a database-driven distributed application significantly. You can use
    SQL Server Profile and review SQL Server Execution Plans to identify bottlenecks
    and rewrite SQL so that it’s more performant. You can also add missing indexes,
    correct incorrect indexing, and use pre-compiled stored procedures for performance
    enhancement purposes.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server can become corrupt and fail for many reasons, so it must be regularly
    updated with security patches. Here, you can use Always-On and failover clusters
    to keep connections alive and switch between SQL Servers when a server is down
    or needs to be taken offline for maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: The number of connections to a resource can also overload a distributed system
    to the point that clients cannot connect. To overcome this, you can employ load
    balancing so that when a resource server reaches a certain peak, clients are sent
    to an alternative server for those resources.
  prefs: []
  type: TYPE_NORMAL
- en: Another common oversight when sharing networked resources is network permissions.
    Sometimes, a folder may not be shared that should be shared. A really nasty problem
    can be that of a permissions hierarchy that is enforced via group policy that
    overrides even a network domain administrator’s ability to do their job.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to fully document your group policy and permissions structure
    for current and future staff. With a clear document that diagrammatically shows
    the permission groups and hierarchies, as well as provides a list of resources
    and their permission sets, if someone or an app is having trouble accessing resources,
    such documents can ease the pain of troubleshooting such problems.
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that sometimes, System and TrustedInstaller take control
    of certain resources and prevent you from being able to access resources locally
    and across a network. This can result in you having to override the ownership
    of that network or local location and file resource.
  prefs: []
  type: TYPE_NORMAL
- en: Computer security software can also significantly slow down network traffic
    and even stop programs from working. The usual culprits are the firewall, as we
    mentioned previously, and antivirus software. If your software is not code-signed
    with an authority-approved code signing certificate, then DLLs and executables
    can be quarantined and identified as harmful software. This is what is known as
    being identified as a false positive. You can either sign your software, add your
    software as an application or folder exception, or pass your software to security
    firms to assess your software and update their software to prevent this from happening
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus software can also slow applications down when all network traffic
    and even local files are real-time scanned. An example of this is educational
    software that pulls audio files across the network during assessments. A characteristic
    that identifies this being the case is when the audio files are backed up and
    fired together. To overcome this problem, you can update the antivirus software
    by adding the application, its folders, and its resources as folder and or application/file
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: The size of resources also affects network performance. The larger the size,
    the longer the time to request and receive a resource. Here, you can reduce the
    size of resources such as images, video, and audio files using various compression
    techniques. You can also zip resources up and transmit them before they need to
    be accessed, such as at application startup. You can store resources in the local
    cache once they have been requested and received.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the workload increases to the point that your current system cannot handle
    it, you have two options: scale up vertically or scale out horizontally. Scaling
    up involves increasing the physical computing capacity to cope with the increased
    workload. Scaling out is when you add more servers to cope with the increased
    workload. At the time of writing, the way forward for many companies is to use
    server VMs and containers and have containers running in container management
    software such as Docker and Kubernetes on cloud platforms such as Azure, AWS,
    Google Cloud, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: Large libraries and executables can be made smaller by moving code into microservices
    such as Azure Functions. Azure Functions is an event-driven, compute-on-demand
    experience that extends the existing Azure application platform with capabilities
    to implement code triggered by events occurring in Azure or third-party services,
    as well as on-premises systems. These online services can then scale up and down
    and run only when they are required to do so. This has the added advantage of
    providing cost savings, such as electricity and equipment costs.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use tools such as the browser developer tools and Postman to monitor
    application and network performance.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s summarize what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at the implementation of the CQRS design
    pattern. Then, we looked at an implementation of event sourcing. You can use both
    these patterns by themselves, though they can also be combined to provide very
    powerful and functional microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we took a high-level look at using Microsoft Azure for writing distributed
    systems. The benefits and negative aspects of containers and serverless functions
    were covered to help you understand when to use each technology.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Microsoft Azure, we focused mainly on Azure Functions. Specifically,
    we looked at Durable Azure Functions. We identified the various types of durable
    functions and various durable function patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Now, take some time to answer this chapter’s questions to see how much you have
    retained from this chapter. Please review the *Further reading* section to build
    upon what you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at multithreaded programming in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What does CQRS stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we use the CQRS pattern when developing microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is event sourcing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we use event sourcing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we use containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are serverless functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should we use serverless functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are durable functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of durable functions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of durable function patterns are there?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Pulumi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we use Pulumi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Getting started with Pulumi on Azure*: [https://www.pulumi.com/docs/get-started/azure/](https://www.pulumi.com/docs/get-started/azure/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Modern Cloud Applications using Pulumi and .NET Core*: [https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/](https://devblogs.microsoft.com/dotnet/building-modern-cloud-applications-using-pulumi-and-net-core/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Orchestration Using Durable Azure Functions*: [https://blog.kiprosh.com/orchestration-using-durable-azure-function/](https://blog.kiprosh.com/orchestration-using-durable-azure-function/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Durable Functions Orchestrations*: [https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp](https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-orchestrations?tabs=csharp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best Practices for Durable Functions Patterns*: [https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices](https://www.serverless360.com/blog/azure-durable-functions-patterns-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapters 9* and *10* of *Clean Code in C#* by Jason Alls: [https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S](https://www.amazon.co.uk/Clean-Code-application-performance-practices-ebook/dp/B08614MS6S)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10 Ways to Troubleshoot DNS Resolution Issues*: [https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/](https://techgenix.com/10-Ways-Troubleshoot-DNS-Resolution-Issues/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
