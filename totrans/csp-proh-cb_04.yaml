- en: Chapter 4. Composing Event-Based Programs Using Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter deals with **Reactive Extensions** (**Rx**). To understand Rx,
    we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events versus observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ to perform queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using schedulers in Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, during your day-to-day dealings with developing applications in C#, you
    will have to use asynchronous programming. You might also have to deal with many
    data sources. Think of a web service that returns the current exchange rates,
    a Twitter search returning a stream of related data, or even different events
    generated by multiple computers. Rx provides an elegant solution in the form of
    the `IObserver<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `IObserver<T>` interface to subscribe to the events. Then, the
    `IObservable<T>` interface, which maintains a list of `IObserver<T>` interfaces,
    will notify them on the change of state. In essence, Rx will stick together multiple
    data sources (social media, RSS feeds, UI events, and so on) that generate data.
    Rx, therefore, brings these data sources together in one interface. In fact, Rx
    can be thought of as consisting of three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: The interface that brings together and represents all these
    data streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple data streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedulers**: Parametrizing concurrency using schedulers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question on many minds might be why developers should use (or find use
    for) Rx. Here are a few examples where Rx are really useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a search that has an autocomplete function. You don't want the code
    to perform a search for each value you type into the search area. Rx allows you
    to throttle the search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the UI of your application more responsive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being notified when data changes instead of having to poll the data for changes.
    Think of real-time stock prices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To keep up to date with Rx, you can have a look at the GitHub page: [https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin exploring Rx, we need to install it. The easiest way to
    do this is using NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this chapter on Rx, we will not create a separate class. All the code will
    be written in a console application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click on your solution and select **Manage NuGet Packages for Solution…**
    from the context menu:![How to do it…](img/B05391_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the window that is displayed afterwards, type `System.Reactive` in the search
    text box and search for the NuGet installer:![How to do it…](img/B05391_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing this book, the last stable release was version 3.0.0\.
    Next, select the projects that you want to install Rx on. For simplicity sake,
    we just selected it to be installed project wide:![How to do it…](img/B05391_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next screenshot that is displayed is a confirmation dialog box, asking you
    to confirm the changes to the project. It will show a preview of the changes it
    will be making to each project. If you are happy with the changes, click on the
    **OK** button:![How to do it…](img/B05391_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A license agreement might be presented to you in the last dialog screen, which
    you will need to accept. To continue, click on the **I Accept** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation is complete, you will see the references added to Rx
    under the **References** node in your project. These are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`System.Reactive.Core`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Interfaces`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Linq`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.PlatformServices`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/B05391_04_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NuGet is by far the easiest way to add additional components to your projects.
    As you can see from the added references, `System.Reactive` is the main assembly.
    To gain a better understanding of `System.Reactive`, view the assemblies in **Object
    Browser**. To do this, double-click on any of the assemblies in the **References**
    option of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`System.Reactive.Linq` contains all the querying functionality in Rx. You will
    also notice that `System.Reactive.Concurrency` contains all the schedulers.'
  prefs: []
  type: TYPE_NORMAL
- en: Events versus observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being developers, we should all be quite familiar with events. Most developers
    have been creating events since we started writing code. In fact, if you have
    even dropped a button control on a form and double-clicked the button to create
    the method that handles the click of the button, you have created an event. In
    .NET, we can declare events using the `event` keyword, publish to the event by
    invoking it, and subscribe to that event by adding a handler to the event. We
    therefore have the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Rx, we have a similar structure where we declare a data stream, publish
    data to that stream, and subscribe to it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will see how an event works in C#. We will then see the working of
    an event using Rx and, in doing so, highlight the differences.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In your console application, add a new class called `DotNet`. To this class,
    add a property called `AvailableDatatype`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the main program class, add a new static action event called `types`. Basically,
    this is just a delegate and will receive some value, in our case, the available
    .NET data types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `void Main`, create a `List<DotNet>` class called `lstTypes`. Inside
    this list, add several values of type `DotNet` class. Here, we will just add hardcoded
    data of some of the data types in .NET:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our next task is to subscribe to this event with an event handler that is simply
    outputting the value of *x* to the console window. We will then raise the event
    each time we loop through our `lstTypes` list by adding the line `types(lstTypes[i].AvailableDatatype);`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, before raising an event, we should always check that the event isn't
    null. Only after this check should we raise the event. For brevity, we have not
    added this check before raising the event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you have added all the code from step 1 to step 4, your console application
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running your application will set our list with values and then raise the event
    created to output the values of the list to the console window:![How to do it…](img/B05391_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see the working of events using Rx. Add a static `Subject` of `string`.
    You might also need to add the `System.Reactive.Subjects` namespace to your project
    as `Subjects` live in this separate namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the code that created the list of `DotNet`, we used `+=` to wire up an
    event handler. This time round, we will use `Subscribe`. This is the `IObservable`
    portion of the code. After you have added this, raise the event using the `OnNext`
    keyword. This is the `IObserver` portion of the code. Therefore, as we loop through
    our list, we will call `OnNext` to pump out the values to the subscribed `IObservable`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you have completed adding all the code, your application should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run your application, you will see the same items output to the console
    window as earlier:![How to do it…](img/B05391_04_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Rx, we can declare an event stream with the `Subject` keyword. So, we have
    a source of events that we can publish to using `OnNext`. To see those values
    in the console window, we subscribed to the event stream using `Subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rx allows you to have objects that are just publishers or just subscribers.
    This is because the `IObservable` and `IObserver` interfaces are in fact separate.
    Also, note that in Rx, the observables can be passed as parameters, returned as
    results, and stored in variables, which makes them first class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rx also allows you to specify that the event stream is completed or that an
    error occurred. This really sets Rx apart from events in .NET. Also, it is important
    to note that including the `System.Reactive.Linq` namespace in your project allows
    developers to write queries over the `Subject` type because a `Subject` is an
    `IObservable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B05391_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is another feature that sets Rx apart from the events in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ to perform queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rx allow developers to use the `IObservable` interface that represents synchronous
    data streams to write queries using LINQ. To recap, Rx can be thought of as consisting
    of three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: The interface that brings together and represents all these
    data streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple data streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedulers**: Parametrizing concurrency using schedulers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will be looking at the LINQ functionality of Rx in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As observables are just data streams, we can use LINQ to query them. In the
    following recipe, we will output text to the screen based on a LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by adding a new Windows Forms project to your solution:![How to do it…](img/B05391_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the project `winformRx` and click on the **OK** button:![How to do it…](img/B05391_04_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Toolbox**, search for the **TextBox** control and add it to your form:![How
    to do it…](img/B05391_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add a label control to your form:![How to do it…](img/B05391_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on your `winformRx` project and select **Manage NuGet Packages…**
    from the context menu:![How to do it…](img/B05391_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search text box, enter `System.Reactive` to search for the NuGet package
    and click on the **Install** button:![How to do it…](img/B05391_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to review the changes it's about to make to your
    project. Click on the **OK** button:![How to do it…](img/B05391_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before the installation starts, you might need to accept the license agreement
    by clicking on the **I Accept** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the installation completes, you should see the newly added references
    to your `winformRx` project if you expand the **References** for the project:![How
    to do it…](img/B05391_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, right-click on the project and set `winformRx` as your startup project
    by clicking on **Set as StartUp Project** from the context menu:![How to do it…](img/B05391_04_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the form load event handler for the form by double-clicking anywhere
    on the Windows Form. To this form, add the `Observable` keyword. You will notice
    that the keyword is immediately underlined. This is because you are missing the
    reference to the LINQ assembly of `System.Reactive`:![How to do it…](img/B05391_04_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add this, press *Ctrl* + *.* (period) to bring up the possible suggestions
    to fix the issue. Select to add the `using System.Reactive.Linq` namespace to
    your project:![How to do it…](img/B05391_04_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue adding the following code to your form load event. Basically, you
    are using LINQ and telling the compiler that you want to select the text from
    the event pattern that matches the text changed event of the text box on the form
    called `textBox1`. After you have done that, add a subscription to the variable
    and tell it to output whatever it finds in the text to the label on the form called
    `label1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When we added the text box and label to our form, we left the control names
    as default. If, however, you changed the default names, you would need to specify
    those names instead of `textBox1` and `label1` for the controls on the form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the run button to run your application. The Windows Form will be displayed
    with the text box and label on it:![How to do it…](img/B05391_04_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that the text is output to the label on the form as you type:![How to
    do it…](img/B05391_04_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s jazz things up a bit by adding a `Where` condition to the LINQ statement.
    We will specify that the `text` string must only select the text when it ends
    with a period. This means that the text will only be displayed in the label after
    each full sentence. As you can see, we aren''t doing anything special here. We
    are merely using standard LINQ to query our data stream and return the results
    to our `searchTerm` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your application and start typing in a line of text. You will see that nothing
    is output to the label control as you type, as was evident in the previous example
    before we added in our `Where` condition:![How to do it…](img/B05391_04_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a period and start adding a second line of text:![How to do it…](img/B05391_04_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that only after each period, the text entered is added to the label.
    Our `Where` condition is, therefore, working perfectly:![How to do it…](img/B05391_04_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The LINQ aspect of Rx allows developers to construct observables. Here are
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Empty<>`: Returns an empty observable sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Return<>`: Returns an observable sequence containing a single element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Throw<>`: Returns an observable sequence terminating with an exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Never<>`: Returns a non-terminating observable sequence infinite
    in duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of LINQ in Rx allows the developer to manipulate and filter the data
    stream to return exactly what they need.
  prefs: []
  type: TYPE_NORMAL
- en: Using schedulers in Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to have an `IObservable` subscription run at a specific time.
    Imagine having to synchronize events across servers in geographically different
    areas and time zones. You might also need to read data from a queue while preserving
    the order in which the events occur. Another example would be to perform some
    kind of I/O task that could take some time to complete. Schedulers come in very
    handy in these situations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additionally, you can consider reading up more on using schedulers on MSDN.
    Have a look at [https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already done so, create a new Windows Form application and call
    it `winformRx`. Open the form designer and in **Toolbox**, search for the **TextBox**
    control and add it to your form:![How to do it…](img/B05391_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add a label control to your form:![How to do it…](img/B05391_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on your Windows Form designer to create the onload event handler.
    Inside this handler, add some code to read the text entered into the text box
    and only display that text 5 seconds after the user has stopped typing. This is
    achieved using the `Throttle` keyword. Add a subscription to the `searchTerm`
    variable, writing the result of the text input to the label control''s text property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you might need to add `System.Reactive.Linq` in your `using` statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run your application and start typing in some text into the text box. Immediately,
    we will receive an exception. It is a cross-thread violation. This occurs when
    there is an attempt to update the UI from a background thread. The `Observable`
    interface is running a timer from `System.Threading`, which isn't on the same
    thread as the UI. Luckily, there is an easy way to overcome this. Well, it turns
    out that the UI-threading capabilities lie in a different assembly, which we found
    easiest to get via the **Package Manager Console**:![How to do it…](img/B05391_04_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **View** | **Other Windows** | **Package Manager Console** to access
    the **Package Manager Console**:![How to do it…](img/B05391_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command: `PM> Install-Package System.Reactive.Windows.Forms`![How
    to do it…](img/B05391_04_30.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that you need to ensure that the **Default project** selection is
    set to `winformRx` in the **Package Manager Console**. If you don't see this option,
    resize the **Package Manager Console** screen width until the option is displayed.
    This way you can be certain that the package is added to the correct project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After the installation completes, modify your code in the onload event handler
    and change `searchTerm.Subscribe(trm => label1.Text = trm);`, which does the subscription,
    to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that we are using the `ObserveOn` method here. What this basically
    tells the compiler is that the `this` keyword in `new ControlScheduler(this)`
    is actually a reference to our Windows Form. Therefore, `ControlScheduler` will
    use the Windows Forms timers to create the interval to update our UI. The message
    happens on the correct thread, and we no longer have our cross-thread violation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have not added the `System.Reactive.Concurrency` namespace to your project,
    Visual Studio will underline the `ControlScheduler` line of code with a squiggly
    line. Pressing *Ctrl* + *.* (the Control key and dot) will allow you to add the
    missing namespace:![How to do it…](img/B05391_04_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This means that `System.Reactive.Concurrency` contains a scheduler that can
    talk to Windows Forms controls so that it can do the scheduling. Run your application
    again and start typing some text into your text box:![How to do it…](img/B05391_04_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Five seconds after we stop typing, the throttle condition is fulfilled, and
    the text is output to our label:![How to do it…](img/B05391_04_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we need to keep in mind here from the code we created is that there are
    `ObserveOn` and `Subscribe`. You should not confuse the two. In most cases, when
    dealing with schedulers, you will use `ObserveOn`. The `ObserveOn` method allows
    you to parametrize where the `OnNext`, `OnCompleted`, and `OnError` messages run.
    With `Subscribe`, we parameterize where the actual subscribe and unsubscribe code
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to remember that Rx use the threading timers (`System.Threading.Timer`)
    as a default, which is why we encountered the cross-thread violation earlier.
    As you saw though, we used schedulers to parameterize what timer to use. The way
    schedulers do this is by exposing three components. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler's ability to perform some action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which the action or work to be performed is executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clock that allows the scheduler to have a notion of time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a clock is important because it allows the developer to use timers
    on remote machines, for example (where there might be a time difference between
    you and them), to tell them to perform an action at a particular time.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2015 has added the ability for developers to debug lambda expressions.
    This is a fantastic addition to the features of our favorite IDE. It allows us
    to check the results of a lambda expression on the fly and modify the expression
    to test different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create a very basic lambda expression and change it in the **Watch**
    window to produce a different value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a class called `CSharpSix`. Add a property to this class called `FavoriteFeature`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a `List<CSharpSix>` object and add a few of your favorite C# 6
    features to this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an expression to return only the features starting with the `"Ex"`
    string. Here, we would obviously expect to see exception filters as a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Place a breakpoint on the expression and run your application. When the code
    stops at the breakpoint, you can copy the lambda expression:![How to do it…](img/B05391_04_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the lambda expression into your **Watch** windows and change the string
    in the `StartsWith` method. You will see that the result has changed to the `"Nameof
    Expressions"` string:![How to do it…](img/B05391_04_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to debug lambda expressions allows us to change and debug a lambda
    expression easily. This is something that was not possible in previous versions
    of Visual Studio. It is obviously of great importance to know this tip when working
    with these expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to note is that you can do the same thing from the **Immediate**
    window in Visual Studio 2015, as well as pinned variables from the lambda expression.
  prefs: []
  type: TYPE_NORMAL
