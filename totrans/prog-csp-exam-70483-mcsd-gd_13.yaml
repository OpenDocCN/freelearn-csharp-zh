- en: Managing Assemblies and Debugging Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理组件和调试应用程序
- en: In the last chapter, we learned about cryptography and how we can encrypt and
    decrypt using different techniques available in C#. In this chapter, we will focus
    on how we can manage .NET assemblies, debugging applications, and how to do tracing.
    Writing a .NET application appears to be relatively simple; however, it is important
    to make sure your program serves its purpose, maintains quality standards, doesn't
    crash on exceptions, and behaves properly in all circumstances. To achieve such
    a quality output, it is important to test your application and check the input
    source and values generated at runtime, which are used in the application logic
    for further processing and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了加密学以及如何使用C#中可用的不同技术进行加密和解密。在本章中，我们将关注如何管理.NET组件、调试应用程序以及如何进行跟踪。编写.NET应用程序看起来相对简单；然而，确保您的程序能够实现其目的、维持质量标准、在异常情况下不会崩溃，并且在所有情况下都能正常工作是非常重要的。为了实现这样的质量输出，重要的是测试您的应用程序并检查在运行时生成的输入源和值，这些值用于应用程序逻辑的进一步处理等。
- en: Assemblies are the fundamental units of .NET application deployment. They maintain
    the version, type, resources required, scope, and security details. We will discuss
    this in more detail in the upcoming sections.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是.NET应用程序部署的基本单元。它们维护版本、类型、所需资源、范围和安全细节。我们将在接下来的章节中更详细地讨论这一点。
- en: Debugging is the process of stepping through each and every line of code that
    seems to be problematic or code that you believe will throw errors. During this
    process, we can observe the values in the variables and parameters and whether
    the program is running as expected.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是通过逐行检查似乎有问题或您认为会引发错误的代码的过程。在这个过程中，我们可以观察变量和参数的值以及程序是否按预期运行。
- en: It is also important to understand whether we are creating a library or an independent
    application to distribute to clients. Based on this, we can decide what type (`.exe`
    or `.dll`) of application needs to be created.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理解我们是在创建一个库还是一个独立的应用程序以分发给客户也很重要。基于这一点，我们可以决定需要创建哪种类型（`.exe`或`.dll`）的应用程序。
- en: Tracing allows you to track through each and every line of code while it is
    executing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪允许您在代码执行时跟踪每一行代码。
- en: 'After reading this chapter, you will be able to understand assemblies in .NET
    and how we can manage them, as well as versioning and signing. We will also look
    at a number of ways to debug an application and how to write trace messages when
    an exception occurs. In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章后，您将能够理解.NET中的组件以及如何管理它们，以及版本控制和签名。我们还将探讨调试应用程序的多种方法以及当发生异常时如何编写跟踪消息。在本章中，我们将涵盖以下主题：
- en: Assemblies
  id: totrans-7
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装
- en: Debugging a C# application
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试C#应用程序
- en: Tracing
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can practice the exercises from this chapter using Visual Studio 2012 or
    later with .NET Framework 2.0 or later. However, any new C# features from C# 7.0
    and later require you to have Visual Studio 2017.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Visual Studio 2012或更高版本以及.NET Framework 2.0或更高版本来练习本章的练习。然而，任何从C# 7.0及以后版本的新特性都需要您拥有Visual
    Studio 2017。
- en: If you don't have a license for any of these products, you can download the
    Community version of Visual Studio 2017 from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有这些产品的任何一项许可证，您可以从[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)下载Visual
    Studio 2017的社区版。
- en: The sample code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter13.](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter13)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter13.](https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples/Chapter13)
- en: Assemblies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装
- en: Assemblies in the .NET Framework can be of two types, `.exe` or `.dll`, and
    are termed as the building blocks of a .NET application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework中的组件可以是两种类型之一，`.exe`或`.dll`，被称为.NET应用程序的构建块。
- en: These assemblies form the basic units of an application and allow a programmer
    to maintain versions, security, scope of usage, and reuse. Since an assembly contains
    all the information required to execute your application, it provides the runtime
    with information about what .NET types are used and what features of runtime are
    required to execute the application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件构成了应用程序的基本单元，并允许程序员维护版本、安全性、使用范围和重用性。由于组件包含执行应用程序所需的所有信息，因此它为运行时提供了有关使用哪些
    .NET 类型以及执行应用程序所需的运行时功能的信息。
- en: 'When you create an application in .NET using Visual Studio, it creates source
    code files (`.cs` files), properties of an assembly (`AssemblyInfo.cs`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 .NET 中使用 Visual Studio 创建应用程序时，它会创建源代码文件（`.cs` 文件）、组件属性（`AssemblyInfo.cs`）：
- en: '![](img/f9e5d21d-413c-4dfb-8eb0-a04b89d516fe.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9e5d21d-413c-4dfb-8eb0-a04b89d516fe.png)'
- en: These projects allow programmers to associate other assemblies, which, in turn,
    allows them to create and maintain larger projects for multiple users to work
    on each project. When work on individual projects is completed, these projects
    can be created as one assembly unit to release for the customer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目允许程序员关联其他组件，从而允许他们创建和维护供多个用户共同工作的更大项目。当完成对单个项目的开发工作后，这些项目可以作为一个组件单元创建，以便向客户发布。
- en: 'When an assembly is created, each assembly creates a manifest file that details
    information about the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建组件时，每个组件都会创建一个清单文件，详细说明以下信息：
- en: Each file that has been used in creating this assembly
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建此组件时使用过的每个文件
- en: If there are any references that have been used
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何已使用的引用
- en: The version of the assembly with a unique name
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有唯一名称的组件版本
- en: Assembly contents and manifest
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件内容和清单
- en: 'An assembly in the .NET Framework contains the following four elements:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架中的组件包含以下四个元素：
- en: Assembly manifest
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件清单
- en: Metadata
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: MSIL code
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSIL 代码
- en: Resources
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源
- en: 'These elements can be grouped into one assembly, as shown in the following
    screenshot. Here, the runtime requires manifest information in order to get the
    type information, the dependent assembly information, the version, and the unique
    name of the assembly in order to execute:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素可以组合成一个组件，如下面的截图所示。在这里，运行时需要清单信息以获取类型信息、依赖组件信息、版本和组件的唯一名称，以便执行：
- en: '![](img/d38c91ad-6f14-43d1-8ebb-82e3ef688f7c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d38c91ad-6f14-43d1-8ebb-82e3ef688f7c.png)'
- en: 'The .NET Framework also allows us to group the four elements of the assemblies
    into multiple modules and create an assembly to refer them while executing the
    program block. When you refer such modules in an assembly, it is the manifest
    file that maintains all the links required to refer to these resources:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架还允许我们将组件的四个元素组合成多个模块，并在执行程序块时创建一个组件来引用它们。当在组件中引用这些模块时，是清单文件维护了所有引用这些资源所需的链接：
- en: '![](img/783be34c-df17-4984-9e8f-3d8d000411fe.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/783be34c-df17-4984-9e8f-3d8d000411fe.png)'
- en: An assembly manifest contains the name of the assembly, the version of the assembly,
    which culture is used to build the assembly, the strong name information (that
    is, public key), the type information, a list of files and how they are associated
    with each other and the assembly, and, finally, a list of referenced assemblies
    and their versions. We can add more information by updating the `AssemblyInfo.cs`
    file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 组件清单包含以下信息：组件的名称、版本、用于构建组件的文化、强名称信息（即公钥）、类型信息、文件列表以及它们如何与组件相关联，以及最后，引用的组件及其版本列表。我们可以通过更新
    `AssemblyInfo.cs` 文件来添加更多信息。
- en: A manifest file can be part of the **portable executable** (**PE**) file along
    with MSIL or a standalone PE file. Each assembly file contains all the files that
    are required for an assembly; it governs how the mapping between these files,
    resources, and assemblies are maintained, and it also contains referenced assemblies.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件可以是包含 MSIL 的可移植可执行文件（PE）文件的一部分，也可以是独立的 PE 文件。每个组件文件包含构成组件所需的所有文件；它控制这些文件、资源和组件之间的映射关系，并包含引用的组件。
- en: Target .NET Framework
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标 .NET 框架
- en: When you create a C# application, you can specify which .NET Framework you want
    to target your application to. In a real-world scenario, not every customer updates
    their servers with the latest versions when new versions of the Framework are
    released. Additionally, when a new version is released, some of the old features
    might be deprecated and newer versions of the existing features are added. In
    these situations, your application should not fail. So, the .NET Framework allows
    you to target your application to a specific version of the .NET Framework.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个 C# 应用程序时，你可以指定你的应用程序要针对哪个 .NET Framework。在实际场景中，当框架发布新版本时，并非每个客户都会更新他们的服务器以使用最新版本。此外，当发布新版本时，一些旧功能可能会被弃用，而现有功能的新版本会被添加。在这些情况下，你的应用程序不应失败。因此，.NET
    Framework 允许你将应用程序针对 .NET Framework 的特定版本。
- en: 'You can target the .NET Framework version while creating a new project using
    Visual Studio, or change the target framework using the property pages of the
    project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Visual Studio 创建新项目时，你可以指定要针对的 .NET Framework 版本，或者使用项目的属性页更改目标框架：
- en: '![](img/4ec18630-b493-42d5-a3a4-859dd0886f99.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ec18630-b493-42d5-a3a4-859dd0886f99.png)'
- en: 'Alternatively, to change the target framework version using the property pages,
    select an existing project, right-click on it, and then navigate to Properties:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，要使用属性页更改目标框架版本，请选择一个现有项目，右键单击它，然后导航到属性：
- en: '![](img/c06ae7e5-26ca-4308-b509-0e6e9a78cc07.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c06ae7e5-26ca-4308-b509-0e6e9a78cc07.png)'
- en: 'In the Target framework drop-down menu, select your required version:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在“目标框架”下拉菜单中，选择你需要的版本：
- en: '![](img/18409511-c029-4f79-8589-9f4c7032e293.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18409511-c029-4f79-8589-9f4c7032e293.png)'
- en: Signing assemblies
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署程序集
- en: 'Creating a unique identity for an assembly is referred to as signing or strong-naming
    an assembly. Providing a unique identity for an assembly avoids assembly conflicts.
    Each assembly maintains hashes of the modules, resources, and file information
    in its manifest. When you sign an assembly, the following is captured:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为程序集创建一个唯一的标识符被称为对程序集进行签名或强命名。为程序集提供唯一标识符可以避免程序集冲突。每个程序集在其清单中维护模块、资源和文件信息的哈希值。当你对程序集进行签名时，以下信息将被捕获：
- en: The name of the assembly
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的名称
- en: The version number of the assembly
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集的版本号
- en: If available, the culture (also called *locale* for code development) of the
    assembly
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可用，程序集的文化（也称为代码开发的*区域设置*）
- en: The public key that is used to sign the assembly to the assembly manifest
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于对程序集进行签名的公钥被添加到程序集清单中
- en: 'Signing an assembly provides the following benefits:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 签署程序集提供了以下好处：
- en: It allows us to give a friend access to other signed assemblies.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这允许我们给朋友访问其他已签名的程序集。
- en: It allows us to run different versions of the same assembly side by side.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这允许我们在同一时间运行同一程序集的不同版本。
- en: It allows us to deploy our assembly into the GAC. This allows other applications
    to use our assembly as well.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这允许我们将我们的程序集部署到全局程序集缓存（GAC）。这允许其他应用程序使用我们的程序集。
- en: 'You can sign an assembly in two ways: the first is by using Visual Studio,
    and the second is by using the command-line tool. Visual Studio makes it simple
    to sign the assembly.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式对程序集进行签名：第一种是使用 Visual Studio，第二种是使用命令行工具。Visual Studio 使签名程序集变得简单。
- en: 'Here, we will demonstrate how to sign an assembly using Visual Studio:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将演示如何使用 Visual Studio 签署一个程序集：
- en: Navigate to Project Properties.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目属性。
- en: 'Navigate to the Signing* tab on the left side:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到左侧的“签名*”选项卡：
- en: '![](img/71acc81d-2c4f-49e6-b573-ef151d920e96.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71acc81d-2c4f-49e6-b573-ef151d920e96.png)'
- en: Select the Sign the assembly checkbox.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“签名程序集”复选框。
- en: 'Choose <New...> in the drop-down menu, and then choose a strong key filename:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中选择 <新建...>，然后选择一个强密钥文件名：
- en: '![](img/7ae0ae8b-23f2-4248-9896-4a6334c79a7f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ae0ae8b-23f2-4248-9896-4a6334c79a7f.png)'
- en: Give a key filename in the pop-up window.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中输入一个密钥文件名。
- en: Visual Studio allows you to choose an algorithm and provide a password for the
    key file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 允许你选择一个算法并为密钥文件提供密码。
- en: The password is optional; an algorithm can be changed as per your requirements
    from the available list.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码是可选的；你可以根据需要从可用列表中更改算法。
- en: 'Alternatively, we can sign an assembly using Command Prompt and Visual Studio
    tools that come with the following installation steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用命令提示符和包含以下安装步骤的 Visual Studio 工具对程序集进行签名：
- en: Click the Windows button on your system.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击系统上的 Windows 按钮。
- en: Navigate through the installed programs.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在已安装程序中导航。
- en: Find the Visual Studio 20xx installation folder.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 Visual Studio 20xx 安装文件夹。
- en: Select Developer Command Prompt for Visual Studio 20xx.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 Visual Studio 20xx 的开发者命令提示符。
- en: 'Use `sn.exe` to generate a strong name pair into a `.snk` file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `sn.exe` 将强名称对生成到 `.snk` 文件中：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the key file is created, you can now use Visual Studio to sign the assembly
    or use the `al.exe` tool.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了密钥文件，你现在可以使用 Visual Studio 对程序集进行签名或使用 `al.exe` 工具。
- en: 'Use `al.exe` to link the assembly and key pair generated in the preceding steps:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `al.exe` 将前面步骤中生成的程序集和密钥对链接起来：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: More information about these commands is available on MSDN ([https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool](https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool)).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些命令的更多信息可以在 MSDN 上找到（[https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool](https://docs.microsoft.com/en-us/dotnet/framework/tools/sn-exe-strong-name-tool)）。
- en: Versioning assemblies
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序集版本控制
- en: When you are ready with an assembly and have signed it, you can version it.
    When you version an assembly, the current assembly and all the dependent assembly
    versions are maintained in the assembly manifest. When a versioned assembly is
    deployed into an environment, then that becomes the default version of your application
    and the system throws an assembly manifest mismatch error when either the current
    assembly or dependent assemblies do not match the default version. There is a
    way to override this using a configuration file, which tells the runtime to use
    a specific version instead of the default version.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好一个程序集并对其进行了签名后，你可以对其进行版本控制。当你对程序集进行版本控制时，当前程序集以及所有依赖的程序集版本都保存在程序集清单中。当版本化的程序集部署到环境中时，它将成为你应用程序的默认版本，如果当前程序集或依赖的程序集与默认版本不匹配，系统将抛出程序集清单不匹配错误。有一种方法可以通过配置文件来覆盖这一点，该配置文件告诉运行时使用特定版本而不是默认版本。
- en: 'When an assembly is executed at runtime, it performs multiple steps to resolve
    assembly binding:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序集在运行时执行时，它执行多个步骤以解析程序集绑定：
- en: It checks the current assembly for the version information and a unique name.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查当前程序集的版本信息和唯一名称。
- en: It checks for configuration files to see whether any version override policies
    are defined.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查配置文件以查看是否定义了任何版本覆盖策略。
- en: In the case of any policy changes, the runtime identifies and loads the redirected
    assembly as per the policy.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何策略更改的情况下，运行时会根据策略识别和加载重定向的程序集。
- en: It checks the GAC, or the path specified in configuration files, then the application
    directory, subdirectories, and serves the assembly binding request.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查全局程序集缓存（GAC）或配置文件中指定的路径，然后是应用程序目录、子目录，并服务程序集绑定请求。
- en: Version number
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本号
- en: Every assembly maintains version information in two forms, identity and informational.
    The version number, name, and culture of the assembly form the identity of the
    assembly and the informational version is provided in a string format specified
    in the assembly info file and is for informational purposes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序集以两种形式维护版本信息，即标识符和信息。程序集的版本号、名称和区域设置形成程序集的标识符，信息版本以程序集信息文件中指定的字符串格式提供，仅用于信息目的。
- en: 'The version number of an assembly is represented as a four-part string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 程序集的版本号表示为一个四部分字符串：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For example, if an assembly version is set to 2.1.1234.2, this indicates that
    the major version of the assembly is 2, the minor version is 1, the build number
    is 1234, and the revision number is 2\. When this version is created or updated,
    it is maintained in the manifest file along with a snapshot of all resources and
    dependent assembly files and their versions. In addition to this, versioning checks
    are applicable only when the assembly is signed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果程序集版本设置为 2.1.1234.2，这表示程序集的主版本是 2，次要版本是 1，构建号是 1234，修订号是 2。当创建或更新此版本时，它将连同所有资源和依赖程序集文件及其版本快照一起保存在清单文件中。此外，版本控制检查仅适用于已签名的程序集。
- en: One important thing to understand from a real-world scenario is that, when you
    build a product and release your assemblies for customers and later upgrade your
    assembly, then you have to maintain the previous versions. So, when a new version
    of an assembly is released, clients can still use the old version as long as it
    is supported.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从现实世界的场景中理解的一个重要事情是，当你构建一个产品并发布你的程序集给客户，后来升级你的程序集，那么你必须维护之前的版本。因此，当发布程序集的新版本时，只要它得到支持，客户端仍然可以使用旧版本。
- en: Debugging the C# application
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 C# 应用程序
- en: 'When you build a C# application, you will have two options, debug mode and
    release mode. Debug mode helps you to step through each and every line of your
    code to check for errors and fix them if required. Release mode doesn''t allow
    us to step into code. Visual Studio makes it easy for developers by providing
    more tools, which allows us to `Step-in`, `Step-Over`, and `Step-Out` when a debug
    point is hit by the runtime. These tools are highlighted in a blue box in the
    following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个 C# 应用程序时，你将有两个选项，调试模式和发布模式。调试模式帮助你逐行检查代码以查找错误并在需要时进行修复。发布模式不允许我们进入代码。Visual
    Studio 通过提供更多工具使开发者更容易使用，这些工具允许我们在运行时遇到调试点时执行 `Step-in`、`Step-Over` 和 `Step-Out`。以下截图中的蓝色框中突出显示了这些工具：
- en: '![](img/a8cf1510-0044-4384-8068-5794adbb58c4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8cf1510-0044-4384-8068-5794adbb58c4.png)'
- en: Apart from these tools, Visual Studio also allows us to view stack trace, inspect
    variables, and much more. Let's explore this further in order to understand more
    about debugging.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具，Visual Studio 还允许我们查看堆栈跟踪、检查变量以及更多功能。让我们进一步探索，以便更好地了解调试过程。
- en: Let's start with the basics. To place a breakpoint, just click on the left margin
    next to the line of code you want to debug or place your cursor on the line and
    press the *F9* key on the keyboard. Another way to place a breakpoint is to select
    the Debug menu option and select a new breakpoint.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始。要设置断点，只需单击要调试的代码行左侧的空白处，或将光标放在该行上并按键盘上的 *F9* 键。另一种设置断点的方法是选择调试菜单选项并选择新的断点。
- en: 'When you set a breakpoint, the entire line of code is highlighted in the color
    brown. When the program starts the execution with breakpoints, the control halts
    at the breakpoint and highlights the line in yellow, which means the highlighted
    line is set to execute next:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置断点时，整行代码会被高亮显示为棕色。当程序带有断点开始执行时，控制会在断点处停止并高亮显示该行，这表示高亮显示的行将被执行：
- en: '![](img/5e62e947-ea7b-4de0-a6be-15db19645440.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e62e947-ea7b-4de0-a6be-15db19645440.png)'
- en: 'Observe the preceding screenshot; we have a breakpoint at line 13\. When you
    start the program, the control halted at line 13 where the breakpoint is placed.
    When we step-over, the output is printed on the screen but the control stays at
    line 14 as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的截图；我们在第 13 行设置了断点。当你启动程序时，控制会在设置断点的第 13 行停止。当我们单步执行时，屏幕上会打印输出，但控制会停留在第
    14 行，如下面的截图所示：
- en: '![](img/0b12e200-d1f1-42ff-a118-ecd226d3906e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b12e200-d1f1-42ff-a118-ecd226d3906e.png)'
- en: When a breakpoint is hit, though the application execution is halted, all the
    variables, functions, and objects remain in memory, allowing us to validate the
    values. When you want to debug an application, you build it in debug mode, which
    generates a `.pdb` file; this file is key for debugging. The `.pdb` file contains
    symbols (or source) that get loaded into memory to allow us to debug. If these
    symbols were not loaded, then you might see an error message stating that the
    symbols were not found. It is also important to maintain the versions of these
    `pdb` files, as any version mismatch between your assembly and the `.pdb` file
    will result in an assembly version mismatch error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到断点时，尽管应用程序执行被停止，但所有变量、函数和对象仍然保留在内存中，这允许我们验证它们的值。当你想要调试一个应用程序时，你需要在调试模式下构建它，这会生成一个
    `.pdb` 文件；这个文件是调试的关键。`.pdb` 文件包含符号（或源代码），这些符号被加载到内存中以允许我们进行调试。如果没有加载这些符号，你可能会看到一个错误消息，表明符号未找到。维护这些
    `pdb` 文件的版本也很重要，因为你的程序集和 `.pdb` 文件之间的任何版本不匹配都将导致程序集版本不匹配错误。
- en: Let's jump into an example code and examine the different actions we can perform
    while debugging, as well as the features that Visual Studio provides us with.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳入一个示例代码，并检查在调试过程中我们可以执行的不同操作，以及 Visual Studio 提供给我们的功能。
- en: 'The following is an example program that accepts two numbers and calculates
    the addition and subtraction of those numbers, and then invokes another method
    where 10 is added to the result. Let''s debug this application by placing a couple
    of breakpoints in the code block:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例程序，它接受两个数字并计算这些数字的和与差，然后调用另一个方法将 10 添加到结果中。让我们通过在代码块中设置几个断点来调试这个应用程序：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, two breakpoints were placed on lines 18 and 21\. When the program starts
    executing, it stops at line 18 for user input and when you select continue program
    execution, the control stops at line 21\. One of the important things to observe
    in the following screenshot is that when the control stops at line 21, you can
    view the value of the `number1` variable by just hovering the cursor over it.
    You can see that the `number1` variable has a value of 23:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在第18行和第21行设置了两个断点。当程序开始执行时，它会在第18行停止以等待用户输入，当您选择继续程序执行时，控制会停止在第21行。在下面的屏幕截图中，需要注意的一个重要事项是，当控制停止在第21行时，您只需将光标悬停在`number1`变量上即可查看其值。您可以看到`number1`变量的值为23：
- en: '![](img/6b5d47b8-2511-42dc-9542-64f4d53e0155.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b5d47b8-2511-42dc-9542-64f4d53e0155.png)'
- en: 'Visual Studio debugging tools allow us to watch a variable while the program
    is being executed in debug mode. You can right-click on a variable and select
    `Add Watch` to add the variable to the watch window. As you see can see at the
    bottom of the screen, there is a watch window where variable `number3` has been
    added, and we can see the value of 43, which is the output of the sum of `number1`
    and `number2`. The watch window allows you to view the values after the line of
    code executes. This comes in really handy when your application logic is performing
    complex calculations:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试工具允许我们在调试模式下执行程序时监视变量。您可以在变量上右键单击并选择“添加监视”将变量添加到监视窗口。正如您在屏幕底部所看到的那样，有一个监视窗口，其中已添加了变量`number3`，我们可以看到值为43，这是`number1`和`number2`之和的输出。监视窗口允许您查看代码行执行后的值。当您的应用程序逻辑执行复杂计算时，这非常有用：
- en: '![](img/a8246f05-0ac9-4632-9ea7-4eb4254c8cb9.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8246f05-0ac9-4632-9ea7-4eb4254c8cb9.png)'
- en: 'Another window that comes in handy with debugging is Immediate Window (*Ctrl*
    + *Alt* + *I*), which can be opened by using the keyboard shortcut or the Debug
    menu. In contrast to the watch window, this window helps you to perform operations
    before executing the line of code. As you can see in the following screenshot,
    the control is at line 25 where the breakpoint was hit; however, if you look down,
    the Immediate Window was open where we performed the `number1 - number2` operation
    to check the value before executing the line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在调试过程中非常有用的窗口是即时窗口（*Ctrl* + *Alt* + *I*），可以通过键盘快捷键或调试菜单打开。与监视窗口不同，此窗口可以帮助你在执行代码行之前执行操作。正如您可以在下面的屏幕截图中所见，控制位于第25行，即断点被触发的位置；然而，如果您向下看，即时窗口是打开的，我们在其中执行了`number1
    - number2`操作来检查执行该行之前的值：
- en: '![](img/2e22f179-f671-4a0e-bd35-d05dfea5167c.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e22f179-f671-4a0e-bd35-d05dfea5167c.png)'
- en: 'When you place a breakpoint and hover your cursor over the breakpoint in the
    left margin, the system displays a cogwheel, which allows you to add conditions
    to your breakpoint; for example, your program has a `for` loop, but you want your
    breakpoint to hit when the loop variable is, say, 5:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您放置一个断点并将光标悬停在左侧边缘的断点上时，系统会显示一个齿轮，这允许您为断点添加条件；例如，您的程序有一个`for`循环，但您希望断点在循环变量为5时触发：
- en: '![](img/77f9d984-84ff-4937-9843-cb3194be2e4c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77f9d984-84ff-4937-9843-cb3194be2e4c.png)'
- en: 'When you click on the cogwheel, you will be presented with the condition wizard
    where you can configure the condition of when the breakpoint should hit. By default,
    the condition is set to true, which can be changed by the developer. In the following
    screenshot, we selected `number4=3`, which means that this breakpoint will be
    hit when the number 4 value is equal to 3:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击齿轮时，您将看到一个条件向导，您可以在其中配置断点何时触发的条件。默认情况下，条件设置为true，这可以通过开发人员更改。在下面的屏幕截图中，我们选择了`number4=3`，这意味着当数字4的值等于3时，此断点将被触发：
- en: '![](img/2f513cd1-b8eb-4c1b-99ac-8f40c5123818.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f513cd1-b8eb-4c1b-99ac-8f40c5123818.png)'
- en: 'Another important feature to understand while debugging is that certain types
    of projects in Visual Studio allow you to change the variable values at runtime
    while debugging the application. When the following program was executed, we entered
    `60` as a numeric value to variable `number2`. You can see the value of variable
    2 as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，另一个需要理解的重要功能是，Visual Studio中的某些类型的项目允许您在调试应用程序时更改变量值。当以下程序执行时，我们将`60`作为数值输入到变量`number2`中。您可以通过以下方式查看变量2的值：
- en: '![](img/89927d5a-4ed2-4e35-97fd-838ba6cdd89e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89927d5a-4ed2-4e35-97fd-838ba6cdd89e.png)'
- en: 'Now, when you select the displayed value, the system allows you to change it
    (we changed it to 40), and then continue the execution of the block with the modified
    value. Please remember that not every project type will allow you to change values
    at runtime:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你选择显示的值时，系统允许你更改它（我们将其更改为40），然后使用修改后的值继续执行代码块。请记住，并非所有项目类型都允许你在运行时更改值：
- en: '![](img/827276d3-68e8-4aec-89fc-4528e6c844d2.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/827276d3-68e8-4aec-89fc-4528e6c844d2.png)'
- en: As discussed earlier, there are many tools available while debugging a C# application
    using Visual Studio and some of them are highlighted in the following screenshot.
    The Continue and Stop Debugging buttons enable the developer to continue executing
    once a breakpoint is hit, or to stop the execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Visual Studio中调试C#应用程序时，有许多可用的工具，其中一些在下面的屏幕截图中被突出显示。继续和停止调试按钮允许开发者在一处断点被触发后继续执行，或者停止执行。
- en: There are buttons to Step Into, Step Out, and Step Over. These buttons allow
    you to step into each and every line of code once a breakpoint is hit, or skip
    the execution of a method and continue the execution in the same context, or step
    into an external method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有进入、退出和跳过按钮。这些按钮允许你在断点触发后进入每一行代码，或者跳过方法的执行并继续在同一上下文中执行，或者进入外部方法。
- en: 'Once you debug your program block and fix all the issues you found, you can
    disable or delete all the breakpoints at once by using the Delete All Breakpoints
    or Disable All Breakpoints option in the Debug menu:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你调试了程序块并修复了所有发现的问题，你可以通过使用调试菜单中的删除所有断点或禁用所有断点选项一次性禁用或删除所有断点：
- en: '![](img/e89d54cf-518b-4b89-aaf3-8ece2e141ef5.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e89d54cf-518b-4b89-aaf3-8ece2e141ef5.png)'
- en: 'A few more options are highlighted in the following screenshot, such as Attach
    to Process, QuickWatch..., Save Dump As..., Parallel Stacks, Immediate, and Watch
    windows, Call Stack, and many more:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，突出显示了几个更多选项，例如附加到进程、快速监视...、另存为内存转储...、并行堆栈、立即和监视窗口、调用堆栈等：
- en: '![](img/bd92a1b4-55c0-4080-bd4f-a9104f8ff016.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd92a1b4-55c0-4080-bd4f-a9104f8ff016.png)'
- en: We structure our project in such a way that multiple assemblies are created,
    be it a helper or a dependent assembly. While debugging, it is important to load
    the symbols by attaching the process running those assemblies to the current debugging
    process using the Attach to Process... command. Otherwise, the system prompts
    that the source code is not available, so control cannot step into the code block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式构建项目，即创建多个程序集，无论是辅助程序集还是依赖程序集。在调试时，通过使用附加到进程...命令将运行这些程序集的进程附加到当前调试进程，加载符号非常重要。否则，系统会提示源代码不可用，因此无法进入代码块。
- en: In a real-project scenario, sometimes your application crashes suddenly; in
    such scenarios, you can save the memory dump and analyze the memory registers
    on what's happening. This might require you to have special skills to read and
    understand such dumps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目场景中，有时你的应用程序会突然崩溃；在这种情况下，你可以保存内存转储并分析内存寄存器以了解发生了什么。这可能需要你具备阅读和理解此类转储的特殊技能。
- en: We read about parallel tasks and multithreading in previous chapters; when your
    code block is running a multithreaded application of parallel tasks, the Debug
    menu can help you understand the parallel stack and tasks.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中了解了并行任务和多线程；当你的代码块运行多线程应用程序的并行任务时，调试菜单可以帮助你理解并行堆栈和任务。
- en: Tracing
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪
- en: Tracing enables us to monitor an application while it is executing. When a program
    is executed, the runtime allows us to write messages to monitor the control flow
    of the program. This will enable us to identify any incorrect behavior of the
    application logic. In the case of exceptions, we can identify where exactly the
    code failed and what variable values caused issues in smooth execution. These
    messages can be created by the `System.Diagnostics.Debug` class. When such messages
    are created, by default, these messages are displayed in the output window of
    Visual Studio.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪使我们能够在应用程序执行时对其进行监控。当程序执行时，运行时允许我们写入消息以监控程序的流程控制。这将使我们能够识别应用程序逻辑的任何错误行为。在异常的情况下，我们可以确定代码失败的确切位置以及哪些变量值导致了平稳执行的故障。这些消息可以通过`System.Diagnostics.Debug`类创建。当创建此类消息时，默认情况下，这些消息将在Visual
    Studio的输出窗口中显示。
- en: Apart from creating these messages, you can redirect these messages to a file
    or database using the `System.Diagnostics.Trace` class. You can register listeners
    using the trace class, which allows you to redirect your messages. Here, your
    debug class or trace class acts as the publisher and the listener class acts as
    a subscriber. We hope you remember [Chapter 5](66c957f7-4032-461e-91e4-00da1eb6a517.xhtml),
    *Creating and Implementing Events and Callbacks*, where we learned about the publisher
    and subscriber model.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建这些消息外，您还可以使用 `System.Diagnostics.Trace` 类将这些消息重定向到文件或数据库。您可以使用跟踪类注册监听器，这允许您重定向您的消息。在这里，您的调试类或跟踪类充当发布者，而监听器类充当订阅者。我们希望您还记得第
    5 章，*创建和实现事件和回调*，在那里我们学习了发布者和订阅者模型。
- en: 'Let''s take a look at an example to understand how we can use debug messages.
    In the following program, we are trying to accept two input parameters and perform
    actions such as addition and subtraction on those numbers. However, we added a
    few extra lines to monitor messages that record what''s happening:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解我们如何使用调试消息。在下面的程序中，我们试图接受两个输入参数，并对这些数字执行加法和减法等操作。然而，我们添加了一些额外的行来监控记录发生情况的日志消息：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we used `Debug.WriteLine` to record the messages, these values are
    written in the output window. Observe the following output window where all `Debug.WriteLine`
    messages are written:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了 `Debug.WriteLine` 来记录消息，所以这些值会写入输出窗口。观察以下输出窗口，其中所有 `Debug.WriteLine`
    消息都被写入：
- en: '![](img/7a6ff62f-d20c-41e9-861b-15be1758cad5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a6ff62f-d20c-41e9-861b-15be1758cad5.png)'
- en: In the preceding code block, you can see the last two `Debug.WriteLine` statements
    in the program block, where `Debug.WriteLineIf` is used. The system checks the
    condition that we provided, and, if it returns true, the system writes the message
    to the output window.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，您可以看到程序块中的最后两个 `Debug.WriteLine` 语句，其中使用了 `Debug.WriteLineIf`。系统会检查我们提供的条件，如果返回
    true，则系统会将消息写入输出窗口。
- en: Now, let's go a step further and see how we can use tracing listeners to redirect
    your message to different channels.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，看看我们如何可以使用跟踪监听器将消息重定向到不同的通道。
- en: 'We are going to use the same program with five extra lines, where we add `Console.Out`
    and a `logfile.txt` file as two different trace listeners, and then attach these
    two listeners to the debug object. The last line is `Debug.Flush`, which pushes
    all messages from the object to the log file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的程序，并添加五条额外的行，其中添加 `Console.Out` 和 `logfile.txt` 文件作为两个不同的跟踪监听器，然后将这两个监听器附加到调试对象上。最后一行是
    `Debug.Flush`，它将对象中的所有消息推送到日志文件：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because we added `Console.Out` as one of the listeners, `Debug.WriteLine` messages
    are now written on the screen when we execute the program:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将 `Console.Out` 添加为其中一个监听器，所以当我们执行程序时，`Debug.WriteLine` 消息现在会显示在屏幕上：
- en: '![](img/e21a96aa-f660-4150-ae0b-bb2a2ab61805.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e21a96aa-f660-4150-ae0b-bb2a2ab61805.png)'
- en: 'Additionally, as we added `logfile.txt` as one of the listeners, a new text
    file gets created in the program executing folder where `Debug.WriteLine` messages
    are written:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为我们添加了 `logfile.txt` 作为其中一个监听器，所以程序执行文件夹中会创建一个新的文本文件，其中包含 `Debug.WriteLine`
    消息：
- en: '![](img/a740c00a-e4a4-4ad6-b061-02ea315c39f7.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a740c00a-e4a4-4ad6-b061-02ea315c39f7.png)'
- en: These listeners are not limited to text files and console. Based on the project
    requirement, you can add XML, database listeners, which might require some extra
    coding.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些监听器不仅限于文本文件和控制台。根据项目需求，您可以添加 XML、数据库监听器，这可能需要一些额外的编码。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how a C# assembly can be managed, how to debug an
    assembly or a program block, what features Visual Studio gives us in performing
    these actions, and how to use tracing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何管理 C# 程序集，如何调试程序集或程序块，Visual Studio 在执行这些操作时提供了哪些功能，以及如何使用跟踪。
- en: In the next chapter, we will look at the different functionalities provided
    in C# to access and utilize the data present in file objects and external web
    services, focusing on performing I/O operations on file objects and the different
    helper classes available in the `System.Net` namespace, which helps us with I/O
    operations.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 C# 提供的不同功能，用于访问和利用文件对象和外部 Web 服务中存在的数据，重点关注在文件对象上执行 I/O 操作，以及 `System.Net`
    命名空间中可用的不同辅助类，这些类帮助我们进行 I/O 操作。
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the version number of an assembly represent?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序集的版本号代表什么？
- en: Major version, minor version, build number, and revision.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主版本号、次版本号、构建号和修订号。
- en: Major build, major version, assembly number, and date.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要版本，次要版本，程序集版本和日期。
- en: Major build, major version, assembly number, and revision.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要版本，次要版本，程序集版本和修订号。
- en: All of the above.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有选项。
- en: What is the important benefit of strong naming an assembly?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强类型命名程序集的重要好处是什么？
- en: It allows you to share your assembly.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许您共享您的程序集。
- en: It allows you to run more than two assemblies at the same time.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许您同时运行超过两个程序集。
- en: It allows you to get it installed in GAC.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许您将其安装到全局程序集缓存（GAC）中。
- en: All of the above.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有选项。
- en: What is the easiest way to log debug messages in a text file?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本文件中记录调试消息的最简单方法是什么？
- en: Create a file and use a text stream object to write messages.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件并使用文本流对象写入消息。
- en: Create a trace listener and attached it to the debug object.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个跟踪监听器并将其附加到调试对象。
- en: Use a third-party logging assembly.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第三方日志程序集。
- en: All of the above.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有选项。
- en: Answers
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '**Major version, minor version, build number, and revision**'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主要版本，次要版本，构建号和修订号**'
- en: '**All of the above**'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以上所有选项**'
- en: '**Create a trace listener and attached it to the debug object**'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个跟踪监听器并将其附加到调试对象**'
