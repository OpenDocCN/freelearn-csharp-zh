- en: Chapter 6. Continuing the 2D Adventure
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 继续2D冒险
- en: 'In the previous chapter, we started work on a 2D adventure game. On reaching
    this point, we''ve now created a controllable character that can navigate a level
    using physics and collision detection as well as gravity. This chapter completes
    the 2D game project by adding the remaining features. Specifically, this chapter
    will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始了一个2D冒险游戏。到达这个阶段，我们现在已经创建了一个可控角色，该角色可以使用物理和碰撞检测以及重力来导航关卡。本章通过添加剩余的特性来完成2D游戏项目。具体来说，本章将涵盖以下主题：
- en: Moving obstacles and features such as an elevator platform
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动障碍物和如电梯平台等特性
- en: Gun turrets to attack the player
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于攻击玩家的枪塔
- en: An NPC with a quest system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有任务系统的NPC
- en: Note
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The starting project and assets can be found in the book companion files in
    the `Chapter06/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 起始项目和资源可以在本书配套文件中的`Chapter06/Start`文件夹中找到。如果您还没有自己的项目，可以从这里开始，并跟随本章进行操作。
- en: Moving platforms
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动平台
- en: 'Now let''s refine the adventure further by adding a moving element to the existing
    scene; specifically, a moving platform object. This platform should move up and
    then down again on a loop, ping-ponging between extremes. The player will be able
    to jump onto the platform to hitch a ride, and the object will be constructed
    as a prefab, allowing it to be reused across scenes. See *Figure 6.1* for the
    result:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过向现有场景添加一个移动元素来进一步细化冒险；具体来说，是一个移动平台对象。这个平台应该在循环中上下移动，在极端之间弹跳。玩家将能够跳上平台以搭乘，并且该对象将作为预制件构建，允许它在场景之间重用。请参阅*图6.1*查看结果：
- en: '![Moving platforms](img/figure_06_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![移动平台](img/figure_06_01.jpg)'
- en: 'Figure 6.1: Create a moving platform'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：创建移动平台
- en: 'To start, select the platform texture in the **Project** panel, making sure
    that it''s specified as a **Sprite** (2D and UI) texture type in the **Object
    Inspector**. The **Sprite Mode** should be set to **Single**. Drag and drop the
    platform texture to the scene and set its **Scale** to (`0.7`, `0.5`, `1`). See
    *Figure 6.2*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在**项目**面板中选择平台纹理，确保在**对象检查器**中将其指定为**精灵**（2D和UI）纹理类型。**精灵模式**应设置为**单个**。将平台纹理拖放到场景中，并将其**缩放**设置为(`0.7`,
    `0.5`, `1`)。请参阅*图6.2*：
- en: '![Moving platforms](img/figure_06_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![移动平台](img/figure_06_02.jpg)'
- en: 'Figure 6.2: Building a moving platform'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：构建移动平台
- en: 'Next, the platform should be a solid object, the kind of thing with which the
    player can collide. Remember, the player should be able to stand on the platform.
    Consequently, a Collider must be added. In this case, a Box Collider 2D is appropriate.
    To add this, select the platform object in the scene and navigate to **Component**
    | **Physics 2D** | **Box Collider 2D** from the menu. See *Figure 6.3*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，平台应该是一个固体对象，玩家可以与之碰撞的对象。记住，玩家应该能够站在平台上。因此，必须添加一个碰撞器。在这种情况下，2D盒子碰撞器是合适的。要添加此碰撞器，请选择场景中的平台对象，并从菜单中选择**组件**
    | **物理2D** | **盒子碰撞器2D**。请参阅*图6.3*：
- en: '![Moving platforms](img/figure_06_03.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![移动平台](img/figure_06_03.jpg)'
- en: 'Figure 6.3: Adding a collider to the platform'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：向平台添加碰撞器
- en: 'After the collider has been added to the platform, you may need to adjust its
    properties from the **Object Inspector**; specifically, its **Offset** and **Size**
    fields to make the collider match the size of the platform sprite closely. Then,
    finally, test the platform by entering the play mode and standing the player character
    on the platform. By doing so, the player should not fall through the platform!
    See *Figure 6.4*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在将碰撞器添加到平台后，您可能需要从**对象检查器**中调整其属性；具体来说，调整其**偏移**和**大小**字段，以便使碰撞器与平台精灵的大小紧密匹配。然后，最后，通过进入游戏模式并在平台上放置玩家角色来测试平台。这样做的话，玩家不应该会穿过平台！请参阅*图6.4*：
- en: '![Moving platforms](img/figure_06_04.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![移动平台](img/figure_06_04.jpg)'
- en: 'Figure 6.4: Testing platform collisions'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：测试平台碰撞
- en: 'The platform so far is static and motionless, and it should move up and down
    repeatedly. To fix this, we could create a predefined animation sequence using
    the **Animation Editor** via the **Window** | **Animation** menu option. However,
    instead, we''ll use a script file. Frequently, when making animations, you''ll
    often need to reach decisions about which option is best: *C# animations* or *Baked
    animations*. Typically, script should be chosen when an animation should be simple
    and must apply to many objects and vary for each. The following script file `PingPongMotion.cs`
    should be created and attached to the platform. See *Code Sample 6.1*, and code
    comments follow:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，平台是静态的，没有运动，它应该反复上下移动。为了解决这个问题，我们可以通过**动画编辑器**使用**窗口**|**动画**菜单选项创建一个预定义的动画序列。然而，我们将使用脚本文件。在制作动画时，你通常会需要做出决定：选择哪种选项最佳：*C#动画*或*烘焙动画*。通常，当动画应该简单且必须应用于许多对象且各不相同时，应选择脚本。以下脚本文件`PingPongMotion.cs`应创建并附加到平台。参见*代码示例6.1*，代码注释如下：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code Sample 6.1
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例6.1
- en: 'The following points summarize the code sample:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `PingPongMotion` class is responsible for moving a `GameObject` back and
    forth from an original starting point.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PingPongMotion`类负责将`GameObject`从一个原始起始点来回移动。'
- en: The `Awake` function uses the `OrigPos` variable to record the starting position
    of the `GameObject`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Awake`函数使用`OrigPos`变量记录`GameObject`的起始位置。'
- en: The `Update` function relies on the `Mathf.PingPong` function to transition
    a value smoothly between a minimum and maximum. This function fluctuates a value
    between minimum and maximum repeatedly and continuously over time, allowing you
    move objects linearly. For more information, see the Unity online documentation
    at [http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html](http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Update`函数依赖于`Mathf.PingPong`函数在最小值和最大值之间平滑地转换一个值。这个函数在时间上反复连续地在一个最小值和最大值之间波动一个值，允许你线性地移动对象。有关更多信息，请参阅Unity在线文档[http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html](http://docs.unity3d.com/ScriptReference/Mathf.PingPong.html)。'
- en: The completed code should be attached to the platform object in the scene and
    can be reused easily for any other object that should move up and down regularly
    (or left and right).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的代码应附加到场景中的平台对象上，并且可以轻松地用于任何其他需要定期上下（或左右）移动的对象。
- en: Creating other scenes – levels 2 and 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建其他场景 – 级别2和3
- en: 'Unlike the other games created in the book so far, our adventure game will
    span multiple scenes. That is, our game features several different screens, which
    the player may move between by walking off the edge of one screen and entering
    from the edge of another. Supporting this functionality introduces us to some
    new and interesting problems in Unity that are well worth exploring, as we''ll
    see later. For now, let''s make a second and third scene for the game, using the
    remaining background and foreground objects, and configuring collisions for each
    level, allowing the player prefab to work seamlessly with each environment. The
    details to create a level with collisions (Edge Colliders) are covered in depth
    in the previous chapter. The final, completed scenes are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与书中迄今为止创建的其他游戏不同，我们的冒险游戏将跨越多个场景。也就是说，我们的游戏有几个不同的屏幕，玩家可以通过从一个屏幕的边缘走开并从另一个屏幕的边缘进入来在这些屏幕之间移动。支持此功能使我们接触到一些新的有趣问题，这些问题在Unity中值得探索，正如我们稍后将会看到的。现在，让我们为游戏创建第二个和第三个场景，使用剩余的背景和前景对象，并为每个级别配置碰撞，使玩家预制物能够与每个环境无缝工作。创建具有碰撞（边缘碰撞器）的级别的详细信息在前一章中进行了深入探讨。最终的完成场景如下：
- en: Level 2 is divided across two vertically arranged ledges with a set of moving
    platforms on the lower ledge. These are created from the moving platform prefab
    created in the previous section. The upper ledge is, for now, non-hazardous but
    this will be changed later as we add gun turrets that can shoot the player character.
    This level can be reached from the first original level by walking off the left
    edge of the screen. See *Figure 6.5*:![Creating other scenes – levels 2 and 3](img/figure_06_05.jpg)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二级被分成两个垂直排列的台面，下面台面上有一组移动平台。这些平台是从上一节中创建的移动平台预制件中创建的。目前，上面的台面是无害的，但稍后我们将添加可以射击玩家角色的枪塔，这将改变这一点。这个级别可以通过从第一个原始级别的左侧边缘走开进入。参见*图6.5*：![创建其他场景
    – 级别2和3](img/figure_06_05.jpg)
- en: 'Figure 6.5: Scene 2 – dangerous ledges and moving platforms'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图6.5：场景2 – 危险的台面和移动平台
- en: Level 3 is reached from the first original level by walking off the right edge
    of the screen. It consists of one ground-level plane featuring a house. It will
    be home to an NPC character whom the player can meet and receive a quest to collect
    an item. This character is created later in the chapter. See *Figure 6.6*:![Creating
    other scenes – levels 2 and 3](img/figure_06_06.jpg)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三级是通过从第一个原始级别向屏幕右侧边缘走过去达到的。它由一个地面平面组成，上面有一座房子。它将成为一个NPC角色的家，玩家可以遇到并接受收集物品的任务。这个角色将在本章后面创建。参见
    *图 6.6*：![创建其他场景 – 级别 2 和 3](img/figure_06_06.jpg)
- en: 'Figure 6.6: Scene 3 – a lonely house for an NPC'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.6：场景 3 – 一个NPC的孤独房子
- en: Both Levels 2 and 3 were created entirely with the techniques seen so far. However,
    to give each scene its own charm and character, some unique elements must be added—some
    of these are specific to each scene and some are more general. Let's now consider
    these in turn.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二级和第三级完全使用迄今为止看到的技巧创建。然而，为了给每个场景增添其独特的魅力和个性，必须添加一些独特元素——其中一些是特定于每个场景的，而另一些则更通用。现在让我们逐一考虑这些元素。
- en: Kill zones
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杀戮区域
- en: A common scripted feature required by all scenes, but not yet implemented, is
    the **Kill Zone**. That is, the functionality to mark out a region of 2D space
    in the level that, when entered by the player, will kill them or damage them.
    This is especially useful to kill the player whenever they fall down a hole in
    the ground. Thus, the Kill Zone will be required in every level because every
    level created so far contains pits and holes in the ground. To implement this
    functionality, create a new and empty **GameObject** in any scene. (It doesn't
    matter which because we'll be making a prefab object that can be reused anywhere.)
    As mentioned, new **GameObjects** are created with the menu option, **GameObject**
    | **Create Empty**. Once created, name the object `KillZone`, then position it
    at the world origin (0,0,0), and finally, attach a Box Collider 2D component using
    the menu command, **Component** | **Physics 2D** | **Box Collider 2D**. The Box
    Collider will define the Kill Zone area. Remember to make sure that the **Box
    Collider 2D** is configured as a Trigger by checking the **Is Trigger** checkbox
    in the Inspector from the **Box Collider 2D** component. See *Figure 6.7*. A Trigger
    differs from a Collider; colliders prevent objects from passing through and Triggers
    detect when objects pass through, allowing you to perform custom behaviors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所有场景都需要的一个常见脚本功能，但尚未实现，是**杀戮区域**。也就是说，在级别中标记出2D空间区域的功能，当玩家进入该区域时，会杀死他们或对他们造成伤害。这在玩家从地面上的洞中掉下来时特别有用。因此，每个级别都需要杀戮区域，因为到目前为止创建的每个级别都包含地面上的坑和洞。要实现此功能，在任意场景中创建一个新的空**GameObject**。（这无关紧要，因为我们将会创建一个可以在任何地方重复使用的预制对象。）如前所述，使用菜单选项**GameObject**
    | **Create Empty**创建新的**GameObject**。一旦创建，将对象命名为`KillZone`，然后将其定位在世界原点（0,0,0），最后，使用菜单命令**Component**
    | **Physics 2D** | **Box Collider 2D**附加一个Box Collider 2D组件。Box Collider将定义杀戮区域区域。请确保将**Box
    Collider 2D**配置为触发器，通过在**Box Collider 2D**组件的检查器中勾选**Is Trigger**复选框来实现。参见 *图
    6.7*。触发器与碰撞体不同；碰撞体阻止对象穿过，而触发器检测对象是否穿过，允许您执行自定义行为。
- en: '![Kill zones](img/figure_06_07.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![杀戮区域](img/figure_06_07.jpg)'
- en: 'Figure 6.7: Creating a Kill Zone object and Trigger'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：创建杀戮区域对象和触发器
- en: 'Next, create a new script file `KillZone.cs`, which should be attached to the
    Kill Zone object in the scene. This script file is responsible for damaging the
    player''s health for as long as they are in the Kill Zone. At this stage, there
    are several ways to approach kill zone implementation. One way is to destroy the
    player as soon as they enter the Kill Zone. The other is to damage the player
    for as long as they are in the Kill Zone. The second method is preferred here
    because of its versatility and contribution toward code reuse. Specifically, we
    get the option to damage the player by reducing their health at a particular speed
    (if we need to) as well as killing the player instantly simply by reducing their
    health by an increase in reduction speed. Let''s see this at work in the following
    *Code Sample 6.2*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的脚本文件 `KillZone.cs`，该文件应附加到场景中的杀戮区域对象上。此脚本文件负责在玩家处于杀戮区域期间对其健康造成伤害。在此阶段，有几种方法可以实现杀戮区域。一种方法是在玩家进入杀戮区域时立即摧毁他们。另一种方法是在玩家处于杀戮区域期间持续对其造成伤害。这里更倾向于第二种方法，因为它具有多功能性和代码重用的贡献。具体来说，我们有机会通过以特定速度减少玩家的健康值（如果需要的话）以及通过增加减少速度来立即杀死玩家。让我们在以下
    *代码示例 6.2* 中看看它是如何工作的：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code Sample 6.2
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 6.2
- en: The `KillZone` class is responsible for continually damaging the player health
    when a `GameObject`, tagged as `Player`, enters and remains within a Trigger Volume.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KillZone` 类负责在标记为 `Player` 的 `GameObject` 进入并保持在触发体积内时，持续损害玩家健康。'
- en: The `OnTriggerStay2D` function is called automatically by Unity, once per frame,
    when an object with `RigidBody` enters and remains within a Trigger Volume. Thus,
    when a physics object enters the Kill Zone trigger, the `OnTriggerStay2D` function
    will be called as frequently as the `Update` function. More information on `OnTriggerStay2D`
    can be found at the online Unity documentation at [http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerStay2D` 函数由 Unity 自动调用，每次帧更新时，当具有 `RigidBody` 的对象进入并保持在触发体积内时。因此，当一个物理对象进入
    Kill Zone 触发器时，`OnTriggerStay2D` 函数将被调用，其频率与 `Update` 函数相同。有关 `OnTriggerStay2D`
    的更多信息，请参阅在线 Unity 文档 [http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html](http://docs.unity3d.com/ScriptReference/MonoBehaviour.OnTriggerStay2D.html)。'
- en: The `Damage` variable encodes the reduction of health for the player by adjusting
    the public static property, `Health`, which is part of the `PlayerControl` class.
    When `Health` reaches `0`, the player will be destroyed.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Damage` 变量通过调整 `PlayerControl` 类中的公共静态属性 `Health` 来编码玩家健康的减少。当 `Health` 达到
    `0` 时，玩家将被销毁。'
- en: 'Now, give the game a test run, marking out a Kill Zone in the scene and walking
    the Player into it during play mode. On entry, the player character should be
    destroyed or damaged. To ensure that the player is killed instantly, increase
    the damage to a very high number, such as `9000`! After testing, create a prefab
    from the Kill Zone by dragging and dropping it from the scene **Hierarchy** panel
    to the **Project** panel in the **Prefab** folder. Then, add the **Kill Zone**
    prefab to each level, adjusting and sizing the Collider as needed. See *Figure
    6.8*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行游戏进行测试，在场景中标记出 Kill Zone，并在游戏模式中将玩家走进去。进入时，玩家角色应该被销毁或损坏。为了确保玩家被立即杀死，将伤害增加到非常高的数值，例如
    `9000`！测试完成后，从场景的 **Hierarchy** 面板拖放到 **Prefab** 文件夹中的 **Project** 面板，创建 Kill
    Zone 的预制件。然后，将 **Kill Zone** 预制件添加到每个级别，根据需要调整和调整 Collider。参见 *图 6.8*：
- en: '![Code Sample 6.2](img/figure_06_08.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 6.2](img/figure_06_08.jpg)'
- en: 'Figure 6.8: Configuring a Kill Zone to destroy on contact'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：配置接触时销毁的 Kill Zone
- en: The UI health bar
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI 健康条
- en: 'In the previous section, we introduced the first danger and hazard to the game;
    namely, a Kill Zone that can damage and potentially kill the player. As a result,
    their health has the potential to reduce from its starting state. It''s therefore
    useful both to us as developers and gamers to visualize the health status. For
    this reason, let''s focus on rendering player health to the screen as a UI health
    bar. This configuration of objects will also be made as a prefab, allowing reuse
    across multiple scenes This will prove a highly useful feature. *Figure 6.9* offers
    a glimpse of the future, displaying the result of our work to come:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了游戏中的第一个危险和危害；即一个可以损害并可能杀死玩家的 Kill Zone。因此，他们的健康有可能从起始状态减少。因此，对于我们作为开发人员和玩家来说，可视化健康状态非常有用。因此，让我们专注于将玩家健康渲染到屏幕上的
    UI 健康条。这种对象配置也将被制作成预制件，以便在多个场景中重复使用，这将是一个非常有用的功能。*图 6.9* 展示了未来的一个缩影，显示了我们将要完成的工作的结果：
- en: '![The UI health bar](img/figure_06_09.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![UI 健康条](img/figure_06_09.jpg)'
- en: 'Figure 6.9: Preparing to create player health'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：准备创建玩家健康
- en: 'To get started, create a new GUI Canvas in the scene (any scene) by choosing
    **GameObject** | **UI** | **Canvas** from the application menu. Selecting this
    will automatically create an **EventSystem** object in the scene, if one does
    not exist already. This object is essential for proper use of the UI system. If
    you accidentally delete it, **EventSystem** can be recreated by choosing **GameObject**
    | **UI** | **Event System** from the application menu. The newly created Canvas
    object represents the surface on which the GUI will be drawn. See *Figure 6.10*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请从应用程序菜单中选择 **GameObject** | **UI** | **Canvas** 在场景（任何场景）中创建一个新的 GUI 画布。选择此选项将在场景中自动创建一个
    **EventSystem** 对象（如果尚未存在）。此对象对于正确使用 UI 系统至关重要。如果您意外删除它，可以从应用程序菜单中选择 **GameObject**
    | **UI** | **Event System** 来重新创建 **EventSystem**。新创建的画布对象代表 GUI 将被绘制到的表面。参见 *图
    6.10*：
- en: '![The UI health bar](img/figure_06_10.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![UI 健康条](img/figure_06_10.jpg)'
- en: 'Figure 6.10: Creating a GUI Canvas and Event System'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：创建 GUI 画布和事件系统
- en: 'Next, we''ll create a new and separate camera object for the UI, adding it
    as a child of the newly created Canvas. By creating a separate camera for UI rendering,
    we can apply camera effects and other image adjustments separately to the UI,
    if we need to. To create a Camera as a child, right-click on the **Canvas** object
    in the **Hierarchy** panel and, from the **Context** menu, choose **Camera**.
    This adds a new camera object to the scene as a child of the selected object.
    See *Figure 6.11*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为UI创建一个新的独立相机对象，将其添加为新创建的画布的子对象。通过为UI渲染创建一个独立的相机，如果我们需要的话，我们可以单独对UI应用相机效果和其他图像调整。要创建一个作为子对象的相机，在**层次结构**面板中右键单击**画布**对象，从**上下文**菜单中选择**相机**。这将在场景中添加一个新的相机对象，作为所选对象的子对象。参见*图6.11*：
- en: '![The UI health bar](img/figure_06_11.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_11.jpg)'
- en: 'Figure 6.11: Creating a camera child object'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：创建相机子对象
- en: Now, configure the UI camera to be an Orthographic camera. We saw how to do
    this in the previous chapter, as well as earlier chapters too. *Figure 6.12* displays
    the camera settings for an orthographic camera. Remember that an Orthographic
    camera is truly 2D insofar as it removes perspective and foreshortening effects
    from the render result, which is appropriate for GUIs and other objects that live
    and work in screen space. In addition, the camera **Depth** field, from the **Object
    Inspector**, should be higher than the main game camera to ensure that it renders
    on top of everything else. Otherwise, the GUI could potentially render beneath
    and be ineffectual in the game.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，配置UI相机为正交相机。我们之前章节以及更早的章节中已经看到了如何做到这一点。*图6.12*显示了正交相机的相机设置。记住，正交相机在去除渲染结果的透视和缩短效果方面确实是2D的，这对于GUI和其他在屏幕空间中存在和工作的对象是合适的。此外，从**对象检查器**中的相机**深度**字段，应该比主游戏相机高，以确保它渲染在所有其他内容之上。否则，GUI可能会潜在地渲染在下面，并且在游戏中无效。
- en: '![The UI health bar](img/figure_06_12.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_12.jpg)'
- en: 'Figure 6.12: Configuring an Orthographic camera for GUI rendering'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：为GUI渲染配置正交相机
- en: 'The created camera is almost ready to go! However, right now, it''s configured
    to render everything in the scene just like any other camera. This means that
    the scene is effectively being rendered twice by two separate cameras. This is
    not only wasteful and poor for performance, but it makes the second camera totally
    unnecessary. Instead, we want the first and original camera to show everything
    in the scene, in terms of characters and environments, but to ignore GUI objects,
    and likewise, the newly created GUI camera should show only GUI objects. To fix
    this, select the main game camera and, from the **Object Inspector**, click on
    the **Culling Mask** drop-down list in the **Camera** component. From here, remove
    the check mark for the UI layer. This drop-down list allows you to select layers
    to be ignored for the rendering from the selected camera. See *Figure 6.13*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的相机几乎准备好了！然而，目前，它被配置为像任何其他相机一样渲染场景中的所有内容。这意味着场景实际上正由两个独立的相机渲染两次。这不仅浪费资源且对性能不利，而且使第二个相机完全不必要的。相反，我们希望第一个和原始相机在角色和环境方面显示场景中的所有内容，但忽略GUI对象，同样，新创建的GUI相机应仅显示GUI对象。要修复此问题，选择主游戏相机，并在**对象检查器**中，点击**相机**组件中的**剔除遮罩**下拉列表。从这里，取消勾选UI层的勾选标记。此下拉列表允许您从所选相机中选择要忽略的层。参见*图6.13*：
- en: '![The UI health bar](img/figure_06_13.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_13.jpg)'
- en: 'Figure 6.13: Ignore the UI layer for the main camera'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：对于主相机忽略UI层
- en: Now, select the GUI camera object and, for the **Culling Mask** field in the
    **Camera** component, select the **Nothing** option to deselect all options, and
    then enable the UI layer to render only UI layer objects. See *Figure 6.14*. Good
    work!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择GUI相机对象，并在**相机**组件中的**剔除遮罩**字段中，选择**无**选项以取消选择所有选项，然后启用UI层以仅渲染UI层对象。参见*图6.14*。做得好！
- en: '![The UI health bar](img/figure_06_14.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_14.jpg)'
- en: 'Figure 6.14: Ignoring all layers except the UI layer for the GUI camera'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：对于GUI相机忽略所有层除了UI层
- en: 'By default, any newly created Canvas is configured to work in the Screen Space
    Overlay mode, which means it renders on top of everything else in the scene that
    is not associated with any specific camera. In addition, all GUI elements will
    be sized and scaled on the basis of this. Consequently, to make our work simpler,
    let''s start creating the GUI by first configuring the **Canvas** object to work
    with the newly created GUI camera. To do this, select the **Canvas** object and,
    from the **Canvas** component in the **Object Inspector**, change the **Render
    Mode** from **Screen Space - Overlay** to **Screen Space - Camera**. Then, drag
    and drop the GUI camera object to the **Camera** field. See *Figure 6.15*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何新创建的画布都配置为在屏幕空间叠加模式下工作，这意味着它渲染在场景中与任何特定相机无关的所有其他内容之上。此外，所有GUI元素都将基于此进行尺寸和缩放。因此，为了使我们的工作更简单，让我们首先通过配置**画布**对象与新建的GUI相机一起工作来开始创建GUI。为此，选择**画布**对象，并从**对象检查器**中的**画布**组件，将**渲染模式**从**屏幕空间
    - 叠加**更改为**屏幕空间 - 相机**。然后，将GUI相机对象拖放到**相机**字段。见图6.15：
- en: '![The UI health bar](img/figure_06_15.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_15.jpg)'
- en: 'Figure 6.15: Configuring the Canvas component for camera rendering'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：配置画布组件以进行相机渲染
- en: 'Next, let''s configure the **Canvas Scaler** component, which is attached to
    the **Canvas** object. This component is responsible for how the GUI appears when
    the screen size is changed, from either up-scaling or down-scaling. In short,
    for our game, the GUI should up- and down-scale relatively to the screen size.
    For this reason, change the **UI Scale Mode** drop-down to **Scale With Screen
    Size**, and then enter the game resolution of `1024 x 600` in the **Reference
    Resolution** field. See *Figure 6.16*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置附加到**画布**对象的**画布缩放器**组件。该组件负责当屏幕大小改变时GUI的显示方式，无论是放大还是缩小。简而言之，对于我们的游戏，GUI应该相对于屏幕大小进行放大和缩小。因此，将**UI缩放模式**下拉菜单更改为**与屏幕大小缩放**，然后在**参考分辨率**字段中输入游戏分辨率`1024
    x 600`。见图6.16：
- en: '![The UI health bar](img/figure_06_16.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_16.jpg)'
- en: 'Figure 6.16: Adjusting the Canvas Scaler for responsive UI design'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：调整画布缩放器以实现响应式UI设计
- en: 'Now, we can start adding GUI elements to the game, knowing that they will appear
    correctly when added to the scene. To display health, a representation of the
    player will be useful. Create a new **Image** object by right-clicking on the
    **Canvas** object from the **Hierarchy** panel and choosing **UI** | **Image**
    from the context menu. Once created, select the **Image** object and, from the
    **Object Inspector** (in the **Image** component), drag and drop the player head
    sprite from the **Project** panel to the **Source Image** field. Then, use the
    **Rect Transform** tool (*T* on the keyboard) to resize the image in place at
    the top-left corner of the screen. See *Figure 6.17*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始向游戏中添加GUI元素，知道它们在添加到场景时将正确显示。要显示健康状态，玩家的表示将很有用。通过在**层次结构**面板中右键单击**画布**对象并从上下文菜单中选择**UI**
    | **图像**来创建一个新的**图像**对象。创建后，选择**图像**对象，并从**对象检查器**（在**图像**组件中），将**项目**面板中的玩家头部精灵拖放到**源图像**字段。然后，使用**矩形变换**工具（键盘上的*T*键）在屏幕左上角就地调整图像大小。见图6.17：
- en: '![The UI health bar](img/figure_06_17.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_17.jpg)'
- en: 'Figure 6.17: Adding a head image to the GUI Canvas'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：将头部图像添加到GUI画布
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you cannot see the added head image, remember to assign the UI layer to render
    by the UI camera. In addition, you may need to offset the GUI camera back along
    the *Z* axis to include the head sprite within the **Camera Frustum** (Viewing
    Area).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到添加的头部图像，请记住将UI层分配给UI相机进行渲染。此外，你可能需要将GUI相机沿**Z**轴向后偏移，以便将头部精灵包含在**相机视锥体**（视区）内。
- en: 'Finally, anchor the Head Sprite to the top-left of the screen by clicking on
    the **Anchor Preset** button in the **Rect Transform** component from the **Object
    Inspector**. Choose top-left alignment. This locks the head sprite to the screen
    top-left, ensuring that the interface would look consistent at multiple resolutions.
    See *Figure 6.18*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在**对象检查器**中的**矩形变换**组件上点击**锚点预设**按钮，将头部精灵固定到屏幕的左上角。选择左上对齐。这将锁定头部精灵到屏幕的左上角，确保在多个分辨率下界面看起来一致。见图6.18：
- en: '![The UI health bar](img/figure_06_18.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_18.jpg)'
- en: 'Figure 6.18: Anchoring the head position'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：固定头部位置
- en: 'To create the health bar, add a new **Image** object to the GUI Canvas by right-clicking
    on the **Canvas** and selecting **UI** | **Image** from the context menu. For
    this object, leave the **Source Image** field empty and choose red for the **Color**
    field, **RGB (255,0,0)**. This will represent the background or *red status* for
    the health bar when it''s fully depleted. Then, use the **Rect Transform** tool
    to resize the bar as needed, anchoring to the top-left screen corner. See *Figure
    6.19*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建健康条，通过在 **Canvas** 上右键单击并从上下文菜单中选择 **UI** | **Image** 来在GUI画布中添加一个新的 **Image**
    对象。对于此对象，保留 **Source Image** 字段为空，并将 **Color** 字段选择为红色，**RGB (255,0,0)**。这将代表健康条完全耗尽时的背景或
    *红色状态*。然后，使用 **Rect Transform** 工具根据需要调整条的尺寸，并锚定到屏幕的左上角。参见 *图6.19*：
- en: '![The UI health bar](img/figure_06_19.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_19.jpg)'
- en: 'Figure 6.19: Creating the red health status'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：创建红色健康状态
- en: 'To complete the health bar, we''ll need to use scripting. Specifically, we''re
    going to overlap two identical health bars on top of each other, one red and one
    green. We''ll scale the green bar as the health reduces so that it reveals the
    red bar underneath. Before scripting this behavior, further configuration is necessary.
    Specifically, let''s change the pivot of the health bar away from the center and
    to the middle-left point—the point from which the health bar should scale as it
    reduces and increases. To do this, select the **Health bar** object and, from
    the **Object Inspector**, enter a new **Pivot** value of `0` for **X** and `0.5`
    for **Y**. See *Figure 6.20*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成健康条，我们需要使用脚本。具体来说，我们将在两个相同的健康条上方重叠，一个红色，一个绿色。随着健康的减少，我们将调整绿色条的尺寸，以便露出下面的红色条。在编写脚本之前，还需要进行进一步的配置。具体来说，让我们将健康条的支点从中心移动到中间左侧的点——这是健康条应该根据其减少和增加而缩放的点。为此，选择
    **Health bar** 对象，并在 **Object Inspector** 中为 **X** 输入新的 **Pivot** 值 `0`，为 **Y**
    输入 `0.5`。参见 *图6.20*：
- en: '![The UI health bar](img/figure_06_20.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_20.jpg)'
- en: 'Figure 6.20: Repositioning the Pivot for the health bar'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：重新定位健康条的支点
- en: 'To create the green overlay for the health, select the red health bar and duplicate
    it. Name the duplicate `Health_Green` and drag and drop it to appear beneath the
    red version in the **Hierarchy** panel. The ordering of objects in the hierarchy
    relates to the draw order for GUI elements—lower-order objects are rendered on
    top of higher-order objects. See *Figure 6.21*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建健康条的绿色覆盖层，选择红色健康条并复制它。将复制品命名为 `Health_Green` 并将其拖放到 **Hierarchy** 面板中红色版本下方。层次结构中对象的顺序与GUI元素的绘制顺序相关——较低顺序的对象在较高顺序的对象上方绘制。参见
    *图6.21*：
- en: '![The UI health bar](img/figure_06_21.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![UI健康条](img/figure_06_21.jpg)'
- en: 'Figure 6.21: Creating a duplicate green bar'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：创建一个重复的绿色条
- en: 'Now, we need to make a new script file linking the width of the green bar to
    the health of the player. This means that reductions in health will reduce the
    width of the green bar, revealing the red bar beneath. Create a new script file
    named `HealthBar.cs` and attach it to the green bar. The following is the *Code
    Sample 6.3* for the `HealthBar` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个新的脚本文件，将绿色条的宽度与玩家的健康状态相链接。这意味着健康状态的减少将减少绿色条的宽度，从而露出下面的红色条。创建一个名为
    `HealthBar.cs` 的新脚本文件，并将其附加到绿色条上。以下是为 `HealthBar` 类提供的 *代码示例6.3*：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code Sample 6.3
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例6.3
- en: 'The following points summarize the code sample:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `HealthBar` class is responsible for reducing the width of a green (on the
    top) health bar, based on the player health.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HealthBar` 类负责根据玩家健康状态减少顶部绿色健康条的宽度。'
- en: The `SizeDelta` property of `RectTransform` is used to set the width of `RectTransform`.
    More information on this property can be found at the online Unity documentation
    at [http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html](http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `RectTransform` 的 `SizeDelta` 属性来设置 `RectTransform` 的宽度。关于此属性的更多信息可以在Unity在线文档中找到：[http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html](http://docs.unity3d.com/462/Documentation/ScriptReference/RectTransform-sizeDelta.html)。
- en: The `Mathf.MoveTowards` function is used to gradually and smoothly transition
    the health bar width from its existing width to its destination width over time.
    That is, as and when player health is reduced, the health bar will decrease gradually
    as opposed to instantly. More information can be found at the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html](http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mathf.MoveTowards` 函数用于在一段时间内逐渐且平滑地将生命条宽度从其现有宽度过渡到目标宽度。也就是说，当玩家生命值减少时，生命条会逐渐减少，而不是瞬间减少。更多信息可以在
    Unity 在线文档中找到，链接为 [http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html](http://docs.unity3d.com/ScriptReference/Mathf.MoveTowards.html)。'
- en: Finally, make a prefab of the UI objects by dragging and dropping the topmost
    **Canvas** object from the **Hierarchy** panel to the **Project** panel in the
    **Prefab** folder. This allows the UI system to be reused across multiple scenes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将 **Hierarchy** 面板中最顶部的 **Canvas** 对象拖放到 **Prefab** 文件夹中的 **Project** 面板中，创建
    UI 对象的预制件。这允许 UI 系统在多个场景中重复使用。
- en: Ammo and hazards
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹药和危险
- en: Level 2 is a hazardous place. It should feature not only pits and holes leading
    to kill zones, but also fixed dangers such as gun turrets that can shoot the player.
    This section focuses on their creation. To get started, let's make a gun turret.
    Now, the course companion files don't include a texture or image for the gun turrets,
    but when using the dark silhouette style as we are here, we can easily make a
    consistent turret prop from primitives. In particular, create a new cube object
    (**GameObject** | **3D Object** | **Cube**), rescale it to approximate a gun turret,
    and then position it to the upper ledge in the scene where it will appear as part
    of the scenery. See *Figure 6.22*. Note that you can also use the **Rect Transform**
    tool to resize primitives!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 级别是一个危险的地方。它不仅应该有通向死亡区域的坑洞和洞穴，还应该有固定危险，如可以射击玩家的炮塔。本节重点介绍它们的创建。要开始，让我们制作一个枪炮塔。现在，课程配套文件不包括枪炮塔的纹理或图像，但当我们使用这里使用的暗影轮廓风格时，我们可以很容易地从原始形状中制作出一致的炮塔道具。特别是，创建一个新的立方体对象（**GameObject**
    | **3D Object** | **Cube**），将其缩放以近似枪炮塔，然后将其放置在场景中上方的边缘，使其成为风景的一部分。参见 *图 6.22*。注意，您还可以使用
    **Rect Transform** 工具调整原始形状的大小！
- en: '![Ammo and hazards](img/figure_06_22.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_22.jpg)'
- en: 'Figure 6.22: Creating a prop for a gun turret'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22：创建枪炮塔的道具
- en: 'Of course, the gun turret created so far is a conspicuous and obvious grey
    color. To solve this, create a new black material. Right-click in the **Project**
    panel and choose **Create** | **Material** from the context menu. Assign the material
    a black color from the **Object Inspector** in the **Albedo** field, and then
    drag and drop the material from the **Project** panel to the **Turret** object
    in the scene. Make sure that the **Smoothness** field for the black material is
    reduced to `0` to prevent a shiny or glowing appearance. After the material is
    assigned, the turret will mix with the scene and its color scheme will be much
    better! See *Figure 6.23*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，到目前为止创建的枪炮塔是一个显眼的灰色。为了解决这个问题，创建一个新的黑色材质。在 **Project** 面板中右键单击，并从上下文菜单中选择
    **Create** | **Material**。从 **Object Inspector** 中的 **Albedo** 字段分配黑色颜色，然后将材质从
    **Project** 面板拖放到场景中的 **Turret** 对象上。确保将黑色材质的 **Smoothness** 字段降低到 `0` 以防止出现闪亮或发光的外观。材质分配后，炮塔将与场景混合，其颜色方案将变得更好！参见
    *图 6.23*：
- en: '![Ammo and hazards](img/figure_06_23.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_23.jpg)'
- en: 'Figure 6.23: Assigning a black material to the turret'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23：为炮塔分配黑色材质
- en: 'Now, the turret must fire ammo. To achieve this, it''ll need an empty game
    object to spawn ammo. Let''s create this now by choosing **GameObject** | **Create
    Empty** and drag and drop the object in the **Hierarchy** panel to the Turret
    Cube in order to make it a child of the turret. Then, position the empty object
    to the tip of the cannon. Once positioned, assign an icon representation to the
    empty to make it visible in the viewport. Ensure that the empty is selected and,
    from the Inspector, click on the cube icon (beside the object name) to assign
    it a graphical representation. See *Figure 6.24*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，炮塔必须发射弹药。为了实现这一点，它需要一个空的游戏对象来生成弹药。让我们现在通过选择 **GameObject** | **Create Empty**
    并将对象拖放到 **Hierarchy** 面板中的炮塔立方体上，使其成为炮塔的子对象。然后，将空对象放置在炮管的尖端。一旦定位好，为空对象分配一个图标表示，使其在视图中可见。确保空对象被选中，并在检查器中点击立方体图标（在对象名称旁边）以分配一个图形表示。参见
    *图 6.24*：
- en: '![Ammo and hazards](img/figure_06_24.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_24.jpg)'
- en: 'Figure 6.24: Assigning an icon to the Turret Spawn Point'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：为炮塔生成点分配图标
- en: 'Before moving further with ammo spawning, we''ll actually need some ammo to
    spawn. That is, the turret must fire something, and now it''s time to create this
    something. The ammo should appear as a glowing and pulsating plasma ball. To build
    this, create a new particle system by choosing **GameObject** | **ParticleSystem**
    from the application menu. Remember that a particle system is useful to create
    special effects such as rain, fire, dust, smoke, sparkles, and more. When you
    create a new particle system from the main menu, a new object is created in the
    scene and is automatically selected. When selected, you can preview how the particle
    system works and looks in the **Scene** viewport. By default, the system will
    be spawning small blob-like particles. See *Figure 6.25*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步处理弹药生成之前，我们实际上需要一些弹药来生成。也就是说，炮塔必须发射某种东西，现在是创建这种东西的时候了。弹药应呈现为发光且脉动的等离子球。要构建这个，从应用程序菜单中选择**GameObject**
    | **ParticleSystem**来创建一个新的粒子系统。记住，粒子系统对于创建特殊效果，如雨、火、灰尘、烟雾、火花等非常有用。当您从主菜单创建一个新的粒子系统时，场景中会创建一个新的对象，并且自动选中。选中后，您可以在**场景**视图中预览粒子系统的工作方式和外观。默认情况下，系统将生成类似小滴的粒子。参见*图6.25*：
- en: '![Ammo and hazards](img/figure_06_25.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_25.jpg)'
- en: 'Figure 6.25: Creating a particle system'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：创建粒子系统
- en: 'Sometimes, on creating a particle system for a 2D game, the particles themselves
    may not be visible because they appear behind other 2D objects in the scene, such
    as the background and characters. You can control the depth order of the particle
    system from the **Object Inspector**. Scroll down in the **Object Inspector**
    and click on the **Renderer** roll-out title to expand more options, bringing
    them into view. From the **Renderer** group, set the **Order In Layer** field
    to a higher value, above the order of other objects to render the particles in
    front. See *Figure 6.26*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在为2D游戏创建粒子系统时，粒子本身可能不可见，因为它们出现在场景中其他2D对象之后，例如背景和角色。您可以从**对象检查器**中控制粒子系统的深度顺序。在**对象检查器**中向下滚动并单击**渲染器**展开标题以展开更多选项，使它们可见。在**渲染器**组中，将**层内顺序**字段设置为比其他对象渲染顺序更高的值，以便将粒子渲染在前面。参见*图6.26*：
- en: '![Ammo and hazards](img/figure_06_26.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_26.jpg)'
- en: 'Figure 6.26: Controlling the render order of particles'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：控制粒子的渲染顺序
- en: 'Excellent, we should now see particles in the viewport. Getting a particle
    system to look and behave correctly takes some tweaking and trial and error. It
    involves testing settings, previewing their effects in the viewport, making judgments
    about what is needed, and then tweaking and amending as needed. To start creating
    a more believable ammo object, I want particles to spawn slowly in multiple directions
    and not just one direction. To achieve this, expand the **Shape** field from the
    **Object Inspector** to control the shape of the spawn surface. Change the **Shape**
    from **Cone** to **Sphere** and set **Radius** to `0.01`. On doing this, particles
    will spawn and travel in all directions emitted from a Sphere surface. See *Figure
    6.27*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们现在应该在视图中看到粒子。要使粒子系统看起来和表现正确，需要进行一些调整和尝试错误。这涉及到测试设置，在视图中预览其效果，对所需内容做出判断，然后根据需要调整和修改。为了开始创建一个更可信的弹药对象，我希望粒子以多个方向缓慢生成，而不仅仅是单一方向。为了实现这一点，从**对象检查器**中展开**形状**字段以控制生成表面的形状。将**形状**从**圆锥**更改为**球体**，并将**半径**设置为`0.01`。这样做后，粒子将从球体表面发出的所有方向生成并移动。参见*图6.27*：
- en: '![Ammo and hazards](img/figure_06_27.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_27.jpg)'
- en: 'Figure 6.27: Changing the shape of the particle system emitter'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：更改粒子系统发射器的形状
- en: 'Now, adjust the main particle system properties to create the energy ball effect.
    From the **Object Inspector**, set **Start Lifetime** to `0.19`, **Start Speed**
    to `0.88`, and **Start Size** to `0.59`. Then, set **Start Color** to **teal (light
    blue)**. See *Figure 6.28*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调整主要粒子系统属性以创建能量球效果。从**对象检查器**中，将**开始寿命**设置为`0.19`，**开始速度**设置为`0.88`，**开始大小**设置为`0.59`。然后，将**开始颜色**设置为**青色（浅蓝色）**。参见*图6.28*：
- en: '![Ammo and hazards](img/figure_06_28.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_28.jpg)'
- en: 'Figure 6.28: Configuring the particle system main properties'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：配置粒子系统的主要属性
- en: 'Great! The particle system should now look just as we need it. However, if
    we press play on the toolbar, it doesn''t move. Ammo should, of course, hurtle
    through the air and collide with its target. So, let''s make a `Mover` script
    that should be attached to the object. The following is the code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在粒子系统应该看起来正是我们所需要的。然而，如果我们按工具栏上的播放按钮，它不会移动。弹药当然应该猛冲穿过空气并与其目标碰撞。所以，让我们创建一个`Mover`脚本，并将其附加到对象上。以下代码如下：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Mover features nothing that we haven''t seen before many times already.
    It moves an object (the ammo) in direction of its forward vector. For this reason,
    as our game is two-dimensional, the particle system object may need to be rotated
    in order to turn the forward vector along the *X* axis. See *Figure 6.29*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Mover功能没有我们之前没有多次见过的。它沿着其前向向量移动一个对象（弹药）。因此，由于我们的游戏是二维的，粒子系统对象可能需要旋转，以便将前向向量沿*X*轴对齐。参见*图6.29*：
- en: '![Ammo and hazards](img/figure_06_29.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_29.jpg)'
- en: 'Figure 6.29: Aligning the forward vector to the X axis'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：将前向向量对齐到X轴
- en: 'Next, in addition to moving through the level, the ammo object must collide
    with and damage the player character on impact. To achieve this, several steps
    must be taken. First, a Rigidbody component must be attached to the ammo, allowing
    it to collide with other objects. To add Rigidbody, select the Ammo object in
    the scene and, from the application menu, choose **Component** | **Physics** |
    **Rigidbody2D**. Once added, enable the **Is Kinematic** checkbox from the Rigidbody
    component in the **Object Inspector**. This ensures that the object will travel
    based on the Mover script and still interact with physical objects without being
    affected by gravity. See *Figure 6.30*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，除了在关卡中移动外，弹药对象在碰撞时还必须与玩家角色碰撞并造成伤害。为了实现这一点，必须采取几个步骤。首先，必须将Rigidbody组件附加到弹药上，使其能够与其他对象碰撞。要添加Rigidbody，请在场景中选择弹药对象，然后从应用程序菜单中选择**组件**
    | **物理** | **Rigidbody2D**。一旦添加，从**对象检查器**中的Rigidbody组件中启用**是运动学**复选框。这确保了对象将根据Mover脚本移动，并且仍然与物理对象交互，而不会受到重力的影响。参见*图6.30*：
- en: '![Ammo and hazards](img/figure_06_30.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_30.jpg)'
- en: 'Figure 6.30: Marking Rigidbody with Is Kinematic'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：标记Rigidbody为运动学
- en: 'Now for a Circle Collider to the ammo object to give the ammo some shape, form,
    and size in terms of physics, allowing collisions to be detected between the ammo
    and its target. To do this, choose **Component** | **Physics 2D CircleCollider**
    from the application menu. Once added, mark the collider as Trigger and change
    **Radius** until it approximates the size of the ammo object. See *Figure 6.31*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为弹药对象添加一个圆形碰撞器，使其在物理上具有形状、形式和大小，以便检测弹药与其目标之间的碰撞。为此，从应用程序菜单中选择**组件** | **物理2D圆形碰撞器**。一旦添加，将碰撞器标记为触发器，并更改**半径**，直到它大致等于弹药对象的大小。参见*图6.31*：
- en: '![Ammo and hazards](img/figure_06_31.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_31.jpg)'
- en: 'Figure 6.31: Configuring the Circle Collider for the Ammo object'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：配置弹药对象的圆形碰撞器
- en: 'The ammo should support two final and additional behaviors. First, the ammo
    should damage and perhaps destroy any target it collides with, and second, the
    ammo should destroy itself, both after an elapsed time and if it collides with
    the target. To achieve this, two additional scripts will be created; specifically,
    `CollideDestroy.cs` and `Ammo.cs`. The following code lists the `Ammo.cs` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 弹药应支持两种最终和附加行为。首先，弹药应损坏并可能销毁它与之碰撞的任何目标，其次，弹药应在经过一段时间后以及如果它与目标碰撞时销毁自身。为了实现这一点，将创建两个额外的脚本；具体来说，是`CollideDestroy.cs`和`Ammo.cs`。以下代码列出了`Ammo.cs`文件：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code lists the `CollideDestroy.cs` file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码列出了`CollideDestroy.cs`文件：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code spanning across these files is functionality that we encountered before
    when making the Twin-stick Space Shooter. Both the files should be attached to
    the ammo object in the scene. Once completed, just drag and drop the ammo object
    from the scene viewport to the **Project** panel in the **Prefabs** folder. This
    makes an Ammo prefab, ready to add to any scene. See *Figure 6.32*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 涵盖这些文件的代码是我们之前在制作Twin-stick Space Shooter时遇到的功能。这两个文件都应该附加到场景中的弹药对象上。完成后，只需将场景视图中弹药对象拖放到**项目**面板中的**预制体**文件夹即可。这样就创建了一个弹药预制体，可以添加到任何场景中。参见*图6.32*：
- en: '![Ammo and hazards](img/figure_06_32.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![弹药和危险](img/figure_06_32.jpg)'
- en: 'Figure 6.32: Adding the Destroy and Ammo components to the Ammo and then making
    a prefab'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32：将销毁和弹药组件添加到弹药中，然后创建预制体
- en: Excellent work! You now have an ammo object that fires, moves, and collides
    with the player. By setting the **Damage** setting high enough, you will be able
    to destroy the player on impact. Give this a test now by adding an ammo object
    to the scene and pressing the play icon. Of course, right now, nothing in the
    scene actually fires the ammo. We'll explore that next.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在有一个可以发射、移动并与玩家发生碰撞的弹药对象。通过将**伤害**设置得足够高，你将能够在碰撞时摧毁玩家。现在通过向场景添加一个弹药对象并按下播放图标来测试一下。当然，目前场景中实际上并没有东西在发射弹药。我们将在下一节中探讨这个问题。
- en: Gun turrets and ammo
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枪塔和弹药
- en: 'We''ve now created an ammo object (a projectile) and we''ve started to engineer
    a gun turret object, but it doesn''t yet spawn ammo. Let''s create this functionality
    now. We have a spawn point positioned in front of the turret parented to it as
    a child object. We''ll attach a new script file called `AmmoSpawner.cs` to this
    object. This script is responsible for generating ammo at regular intervals. Refer
    to the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个弹药对象（一个投射物），并且已经开始设计一个炮塔对象，但它还没有生成弹药。现在让我们创建这个功能。我们在炮塔父对象前面放置了一个作为子对象的生成点。我们将一个名为`AmmoSpawner.cs`的新脚本文件附加到这个对象上。这个脚本负责定期生成弹药。参考以下代码：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code relies on the `Invoke` function called at random intervals
    using `Random.Range` in order to instantiate a new ammo prefab into the scene.
    This code could be improved using Object Pooling (or Caching), as discussed in
    the previous chapter with ammo, but in this case, the code performs acceptably.
    See *Figure 6.33*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码依赖于在随机间隔内使用`Random.Range`调用的`Invoke`函数，以便在场景中实例化一个新的弹药预制件。这个代码可以通过使用上一章中讨论的对象池（或缓存）来改进，但在这种情况下，代码的表现是可以接受的。参见*图6.33*：
- en: '![Gun turrets and ammo](img/figure_06_33.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![枪塔和弹药](img/figure_06_33.jpg)'
- en: 'Figure 6.33: A time delay of (0,0) generates ammo continually in a beam. Increase
    the value to insert reasonable gaps between ammo spawns'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33：时间延迟为（0，0）会在一条光束中不断生成弹药。增加值以在弹药生成之间插入合理的间隔
- en: Excellent! We've now created a gun turret that, like the ammo itself, can be
    turned into a prefab. Make sure that the **Time Delay** range (the time between
    ammo spawns) is set to a value higher than zero; otherwise, ammo will be continually
    generated and become practically impossible for the player to avoid. Go ahead
    and position more turrets, if needed, to balance the difficulty of the scene.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经创建了一个炮塔，就像弹药本身一样，可以被转换成预制件。确保将**时间延迟**范围（弹药生成的间隔时间）设置为大于零的值；否则，弹药将不断生成，玩家几乎无法避免。如果需要，可以继续放置更多炮塔，以平衡场景的难度。
- en: NPCs and quests
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NPC和任务
- en: '**NPC** stands for **Non-player Character** and typically refers to any friendly
    or neutral characters other than the player-controlled character. In our adventure,
    Level 3 should feature an NPC character standing outside their house, and they
    provide us with a quest; specifically, to collect a gem item from Level 2, which
    features many hazards, including pits and gun turrets, as we''ve seen. To create
    the NPC character, we''ll simply duplicate the player and adjust the character
    color, making them appear distinct. Thus, simply drag and drop the **Player**
    prefab from the **Project** panel to the Level 2 scene and position it near the
    house area. Then, remove all additional components (such as the Player Controller
    and Collider) to return this character back to a standard sprite that is not player-controlled.
    See *Figure 6.34*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**NPC**代表**非玩家角色**，通常指除玩家控制的角色之外的所有友好或中立角色。在我们的冒险中，第3级应该有一个站在房子外面的NPC角色，他们为我们提供任务；具体来说，是从第2级收集宝石物品，第2级有许多危险，包括坑和枪塔，正如我们所见。为了创建NPC角色，我们只需复制玩家并调整角色颜色，使他们看起来与众不同。因此，只需将**玩家**预制件从**项目**面板拖放到第2级场景中，并将其放置在房子附近。然后，移除所有其他组件（如玩家控制器和碰撞器），将这个角色恢复为标准精灵，不再是玩家控制的。参见*图6.34*：'
- en: '![NPCs and quests](img/figure_06_34.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![NPC和任务](img/figure_06_34.jpg)'
- en: 'Figure 6.34: Creating an NPC from the player character prefab'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34：从玩家角色预制件创建NPC
- en: 'Now, let''s invert the character''s **X** scale to make him or her face left
    instead of right. Select the parent NPC object as opposed to its constituent limbs,
    such as hands and arms, and invert its **X** scale. All child objects will flip
    to face the direction of their parent. See *Figure 6.35*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们反转角色的**X**轴缩放，使其面向左边而不是右边。选择NPC父对象而不是其组成部分，如手和手臂，并反转其**X**轴缩放。所有子对象都将翻转以面向其父对象的方向。参见*图6.35*：
- en: '![NPCs and quests](img/figure_06_35.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![NPCs and quests](img/figure_06_35.jpg)'
- en: 'Figure 6.35: Flipping the X scale for a character NPC'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：翻转NPC角色的X轴缩放
- en: 'We should also change the color of the NPC from green to red to distinguish
    him from the player. Now, the character is a multipart object composed from several
    sprite renderers. We could select each object and change its color individually
    via the **Object Inspector**. However, it''s easier to select all the objects
    and change their color together; Unity 5 supports multi-object editing for common
    properties. See *Figure 6.36*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该将NPC的颜色从绿色改为红色，以便与玩家区分开来。现在，这个角色是一个由几个sprite renderers组成的multipart对象。我们可以选择每个对象并单独通过**Object
    Inspector**更改其颜色。然而，选择所有对象一起更改它们的颜色会更简单；Unity 5支持多对象编辑以编辑常见属性。见*图6.36*：
- en: '![NPCs and quests](img/figure_06_36.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![NPCs and quests](img/figure_06_36.jpg)'
- en: 'Figure 6.36: Setting the NPC color'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：设置NPC颜色
- en: 'The NPC should talk to the player on approach. This means that when the player
    approaches the NPC, the NPC should display dialog text. The text to be displayed
    varies, depending on the status of their quest. On a first visit, the NPC will
    give the player a quest. On a second visit, the NPC will respond differently,
    depending on whether the quest has been completed in the meantime. To start creating
    this functionality, we need to determine when the player approaches the NPC. This
    is achieved using a Collider. Consequently, select the NPC object in the scene
    and then choose **Component** | **Physics 2D** | **Box Collider 2D** from the
    application menu. Size the collider not to approximate the NPC specifically, but
    to approximate the area around the NPC in which the player should enter to have
    a conversation. Be sure to mark the collider as a Trigger object, allowing the
    player to enter and pass through. See *Figure 6.37*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NPC应该在接近玩家时与玩家交谈。这意味着当玩家接近NPC时，NPC应该显示对话框文本。要显示的文本根据他们的任务状态而变化。在第一次访问时，NPC会给玩家一个任务。在第二次访问时，NPC会根据在此期间任务是否完成而有所不同。为了开始创建这个功能，我们需要确定玩家何时接近NPC。这是通过使用Collider实现的。因此，在场景中选择NPC对象，然后从应用程序菜单中选择**Component**
    | **Physics 2D** | **Box Collider 2D**。调整碰撞器的大小，使其不精确地近似NPC，而是近似NPC周围的区域，玩家应该进入该区域进行对话。确保将碰撞器标记为Trigger对象，允许玩家进入并通过。见*图6.37*：
- en: '![NPCs and quests](img/figure_06_37.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![NPCs and quests](img/figure_06_37.jpg)'
- en: 'Figure 6.37: Configuring the NPC Collider'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：配置NPC碰撞器
- en: 'At this stage, we need a GUI element to act as the conversation panel to display
    conversation text when the NPC speaks. This configuration simply consists of a
    GUI Canvas object with a Text object child. Both of these objects can be created
    from the application menu with **GameObject** | **UI** | **Canvas and GameObject**
    | **UI** | **Text** respectively. The Canvas object should also have a CanvasGroup
    component attached using the **Component** | **Layout** | **CanvasGroup** menu
    option. This lets you set the alpha transparency for the panel and child objects
    as one complete unit. The Alpha member can be changed from the **Object Inspector**.
    A value of `1` means fully visible and value of `0` means fully transparent. See
    *Figure 6.38*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们需要一个GUI元素作为对话面板来显示NPC说话时的对话文本。这个配置简单由一个GUI Canvas对象及其子Text对象组成。这两个对象都可以通过应用程序菜单中的**GameObject**
    | **UI** | **Canvas and GameObject** | **UI** | **Text**分别创建。Canvas对象还应通过**Component**
    | **Layout** | **CanvasGroup**菜单选项附加一个CanvasGroup组件。这允许你将面板及其子对象的alpha透明度作为一个整体设置。Alpha成员可以从**Object
    Inspector**中更改。值为`1`表示完全可见，值为`0`表示完全透明。见*图6.38*：
- en: '![NPCs and quests](img/figure_06_38.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![NPCs and quests](img/figure_06_38.jpg)'
- en: 'Figure 6.38: Adding a Canvas Group component to the GUI conversation panel'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38：将Canvas Group组件添加到GUI对话面板
- en: 'Excellent. We now have the ability, if we need to, to fade the panel in and
    out simply by animating the Alpha value from `0` to `1` over time. However, we
    still need functionality to maintain quest information to determine whether a
    quest has been assigned and to determine which text should be displayed in the
    conversation, based on the quest completion status. To do this, a new class must
    be created, `QuestManager.cs`. This class will allow us to create and maintain
    quest information. Refer to the *Code Sample 6.8*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 极好。我们现在有了能力，如果需要的话，可以通过在一段时间内将 Alpha 值从 `0` 动画到 `1` 来简单地淡入淡出面板。然而，我们仍然需要功能来维护任务信息，以确定任务是否已被分配，以及根据任务完成状态确定应该显示在对话中的文本。为此，必须创建一个新的类，`QuestManager.cs`。这个类将允许我们创建和维护任务信息。请参阅
    *代码示例 6.8*：
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Code Sample 6.8
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 6.8
- en: 'The following points summarize the code sample:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: '`QuestManager` maintains a list of all quests (`Quest`). That is, a list of
    all possible quests within the game and not a list of only assigned or completed
    quests. The `Quest` class defines the name and status for a single and specific
    quest.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QuestManager` 维护所有任务（`Quest`）的列表。也就是说，游戏内所有可能任务列表，而不仅仅是已分配或完成的任务列表。`Quest`
    类定义了单个特定任务的名称和状态。'
- en: Any single quest can be `UNASSIGNED` (meaning that the player hasn't collected
    it), `ASSIGNED` (the player has collected it but not completed it), and `COMPLETE`
    (the player has collected and completed it).
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何单个任务可以是 `UNASSIGNED`（意味着玩家尚未收集它），`ASSIGNED`（玩家已收集但未完成），或者 `COMPLETE`（玩家已收集并完成）。
- en: The `GetQuestStatus` function retrieves the completed status of the specified
    quest. The `SetQuestStatus` function assigns a new status to the specified quest.
    These are static functions, and so any script can set or get this data from any
    place.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetQuestStatus` 函数检索指定任务的完成状态。`SetQuestStatus` 函数将新状态分配给指定任务。这些是静态函数，因此任何脚本都可以在任何地方设置或获取这些数据。'
- en: 'To use this object, create an instance in the scene (the first scene of the
    game), and then define all the quests that can be collected via the **Object Inspector**.
    In our game, there is only quest available: the quest given by an NPC character
    to collect a stolen gemstone from Level 2, the hazardous scene protected by gun
    turrets. See *Figure 6.39* for how I configured quests to work with **Quest Manager**:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此对象，在场景中（游戏的第一场景）创建一个实例，然后通过 **Object Inspector** 定义所有可以收集的任务。在我们的游戏中，只有一个任务可用：由
    NPC 角色给出的任务，从第 2 级收集被盗的宝石，该场景由机枪炮塔保护。请参阅 *图 6.39* 了解如何配置与 **Quest Manager** 一起工作的任务：
- en: '![Code Sample 6.8](img/figure_06_39.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 6.8](img/figure_06_39.jpg)'
- en: 'Figure 6.39: Defining in-game quests via QuestManager'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.39：通过 QuestManager 定义游戏中的任务
- en: '`QuestManager` defines all the possible quests in the game, whether or not
    they''re collected by the player. However, the NPC still needs to assign the quest
    to the player on approach. This can be achieved with the script file, `QuestGiver.cs`.
    See the following code. This script file should be attached to anything that gives
    quests, such as the NPC:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuestManager` 定义了游戏中所有可能的任务，无论玩家是否收集。然而，NPC 仍然需要在接近时将任务分配给玩家。这可以通过脚本文件 `QuestGiver.cs`
    实现。请参阅以下代码。此脚本文件应附加到任何提供任务的物品上，例如 NPC：'
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After attaching this script to the NPC, give the game a test by pressing the
    play icon on the toolbar. Approach the NPC, and the GUI text should change to
    the specified quest as defined for the **QuestName** field for the **QuestGiver**
    component in the **Object Inspector**. This name should match **QuestName**, as
    defined in the `QuestManager` class. See *Figure 6.40*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此脚本附加到 NPC 后，通过在工具栏上按下播放图标来测试游戏。接近 NPC，GUI 文本应更改为为 **QuestGiver** 组件的 **QuestName**
    字段定义的指定任务，该字段位于 **Object Inspector** 中。此名称应与 `QuestManager` 类中定义的 **QuestName**
    匹配。请参阅 *图 6.40*：
- en: '![Code Sample 6.8](img/figure_06_40.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 6.8](img/figure_06_40.jpg)'
- en: 'Figure 6.40: Defining the QuestGiver component'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.40：定义 QuestGiver 组件
- en: The assigned quest is to collect a gemstone, but our levels lack a stone. Let's
    now add one for the player to collect. To do this, drag and drop the GemStone
    texture from the project panel (`Texture` folder) to scene 2 on the topmost ledge
    so that the player has to climb to reach it (a challenge!). See *Figure 6.41*.
    Be sure to attach a **Circle Collider** trigger to the object, allowing it to
    collide with the player.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的任务是收集宝石，但我们的关卡缺少石头。现在让我们添加一个，让玩家去收集。为此，将项目面板（`Texture`文件夹）中的GemStone纹理拖放到场景2的最高边缘，这样玩家就必须爬上去才能拿到它（一个挑战！）。参见*图6.41*。务必将一个**圆形碰撞体**触发器附加到该对象上，以便它能够与玩家发生碰撞。
- en: '![Code Sample 6.8](img/figure_06_41.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例6.8](img/figure_06_41.jpg)'
- en: 'Figure 6.41: Creating a Quest object'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.41：创建任务对象
- en: 'Finally, we''ll need a `QuestItem` script to set the quest status on the `QuestManager`
    class when the item is collected, allowing `QuestGiver` to determine whether the
    gem has been collected the next time the player visits. The `QuestItem` script
    should be attached to the Gem object. Refer to the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`QuestItem`脚本，当收集到物品时在`QuestManager`类上设置任务状态，以便`QuestGiver`能够在玩家下次访问时确定宝石是否已被收集。`QuestItem`脚本应附加到宝石对象上。请参考以下代码：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is responsible for setting the quest status to completed
    when the gem (quest item) object is collected as the player enters the trigger
    volume. This happens through the `QuestManager` class.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码负责在玩家进入触发体积时，当收集到宝石（任务物品）对象时将任务状态设置为完成。这是通过`QuestManager`类实现的。
- en: 'Excellent work! You now have a completed integrated quest system and an NPC
    character. The complete files for this project can be found in the `Chapter06/End`
    folder. I highly recommend checking them out and playing the game. See *Figure
    6.42*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！你现在拥有了一个完整的集成任务系统和NPC角色。本项目的完整文件可以在`Chapter06/End`文件夹中找到。我强烈建议您查看它们并玩玩游戏。参见*图6.42*：
- en: '![Code Sample 6.8](img/figure_06_42.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例6.8](img/figure_06_42.jpg)'
- en: 'Figure 6.42: The completed game!'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.42：游戏完成！
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Great work! We''ve now completed the 2D adventure game. Some minor details
    were not covered in this chapter for the sake of clarity and conciseness because
    we''ve seen the methods or content already in earlier chapters. Hence, it''s important
    to open the course files and check out the completed project, seeing how the code
    works. Overall, in having reached this far in the book, you have three completed
    Unity projects to your name. So, in the next chapter, we''ll wrap up everything
    that we''ve seen so far and get started on the grand finale: the final, fourth
    project!'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们现在已经完成了2D冒险游戏。为了清晰和简洁，本章没有涵盖一些细节，因为我们已经在前面的章节中看到了这些方法或内容。因此，打开课程文件并查看完成的项目，了解代码是如何工作的，这一点很重要。总的来说，在本书中达到这一步，你已经拥有了三个完成的项目。所以，在下一章，我们将总结到目前为止所看到的一切，并开始最后的盛宴：第四个项目！
