- en: Chapter 11. Xamarin.Forms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。Xamarin.Forms
- en: 'Since the beginning of Xamarin''s lifetime as a company, their motto has always
    been to expose the native APIs on iOS and Android directly to C#. This was a great
    strategy at the beginning, because applications built with Xamarin.iOS or Xamarin.Android
    were pretty much indistinguishable from a native Objective-C or Java application.
    Code sharing was generally limited to non-UI code that left a potential gap to
    fill in the Xamarin ecosystem: a cross-platform UI abstraction. Xamarin.Forms
    is the solution to this problem, a cross-platform UI framework that renders native
    controls on each platform. Xamarin.Forms is a great solution for those who know
    C# (and XAML), but also might not want to get into the full details of using the
    native iOS and Android APIs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Xamarin作为公司开始以来，他们的座右铭一直是直接将iOS和Android的本地API暴露给C#。这是一个很好的策略，因为使用Xamarin.iOS或Xamarin.Android构建的应用程序几乎与本地Objective-C或Java应用程序无法区分。代码共享通常限于非UI代码，这可能在Xamarin生态系统中留下一个潜在的空白：一个跨平台UI抽象。Xamarin.Forms是解决这个问题的方案，这是一个跨平台UI框架，在每个平台上渲染本地控件。对于知道C#（和XAML）的人来说，Xamarin.Forms是一个很好的解决方案，但也可能不想深入了解使用本地iOS和Android
    API的细节。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Create "Hello World" in Xamarin.Forms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中创建“Hello World”
- en: Discuss Xamarin.Forms architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Xamarin.Forms架构
- en: Use XAML with Xamarin.Forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XAML与Xamarin.Forms
- en: Cover data binding and MVVM with Xamarin.Forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Xamarin.Forms实现数据绑定和MVVM
- en: Creating Hello World in Xamarin.Forms
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Xamarin.Forms中创建“Hello World”
- en: To understand how a Xamarin.Forms application is put together, let's begin by
    creating a simple "Hello World" application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Xamarin.Forms应用程序是如何组合的，让我们先创建一个简单的“Hello World”应用程序。
- en: 'Open Xamarin Studio and perform the following steps:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Xamarin Studio并执行以下步骤：
- en: Create a new solution.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的解决方案。
- en: Navigate to the **C#** | **Mobile Apps** section.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航到**C#** | **移动应用**部分。
- en: Create a new **Blank App (Xamarin.Forms Portable)** solution.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的**空白应用（Xamarin.Forms Portable）**解决方案。
- en: Name your solution something appropriate such as `HelloForms`.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的解决方案命名为合适的名称，例如`HelloForms`。
- en: 'Notice the three new projects that were successfully created: `HelloForms`,
    `HelloForms.Android`, and `HelloForms.iOS`. In Xamarin.Forms applications, the
    bulk of your code will be shared, and each platform-specific project is just a
    small amount of code that starts the Xamarin.Forms framework.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意成功创建的三个新项目：`HelloForms`、`HelloForms.Android`和`HelloForms.iOS`。在Xamarin.Forms应用程序中，你大部分的代码将是共享的，而每个平台特定项目只是启动Xamarin.Forms框架的一小部分代码。
- en: 'Let''s examine the minimal parts of a Xamarin.Forms application:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查Xamarin.Forms应用程序的最小部分：
- en: '`App.cs` in the `HelloForms` PCL library. This class holds the startup page
    of the Xamarin.Forms application. A simple static method, `GetMainPage()`, returns
    the startup page of the application. In the default project template,'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`HelloForms` PCL库中的`App.cs`。这个类包含Xamarin.Forms应用程序的启动页面。一个简单的静态方法`GetMainPage()`返回应用程序的启动页面。在默认项目模板中，
- en: A `ContentPage` is created with a single label that will be rendered as a `UILabel`
    on iOS and a `TextView` on Android.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个带有单个标签的`ContentPage`，在iOS上渲染为`UILabel`，在Android上渲染为`TextView`。
- en: '`MainActivity.cs` in the `HelloForms.Android` Android project. This is the
    main launcher activity of the Android application. The important part for Xamarin.Forms
    here is the call to `Forms.Init(this, bundle)` that initializes the Android-specific
    portion of the Xamarin.Forms framework. Next is a call to `SetPage(App.GetMainPage())`
    that displays the native version of the main Xamarin.Forms page.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`HelloForms.Android` Android项目中，`MainActivity.cs`。这是Android应用程序的主要启动活动。对于Xamarin.Forms来说，这里重要的是对`Forms.Init(this,
    bundle)`的调用，它初始化了Xamarin.Forms框架的Android特定部分。接下来是对`SetPage(App.GetMainPage())`的调用，它显示主Xamarin.Forms页面的本地版本。
- en: '`AppDelegate.cs` in the `HelloForms.iOS` iOS project. This is very similar
    to Android, except iOS applications startup via a `UIApplicationDelegate` class.
    `Forms.Init()` will initialize the iOS-specific parts of Xamarin.Forms, while
    `App.GetMainPage().CreateViewController()` will generate a native controller that
    can be used as the `RootViewController` of the main window of the application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`HelloForms.iOS` iOS项目中的`AppDelegate.cs`。这与Android非常相似，只是iOS应用程序通过`UIApplicationDelegate`类启动。`Forms.Init()`将初始化Xamarin.Forms的iOS特定部分，而`App.GetMainPage().CreateViewController()`将生成一个可以用于应用程序主窗口的`RootViewController`的本地控制器。
- en: 'Go ahead and run the iOS project; you should see something similar to the following
    screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行iOS项目；你应该能看到以下截图类似的内容：
- en: '![Creating Hello World in Xamarin.Forms](img/00085.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xamarin.Forms 中创建 Hello World](img/00085.jpeg)'
- en: 'If you run the Android project, you will get a UI very similar to the iOS,
    but using the native Android controls, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行 Android 项目，您将得到一个非常类似于 iOS 的 UI，但使用的是原生 Android 控件，如下面的截图所示：
- en: '![Creating Hello World in Xamarin.Forms](img/00086.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xamarin.Forms 中创建 Hello World](img/00086.jpeg)'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Even though not covered in this book, Xamarin.Forms also supports Windows Phone
    applications. However, a PC running Windows and Visual Studio is required to develop
    for Windows Phone. If you can get a Xamarin.Forms application working on iOS and
    Android, then getting a Windows Phone version working should be a piece of cake.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书没有涉及，但 Xamarin.Forms 也支持 Windows Phone 应用程序。然而，要为 Windows Phone 开发，需要一个运行
    Windows 和 Visual Studio 的 PC。如果您能让一个 Xamarin.Forms 应用程序在 iOS 和 Android 上运行，那么让
    Windows Phone 版本运行应该易如反掌。
- en: Understanding the architecture behind Xamarin.Forms
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Xamarin.Forms 背后的架构
- en: Getting started with Xamarin.Forms is very easy, but it is always good to look
    behind the curtain to understand what is happening behind the scenes. In the earlier
    chapters of this book, we created a cross-platform application using native iOS
    and Android APIs directly. Certain applications are much more suited for this
    development approach, so understanding the difference between a Xamarin.Forms
    application and a plain Xamarin application is important to know when choosing
    what framework is best suited for your app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Xamarin.Forms 非常简单，但总是好的，看看幕后发生了什么，以了解幕后发生的事情。在这本书的早期章节中，我们使用原生 iOS 和 Android
    API 直接创建了一个跨平台应用程序。某些应用程序更适合这种开发方法，因此了解 Xamarin.Forms 应用程序和纯 Xamarin 应用程序之间的区别对于选择最适合您应用程序的框架非常重要。
- en: Xamarin.Forms is an abstraction over the native iOS and Android APIs that you
    can call directly from C#. So, Xamarin.Forms is using the same APIs you would
    in a plain Xamarin application, while providing a framework that allows you to
    define your UIs in a cross-platform way. An abstraction layer such as this is
    in many ways a very good thing because it gives you the benefit of sharing the
    code driving your UI as well as any backend C# code that could have also been
    shared in a standard Xamarin app. The main disadvantage, however, is a slight
    hit in performance and being limited by the Xamarin.Forms framework as far as
    what types of controls are available. Xamarin.Forms also gives the option of writing
    **renderers** that allow you to override your UI in a platform-specific way. However,
    in my opinion, renderers are still somewhat limited in what can be achieved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms 是一个在原生 iOS 和 Android API 之上的抽象层，您可以直接从 C# 中调用。因此，Xamarin.Forms
    使用与纯 Xamarin 应用程序相同的 API，同时提供了一个框架，允许您以跨平台的方式定义您的 UI。这种抽象层在许多方面是非常好的，因为它让您能够共享驱动
    UI 的代码以及任何可能也在标准 Xamarin 应用程序中共享的后端 C# 代码。然而，主要的缺点是性能略有下降，并且受限于 Xamarin.Forms
    框架，在可用的控件类型方面有所限制。Xamarin.Forms 还提供了编写 **渲染器** 的选项，允许您以特定平台的方式覆盖您的 UI。然而，在我看来，渲染器的功能仍然相对有限。
- en: 'See the difference in a Xamarin.Forms application and a traditional Xamarin
    app in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中查看 Xamarin.Forms 应用程序与传统 Xamarin 应用程序之间的区别：
- en: '![Understanding the architecture behind Xamarin.Forms](img/00087.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![理解 Xamarin.Forms 背后的架构](img/00087.jpeg)'
- en: In both the applications, the business logic and backend code of the application
    can be shared, but Xamarin.Forms gives you an enormous benefit by allowing your
    UI code to be shared as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个应用程序中，应用程序的业务逻辑和后端代码可以共享，但 Xamarin.Forms 通过允许共享 UI 代码为您提供了巨大的好处。
- en: 'Additionally, Xamarin.Forms applications have two project templates to choose
    from, so let''s cover each option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Xamarin.Forms 应用程序有两个项目模板可供选择，因此让我们分别介绍每个选项：
- en: '**Xamarin.Forms Shared**: This creates a shared project with all of your Xamarin.Forms
    code, an iOS project, and an Android project.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xamarin.Forms 共享**：这会创建一个包含所有您的 Xamarin.Forms 代码、iOS 项目和 Android 项目的共享项目。'
- en: '**Xamarin.Forms Portable**: This creates a portable class library that contains
    all the shared Xamarin.Forms code, an iOS project, and an Android project.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xamarin.Forms 可移植**：这会创建一个包含所有共享 Xamarin.Forms 代码、iOS 项目和 Android 项目的可移植类库。'
- en: In general, both the options will work fine for any application. Shared projects
    are basically a collection of code files that get added automatically to another
    project referencing it. Using a shared project allows you to use preprocessor
    statements to implement platform-specific code. Portable class library projects,
    on the other hand, create a portable .NET assembly that can be used on iOS, Android,
    and various other platforms. PCLs can't use preprocessor statements, so you generally
    set up platform-specific code with an interface or abstract/base classes. In most
    cases, I think a portable class library is a better option since it inherently
    encourages better programming practices. You can refer to [Chapter 3](part0029_split_000.html#page
    "Chapter 3. Code Sharing between iOS and Android"), *Code Sharing between iOS
    and Android*, for details on the advantages and disadvantages of these two code-sharing
    techniques.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这两种选项对任何应用程序都适用。共享项目基本上是一组代码文件集合，这些文件会自动添加到引用它的另一个项目中。使用共享项目允许您使用预处理器语句来实现平台特定代码。另一方面，可移植类库项目创建了一个可移植的
    .NET 程序集，可以在 iOS、Android 和各种其他平台上使用。PCL 不能使用预处理器语句，因此您通常使用接口或抽象/基类设置平台特定代码。在大多数情况下，我认为可移植类库是一个更好的选择，因为它本质上鼓励更好的编程实践。您可以参考
    [第 3 章](part0029_split_000.html#page "第 3 章。iOS 和 Android 之间的代码共享")，*iOS 和 Android
    之间的代码共享*，以了解这两种代码共享技术的优缺点。
- en: Using XAML in Xamarin.Forms
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XAML 在 Xamarin.Forms 中
- en: In addition to defining Xamarin.Forms controls from C# code, Xamarin has provided
    the tool to develop your UI in **Extensible Application Markup Language** (**XAML**).
    XAML is a declarative language that is basically a set of XML elements that map
    to a certain control in the Xamarin.Forms framework. Using XAML is comparable
    to what you would think of using HTML to define the UI on a web page, with the
    exception that XAML in Xamarin.Forms creates C# objects that represent a native
    UI.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从 C# 代码中定义 Xamarin.Forms 控件外，Xamarin 还提供了使用 **可扩展应用程序标记语言** (**XAML**) 开发
    UI 的工具。XAML 是一种声明性语言，基本上是一组映射到 Xamarin.Forms 框架中特定控件的 XML 元素。使用 XAML 与您认为使用 HTML
    定义网页 UI 相似，但区别在于 Xamarin.Forms 中的 XAML 创建代表原生 UI 的 C# 对象。
- en: 'To understand how XAML works in Xamarin.Forms, let''s create a new page with
    lots of UI on it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 XAML 在 Xamarin.Forms 中的工作原理，让我们创建一个带有许多 UI 元素的新页面：
- en: Create a new Xamarin.Forms Portable solution by navigating to **C#** | **Mobile
    Apps** | **Blank App (Xamarin.Forms Portable)**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **C#** | **移动应用** | **空白应用 (Xamarin.Forms Portable)** 创建一个新的 Xamarin.Forms
    Portable 解决方案。
- en: Name the project something appropriate such as `UIDemo`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为合适的名称，例如 `UIDemo`。
- en: Add a new file by navigating to the **Forms** | **Forms ContentPage XAML** item
    template. Name the page `UIDemoPage`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 **Forms** | **Forms ContentPage XAML** 项模板添加一个新文件。将页面命名为 `UIDemoPage`。
- en: Open `UIDemoPage.xaml`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `UIDemoPage.xaml`。
- en: 'Now, let''s edit the XAML code. Add the following XAML code between the `<ContentPage.Content>`
    tag:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑 XAML 代码。在 `<ContentPage.Content>` 标签之间添加以下 XAML 代码：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Go ahead and run the application on iOS and Android. Your application will
    look something like the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 和 Android 上运行应用程序。您的应用程序将类似于以下截图：
- en: '![Using XAML in Xamarin.Forms](img/00088.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xamarin.Forms 中使用 XAML](img/00088.jpeg)'
- en: 'Then, on Android, Xamarin.Forms will render the screen in the same way, but
    with the native Android controls:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 Android 上，Xamarin.Forms 将以相同的方式渲染屏幕，但使用原生 Android 控件：
- en: '![Using XAML in Xamarin.Forms](img/00089.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![在 Xamarin.Forms 中使用 XAML](img/00089.jpeg)'
- en: First, we created a `StackLayout` control, which is a container for other controls.
    It can layout controls either vertically or horizontally one by one as defined
    by the `Orientation` value. We also applied a padding of 10 around the sides and
    bottom, and 20 from the top to adjust the iOS status bar. You might be familiar
    with this syntax for defining rectangles if you are familiar with WPF or Silverlight.
    Xamarin.Forms uses the same syntax of the left, top, right, and bottom values
    delimited by commas.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个 `StackLayout` 控件，这是一个其他控件的容器。它可以根据 `Orientation` 值垂直或水平逐个布局控件。我们还为侧面和底部添加了
    10 像素的填充，以及从顶部到 iOS 状态栏的 20 像素填充，以调整 iOS 状态栏。如果您熟悉 WPF 或 Silverlight 中的矩形定义语法，您可能对这种语法很熟悉。Xamarin.Forms
    使用相同的语法，即由逗号分隔的左、上、右和底部值。
- en: 'We also used several of the built-in Xamarin.Forms controls to see how they
    work:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了几个内置的 Xamarin.Forms 控件来查看它们的工作方式：
- en: '`Label`: We used this earlier in the chapter. This is used only to display
    the text. This maps to a `UILabel` on iOS and a `TextView` on Android.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Label`：我们在本章前面已经使用过这个控件。它仅用于显示文本。在 iOS 上对应于 `UILabel`，在 Android 上对应于 `TextView`。'
- en: '`Button`: This is a general purpose button that can be tapped by a user. This
    control maps to a `UIButton` on iOS and a `Button` on Android.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Button`：这是一个通用按钮，用户可以点击。这个控件在 iOS 上对应于 `UIButton`，在 Android 上对应于 `Button`。'
- en: '`Entry`: This control is a single-line text entry. It maps to a `UITextField`
    on iOS and an `EditText` on Android.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Entry`：这个控件是一个单行文本输入。在 iOS 上对应于 `UITextField`，在 Android 上对应于 `EditText`。'
- en: '`Image`: This is a simple control to display an image on the screen, which
    maps to a `UIImage` on iOS and an `ImageView` on Android. We used the `Source`
    property of this control that loads an image from the `Resources` folder on iOS
    and the `Resources/drawable` folder on Android. You can also set URLs on this
    property, but it is best to include the image in your project for the performance.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Image`：这是一个简单的控件，用于在屏幕上显示图像，在 iOS 上对应于 `UIImage`，在 Android 上对应于 `ImageView`。我们使用了这个控件的
    `Source` 属性，从 iOS 的 `Resources` 文件夹和 Android 的 `Resources/drawable` 文件夹加载图像。你也可以在这个属性上设置
    URL，但最好是将图像包含在你的项目中以提高性能。'
- en: '`Switch`: This is an on/off switch or a toggle button. It maps to a `UISwitch`
    on iOS and a `Switch` on Android.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Switch`：这是一个开关或切换按钮。在 iOS 上对应于 `UISwitch`，在 Android 上对应于 `Switch`。'
- en: '`Stepper`: This is a general-purpose input to enter numbers via two plus and
    minus buttons. On iOS, this maps to a `UIStepper`, while on Android Xamarin.Forms
    implements this functionality with two `Button`.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stepper`：这是一个通用输入，可以通过两个加号和减号按钮输入数字。在 iOS 上，这对应于 `UIStepper`，而在 Android 上，Xamarin.Forms
    使用两个 `Button` 来实现这个功能。'
- en: This is just some of the controls provided by Xamarin.Forms. There are also
    more complicated controls such as the `ListView` and `TableView` you would expect
    to develop mobile UIs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Xamarin.Forms 提供的一些控件中的一部分。还有更多复杂的控件，如你期望用于开发移动 UI 的 `ListView` 和 `TableView`。
- en: 'Even though we used XAML in this example, you can also implement this Xamarin.Forms
    page from C#. Here is an example of what this would look like:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中我们使用了 XAML，但你也可以用 C# 实现这个 Xamarin.Forms 页面。下面是一个这样的例子：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So you can see that using XAML can be a bit more readable and is generally a
    bit better at declaring UIs. However, using C# to define your UIs is still a viable,
    straightforward approach.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到使用 XAML 可以使代码更易读，并且通常在声明 UI 方面表现得更好。然而，使用 C# 来定义你的 UI 仍然是一个可行且直接的方法。
- en: Using data binding and MVVM
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据绑定和 MVVM
- en: At this point, you should be grasping the basics of Xamarin.Forms, but you may
    be wondering how the MVVM design pattern fits into the picture. The MVVM design
    pattern was originally conceived for its use along with XAML and the powerful
    data binding features XAML provides, so it is only natural that it is a perfect
    design pattern to be used with Xamarin.Forms.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经掌握了 Xamarin.Forms 的基础知识，但你可能想知道 MVVM 设计模式如何融入其中。MVVM 设计模式最初是为了与 XAML
    和 XAML 提供的强大数据绑定功能一起使用而构思的，因此它自然是一个与 Xamarin.Forms 一起使用的完美设计模式。
- en: 'Let''s cover the basics of how data binding and MVVM is set up with Xamarin.Forms:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何使用 Xamarin.Forms 设置数据绑定和 MVVM 的基本知识：
- en: Your Model and ViewModel layers will remain mostly unchanged from the MVVM pattern
    we covered earlier in the book.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的模型和视图模型层将主要保持与本书前面介绍的 MVVM 模式不变。
- en: Your ViewModel layer should implement the `INotifyPropertyChanged` interface,
    which facilitates data binding. To simplify things in Xamarin.Forms, you can use
    the `BindableObject` base class and call `OnPropertyChanged` when the values change
    on your ViewModel.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的视图模型层应该实现 `INotifyPropertyChanged` 接口，这有助于数据绑定。为了简化 Xamarin.Forms，你可以使用 `BindableObject`
    基类，并在视图模型中的值发生变化时调用 `OnPropertyChanged`。
- en: Any page or control in Xamarin.Forms has a `BindingContext` property, which
    is the object that it is data bound to. In general, you can set a corresponding
    ViewModel to each view's `BindingContext` property.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xamarin.Forms 中，任何页面或控件都有一个 `BindingContext` 属性，它是与之数据绑定的对象。通常，你可以将相应的视图模型设置为每个视图的
    `BindingContext` 属性。
- en: In XAML, you can set up data binding using the syntax of the form `Text="{Binding
    Name}"`. This example will bind the Text property of the control to a Name property
    of the object residing in the `BindingContext`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XAML 中，你可以使用如下形式的语法 `Text="{Binding Name}"` 来设置数据绑定。这个例子将控件的 Text 属性绑定到 `BindingContext`
    中对象的 Name 属性。
- en: In conjunction with data binding, events can be translated to commands using
    the `ICommand` interface. So, for example, a button's click event can be data
    bound to a command exposed by a ViewModel. There is a built-in `Command` class
    in Xamarin.Forms to support this.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合数据绑定，事件可以通过 `ICommand` 接口转换为命令。例如，一个按钮的点击事件可以绑定到由 ViewModel 提供的命令。Xamarin.Forms
    中有一个内置的 `Command` 类来支持这一点。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Data binding can also be set up from C# code in Xamarin.Forms via the `Binding`
    class. However, it is generally much easier to set up bindings from XAML, since
    the syntax has been simplified there.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin.Forms 中，也可以通过 `Binding` 类从 C# 代码设置数据绑定。然而，通常从 XAML 设置绑定要简单得多，因为那里的语法已经被简化了。
- en: Now that we have covered the basics, let's go through it step by step and partially
    convert our XamChat sample application discussed earlier in the book to use Xamarin.Forms.
    For the most part, we can reuse most of the Model and ViewModel layers, although
    we will have to make a few minor changes to support data binding from XAML.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了基础知识，让我们一步一步地来，并将之前在书中讨论的 XamChat 示例应用程序部分转换为使用 Xamarin.Forms。大部分情况下，我们可以重用大部分的
    Model 和 ViewModel 层，尽管我们需要进行一些小的修改以支持从 XAML 的数据绑定。
- en: 'Let''s begin by creating a new Xamarin.Forms application backed by a PCL named
    `XamChat`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `XamChat` 的 PCL 支持的新 Xamarin.Forms 应用程序开始：
- en: First, create three folders in the `XamChat` project named `Views`, `ViewModels`,
    and `Models`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `XamChat` 项目中创建三个文件夹，分别命名为 `Views`、`ViewModels` 和 `Models`。
- en: Add the appropriate `ViewModels` and `Models` classes from the XamChat application
    in the earlier chapter. These are found in the `XamChat.Core` project.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前章节中 XamChat 应用程序中添加适当的 `ViewModels` 和 `Models` 类。这些在 `XamChat.Core` 项目中可以找到。
- en: Build the project and just make sure that everything is saved. You will get
    a few compiler errors that we will resolve shortly.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并确保所有内容都已保存。你将得到一些编译错误，我们将在稍后解决。
- en: 'The first class that we will need to edit is the `BaseViewModel` class. Open
    it and make the following changes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑的第一个类是 `BaseViewModel` 类。打开它并做出以下更改：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First of all, we removed the calls to the `ServiceContainer` class, because
    Xamarin.Forms provides its own IoC container called `DependencyService`. It functions
    very similar to the container we built in the previous chapters, except that it
    only has one method, `Get<T>`, and the registrations are set up via an assembly
    attribute that we will set up shortly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们移除了对 `ServiceContainer` 类的调用，因为 Xamarin.Forms 提供了自己的 IoC 容器，称为 `DependencyService`。它的工作方式与我们在上一章中构建的容器非常相似，但它只有一个方法，即
    `Get<T>`，并且注册是通过我们将要设置的程序集属性来设置的。
- en: Additionally, we removed the `IsBusyChanged` event in favor of the `INotifyPropertyChanged`
    interface that supports data binding. Inheriting from `BindableObject` gives us
    the helper method, `OnPropertyChanged`, which we use to inform bindings that the
    value has changed in Xamarin.Forms. Notice that we didn't pass `string`, which
    contains the property name, to `OnPropertyChanged`. This method uses a lesser-known
    feature of .NET 4.0 called `CallerMemberName`, which will automatically fill in
    the calling property's name at runtime.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们移除了 `IsBusyChanged` 事件，转而使用支持数据绑定的 `INotifyPropertyChanged` 接口。从 `BindableObject`
    继承给我们一个辅助方法 `OnPropertyChanged`，我们使用它来通知绑定在 Xamarin.Forms 中值已更改。请注意，我们没有将包含属性名的
    `string` 传递给 `OnPropertyChanged`。此方法使用 .NET 4.0 的一个不太为人所知的功能 `CallerMemberName`，该功能将在运行时自动填充调用属性的名称。
- en: 'Next, let''s set up our required services with `DependencyService`. Open `App.cs`
    in the root of the PCL project, and add the following two lines above the namespace
    declaration:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `DependencyService` 设置所需的服务。在 PCL 项目的根目录中打开 `App.cs` 文件，并在命名空间声明之上添加以下两行：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`DependencyService` will automatically pick up these attributes and inspect
    the types that we declared. Any interfaces that these types implement will be
    returned for any future callers of `DependencyService.Get<T>`. I normally put
    all `Dependency` declarations in the `App.cs` file so that they are easy to manage
    and in one place.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`DependencyService` 将会自动获取这些属性并检查我们声明的类型。这些类型实现的任何接口都将被返回给任何未来调用 `DependencyService.Get<T>`
    的调用者。我通常将所有的 `Dependency` 声明放在 `App.cs` 文件中，以便于管理和集中处理。'
- en: 'Next, let''s modify `LoginViewModel` by adding a new property:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过添加一个新属性来修改 `LoginViewModel`：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ll use this shortly to data bind a button''s command. One last change in
    the View Model layer is to set up `INotifyPropertyChanged` for the `MessageViewModel`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快使用这个来绑定按钮的命令。在 ViewModel 层的最后一个小改动是为 `MessageViewModel` 设置 `INotifyPropertyChanged`：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Likewise, you can repeat this pattern for the remaining public properties throughout
    the ViewModel layer, but this is all that we will need for this example. Next,
    let''s create a new `Foms ContentPage Xaml` item under the `Views` folder named
    `LoginPage`. In the code-behind file `LoginPage.xaml.cs`, we''ll just need to
    make a few changes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以重复这个模式来处理 ViewModel 层中剩余的公共属性，但在这个例子中我们只需要这些。接下来，在 `Views` 文件夹下创建一个新的
    `Foms ContentPage Xaml` 项目，命名为 `LoginPage`。在 `LoginPage.xaml.cs` 代码背后文件中，我们只需做一些修改：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We did a few important things here, including setting the `BindingContext` to
    our `LoginViewModel`. We set up `LoginCommand`, which basically invokes the `Login`
    method and displays a message if something goes wrong. It also navigates to a
    new page if successful. We also set the title, which will show up in the top navigation
    bar of the application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做了几件重要的事情，包括将 `BindingContext` 设置为我们的 `LoginViewModel`。我们设置了 `LoginCommand`，它基本上调用
    `Login` 方法，如果出现问题则显示消息。如果成功，它还会导航到新页面。我们还设置了标题，这将在应用程序的顶部导航栏中显示。
- en: 'Next, open `LoginPage.xaml`, and we''ll add the following XAML code inside
    the content page''s content:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 `LoginPage.xaml`，我们将在内容页的内容中添加以下 XAML 代码：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will set up the basics of two text fields, a button, and a spinner complete
    with all the bindings to make everything work. Since we set up the `BindingContext`
    from the `LoginPage` code behind, all the properties are bound to the `LoginViewModel`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置两个文本字段、一个按钮和一个带有所有绑定以使一切正常工作的旋转按钮的基本设置。由于我们从 `LoginPage` 代码背后设置了 `BindingContext`，所以所有属性都绑定到了
    `LoginViewModel`。
- en: 'Next, create `ConversationsPage` as a XAML page as we did earlier, and edit
    the `ConversationsPage.xaml.cs` code behind:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `ConversationsPage` 的 XAML 页面，就像我们之前做的那样，并编辑其背后的 `ConversationsPage.xaml.cs`
    代码：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we repeated a lot of the same steps. The exception is that we
    used the `Appearing` event as a way to load the conversations to display on the
    screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们重复了很多相同的步骤。例外的是，我们使用了 `Appearing` 事件作为加载屏幕上显示的对话的方式。
- en: 'Now let''s add the following XAML code to `ConversationsPage.xaml`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下 XAML 代码添加到 `ConversationsPage.xaml` 中：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we used `ListView` to data bind a list of items and display
    on the screen. We defined a `DataTemplate` class that represents a set of cells
    for each item in the list that `ItemsSource` is data bound to. In our case, a
    `TextCell` displaying the `Username` is created for each item in the `Conversations`
    list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `ListView` 来绑定一个项目列表并在屏幕上显示。我们定义了一个 `DataTemplate` 类，它代表了一个集合，用于表示
    `ItemsSource` 绑定到的列表中的每个项目的单元格。在我们的例子中，为 `Conversations` 列表中的每个项目创建了一个显示 `Username`
    的 `TextCell`。
- en: 'Last but not least, we must return to the `App.cs` file and modify the startup
    page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们必须回到 `App.cs` 文件并修改启动页面：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used `NavigationPage` here so that Xamarin.Forms can push and pop between
    different pages. This uses a `UINavigationController` on iOS so you can see how
    the native APIs are being used on each platform.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了 `NavigationPage`，这样 Xamarin.Forms 就可以在不同的页面之间推送和弹出。这在 iOS 上使用 `UINavigationController`，这样你就可以看到每个平台上如何使用原生
    API。
- en: 'At this point, if you compile and run the application, you will get a functional
    iOS and an Android application that can login and view a list of conversations:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你编译并运行应用程序，你将得到一个功能齐全的 iOS 和 Android 应用程序，它可以登录并查看对话列表：
- en: '![Using data binding and MVVM](img/00090.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用数据绑定和 MVVM](img/00090.jpeg)'
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of Xamarin.Forms and learned how it can
    be very useful to build your own cross-platform applications. Xamarin.Forms shines
    for certain types of apps, but can be limiting if you need to write more complicated
    UIs or take advantage of native drawing APIs. We discovered how to use XAML to
    declare our Xamarin.Forms UIs and understood how Xamarin.Forms controls are rendered
    on each platform. We also dived into the concepts of data binding and discovered
    how to use the MVVM design pattern with Xamarin.Forms. Last but not least, we
    began porting the XamChat application that was discussed earlier in the book to
    Xamarin.Forms and we were able to reuse most of the backend code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Xamarin.Forms的基础知识，并学习了它如何非常有用，可以用来构建自己的跨平台应用程序。Xamarin.Forms在某些类型的应用程序中表现出色，但如果需要编写更复杂的UI或利用原生绘图API，可能会受到限制。我们发现了如何使用XAML来声明我们的Xamarin.Forms
    UI，并理解了Xamarin.Forms控件在每个平台上是如何渲染的。我们还深入探讨了数据绑定的概念，并发现了如何使用MVVM设计模式与Xamarin.Forms结合。最后但同样重要的是，我们开始将书中之前讨论过的XamChat应用程序移植到Xamarin.Forms，并且能够重用大部分后端代码。
