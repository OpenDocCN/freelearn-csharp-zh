- en: 7\. Creating Modern Web Applications with ASP.NET
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 使用 ASP.NET 创建现代 Web 应用程序
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概览
- en: There are many types of applications in use nowadays and web apps top the list
    of the most used ones. In this chapter, you will be introduced to ASP.NET, a web
    framework built with C# and the .NET runtime, made to create web apps with ease.
    You will also learn the anatomy of a basic ASP.NET application, web application
    development approaches such as server-side rendering and single-page applications,
    and how C# helps implement these approaches to build safe, performant, and scalable
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多类型的应用程序在使用中，Web 应用程序是其中使用最广泛的一种。在本章中，你将介绍 ASP.NET，这是一个用 C# 和 .NET 运行时构建的
    Web 框架，旨在轻松创建 Web 应用程序。你还将了解基本 ASP.NET 应用程序的解剖结构、Web 应用程序开发方法，如服务器端渲染和单页应用程序，以及
    C# 如何帮助实现这些方法来构建安全、高效和可扩展的应用程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In *Chapter 1*, *Hello C#*, you learned that .NET is what brings C# to life,
    as it contains both a Software Development Kit (SDK) used to build your code and
    a runtime that executes the code. In this chapter, you will learn about ASP.NET,
    which is an open-source and cross-platform framework embedded within the .NET
    runtime. It is used for building applications for both frontend and backend applications
    for web, mobile, and IoT devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 1 章*，*你好 C#* 中，你了解到 .NET 是使 C# 生机勃勃的东西，因为它包含用于构建你的代码的软件开发工具包 (SDK) 和执行代码的运行时。在本章中，你将了解
    ASP.NET，它是一个嵌入在 .NET 运行时中的开源和跨平台框架。它用于构建 Web、移动和物联网设备的客户端和后端应用程序。
- en: It is a complete toolbox for these kinds of development, as it provides several
    built-in features, such as lightweight and customizable HTTP pipelines, dependency
    injection, and support for modern hosting technologies, such as containers, web
    UI pages, routing, and APIs. A well-known example is Stack Overflow; its architecture
    is built entirely on top of ASP.NET.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这类开发的完整工具箱，因为它提供了几个内置功能，例如轻量级和可定制的 HTTP 管道、依赖注入以及对现代托管技术（如容器、Web UI 页面、路由和
    API）的支持。一个著名的例子是 Stack Overflow；其架构完全建立在 ASP.NET 之上。
- en: The focus of this chapter is to acquaint you with the fundamentals of ASP.NET
    and to give you both an introduction and an end-to-end overview of web application
    development with Razor Pages, a built-in toolbox included in ASP.NET to build
    web apps.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是使你熟悉 ASP.NET 的基础知识，并为你提供对使用 Razor Pages 进行 Web 应用程序开发的介绍和端到端概述，Razor Pages
    是 ASP.NET 中内置的工具箱，用于构建 Web 应用程序。
- en: Anatomy of an ASP.NET Web App
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Web 应用的解剖结构
- en: You'll begin this chapter by creating a new Razor Pages application with ASP.NET.
    It is just one of the various types of apps that can be created with ASP.NET but
    will be an effective starting point as it shares and showcases a lot of commonalities
    with other web application types that can be built with the framework.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从这个章节开始，使用 ASP.NET 创建一个新的 Razor Pages 应用程序。它只是可以使用 ASP.NET 创建的多种应用程序类型之一，但将是一个有效的起点，因为它与其他可以使用该框架构建的
    Web 应用程序类型共享并展示了许多共同点。
- en: 'To create a new Razor Pages app, enter the following commands in the CLI:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的 Razor Pages 应用程序，请在 CLI 中输入以下命令：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here you are creating a to-do list application with Razor Pages. Once the preceding
    command is executed, you will see a folder with the following structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用 Razor Pages 创建一个待办事项列表应用程序。一旦执行了前面的命令，你将看到一个具有以下结构的文件夹：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Open the root folder in Visual Studio Code.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开根文件夹。
- en: 'There are some files inside these folders that will be covered in the upcoming
    sections. For now, consider this structure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹中的一些文件将在接下来的章节中介绍。现在，请考虑以下结构：
- en: '`bin` is the folder where the final binaries go after the application is built.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bin` 是在应用程序构建后放置最终二进制文件的文件夹。'
- en: '`obj` is the folder where the compiler places intermediate outputs during the
    build process.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj` 是在构建过程中编译器放置中间输出的文件夹。'
- en: '`Pages` is the folder where the application Razor Pages will be placed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pages` 是放置应用程序 Razor Pages 的文件夹。'
- en: '`Properties` is a folder containing the `launchSettings.json` file, a file
    where the run configurations are placed. In this file, you can define some configuration
    for local run i.e., environment variables and application ports.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Properties` 是包含 `launchSettings.json` 文件的文件夹，这是一个放置运行配置的文件。在此文件中，你可以定义一些本地运行的配置，例如环境变量和应用程序端口。'
- en: '`wwwroot` is the folder where all the static files of the application go.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wwwroot` 是放置应用程序所有静态文件的文件夹。'
- en: '`appsettings.json` is a configuration file.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.json` 是一个配置文件。'
- en: '`appsettings.Development.json` is a configuration file for the Development
    environment.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appsettings.Development.json` 是开发环境的配置文件。'
- en: '`Program.cs` is the program class that you have seen since *Chapter 1*, *Hello
    C#*. It is the entry point of an application.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Program.cs` 是自第 1 章“Hello C#”以来您所看到的程序类。它是应用程序的入口点。'
- en: Now that you know that in .NET 6.0, it is the `Program.cs` file, created at
    the root of the folder, that brings a `WebApplication` to life, you can begin
    to explore `Program.cs` in greater depth in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道在 .NET 6.0 中，位于文件夹根目录的 `Program.cs` 文件使 `WebApplication` 生命周期开始，您可以在下一节中更深入地探索
    `Program.cs`。
- en: Program.cs and the WebApplication
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Program.cs 和 WebApplication
- en: 'As mentioned earlier, `Program.cs` is the entry point of any C# application.
    In this section, you will see how a typical `Program` class is structured for
    an ASP.NET app. Consider the following example of `Program.cs`, which describes
    a very simple ASP.NET application:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Program.cs` 是任何 C# 应用程序的入口点。在本节中，您将了解一个典型的 ASP.NET 应用程序的 `Program` 类是如何构建的。以下是一个
    `Program.cs` 的示例，它描述了一个非常简单的 ASP.NET 应用程序：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing done here is the creation of a `WebApplicationBuilder` object.
    This object contains everything that's needed to bootstrap a basic Web Application
    in ASP.NET—Configuration, Logging, DI, and Service Registration, Middlewares,
    and other Host configurations. This Host is the one responsible for the lifetime
    management of a web application; they set up a web server and a basic HTTP pipeline
    to process HTTP requests.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里首先执行的是创建一个 `WebApplicationBuilder` 对象。该对象包含启动 ASP.NET 基本Web应用程序所需的一切——配置、日志记录、依赖注入、服务注册、中间件和其他主机配置。这个主机负责管理
    Web 应用程序的生命周期；它们设置一个 Web 服务器和一个基本的 HTTP 管道来处理 HTTP 请求。
- en: As you can see, it is quite impressive how, in a few lines of code, so many
    things can be done that enable you to run a well-structured web application. ASP.NET
    does all of that so that you can focus on providing value through the functionalities
    you will build.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过几行代码就能完成许多事情，这使您能够运行一个结构良好的 Web 应用程序，这非常令人印象深刻。ASP.NET 做所有这些是为了让您能够专注于通过您将要构建的功能提供价值。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bootstrap is a CSS library for the beautification of web content. You can know
    more about it at the official website.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 是一个用于美化网页内容的 CSS 库。您可以在官方网站上了解更多信息。
- en: Middlewares
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Think of middleware as small pieces of applications that connect to each other
    to form a pipeline for handling HTTP requests and responses. Each piece is a component
    that can do some work either before or after another component is executed on
    the pipeline. They are also linked to each other through a `next()` call, as shown
    in *Figure 7.1*:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将中间件想象成连接在一起的小型应用程序组件，以形成一个处理 HTTP 请求和响应的管道。每个组件都是一个可以在管道中执行其他组件之前或之后执行一些工作的组件。它们还通过
    `next()` 调用相互连接，如图 7.1 所示：
- en: '![Figure 7.1: The Middleware for an HTTP pipeline ](img/B16835_07_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：HTTP 管道的中间件](img/B16835_07_01.jpg)'
- en: 'Figure 7.1: The Middleware for an HTTP pipeline'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：HTTP 管道的中间件
- en: 'Middleware is a whole universe unto itself. The following list defines the
    salient features for building a web application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一个庞大的宇宙。以下列表定义了构建 Web 应用程序的主要特征：
- en: The order in which the middleware is placed matters. As they are chained one
    after another, the placement of each component impacts the way the pipeline is processed.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件的放置顺序很重要。由于它们一个接一个地链接，每个组件的放置都会影响管道的处理方式。
- en: The `before` logic, as shown in *Figure 7.1*, is executed until the endpoint
    is finally reached. Once the endpoint is reached, the pipeline continues to process
    the response using the `after` logic.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如图 7.1 所示，`before` 逻辑会一直执行，直到最终到达端点。一旦到达端点，管道将继续使用 `after` 逻辑处理响应。
- en: '`next()` is a method call that will execute the next middleware in the pipeline,
    before executing the `after` logic of the current middleware.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next()` 是一个方法调用，它将在执行当前中间件的 `after` 逻辑之前，执行管道中的下一个中间件。'
- en: In ASP.NET applications, middleware can be defined in the `Program.cs` file
    after the `WebApplicationBuilder` calls the `Build` method with a `WebApplication?`
    object as a result of this operation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 应用程序中，可以在 `WebApplicationBuilder` 使用 `WebApplication?` 对象作为结果调用 `Build`
    方法之后，在 `Program.cs` 文件中定义中间件。
- en: The application you created in the *Program.cs and the WebApplication* section,
    already contains a set of middlewares placed for new boilerplate Razor Pages applications
    that will be called sequentially when an **HTTP request** arrives.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Program.cs 和 WebApplication* 部分创建的应用程序中，已经包含了一组为新的样板 Razor Pages 应用程序预置的中间件，当
    **HTTP 请求** 到达时，这些中间件将按顺序被调用。
- en: This is easily configurable because the `WebApplication` object contains a generic
    `UseMiddleware<T>` method. This method allows you to create middleware to embed
    into the HTTP pipeline for requests and responses. When used within the `Configure`
    method, each time the application receives an incoming request, this request will
    go through all the middleware in the order the requests are placed within the
    `Configure` method. By default, ASP.NET provides basic error handling, `autoredirection`
    to HTTPS, and serves static files, along with some basic routing and authorization.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易配置，因为 `WebApplication` 对象包含一个通用的 `UseMiddleware<T>` 方法。此方法允许您创建中间件并将其嵌入到
    HTTP 管道中，用于请求和响应。当在 `Configure` 方法中使用时，每次应用程序收到一个传入请求，该请求将按照在 `Configure` 方法中放置请求的顺序通过所有中间件。默认情况下，ASP.NET
    提供基本的错误处理、自动重定向到 HTTPS、服务静态文件，以及一些基本的路由和授权。
- en: 'However, you might notice in your `Program.cs` file, of the *Program.cs and
    the WebApplication* section, there are no `UseMiddleware<>` calls. That''s because
    you can write extension methods to give a more concise name and readability to
    the code, and the ASP.NET framework already does it by default for some built-in
    middlewares. For instance, consider the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能会在 `Program.cs` 文件中注意到，在 *Program.cs 和 WebApplication* 部分没有 `UseMiddleware<>`
    调用。这是因为您可以编写扩展方法来给代码提供一个更简洁的名称和可读性，并且 ASP.NET 框架默认情况下已经为一些内置中间件做了这件事。例如，考虑以下示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, a sample of the built-in `UseHttpsRedirection` extension method is used
    for enabling a redirect middleware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用了内置的 `UseHttpsRedirection` 扩展方法的一个示例来启用重定向中间件。
- en: Logging
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: Logging might be understood as the simple process of writing everything that
    is done by an application to an output. This output might be the console application,
    a file, or even a third-party logging monitor application, such as the ELK Stack
    or Grafana. Logging has an important place in assimilating the behavior of an
    application, especially with regard to error tracing. This makes it an important
    concept to learn.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录可能被理解为将应用程序所做的一切都写入输出的简单过程。这个输出可能是控制台应用程序、文件，甚至是第三方日志监控应用程序，例如 ELK Stack
    或 Grafana。日志记录在理解应用程序行为方面占有重要位置，尤其是在错误跟踪方面。这使得它成为一个重要的概念需要学习。
- en: One thing that enables ASP.NET to be an effective platform for enterprise applications
    is its modularity. Since it is built on top of abstractions, any new implementation
    can be easily done without loading too much into the framework. The **logging**
    abstractions are some of these.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使 ASP.NET 成为有效企业应用平台的一个因素是其模块化。由于它是建立在抽象之上的，因此任何新的实现都可以轻松完成，而无需将太多内容加载到框架中。**日志记录**抽象就是这些之一。
- en: By default, the `WebApplication` object created in `Program.cs` adds some logging
    providers on top of these logging abstractions, which are `Console`, `Debug`,
    `EventSource`, and `EventLog`. The latter—`EventLog`—is an advanced feature specific
    to the Windows OS only. The focus here will be the `Console` logging provider.
    As the name suggests, this provider will output all the logged information to
    your application console. You'll learn more about it later in this section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Program.cs` 中创建的 `WebApplication` 对象在这些日志抽象之上添加了一些日志提供程序，它们是 `Console`、`Debug`、`EventSource`
    和 `EventLog`。后者——`EventLog`——是仅针对 Windows 操作系统的先进功能。这里的重点将是 `Console` 日志提供程序。正如其名所示，此提供程序将所有记录的信息输出到您的应用程序控制台。您将在本节后面的内容中了解更多关于它的信息。
- en: 'As logs basically write everything your application does, you might wonder
    whether these logs will end up being huge, especially for large-scale apps. They
    might be, but an important thing while writing application logs is to grasp the
    **severity** of the log. There might be some information that is crucial to log,
    such as an unexpected exception. There might also be information that you would
    only like to log to a development environment, to know some behaviors better.
    That said, a log in .NET has seven possible log levels, which are:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志基本上记录了应用程序所做的所有事情，你可能会想知道这些日志是否会变得非常大，尤其是对于大型应用程序。它们可能会，但在编写应用程序日志时，一个重要的事情是要掌握日志的**严重性**。可能有一些信息是至关重要的，例如意外的异常。也可能有一些信息你只想记录到开发环境中，以便更好地了解某些行为。话虽如此，.NET
    中的日志有七个可能的日志级别，它们是：
- en: '`Trace` = 0'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`跟踪` = 0'
- en: '`Debug` = 1'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调试` = 1'
- en: '`Information` = 2'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信息` = 2'
- en: '`Warning` = 3'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告` = 3'
- en: '`Error` = 4'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误` = 4'
- en: '`Critical` = 5'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关键` = 5'
- en: '`None` = 6'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`无` = 6'
- en: 'Which level is output to the provider is defined via variables set either as
    environment variables or via the `appSettings.json` file in the `Logging:LogLevel`
    section, as in the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到提供者的级别是通过设置环境变量或通过 `Logging:LogLevel` 部分中的 `appSettings.json` 文件来定义的，如下例所示：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this file, there are log categories, which are either the `Default` category
    or part of the namespace of the type that wants to set the log. That is exactly
    why these namespaces exist. For instance, you could set two different levels of
    logging for files inside the namespace.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件中，有日志类别，它们是 `默认` 类别或想要设置日志的类型命名空间的一部分。这正是这些命名空间存在的原因。例如，你可以在命名空间内部为文件设置不同的日志级别。
- en: In the preceding example configuration, the entire `ToDoListApp` is a set namespace
    to write logs only with `LogLevel` equal to or higher than `Warning`. You are
    also specifying that, for the `ToDoListApp.Pages` category/ namespace, the application
    will write all logs with a level equal to or higher than `Information`. This means
    that the changes on a more specific namespace override the settings that were
    set at a higher level.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例配置中，整个 `ToDoListApp` 是一个只使用 `LogLevel` 等于或高于 `Warning` 的 `LogLevel` 来记录日志的命名空间。你还指定了，对于
    `ToDoListApp.Pages` 类别/命名空间，应用程序将记录所有日志，其级别等于或高于 `Information`。这意味着在更具体的命名空间上的更改会覆盖在更高级别设置的设置。
- en: This section showed you how to configure log levels for an application. With
    this knowledge, you can now grasp the concept of DI, as discussed in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节向你展示了如何配置应用程序的日志级别。有了这些知识，你现在可以理解以下章节中讨论的 DI 概念。
- en: Dependency Injection
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: Dependency Injection (DI) is a technique supported natively by the ASP.NET framework.
    It is a form of achieving a famous concept in object-oriented programming called
    Inversion of Control (IoC).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是 ASP.NET 框架原生支持的技巧。它是实现面向对象编程中一个著名概念的一种形式，称为控制反转（IoC）。
- en: Any component that an object requires to function can be termed a dependency.
    In the case of a class, this might refer to parameters that need to be constructed.
    In the case of a method, it might be the method that parameters need for the execution.
    Using IoC with dependencies means delegating the responsibility of creating a
    class to the framework, instead of doing everything manually.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象需要以功能正常运作的组件都可以称为依赖项。在类的例子中，这可能会指需要构造的参数。在方法的例子中，这可能是参数执行所需的那个方法。使用 IoC
    和依赖项意味着将创建类的责任委托给框架，而不是手动完成所有事情。
- en: 'In *Chapter 2*, *Building Quality Object-Oriented Code*, you learned about
    interfaces. Interfaces are basically a common form of establishing a contract.
    They allow you to focus on what the outcome is of a call, rather than how it is
    executed. When you use IoC, your dependencies can now be interfaces instead of
    concrete classes. This allows your classes or methods to focus on the contracts
    established by these interfaces, instead of implementation details. This brings
    the following advantages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第2章*，*构建高质量的面向对象代码* 中，你学习了接口。接口基本上是建立契约的常见形式。它们允许你关注调用结果的输出，而不是执行方式。当你使用
    IoC 时，你的依赖项现在可以是接口而不是具体类。这允许你的类或方法专注于这些接口建立的契约，而不是实现细节。这带来了以下优势：
- en: You can easily replace implementations without affecting any class that depends
    on the contracts.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以轻松地替换实现，而不会影响任何依赖于这些契约的类。
- en: It decouples the application boundaries and modules, as the contracts usually
    do not need any hardened dependencies.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解耦了应用程序边界和模块，因为通常不需要任何硬编码的依赖项。
- en: It makes testing easier, allowing you to create these explicit dependencies
    as mocks, or fakes, and focus on behavior instead of real implementation details.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使测试变得更容易，允许你将这些显式依赖项作为模拟或伪造，并专注于行为而不是真实实现细节。
- en: Imagine now that to create the middleware of your application, you need to construct
    each of their dependencies, and you have a lot of middleware chained to each other
    on the constructor. Clearly, this would be a cumbersome process. Also, testing
    any of this middleware would be a tedious process, as you would need to rely on
    every single concrete implementation to create an object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在为了创建应用程序的中间件，你需要构建它们的每个依赖项，并且有很多中间件在构造函数中相互链接。显然，这将是一个繁琐的过程。此外，测试任何此类中间件都将是一个繁琐的过程，因为你需要依赖每个具体的实现来创建一个对象。
- en: By injecting dependencies, you tell the compiler how to construct a class that
    has its dependencies declared on the constructor. The DI mechanism does this at
    runtime. This is equivalent to telling the compiler that whenever it finds a dependency
    of a certain type, it should resolve it using the appropriate class instance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入依赖项，你告诉编译器如何构建一个在其构造函数中声明了依赖项的类。DI 机制在运行时执行此操作。这相当于告诉编译器，每当它找到特定类型的依赖项时，它应该使用适当的类实例来解析它。
- en: ASP.NET provides a native DI container, which stores the information pertaining
    to how a type should be resolved. You'll next learn how to store this information
    in the container.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 提供了一个本地的依赖注入容器，该容器存储了有关如何解析类型的所有信息。接下来，你将学习如何将此信息存储在容器中。
- en: In the `Program.cs` file, you'll see the call `builder.Services.AddRazorPages()`.
    The `Services` property is of type `IServiceCollection` and it holds the entire
    set of dependencies—also known as services—that is injected into the container.
    A lot of the required dependencies for an ASP.NET application to run are already
    injected in the `WebApplication.CreateBuilder(args)` method called at the top
    of the `Program.cs` file. This is true, for instance, for some native logging
    dependencies as you will see in the next exercise.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，你会看到调用 `builder.Services.AddRazorPages()`。`Services` 属性是
    `IServiceCollection` 类型，它包含注入到容器中的所有依赖项——也称为服务。许多 ASP.NET 应用程序运行所需的依赖项已经在 `Program.cs`
    文件顶部的 `WebApplication.CreateBuilder(args)` 方法中注入。例如，一些本地的日志依赖项将在下一个练习中看到。
- en: 'Exercise 7.01: Creating Custom Logging Middleware'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.01：创建自定义日志中间件
- en: In this exercise, you will create custom logging middleware that will output
    the details and the duration of an HTTP request to the console. After creating
    it, you will place it in the HTTP pipeline so that it is called by every request
    your application receives. The purpose is to give you a first practical introduction
    to the concepts of middleware, logging, and DI.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个自定义日志中间件，该中间件将输出 HTTP 请求的详细信息及其持续时间到控制台。创建后，你将将其放置在 HTTP 管道中，以便它被应用程序接收到的每个请求调用。其目的是为你提供一个关于中间件、日志和
    DI 的第一个实际介绍。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此练习：
- en: Create a new folder called `Middlewares`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Middlewares` 的新文件夹。
- en: Inside this folder, create a new class named `RequestLoggingMiddleware`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，创建一个名为 `RequestLoggingMiddleware` 的新类。
- en: 'Create a new private readonly field named `RequestDelegate` and initialize
    this field inside the constructor:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `RequestDelegate` 的新私有 `readonly` 字段，并在构造函数中初始化此字段：
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the reference that ASP.NET gathers as the next middleware to be executed
    on the HTTP pipeline. By initializing this field, you can call the next registered
    middleware.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ASP.NET 收集的下一个要在 HTTP 管道中执行的中间件引用。通过初始化此字段，你可以调用已注册的下一个中间件。
- en: 'Add a `using` statement to the `System.Diagnostics` namespace so that a special
    class named `Stopwatch` can be added It will be used to measure the request time
    length:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `System.Diagnostics` 命名空间中添加一个 `using` 语句，以便添加一个名为 `Stopwatch` 的特殊类。它将被用来测量请求时间长度：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Create a private `readonly ILogger` field. The `ILogger` interface is the default
    interface provided by .NET to manually log information.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个私有的 `readonly ILogger` 字段。`ILogger` 接口是 .NET 提供的默认接口，用于手动记录信息。
- en: After that, place a second parameter inside the constructor for the `ILoggerFactory`
    type. This interface is another one provided by .NET that allows you to create
    `ILogger` objects.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在 `ILoggerFactory` 类型的构造函数中放置第二个参数。此接口是 .NET 提供的另一个接口，允许您创建 `ILogger` 对象。
- en: 'Use the `CreateLogger<T>` method from this factory to create a logger object:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此工厂的 `CreateLogger<T>` 方法创建一个日志记录器对象：
- en: '[PRE7]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `T` is a generic parameter that refers to a type, which is the log category,
    as seen in the *Logging* section. In this case, the category will be the type
    of the class where the logging will be done that is, the `RequestLoggingMiddleware`
    class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`T` 是一个泛型参数，它指的是一个类型，即日志类别，如 *日志* 部分所示。在这种情况下，该类别将是执行日志记录的类的类型，即 `RequestLoggingMiddleware`
    类。
- en: 'Once the fields have been initialized, create a new method with the following signature:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦初始化了字段，创建一个新的方法，其签名如下：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside this method, declare a variable called `Stopwatch` and assign the `Stopwatch.StartNew()`
    value to it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此方法内部，声明一个名为 `Stopwatch` 的变量，并将其赋值为 `Stopwatch.StartNew()`：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Stopwatch` class is a helper that measures the execution time from the
    moment the .`StartNew()` method is called.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stopwatch` 类是一个辅助类，用于从调用 `.StartNew()` 方法的那一刻起测量执行时间。'
- en: 'After this variable, write a `try-catch` block with code to call the next request
    as well as a call to the `.Stop()` method from the `stopwatch` to measure the
    elapsed time that the `_next()` call took:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此变量之后，编写一个 `try-catch` 块，其中包含调用下一个请求以及从 `stopwatch` 的 `.Stop()` 方法调用以测量 `_next()`
    调用所花费的时间：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can also deal with a possible exception here. So, it is better to wrap these
    two calls inside a `try-catch` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处理可能的异常。因此，最好将这两个调用包裹在一个 `try-catch` 方法中。
- en: 'In the `Program.cs` file, call the custom middleware by placing the declaration
    as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 文件中，通过以下声明调用自定义中间件：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Write it in the line right below where the `app` variable is assigned.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `app` 变量赋值的下一行编写它。
- en: 'Finally, in the `Program.cs` file, place a `using` statement to `ToDoListApp.Middlewares`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `Program.cs` 文件中，放置一个 `using` 语句到 `ToDoListApp.Middlewares`：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To see the application running on your web browser and its output in the Visual
    Studio Code, type the following command at the address bar:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在您的网络浏览器中查看应用程序的运行情况及其在 Visual Studio Code 中的输出，请在地址栏中键入以下命令：
- en: '[PRE14]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here `####` represents the port number. This would be different for different
     systems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `####` 代表端口号。这会因不同的系统而异。
- en: 'After pressing enter, the following screen gets displayed:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下回车键后，将显示以下屏幕：
- en: '![Figure 7.2: Application running on the browser ](img/B16835_07_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：在浏览器上运行的应用程序](img/B16835_07_02.jpg)'
- en: 'Figure 7.2: Application running on the browser'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：在浏览器上运行的应用程序
- en: Perform *Step 13* each time after executing the exercise/ activity in VS Code.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次在 VS Code 中执行练习/活动后，都要执行 *步骤 13*。
- en: Press `Control+C` inside the VS code terminal to break the task before executing
    another exercise/ activity.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS code 终端内部按 `Control+C` 以在执行另一个练习/活动之前中断任务。
- en: 'After executing the application in your browser, you''ll see a similar output
    in the Visual Studio Code terminal:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中执行应用程序后，您将在 Visual Studio Code 终端看到类似的输出：
- en: '[PRE15]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will observe that the output on the console logs messages with an elapsed
    time of HTTP requests coming in the middleware pipelines. Since you've declared
    it with your methods, it should take the execution time considering all the pipeline
    chains.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到控制台日志中记录了带有 HTTP 请求中间件管道中经过的时间的消息。由于您已使用自己的方法声明了它，它应该考虑所有管道链的执行时间。
- en: In this exercise, you created your first middleware—the `RequestLoggingMiddleware`.
    This middleware measures the execution time of an HTTP request, in your HTTP pipeline.
    By placing it right before all other middlewares, you will be able to measure
    the entire execution time of a request that goes through the entire middleware
    pipeline.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您创建了您的第一个中间件——`RequestLoggingMiddleware`。此中间件测量 HTTP 请求的执行时间，在您的 HTTP
    管道中。通过将其放置在所有其他中间件之前，您将能够测量整个中间件管道中请求的整个执行时间。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/i04Iq](https://packt.link/i04Iq).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/i04Iq](https://packt.link/i04Iq) 找到此练习使用的代码。
- en: Now imagine you have 10 to 20 middleware for the HTTP pipeline, each has its
    own dependencies, and you must manually instantiate each middleware. IoC comes
    in handy in such cases by delegating to ASP.NET the instantiation of these classes,
    as well as injecting their dependencies. You have already seen how to create custom
    middleware that uses the native ASP.NET logging mechanism with DI.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，你有一个 10 到 20 个中间件的 HTTP 管道，每个中间件都有自己的依赖项，你必须手动实例化每个中间件。在这种情况下，IoC 通过将这些类的实例化和它们的依赖项注入委托给
    ASP.NET 来派上用场。你已经看到了如何创建使用原生 ASP.NET 日志机制和依赖注入的自定义中间件。
- en: 'In ASP.NET, logging and DI are powerful mechanisms that allow you to create
    very detailed logs for an application. This is possible, as you''ve seen, through
    `logger` injection via constructors. For these loggers, you can create an object
    of a log category in two ways:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET 中，日志记录和依赖注入是强大的机制，允许你为应用程序创建非常详细的日志。正如你所看到的，这是通过构造函数中的 `logger` 注入实现的。对于这些日志记录器，你可以通过两种方式创建日志类别的对象：
- en: As shown in the exercise, one way is the injection of `ILoggerFactory`. You
    could call the `CreateLogger(categoryName)` method, which receives a string as
    an argument. You could also call the `CreateLogger<CategoryType>()` method, which
    receives a generic type. This approach is preferable as it sets the category for
    the `logger` as the full name of the type (including the namespace).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如练习所示，一种方式是注入 `ILoggerFactory`。你可以调用 `CreateLogger(categoryName)` 方法，它接收一个字符串作为参数。你也可以调用
    `CreateLogger<CategoryType>()` 方法，它接收一个泛型类型。这种方法更可取，因为它将 `logger` 的类别设置为类型的全名（包括命名空间）。
- en: 'Another way would be through the injection of `ILogger<CategoryType>`. In this
    case, the category type is usually the type of the class where you are injecting
    the logger, as seen in the previous exercise. In the previous exercise, you could
    replace the injection of `ILoggerFactory` with `ILogger<RequestLoggingMiddleware>`
    and assign this new injected dependency directly to the `ILogger` private field
    as follows:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方式是通过注入 `ILogger<CategoryType>`。在这种情况下，类别类型通常是你要注入日志记录器的类的类型，如前一个练习中所示。在前面的练习中，你可以用
    `ILogger<RequestLoggingMiddleware>` 替换 `ILoggerFactory` 的注入，并将这个新的注入依赖项直接分配给 `ILogger`
    的私有字段，如下所示：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You now know that logging and DI are powerful mechanisms that allow you to create
    very detailed logs for an application. Before moving to Razor pages, it is important
    to learn about the life cycle of an object within an application. This is called
    the dependency lifetimes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道日志记录和依赖注入是强大的机制，允许你为应用程序创建非常详细的日志。在转向 Razor 页面之前，了解应用程序中对象的生命周期是很重要的。这被称为依赖生命周期。
- en: Dependency Lifetimes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖生命周期
- en: 'Before moving on to the next and main topic of this chapter, it is important
    to talk about dependency lifetimes. All the dependencies used in the previous
    exercise were injected via the constructor. But the resolution of these dependencies
    was only possible because ASP.NET registers these dependencies beforehand, as
    mentioned in the `Program.cs` section. In the following code, you can see an example
    of code built into ASP.NET that deals with the logging dependency registration,
    by adding the `ILoggerFactory` dependency to the services container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入本章的下一主题之前，讨论依赖生命周期是很重要的。在前面的练习中使用的所有依赖项都是通过构造函数注入的。但这些依赖项的解析之所以成为可能，仅仅是因为
    ASP.NET 在 `Program.cs` 部分之前注册了这些依赖项。在下面的代码中，你可以看到一个 ASP.NET 内置的代码示例，它处理日志依赖项的注册，通过向服务容器添加
    `ILoggerFactory` 依赖项：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code is an example from a standard library and built into ASP.NET
    that deals with the logging dependency registration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个来自标准库并内置在 ASP.NET 中的示例，它处理日志依赖项的注册。
- en: 'A lot is going on here, but the two important things to consider are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，但需要考虑的两个重要事项如下：
- en: The method here is `TryAdd`, which registers a dependency on the DI container.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的方法是 `TryAdd`，它将依赖项注册到 DI 容器中。
- en: The `ServiceDescriptor.Singleton` method is what defines a dependency lifetime.
    This is the final important concept of the *Dependency Injection* section of this
    chapter.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceDescriptor.Singleton` 方法定义了依赖生命周期。这是本章 *依赖注入* 部分的最后一个重要概念。'
- en: 'A dependency lifetime describes the life cycle of an object within an application.
    ASP.NET has three default lifetimes that can be used to register a dependency:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖生命周期描述了应用程序中对象的生命周期。ASP.NET 有三个默认的生命周期，可以用来注册依赖项：
- en: 'Transient: Objects with this lifetime are created every time they are requested
    and disposed of after use. This is effective for stateless dependencies, which
    are dependencies that do not need to keep the state when they are called. For
    instance, if you need to connect to an HTTP API to request some information, you
    can register a dependency with this lifetime, since HTTP requests are stateless.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时（Transient）：具有这种生命周期的对象每次请求时都会创建，并在使用后销毁。这对于无状态依赖项非常有效，即当它们被调用时不需要保持状态。例如，如果你需要连接到
    HTTP API 来请求一些信息，你可以注册一个具有这种生命周期的依赖项，因为 HTTP 请求是无状态的。
- en: 'Scoped: Objects with a scoped lifetime are created once for each client connection.
    For instance, in an HTTP request, a scoped dependency will have the same instance
    for the entire request, no matter how many times it is called. This dependency
    carries some state around for a certain amount of time. At the end of the connection,
    the dependency is disposed of.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域（Scoped）：具有作用域生命周期的对象为每个客户端连接创建一次。例如，在 HTTP 请求中，作用域依赖项在整个请求期间将具有相同的实例，无论它被调用多少次。这种依赖项在一段时间内携带一些状态。在连接结束时，依赖项将被销毁。
- en: 'Singleton: Objects with a singleton lifetime are created once for an entire
    application''s lifetime. Once they are requested, their instance will be carried
    on while the application is running. This kind of lifetime should be considered
    carefully as it might consume a lot of memory.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例（Singleton）：具有单例生命周期的对象在整个应用程序的生命周期内只创建一次。一旦它们被请求，它们的实例将在应用程序运行期间保持。这种生命周期应该仔细考虑，因为它可能会消耗大量内存。
- en: As mentioned before, the manual registration of these dependencies can be done
    in the `ConfigureServices` method located in the `Startup` class. Every new dependency
    that is not provided and automatically registered by ASP.NET should be manually
    registered there and knowing about these lifetimes is important as they allow
    the application to manage the dependencies in different ways.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这些依赖项的手动注册可以在 `Startup` 类中的 `ConfigureServices` 方法中完成。每个不是由 ASP.NET 自动提供和注册的新依赖项都应该在那里手动注册，了解这些生命周期很重要，因为它们允许应用程序以不同的方式管理依赖项。
- en: You have learned that the resolution of these dependencies was only possible
    because ASP.NET registers three default lifetimes that can be used to register
    a dependency. You will now move on to Razor pages that enable the construction
    of page-based applications with all the capabilities provided and powered by ASP.NET.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，这些依赖项的解析之所以成为可能，仅仅是因为 ASP.NET 注册了三个默认的生命周期，可以用来注册依赖项。现在你将转向 Razor Pages，它允许使用
    ASP.NET 提供和驱动的所有功能来构建基于页面的应用程序。
- en: Razor Pages
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Razor Pages
- en: Now that you have covered the main aspects pertaining to an ASP.NET application,
    you'll continue to build the application that you started at the beginning of
    the chapter. The goal here is to build a to-do list application, where you can
    easily create and manage a list of tasks on a Kanban-style board.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了与 ASP.NET 应用程序相关的主要方面，你将继续构建本章开头开始的应用程序。这里的目的是构建一个待办事项列表应用程序，你可以在 Kanban
    风格的看板上轻松创建和管理任务列表。
- en: Earlier sections have referenced Razor Pages, but what exactly is it? Razor
    Pages is a framework that enables the construction of page-based applications
    with all the capabilities provided and powered by ASP.NET. It was created to enable
    the building of dynamic data-driven applications with a clear separation of concerns
    that is, having each method and class with separate but complementary responsibilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 早期章节中提到了 Razor Pages，但究竟它是什么呢？Razor Pages 是一个框架，它允许使用 ASP.NET 提供和驱动的所有功能来构建基于页面的应用程序。它是为了能够构建具有清晰关注点分离的动态数据驱动应用程序而创建的，也就是说，每个方法和类都有各自但互补的责任。
- en: Basic Razor Syntax
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本Razor语法
- en: Razor Pages uses Razor syntax, a syntax powered by Microsoft that enables a
    page to have static HTML/ CSS/ JS, C# code, and custom tag helpers, which are
    reusable components that enable the rendering of HTML pieces in pages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Razor Pages 使用由 Microsoft 驱动的 Razor 语法，它允许页面具有静态 HTML/CSS/JS、C# 代码和自定义标签助手，这些是可重用组件，它们能够使页面中渲染
    HTML 片段。
- en: If you look at the `.cshtml` files generated by the `dotnet new` command that
    you ran in the first exercise, you will notice a lot of HTML code and, inside
    this code, some methods, and variables with a `@` prefix. In Razor, as soon as
    you write this symbol, the compiler detects that some C# code will be written.
    You're already aware that HTML is a markup language used to build web pages. Razor
    uses it along with C# to create powerful markup combined with server-rendered
    code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看在第一次练习中运行的 `dotnet new` 命令生成的 `.cshtml` 文件，你会注意到大量的 HTML 代码，以及一些带有 `@`
    前缀的方法和变量。在 Razor 中，一旦你写下这个符号，编译器就会检测到将编写一些 C# 代码。你已经知道 HTML 是一种用于构建网页的标记语言。Razor
    使用它与 C# 结合来创建强大的标记，并结合服务器端渲染的代码。
- en: 'If you want to place a block of code, it can be done within brackets like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想放置一个代码块，它可以在括号内完成，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside this block, you are allowed to do basically everything you can do with
    C# syntax, from local variable declarations to loops and more. If you want to
    put a `static @`, you have to escape it by placing two `@` symbols for it to be
    rendered in HTML. That happens, for instance, in email IDs, such as `james@@bond.com`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块内部，你可以基本上做所有可以用 C# 语法做的事情，从局部变量声明到循环等。如果你想放置一个 `static @`，你必须通过放置两个 `@`
    符号来转义它，以便在 HTML 中渲染。例如，在电子邮件 ID（如 `james@@bond.com`）中就是这样做的。
- en: File Structure
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件结构
- en: 'Razor Pages end with the `.cshtml` extension and might have another file, popularly
    called the `.cshtml.cs` extension. If you go to the root folder of your application
    and navigate to the `Pages` folder, you will see the following structure generated
    upon the creation of a page:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 页面以 `.cshtml` 扩展名结尾，可能还包含另一个名为 `.cshtml.cs` 的文件。如果你前往应用程序的根目录并导航到 `Pages`
    文件夹，你将看到在创建页面时生成的以下结构：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Index`, `Privacy`, and `Error` pages are automatically generated after
    project creation. Briefly look at the other files here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index`、`Privacy` 和 `Error` 页面在项目创建后自动生成。简要查看这里的其他文件。'
- en: 'The `/Shared` folder contains a shared `Layout` page that is used by default
    in the application. This page contains some shared sections, such as navbars,
    headers, footers, and metadata, that repeat in almost every application page:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Shared` 文件夹包含一个默认用于应用程序的共享 `Layout` 页面。这个页面包含一些共享部分，如导航栏、页眉、页脚和元数据，这些在几乎每个应用程序页面中都会重复：'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Keeping these shared sections in a single file makes reusability and maintainability
    easier. If you look at this `Layout` page generated in your boilerplate, there
    are some things worth highlighting:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些共享部分保存在单个文件中，使得重用性和可维护性更容易。如果你查看在模板中生成的这个 `Layout` 页面，有一些值得强调的事情：
- en: By default, a Razor Pages app is generated using Twitter Bootstrap for design—a
    library used for writing beautiful, simple, and responsive websites—and jQuery
    for basic scripting. This can be customized for each application, as those are
    just static files.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Razor Pages 应用程序使用 Twitter Bootstrap 进行设计——一个用于编写美观、简单和响应式网站的库——以及 jQuery
    进行基本脚本编写。这可以根据每个应用程序进行自定义，因为这些都是静态文件。
- en: There is a special `RenderBody()` method that indicates where the generated
    HTML for the application pages will be placed.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个特殊的 `RenderBody()` 方法，它指示应用程序页面生成的 HTML 将放置在哪里。
- en: Another method, named `RenderSection()`, is useful for rendering predefined
    sections per page. It is useful, for instance, when some static file, such as
    an image, script, or stylesheet, is needed only for some pages. In this way, you
    can place these files inside specific sections only in the pages where they are
    needed and call the `RenderSection` method at the level of the HTML you want them
    to be rendered. This is done on the `_Layout.cshtml` page.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种名为 `RenderSection()` 的方法，用于按页面渲染预定义的各个部分。例如，当需要仅对某些页面使用某些静态文件（如图像、脚本或样式表）时，它非常有用。这样，你可以在需要这些文件的页面中特定部分内放置这些文件，并在你希望它们被渲染的
    HTML 层级上调用 `RenderSection` 方法。这是在 `_Layout.cshtml` 页面上完成的。
- en: 'The `_ViewImports.cshtml` file is another important file; it enables the application
    pages to share common directives and reduces effort by placing these directives
    on every page. It is where all the global using namespaces, tag helpers, and global
    `Pages` namespaces are defined. Some of the directives this file supports are
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ViewImports.cshtml` 文件是另一个重要的文件；它使应用程序页面能够共享公共指令，并通过在每一页上放置这些指令来减少工作量。它定义了所有全局使用命名空间、标签辅助器和全局
    `Pages` 命名空间的地方。该文件支持的指令如下：'
- en: '`@namespace`: Used to set the base namespace for `Pages`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@namespace`：用于设置 `Pages` 的基本命名空间。'
- en: '`@inject`: Used to place DI within the page.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inject`：用于在页面中放置依赖注入。'
- en: '`@model`: Includes `PageModel`, a class that will determine what information
    the page will handle.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@model`：包含 `PageModel` 类，该类将确定页面将处理哪些信息。'
- en: '`@using`: Similar to the `.cs` files, this directive allows you to fully qualify
    namespaces at the top level of a Razor page to avoid repeating these namespaces
    throughout the code.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@using`：类似于 `.cs` 文件，这个指令允许你在 Razor 页面的顶级完全限定命名空间，以避免在代码中重复这些命名空间。'
- en: The `_ViewStart.cshtml` file is used to place code that will be executed at
    the start of each page call. On this page, you define the `Layout` property while
    setting the `Layout` page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`_ViewStart.cshtml` 文件用于放置在每个页面调用开始时执行的代码。在这个页面上，你定义 `Layout` 属性并设置 `Layout`
    页面。'
- en: Now that you are familiar with the basics of Razor Pages, it is time to start
    working on your application and dive into some more interesting topics. You will
    start by creating the basic structure of the to-do list application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 Razor Pages 的基础知识，是时候开始着手你的应用程序并深入研究一些更有趣的话题了。你将从创建待办事项应用程序的基本结构开始。
- en: 'Exercise 7.02: Creating a Kanban Board with Razor'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：使用 Razor 创建看板
- en: 'The goal of this exercise will be to start the to-do application creation with
    its first component—a Kanban board. This board is used for controlling workflows,
    where people can divide their work into cards and move these cards between different
    statuses, such as To Do, Doing, and Done. A popular application that uses this
    is Trello. The same `ToDoListApp` project created in the *Exercise 7.01* will
    be used throughout this chapter to learn new concepts and incrementally evolve
    the application, including in this exercise. Perform the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是使用其第一个组件——看板来开始创建待办事项应用程序。这个看板用于控制工作流程，人们可以将他们的工作分成卡片，并在不同的状态之间移动这些卡片，例如待办、进行中和完成。使用这种功能的流行应用程序是
    Trello。在本章中，我们将使用与 *练习 7.01* 中创建的相同的 `ToDoListApp` 项目来学习新概念并逐步发展应用程序，包括本练习。执行以下步骤：
- en: Navigate to the root folder of your application and create a folder named `Models`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你的应用程序的根目录，并创建一个名为 `Models` 的文件夹。
- en: 'Inside the `Models` folder, create a new `enum` called `ETaskStatus` with the
    `ToDo`, `Doing`, and `Done` options:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹中，创建一个新的 `enum` 类 `ETaskStatus`，包含 `ToDo`、`Doing` 和 `Done` 选项：
- en: '[PRE21]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, in the `Models` folder, create a new class called `ToDoTask` that will
    be used to create a new task for your to-do list with the following properties:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在 `Models` 文件夹中，创建一个新的类 `ToDoTask`，它将被用来为待办事项列表创建一个新的任务，具有以下属性：
- en: '[PRE22]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create two constructors as shown here for the `ToDoTask` class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `ToDoTask` 类创建两个构造函数，如下所示：
- en: '[PRE23]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Create one with no parameters to set the default values for the `Id` and `CreatedAt`
    properties, and the other with lowercase-named parameters for the preceding class
    to initialize the `Title` and `Status` properties.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个不带参数的，用于设置 `Id` 和 `CreatedAt` 属性的默认值，另一个带有小写命名的参数，用于初始化前面类的 `Title` 和 `Status`
    属性。
- en: The `Pages`/ `Index.cshtml` is automatically generated in your application boilerplate.
    It is this page that will be the entry point of your application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pages`/ `Index.cshtml` 文件是在你的应用程序样板中自动生成的。这个页面将是你的应用程序的入口点。'
- en: 'Now, customize it by editing the file `Pages`/ `Index.cshtml.cs` and replacing
    the boilerplate code with the code shown as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过编辑文件 `Pages`/ `Index.cshtml.cs` 并替换以下代码中的样板代码来自定义它：
- en: '[PRE25]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Basically, this code fills your model. Here, the `OnGet` method of `PageModel`
    is used to tell the application that when the page is loaded, it should fill the
    model with the properties assigned to `Task`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这段代码填充了你的模型。在这里，`PageModel` 类的 `OnGet` 方法被用来通知应用程序，当页面加载时，它应该使用分配给 `Task`
    的属性填充模型。
- en: 'Replace the code within `Pages`/ `Index.cshtml` with the code shown as follows
    in order to create your Kanban board with the task cards:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Pages`/ `Index.cshtml` 中的代码替换为以下代码，以创建你的看板和任务卡片：
- en: '[PRE27]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This page is your view. It shares the properties from the `Pages`/ `Index.cshtml.cs`
    class (also called the code-behind class). When you assign a value to the `Tasks`
    property in the code-behind class, it becomes visible to the view. With this property,
    you can populate the HTML from the page.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '这个页面是你的视图。它共享 `Pages`/ `Index.cshtml.cs` 类（也称为代码后类）的属性。当你为代码后类中的 `Tasks` 属性赋值时，它对视图可见。使用这个属性，你可以从页面填充
    HTML。 '
- en: 'Now, run your application with the `dotnet run` command. You will see the following
    on the `Index` page when the application is loaded on the browser:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `dotnet run` 命令运行你的应用程序。当应用程序在浏览器中加载时，你将在 `Index` 页面上看到以下内容：
- en: '![Figure 7.3: Displaying your first application, the Kanban board ](img/B16835_07_03.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：显示你的第一个应用程序，看板](img/B16835_07_03.jpg)'
- en: 'Figure 7.3: Displaying your first application, the Kanban board'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：显示你的第一个应用程序，看板
- en: Notice that, for now, the application does not contain any logic. What you built
    here is simply a UI powered by the `PageModel` data.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前应用程序不包含任何逻辑。你在这里构建的只是一个由 `PageModel` 数据驱动的 UI。
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/1PRdq](https://packt.link/1PRdq).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/1PRdq](https://packt.link/1PRdq) 找到用于此练习的代码。
- en: As you saw in *Exercise 7.02*, for every page created there are two main types
    of files which are a `.cshtml` and a `.cshtml.cs` file. These files form the foundations
    of each Razor page. The next section will detail about this difference in the
    filename suffix and how these two files complement each other.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 *练习 7.02* 中所看到的，为每个创建的页面都有两种主要类型的文件，即 `.cshtml` 和 `.cshtml.cs` 文件。这些文件构成了每个
    Razor 页面的基础。下一节将详细介绍文件名后缀的差异以及这两个文件是如何相互补充的。
- en: PageModel
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageModel
- en: In the `Index.cshtml.cs` file that you created in *Exercise 7.02*, you might
    have noticed that the class inside it inherits from the `PageModel` class. Having
    this code-behind class provides some advantages—such as a clear separation of
    concerns between the client and the server—and this makes maintenance and development
    easier. It also enables you to create both unit and integration tests for the
    logic placed on the server. You will learn more about testing in *Chapter 10*,
    *Automated Testing*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 7.02* 中创建的 `Index.cshtml.cs` 文件中，你可能已经注意到其中的类继承自 `PageModel` 类。拥有这个代码后置类提供了一些优势——例如，客户端和服务器之间关注点的清晰分离——这使得维护和开发更加容易。它还使你能够为放置在服务器上的逻辑创建单元和集成测试。你将在
    *第 10 章*，*自动化测试* 中了解更多关于测试的内容。
- en: A `PageModel` may contain some properties that are bound to the view. In *Exercise
    7.02*, the `IndexModel` page has a property that is a `List<ToDoTask>`. This property
    is then populated when the page loads on the `OnGet()` method. So how does populating
    happen? The next section will discuss the life cycle of populating properties
    and using them within `PageModel`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageModel` 可能包含一些绑定到视图的属性。在 *练习 7.02* 中，`IndexModel` 页面有一个属性是 `List<ToDoTask>`。这个属性在页面加载时的
    `OnGet()` 方法中被填充。那么填充是如何发生的呢？下一节将讨论填充属性的生命周期以及在 `PageModel` 中使用它们。'
- en: The Life Cycle with Page Handlers
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有页面处理器的生命周期
- en: Handler methods are a core feature of Razor Pages. These methods are automatically
    executed when the server receives a request from the page. In *Exercise 7.02*,
    for instance, the `OnGet` method will be executed each time the page receives
    a `GET` request.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序方法是 Razor Pages 的核心功能。当服务器从页面接收到请求时，这些方法会自动执行。例如，在 *练习 7.02* 中，每次页面接收到 `GET`
    请求时，`OnGet` 方法都会被执行。
- en: By convention, the handler methods will answer according to the HTTP verb of
    the request. So, for instance, if you wanted something to be executed after a
    `POST` request, you should have an `OnPost` method. Also, after a `PUT` request,
    you should have an `OnPut` method. Each of these methods has an asynchronous equivalent,
    which changes the method's signature; an `Async` suffix is added to the method
    name, and it returns a `Task` property instead of `void`. This also makes the
    `await` functionality available for the method.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，处理程序方法将根据请求的 HTTP 动词来回答。例如，如果你想在一个 `POST` 请求之后执行某些操作，你应该有一个 `OnPost` 方法。同样，在
    `PUT` 请求之后，你应该有一个 `OnPut` 方法。这些方法中的每一个都有一个异步等效方法，它改变了方法的签名；方法名后添加了 `Async` 后缀，并且它返回一个
    `Task` 属性而不是 `void`。这也使得 `await` 功能可用于该方法。
- en: 'There is, however, one tricky scenario in which you may want a form to perform
    multiple actions with the same HTTP verb. In that case, you could perform some
    confusing logic on the backend to handle different inputs. Razor Pages, however,
    provides you with a functionality right out of the box called `asp-page-handler`
    that allows you to specify the name of the handler being called on the server.
    Tag helpers will be discussed in the next section, but for now, consider the following
    code as an example. The code contains an HTML form containing two submit buttons,
    to perform two different actions—one for creating an order, and the other for
    canceling an order:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个棘手的情况，你可能希望表单使用相同的HTTP动词执行多个操作。在这种情况下，你可以在后端执行一些令人困惑的逻辑来处理不同的输入。然而，Razor
    Pages为你提供了一个开箱即用的功能，称为`asp-page-handler`，允许你指定在服务器上被调用的处理程序名称。标签辅助器将在下一节中讨论，但在此阶段，请考虑以下代码作为示例。该代码包含一个HTML表单，包含两个提交按钮，用于执行两个不同的操作——一个用于创建订单，另一个用于取消订单：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the server side, you only need to have two handlers, one for each action,
    as shown in the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，你只需要有两个处理程序，每个操作一个，如下面的代码所示：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, the code behind the page matches the value of the `form` method and the
    `asp-page-handler` tag on the `.cshtml` file to the method name on the code-behind
    file. That way, you can have multiple actions for the same HTTP verb in the same
    form.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，页面的后台代码与`.cshtml`文件上的`form`方法和`asp-page-handler`标签的值相匹配，与代码后台文件中的方法名称相匹配。这样，你可以在同一个表单中为相同的HTTP动词执行多个操作。
- en: 'A final note on this subject is that in this case, the method name on the server
    should be written as:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的最后一句话是，在这种情况下，服务器上的方法名称应该写成如下格式：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is written with or without the `Async` suffix. In the previous example,
    the `OnPostPlaceOrderAsync` method is the `PlaceOrder` handler for the `PlaceOrder`
    button, and `OnPostCancelOrderAsync` is the handler for the `CancelOrder` button.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以带有或不带有`Async`后缀。在前面的例子中，`OnPostPlaceOrderAsync`方法是`PlaceOrder`按钮的`PlaceOrder`处理程序，而`OnPostCancelOrderAsync`是`CancelOrder`按钮的处理程序。
- en: Rendering Reusable Static Code with Tag Helpers
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签辅助器渲染可重用静态代码
- en: One thing you might have noticed is that the HTML written previously is lengthy.
    You created Kanban cards, lists, and a board to wrap it all. If you take a closer
    look at the code, it has the same pattern repeated all the way through. That raises
    one major problem, maintenance. It is hard to imagine having to handle, maintain,
    and evolve all this plain text.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，之前编写的HTML代码很长。你创建了看板卡片、列表和一个板来包裹所有内容。如果你仔细查看代码，会发现整个代码中都有相同的模式重复出现。这引发了一个主要问题，维护。很难想象需要处理、维护和演变所有这些纯文本。
- en: Fortunately, tag helpers can be immensely useful in this regard. They are basically
    components that render static HTML code. ASP.NET has a set of built-in tag helpers
    with custom server-side attributes, such as anchors, forms, and images. Tag helpers
    are a core feature that helps make advanced concepts easy to handle, such as model
    binding, which will be discussed a little further ahead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标签辅助器在这方面可以非常有用。它们基本上是渲染静态HTML代码的组件。ASP.NET有一组内置的标签辅助器，具有自定义服务器端属性，如锚点、表单和图像。标签辅助器是一个核心功能，有助于使高级概念易于处理，例如模型绑定，这将在稍后进一步讨论。
- en: Besides the fact that they add rendering capabilities to built-in HTML tags,
    they are also an impressive way to achieve reusability on static and repetitive
    code. In the next exercise, you will learn how to create a customized tag helper.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为内置HTML标签添加渲染功能外，它们还是实现静态和重复代码可重用性的令人印象深刻的方法。在下一个练习中，你将学习如何创建自定义标签辅助器。
- en: 'Exercise 7.03: Creating Reusable Components with Tag Helpers'
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：使用标签辅助器创建可重用组件
- en: In this exercise, you are going to improve upon your work in the previous one.
    The improvement here will be to simplify the HTML code by moving part of this
    code that could be reused to custom tag helpers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将改进上一个练习中的工作。这里的改进是将可以复用的部分代码移动到自定义标签辅助器中，以简化HTML代码。
- en: 'To do so, perform the following steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请执行以下步骤：
- en: Open the `_ViewImports.cshtml` file, which was created with your application.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开与你的应用程序一起创建的`_ViewImports.cshtml`文件。
- en: 'Add the following lines to the end with the content to define custom tag helpers
    `@addTagHelper` directive:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到末尾，以定义自定义标签辅助器的内容`@addTagHelper`指令：
- en: '[PRE32]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, you added all the custom tag helpers that exist within
    this namespace using the asterisk (`*`).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你使用星号 (`*`) 添加了此命名空间中存在的所有自定义标签助手。
- en: Now, create a new folder under the project's root (`ToDoApp`) called `TagHelpers`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在项目的根目录（`ToDoApp`）下创建一个名为 `TagHelpers` 的新文件夹。
- en: Create a new class inside this folder called `KanbanListTagHelper.cs`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内创建一个名为 `KanbanListTagHelper.cs` 的新类。
- en: 'Make this class inherit from the `TagHelper` class:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个类继承自 `TagHelper` 类：
- en: '[PRE33]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This inheritance is what allows ASP.NET to identify both built-in and custom
    tag helpers.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种继承使得 ASP.NET 能够识别内置和自定义的标签助手。
- en: 'Now place a `using` statement for the `Microsoft.AspNetCore.Razor.TagHelpers`
    namespace:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Microsoft.AspNetCore.Razor.TagHelpers` 命名空间下放置一个 `using` 语句：
- en: '[PRE34]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For the `KanbanListTagHelper` class, create two string properties, called `Name`
    and `Size`, with getters and setters:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `KanbanListTagHelper` 类，创建两个名为 `Name` 和 `Size` 的字符串属性，并具有获取器和设置器：
- en: '[PRE35]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Override the base asynchronous `ProcessAsync (TagHelperContext context`, `TagHelperOutput)`
    output method with the following code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码重写基类的异步 `ProcessAsync (TagHelperContext context, TagHelperOutput)` 输出方法：
- en: '[PRE36]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Every tag helper has a standard HTML tag as an output. That is why, at the beginning
    of your methods, the `TagName` property was called from the `TagHelperOutput`
    object to specify the HTML tag that will be used as output. Additionally, you
    can set the attributes for this HTML tag by calling the `Attributes` property
    and its `SetAttribute` method from the `TagHelperOutput` object. That is what
    you did right after specifying the HTML output tag.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签助手都有一个标准的 HTML 标签作为输出。这就是为什么在方法开始时，从 `TagHelperOutput` 对象中调用 `TagName` 属性来指定将用作输出的
    HTML 标签。此外，你还可以通过从 `TagHelperOutput` 对象中调用 `Attributes` 属性及其 `SetAttribute` 方法来设置此
    HTML 标签的属性。这正是你在指定 HTML 输出标签之后所做的事情。
- en: 'Now, create another class named `KanbanCardTagHelper.cs` with the same inheritance
    and namespace using a statement such as the previous one:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个名为 `KanbanCardTagHelper.cs` 的类，具有相同的继承和命名空间使用语句，如前所述：
- en: '[PRE38]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For this class, create a `string` property with public getters and setters named `Task.`
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，创建一个名为 `Task` 的 `string` 属性，并具有公共的获取器和设置器：
- en: 'In this new class, override the base synchronous `Process(TagHelperContext
    context, TagHelperOutput output)` method. Within this method, write the following
    code:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新类中，重写基类的同步 `Process(TagHelperContext context, TagHelperOutput output)` 方法。在这个方法中，编写以下代码：
- en: '[PRE39]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An important concept to know about is how the HTML content is placed within
    the tag helper. As you can see, the code uses three different properties from
    the `TagHelperOutput` object to place the content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的概念是了解 HTML 内容如何在标签助手内放置。正如你所见，代码使用了 `TagHelperOutput` 对象的三个不同属性来放置内容：
- en: '`PreContent`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreContent`'
- en: '`Content`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content`'
- en: '`PostContent`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostContent`'
- en: The pre-and post-properties are useful to set the content right before and after
    that you want to generate. A use case for them is when you want to set up fixed
    content as `div` containers, headers, and footers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 预设和后置属性对于在生成内容之前和之后设置内容非常有用。它们的一个用例是当你想要设置固定内容作为 `div` 容器、标题和页脚时。
- en: Another thing you did here was set how the tag helper will be rendered through
    the `Mode` property. You used `TagMode.StartTagAndEndTag` as a value because you
    used a `div` container as a tag output for the tag helper, and `div` elements
    have both start and end tags in HTML. If the output tag were some other HTML element,
    such as email, which is self-closing, you would use `TagMode.SelfClosing` instead.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里做的另一件事是通过 `Mode` 属性设置标签助手如何被渲染。你使用了 `TagMode.StartTagAndEndTag` 作为值，因为你使用了
    `div` 容器作为标签助手输出，而 `div` 元素在 HTML 中既有开始标签也有结束标签。如果输出标签是其他 HTML 元素，例如自闭合的电子邮件，你会使用
    `TagMode.SelfClosing` 代替。
- en: 'Finally, go to the `Index.cshtml` file under the Pages folder and replace the
    HTML created in *Exercise 7.02* with the tag helpers to make your code concise:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，转到 Pages 文件夹下的 `Index.cshtml` 文件，并用标签助手替换 *练习 7.02* 中创建的 HTML，以使你的代码更简洁：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now run the application with the following command:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在用以下命令运行应用程序：
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In your browser, navigate to the localhost:#### address provided by the Visual
    Studio console output just like you did in the last exercise:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，导航到 Visual Studio 控制台输出提供的 localhost:#### 地址，就像你在上一个练习中所做的那样：
- en: '![Figure 7.4: The frontend displayed in the browser ](img/B16835_07_04.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4：浏览器中显示的前端](img/B16835_07_04.jpg)'
- en: 'Figure 7.4: The frontend displayed in the browser'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4：浏览器中显示的前端
- en: You will see the same result at the frontend that you had before, as shown in
    *Figure 7.3*. The improvement is in the fact that even though the output is the
    same, you have now a much more modular and concise code to maintain and evolve.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在前端看到与之前相同的结果，如*图 7.3*所示。改进之处在于，尽管输出相同，你现在拥有一个更加模块化和简洁的代码来维护和演进。
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/YEdiU](https://packt.link/YEdiU).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/YEdiU](https://packt.link/YEdiU)找到用于此练习的代码。
- en: In this exercise, you used tag helpers to create reusable components that generate
    static HTML code. You can see now that the HTML code is much cleaner and more
    concise. The next section will detail about creating interactive pages by linking
    what's on the Code Behind with your HTML view using the concept of model binding.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了标签辅助器来创建可重用的组件，这些组件生成静态 HTML 代码。你现在可以看到 HTML 代码变得更加干净和简洁。下一节将详细介绍通过使用模型绑定将代码背后的内容与你的
    HTML 视图链接起来创建交互式页面。
- en: Model Binding
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型绑定
- en: 'So far, you have covered concepts that helped create a foundation for the to-do
    app. As a quick recap, the main points are as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经涵盖了有助于为待办事项应用程序打下基础的概念。作为一个快速回顾，主要点如下：
- en: '`PageModel` is used to add data to a page.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PageModel` 用于向页面添加数据。'
- en: Tag helpers add custom static rendering to the HTML generated by the server.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签辅助器为服务器生成的 HTML 添加了自定义的静态渲染。
- en: Handler methods define the way a page interacts with an HTTP request.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序方法定义了页面与 HTTP 请求交互的方式。
- en: One final overarching concept that is central to building Razor Pages applications
    is model binding. The data used as arguments in handler methods and passed through
    the page model is rendered through this mechanism. It consists of extracting data
    in key/ value pairs from HTTP requests and placing them in either the client-side
    HTML or the server-side code, depending on the direction of the binding that is,
    whether the data is moving from client to server or from server to client.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个至关重要的最终概念，是构建 Razor Pages 应用程序的核心，即模型绑定。在处理程序方法中用作参数的数据以及通过页面模型传递的数据是通过此机制渲染的。它包括从
    HTTP 请求中提取键/值对，并根据绑定的方向（即数据是从客户端移动到服务器还是从服务器移动到客户端），将它们放置在客户端 HTML 或服务器端代码中。
- en: This data might be placed in routes, forms, or query strings and is binding
    to .NET types, either primitive or complex. *Exercise 7.04* will help clarify
    how the model binding works when coming from the client to the server.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可能放置在路由、表单或查询字符串中，并与 .NET 类型绑定，无论是原始类型还是复杂类型。*练习 7.04* 将有助于阐明模型绑定在从客户端到服务器时的运作方式。
- en: 'Exercise 7.04: Creating a New Page to Submit Tasks'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.04：创建一个提交任务的页面
- en: 'The goal of this exercise is to create a new page. It will be used to create
    new tasks that will be displayed on the Kanban board. Perform the following steps
    to complete this exercise:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是创建一个新页面。它将被用来创建将在看板中显示的新任务。按照以下步骤完成此练习：
- en: 'Inside the project root folder, run the following commands:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录文件夹中，运行以下命令：
- en: '[PRE43]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At the root of the project, create a new folder named `Data` with a `ToDoDbContext`
    class inside it. This class will inherit from Entity Framework's `DbContext` and
    will be used to access the database.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个名为 `Data` 的新文件夹，并在其中包含一个 `ToDoDbContext` 类。这个类将继承自 Entity Framework
    的 `DbContext` 并用于访问数据库。
- en: 'Now add the following code in it:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将其中的以下代码添加进去：
- en: '[PRE44]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Update your `Program.cs` file to match the following:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新你的 `Program.cs` 文件以匹配以下内容：
- en: '[PRE45]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This change will register the `DbContext` dependencies within the DI container,
    as well as sets up the database access.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改将在 DI 容器中注册 `DbContext` 依赖项，并设置数据库访问。
- en: 'Run the following commands on the terminal to install the `dotnet ef` tool.
    This is a CLI tool that will help you to iterate with database helpers, such as
    schema creation and update:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端上运行以下命令来安装 `dotnet ef` 工具。这是一个 CLI 工具，它将帮助你与数据库辅助器进行迭代，例如架构创建和更新：
- en: '[PRE47]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, build the application and run the following commands on the terminal:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建应用程序并在终端上运行以下命令：
- en: '[PRE48]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These commands will create a new migration that will create the schema from
    your database and apply this migration to your database.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将创建一个新的迁移，该迁移将从你的数据库创建架构并将此迁移应用到数据库中。
- en: After the migration has run and the database is updated, create a new folder
    called `Tasks` inside the `Pages` folder.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迁移运行并数据库更新后，在 `Pages` 文件夹内创建一个名为 `Tasks` 的新文件夹。
- en: Move the Index page files—`index.cshtml` and `index.cshtml.cs`—to the `Tasks`
    folder.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Index`页面文件——`index.cshtml`和`index.cshtml.cs`——移动到`Tasks`文件夹。
- en: 'Next, replace the `AddRazorPages` call in the `Program.cs` with the following call:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Program.cs`中的`AddRazorPages`调用替换为以下调用：
- en: '[PRE49]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will add a convention for the page routes to be called.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为页面路由添加一个约定。
- en: 'Replace the header tag inside the `_Layout.cshtml` file (under `Pages/Shared/`)
    to create a shared `navbar` for the application:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`_Layout.cshtml`文件中的标题标签（位于`Pages/Shared/`）以创建应用的共享`navbar`：
- en: '[PRE50]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This `navbar` will allow you to access the newly created page.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`navbar`将允许你访问新创建的页面。
- en: 'Create the `Create.cshtml` page (under `Pages/Tasks/`) and add the following
    code:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Create.cshtml`页面（位于`Pages/Tasks/`），并添加以下代码：
- en: '[PRE51]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This should contain a form that will use a `PageModel` class to create the new
    tasks. For each form input field, an `asp-for` attribute is used inside the `input`
    tag helper. This attribute is responsible for filling the HTML input with a proper
    value in the `name` attribute.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该包含一个表单，该表单将使用`PageModel`类来创建新任务。对于每个表单输入字段，在`input`标签辅助器内部使用`asp-for`属性。此属性负责在`name`属性中用适当的值填充HTML输入。
- en: 'Since you are binding to a complex property inside the page model named `Task`,
    the name value is generated with the following syntax:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在将页面模型中的复杂属性`Task`进行绑定，名称值使用以下语法生成：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here `PREFIX` is the complex object name on the `PageModel`. So, for an ID of
    a task, an input with `name="Task_Id"` is generated on the client-side and the
    input is populated with the `value` attribute having the `Task.Id` property value
    that comes from the server. In the case of the page, as you are creating a new
    task, the field does not come previously populated. That is because with the `OnGet`
    method you assigned a new object to the `Task` property of the `PageModel` class.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`PREFIX`是`PageModel`上的复杂对象名称。因此，对于一个任务的ID，客户端会生成一个带有`name="Task_Id"`的输入，并且输入通过具有来自服务器的`Task.Id`属性值的`value`属性进行填充。在页面的情况下，因为你正在创建一个新任务，字段之前没有被预先填充。这是因为你使用`OnGet`方法将一个新对象分配给了`PageModel`类的`Task`属性。
- en: 'Now, create the code-behind page, named `CreateModel.cshtml.cs` (placed in
    `Pages/Tasks/`):'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建名为`CreateModel.cshtml.cs`的后台代码页面（位于`Pages/Tasks/`）：
- en: '[PRE54]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When posting a form, all the values inside the form are placed in the incoming
    `HttpRequest`. The call to `TryUpdateModelAsync` tries to populate an object with
    these values that the request brought from the client-side. Since the form is
    created with the `name` attribute in the input element with the format that has
    been explained previously, this method knows how to extract these values and bind
    them to the object. Put simply, that is the magic behind model binding.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交表单时，表单内的所有值都放置在传入的`HttpRequest`中。`TryUpdateModelAsync`的调用尝试使用来自客户端的请求中的这些值填充一个对象。由于表单是用前面解释过的格式创建的，此方法知道如何提取这些值并将它们绑定到对象上。简单来说，这就是模型绑定的魔法。
- en: 'Now, replace the code of `Index.cshtml` (under `Pages/Tasks/`) with the following:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换`Index.cshtml`（位于`Pages/Tasks/`）的代码：
- en: '[PRE56]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code adds a section that introduces an alert to be displayed if there is
    an entry with the `SuccessMessage` key in the `TempData` dictionary.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个部分，用于显示如果`TempData`字典中存在带有`SuccessMessage`键的条目时将显示的警告。
- en: 'Finally, add some display and validation rules via data annotations to the
    `Models/ToDoTask.cs` class properties:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过数据注释向`Models/ToDoTask.cs`类的属性添加一些显示和验证规则：
- en: '[PRE58]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here the `Required` data annotation over the property is to ensure that this
    property is set with a valid value. In this exercise, you added persistence with
    Entity Framework Core and SQLite and created a new page that creates a task for
    the to-do application, finally saving it into the database.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对属性的`Required`数据注释是为了确保这个属性被设置为一个有效的值。在这个练习中，你添加了使用Entity Framework Core和SQLite的持久性，并创建了一个新页面，用于为待办应用创建任务，最后将其保存到数据库中。
- en: Now run the code in VS Code.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在VS Code中运行代码。
- en: 'To see the output on your web browser, type the following command on the address
    bar:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在网页浏览器上查看输出，请在地址栏中输入以下命令：
- en: '[PRE60]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here `####` represents the port number. This would be different for different systems.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`####`代表端口号。这会因不同的系统而异。
- en: 'After pressing enter, the following screen is displayed:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车后，将显示以下屏幕：
- en: '![Figure 7.5: Home page with Create Task button in the navigation bar ](img/B16835_07_05.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：带有创建任务按钮的导航栏的主页](img/B16835_07_05.jpg)'
- en: 'Figure 7.5: Home page with Create Task button in the navigation bar'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：包含创建任务按钮的导航栏主页
- en: 'Click on the `Create Task` button, and you''ll see the page you just created
    to insert new cards into your Kanban Board:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`创建任务`按钮，你将看到你刚刚创建的页面，用于将新卡片插入到你的看板（Kanban Board）中：
- en: '![Figure 7.6: The Create Task page ](img/B16835_07_06.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：创建任务页面](img/B16835_07_06.jpg)'
- en: 'Figure 7.6: The Create Task page'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：创建任务页面
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/3FPaG](https://packt.link/3FPaG).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/3FPaG](https://packt.link/3FPaG)找到这个练习所使用的代码。
- en: Now, you'll take a deep dive into how model binding brings it all together,
    enabling you to transport data back and forth between the client and the server.
    You will also know more about validations in the next section.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将深入了解模型绑定如何将所有这些整合在一起，使你能够在客户端和服务器之间传输数据。你还将了解下一节中关于验证的更多信息。
- en: Validation
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Validating data is something you will often need to do while developing an application.
    Validating a field may either mean that it is a required field or that it should
    follow a specific format. An important thing you may have noticed in the final
    part of the previous exercise is that you placed some `[Required]` attributes
    on top of some model properties in the final step of the last exercise. Those
    attributes are called data annotations and are used to create server-side validations.
    Moreover, you can add some client-side validation combined with this technique.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，验证数据是经常需要做的事情。验证一个字段可能意味着它是必填字段，或者它应该遵循特定的格式。你可能已经注意到，在上一个练习的最后部分，你在最后一个练习的最后一步中，在模型属性上放置了一些`[Required]`属性。这些属性被称为数据注释，用于创建服务器端验证。此外，你还可以添加一些客户端验证，与这种技术相结合。
- en: Note that in *Step 10* of *Exercise 7.04*, the frontend has some span tag helpers
    with an `asp-validation-for` attribute pointing to the model properties. There
    is one thing that binds this all together—the inclusion of the `_ValidationScriptsPartial.cshtml`
    partial page. Partial pages are a subject discussed in the next section, but for
    now, it is enough to know that they are pages that can be reused inside other
    ones. The one just mentioned includes default validation for the pages.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在*练习7.04的第10步*中，前端有一些带有`asp-validation-for`属性的`span`标签辅助器，这些属性指向模型属性。将这一切联系在一起的是`_ValidationScriptsPartial.cshtml`部分页面的包含。部分页面是下一节讨论的主题，但就现在而言，只需知道它们是可以被其他页面重用的页面。刚刚提到的那个包括页面的默认验证。
- en: With those three placed together (that is, the required annotation, the `asp-validation-for`
    tag helper, and the `ValidationScriptsPartial` page), validation logic is created
    on the client-side that prevents the form from being submitted with invalid values.
    If you want to perform the validation on the server, you could use the built-in
    `TryValidateModel` method, passing the model to be validated.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个放在一起（即，所需的注释、`asp-validation-for`标签辅助器和`ValidationScriptsPartial`页面），客户端将创建验证逻辑，防止表单提交无效值。如果你想将验证放在服务器上，可以使用内置的`TryValidateModel`方法，传递要验证的模型。
- en: Dynamic Behavior with Partial Pages
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分页面的动态行为
- en: So far, you have built a board to display tasks and a way to create and edit
    them. Still, there is one major feature for a to-do application that needs adding—a
    way to move tasks across the board. You can start as simple as moving one way
    only—from to-do to doing, and from doing to done.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了一个用于显示任务和创建及编辑任务的方式的看板。然而，对于一个待办事项应用来说，还有一个主要功能需要添加——一种在看板之间移动任务的方式。你可以从最简单的方式开始，即从待办事项到进行中，再从进行中到完成。
- en: Until now, your task cards were built using tag helpers. However, tag helpers
    are rendered as `static` components and do not allow any dynamic behavior to be
    added during rendering. You could add tag helpers directly to your page, but you
    would have to repeat it for every board list. That is exactly where a major Razor
    Pages feature comes into play and that is Partial Pages. They allow you to create
    reusable page code snippets in smaller pieces. That way, you can share the base
    page dynamic utilities and still avoid duplicate code in your application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的任务卡片都是使用标签辅助器构建的。然而，标签辅助器被渲染为`静态`组件，不允许在渲染过程中添加任何动态行为。你可以直接将标签辅助器添加到你的页面上，但你必须为每个看板列表重复它。这正是Razor
    Pages的一个主要功能发挥作用的地方，那就是部分页面。它们允许你以更小的片段创建可重用的页面代码片段。这样，你可以共享基础页面的动态工具，同时避免在应用程序中重复代码。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本节的理沦部分。在接下来的部分中，你将通过练习将其付诸实践。
- en: 'Exercise 7.05: Refactoring a Tag Helper to a Partial Page with Custom Logic'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.05：将标签助手重构为具有自定义逻辑的部分页面
- en: 'In this exercise, you will create a partial page to replace `KanbanCardTagHelper`
    and add some dynamic behavior to your task''s cards, such as changing content
    based on custom logic. You will see how partial pages help in reducing duplicate
    code and make it more easily reusable. Perform the following steps to complete
    this exercise:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个部分页面来替换 `KanbanCardTagHelper`，并为你的任务卡片添加一些动态行为，例如根据自定义逻辑更改内容。你将看到部分页面如何帮助减少重复代码并使其更容易重用。执行以下步骤以完成此练习：
- en: 'Inside the `Pages/Tasks` folder, create a new file called `_TaskItem.cshtml`
    with the following content:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Pages/Tasks` 文件夹内，创建一个名为 `_TaskItem.cshtml` 的新文件，内容如下：
- en: '[PRE61]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `_TaskItem.cshtml` is basically a partial page that contains the `.cshtml`
    code of a card from the Kanban board.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`_TaskItem.cshtml` 主要是包含看板板卡片 `.cshtml` 代码的部分页面。'
- en: 'Now, replace the code within the `Index.cshtml.cs` file with the following
    code that can read the saved tasks from the database and place the actions you
    created on the partial page:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `Index.cshtml.cs` 文件内的代码替换为以下代码，该代码可以从数据库中读取保存的任务，并将你创建的操作放置在部分页面上：
- en: '[PRE63]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code creates handler methods for the three HTTP requests—a GET request
    and two POST requests. It also places the logic to be executed on these handlers.
    You will read values from the database with GET and save them back with POST.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码为三个 HTTP 请求创建了处理程序方法——一个 GET 请求和两个 POST 请求。它还放置了在这些处理程序上要执行的逻辑。你将使用 GET 从数据库中读取值，并使用
    POST 将它们保存回去。
- en: 'Finally, update the `Index.cshtml` page with the following code to replace
    the use of tag helpers by the partial Razor page with your Kanban cards:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下代码更新 `Index.cshtml` 页面，用你的看板卡片的部分 Razor 页面替换标签助手的使用：
- en: '[PRE65]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Doing so, you'll notice how much duplicate code gets eliminated.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，你会注意到有多少重复代码被消除了。
- en: 'Now run the application with the following command:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行以下命令来启动应用程序：
- en: '[PRE67]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Next click at the Create Task button and fill the form. After a Task is created,
    you'll see a confirmation message, as shown in *Figure 7.7*.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来点击创建任务按钮并填写表单。创建任务后，你将看到一个确认消息，如图 *7.7* 所示。
- en: '![Figure 7.7: The Home screen after a Task creation ](img/B16835_07_07.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7：创建任务后的主屏幕](img/B16835_07_07.jpg)'
- en: 'Figure 7.7: The Home screen after a Task creation'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7：创建任务后的主屏幕
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have created some tasks in the previous screen, the screen display might
    be different on your system.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在之前的屏幕上创建了一些任务，你的系统上的屏幕显示可能会有所不同。
- en: In this exercise, you created an almost fully functional to-do application in
    which you can create tasks and save them to the database, and even log your requests
    to see how long they take.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你创建了一个几乎完全功能化的待办事项应用程序，你可以创建任务并将它们保存到数据库中，甚至记录你的请求以查看它们花费了多长时间。
- en: Note
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/VVT4M](https://packt.link/VVT4M).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/VVT4M](https://packt.link/VVT4M) 找到用于此练习的代码。
- en: Now, it is time to work on an enhanced feature through an activity.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候通过一个活动来工作在增强功能上了。
- en: 'Activity 7.01: Creating a Page to Edit an Existing Task'
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.01：创建一个页面来编辑现有任务
- en: Now it's time to enhance the previous exercise with a new and fundamental feature
    that is, to move tasks across the Kanban board. You must build this application
    using the concepts covered in this chapter such as model binding, tag helpers,
    partial pages, and DI.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过一个新功能和基本功能来增强之前的练习，即移动看板板上的任务。你必须使用本章中涵盖的概念（如模型绑定、标签助手、部分页面和依赖注入）来构建此应用程序。
- en: 'To complete this activity, you need to add a page to edit the tasks. The following
    steps will help you complete this activity:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，你需要添加一个编辑任务的页面。以下步骤将帮助你完成此活动：
- en: Create a new file called `Edit.cshtml` with the same form as `Create.cshtml`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Edit.cshtml` 的新文件，其表单与 `Create.cshtml` 相同。
- en: Change the route at the page directive to receive `"/tasks/{id}"`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面指令中的路由更改为接收 `"/tasks/{id}"`。
- en: Create the code-behind file that loads a task by the `OnGet ID` from the `DbContext`
    schema. If the ID does not return a task, redirect it to the `Create` page.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个后端代码文件，通过 `OnGet ID` 从 `DbContext` 架构中加载数据。如果 ID 没有返回任务，则将其重定向到 `Create`
    页面。
- en: On the Post form, recover the task from the database, update its values, send
    a success message, and redirect to the Index view afterward.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Post 表单中，从数据库中恢复任务，更新其值，发送成功消息，然后重定向到 Index 视图。
- en: 'The output of a page is displayed as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的输出如下所示：
- en: '![Figure 7.8: The Edit Task Page as output to the activity ](img/B16835_07_08.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8：输出到活动的编辑任务页面](img/B16835_07_08.jpg)'
- en: 'Figure 7.8: The Edit Task Page as output to the activity'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：输出到活动的编辑任务页面
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: With the examples and activity so far, you now know how to develop pages with
    Razor. In the next section, you will learn how to work with a tool that has an
    even smaller scope of isolated and reusable logic called view components.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通过到目前为止的示例和活动，你现在知道如何使用 Razor 开发页面。在下一节中，你将学习如何使用一个具有更小范围隔离和可重用逻辑的工具，即视图组件。
- en: View Components
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图组件
- en: So far, you have seen two ways of creating reusable components to provide better
    maintenance and reduce the amount of code and that is tag helpers and partial
    pages. While a tag helper produces mainly static HTML code (as it translates a
    custom tag into an existing HTML tag with some content inside it), a `partial
    page` is a small Razor page inside another Razor page that shares the page data-binding
    mechanism and can perform some actions such as form submission. The only downside
    to `partial pages` is that the dynamic behavior relies on the page that contains
    it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了两种创建可重用组件的方法，以提供更好的维护并减少代码量，那就是标签辅助器和部分页面。虽然标签辅助器主要生成静态 HTML 代码（因为它将自定义标签转换为具有一些内容的现有
    HTML 标签），但`部分页面`是另一个 Razor 页面内的一个小型 Razor 页面，它共享页面数据绑定机制并可以执行一些操作，如表单提交。`部分页面`的唯一缺点是它的动态行为依赖于包含它的页面。
- en: This section is about another tool that allows you to create reusable components
    that is, view components. View components are somewhat similar to partial pages,
    as they also allow you to provide dynamic functionality and have logic on the
    backend. However, they are even more powerful as they are self-contained. This
    self-containment allows them to be developed independently of the page and be
    fully testable on their own.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于另一个允许你创建可重用组件的工具，即视图组件。视图组件在某种程度上类似于部分页面，因为它们也允许你提供动态功能并在后端有逻辑。然而，它们更强大，因为它们是自包含的。这种自包含性允许它们独立于页面开发，并且可以单独进行全面测试。
- en: 'There are several requirements for creating view components, as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图组件有几个要求，如下所述：
- en: The custom component class must inherit from `Microsoft.AspNetCore.Mvc.ViewComponent`.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义组件类必须从`Microsoft.AspNetCore.Mvc.ViewComponent`继承。
- en: It must either have the `ViewComponent` suffix in the class name or be decorated
    with the `[ViewComponent]` attribute.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须在类名中具有`ViewComponent`后缀或用`[ViewComponent]`属性装饰。
- en: This class must implement either a `IViewComponentResult Invoke()` synchronous
    method or a `Task<IViewComponentResult> InvokeAsync()` asynchronous method (when
    you need to call async methods from within).
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此类必须实现`IViewComponentResult Invoke()`同步方法或`Task<IViewComponentResult> InvokeAsync()`异步方法（当你需要从内部调用异步方法时）。
- en: The result of both previous methods is typically the `View(model)` method with
    the view component model as an argument. On the frontend, the default view filename
    should, by convention, be called `Default.cshtml`.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两种先前方法的典型结果是带有视图组件模型的`View(model)`方法。在前端，默认视图文件名应按惯例称为`Default.cshtml`。
- en: For the view to be rendered, it must be located in either `Pages/Components/{MY_COMPONENT_NAME}/Default.cshtml`
    or `/Views/Shared/Components/{MY_COMPONENT_NAME}/Default.cshtml`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了渲染视图，它必须位于`Pages/Components/{MY_COMPONENT_NAME}/Default.cshtml`或`/Views/Shared/Components/{MY_COMPONENT_NAME}/Default.cshtml`之一。
- en: If not located in any of the preceding paths, the location of the view must
    be explicitly passed as an argument on the `View` method returned in the `Invoke`
    or `InvokeAsync` methods.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不在上述任何路径中，视图的位置必须显式地作为参数传递给`Invoke`或`InvokeAsync`方法返回的`View`方法。
- en: This concludes the theoretical portion of this section. In the following section,
    you will put this into practice with an exercise.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本节的理沦部分。在下一节中，你将通过练习将其付诸实践。
- en: 'Exercise 7.06: Creating a View Component to Display Task Statistics'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.06：创建用于显示任务统计信息的视图组件
- en: 'In this exercise, you will create a view component that allows you to display
    some statistics regarding delayed tasks on the navbar of the application. Working
    through this exercise, you will learn the basic syntax of view components and
    how to place them in Razor Pages. Perform the following steps to do so:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个视图组件，允许你在应用程序的导航栏上显示有关延迟任务的统计信息。通过完成这个练习，你将学习视图组件的基本语法以及如何在 Razor
    页面上放置它们。执行以下步骤来完成此操作：
- en: Under the root of the `ToDoListApp` project, create a new folder called `ViewComponents`.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ToDoListApp` 项目的根目录下，创建一个名为 `ViewComponents` 的新文件夹。
- en: 'Inside this folder, create a new class called `StatsViewComponent`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，创建一个名为 `StatsViewComponent` 的新类：
- en: '[PRE68]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Again, inside the `ViewComponents` folder, create a new class named `StatsViewModel`
    with two public `int` properties, named `Delayed` and `DueToday`:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在 `ViewComponents` 文件夹内，创建一个名为 `StatsViewModel` 的新类，包含两个公共 `int` 属性，分别命名为
    `Delayed` 和 `DueToday`：
- en: '[PRE69]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Edit the `StatsViewComponent` class to inherit from the `ViewComponent` class
    that is contained in the `Microsoft.AspNetCore.Mvc` namespace:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `StatsViewComponent` 类，使其继承自 `Microsoft.AspNetCore.Mvc` 命名空间中包含的 `ViewComponent`
    类：
- en: '[PRE70]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Inject `ToDoDbContext` via a constructor initializing a `private readonly` field:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构造函数初始化一个 `private readonly` 字段来注入 `ToDoDbContext`：
- en: '[PRE71]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Place the proper `using` namespaces.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 放置正确的 `using` 命名空间。
- en: 'Create a method named `InvokeAsync` with the following signature and content:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InvokeAsync` 的方法，具有以下签名和内容：
- en: '[PRE72]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This method will use `ToDoDbContext` to query the database and retrieve the
    delayed tasks, as well as the ones that are due on the current day.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将使用 `ToDoDbContext` 查询数据库并检索延迟任务，以及当天到期的任务。
- en: Now under the `Pages` folder, create a new folder called `Components`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `Pages` 文件夹下，创建一个名为 `Components` 的新文件夹。
- en: Under it make another folder called `Stats`.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其下创建一个名为 `Stats` 的文件夹。
- en: 'Then, inside the `Stats` folder, create a new file called `default.cshtml`
    with the following content:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `Stats` 文件夹内，创建一个名为 `default.cshtml` 的新文件，内容如下：
- en: '[PRE74]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `default.cshtml` will contain the view part of the view component class.
    Here, you are basically creating a `.cshtml` file based on a model specified.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`default.cshtml` 将包含视图组件类的视图部分。在这里，你基本上是基于指定的模型创建一个 `.cshtml` 文件。'
- en: 'Finally, in `_Layout.cshtml` (under `Pages/Shared/`), add a call to the `ViewComponent`
    by adding the `<vc:stats></vc:stats>` tag inside your navbar. Replace the page
    code with the following:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `_Layout.cshtml`（位于 `Pages/Shared/` 下），通过在导航栏内添加 `<vc:stats></vc:stats>`
    标签来调用 `ViewComponent`。用以下代码替换页面代码：
- en: '[PRE75]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the application to see your navbar as shown in *Figure 7.8*:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序以查看如图 *7.8* 所示的导航栏：
- en: '![Figure 7.9: The Task stats view component ](img/B16835_07_09.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9：任务统计视图组件](img/B16835_07_09.jpg)'
- en: 'Figure 7.9: The Task stats view component'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9：任务统计视图组件
- en: In this exercise, you created your first view component which is a task stat
    displayed right on your navbar. As you may have noticed, one efficient thing about
    view components that distinguishes them from partial pages is that they are independent
    of the page they are displayed on. You build both your frontend and backend all
    self-contained inside the component, with no external dependencies on the page.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你创建了你的第一个视图组件，这是一个直接显示在导航栏上的任务统计信息。正如你可能已经注意到的，视图组件的一个高效之处在于它们与显示在页面上的页面无关。你将前端和后端都封装在组件内部，没有任何外部依赖。
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/j9eLW](https://packt.link/j9eLW).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/j9eLW](https://packt.link/j9eLW) 找到本练习使用的代码。
- en: This exercise covered view components, which allow you to display some statistics
    regarding delayed tasks on the navbar of the application. With this knowledge,
    you will now complete an activity wherein you will work in a view component to
    show a log history.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习涵盖了视图组件，这些组件允许你在应用程序的导航栏上显示有关延迟任务的统计信息。有了这些知识，你现在将完成一个活动，在这个活动中，你将在视图组件中工作以显示日志历史。
- en: 'Activity 7.02: Writing a View Component to Display Task Log'
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 7.02：编写一个用于显示任务日志的视图组件
- en: As the final step of this chapter, this activity will be based on a common task
    in real-world applications—to have a log of user activities. In this case, you
    will write every change the user does to a field to the database and display it
    in a view. To do so, you would need to use a view component.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的最后一步，这个活动将基于现实世界应用中的常见任务——记录用户活动。在这种情况下，你将把用户对字段的每个更改写入数据库并在视图中显示。为此，你需要使用视图组件。
- en: 'The following steps will help you complete this activity:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成此活动：
- en: 'Create a new class under the `Models` folder named `ActivityLog`. This class
    should have the following properties: `Guid Id`, `String EntityId`, `DateTime`
    `Timestamp`, `String Property`, `String OldValue`, and `String NewValue`.'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Models` 文件夹下创建一个新的类，命名为 `ActivityLog`。该类应具有以下属性：`Guid Id`、`String EntityId`、`DateTime
    Timestamp`、`String Property`、`String OldValue` 和 `String NewValue`。
- en: Create a new `DbSet<ActivityLog>` property for this model under `ToDoDbContext`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ToDoDbContext` 下为该模型创建一个新的 `DbSet<ActivityLog>` 属性。
- en: Under your `DbContext`, create a method to generate activity logs for the modified
    properties of `Entries` under the Entity Framework's `ChangeTracker` with `EntityState.Modified`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `DbContext` 下创建一个方法，使用 Entity Framework 的 `ChangeTracker` 中的 `EntityState.Modified`
    为 `Entries` 的修改属性生成活动日志。
- en: Override `SaveChangesAsync()` in `DbContext`, by adding the generated logs to
    `DbSet` right before calling the `base` method.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DbContext` 中重写 `SaveChangesAsync()` 方法，通过在调用 `base` 方法之前将生成的日志添加到 `DbSet`。
- en: Create a new Entity Framework Core migration and update the database to support
    this migration.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Entity Framework Core 迁移并更新数据库以支持此迁移。
- en: Create the `ViewComponent` class, which should load all logs for a given `taskId`
    passed on the invocation and return them to the `ViewComponent`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ViewComponent` 类，该类应加载在调用中传递的给定 `taskId` 的所有日志，并将它们返回给 `ViewComponent`。
- en: Create the `ViewComponent` view, which should take a collection of `ActivityLog`
    as a model and display them in a Bootstrap table, if any exists. If no logs are
    recorded, show an alert saying that no logs are available.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ViewComponent` 视图，该视图应接受一个 `ActivityLog` 集合作为模型，并在 Bootstrap 表中显示它们，如果有的话。如果没有记录日志，显示一个警告，说明没有可用的日志。
- en: Add the view component to the `Edit` page, passing the `taskId` property.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图组件添加到 `Edit` 页面，传递 `taskId` 属性。
- en: Run the application and check the final output by opening a task's details.
    You will see a box on the right with your activity logs or a message with no logs,
    if there are no activity logs recorded, for that task yet.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，通过打开任务详情来检查最终输出。你将看到一个右侧的框，其中包含你的活动日志，或者如果没有记录活动日志，将显示一条没有日志的消息，对于该任务还没有记录活动日志。
- en: '![Figure 7.10: The Activity log being displayed with no logs ](img/B16835_07_10.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10：没有日志的活动日志显示](img/B16835_07_10.jpg)'
- en: 'Figure 7.10: The Activity log being displayed with no logs'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10：没有日志的活动日志显示
- en: In this activity, you were able to create an isolated view component with completely
    new functionality that's decoupled from a page, allowing it to work on a single
    feature at a time.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你能够创建一个具有完全新功能且与页面解耦的独立视图组件，使其能够一次处理一个功能。
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: Summary
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the foundations of building a modern web application
    with C# and Razor Pages. You focused on important concepts at the beginning of
    the chapter, such as middleware, logging, DI, and configuration. Next, you used
    Razor Pages to create CRUD models along with Entity Framework and used some more
    advanced features, such as custom tag helpers, partial pages, and view components,
    which enable you to create more easily maintainable application features.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了使用 C# 和 Razor Pages 构建现代 Web 应用程序的基础。你专注于章节开头的重要概念，例如中间件、日志记录、DI 和配置。接下来，你使用
    Razor Pages 创建了 CRUD 模型，并使用了一些更高级的功能，如自定义标签助手、部分页面和视图组件，这些功能使你能够更轻松地创建可维护的应用程序功能。
- en: Finally, you saw how ASP.NET model binding works so that there can be a two-way
    data binding between the client and the server. By now, you should have an effective
    foundation for building modern web applications with ASP.NET and Razor Pages on
    your own.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你看到了 ASP.NET 模型绑定的工作原理，以便在客户端和服务器之间实现双向数据绑定。到目前为止，你应该已经具备了使用 ASP.NET 和 Razor
    Pages 独立构建现代 Web 应用程序的有效基础。
- en: Over the next two chapters, you will learn about building and communicating
    with APIs.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，你将学习如何构建和与 APIs 通信。
