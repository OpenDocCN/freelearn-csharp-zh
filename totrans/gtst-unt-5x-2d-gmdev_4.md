# 第四章. 不再孤单 - 甜食熊猫出击

> *"他们生气又饿。小心，甜食熊猫正靠近你的美味蛋糕！*

动画和人工智能是赋予游戏中的**非玩家角色（NPCs**）或复杂物体生命力的核心。前者使NPC看起来动态而非静态；后者赋予它们智能，使它们能够在世界中移动和行动。

本章解释了如何使用Unity的动画系统，特别是关注2D动画。我们将在本书的后面部分介绍人工智能及其在视频游戏中的功能。

本章的第一部分将重点关注Unity丰富而复杂的动画系统（有时称为Mecanim）。在解释每个部分时，我们将逐步将我们的邪恶熊猫栩栩如生。

然而，在章节的第二部分，我们将给邪恶的熊猫移动地图的可能性，触发死亡或吃太多蛋糕以至于爆炸等动作... *字面上的*！

尤其是以下内容：

+   动画剪辑及其从精灵图集中创建和处理方法

+   Animator及其如何为动画构建有限状态机

+   使用Animator组件脚本化对象以触发动画并使动画机器工作

+   实现路径点系统以移动甜食熊猫

就像本书的所有其他章节一样，你将在结尾找到*作业*部分。它包含一系列不同的练习，以提高你的技能并在你的游戏中实现各种不同的功能。所以，让我们准备好学习如何让我们的邪恶熊猫栩栩如生。

# 准备工作

我们用于本书的图形包包含一个动画精灵图集，用于我们可怕的甜食熊猫。因此，请确保将精灵图集导入为**精灵**，并将**精灵模式**设置为**多个**。实际上，你应该将所有单独的帧放在不同的精灵中。记住重命名它们，这样你以后就不会那么困惑了。如果你使用自己的图形，这也适用。

![准备工作](img/image00445.jpeg)

一只邪恶的熊猫正期待着吃你的蛋糕

# 动画

生命及其所有生物都是动态的。我们移动，我们的动作，即使是微妙的动作，也表达着情感。如果我们移除这些事物，即使是微小的微笑，生命也会变得乏味和静态。动画效果可以从最简单的事物，如旗帜挥舞，到龙飞翔。只需环顾四周，无论是室内还是室外；总会有东西在移动，或者时不时地移动。即使是石头也会移动，尽管是风吹，或者有人从水面上跳过它们。

Unity 拥有一个复杂的动画系统，也称为 **Mecanim**，需要时间来习惯。它包括不同的组件。其中一些是专门用于 3D 动画的；其他则可以用于 2D 和 3D。通常，3D 动画比 2D 动画更难，因为它需要调整许多参数，因此需要更多的实践来掌握它。如果你对在 Unity 中学习 3D 动画感兴趣，我建议你阅读关于它的特定书籍。

在这本书中，我们将专注于仅进行 2D 动画。因此，我们的工作流程足够简单，可以在本章中解释。特别是，我们将进行以下工作流程：

+   创建一些名为动画剪辑的文件，以存储我们的动画。我们将从动画 Sprite Sheets 开始做这件事。

+   构建一个有限状态机来控制动画的流程。

+   编写一个脚本以控制有限状态机的触发器。

具体来说，在本节中，我们将看到如何为我们的糟糕甜食爱好者熊猫进行动画制作。在我们的图形包中，我们可以在 `Graphic/Enemies` 文件夹下找到熊猫的动画 Sprite Sheets。当然，所有的 Sprite Sheets 应该已经切片，正如我们在 [第 1 章](part0016.xhtml#aid-F8901 "第 1 章。Unity 中的平面世界")，*Unity 中的平面世界* 中所看到的，如果你使用自己的图形，最好所有单个精灵都有相同的尺寸。但在我们进一步探索 Mecanim 之前，让我们在接下来的两个部分中了解一些关于动画的背景信息。

## 历史概述

术语 *animation* 来自拉丁语单词 *animates*，它是动词 *animare* 的过去分词；这意味着 *赋予生命*。这个动词来自单词 *anima*，意思是 *生命，呼吸*，起源于希腊语单词 *anemos*，字面意思是 *风*，它又源自梵文单词 *aniti*，意思是 *呼吸*。直到 1742 年，动词 *to animate* 才第一次被用来表示 *赋予生命* 的意思。

现代动画基于运动的概念。因此，值得一提的是，关于运动的第一项研究是在公元前 4 世纪由希腊哲学家 *Ζήνων ὁ Ἐλεάτης*（在英语中被称为 *Zeno of Elea*）进行的。我们可以在另一位希腊哲学家 *Ἀριστοτέλης*（在英语中被称为 *Aristotle*）的作品中读到许多他的想法。Zeno 以构想许多关于运动的悖论而闻名，探索这个问题以证明运动的不存在。其中一个悖论是箭悖论（也称为 **Fletcher's paradox**）。我们可以从亚里士多德的《物理学》第四卷中读到一些关于这个悖论的内容，如下所示：

> *"如果一切在占据相等空间时都是静止的，如果运动中的物体在任何时刻都占据这样的空间，那么飞箭因此就是静止的。"*

![历史概述](img/image00446.jpeg)

亚里士多德描述的芝诺的飞矢悖论。你并没有看到箭头向目标移动，而只是看到箭头静止在某个位置上的瞬间，尽管这些位置各不相同。因此，运动是一种错觉。

如前图所示，悖论声称箭头的静止状态，因为箭头在每一瞬间都在空间中的一个非常特定的位置，并且在这一瞬间是静止的。除了悖论的多重哲学含义和解决方案之外，值得注意的是，同样的概念现在也适用于动画。电影和视频游戏（仅举几个例子）中的动画只是一系列静态帧，这些帧以快速连续的方式给出运动错觉。

## 视频游戏中的动画

动画有助于使我们的创作栩栩如生。它们使生活更加生动，使死者更加令人毛骨悚然！自从像素艺术图形发展到只能用“运动怪异谷”来形容的程度，动画的发展已经走了很长的路。在某些情况下，动画如此逼真，以至于我们一时忘记了我们身处一个不同的现实。

现在，让我们回到游戏动画的起点。太空侵略者、大金刚和暴风雨。如果你曾经玩过这些游戏中的任何一个，那么当你听到“很多内容可以通过非常简单的动画传达”时，你会明白我的意思。无论是太空侵略者横向移动，大金刚跳跃躲避油桶，还是暴风雨中的旋转，都是如此。然而，随着时间的推移，我们变得非常熟悉的动画技术也在不断发展。随着3D游戏和随之而来的角色的引入，我们看到动画进入了另一个维度……字面上的。但尽管它们的身体是多边形的，动作是刻板的，比如以下劳拉·克劳馥的图像（尽管现在不那么明显了），动画使我们能够简单地与游戏互动。

![视频游戏中的动画](img/image00447.jpeg)

取自《古墓丽影》中劳拉·克劳馥的游戏画面

在包含动画背后的一个良好哲学是，将动画视为与观众沟通的一种方式。有时，像爱、兴奋和仇恨这样的情感是传达感受的好方法，就像跑步、跳跃和攻击这样的身体动作是表明玩家当前体验状态的好方法。然而，动画不仅仅包括玩家；树木、动物以及那些不玩游戏或NPC也会在游戏空间中互动和移动，有时就像任何受控玩家一样。使用动画与NPC的一些最典型的例子是在**角色扮演游戏**（**RPGs**）中。

你与之互动的许多角色都会对你产生某种感觉。例如，如果你总是用简短的反应回答他们，他们很可能会表现出轻蔑或震惊的表情，就像下一张图片所示。另一方面，如果你热情友好，并伸出援手，那么他们的表情可能会更加欢迎。

![视频游戏中的动画](img/image00448.jpeg)

Shepard，显然没有在笑一个笑话（质量效应系列）

时间就是一切，所以当涉及到动画时，确保它们在应该发生的时候发生。按***X***键跳跃，而跳跃却在3秒后才发生，这对你的游戏或玩家来说都不会有好的结果。仅仅为角色或物体制作动画是不够的，你必须将它们组合起来以创造一个沉浸式的环境。如果你想让玩家再次回来，那么沉浸在游戏中是至关重要的。如果你有笨拙的动画导致玩家沮丧，那么玩家可能不会坚持下去，除非故事极其吸引人。即使在大多数游戏中，树木也会进行动画处理，即使只是细微的摇摆或随风摇曳的树叶。这样，它比从地面上伸出的大木桩要好得多。

在考虑动画时，还有另一件事需要考虑，那就是帧率和相应的硬件。你可能有一个精彩的动画序列，比如在《最终幻想VII：核心危机》中Sephiroth、Genesis和Angeal之间的史诗级场景（如以下图片所示）；另一个例子是在《战地4》中杀敌时的游戏画面。但如果有延迟，那基本上就没什么了！当为Unity创建游戏时，考虑这一点非常重要，尤其是当你针对移动设备时。虽然许多移动设备能够播放一些资源密集型的媒体，但并非所有都能。因此，如果你的最终设备无法跟上，你的辛勤努力很可能会白费，除非当然你找到了另一个目标设备。这在移动设备上的3D游戏中尤为常见，你可以在官方Unity文档中了解更多信息：[https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html](https://docs.unity3d.com/Manual/MecanimPeformanceandOptimization.html)。

### 小贴士

我建议你在完成本章后访问前面的链接，以便更好地了解Unity中的动画系统。

![视频游戏中的动画](img/image00449.jpeg)

Genesis和Sephiroth在《最终幻想VII：核心危机》中的战斗游戏截图

### 小贴士

查看这个网站，了解一些在移动游戏中使用动画的绝佳技巧：[www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging](http://www.teksmobile.com.au/blog/15-animation-tips-to-make-your-mobile-games-more-engaging)。

既然我们已经对视频游戏中的动画有了概述，让我们回到 Unity，了解它如何处理动画，从一般的工作流程开始。

## 动画工作流程

既然我们已经了解了动画对视频游戏的重要性，让我们更深入地了解一下。Unity 的动画系统基于动画片段的概念；我们将在下一节中更详细地探讨这一点。正如其名所示，它们只是包含单个动画数据的片段（有一些例外）。

动画片段被组织成一个类似于流程图系统的结构，其中不同的节点相互连接（如下一张截图所示）。这个系统被称为动画控制器（Animator Controller），它充当状态机。它跟踪当前应该播放哪个片段，并确定何时动画应该改变或混合在一起。

![动画工作流程](img/image00450.jpeg)

一个非常简单的动画控制器可能只包含少量片段。例如，一个片段可能是一个物体破碎，另一个是风扇旋转。另一方面，一个更高级的动画控制器可能包含更多的动画，例如与主要角色相关的所有动作，如跑步、行走、闲置、死亡等。此外，动画可以在多个片段之间混合，以看起来更流畅，更不机械，除非当然这是您的意图！

Unity 的动画系统也拥有许多特殊功能，尤其是在使用类人角色时。这些功能允许您从任何来源重新定位类似人类或类人动画，例如动作捕捉、Unity 资产商店，或如 Maya 或 Blender 这样的软件，然后将它们应用到自己的角色模型上。除了应用这些动画外，您还可以调整角色的肌肉定义。这些特殊功能是通过 Unity 的 Avatar 系统实现的，其中类人角色被映射到一个通用的内部格式（我们不会在这里详细讨论，但您可以在章节末尾的选读部分了解更多信息）。

最终，动画片段、动画控制器和 Avatar 通过动画组件在 gameObject 上汇集在一起。该组件引用一个动画控制器（如果需要）以及相应模型的 Avatar。反过来，动画控制器包含它所使用的动画片段的引用。

## 动画片段和动画组件

Unity动画系统的核心是动画剪辑。这些组件包含与对象动画相关的信息，例如它们是否需要在动画过程中改变它们的平移（位置）、旋转等。动画剪辑可以是2D或3D，通常在3D Studio Max、Flash、Maya、Blender甚至Photoshop等程序中创建。除了使用软件，动画还可以手动创建，例如为3D角色绑定（给它一个可以移动的骨架）或创建逐帧移动的精灵，其中每个动作都是单独绘制的。还记得那些老迪士尼卡通吗？嗯，他们使用了类似的过程带给我们一些最珍贵的记忆。然而，如果你的游戏需要的东西不是很复杂，比如开关门，你可以在Unity中做到这一点。Unity提供了一个名为动画窗口的工具（本章后面将详细介绍）。

在2D的情况下，这些动画剪辑可以包含任意序列的精灵，就像电影中的单帧一样，并且随着时间的推移改变它们，以产生运动的错觉。通常，在2D游戏开发中，精灵图用于这些目的（正如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中预期的，*Unity中的平面世界*)。因此，我们的图形包中也包含这些动画精灵图。

![动画剪辑和Animator组件](img/image00451.jpeg)

关于动画剪辑的另一种有用的思考方式是想象它们是动作，比如捡起一个物体、行走或跳跃。

### 注意

在大多数高级情况下，动画剪辑可以包含一个动作的一部分，可以与其他动画剪辑混合或合并。

对于我们的熊猫，我们有以下动画：

+   **行走**：当我们的熊猫沿着路径移动时

+   **死亡**：当玩家的杯子蛋糕塔将熊猫击倒时

+   **击中**：当玩家的杯子蛋糕塔击中熊猫时

+   **吃**：当熊猫到达关卡末尾并吃掉玩家蛋糕的一块

因此，我们需要创建四个不同的动画剪辑，每个对应这些中的一个。

### 使用控制器创建动画剪辑

本节中解释的方法是一种快速创建第一个动画剪辑的方法，从精灵图开始，并且作为副作用，会创建一个控制器。然而，我们将在本章的后面处理它。

首先，在场景中创建一个空的游戏对象，并将其重命名为`Panda`（或者如果你愿意，`Sweet-Tooth_Panda`）。最终，当你完成对这个对象的工作后，你希望将其存储在一个预制体中。

现在在项目面板中，如果我们选择`animation_panda_sprite_sheet`并展开它，我们会看到如下内容：

![使用控制器创建动画剪辑](img/image00452.jpeg)

动画的单个精灵/帧应该具有相同的大小。通过在开始时确保这一点，它可以帮助你避免以后出现许多头痛问题。因此，如果精灵图已经做得很好，它应该可以在精灵编辑器中的**按单元格计数网格**模式下轻松切片，就像我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中做的那样。在我们的包中，我们的精灵图已经准备好了，每个精灵均匀分布，但如果你使用自己的图形，并且精灵图没有所有帧的大小相同，你可能需要在图形程序（如Photoshop或Gimp）中修改它，以便精灵相应地分布。

这是精灵编辑器中的最终结果：

![使用控制器创建动画片段](img/image00453.jpeg)

然而，如果你移动项目面板底部滑块（正如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中学习的），你将能够看到所有单个精灵，如下图所示：

![使用控制器创建动画片段](img/image00454.jpeg)

选择属于行走熊猫动画的所有精灵，并将它们拖动到我们之前创建的**熊猫**游戏对象上：

![使用控制器创建动画片段](img/image00455.jpeg)

在我们的案例中，行走动画有11个精灵，然后是5个击打动画的精灵，10个死亡动画的精灵，最后是16个进食动画的精灵

### 小贴士

有可能最后一张精灵图与第一张相同。根据情况，你可能不希望它因为很可能会在动画中引起中断，比如行走序列中的延迟。在这种情况下，你只需选择除了最后一张之外的所有精灵。

Unity会询问你将动画剪辑保存到何处以及使用哪个名称。我们可以将其命名为`Panda_Walk_Animation`并将其保存在我们的`Animation`文件夹中。如果你没有它，你可以在`Asset`文件夹下创建它。这样，正如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中讨论的，我们可以保持我们的项目整洁有序。

当我们选择`Panda`对象时，我们可以在检查器中注意到已经添加了两个组件。一个是**精灵渲染器**，我们已经在之前的章节中讨论过。另一个是**动画器**组件。让我们在下一节中详细了解它。

![使用控制器创建动画片段](img/image00456.jpeg)

### 注意

如果你导航到**动画**文件夹，除了我们刚刚创建的动画文件外，你还会找到一个名为`Panda`（或`Sweet-Tooth_Panda`，因为名称是从游戏对象中取的）的动画控制器。为了我们的目的，最好将其重命名为更描述性的名称，例如`PandaAnimatorController`。我们将在本章后面了解更多关于它的内容。

### 动画组件

Animator组件的主要功能是持有Animator Controller的引用，它定义了我们的动画剪辑应该如何播放。此外，它控制何时以及如何混合和/或在这之间进行过渡。我们将在下一节中探讨控制器。

Animator组件有一些可以调整的参数。让我们看看主要的几个：

+   **控制器**：这是Animator Controller的引用，是最重要的变量。如果没有设置，Animator组件将无法工作。在前面的图片中，控制器设置为`Panda`（或者如果您已重命名它，则为`PandaAnimatorController`），这是我们刚刚创建的控制器。

+   **Avatar**：仅适用于3D人形角色参数，您可以忽略它（然而，如果您想了解更多，请查看本章后面的*关于动画的更多信息*部分）。

+   **应用根运动**：您也可以忽略这一点（然而，如果您想了解更多，请查看*关于动画的更多信息*部分）。

+   **更新模式**：指定Animator何时更新以及它应该使用哪个时间尺度。**正常**模式与更新调用同步更新控制器，Animator的速度与当前时间尺度匹配。如果时间尺度减慢，动画也会减慢以匹配。**Animate Physics**模式则相反，它与**FixedUpdate**调用同步更新Animator，这些调用由物理引擎使用。这在您所动画化的对象具有物理交互时很有用，例如，如果角色需要推动或拉动一个刚体（关于物理的更多内容将在下一章中介绍）。最后，**Unscaled Time**模式与更新调用同步更新Animator，就像**正常**模式一样，但当前时间尺度被忽略，它总是以100%的速度播放。例如，当您暂停游戏但仍然想要动画化部分UI或暂停菜单本身时，此模式很有用。

+   **剔除模式**：指定动画的剔除模式（关于这一点将在本章后面的*关于动画的更多信息*部分中详细介绍）。

此外，在Animator组件的底部，有一个包含有关我们使用的Animator控制器一些有用信息的信息框。目前，唯一相关的信息是**剪辑数量**，它告诉您控制器使用了多少个动画剪辑。您可以在*关于动画的更多信息*部分了解更多关于这个信息框的内容。

![Animator组件](img/image00457.jpeg)

### 创建其他动画剪辑

现在，我们需要分别为熊猫死亡、吃或被击中时创建剩余的动画片段。这次，我们不想生成控制器。我们有两种选择。第一种，我们仍然像之前那样将其他组精灵拖放到**熊猫**游戏对象上。结果，Unity仍然会要求为动画片段命名和指定位置，但不会生成另一个控制器。这是最快的方法。然而，还有另一种方法。它涉及到**动画**窗口，但为了学习，我们将使用第二种方法来创建剩余的动画片段。

要这样做，打开**动画**窗口（点击**窗口**菜单栏上的**动画**或使用快捷键*Ctrl* + **6**）。然后，从**层次结构**面板中选择你的**熊猫**。你应该会看到如下内容：

![创建其他动画片段](img/image00458.jpeg)

**动画**窗口允许你在Unity中创建动画。它使用关键帧之间的插值技术来计算每帧之间的位置和旋转（以及其他参数）。它还支持录制功能以及曲线编辑器。在2D游戏开发中，如果可用动画精灵表（如我们的情况），则不太使用此功能（除非你需要微调动画）。然而，这是一个重要的工具，可以避免需要第三方程序来创建你的动画。此外，它还适用于原型设计动画。不幸的是，我们在这章中没有足够的空间详细讨论**动画**窗口，但你可以在官方文档中了解更多信息：[https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html](https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html)。

然而，在我们的情况下，我们只是用它来从我们的精灵开始创建和保存动画片段。正如我们可以从前面的图片中注意到的那样，在上一个部分中已经创建了一个行走动画。要创建一个新的动画片段，点击**Panda_Walk_Animation**，应该会出现如下下拉菜单：

![创建其他动画片段](img/image00459.jpeg)

点击**创建新片段...**，Unity会询问你保存新文件的位置和名称。我们可以将其命名为`Panda_Die_Animation`并在`Animations`文件夹中保存。结果，**动画**窗口现在应该已经清空，如图所示：

![创建其他动画片段](img/image00460.jpeg)

现在，我们可以选择死亡动画的精灵，并将它们拖放到窗口中。因此，精灵动画被加载到动画文件中，正如我们可以从动画窗口中看到的那样：

![创建其他动画片段](img/image00461.jpeg)

我们需要重复这个过程来创建击中和吃动画。最后，你应该在`Animations`文件夹中有以下文件：

![创建其他动画片段](img/image00462.jpeg)

有一点要注意。如果你点击其中一个，在**检查器**中，你可以看到一些选项，关于动画是否可以循环播放以及如何播放，还有一个信息框，显示动画的一些数据量，例如肌肉数量（但这是针对3D动画的，我们不会使用这些信息）。

![创建其他动画剪辑](img/image00463.jpeg)

并非所有的动画都旨在循环播放。实际上，除了走路动画之外，其他所有动画都不应该循环播放。因此，对于它们，只需在**检查器**中取消勾选**Loop Time**变量，就像这样：

![创建其他动画剪辑](img/image00464.jpeg)

到目前为止一切顺利。在你继续之前，我建议你在`Prefab`文件夹中创建一个新的预制件，命名为`PandaPrefab`，并将你的**熊猫**拖放到那里。

## 动画师

想象一下你一天中执行的所有不同类型的动作——从你醒来，到煮咖啡、洗澡、准备上班。每个动作都会有不同的动画。对于角色来说也是如此。在大多数游戏中，角色或其他动画对象（动物、树木等）都有一系列动画。就像我们之前的例子一样，每个动画都会对应游戏过程中的不同时刻。例如，当一个角色只是站立并处于闲置状态时，他们并没有做什么，但他们很可能会继续呼吸。在一些游戏中，如果角色长时间闲置，那么就会触发其他动画序列，比如不耐烦的脚趾敲击或完全出乎意料的事情。在第一人称射击游戏中，游戏环境中的物体可能能够被子弹或力量（比如用力撞墙）影响，因此它们可能会破碎、开裂、打开或甚至关闭。Mecanim使用类似于流程图的视觉布局系统来表示状态机，并允许你控制并编排你想要在角色或对象上使用的动画剪辑。我们将在稍后详细讨论这一点。

### 动画师窗口

动画师窗口允许你在Unity中创建、查看和修改动画控制器资产。

现在我们有了所有的动画文件，我们需要以有意义的方式将它们嵌入到动画控制器中。如果你双击`PandaAnimatorController`，动画师窗口就会打开，你应该有一个类似于以下屏幕的界面：

![动画师窗口](img/image00465.jpeg)

### 注意

如果你在矩形框内看不到你的熊猫动画，就像前面的图片那样，可能是因为你没有将动画窗口链接到控制器就创建了动画剪辑。这不是问题；你只需要在控制器中选择你想要的动画剪辑，并将它们拖入**动画师**窗口，它们就会被添加。

**动画器**窗口分为两个部分。深灰色网格的主区域是布局区域。您可以使用此区域在您的动画控制器中创建、排列和连接状态。

您可以在网格上右键单击以创建一个新的状态节点。使用中间鼠标按钮或***Alt*** /Option，拖动以在视图中平移。点击以选择状态节点，以便在**检查器**中编辑它们，并点击并拖动状态节点以重新排列状态机的布局，如下所示：

![动画器窗口](img/image00466.jpeg)

这样，我们的状态机将更加清晰和整洁，以便我们进行操作。**动画器**窗口的第二部分是左侧面板，可以在**参数**选项卡和**层**选项卡之间切换（如果您想了解更多关于层的信息，可以阅读本章的可选部分，*更多关于动画*部分中的**动画器**中的**层**）。**参数**选项卡允许您创建、查看和编辑动画控制器参数。这些是您定义的变量，它们将作为输入进入状态机。我们很快就会详细了解它们。

此外，打开或关闭眼睛图标（在下一张图片中突出显示以便轻松定位）将显示或隐藏**参数**和**层**侧边栏，这为您提供了更多空间来查看和编辑您的状态机。

![动画器窗口](img/image00467.jpeg)

此外，如果我们启用右上角的上锁图标（如下一张图片所示），我们就能使**动画器**窗口始终聚焦于当前状态机。如果上锁图标被禁用，点击新的动画器资产或带有动画组件的游戏对象将切换**动画器**窗口。因此，我们就能展示该对象的州机。锁定窗口的好处是，它允许我们保持**动画器**窗口不显示相同的州机，无论选择了哪些资产或游戏对象。

![动画器窗口](img/image00468.jpeg)

最后一个有用的切换（位于上锁图标下方）是**自动实时链接**，它允许我们在运行时看到机器的实际运行情况。为了您的方便，它在以下图片中突出显示，但当我们需要测试我们正在构建的机器时，我们会更多地讨论它：

![动画器窗口](img/image00469.jpeg)

### 动画器状态机

正如我们之前提到的，动画控制器是一个流程图系统；具体来说，它是一种有限状态机。但什么是有限状态机？从维基百科，我们可以读到：

> *"有限状态机（FSM）或有限状态自动机（FSA，复数：automata），或简单地称为状态机，是一种用于设计计算机程序和时序逻辑电路的计算数学模型。它被构想为一个可以处于有限多个状态之一的抽象机器。机器在任何给定时间只处于一个状态；它在任何给定时间所处的状态称为当前状态。当由触发事件或条件启动时，它可以从一个状态转换到另一个状态；这称为转换。特定的FSM由其状态列表、初始状态以及每个转换的触发条件定义。"*

在我们的特定情况下，状态将是动画。所以，说我们的动画师是特定的状态意味着具有该动画师控制器的游戏对象正在播放该特定动画。如果现在还不完全清楚，我们将在稍后解释不同的部分。

### 注意

我们将在本书的后面部分更详细地探讨有限状态机，当我们处理人工智能时。

当我们创建第一个动画剪辑时，Unity为我们生成了一个动画师控制器。但如果你需要手动创建它，这里是如何做的。从**项目**面板（可能在一个有意义的文件夹中，例如`Animations`），右键单击并选择**创建** | **动画师控制器**。一旦重命名，双击它以在**动画师**窗口中打开它。与自动生成的控制器不同，它已经包含了我们熊猫动画的所有状态，这里没有这样的状态。实际上，我们需要手动导入它们。在我们的熊猫案例中，我们只需要从**项目**面板中选择我们之前创建的动画文件，并将它们拖放到**动画师**窗口的网格中。如果你记得，我们把它们存储在`Animations`文件夹中。始终记住，你可以通过拖动来移动任何状态。这很有用，因为你可以重新组织状态，以便有一个视觉顺序并提高你工作的可读性。

现在，是时候深入挖掘，看看如何为我们的熊猫实际构建一个动画机。如果你创建了一个新的动画师控制器，请丢弃它，让我们使用之前的一个。

### 动画师状态

动画使角色栩栩如生，因此动画状态为Unity中的动画状态机提供了基础。每个状态都包含一个独立的动画序列（或混合树），例如跑步、行走、攀爬、跳跃等。所有这些动画序列将在角色处于相应状态时被触发并播放。当游戏中的事件触发状态转换，例如玩家在跑步时跳过边缘，角色将保持在新的状态，其动画序列将随后接管。

当你在动画师控制器中选择一个状态时，你将在检查器中看到该状态的属性，如图所示：

![动画状态](img/image00470.jpeg)

这些属性及其功能在此列出：

+   **名称**：这是在Animator中引用状态的方式，也是显示在状态顶部的名称。如果它是从动画自动生成的，默认情况下，它将具有与动画片段相同的名称。实际上，我们的四个熊猫状态与它们的相应动画片段具有相同的名称。

+   **标签**：识别状态或一组状态的一种方式。当需要从脚本中控制动画机器时很有用。就我们的目的而言，我们可以将其留空。

+   **动作**：这是分配给此状态的动作片段，例如，我们之前创建的动画片段之一，如`Panda_Walk_Animation`或`Panda_Die_Animation`（实际上，它也可以是一个混合树；请参阅本章后面的可选部分*更多关于动画*）。

+   **速度**：动画的默认速度。例如，动画的默认速度可能过慢，比如跑步动画，因此需要提高速度。通过改变**速度**的值，动画可以播放得更快。

+   **乘数**：一个乘以**速度**的数字，以增加或减少速度。旁边有一个参数复选框。这允许我们将这个数字转换为动画参数（请注意，乘数不能有独立的价值，只能链接到浮点参数）。这样，我们可以控制某些动画的速度，而无需触摸**速度**设置（假设它们都链接到相同的参数）。

+   **镜像**：是否应该镜像状态，这意味着动画片段应该像镜子中播放，左右互换。这仅适用于3D人形动画，因此我们不会处理它。注意，这可以转换为布尔参数。

+   **循环偏移**：确定动画循环是否应该从不同的点开始，该值表示从动画开始处的偏移量。此外，它还充当**乘数**，可以设置为参数。

+   **足部逆运动学**：是否应该尊重此状态的**足部逆运动学**？这适用于3D人形动画，因此我们不会处理它。

+   **写入默认值**：这决定了AnimatorStates是否将默认值写回未由其动作动画化的属性。默认情况下，它设置为true，但取消选中它意味着状态的非动画属性将保持它们之前的价值。

+   **过渡**：从这个状态起源的过渡列表。它等同于确定在什么条件下这个状态会变成另一个状态。我们将在接下来的几个部分中详细讨论过渡。

+   **添加行为**：关于此按钮的描述请参阅本章后面的可选部分*更多关于动画*。

默认状态，以棕色显示，是机器首次激活时将处于的状态。如果你想，你可以通过在另一个状态上右键单击并从上下文菜单中选择**设置为层默认状态**来更改状态机的默认状态。

![动画状态](img/image00471.jpeg)

在我们的案例中，默认状态是**Panda_Walk_Animation**状态，所以请确保它被选为默认状态。此外，要添加新状态，在**Animator Controller**窗口的空白区域右键单击，并从上下文菜单导航到**创建状态** | **空**。另一种创建状态的方法，正如我们之前指出的，是将动画拖入**Animator Controller**窗口，结果，你将创建包含该动画的状态。

就我们熊猫的动画状态而言，我们没有特别的需要或设置去调整。毕竟，我们构建的是一个相对简单的有限状态机，与大型、复杂的3D动画机器相比。但是，如果你在任何时候觉得我们拥有的四个动画中有一个太快或太慢，只需选择它并改变其速度。在这种情况下，你可以在我们完成状态机之后进行，以便更好地全面了解熊猫动画，并调整这些值来改进它。例如，我将行走、击打和进食动画的速度减慢到25%，这意味着速度为0.25，而对于死亡动画，我使用了0.2。通常，你通过试错来找到这些值。

### 注意

注意，你只能将Mecanim动画拖入控制器；非Mecanim动画将被拒绝。此外，状态不一定只包含单个动画剪辑。实际上，它们也可能包含混合树。你可以在本章后面的可选部分*关于动画的更多内容*中了解更多关于它们的信息。

#### 特殊状态

动画机也有一些特殊状态，如图中所示：

![特殊状态](img/image00472.jpeg)

**任何状态**是一个始终存在的特殊状态。**任何状态**意味着它不能是转换的终点。例如，跳转到*任何状态*不能用作选择随机状态进入下一状态的方法。**任何状态**存在于你想无论当前处于哪个状态都要进入特定状态的情况。这是向你的机器中添加相同的外部转换的更简单方式。**进入**和**退出**是确定动画状态机开始和结束的状态。

### 注意

有其他特殊状态来处理子机。有关更多信息，请参阅本章后面的*关于动画的更多内容*部分。

### 动画参数

如我们之前所介绍，在**动画器**窗口的左侧，有两个标签页：**层**，这里我们不会处理（但我提醒你，你可以阅读可选的*动画器中的层*部分），以及**参数**，我们将在本节中学习。

![动画器参数](img/image00473.jpeg)

动画**参数**是在**动画控制器**内定义的变量。这些参数可以从脚本中访问并分配它们的值。因此，脚本可以控制或影响状态机的流程。例如，脚本可以设置一个参数，指示动画应该播放多快，例如跑步或行走；这些可以是相同的动画，只是以不同的速度播放。在更复杂的行为中，相同的参数可以是根据玩家的输入在合适的行走动画和跑步动画之间切换的条件。

要添加一个参数，点击图中突出显示的小+按钮：

![动画器参数](img/image00474.jpeg)

### 注意

然而，如果你想删除一个参数，请在列表中选择该参数，然后按*删除*键。

出现一个下拉菜单，询问我们想添加哪种类型的参数：

![动画器参数](img/image00475.jpeg)

它们可以是四种基本类型：

+   `Int`：一个整数（整个数）

+   `Float`：一个带有小数部分的数字

+   `Bool`：一个真或假值（由复选框表示）

+   `Trigger`：一个布尔参数，当被过渡消耗时由控制器重置（由圆形按钮表示）

可以使用`Animator`类中的函数从脚本中为参数分配值，具体来说，以下函数具有自解释性：`SetFloat()`、`SetInt()`、`SetBool()`、`SetTrigger()`和`ResetTrigger()`。

正如我们已经看到的，参数可以链接到过渡条件，甚至可以链接到状态变量（例如速度乘数），然后由脚本控制。以一个例子来说明，假设你的游戏中的女主角正在骑马。脚本可以根据玩家踢马的程度改变一个浮点参数，该参数与奔跑动画的速度乘数相链接。结果，马的动作将根据玩家的输入（如果玩家正在控制你的女主角）实时改变，马会跑得更快。

然而，对于我们的塔防游戏，我们只需要触发器，特别是三个：一个用于熊猫被击中时，另一个用于它到达终点并吃掉蛋糕时，最后一个用于它在被喷溅击中时死亡。我们可以分别将它们命名为`HitTrigger`、`EatTrigger`和`DieTrigger`。最后，你应该看到以下内容：

![动画器参数](img/image00476.jpeg)

### 注意

当然，这并不是实现此系统的唯一方法。请参阅后面的*状态机行为*部分，了解如何在状态内使用行为，以便在*作业*部分您可以使用这种新技术进行自我测试，以以不同的方式实现此类行为。

### 动画师过渡

过渡使我们能够从有限状态机的当前状态切换到另一个状态。当满足某些条件时，它们可以被触发。正如其名称所暗示的，它们处理当前状态如何过渡到目标状态以及这两个状态应该如何合并以实现平滑过渡。

它们表示为两个状态之间的单向箭头。要创建两个状态之间的新过渡，请从过渡应开始的状态（在我们的案例中，`Panda_Walk_Animation`）右键单击并选择**创建过渡**，如图所示：

![动画过渡](img/image00477.jpeg)

然后单击另一个状态以创建它们之间的过渡。在这个例子中，我们正在从`Panda_Walk_Animation`过渡到`Panda_Hit_Animation`，如图所示：

![动画过渡](img/image00478.jpeg)

### 过渡设置

如果您单击箭头，您可以在**检查器**中看到过渡设置/属性，如下面的截图所示：

![过渡设置](img/image00479.jpeg)

如果您愿意，可以通过在下面的字段中输入来为过渡分配一个名称（您需要按*Enter*键来确认您的选择）：

![过渡设置](img/image00480.jpeg)

因此，其名称将在包含该过渡的状态中显示（例如，在我们的例子中，在`Panda_Walk_Animation`状态内）：

![过渡设置](img/image00481.jpeg)

重命名过渡是您的选择。有人喜欢给出合适的名称，有人则将其引用为初始状态和最终状态，这是默认名称。然而，如果您决定重命名它们，请记住给出有意义的名称；它们是否长无关紧要。

让我们详细说明每个设置，以便更好地理解它们的含义。请记住，其中一些设置涉及特定条件，我们将在不久后探讨。

+   **具有退出时间**：如果此设置为true，则过渡只能在**退出时间**变量指定的时刻发生。

+   **退出时间**：如果启用了**Has Exit Time**，此值表示过渡生效的确切时间。这以归一化时间（百分比值）表示；因此，例如，退出时间为0.65表示在动画播放了65%的第一帧时，**退出时间**条件为真。在下一帧，条件将为假。对于循环动画，具有小于1的退出时间的过渡将在每个循环中评估，因此您可以使用此功能在动画的每个循环中根据适当的时机进行过渡。具有大于1的退出时间的过渡将只评估一次，因此它们可以用于在固定数量的循环后退出。例如，退出时间为4.5的过渡将只评估一次，在四个半循环之后。

+   **固定持续时间**：如果启用，过渡时间以秒为单位解释；否则，它以0到1之间的百分比（归一化时间）解释，例如0.5，它将表示50%。

+   **过渡持续时间**：这是过渡的持续时间。这还将确定过渡图中两个蓝色标记之间的长度（参见下一节）。

+   **过渡偏移**：这是动画（过渡到的目标状态）开始播放的时间偏移。例如，值为0.4表示目标状态将在自己的时间线的40%处开始播放。

+   **中断源**：这允许您控制允许过渡中断当前过渡的环境。特别是，您可以选择五种不同的模式：

    +   **无**将不允许任何内容中断过渡。

    +   **当前状态**仅允许当前状态内的过渡中断过渡。

    +   **下一状态**允许过渡被其他过渡中断，但仅当这些过渡在目标状态内时。因此，如果目标状态有一个准备触发的过渡，它将中断此过渡并触发。

    +   **当前状态然后下一状态**允许过渡被当前状态或目标状态的过渡中断。然而，如果过渡的条件在当前状态和目标状态上同时为真，则前者将具有优先权。例如，如果有两个过渡准备触发，但一个在当前状态，另一个在目标状态，则第一个过渡将被触发并中断当前正在播放的过渡。

    +   **下一状态然后当前状态**仍然允许过渡被当前状态或目标状态的过渡中断。但与**当前状态然后下一状态**相比，如果过渡的条件在当前状态和目标状态上同时为真，则后者将具有优先权。

+   **有序中断**：这确定当前转换是否可以被其他转换独立于它们的顺序中断。

### 小贴士

现在您可以使用转换，请记住经常重新排列您的有限状态机以提高可读性。您应该始终将状态放置得使所有转换都清晰可见，并且理想情况下它们不应交叉太多。

### 转换图

Unity还提供了一种通过转换图以可视方式调整这些属性（如上所述）的有用方法，转换图位于上一节设置下方。

可以手动调整转换设置，通过在之前看到的字段中输入数字，或者使用转换图，当操作视觉元素时，它将修改值。

![转换图](img/image00482.jpeg)

带有清晰时间线的转换图；我们可以以可视方式调整转换将如何发生

在前面的图中，您可以执行以下操作之一：

+   通过拖动*出*标记来更改转换的持续时间。

+   通过拖动*入*标记来更改转换的持续时间和退出时间。

+   通过拖动图底部显示的动画片段来调整转换偏移量。

+   通过拖动播放标记预览转换，逐帧导航以调整动画片段的混合方式。预览窗口位于检查器的底部。

![转换图](img/image00483.jpeg)

这是预览窗口，您可以在这里旋转、缩放和播放动画，以及显示它们的旋转中心点（或3D模型的质量中心）并更改预览播放的时间比例。

### 注意

如果转换涉及混合树作为两个状态之一（或两个状态），混合树参数也将出现在转换图中。您可以在本章后面的*关于动画的更多信息*部分找到有关混合树的一些更多信息。

### 转换条件

到目前为止，我们已经看到了许多转换的设置，但它们实际上何时被触发？这就是为什么在设置底部有转换条件。您可以看到它们在这里：

![转换条件](img/image00484.jpeg)

要添加条件，请按**+**按钮。要删除，选择其中一个并点击**-**按钮。此外，您可以通过拖动它们的左侧手柄来重新排列它们。然而，顺序不会影响转换背后的逻辑（只是其实施，以及可能的项目可读性）。

这些条件可以与参数进行核对。对于`int`和`float`参数，我们可以将它们与一个固定数字进行比较。所以如果参数中的值是**大于**或**小于**固定数字。对于`int`参数，我们还可以检查它们是否与固定数字**相等**或**不相等**。布尔值，相反，可以检查它们是**真**还是**假**。最后，触发器不能与某物进行比较，但条件检查它们是否被触发。

这里是一个使用所有四种参数的条件的示例：

![Transition conditions](img/image00485.jpeg)

请注意，只有在该时刻所有条件都得到验证时，过渡才会执行/执行。如果没有条件，则过渡在**退出时间**指定的时刻触发。

### 注意

如果**有退出时间**没有被勾选，并且过渡没有条件，那么Unity将忽略该过渡。所以它就像过渡不存在一样。

现在我们已经学会了如何设置过渡，我们将在下一节探索一些有用的功能来测试它们。

### 测试过渡

如果需要测试过渡，有两个有用的功能需要了解。第一个是**独奏**，第二个是**静音**。如果你选择一个过渡，你可以在**检查器**的顶部看到它们：

![Testing transitions](img/image00486.jpeg)

然而，我建议你以另一种方式设置**独奏**和**静音**。实际上，如果我们选择一个状态，我们可以在**检查器**中找到该状态的所有具有**独奏**和**静音**功能的过渡。因此，我们将有一个方便的视图，因为我们可以一次性查看和设置该状态的所有过渡，如下所示（本图中的所有过渡将在下一节中实现）：

![Testing transitions](img/image00487.jpeg)

当选择**静音**复选框时，该特定过渡将被完全忽略。而，当选择**独奏**复选框时，所有其他过渡都将被视为静音。此外，在**动画器**窗口中，可以看到**静音**过渡为红色，而**独奏**过渡为绿色：

![Testing transitions](img/image00488.jpeg)

独奏和静音过渡的示例

如果你拥有这本书的纸质版（因此没有颜色），从`Panda_Walk_Animation`到`Panda_Hit_Animation`的过渡是一个**静音**过渡，所以箭头是红色的。从`Panda_Walk_Animation`到`Panda_Die_Animation`和`Panda_Eat_Animation`的过渡都是**独奏**过渡，箭头是绿色的。剩下的一个既不是**静音**也不是**独奏**过渡，因此它是白色的。然而，这只是一个例子；请随意以最适合你的方式测试。

此外，从官方文档中我们可以找到关于**独奏**和**静音**功能的经验法则：

> *"基本规则是，如果选中了一个 Solo，那么从该状态到其他状态的过渡将被静音。如果同时选中了 Solo 和 Mute，则 Mute 优先。"*

最后，值得注意的是，在我写这句话的时候，有一个已知的问题（始终来自官方文档）：

> *"控制器图目前并不总是反映引擎的内部静音状态。"*

## 熊猫的动画状态机

现在我们对如何使用 Mecanim 系统有了更多了解，我们将做我们开始的事情——为我们的熊猫动画创建一个完整的控制器。这是控制器完成后的样子：

![熊猫的动画状态机](img/image00489.jpeg)

如您所见，有四个过渡，而我们只有一个。但我们仍然需要正确设置所有这些。因此，按照以下方式创建和完成过渡：

+   `Panda_Walk_Animation` 到 `Panda_Hit_Animation`：当熊猫在行走时被洒水击中，熊猫将播放击中动画。因此，让我们添加 `HitTrigger` 作为条件，并取消选中 **Has Set Time** 以在行走循环的任何时刻触发过渡。此外，为了使过渡瞬间发生，让我们将 **Transition Duration** 设置为零，使其从第一帧开始播放击中动画，并将 **Transition Offset** 设置为零。

+   `Panda_Hit_Animation` 到 `Panda_Walk_Animation`：当熊猫被击中后，它将再次继续向玩家的蛋糕走去。因此，我们需要在动画结束时立即将熊猫从 `Panda_Hit_Animation` 状态恢复过来。所以，让我们将 **Has Exit Time** 设置为 true，并将 **Transition Duration** 和 **Transition Offset** 设置为零，因为我们希望过渡是瞬间的。

+   `Panda_Walk_Animation` 到 `Panda_Eat_Animation`：当熊猫最终到达玩家的蛋糕时，它会吃掉那么多的蛋糕以至于会爆炸！因此，过渡需要通过 `EatTrigger` 触发，所以将其添加到条件中，并取消选中 **Has Exit Time**。此外，由于熊猫的所有过渡都应该是立即的，将 **Transition Duration** 和 **Transition Offset** 都设置为零。

+   `Panda_Walk_Animation` 到 `Panda_Die_Animation`：被洒水攻击对我们熊猫来说很困难。如果它不能再坚持，它就会死去，而玩家的蛋糕则完好无损。这是一个由 `DieTrigger` 触发的过渡，我们需要将其添加到条件中。同样，由于之前的相同原因，取消选中 **Has Exit Time** 并将 **Transition Duration** 和 **Transition Offset** 都设置为零。

+   `Panda_Die_Animation`到`Exit`：一旦熊猫死亡，我们希望将其移除。进入`Exit`状态（因为我们没有子状态机），实际上会让控制器从进入状态/节点重新开始。然而，我们将在发生之前展示如何销毁熊猫。这个动画进入任何其他状态都无关紧要，但选择退出更有意义，这有助于提高你控制器可读性。再次强调，我们希望转换是瞬时的，因此我们将**转换持续时间**和**转换偏移**都设置为零；但我们希望动画完成后立即触发这个转换，这意味着将**Has Exit Time**设置为true。

+   `Panda_Eat_Animation`到`Exit`：我们之前提到的原因也适用于这个转换。熊猫会吃掉很多蛋糕以至于爆炸，然后熊猫将从场景中移除。检查**Has Exit Time**，并将**转换持续时间**和**转换偏移**设置为零。

### 测试熊猫的动画状态机

在我们进入下一节之前，我们应该检查我们到目前为止所做的工作是否有效。然而，整个系统只有在完成游戏后才会完成。因此，我们需要找到一个既聪明又快速的方式来测试控制器。

最简单的方法是创建一个新的场景，并将熊猫Prefab拖放到其中。然后，构建一个包含三个按钮的UI界面。更改它们的文本，以便你将拥有`触发死亡动画`、`触发击打动画`和`触发进食动画`，如图所示：

![测试熊猫的动画状态机](img/image00490.jpeg)

正如我们在上一章中学到的，按钮有**On Click ()**事件，这允许我们在按钮被按下时调用一些函数。然而，我们没有机会使用这个功能。实际上，我们将在下一章中更多地处理UI事件。

现在，你可以选择所有三个按钮，并点击**On Click ()**事件右下角的小**+**按钮。我们可以在以下图像中看到这一点：

![测试熊猫的动画状态机](img/image00491.jpeg)

出现了一个新的事件，如图所示：

![测试熊猫的动画状态机](img/image00492.jpeg)

将熊猫从**层次结构**面板拖动到对象变量中，这样你将得到以下内容：

![测试熊猫的动画状态机](img/image00493.jpeg)

从下拉菜单中，导航到**Animator** | **设置触发器（字符串）**。这样，我们可以设置Animator的触发器。所以最后，你应该有这个：

![测试熊猫的动画状态机](img/image00494.jpeg)

现在，分别选择每个按钮，并将相应的触发器分配给它们。例如，在**触发投掷动画**按钮中，你应该写下`DieTrigger`，如图所示：

![测试熊猫的动画状态机](img/image00495.jpeg)

### 注意

使用`Set Trigger (字符串)`函数并不是最佳选择，因为它涉及到字符串的使用。但出于测试目的，这已经足够好了。在下一节中，当我们构建一个控制动画器的脚本时，我们将看到如何使用散列来引用动画器参数作为数字，并提高效率。

因此，现在每个按钮现在都充当我们熊猫的触发器。因此，我们可以按下**播放**，最终看到我们的熊猫在行走。然后，通过点击按钮，我们可以触发动画器中的转换并看到熊猫改变状态/动画。结果，我们可以测试转换是否工作良好。请随意调整任何您想要的参数，例如动画的速度或某个转换的转换图，以满足您的需求。

你还记得我们讨论**动画器**窗口时提到的**自动活链**切换吗？一旦你进入**播放**模式，这就是激活它的正确时机。结果，你将能够在你的**动画器**窗口中看到机器的状态的视觉表示。

例如，在下面的屏幕截图中，执行了行走循环，并且还显示了一个显示动画进度的条形图。这可以帮助你大量调整动画器控制器。

![测试熊猫的动画状态机](img/image00496.jpeg)

现在，一旦你对你的更改感到满意并且已经应用了它们，如果你想的话，保存场景，然后回到我们的主场景。然后，我们准备好为我们的熊猫创建一个或两个脚本。

## 动画脚本

最后，我们为我们的熊猫准备好了所有的动画以及一个根据某些触发器改变它们的控制器。然而，到目前为止，没有任何东西会设置动画器的触发器（除了其他场景中的我们的UI测试按钮）。因此，我们需要为熊猫创建脚本，这个脚本不仅包括熊猫的行为，还会触发正确的动画。在下一节中，我们将学习如何在脚本中调整动画器的参数。但在我们到达那里之前，让我先向你介绍一个非常强大的工具：状态机行为！

## 状态机行为

动画机的每个状态可以包含一个或多个行为。这些是扩展`StateMachineBehaviour`类的脚本，包括以下函数/事件，具有关于它们何时被调用/触发的自解释名称：`OnStateEnter()`、`OnStateExit()`、`OnStateIK()`、`OnStateMove()`和`OnStateUpdate()`。

特别是，你需要从母类中重写这些函数，并且它们接受三个参数作为输入。第一个是动画器本身，第二个是`AnimatorStateInfo`，它存储有关当前状态的信息，最后是一个表示层的整数。在我们的案例中，因为我们不会使用除了基础层以外的任何其他层，所以它总是零。它们具有以下签名（以`OnStateEnter()`为例）：

[PRE0]

因此，我们可以在一个状态下控制一切。实际上，状态机行为是一个非常强大的工具。一旦你创建了一个扩展`StateMachineBehaviour`类的脚本，选择你想要添加该脚本的州。然后，点击**检查器**底部的**添加行为**按钮，如下所示：

![状态机行为](img/image00497.jpeg)

如果你的类包含变量，它们在**检查器**中的显示方式与其他脚本相同，并且可以为该特定状态进行配置。以下是一个包含一些变量及其显示方式的状态机行为：

![状态机行为](img/image00498.jpeg)

### 注意

使用静态变量时要小心，因为它们在所有控制器的状态机行为实例之间是共享的！实际上，在这个上下文中不使用静态变量是一个好的实践。

现在，想象一下你的游戏中的英雄角色拥有携带和持有不同武器的能力。在这种情况下，使用机器行为，你可以检查角色手持的是哪一把武器，如果它与传说中的火焰剑相匹配，当我们的英雄挥砍敌人时，就会添加火焰粒子效果。另一个例子可能是，一些角色共享相同的动画机器，因为它们真的很相似，但其中一些角色在跳跃后可以滑行。因此，你可能想要检查这一点，并以某种方式修改你的动画机器的一些参数。

简而言之，唯一的限制是你的想象力（以及计算能力），你可以增强你的动画机器。当然，你可以用状态机行为实现的所有事情都可以用其他方式完成，但它们提供了一个简单且相当直观的方式来做到这一点。熟悉并学习如何使用这个工具并不需要太多时间。

现在我们已经知道了状态机行为是什么，让我们为我们的熊猫创建一个状态机行为！

### 摧毁行为

当我们的熊猫被可怕的喷水雨或吃太多蛋糕杀死时，我们需要以某种方式让熊猫从场景中消失。然而，我们需要在播放死亡动画之后，以及我们在书中稍后将要看到的更新游戏玩法之后完成这个操作。

正因如此，我们才创建了从**死亡**和**进食**动画到**退出**状态的额外两个转换。这些转换将在相应的动画播放完毕后执行。此外，这些动画是由我们在单独的脚本中触发的（见下一节），所以在熊猫死亡之前，我们有更新游戏玩法的机会，比如玩家的糖分或健康值。

状态机行为允许我们达到这样的控制水平，即在熊猫播放特定动画结束后摧毁熊猫。因此，我们可以创建一个新的脚本，并将其命名为有意义的名称，例如`StateMachineBehaviour_DestroyOnExit`。现在，双击脚本以打开它。

首先，我们需要扩展`StateMachineBehaviour`而不是`MonoBehaviour`。我们可以直接用前者替换后者。由于脚本不再扩展`MonoBehaviour`，我们也可以移除`Start()`和`Update()`函数。最后，我们应该得到以下结果：

[PRE1]

接下来，我们需要覆盖上述状态机行为中的一个函数。特别是我们想要覆盖`OnExit()`函数。所以每次状态改变到另一个（在**死亡**和**进食**状态的情况下意味着动画播放后立即），熊猫将被销毁。我们可以轻松做到这一点，因为函数的一个参数就是Animator本身，我们可以从中检索Animator附加的gameObject并将其销毁。因此，我们只需添加这个函数：

[PRE2]

保存脚本，然后选择**死亡**和**进食**状态。从那里，点击**添加行为**并选择`StateMachineBehaviour_DestroyOnExit`。

一旦完成所有这些，我们就完成了！现在，每次播放**死亡**或**进食**动画时，在动画完成后，熊猫将被销毁。下一步是看看如何在控制器中实际触发状态。

### 熊猫脚本

我们需要创建一个新的脚本，这次让它从`MonoBehaviour`派生。我们可以称它为`PandaScript`。然后，我们可以在其中创建一些变量。让我们从一个公共变量开始，用于跟踪熊猫的生命，另一个用于其速度：

[PRE3]

然后，我们需要一个变量来存储Animator的引用。因此，当我们需要在Animator中触发动画时，我们可以使用这个变量：

[PRE4]

正如我们在**Animator参数**部分所学，在Animator中设置参数有不同的方法。然而，它们有两种版本：一种是通过ID或哈希引用参数，另一种是作为字符串。后者当然是最直观的，但由于它依赖于字符串处理，所以比第一种慢一些。因此，只要可能，最好使用哈希（见信息框）来引用Animator中的特定参数。因此，我们可以将这些哈希存储在某个变量中，以便快速使用它们。

### 注意

在计算机科学中，当我们需要将任意大小的数据映射到固定大小的数据时，我们使用`Hash`函数。这个函数的结果被称为*哈希值*、*哈希码*、*摘要*或简单地称为*哈希*。这些`Hash`函数的主要用途在密码学和数字安全中。每次你进行数字签名时，幕后也有一处使用`Hash`函数。然而，它们在其他上下文中也被使用，例如在Unity中用于优化。

在我们非常具体的案例中，我们有一组参数，它们需要一个整数ID，这样它们就可以在Animator中快速引用。从参数的名称（一个字符串）应用一个`Hash`函数，由于字符串可以是非常长的任意长度，因此有无限多的组合，将其映射到一个有限的整数集合上，这些整数可以用一个单一的`int`变量表示（因此最多可达二十亿一千四百七十万四千八百三十个六百四十七）。所以，在您的视频游戏中，每次使用`int`变量来存储金钱或生命值，就像我们在上一章中所做的那样，`2,147,483,647`是最大值。通常对于视频游戏来说，这个限制对于您可能想要的任何整数参数来说都足够好了，尽管如果需要的话，可以通过特殊的数据结构来克服它。因此，从Animator参数的名称中，我们可以得到一个可以用来引用参数的数字。

这些哈希值是Animator无关的，因为它们仅基于参数本身的名称。因此，它们可以通过静态函数`Animator.StringToHash()`计算或检索，该函数接受参数的名称作为输入，并返回用于Animator的数值表示。

在我们具体的案例中，我们有三个触发器，我们可以将它们的哈希值存储在以下变量中：

[PRE5]

下一步是在`Start()`函数中获取Animator控制器的引用，以便在其他函数中使用。我们可以通过使用`GetComponent()`函数来实现这一点，该函数返回指定为`Type`的组件，该组件附加到与该脚本相同的gameobject上。因此，我们可以在`Start()`函数中简单地添加这一行：

[PRE6]

现在，关于模块化工作流程，我们可以创建一些私有函数来实现控制状态机的逻辑。然而，我们将等到需要调用它们的时候再处理它们。

因此，现在我们需要一个函数，允许我们的熊猫移动到地图上的一个点。这个函数接受一个`Vector3`作为输入参数，它是地图上的目标点。根据速度变量，它为熊猫创建一个步骤。然后，使用`MoveTowards()`函数，它将熊猫移动一步，朝向目标点：

[PRE7]

当熊猫被玩家的一个纸杯蛋糕塔的喷雾击中时，将调用另一个函数。它的输入是一个浮点数，表示熊猫从击打中受到的伤害量。因此，该函数从这个值中减去熊猫的健康值，然后检查健康值是否小于零。如果是这样，该函数通过设置`DieTrigger`参数来触发死亡动画。我们不需要销毁熊猫，因为一旦触发死亡，状态机行为将负责处理它。另一方面，如果熊猫还没有死，该函数将播放击打动画：

[PRE8]

我们需要添加的最后一个功能是当熊猫到达其路径的末端并站在玩家蛋糕前面时。在这里，这个功能只是触发`吃动画`。如何伤害玩家是我们将在下一章中讨论的内容：

[PRE9]

我们可以先保存这个脚本。它在检查器中的样子应该是这样的：

![熊猫脚本](img/image00499.jpeg)

现在不需要担心如何设置速度和健康！当我们讨论游戏玩法编程时，我们会看到这一点。

除非你想阅读下一个可选部分，该部分将引导你了解更高级的主题，否则我们可以这样说，我们已经完成了动画。如果你不想阅读下一个部分，或者想稍后再回来，也许在你完成整本书之后，你可以直接跳到作业和总结部分。否则，休息一下，继续下一部分。

# 更多关于动画的内容

我们已经了解了Unity中动画工作流程的很多内容，但还有很多内容被省略了。本节介绍了Unity中动画工作流程的一些相对高级主题，它们对于开发我们的塔防游戏不是必需的。实际上，其中一些只适用于3D，但我认为提及它们对于有一个关于Unity中动画整个工作流程的粗略但完整的了解是有价值的。因此，你可以自由地跳过这一节，或者不用太专注地阅读，以完全理解所写的内容。你总是可以在以后回来，也许在你完成这本书之后，可以更深入地研究其内容。

### 注意

所有以下章节的目的不是详细解释如何在Unity中使用这些工具，而是让你了解它们的存在和功能，以便你在对Unity有更多实践经验时再学习它们。

## 虚拟形象

在3D角色，尤其是人类角色的案例中，你需要对你的角色进行**绑定**，这意味着将3D模型的所有骨骼匹配到Unity虚拟形象中。如果模型制作得很好并且已经针对Unity进行了优化，这个过程可以自动化；否则，需要手动完成，如图所示：

![虚拟形象](img/image00500.jpeg)

### 注意

在场景视图中，你可以看到你的3D模型，你可以从其中拖放身体部分到虚拟形象中。

以这种方式，Unity存储了关于3D模型的附加信息。它不仅存储了匹配的骨骼，还存储了肌肉。主要原因是通过这种方式，可以执行重定向，这意味着使用相同的动画应用于不同的角色。假设你有一个美丽的行走动画，并且你想将其应用于所有角色。但其中一些角色很高。其他人很胖或者肌肉发达。虚拟形象存储这些附加信息以克服这个问题，并使行走动画适应每个角色。

此外，Unity还允许遮罩，这意味着丢弃动画剪辑数据的一部分，只使用特定的部分。例如，想象你有一个美丽的行走动画和一个某人喝水动画。假设你想要在角色行走的同时喝水。通过遮罩喝水动画，我们能够将其裁剪到上半身部分。结果，我们可以让行走动画在腿部播放，而喝水动画在角色的上半身播放。

如果你想象一个复杂的游戏，其中角色在行走时可以做很多事情（例如射击、装弹或交谈），这个功能真的非常有用。记住，遮罩可以在不同级别进行。例如，你可以根据不同的身体部分合并超过两个动画，以及子遮罩。可能性是无限的！

正因如此，Unity在需要时也提供了更详细的映射，例如，对于头部或手部，如图所示，我们可以看到左手部的映射：

![头像](img/image00501.jpeg)

所有这些功能与子状态机、状态行为和动画器中的层结合使用时都非常强大。

### 子状态机

之前，我们看到了Animator是一个有限状态机，具有不同的状态，每个状态都是一个动画剪辑。但实际上，并非所有状态都是动画剪辑。其中一些可以是其他东西，例如子状态机。这意味着，一个状态可以包含另一个完整的有限状态机！

![子状态机](img/image00502.jpeg)

子状态机以状态的形式出现在上层，尽管形状略有不同。实际上，转换可以在子状态机上开始或结束，就像任何其他状态一样。

### 注意

你可以通过名称周围的形状略有所不同来识别子状态机。

在这个场景中，退出状态/节点变得很重要，因为它允许我们完成/退出子状态机并继续到下一个状态。当然，如果满足某些条件，子机器也可以被中断。不言而喻，能够嵌套动画机确实是一个非常强大的工具，可以构建非常复杂的动画器。

### 层级位置菜单

正如我们所见，状态可以包含子状态和树，这些结构可以重复嵌套。当深入到子状态时，父状态和当前状态的层次结构可以在顶部栏中查看（以下图片中突出显示）：

![层级位置菜单](img/image00503.jpeg)

点击父状态允许你跳回到父状态或直接回到状态机的基层。

## 动画器中的层

现在，如果我们想在Animator控制器中创建、查看或编辑层，我们需要确保左侧面板设置为层视图，就像以下图片所示：

![动画器中的图层](img/image00504.jpeg)

这允许你在单个动画控制器中拥有多个动画层。所有这些层都可以同时运行，其中每个层由一个独立的状态机控制。这个过程在例如，你有一个单独的图层在基础层上播放上半身动画时常用，基础层控制角色的整体运动动画（与Avatar Masks结合使用）。

要开始，点击加号图标以添加图层。另一方面，要删除图层，选择图层并按*Delete*键。

## 混合树

除了动画片段和子状态机之外，动画器中的状态也可以是一个混合树。在动画的不同帧之间应用的一个常见过程是将两个或更多相似的动作混合在一起，这样就会感觉像是一个流畅的动画。例如，行走和跑步动画可能需要根据角色的速度在关键帧之间进行混合。理想情况下，你希望玩家行走时速度较慢，跑步时速度较快。在某些情况下，玩家的跑步速度还可以通过游戏元素（如物品，速度提升）再次增加。另一个典型的例子是在角色转向时向左或向右倾斜，以实现更真实的行为。这可以通过混合树来实现，混合树能够*混合*动画片段。

![混合树](img/image00505.jpeg)

一个非常常见的混合树示例；在这里，行走动画被分成三个动画片段，因此角色在行走时可以向左或向右倾斜。

实际上，它们使用线性插值，可以通过一些权重和参数进行控制。Unity支持混合树的一维和二维插值。

![混合树](img/image00506.jpeg)

混合树的二维插值。数字和动画片段随机放置，图中的目的是展示上部分的二维插值，其中菱形是不同的动画片段，圆形是控制片段之间混合的二维值。

我们不会进一步探讨混合树，但请记住，它们可以用于实时混合更多动画，以实现极其真实的行为和更平滑的动画。

## 动画器覆盖控制器

想象一下，你刚刚创建了一个美丽的动画状态机，它充满了层和转换，因为它非常详细。你的角色有状态，允许她施展法术、拿咖啡或挥舞剑。然而，现在，你需要考虑即使是哥布林也能做到这一点。以及你的第二级中的巨魔，以及你游戏后期要与之战斗的精灵。你是否需要为每一个都再次创建一个非常相似的动画机，但只是更改动画剪辑？而且如果你稍后决定稍微改变控制器，你是否需要稍微改变所有这些？感谢上帝，Unity提供了一个更简单的方法，称为**动画覆盖控制器**。

你可以通过在项目面板上右键单击并导航到**创建** | **动画覆盖控制器**来创建一个**动画覆盖控制器**。它将像其他动画控制器一样成为一个资产。然而，你无法在**动画**窗口中打开它。如果你在**检查器**中选择它，你会看到你可以将其链接到一个正常的动画控制器，如图中所示：

![动画覆盖控制器](img/image00507.jpeg)

只为了学习的目的，我们将我们项目中唯一的控制器，即熊猫控制器拖放到这里。结果，我们使用的所有动画状态都会出现在列表中，我们可以从原始控制器分配不同的动画剪辑。

![动画覆盖控制器](img/image00508.jpeg)

这样，你不需要复制动画控制器，只需分配新的动画剪辑。一旦动画控制器发生变化，所有相关的**动画覆盖控制器**也会相应地改变，更新你游戏中使用该控制器的所有角色。不错，不是吗？

### 动画组件中的剔除模式

现在，想象一下一枚闪亮的硬币的美丽动画。它如此美丽，以至于你决定在你的游戏中包含许多硬币。结果，如果玩家只能看到屏幕上的三个硬币，那么旋转数千枚硬币可能会在计算上变得很重。

考虑另一种情况。玩家刚刚打开了一个开关，触发了一扇非常重且缓慢的门。因此，当门在打开时，玩家会稍微探索一下环境。当他或她回来时，玩家会期望门的动画已经完成，所以门是开着的。这意味着门动画应该在它不可见时也运行，而硬币在任何时候都不需要动画，例如当它在屏幕之外时。

为了优化这个问题，Unity在动画组件中提供了一个选项，称为**剔除模式**。这允许我们指定对象何时应该动画化。可能的值如下：

+   **始终动画**：最昂贵但也是最逼真的解决方案。正如其名所示，对象始终在动画中，所以在这种情况下，当门在屏幕之外时，它也会继续打开。

+   **剔除更新变换**：这是一个中间解决方案；它仅禁用一些部分，如重定向和IK，以提高性能，但在需要时仍具有一定的真实感，而不需要付出太多的计算成本。

+   **完全剔除**：从计算角度来看，这是最便宜的，因为当对象离屏时，它将完全停止动画。

### 根运动

一些动画，从理论上讲，应该改变角色的位置，例如走路但不喝水。因此，为了在Unity中解决这个问题，你可以用脚本移动角色，就像我们在我们的案例中所做的那样，或者使用根运动。正如其名所示，这允许动画本身移动角色的根（或对象或生物）以在空间中获得更真实的运动。

然而，这并不简单，并且有一些缺点。例如，从计算角度来看，它更昂贵，因此，在低端设备上具有根运动的许多角色可能会变得不可行。此外，它需要不同的调整，特别是如果动画做得不是很好。

### 反向运动学

反向运动学是视频游戏中相对较新的技术。它允许你将目标纳入动画中，有时还能实时计算出适合目标的动画。例如，想象一个角色只想把手放在墙上。反向运动学应该允许你控制动画，将手放在墙上，无论墙是远1厘米还是更近。

通常，动画使用所谓的直接运动学（或正向运动学）。基于关节的位置和旋转，可以确定骨骼每个部分的位置。所以想象一下有一个手臂，基于肩部、肘部和手腕的位置和旋转，你可以确定手的位置和旋转。实际上，这些技术来自机器人研究。

反向问题，称为反向运动学，是从手的位置和旋转确定肩部、肘部和手腕的位置和旋转。然而，这个问题不是唯一确定的，因为它可能有无限多的解。因此，解决这个问题并不简单。无论如何，已经开发出不同的技术（在机器人技术中可能涉及雅可比矩阵的逆运算）来解决这个问题。

不同的解决方案的问题在于，其中一些可能会导致非常不寻常的姿态。再次以手臂为例，一个为了将手放在墙上而将肘部抬到眼睛高度的解决方案并不真实（见下一张图片，左侧）。虽然这可能在应用于机器人技术时是一个相对问题，但在动画中这确实是一个大问题，因为我们希望我们的角色是可信的。

因此，已经开发出其他技术来解决这一问题，并对社会行为（针对人形角色）进行了研究，以了解为什么某些姿势比其他姿势更真实。例如，前一张图片中的姿势很累人；没有人会把手放在墙上这样。实际上，这也涉及到物理，因为我们的大脑试图以尽可能少消耗能量的方式控制我们的身体。这导致了一种无意识的行为，我们在其他人身上也能识别出来，我们的游戏角色也需要这种行为。

Unity实现了其中一些技术，Mecanim支持人形角色的一些逆运动学，前提是他们有一个正确配置的化身。然而，我们不想深入探讨这个问题。我只是把最好奇的读者留在这里，提供官方文档的链接：[https://docs.unity3d.com/Manual/InverseKinematics.html](https://docs.unity3d.com/Manual/InverseKinematics.html)。

### 注意

另一个研究并使用逆运动学的例子是用于虚拟现实中的虚拟存在。最近的Oculus Touch允许您在Rift头显内拥有您的手，但不能是肘部和/或肩膀。在实现逆运动学时——即使考虑到可信度和更节省能量的姿势——软件仍然无法精确地映射您的手臂在空间中的位置，因为您会感到不舒服。然而，在多人游戏中，您可以在虚拟世界中看到其他人，但在现实中却看不到（或像他们那样感受他们的身体），因此可以应用逆运动学。尽管它不会给出游戏中其他玩家肘部的确切位置，但足够接近以令人信服。例如，使用这种机制的其中一个游戏是Dead and Buried。正如您从下一张图片中可以看到的，您只能看到自己的手，但其他玩家的整个身体您也能看到。

![逆运动学](img/image00509.jpeg)

## 动画组件信息框

如我们之前提到的，动画组件在底部有一个信息框，其中可能包含一些有用的数据。这里再次提供信息框的图片，供您参考：

![动画组件信息框](img/image00510.jpeg)

除了我们已看到的**剪辑数量**之外，这里简要列出其他信息：

+   **位置**、**旋转**和**缩放**：这些分别表示用于位置、旋转和缩放的曲线总数。动画窗口，我们没有详细看到的一个，允许您创建这样的曲线。

+   **肌肉**：在动画器中用于人形角色的肌肉数量。

+   **通用**：动画器用于动画其他属性的数值曲线数量。

+   **PPtr**：精灵动画曲线的总数；当我们在2D中工作时很有用。

+   **曲线数量**：动画曲线的总数。

+   **常量**: 作为常量值优化的动画曲线数量。如果您的动画文件包含具有不变值的曲线，Unity会自动选择此选项。

+   **密集**: 使用*密集*方法存储数据（离散值，这些值在线性之间进行插值）优化的动画曲线数量。这种方法比*流式*方法使用的内存显著更少。

+   **流式存储**: 使用*流式*方法存储数据（用于曲线插值的值和时间以及切线数据）的动画曲线数量。这种数据比*密集*方法占用更多的内存。

### 传统的动画

在Mecanim（2012年，Unity 4.0版本）引入之前，Unity使用了一个更简单的动画系统。鉴于从那时起已经过去了一段时间，向后兼容性仍然存在。因此，仍然可以在不更新Mecanim或担心软件引发的其他问题的情况下继续处理旧项目。

有些人发现传统的动画系统对于快速原型制作和/或测试动画剪辑很有用，尤其是在对象只有一个动画剪辑时。这是因为它是基于动画组件（下图中所示），并且不应与我们在本章之前看到的Animator组件混淆。

![传统动画](img/image00511.jpeg)

您可以在官方文档中了解更多关于传统动画系统信息：[https://docs.unity3d.com/Manual/Animations.html](https://docs.unity3d.com/Manual/Animations.html)。

因此，除非您有特定的需求，否则您可以完全忽略传统的动画系统，但提到它是值得的，以免您在找到动画组件但不知道它是做什么的时候感到困惑。

在说这个的同时，虽然传统的动画仍然可用，但不建议您使用它来创建新的Unity项目。

# 让我们开始动画吧！！

一个实际例子是思考动画中涉及到的动作。例如，当你走路、打字、喝水、吃饭，任何类型的动作，都尝试用慢动作来做。你开始注意到微妙的动作如何使动画独特并赋予其个性。对于每个动画，比如喝水，你可以用不同的方式来做。拿起杯子，可能用不同的握法，比如用整个手或几个手指握住把手。当你开始更加关注动作时，你应该能够获得一些关于你如何在Unity中调整动画的见解，当某些事情感觉不太对劲时。为了再次获得更好的想法，搜索视频，甚至书籍，以探索动画的应用和一些基础。虽然这本书并不是关于动画的指南，但理解基础不仅有助于你提高自己对动画的理解，而且有助于你更好地理解动画师的角色及其所涉及的内容。如果你将来需要与动画师合作，这类信息将对你非常有价值。

# 作业

在本章中，我们遇到了动画剪辑和动画控制器方面的许多方面。然而，在我们进入下一章之前，我邀请你看看这些练习，以提高你的技能：

1.  **成为动画设计师**：想想你玩过的五款游戏，并选择每个游戏的一部分，比如教程关卡、与Boss战斗、穿过森林，甚至是主菜单。现在，列出每个游戏所拥有的动画列表。接下来，移除一些动画，甚至添加一些，并思考这会如何改变体验。它是否改善了体验，或者是否完全改变了氛围？你能通过改变一些动画，让相对愉快的氛围变得非常黑暗，反之亦然吗？通过这样做，你将开始理解动画在不仅为你的游戏带来生命，而且带来情感和设定氛围方面所扮演的重要角色。

1.  **动画绘制（第一部分）**：想象一下你需要创建一个动画；你可以在图形程序中简单地完成这个任务。首先，勾勒出手臂的轮廓；你可以用正方形代表手，用矩形代表前臂，用更长的矩形代表上臂。现在，移动每一个部分，使其能够执行摆动动画。理想的情况是设置成我们之前使用的精灵图集那样。然后，将它们导入Unity中并测试一下。

1.  **动画绘制（第二部分）**：现在，给你的动画添加细节，或者添加其他身体部位，比如腿。此外，你可以自由地添加一些特殊效果，比如熊猫的击打动画。一旦你的动画准备好了，尝试创建第二个和第三个。然后，将它们全部导入，设置好，并构建一个动画控制器来查看它们的动画。此外，你可以润色你的动画，以改善它们之间的过渡。

1.  **一个不那么无畏的熊猫（第一部分）**：正如我们所编写的，当熊猫被击中时，它会继续向前移动。然而，熊猫应该有点震惊。只有当动画结束时，熊猫才应该继续向玩家的蛋糕前进。用你想到的任何技术解决这个问题，以便你可以修改**熊猫脚本**或创建机器状态行为。

1.  **一个不那么无畏的熊猫（第二部分）**：如果你已经完成了前面的练习并找到了解决方案，那么是时候让你的代码更加健壮了。在**熊猫脚本**中添加一个布尔值，并在布尔值设置为true时停止熊猫移动，但只有当它被击中时。这样，我们可以在**检查器**中公开这个变量，为玩家面临的熊猫类型提供更多可能性（在下一章中继续）。

1.  **状态机行为作为监听器**：我们已经以这种方式实现了**熊猫脚本**，在Animator控制器中设置了触发器以改变动画。现在，从**熊猫脚本**中移除击打和死亡触发器，并实现其他机器状态行为，这些行为检索熊猫的健康值，并在健康值从上次降低或低于零时分别触发击打动画或死亡动画。

1.  **探索动画窗口**：即使我们没有处理动画窗口，你也可以尝试探索它，也许可以通过点击提供的官方文档链接。然后，尝试为我们的糖浆制作一些动画，以便它们在飞向邪恶熊猫的过程中旋转。也许你还可以创建一个碰撞动画。将这些动画包裹在Animator控制器中，并在需要时修改Projectile脚本。

# 摘要

因此，我们为我们的熊猫制作了四个不同的动画片段，每个片段对应其可能的行为：行走、死亡、击打和进食。然后，我们将它们包裹在一个控制器中，并构建了一个有限状态机来定义这些动画片段如何通过转换相互链接。最后，我们编写了一个脚本来触发机器的不同状态。

现在我们已经看到了如何为我们的熊猫动画，是时候进入下一章了，也许在喝杯咖啡之后。
