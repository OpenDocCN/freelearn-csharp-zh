<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What to Know Before Getting Started</h1>
                
            
            <article>
                
<p class="calibre2">You're off to a pretty good start. By now, you should be starting to feel comfortable with the basic concepts behind Test-Driven Development. You know the basic premise behind TDD and how to write a unit test in C# and JavaScript.</p>
<p class="calibre2">In this chapter:</p>
<ul class="calibre7">
<li class="calibre8">We'll cover more of the practices behind TDD</li>
<li class="calibre8">Specific advice will be given on how to avoid pitfalls along the way</li>
<li class="calibre8">We'll explain the importance of defining and testing boundaries, abstracting away third-party code (including the .NET Framework)</li>
<li class="calibre8">We'll begin to introduce more advanced concepts, such as spies, mocks, and fakes</li>
</ul>
<p class="calibre2">First, let's cover some issues you may run into while trying to test an existing application. Hopefully, this will help you avoid problems in your next green-field application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Untestable code</h1>
                
            
            <article>
                
<p class="calibre2">There are a variety of telltale signs that an application, class, or method will be difficult, or even impossible, to test. Sure, there are ways around some of the following examples but it's usually best to just avoid workarounds and programmatic acrobatics. Simple is usually best, and your future self and/or future maintainers will thank you for keeping things simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection</h1>
                
            
            <article>
                
<p class="calibre2">If you're creating instances of external resources within your constructors or inside methods instead of having them passed in, it will be very difficult to write tests to cover these classes and methods. Generally, in today's modern applications, Dependency Injection frameworks are used to create and provide the external dependencies to a class. Many choose to define an <em class="calibre12">interface</em> as the contract for the dependency, providing a more flexible method for testing and the coupling to external resources.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Static</h1>
                
            
            <article>
                
<p class="calibre2">You may have a need to access static third-party classes or methods. Instead of accessing static resources directly, it would be better to access these through an <em class="calibre12">interface</em>. In the example of <kbd class="calibre11">DateTime</kbd> in C#, <kbd class="calibre11">Now</kbd> is a static property, which prevents you from being able to control the <kbd class="calibre11">DateTime</kbd> value used by the class or method being tested. This makes it more difficult to verify your test cases and ensure your program's logic is behaving correctly, based on specific dates or times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Singleton</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre12">Singletons</em> are the essence of the shared state. In order to ensure your tests run in an isolated environment, it would be best to avoid them. If a <em class="calibre12">singleton</em> is required (for example, <kbd class="calibre11">Logging</kbd>, <kbd class="calibre11">Data Context</kbd>, and so on), most Dependency Injection frameworks allow for the substitution of a non-singleton class as a single instance, which gives the functionality and flexibility of effectively having a singleton. For production code, this allows you to control the scope of the singleton instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Global state</h1>
                
            
            <article>
                
<p class="calibre2">It has long been understood that global state within an application will wreak havoc on a system and cause unexpected behavior that is difficult to trace. Changing the code in one place will possibly have far-reaching side-effects on the rest of your system. For testability, this often means much more effort in setup and slower test execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstracting third-party software</h1>
                
            
            <article>
                
<p class="calibre2">As your application grows, you'll likely introduce external dependencies. Assuredly, the developers of these systems, applications, and libraries have thoroughly tested their offerings. You should focus your attention on testing your application, not on testing third-party code. Your application should be robust enough to handle edge cases, and you'll want to account for expected and unexpected behavior. You'll want to abstract away the details of the third-party code and test for expected (and unexpected) results.</p>
<p class="calibre2">So, what is <em class="calibre12">third-party code</em>? Anything you didn't write. That includes the .NET Framework itself. One way to achieve the abstraction of third-party code is with the use of test doubles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test doubles</h1>
                
            
            <article>
                
<p class="calibre2">Test doubles are functions and classes that aid in the testing process by allowing you to either verify functionality or bypass a dependency that would otherwise be difficult to test. Test doubles are used at all levels to isolate the code being tested. Many times, the need for a test double drives the architecture of the code.</p>
<p class="calibre2">The <kbd class="calibre11">DateTime</kbd> object in C# is an example of when this is the case. <kbd class="calibre11">System.DateTime</kbd> is part of the .NET Framework, and normally you wouldn’t think that you would abstract this in your code. The instinct of most developers is to simply reference it in a <em class="calibre12">using statement</em> and then access <kbd class="calibre11">DateTime.Now</kbd> directly within their code.</p>
<div class="packt_tip">
<p class="calibre36">A test that can't be repeated is a bad test.</p>
</div>
<p class="calibre2">This is usually difficult to test. If we were to try to test a method using <kbd class="calibre11">DateTime.Now</kbd>, we would be unable to prevent <kbd class="calibre11">DateTime.Now</kbd> default functionality. <kbd class="calibre11">DateTime.Now</kbd> returns the current date and time stored in a <kbd class="calibre11">DateTime</kbd> object. Not having the ability to manipulate the return of this object causes our tests to be unpredictable and unrepeatable. A test that can't be repeated is a bad test.</p>
<p class="calibre2">Many developers already understand the need for predictability. You may have heard the phrase, <em class="calibre12">If it can't be reproduced, it's not a bug</em> or a similar sentiment. This is because, in order to verify that we have fixed a bug, we must be able to predictably repeat the error. This way, once the steps to reproduce it no longer produce the bug, we can confidently say that the bug is fixed. At least we can for that series of steps.</p>
<p class="calibre2">Testing is no different from bug fixing; it follows all the same steps. We just know exactly what caused the bug; the code hasn't been written yet, or the refactoring we just attempted failed.</p>
<p class="calibre2">Creating test doubles can get a little involved at times. For this reason, frameworks to support the creation of these test doubles have been created for nearly every language that has a testing framework. The frameworks are generally referred to as mocking frameworks or libraries. In C#, the predominant framework currently in use is <em class="calibre12">Moq</em>, pronounced <em class="calibre12">mock</em>. Similarly, in JavaScript, the most referenced mocking library seems to be <em class="calibre12">Sinon</em>, pronounced <em class="calibre12">sign on</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocking frameworks</h1>
                
            
            <article>
                
<p class="calibre2">Mocking frameworks are a great utility to alleviate some of the pressure of testing in a large project. They are especially useful when trying to wrap tests around a legacy system. A legacy system, in this case, is defined as an application that does not already have tests around it. This definition is from Michael Feather's book, <em class="calibre12">Working Effectively with Legacy Code</em>.</p>
<p class="calibre2">Use caution while learning Test-Driven Development and using mocking frameworks. Mocking frameworks provide a very attractive alternative to carefully considering your code. It is possible to write a complete set of tests that, in the end, only really test the mocking framework.</p>
<p class="calibre2">Many mocking frameworks are overpowered in this respect. In C#, a classification of mocking frameworks exists that allows you to replace external code. This external code includes <kbd class="calibre11">DateTime.Now</kbd> and any other class that you don’t control. In JavaScript, this is called monkey patching, and every framework allows you to do it.</p>
<p class="calibre2">What's the harm, you ask? One of the benefits of TDD is that it encourages smart architectural choices. When you have the power to override the functionality of the third-party code, you no longer have the need to abstract in order to test.</p>
<p class="calibre2">Why is that a problem? Abstraction of the third-party is necessary if we want to keep the code flexible and if we want to follow the SOLID principles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The SOLID principles</h1>
                
            
            <article>
                
<p class="calibre2">The SOLID principles are a collection of concepts originally put together by Robert C. Martin, aka "Uncle Bob." Usually advertised as <em class="calibre12">Object-Oriented Principles</em>, you should think of them as just plain good architectural choices. The SOLID principles consist of five principles: the Single Responsibility Principle, the Open/Closed principle, the Liskov Substitution principle, the Interface Segregation Principle, and the Dependency Inversion Principle.</p>
<p class="calibre2">The original articles on the SOLID principles are available at <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" class="calibre10">http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Single Responsibility Principle</h1>
                
            
            <article>
                
<p class="calibre2">In Uncle Bob's article, the <strong class="calibre1">Single Responsibility Principle</strong> (<strong class="calibre1">SRP</strong>) is defined as, "A class should have only one reason to change."</p>
<p class="calibre2">What does this mean? That is the tough part; there are many approaches to understanding the meaning. One way to look at it is that the class should only support one business user. Another is that, within the application, the class should only be used with a limited or specific scope. Another is that the class should have a limited range of functionality. These are all correct, and yet insufficient. One way to ensure you are following it is to use what we will refer to as the "Rule of Three to Five."</p>
<p class="calibre2">If we're discussing requirements, for example, when a requirement has between three to five acceptance criteria, then it is most likely appropriately sized for its level of detail. Similarly, if we are discussing a method or function, then three to five lines of code is probably appropriately sized.</p>
<p class="calibre2">The Rule of Three to Five is a generic way to know that you are honoring the SRP. The rule states, "Less than three is good. Between three and five is fine. Above five is strongly consider refactoring." It's not quite as elegant as many other laws, principles, and rules, but the rule of three to five is easy to follow. This rule is just a guideline and should not be used as an ultimatum. You should try to apply this rule to just about everything in software development. You have already seen it in action in this book. This rule was used to determine the scope of the requirements in <a target="_blank" href="part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 1</a>, <em class="calibre12">Why TDD is Important</em>, and in all the code samples that have been included so far.</p>
<p class="calibre2">If you use the Rule of Three to Five, it nearly guarantees that you are following SRP, and it keeps your code, file structure, and requirements small and maintainable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Open/Closed principle</h1>
                
            
            <article>
                
<p class="calibre2">The Open/Closed principle states, "Software entities (classes, modules, functions, and so on) should be open for extension, but closed for modification." The second of the SOLID principles doesn't sound like it is saying much, but it has a large impact.</p>
<p class="calibre2">There are many ways to honor this principle. You or your development team could put into place a rule that only allows for new development. That is, any existing functionality cannot be updated or changed, only replaced by new methods or classes. When we get to creating dividing lines in the code, you could use those dividing lines to create a place for this functionality swap to take place.</p>
<p class="calibre2">The Open/Closed principle also enables continuous integration and deployment. This is because, if your application never breaks a contract it has with the user, itself, or a third party, then it can always be deployed without fear of causing a production issue.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Liskov Substitution principle</h1>
                
            
            <article>
                
<p class="calibre2">The Liskov Substitution principle may be difficult to understand at first due to its somewhat complex and mathematical definition. From Barbara Liskov's <em class="calibre12">Data Abstraction and Hierarchy</em> [<a href="https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf" class="calibre10">https://pdfs.semanticscholar.org/36be/babeb72287ad9490e1ebab84e7225ad6a9e5.pdf</a>], the principle is stated as follows:</p>
<div class="packt_quote"><em class="calibre12">What is wanted here is something like the following substitution property. If for each object o1 of type S there is an object o2 of type T, such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2, then S is a subtype of T.</em></div>
<p class="calibre2">Uncle Bob has simplified this definition to be, <em class="calibre12">Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</em> Looking at this principle, it seems like it would just be inheritance. Except, it's not just inheritance. This principle implies that not only does the object replacing the other have to implement the same interface or contract as the original, it must also adhere to the same expectations as the original.</p>
<p class="calibre2">The classic example of a violation of this principle is the use of a square class in the place of a rectangle class. A typical rectangle class would need to have both length and width properties. In mathematics, a square is just a special type of rectangle. So, many would assume that creating a square class with length and width would be an acceptable swap for the rectangle class.</p>
<p class="calibre2">The problem here is that a square requires that both length and width have the same value. So, when you change either one on the square class, the class will update the other to have the same value. This is a problem because the application using the object doesn't expect this behavior. Therefore, the application must be aware of the possibility of the length or width changing without notice.</p>
<p class="calibre2">A failure to meet the expectations of the application is known as a refused bequest. A refused bequest can cause inconsistent behavior in an application and, at the very least, requires more code to compensate for the mismatch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Interface Segregation principle</h1>
                
            
            <article>
                
<p class="calibre2">The Interface Segregation principle is about keeping to the contract of interaction presented by your class small. More than small, the contract presented by your class should have a single responsibility.</p>
<p class="calibre2">Sometimes, having a class with a small single responsibility contract is difficult or not desired. In those instances, the class should implement multiple contracts instead of creating a combined contract. We want multiple contracts to reduce the number of far-reaching dependencies.</p>
<p class="calibre2">Every time a base class or interface is modified, the child classes must also be modified. At the very least, the child classes must now be recompiled. By limiting the scope of a contract, we can reduce the impact of changing that contract and improve the overall system architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Dependency Inversion principle</h1>
                
            
            <article>
                
<p class="calibre2">Inversion of dependencies is important for several reasons, among which are that inverted dependencies increase flexibility, decrease fragility, and help the code to be potentially reused.</p>
<p class="calibre2">Inversion of dependencies allows for a plugin type architecture. By defining a contract of interaction, a module can determine how it wants to interact with dependencies. Then the dependencies depend on that contract.</p>
<p class="calibre2">Because the top-level module has no outgoing dependencies, it can be deployed independently. Deploying a piece of an application independently almost never happens, but having an independently deployable library has the tremendous benefit of not needing to be recompiled when a dependency changes.</p>
<p class="calibre2">In normal development, the dependencies fluctuate a lot more than the higher-level modules. This fluctuation causes the need to recompile. When your application dependencies flow downward, a dependency recompile also triggers a recompile of the dependent library. So, in effect, changing a utility helper class in a tiny, but common, library will trigger a recompile of your entire application.</p>
<p class="calibre2">If you are inverting your dependencies, however, a change like this will only trigger a recompile of the utility helper library and the application library. It will not trigger a recompile of every library between.</p>
<p class="calibre2">That does it for the SOLID principles. Please keep them in mind if you choose to use a mocking framework. Make sure you don't allow the mocking framework to trick you into building a rigid, fragile, immobile system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Timely greeting</h1>
                
            
            <article>
                
<p class="calibre2">Expanding on the classic <em class="calibre12">Hello World</em> example, what if you wanted to change your greeting based on the time of day? An example is as follows:</p>
<pre class="calibre19"><strong class="calibre1">As a</strong> visitor to the site <br class="title-page-name"/> <strong class="calibre1">I want</strong> to receive a time-appropriate greeting <br class="title-page-name"/> <strong class="calibre1">So that</strong> I may plan the submission of my talks <br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">Given</strong> it is before noon <br class="title-page-name"/> <strong class="calibre1">When</strong> greeting is requested <br class="title-page-name"/> <strong class="calibre1">Then</strong> morning message is returned<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">Given</strong> it is afternoon <br class="title-page-name"/> <strong class="calibre1">When</strong> greeting is requested <br class="title-page-name"/> <strong class="calibre1">Then</strong> afternoon message is returned</pre>
<p class="calibre2">You might think to yourself, This is simple; I can just write a quick method to return the proper message. Of course, you would be right. This is a pretty easy task. You might come up with something like this:</p>
<pre class="calibre19">public string GetGreeting()<br class="title-page-name"/>{<br class="title-page-name"/>  if (DateTime.Now.Hour &lt; 12)<br class="title-page-name"/>    return "Good morning";<br class="title-page-name"/><br class="title-page-name"/>  return "Good afternoon";<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember, back in <a target="_blank" href="part0021.html#K0RQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 1</a>, <em class="calibre12">Why TDD is Important</em>, we discussed the Three laws of TDD. The all-important first law states that you aren't allowed to write a single line of production code without a failing test.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fragile tests</h1>
                
            
            <article>
                
<p class="calibre2">"But, this is such a simple method," you might say. What if you encountered a bug? What if you wanted to write some tests for this method after the fact? Would you have to run your test suite at a specific time of day to ensure a passing test? Would you have to alter your tests based on the time of day that you ran them?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">False positives and false failures</h1>
                
            
            <article>
                
<p class="calibre2">If we left the code in our <em class="calibre12">Message</em> example as-is and wrote a test to cover the method, it might look something like this:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenEvening_ThenAfternoonMessage()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var message = GetGreeting();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Good afternoon", message);<br class="title-page-name"/>}</pre>
<p class="calibre2">Can you spot the problem with this test? There's nothing inherently wrong with the test, per se. The problem is that the production code will return a different message, based on the time of day. This means that if you ran the test in the afternoon, it would pass. If you ran the test in the morning, it would fail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abstract DateTime</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre11">DateTime</kbd> is part of the .NET Framework, and therefore, it should be abstracted away from our system. Typically, we want our system to depend on interfaces, allowing us to substitute implementations at runtime.</p>
<p class="calibre2">Following is an example of <kbd class="calibre11">ITimeManager</kbd>:</p>
<pre class="calibre19">public interface ITimeManager<br class="title-page-name"/>{<br class="title-page-name"/>  DateTime Now { get; }<br class="title-page-name"/>}</pre>
<p class="calibre2">For testing purposes, you might end up with an implementation of <kbd class="calibre11">ITimeManager</kbd> that looks like this:</p>
<pre class="calibre19">public class TestTimeManager : ITimeManager<br class="title-page-name"/>{<br class="title-page-name"/>  public Func&lt;DateTime&gt; CurrentTime = () =&gt; DateTime.Now;<br class="title-page-name"/><br class="title-page-name"/>  public void SetDateTime(DateTime now)<br class="title-page-name"/>  {<br class="title-page-name"/>    CurrentTime = () =&gt; now;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public DateTime Now =&gt; CurrentTime();<br class="title-page-name"/>}</pre>
<p class="calibre2">This allows us to set the value for <kbd class="calibre11">Now</kbd> so that we can supply a known value to our test methods. Now, let's revisit our tests:</p>
<pre class="calibre19">[Theory]<br class="title-page-name"/>[InlineData(12)]<br class="title-page-name"/>[InlineData(13)]<br class="title-page-name"/>[InlineData(14)]<br class="title-page-name"/>[InlineData(15)]<br class="title-page-name"/>[InlineData(16)]<br class="title-page-name"/>[InlineData(17)]<br class="title-page-name"/>[InlineData(18)]<br class="title-page-name"/>[InlineData(19)]<br class="title-page-name"/>[InlineData(20)]<br class="title-page-name"/>[InlineData(21)]<br class="title-page-name"/>[InlineData(22)]<br class="title-page-name"/>[InlineData(23)]<br class="title-page-name"/>public void GivenAfternoon_ThenAfternoonMessage(int hour)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var afternoonTime = new TestTimeManager();<br class="title-page-name"/>  afternoonTime.SetDateTime(new DateTime(2017, 7, 13, hour, 0, 0));<br class="title-page-name"/>  var messageUtility = new MessageUtility(afternoonTime);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var message = messageUtility.GetGreeting();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Good afternoon", message);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>[Theory]<br class="title-page-name"/>[InlineData(0)]<br class="title-page-name"/>[InlineData(1)]<br class="title-page-name"/>[InlineData(2)]<br class="title-page-name"/>[InlineData(3)]<br class="title-page-name"/>[InlineData(4)]<br class="title-page-name"/>[InlineData(5)]<br class="title-page-name"/>[InlineData(6)]<br class="title-page-name"/>[InlineData(7)]<br class="title-page-name"/>[InlineData(8)]<br class="title-page-name"/>[InlineData(9)]<br class="title-page-name"/>[InlineData(10)]<br class="title-page-name"/>[InlineData(11)]<br class="title-page-name"/>public void GivenMorning_ThenMorningMessage(int hour)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var morningTime = new TestTimeManager();<br class="title-page-name"/>  morningTime.SetDateTime(new DateTime(2017, 7, 13, hour, 0, 0));<br class="title-page-name"/>  var messageUtility = new MessageUtility(morningTime);<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var message = messageUtility.GetGreeting();<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.Equal("Good morning", message);<br class="title-page-name"/>}</pre>
<p class="calibre2">Our production code would end up looking something like this:</p>
<pre class="calibre19">public class MessageUtility<br class="title-page-name"/>{<br class="title-page-name"/>  private readonly ITimeManager _timeManager;<br class="title-page-name"/><br class="title-page-name"/>  public MessageUtility(ITimeManager timeManager)<br class="title-page-name"/>  {<br class="title-page-name"/>    _timeManager = timeManager;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public string GetMessage()<br class="title-page-name"/>  {<br class="title-page-name"/>    if (_timeManager.Now.Hour &lt; 12)<br class="title-page-name"/>      return "Good morning";<br class="title-page-name"/> <br class="title-page-name"/>    return "Good afternoon";<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test double types</h1>
                
            
            <article>
                
<p class="calibre2">Test doubles come in many varieties. Those varieties can generally be grouped as dummies, stubs, spies, mocks, and fakes. Coming up, we will discuss the different types and provide examples in C# and in JavaScript for each.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dummies</h1>
                
            
            <article>
                
<p class="calibre2">Dummies are the simplest form of test double. A dummy has no appreciable functionality. We don't actually expect the <kbd class="calibre11">dummy</kbd> class or method to be used in the result of the class or method we are testing.</p>
<p class="calibre2">Dummies are most often used when the class you are testing has a dependency that the method or function you are testing does not use.</p>
<p class="calibre2">You create a dummy by creating a new copy or instance of a class or method and then doing absolutely nothing in the body of the code. Void methods will be empty and methods or functions expecting a return value will either throw when called or return the simplest form of that return value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dummy logger</h1>
                
            
            <article>
                
<p class="calibre2">A <em class="calibre12">Logging</em> service is a perfect example of something that can be replaced with a dummy. While you are testing specific methods it is unlikely (and not recommended) to also test logging functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in C#</h1>
                
            
            <article>
                
<p class="calibre2">The following is an example of a <kbd class="calibre11">DummyLogger</kbd> in C#. You'll note that when <kbd class="calibre11">Log</kbd> is called nothing happens.</p>
<pre class="calibre19">enum LogLevel<br class="title-page-name"/>{<br class="title-page-name"/>  None = 0,<br class="title-page-name"/>  Error = 1,<br class="title-page-name"/>  Warning = 2,<br class="title-page-name"/>  Success = 3,<br class="title-page-name"/>  Info = 4<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>interface ILogger<br class="title-page-name"/>{<br class="title-page-name"/>  void Log(LogLevel type, string message);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class DummyLogger: ILogger<br class="title-page-name"/>{ <br class="title-page-name"/>  public void Log(LogLevel type, string message)<br class="title-page-name"/>  {<br class="title-page-name"/>    // Do Nothing<br class="title-page-name"/>  }       <br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in JavaScript</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a</span> <kbd class="calibre11">DummyLogger</kbd><span> in JavaScript. You'll note that when </span><kbd class="calibre11">info</kbd>, <kbd class="calibre11">warn</kbd>, <kbd class="calibre11">error</kbd>, and <kbd class="calibre11">success</kbd><span> are called nothing happens.</span></p>
<pre class="calibre19"><strong class="calibre1">export class </strong>DummyLogger {<br class="title-page-name"/>   info(message) {<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   warn(message) {<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   error(message) {<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   success(message) {<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stubs</h1>
                
            
            <article>
                
<p class="calibre2">Stubs are the next level up from dummies. A Stub test double will provide the same response regardless of the parameters passed into it.</p>
<p class="calibre2">Stubs are used when you want to test different paths of execution in your code. One instance is an error that must be thrown under a particular condition.</p>
<p class="calibre2">Stubs are created by creating a copy or override of the class or method that needs to return the stub value and then setting it to return the needed value. Remember, stubs don't evaluate parameters, so you need to just return the desired value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in C#</h1>
                
            
            <article>
                
<p class="calibre2">The following is an example of a <kbd class="calibre11">StubSpeakerContactServiceError</kbd> in C#. You'll note that, when <kbd class="calibre11">MessageSpeaker</kbd> is called then a new <kbd class="calibre11">UnableToContactSpeakerException</kbd> error is thrown.</p>
<pre class="calibre19">class StubSpeakerContactServiceError : ISpeakerContactService<br class="title-page-name"/>{<br class="title-page-name"/>  public void MessageSpeaker(string message) <br class="title-page-name"/>  {<br class="title-page-name"/>    throw new UnableToContactSpeakerException();<br class="title-page-name"/>  } <br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in JavaScript</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a </span><kbd class="calibre11">stubSpeakerReducer</kbd><span> </span><span>in JavaScript. You'll note that regardless of the action passed in, a new <kbd class="calibre11"><em class="calibre12">UNABLE_TO_RETRIEVE_SPEAKERS</em></kbd> error is pushed to the error array in the state</span><span>.</span></p>
<pre class="calibre19"><strong class="calibre1"> import </strong>{ SpeakerErrors } <strong class="calibre1">from </strong><strong class="calibre1">'./errors'</strong>;<br class="title-page-name"/> <strong class="calibre1">import </strong>{ SpeakerFilters } <strong class="calibre1">from </strong><strong class="calibre1">'./actions'</strong>;<br class="title-page-name"/> <br class="title-page-name"/> <strong class="calibre1">const </strong>initialState = {<br class="title-page-name"/>   <strong class="calibre1">speakerFilter</strong>: SpeakerActions.SHOW_ALL,<br class="title-page-name"/>   <strong class="calibre1">speakers</strong>: [],<br class="title-page-name"/>   <strong class="calibre1">errors</strong>: []<br class="title-page-name"/> };<br class="title-page-name"/> <br class="title-page-name"/> <strong class="calibre1">export</strong> <strong class="calibre1">function </strong><em class="calibre12">stubSpeakerReducer</em>(state, action) {<br class="title-page-name"/>   state = state || initialState;<br class="title-page-name"/>   <br class="title-page-name"/>   state.<strong class="calibre1">speakerFilter </strong>= action.<strong class="calibre1">filter </strong>|| SpeakerFilters.SHOW_ALL;<br class="title-page-name"/>   state.<strong class="calibre1">errors</strong>.push(SpeakerErrors.UNABLE_TO_RETRIEVE_SPEAKERS);<br class="title-page-name"/>   <br class="title-page-name"/>   <strong class="calibre1">return </strong>state;<br class="title-page-name"/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Spies</h1>
                
            
            <article>
                
<p class="calibre2">Spies are the next evolution in test doubles. A spy returns a value similar to a stub but has an extremely important and helpful difference. Spies can report back on the information related to the function call.</p>
<p class="calibre2">Spies are most often used when you want to verify that a function was called with specific parameters. This is most useful at third-party boundaries in your application. For instance, it is important to know whether your application is correctly configuring a database connection using the credentials supplied by some configuration service. Also, in some cases, it is difficult to measure the side-effects of the method or function being tested. In those cases, you can use a spy to just make sure you are calling the method or function in the first place.</p>
<p class="calibre2">Spies are created by starting with a stub and adding the functionality to determine whether a function has been called, how many times a function is called, or reporting what values were passed into that function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in C#</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a </span><kbd class="calibre11">SpySpeakerContactService</kbd><span> in C#</span><span>. The <kbd class="calibre11">SpySpeakerContactService</kbd> allows you to determine if the service has been called and how many times it might have been called.</span></p>
<pre class="calibre19">class SpySpeakerContactService : ISpeakerContactService<br class="title-page-name"/>{<br class="title-page-name"/>  public bool MessageSpeakerHasBeenCalled { get; private set; }<br class="title-page-name"/><br class="title-page-name"/>  public int MessageSpeakerCallCount { get; private set; }<br class="title-page-name"/><br class="title-page-name"/>  public void MessageSpeaker(string message)<br class="title-page-name"/>  {<br class="title-page-name"/>    MessageSpeakerHasBeenCalled = true;<br class="title-page-name"/>    MessageSpeakerCallCount++;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in JavaScript</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a </span><kbd class="calibre11">spySpeakerReducer</kbd><span> in JavaScript</span><span>. The <kbd class="calibre11">spySpeakerReducer</kbd> allows you to determine how many times it might have been called.</span></p>
<pre class="calibre19"><strong class="calibre1">import </strong>{ speakerReducer <strong class="calibre1">as </strong>original_speakerReducer } <strong class="calibre1">from </strong><strong class="calibre1">'./reducers'</strong>;<br class="title-page-name"/> <br class="title-page-name"/> <strong class="calibre1">export let </strong>callCounter = 0;<br class="title-page-name"/> <br class="title-page-name"/> <strong class="calibre1">export function </strong><em class="calibre12">spySpeakerReducer</em>(state, action) {<br class="title-page-name"/>   callCounter++;<br class="title-page-name"/>   <br class="title-page-name"/>   <strong class="calibre1">return </strong>original_speakerReducer(state,action);<br class="title-page-name"/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Mocks</h1>
                
            
            <article>
                
<p class="calibre2">Mocks are essentially programmable spies. Mocks are useful when you want to use the same test double in multiple tests. Mocks have the ability to return whatever values you set them to return. It is important to note that mocks are still not doing any logic. They return the value that is specified and do not check the parameters passed to the function.</p>
<p class="calibre2">Mocks are used in all the situations where dummies, stubs, and spies are used. Mocks are a heavier implementation of a test double, which is why you may not want to use them all the time. Mocks get less reuse than the previous test doubles because a mock's data must be set for each test, whereas a dummy, stub, or spy has a set return value that does not need to be configured. Setting up the test data that gets returned is often more difficult than simply creating a whole stub or spy class.</p>
<p class="calibre2">Mocks are created by making a copy of a class or method and creating a property that can be set as the return value for a method; then, in the method being mocked, the property value is returned. Once created, before each test, the mock's return value must be set.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in C#</h1>
                
            
            <article>
                
<p class="calibre2">The following is an example of a <kbd class="calibre11">MockDateTimeService</kbd> in C#. The <kbd class="calibre11">MockDateTimeService</kbd> allows you to set the <kbd class="calibre11">DateTime</kbd> to be returned by the service in order to reliably test how other parts of the system might behave based on specific <kbd class="calibre11">DateTime</kbd>.</p>
<pre class="calibre19">class MockDateTimeService<br class="title-page-name"/>{<br class="title-page-name"/>  public DateTime CurrentDateTime { get; set; } = new DateTime();<br class="title-page-name"/><br class="title-page-name"/>  public DateTime UTCNow()<br class="title-page-name"/>  {<br class="title-page-name"/>    return CurrentDateTime.ToUniversalTime();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in JavaScript</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a </span><kbd class="calibre11">MockDateTimeService</kbd><span> in JavaScript</span><span>. Much like the <kbd class="calibre11">MockDateTimeService</kbd> in C#, this allows you to set the <kbd class="calibre11">DateTime</kbd> to be returned by the service in order to reliably test how other parts of the system might behave based on specific <kbd class="calibre11">DateTimes</kbd>.</span></p>
<pre class="calibre19"><strong class="calibre1">export class </strong>MockDateTimeService {<br class="title-page-name"/>   constructor() {<br class="title-page-name"/>     <strong class="calibre1">this</strong>.<strong class="calibre1">currentDateTime </strong>= <strong class="calibre1">new </strong>Date(2000, 0, 1);<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   now() {<br class="title-page-name"/>     <strong class="calibre1">return this</strong>.<strong class="calibre1">currentDateTime</strong>;<br class="title-page-name"/>   }<br class="title-page-name"/> }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Fakes</h1>
                
            
            <article>
                
<p class="calibre2">Fakes are the last and most powerful type of test double. A fake is a class that attempts to behave as if it weren't a test double. While a fake will not connect with a database, it will attempt to behave just like it is connecting to a database. A fake will not use the system clock, but it will attempt to have an internal clock that behaves as close to the system clock as possible.</p>
<p class="calibre2">Fakes either add extra testing functionality or prevent external interference from third-party libraries and systems. Most applications are connected to some data source. A fake repository can be created that uses its own in-memory data source but otherwise behaves just like a normal data connection.</p>
<p class="calibre2">Fakes are created by generating a whole new class or method and then writing enough functionality to be indistinguishable from the production class or method. The only important distinction for a fake versus a production class or method is that the fake does not make external connections and likely has the ability for the tester to control the underlying data set.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in C#</h1>
                
            
            <article>
                
<p class="calibre2">The following is an example of a <kbd class="calibre11">FakeRepository</kbd> and associated <em class="calibre12">interfaces</em>. The <kbd class="calibre11">FakeRepository</kbd> is a fake implementation of a generic repository.</p>
<pre class="calibre19">public interface IRepository&lt;T&gt;<br class="title-page-name"/>{<br class="title-page-name"/>  T Get(Func&lt;T, bool&gt; predicate);<br class="title-page-name"/>  IQueryable&lt;T&gt; GetAll();<br class="title-page-name"/>  T Save(T item);<br class="title-page-name"/>  IRepository&lt;T&gt; Include(Expression&lt;Func&lt;T, object&gt;&gt; path);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public interface IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  int Id {get;set;}<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>public class FakeRepository&lt;T&gt; : IRepository&lt;T&gt; where T : IIdentity<br class="title-page-name"/>{<br class="title-page-name"/>  private int _identityCounter = 0;<br class="title-page-name"/>  public IList&lt;T&gt; DataSet { get; set; } = new List&lt;T&gt;();<br class="title-page-name"/><br class="title-page-name"/>  public T Get(Func&lt;T, bool&gt; predicate)<br class="title-page-name"/>  {<br class="title-page-name"/>    return GetAll().Where(predicate).FirstOrDefault();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public IQueryable&lt;T&gt; GetAll()<br class="title-page-name"/>  {<br class="title-page-name"/>    return DataSet.AsQueryable();<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  public T Save(T item)<br class="title-page-name"/>  {<br class="title-page-name"/>    return item.Id == default(int) ? Create(item) : Update(item);<br class="title-page-name"/>  }           <br class="title-page-name"/><br class="title-page-name"/>  public IRepository&lt;T&gt; Include(Expression&lt;Func&lt;T, object&gt;&gt; path)<br class="title-page-name"/>  {<br class="title-page-name"/>    // Nothing to do here since this function is for EntityFramework<br class="title-page-name"/>    // We are using Linq to Objects so there is not need for Include<br class="title-page-name"/>    return this;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private T Create(T item)<br class="title-page-name"/>  { <br class="title-page-name"/>    item.Id = ++_identityCounter;<br class="title-page-name"/>    DataSet.Add(item);<br class="title-page-name"/>    return item;<br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>  private T Update(T item)<br class="title-page-name"/>  {<br class="title-page-name"/>    var found = Get(x =&gt; x.Id == item.Id);<br class="title-page-name"/><br class="title-page-name"/>    if(found == null)<br class="title-page-name"/>    {<br class="title-page-name"/>      throw new KeyNotFoundException($"Item with Id {item.Id} not    <br class="title-page-name"/>        found!");<br class="title-page-name"/>    }<br class="title-page-name"/><br class="title-page-name"/>    DataSet.Remove(found);<br class="title-page-name"/>    DataSet.Add(item);<br class="title-page-name"/><br class="title-page-name"/>    return item;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Example in JavaScript</h1>
                
            
            <article>
                
<p class="calibre2"><span>The following is an example of a </span><kbd class="calibre11">FakeDataContext</kbd> in JavaScript.</p>
<pre class="calibre19"><strong class="calibre1">export class </strong>FakeDataContext {<br class="title-page-name"/>   <strong class="calibre1">_identityCounter </strong>= 1;<br class="title-page-name"/>   <strong class="calibre1">_dataSet </strong>= [];<br class="title-page-name"/> <br class="title-page-name"/>   <strong class="calibre1">get </strong>DataSet() {<br class="title-page-name"/>     <strong class="calibre1">return this</strong>.<strong class="calibre1">_dataSet</strong>;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   <strong class="calibre1">set </strong>DataSet(value) {<br class="title-page-name"/>     <strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet </strong>= value;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   get(predicate) {<br class="title-page-name"/>     <strong class="calibre1">if </strong>(<strong class="calibre1">typeof</strong>(predicate) !== <strong class="calibre1">'function'</strong>) {<br class="title-page-name"/>       <strong class="calibre1">throw new </strong>Error(<strong class="calibre1">'Predicate must be a function'</strong>);<br class="title-page-name"/>     }<br class="title-page-name"/> <br class="title-page-name"/>     <strong class="calibre1">const </strong>resultSet = this_dataSet.<strong class="calibre1">filter</strong>(predicate);<br class="title-page-name"/> <br class="title-page-name"/>     <strong class="calibre1">return </strong>resultSet.<strong class="calibre1">length </strong>&gt;= 1 ? {...resultSet[0]} : <strong class="calibre1">null</strong>;<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   getAll() {<br class="title-page-name"/>     <strong class="calibre1">return this</strong>.<strong class="calibre1">_dataSet</strong>.map((x) =&gt; {<br class="title-page-name"/>       <strong class="calibre1">return </strong>{...x};<br class="title-page-name"/>     });<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   save(item) {<br class="title-page-name"/>     <strong class="calibre1">return </strong>item.<strong class="calibre1">id </strong>? <strong class="calibre1">this</strong>.update(item) : <strong class="calibre1">this</strong>.create(item);<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   update(item) {<br class="title-page-name"/>     <strong class="calibre1">if </strong>(!<strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet</strong>.some(x =&gt; x.<strong class="calibre1">id </strong>=== item.<strong class="calibre1">id</strong>)) {<br class="title-page-name"/>       <strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet</strong>.push({...item});<br class="title-page-name"/>     } <strong class="calibre1">else </strong>{<br class="title-page-name"/>       <strong class="calibre1">let </strong>itemIndex = <strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet</strong>.findIndex(x =&gt; x.<strong class="calibre1">id </strong>=== item.<strong class="calibre1">id</strong>);<br class="title-page-name"/>       <strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet</strong>[itemIndex] = {...item};<br class="title-page-name"/>     }<br class="title-page-name"/> <br class="title-page-name"/>     <strong class="calibre1">return </strong>{...item};<br class="title-page-name"/>   }<br class="title-page-name"/> <br class="title-page-name"/>   create(item) {<br class="title-page-name"/>     <strong class="calibre1">let </strong>newItem = {...item};<br class="title-page-name"/>     newItem.<strong class="calibre1">id </strong>= <strong class="calibre1">this</strong>.<strong class="calibre1">_identityCounter</strong>++;<br class="title-page-name"/>     <strong class="calibre1">this</strong>.<strong class="calibre1">_dataSet</strong>.push({...newItem});<br class="title-page-name"/> <br class="title-page-name"/>     <strong class="calibre1">return </strong>{...newItem};<br class="title-page-name"/>   }<br class="title-page-name"/> } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">N-Tiered example</h1>
                
            
            <article>
                
<p class="calibre2">Now, turn your attention back to the API controller in <a target="_blank" href="part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 2</a>, <em class="calibre12">Setting Up the .NET Test Environment</em>. Hard-coded data being returned directly from the controller does not make for a solid foundation on which to build an application. Most modern .NET applications of any size are written in some sort of N-tiered architecture. You'll want to separate your business logic from your presentation, in this instance, the presentation in the API endpoint.</p>
<p class="calibre2">We'll introduce an <em class="calibre12">interface</em> for a speaker service in preparation for using Dependency Injection to provide the concrete implementation to the controller, then verify that the proper method in the new service is being called. You'll need to rearrange some tests in order to remove the business logic from the controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Presentation layer</h1>
                
            
            <article>
                
<p class="calibre2">To get started, add a new test to verify that the controller accepts an <em class="calibre12">interface</em> of <kbd class="calibre11">ISpeakerService</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItAcceptsInterface()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange <br class="title-page-name"/>  ISpeakerService testSpeakerService = new TestSpeakerService();<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  var controller = new SpeakerController(testSpeakerService);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(controller);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, make your test pass by creating a constructor in the <kbd class="calibre11">SpeakerController</kbd> to accept the <kbd class="calibre11">ISpeakerService</kbd> interface, introducing a field variable and a constructor in your <kbd class="calibre11">speaker controller</kbd> class:</p>
<pre class="calibre19">public SpeakerController(ISpeakerService speakerService)<br class="title-page-name"/>{<br class="title-page-name"/>}</pre>
<p class="calibre2">Your test project should now fail to compile. This is because in our previous example from <a target="_blank" href="part0069.html#21PMQ0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 2</a>, <em class="calibre12">Setting up the .NET Test Environment</em>, we're defining the controller instance in the constructor of the test class. Modify the constructor to create an instance of <kbd class="calibre11">TestSpeakerService</kbd>, which implements the <kbd class="calibre11">ISpeakerService</kbd> interface, and pass this to the <kbd class="calibre11">SpeakerController</kbd>. Feel free to create the <kbd class="calibre11">TestSpeakerService</kbd> in your test class:</p>
<pre class="calibre19">public SpeakerControllerSearchTests()<br class="title-page-name"/>{<br class="title-page-name"/>  var testSpeakerService = new TestSpeakerService();<br class="title-page-name"/><br class="title-page-name"/>  _controller = new SpeakerController(testSpeakerService);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, you'll want to verify that the <kbd class="calibre11">Search</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> is called from the controller. But, how do you do that? One way is to use a mocking framework called <em class="calibre12">Moq</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Moq</h1>
                
            
            <article>
                
<p class="calibre2">To add <em class="calibre12">Moq</em> to your unit test project, right-click on your test project and choose <span>Manage NuGet Packages</span>. Browse for <em class="calibre12">Moq,</em> and choose to install the latest stable version. We won't delve too deeply into <em class="calibre12">Moq</em>, but we will show how mocking frameworks help facilitate testing the boundaries of your application.</p>
<p class="calibre2">Add a test to verify that the <kbd class="calibre11">Search</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> is called once from the <kbd class="calibre11">Search</kbd> action result of the controller:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItCallsSearchServiceOnce()<br class="title-page-name"/>{ <br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Search("jos");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  _speakerServiceMock.Verify(mock =&gt; mock.Search(It.IsAny&lt;string&gt;()), <br class="title-page-name"/>      Times.Once());<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to make the test pass, you will also be required to do a little more setup in the constructor of the <kbd class="calibre11">test</kbd> class:</p>
<pre class="calibre19">private readonly SpeakerController _controller;<br class="title-page-name"/>private static Mock&lt;ISpeakerService&gt; _speakerServiceMock;<br class="title-page-name"/><br class="title-page-name"/>public SpeakerControllerSearchTests()<br class="title-page-name"/>{<br class="title-page-name"/>  var speaker = new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Name = "test"<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  // define the mock<br class="title-page-name"/>  _speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/><br class="title-page-name"/>  // when search is called, return list of speakers containing speaker<br class="title-page-name"/>  _speakerServiceMock.Setup(x =&gt; x.Search(It.IsAny&lt;string&gt;()))<br class="title-page-name"/>      .Returns(() =&gt; new List&lt;Speaker&gt; { speaker });<br class="title-page-name"/><br class="title-page-name"/>  // pass mock object as ISpeakerService<br class="title-page-name"/>  _controller = new SpeakerController(_speakerServiceMock.Object);<br class="title-page-name"/>}</pre>
<p class="calibre2">Be sure to modify the <em class="calibre12">interface</em> so that the application will compile:</p>
<pre class="calibre19">public interface ISpeakerService<br class="title-page-name"/>{<br class="title-page-name"/>  IEnumerable&lt;Speaker&gt; Search(string searchString);<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, make your test pass by ensuring the <kbd class="calibre11">Search</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> is called from the <kbd class="calibre11">Search</kbd> action result of the controller. If you haven't done so already, create a <kbd class="calibre11">field</kbd> variable for <kbd class="calibre11">_speakerService</kbd> that is assigned in the constructor by the <kbd class="calibre11">speakerService</kbd> parameter:</p>
<pre class="calibre19">private readonly ISpeakerService _speakerService;<br class="title-page-name"/><br class="title-page-name"/>public SpeakerController(ISpeakerService speakerService)<br class="title-page-name"/>{<br class="title-page-name"/>  _speakerService = speakerService;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>[Route("search")]<br class="title-page-name"/>public IActionResult Search(string searchString)<br class="title-page-name"/>{<br class="title-page-name"/>  var hardCodedSpeakers = new List&lt;Speaker&gt;<br class="title-page-name"/>  {<br class="title-page-name"/>    new Speaker{Name = "Josh"},<br class="title-page-name"/>    new Speaker{Name = "Joshua"},<br class="title-page-name"/>    new Speaker{Name = "Joseph"},<br class="title-page-name"/>    new Speaker{Name = "Bill"},<br class="title-page-name"/>  };<br class="title-page-name"/><br class="title-page-name"/>  _speakerService.Search("foo");<br class="title-page-name"/><br class="title-page-name"/>  var speakers = hardCodedSpeakers.Where(x =&gt;   <br class="title-page-name"/>                       x.Name.StartsWith(searchString,  <br class="title-page-name"/>                       StringComparison.OrdinalIgnoreCase)).ToList();<br class="title-page-name"/><br class="title-page-name"/>  return Ok(speakers);<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, add a test to validate that the <kbd class="calibre11">searchString</kbd> supplied to the <kbd class="calibre11">Search</kbd> action result of the controller is the <kbd class="calibre11">searchString</kbd> being passed to the <kbd class="calibre11">Search</kbd> method of the <kbd class="calibre11">SpeakerService</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSearchStringThenSpeakerServiceSearchCalledWithString(){<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var searchString = "jos";<br class="title-page-name"/><br class="title-page-name"/>  // Act<br class="title-page-name"/>  _controller.Search(searchString);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  _speakerServiceMock.Verify(mock =&gt; mock.Search(searchString),   <br class="title-page-name"/>      Times.Once());<br class="title-page-name"/>}</pre>
<p class="calibre2">And make the test pass by supplying <kbd class="calibre11">searchString</kbd> to the <kbd class="calibre11">Search</kbd> method on the <kbd class="calibre11">_speakerService</kbd>:</p>
<pre class="calibre19">  _speakerService.Search(searchString);</pre>
<p class="calibre2">Now, ensure that the results of the <kbd class="calibre11">Search</kbd> method from the <kbd class="calibre11">SpeakerService</kbd> are what is being returned by the action result:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenSpeakerServiceThenResultsReturned()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  var searchString = "jos";<br class="title-page-name"/><br class="title-page-name"/>  // Act <br class="title-page-name"/>  var result = _controller.Search(searchString) as OkObjectResult;<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  Assert.NotNull(result);<br class="title-page-name"/>  var speakers = ((IEnumerable&lt;Speaker&gt;)result.Value).ToList();<br class="title-page-name"/>  Assert.Equal(_speakers, speakers);<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember, the results returned by the <kbd class="calibre11">Search</kbd> method of the <kbd class="calibre11">SpeakerService</kbd> are being defined by the <kbd class="calibre11">Mock</kbd>. You'll need to extract a <kbd class="calibre11">field</kbd> in order to test that the results being returned by the <em class="calibre12">action result</em> are the same as those being defined for our <kbd class="calibre11">Mock</kbd>:</p>
<pre class="calibre19">private readonly SpeakerController _controller;<br class="title-page-name"/>private static Mock&lt;ISpeakerService&gt; _speakerServiceMock;<br class="title-page-name"/>private readonly List&lt;Speaker&gt; _speakers;<br class="title-page-name"/><br class="title-page-name"/>public SpeakerControllerSearchTests()<br class="title-page-name"/>{<br class="title-page-name"/>  _speakers = new List&lt;Speaker&gt; { new Speaker<br class="title-page-name"/>  {<br class="title-page-name"/>    Name = "test"<br class="title-page-name"/>  } };<br class="title-page-name"/><br class="title-page-name"/>  _speakerServiceMock = new Mock&lt;ISpeakerService&gt;();<br class="title-page-name"/>  _speakerServiceMock.Setup(x =&gt; x.Search(It.IsAny&lt;string&gt;()))<br class="title-page-name"/>                .Returns(() =&gt; _speakers);<br class="title-page-name"/><br class="title-page-name"/>  _controller = new SpeakerController(_speakerServiceMock.Object);<br class="title-page-name"/>}</pre>
<p class="calibre2">There's still the problem of the hard-coded data. Don't forget to remove unnecessary and unneeded code while you're making your test pass. Remember <em class="calibre12">red, green, refactor</em>. This applies to your production code as well as your tests.</p>
<p class="calibre2">You may encounter some failing tests once you remove the hard-coded data. For now, skip these tests, as we'll be moving this logic to another part of the application. Now it's time to create a <kbd class="calibre11">SpeakerService</kbd>:</p>
<pre class="calibre19">xUnit<br class="title-page-name"/> [Fact(Skip="Reason for skipping")]<br class="title-page-name"/>MSTest<br class="title-page-name"/> [Skip]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Business layer</h1>
                
            
            <article>
                
<p class="calibre2">You might want to start thinking about how to organize your tests effectively. As your application grows, and the number of test files increases, you may find it more and more cumbersome to navigate your solution. One answer  might be to create individual folders per class under test and a single file per public method within the class folder. This might look something like this:</p>
<pre class="calibre19">SpeakerService -&gt; Search</pre>
<p class="calibre2">You don't necessarily need to tackle this now, but it wouldn't hurt to have a plan for the future. Applications tend to grow quite quickly, and before you know it you will have thirteen projects within your solution. You may choose to go ahead and create a <kbd class="calibre11">Services</kbd> project with a <kbd class="calibre11">ServicesTest</kbd> project at this time, to separate your business layer and associated tests from your presentation layer and its tests. That will be left as an exercise for the reader.</p>
<p class="calibre2">Now, create a new test class for the <kbd class="calibre11">SpeakerService</kbd>. Here is where you'll be creating all of your test methods for <kbd class="calibre11">Search</kbd> in the <kbd class="calibre11">SpeakerService</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItExists()<br class="title-page-name"/>{<br class="title-page-name"/>  var speakerService = new SpeakerService();<br class="title-page-name"/>}</pre>
<p class="calibre2">Once you make this test pass, create a few new tests to confirm the <kbd class="calibre11">Search</kbd> method exists and that it returns a collection of speakers:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItHasSearchMethod()<br class="title-page-name"/>{<br class="title-page-name"/>  var speakerService = new SpeakerService();<br class="title-page-name"/>  <br class="title-page-name"/>  speakerService.Search("test");<br class="title-page-name"/>}</pre>
<p class="calibre2">Next, test that the <kbd class="calibre11">SpeakerService</kbd> implements the <kbd class="calibre11">ISpeakerService</kbd> interface:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void ItImplementsISpeakerService()<br class="title-page-name"/>{<br class="title-page-name"/>  var speakerService = new SpeakerService();<br class="title-page-name"/><br class="title-page-name"/>  Assert.True(speakerService is ISpeakerService);<br class="title-page-name"/>}</pre>
<p class="calibre2">Your <kbd class="calibre11">SpeakerService</kbd> should now look something like this:</p>
<pre class="calibre19">public class SpeakerService : ISpeakerService<br class="title-page-name"/>{<br class="title-page-name"/>  public IEnumerable&lt;Speaker&gt; Search(string searchString)<br class="title-page-name"/>  {<br class="title-page-name"/>    return new List&lt;Speaker&gt;();<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Remember, take slow and methodical steps. You are not allowed to write a line of production code without writing a failing test, and you're not to write more production code than is sufficient to make the tests pass.</p>
<p class="calibre2">Now, begin to move the s<em class="calibre12">kipped</em> tests from the <kbd class="calibre11">controller test</kbd> file to the <kbd class="calibre11">Speaker Service Search Test</kbd> file. Start with <kbd class="calibre11">GivenExactMatchThenOneSpeakerInCollection</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenExactMatchThenOneSpeakerInCollection()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _speakerService.Search("Joshua");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  var speakers = result.ToList();<br class="title-page-name"/>  Assert.Equal(1, speakers.Count);<br class="title-page-name"/>  Assert.Equal("Joshua", speakers[0].Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">Make this test pass, then move on to <kbd class="calibre11">GivenCaseInsensitveMatchThenSpeakerInCollection</kbd>:</p>
<pre class="calibre19">[Theory]<br class="title-page-name"/>[InlineData("Joshua")]<br class="title-page-name"/>[InlineData("joshua")]<br class="title-page-name"/>[InlineData("JoShUa")]<br class="title-page-name"/>public void GivenCaseInsensitveMatchThenSpeakerInCollection(string searchString)<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _speakerService.Search(searchString);<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  var speakers = result.ToList();<br class="title-page-name"/>  Assert.Equal(1, speakers.Count);<br class="title-page-name"/>  Assert.Equal("Joshua", speakers[0].Name);<br class="title-page-name"/>}</pre>
<p class="calibre2">And finally, <kbd class="calibre11">GivenNoMatchThenEmptyCollection</kbd> and <kbd class="calibre11">Given3MatchThenCollectionWith3Speakers</kbd>:</p>
<pre class="calibre19">[Fact]<br class="title-page-name"/>public void GivenNoMatchThenEmptyCollection()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _speakerService.Search("ZZZ");<br class="title-page-name"/>  <br class="title-page-name"/>  // Assert<br class="title-page-name"/>  var speakers = result.ToList();<br class="title-page-name"/>  Assert.Equal(0, speakers.Count);<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>[Fact]<br class="title-page-name"/>public void Given3MatchThenCollectionWith3Speakers()<br class="title-page-name"/>{<br class="title-page-name"/>  // Arrange<br class="title-page-name"/>  // Act<br class="title-page-name"/>  var result = _speakerService.Search("jos");<br class="title-page-name"/><br class="title-page-name"/>  // Assert<br class="title-page-name"/>  var speakers = result.ToList();<br class="title-page-name"/>  Assert.Equal(3, speakers.Count);<br class="title-page-name"/>  Assert.True(speakers.Any(s =&gt; s.Name == "Josh"));<br class="title-page-name"/>  Assert.True(speakers.Any(s =&gt; s.Name == "Joshua"));<br class="title-page-name"/>  Assert.True(speakers.Any(s =&gt; s.Name == "Joseph"));<br class="title-page-name"/>}</pre>
<p class="calibre2">As you get more comfortable with the practice and gain more experience with TDD, you may find it helpful to list the tests which you want to implement. This could be simply jotting them down on a piece of paper, or stubbing out some skipped or ignored tests in your IDE.</p>
<p class="calibre2">If done correctly, your code should look something like this:</p>
<pre class="calibre19">public class SpeakerService : ISpeakerService<br class="title-page-name"/>{<br class="title-page-name"/>  public IEnumerable&lt;Speaker&gt; Search(string searchString)<br class="title-page-name"/>  {<br class="title-page-name"/>    var hardCodedSpeakers = new List&lt;Speaker&gt;<br class="title-page-name"/>    {<br class="title-page-name"/>      new Speaker{Name = "Josh"},<br class="title-page-name"/>      new Speaker{Name = "Joshua"},<br class="title-page-name"/>      new Speaker{Name = "Joseph"},<br class="title-page-name"/>      new Speaker{Name = "Bill"},<br class="title-page-name"/>    };<br class="title-page-name"/><br class="title-page-name"/>    var speakers = hardCodedSpeakers.Where(x =&gt; <br class="title-page-name"/>                        x.Name.StartsWith(searchString, <br class="title-page-name"/>                        StringComparison.OrdinalIgnoreCase)).ToList();<br class="title-page-name"/><br class="title-page-name"/>    return speakers;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We’ve now moved the hard-coded data out of our controller and into our business layer in the <kbd class="calibre11">SpeakerService</kbd>. You may think that a lot of effort was expended simply to move the problem into a new file! While this is true to an extent, this actually puts us in a better place for future development. The "logic", such as it is, has been moved into a class that can be reused by other parts of the application, and by potential new interfaces (think native and/or mobile applications) that would not have access to our original controller.</p>
<p class="calibre2">We'll continue with this example in future chapters. We will <em class="calibre12">finally</em> rid ourselves of hard-coded data and implement a data access layer using the Entity framework. All of this can be accomplished with Test-Driven Development.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we covered some pitfalls that will hinder TDD, such as dependence on third-party libraries, direct instantiation of classes, and fragile tests. We also discussed ways to avoid or work around those issues. We introduced and discussed each of the SOLID principles. We also discussed the different types of test double and when each type is appropriate. Lastly, we gave a short example of an N-tiered application and how it could be tested.</p>
<p class="calibre2">In <a target="_blank" href="part0183.html#5EGMU0-d186949d2da74f5c95dd1712efae1195" class="calibre10">Chapter 5</a>, <em class="calibre12">Tabula Rasa – Approaching an Application with TDD in Mind</em>, we'll explore how to approach and application with a TDD in mind, turning theory into practice, and how better to grow an application through tests.</p>


            </article>

            
        </section>
    </body></html>