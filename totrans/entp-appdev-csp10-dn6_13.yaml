- en: '*Chapter 10*: Creating an ASP.NET Core 6 Web API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：创建 ASP.NET Core 6 Web API'
- en: In recent times, web services have become an important part of web application
    development. With ever-changing requirements and increased business complexity,
    it is very important to loosely couple various components/layers involved in web
    application development, and there is nothing better than decoupling the **user
    interface** (**UI**) part of the application with the core business logic. This
    is where the simplicity of web services using a RESTful approach (where **REST**
    stands for **REpresentational State Transfer**) helps us to develop scalable web
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，Web 服务已成为 Web 应用程序开发的重要组成部分。随着需求的不断变化和商业复杂性的增加，松散耦合 Web 应用程序开发中涉及的各个组件/层非常重要，而与应用程序的核心业务逻辑解耦的方案则更为出色。这就是使用
    RESTful 方法（其中 **REST** 代表 **REpresentational State Transfer**）的 Web 服务的简单性帮助我们开发可扩展的
    Web 应用程序的地方。
- en: In this chapter, we will learn how to build RESTful services using an ASP.NET
    Core web **application programming interface** (**API**), and along the way, we
    will build all the required APIs for our e-commerce application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 ASP.NET Core Web **应用程序编程接口**（**API**）构建 RESTful 服务，并且在这个过程中，我们将为我们的电子商务应用程序构建所有必需的
    API。
- en: 'We''ll be covering the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下主题：
- en: Introduction to REST
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST 简介
- en: Understanding the internals of an ASP.NET Core 6 web API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 6 Web API 的内部结构
- en: Handling requests using controllers and actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用控制器和操作处理请求
- en: Integration with the data layer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数据层的集成
- en: Understanding **Google Remote Procedure Call** (**gRPC**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 **Google 远程过程调用**（**gRPC**）
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will require a basic knowledge of C#, .NET Core, web APIs,
    **HyperText Transfer Protocol** (**HTTP**), Azure, **dependency injection** (**DI**),
    Postman, and the .NET **command-line interface** (**CLI**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要具备基本的 C#、.NET Core、Web API、**超文本传输协议**（**HTTP**）、Azure、**依赖注入**（**DI**）、Postman
    以及 .NET **命令行界面**（**CLI**）知识。
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi)。
- en: 'For more code examples, refer to the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 更多代码示例，请参考以下链接：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application)。
- en: Introduction to REST
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 简介
- en: REST is an architectural guideline for building a web service. Primarily, it
    defines a set of constraints that can be followed while designing a web service.
    One of the key principal REST approaches recommends that APIs should be designed
    around resources and should be media- and protocol-agnostic. The underlying implementation
    of the API is independent of the client consuming the API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是构建 Web 服务的架构指南。主要来说，它定义了一组在设计 Web 服务时可以遵循的约束。REST 方法的关键原则之一建议 API 应该围绕资源设计，并且应该是媒体和协议无关的。API
    的底层实现与使用 API 的客户端是独立的。
- en: 'Considering an example of our e-commerce application, let''s say we are searching
    for a product on the UI using a product''s search field. There should be an API
    that is created for products, and here, products are nothing but a resource in
    the context of an e-commerce application. The `GET` operation on product entities:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的电子商务应用程序为例，假设我们在 UI 中使用产品搜索字段搜索产品。应该有一个为产品创建的 API，在这里，产品只是电子商务应用程序上下文中的一个资源。对产品实体执行
    `GET` 操作：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The response of the API should be independent of the client that is calling
    the API—that is, in this case, we are using a browser to load a list of products
    on the product search page. However, the same API can be consumed in a mobile
    application as well without any changes. Secondly, in this case, in order to retrieve
    product information internally, an application may be using one or more physical
    data stores; however, that complexity is hidden from the client application, and
    the API is exposed to the client as a single business entity—products. Although
    REST principles do not dictate the protocol to be HTTP, the majority of RESTful
    services are built over HTTP. Some key design principles/constraints/rules of
    HTTP-based RESTful APIs are outlined here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: API 的响应应该独立于调用 API 的客户端——也就是说，在这种情况下，我们正在使用浏览器在产品搜索页面上加载产品列表。然而，相同的 API 可以在移动应用程序中消费，而无需任何更改。其次，在这种情况下，为了内部检索产品信息，应用程序可能使用一个或多个物理数据存储；然而，这种复杂性被隐藏在客户端应用程序中，API
    作为单个业务实体——产品——暴露给客户端。尽管 REST 原则并没有规定必须使用 HTTP 协议，但大多数 RESTful 服务都是建立在 HTTP 之上的。这里概述了基于
    HTTP 的 RESTful API 的一些关键设计原则/约束/规则：
- en: Identify the business entities of the system and design APIs around those resources.
    In the case of our e-commerce application, all our APIs would be around resources
    such as products, orders, payments, and users.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别系统的业务实体，并围绕这些资源设计 API。在我们的电子商务应用程序中，我们所有的 API 都将围绕产品、订单、支付和用户等资源进行设计。
- en: REST APIs should have a uniform interface that assists in making them independent
    of the client. As all the APIs need to be resource-oriented, each resource is
    uniquely identified by a URI; additionally, various operations on resources are
    uniquely identified by HTTP verbs such as `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`.
    For example, `GET` (`http://ecommerce.packt.com/products/1`) should be used to
    retrieve a product with an`1`. Similarly, `DELETE` (`http://ecommerce.packt.com/products/1`)
    should be used to delete a product.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RESTful API 应该有一个统一的接口，有助于使它们独立于客户端。由于所有 API 都需要面向资源，每个资源都由 URI 唯一标识；此外，对资源的各种操作由
    HTTP 动词（如 `GET`、`POST`、`PUT`、`PATCH` 和 `DELETE`）唯一标识。例如，使用 `GET` (`http://ecommerce.packt.com/products/1`)
    应该用来检索一个产品。同样，使用 `DELETE` (`http://ecommerce.packt.com/products/1`) 应该用来删除一个产品。
- en: As HTTP is stateless, REST dictates a number of things for RESTful APIs. What
    this means is that APIs should be atomic and conclude the processing of a request
    within the same call. Any subsequent request, even from the same client (same
    **Internet Protocol** (**IP**) address), is treated as a new request. For example,
    if an API accepts an authentication token, it should accept authentication for
    each request. One major advantage of statelessness is the scalability that servers
    can eventually achieve, as a client can make an API call to any of the available
    servers and still receive the same response.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 HTTP 是无状态的，REST 对 RESTful API 规定了一系列内容。这意味着 API 应该是原子的，并在同一调用中完成请求的处理。任何后续请求，即使是来自同一客户端（相同的
    **Internet Protocol**（**IP**）地址），都被视为新的请求。例如，如果 API 接受身份验证令牌，它应该为每个请求接受身份验证。无状态的一个主要优点是服务器最终可以实现的可扩展性，因为客户端可以向任何可用的服务器发出
    API 调用，并仍然收到相同的响应。
- en: Apart from sending back a response, APIs should make use of HTTP status codes
    and response headers to send any additional information to the client. For example,
    if a response can be cached, an API should send the relevant response headers
    to the client so that it can be cached. `1xx` for information, `2xx` for success,
    `3xx` for redirection, `4xx` for client errors, and `5xx` for server errors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了发送回响应之外，API 应该利用 HTTP 状态码和响应头来向客户端发送任何额外的信息。例如，如果响应可以被缓存，API 应该向客户端发送相关的响应头，以便它可以被缓存。`1xx`
    表示信息，`2xx` 表示成功，`3xx` 表示重定向，`4xx` 表示客户端错误，`5xx` 表示服务器错误。
- en: APIs should give information about the resource such that clients should be
    easily able to discover it without any prior information relating to the resource—that
    is, there should follow the principle of **Hypermedia as the Engine of Application
    State** (**HATEOAS**). For example, if there is an API to create a product, once
    a product is created, the API should respond with the URI of that resource so
    that the client can use that to retrieve the product later.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 应该提供关于资源的信息，使得客户端能够轻松地发现它，而无需任何与资源相关的先验信息——也就是说，应该遵循**超媒体作为应用状态引擎**（**HATEOAS**）的原则。例如，如果有一个创建产品的
    API，一旦产品创建成功，API 应该返回该资源的 URI，以便客户端可以用来稍后检索该产品。
- en: 'Refer to the following response for an API that retrieves a list of all products
    (`GET /products`) and has information to retrieve further details regarding each
    product:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有关检索所有产品列表（`GET /products`）和获取每个产品详细信息的信息，请参阅以下响应：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding example is one way to implement the *HATEOAS* principle, but it
    can be designed in a more descriptive way, such as a response containing information
    about accepted HTTP verbs and relationships.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例是实施*HATEOAS*原则的一种方式，但它可以设计得更加描述性，例如包含有关接受的HTTP动词和关系的响应信息。
- en: The REST maturity model
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST成熟度模型
- en: 'These are various guidelines that an API should follow in order for it to be
    RESTful. However, not all the principles need to be followed to make it perfectly
    RESTFUL; it''s more important that an API should fulfill the business goal rather
    than being 100% REST-compliant. Leonard Richardson, an expert on RESTful API design,
    came up with the following model to categorize the maturity of an API:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是API应该遵循的各种指南，以便使其成为RESTful API。然而，并非所有原则都需要遵循才能使其完美地符合RESTful；更重要的是，API应该实现业务目标，而不是100%符合REST规范。RESTful
    API设计专家Leonard Richardson提出了以下模型来分类API的成熟度：
- en: '`POST` URI to perform all operations will fall under this category. An example
    would be a **Simple Object Access Protocol** (**SOAP**)-based web service that
    has a single URI, and all operations are segregated based on the SOAP envelope.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行所有操作的URI属于这一类别。一个例子是基于**简单对象访问协议**（**SOAP**）的Web服务，它有一个单一的URI，所有操作都是基于SOAP信封进行隔离的。
- en: '**Level 1—Resources**: All resources are URI-driven, and APIs that have a dedicated
    URI pattern per resource fall under this maturity model.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别1—资源**：所有资源都是URI驱动的，每个资源都有专门的URI模式，这些API属于此成熟度模型。'
- en: '`GET` and `DELETE` using the same URI with different HTTP verbs falls under
    this maturity model. Most enterprise application RESTful APIs fall under this
    category.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同URI但不同HTTP动词进行`GET`和`DELETE`操作属于此成熟度模型。大多数企业应用RESTful API都属于这一类别。
- en: '**Level 3—HATEOAS**: APIs that are designed with all additional discovery information
    (the URI for the resources; various operations that the resource supports) fall
    under this maturity model. Very few APIs are compliant with this maturity level;
    however, as discussed earlier, it''s important that our APIs fulfill the business
    objective and are as compliant as possible with RESTful principles, rather than
    100% compliant but not fulfilling the business objective.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级别3—HATEOAS**：设计时包含所有附加发现信息（资源的URI；资源支持的各种操作）的API属于此成熟度模型。很少有API符合此成熟度级别；然而，如前所述，重要的是我们的API应该实现业务目标，并且尽可能符合RESTful原则，而不是100%符合但未实现业务目标。'
- en: 'The following diagram illustrates Richardson''s maturity model:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了Richardson成熟度模型：
- en: '![Figure 10.1 – Richardson''s maturity model'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – Richardson的成熟度模型'
- en: '](img/Figure_10.1_B18507.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.1_B18507.jpg]'
- en: Figure 10.1 – Richardson's maturity model
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – Richardson的成熟度模型
- en: Up to now, we have discussed various principles of REST architecture. In the
    next section, let's get into using an ASP.NET Core web API for which we will create
    various RESTful services in our e-commerce application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了REST架构的各种原则。在下一节中，让我们深入了解使用ASP.NET Core Web API，我们将在我们的电子商务应用程序中创建各种RESTful服务。
- en: Understanding the internals of an ASP.NET Core 6 web API
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core 6 Web API的内部结构
- en: '**ASP.NET Core** is a unified framework that runs on top of .NET Core and is
    used to develop web applications (MVC/Razor), RESTful services (web API), and—most
    recently—web assembly-based client applications (Blazor apps). The fundamental
    design of ASP.NET Core applications is based on the **Model-View-Controller**
    (**MVC**) pattern, which divides code into three primary categories, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASP.NET Core**是一个在.NET Core之上运行的统一框架，用于开发Web应用程序（MVC/Razor）、RESTful服务（Web
    API）以及最近基于Web Assembly的客户端应用程序（Blazor应用程序）。ASP.NET Core应用程序的基本设计基于**模型-视图-控制器**（**MVC**）模式，将代码分为三个主要类别，如下所示：'
- en: '**Model**: This is a **plain old CLR object** (**POCO**) class that holds the
    data and is used to pass data between various layers of the application. Layers
    include passing data between the *repository* class and the *service* class or
    passing information back and forth between the *client* and *server*. The model
    primarily represents the resource state or the domain model of the application
    and contains information that you have requested.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这是一个**简单的普通CLR对象**（**POCO**）类，用于存储数据并在应用程序的各个层之间传递数据。层包括在*仓库*类和*服务*类之间传递数据，或者在与*客户端*和*服务器*之间来回传递信息。模型主要表示资源状态或应用程序的领域模型，并包含您请求的信息。'
- en: For example, if we wanted to store user profile information, this can be represented
    by the `UserInformation` POCO class and can contain all the profile information.
    This will be further used to pass between repositories and service classes and
    can also be serialized into **JavaScript Object Notation** (**JSON**)/**Extensible
    Markup Language** (**XML**) before being sent back to the client. In enterprise
    applications, we will encounter different types of models while creating models
    for our e-commerce application in the *Integration with the data layer* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想存储用户配置文件信息，这可以通过`UserInformation` POCO类表示，并可以包含所有配置文件信息。这将进一步用于在仓库和服务类之间传递，也可以在发送回客户端之前将其序列化为**JavaScript对象表示法**（**JSON**）/**可扩展标记语言**（**XML**）。在企业应用程序中，在*与数据层集成*部分创建我们的电子商务应用程序模型时，我们将遇到不同类型的模型。
- en: '**View**: These are the pages that represent UIs. All our models retrieved
    from controllers are bound to various **HyperText Markup Language** (**HTML**)
    controls on views and are presented to users. Views are usually common in MVC/Razor
    applications; for web API applications, the process ends with serializing models
    as a response.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这些是表示UI的页面。我们从控制器检索的所有模型都绑定到视图上的各种**超文本标记语言**（**HTML**）控件，并向用户展示。视图在MVC/Razor应用程序中通常是常见的；对于Web
    API应用程序，过程以将模型序列化为响应结束。'
- en: '`Microsoft.AspNetCore.Mvc.ControllerBase` class to define controllers.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Microsoft.AspNetCore.Mvc.ControllerBase`类来定义控制器。
- en: So, in a web application developed using ASP.NET Core, whenever a request comes
    from a client (browser, mobile apps, and similar sources), it goes through the
    ASP.NET Core request pipeline and reaches a controller that interacts with the
    data store to populate models/view-models and send them back either as a response
    in the form of JSON/XML or to a view to further bind the response and present
    it to the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在用ASP.NET Core开发的Web应用程序中，每当客户端（浏览器、移动应用等类似来源）发起请求时，它将通过ASP.NET Core请求管道，到达与数据存储交互的控制器，以填充模型/视图模型并将它们以JSON/XML形式作为响应发送回去，或者发送到视图中以进一步绑定响应并向用户展示。
- en: As you can see, there is a clear **separation of concerns** (**SOC**) where
    a controller is not aware of any UI aspect and performs the business logic in
    the current context and responds via models; views, on the other hand, receive
    models and use them to present them to the user in HTML pages. This SOC easily
    helps to unit test the application, as well as maintain and scale it as needed.
    MVC patterns are not only applicable to web applications and can be used for any
    application that requires an SOC.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，存在一个清晰的**关注点分离**（**SOC**），其中控制器不了解任何UI方面，并在当前上下文中执行业务逻辑，并通过模型进行响应；另一方面，视图接收模型并使用它们在HTML页面上向用户展示。这种SOC有助于轻松地进行单元测试，以及根据需要维护和扩展应用程序。MVC模式不仅适用于Web应用程序，还可以用于任何需要SOC的应用程序。
- en: As the focus of this chapter is to build RESTful services, we will focus on
    an ASP.NET Core web API in this chapter and discuss ASP.NET MVC and Razor Pages
    in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的重点是构建RESTful服务，因此在本章中我们将关注ASP.NET Core Web API，并在[*第11章*](B18507_11_Epub.xhtml#_idTextAnchor1228)
    *创建ASP.NET Core 6 Web应用程序*中讨论ASP.NET MVC和Razor Pages。
- en: 'To develop RESTful services, many frameworks are available, but here are a
    few advantages of going with ASP.NET Core on .NET 6:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发RESTful服务，有许多框架可供选择，但选择在.NET 6上使用ASP.NET Core有以下一些优势：
- en: '**Cross-platform support**: Unlike ASP.NET, which used to be part of the .NET
    Framework (which is coupled with the Windows operating system), ASP.NET Core is
    now part of the application, thereby eliminating platform dependency and making
    it compatible with all platforms.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨平台支持**：与ASP.NET不同，它曾经是.NET Framework的一部分（与Windows操作系统耦合），ASP.NET Core现在是应用程序的一部分，从而消除了平台依赖性，使其与所有平台兼容。'
- en: '**Highly customizable request pipelines**: Use middlewares and support to inject
    various out-of-the-box modules, such as logging and configuration.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度可定制的请求管道**: 使用中间件和支持注入各种开箱即用的模块，例如日志和配置。'
- en: '`IIS` and `HTTP.sys`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIS`和`HTTP.sys`。'
- en: Note
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: By default, Kestrel is the HTTP server used in ASP.NET Core templates; however,
    that can be overridden as required.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，Kestrel是ASP.NET Core模板中使用的HTTP服务器；然而，这可以根据需要覆盖。
- en: '**Strong tooling support**: This comes in the form of **Visual Studio Code**
    (**VS Code**), Visual Studio, and the DOTNET CLI, along with project templates,
    which means developers can start working on implementing the business logic with
    very little setup.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强大的工具支持**: 这包括**Visual Studio Code**（**VS Code**）、Visual Studio和DOTNET CLI，以及项目模板，这意味着开发者可以以非常少的设置开始实现业务逻辑。'
- en: '**Open sourced**: Finally, the entire framework is open sourced and is available
    at [https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore).'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**: 最后，整个框架已经开源，可在[https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore)找到。'
- en: 'So, we now know why we picked ASP.NET Core as our framework to develop RESTful
    services. Let''s now look into some key components that assist in the execution
    of the request and create a sample web API by using the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道为什么我们选择ASP.NET Core作为开发RESTful服务的框架。现在让我们看看一些关键组件，这些组件有助于请求的执行，并使用以下命令创建一个示例Web
    API：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the preceding command is successfully executed, let''s navigate to the
    `TestApi` folder and open it in VS Code to see the various files that are generated,
    as shown in the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功执行上述命令后，让我们导航到`TestApi`文件夹，并在VS Code中打开它，查看生成的各种文件，如下面的截图所示：
- en: '![Figure 10.2 – Test web API project in VS Code'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.2 – 在VS Code中测试Web API项目'
- en: '](img/Figure_10.2_B18507.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.2_B18507.jpg]'
- en: Figure 10.2 – Test web API project in VS Code
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.2 – 在VS Code中测试Web API项目
- en: Here, you can see a `Program` class used to bootstrap the application, and settings
    files, such as `appsettings.json`, that are used to run a web API project, and
    there is also `WeatherForecast`, which is a model class used in the controller
    class. Let's examine each of the components of `TESTAPI` in the following sections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到用于启动应用的`Program`类，以及用于运行Web API项目的设置文件，如`appsettings.json`，还有`WeatherForecast`，这是一个在控制器类中使用的模型类。接下来几节将逐一检查`TESTAPI`的各个组件。
- en: The Program class
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Program`类'
- en: 'The `Program` class is used to bootstrap web API projects in ASP.NET Core 6\.
    Let''s look at the activities performed by this class in the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类用于在ASP.NET Core 6中启动Web API项目。接下来几步将查看这个类执行的活动：'
- en: The `Program` class is the entry point for our web API, and it tells ASP.NET
    Core to begin execution whenever someone executes the web API project. Primarily,
    this is the class that is used to bootstrap the application. Unlike earlier versions
    of ASP.NET Core applications, by default we don't have a `Startup` class—that
    is, the `Program` class has everything that we need—and to keep the code minimal,
    we further rely on C# 10's top-level statements and global using statements.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Program`类是我们Web API的入口点，它告诉ASP.NET Core每当有人执行Web API项目时开始执行。主要来说，这是一个用于启动应用的类。与ASP.NET
    Core的早期版本应用不同，默认情况下我们没有`Startup`类——也就是说，`Program`类包含了我们所需的一切——为了保持代码最小化，我们进一步依赖于C#
    10的顶级语句和全局using语句。'
- en: Since this is the entry point, we need to ensure all components such as the
    web server, routing, and configuration, get initialized and loaded, and that is
    what the `CreateBuilder` method of the `WebApplication` class helps with. It primarily
    creates an object of `WebApplicationBuilder`, which can be used to configure the
    HTTP request pipeline.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是入口点，我们需要确保所有组件，如Web服务器、路由和配置，都得到初始化和加载，这正是`WebApplication`类的`CreateBuilder`方法所帮助实现的。它主要创建一个`WebApplicationBuilder`对象，该对象可用于配置HTTP请求管道。
- en: '`WebApplicationBuilder` is inherited from the `IApplicationBuilder` interface,
    which is nothing but the `Host` is nothing more than an object that encapsulates
    these components, such as the HTTP server defaulted to Kestrel, all the middleware
    components, and any additional services—such as logging—that are injected. Finally,
    the `Build()` method is called to run actions and initialize the `Host` object.
    The `Run()` method is called to keep the `Host` object running.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WebApplicationBuilder` 继承自 `IApplicationBuilder` 接口，这实际上只是一个封装了这些组件的对象，例如默认的
    Kestrel HTTP 服务器，所有中间件组件，以及任何额外的服务——例如日志记录——这些服务被注入。最后，调用 `Build()` 方法来运行操作并初始化
    `Host` 对象。调用 `Run()` 方法来保持 `Host` 对象的运行。'
- en: 'Now that we have the `Host` object loaded with all the default components and
    it is up and running, let''s examine whether we can inject additional ASP.NET
    Core classes/application-specific classes (repositories, services, options) and
    middlewares. Consider the following points:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经加载了包含所有默认组件的 `Host` 对象，并且它正在运行，让我们检查我们是否可以注入额外的 ASP.NET Core 类/应用程序特定的类（存储库、服务、选项）和中间件。考虑以下要点：
- en: 'This `WebApplicationBuilder` object is used to inject any ASP.NET Core-provided
    services so that applications can use those services. A few common services that
    enterprise applications can inject are shown in the following code snippet:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此 `WebApplicationBuilder` 对象用于注入任何 ASP.NET Core 提供的服务，以便应用程序可以使用这些服务。以下代码片段展示了企业应用程序可以注入的一些常见服务：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apart from services provided by ASP.NET Core, we can also inject any custom
    services specific to our application—for example, `ProductService` can be mapped
    to `IProductService` and can be made available for the entire application. Primarily,
    this is the place we can use to plumb anything into the DI container, as explained
    in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445), *Dependency Injection
    in .NET 6*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 ASP.NET Core 提供的服务之外，我们还可以注入任何特定于我们应用程序的自定义服务——例如，`ProductService` 可以映射到
    `IProductService` 并在整个应用程序中可用。主要来说，这是我们可以使用来将任何内容集成到依赖注入容器中的地方，如 [*第 5 章*](B18507_05_Epub.xhtml#_idTextAnchor445)
    中所述，*.NET 6 中的依赖注入*。
- en: Additionally, all services, including ASP.NET Core services and custom services,
    can be plumbed into the application and are available as extension methods of
    `IServiceCollection`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有服务，包括 ASP.NET Core 服务和自定义服务，都可以集成到应用程序中，并作为 `IServiceCollection` 的扩展方法可用。
- en: Next, we have an object of the `WebApplication` class that can be used to integrate
    all the middlewares required to be applied to the request pipeline. This object
    primarily controls how applications respond to HTTP requests—that is, how applications
    should respond to exceptions, how they should respond to static files, or how
    URI routing should happen. All can be configured using this object.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 `WebApplication` 类的对象，可以用来集成所有需要应用到请求管道的中间件。此对象主要控制应用程序如何响应 HTTP 请求——即应用程序应该如何响应异常，如何响应静态文件，或者如何进行
    URI 路由。所有这些都可以使用此对象进行配置。
- en: 'Additionally, any specific handling on a request pipeline—such as calling a
    custom middleware or adding specific response headers, or even defining a specific
    endpoint—can be injected using the `WebApplication` object. So, apart from what
    we saw earlier, the following code snippet shows a few common additional configurations
    that can be integrated using the `WebApplication` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何对请求管道的特定处理——例如调用自定义中间件或添加特定的响应头，甚至定义特定的端点——都可以使用 `WebApplication` 对象注入。所以，除了我们之前看到的之外，以下代码片段展示了使用
    `WebApplication` 对象可以集成的几个常见额外配置：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `app.UseEndpoints` is configuring a response for a URI that matches `/subscribe`.
    `app.UseEndPoints` works alongside routing rules and is explained in the *Handling
    requests using controllers and actions* section, while `app.Use`, on the other
    hand, is used to add an inline middleware. In this case, we are removing `X-Powered-By`
    and `Server` response headers from the response.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`app.UseEndpoints` 正在配置一个匹配 `/subscribe` URI 的响应。`app.UseEndPoints` 与路由规则协同工作，并在
    *使用控制器和操作处理请求* 部分中解释，而 `app.Use` 则用于添加内联中间件。在这种情况下，我们正在从响应中移除 `X-Powered-By` 和
    `Server` 响应头。
- en: Since ASP.NET Core 6 supports something called `Program` class alone can be
    used to build a fully working API; however, for enterprise applications, it is
    good to segregate APIs for easier maintenance and better readability, hence in
    our enterprise applications, we will be using APIs with the controller, which
    is supported by `MapControllers` middleware and is configured by calling `app.`
    `MapControllers()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASP.NET Core 6 支持使用 `Program` 类，因此可以单独使用它来构建一个完全工作的 API；然而，对于企业应用程序来说，为了便于维护和更好的可读性，最好将
    API 与控制器分离，因此在我们的企业应用程序中，我们将使用由 `MapControllers` 中间件支持的 API，并通过调用 `app.MapControllers()`
    来配置。
- en: To sum up, the `Program` class plays a vital role in bootstrapping the application
    and then customizing application services and HTTP request/response pipelines
    as needed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Program` 类在启动应用程序和根据需要自定义应用程序服务和 HTTP 请求/响应管道方面发挥着至关重要的作用。
- en: Let's now see how middlewares help in customizing the HTTP request/response
    pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看中间件如何帮助定制 HTTP 请求/响应管道。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: ASP.NET Core 6 still supports using the `Startup` class, and the `Configure`
    and `ConfigureServices` methods can be used as-is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 6 仍然支持使用 `Startup` 类，并且可以直接使用 `Configure` 和 `ConfigureServices`
    方法。
- en: Understanding middleware
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解中间件
- en: 'We have been referring to middleware for a while now, so let''s understand
    what middlewares are and how we can we build one and use it in our enterprise
    application. Middlewares are classes that intercept incoming requests, perform
    some processing on the requests, and then hand them over to the next middleware
    or skip them as required. Middlewares are bidirectional, hence all middlewares
    intercept both requests and responses. Let''s assume that an API retrieves product
    information and, in the process, it goes through various middlewares. Representing
    them in pictorial form would look something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了中间件一段时间了，现在让我们了解中间件是什么，以及我们如何构建一个中间件并在我们的企业应用程序中使用它。中间件是拦截传入请求、对请求执行一些处理并将它们传递给下一个中间件或按需跳过的类。中间件是双向的，因此所有中间件都会拦截请求和响应。假设一个
    API 获取产品信息，在这个过程中，它会通过各种中间件。以图形形式表示，看起来可能像这样：
- en: '![Figure 10.3 – Middleware processing'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.3 – Middleware processing](img/Figure_10.3_Middleware_processing.jpg)'
- en: '](img/Figure_10.3_B18507.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.3_B18507.jpg](img/Figure_10.3_B18507.jpg)'
- en: Figure 10.3 – Middleware processing
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 中间件处理
- en: Each middleware has an instance of `Microsoft.AspNetCore.Http.RequestDelegate`.
    As a result of using this, the middleware invokes the next middleware. So, flows
    would typically process the request as per some processing logic that you want
    the middleware to perform on the request and then invoke `RequestDelegate` to
    hand the request over to the next middleware in the pipeline.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件都有一个 `Microsoft.AspNetCore.Http.RequestDelegate` 的实例。因此，使用这个实例，中间件会调用下一个中间件。所以，流通常会按照你希望中间件在请求上执行的处理逻辑来处理请求，然后调用
    `RequestDelegate` 将请求传递给管道中的下一个中间件。
- en: 'If we take an analogy from manufacturing, it would be like an assembly line
    in a manufacturing process, where parts are added/modified from workstation to
    workstation until a final product is produced. In the previous diagram, let''s
    consider each middleware as a workstation, so it will be going through the following
    steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从制造业中找一个类比，那就像制造过程中的装配线，部件从工作站到工作站添加/修改，直到最终产品生产出来。在前面的图中，让我们将每个中间件视为一个工作站，因此它将经历以下步骤：
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following explanation of each middleware is just a hypothetical explanation
    for our understanding; the internal workings of these middlewares differ slightly
    from what is explained here. More details can be found here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面每个中间件的解释只是为了我们理解而做的假设性解释；这些中间件的内部工作原理与这里所解释的略有不同。更多详情可以在这里找到：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0)。
- en: '`UseHttpsRedirection`: An HTTP request arrives for `GET/Products` and is inspected
    for the protocol. If the request is via HTTP, a redirect is sent back through
    the HTTP status code; if the request is on HTTPS, it''s handed over to the next
    middleware.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UseHttpsRedirection`：一个 HTTP 请求到达 `GET/Products`，并检查协议。如果请求是通过 HTTP，则通过 HTTP
    状态码发送重定向；如果请求是通过 HTTPS，则将其传递给下一个中间件。'
- en: '`UseStaticFiles`: If the request is for a static file (usually detected based
    on the extension—the **Multipurpose Media Extensions** (**MIME**) type), this
    middleware processes the request and sends the response back, or else hands the
    request on to the next middleware. Here, as you can see, if the request is for
    a static file, the rest of the pipeline is not even executed as this middleware
    can process the complete request, thereby reducing the load on the server for
    any unwanted processing and also reducing the response time. This process is also
    known as **short-circuiting**, which every middleware can support.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UseStaticFiles`: 如果请求是针对静态文件（通常基于扩展名检测——**多用途媒体类型**（MIME）类型），这个中间件会处理请求并发送响应，或者将请求传递给下一个中间件。正如你所看到的，如果请求是针对静态文件，那么整个管道的其他部分甚至都不会被执行，因为这个中间件可以处理完整的请求，从而减少服务器上任何不需要的处理负载，并减少响应时间。这个过程也被称为**短路**，这是每个中间件都可以支持的。'
- en: '`UseRouting`: The request is inspected further, and the controller/action that
    can process the request is identified. If there isn''t any match, this middleware
    usually responds with a `404` HTTP status code.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UseRouting`: 请求将进一步检查，并识别可以处理该请求的控制器/操作。如果没有匹配项，这个中间件通常会以`404` HTTP状态码响应。'
- en: '`UseAuthorization`: Here, if the controller/action needs to be available for
    authenticated users, then this middleware will look for any valid token in the
    header and respond accordingly.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UseAuthorization`: 在这里，如果控制器/操作需要可供认证用户使用，那么这个中间件将查找头中的任何有效令牌并相应地响应。'
- en: Once the controller gets the data from services/repositories, the response goes
    through the same middlewares in reverse order—that is, `UseAuthorization` first,
    followed by `UseHttpsRedirection`—and the response is processed as needed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制器从服务/存储库中获取数据，响应将通过相同的中间件以相反的顺序处理——即首先`UseAuthorization`，然后是`UseHttpsRedirection`——并根据需要处理响应。
- en: As mentioned earlier, all middlewares are installed using the `Program` class
    and are configured using the object of the `WebApplication` class. The order of
    middleware execution would precisely follow the way it is configured in the `Program`
    class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有中间件都是通过`Program`类安装的，并使用`WebApplication`类的对象进行配置。中间件执行的顺序将精确地遵循在`Program`类中配置的方式。
- en: Armed with this understanding, let's create a middleware that will be used to
    handle exceptions across the RESTful services of our e-commerce application, so
    instead of adding `try…catch` blocks in the code, we will create a middleware
    that gets installed at the beginning of the request pipeline and then catches
    any exceptions throughout.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种理解，让我们创建一个中间件，它将用于处理我们电子商务应用程序的RESTful服务的异常，这样我们就不需要在代码中添加`try…catch`块，而是在请求管道的开始处安装一个中间件，然后捕获任何异常。
- en: Building a custom middleware
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建自定义中间件
- en: As the middleware is going to be reused across all RESTful services, we will
    add the middleware to the `Packt.Ecommerce.Common` project inside the `Middlewares`
    folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中间件将在所有RESTful服务中重用，我们将中间件添加到`Middlewares`文件夹中的`Packt.Ecommerce.Common`项目。
- en: 'Let''s first create a POCO class that represents the response in case of errors.
    This model will typically hold an error message, a `ExceptionResponse` inside
    the `Models` folder of the `Packt.Ecommerce.Common` project and add the following
    code to it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个Poco类，它代表错误情况下的响应。这个模型通常将包含一个错误消息，一个位于`Packt.Ecommerce.Common`项目的`Models`文件夹中的`ExceptionResponse`，并向其中添加以下代码：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, create another POCO class that can hold the configuration to toggle the
    behavior of sending an inner exception in our response. This class will be populated
    using the `Options` pattern, which was discussed in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473),
    *Configuration in .NET 6*. Since it needs to hold only one setting, it will have
    one property. Add a class file named `ApplicationSettings` in the `Options` folder
    and then add the following code to it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建另一个Poco类，它可以保存发送内部异常行为的配置。这个类将使用`Options`模式进行填充，该模式在[*第6章*](B18507_06_Epub.xhtml#_idTextAnchor473)中讨论过，*在.NET
    6中的配置*。因为它只需要保存一个设置，所以它将有一个属性。在`Options`文件夹中添加一个名为`ApplicationSettings`的类文件，然后向其中添加以下代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class will be extended further for any configuration that will be common
    across all our APIs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将进一步扩展，以包含所有API中通用的任何配置。
- en: 'Navigate to the `Middlewares` folder and create a class named `ErrorHandlingMiddleware`.
    As we discussed, one of the key properties in any middleware is a property of
    the `RequestDelegate` type. Additionally, we will add a property for `ILogger`
    to log the exception to our logging provider, and finally, we will add a property
    of the `bool` `includeExceptionDetailsInResponse` type to hold a flag that controls
    masking the inner exception. With this, here''s what the `ErrorHandlingMiddleware`
    class will look like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Middlewares`文件夹，创建一个名为`ErrorHandlingMiddleware`的类。正如我们讨论的那样，任何中间件中的关键属性之一是`RequestDelegate`类型的属性。此外，我们将添加一个`ILogger`属性以将异常记录到我们的日志提供程序，最后，我们将添加一个`bool`类型的`includeExceptionDetailsInResponse`属性来保存一个控制是否屏蔽内部异常的标志。有了这个，`ErrorHandlingMiddleware`类将看起来如下：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a parameterized constructor where we inject `RequestDelegate` and `ILogger`
    for our logging provider and `IOptions<ApplicationSettings>` for configuration
    and assign them to the properties created earlier. Here, again, we are relying
    on the constructor injection of ASP.NET Core to instantiate the respective objects.
    With this, here''s what the constructor of `ErrorHandlingMiddleWare` will look
    like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个参数化构造函数，其中我们注入`RequestDelegate`和`ILogger`以用于我们的日志提供程序，以及`IOptions<ApplicationSettings>`以用于配置，并将它们分配给之前创建的属性。在这里，我们再次依赖于ASP.NET
    Core的构造函数注入来实例化相应的对象。有了这个，`ErrorHandlingMiddleWare`的构造函数将看起来如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, add an `InvokeAsync` method that will have the logic to process the
    request and then call the next middleware using `RequestDelegate`. Since this
    is an exception-handling middleware as part of our logic, all we are going to
    do is wrap the request in a `try…catch` block. In the `catch` block, we will log
    it to the respective logging provider using `ILogger`, and finally send an object,
    `ExceptionResponse`, back as the response. With this, here''s what `InvokeAsync`
    will look like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个`InvokeAsync`方法，该方法将包含处理请求的逻辑，然后使用`RequestDelegate`调用下一个中间件。由于这是一个作为我们逻辑一部分的异常处理中间件，我们所有要做的就是将请求包裹在一个`try…catch`块中。在`catch`块中，我们将使用`ILogger`将其记录到相应的日志提供程序，并最终发送一个对象`ExceptionResponse`作为响应。有了这个，`InvokeAsync`将看起来如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we can inject this middleware into the `Program` class with the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码将此中间件注入到`Program`类中：
- en: '[PRE65]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Since this is an exception handler, it is recommended to configure it as early
    as possible in the `Program` class so that any exceptions in all subsequent middlewares
    are caught. Additionally, we need to ensure that we map the `ApplicationSettings`
    class to a configuration, so add the following code to the `Program` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个异常处理器，建议在`Program`类中尽早配置它，以便捕获所有后续中间件中的任何异常。此外，我们需要确保将`ApplicationSettings`类映射到配置，因此将以下代码添加到`Program`类中：
- en: '[PRE66]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Add the relevant section to `appsettings.json`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关部分添加到`appsettings.json`中，如下所示：
- en: '[PRE67]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, if there is an error in any of our APIs, the response will look like the
    one shown in the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们的任何API中发生错误，响应将类似于以下代码片段所示：
- en: '[PRE70]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'From the preceding code snippet, we can take `CorrelationIdentifier`, which
    is `03410a51b0475843936943d3ae04240c`, search the value in our logging provider,
    **Application Insights**, and we can ascertain additional information regarding
    the exception, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以获取`CorrelationIdentifier`，即`03410a51b0475843936943d3ae04240c`，在我们的日志提供程序**Application
    Insights**中搜索该值，我们可以确定有关异常的更多信息，如图下所示：
- en: '![Figure 10.4 – Tracing CorrelationIdentifier in Application Insights'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.4 – Tracing CorrelationIdentifier in Application Insights](img/Figure_10.4_B18507.jpg)'
- en: '](img/Figure_10.4_B18507.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.4 – Tracing CorrelationIdentifier in Application Insights](img/Figure_10.4_B18507.jpg)'
- en: Figure 10.4 – Tracing CorrelationIdentifier in Application Insights
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 在Application Insights中跟踪CorrelationIdentifier
- en: '`CorrelationIdentifier` is extremely helpful in production environments where
    there is no inner exception.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`CorrelationIdentifier`在生产环境中非常有用，尤其是在没有内部异常的情况下。'
- en: This concludes our discussion regarding middleware. In the next section, let's
    look at what **controllers** and **actions** are and how they help in handling
    requests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对中间件的讨论。在下一节中，我们将探讨**控制器**和**操作**是什么，以及它们如何帮助处理请求。
- en: Handling requests using controllers and actions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用控制器和操作处理请求
- en: '**Controllers** are the fundamental blocks for handling requests for designing
    RESTful servicers using an ASP.NET Core web API. These are the primary classes
    that hold the logic to process requests, which includes retrieving data from a
    database, inserting a record into a database, and so on. Controllers are classes
    where we define methods to process requests. These methods usually include validating
    the input, talking to a data store, applying business logic (in enterprise applications,
    controllers will also call service classes), and—finally—serializing the response
    and sending it back to the client using HTTP protocols in JSON/XML form.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是处理请求的基本块，用于使用 ASP.NET Core Web API 设计 RESTful 服务。这些是包含处理请求逻辑的主要类，包括从数据库检索数据、将记录插入数据库等。控制器是我们定义处理请求方法的类。这些方法通常包括验证输入、与数据存储通信、应用业务逻辑（在企业应用程序中，控制器还将调用服务类），最后使用
    HTTP 协议以 JSON/XML 格式序列化响应并发送回客户端。'
- en: All these methods that hold the logic to process requests are known as **actions**.
    All requests received by the HTTP server are handed over to action methods using
    a routing engine. However, a routing engine transfers requests to actions based
    on certain rules that can be defined in a request pipeline. These rules are what
    we define in routing. Let's see how a URI for handling requests is mapped to a
    particular action in a controller.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些包含处理请求逻辑的方法都称为**操作**。HTTP 服务器接收到的所有请求都通过路由引擎交给操作方法。然而，路由引擎根据可以在请求管道中定义的某些规则将请求转移到操作。这些规则就是我们定义的路由。让我们看看如何将处理请求的
    URI 映射到控制器中的特定操作。
- en: Understanding ASP.NET Core routing
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core 路由
- en: 'Up to now, we have seen that any HTTP request goes through the middleware and
    is finally handed over to the controller or an endpoint defined in the `configure`
    method, but who is responsible for this handover to a controller/endpoint, and
    how does ASP.NET Core know which controller and method inside the controller to
    trigger? That is what the routing engine is for, and this was injected when adding
    the following middlewares:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到任何 HTTP 请求都会通过中间件，最终交给控制器或 `configure` 方法中定义的端点，但谁负责将请求交给控制器/端点，ASP.NET
    Core 如何知道触发哪个控制器和控制器内的哪个方法？这正是路由引擎的作用，这也是在添加以下中间件时注入的：
- en: '[PRE75]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, `app.UseRouting()` injects `Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware`,
    which is used to make all routing decisions based on the URI. The primary job
    of this middleware is to set the instance of the `Microsoft.AspNetCore.Http.Endpoint`
    method with the value of the action that needs to be executed for a particular
    URI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`app.UseRouting()` 注入 `Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware`，它用于根据
    URI 进行所有路由决策。这个中间件的主要任务是设置 `Microsoft.AspNetCore.Http.Endpoint` 方法的实例，该实例包含特定
    URI 需要执行的操作的值。
- en: 'For example, if we are trying to get the details of a product according to
    its ID and have a product controller that has the `GetProductById` method to fulfill
    this request, when we make an API call to the `api/products/1` URI, putting a
    breakpoint in a middleware after `EndpointRoutingMiddleware` shows you that an
    instance of the `Endpoint` class is available with information regarding the action
    that matches the URI and should be executed. We can see this in the following
    screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们试图根据产品 ID 获取产品详情，并且有一个具有 `GetProductById` 方法的控制器来满足这个请求，当我们对 `api/products/1`
    URI 进行 API 调用时，在 `EndpointRoutingMiddleware` 后的中间件中设置断点会显示有一个 `Endpoint` 类的实例可用，其中包含与
    URI 匹配的操作信息以及应该执行的操作。我们可以在以下屏幕截图中看到这一点：
- en: '![Figure 10.5 – Routing middlewares'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 路由中间件'
- en: '](img/Figure_10.5_B18507.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B18507.jpg)'
- en: Figure 10.5 – Routing middlewares
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 路由中间件
- en: This object would be null if there wasn't any matching controller/action. Internally,
    `EndpointRoutingMiddleware` uses the URI, query string parameters, and HTTP verbs
    and request headers to find the correct match.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有匹配的控制器/操作，这个对象将是 null。内部，`EndpointRoutingMiddleware` 使用 URI、查询字符串参数、HTTP
    动词和请求头来找到正确的匹配项。
- en: 'Once the correct action method is identified, it''s the job of `app.UseEndPoints`
    to hand over control to the action method identified by the `Endpoint` object
    and execute it. `UseEndPoints` injects `Microsoft.AspNetCore.Routing.EndpointMiddleware`
    to execute the appropriate method to fulfill a request. One important aspect of
    populating an appropriate `EndPoint` object is the various URIs that are configured
    inside `UseEndPoints` that can be achieved through the static extension methods
    available in ASP.NET Core. For example, if we want to configure just controllers,
    we can use `MapControllers` extension methods, which add endpoints for all actions
    in controllers for `UseRouting` to match further. If we are building RESTful APIs,
    it is recommended to use `MapControllers` extensions. However, there are many
    such extension methods for the following extensions that are commonly used:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了正确的操作方法，`app.UseEndPoints`的任务就是将控制权交给由`Endpoint`对象指定的操作方法并执行它。`UseEndPoints`注入`Microsoft.AspNetCore.Routing.EndpointMiddleware`以执行满足请求的适当方法。填充适当的`EndPoint`对象的一个重要方面是`UseEndPoints`内部配置的各种URI，这些可以通过ASP.NET
    Core中可用的静态扩展方法实现。例如，如果我们只想配置控制器，我们可以使用`MapControllers`扩展方法，这些方法为`UseRouting`匹配的所有操作添加端点。如果我们正在构建RESTful
    API，建议使用`MapControllers`扩展方法。然而，对于以下扩展，有许多这样的扩展方法被广泛使用：
- en: '`MapGet`/`MapPost`: These are extension methods that can match specific patterns
    for `GET`/`POST` verbs and execute the request. They accept two parameters, one
    being the pattern of the URI and the second being the request delegate that can
    be used to execute when the pattern is matched. For example, the following code
    can be used to match the `/aboutus` route and respond with the text `Welcome to
    default products route`:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapGet`/`MapPost`：这些是扩展方法，可以匹配特定的`GET`/`POST`动词模式并执行请求。它们接受两个参数，一个是URI的模式，另一个是当模式匹配时可以用来执行的请求委托。例如，以下代码可以用来匹配`/aboutus`路由并返回文本`欢迎使用默认产品路由`：'
- en: '[PRE80]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '`MapRazorPages`: This extension method is used if we are using Razor Pages
    and need to route to appropriate pages based on routes.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapRazorPages`：这个扩展方法在如果我们使用Razor Pages并且需要根据路由路由到适当的页面时使用。'
- en: '`MapControllerRoute`: This extension method can be used to match controllers
    with a specific pattern; for example, the following code can be seen in the ASP.NET
    Core MVC template, which matches methods based on a pattern:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MapControllerRoute`：这个扩展方法可以用来匹配具有特定模式的控制器；例如，以下代码可以在ASP.NET Core MVC模板中看到，它根据模式匹配方法：'
- en: '[PRE81]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The request URI is split based on the forward slash (`/`) and is matched to
    the controller, action method, and ID. So, if you wanted to match a method in
    a controller, you need to pass the controller name (ASP.NET Core automatically
    suffixes the `controller` keyword) and method name in the URI.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请求URI基于正斜杠(`/`)进行分割，并与控制器、操作方法和ID进行匹配。因此，如果您想匹配控制器中的方法，您需要在URI中传递控制器名称（ASP.NET
    Core会自动添加`controller`关键字后缀）和方法名称。
- en: Optionally, the ID can be passed as a parameter to that method. For example,
    if I have `GetProducts` in `ProductsController`, you would be calling it using
    the absolute URI, `products/GetProducts`. This kind of routing is known as **conventional
    routing** and is a good fit for UI-based web applications, and so can be seen
    in the ASP.NET Core MVC template.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以将ID作为参数传递给该方法。例如，如果我在`ProductsController`中有`GetProducts`，您将使用绝对URI `products/GetProducts`
    来调用它。这种路由方式被称为**传统路由**，非常适合基于UI的Web应用程序，因此在ASP.NET Core MVC模板中可以看到。
- en: This concludes our discussion of the basics of routing; there are many such
    extension methods available in ASP.NET Core that can be plumbed into the request
    pipeline based on application requirements. Now, let's look at attribute-based
    routing, a routing technique recommended for RESTful services built using ASP.NET
    Core.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对路由基础知识的讨论；根据应用需求，ASP.NET Core中有许多这样的扩展方法可以集成到请求管道中。现在，让我们看看基于属性的路由，这是一种推荐用于使用ASP.NET
    Core构建的RESTful服务的路由技术。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another important aspect of routing, as with any other middleware sequence,
    is that injection is very important, and `UseRouting` should be called before
    `UseEndpoints`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的另一个重要方面，就像任何其他中间件序列一样，是注入非常重要，并且应该在`UseEndpoints`之前调用`UseRouting`。
- en: Attribute-based routing
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于属性的路由
- en: For RESTful services, conventional routing contravenes a few REST principles,
    especially the principle that states that the operation on entities performed
    by the action method should be based on HTTP verbs; so, ideally, in order to get
    products, the URI should be `GET api/products`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful服务，传统的路由违反了一些REST原则，特别是指出操作方法对实体执行的操作应基于HTTP动词的原则；因此，理想情况下，为了获取产品，URI应该是`GET
    api/products`。
- en: 'This is where attribute-based routing comes into play, in which routes are
    defined using attributes either at the controller level or at the action method
    level, or both. This is achieved using the `Microsoft.AspNetCore.Mvc.Route` attribute,
    which takes a string value as an input parameter and is used to map the controller
    and action. Let''s take an example of `ProductsController`, which has the following
    code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于属性的路由发挥作用的地方，其中路由是通过在控制器级别或操作方法级别使用属性来定义的，或者两者都使用。这是通过使用`Microsoft.AspNetCore.Mvc.Route`属性实现的，它接受一个字符串值作为输入参数，并用于映射控制器和操作。让我们以`ProductsController`为例，它具有以下代码：
- en: '[PRE82]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, in the `Route` attribute at the controller level, we are passing the value
    `api/[controller]`, which means that any URI matching `api/products` is mapped
    to this controller, where `products` is the name of the controller. Using the
    `controller` keyword inside square brackets is a specific way of telling ASP.NET
    Core to map the controller name automatically to the route.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在控制器级别的`Route`属性中，我们传递的值是`api/[controller]`，这意味着任何匹配`api/products`的URI都将映射到这个控制器，其中`products`是控制器的名称。在方括号中使用`controller`关键字是一种特定的方式，告诉ASP.NET
    Core自动将控制器名称映射到路由。
- en: However, if you want to stick to a specific name irrespective of the controller
    name, this can be used without square brackets. As a best practice, it is recommended
    to decouple controller names with routes. Hence, for our e-commerce application,
    we will go with exact values in routes—that is, `ProductsController` will have
    a route prefix of `[Route("api/products")]`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想坚持特定的名称，而不管控制器名称如何，则可以使用不带方括号的名称。作为最佳实践，建议将控制器名称与路由解耦。因此，对于我们的电子商务应用程序，我们将在路由中使用精确值——也就是说，`ProductsController`将具有`[Route("api/products")]`的路由前缀。
- en: The `Route` attribute can also be added to action methods and can be used to
    additionally identify specific methods uniquely. Here, we are also passing a string
    that can be used to identify the method. For example, `[Route("GetProductById/{id}")]`
    would be matched to the `api/products/GetProductById/1` URI, and the value inside
    the curly brackets is a dynamic value that can be passed as a parameter to the
    action method and matched with the parameter name.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Route`属性也可以添加到操作方法中，并可以用来唯一地识别特定的方法。在这里，我们也在传递一个可以用来识别方法的字符串。例如，`[Route("GetProductById/{id}")]`将与`api/products/GetProductById/1`
    URI相匹配，并且花括号内的值是一个动态值，可以作为参数传递给操作方法并与参数名称匹配。'
- en: 'What this means is that in the preceding code, there is an ID parameter, and
    the value inside the curly brackets should also be named `ID` so that ASP.NET
    Core can map values from the URI to the `method` parameter. Hence, for the `api/products/1`
    URI, the ID parameter in the `GetProductById` method will have a value of `1`
    if the route attribute looks like this: `[Route("{id}")]`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在先前的代码中，有一个ID参数，并且花括号内的值也应该命名为`ID`，这样ASP.NET Core才能将URI中的值映射到`method`参数。因此，对于`api/products/1`
    URI，如果路由属性看起来像这样：`[Route("{id}")]`，则`GetProductById`方法中的ID参数将具有值为`1`。
- en: 'Finally, the HTTP verb is represented by attributes such as `[HttpGet]`, which
    will be used to map the HTTP verb from the URI to the method. The following table
    shows various examples and possible matches, assuming that `ProductsController`
    has `[Route("api/products")]`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，HTTP动词由如`[HttpGet]`之类的属性表示，它将被用来将URI中的HTTP动词映射到方法。以下表格显示了各种示例和可能的匹配，假设`ProductsController`具有`[Route("api/products")]`：
- en: '![Table 10.1'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![表10.1'
- en: '](img/Table_10.1.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_10.1.jpg)'
- en: Table 10.1
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1
- en: As you can see, the name of the method is immaterial here and so is not part
    of the URI matching unless it is specified in the `Route` attribute.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，方法名称在这里是不重要的，因此除非在`Route`属性中指定，否则它不是URI匹配的一部分。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'One important aspect is that the web API supports the reading of parameters
    from various locations within a request, be it in the request body, header, query
    string, or URI. The following documentation covers the various options available:
    [https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference](https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference).'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的方面是，Web API 支持从请求中的各个位置读取参数，无论是请求体、头部、查询字符串还是 URI。以下文档涵盖了可用的各种选项：[https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference](https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference).
- en: 'A summary of an entire API routing in ASP.NET Core could be represented as
    follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 中整个 API 路由的总结可以表示如下：
- en: '![Figure 10.6 – ASP.NET Core API routing'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – ASP.NET Core API 路由'
- en: '](img/Figure_10.6_B18507.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B18507.jpg)'
- en: Figure 10.6 – ASP.NET Core API routing
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – ASP.NET Core API 路由
- en: Attribute-based routing is more RESTful, and we will follow this kind of routing
    in our e-commerce services. Now, let's look at the various helper classes available
    in ASP.NET Core that can be used to simplify the building of RESTful services.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的路由更符合 RESTful 风格，我们将在我们的电子商务服务中采用这种路由方式。现在，让我们看看 ASP.NET Core 中可用的各种辅助类，这些类可以帮助简化
    RESTful 服务的构建。
- en: Tip
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `{id}` expression in routing is known as a **routing constraint**, and
    ASP.NET Core comes with a varied set of such routing constraints that can also
    be found here: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 路由中的 `{id}` 表达式被称为 **路由约束**，ASP.NET Core 提供了一系列这样的路由约束，也可以在这里找到：[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference).
- en: The ControllerBase class, the ApiController attribute, and the ActionResult
    class
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ControllerBase 类、ApiController 属性和 ActionResult 类
- en: 'If we go back to any of the controllers created hitherto, you can see that
    all the controllers are inherited from the `ControllerBase` class. In ASP.NET
    Core, `ControllerBase` is an abstract class that provides various helper methods
    that assist in handling requests and responses. For example, if I wanted to send
    an HTTP status code `400` (bad request), there is a `BadRequest` helper method
    in `ControllerBase` that can be used to send an HTTP status code of `400`; otherwise,
    we have to manually create an object and populate it with the HTTP status code
    `400`. There are many such helper methods in `ControllerBase` that are available
    out of the box; however, not every API controller needs to be inherited from the
    `ControllerBase` class. All helper methods from the `ControllerBase` class are
    mentioned here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾之前创建的任何控制器，你可以看到所有控制器都是继承自 `ControllerBase` 类。在 ASP.NET Core 中，`ControllerBase`
    是一个抽象类，它提供了各种辅助方法，有助于处理请求和响应。例如，如果我想发送 HTTP 状态码 `400`（错误请求），`ControllerBase` 中有一个
    `BadRequest` 辅助方法可以用来发送 HTTP 状态码 `400`；否则，我们必须手动创建一个对象并填充它为 HTTP 状态码 `400`。`ControllerBase`
    类中有许多这样的辅助方法，它们是开箱即用的；然而，并非每个 API 控制器都需要从 `ControllerBase` 类继承。这里列出了 `ControllerBase`
    类中的所有辅助方法：[https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0).
- en: 'This brings us to a discussion as to what the return type of our controller
    methods should be because there could be at least two possible responses for any
    API in general, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了关于我们的控制器方法返回类型应该是什么的讨论，因为任何 API 在一般情况下都可能有至少两种可能的响应，如下所示：
- en: A successful response with a 2xx status code that possibly responds with a resource
    or a list of resources
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 2xx 状态码的成功响应，可能响应资源或资源列表
- en: A validation failure case with a 4xx status code
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 4xx 状态码的验证失败案例
- en: 'To handle such scenarios, we need to create a generic type that can be used
    to send different response types, and this is where ASP.NET Core''s `IActionResult`
    and `ActionResult` types come into play, providing us with derived response types
    for various scenarios. A few important response types that `IActionResult` supports
    are listed here:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理此类场景，我们需要创建一个泛型类型，可以用来发送不同的响应类型，这就是ASP.NET Core的`IActionResult`和`ActionResult`类型发挥作用的地方，为我们提供了针对各种场景的派生响应类型。以下是`IActionResult`支持的一些重要响应类型：
- en: '`OkObjectResult`: This is a response type that sets the HTTP status code to
    `200` and adds the resource to the body of the response containing the details
    of the resource. This type is ideal for all APIs that respond with a resource
    or a list of resources—for example, get products.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OkObjectResult`: 这是一个将HTTP状态码设置为`200`并将包含资源详细信息的资源添加到响应正文中的响应类型。对于所有响应资源或资源列表的API来说，这种类型非常理想——例如获取产品。'
- en: '`NotFoundResult`: This is a response type that sets the HTTP status code to
    `404` and has an empty body. This can be used if a particular resource is not
    found. However, in the case of a resource not found, we will use `NoContentResult`
    (`204`), as `404` will also be used for an API not found.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotFoundResult`: 这是一个将HTTP状态码设置为`404`且正文为空的响应类型。如果特定资源未找到，则可以使用它。然而，在资源未找到的情况下，我们将使用`NoContentResult`（`204`），因为`404`也将用于API未找到的情况。'
- en: '`BadRequestResult`: This is a response type that sets the HTTP status code
    to `400` and contains an error message in the response body. This is ideal for
    any validation failures.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BadRequestResult`: 这是一个将HTTP状态码设置为`400`并在响应正文中包含错误消息的响应类型。这对于任何验证失败来说非常理想。'
- en: '`CreatedAtActionResult`: This is a response type that sets the HTTP status
    code to `201` and can add the newly created resource URI to the response. This
    is ideal for APIs that create resources.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreatedAtActionResult`: 这是一个将HTTP状态码设置为`201`并可以将新创建的资源URI添加到响应中的响应类型。这对于创建资源的API来说非常理想。'
- en: All these response types are inherited from `IActionResult`, and there are methods
    available in the `ControllerBase` class that can create these objects; so, `IActionResult`,
    along with `ControllerBase`, would solve most of the business requirements, and
    this is what we will have as the return type for all our API controller methods.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些响应类型都继承自`IActionResult`，`ControllerBase`类中提供了创建这些对象的方法；因此，`IActionResult`与`ControllerBase`结合将解决大多数业务需求，这就是我们所有API控制器方法的返回类型。
- en: 'The final important class available in ASP.NET Core that comes in handy is
    the `ApiController` class, which can be added as an attribute to the controller
    class or to an assembly, and adds the following behaviors to our controllers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，另一个非常有用的类是`ApiController`类，它可以作为属性添加到控制器类或程序集，并为我们的控制器添加以下行为：
- en: It disables conventional routing and makes attribute-based routing mandatory.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它禁用了传统路由，并强制使用基于属性的路由。
- en: It validates models automatically, so we don't need to explicitly call `ModelState.IsValid`
    in every method. This behavior is very useful in the case of insert/update methods.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会自动验证模型，因此我们不需要在每个方法中显式调用`ModelState.IsValid`。在插入/更新方法的情况下，这种行为非常有用。
- en: 'It facilitates automatic parameter mapping from the body/route/header/query
    strings. What this means is that we don''t specify whether a parameter of an API
    is going to be part of the body or route. For example, in the following code snippet,
    we don''t need to explicitly say that the ID parameter is going to be part of
    the route as `ApiController` automatically uses something known as `[FromRoute]`:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了从正文/路由/头部/查询字符串到参数的自动映射。这意味着我们不需要指定API参数是否将作为正文或路由的一部分。例如，在下面的代码片段中，我们不需要显式说明ID参数将作为路由的一部分，因为`ApiController`自动使用名为`[FromRoute]`的某种机制：
- en: '[PRE98]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Similarly, in the following code snippet, `ApiController` will automatically
    add `[FromBody]` based on the inference rules:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，在下面的代码片段中，`ApiController`将根据推断规则自动添加`[FromBody]`：
- en: '[PRE99]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: A couple of other behaviors that `ApiController` adds are inferring request
    content to multipart/form data and more detailed error responses, as per [https://tools.ietf.org/html/rfc7807.](https://tools.ietf.org/html/rfc7807.)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApiController`添加的其他一些行为包括推断请求内容为multipart/form数据以及更详细的错误响应，具体请参阅[https://tools.ietf.org/html/rfc7807.](https://tools.ietf.org/html/rfc7807.)'
- en: So, all in all, `ControllerBase`, `ApiController`, and `ActionResult` provide
    various helper methods and behaviors, thereby providing developers with all the
    tools needed to write RESTful APIs and allowing them to focus on business logic
    while writing APIs using ASP.NET Core.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，`ControllerBase`、`ApiController`和`ActionResult`提供了各种辅助方法和行为，从而为开发者提供了编写RESTful
    API所需的所有工具，并允许他们在使用ASP.NET Core编写API时专注于业务逻辑。
- en: With this foundation, let's design various APIs for our e-commerce application
    in the next section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，让我们在下一节设计我们电子商务应用的各个API。
- en: Integration with the data layer
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数据层的集成
- en: The response from our APIs may or may not look like our domain models. Instead,
    their structure can resemble the fields that the UI or Views need to bind; hence,
    it is recommended to create a separate set of POCO classes that integrate with
    our UI. These POCOs are known as **Data Transfer Objects** (**DTOs**).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们API的响应可能看起来像或不像我们的领域模型。相反，它们的结构可能类似于UI或视图需要绑定的字段；因此，建议创建一组独立的POCO（Plain Old
    CLR Object）类，这些类与我们的UI集成。这些POCO被称为**数据传输对象**（**DTOs**）。
- en: In this section, we will implement our DTOs' domain logic integrating with the
    data layer and integrate the cache services discussed in [*Chapter 8*](B18507_08_Epub.xhtml#_idTextAnchor714),
    *All You Need to Know about Caching*, using the Cache-Aside pattern, and then—finally—implement
    the required RESTful APIs using controllers and actions. Along the way, we will
    use the `HTTPClient` factory for our service-to-service communication, and the
    `AutoMapper` library for mapping domain models to DTOs.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的DTOs（数据传输对象）的领域逻辑，并将其与数据层集成，同时使用[*第8章*](B18507_08_Epub.xhtml#_idTextAnchor714)中讨论的缓存服务，即*关于缓存的全部知识*，采用Cache-Aside模式进行集成，然后——最终——使用控制器和操作实现所需的RESTful
    API。在这个过程中，我们将使用`HTTPClient`工厂进行服务间的通信，并使用`AutoMapper`库将领域模型映射到DTOs。
- en: 'We will pick a product service that is part of `Packt.Ecommerce.Product`, a
    web API project using .NET 6, and discuss its implementation in detail. By the
    end of this section, we will have implemented the projects highlighted in the
    following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择一个作为`Packt.Ecommerce.Product`一部分的产品服务，这是一个使用.NET 6的Web API项目，并详细讨论其实现。在本节结束时，我们将实现以下屏幕截图中所突出的项目：
- en: '![Figure 10.7 – Product service and DTOs'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.7 – Product service and DTOs'
- en: '](img/Figure_10.7_B18507.png)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_10.7_B18507.png]'
- en: Figure 10.7 – Product service and DTOs
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 产品服务和DTOs
- en: 'A similar implementation is replicated across all RESTful services with slight
    modifications in business logic, as required, but the high-level implementation
    remains the same across the following various services:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有RESTful服务中，都有一个类似的实现，根据需要对业务逻辑进行轻微修改，但以下各种服务的高级实现保持不变：
- en: '`Packt.Ecommerce.DataAccess`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.DataAccess`'
- en: '`Packt.Ecommerce.Invoice`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.Invoice`'
- en: '`Packt.Ecommerce.Order`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.Order`'
- en: '`Packt.Ecommerce.Payment`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.Payment`'
- en: '`Packt.Ecommerce.UserManagement`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Packt.Ecommerce.UserManagement`'
- en: 'To start with, we will have the corresponding section in `appsettings.json`,
    which is shown as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`appsettings.json`中有一个相应的部分，如下所示：
- en: '[PRE100]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'For the local development environment, we will use **Manage User Secrets**
    (as explained at [https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows))
    and set the following values. However, once the service is deployed, it will make
    use of Azure Key Vault, as explained in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473),
    *Configuration in .NET 6*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地开发环境，我们将使用**管理用户密钥**（如[https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows)中所述）并设置以下值。然而，一旦服务部署，它将使用Azure
    Key Vault，如[*第6章*](B18507_06_Epub.xhtml#_idTextAnchor473)中所述，*在.NET 6中的配置*：
- en: '[PRE109]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Let's begin by creating DTOs for the Products API.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为产品API创建DTOs。
- en: Creating DTOs
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建DTOs
- en: 'The key requirements in terms of product services are to provide the ability
    to search for products, view additional details relating to the products, and
    then proceed with the purchase. Since a listing of products can have limited details,
    let''s create a POCO (all DTOs are created in the `Packt.Ecommerce.DTO.Models`
    project) and name it `ProductListViewModel`. This class will have all the properties
    that we want to show on the product''s list page, and it should look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在产品服务方面，关键要求是提供搜索产品、查看与产品相关的额外详细信息，然后进行购买的能力。由于产品列表可能包含有限的信息，让我们创建一个POCO（所有DTO都在`Packt.Ecommerce.DTO.Models`项目中创建）并命名为`ProductListViewModel`。这个类将包含我们希望在产品列表页面上显示的所有属性，并且应该看起来像这样：
- en: '[PRE114]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'As you can see, these are minimum fields that are usually displayed on any
    e-commerce application. Hence, we will go with these fields, but the idea is to
    extend as the application evolves. Here, the `Id` and `Name` properties are important
    properties as those will be used to query the database once the user wants to
    retrieve all further details regarding the product. We are annotating the `Id`
    property with the `JsonProperty(PropertyName = "id")` attribute to ensure that
    the property name remains as `Id` during serialization and deserialization. This
    is important because, in our Cosmos DB instance, we are using `Id` as the key
    for most of the containers. Let''s now create another POCO that represents the
    details of a product, as shown in the following code snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些是在任何电子商务应用程序上通常显示的最小字段。因此，我们将采用这些字段，但想法是随着应用程序的发展而扩展。在这里，`Id`和`Name`属性是重要的属性，因为它们将被用于在用户想要检索有关产品的所有进一步详细信息时查询数据库。我们使用`JsonProperty(PropertyName
    = "id")`属性来注释`Id`属性，以确保在序列化和反序列化过程中属性名称保持为`Id`。这很重要，因为在我们Cosmos DB实例中，我们使用`Id`作为大多数容器的主键。现在让我们创建另一个POCO，它表示产品的详细信息，如下面的代码片段所示：
- en: '[PRE123]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: So, in this DTO, apart from `Id` and `Name`, one of the important properties
    is `Etag`, which will be used for entity tracking to avoid concurrent overwrites
    on an entity. For example, if two users access a product and user A updates it
    before user B, using `Etag`, we can stop user B from overwriting user A's changes
    and force user B to take the latest copy of the product prior to updating. The
    `AddProductAsync(ProductDetailsViewModel product)` method in [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers)
    follows this pattern.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个DTO中，除了`Id`和`Name`之外，另一个重要的属性是`Etag`，它将被用于实体跟踪，以避免在实体上并发覆盖。例如，如果有两个用户访问一个产品，并且用户A在用户B之前更新它，使用`Etag`，我们可以阻止用户B覆盖用户A的更改，并强制用户B在更新之前获取产品的最新副本。《AddProductAsync(ProductDetailsViewModel
    product)》方法在[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers)遵循此模式。
- en: Another important aspect is that we are using ASP.NET Core's built-in validation
    attributes on our model to define all constraints on the models. Primarily, we
    will be using the `[Required]` attribute and any relevant attributes, as per [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是我们正在使用ASP.NET Core内置的验证属性在我们的模型上定义所有约束。主要，我们将使用`[Required]`属性和任何相关属性，如[https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes)。
- en: All the DTOs would be part of the `Packt.Ecommerce.DTO.Models` project as they
    will be reused in our ASP.NET MVC application, which will be used to build the
    UI of our e-commerce application. Now, let's look at the contracts needed for
    the `Products` service.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 所有DTO都将作为`Packt.Ecommerce.DTO.Models`项目的一部分，因为它们将在我们的ASP.NET MVC应用程序中重用，该应用程序将用于构建我们电子商务应用程序的UI。现在，让我们看看`Products`服务所需的合同。
- en: Service-class contracts
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类合同
- en: 'Add a `Contracts` folder to `Packt.Ecommerce.Product` and create a contract/interface
    of a product''s service class, for which we will refer to our requirements and
    define methods as needed. To start with, it will have all the methods to perform
    **create, read, update, and delete** (**CRUD**) operations on products based on
    that interface, and these will look like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Packt.Ecommerce.Product` 中添加一个 `Contracts` 文件夹，并创建一个产品服务类的合同/接口，我们将参考我们的需求并根据需要定义方法。最初，它将包含所有基于该接口在产品上执行
    **创建、读取、更新和删除**（**CRUD**）操作的方法，如下所示：
- en: '[PRE152]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Here, you can see that we are returning `Task` in all methods, thereby sticking
    to our asynchronous approach discussed in [*Chapter 4*](B18507_04_Epub.xhtml#_idTextAnchor205),
    *Threading and Asynchronous Operations*.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们在所有方法中返回 `Task`，从而坚持我们在 [*第4章*](B18507_04_Epub.xhtml#_idTextAnchor205)，*线程和异步操作*
    中讨论的异步方法。
- en: The mapper class using AutoMapper
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 AutoMapper 的映射类
- en: 'The next thing that we will need is a way to transform our domain models to
    DTOs, and here, we will use a well-known library called `AutoMapper` (please refer
    to [https://docs.automapper.org/en/stable/Getting-started.html](https://docs.automapper.org/en/stable/Getting-started.html)
    for more details) to configure and add the following packages:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要一种将领域模型转换为 DTO 的方法，这里我们将使用一个名为 `AutoMapper` 的知名库（请参阅 [https://docs.automapper.org/en/stable/Getting-started.html](https://docs.automapper.org/en/stable/Getting-started.html)
    获取更多详细信息）来配置并添加以下包：
- en: '`Automapper`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Automapper`'
- en: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
- en: 'To configure `AutoMapper`, we need to define a class that inherits from `AutoMapper.Profile`
    and then defines the mapping between various domain models and DTOs. Let''s add
    an `AutoMapperProfile` class to the `Packt.Ecommerce.Product` project, as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 `AutoMapper`，我们需要定义一个继承自 `AutoMapper.Profile` 的类，然后定义各种领域模型和 DTO 之间的映射。让我们在
    `Packt.Ecommerce.Product` 项目中添加一个 `AutoMapperProfile` 类，如下所示：
- en: '[PRE167]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '`AutoMapper` comes with many inbuilt methods for mapping, one of these being
    `CreateMap`, which accepts source and destination classes and maps them based
    on the same property names. Any property that does not have the same name can
    be manually mapped using the `ForMember` method. Since `ProductDetailsViewModel`
    has a one-to-one mapping with our domain model, `CreateMap` should be good enough
    for their mapping. For `ProductListViewModel`, we have an additional field, `AverageRating`,
    for which we wanted to calculate the average of all the ratings given for a particular
    product. To keep it simple, we will use the `Average` method from `Linq` and then
    map it to the average rating. For modularization, we will have this in a separate
    method, `MapEntity`, which looks like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoMapper` 包含许多内置的映射方法，其中之一是 `CreateMap`，它接受源和目标类，并根据相同的属性名称进行映射。任何没有相同名称的属性都可以使用
    `ForMember` 方法手动映射。由于 `ProductDetailsViewModel` 与我们的领域模型有一对一的映射，因此 `CreateMap`
    对于它们的映射应该是足够的。对于 `ProductListViewModel`，我们有一个额外的字段 `AverageRating`，我们希望计算特定产品的所有评分的平均值。为了简化，我们将使用来自
    `Linq` 的 `Average` 方法，并将其映射到平均评分。为了模块化，我们将将其放在一个单独的方法 `MapEntity` 中，如下所示：'
- en: '[PRE173]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Now, modify the constructor to call this method. Refer to [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs)
    for the complete implementation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，修改构造函数以调用此方法。有关完整实现，请参阅 [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs)。
- en: 'The final step involved in setting up `AutoMapper` is to inject it as one of
    the services, for which we will use the `WebApplicationBuilder` object of the
    `Program` class, using the following line of code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `AutoMapper` 的最后一步是将它注入为服务之一，我们将使用 `Program` 类的 `WebApplicationBuilder` 对象，使用以下代码行：
- en: '[PRE185]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: As explained earlier, this will inject the `AutoMapper` library into our API,
    and this will then allow us to inject `AutoMapper` into various services and controllers.
    Let's now look at the configuration of the `HttpClient` factory, which is used
    for calling the data access service.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这将把 `AutoMapper` 库注入到我们的 API 中，然后这将允许我们将 `AutoMapper` 注入到各种服务和控制器中。现在，让我们看看
    `HttpClient` 工厂的配置，该工厂用于调用数据访问服务。
- en: HttpClient factory for service-to-service calls
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务间调用的 HttpClient 工厂
- en: To retrieve data, we must call APIs exposed by our data access service defined
    in `Packt.Ecommerce.DataAccess`. For this, we need a resilient library that can
    effectively use the available sockets, allowing us to define a circuit breaker
    as well as retry/timeout policies. `IHttpClientFactory` is ideal for such scenarios.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索数据，我们必须调用定义在 `Packt.Ecommerce.DataAccess` 中的数据访问服务公开的 API。为此，我们需要一个能够有效使用可用套接字的弹性库，允许我们定义断路器以及重试/超时策略。`IHttpClientFactory`
    对于此类场景非常理想。
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One common issue with `HttpClient` is the potential `SocketException` error,
    which happens as `HttpClient` leaves the `HttpClient` as a static/singleton—which
    has its own overheads—while connecting to multiple services. These issues are
    summarized at [https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests](https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests),
    and these are all now addressed by `IhttpClientFactory`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 中的一个常见问题是潜在的 `SocketException` 错误，这发生在 `HttpClient` 在连接到多个服务时将
    `HttpClient` 作为静态/单例使用——这有其自身的开销。这些问题在 [https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests](https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests)
    中进行了总结，现在这些都可以通过 `IhttpClientFactory` 解决。'
- en: 'To configure `IHttpClientFactory`, perform the following steps:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 `IHttpClientFactory`，请执行以下步骤：
- en: Install `Microsoft.Extensions.Http`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Microsoft.Extensions.Http`。
- en: 'We will be configuring `IHttpClientFactory` using typed clients, so add a `Services`
    folder and a `ProductsService` class and inherit them from `IProductService`.
    For now, leave the implementation empty. Now, map `IProductService` and `ProductsService`
    in the `Program` class using the following code:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用类型化客户端来配置 `IHttpClientFactory`，因此添加一个 `Services` 文件夹和一个 `ProductsService`
    类，并从 `IProductService` 继承。目前，请保持实现为空。现在，在 `Program` 类中使用以下代码映射 `IProductService`
    和 `ProductsService`：
- en: '[PRE186]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Here, we are defining the timeout for `HttpClient` used by `ProductsService`
    as `5` minutes and additionally configuring a policy for retries and a circuit
    breaker.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 `ProductsService` 使用的 `HttpClient` 定义了 `5` 分钟的超时，并额外配置了重试和断路器的策略。
- en: Implementing a circuit-breaker policy
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现断路器策略
- en: 'To define these policies, we will use a library called `Polly` (refer to [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
    for the official documentation), which gives out-of-the-box resiliency and fault-handling
    capabilities. Install the `Microsoft.Extensions.Http.Polly` package and then add
    the following static method to the `Program` class that defines our circuit-breaker
    policy:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这些策略，我们将使用一个名为 `Polly` 的库（有关官方文档，请参阅[https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)），它提供了开箱即用的弹性和错误处理能力。安装
    `Microsoft.Extensions.Http.Polly` 包，然后向定义我们断路器策略的 `Program` 类中添加以下静态方法：
- en: '[PRE187]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Here, we are saying that the circuit would be opened if there are 5 failures
    within 30 seconds. A circuit breaker assists in avoiding unnecessary HTTP calls
    where there is a critical failure that cannot be fixed with a retry.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们表示如果30秒内有5次失败，则会打开电路。断路器有助于避免在无法通过重试修复的严重故障时进行不必要的 HTTP 调用。
- en: Implementing a retry policy
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现重试策略
- en: 'Now, let''s add our retry policy, which is a bit smarter compared with the
    standard retries that retire within a specified timeframe. So, we define a policy
    that will affect a retry and HTTP service calls on five occasions, and each retry
    would have a time difference in seconds at a rate of power of two. The code is
    illustrated here:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加我们的重试策略，它比在指定时间范围内退出的标准重试更智能。因此，我们定义了一个将在五次重试和 HTTP 服务调用上产生影响的政策，并且每次重试都会以2的幂次方的时间差。代码如下所示：
- en: 'To add some randomness in terms of the time variation, we will use a `Random`
    class of C# to generate a random number and add it to the time gap. This random
    generation will be as shown in the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在时间变化方面添加一些随机性，我们将使用 C# 的 `Random` 类生成一个随机数并将其添加到时间间隔中。这种随机生成将如下所示：
- en: '[PRE193]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Here, `retry` is an integer that increments by one with every retry. With this,
    add a static method to the `Program` class that has the preceding logic.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`retry` 是一个整数，每次重试时都会增加一。为此，在 `Program` 类中添加一个具有前面逻辑的静态方法。
- en: This completes our `HTTPClient` factory configuration, and `ProductsService`
    can use constructor injection to instantiate `IHttpClientFactory`, which can be
    further used to create `HttpClient`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的 `HTTPClient` 工厂配置，`ProductsService` 可以使用构造函数注入来实例化 `IHttpClientFactory`，然后可以进一步用来创建
    `HttpClient`。
- en: With all this configuration, we can now implement our service class. Let's look
    at that in the next section.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些配置完成后，我们现在可以实施我们的服务类。让我们在下一节中查看它。
- en: Implementing service classes
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务类中实现
- en: 'Let''s now implement `ProductsService`, starting by defining various properties
    that we have now built and instantiating them using constructor injections, as
    shown in the following code block:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现 `ProductsService`，首先定义我们已构建的各种属性，并使用构造函数注入来实例化它们，如下面的代码块所示：
- en: '[PRE206]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'All our services are going to use the same exception-handling middleware we
    defined in this chapter, so during service-to-service calls, if there is a failure
    in another service, the response would be of the `ExceptionResponse` type. Hence,
    let''s create a private method, so deserialize the `ExceptionResponse` class and
    raise it accordingly. This is required because `HttpClient` would represent success
    or failure while using the `IsSuccessStatusCode` and `StatusCode` properties,
    so if there is an exception, we need to check `IsSuccessStatusCode` and rethrow
    it. Let''s call this method `ThrowServiceToServiceErrors` and refer to the following
    code snippet:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有服务都将使用我们在本章中定义的相同的异常处理中间件，因此在服务之间的调用过程中，如果另一个服务出现故障，响应将属于 `ExceptionResponse`
    类型。因此，让我们创建一个私有方法，以反序列化 `ExceptionResponse` 类并相应地抛出异常。这是必需的，因为在使用 `IsSuccessStatusCode`
    和 `StatusCode` 属性时，`HttpClient` 会表示成功或失败，所以如果出现异常，我们需要检查 `IsSuccessStatusCode`
    并重新抛出它。让我们将此方法命名为 `ThrowServiceToServiceErrors` 并参考以下代码片段：
- en: '[PRE221]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Let''s now implement the `GetProductsAsync` method, in which we will use `CacheService`
    to retrieve data from the cache, and if it is not available in the cache, we will
    call the data access service using `HttpClient`, and finally map the `Product`
    domain''s model to a DTO and return it asynchronously. The code will look like
    this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现 `GetProductsAsync` 方法，在这个方法中，我们将使用 `CacheService` 从缓存中检索数据，如果缓存中没有数据，我们将使用
    `HttpClient` 调用数据访问服务，并将 `Product` 领域模型映射到 DTO，然后异步返回。代码将如下所示：
- en: '[PRE226]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: We will follow a similar pattern and implement `AddProductAsync`, `UpdateProductAsync`,
    `GetProductByIdAsync`, and `DeleteProductAsync`. The only difference in each of
    these methods would be to use the relevant `HttpClient` method and handle them
    accordingly. Now that we have our service implemented, let's implement our controller.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循类似的模式并实现 `AddProductAsync`、`UpdateProductAsync`、`GetProductByIdAsync` 和
    `DeleteProductAsync`。这些方法中的唯一区别将是使用相关的 `HttpClient` 方法并相应地处理它们。现在我们已经实现了服务，让我们来实现我们的控制器。
- en: Implementing action methods in the controller
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中实现操作方法
- en: 'Let''s first inject the service created in the previous section into the ASP.NET
    Core 6 DI container so that we can use constructor injection to create an object
    of `ProductsService`. We will do this in the `Program` class using the following
    code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先将在上一节中创建的服务注入到 ASP.NET Core 6 DI 容器中，这样我们就可以使用构造函数注入来创建 `ProductsService`
    的对象。我们将在 `Program` 类中使用以下代码来完成此操作：
- en: '[PRE262]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Also, ensure that all the required framework components—such as `ApplicationSettings`,
    `CacheService`, and `AutoMapper`—are configured.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，确保所有必需的框架组件（如 `ApplicationSettings`、`CacheService` 和 `AutoMapper`）都已配置。
- en: 'Add a controller to the `Controllers` folder and name it `ProductsController`
    with the default route as `api/products`, and then add an `IProductService` property
    and inject it using constructor injection. The controller should implement five
    action methods, each calling one of the service methods, and use various out-of-the-box
    helper methods and attributes discussed in *The ControllerBase class, the* *ApiController
    attribute, and the ActionResult class* section of this chapter. The methods for
    retrieving specific products and creating a new product are shown in the following
    code block:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Controllers` 文件夹中添加一个控制器，命名为 `ProductsController`，默认路由为 `api/products`，然后添加一个
    `IProductService` 属性，并使用构造函数注入。控制器应实现五个操作方法，每个方法调用一个服务方法，并使用本章中讨论的各种现成辅助方法和属性，如
    *The ControllerBase class, the* *ApiController attribute, and the ActionResult
    class* 部分。获取特定产品和创建新产品的代码块如下所示：
- en: '[PRE263]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The method implementation is self-explanatory and based purely on the fundamentals
    discussed in the *Handling requests using controllers and actions* section of
    this chapter. Similarly, we will implement all the other methods (`Delete`, `Update`,
    and `Get` all products) by calling the corresponding service method and returning
    the relevant `ActionResult`. With that, we will have APIs shown in the following
    table to handle various scenarios related to the product entity:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 方法实现是显而易见的，并完全基于本章 *Handling requests using controllers and actions* 部分讨论的基本原理。同样，我们将通过调用相应的服务方法并返回相关的
    `ActionResult` 来实现所有其他方法（`Delete`、`Update` 和获取所有产品的 `Get`）。这样，我们将拥有以下表格中显示的 API
    来处理与产品实体相关的各种场景：
- en: '![Table 10.2'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 10.2'
- en: '](img/Table_10.2.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table_10.2.jpg)'
- en: Table 10.2
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.2
- en: Tip
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another common scenario with APIs is to have an API that supports file upload/download.
    The upload scenario is achieved by passing `IFormFile` as an input parameter to
    the API. This serializes the uploaded file and can also save on the server. Similarly,
    for file downloading, `FileContentResult` is available and can stream files to
    any client. This is left to you as an activity to explore further.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 相关的另一个常见场景是拥有支持文件上传/下载的 API。上传场景是通过将 `IFormFile` 作为 API 的输入参数来实现的。这会将上传的文件序列化，并可以将其保存到服务器上。同样，对于文件下载，`FileContentResult`
    也是可用的，可以将文件流式传输到任何客户端。这留给你作为一项活动来进一步探索。
- en: 'For the testing API, we will use Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/)).
    All Postman collections can be found under the `Solution Items` folder file, `Mastering
    enterprise application development Book.postman_collection.json`. To import a
    collection once Postman has been installed, perform the following steps:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试 API，我们将使用 Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/))。所有
    Postman 集合都可以在 `Solution Items` 文件夹中的 `Mastering enterprise application development
    Book.postman_collection.json` 文件下找到。一旦安装了 Postman，导入集合的步骤如下：
- en: Open Postman, and then click on **File**.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Postman，然后点击 **文件**。
- en: Click `Mastering enterprise application development Book.postman_collection.json`
    file and then click on **Import**.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Mastering enterprise application development Book.postman_collection.json`
    文件，然后点击 **导入**。
- en: 'A successful import will show the collection in the **Collections** menu of
    Postman, as depicted in the following screenshot:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 成功导入后，Postman 的 **集合** 菜单中将显示该集合，如下截图所示：
- en: '![Figure 10.8 – Collections in Postman'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.8 – Collections in Postman'
- en: '](img/Figure_10.8_B18507.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B18507.jpg)'
- en: Figure 10.8 – Collections in Postman
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – Postman 中的集合
- en: This completes our `Products` RESTful service implementation. All the other
    services mentioned at the beginning of this section are implemented in a similar
    way, where each of them is an individual web API project and handles the relevant
    domain logic for that entity.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的 `Products` RESTful 服务实现。本节开头提到的其他所有服务都是以类似的方式实现的，其中每个服务都是一个独立的 Web API
    项目，并处理该实体的相关领域逻辑。
- en: Understanding gRPC
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 gRPC
- en: 'As per `grpc.io`, gRPC is a high-performance, open source universal RPC framework.
    Originally developed by Google, gRPC uses HTTP/2 for transport and a **Protocol
    Buffer** (**protobuf**) as the interface description language. gRPC is a contract-based
    binary communication system, and it is available across multiple ecosystems. The
    following diagram from gRPC''s official documentation (https://grpc.io) illustrates
    client-server interaction using gRPC:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `grpc.io`，gRPC 是一个高性能、开源的通用 RPC 框架。最初由 Google 开发，gRPC 使用 HTTP/2 进行传输，并使用
    **协议缓冲区**（**protobuf**）作为接口描述语言。gRPC 是基于合同的二进制通信系统，并且可在多个生态系统中使用。以下来自 gRPC 官方文档（https://grpc.io）的图表展示了使用
    gRPC 的客户端-服务器交互：
- en: '![Figure 10.9 – gRPC client-server interaction'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – gRPC 客户端-服务器交互'
- en: '](img/Figure_10.9_B18507.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B18507.jpg)'
- en: Figure 10.9 – gRPC client-server interaction
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – gRPC 客户端-服务器交互
- en: As with many distributed systems, gRPC is based on the idea of defining a service
    and specifying an interface with methods that can be invoked remotely, along with
    contracts. In gRPC, the server implements the interface and runs the gRPC server
    to handle client calls. The client side has the stub, which provides the same
    interface as defined by the server. The client calls the stub in the same way
    as it invokes methods in any other local object to invoke a method on the server.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多分布式系统一样，gRPC 基于定义服务并指定具有可远程调用的方法的接口以及合同的想法。在 gRPC 中，服务器实现接口并运行 gRPC 服务器以处理客户端调用。客户端方面有存根，它提供了与服务器定义相同的接口。客户端以调用任何其他本地对象上的方法相同的方式调用存根以在服务器上调用方法。
- en: By default, data contracts use `.proto` extension. In a protobuf, the data is
    structured as a logical record of the information contained in fields. In the
    upcoming section, we will learn about how to define a protobuf in Visual Studio
    for a .NET 6 application.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据合同使用 `.proto` 扩展。在 protobuf 中，数据以字段中包含的信息的逻辑记录结构化。在接下来的章节中，我们将学习如何在
    Visual Studio 中为 .NET 6 应用程序定义 protobuf。
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Refer to the official documentation to learn more about gRPC: [https://grpc.io](https://grpc.io).
    To learn more about protobufs, refer to [https://developers.google.com/protocol-buffers/docs/overview](https://developers.google.com/protocol-buffers/docs/overview).'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅官方文档了解有关 gRPC 的更多信息：[https://grpc.io](https://grpc.io)。要了解更多关于 protobuf 的信息，请参阅
    [https://developers.google.com/protocol-buffers/docs/overview](https://developers.google.com/protocol-buffers/docs/overview)。
- en: Given the benefits of high performance, language-agnostic implementation, and
    reduced network usage associated with the protobuf of gRPC, many teams are exploring
    the use of gRPC in their endeavors to build microservices.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 gRPC 的 protobuf 与高性能、语言无关的实现和减少的网络使用相关联，许多团队正在探索在其构建微服务的努力中使用 gRPC。
- en: In the next section, we will learn how to build a gRPC server and client in
    .NET 6.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在 .NET 6 中构建 gRPC 服务器和客户端。
- en: Building a gRPC server in .NET
  id: totrans-551
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 .NET 中构建 gRPC 服务器
- en: 'After making its first appearance in .NET Core 3.0, gRPC has become a first-class
    citizen in the .NET ecosystem. Fully managed gRPC implementation is now available
    in .NET. Using Visual Studio 2022 and .NET 6, we can create gRPC server and client
    applications easily. Let''s create a gRPC service using the gRPC service template
    in Visual Studio, shown in the following screenshot, and name it `gRPCDemoService`:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET Core 3.0 首次出现后，gRPC 已成为 .NET 生态系统中的第一公民。现在在 .NET 中提供了完全托管的 gRPC 实现。使用
    Visual Studio 2022 和 .NET 6，我们可以轻松地创建 gRPC 服务器和客户端应用程序。让我们使用 Visual Studio 中的
    gRPC 服务模板创建一个 gRPC 服务，如下面的截图所示，并将其命名为 `gRPCDemoService`：
- en: '![Figure 10.10 – gRPC Visual Studio 2022 project template'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – gRPC Visual Studio 2022 项目模板'
- en: '](img/Figure_10.10_B18507.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.10_B18507.jpg)'
- en: Figure 10.10 – gRPC Visual Studio 2022 project template
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – gRPC Visual Studio 2022 项目模板
- en: 'This will create a solution with a sample gRPC service named `GreetService`.
    Let''s now understand the solution created with the template. The solution created
    will have a package reference to `Grpc.AspNetCore`. This will have the libraries
    required to host the gRPC service and a code generator for the `.proto` files.
    This solution will have a proto file created for `GreetService` under the `Protos`
    solution folder. The following code defines the `Greeter` service:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `GreetService` 的示例 gRPC 服务解决方案。现在让我们了解使用模板创建的解决方案。创建的解决方案将引用 `Grpc.AspNetCore`
    包。这将包含托管 gRPC 服务所需的库以及 `.proto` 文件的代码生成器。此解决方案将在 `Protos` 解决方案文件夹下创建一个 `GreetService`
    的 proto 文件。以下代码定义了 `Greeter` 服务：
- en: '[PRE297]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'The `Greeter` service has only one method named `SayHello`, which takes the
    input parameter as `HelloRequest` and returns a message of the `HelloReply` type.
    `HelloRequest` and `HelloReply` messages are defined in the same proto file, as
    shown in the following code snippet:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '`HelloRequest` has one field named `name`, and `HelloReply` has one field named
    `message`. The number next to the field shows the ordinal position of the field
    in the buffer. The proto files are compiled with the `Protobuf` compiler to generate
    stub classes with all the plumbing required. We can specify the kind of stub classes
    to generate from the properties of the proto file. Since this is a server, it
    will have the configuration set to **Server only**.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `GreetService` implementation. This will appear as
    shown in the following code snippet:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '`GreetService` inherits from `Greeter.GreeterBase`, which is generated by the
    protobuf compiler. The `SayHello` method is overridden to provide the implementation
    so as to return a greeting to the caller by constructing `HelloReply`, as defined
    in the proto file.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: 'To expose gRPC services in a .NET 6 application, all the required gRPC services
    are to be added to the service collection by calling `AddGrpc` in the `Program`
    class. The `GreeterService` gRPC service is exposed by calling `MapGrpcService`,
    as illustrated in the following code snippet:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: That is everything that is required to expose a gRPC service in a .NET 6 application.
    In the next section, we will implement a .NET 6 client to consume `GreeterService`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC client in .NET
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As specified at the start of this *Understanding gRPC* section, .NET 6 has
    very good tooling for building a gRPC client as well. In this section, we will
    be building a gRPC client in a console application. Here are the steps to follow
    for you to accomplish this:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Create a .NET 6 console application and name it `gRPCDemoClient`.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, right-click on the project and click on the **Add** | **Service reference…**
    menu items. This will open the **Connected Services** tab, as shown in the following
    screenshot:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – gRPC Connected Services tab'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B18507.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – gRPC Connected Services tab
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: Select **gRPC** in the **Add service reference** dialog, and then click on **Next**.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `greet.proto` file from `gRPCDemoService`, and then click on the `Client`
    stub classes:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Adding a gRPC service reference'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B18507.jpg)'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Adding a gRPC service reference
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: This will also add the required `Google.Protobuf`, `Grpc.Net.ClientFactory`,
    and `Grpc.Tools` NuGet packages to the project.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `Program` class of the `gRPCDemoClient`
    project:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE324]'
- en: In this code snippet, we are creating a gRPC channel to the `gRPCDemoService`
    endpoint, and then instantiating `Greeter.GreeterClient`, which is a stub to `gRPCDemoService`,
    by passing in the gRPC channel.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Now, to invoke the service, we just need to call the `SayHelloAsync` method
    on the stub by passing the `HelloRequest` message. This call will return `HelloReply`
    from the service.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up to now, we have created a simple gRPC service and a console client for that
    service. In the next section, we will learn about `grpcurl`, which is a generic
    client to test gRPC services.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Testing gRPC services
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test or invoke a REST service, we use tools such as Postman or Fiddler. `grpcurl`
    is a command-line utility that helps us to interact with gRPC services. Using
    `grpcurl`, we can test gRPC services without building client apps. `grpcurl` is
    available for download from [https://github.com/fullstorydev/grpcurl](https://github.com/fullstorydev/grpcurl).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `grpcurl` is downloaded, we can call `GreeterService` using the following
    command:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: Note
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: Currently, gRPC applications can only be hosted in Azure App Service and **Internet
    Information Services** (**IIS**), hence we did not leverage gRPC in the demo e-commerce
    application that is hosted on Azure App Service. However, there is a version of
    the e-commerce application in this chapter demo, where obtaining a product according
    to its ID is exposed as a gRPC endpoint in a self-hosted service.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic principles of REST and also designed enterprise-level
    RESTful services for our e-commerce application.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we got to grips with the various web API internals of an ASP.NET
    Core 6 web API—including routing and sample middleware—and became familiar with
    tools for testing our services, while learning how to handle requests using a
    controller and its actions, which we also learned to build. Also, we saw how to
    create and test basic gRPC client and server applications in .NET 6\. You should
    now be able to confidently build RESTful services using an ASP.NET Core 6 web
    API.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through the fundamentals of ASP.NET MVC, build
    our UI layer using ASP.NET MVC, and integrate it with our APIs.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following HTTP verbs is recommended for creating a resource?
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `GET`
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: b. `POST`
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: c. `DELETE`
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: d. `PUT`
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following HTTP status codes represents `No Content`?
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `200`
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: b. `201`
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: c. `202`
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: d. `204`
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following middlewares is used to configure routing?
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `UseDeveloperExceptionPage()`
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: b. `UseHttpsRedirection()`
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: c. `UseRouting()`
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: d. `UseAuthorization()`
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: If a controller is annotated with the `[ApiController]` attribute, do I need
    to class `ModelState.IsValid` explicitly in each action method?
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes—model validation isn't part of the `ApiController` attribute, hence you
    need to call `ModelState.Valid` in each action method.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: b. No—model validation is handled as part of the `ApiController` attribute,
    hence `ModelState.Valid` is triggered automatically for all action items.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-641
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0)'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0)'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0)'
- en: '[https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0)'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0)'
- en: '[https://docs.microsoft.com/en-us/odata/overview](https://docs.microsoft.com/en-us/odata/overview)'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/odata/overview](https://docs.microsoft.com/en-us/odata/overview)'
