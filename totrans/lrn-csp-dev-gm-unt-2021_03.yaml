- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Diving into Variables, Types, and Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入变量、类型和方法
- en: The initial steps into any programming language are plagued with a fundamental
    issue—you can understand the words being typed out, but not the meaning behind
    them. Normally, this would be cause for a paradox, but programming is a special
    case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的入门步骤都受到一个基本问题的困扰——你可以理解所输入的单词，但无法理解它们的含义。通常，这会导致悖论，但编程是一个特殊情况。
- en: C# is not its own language; it's written in English. The discrepancy between
    the words you use every day and the code in Visual Studio comes from missing context,
    which is something that has to be learned all over again. You know how to say
    and spell the words used in C#, but what you don't know is where, when, why, and,
    most importantly, how they make up the syntax of the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C# 不是一个自己的语言；它是用英语编写的。你每天使用的单词与 Visual Studio 中的代码之间的差异来自于缺少上下文，这是必须再次学习的东西。你知道如何说和拼写
    C# 中使用的单词，但你不知道的是它们在哪里、何时、为什么，最重要的是，它们如何构成语言的语法。
- en: 'This chapter marks our departure from programming theory and the beginning
    of our journey into actual coding. We''ll talk about accepted formatting, debugging
    techniques, and putting together more complex examples of variables and methods.
    There''s a lot of ground to cover, but by the time you reach the last quiz, you''ll
    be comfortable with the following high-level topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着我们从编程理论转向实际编码的开始。我们将讨论接受的格式、调试技术，以及组合更复杂的变量和方法示例。有很多内容要覆盖，但当你到达最后一个测验时，你将能够舒适地掌握以下高级主题：
- en: Writing proper C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确编写 C#
- en: Debugging your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: Understanding variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量
- en: Introducing operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍运算符
- en: Defining methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义方法
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Writing proper C#
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确编写 C#
- en: Lines of code function like sentences, meaning they need to have some sort of
    separating or ending character. Every line of C#, called a statement, *must* end
    with a semicolon to separate them for the code compiler to process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行就像句子一样，意味着它们需要某种分隔或结束字符。每一行 C# 代码，称为语句，*必须*以分号结尾，以便代码编译器能够处理。
- en: 'However, there''s a catch that you need to be aware of. Unlike the written
    word we''re all familiar with, a C# statement doesn''t technically have to be
    on a single line; whitespace and newlines are ignored by the code compiler. For
    example, a simple variable could be written like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个你必须注意的陷阱。与我们都熟悉的书面文字不同，C# 语句在技术上不必在单行上；空白符和新行被代码编译器忽略。例如，一个简单的变量可以写成这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, it could also be written as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以写成如下形式：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two code snippets are both perfectly acceptable to Visual Studio, but
    the second option is highly discouraged in the software community as it makes
    code extremely hard to read. The idea is to write your programs as efficiently
    and clearly as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段在 Visual Studio 中都是完全可以接受的，但第二个选项在软件社区中是高度不建议的，因为它使得代码变得极其难以阅读。理念是尽可能高效和清晰地编写你的程序。
- en: There will be times when a statement will be too long to reasonably fit on a
    single line, but those are few and far between. Just make sure that it's formatted
    in a way someone else could understand, and don't forget the semicolon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会有一行语句太长，无法合理地放在单行上，但这些情况很少。只需确保格式化方式能让其他人理解，并且不要忘记分号。
- en: 'The second formatting rule you need to drill into your coding muscle memory
    is the use of curly brackets or braces: `{}`. Methods, classes, and interfaces
    all need a set of curly brackets after their declaration. We''ll talk about each
    of these in-depth later on, but it''s important to get the standard formatting
    in your head early on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要深入到你的编码肌肉记忆中的第二个格式化规则是使用花括号或大括号：`{}`。方法、类和接口在其声明之后都需要一组花括号。我们稍后会深入讨论这些内容，但重要的是要尽早在你的脑海中形成标准格式。
- en: 'The traditional practice in C# is to include each bracket on a new line, as
    shown in the following method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中的传统做法是将每个括号放在新的一行上，如下所示的方法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, you might see the first curly bracket located on the same line as
    the declaration out in the wild. It''s all down to personal preference:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会在野外看到第一个花括号与声明位于同一行的。这完全取决于个人喜好：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this isn't something to tear your hair out over, the important thing is
    to be consistent. In this book, we'll stick with "pure" C# code, which will always
    put each bracket on a new line, while C# examples that have to do with Unity and
    game development will often follow the second example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是什么值得让你抓狂的事情，但重要的是要保持一致性。在这本书中，我们将坚持使用“纯”C#代码，这总是将每个括号放在新的一行上，而与Unity和游戏开发相关的C#示例通常会遵循第二个示例。
- en: Good, consistent formatting style is paramount when starting in programming,
    but so is being able to see the fruits of your work. In the next section, we'll
    talk about how to print out variables and information straight to the Unity console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编程时，良好的、一致的格式化风格至关重要，但能够看到你工作的成果也同样重要。在下一节中，我们将讨论如何将变量和信息直接打印到Unity控制台。
- en: Debugging your code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: While we're working through practical examples, we'll need a way to print out
    information and feedback to the **Console** window in the Unity editor. The programmatic
    term for this is debugging, and both C# and Unity provide helper methods to make
    this process easier for developers. You already debugged your code from the last
    chapter, but we didn't go into much detail about how it actually works. Let's
    fix that.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在实际示例中工作时，我们需要一种方法来将信息和反馈打印到Unity编辑器中的**控制台**窗口。这种程序性的术语是调试，C#和Unity都提供了辅助方法来简化开发者的这一过程。你已经从上一章中调试了你的代码，但我们没有深入探讨它实际上是如何工作的。让我们来解决这个问题。
- en: 'Whenever I ask you to debug or print something out, use one of the following
    methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我让你调试或打印某些内容时，请使用以下方法之一：
- en: 'For simple text or individual variables, use the standard `Debug.Log()` method.
    The text needs to be inside a set of parentheses, and variables can be used directly
    with no added characters; for example:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的文本或单个变量，请使用标准的`Debug.Log()`方法。文本需要放在一组括号内，变量可以直接使用，无需添加任何字符；例如：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_01.png)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17573_03_01.png)'
- en: 'Figure 3.1: Observing Debug.Log output'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：观察Debug.Log输出
- en: 'For more complex debugging, use `Debug.LogFormat()`. This will let you place
    variables inside the printed text by using placeholders. These are marked with
    a pair of curly brackets, each containing an index. An index is a regular number,
    starting at 0 and increasing sequentially by 1\. In the following example, the
    `{0}` placeholder is replaced with the `CurrentAge` value, `{1}` with `FirstName`,
    and so on:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更复杂的调试，请使用`Debug.LogFormat()`。这将允许你通过使用占位符在打印的文本中放置变量。这些占位符由一对大括号标记，每个大括号包含一个索引。索引是一个常规数字，从0开始，按顺序递增1。在以下示例中，`{0}`占位符被`CurrentAge`值替换，`{1}`被`FirstName`替换，依此类推：
- en: '[PRE5]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_02.png)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17573_03_02.png)'
- en: 'Figure 3.2: Observing Debug.LogFormat output'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图3.2：观察Debug.LogFormat输出
- en: You might have noticed that we're using **dot notation** in our debugging techniques,
    and you'd be right! Debug is the class we're using, and `Log()` and `LogFormat()`
    are different methods that we can use from that class. More on this at the end
    of this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在调试技术中使用了**点符号**，你说得对！Debug是我们使用的类，而`Log()`和`LogFormat()`是我们可以从该类中使用的不同方法。更多内容将在本章末尾介绍。
- en: With the power of debugging under our belts, we can safely move on and do a
    deeper dive into how variables are declared, as well as the different ways that
    syntax can play out.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了调试的技巧之后，我们可以安全地继续深入探讨变量的声明方式以及语法如何以不同的方式发挥作用。
- en: Understanding variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量
- en: In the previous chapter, we saw how variables are written and touched on the
    high-level functionality that they provide. However, we're still missing the syntax
    that makes all of that possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何编写变量以及它们提供的高级功能。然而，我们仍然缺少使所有这些成为可能的语言语法。
- en: Declaring variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'Variables don''t just appear at the top of a C# script; they have to be declared
    according to certain rules and requirements. At its most basic level, a variable
    statement needs to satisfy the following requirements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不仅仅出现在C#脚本的最顶部；它们必须根据某些规则和要求进行声明。在最基本层面上，一个变量声明需要满足以下要求：
- en: The type of data the variable will store needs to be specified
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要指定变量将存储的数据类型
- en: The variable has to have a unique name
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须有一个唯一的名称
- en: If there is an assigned value, it must match the specified type
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有指定的值，它必须与指定的类型匹配
- en: The variable declaration needs to end with a semicolon
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明需要以分号结束
- en: 'The result of adhering to these rules is the following syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些规则的结果是以下语法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables need unique names to avoid conflicts with words that have already
    been taken by C#, which are called keywords. You can find the full list of protected
    keywords at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 变量需要唯一的名称以避免与 C# 已经占用的单词冲突，这些单词被称为关键字。你可以在 [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index)
    找到受保护关键字的完整列表。
- en: This is simple, neat, and efficient. However, a programming language wouldn't
    be useful in the long run if there was only one way of creating something as pervasive
    as variables. Complex applications and games have different use cases and scenarios,
    all of which have unique C# syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单、整洁且高效。然而，如果编程语言只有一种创建像变量这样普遍的东西的方法，那么从长远来看，它将没有用处。复杂的应用程序和游戏有不同的用例和场景，所有这些都有独特的
    C# 语法。
- en: Type and value declarations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型和价值声明
- en: 'The most common scenario for creating variables is one that has all of the
    required information available when the declaration is made. For instance, if
    we knew a player''s age, storing it would be as easy as doing the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建变量的最常见场景是在声明时提供所有必要信息。例如，如果我们知道一个玩家的年龄，存储它就像做以下事情一样简单：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, all of the basic requirements have been met:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，所有基本要求都已满足：
- en: A data type is specified, which is `int` (short for integer)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了一个数据类型，即 `int`（代表整数）
- en: A unique name is used, which is `CurrentAge`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个唯一的名称，即 `CurrentAge`
- en: '`32` is an integer, which matches the specified data type'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32` 是一个整数，与指定的数据类型匹配'
- en: The statement ends with a semicolon
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句以分号结束
- en: However, there will be scenarios where you'll want to declare a variable without
    knowing its value right away. We'll talk about this topic in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将会有一些场景，你想要声明一个变量，但一开始不知道它的值。我们将在下一节讨论这个话题。
- en: Type-only declarations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅类型声明
- en: 'Consider another scenario—you know the type of data you want a variable to
    store and its name, but not its value. The value will be computed and assigned
    somewhere else, but you still need to declare the variable at the top of the script.
    This situation is perfect for a type-only declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种场景——你知道一个变量要存储的数据类型及其名称，但不知道其值。值将在其他地方计算并分配，但你仍然需要在脚本顶部声明这个变量。这种情况非常适合仅类型声明：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only the type (`int`) and unique name (`CurrentAge`) are defined, but the statement
    is still valid because we''ve followed the rules. With no assigned value, default
    values will be assigned according to the variable''s type. In this case, `CurrentAge`
    will be set to `0`, which matches the `int` type. As soon as the actual value
    of the variable becomes available, it can easily be set in a separate statement
    by referencing the variable name and assigning it a value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 仅定义了类型（`int`）和唯一名称（`CurrentAge`），但语句仍然有效，因为我们遵循了规则。没有赋值的情况下，将根据变量的类型分配默认值。在这种情况下，`CurrentAge`
    将被设置为 `0`，这与 `int` 类型相匹配。一旦变量的实际值可用，就可以通过引用变量名称并为其赋值来轻松地在单独的语句中设置它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find a complete list of all C# types and their default values at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values)
    找到所有 C# 类型及其默认值的完整列表。
- en: At this point, you might be asking why, so far, our variables haven't included
    the `public` keyword, called an *access modifier*, which we saw in earlier scripting
    examples. The answer is that we didn't have the necessary foundation to talk about
    them with any clarity. Now that we have that foundation, it's time to revisit
    them in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能想知道为什么我们的变量还没有包括 `public` 关键字，这被称为 *访问修饰符*，我们在早期的脚本示例中见过。答案是，我们没有必要的知识基础来清晰地讨论它们。现在我们有了这个基础，是时候详细回顾它们了。
- en: Using access modifiers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符
- en: Now that the basic syntax is no longer a mystery, let's get into the finer details
    of variable statements. Since we read code from left to right, it makes sense
    to begin our variable deep dive with the keyword that traditionally comes first—an
    access modifier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本语法不再是谜团，让我们深入了解变量语句的细节。由于我们是从左到右阅读代码，因此从传统上首先出现的关键字——访问修饰符——开始我们的变量深入研究是有意义的。
- en: 'Take a quick look back at the variables we used in the preceding chapter in
    `LearningCurve` and you''ll see they had an extra keyword at the front of their
    statements: `public`. This is the variable''s access modifier. Think of it as
    a security setting, determining who and what can access the variable''s information.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下前一章在`LearningCurve`中使用的变量，你会发现它们在语句的开头有一个额外的关键字：`public`。这是变量的访问修饰符。把它想象成一个安全设置，决定了谁和什么可以访问变量的信息。
- en: Any variable that isn't marked `public` is defaulted to `private` and won't
    show up in the Unity Inspector panel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未标记为`public`的变量默认为`private`，并且不会在Unity检查器面板中显示。
- en: 'If you include a modifier, the updated syntax recipe we put together at the
    beginning of this chapter will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你包含一个修饰符，我们在本章开头整理的更新语法食谱将看起来像这样：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While explicit access modifiers aren't necessary when declaring a variable,
    it's a good habit to get into as a new programmer. That extra word goes a long
    way toward readability and professionalism in your code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明变量时，虽然显式访问修饰符不是必需的，但作为一个新程序员养成这个习惯是好的。这个词的额外作用对于代码的可读性和专业性来说意义重大。
- en: 'There are four main access modifiers available in C#, but the two you''ll be
    working with most often as a beginner are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有四种主要的访问修饰符可用，但作为初学者，你将最常使用以下两个：
- en: '**Public**: This is available to any script without restriction.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：这可以无限制地提供给任何脚本。'
- en: '**Private**: This is only available in the class they''re created in (which
    is called the containing class). Any variable without an access modifier defaults
    to private.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：这仅在它们被创建的类中可用（称为包含类）。任何没有访问修饰符的变量默认为私有。'
- en: 'The two advanced modifiers have the following characteristics:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个高级修饰符有以下特点：
- en: '**Protected**: Accessible from their containing class or types derived from
    it'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**受保护的**：可以从它们的包含类或从它派生的类型中访问'
- en: '**Internal**: Only available in the current assembly'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：仅在当前程序集内可用'
- en: There are specific use cases for each of these modifiers, but until we get to
    the advanced chapters, don't worry about **protected** and **internal**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些修饰符都有特定的使用场景，但直到我们到达高级章节，不用担心**受保护的**和**内部的**。
- en: Two combined modifiers also exist, but we won't be using them in this book.
    You can find more information about them at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在两种组合修饰符，但在这本书中我们不会使用它们。你可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)找到更多关于它们的信息。
- en: Let's try out some access modifiers of our own! Just like information in real
    life, some data needs to be protected or shared with specific people. If there's
    no need for a variable to be changed in the **Inspector** window or accessed from
    other scripts, it's a good candidate for a private access modifier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些自己的访问修饰符！就像现实生活中的信息一样，一些数据需要被保护或与特定的人共享。如果一个变量不需要在**检查器**窗口中更改或从其他脚本中访问，它是一个很好的私有访问修饰符的候选者。
- en: 'Perform the following steps to update `LearningCurve`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以更新`LearningCurve`：
- en: Change the access modifier in front of `CurrentAge` from `public` to `private`
    and save the file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentAge`前面的访问修饰符从`public`更改为`private`并保存文件。
- en: Go back into Unity, select the Main Camera, and take a look at what changed
    in the `LearningCurve`section:![](img/B17573_03_03.png)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，选择主摄像机，查看`LearningCurve`部分发生了什么变化！![图片](img/B17573_03_03.png)
- en: 'Figure 3.3: LearningCurve script component attached to the Main Camera'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：附加到主摄像机的LearningCurve脚本组件
- en: Since `CurrentAge` is now private, it's no longer visible in the **Inspector**
    window and can only be accessed within the `LearningCurve` script in code. If
    we click play, the script will still work exactly as it did before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAge`现在是私有的，它不再在**检查器**窗口中可见，只能在代码中的`LearningCurve`脚本中访问。如果我们点击播放，脚本仍然会像以前一样工作。
- en: This is a good start on our journey into variables, but we still need to know
    more about what kinds of data they can store. This is where data types come in,
    which we'll look at in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们变量之旅的良好开端，但我们仍然需要了解它们可以存储哪些类型的数据。这正是数据类型发挥作用的地方，我们将在下一节中探讨。
- en: Working with types
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与类型一起工作
- en: Assigning a specific type to a variable is an important choice, one that trickles
    down into every interaction a variable has over its entire lifespan. Since C#
    is what's called a *strongly-typed* or *type-safe* language, every variable has
    to have a data type without exception. This means that there are specific rules
    when it comes to performing operations with certain types, and regulations when
    converting a given variable type into another.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为变量指定特定类型是一个重要的选择，这个选择会渗透到变量在其整个生命周期中的每一次交互中。由于C#被称为*强类型*或*类型安全*的语言，每个变量都必须有一个数据类型，没有例外。这意味着在执行某些类型的操作时有一些特定的规则，以及将给定变量类型转换为另一种类型时的规定。
- en: Common built-in types
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用内置类型
- en: 'All data types in C# trickle down (or *derive*, in programmatic terms) from
    a common ancestor: `System.Object`. This hierarchy, called the **Common Type System**
    (**CTS**), means that different types have a lot of shared functionality. The
    following table lays out some of the most common data type options and the values
    they store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的所有数据类型都源自一个共同的祖先：`System.Object`。这个被称为**公共类型系统**（**CTS**）的层次结构意味着不同类型有很多共享的功能。以下表格列出了一些最常见的数据类型选项及其存储的值：
- en: '![](img/B17573_03_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4](img/B17573_03_04.png)'
- en: 'Figure 3.4: Common data types for variables'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：变量的常见数据类型
- en: 'In addition to specifying the kind of value a variable can store, types contain
    added information about themselves, including the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定变量可以存储的值的类型外，类型还包含有关自身的一些附加信息，包括以下内容：
- en: Required storage space
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需存储空间
- en: Minimum and maximum values
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小和最大值
- en: Allowed operations
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的操作
- en: Location in memory
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的位置
- en: Accessible methods
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问的方法
- en: Base (derived) type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础（派生）类型
- en: If this seems overwhelming, take a deep breath. Working with all of the types
    C# offers is a perfect example of using documentation over memorization. Pretty
    soon, using even the most complex custom types will feel like second nature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来令人不知所措，请深呼吸。处理C#提供的所有类型是使用文档而不是记忆的完美例子。很快，使用甚至最复杂的自定义类型将感觉像第二本能。
- en: You can find a complete list of all of the C# built-in types and their specifications
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index)找到所有C#内置类型及其详细说明的完整列表。
- en: Before the list of types becomes a sticking point, it's best to experiment with
    them. After all, the best way to learn something new is to use it, break it, and
    then learn to fix it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型列表成为难题之前，最好是尝试使用它们。毕竟，学习新事物的最佳方式是使用它，破坏它，然后学会修复它。
- en: 'Go ahead and open up `LearningCurve`and add a new variable for each type in
    the preceding chart from the *Common built-in types* section. The names and values
    you use are up to you; just make sure they''re marked as public so we can see
    them in the Inspector window. If you need inspiration, take a look at my code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请打开`LearningCurve`并从*常用内置类型*部分为前表中每种类型添加一个新变量。您使用的名称和值由您决定；只需确保它们被标记为public，这样我们就可以在检查器窗口中看到它们。如果您需要灵感，请查看我的代码：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When dealing with string types, the actual text value needs to be inside a pair
    of double quotes, while float values need to end with a lowercase `f`, as you
    can see with `FirstName` and `Pi`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串类型时，实际文本值需要放在一对双引号内，而浮点值需要以小写`f`结尾，例如`FirstName`和`Pi`所示。
- en: All our different variable types are now visible. Take note of the `bool` variable
    that Unity displays as a checkbox (true is checked and false is unchecked).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有不同变量类型现在都可见。请注意Unity显示为复选框的`bool`变量（true被选中，false未被选中）。
- en: '![](img/B17573_03_05.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5](img/B17573_03_05.png)'
- en: 'Figure 3.5: LearningCurve script component with common variable types'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：包含常见变量类型的LearningCurve脚本组件
- en: Remember, any variables you declare as private won't show up in the Inspector
    window. Before we move on to conversions, we need to touch on a common and powerful
    application of the string data type; namely, the creation of strings that have
    variables interspersed at will.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，任何你声明为私有的变量都不会出现在检查器窗口中。在我们继续讨论转换之前，我们需要提及字符串数据类型的一个常见且强大的应用；即创建任意位置插入变量的字符串。
- en: While number types behave as you'd expect from grade school math, strings are
    a different story. It's possible to insert variables and literal values directly
    into text by starting with a `$` character, which is called string interpolation.
    You've already used an interpolated string in your `LogFormat()` debugging; adding
    the `$` character lets you use them anywhere!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数字类型的表现符合你从小学数学中学到的预期，但字符串则另当别论。可以通过在文本中直接插入变量和字面量值，并在开头使用一个 `$` 字符来实现字符串插值，这被称为字符串插值。你已经在
    `LogFormat()` 调试中使用了插值字符串；添加 `$` 字符让你可以在任何地方使用它们！
- en: 'Let''s create a simple interpolated string of our own inside `LearningCurve`
    to see this in action. Print out the interpolated string inside the `Start()`
    method directly after `ComputeAge()` is called:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `LearningCurve` 中创建一个简单的插值字符串，以观察其作用。在调用 `ComputeAge()` 之后直接在 `Start()`
    方法中打印出插值字符串：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to the `$` character and curly brackets, the value of `FirstName` is
    treated as a value and is printed out inside the interpolated string. Without
    this special formatting, the string would just include `FirstName` as text instead
    of the variable value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `$` 字符和大括号，`FirstName` 的值被当作值处理，并在插值字符串中打印出来。如果没有这种特殊格式，字符串将只包含 `FirstName`
    作为文本，而不是变量值。
- en: '![](img/B17573_03_06.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_06.png)'
- en: 'Figure 3.6: Console showing debug log output'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：显示调试日志输出的控制台
- en: It's also possible to create interpolated strings using the `+` operator, which
    we'll talk about in the *Introducing operators* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `+` 运算符创建插值字符串，我们将在 *介绍运算符* 部分讨论这一点。
- en: Type conversions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'We''ve already seen that variables can only hold values of their declared types,
    but there will be situations where you''ll need to combine variables of different
    types. In programming terminology, these are called conversions, and they come
    in two main flavors:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到变量只能持有其声明类型的值，但会有需要组合不同类型变量值的情况。在编程术语中，这些被称为转换，并且主要有两种类型：
- en: '**Implicit** conversions take place automatically, usually when a smaller value
    will fit into another variable type without any rounding. For example, any integer
    can be implicitly converted into a `double` or `float` value without additional
    code:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式**转换会自动进行，通常是在一个较小的值可以无任何舍入地放入另一个变量类型时。例如，任何整数都可以隐式地转换为 `double` 或 `float`
    值，而无需额外的代码：'
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output in the **Console** pane can be seen in the following screenshot:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**控制台**面板中的输出可以在以下屏幕截图中看到：'
- en: '![](img/B17573_03_07.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17573_03_07.png)'
- en: 'Figure 3.7: Implicit type conversion debug log output'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：隐式类型转换调试日志输出
- en: '**Explicit** conversions are needed when there is a risk of losing a variable''s
    information during the conversion. For example, if we wanted to convert a `double`
    value into an `int` value, we would have to explicitly cast (convert) it by adding
    the destination type in parentheses before the value we want to convert.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当转换过程中有丢失变量信息的风险时，需要使用**显式**转换。例如，如果我们想将 `double` 类型的值转换为 `int` 类型的值，我们必须通过在要转换的值之前添加括号内的目标类型来显式地转换（转换）它。
- en: 'This tells the compiler that we are aware that data (or precision) might be
    lost:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这告诉编译器我们意识到数据（或精度）可能会在转换过程中丢失：
- en: '[PRE14]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this explicit conversion, `3.14` would be rounded down to `3`, losing the
    decimal values:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种显式转换中，`3.14` 将被舍入到 `3`，丢失小数部分：
- en: '![](img/B17573_03_08.png)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B17573_03_08.png)'
- en: 'Figure 3.8: Explicit type conversion debug log output'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：显式类型转换调试日志输出
- en: C# provides built-in methods for explicitly converting values to common types.
    For example, any type can be converted into a string value with the `ToString()`
    method, while the `Convert` class can handle more complicated conversions. You
    can find more info about these features under the *Methods* section at [https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C# 提供了内置方法来显式地将值转换为常见类型。例如，任何类型都可以使用 `ToString()` 方法转换为字符串值，而 `Convert` 类可以处理更复杂的转换。您可以在
    [https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2)
    的 *方法* 部分找到更多关于这些功能的信息。
- en: So far, we've learned that types have rules regarding their interactions, operations,
    and conversion, but how do we handle a situation where we need to store a variable
    of an unknown type? This might sound crazy, but think about a data-download scenario—you
    know the information is coming into your game, but you're not sure what form it
    will take. We'll discuss how to handle this in the following section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到类型在它们的交互、操作和转换方面有一些规则，但当我们需要存储未知类型的变量时，我们该如何处理这种情况呢？这听起来可能有些疯狂，但想想数据下载的场景——你知道信息正在进入你的游戏，但你不确定它将以什么形式出现。我们将在下一节中讨论如何处理这种情况。
- en: Inferred declarations
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断声明
- en: 'Luckily, C# can *infer* a variable''s type from its assigned value. For example,
    the `var` keyword can let the program know that the type of the data, `CurrentAge`,
    needs to be determined by its value of `32`, which is an integer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C# 可以从其分配的值中 *推断* 变量的类型。例如，`var` 关键字可以让程序知道数据类型 `CurrentAge` 需要根据其值 `32`（一个整数）来确定：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this is handy in certain situations, don't be suckered into the lazy programming
    habit of using inferred variable declarations for everything. This adds a lot
    of guesswork to your code, where it should be crystal clear.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在某些情况下很有用，但不要陷入使用推断变量声明来处理所有事情的懒惰编程习惯。这会给你的代码增加很多猜测，而它应该是清晰明了的。
- en: Before we wrap up our discussion on data types and conversion, we do need to
    briefly touch on the idea of creating custom types, which we'll do next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对数据类型和转换的讨论之前，我们确实需要简要地提及创建自定义类型的概念，我们将在下一部分进行。
- en: Custom types
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义类型
- en: When we're talking about data types, it's important to understand early on that
    numbers and words (referred to as *literal values*) are not the only kinds of
    values a variable can store. For instance, a class, struct, or enumeration can
    be stored as variables. We will introduce these topics in *Chapter 5*, *Working
    with Classes, Structs, and OOP*, and explore them in greater detail in *Chapter
    10*, *Revisiting Types, Methods, and Classes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据类型时，重要的是从一开始就理解，数字和单词（称为 *字面值*）并不是变量可以存储的唯一类型的值。例如，类、结构体或枚举可以作为变量存储。我们将在
    *第5章*，*使用类、结构体和面向对象编程* 中介绍这些主题，并在 *第10章*，*重新审视类型、方法和类* 中更详细地探讨它们。
- en: 'Types are complicated, and the only way to get comfortable with them is by
    using them. However, here are some important things to keep in mind:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型很复杂，唯一能够熟悉它们的方法就是使用它们。然而，以下是一些需要记住的重要事项：
- en: All variables need to have a specified type (be it explicit or inferred)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量都需要指定一个类型（无论是显式还是推断）
- en: Variables can only hold values of their assigned type (a `string` value can't
    be assigned an `int` variable)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量只能持有其分配类型的值（一个 `string` 值不能分配给 `int` 变量）
- en: If a variable needs to be assigned or combined with a variable of a different
    type, a conversion needs to take place (either implicit or explicit)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个变量需要与不同类型的变量赋值或组合，则需要执行转换（无论是隐式还是显式）
- en: The C# compiler can infer a variable's type from its value using the `var` keyword,
    but should only be used when the type isn't known when it's created
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编译器可以使用 `var` 关键字从变量的值中推断其类型，但只有在创建时类型未知的情况下才应使用
- en: That's a lot of nitty-gritty detail we've just jammed into a few sections, but
    we're not done yet. We still need to understand how naming conventions work in
    C#, as well as where the variables live in our scripts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在几个部分中详细介绍了许多细节，但我们还没有完成。我们仍然需要了解 C# 中的命名约定是如何工作的，以及变量在我们的脚本中的位置。
- en: Naming variables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量命名
- en: Picking names for your variables might seem like an afterthought in light of
    everything we've learned about access modifiers and types, but it shouldn't be
    a straightforward choice. Clear and consistent naming conventions in your code
    will not only make it more readable but will also ensure that other developers
    on your team understand your intentions without having to ask.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了访问修饰符和类型之后，为变量命名可能看起来像是事后考虑的事情，但它不应该是一个简单的选择。代码中的清晰和一致的命名约定不仅会使代码更易读，而且还能确保你的团队成员在不需要询问的情况下就能理解你的意图。
- en: 'The first rule when it comes to naming a variable is that the name you give
    it should be meaningful; the second rule is that you use Pascal case. Let''s take
    a common example from games and declare a variable to store a player''s health:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 命名变量的第一个规则是，你给它起的名字应该是具有意义的；第二个规则是使用 Pascal 风格。让我们以游戏中的一个常见例子为例，声明一个变量来存储玩家的生命值：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you find yourself declaring a variable like this, alarm bells should be going
    off in your head. Whose health? Is it storing the maximum or minimum value? What
    other code will be affected when this value changes? These are all questions that
    should be easily answered by a meaningful variable name; you don't want to find
    yourself confused by your code in a week or a month.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己声明变量是这样的，你应该在脑海中响起警钟。谁的健康？它是存储最大值还是最小值？当这个值改变时，哪些其他代码会受到什么影响？这些都是应该通过有意义的变量名轻松回答的问题；你不想在一周或一个月后发现自己被自己的代码搞糊涂。
- en: 'With that said, let''s try to make this a bit better using a Pascal case name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们尝试使用 Pascal 风格的命名来使它变得更好：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, Pascal case starts each word in the variable name with an uppercase
    letter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Pascal 风格的命名在每个单词的开头字母都要大写。
- en: That's much better. With a little thought, we've updated the variable name with
    meaning and context. Since there is no technical limit in terms of how long a
    variable name can be, you might find yourself going overboard and writing out
    ridiculously descriptive names, which will give you problems just as much as a
    short, non-descriptive name would.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就更好了。经过一番思考，我们用意义和上下文更新了变量名。由于在变量名长度方面没有技术限制，你可能会发现自己写出了过于详细的名字，这会给你带来和简短、不具描述性的名字一样的问题。
- en: As a general rule, make a variable name as descriptive as it needs to be—no
    more, no less. Find your style and stick to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，使变量名尽可能具有描述性——既不过多也不过少。找到你的风格并坚持下去。
- en: Understanding variable scope
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量作用域
- en: 'We''re getting to the end of our dive into variables, but there''s still one
    more important topic we need to cover: scope. Similar to access modifiers, which
    determine which outside classes can grab a variable''s information, the variable
    scope is the term used to describe where a given variable exists and its access
    point within its containing class.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将结束对变量的深入研究，但还有一个更重要的话题需要讨论：作用域。与确定哪些外部类可以获取变量信息的访问修饰符类似，变量作用域是用来描述给定变量在其包含类中存在的地方及其访问点的术语。
- en: 'There are three main levels of variable scope in C#:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中变量作用域主要有三个级别：
- en: '**Global** scope refers to a variable that can be accessed by an entire program;
    in this case, a game. C# doesn''t directly support global variables, but the concept
    is useful in certain cases, which we''ll cover in *Chapter 10*, *Revisiting Types,
    Methods, and Classes.*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**作用域指的是可以被整个程序访问的变量；在这种情况下，是一个游戏。C# 不直接支持全局变量，但在某些情况下，这个概念是有用的，我们将在 *第
    10 章*，*重新审视类型、方法和类* 中讨论。'
- en: '**Class** or **member** scope refers to a variable that is accessible anywhere
    in its containing class.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**或**成员**作用域指的是在其包含类中任何地方都可以访问的变量。'
- en: '**Local** scope refers to a variable that is only accessible inside the specific
    block of code it''s created in.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部**作用域指的是只在其创建的特定代码块内可以访问的变量。'
- en: 'Take a look at the following screenshot. You don''t need to put this into `LearningCurve`
    if you don''t want to; it''s only for visualization purposes at this point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图。如果你不想将其放入 `LearningCurve`，那就不用了；目前这只是为了可视化目的：
- en: '![](img/B17573_03_09.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_09.png)'
- en: 'Figure 3.9: Diagram of different scopes in the LearningCurve script'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：LearningCurve 脚本中不同作用域的示意图
- en: When we talk about code blocks, we're referring to the area inside any set of
    curly brackets. These brackets serve as a kind of visual hierarchy in programming;
    the farther right-indented they are, the deeper they are nested in the class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码块时，我们指的是任何一组花括号内的区域。这些括号在编程中充当一种视觉层次结构；它们越向右缩进，就越深地嵌套在类中。
- en: 'Let''s break down the class and local scope variables in the preceding screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下前面截图中的类和局部作用域变量：
- en: '`CharacterClass` is declared at the very top of the class, which means we can
    reference it by name anywhere inside `LearningCurve`. You might hear this concept
    referred to as variable visibility, which is a good way of thinking about it.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterClass` 在类的最顶部声明，这意味着我们可以在 `LearningCurve` 的任何地方通过名称引用它。你可能听说过这个概念被称为变量可见性，这是一个很好的思考方式。'
- en: '`CharacterHealth` is declared inside the `Start()` method, which means it is
    only visible inside that block of code. We can still access `CharacterClass` from
    `Start()` with no issue, but if we attempted to access `CharacterHealth` from
    anywhere but `Start()`, we would get an error.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterHealth` 在 `Start()` 方法中声明，这意味着它只在该代码块内部可见。我们仍然可以从 `Start()` 中无问题地访问
    `CharacterClass`，但如果尝试从 `Start()` 之外的地方访问 `CharacterHealth`，就会得到错误。'
- en: '`CharacterName` is in the same boat as `CharacterHealth`; it can only be accessed
    from the `CreateCharacter()` method. This was just to illustrate that there can
    be multiple, even nested, local scopes in a single class.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterName` 和 `CharacterHealth` 处于同一境地；它只能从 `CreateCharacter()` 方法中访问。这只是为了说明在单个类中可以有多个，甚至是嵌套的局部作用域。'
- en: 'If you spend enough time around programmers, you''ll hear discussions (or arguments,
    depending on the time of day) about the best place to declare a variable. The
    answer is simpler than you might think: variables should be declared with their
    use in mind. If you have a variable that needs to be accessed throughout a class,
    make it a class variable. If you only need a variable in a specific section of
    code, declare it as a local variable.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常和程序员在一起，你会听到关于最佳变量声明位置的讨论（或者根据时间可能是争论）。答案比你想象的要简单：变量应该根据其用途来声明。如果你有一个需要在整个类中访问的变量，就将其声明为类变量。如果你只需要在代码的特定部分使用变量，就将其声明为局部变量。
- en: Note that only class variables can be viewed in the Inspector window, which
    isn't an option for local or global variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有类变量可以在检查器窗口中查看，而局部或全局变量则没有这个选项。
- en: With naming and scope in our toolbox, let's transport ourselves back to middle
    school math class and relearn how arithmetic operations work all over again!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工具箱中有了命名和作用域之后，让我们回到中学的数学课堂，重新学习算术运算是如何工作的！
- en: Introducing operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍运算符
- en: Operator symbols in programming languages represent the *arithmetic*, *assignment*,
    *relational*, and *logical* functionality that types can perform. Arithmetic operators
    represent basic math functions, while assignment operators perform math and assignment
    functions together on a given value. Relational and logical operators evaluate
    conditions between multiple values, such as *greater than*, *less than*, and *equal
    to*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中的运算符符号代表类型可以执行的计算、赋值、关系和逻辑功能。算术运算符代表基本的数学函数，而赋值运算符则在给定的值上同时执行数学和赋值功能。关系和逻辑运算符评估多个值之间的条件，例如大于、小于和等于。
- en: C# also offers bitwise and miscellaneous operators, but these won't come into
    play for you until you're well on your way to creating more complex applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C# 还提供了位运算和杂项运算符，但直到你开始创建更复杂的应用程序，这些运算符才对你有用。
- en: At this point, it only makes sense to cover arithmetic and assignment operators,
    but we'll get to relational and logical functionality when it becomes relevant
    in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，只介绍算术和赋值运算符是有意义的，但当我们进入下一章并变得相关时，我们会讨论关系和逻辑功能。
- en: Arithmetic and assignments
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术和赋值
- en: 'You''re already familiar with the arithmetic operator symbols from school:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉了从学校学到的算术运算符符号：
- en: '`+` for addition'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+` 表示加法'
- en: '`-` for subtraction'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 表示减法'
- en: '`/` for division'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` 表示除法'
- en: '`*` for multiplication'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*` 表示乘法'
- en: 'C# operators follow the conventional order of operations, that is, evaluating
    parentheses first, then exponents, then multiplication, then division, then addition,
    and finally subtraction. For instance, the following equations will provide different
    results, even though they contain the same values and operators:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: C# 操作符遵循传统的运算顺序，即首先评估括号，然后是指数，然后是乘法，然后是除法，然后是加法，最后是减法。例如，以下等式将提供不同的结果，即使它们包含相同的值和操作符：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Operators work the same when applied to variables as they do with literal values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符在应用于变量时与应用于字面值时的行为相同。
- en: 'Assignment operators can be used as a shorthand replacement for any math operation
    by using any arithmetic and equals symbol together. For example, if we wanted
    to multiply a variable, you could use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何算术和等于符号的组合，将赋值操作符用作任何数学运算的简写替换。例如，如果我们想乘以一个变量，可以使用以下代码：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second, alternative, way to do this is shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作的第二种、替代方法如下所示：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The equals symbol is also considered an assignment operator in C#. The other
    assignment symbols follow the same syntax pattern as our preceding multiplication
    example: `+=`, `-=`, and `/=` for add and assign, subtract and assign, and divide
    and assign, respectively.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，等于符号也被视为赋值操作符。其他赋值符号遵循我们之前的乘法示例中的相同语法模式：`+=`、`-=` 和 `/=` 分别用于加和赋值、减和赋值以及除和赋值。
- en: 'Strings are a special case when it comes to operators as they can use the addition
    symbol to create patchwork text, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到操作符时，字符串是一个特殊情况，因为它们可以使用加号来创建拼贴文本，如下所示：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will produce the following when logged in to the **Console** panel:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 **控制台** 面板中记录时，这将产生以下结果：
- en: '![](img/B17573_03_10.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_03_10.png)'
- en: 'Figure 3.10: Using operators on strings'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10：在字符串上使用操作符
- en: This approach tends to produce clunky code, making string interpolation the
    preferred method for putting together different bits of text in most cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法往往会产生笨拙的代码，因此在大多数情况下，字符串插值是组合不同文本片段的首选方法。
- en: Take note that arithmetic operators don't work on all data types. For example,
    the `*` and `/` operators don't work on string values, and none of these operators
    work on Booleans. Having learned that types have rules that govern what kind of
    operations and interactions they can have, let's give it a shot in practice in
    the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，算术操作符并不适用于所有数据类型。例如，`*` 和 `/` 操作符不适用于字符串值，而且这些操作符都不适用于布尔值。了解了类型有规则来规范它们可以进行的操作和交互后，让我们在下一节中尝试一下实践操作。
- en: 'Let''s do a little experiment: we''ll try to multiply our `string` and `float`
    variables together, as we did earlier with our numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个小实验：我们将尝试将我们的 `string` 和 `float` 变量相乘，就像我们之前对数字所做的那样：
- en: '![](img/B17573_03_11.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_03_11.png)'
- en: 'Figure 3.11: Visual Studio incorrect type operation error message'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11：Visual Studio 错误类型操作错误信息
- en: Look at Visual Studio and you'll see we've got an error message letting us know
    that a `string` type and a `float` type can't be multiplied. This error will also
    show up in the Unity **Console**, and won't let the project build.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 Visual Studio，你会看到一个错误信息，告诉我们 `string` 类型和一个 `float` 类型不能相乘。这个错误也会在 Unity
    **控制台** 中显示，并且不允许项目构建。
- en: '![](img/B17573_03_12.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_03_12.png)'
- en: 'Figure 3.12: Console showing operator errors on incompatible data types'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：控制台显示不兼容数据类型上的操作符错误
- en: Whenever you see this type of error, go back and inspect your variable types
    for incompatibilities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到这种类型的错误时，请返回并检查你的变量类型是否存在不兼容性。
- en: We must clean up this example, as the compiler won't allow us to run our game
    at this point. Choose between a pair of backslashes (`//`) at the beginning of
    the line `Debug.Log(FirstName*Pi)`, or delete it altogether.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须清理这个例子，因为编译器不允许我们在这一点上运行我们的游戏。在 `Debug.Log(FirstName*Pi)` 行的开始选择一对反斜杠（`//`），或者完全删除它。
- en: That's as far as we need to go in terms of variables and types for the moment.
    Be sure to test yourself on this chapter's quiz before moving on!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们关于变量和类型的讨论就到这里。在继续之前，务必在章节测验中测试自己！
- en: Defining methods
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义方法
- en: In the previous chapter, we briefly touched on the role methods play in our
    programs; namely, that they store and execute instructions, just like variables
    store values. Now, we need to understand the syntax of method declarations and
    how they drive action and behavior in our classes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了方法在我们程序中的作用；即它们存储和执行指令，就像变量存储值一样。现在，我们需要了解方法声明的语法以及它们如何在我们的类中驱动动作和行为。
- en: 'As with variables, method declarations have their basic requirements, which
    are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法声明也有其基本要求，如下所示：
- en: The type of data that will be returned by the method
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法将返回的数据类型
- en: A unique name, starting with a capital letter
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个独特的名称，以大写字母开头
- en: A pair of parentheses following the method name
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称后跟一对括号
- en: A pair of curly brackets marking the method body (where instructions are stored)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对大括号标记方法体（其中存储指令）
- en: 'Putting all of these rules together, we get a simple method blueprint:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些规则放在一起，我们得到一个简单的方法蓝图：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the default `Start()` method in `LearningCurve` as a practical
    example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`LearningCurve`中的默认`Start()`方法作为一个实际例子来分解：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding output, we can see the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到以下内容：
- en: The method starts with the `void` keyword, which is used as the method's return
    type if it doesn't return any data.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法以`void`关键字开头，如果方法不返回任何数据，则用作方法的返回类型。
- en: The method has a unique name within the class. You can use the same name in
    different classes, but you should aim to always make your names unique no matter
    what.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在类中有唯一的名称。你可以在不同的类中使用相同的名称，但你应该始终努力使你的名称独特，无论什么情况。
- en: The method has a pair of parentheses after its name to hold any potential parameters.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法名称后有一对括号，用于包含任何潜在的参数。
- en: The method body is defined by a set of curly brackets.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法体由一组大括号定义。
- en: In general, if you have a method that has an empty method body, it's good practice
    to delete it from the class. You always want to be pruning your scripts of unused
    code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果你有一个方法体为空的方法，删除它是一个好的实践。你总是希望修剪掉脚本中未使用的代码。
- en: Like variables, methods can also have security levels. However, they can also
    have input parameters, both of which we'll be discussing next!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法也可以有安全级别。然而，它们也可以有输入参数，这两个问题我们将在下一节讨论！
- en: Declaring methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明方法
- en: Methods can also have the same four access modifiers that are available to variables,
    as well as input parameters. Parameters are variable placeholders that can be
    passed into methods and accessed inside them. The number of input parameters you
    can use isn't limited, but each one needs to be separated by a comma, show its
    data type, and have a unique name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有与变量相同的四种访问修饰符，以及输入参数。参数是变量占位符，可以传递到方法中并在其中访问。你可以使用的输入参数数量没有限制，但每个参数都需要用逗号分隔，显示其数据类型，并且具有唯一名称。
- en: Think of method parameters as variable placeholders whose values can be used
    inside the method body.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法参数想象成变量占位符，其值可以在方法体中使用。
- en: 'If we apply these options, our updated blueprint will look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用这些选项，我们的更新蓝图将看起来像这样：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is no explicit access modifier, the method defaults to private. A private
    method, like a private variable, cannot be called from other scripts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确的访问修饰符，则方法默认为私有。私有方法，就像私有变量一样，不能从其他脚本中调用。
- en: 'To call a method (meaning to run or execute its instructions), we simply use
    its name, followed by a pair of parentheses, with or without parameters, and cap
    it off with a semicolon:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个方法（即运行或执行其指令），我们只需使用其名称，然后跟上一对括号，其中可以包含或不包含参数，并以分号结尾：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like variables, every method has a fingerprint that describes its access level,
    return type, and parameters. This is called its method signature. Essentially,
    a method's signature marks it as unique to the compiler so Visual Studio knows
    what to do with it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，每个方法都有一个指纹，描述其访问级别、返回类型和参数。这被称为其方法签名。本质上，方法签名将方法标记为对编译器是唯一的，这样Visual Studio就知道如何处理它。
- en: Now that we understand how methods are structured, let's create one of our own.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了方法的构成，让我们自己创建一个。
- en: 'The *Methods are placeholders too* section in the previous chapter had you
    blindly copy a method called `ComputeAge()` into `LearningCurve` without you knowing
    what you were getting into. This time, let''s purposefully create a method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的“方法也是占位符”部分让你盲目地将名为`ComputeAge()`的方法复制到`LearningCurve`中，而你并不知道你将面临什么。这次，让我们有目的地创建一个方法：
- en: Declare a `public` method with a void return type called `GenerateCharacter():`
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`GenerateCharacter()`的`public`方法，返回类型为`void`：
- en: '[PRE26]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a simple `Debug.Log()` inside the new method and print out a character
    name from your favorite game or movie:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新方法中添加一个简单的`Debug.Log()`并打印出你喜欢的游戏或电影中的角色名称：
- en: '[PRE27]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call `GenerateCharacter()` inside the `Start()` method and hit play:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法中调用`GenerateCharacter()`并播放：
- en: '[PRE28]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the game starts up, Unity automatically calls `Start()`, which, in turn,
    calls our `GenerateCharacter()` method and prints the result to the Console window.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当游戏启动时，Unity会自动调用`Start()`，这反过来又调用我们的`GenerateCharacter()`方法并将结果打印到控制台窗口。
- en: If you have read enough documentation, you'll see different terminology related
    to methods. Throughout the rest of this book, when a method is created or declared,
    I'll refer to this as **defining** a method. Similarly, I'll refer to running
    or executing a method as **calling** that method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了足够的文档，你会看到与方法相关的一些不同术语。在这本书的其余部分，当创建或声明一个方法时，我会将其称为**定义**方法。同样，我会将运行或执行一个方法称为**调用**该方法。
- en: The power of naming is integral to the entirety of the programming landscape,
    so it shouldn't be a surprise that we're going to revisit naming conventions for
    methods before moving on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 命名的力量对于整个编程领域至关重要，因此在我们继续前进之前回顾命名规范对于方法来说并不令人惊讶。
- en: Naming conventions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名规范
- en: Like variables, methods need unique, meaningful names to distinguish them in
    code. Methods drive actions, so it's a good practice to name them with that in
    mind. For example, `GenerateCharacter()` sounds like a command, which reads well
    when you call it in a script, whereas a name such as `Summary()` is bland and
    doesn't paint a very clear picture of what the method will accomplish. Like variables,
    method names are written in Pascal case.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 和变量一样，方法需要独特、有意义的名称来在代码中区分它们。方法驱动动作，因此考虑到这一点命名它们是一个好习惯。例如，`GenerateCharacter()`听起来像是一个命令，当你在一个脚本中调用它时，读起来很好，而像`Summary()`这样的名字平淡无奇，并不能清楚地描绘出该方法将完成什么。
- en: Methods as logic detours
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法作为逻辑绕行
- en: We've seen that lines of code execute sequentially in the order they're written,
    but bringing methods into the picture introduces a unique situation. Calling a
    method tells the program to take a detour into the method instructions, run them
    one by one, and then resume sequential execution where the method was called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到代码行是按照它们书写的顺序顺序执行的，但是将方法引入画面引入了一个独特的情况。调用一个方法告诉程序进入方法指令，逐个运行它们，然后从方法被调用处继续顺序执行。
- en: 'Take a look at the following screenshot and see whether you can figure out
    in what order the debug logs will be printed out to the console:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图，看看你是否能弄清楚调试日志将按什么顺序打印到控制台：
- en: '![](img/B17573_03_13.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_13.png)'
- en: 'Figure 3.13: Considering the order of debug logs'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：考虑调试日志的顺序
- en: 'These are the steps that occur:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是发生的步骤：
- en: '`Choose a character` prints out first because it''s the first line of code.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`选择一个字符`首先打印出来，因为它是最先的代码行。'
- en: 'When `GenerateCharacter()` is called, the program jumps to line 23, prints
    out `Character: Spike`, and then resumes execution at line 17.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当调用`GenerateCharacter()`时，程序跳转到第23行，打印出`Character: Spike`，然后从第17行继续执行。'
- en: '`A fine choice` prints out last, after all the lines in `GenerateCharacter()`
    have finished running.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`A fine choice`在所有`GenerateCharacter()`中的行执行完毕后最后打印出来。'
- en: '![](img/B17573_03_14.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_14.png)'
- en: 'Figure 3.14: Console showing the output of character building code'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：显示角色构建代码输出的控制台
- en: Now, methods in themselves wouldn't be very useful beyond simple examples like
    these if we couldn't add parameter values to them, which is what we'll do next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们不能向方法中添加参数值，那么方法本身将不会在简单示例之外非常有用，这正是我们接下来要做的。
- en: Specifying parameters
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定参数
- en: 'Chances are your methods aren''t always going to be as simple as `GenerateCharacter()`.
    To pass in additional information, we''ll need to define parameters that our method
    can accept and work with. Every method parameter is an instruction and needs to
    have two things:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你的方法不会总是像 `GenerateCharacter()` 那么简单。为了传递更多信息，我们需要定义方法可以接受和处理参数。每个方法参数都是一个指令，并且需要有两个东西：
- en: An explicit type
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型
- en: A unique name
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一的名字
- en: Does this sound familiar? Method parameters are essentially stripped-down variable
    declarations and perform the same function. Each parameter acts like a local variable,
    only accessible inside their specific method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来熟悉吗？方法参数本质上是被简化的变量声明，并执行相同的功能。每个参数就像一个局部变量，只能在它们特定的方法内部访问。
- en: You can have as many parameters as you need. Whether you're writing custom methods
    or using built-in ones, the parameters that are defined are what the method requires
    to perform its specified task.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义任意数量的参数。无论是编写自定义方法还是使用内置方法，定义的参数就是方法执行指定任务所需的内容。
- en: 'If parameters are the blueprint for the types of values a method can accept,
    then arguments are the values themselves. To break this down further, consider
    the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是方法可以接受的值的类型的蓝图，那么参数就是这些值本身。为了进一步解释，考虑以下内容：
- en: The argument that's passed into a method needs to match the parameter type,
    just like a variable type and its value
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给方法的参数需要与参数类型匹配，就像变量类型和它的值一样
- en: Arguments can be literal values (for instance, the number 2) or variables declared
    elsewhere in the class
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数可以是字面值（例如，数字 2）或类中其他地方声明的变量
- en: Argument names and parameter names don't need to match to compile.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名和参数名不需要匹配即可编译。
- en: Now, let's move on and add some method parameters to make `GenerateCharacter()`
    a bit more interesting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进，添加一些方法参数，使 `GenerateCharacter()` 方法变得更加有趣。
- en: 'Let''s update `GenerateCharacter()` so that it can take in two parameters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `GenerateCharacter()` 方法，使其能够接受两个参数：
- en: 'Add two method parameters: one for a character''s name of the `string` type,
    and another for a character''s level of the `int` type:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个方法参数：一个用于角色的 `string` 类型名称，另一个用于角色的 `int` 类型等级：
- en: '[PRE29]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update `Debug.Log()` so that it uses these new parameters:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Debug.Log()` 以使用这些新参数：
- en: '[PRE30]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the `GenerateCharacter()` method call in `Start()` with your arguments,
    which can be either literal values or declared variables:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Start()` 中更新 `GenerateCharacter()` 方法的调用，使用你的参数，这些参数可以是字面值或类中其他地方声明的变量：
- en: '[PRE31]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Your code should look like the following:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的代码应该看起来像以下这样：
- en: '![](img/B17573_03_15.png)'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17573_03_15.png)'
- en: 'Figure 3.15: Updating the GenerateCharacter() method'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.15：更新 GenerateCharacter() 方法
- en: Here, we defined two parameters, `name` (string) and `level` (int), and used
    them inside the `GenerateCharacter()` method, just like local variables. When
    we called the method inside `Start()`, we added argument values for each parameter
    with corresponding types. In the preceding screenshot, you can see that using
    the literal string value in quotations produced the same result as using `characterLevel`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个参数，`name`（字符串类型）和 `level`（整型），并在 `GenerateCharacter()` 方法内部使用它们，就像局部变量一样。当我们调用
    `Start()` 方法内部的该方法时，我们为每个参数添加了相应的类型和参数值。在先前的屏幕截图中，你可以看到使用引号中的字面字符串值和使用 `characterLevel`
    产生了相同的结果。
- en: '![](img/B17573_03_16.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17573_03_16.png)'
- en: 'Figure 3.16: Console showing the output from method parameters'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：控制台显示方法参数的输出
- en: Going even further with methods, you might be wondering how we can pass values
    from inside the method and back out again. This brings us to our next section
    on return values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中进一步使用方法，你可能想知道我们如何从方法内部传递值并返回。这引出了我们下一个关于返回值的章节。
- en: Specifying return values
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定返回值
- en: Aside from accepting parameters, methods can return values of any C# type. All
    of our previous examples have used the `void` type, which doesn't return anything,
    but being able to write instructions and pass back computed results is where methods
    shine.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了接受参数外，方法还可以返回任何 C# 类型的值。我们之前的所有示例都使用了 `void` 类型，它不返回任何内容，但能够编写指令并返回计算结果正是方法的优势所在。
- en: According to our blueprints, method return types are specified after the access
    modifier. In addition to the type, the method needs to contain the `return` keyword,
    followed by the return value. A return value can be a variable, a literal value,
    or even an expression, as long as it matches the declared return type.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的蓝图，方法返回类型在访问修饰符之后指定。除了类型之外，方法还需要包含 `return` 关键字，后面跟着返回值。返回值可以是变量、字面值，甚至是表达式，只要它与声明的返回类型匹配。
- en: Methods that have a return type of `void` can still use the return keyword with
    no value or expression assigned. Once the line with the return keyword is reached,
    the method will stop executing. This is useful in cases where you want to avoid
    certain behaviors or guard against program crashes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型为 `void` 的方法仍然可以使用 `return` 关键字，而不需要分配任何值或表达式。一旦达到带有 `return` 关键字的行，方法将停止执行。这在需要避免某些行为或防止程序崩溃的情况下很有用。
- en: 'Next, add a return type to `GenerateCharacter()` and learn how to capture it
    in a variable. Let''s update the `GenerateCharacter()` method so that it returns
    an integer:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向 `GenerateCharacter()` 添加返回类型，并学习如何将其捕获到变量中。让我们更新 `GenerateCharacter()`
    方法，使其返回一个整数：
- en: 'Change the return type in the method declaration from `void` to `int`, and
    set the return value to `level += 5` using the `return` keyword:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法声明中的返回类型从 `void` 更改为 `int`，并使用 `return` 关键字将返回值设置为 `level += 5`：
- en: '[PRE32]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`GenerateCharacter()` will now return an integer. This is computed by adding
    `5` to the level argument. We haven''t specified how, or if, we want to use this
    return value, which means that right now, the script won''t do anything new.'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GenerateCharacter()` 现在将返回一个整数。这是通过将 `5` 添加到级别参数来计算的。我们没有指定如何或是否要使用这个返回值，这意味着现在脚本不会做任何新的操作。'
- en: 'Now, the question becomes: how do we capture and use the newly added return
    value? Well, we''ll discuss that very topic in the following section.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题变成了：我们如何捕获和使用新添加的返回值？嗯，我们将在下一节中讨论这个话题。
- en: Using return values
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用返回值
- en: 'When it comes to using return values, there are two approaches available:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到使用返回值时，有两种方法可供选择：
- en: Create a local variable to capture (store) the returned value.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个局部变量来捕获（存储）返回值。
- en: Use the calling method itself as a stand-in for the returned value, using it
    just like a variable. The calling method is the actual line of code that fires
    the instructions, which, in our example, would be `GenerateCharacter("Spike",
    CharacterLevel)`. You can even pass a calling method into another method as an
    argument if need be.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用方法本身用作返回值的替身，就像使用变量一样使用它。调用方法是实际触发指令的实际代码行，在我们的例子中，将是 `GenerateCharacter("Spike",
    CharacterLevel)`。如果需要，你甚至可以将调用方法作为参数传递给另一个方法。
- en: The first option is preferred in most programming circles for its readability.
    Throwing around method calls as variables can get messy fast, especially when
    we use them as arguments in other methods.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程领域，首选第一种方法，因为它易于阅读。将方法调用作为变量随意使用会很快变得混乱，尤其是在我们将它们用作其他方法的参数时。
- en: Let's give this a try in our code by capturing and debugging the return value
    that `GenerateCharacter()` returns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中尝试通过捕获和调试 `GenerateCharacter()` 返回的返回值来验证这一点。
- en: 'We''re going to use both ways of capturing and using return variables with
    two simple debug logs:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种捕获和使用返回变量的方式，通过两个简单的调试日志：
- en: 'Create a new local variable in the `Start` method of the `int` type, called
    `NextSkillLevel`, and assign it to the return value of the `GenerateCharacter()`
    method call we already have in place:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Start` 方法中创建一个新的局部变量，类型为 `int`，名为 `NextSkillLevel`，并将其赋值给现有的 `GenerateCharacter()`
    方法调用返回值：
- en: '[PRE33]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add two debug logs, with the first printing out `NextSkillLevel` and the second
    printing out a new calling method with argument values of your choice:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个调试日志，第一个打印出 `NextSkillLevel`，第二个打印出你选择的参数值的新调用方法：
- en: '[PRE34]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Comment out the debug log inside `GenerateCharacter()` with two forward slashes
    (`//`) to make the console output less cluttered. Your code should look like the
    following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个反斜杠 (`//`) 注释掉 `GenerateCharacter()` 中的调试日志，以使控制台输出更简洁。你的代码应该看起来像以下这样：
- en: '[PRE35]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the file and hit play in Unity. To the compiler, the `NextSkillLevel` variable
    and the `GenerateCharacter()` method caller represent the same information, namely
    an integer, which is why both logs show the number `37`:![](img/B17573_03_17.png)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在 Unity 中播放。对于编译器来说，`NextSkillLevel` 变量和 `GenerateCharacter()` 方法的调用者代表相同的信息，即一个整数，这就是为什么两个日志都显示了数字
    `37`：![](img/B17573_03_17.png)
- en: 'Figure 3.17: Console output from the character generation code'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 3.17：角色生成代码的控制台输出
- en: That was a lot to take in, especially given the exponential possibilities of
    methods with parameters and return values. However, we'll ease off the throttle
    here for a minute and consider some of Unity's most common methods to catch a
    little breathing room.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要吸收很多内容，尤其是考虑到具有参数和返回值的方法的指数级可能性。然而，在这里我们先放慢速度，考虑一下 Unity 中一些最常见的方法，以便我们能够稍微喘口气。
- en: But first, see if you can handle a challenge in the next *Hero's trial*!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，看看你是否能应对接下来的 *英雄试炼* 中的挑战！
- en: Hero's trial – methods as arguments
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄试炼 – 方法作为论据
- en: If you're feeling brave, why not try creating a new method that takes in an
    `int` parameter and simply prints it out to the console? No return type is necessary.
    When you've got that, call the method in `Start`, pass in a `GenerateCharacter`
    method call as its argument, and take a look at the output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感到勇敢，为什么不尝试创建一个新的方法，该方法接受一个 `int` 参数，并将其简单地打印到控制台上？不需要返回类型。当您完成这个任务后，在 `Start`
    中调用该方法，将其作为参数传递 `GenerateCharacter` 方法调用，并查看输出。
- en: Dissecting common Unity methods
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析常见的 Unity 方法
- en: 'We''re now at a point where we can realistically discuss the most common default
    methods that come with any new Unity C# script: `Start()` and `Update()`. Unlike
    the methods we define ourselves, methods belonging to the `MonoBehaviour` class
    are called automatically by the Unity engine according to their respective rules.
    In most cases, it''s important to have at least one `MonoBehaviour` method in
    a script to kick off your code.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以现实地讨论任何新的 Unity C# 脚本附带的最常见的默认方法：`Start()` 和 `Update()`。与我们自己定义的方法不同，属于
    `MonoBehaviour` 类的方法是由 Unity 引擎根据其各自的规则自动调用的。在大多数情况下，在脚本中至少有一个 `MonoBehaviour`
    方法来启动您的代码是很重要的。
- en: You can find a complete list of all available MonoBehaviour methods and their
    descriptions at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    You can also find the order in which each method is executed at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)
    找到所有可用的 MonoBehaviour 方法及其描述的完整列表。您还可以在 [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)
    找到每个方法执行的顺序。
- en: Just like stories, it's always a good idea to start at the beginning. So, naturally,
    we should take a look at every Unity script's first default method—`Start()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就像故事一样，从开始的地方开始总是个好主意。因此，我们自然应该查看每个 Unity 脚本的第一默认方法——`Start()`。
- en: The Start method
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Start 方法
- en: Unity calls the `Start()` method on the first frame where a script is enabled
    for the first time. Since `MonoBehaviour` scripts are almost always attached to
    *GameObjects* in a scene, their attached scripts are enabled at the same time
    they are loaded when you hit play. In our project, `LearningCurve`is attached
    to the **Main Camera** *GameObject*, which means that its `Start()` method runs
    when the main camera is loaded into the scene. `Start()` is primarily used to
    set up variables or perform logic that needs to happen before `Update()` runs
    for the first time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 在脚本首次启用时，会在第一帧调用 `Start()` 方法。由于 `MonoBehaviour` 脚本几乎总是附加到场景中的 *GameObjects*
    上，因此当您按下播放时，它们附加的脚本会在加载时同时启用。在我们的项目中，`LearningCurve` 附加到 **主摄像机** *GameObject*
    上，这意味着当主摄像机被加载到场景中时，它的 `Start()` 方法就会运行。`Start()` 主要用于设置变量或执行需要在 `Update()` 首次运行之前发生的逻辑。
- en: The examples we've worked on so far have all used `Start()`, even though they
    weren't performing setup actions, which isn't normally the way it would be used.
    However, it only fires once, making it an excellent tool to use for displaying
    one-time-only information on the console.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所做的工作示例都使用了 `Start()`，即使它们没有执行设置操作，这通常不是它的常规用法。然而，它只触发一次，这使得它成为在控制台上显示一次性信息的绝佳工具。
- en: 'Other than `Start()`, there''s one other major Unity method that you''ll run
    into by default: `Update()`. Let''s familiarize ourselves with how it works in
    the following section before we finish off this chapter.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Start()` 之外，还有一个主要的 Unity 方法，您会默认遇到：`Update()`。在我们完成本章之前，让我们熟悉一下它在以下部分是如何工作的。
- en: The Update method
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Update 方法
- en: If you spend enough time looking at the sample code in the Unity Scripting Reference
    ([https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)),
    you'll notice that a vast majority of the code is executed using the `Update()`
    method. As your game runs, the Scene window is displayed many times per second,
    which is called the frame rate or **frames per second** (**FPS**).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你花足够的时间查看 Unity 脚本参考中的示例代码（[https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/))，你会注意到大部分代码都是使用
    `Update()` 方法执行的。当你的游戏运行时，场景窗口每秒显示多次，这被称为帧率或 **每秒帧数**（**FPS**）。
- en: After each frame is displayed, the `Update()` method is called by Unity, making
    it one of the most executed methods in your game. This makes it ideal for detecting
    mouse and keyboard input or running gameplay logic.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个帧显示后，Unity 会调用 `Update()` 方法，这使得它成为你游戏中执行次数最多的方法之一。这使得它非常适合检测鼠标和键盘输入或运行游戏逻辑。
- en: 'If you''re curious about the FPS rating on your machine, hit play in Unity
    and click the **Stats** tab in the upper-right corner of the **Game** view:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解你机器上的 FPS 评分，在 Unity 中播放并点击 **游戏** 视图右上角的 **统计** 选项卡：
- en: '![](img/B17573_03_18.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_18.jpg)'
- en: 'Figure 3.18: Unity editor showing the Stats panel with graphics FPS count'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：Unity 编辑器显示带有图形 FPS 计数的统计面板
- en: You'll be using the `Start()` and `Update()` methods in the lion's share of
    your initial C# scripts, so get acquainted with them. That being said, you've
    reached the end of this chapter with a pocketful of the most fundamental building
    blocks programming with C# has to offer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在大部分初始的 C# 脚本中使用 `Start()` 和 `Update()` 方法，所以熟悉它们。话虽如此，你已经带着一袋 C# 编程最基础的构建块结束了这一章。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has been a fast descent from the basic theory of programming and
    its building blocks into the strata of real code and C# syntax. We've seen good
    and bad forms of code formatting, learned how to debug information in the Unity
    console, and created our first variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从编程的基本理论和其构建块快速下降到真实代码和 C# 语法层面。我们看到了代码格式的优劣，学习了如何在 Unity 控制台中调试信息，并创建了我们的第一个变量。
- en: C# types, access modifiers, and variable scope weren't far behind, as we worked
    with member variables in the Inspector window and started venturing into the realm
    of methods and actions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: C# 类型、访问修饰符和变量作用域也紧随其后，因为我们开始在检查器窗口中处理成员变量，并开始探索方法和动作的领域。
- en: Methods helped us to understand written instructions in code, but more importantly,
    how to properly harness their power into useful behaviors. Input parameters, return
    types, and method signatures are all important topics, but the real gift they
    offer is the potential for new kinds of actions to be performed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 方法帮助我们理解代码中的书面指令，但更重要的是，如何正确地利用它们的威力来实现有用的行为。输入参数、返回类型和方法签名都是重要的话题，但它们真正提供的礼物是执行新类型动作的潜力。
- en: You're now armed with the two fundamental building blocks of programming; almost
    everything you'll do from now on will be an extension or application of these
    two concepts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经拥有了编程的两个基本构建块；从现在开始，你几乎所做的一切都将是对这两个概念的扩展或应用。
- en: In the next chapter, we'll take a look at a special subset of C# types called
    collections, which can store groups of related data, and learn how to write decision-based
    code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 C# 类型的一个特殊子集，称为集合，它可以存储相关数据组，并学习如何编写基于决策的代码。
- en: Pop quiz – variables and methods
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 - 变量和方法
- en: What is the proper way to write a variable name in C#?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 C# 中如何正确地编写变量名？
- en: How do you make a variable appear in Unity's Inspector window?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 Unity 的检查器窗口中使变量可见？
- en: What are the four access modifiers available in C#?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C# 中有四种访问修饰符可用吗？
- en: When are explicit conversions needed between types?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下需要在类型之间进行显式转换？
- en: What are the minimum requirements for defining a method?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义方法的最小要求是什么？
- en: What is the purpose of the parentheses at the end of the method name?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法名末尾的括号有什么作用？
- en: What does a return type of `void` mean in a method definition?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法定义中 `void` 返回类型意味着什么？
- en: How often is the `Update()` method called by Unity?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity 多频繁地调用 `Update()` 方法？
- en: JOIN us on Discord!
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家和哈里森·费罗尼一起阅读这本书。提问，为其他读者提供解决方案，通过 *Ask Me Anything* 会话与作者聊天等等。
- en: Join Now!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
