- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Harmonious Soundscapes: Integrating Audio and Music'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now achieved good enough graphics quality, but we are missing an important
    part of the game aesthetics: the sound. Often relegated to being the last step
    in game development, sound is one of those things that, if it’s there, you won’t
    notice its presence, but if you don’t have it, you will feel that something is
    missing. It will help you to reinforce the ambiance you want in your game and
    must match the graphical setting. To do so, we will use Unity’s capabilities to
    import audio assets, play them in 2D and 3D positioning, and mix the audio using
    its mixer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following sound concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating and mixing audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will apply those concepts in our game to import the audio to play in different
    scenarios—such as when the player shoots—and music. Later in the programming chapters,
    we will play sounds, but for now, let’s focus on how to import them into our project.
  prefs: []
  type: TYPE_NORMAL
- en: Importing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with graphic assets, it is important to properly set up the import settings
    for your audio assets, as imports can be resource-intensive if not done properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following audio-importing concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Audio types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring import settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by discussing the different kinds of audio we can use.
  prefs: []
  type: TYPE_NORMAL
- en: Audio types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different types of audio present in video games, which are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Music**: Music is used to enhance the player’s experience according to the
    situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sound effects (SFX)**: Sounds that happen as a reaction to player or NPC
    actions, such as clicking a button, walking, opening a door, shooting a gun, and
    so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambient sound**: A game that uses sounds only in response to events would
    feel empty. If you are recreating an apartment in the middle of the city, even
    if the player is just idle in the middle of the room doing nothing, lots of sounds
    should be heard, and the sources of most of them will be outside the room, such
    as an airplane flying overhead, a construction site two blocks away, cars in the
    street, and so on. Creating objects like the ones mentioned before that won’t
    be seen by the player is a waste of resources. Instead, we can place individual
    sounds all over the scene to recreate the desired ambiance, but that would be
    resource-intensive, requiring lots of CPU and RAM to achieve believable results.
    Considering that these sounds usually occupy the second plane of the user’s attention,
    we can just combine them all into a single looping track and play one audio file,
    and that’s exactly what ambient sound is. If you want to create a café scene,
    you can simply go to a real café and record a few minutes of audio, using that
    as your ambient sound.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For almost all games, we will need at least one music track, one ambient track,
    and several SFX to start the production of the audio. As always, we have different
    sources of audio assets, but we will use the Asset Store. It has three audio categories
    to search for the assets we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a phone  Description automatically generated with low confidence](img/B21361_14_01_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Audio categories in the Asset Store'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, I also used the search bar to further filter the categories, searching
    for `weather` to find a rain effect. Sometimes, you can’t find the exact audio
    separately; in such cases, you will need to dig into **Packs** and **Libraries**,
    so have patience here. In my case, I picked the three packages you can see in
    *Figure 14.2* but imported just some of the sounds included, as all of them would
    weigh a lot in the project in terms of size. For ambiance, I picked a rain sound
    file called `Ambience_Rain_Moderate_01_LOOP` in the case of this package, but
    the name of the rain sound we are looking for could be different if you downloaded
    another package. Then, I picked **Music – Sad Hope** for music, and for SFX, I
    picked one gun sound effect package for our future player’s hero character. Of
    course, you can pick other packages to better suit your game’s needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a music album  Description automatically generated with medium
    confidence](img/B21361_14_02_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: The packages for our game'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the necessary audio packages, let’s discuss how to import them.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring import settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have several import settings we can tweak, but the problem is that we need
    to consider the usage of the audio to properly set it up, so let’s see the ideal
    settings for each case. In order to see the import settings, as always, you can
    select the asset and see it in the **Inspector** panel, as in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_03_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: Audio import settings'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the most important ones, starting with **Force To Mono**. Some
    audio may come with stereo channels, meaning that we have one sound playing in
    the left ear and another one in the right ear. This means that one piece of audio
    can actually contain two different audio tracks. Stereo sound is useful for different
    effects and instrument spatialization in the case of music, so we want that in
    those scenarios, but there are other scenarios where mono audio is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Consider 3D sound effects such as a shooting gun or some walking-pace steps.
    In those cases, we need the sound to be heard in the direction of the source—if
    the shooting of a gun happened to my left, I need to hear it coming from my left.
    In these cases, we can convert stereo audio to mono audio by checking the **Force
    To Mono** checkbox in the audio import settings. This will make Unity combine
    the two channels into a single one, usually reducing the audio to almost half
    its size (sometimes more, sometimes less, depending on various aspects).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the impact of that and other settings at the bottom of the audio
    asset Inspector, where you can see the imported audio size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, number, font  Description automatically
    generated](img/B21361_14_04_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: Top: audio imported without Force To Mono. Bottom: same audio
    with Force To Mono'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next setting to discuss, and an important one at that, is **Load Type**.
    In order to play some audio, Unity needs to read the audio from the disk, decompress
    it, and then play it. **Load Type** changes the way those three processes are
    handled. We have the following three options here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decompress On Load**: The most memory-intensive option. This mode will make
    Unity load the audio uncompressed in memory when the scene is loaded. That means
    that the audio will take up lots of space in RAM because we have the uncompressed
    version loaded. The advantage of using this mode is that playing the audio is
    easier because we have the raw audio data ready to play in RAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming**: The total opposite of **Decompress On Load**. This mode never
    loads audio in RAM. Instead, while the audio is playing, Unity reads a piece of
    the audio asset from the disk, decompresses it, plays it, and repeats, running
    this process once for each piece of audio playing in **Streaming**. This means
    that this mode will be CPU-intensive but will consume almost zero bytes of RAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed in Memory**: The middle ground. This mode will load the audio
    from the disk when the scene is loaded but will keep it compressed in memory.
    When Unity needs to play the audio, it will just take a piece from the RAM, decompress
    it, and play it. Remember that reading pieces of the audio asset from RAM is considerably
    faster than reading from disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maybe, if you are an experienced developer, you can easily determine which
    mode is better suited for which kind of audio, but if this is your first encounter
    with video games, it may sound confusing. So, let’s discuss the best modes for
    different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequent short audio**: This could be a shooting gun or the sound of footsteps,
    which are sounds that last less than one second but can occur in several instances
    and play at the same time. In such cases, we can use **Decompress On Load**. Uncompressed
    short audio won’t have a huge size difference from its compressed version. Also,
    since this is the most performant CPU option, having several instances won’t have
    a huge impact on performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrequent large audio**: This includes music, ambient sound, and dialog.
    These kinds of audio usually have just one instance playing, and they are usually
    big. Those cases are better suited for **Streaming** mode because having them
    compressed or decompressed in RAM can have a huge impact on RAM consumption in
    low-end devices such as mobile devices (on PCs, we can use **Compressed in Memory**
    sometimes). A CPU can handle having two or three bits of audio playing in Streaming
    mode but try to have no more than that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequent medium audio**: This includes pre-made voice chat dialog in multiplayer
    games, character emotes, long explosions, or any audio that is more than 500 KB
    (that is not a strict rule—this number depends a lot on the target device). Having
    this kind of audio decompressed in RAM can have a noticeable impact on performance,
    but due to the fact that this audio is fairly frequently used, we can have it
    compressed in memory. Their relatively small size means they usually won’t make
    a huge difference in our game’s overall size, and we will avoid wasting CPU resources
    on reading from disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other cases to consider, but those can be extrapolated based on the
    previous ones. Remember that the previous analysis was made by taking into account
    the requirements of the standard game, but this can vary a lot according to your
    game and your target device. Maybe you are making a game that won’t consume lots
    of RAM but is pretty intensive in terms of CPU resources, in which case you can
    just put everything in **Decompress On Load**. It’s important to consider all
    aspects of your game and to balance your resources accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, another thing to consider is the compression format, which will change
    the way Unity will encode the audio in the published game. Different compression
    formats will give different compression ratios in exchange for less fidelity with
    the original audio or higher decompression times, and all this varies a lot based
    on the audio patterns and length. We have three compression formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PCM**: The uncompressed format will give you the highest audio quality, with
    no noise artifacts, but will result in a bigger asset file size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADPCM**: Compressing audio this way reduces file size and yields a fast,
    uncompressing process, but this can introduce noise artifacts that can be noticeable
    in certain types of audio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vorbis**: A high-quality compression format that will yield almost zero artifacts
    but takes longer to decompress, so playing Vorbis audio will be slightly more
    intensive than for other formats. It also provides a quality slider to select
    the exact amount of compression aggressiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which one should you use? Again, that depends on the features of your audio.
    Short, smooth audio can use **PCM**, while long, noisy audio can use **ADPCM**;
    the artifacts introduced by this format will be hidden in the audio itself. Maybe
    long, smooth audio where compression artifacts are noticeable could benefit from
    using Vorbis. Sometimes, it’s just a matter of trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe use Vorbis by default, and when performance is reduced, try to switch
    to **ADPCM**. If that causes glitches, just switch to **PCM**. Of course, the
    problem here is being sure that the audio processing is really what’s responsible
    for the performance issues—maybe switching all audio to **ADPCM** and checking
    whether that made a difference is a good way to detect that, but a better approach
    would be to use the Profiler, a performance measurement tool that we will see
    later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have other settings, such as **Sample Rate Setting**, that, again with a
    little trial and error, you can use to detect the best setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have set up the audio that I downloaded from the Asset Store, as you can
    see in *Figures 14.5* and *14.6*. The first one shows how I set up the music and
    ambient audio files (large files):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_05_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: Music and ambient settings'
  prefs: []
  type: TYPE_NORMAL
- en: The music files, which are large in size, should be configured as stereo (with
    **Force To Mono** left unchecked) and set to use **Streaming** as the Load Type
    since only one instance of them will be playing at a time. For the Compression
    Format, choose **ADPCM**, as using Vorbis did not significantly reduce the file
    size in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This second screenshot shows how I set up the SFX files (small files):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_06_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: Shooting SFX settings'
  prefs: []
  type: TYPE_NORMAL
- en: The sounds we downloaded will be 3D, so **Force To Mono** should be checked.
    They will also be short, so the **Load Type** named **Decompress On Load** works
    better. Finally, choosing **Vorbis** for **Compression Format** reduced the **ADPCM**
    size by more than half, which is why we picked it.
  prefs: []
  type: TYPE_NORMAL
- en: Once, I was hired by a team that needed to deliver a project the next day but
    had constant issues with certain audio clips not playing on an iPad 1 (yes, this
    happened a long time ago). They had long, heavy dialogs that were configured to
    use **Load Type** in **Decompress On** Load mode. I just switched to **streaming**
    mode, as those dialogs were played one at a time, fixed the issue, and managed
    to go home early that day. On another occasion, a similar fix applied to the main
    music audio clip of a game reduced loading times from 12 seconds to 5 seconds
    on slow mobile devices. Never underestimate the cost of badly configured audio.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our pieces of audio properly configured, we can start to use
    them in our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating and mixing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can just drag our bits of audio into our scene to start using them, but we
    can dig a little bit further to explore the best ways to configure them to each
    possible scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine the following audio integration concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Using 2D and 3D AudioSources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using audio mixers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start exploring AudioSources, objects that are in charge of audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: Using 2D and 3D AudioSources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AudioSources** are components that can be attached to GameObjects. They are
    responsible for emitting sound in our game based on **AudioClips**, which are
    the audio assets we downloaded previously.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to differentiate an AudioClip from an **AudioSource**; we can
    have a single explosion AudioClip but lots of AudioSources playing it, simulating
    several explosions. An AudioSource can be seen as a CD player that can play AudioClips
    (our CDs in this analogy), only with the exception that we can have several CD
    players or AudioSources playing the same CD at the same time (for example, two
    explosion sounds playing at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create an **AudioSource** is to pick an **AudioClip** (an
    audio asset) and drag it to the **Hierarchy** window. Try to avoid dragging the
    audio into an existing object; instead, drag it between objects so Unity will
    create a new object with the **AudioSource** instead of adding it to an existing
    object (sometimes, you want an existing object to have the **AudioSource**, but
    let’s keep things simple for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_07_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: Dragging an AudioClip to the Hierarchy window between objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **AudioSource** generated by dragging the
    music asset to the scene. You can see that the **AudioClip** field has a reference
    to the dragged audio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated](img/B21361_14_08_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: AudioSource configured to play our music asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the **AudioSource** has several settings, so let’s review the
    common ones in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Play on Awake**: Determines whether the audio starts playing automatically
    when the game starts. We can uncheck that and play the audio via scripting, perhaps
    when the player shoots or jumps (more on that in *Section 3*, *Elevating Visuals,
    Effects, and Audio of the book*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: This will make the audio repeat automatically when it finishes playing.
    Remember to always check this setting on the music and ambient audio clips. It
    is easy to forget this because those tracks are long, and we may never reach the
    end of them in our tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume**: Controls the audio intensity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitch**: Controls the audio velocity. This is useful for simulating effects
    such as slow motion or the increasing revolutions of an engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spatial Blend**: Controls whether our audio is 2D or 3D. In 2D mode, the
    audio will be heard at the same volume at all distances, while 3D will make the
    audio volume decrease as the distance from the Camera (or whichever GameObject
    is holding the AudioListener component) increases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of our music track, I have configured it as shown in the following
    screenshot. You can drag the ambient rain sound to add it to the scene and use
    the same settings as these because we want the same ambient effect in all our
    scenes. In complex scenes, though, you can have different 3D ambient sounds scattered
    all over the scene to change the sound according to the current environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_09_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: Music and ambient settings. This will loop, is set to Play on
    Awake, and is 2D'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can drag the shooting effect and configure it, as shown in *Figure
    14.10*. As you can see, the audio, in this case, won’t loop because we want the
    shooting effect to play once per bullet. Remember that, for our game, the bullet
    will be a Prefab that will spawn each time we press the shoot key, so each bullet
    will have its own **AudioSource** that will play when the bullet is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the bullet has **Spatial Blend** set to **3D**, meaning that the effect
    will be transmitted through different speakers based on the position of the **AudioSource**
    against the camera position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a music player  Description automatically generated with
    low confidence](img/B21361_14_10_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: Sound effect setting. This won’t loop and is a 3D sound'
  prefs: []
  type: TYPE_NORMAL
- en: Something to consider in the case of 3D sounds is the **Volume Rolloff** setting,
    which is inside the **3D Sound Settings** section. This setting controls how the
    volume decays as the distance from the camera increases. By default, you can see
    that this setting is set to **Logarithmic Rolloff**, the way real-life sound works,
    but sometimes you don’t want real-life sound decay because sounds in real life
    are usually heard slightly, even if the source is very far away.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to switch to **Linear Rolloff** and configure the exact maximum
    distance with the **Max Distance** setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_11_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: A 3D sound with a maximum distance of 10 meters, using Linear
    Rolloff'
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering we just discussed 3D sounds, it is worth mentioning the **AudioListener**
    component, one that is created by default in the **MainCamera**, and 99% of the
    time, this component will be placed in the **MainCamera**. It serves as a way
    to identify which object represents the ears of the player in the world, with
    which we can calculate audio directionality. The camera is the logical place to
    put it, given it represents the eyes of the user, and having the eyes and the
    ears of the player in different places would be confusing. There are no properties
    to configure in the **AudioListener** component, but it is important to mention
    that in order for audio to work, we need one and no more than one; we have just
    one pair of ears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_12_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: AudioListener component in the MainCamera'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can configure individual pieces of audio, let’s see how to apply
    effects to groups of audio instances using an **Audio Mixer**.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Audio Mixer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will have several audio instances playing all over our game: the footsteps
    of characters, shooting, bonfires, explosions, rain, and so on. Controlling exactly
    which sounds are supposed to sound louder or quieter depending on the context
    and applying effects to reinforce certain situations, such as being stunned due
    to a nearby explosion, is called audio mixing—the process of mixing several sounds
    together in a cohesive and controlled way.'
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, we can create an Audio Mixer, an asset that we can use to define groups
    of sounds. All changes to a group will affect all sounds inside it by raising
    or lowering the volume, perhaps, or by applying an effect. You can have SFX and
    music groups control sounds separately. For example, you could lower the SFX volume
    in the **Pause** menu but not the music volume. Also, groups are organized in
    a hierarchy, where a group can also contain other groups, so a change in a group
    will also apply changes to its sub-groups. As a matter of fact, every group you
    create will always be a child group of the master group, the group that controls
    every single sound in the game (that uses that mixer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a mixer with SFX and music groups:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Project** window, using the **+** button, select the **Audio Mixer**
    option. Name the asset as you wish; in my case, I chose `Main Mixer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the created asset to open the **Audio Mixer** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_13_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.13: Audio Mixer window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **+** button at the right of the **Groups** label to create a child
    group of the master node. Name it `SFX`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_14_14_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.14: Group creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Master** group and click again on the **+** button to create
    another master node child group called `Music`. Remember to select the **Master**
    group before clicking the **+** button because if another group is selected, the
    new group will be a child of that one. Anyway, you can rearrange a group child-parent
    relationship by dragging the group in the **Groups** panel in the **AudioMixer**
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_15_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.15: The Master, SFX, and Music groups'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Music** GameObject of our scene back in the **Hierarchy** window
    and look for the **AudioSource** component in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the circle to the right of the **Output** property to open the **AudioMixerGroup**
    selector window and select the **Music** group. This will make that **AudioSource**
    affected by the settings on the specified **Mixer** group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_16_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.16: Making an AudioSource belong to an Audio Mixer group'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you play the game now, you can see how the volume meters in the **Audio
    Mixer** window start to move, indicating that the music is going through the **Music**
    group. You will also see that the **Master** group volume meter is also moving,
    indicating that the sound that is passing through the **Music** group is also
    passing through the **Master** group (the parent of the **Music** group) before
    going to the sound card of your computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, diagram  Description automatically
    generated](img/B21361_14_17_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.17: Group volume levels'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps 5* and *6* for the ambient and shooting sounds to make them belong
    to the **SFX** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have separated our sounds into groups, we can start adjusting the
    groups’ settings. But before doing that, we need to take into account the fact
    that we won’t want the same settings all the time, as in the previously mentioned
    pause menu case, where the SFX volume should be lower. To handle those scenarios,
    we can create snapshots, which are presets of our mixer that can be activated
    via scripting during our game. We will deal with the scripting steps in *Section
    3*, *Elevating Visuals, Effects, and Audio* of this book, but we can create a
    normal snapshot for the in-game settings and a pause snapshot for the pause menu
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the **Snapshots** list, you will see that a single snapshot has
    already been created—that can be our normal snapshot. So, let’s create a pause
    snapshot by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **+** button to the right of the **Snapshots** label and call the
    snapshot `Pause`. Remember to stop the game to edit the mixer or click the **Edit
    in Playmode** option to allow Unity to change the mixer during play. If you do
    the latter, remember that the changes will persist when you stop the game, unlike
    changes to GameObjects. Actually, if you change other assets during **Play** mode,
    those changes will also persist—only GameObject changes are reverted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, font, number, line  Description automatically
    generated](img/B21361_14_18_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.18: Snapshot creation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Pause** snapshot and lower the volume slider of the **SFX** group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_19_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.19: Lowering the volume of the Pause snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and hear how the sound is still at its normal volume. That’s because
    the original snapshot is the default one—you can see that by checking for the
    star to its right. You can right-click any snapshot and make it the default one
    using the **Set as Start Snapshot** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Edit in** **Playmode** to enable **Audio Mixer** modification during
    runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Pause** snapshot to enable it and hear how the **Shooting** and
    **Ambient** sound volumes have decreased.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, one of the main uses of the mixer is to control group volume,
    especially when you see that the intensity of a group’s volume is going higher
    than the 0 mark, indicating that the group is too loud. Anyway, there are other
    uses for the mixer, such as applying effects. If you’ve played any war game, you
    will have noticed that whenever a bomb explodes nearby, you hear the sound differently
    for a moment, as if the sound were located in another room. That can be accomplished
    using an effect called **Low Pass**, which blocks high-frequency sounds, and that’s
    exactly what happens with our ears in those scenarios: the stress of the high-volume
    sound generated by an explosion irritates our ears, making them less sensitive
    to high frequencies for a while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add effects to any channel and configure them according to the current
    snapshot, just as we did for the volume, by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Add** button at the bottom of the **Master** group and select
    **Lowpass Simple**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_14_20_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.20: The effects list of a channel'
  prefs: []
  type: TYPE_NORMAL
- en: Select the normal snapshot (the one called `Snapshot`) to modify it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Master** group and look at the **Inspector** panel, where you will
    see settings for the group and its effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Cutoff freq** property of the **Lowpass Simple** settings to the highest
    value (`22000`), and this will disable the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 3* and *4* for the **Pause** snapshot; we don’t want this effect
    in that snapshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new snapshot called **Bomb Stun** and select it to edit it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set **Cutoff freq** to `1000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a music mixer  Description automatically generated with low
    confidence](img/B21361_14_21_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.21: Setting the cutoff frequency of the Lowpass Simple effect'
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and change between snapshots to check the difference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see, **Low Pass** makes the audio sound like there’s a wall between
    the sources and the listener. Aside from the Low Pass filter, you can apply several
    other filters, such as **Echo**, to create an almost dreamy effect, or a combination
    of **Send**, **Receive**, and **Duck** to make a group lower its volume based
    on the intensity of another group (for instance, you may want to lower SFX volume
    when dialogue is happening). I invite you to try those and other effects and check
    the results to identify potential uses by reading the following documentation:
    [https://docs.unity3d.com/Manual/class-AudioEffectMixer.html](https://docs.unity3d.com/Manual/class-AudioEffectMixer.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have integrated the audio, let’s see how we can script our audio.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting audio feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the VFX, audio also needs to react to what is happening in the game
    to give a better sense of immersion. Let’s start adding sound to the explosion
    effect that enemies spawn when they die, which doesn’t necessarily need scripting
    itself but is a result of the script that spawned the explosion in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: Download an explosion sound effect from the internet or the Asset Store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Explosion** prefab we spawn when the enemies die and add an **AudioSource**
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the downloaded explosion’s audio clip as the **AudioClip** property of the
    **Audio Source**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure **Play On Awake** is checked and **Loop** is unchecked under **Audio
    Source.** That will make the sound be played when the explosion begins, and prevent
    the sound from looping again and again once it finishes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_14_22_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.22: Adding sounds to our explosion effect'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see here, we didn’t need to use any script because we activated
    **Play On Awake** on the Audio Source. As the sound is added to the Prefab, it
    will be played automatically at the very moment the Prefab is instantiated. Now,
    let’s integrate the shooting sound by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Download a shooting sound and add it through an Audio Source to the player’s
    weapon muzzle effect (not the weapon), this time unchecking the **Play On Awake**
    checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PlayerShooting` script, create a field of the `AudioSource` type called
    **shootSound**. This way our script has access to the component and can manipulate
    when it plays sounds and when it doesn’t.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Player** in the **Hierarchy** and drag the weapon muzzle effect GameObject
    to the **Shoot Sound** property in the **Inspector** to connect the script with
    the `AudioSource` variable in the weapon muzzle effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `if` statement that checks whether we can shoot, add the `shootSound.Play();`
    line to execute the sound when shooting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B21361_14_23_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.23: Adding sound when shooting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Scripting additional nodes would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, electronics, screenshot  Description automatically
    generated](img/B21361_14_24_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.24: Adding sound when shooting in Visual Scripting'
  prefs: []
  type: TYPE_NORMAL
- en: As we did with the muzzle effect, we added a GameObject variable called `shootSound`
    to reference the weapon GameObject that contains the Audio Source, and then we
    called the **Play** method of the `shootSound` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'I challenge you to try adding shooting sounds to the enemy AI in both C# and
    Visual Scripting versions of the scripts. Take as a guide what we did in *Chapter
    11*, *Captivating Visual Effects: Harnessing Particle Systems and VFX Graph*,for
    the muzzle effect, and in any case, you can always check the Git repository of
    the book (the link can be found in the *Preface*) for the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to this would be the same as the one we did with the explosion;
    just add the shooting sound to the bullet, but if the bullet collides with a wall,
    soon enough, the sound will be cut off. Or, if in the future we want an automatic
    weapon sound, it will need to be implemented as a single looping sound that starts
    when we press the relevant key and stops when we release it. This way, we prevent
    too many sound instances from overlapping when we shoot too many bullets. Take
    into account those kinds of scenarios when choosing the approach to script your
    feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to boost your audio immersion is through audio spatialization.
    It’s an advanced topic, but you can learn more about it here: [https://docs.unity3d.com/Manual/AudioSpatializerSDK.html](https://docs.unity3d.com/Manual/AudioSpatializerSDK.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful in VR and AR applications for fully immersing users
    in the virtual world.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to import and integrate sounds, considering
    their impact on memory usage, and we considered how to apply effects to generate
    different scenarios. Sound is a big part of achieving the desired game experience,
    so take the proper amount of time to get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered almost all of the vital aesthetic aspects of our game,
    let’s create another form of visual communication, the user interface or UI. We
    will create the necessary UI to display the player’s current score, bullets, life,
    and lots more info in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
