- en: Let's Chat Web Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let's Chat Web应用
- en: 'There is an old saying:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有句老话说：
- en: '*"A single conversation with a wise person is worth a month''s study of books*."'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '"与智者的一次交谈胜过一个月的书本学习。"'
- en: 'With this thought, let''s enable a conversation with our online friends by
    developing a chat application called Let''s Chat in ASP.NET Core 2.0\. Over the
    course of the next three chapters, we will be developing and deploying this chat
    app. While doing so, we will dive deep into ASP.NET Core 2.0 features, learn their
    intricacies, and learn how to unit test our ASP.NET Core 2.0 app. We will also
    learn about containers and deploy our app on the cloud. We will end these three
    chapters with a quick development and walkthrough of a Chatbot using the Microsoft
    Bot Framework, which can be easily created in a matter of minutes and can be added
    to any of your web apps and also integrated with social networks.  In this chapter,
    we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个想法，让我们通过开发一个名为Let's Chat的ASP.NET Core 2.0聊天应用来与我们的在线朋友进行对话。在接下来的三个章节中，我们将开发和部署这个聊天应用。在这个过程中，我们将深入研究ASP.NET
    Core 2.0的功能，了解它们的复杂性，并学习如何对ASP.NET Core 2.0应用进行单元测试。我们还将了解容器并将应用部署到云端。在三个章节的结尾，我们将快速开发和演示一个使用Microsoft
    Bot Framework的Chatbot，这个Chatbot可以在几分钟内轻松创建，并可以添加到您的任何Web应用中，也可以与社交网络集成。在本章中，我们将涵盖以下主题：
- en: Let's Chat web app requirement specifications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们来看看Let's Chat网络应用的要求规范
- en: Let's Chat web app design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let's Chat网络应用设计
- en: Project setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'With reference to ASP.NET Core 2.0, we will also learn the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 参考ASP.NET Core 2.0，我们还将学习以下内容：
- en: Authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: Authorization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: ASP.NET Core pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道
- en: Middleware
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件
- en: Dependency registration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项注册
- en: Reading configuration values
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取配置值
- en: Logging
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Let's Chat web app requirement specifications
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let's Chat网络应用要求规范
- en: In this section, we will discuss the requirements for developing our Let's Chat
    web application in ASP.NET Core 2.0.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在ASP.NET Core 2.0中开发我们的Let's Chat网络应用的要求
- en: 'As a user, I should be able to fulfill the following requirements for this
    chat room app:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为用户，我应该能够满足以下对聊天室应用的要求：
- en: Register myself in the web app
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网络应用中注册自己
- en: Log in to the app
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录应用
- en: Reset the password in case I have forgotten the old one
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我忘记了旧密码，重置密码
- en: See a list of all the currently logged in users in the chat room
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看聊天室中所有当前登录用户的列表
- en: See a users joining or leaving the chat room
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看用户加入或离开聊天室
- en: See the display pictures of logged in users, if they exist
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，查看已登录用户的显示图片
- en: Chat with all online users at the same time, just like a chat room
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有在线用户同时聊天，就像聊天室一样
- en: Access the app from a browser over the internet and chat with any number of
    online users
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过互联网从浏览器访问应用并与任何数量的在线用户聊天
- en: To give an example, we are looking at a highly trimmed down version of something
    like [https://gitter.im/dotnet/cli](https://gitter.im/dotnet/cli), which is a
    chat room for .NET Core **command-line interface** (**CLI**) tools.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们正在查看类似[https://gitter.im/dotnet/cli](https://gitter.im/dotnet/cli)的高度精简版本，这是一个.NET
    Core **命令行界面**（CLI）工具的聊天室。
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the app and come up with a flowchart. The following is a rough flowchart
    of the app workflow:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了要求规范，让我们看看应用的活动流程，并制定一个流程图。以下是一个粗略的应用工作流程流程图：
- en: '![](img/e8aeb145-101d-449f-8dde-6419c16c2cde.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8aeb145-101d-449f-8dde-6419c16c2cde.png)'
- en: 'Let''s have a look at the flow:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看流程：
- en: '**Start**: This is the start of the flow. The user browses the chat URL. It
    is being conceptualized as a site, as we want to access it from the browser and
    chat with any number of online users (requirement *Steps 7* and *8*).'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**开始**：这是流程的开始。用户浏览聊天URL。它被构想为一个网站，因为我们希望从浏览器访问它并与任何数量的在线用户聊天（要求步骤7和8）。'
- en: '**Is user logged in**?: At this point, the app checks whether the user is authenticated
    or not, that is, the user is logged in or not. If the user is logged in, he/she
    is redirected to the chat room page; otherwise, the user is redirected to the
    login page. There is also the provision to reset the password (requirement *Steps
    2* and *3*).'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户是否已登录**？：此时，应用检查用户是否已认证，即用户是否已登录。如果用户已登录，则将其重定向到聊天室页面；否则，用户将被重定向到登录页面。还有重置密码的选项（要求步骤2和3）。'
- en: '**Is user registered?**: When the user is not logged in, he/she is redirected
    to the login page, where they need to provide a proper username and password to
    get authenticated and logged in. But this can happen only if the user has valid
    credentials, that is, the user is already registered (requirement *Step 1*).'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户是否已注册**？当用户未登录时，他们将被重定向到登录页面，在那里他们需要提供正确的用户名和密码以获得认证并登录。但这仅发生在用户有有效凭证的情况下，即用户已经注册（需求
    *步骤 1*）。'
- en: '**Register User**: If the user is not registered, the app should provide a
    provision to register the user (requirement *Step 1*).'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册用户**：如果用户未注册，应用应提供注册用户的选项（需求 *步骤 1*）。'
- en: '**Login**: This is the landing screen for any unauthenticated user. Already
    authenticated users are directly navigated to the chat room page. This indicates
    to other online users that the user has joined the room (requirement *Step 2*).'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录**：这是任何未经认证用户的登录页面。已经认证的用户将被直接导航到聊天室页面。这向其他在线用户表明用户已加入房间（需求 *步骤 2*）。'
- en: '**Chat Room**: Upon successful authentication, the user is redirected to the
    chat room, where he/she can see the list of online users and chat with all of
    them (requirements *Steps 4*, *5*, and *6*).'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**聊天室**：在成功认证后，用户将被重定向到聊天室，在那里他们可以看到在线用户列表并与他们所有人聊天（需求 *步骤 4*、*步骤 5* 和 *步骤
    6*）。'
- en: '**Chat with other users**: Once the user is in the chat room, he/she can chat
    with all the online users and can also see their names and display pictures in
    the chat (requirements *Steps 6* and *7*).'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**与其他用户聊天**：一旦用户进入聊天室，他们可以与所有在线用户聊天，并可以在聊天中看到他们的名字和显示图片（需求 *步骤 6* 和 *步骤 7*）。'
- en: '**Finish**: Once the user is done chatting with their friends, he /she can
    exit the page. This indicates to other online users that the user has left the
    room (requirement *Step 5*).'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完成**：一旦用户与朋友聊天完毕，他们可以退出页面。这向其他在线用户表明用户已离开房间（需求 *步骤 5*）。'
- en: As we can see and infer from the flowchart, this is pretty much how every modern
    online app workflow happens. We also see that chatting happens only in *Steps
    6* and *7* of the flowchart. All the other steps are for authentication and setup.
    We also know that this flow covers all the requirements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从流程图中所见和推断，这正是每个现代在线应用工作流程的样子。我们还看到聊天仅在流程图的 *步骤 6* 和 *步骤 7* 中发生。所有其他步骤都是用于认证和设置。我们还知道这个流程涵盖了所有需求。
- en: Let's Chat web app – high-level design
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let's Chat 网页应用 - 高级设计
- en: 'In this section, we will look at the flowchart that we created and we will
    come up with granular modules to constitute the app using ASP.NET Core 2.0\. We
    need to develop the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看我们创建的流程图，并使用 ASP.NET Core 2.0 构成应用程序的细粒度模块。我们需要开发以下内容：
- en: An authentication and authorization module that takes care of login and authentication
    of users
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负责登录和用户认证的认证和授权模块
- en: A registration module that takes care of user registration
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负责用户注册的注册模块
- en: A chat room page
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个聊天室页面
- en: A module that keeps track of all the logged in users and notifies the client
    chat room pages about the user joining and leaving
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个跟踪所有已登录用户并通知客户端聊天室页面用户加入和离开的模块
- en: A user information module that keeps track of all the user information, such
    as display name, display picture, and so on
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户信息模块，用于跟踪所有用户信息，例如显示名称、显示图片等
- en: A chat hub module that enables a message to be broadcast from each user to the
    other online users
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个聊天中心模块，允许每个用户向其他在线用户广播消息
- en: 'Sounds easy? Let''s see how we can design and implement each of the preceding
    requirements using ASP.NET Core 2.0:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单？让我们看看我们如何使用 ASP.NET Core 2.0 设计和实现上述每个需求：
- en: '**Authentication and authorization module**: This is a core functionality and
    needed in most modern apps. It makes sense to use something that is already developed,
    tested, and secure, so that we do not waste our time and energy in rediscovering
    the wheel. There are a variety of ways by which we can achieve this, such as by
    creating and using a custom identity provider, or using Facebook, Twitter, Google,
    or Microsoft authentication providers. We will use Facebook authentication in
    our app, as it''s more likely for the user to have a profile picture in Facebook,
    which would give a good user experience while chatting. This is done through OAuth
    (pronounced *oh-auth*), which stands for open authorization and is an open standard
    for token-based authentication and authorization on the internet. We will discuss
    this in detail when we implement it in our app. This will take care of *Steps
    1* through *5* in our flowchart discussed in the previous section.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证和授权模块**：这是核心功能，在大多数现代应用程序中都是必需的。使用已经开发、测试和安全的解决方案是有意义的，这样我们就不必浪费时间在重新发现轮子上了。我们可以通过多种方式实现这一点，例如创建和使用自定义身份提供者，或者使用Facebook、Twitter、Google或Microsoft认证提供者。在我们的应用程序中，我们将使用Facebook认证，因为用户在Facebook上更有可能有一个个人资料图片，这将在聊天时提供良好的用户体验。这是通过OAuth（发音为*oh-auth*）实现的，代表开放授权，是互联网上基于令牌的认证和授权的开放标准。当我们在应用程序中实现它时，我们将详细讨论这个问题。这将处理我们在上一节中讨论的流程图中的*步骤1*至*步骤5*。'
- en: '**Chat hub module**: This module will be responsible for enabling real-time
    chat between all online users and will also track the users as they join and leave
    the room. The hub will receive messages from clients and then broadcast the received
    messages to all clients. This will be an implementation on top of the SignalR
    hub and will be responsible for handling user connections, disconnections, and
    all the real-time messaging functionality. We have already seen and coded the
    basics of SignalR in our last app.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聊天中心模块**：此模块将负责启用所有在线用户之间的实时聊天，并跟踪用户加入和离开房间的情况。中心将接收来自客户端的消息，然后将接收到的消息广播给所有客户端。这将是基于SignalR中心的实现，并负责处理用户连接、断开连接以及所有实时消息功能。我们在上一个应用程序中已经看到并编写了SignalR的基本知识。'
- en: Now that we have high-level designs in place, let's deep dive into the details
    to implement these and learn more about them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了高级设计，让我们深入细节来实现这些设计，并了解更多相关信息。
- en: Project setup
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: In this section, we will start the development of the Let's Chat web app and
    learn all the required fundamentals and ASP.NET Core 2.0 features in the process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始开发Let's Chat网络应用程序，并在过程中学习所有必需的基本知识和ASP.NET Core 2.0功能。
- en: Create a new ASP.NET Core 2.0 MVC app named Let's Chat, like we did in the *Creating
    a simple running code* section of [Chapter 1](ch01.html), *Getting Started*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的ASP.NET Core 2.0 MVC应用程序，命名为Let's Chat，就像我们在[第1章](ch01.html)中“*入门*”部分的*创建简单运行代码*部分所做的那样。
- en: Since we need SignalR as well for all the real-time messaging, we need to install
    the SignalR package in our app. To do so, please follow the steps mentioned in
    the *Project setup* section of [Chapter 3](ch03.html), *Building Our First .NET
    Core Game - Tic* -*Tac-Toe.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还需要SignalR来实现所有实时消息传递，因此我们需要在我们的应用程序中安装SignalR包。为此，请按照[第3章](ch03.html)中“*项目设置*”部分所述的步骤操作，该部分是关于*构建我们的第一个.NET
    Core游戏 - 费茨*-*塔克*。
- en: After installation of SignalR, we are ready to start coding the app. We will
    start with the authentication and authorization module first and then move on
    to the Chat hub module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装SignalR之后，我们就准备好开始编码应用程序了。我们将首先从认证和授权模块开始，然后继续到聊天中心模块。
- en: Authentication and authorization are closely interlinked, but are quite different
    and are the fundamental concepts of security for distributed applications. It's
    imperative we understand these concepts so that we can develop a secure application.
    One of the most defining principles of security is *trust*. When we make our web
    app available on the internet, it's like keeping our resource in a public area,
    where hundreds and thousands of people can see it. Do you trust that your resource
    will be safe? There is a saying, *In God we trust, the rest must bring data* so,
    it's a big *NO*! Just like stuff left in a public area is not safe, the content
    we have made available on the internet is not safe and from this comes the need
    for authentication and authorization. Let's understand authentication and authorization,
    and then dig into coding the module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权紧密相关，但它们是不同的，并且是分布式应用安全性的基本概念。我们必须理解这些概念，以便我们可以开发一个安全的应用程序。安全性的一个最定义性的原则是**信任**。当我们把我们的Web应用程序发布到互联网上时，就像把我们的资源放在公共场所一样，数百甚至数千人都可以看到它。你相信你的资源会安全吗？有句俗话说，“我们信仰上帝，其余的必须提供数据”，所以，这是一个大大的**不**！就像放在公共场所的东西不安全一样，我们在互联网上提供的内容也不安全，这就是为什么需要认证和授权。让我们理解认证和授权，然后深入到模块的编码中。
- en: Authentication deals with the process of obtaining some sort of credentials
    from the users and validates the user's identity based on these credentials. Authorization
    is the process of specifying the privileges/access rights of the resources to
    the authenticated resources. Authentication always happens before authorization,
    even if the app allows anonymous access, as the app would identify the user as
    an anonymous user first and then grant access. Authorization generally works on
    the basis of the principle of least privilege.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 认证涉及从用户那里获取某种凭据的过程，并基于这些凭据验证用户身份。授权是指指定资源对已认证资源的权限/访问权限的过程。认证总是在授权之前发生，即使应用程序允许匿名访问，因为应用程序首先会将用户识别为匿名用户，然后授予访问权限。授权通常基于最小权限原则。
- en: 'In research, investigations, and journalism, the *Five Ws and How or 5W1H* methodology
    of questioning is known to be a highly effective way of gathering the information,
    so let''s use the same approach to understand authentication and authorization:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究、调查和新闻业中，提问的“五W和如何”或5W1H方法论被认为是收集信息的一种非常有效的方法，因此让我们采用相同的方法来理解认证和授权：
- en: '| **Question** | **Authentication** | **Authorization** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **问题** | **认证** | **授权** |'
- en: '| **What/who?** | As per the Oxford dictionary, the meaning of the word authentication
    in the computing world is *The process or action of verifying the identity of
    a user or process. It is meant to identify the user/process and whether it is
    valid.* | As per the Oxford dictionary, the literal meaning of the word authorization
    is *The action of authorizing.* |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **什么/谁？** | 根据牛津词典，计算机世界中“认证”一词的含义是**验证用户或进程身份的过程或行为。它的目的是识别用户/进程，并确定它是否有效**。
    | 根据牛津词典，“授权”一词的字面意义是**授权的行为**。 |'
- en: '| **Why?** | To validate the identity of the user/process on the basis of credentials.
    | To control or restrict access to your devices/services/resources. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **为什么？** | 基于凭据验证用户/进程的身份。 | 控制或限制对您的设备/服务/资源的访问。 |'
- en: '| **Where/when?** | Wherever/whenever I need to restrict or control access
    to devices/services. But security experts may differ in their answer and say everywhere
    and at all times. | Wherever/whenever I need to restrict or control access to
    devices/services. But security experts may differ in their answer and say everywhere
    and at all times. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **在哪里/什么时候？** | 无论何时何地我需要限制或控制对设备/服务的访问。但安全专家们可能会有不同的答案，他们可能会说在所有地方和所有时间。
    | 无论何时何地我需要限制或控制对设备/服务的访问。但安全专家们可能会有不同的答案，他们可能会说在所有地方和所有时间。 |'
- en: '| **How?** | Validate the supplied credentials against the stored credentials.
    | Check the role of the user/process and grant or refuse access to the resource.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **如何？** | 验证提供的凭据与存储的凭据是否一致。 | 检查用户/进程的角色并授予或拒绝对资源的访问权限。 |'
- en: '| **Example** | Someone knocks at your door. You look out and check you know
    the person by identifying him/her. This is authentication. The question that comes
    to mind is *who are you?* | In the same example, after performing authentication
    (identifying the person), you either let him/her into your house if the person
    is your friend or relative, or you don''t if you don''t know them well. This is
    authorization. The question that comes to mind is *what privileges do you have?*
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | 有人在敲门。你向外看，通过识别他/她来确认你是否认识这个人。这是身份验证。脑海中浮现的问题是“你是谁？”| 在同样的例子中，在执行身份验证（识别这个人）之后，如果你认识这个人，无论是你的朋友还是亲戚，你会让他/她进入你的房子，否则如果你不认识他们，你不会让他们进入。这是授权。脑海中浮现的问题是“你有什么权限？”|'
- en: 'The following diagram illustrates the authentication and authorization flow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了身份验证和授权流程：
- en: '![](img/388dd761-aaa8-4c49-ba1c-69852fbb1eff.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/388dd761-aaa8-4c49-ba1c-69852fbb1eff.png)'
- en: 'Authentication and authorization are vast topics and if we go into details,
    there could be a book on them alone, so we will briefly look at the various different
    implementations and related buzzwords to get the gist of them. The enthusiastic
    reader may want to read more about authentication and authorization. A few great
    and reliable resources I can suggest are:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权是广泛的话题，如果我们深入探讨，可能会有关于它们的整本书。因此，我们将简要地看看各种不同的实现和相关术语，以了解其精髓。热心的读者可能想了解更多关于身份验证和授权的内容。我可以推荐一些优秀且可靠的资源：
- en: '[https://docs.microsoft.com/en-us/aspnet/core/security/authorization/](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/aspnet/core/security/authorization/](https://docs.microsoft.com/en-us/aspnet/core/security/authorization/)'
- en: '[https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en](https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en](https://channel9.msdn.com/Search?term=Advanced%20ASP.NET%20Core%20Authorization%20with%20Barry%20Dorrans#pubDate=year&ch9Search&lang-en=en)'
- en: Authentication
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: 'There has been a variety of implementations for authentication in ASP.NET over
    the years. Some of the most well-known ones are:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET中，身份验证的实现方式多种多样。其中一些最著名的包括：
- en: Windows authentication
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows身份验证
- en: Forms authentication
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单身份验证
- en: Token-based authentication
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: The following sections discuss these further.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将进一步讨论这些内容。
- en: Windows authentication
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows身份验证
- en: 'This uses local Windows users and groups to authenticate. It can be sub-classified
    into:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用本地Windows用户和组进行身份验证。它可以进一步细分为：
- en: '**Basic authentication:** Usernames and passwords are sent as Base64-encoded
    strings and hence can be easily cracked, so it''s a very weak form of authentication
    and should not be used.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本身份验证**：用户名和密码以Base64编码的字符串形式发送，因此很容易被破解，所以这是一种非常弱的身份验证形式，不应使用。'
- en: '**Digest authentication:** Issues with basic authentication are solved with
    digest authentication and the data sent is MD5 hashed. This hashed message is
    not easy to decipher. However, some browsers don''t support it.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摘要身份验证**：摘要身份验证解决了基本身份验证的问题，发送的数据是MD5散列的。这个散列消息不容易被解读。然而，一些浏览器不支持它。'
- en: '**Integrated authentication**: Kerberos authentication or **NT LAN Manager**
    (**NTLM**) authentication. This is the best of the lot, in terms or security as
    well as support.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成身份验证**：Kerberos身份验证或**NT局域网管理器**（NTLM）身份验证。在安全性和支持方面，这是最好的选择。'
- en: Windows authentication is still supported in ASP.NET Core 2.0, but since it
    is based on Windows, it won't be available on Linux or Macintosh. The app has
    to be hosted with IIS or HTTP.SYS (a web server for ASP.NET Core, which runs *only*
    on Windows). This is suited for intranet networks where the servers, clients,
    and users all belong to the same Windows domain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Windows身份验证在ASP.NET Core 2.0中仍然得到支持，但由于它基于Windows，因此它不会在Linux或Macintosh上可用。应用程序必须使用IIS或HTTP.SYS（一个仅适用于Windows的ASP.NET
    Core网络服务器）来托管。这适用于服务器、客户端和用户都属于同一Windows域的内部网络。
- en: Forms authentication
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单身份验证
- en: 'This is cookie/URL-based authentication in which a username and password are
    stored on the client machine as cookies and are sent encrypted in the URL for
    every request if the user has turned off cookie support. We can implement this
    in ASP.NET Core 2.0 as cookie authentication, as illustrated in the following
    diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基于cookie/URL的身份验证，其中用户名和密码以cookie的形式存储在客户端机器上，并在用户关闭cookie支持的情况下，在每次请求中以加密的形式发送到URL。我们可以在ASP.NET
    Core 2.0中实现这种cookie身份验证，如下面的图所示：
- en: '![](img/d7291395-2811-4010-9d09-2f94150ef3db.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7291395-2811-4010-9d09-2f94150ef3db.png)'
- en: As we can see, once we have the auth-key set with the initial call to authenticate,
    we just pass the session ID/token from the cookie in every request. It can be
    used with ASP.NET Core Identity or without it. ASP.NET Core Identity is a membership
    system that allows us to add login functionality to our web app. Users can create
    an account and log in with username and password or they can use external social
    login providers, such as Facebook, Twitter, Google, Microsoft, and so on. We can
    use SQL Server or other persistence storage mechanisms to store the user details.
    Since this needs a very detailed understanding, you are advised to read about
    ASP.NET Identity from Microsoft's official documentation at [https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，一旦我们在初始调用中进行身份验证后设置了auth-key，我们只需在每次请求中传递cookie中的会话ID/令牌。它可以与ASP.NET Core
    Identity一起使用，也可以不使用它。ASP.NET Core Identity是一个成员系统，它允许我们在我们的Web应用程序中添加登录功能。用户可以使用用户名和密码创建账户并登录，或者他们可以使用外部社交登录提供者，如Facebook、Twitter、Google、Microsoft等。我们可以使用SQL
    Server或其他持久化存储机制来存储用户详细信息。由于这需要非常详细的理解，建议您阅读Microsoft官方文档中的ASP.NET Identity，网址为[https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?tabs=visual-studio%2Caspnetcore2x)。
- en: 'If you have worked with ASP.NET prior to ASP.NET Core, you will find out that
    the fundamental type `IPrincipal` is more or less the same. It used to be implemented
    as `user` on `HTTPContext`, which represented the user for a request. Now, we
    also have a property named `user`, but its type is `ClaimsPrincipal`, which in
    turn implements `IPrincipal`. This is the shift that ASP.NET Core 2.0 has taken
    from the previous version of ASP.NET: that is, it has moved to claims-based from
    a role-based model and claims is the superset of a role. So, the question arises,
    what is a claim?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在ASP.NET Core之前使用过ASP.NET，你会发现基本类型`IPrincipal`基本上是相同的。它过去是在`HTTPContext`上的`user`实现，代表请求的用户。现在，我们还有一个名为`user`的属性，但其类型是`ClaimsPrincipal`，它反过来又实现了`IPrincipal`。这是ASP.NET
    Core 2.0从ASP.NET的先前版本中做出的转变：即，它从基于角色的模型转变为基于声明的模型，声明是角色的超集。因此，问题产生了，什么是声明？
- en: Claims are sets of information stored in key value pair form and are used to
    store user information such as name, address, email address, phone number, and
    so on. We can use claims as the replacement for roles as we can transfer the role
    to a claim. For example, I say "I am Rishabh Verma. I live in India. I am the
    author of this book", where I am claiming that my name is Rishabh Verma, I am
    claiming that I live in India, and I am claiming that I have the role of author
    of this book. This is what I mean when I say claims are the superset of roles,
    as in the preceding statement I have transformed my role of author into a claim.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 声明是一组以键值对形式存储的信息，用于存储用户信息，如姓名、地址、电子邮件地址、电话号码等。我们可以将声明用作角色的替代品，因为我们可以将角色转移到声明中。例如，我说“我是Rishabh
    Verma。我住在印度。我是这本书的作者”，在这里我声称我的名字是Rishabh Verma，我声称我住在印度，我声称我是这本书的作者。这就是我说声明是角色超集的含义，因为在先前的陈述中，我已经将我的作者角色转换成了声明。
- en: 'The following code should nicely explain claims, identity, and principal relations
    from the preceding statement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该可以很好地解释声明、身份和主体之间的关系：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Token-based authentication
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证
- en: 'The fundamental concept behind a token-based authentication system is simple.
    It allows users to enter their username and password in order to obtain a token,
    and then use this token in every request to fetch a specific resource—without
    using their username and password again. Once the token has been obtained, the
    user can offer the token to access the resource for a time period, while the token
    is valid. This is depicted in the following diagram:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于令牌的身份验证系统的基本概念很简单。它允许用户输入他们的用户名和密码以获取令牌，然后在每个请求中使用此令牌来获取特定资源——而无需再次使用他们的用户名和密码。一旦获得令牌，用户就可以在令牌有效期间提供令牌以访问资源。这如图所示：
- en: '![](img/fafb9d4f-52ca-48a2-b372-25f4994a90f7.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fafb9d4f-52ca-48a2-b372-25f4994a90f7.png)'
- en: It is stateless and scalable. The server need not store the token in a session
    or memory (stateless) and hence it is scalable. It is mobile application-ready,
    secure, and can be used to pass authentication to other systems. Due to the rise
    of **Single-Page Applications** (**SPAs**), **Internet of Things** (**IoT**),
    and web APIs, token-based authentication has gained importance. Although there
    are different ways to implement the tokens, the **JSON Web Token** (**JWT**) is
    more widely used. The JWT is an open standard and has become the de-facto standard
    token, which defines a compact and self-contained method for securely transmitting
    information between parties, encoded as a JSON object. The JWT has gained massive
    popularity due to its compactness, which allows tokens to be easily transmitted
    through query strings, header attributes, and within the body of requests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它是无状态的且可扩展的。服务器无需在会话或内存中存储令牌（无状态），因此它是可扩展的。它适用于移动应用程序，安全，并且可以用于将身份验证传递到其他系统。由于**单页应用程序**（**SPAs**）、**物联网**（**IoT**）和Web
    API的兴起，基于令牌的身份验证变得重要。尽管有不同方式来实现令牌，但**JSON Web Token**（**JWT**）被更广泛地使用。JWT是一个开放标准，并已成为事实上的标准令牌，它定义了一种紧凑且自包含的方法，用于安全地在各方之间传输信息，编码为JSON对象。JWT因其紧凑性而获得了巨大的人气，这使得令牌可以轻松地通过查询字符串、头部属性和请求体内部进行传输。
- en: 'The JWT consists of three parts:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: JWT由三部分组成：
- en: '**Header**: Containing the type of the token and the hashing algorithm.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**：包含令牌的类型和散列算法。'
- en: '**Payload**: Containing the claims of identity.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效载荷**：包含身份声明。'
- en: '**Signature**: Contains the string created using a secret and the combined
    header and payload. It is used to identify the integrity of the token.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**：包含使用密钥和组合的头部和有效载荷创建的字符串。它用于识别令牌的完整性。'
- en: 'It is in the format `xxxxx.yyyyy.zzzzz` and a sample token may look like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它的格式为`xxxxx.yyyyy.zzzzz`，一个示例令牌可能看起来像这样：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can create the JWT from your data at  [https://jwt.io/](https://jwt.io/),
    and can also paste the JWT and check its data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://jwt.io/](https://jwt.io/)创建JWT，也可以粘贴JWT并检查其数据。
- en: Let us wrap up our discussion on authentication with a quick discussion of OAuth
    and OpenID Connect.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过快速讨论OAuth和OpenID Connect来结束我们对身份验证的讨论。
- en: '**OAuth 2.0:** It is an open standard for authorization. It is commonly used
    to provide a way for users to log in to a website (say, our Let''s Chat app at [http://packtletschat.azurewebsites.net](http://packtletschat.azurewebsites.net))
    using a third-party account such as Facebook without having to provide the password
    of their Facebook account to the Let''s Chat app. While we will use it for authentication,
    it is actually an authorization protocol.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OAuth 2.0**：它是一个开放标准的授权协议。它通常用于提供一种方式，让用户可以使用第三方账户（例如Facebook）登录到网站（比如我们的Let''s
    Chat应用在[http://packtletschat.azurewebsites.net](http://packtletschat.azurewebsites.net)），而无需向Let''s
    Chat应用提供其Facebook账户的密码。虽然我们将用它进行身份验证，但实际上它是一个授权协议。'
- en: '**OpenID Connect (OIDC)**: It is a HTTP-based protocol that uses identity providers
    to validate that the user is actually who they says they are. It is a very simple
    protocol and provides protection for passwords. It is a simple layer that works
    on top of OAuth 2.0 and adds additional security on top of the OAuth  protocol.
    Due to its simplicity, it has found widespread adoption. Google, Facebook, and
    Stack Exchange are a few of the best-known identity providers. It''s important
    to note that OIDC is a very different protocol to OpenID. The latter is an XML-based
    protocol that follows similar approaches and goals to OIDC, but in a less developer-friendly
    way.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenID Connect (OIDC)**：它是一个基于 HTTP 的协议，使用身份提供者来验证用户是否真的是他们所说的那个人。它是一个非常简单的协议，并为密码提供了保护。它是一个简单的层，位于
    OAuth 2.0 之上，并在 OAuth 协议之上增加了额外的安全性。由于其简单性，它已经得到了广泛的应用。Google、Facebook 和 Stack
    Exchange 是一些最知名的标识提供者。重要的是要注意，OIDC 与 OpenID 非常不同。后者是一个基于 XML 的协议，它遵循与 OIDC 相似的方法和目标，但以一种对开发者不太友好的方式。'
- en: Authorization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'As discussed earlier, authorization is orthogonal and independent from authentication.
    Let''s have a quick glance at the different types of authorization:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，授权是正交且独立于认证的。让我们快速浏览一下不同类型的授权：
- en: Simple authorization
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单授权
- en: Role-based authorization
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于角色的授权
- en: Claim-based authorization
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于声明的授权
- en: Let's discuss them in the next sections.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中讨论它们。
- en: Simple authorization
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单授权
- en: 'If you have worked with ASP.NET MVC before, you may already be familiar with
    authorization. The `[Authorize]` and `[AllowAnonymous]` attributes are the inbuilt
    authorization components in the framework. At the simplest level, applying the
    `[Authorize]` attribute over a `Controller` or action restricts the access to
    the `Controller` or action to authenticated users only. If you apply the `[Authorize]`
    attribute to a `Controller`, it applies to all the actions:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前使用过 ASP.NET MVC，您可能已经熟悉授权。`[Authorize]` 和 `[AllowAnonymous]` 属性是框架中内置的授权组件。在最简单的层面上，在
    `Controller` 或操作上应用 `[Authorize]` 属性仅将 `Controller` 或操作的访问限制为已认证的用户。如果您将 `[Authorize]`
    属性应用于 `Controller`，它将应用于所有操作：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, only authenticated users have access to the `Login` action
    as well. This doesn't make sense as I want to log in when I am not logged in,
    and not when I am already logged in. So if you want it to be applied to only a
    few actions, then apply the attribute to those actions alone. The other way to
    prevent this situation is to use the `[AllowAnnonymous]` attribute on the `Login`
    action, and that makes it accessible to non-authenticated users as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，只有已认证的用户可以访问 `Login` 操作。这没有意义，因为我希望在未登录时登录，而不是在已经登录时登录。因此，如果您只想将其应用于少数操作，那么只需将这些属性应用于这些操作即可。防止这种情况的另一种方法是，在
    `Login` 操作上使用 `[AllowAnnonymous]` 属性，这将使其对未认证的用户也开放。
- en: Treat `[AllowAnonymous]` like a `0`,  and `[Authorize]` as `1`. So if you apply
    `[Authorize]` on the `Controller` and `[AllowAnonymous]` on an action, that action
    will be accessible anonymously (`1 x 0 = 0`), while other actions will require
    authentication. On the contrary, if you apply `[AllowAnonymous]` on the controller
    and `[Authorize]` on an action, all the actions will be accessible anonymously.
    The reason for this is that anything multiplied by `0` is `0`, so if you apply
    `[AllowAnonymous]` on the `Controller`, all other action level attributes are
    bypassed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `[AllowAnonymous]` 视为 `0`，将 `[Authorize]` 视为 `1`。因此，如果您在 `Controller` 上应用
    `[Authorize]` 并在操作上应用 `[AllowAnonymous]`，则该操作将可以匿名访问（`1 x 0 = 0`），而其他操作将需要认证。相反，如果您在
    `Controller` 上应用 `[AllowAnonymous]` 并在操作上应用 `[Authorize]`，则所有操作都将可以匿名访问。这是因为任何乘以
    `0` 的结果都是 `0`，所以如果您在 `Controller` 上应用 `[AllowAnonymous]`，则所有其他操作级别的属性都将被绕过。
- en: Role-based authorization
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的授权
- en: 'When a `ClaimsPrincipal` object is created, like we did previously, there is
    a property called `IsInRole`. This property provides us access to the `Roles`
    of the user. Role-based authorization checks are declarative. They can be used
    in the same way, using the `[Authorize]` attribute that we have seen, by passing
    in the `Roles` parameter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `ClaimsPrincipal` 对象时，就像我们之前做的那样，有一个名为 `IsInRole` 的属性。这个属性为我们提供了访问用户 `Roles`
    的权限。基于角色的授权检查是声明性的。它们可以使用我们之前看到的 `[Authorize]` 属性以相同的方式使用，通过传递 `Roles` 参数：
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, all the actions of `UserAdministrationController`
    are accessible to authenticated users with either the `Adminsitrator` or `ITAdministrator`
    roles. So, we can provide multiple roles as comma-separated values in the `Roles`
    parameter and they will be treated as an *or* condition. You can further restrict
    access to only one of the roles by providing the attribute at the action level.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`UserAdministrationController` 的所有操作都对具有 `Adminsitrator` 或 `ITAdministrator`
    角色的认证用户是可访问的。因此，我们可以在 `Roles` 参数中提供多个角色，并以逗号分隔的值形式，它们将被视为一个 *或* 条件。您还可以通过在操作级别提供属性来仅限制访问一个角色。
- en: 'What if I need to have an *and* condition between roles? The following snippet
    will ensure that actions are accessible only if the authenticated user has both
    `ITAdministrator` and `Administrator` roles:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我需要在角色之间有一个 *与* 条件怎么办？以下代码片段将确保只有当认证用户同时具有 `ITAdministrator` 和 `Administrator`
    角色时，操作才是可访问的：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we look at the overloads of the `[Authorize]` attribute, there is an overload
    that accepts the following policy:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `[Authorize]` 属性的重载，有一个重载可以接受以下策略：
- en: '![](img/5b645a68-54b9-4014-bd8c-b3a0650ee07d.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b645a68-54b9-4014-bd8c-b3a0650ee07d.jpg)'
- en: 'Policy-based role checks are also supported and can be done at the `Startup`
    in the `ConfigureServices()` method while configuring authorization:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基于策略的角色检查也受到支持，可以在配置授权时在 `Startup` 的 `ConfigureServices()` 方法中完成：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Claims-based authorization
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于声明的授权
- en: 'When you want to authorize based on user claims, then we can use claims-based
    authorization. A real-world example would be when you are driving a vehicle and
    the traffic police stop you, suspecting you are younger than 18 years. Then, you
    take out your driving license and claim that you are a perfectly legal age to
    drive . The police accept your claim (since it is issued by a valid authority)
    and let you drive on. This is claims-based authorization. Claims-based authorization
    checks are also declarative and can be decorated on a controller or action. Claims
    requirements are policy-based, so like in the previous section, we need to register
    the policy at startup, expressing the claims requirement. In the preceding example,
    the code would look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想根据用户声明进行授权时，我们可以使用基于声明的授权。一个现实世界的例子是当您在驾驶车辆时，交通警察拦住您，怀疑您未满18岁。然后，您拿出您的驾驶执照并声称您是完全合法的驾驶年龄。警察接受您的声明（因为它是由有效机构签发的）并让您继续驾驶。这是基于声明的授权。基于声明的授权检查也是声明性的，并且可以装饰在控制器或操作上。声明要求是基于策略的，因此，就像在前面章节中一样，我们需要在启动时注册策略，表达声明要求。在前面的例子中，代码看起来是这样的：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This discussion should have given you a pretty clear view of authentication
    and authorization, and you should now be able to dive deep into these topics and
    broaden and deepen your knowledge on these fundamental concepts.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这次讨论应该已经给了您一个相当清晰的认证和授权的视图，现在您应该能够深入探讨这些主题，并扩展和深化您对这些基本概念的知识。
- en: 'We also notice that all authentication and authorization is implemented in
    the `ConfigureServices()` method of the `Startup` class where the pipeline is 
    configured and middleware is added. To complete the discussion, let''s quickly
    understand the ASP.NET Core pipeline, and how it serves the requests. The following
    diagram illustrates how the request is served by ASP.NET Core in a step-by-step
    fashion:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到，所有身份验证和授权都是在 `Startup` 类的 `ConfigureServices()` 方法中实现的，在那里配置了管道并添加了中间件。为了完成讨论，让我们快速了解
    ASP.NET Core 管道以及它是如何处理请求的。以下图表逐步说明了 ASP.NET Core 如何服务请求：
- en: '![](img/73d351ed-4c3e-45bd-a18a-f41454504115.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73d351ed-4c3e-45bd-a18a-f41454504115.png)'
- en: 'Here is the flow:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是流程：
- en: The browser sends the HTTP request to the server. The request is received by
    the reverse proxy.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将 HTTP 请求发送到服务器。请求被反向代理接收。
- en: The request is forwarded by the reverse proxy to ASP.NET Core.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求被反向代理转发到 ASP.NET Core。
- en: The ASP.NET Core web server receives the request and routes it through its pipeline,
    through middleware. After passing through middleware, the request is processed
    by the ASP.NET Core application, which generates the response and passes it back.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 网络服务器接收请求并通过其管道路由，通过中间件。在通过中间件后，请求由 ASP.NET Core 应用程序处理，生成响应并将其返回。
- en: The ASP.NET Core web server sends the response to the reverse proxy.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core 网络服务器将响应发送给反向代理。
- en: The HTTP response is sent to the browser.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP 响应发送到浏览器。
- en: A reverse proxy is a type of proxy server that retrieves resources on behalf
    of a client from one or more servers. It can be defined as a software component
    that is responsible for receiving requests and forwarding them on to the appropriate
    web server. The reverse proxy is exposed directly to the internet, whereas the
    underlying web server is exposed only to the proxy. This setup has several benefits,
    primarily security and performance for web servers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理是一种代理服务器，代表客户端从一台或多台服务器检索资源。它可以定义为一种负责接收请求并将它们转发到适当的 Web 服务器的软件组件。反向代理直接暴露给互联网，而底层的
    Web 服务器仅暴露给代理。这种设置有几个好处，主要是对 Web 服务器的安全和性能。
- en: Let's look at the details of *Step 3*, as it talks about the ASP.NET Core web
    server and its pipeline, which is our area of interest. First things first. What
    is middleware?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*步骤 3*的详细信息，因为它讨论了 ASP.NET Core Web 服务器及其管道，这是我们感兴趣的区域。首先，什么是中间件？
- en: Middleware
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件
- en: 'As per the ASP.NET Core documentation (available at [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x)),
    middleware is a software that is assembled into an application pipeline to handle
    requests and responses. Each component:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 ASP.NET Core 文档（可在[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?tabs=aspnetcore2x)找到），中间件是一种软件，它被组装到应用程序管道中以处理请求和响应。每个组件：
- en: Chooses whether to pass the request to the next component in the pipeline
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择是否将请求传递给管道中的下一个组件
- en: Can perform work before and after the next component in the pipeline is invoked
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用管道中的下一个组件之前和之后都可以执行工作
- en: Request delegates are used to build the request pipeline. The request delegates
    handle each HTTP request. Request delegates are configured using the `Run`, `Map`,
    and `Use` extension methods. An individual request delegate can be specified inline
    as an anonymous method (called **inline middleware**), or it can be defined in
    a reusable class. These reusable classes and inline anonymous methods are *middleware*.
    Each middleware component in the request pipeline is responsible for invoking
    the next component in the pipeline, or short-circuiting the chain as required.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请求委托用于构建请求管道。请求委托处理每个 HTTP 请求。请求委托使用`Run`、`Map`和`Use`扩展方法进行配置。单个请求委托可以内联指定为匿名方法（称为**内联中间件**），或者它可以定义在可重用的类中。这些可重用的类和内联匿名方法是**中间件**。请求管道中的每个中间件组件都负责调用管道中的下一个组件，或者根据需要短路链。
- en: 'The classical diagram of middleware in the pipeline, which is available at
    Microsoft''s official ASP.NET Core documentation site, is shown here, with the
    added detail of steps, which makes it extremely lucid. What happens in *Step 3* is
    shown in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中中间件的经典图示，可在微软官方 ASP.NET Core 文档网站上找到，此处展示了带有步骤的详细信息，使其非常清晰。以下图示展示了*步骤 3*发生的情况：
- en: '![](img/d65abcc3-891e-47c6-a41d-10dd40a89e51.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d65abcc3-891e-47c6-a41d-10dd40a89e51.png)'
- en: 'Lets look at it in a step-by-step approach:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地来看：
- en: '**Step 1**: The request is received by **Middleware 1**. The pseudo code of
    **Middleware 1** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` would be `UseMiddleware1();`, as it processes the
    request and invokes the next middleware. Recall that we discussed the `Use`, `Map`,
    and `Run` methods in brief in [Chapter 3](ch03.html), *Building Our First .NET
    Core Game Tic-Tac-Toe*.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤 1**：请求被**中间件 1**接收。在`Startup.cs`中的`Configure(IApplicationBuilder app,
    IHostingEnvironment env)`方法中，**中间件 1**的伪代码会是`UseMiddleware1();`，因为它处理请求并调用下一个中间件。回想一下，我们在[第
    3 章](ch03.html)，*构建我们的第一个 .NET Core 游戏“井字棋”*中简要讨论了`Use`、`Map`和`Run`方法。'
- en: '**Step 2**: The code/logic of **Middleware 1** is executed.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤 2**：执行**中间件 1**的代码/逻辑。'
- en: '**Step 3**: `RequestDelegate`—`next();` is executed, which invokes the next
    middleware.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤 3**：执行`RequestDelegate`—`next();`，这会调用下一个中间件。'
- en: '**Step 4**: The code/logic of **Middleware 2** is executed. The pseudo code
    of **Middleware 2** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` would be `UseMiddleware2();`.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤 4**：执行**中间件 2**的代码/逻辑。在`Startup.cs`中的`Configure(IApplicationBuilder app,
    IHostingEnvironment env)`方法中，**中间件 2**的伪代码会是`UseMiddleware2();`。'
- en: '**Step 5**: `RequestDelegate`—`next(); ` is executed, which invokes the next
    middleware.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤 5**：执行`RequestDelegate`—`next();`，这会调用下一个中间件。'
- en: '**Step 6**: The code/logic of **Middleware 3** is executed. Based on this diagram,
    the request is handled here, but we can chain in as much middleware as we need. The
    pseudo code of **Middleware 3** in the `Configure(IApplicationBuilder app, IHostingEnvironment
    env)` method of `Startup.cs` can be either `UseMiddleware3();`, which doesn''t
    call `next();`, or it can simply be `RunMiddleware3();`, which short-circuits
    the pipeline. Normally, this would be the MVC `Routing` middleware, which would
    route the request to the MVC `Controller`, which processes the request and returns
    the response.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤6**：**中间件3**的代码/逻辑被执行。根据这个图表，请求在这里被处理，但我们可以根据需要链入尽可能多的中间件。在`Startup.cs`的`Configure(IApplicationBuilder
    app, IHostingEnvironment env)`方法中，**中间件3**的伪代码可以是`UseMiddleware3();`，它不调用`next();`，或者它可以是简单的`RunMiddleware3();`，这会短路管道。通常情况下，这会是MVC的`Routing`中间件，它会将请求路由到MVC的`Controller`，处理请求并返回响应。'
- en: '**Step 7**: As the request is handled in the last step, the response is returned
    to **Middleware 2**, which can do further processing of the response and return
    it.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤7**：由于请求在最后一步被处理，响应被返回到**中间件2**，它可以进一步处理响应并将其返回。'
- en: '**Steps 8 and 9**: Likewise, the response is processed in **Middleware 2**
    and **Middleware 1**.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤8和9**：同样，响应在**中间件2**和**中间件1**中被处理。'
- en: '**Step 10**: The processed response from all middleware is returned.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**步骤10**：所有中间件处理后的响应被返回。'
- en: 'If we look at the `Configure(IApplicationBuilder app, IHostingEnvironment env)`
    method in our `Startup.cs` class, we see the following code, which comes with
    the default MVC template:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`Startup.cs`类中的`Configure(IApplicationBuilder app, IHostingEnvironment
    env)`方法，我们会看到以下代码，这是默认MVC模板自带的内容：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'They say that a picture is worth a thousand words, so to understand this code
    in the context of the pipeline, if we draw the diagram for a non-developer environment
    (that is, `env.IsDevelopment() == false;`), here is roughly what it would look
    like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 他们常说“一图胜千言”，为了在管道的上下文中理解这段代码，如果我们为非开发者环境（即`env.IsDevelopment() == false;`）绘制图表，大致会是这个样子：
- en: '![](img/4fec7bc6-63d4-44e4-b1b2-7ce058dee3bb.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fec7bc6-63d4-44e4-b1b2-7ce058dee3bb.png)'
- en: We can see that, based on the code for the `else` case, the request first goes
    through the exception middleware through `app.UseExceptionHandler("/Home/Error");`.This
    is done to ensure that if any part of the code encounters the exception in the
    pipeline, it is handled by the exception handler, so it's kept first. From the
    diagram, we can note that during the request processing, the middleware does nothing,
    but just invokes the next middleware in the chain. This can be seen from the ASP.NET
    Core source code, which is freely available for everyone to see and learn from
    GitHub ([https://github.com/aspnet](https://github.com/aspnet)). I would highly
    encourage readers to browse the code and see the implementation for a better understanding
    of the way things have been implemented by the ASP.NET Core team.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，根据`else`情况的代码，请求首先通过`app.UseExceptionHandler("/Home/Error");`经过异常中间件。这样做是为了确保如果管道中的任何代码遇到异常，它将被异常处理器处理，因此它被放在第一位。从图表中，我们可以注意到在请求处理过程中，中间件不做任何事情，只是调用链中的下一个中间件。这可以从ASP.NET
    Core的源代码中看到，这些源代码在GitHub上免费提供给每个人查看和学习（[https://github.com/aspnet](https://github.com/aspnet)）。我强烈建议读者浏览代码，并查看ASP.NET
    Core团队实现的方式，以更好地理解这些实现。
- en: Next in line is the static file middleware, which serves static files such as
    `css`, `js`, `images`, and so on placed in the `wwwroot` folder. These should
    be served fast as it makes sense to keep this middleware early in the pipeline.
    If a request for a static file comes, the static file middleware serves the request
    and *short-circuits* the pipeline, so that other unnecessary code is not executed
    while serving the static file contents. This is configured through `app.UseStaticFiles();`.
    Then comes the MVC routing, which routes the incoming request to its desired controller
    action. We see that there are a number of items that are executed in this middleware.
    We will go into detail concerning each of these items in later sections and chapters,
    but the important stuff to note here is that the request is served from the controller
    action and then routed back through the same pipeline. The static file middleware
    has no role while a non-static file request is being served, and that becomes
    evident from the diagram. If there is an exception, it would be handled by the
    exception handler and the response is served back.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是静态文件中间件，它服务于放置在 `wwwroot` 文件夹中的静态文件，如 `css`、`js`、`images` 等。这些应该快速提供服务，因为将此中间件放在管道早期是有意义的。如果收到对静态文件的请求，静态文件中间件将处理请求并
    *短路* 管道，这样在服务静态文件内容时就不会执行其他不必要的代码。这是通过 `app.UseStaticFiles();` 配置的。然后是 MVC 路由，它将传入的请求路由到其所需的控制器操作。我们看到在这个中间件中执行了许多项。我们将在后面的章节中详细讨论这些项的每个细节，但这里要注意的重要事情是请求是从控制器操作服务，然后通过相同的管道路由回。当服务非静态文件请求时，静态文件中间件没有作用，这从图中可以明显看出。如果有异常，它将由异常处理器处理，并将响应返回。
- en: The first `app.Run` delegate terminates the pipeline. That is, after this, even
    if you add any further middleware or code, it will not be executed. Multiple request
    delegates or middleware can be chained using `app.Use`. The `next` parameter represents
    the next delegate in the pipeline. We can short-circuit the pipeline by not invoking
    the `next` action. Never call `next.Invoke` after the response has been sent to
    the client. Changes to `HttpResponse` after the response has started will throw
    an exception. The order in which middleware components are added in the `Configure`
    method defines the order in which they are invoked on the requests, and the reverse
    order for the response.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `app.Run` 代理终止了管道。也就是说，在此之后，即使你添加任何进一步的中间件或代码，它们也不会被执行。可以使用 `app.Use` 将多个请求代理或中间件链接起来。`next`
    参数代表管道中的下一个代理。我们可以通过不调用 `next` 动作来短路管道。响应发送到客户端后，切勿调用 `next.Invoke`。响应开始后对 `HttpResponse`
    的更改将抛出异常。在 `Configure` 方法中添加中间件组件的顺序定义了它们在请求上调用的顺序，以及响应的逆序。
- en: Hopefully, by now we have a relatively good understanding of the ASP.NET Core
    pipeline and middleware. Before we write middleware of our own and learn how to
    plug it into our pipeline, let's first learn about Dependency Injection, as it
    will be used extensively in whatever ASP.NET Core application that we write.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在为止，我们已经对 ASP.NET Core 管道和中间件有了相对较好的理解。在我们编写自己的中间件并学习如何将其连接到我们的管道之前，让我们首先了解依赖注入，因为它将在我们编写的任何
    ASP.NET Core 应用程序中得到广泛使用。
- en: Dependency Injection
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency Injection** (**DI**) is a software design pattern that enables
    us to develop loosely coupled code and is a great way to reduce tight coupling
    between software components. The **D** of the **SOLID** design principles stands
    for **Dependency Inversion Principle** (**DIP**), which states that "*high-level
    modules should not depend upon low-level modules. Both should depend on abstractions*".
    That is, it depends on abstractions, not on concrete implementations. If we speak
    in the language of the code, the class should not use new or static helper methods
    to populate its dependencies; it should rather have them injected. If you ever
    heard your architect or lead utter "*program to interfaces, not implementations*",
    it''s because he/she wants you to use DI. DI is the implementation of DIP**. **'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）是一种软件设计模式，它使我们能够开发松耦合的代码，并且是减少软件组件之间紧密耦合的绝佳方式。**SOLID** 设计原则中的
    **D** 代表 **依赖倒置原则**（**DIP**），它指出“**高层模块不应该依赖于低层模块。两者都应依赖于抽象**”。也就是说，它依赖于抽象，而不是具体的实现。如果我们用代码的语言来说，类不应该使用
    new 或静态辅助方法来填充其依赖项；它应该更倾向于注入它们。如果你曾经听到你的架构师或领导说过“**面向接口编程，而不是面向实现**”，那是因为他们想让你使用
    DI。DI 是 DIP 的实现。**'
- en: 'DI enables better:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: DI 使以下方面变得更好：
- en: Testability
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性
- en: Maintainability
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Reusability
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可重用性
- en: 'I am not great at dishing out examples, but let me give it a try with a real-world
    scenario. Suppose there is a boy who wants to get married. To get married, he
    needs a girl, so he is dependent on a girl for marriage. The pseudo code for this
    scenario would be roughly as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我在提供例子方面不是很好，但让我尝试用一个现实世界的场景来试试。假设有一个男孩想结婚。为了结婚，他需要一个女孩，因此他依赖于女孩来结婚。这个场景的伪代码大致如下：
- en: '[PRE8]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We notice that the `Boy` class has hard coupling with the `girl` class, as it
    gets a specific instance of the `girl` class in the `marriage` method and marries
    her. This hard coupling represents that the boy already has a girlfriend and so
    boy and girl are tightly linked. Well, most boys are not lucky (or unlucky, depending
    upon how you see it), enough to have a girlfriend. Also, the preceding code might
    not work for all scenarios, such as if the boy doesn't have a girlfriend or if
    the parents find a girl for the boy.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`Boy`类与`girl`类存在硬耦合，因为它在`marriage`方法中获取`girl`类的特定实例并与之结婚。这种硬耦合表示男孩已经有了女朋友，因此男孩和女孩紧密相连。嗯，大多数男孩（或不幸，取决于你怎么看）都不够幸运（或不幸运）有女朋友。此外，前面的代码可能不适用于所有场景，例如如果男孩没有女朋友或如果父母为男孩找到一个女孩。
- en: 'A better way of implementing the preceding code would be to remove the hard-coupling
    of the girl by injecting the `girl` object from outside. With this, the `GetMarried`
    method is generic as it, removes the hard-coupling of the `girl` class, and will
    work for all boys, depending on the `girl` object passed:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现上述代码的更好方式是移除通过从外部注入`girl`对象而导致的硬耦合。这样，`GetMarried`方法就变得通用，因为它移除了`girl`类的硬耦合，并且将适用于所有男孩，取决于传递的`girl`对象：
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is the simplest example of DI, in which rather than creating a new instance
    of a dependent object, we inject the dependency from outside. There are various
    ways in which dependency can be injected. We will discuss only a few here, with
    reference to classes and interfaces, as follows.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DI（依赖注入）最简单的例子，其中不是创建一个依赖对象的新的实例，而是从外部注入依赖。依赖项可以以多种方式注入。在这里，我们将仅讨论其中的一些，并参考类和接口，如下所示。
- en: 'Let us suppose we have two classes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个类：
- en: '`CoreClass` is the main class implementing the `ICore` interface'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreClass`是实现`ICore`接口的主要类'
- en: '`DependencyClass` is the class implementing the `IDependency` interface, so
    that `CoreClass` is dependent on `DependencyClass:`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DependencyClass`是实现`IDependency`接口的类，这样`CoreClass`就依赖于`DependencyClass`：'
- en: '[PRE10]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Taking the preceding classes and interfaces as a reference, we can inject the
    dependency in the following ways:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以前面的类和接口为参考，我们可以以下列方式注入依赖项：
- en: '**Constructor injection**: In constructor injection, the dependency object
    is injected at the time of constructing the object, that is, in the constructor
    of the class. This way, the dependency is clearly spelled out at the time of the
    object''s creation. The disadvantages are that once the object is created, the
    dependency cannot be changed and since the dependency is injected in the constructor,
    the class doesn''t have a default parameterless constructor. The constructor-injected
    code for the preceding class would look like this:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数注入**：在构造函数注入中，依赖对象在对象构造时注入，即在类的构造函数中。这样，依赖项在对象创建时就明确指出了。缺点是，一旦对象被创建，依赖项就不能更改，并且由于依赖项是在构造函数中注入的，因此类没有默认的无参数构造函数。前面类的构造函数注入代码如下：'
- en: '[PRE11]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Property setter injection**: In property injection, the dependency object
    is injected as a property setter. This way, the default construction of the class
    continues to exist and the dependency can be changed, even after object''s creation,
    by just setting the property. The disadvantage is that since the dependency is
    not injected at the time of the object creation, the dependency to be set can
    be missed and hence may result in runtime errors. The property injected code would
    look like this:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性设置器注入**：在属性注入中，依赖对象作为属性设置器被注入。这样，类的默认构造函数仍然存在，并且可以在对象创建后更改依赖项，只需设置属性即可。缺点是，由于依赖项不是在对象创建时注入的，因此可能错过要设置的依赖项，从而导致运行时错误。注入属性的代码看起来像这样：'
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding `CoreClass` class, there is a property named `Dependency` of
    type `IDependency` that is needed for the class to function correctly. However,
    if the developer just initializes `CoreClass` by creating a new instance of it
    and forgets to set the `Dependency` property, we may encounter a runtime exception.
    In contrast, in constructor injection, since the dependency is passed at the time
    of the object's creation, we are never at risk of such issues.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`CoreClass`类中，有一个名为`Dependency`的属性，其类型为`IDependency`，这是类正常工作所必需的。然而，如果开发人员只是通过创建其新实例来初始化`CoreClass`，并忘记设置`Dependency`属性，我们可能会遇到运行时异常。相比之下，在构造函数注入中，由于依赖项是在对象创建时传递的，所以我们永远不会面临此类问题。
- en: We have seen how dependencies can be injected. Imagine a system where we have
    numerous classes in which dependency needs to be injected. If we follow any one
    the preceding approaches for injection and create the objects at every place where
    they are needed, it will become spaghetti code or become completely messed up.
    It is therefore meaningful to have classes to create these classes and inject
    dependencies as needed. These classes are called containers, DI containers, **Inversion
    of Control** (**IoC**) containers. A container can be thought of as a factory
    that is responsible for providing instances of types that are requested from it.
    If a given type has declared that it has dependencies, and the container has been
    configured to provide the dependency types, it will create the dependencies as
    part of creating the requested instance. In this way, complex dependency graphs
    can be provided to classes without the need for any hardcoded object construction.
    In addition to creating objects with their dependencies, containers typically
    manage object lifetimes within the application.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何进行依赖注入。想象一个系统中存在许多类，这些类都需要进行依赖注入。如果我们遵循上述任何一种注入方法并在需要的地方创建对象，代码将变得混乱不堪。因此，有意义的是拥有创建这些类并按需注入依赖项的类。这些类被称为容器，依赖注入容器，**控制反转**（**IoC**）容器。容器可以被视为一个工厂，负责提供请求的类型实例。如果给定类型已声明它有依赖项，并且容器已配置为提供依赖类型，它将在创建请求实例的过程中创建依赖项。这样，可以无需任何硬编码的对象构造，将复杂的依赖关系图提供给类。此外，除了创建具有其依赖项的对象外，容器通常还管理应用程序中的对象生命周期。
- en: ASP.NET Core comes with a very simple built-in container (the `IServiceProvider`
    interface) that supports constructor injection by default. ASP.NET's container
    refers to the types it manages as services. These services can be injected into
    the container in the `ConfigureServices` method of the ASP.NET Core application's
    `Startup` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core附带一个非常简单的内置容器（`IServiceProvider`接口），默认支持构造函数注入。ASP.NET的容器将其管理的类型称为服务。这些服务可以在ASP.NET
    Core应用程序的`Startup`类的`ConfigureServices`方法中注入到容器中。
- en: There are certain facts about the inbuilt ASP.NET Core container that we need
    to be aware of to make correct use of DI in the app.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解有关内置ASP.NET Core容器的某些事实，以便正确地在应用程序中使用依赖注入。
- en: The constructor for the dependency that should be resolved must have a `public`
    access modifier.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应该解析的依赖项的构造函数必须具有`public`访问修饰符。
- en: There should be only one constructor that gets resolved with a given set of
    parameters. Constructor overloads are supported, but only one overload can exist,
    whose arguments can all be fulfilled by DI. If multiple constructors exist, you
    may encounter `InvalidOperationException`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 应只有一个构造函数，该构造函数与一组给定的参数相匹配。支持构造函数重载，但只能存在一个重载，其参数都可以通过依赖注入（DI）来满足。如果存在多个构造函数，可能会遇到`InvalidOperationException`。
- en: 'Notice the signature of the `ConfigureServices` method in the `Startup` class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Startup`类中`ConfigureServices`方法的签名：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method exposes the `IServicesCollection`, where we can add our own services/types
    as needed. This can be done by the following extension methods in the `Microsoft.Extensions.DependencyInjection`
    namespace:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法暴露了`IServicesCollection`，我们可以根据需要添加自己的服务/类型。这可以通过`Microsoft.Extensions.DependencyInjection`命名空间中的以下扩展方法来完成：
- en: '`AddTransient`: Use this extension method to instantiate types that should
    be created each time they are requested. This should be used for lightweight,
    stateless services.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTransient`：使用此扩展方法来实例化每次请求时都应该创建的类型。这应该用于轻量级、无状态的服务。'
- en: '`AddScoped`: Use this extension method to instantiate types that should be
    created once per request. Types that are based on requests should be instantiated
    on a per-request basis and hence should be created by this method.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddScoped`：使用这个扩展方法来实例化每次请求都应创建一次的类型。基于请求的类型应根据请求进行实例化，因此应由该方法创建。'
- en: '`AddSingleton`: Use this extension method to create types that should be instantiated only
    once and should be used throughout the life cycle of the application. A common
    example of this scenario is caching. One instance is good enough for the application.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddSingleton`：使用这个扩展方法来创建只应实例化一次并在应用程序的生命周期中使用的类型。这种场景的一个常见例子是缓存。一个实例对于应用程序来说就足够了。'
- en: My architect calls these *every time, sometimes, and one time*, respectively.
    Transients are created every time they are requested; scoped are created once
    per request, so sometimes. Singletons are created once in the lifetime of the
    application, so one time. Nice way to remember!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我的架构师将这些分别称为*每次、有时和一次*。瞬态每次请求时都会创建；作用域每次请求时创建，所以有时。单例在整个应用程序的生命周期中只创建一次，所以一次。这是一个很好的记忆方式！
- en: 'On a lighter note and to digest the concept: the **Prime Minister** (**PM**)
    of a nation can be a good example of a singleton. Irrespective of where and how
    many times he/she is needed, there is one and only one PM, so the PM is a singleton.
    Likewise, examples of transient and scoped can be formed. This is left as an exercise
    and teaser to readers to come up with real-world examples of transient and scoped.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在轻松的气氛中消化这个概念：一个国家的**总理**（**PM**）可以作为一个单例的例子。无论何时何地以及需要多少次，都只有一个总理，因此总理是一个单例。同样，可以形成瞬态和作用域的例子。这留作读者练习和悬念，以提供瞬态和作用域的真实世界例子。
- en: Each of these extension methods have seven or more overloads to provide flexibility
    and cater to different needs, such as passing the concrete instance or providing
    a factory method to create the object. Readers should have a good look at the
    overloads and make effective use of these methods. The easiest way to do so is
    either to use *F12* on one of these extension methods in Visual Studio and read
    the method documentation, or use the object browser of Visual Studio, or browse
    the source code on GitHub ([https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展方法都有七个或更多的重载，以提供灵活性并满足不同的需求，例如传递具体实例或提供工厂方法来创建对象。读者应该仔细查看重载，并有效地使用这些方法。这样做最简单的方法是，在Visual
    Studio中，对其中一个扩展方法使用*F12*来阅读方法文档，或者使用Visual Studio的对象浏览器，或者浏览GitHub上的源代码（[https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example)）。
- en: 'I will list a few of the ways by which we can inject the types/services:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我将列出几种我们可以注入类型/服务的方法：
- en: '[PRE14]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This concludes our discussion on DI. For a more detailed and extensive dive
    into DI in ASP.NET Core 2.0, please visit [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对依赖注入的讨论结束。有关ASP.NET Core 2.0中依赖注入的更详细和广泛的探讨，请访问[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection)。
- en: How do you write custom middleware?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你如何编写自定义中间件？
- en: Now is the right time to create simple middleware of our own and plug it into
    the pipeline, so that all this theory that we have gone through ends with a practical
    example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是创建我们自己的简单中间件并将其插入管道的合适时机，这样我们就可以通过一个实际例子来结束我们所学到的所有理论。
- en: 'We can write either inline middleware or a neatly written class which can be
    configured at the startup. We will write both:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写内联中间件或整洁的类，该类可以在启动时进行配置。我们将编写两者：
- en: '[PRE15]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the simplest middleware that one can write. This is the `Run` middleware
    and short-circuits the pipeline  after execution, and just sends a response with
    the message `".NET Core 2.0 By Example"`. It has been plugged with this code into
    the `Configure` method of `Startup.cs/`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的中间件之一。这是`Run`中间件，在执行后短路管道，并仅发送带有消息`".NET Core 2.0 By Example"`的响应。它已经通过以下代码插入到`Startup.cs/`的`Configure`方法中。
- en: Having seen inline middleware, let's write the more serious middleware that
    you would write in your app.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到了内联中间件之后，让我们编写你会在应用程序中编写的更严肃的中间件。
- en: Let's begin by creating a class called `MyFirstMiddleware`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为`MyFirstMiddleware`的类开始。
- en: 'Since middleware is just a request delegate that processes the request/response
    and then invokes the next one in the chain, the following is how we would create
    the class for middleware. Notice the next request delegate is expected to be resolved
    by DI. It''s a pretty simple class, consisting of:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于中间件只是一个处理请求/响应并调用链中下一个代理的请求代理，以下是如何创建中间件类的示例。注意，下一个请求代理预期将由 DI 解决。这是一个相当简单的类，由以下内容组成：
- en: A `readonly` field to hold the reference to the next `RequestDelegate`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `readonly` 字段，用于保存对下一个 `RequestDelegate` 的引用。
- en: A constructor that expects the next `RequestDelegate` to be executed as the
    parameter. During construction, it sets the field with the reference of the next
    request delegate.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，它期望将下一个 `RequestDelegate` 作为参数执行。在构造过程中，它设置字段以引用下一个请求代理。
- en: An `Invoke` method that takes an `HttpContext` object to fiddle with and then
    passes it along to the next middleware.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Invoke` 方法，它接受一个 `HttpContext` 对象进行操作，然后将它传递给下一个中间件。
- en: 'Let''s have a look at the code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this, we have our simple middleware code ready. However, we are yet to
    plug it into our app pipeline. To do so, we will create an extension method of
    `IApplicationBuilder`, which internally uses the `UseMiddleware&lt;T&gt;` method
    to register the middleware, as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经准备好了简单的中间件代码。然而，我们还没有将其连接到我们的应用程序管道。为此，我们将创建一个 `IApplicationBuilder`
    的扩展方法，它内部使用 `UseMiddleware<T>` 方法来注册中间件，如下所示：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, to plug it into our pipeline, go to the `Configure` method of the `Startup`
    class and add the middleware with a simple single line of code, `app.UseMyFirstMiddleware();`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将它连接到我们的管道，请转到 `Startup` 类的 `Configure` 方法，并使用简单的一行代码添加中间件，`app.UseMyFirstMiddleware();`。
- en: With this, we have created our very first middleware and plugged it into our
    app pipeline. Sweet, short, and simple!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经创建了我们的第一个中间件并将其连接到我们的应用程序管道。太棒了，简单又快捷！
- en: Next, we will look at the configuration providers in ASP.NET Core and how we
    can read configuration and use it in our app.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨 ASP.NET Core 中的配置提供程序以及我们如何读取配置并在我们的应用程序中使用它。
- en: Extension methods in C# allow us to extend an existing type with new functionality,
    and add new methods to it, without having to derive or recompile the old type. Extension
    methods are a special kind of static method, but they are called as if they are
    instance methods on the extended type.  The most common extension methods are
    the `LINQ` standard query operators. ASP.NET Core makes extensive use of extension
    methods for registering services.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的扩展方法允许我们通过新功能扩展现有类型，并向其添加新方法，而无需派生或重新编译旧类型。扩展方法是一种特殊的静态方法，但它们被调用时就像它们是扩展类型的实例方法一样。最常用的扩展方法是
    `LINQ` 标准查询运算符。ASP.NET Core 广泛使用扩展方法来注册服务。
- en: Configuration
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: When we develop ASP.NET Core web apps, we will quickly realize that we need
    to change a few settings at runtime. To give an example, consider a web application
    that makes API calls to the service. When you develop the web app, the service
    is deployed in some development server and when you deploy it in production, the
    service URL is different, so the URL should not be hardcoded in the application.
    Instead, it should be read from the configuration, so that it can be changed without
    having to recompile the code. Another often used example is that of database connection
    strings, if the app makes use of them. This section takes a look at how we can
    accomplish this in ASP.NET Core.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开发 ASP.NET Core 网络应用程序时，我们会很快意识到我们需要在运行时更改一些设置。以一个向服务发出 API 调用的网络应用程序为例。当你开发网络应用程序时，服务部署在一些开发服务器上，当你将其部署到生产环境中时，服务
    URL 是不同的，因此 URL 不应该硬编码在应用程序中。相反，它应该从配置中读取，这样就可以在不重新编译代码的情况下进行更改。另一个常用的例子是数据库连接字符串，如果应用程序使用它们。本节将探讨我们如何在
    ASP.NET Core 中实现这一点。
- en: 'The ASP.NET Core configuration model has three main constructs of interest:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 配置模型有三个主要的感兴趣的结构：
- en: '`ConfigurationProvider`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationProvider`'
- en: '`ConfigurationRoot`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationRoot`'
- en: '`ConfigurationBuilder`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConfigurationBuilder`'
- en: 'As shown in the following screenshot, the map diagram is constructed from `Microsoft.Extensions.Configuration`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，映射图是由 `Microsoft.Extensions.Configuration` 构建的：
- en: '![](img/5f65ea3a-6b35-406a-8610-583dfe10861d.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f65ea3a-6b35-406a-8610-583dfe10861d.png)'
- en: '`ConfigurationProvider` is abstracted from the developer and hence we would
    not see it, but it''s good to know that there is support for multiple configuration
    providers. A few of the important ones are:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigurationProvider`被开发者抽象化，因此我们不会看到它，但了解存在对多个配置提供者的支持是好的。其中一些重要的提供者包括：'
- en: '**JSON file**: Reads the JSON file in the app''s `Startup` folder and configures
    the application'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON文件**：读取应用程序`Startup`文件夹中的JSON文件并配置应用程序'
- en: '**Command-line arguments**: While launching the app, command-line arguments
    can be passed as a key value to configure the application'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行参数**：在启动应用程序时，可以将命令行参数作为键值传递来配置应用程序'
- en: '**Environment variables**: Setting the environment variables, the provider
    reads the environment variable and takes care of configuration'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：设置环境变量，提供者会读取环境变量并处理配置'
- en: '**Azure Key Vault**: We will cover this in later chapters when we discuss Azure,
    but as the name suggests, it is a key vault.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure密钥保管库**：我们将在讨论Azure的后续章节中介绍这个内容，但正如其名称所暗示的，它是一个密钥保管库。'
- en: 'So in a single app, we can choose to read a few configurations from the JSON
    file, a few from the command line, and so on. When we add multiple providers,
    it''s important to consider the order in which we add them, as that defines the
    order in which the configuration values are added to the underlying dictionary.
    Configuration values from later providers will overwrite values with the same
    key from earlier providers. Also, we can notice in the diagram that there is a
    `GetReloadToken` method in `ConfigurationProvider` and a `Reload` method in `ConfigurationRoot`
    as well. If we read the documentation (using *F12* in Visual Studio), we know
    that the configuration system supports reloading the configuration without having
    to restart the web app, which is fantastic. Let''s see how we can read the configuration. The
    default `Startup.cs` comes with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个单一的应用程序中，我们可以选择从JSON文件中读取一些配置，从命令行读取一些，等等。当我们添加多个提供者时，考虑添加它们的顺序很重要，因为这定义了配置值添加到基础字典中的顺序。较晚提供者的配置值将覆盖较早提供者具有相同键的值。此外，我们还可以在图中注意到`ConfigurationProvider`中有一个`GetReloadToken`方法，在`ConfigurationRoot`中也有一个`Reload`方法。如果我们阅读文档（在Visual
    Studio中使用*F12*），我们知道配置系统支持在不重新启动Web应用程序的情况下重新加载配置，这是非常棒的。让我们看看我们如何读取配置。默认的`Startup.cs`包含以下代码：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that we already have the `IConfiguration` interface injected in the `Startup`
    constructor, which sets the `Configuration` property of the `Startup`. Also notice
    that when we create an app from the template, `appsettings.json` is included by
    default. Essentially, the default code has already wired up JSON-based configuration
    for us and we can leverage its goodness without having to code anything extra.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们已经在`Startup`构造函数中注入了`IConfiguration`接口，这设置了`Startup`的`Configuration`属性。另外，请注意，当我们从模板创建应用程序时，默认包含`appsettings.json`。本质上，默认代码已经为我们连接了基于JSON的配置，我们无需编写额外的代码即可利用其优点。
- en: 'To make effective use of the `Configuration` property, lets do *F12* (go to
    definition) on `IConfiguration` and check out its properties. The following is
    the code that comes up in Visual Studio:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用`Configuration`属性，让我们在`IConfiguration`上执行*F12*（转到定义）来查看其属性。以下是在Visual
    Studio中出现的代码：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, we see that we can get the value of a key through the indexer property,
    passing in the key to look up. We can get children, get a reload token, or get
    a specific section by giving the key. This documentation makes our task of using
    the configuration extremely easy. Let''s see an example. First, define the config
    that we want to read, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到我们可以通过索引器属性获取键的值，通过传递要查找的键。我们可以获取子项，获取一个重新加载令牌，或者通过提供键来获取特定的部分。这份文档使我们的配置使用任务变得极其简单。让我们看看一个例子。首先，定义我们想要读取的配置，如下所示：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code to read the values would be:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 读取值的代码如下：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we used a zero-based index to access the contents of an array. The
    rest of the keys are read  just by passing in the correct key to the `Configuration`
    indexer, as we have just seen.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们使用零基索引来访问数组的元素。其余的键可以通过传递正确的键到`Configuration`索引器来读取，正如我们刚才看到的。
- en: 'We generally use different configuration settings for different environments.
    For example, Development, Test, Staging, and Production may all have different
    configuration settings. The `CreateDefaultBuilder` extension method in an ASP.NET
    Core 2.0 app adds configuration providers for reading JSON files and environment
    variables in the following order:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常为不同的环境使用不同的配置设置。例如，开发、测试、预发布和生产可能都有不同的配置设置。在 ASP.NET Core 2.0 应用中，`CreateDefaultBuilder`
    扩展方法添加了以下顺序的配置提供程序来读取 JSON 文件和环境变量：
- en: '`appsettings.json`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appsettings.json`'
- en: '`appsettings.&lt;EnvironmentName&gt;.json`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`appsettings.&lt;EnvironmentName&gt;.json`'
- en: Environment variables
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Here, `appsettings.&lt;EnvironmentName&gt;.json` would overwrite the key values
    defined in `appsettings.json` and the environment variables would overwrite the
    key values defined before them.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`appsettings.&lt;EnvironmentName&gt;.json` 将覆盖 `appsettings.json` 中定义的键值，而环境变量将覆盖之前定义的键值。
- en: 'This didn''t need any code changes in our `Startup` class. However, if we wish
    to use any other named config file, then we will need the code to be changed.
    The following example uses `config.json` as the configuration file, followed by
    `config.Development.json`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这不需要在我们的 `Startup` 类中进行任何代码更改。然而，如果我们希望使用任何其他命名的配置文件，那么我们需要更改代码。以下示例使用 `config.json`
    作为配置文件，然后是 `config.Development.json`：
- en: '[PRE22]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A thoughtful programmer would say that in my `appsettings.json`, there may
    be a variety of sections for caching, database connection strings, service URLs,
    and so on. Why should I pass on all these values to every place? For example,
    what has caching to do with the database connection strings section or the service
    URL? Looks like there is no separation of concerns, and a clear violation of the **I**
    of **SOLID**: **Interface Segregation Principle**. Why should caching depend on
    `IConfiguration` when it needs just a subsection of it? To prevent these violations,
    it is *not* recommended to use the preceding way to access settings if configurations
    are to be read outside of `Startup.cs`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个深思熟虑的程序员会说，在我的 `appsettings.json` 中，可能会有各种用于缓存、数据库连接字符串、服务 URL 等的章节。为什么我要将这些值传递到每个地方呢？例如，缓存与数据库连接字符串章节或服务
    URL 有什么关系？看起来这里没有职责分离，明显违反了 **SOLID** 的 **I**（接口隔离原则）：**接口隔离原则**。为什么缓存需要依赖于 `IConfiguration`，而它只需要它的一个子集？为了防止这些违规行为，如果配置要在
    `Startup.cs` 之外读取，则不建议使用前面提到的方式来访问设置。
- en: 'We should instead use what is called the `Options` pattern. Using it is simple:
    first create a simple **Plain Old CLR O****bject** (**POCO**) class and then use
    it by registering it as a service and consume it wherever we need. It''s a simple
    and dumb class with properties and no logic or smartness.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用所谓的 `Options` 模式。使用它很简单：首先创建一个简单的 **Plain Old CLR Object**（**POCO**）类，然后通过将其注册为服务并在需要的地方消费它来使用它。这是一个简单的、无脑的类，具有属性但没有逻辑或智能。
- en: 'The POCO class for the preceding example would be:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的 POCO 类将是：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To register it, we go to the `ConfigureServices` method in `Startup.cs` and
    add the following line:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册它，我们进入 `Startup.cs` 中的 `ConfigureServices` 方法并添加以下行：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`BookDetails` will be populated and added to the container. To use it in the
    controller, the following code would suffice:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookDetails` 将会被填充并添加到容器中。要在控制器中使用它，以下代码就足够了：'
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The properties can now be used from the strongly typed object, `details`. If
    you wish to overwrite certain properties after the configuration is bound, you
    can do the following in the `ConfigureService` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以从强类型对象 `details` 中使用属性。如果你希望在配置绑定后覆盖某些属性，你可以在 `ConfigureService` 方法中执行以下操作：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This changes the name of the book to `"Roslyn Via C#"`. This is a last-one-wins
    approach, in which what is done last prevails.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将书的名称更改为 `"Roslyn Via C#"`。这是一个“后发制人”的方法，即最后执行的操作占上风。
- en: Another question that comes to mind is what if my configuration value changes,
    do I restart my app like in the old days when modifying the `web.config` used
    to restart the app? No, we have this covered in ASP.NET Core. For this, we need
    to use `IOptionsSnapshot`, which is designed to support the reloading of configuration
    data when the configuration file changes. Using `IOptionsSnapshot` with the `reloadOnChange`
    flag set to `true`, the options are bound to the configuration and reloaded when
    the file changes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题浮现在脑海中：如果我的配置值发生变化，我是否需要像过去修改 `web.config` 时那样重启我的应用程序？不，在 ASP.NET Core
    中我们已经考虑了这一点。为此，我们需要使用 `IOptionsSnapshot`，它被设计用来支持配置文件更改时配置数据的重新加载。使用带有 `reloadOnChange`
    标志设置为 `true` 的 `IOptionsSnapshot`，当文件更改时，选项会被绑定到配置并重新加载。
- en: From the preceding sample, we just need to change `IOptions` to `IOptionsSnapshot`
    and add a flag, `reloadOnChange`, to `true` while adding the JSON file in the `AddJsonFile`
    method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们只需要在 `AddJsonFile` 方法中添加 JSON 文件时，将 `IOptions` 更改为 `IOptionsSnapshot`
    并添加一个标志 `reloadOnChange` 设置为 `true`。
- en: 'Let''s take a step back and look at our `Program.cs`, which is the entry point
    of the application:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看我们的 `Program.cs` 文件，它是应用程序的入口点：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `CreateDefaultBuilder` loads optional configurations from `appsettings.json`, `appsettings.{Environment}.json`,
    User Secrets (in the Development environment), environment variables, and command-line
    arguments. The `CommandLine` configuration provider is called last. Calling the
    provider last allows the command-line arguments passed at runtime to override
    the configuration set by the other configuration providers called earlier, by
    the last-one-wins approach. Also, it is important to note that `reloadOnChange` is
    enabled for the `appsettings` file and so command-line arguments are overridden
    if a matching configuration value in an `appsetting*s*` file is changed after
    the app starts.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateDefaultBuilder` 加载来自 `appsettings.json`、`appsettings.{Environment}.json`、用户机密（在开发环境中）、环境变量和命令行参数的可选配置。最后调用
    `CommandLine` 配置提供程序。将提供程序放在最后调用允许在运行时传递的命令行参数通过“后到先得”的方法覆盖之前调用的其他配置提供程序设置的配置。此外，重要的是要注意，`reloadOnChange`
    对 `appsettings` 文件是启用的，因此如果应用程序启动后 `appsettings` 文件中的匹配配置值发生变化，则命令行参数将被覆盖。'
- en: When we work in enterprise applications, we will realize that there are a variety
    of configuration settings, such as secrets, passwords, and so on, that should
    not be kept in configuration files and hence should be kept out of the application
    code. Also, as a best practice, we should not be using production secrets in our
    development environment. In production also, these should be read from Azure Key
    Vault, which we will look at in later chapters. In the development environment,
    we can use the Secret Manager tool to safeguard secrets.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在企业应用程序中工作时，我们会意识到存在各种配置设置，例如机密、密码等，这些不应该保存在配置文件中，因此应该从应用程序代码中排除。此外，作为一个最佳实践，我们不应该在我们的开发环境中使用生产机密。在生产环境中，这些也应该从
    Azure Key Vault 中读取，我们将在后面的章节中探讨这一点。在开发环境中，我们可以使用 Secret Manager 工具来保护机密。
- en: 'Before seeing how to use User Secrets, a question comes to mind: is that why
    we don''t use environment variables to keep secrets away from the application,
    as it is supported by ASP.NET Core and is also there by default in the template
    code? Yes, we can use environment variables. However, environment variables are
    stored as plain text and can be accessed from any third-party code, so we can
    use them in local development but should not rely on them for production deployments.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到如何使用用户机密之前，一个问题浮现在脑海中：这是否意味着我们不使用环境变量来将机密与应用程序隔离开，因为 ASP.NET Core 支持，并且在模板代码中默认存在？是的，我们可以使用环境变量。然而，环境变量以纯文本形式存储，可以被任何第三方代码访问，因此我们可以在本地开发中使用它们，但不应该依赖它们进行生产部署。
- en: 'The Secret Manager tool is just a fancy name given to store the secrets of
    a .NET Core project outside of the code base during development. The data stored
    is *not* encrypted. The only advantage this approach provides is that the secrets
    would not be part of the code and hence will not be checked in the source control,
    and so the secret will remain a secret during development. The secret is stored
    in a JSON file, which is kept in the user profile folder. To set up the User Secret
    tool, edit the `.csproj` file and add the following line in the `ItemGroup` node:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密管理器工具只是给在开发期间将 .NET Core 项目的秘密存储在代码库之外的一个花哨的名字。存储的数据*不是*加密的。这种方法提供的唯一优势是秘密不会成为代码的一部分，因此不会在源控制中检查，因此在开发期间秘密将保持秘密。秘密存储在一个
    JSON 文件中，该文件保存在用户配置文件文件夹中。要设置用户秘密工具，编辑 `.csproj` 文件，并在 `ItemGroup` 节点中添加以下行：
- en: '[PRE28]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So the final code looks like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的代码看起来像这样：
- en: '[PRE29]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save the `.csproj` file. This will restore the package we just added. Now, right-click
    the project in the Solution Explorer and select Manage User Secrets. This will
    add a new node named `UserSecretId` in the `PropertyGroup`. Save the file. A file
    named `secrets.json` will open up in Visual Studio. Hover over it and see the
    path. It will be `%AppData%\microsoft\UserSecrets\&lt;userSecretsId&gt;\secrets.json`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 `.csproj` 文件。这将恢复我们刚刚添加的包。现在，在解决方案资源管理器中右键单击项目，并选择管理用户秘密。这将向 `PropertyGroup`
    中添加一个名为 `UserSecretId` 的新节点。保存文件。Visual Studio 将打开一个名为 `secrets.json` 的文件。将鼠标悬停在其上，查看路径。它将是
    `%AppData%\microsoft\UserSecrets\<userSecretsId>\secrets.json`。
- en: 'Now we can add key value-pairs in the JSON file, just like we did for the configuration
    file. To read them, we need to add a couple of lines of code in our startup, as
    shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像配置文件一样在 JSON 文件中添加键值对。要读取它们，我们需要在我们的启动代码中添加几行代码，如下所示：
- en: '[PRE30]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, we can access the secret, just like we access anything else from
    the configuration:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以像访问其他任何配置项一样访问秘密：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This concludes our configuration discussion. Let's check out how we can do logging.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们的配置讨论。让我们看看我们如何进行日志记录。
- en: Logging
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: ASP.NET Core supports the logging API, which works with a wide variety of logging
    providers. We can write logs to one or more locations and we can also plug in
    third-party logging frameworks, such as NLog, Serilog, and so on. In this section,
    we will look at out-of-the box logging, as it is sufficient for the logging needs
    of most apps.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 支持日志记录 API，它可以与各种日志记录提供者一起工作。我们可以将日志写入一个或多个位置，也可以集成第三方日志记录框架，如
    NLog、Serilog 等。在本节中，我们将查看开箱即用的日志记录，因为它足以满足大多数应用程序的日志记录需求。
- en: 'Let''s see the architecture of the logging infrastructure. The code map diagram
    for logging is shown here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看日志记录基础设施的架构。日志记录的代码映射图如下所示：
- en: '![](img/ea861236-f127-49cb-814c-50edc17cce06.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea861236-f127-49cb-814c-50edc17cce06.png)'
- en: 'As we can see, it consists of the following main components:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它由以下主要组件组成：
- en: '`ILogger/ ILogger&lt;TCategoryName&gt;`: We will use this in our app to log
    messages. We can see it has the`IsEnabled()` method to check whether logging is
    enabled and `Log` to write the log.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILogger/ ILogger<TCategoryName>`：我们将在我们的应用程序中使用这个来记录消息。我们可以看到它有一个 `IsEnabled()`
    方法来检查日志记录是否启用，以及一个 `Log` 方法来写入日志。'
- en: '`ILoggerFactory`: It has a method to add a provider and logger.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILoggerFactory`：它有一个添加提供者和日志记录器的方法。'
- en: '`ILoggerProvider`: It has a method to create the logger and it will control
    the output location of the log.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ILoggerProvider`：它有一个创建日志记录器的方法，它将控制日志的输出位置。'
- en: We also notice the `EventId`, `LogLevel` enumeration, and extensions for registering
    the logging.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到 `EventId`、`LogLevel` 枚举以及用于注册日志的扩展。
- en: 'We can configure logging at the time of building the `WebHost` in the `Program.cs`
    file, as shown here:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Program.cs` 文件中构建 `WebHost` 的时候配置日志记录，如下所示：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code configures the logging to read the logging configuration section
    provided in `appsettings.json` and adds console and debug logging. Alternatively,
    we can inject `ILoggerFactory` as a parameter in the `Configure` method of `Startup.cs`
    and configure `loggerFactory` , as shown here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码配置了日志记录以读取 `appsettings.json` 中提供的日志记录配置部分，并添加了控制台和调试日志记录。或者，我们可以将 `ILoggerFactory`
    作为参数注入到 `Startup.cs` 的 `Configure` 方法中，并配置 `loggerFactory`，如下所示：
- en: '[PRE33]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Like any other type or service in the ASP.NET Core application, the logger is
    also injected into a class or controller through DI.  Here we inject `ILogger&lt;T&gt;`,
    where `T` is the name of the class. The type parameter `T` is used to define the *category*
    as it follows the `ILogger&lt;TCategoryName&gt;` interface.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 ASP.NET Core 应用程序中的任何其他类型或服务一样，日志记录器也是通过依赖注入 (DI) 注入到类或控制器中的。在这里，我们注入 `ILogger<T>`，其中
    `T` 是类的名称。类型参数 `T` 用于定义 *类别*，因为它遵循 `ILogger<TCategoryName>` 接口。
- en: 'For example, to write a log message in an ASP.NET Core controller, `HomeController`,
    we would inject the `ILogger&lt;HomeController&gt;` and call one of the logging
    extension methods on `ILogger`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在 ASP.NET Core 控制器 `HomeController` 中编写日志消息，我们需要注入 `ILogger<HomeController>`
    并在 `ILogger` 上调用其中一个日志扩展方法：
- en: '[PRE34]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will write a log message to each output of the configured logging providers.
    The following is what it would look like in the console:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将日志消息写入配置的日志提供程序的每个输出。以下是在控制台中的样子：
- en: '![](img/d61c6be4-43d1-4d95-a8be-65da5cd28beb.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d61c6be4-43d1-4d95-a8be-65da5cd28beb.jpg)'
- en: 'ASP.NET Core includes numerous logging providers out of the box, which we can
    use to write log messages to various locations:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 默认包含许多日志提供程序，我们可以使用它们将日志消息写入各种位置：
- en: '**Console provider**: To write log messages to the console'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台提供程序**：将日志消息写入控制台'
- en: '**Debug provider**: To write log messages to the Debug window while debugging
    in Visual Studio'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试提供程序**：在 Visual Studio 调试时将日志消息写入调试窗口'
- en: '**EventSource provider**: To write log messages using Event Tracing for Windows'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EventSource 提供程序**：使用 Windows 事件跟踪写入日志消息'
- en: '**Event Log provider**: To write log messages to the Windows event log'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件日志提供程序**：将日志消息写入 Windows 事件日志'
- en: There is support for third-party structured logging as well, which is greatly
    useful, as it makes finding and diagnosing issues easier in production. Structured
    logging involves associating key-value pairs with each log entry, instead of a
    simple string of messages. We will not delve into this discussion, but it's good
    to know and the reader should take it up as an exercise to explore and implement
    structured logging with ASP.NET Core apps.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 同样支持第三方结构化日志，这非常有用，因为它使得在生产环境中查找和诊断问题变得更加容易。结构化日志涉及将键值对与每个日志条目关联起来，而不是简单的消息字符串。我们不会深入讨论这个问题，但了解这一点是好的，读者可以将它作为练习来探索和实现使用
    ASP.NET Core 应用程序的结构化日志。
- en: 'A *category* is included with each log that is created. We specify the category
    while creating an `ILogger` object. The category may be any string, but the convention
    is to use the qualified name of the class from which the logs are written, like
    we did in our previous example. We can also specify the log level, which indicates
    the degree of severity or importance of the log. For example, typically we use
    an information log when a method executes normally, a warning log when a method
    returns a 404 return code, and an error log when an unexpected exception is caught. Log
    methods that include the level in the method name are extension methods for `ILogger` ,
    such as`LogError`,`LogWarning`, `LogInformation`, and `LogTrace`. Behind the scenes,
    these methods call the `Log` method whcih takes a `LogLevel` parameter. ASP.NET
    Core defines the following log levels, ordered here from least to highest severity.
    The documentation of the code makes it intuitive to understand:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 每个创建的日志条目都包含一个 *类别*。我们在创建 `ILogger` 对象时指定类别。类别可以是任何字符串，但惯例是使用写入日志的类的限定名，就像我们在之前的示例中所做的那样。我们还可以指定日志级别，它表示日志的严重程度或重要性。例如，通常在方法正常执行时使用信息日志，在方法返回
    404 返回代码时使用警告日志，在捕获到意外异常时使用错误日志。包含级别的日志方法都是 `ILogger` 的扩展方法，例如 `LogError`、`LogWarning`、`LogInformation`
    和 `LogTrace`。在幕后，这些方法调用带有 `LogLevel` 参数的 `Log` 方法。ASP.NET Core 定义了以下日志级别，按严重程度从低到高排序。代码的文档使其直观易懂：
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can set minimum trace levels while configuring the logger as well, with
    the following code, which creates the `WebHost` in the `Program.cs` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在配置日志记录器时设置最小跟踪级别，以下代码在 `Program.cs` 文件中创建 `WebHost`：
- en: '[PRE36]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also do scope-based logging; that is, logging, on a logical group of
    operations within a scope in order to attach same data to each log. The `BeginScope`
    method is specifically made for this purpose and the following example shows the
    sample usage:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以进行基于范围的日志记录；也就是说，在范围内的逻辑操作组中进行日志记录，以便将相同的数据附加到每个日志条目。`BeginScope` 方法专门为此目的而设计，以下示例展示了其用法：
- en: '[PRE37]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before we conclude, let''s have a look at the configuration for `Logging` in
    the `appSettings.json` file. Consider the following `Logging` configuration:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，让我们看一下 `appSettings.json` 文件中 `Logging` 的配置。考虑以下 `Logging` 配置：
- en: '[PRE38]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding configuration defines four logging filters. The following is
    the interpretation of the configuration:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置定义了四个日志过滤器。以下是对配置的解释：
- en: Scope-based logging is disabled, as we have `IncludeScopes` as `false`. One
    of the primary use cases of scope-based logging comes in transactional data access
    or operations, where you may want to attach the same identifier to all the operations
    that happen in the transaction.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于范围的日志记录已被禁用，因为我们已将 `IncludeScopes` 设置为 `false`。基于范围的日志记录的主要用例之一是在事务性数据访问或操作中，您可能希望将相同的标识符附加到事务中发生的所有操作上。
- en: The default log level of the `Debug` log provider is `Information` for all categories.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的 `Debug` 日志提供程序的日志级别对所有类别都是 `Information`。
- en: The default log level of the `Console` log provider is `Information` for all
    categories.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的 `Console` 日志提供程序的日志级别对所有类别都是 `Information`。
- en: The log level of categories beginning with `Microsoft.AspNetCore.Mvc.Razor`
    is `Error` for the `Console` log provider.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 `Microsoft.AspNetCore.Mvc.Razor` 开头的类别的日志级别对于 `Console` 日志提供程序是 `Error`。
- en: The default log level for all log providers for all categories is `Debug`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有日志提供程序对所有类别的默认日志级别是 `Debug`。
- en: For a detailed and deep dive into logging in ASP.NET Core 2.0, readers should
    visit [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x).[](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对 ASP.NET Core 2.0 中的日志记录进行详细深入的了解，读者应访问 [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x)。[https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?tabs=aspnetcore2x)
- en: With this, we conclude our discussion of logging, and this chapter as well.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一点，我们结束了对日志记录的讨论，以及本章的内容。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the Let's Chat web application, its requirements
    and high-level design, and did the project setup to get started with coding. After
    doing the project setup, we learned about ASP.NET Core fundamentals, such as authentication,
    authorization, middleware, Dependency Injection, configuration, and logging.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Let's Chat 网络应用程序，其需求和高层次设计，并完成了项目设置以开始编码。完成项目设置后，我们学习了 ASP.NET Core
    的基础知识，例如身份验证、授权、中间件、依赖注入、配置和日志记录。
- en: In the next chapter, we will complete the fundamentals and then dive into coding
    the Let's Chat application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成基础知识的学习，然后深入编码 Let's Chat 应用程序。
