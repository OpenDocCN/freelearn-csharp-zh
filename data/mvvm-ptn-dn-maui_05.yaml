- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Community Toolkits
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区工具包
- en: In this chapter, we will explore some of the popular **Community Toolkits**
    that have been developed to assist developers in using data binding and the MVVM
    pattern more efficiently and effectively in .NET MAUI. These toolkits offer valuable
    components and utilities that can greatly enhance your development experience
    and help you build robust and maintainable applications. There are numerous large
    and small frameworks or toolkits that facilitate data binding and the application
    of the MVVM pattern in your projects. Some of them have a significant overall
    impact on your code, while others are more focused on providing developers with
    a set of helpers or components that you typically rewrite for each new project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些流行的 **社区工具包**，这些工具包是为了帮助开发者更高效、更有效地在 .NET MAUI 中使用数据绑定和 MVVM 模式而开发的。这些工具包提供了有价值的组件和实用工具，可以极大地提升你的开发体验，并帮助你构建健壮和可维护的应用程序。有许多大型和小型框架或工具包可以促进数据绑定和
    MVVM 模式在你的项目中的应用。其中一些对你的代码有重大影响，而另一些则更专注于为开发者提供一套辅助器或组件，你通常需要为每个新项目重写这些组件。
- en: Every existing toolkit or framework is the product of dedicated developers investing
    their time and expertise, and each one provides value to its users, whether or
    not it suits your particular coding style. In this book, I don’t want to favor
    any specific framework or toolkit over others but rather showcase community-driven
    efforts that can be beneficial to developers. For this reason, we’ll be exploring
    two Community Toolkits that provide some helpers and base classes that you can
    build upon but don’t have a large impact on your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个现有的工具包或框架都是一群投入时间和专业知识的开发者创造的产品，每个都为用户提供价值，无论它是否适合你的特定编码风格。在这本书中，我不想偏袒任何特定的框架或工具包，而是展示那些对开发者有益的社区驱动努力。因此，我们将探讨两个社区工具包，它们提供了一些辅助类和基类，你可以在此基础上构建，但不会对你的代码产生重大影响。
- en: 'In this chapter, we will be discussing the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下内容：
- en: The MVVM Toolkit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM 工具包
- en: The .NET MAUI Community Toolkit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI 社区工具包
- en: Other popular frameworks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他流行框架
- en: Contributing to the community
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献社区
- en: These toolkits were chosen as examples because they offer tools and components
    that can be integrated into your projects as needed, without imposing a specific
    architectural style or coding paradigm. This feature makes these toolkits particularly
    flexible and adaptable to a variety of coding styles and project requirements.
    Being part of the .NET Community Toolkits, they benefit from a wide community
    of contributors, including both Microsoft employees and independent developers.
    This collaboration ensures the toolkits remain up to date, reliable, and effective
    for developers across the board.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具包被选为示例，因为它们提供了可以按需集成到你的项目中的工具和组件，而不强加特定的架构风格或编码范式。这一特性使得这些工具包特别灵活和适应性强，可以适应各种编码风格和项目需求。作为
    .NET 社区工具包的一部分，它们受益于一个广泛的贡献者社区，包括微软员工和独立开发者。这种合作确保了工具包始终保持最新、可靠和有效，适用于所有开发者。
- en: These toolkits aim to simplify many common tasks you will encounter when building
    .NET MAUI applications. The features they provide are often things we’ve covered
    in earlier chapters, but now, they’ve been conveniently implemented for you. It’s
    important to understand that these toolkits are not magical entities; they encapsulate
    strategies and techniques that you could implement yourself. However, their true
    value lies in offering a ready-made, community-approved solution, saving you significant
    time and effort. By knowing what’s available in these toolkits, you can make informed
    decisions about when to leverage them and when to customize your solutions. So,
    without further ado, let’s dive in and see what they have to offer!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具包旨在简化你在构建 .NET MAUI 应用程序时遇到的大量常见任务。它们提供的功能通常是我们在前面的章节中介绍过的，但现在，它们已经方便地为你实现了。重要的是要理解，这些工具包并不是魔法般的存在；它们封装了你可以自己实现的战略和技术。然而，它们的真正价值在于提供现成的、社区认可的解决方案，为你节省大量的时间和精力。通过了解这些工具包中可用的内容，你可以做出明智的决定，关于何时利用它们以及何时定制你的解决方案。所以，无需多言，让我们深入探讨一下它们能提供什么吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we will be updating some code from the *Recipes!* app.
    The updated code can be found on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05)
    for reference and comparison.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更新*Recipes!*应用程序的一些代码。更新的代码可以在GitHub上找到，用于参考和比较：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter05)。
- en: The MVVM Toolkit
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM Toolkit
- en: The **MVVM Toolkit** (**CommunityToolkit.Mvvm**) is a comprehensive library
    that’s designed to simplify and streamline the implementation of the MVVM pattern
    in your applications. Developed and maintained by the .NET community, this toolkit
    provides a robust set of framework-independent tools, components, and utilities
    that help you build applications using the MVVM pattern. It’s important to note
    that this toolkit isn’t .NET MAUI-specific; it’s UI framework-agnostic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVVM Toolkit**（**CommunityToolkit.Mvvm**）是一个综合性的库，旨在简化并简化您应用程序中MVVM模式的实现。由.NET社区开发和维护，这个工具包提供了一套强大的框架无关的工具、组件和实用程序，帮助您使用MVVM模式构建应用程序。重要的是要注意，这个工具包不是.NET
    MAUI特定的；它是UI框架无关的。'
- en: 'Here are some of the key features of the MVVM Toolkit:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是MVVM Toolkit的一些关键特性：
- en: '`INotifyPropertyChanged` interface, simplifying the process of raising the
    `PropertyChanged` event. Its `SetProperty` method streamlines setting property
    values and automatically raises the `PropertyChanged` event when needed. By using
    this class, developers can reduce the boilerplate code associated with checking
    for property updates and triggering the `PropertyChanged` event accordingly.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INotifyPropertyChanged`接口简化了引发`PropertyChanged`事件的过程。它的`SetProperty`方法简化了属性值的设置，并在需要时自动引发`PropertyChanged`事件。通过使用这个类，开发者可以减少与检查属性更新和相应触发`PropertyChanged`事件相关的样板代码。'
- en: '`ObservableValidator` extends the `ObservableObject` class and includes built-in
    validation logic. This means that any object that inherits from `ObservableValidator`
    will have both observable and validating features.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservableValidator`扩展了`ObservableObject`类，并包含内置的验证逻辑。这意味着任何从`ObservableValidator`继承的对象都将具有可观察和验证的特性。'
- en: '`ICommand` interface. `RelayCommand` handles synchronous operations, while
    `AsyncRelayCommand` is designed for asynchronous tasks. Both support optional
    `CanExecute` logic.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ICommand`接口。`RelayCommand`处理同步操作，而`AsyncRelayCommand`是为异步任务设计的。两者都支持可选的`CanExecute`逻辑。'
- en: '`WeakReferenceMessenger` is a messaging system that enables communication between
    loosely coupled components. It uses weak references to manage message subscriptions,
    which helps you avoid memory leaks and unintended strong dependencies between
    objects in your application. Messaging will be discussed in more depth in [*Chapter
    7*](B20941_07.xhtml#_idTextAnchor119), *Dependency Injection, Services,* *and
    Messaging*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakReferenceMessenger`是一个消息系统，它允许松散耦合组件之间的通信。它使用弱引用来管理消息订阅，这有助于您避免应用程序中对象之间的内存泄漏和意外的强依赖。消息将在[*第7章*](B20941_07.xhtml#_idTextAnchor119)中更深入地讨论，*依赖注入、服务*和*消息*。'
- en: '`ObservablePropertyAttribute` simplifies the implementation of properties that
    trigger the `PropertyChanged` event, and `RelayCommandAttribute` automates the
    creation of commands, respectively.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservablePropertyAttribute`简化了触发`PropertyChanged`事件的属性的实现，而`RelayCommandAttribute`则自动化了命令的创建。'
- en: These are only a few examples of the components of an MVVM Toolkit. The idea
    here was to let you know what the MVVM library has to offer. Now, let’s look into
    how to effectively use it in our project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是MVVM Toolkit组件的几个示例。这里的想法是让您了解MVVM库能提供什么。现在，让我们看看如何在我们的项目中有效地使用它。
- en: 'Adding the MVVM Toolkit to your project is very easy:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将MVVM Toolkit添加到您的项目中非常简单：
- en: Right-click the `Recipes.Client.Core` project and select **Manage** **Nuget
    Packages**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Recipes.Client.Core`项目并选择**管理** **NuGet包**。
- en: 'Search for `MVVM Toolkit` and select **CommunityToolkit.Mvvm** from the list.
    *Figure 5**.1* shows the NuGet package we are searching for:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中搜索`MVVM Toolkit`并选择**CommunityToolkit.Mvvm**。*图5.1*显示了我们要搜索的NuGet包：
- en: '![Figure 5.1: CommunityToolkit.Mvvm NuGet package](img/B20941_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：CommunityToolkit.Mvvm NuGet包](img/B20941_05_01.jpg)'
- en: 'Figure 5.1: CommunityToolkit.Mvvm NuGet package'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：CommunityToolkit.Mvvm NuGet包
- en: Hit `Recipes.Client.Core` project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Recipes.Client.Core`项目。
- en: In the following example, we will be updating `RecipeDetailViewModel` and `IngredientsListViewModel`
    so that they use `ObservableObject` from the MVVM Toolkit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将更新`RecipeDetailViewModel`和`IngredientsListViewModel`，使它们使用MVVM Toolkit中的`ObservableObject`。
- en: ObservableObject
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ObservableObject
- en: Implementing the `INotifyPropertyChanged` interface in each ViewModel can become
    tedious and repetitive. That’s why developers often create a base class that takes
    care of this task. The MVVM Toolkit provides such a base class for free in the
    form of `ObservableObject`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个ViewModel中实现`INotifyPropertyChanged`接口可能会变得繁琐和重复。这就是为什么开发者经常创建一个基类来处理这项任务。MVVM
    Toolkit免费提供这样一个基类，形式为`ObservableObject`。
- en: By inheriting from `ObservableObject`, your ViewModel classes can automatically
    notify the View of property changes, keeping the UI synchronized with the underlying
    data. `ObservableObject` also provides the `SetProperty` method, which allows
    developers to set a property’s value. As a result, if the value has changed, it
    automatically triggers the `PropertyChanged` event to update the UI.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承自`ObservableObject`，您的ViewModel类可以自动通知视图属性更改，保持UI与底层数据同步。`ObservableObject`还提供了`SetProperty`方法，允许开发者设置属性值。因此，如果值已更改，它将自动触发`PropertyChanged`事件以更新UI。
- en: 'Let’s update our code so that our ViewModels inherit from `ObservableObject`
    instead of each one having its own implementation of the `INotifyPropertyChanged`
    interface:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的代码，让我们的ViewModel继承自`ObservableObject`而不是每个都实现自己的`INotifyPropertyChanged`接口：
- en: 'Head over to `IngredientsListViewModel` and let this class inherit from `ObservableObject`
    instead of implementing the `INotifyPropertyChanged` interface, as seen here:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`IngredientsListViewModel`，让这个类继承自`ObservableObject`而不是实现`INotifyPropertyChanged`接口，如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By inheriting `ObservableObject`, we can remove the `OnPropertyChanged` method
    and the `PropertyChanged` event that we had before.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过继承`ObservableObject`，我们可以移除之前存在的`OnPropertyChanged`方法和`PropertyChanged`事件。
- en: 'Next, we can update the setter of the `NumberOfServings` property so that it
    uses the `SetProperty` method of `ObservableObject`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以更新`NumberOfServings`属性的setter，使其使用`ObservableObject`的`SetProperty`方法：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `SetProperty` method eases the implementation of calling the `PropertyChanged`
    event when the value is being updated. This method will update the provided backing
    field (`_numberOfServings`) and trigger the `PropertyChanged` event automatically
    when the value is being updated.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SetProperty`方法简化了在值更新时调用`PropertyChanged`事件的实现。此方法将更新提供的后置字段（`_numberOfServings`），并在值更新时自动触发`PropertyChanged`事件。'
- en: 'We can start doing the same thing for `RecipeDetailViewModel` as well:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以为`RecipeDetailViewModel`做同样的事情：
- en: Inherit from `ObservableObject`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承自`ObservableObject`。
- en: Remove the `OnPropertyChanged` method and the `PropertyChanged` event.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`OnPropertyChanged`方法和`PropertyChanged`事件。
- en: 'Update the setter of `HideAllergenInformation` so that it uses the `SetProperty`
    method, as shown in the following snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`HideAllergenInformation`属性的setter，使其使用`SetProperty`方法，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By ensuring our ViewModels inherit from `ObservableObject` and utilize the `SetProperty`
    method, we can eliminate excessive boilerplate code. This would benefit us by
    reducing a significant amount of ceremony. This helps maintain the conciseness
    and clarity of our ViewModels, allowing them to stay focused on their core responsibilities.
    Unless you are being paid by lines of code, I think you would agree that these
    updated classes look a lot better with a lot less boilerplate code!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保我们的ViewModel继承自`ObservableObject`并利用`SetProperty`方法，我们可以消除过多的样板代码。这将使我们受益，减少大量的仪式感。这有助于保持ViewModel的简洁和清晰，使它们能够专注于其核心职责。除非你因代码行数而获得报酬，否则我认为你会同意，这些更新后的类看起来要好得多，样板代码要少得多！
- en: One of the most helpful features in the MVVM Toolkit is the different `ICommand`
    implementations. Let’s take a look!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM Toolkit中最有帮助的特性之一是不同的`ICommand`实现。让我们看看吧！
- en: RelayCommand
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RelayCommand
- en: 'The MVVM Toolkit provides several robust implementations of the `ICommand`
    interface. Each implementation serves a unique purpose, addressing varied needs
    for communication between the ViewModel and View in different scenarios. These
    implementations help streamline command operations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM Toolkit提供了`ICommand`接口的几个强大实现。每个实现都有其独特的作用，针对不同场景中ViewModel和视图之间通信的不同需求。这些实现有助于简化命令操作：
- en: '`RelayCommand`: This straightforward implementation of `ICommand` allows you
    to specify `Execute` and `CanExecute` methods using delegates, tailoring what
    the command does and whether it can be executed at a given time. This implementation
    is similar to `Microsoft.Maui.Controls.Command`, which we used earlier. However,
    the `Command` implementation had the `ChangeCanExecute` method, which we can call
    to trigger the re-evaluation of the `CanExecute` method. On the `RelayCommand`
    class, a method with this behavior is called `NotifyCanExecuteChanged`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelayCommand`：这是 `ICommand` 的简单实现，允许你使用委托指定 `Execute` 和 `CanExecute` 方法，定制命令的行为以及是否可以在特定时间执行。这种实现类似于我们之前使用的
    `Microsoft.Maui.Controls.Command`。然而，`Command` 实现有 `ChangeCanExecute` 方法，我们可以调用它来触发
    `CanExecute` 方法的重新评估。在 `RelayCommand` 类中，具有这种行为的函数称为 `NotifyCanExecuteChanged`。'
- en: '`RelayCommand<T>`: This is a variant of `RelayCommand` that adds support for
    a parameter that can be passed to the `Execute` and `CanExecute` methods. The
    type of the parameter is determined by the generic type parameter. This implementation
    is similar to `Microsoft.Maui.Controls.Command<T>`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelayCommand<T>`：这是 `RelayCommand` 的一个变体，它增加了对可以传递给 `Execute` 和 `CanExecute`
    方法的参数的支持。参数的类型由泛型类型参数确定。这种实现类似于 `Microsoft.Maui.Controls.Command<T>`。'
- en: '`AsyncRelayCommand`: An async variant of `ICommand`, `AsyncRelayCommand` returns
    a `Task`, making it ideal for managing asynchronous operations such as network
    data fetches.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncRelayCommand`：`ICommand` 的异步变体，`AsyncRelayCommand` 返回一个 `Task`，使其非常适合管理如网络数据获取之类的异步操作。'
- en: '`AsyncRelayCommand<T>`: A parameter-supporting version of `AsyncRelayCommand`,
    this allows you to pass an argument to the asynchronous `Execute` and `CanExecute`
    methods, providing additional versatility for async operations.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncRelayCommand<T>`：`AsyncRelayCommand` 的参数支持版本，这允许你向异步的 `Execute` 和 `CanExecute`
    方法传递参数，为异步操作提供额外的灵活性。'
- en: 'Let’s see how we can update our command so that it leverages the `RelayCommand`
    and `RelayCommand<T>` classes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何更新我们的命令，以便利用 `RelayCommand` 和 `RelayCommand<T>` 类：
- en: 'The following code block shows how we can initialize the commands in the constructor
    by updating their type from `Microsoft.Maui.Controls.Command` to `CommunityToolkit.Mvvm.Input.RelayCommand`
    and from `Microsoft.Maui.Controls.Command<T>` to `CommunityToolkit.Mvvm.Input.RelayCommand<T>`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下面的代码块展示了我们如何通过将类型从 `Microsoft.Maui.Controls.Command` 更新为 `CommunityToolkit.Mvvm.Input.RelayCommand`，以及从
    `Microsoft.Maui.Controls.Command<T>` 更新为 `CommunityToolkit.Mvvm.Input.RelayCommand<T>`
    来在构造函数中初始化命令：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This updated code will instantiate the three commands with a new `RelayCommand`,
    passing in the methods that should be triggered when calling the command’s `Execute`
    and `CanExecute` methods.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此更新后的代码将使用新的 `RelayCommand` 实例化三个命令，传递在调用命令的 `Execute` 和 `CanExecute` 方法时应触发的函数。
- en: 'While we are at it, we can also go ahead and update the types of the commands
    in this class. While `RelayCommand` implements the `ICommand` interface, it also
    implements the `IRelayCommand` interface:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们进行这些操作时，我们还可以更新这个类中命令的类型。虽然 `RelayCommand` 实现了 `ICommand` 接口，但它也实现了 `IRelayCommand`
    接口：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By updating the type of our commands, as shown in the preceding snippet, we
    can avoid additional castings later on.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过更新我们命令的类型，如前文代码片段所示，我们可以避免后续的额外类型转换。
- en: 'The setter of `IsFavorite` can now be updated to this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsFavorite` 的设置器现在可以更新为以下内容：'
- en: '[PRE5]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `SetProperty` method returns `true` if the property was changed. This allows
    us to do additional things when the property is changed (or not). For example,
    in this case, we want to re-evaluate the `CanExecute` method of the commands when
    the `IsFavorite` property changes its value by calling each command’s `NotifyCanExecuteChanged`
    method.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SetProperty` 方法在属性被更改时返回 `true`。这允许我们在属性更改（或未更改）时执行额外操作。例如，在这种情况下，我们希望在 `IsFavorite`
    属性值更改时重新评估命令的 `CanExecute` 方法，通过调用每个命令的 `NotifyCanExecuteChanged` 方法。'
- en: Adhering to the best practices of MVVM
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 MVVM 的最佳实践
- en: Because we don’t use `Microsoft.Maui.Control.Command` anymore, we can also remove
    the MAUI dependency that we currently have on this project. Click on the `Recipes.Client.Core`
    project so that the project’s `.csproj` file opens and remove the `<UseMaui>`
    tag. Now, the ViewModels (and the `Recipes.Client.Core` project) are platform-agnostic
    again, adhering to the best practices of MVVM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用 `Microsoft.Maui.Control.Command`，我们也可以移除这个项目当前所依赖的 MAUI 依赖。点击 `Recipes.Client.Core`
    项目，以便打开项目的 `.csproj` 文件，并移除 `<UseMaui>` 标签。现在，ViewModel（以及 `Recipes.Client.Core`
    项目）再次成为平台无关的，遵循 MVVM 的最佳实践。
- en: In [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), it was apparent that applying
    the MVVM pattern involves a lot more code compared to writing everything in code-behind.
    Mostly, that’s because of all of the ceremony in the ViewModels. While classes
    such as `ObservableObject` already abstract away some of the boilerplate code,
    we could even go one step further and look at the Source Generators that are available
    in the MVVM Toolkit.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B20941_01.xhtml#_idTextAnchor015)中，很明显，应用MVVM模式比在代码后端编写所有内容需要更多的代码。这主要是因为ViewModel中的所有仪式。虽然像`ObservableObject`这样的类已经抽象了一些样板代码，但我们甚至可以更进一步，看看MVVM
    Toolkit中可用的源生成器。
- en: Source Generators
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源生成器
- en: Source Generators are a compiler feature in .NET that allows developers to generate
    new code during the compilation process. This has the potential to greatly reduce
    manual coding and the likelihood of errors.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 源生成器是.NET中的一个编译器功能，允许开发者在编译过程中生成新代码。这有可能大大减少手动编码和错误的可能性。
- en: The MVVM Toolkit provides `ObservablePropertyAttribute` and `RelayCommandAttribute`,
    which are used by the Source Generators to create properties that notify the UI
    of changes and commands that handle user interactions, respectively. Additionally,
    other attributes such as `NotifyPropertyChangedForAttribute` and `NotifyCanExecuteChangedForAttribute`
    can be used in combination with `ObservablePropertyAttribute` to add even more
    functionality through code generation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM Toolkit提供了`ObservablePropertyAttribute`和`RelayCommandAttribute`，这些属性由源生成器用于创建通知UI变化的属性和用于处理用户交互的命令。此外，还可以使用`NotifyPropertyChangedForAttribute`和`NotifyCanExecuteChangedForAttribute`等属性与`ObservablePropertyAttribute`结合使用，通过代码生成添加更多功能。
- en: 'Given how Source Generators work, the class on which these attributes are applied
    must be declared as a partial class. In C#, partial classes allow you to split
    a class across multiple files using the `partial` keyword. At compile time, the
    different files are combined into one class. This feature is integral to source
    generators, which generate additional source code during compilation. Therefore,
    when you wish to use any of these attributes, remember to declare your ViewModel
    as `partial`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于源生成器的工作方式，应用这些属性的课程必须声明为部分类。在C#中，部分类允许您使用`partial`关键字将类拆分到多个文件中。在编译时，不同的文件将组合成一个类。此功能对于源生成器至关重要，因为源生成器在编译期间生成额外的源代码。因此，当您希望使用这些属性中的任何一个时，请记住将您的ViewModel声明为`partial`：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that the ViewModel has been declared as partial, we can begin to adapt our
    code to take advantage of these attributes. Let’s see how this can be done.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将ViewModel声明为部分类，我们可以开始调整我们的代码以利用这些属性。让我们看看如何做到这一点。
- en: Using the ObservableProperty attribute
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ObservableProperty属性
- en: Typically, we need to write some boilerplate code when implementing a property
    that triggers the `PropertyChanged` event. By using `ObservablePropertyAttribute`,
    we can let Source Generators generate this code for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在实现触发`PropertyChanged`事件的属性时，我们需要编写一些样板代码。通过使用`ObservablePropertyAttribute`，我们可以让源生成器为我们生成此代码。
- en: This attribute can be applied to a field; at build time, a public property will
    be generated, with the annotated field as the backing field.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可以应用于字段；在构建时，将生成一个公共属性，注解的字段作为后端字段。
- en: 'As an example, we can take a look at `RecipeDetailViewModel`. The `HideExtendedAllergenList`
    property can be deleted and `ObservablePropertyAttribute` can be added to the
    `_hideExtendedAllergenList` field:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看看`RecipeDetailViewModel`。可以将`HideExtendedAllergenList`属性删除，并将`ObservablePropertyAttribute`添加到`_hideExtendedAllergenList`字段：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this `ObservableProperty` attribute in place, a full-fledged public property
    named `HideExtendedAllergenList` will be generated at build time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`ObservableProperty`属性生效的情况下，在构建时将生成一个名为`HideExtendedAllergenList`的完整公共属性。
- en: The generated property’s set method will contain logic that checks whether the
    value is updated and triggers the `PropertyChanged` event accordingly. The setter
    will also call a handful of partial methods that are being generated, allowing
    us to add some custom code while the property value is being updated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的属性的设置方法将包含检查值是否已更新并相应触发`PropertyChanged`事件的逻辑。设置器还将调用一些正在生成的部分方法，允许我们在属性值更新时添加一些自定义代码。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s very important to note that the `ObservableProperty` attribute generates
    a public property for us. When binding this value to the UI, make sure you bind
    to this generated property (`HideExtendedAllergenList`, in this case) and not
    try to bind to the field you’ve set the attribute on. Also, when assigning a value,
    always assign it to the generated property to make sure the `PropertyChanged`
    event gets triggered!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，`ObservableProperty` 属性会为我们生成一个公共属性。当将此值绑定到 UI 时，请确保绑定到这个生成的属性（在这个例子中是
    `HideExtendedAllergenList`），而不是尝试绑定到设置了属性的域。另外，在赋值时，始终将值赋给生成的属性，以确保触发 `PropertyChanged`
    事件！
- en: But what about the `IsFavorite` property of `RecipeDetailViewModel`?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `RecipeDetailViewModel` 的 `IsFavorite` 属性怎么办呢？
- en: 'In this setter, we call the `NotifyCanExecuteChanged` method of our commands.
    Can we make this work on a generated property as well? Yes; for those cases, we
    have the `NotifyCanExecuteChangedFor` attribute, which accepts the name of the
    command whose `NotifyCanExecuteChanged` method needs to be triggered when the
    value of the property is updated. This means that the entire `IsFavorite` property
    could be rewritten like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置器中，我们调用我们命令的 `NotifyCanExecuteChanged` 方法。我们能否让这也在生成的属性上工作？是的；对于这些情况，我们有
    `NotifyCanExecuteChangedFor` 属性，它接受当属性值更新时需要触发的命令的 `NotifyCanExecuteChanged` 方法的名称。这意味着整个
    `IsFavorite` 属性可以重写为如下所示：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first attribute, `ObservableProperty`, will generate a property that will
    trigger the `PropertyChanged` event when its value is being updated. The next
    three `NotifyCanExecuteChangedFor` attributes will make sure that the `NotifyCanExecuteChanged`
    method of the three commands of the `IRelayCommand` type will be invoked when
    the property updates.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性 `ObservableProperty` 将生成一个属性，当其值更新时将触发 `PropertyChanged` 事件。接下来的三个 `NotifyCanExecuteChangedFor`
    属性将确保当属性更新时，`IRelayCommand` 类型的三个命令的 `NotifyCanExecuteChanged` 方法将被调用。
- en: Speaking of commands, there’s a Source Generator for generating a `RelayCommand`
    as well. Let’s take a look.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 说到命令，还有一个用于生成 `RelayCommand` 的源生成器。让我们看看。
- en: Using the RelayCommand attribute
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 RelayCommand 属性
- en: 'You can apply the `RelayCommand` attribute to a method that you intend to use
    as the execution action for a command. At build time, this will generate a public
    `RelayCommand` property with the same name as the method, suffixed with “Command.”
    When calling the `Execute` method of the generated `RelayCommand`, the method
    on which the attribute was applied will be invoked. This essentially simplifies
    the process of declaring a public `IRelayCommand` command, making a method to
    be invoked, and creating an instance of the command tied to that method, in the
    following simplified form:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 `RelayCommand` 属性应用于您打算用作命令执行动作的方法。在构建时，这将生成一个与方法同名的公共 `RelayCommand` 属性，后缀为
    “Command。” 当调用生成的 `RelayCommand` 的 `Execute` 方法时，应用了该属性的该方法将被调用。这实际上简化了声明公共 `IRelayCommand`
    命令、创建要调用的方法以及创建与该方法关联的命令实例的过程，以下是一个简化的形式：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will generate a `RemoveAsFavoriteCommand` public property of type `IRelayCommand`
    that will call the `RemoveAsFavorite` method when the command is being executed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个公共 `IRelayCommand` 类型的 `RemoveAsFavoriteCommand` 属性，当命令执行时将调用 `RemoveAsFavorite`
    方法。
- en: When applying this attribute to a method that accepts one parameter, the resulting
    command will be a generic `RelayCommand<T>`, where `T` corresponds to the type
    of the parameter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此属性应用于接受一个参数的方法时，生成的命令将是一个泛型 `RelayCommand<T>`，其中 `T` 对应于参数的类型。
- en: 'Alternatively, we can also pass in a string parameter called `CanExecute` that
    points to a method, which should be invoked when calling the command’s `CanExecute`
    method. This is essential if we want to update `RecipeDetailViewModel` and let
    `AddAsFavoriteCommand`, `RemoveAsFavoriteCommand`, and `SetFavoriteCommand` be
    generated by Source Generators. Let’s see how we can achieve that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以传递一个名为 `CanExecute` 的字符串参数，该参数指向一个方法，当调用命令的 `CanExecute` 方法时应调用该方法。如果我们想更新
    `RecipeDetailViewModel` 并让 `AddAsFavoriteCommand`、`RemoveAsFavoriteCommand` 和
    `SetFavoriteCommand` 由源生成器生成，这是必不可少的。让我们看看我们如何实现这一点：
- en: Delete the public `AddAsFavoriteCommand`, `RemoveAsFavoriteCommand`, and `SetFavoriteCommand`
    properties of type `IRelayCommand`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除公共 `AddAsFavoriteCommand`、`RemoveAsFavoriteCommand` 和 `SetFavoriteCommand`
    属性，这些属性的类型为 `IRelayCommand`。
- en: Delete the instantiation of these commands in the constructor of `RecipeDetailViewModel`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeDetailViewModel` 的构造函数中删除这些命令的实例化。
- en: 'Add the `RelayCommand` attribute to the `AddAsFavorite`, `RemoveAsFavorite`,
    and `SetFavorite` methods, as shown here:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RelayCommand`属性添加到`AddAsFavorite`、`RemoveAsFavorite`和`SetFavorite`方法中，如下所示：
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At build time, the public command will be generated thanks to the `RelayCommand`
    attributes. In this example, all of the attributes also point to a method that
    gets invoked when calling the generated command’s `CanExecute` method.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在构建时，公共命令将通过`RelayCommand`属性生成。在这个例子中，所有属性都指向一个方法，当调用生成的命令的`CanExecute`方法时会被调用。
- en: While Source Generators can greatly simplify code bases and improve productivity
    by automating boilerplate code, I choose not to use them for a couple of reasons.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源生成器可以极大地简化代码库并提高生产力，通过自动化样板代码，但我出于几个原因选择不使用它们。
- en: Firstly, they can obscure some of the underlying implementation details. This
    might make it challenging for newcomers or less experienced developers to fully
    understand the code and its intrinsic patterns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它们可能会掩盖一些底层实现细节。这可能会让新来的开发者或经验较少的开发者难以完全理解代码及其内在模式。
- en: Secondly, employing the MVVM Toolkit’s Source Generators may require adjusting
    your coding style to match the “prescribed” style inherent to the toolkit. This
    may not appeal to all developers who prefer more flexibility in their coding approach.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，使用MVVM工具包的源生成器可能需要调整你的编码风格以匹配工具包内固有的“规定”风格。这可能不会吸引所有喜欢在编码方法上更有灵活性的开发者。
- en: However, it’s essential to note that these are personal preferences, and many
    developers find great value in using Source Generators. They can significantly
    streamline your ViewModel development process, and if you find them beneficial
    and conducive to your coding style, I wholeheartedly recommend their usage!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，这些是个人偏好，许多开发者发现使用源生成器有很大的价值。它们可以显著简化ViewModel的开发过程，如果你发现它们对你有益且有利于你的编码风格，我真诚地推荐使用它们！
- en: At the end of the day, Source Generators are a tool. Like any tool, it’s crucial
    to consider when and where they add the most value. Balancing the benefits of
    automation and simplicity with understanding, flexibility, and individual style
    in your code is always an important consideration in software development.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，源生成器是一个工具。像任何工具一样，考虑何时何地它们能带来最大价值是至关重要的。在自动化和简单性与理解、灵活性以及个人代码风格之间取得平衡，始终是软件开发中一个重要的考虑因素。
- en: This covers most of the essentials of the MVVM Toolkit. Now, let’s see how the
    .NET MAUI Community Toolkit can make our lives easier when applying the MVVM pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了MVVM工具包的大部分基本内容。现在，让我们看看.NET MAUI社区工具包如何使我们在应用MVVM模式时生活变得更轻松。
- en: The .NET MAUI Community Toolkit
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包
- en: 'The .**NET MAUI Community Toolkit** is a collection of useful components, controls,
    and utilities designed to enhance the development experience with .NET MAUI. Although
    its primary focus is not on enabling or facilitating MVVM, the toolkit does provide
    features that can greatly assist developers in implementing the MVVM pattern in
    their .NET MAUI projects:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: .**NET MAUI社区工具包**是一组有用的组件、控件和实用工具，旨在增强使用.NET MAUI的开发体验。尽管其主要焦点不是启用或促进MVVM，但工具包确实提供了可以帮助开发者在其.NET
    MAUI项目中实现MVVM模式的功能：
- en: '**Behaviors**: These are reusable pieces of functionality that can be attached
    to certain types of controls. By encapsulating code in behaviors, you can keep
    your views clean and easy to understand.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为**：这些是可以附加到某些类型控件上的可重用功能块。通过在行为中封装代码，你可以保持视图的整洁和易于理解。'
- en: '**Converters**: As we’ve seen before, converters help transform data from one
    type into another, making it easier to bind data from your ViewModel to your View.
    The toolkit has a lot of converters for a huge range of common scenarios.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换器**：正如我们之前看到的，转换器有助于将数据从一种类型转换为另一种类型，这使得从ViewModel绑定数据到View变得更加容易。工具包为大量常见场景提供了许多转换器。'
- en: There is much more to the .NET MAUI Community Toolkit, but in the context of
    MVVM, these are the relevant bits. Please note that this is a toolkit that should
    only be added to MAUI projects and not to the core project that houses your ViewModels,
    for example. Why? Because the .NET MAUI Community is .NET MAUI-dependent and therefore
    it should not be referenced to projects that are agnostic of UI frameworks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包还有很多其他功能，但在MVVM的上下文中，这些是相关的部分。请注意，这是一个应该只添加到MAUI项目中的工具包，而不是包含你的ViewModel的核心项目。为什么？因为.NET
    MAUI社区依赖于.NET MAUI，因此它不应该被引用到与UI框架无关的项目中。
- en: By offering these additional features and helpers, the .NET MAUI Community Toolkit
    contributes to a more efficient and streamlined development process when working
    with MVVM in .NET MAUI.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供这些额外的功能和辅助工具，.NET MAUI Community Toolkit 有助于在 .NET MAUI 中使用 MVVM 时提高开发效率和流程简化。
- en: 'Installing the .NET MAUI Community Toolkit is just like installing any other
    NuGet package:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 .NET MAUI Community Toolkit 与安装任何其他 NuGet 包类似：
- en: Right-click the `Recipes.Mobile` project and select **Manage** **NuGet Packages**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Recipes.Mobile` 项目，然后选择 **管理** **NuGet 包**。
- en: 'Search for `Maui Community` and select **CommunityToolkit.Maui** from the list.
    *Figure 5**.2* shows the NuGet package we should download:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索 `Maui Community` 并从列表中选择 **CommunityToolkit.Maui**。*图 5*.2 展示了我们应该下载的 NuGet
    包：
- en: '![Figure 5.2: CommunityToolkit.Maui NuGet package](img/B20941_05_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：CommunityToolkit.Maui NuGet 包](img/B20941_05_02.jpg)'
- en: 'Figure 5.2: CommunityToolkit.Maui NuGet package'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2：CommunityToolkit.Maui NuGet 包
- en: Hit `Recipes.Mobile` project.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打击 `Recipes.Mobile` 项目。
- en: 'Once installed, head over to `MauiProgram.cs` and make sure you call `UseMauiCommunityToolkit`
    on `MauiAppBuilder`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，转到 `MauiProgram.cs` 并确保在 `MauiAppBuilder` 上调用 `UseMauiCommunityToolkit`：
- en: '[PRE11]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use components from the toolkit in XAML, you will need to add the namespace
    to the XAML pages where you want to use the toolkit:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 XAML 中使用工具包中的组件，您需要将命名空间添加到您想要使用工具包的 XAML 页面中：
- en: Once all of this is in place, we can start using the .NET MAUI Community Toolkit.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有这些设置就绪，我们就可以开始使用 .NET MAUI Community Toolkit。
- en: Converters
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换器
- en: 'In [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Data Binding in .NET MAUI*,
    we discussed what value converters are and how to create them. The .NET MAUI Community
    Toolkit comes packed with a whole lot of ready-to-use value converters. One such
    converter is `ListToStringConverter`, which can be very handy for displaying a
    list of items as a single string. Let’s use it to display the allergen information
    of the recipe:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B20941_04.xhtml#_idTextAnchor069)，*.NET MAUI 中的数据绑定*，我们讨论了值转换器是什么以及如何创建它们。.NET
    MAUI Community Toolkit 内置了许多现成的值转换器。其中之一是 `ListToStringConverter`，它可以非常方便地将项目列表显示为单个字符串。让我们使用它来显示食谱的过敏信息：
- en: 'To start, let’s add an array of strings called `Allergens` to `RecipeDetailViewModel`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向 `RecipeDetailViewModel` 添加一个名为 `Allergens` 的字符串数组：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This property holds a list of all allergens that the recipe contains. For now,
    we’re hardcoding some values here.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性包含食谱中包含的所有过敏原列表。目前，我们在这里硬编码了一些值。
- en: 'On `RecipeDetailPage`, add the toolkit’s namespace:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeDetailPage` 上添加工具包的命名空间：
- en: '[PRE13]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will allow us to access the Community Toolkit library in XAML using the
    `toolkit` prefix.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将允许我们使用 `toolkit` 前缀在 XAML 中访问 Community Toolkit 库。
- en: 'Add an instance of `ListToStringConverter` to the page’s `Resources`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ListToStringConverter` 实例添加到页面的 `Resources` 中：
- en: '[PRE14]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ListToStringConverter` has a property called `Separator` that we set to ",".'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ListToStringConverter` 有一个名为 `Separator` 的属性，我们将其设置为 ","。'
- en: 'Finally, we can update the label that should display the allergen information:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以更新标签，以显示过敏信息：
- en: '[PRE15]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This value converter and some other converters in the toolkit aren’t exactly
    rocket science. It’s something you could write yourself. However, in my opinion,
    why reinvent the wheel when someone has already done the hard work for you? Utilizing
    these ready-made tools can certainly make your coding life easier!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此值转换器以及工具包中的其他一些转换器并不完全是火箭科学。这是您可以自己编写的。然而，在我看来，为什么要在别人已经为你做了艰苦工作的情况下重新发明轮子呢？利用这些现成的工具无疑可以使您的编码生活更加轻松！
- en: Behaviors
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为
- en: Behaviors allow you to add functionality to UI controls without the need to
    build custom controls from scratch. This greatly helps in constructing rich and
    intuitive user interfaces tailored to your specific requirements. By encapsulating
    UI-specific actions within the View layer, behaviors help reduce the complexity
    of ViewModels, adhering to the separation of concerns principle central to MVVM.
    The .NET MAUI Community Toolkit comes with a variety of ready-to-use behaviors,
    saving you time and effort in enhancing your UI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 行为允许您在不从头开始构建自定义控件的情况下向 UI 控件添加功能。这极大地帮助构建丰富且直观的用户界面，以满足您的特定需求。通过在视图层封装 UI 特定的操作，行为有助于减少
    ViewModels 的复杂性，遵循 MVVM 中核心的关注点分离原则。.NET MAUI Community Toolkit 提供了各种现成的行为，节省了您在增强
    UI 时的时间和精力。
- en: One of the behaviors provided by the .NET MAUI Community Toolkit is `EventToCommand`,
    which allows you to map events to commands. This allows you to further enhance
    the decoupling of your UI and business logic. This behavior is particularly useful
    when dealing with events that do not directly support binding to commands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 社区工具包提供的一个行为是 `EventToCommand`，它允许你将事件映射到命令。这允许你进一步增强你的 UI 和业务逻辑之间的解耦。这个行为在处理不支持直接绑定到命令的事件时特别有用。
- en: 'As a very simple example, let’s imagine that we want to collect some user behavior
    throughout the app. One of the things we might be interested in is whether the
    user scrolls on a recipe page or not, as that might indicate some level of interest
    in that particular recipe. `ScrollView` has a `Scrolled` event, but no corresponding
    command. In such a use case, `EventToCommandBehavior` can be very helpful, as
    I will show you in the next steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简单的例子，让我们想象一下，我们想要在整个应用程序中收集一些用户行为。我们可能感兴趣的一件事是用户是否在食谱页面上滚动，因为这可能表明用户对该特定食谱有一定程度的兴趣。`ScrollView`
    有一个 `Scrolled` 事件，但没有相应的命令。在这种情况下，`EventToCommandBehavior` 可以非常有帮助，就像我在接下来的步骤中将要展示的那样：
- en: 'Create a `RelayCommand` on `RecipeDetailViewModel`, which needs to be invoked
    when the user scrolls on the page:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RecipeDetailViewModel` 上创建一个 `RelayCommand`，当用户在页面上滚动时需要调用：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we can add `EventToCommandBehavior` to `ScrollView`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在 `ScrollView` 上添加 `EventToCommandBehavior`：
- en: '[PRE17]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Command` property of `EventToCommandBehavior` is bound to the `UserIsBrowsingCommand`
    property that we just created on the ViewModel. By setting the `EventName` property
    to `"Scrolled"`, we define that we want this command to be invoked on the `Scrolled`
    event of `ScrollView`.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EventToCommandBehavior` 的 `Command` 属性绑定到我们在 ViewModel 上刚刚创建的 `UserIsBrowsingCommand`
    属性。通过将 `EventName` 属性设置为 `"Scrolled"`，我们定义我们想要在 `ScrollView` 的 `Scrolled` 事件上调用此命令。'
- en: 'As a final example to demonstrate how helpful this toolkit can be by combining
    behaviors and converters, imagine the following: a heart icon should always be
    shown on the screen, but only when the user has marked the recipe as a favorite,
    and it should be red. We can write this without adding a single line of C# code
    and without working with multiple icons! Let’s see how this is done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一个示例，为了展示通过结合行为和转换器这个工具包如何有用，想象以下情况：一个心形图标应该始终显示在屏幕上，但只有当用户将食谱标记为收藏时，它才应该是红色的。我们可以不添加任何一行
    C# 代码，也不与多个图标交互来完成这个任务！让我们看看这是如何实现的：
- en: 'Until now, in our *Recipes!* app, the favorite icon was a little misplaced.
    Let’s start by placing the favorite icon next to the recipe title. You can accomplish
    this by replacing the label that displays the recipe’s title with the following
    XAML code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的 *Recipes!* 应用程序中，收藏图标放置得有点不合适。让我们先从将收藏图标放置在食谱标题旁边开始。你可以通过替换显示食谱标题的标签来完成此操作，以下是一个
    XAML 代码：
- en: '[PRE18]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, the favorite icon will permanently appear right next to the recipe’s title.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，收藏图标将永久地出现在食谱标题旁边。
- en: 'The .NET MAUI Community Toolkit offers `IconTintColorBehavior`, which we can
    apply to change the color of `favoriteIcon`. We can add this behavior to our image:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET MAUI 社区工具包提供了 `IconTintColorBehavior`，我们可以将其应用到 `favoriteIcon` 上以改变其颜色。我们可以在我们的图片上添加此行为：
- en: '[PRE19]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After adding this behavior, the icon will take on the specified `TintColor`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加此行为后，图标将采用指定的 `TintColor`。
- en: 'Now, we need to set the `TintColor` value based on the `IsFavorite` property
    of `RecipeDetailViewModel`. Conveniently, the toolkit provides `BoolToObjectConverter`,
    which we can utilize to convert a `boolean` value into another value. We can add
    an instance of it to `RecipeDetailPage`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要根据 `RecipeDetailViewModel` 的 `IsFavorite` 属性设置 `TintColor` 值。方便的是，工具包提供了
    `BoolToObjectConverter`，我们可以利用它将 `boolean` 值转换为另一个值。我们可以在 `RecipeDetailPage` 中添加其实例：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By setting this instance’s `TypeArguments` to `"Color"`, we specify that we
    want to convert a `bool` value into a `Color` value. The `FalseObject` and `TrueObject`
    properties set the values that the converter should return for false and true,
    respectively.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将此实例的 `TypeArguments` 设置为 `"Color"`，我们指定我们想要将 `bool` 值转换为 `Color` 值。`FalseObject`
    和 `TrueObject` 属性设置了转换器应该为 `false` 和 `true` 返回的值。
- en: 'The last step is to update `IconTintColorBehavior` on the image. The challenge
    is binding the `TintColor` property of the behavior to the `IsFavorite` property
    of `RecipeDetailViewModel`. Since behaviors do not inherit their `BindingContext`
    from the controls they’re defined on, we’ll use `ElementBinding` to access `RecipeDetailViewModel`
    through the `BindingContext` of the `favoriteIcon`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在图片上更新`IconTintColorBehavior`。挑战在于将行为的`TintColor`属性绑定到`RecipeDetailViewModel`的`IsFavorite`属性。由于行为不会从它们定义的控件继承`BindingContext`，我们将使用`ElementBinding`通过`favoriteIcon`的`BindingContext`访问`RecipeDetailViewModel`：
- en: '[PRE21]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The .NET MAUI Community Toolkit is an invaluable resource that streamlines the
    development process. It offers a wide variety of reusable building blocks, reducing
    the necessity for duplicative work and allowing you to focus on creating unique
    application features. With components such as behaviors, converters, and more,
    the toolkit empowers developers to build rich and interactive user experiences
    with less effort and complexity. Although the toolkit isn’t focused on MVVM, it
    helps in implementing the MVVM pattern by offering handy features such as behaviors,
    converters, and more.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI Community Toolkit是一个无价的资源，它简化了开发过程。它提供了各种可重用的构建块，减少了重复工作的必要性，并允许您专注于创建独特应用程序功能。通过行为、转换器等组件，该工具包使开发者能够以更少的努力和复杂性构建丰富和交互式的用户体验。尽管该工具包不专注于MVVM，但它通过提供行为、转换器等实用功能，有助于实现MVVM模式。
- en: Other popular frameworks
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他流行的框架
- en: As mentioned earlier, there are numerous MVVM frameworks available, each with
    its unique characteristics and advantages. Throughout this chapter, we’ve explored
    the MVVM Toolkit and .NET MAUI Community Toolkit. These toolkits, being community-driven
    and highly accessible, offer a variety of useful tools to simplify your MVVM code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有众多MVVM框架可供选择，每个框架都有其独特的特性和优势。在本章中，我们探讨了MVVM Toolkit和.NET MAUI Community
    Toolkit。这些工具包由社区驱动且易于访问，提供了各种有用的工具，以简化您的MVVM代码。
- en: 'However, the landscape of MVVM frameworks is vast, so it might be worth seeing
    what other frameworks can provide. Here’s a list of some of the most popular third-party
    MVVM frameworks that are compatible with .NET MAUI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MVVM框架的领域非常广泛，因此了解其他框架可以提供什么可能是有价值的。以下是一些与.NET MAUI兼容的最受欢迎的第三方MVVM框架列表：
- en: 'ReactiveUI: [https://www.reactiveui.net/](https://www.reactiveui.net/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'ReactiveUI: [https://www.reactiveui.net/](https://www.reactiveui.net/)'
- en: 'Prism Library: [https://prismlibrary.com/](https://prismlibrary.com/)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Prism库: [https://prismlibrary.com/](https://prismlibrary.com/)'
- en: 'TinyMvvm: [https://github.com/dhindrik/TinyMvvm](https://github.com/dhindrik/TinyMvvm)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'TinyMvvm: [https://github.com/dhindrik/TinyMvvm](https://github.com/dhindrik/TinyMvvm)'
- en: 'FreshMvvm: [https://github.com/XAM-Consulting/FreshMvvm.Maui](https://github.com/XAM-Consulting/FreshMvvm.Maui)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'FreshMvvm: [https://github.com/XAM-Consulting/FreshMvvm.Maui](https://github.com/XAM-Consulting/FreshMvvm.Maui)'
- en: Whether you are seeking a simple toolkit for the basics or a comprehensive framework
    with advanced capabilities, you will soon discover a framework that would best
    suit your specific needs and align with your coding style. However, it’s important
    to remember that using an MVVM framework is not a prerequisite for effective MVVM.
    It is entirely possible to implement the MVVM pattern effectively without a dedicated
    framework. Ultimately, the choice of whether to use a framework – and if so, which
    one – should depend on your project’s requirements, your team’s familiarity with
    the framework, and your personal coding preferences. *Remember, tools are there
    to assist you, not dictate how* *you code.*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在寻找一个简单的工具包来处理基础知识，还是需要一个具有高级功能的全面框架，您很快就会发现一个最适合您特定需求并与您的编码风格相匹配的框架。然而，重要的是要记住，使用MVVM框架并不是有效实现MVVM的先决条件。完全有可能在没有专用框架的情况下有效地实现MVVM模式。最终，是否使用框架——以及如果使用，使用哪个框架——应取决于您项目的需求、您团队对框架的熟悉程度以及您个人的编码偏好。*记住，工具是用来帮助您的，而不是规定您如何编码的。*
- en: Contributing to the community
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为社区贡献力量
- en: As we wrap up this chapter, it’s important to recognize that these third-party
    toolkits and frameworks are, at their core, community contributions. They’re the
    result of someone else’s hard work, thought, and passion. All this code is accessible
    to you on platforms such as GitHub, and it’s maintained by community-minded individuals
    who are always open to suggestions, improvements, and bug reports.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的结束，重要的是要认识到这些第三方工具包和框架在本质上都是社区贡献的结果。它们是他人辛勤工作、思考和热情的结晶。所有这些代码都可以在GitHub等平台上供您访问，并由具有社区意识的个人维护，他们总是乐于接受建议、改进和错误报告。
- en: Remember, contributing to the community isn’t limited to creating a new project
    or toolkit of your own. It can be as simple as reporting a bug, suggesting a feature,
    or even making a small code improvement on an open source project. This open source
    ethos is one of the key strengths of the .NET ecosystem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为社区做出贡献并不仅限于创建自己的新项目或工具包。它可能只是报告一个bug、建议一个功能，甚至在开源项目上进行小的代码改进。这种开源精神是.NET生态系统的主要优势之一。
- en: So, if you’re using these frameworks and see something that can be improved
    or a bug that needs fixing, don’t hesitate to contribute. By doing so, you’ll
    not only improve the tool for yourself but also for other developers who use it.
    This way, you can give back to the community and maybe learn a thing or two in
    the process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您在使用这些框架时发现可以改进的地方或需要修复的bug，请不要犹豫，积极贡献。通过这样做，您不仅会为自己改进工具，也会为其他使用它的开发者带来便利。这样，您可以回馈社区，也许在这个过程中还能学到一些东西。
- en: In conclusion, never forget that these open source MVVM frameworks are not just
    tools for you to use, but they’re also opportunities for you to grow as a developer
    and contribute to the broader .NET community.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，这些开源MVVM框架不仅仅是您使用的工具，它们也是您作为开发者成长和为更广泛的.NET社区做出贡献的机会。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize, both the MVVM Toolkit and .NET MAUI Community Toolkit offer a
    comprehensive collection of components that facilitate the implementation of the
    MVVM pattern in your applications. By using these toolkits, you can avoid the
    need to build everything from scratch or reinvent existing solutions, ultimately
    saving time and effort, and allowing you to focus on building your application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，MVVM工具包和.NET MAUI社区工具包都提供了一套全面的组件，有助于在您的应用程序中实现MVVM模式。通过使用这些工具包，您可以避免从头开始构建一切或重新发明现有解决方案的需要，从而节省时间和精力，并让您能够专注于构建应用程序。
- en: Throughout the rest of the code samples in this book, we’ll be using the MVVM
    Toolkit and make use of classes such as `ObservableObject` and `RelayCommand`.
    These classes are quite straightforward to understand. Even if you choose not
    to use this toolkit, you should still find the code samples clear and comprehensible
    as the underlying concepts are not overly complex.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余代码示例中，我们将使用MVVM工具包，并使用`ObservableObject`和`RelayCommand`等类。这些类非常易于理解。即使您选择不使用此工具包，您也应该发现代码示例清晰易懂，因为底层概念并不复杂。
- en: Further reading
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及主题的信息，请查看以下资源：
- en: 'Introduction to the MVVM Toolkit: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM工具包简介：[https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/)
- en: '.NET MAUI Community Toolkit documentation: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包文档：[https://learn.microsoft.com/dotnet/communitytoolkit/maui/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/)
- en: '.NET MAUI Community Toolkit converters: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包转换器：[https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/converters/)
- en: '.NET MAUI Community Toolkit behaviors: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI社区工具包行为：[https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)
- en: '`ObservablePropertyAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservablePropertyAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/observableproperty)'
- en: '`RelayCommandAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelayCommandAttribute`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/generators/relaycommand)'
