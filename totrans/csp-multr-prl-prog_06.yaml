- en: Chapter 6. Task-based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will cover the **Task Parallel Library** (**TPL**) and the
    details of using the `Task` class to write concurrent code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Lightweight Concurrency – Task Parallel
    Library (TPL)"), *Lightweight Concurrency – Task Parallel Library (TPL)*, we started
    our exploration of lightweight concurrency and .NET's new most preferred way to
    accomplish multithreaded programming—the TPL. In this chapter, we will explore
    task-based parallelism further and show how to wait on tasks or multiple tasks,
    custom scheduling of a task, error handling, and canceling a task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The TPL gives us an easy way to schedule, run, and coordinate tasks at a higher
    level of abstraction than working directly with threads. As mentioned earlier,
    a task is a set of instructions to carry out an objective, a unit of work if you
    wish. We can define a task in a method called by a delegate or in a lambda expression
    defined directly in the task-creation command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: When running more than one task concurrently, there will be times when we need
    to wait on one or more tasks to complete before performing a function, or be able
    to cancel one or more tasks if a certain condition arises, or coordinate exception
    handling if one or more tasks throws an error when running in parallel. We will
    discuss all of these scenarios in this chapter and work through examples. By the
    end of this chapter, you will be very comfortable with all the aspects of using
    tasks in parallel in your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Wait on a particular task when multiple tasks are running concurrently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait on all or many tasks that are running concurrently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancel one or more tasks when certain conditions occur
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle exceptions thrown by one or more tasks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully coordinate the execution and completion of concurrently running tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for a task to complete
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do when we execute a task is to know when it has
    completed, and if it returns results, what the results are. Let's see a simple
    example by creating a task, waiting for it to complete, and then checking the
    results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: We will do this using a task that doesn't return a result and one that does,
    and see the difference between `Task` and `Task<TResult>`. When a task returns
    a result value, the wait is implicit, and when it doesn't, we need to explicitly
    wait for it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s open up Visual Studio and create a new console application called
    `WaitonTask`. Once we have the new project created, we will add the following
    code to the `Program.cs` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from this code, we are creating a task to run for 10 seconds
    and we will wait on the task to finish. This task calls a method named `Worker`
    and is instantiated using a `Task.Factory` and a lambda expression. The task does
    not return a value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compile and run our new application. The following is an example
    of the output you should see:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_01.jpg)'
- en: As you can see, we first start a task with the `Worker` method and wait on it
    to complete and then we start a task with the `Worker` method and perform a wait
    with a time-out value. Did you notice a difference between the two executions?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先使用`Worker`方法启动一个任务并等待它完成，然后我们再次使用`Worker`方法启动一个任务并执行带有超时值的等待。你注意到两次执行之间的区别了吗？
- en: The first time we run the task, we will wait the full 10 seconds for the task
    to complete. The second time we run the task, we set a timeout and continue on
    before the task completes. Since the task runs for longer than 2 seconds, the
    wait command times out and the program moves on, while the task is still running.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行任务时，我们将等待完整的10秒钟直到任务完成。第二次运行任务时，我们设置了一个超时值并在任务完成之前继续执行。由于任务运行时间超过2秒，等待命令超时，程序继续执行，而任务仍在运行。
- en: 'In both of these examples, we have a task that does not return a value. Now,
    let''s change our worker task to return a value and see what happens. Let''s add
    a new method to our program called `Worker1`. Add the following code to the `Worker1`
    method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们都有一个不返回值的任务。现在，让我们将我们的工作任务改为返回一个值，看看会发生什么。让我们向程序中添加一个新的方法，称为`Worker1`。将以下代码添加到`Worker1`方法中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, in the `Main` method of the `Program.cs` file, add the following two lines
    of code towards the end right before the `Console.ReadLine` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Program.cs`文件的`Main`方法中，在`Console.ReadLine`命令之前，添加以下两行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s compile and run our program again. The following is the output
    that you should see when you run the program:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次编译并运行我们的程序。以下是你运行程序时应看到的输出：
- en: '![How to do it](img/8321EN_06_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_02.jpg)'
- en: Did you notice that the program ran and waited for `TaskC` to complete? Shortly,
    we will get to the `SpinWait` method of the `Thread` class, but for now, why did
    the program wait on `TaskC` to finish running when we did not put a wait command
    in the code for it?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到程序运行并等待`TaskC`完成了吗？我们很快就会了解到`Thread`类的`SpinWait`方法，但现在，为什么程序在代码中没有放置等待命令的情况下等待`TaskC`完成？
- en: How it works
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In the previous exercise, we saw three ways to wait for a task to complete.
    The first two examples used the `Task.Wait` method to tell our program to wait
    on the task. Since the task is running on a different thread, we have to wait
    for it to complete before we continue the execution of the program in our main
    thread. In these two examples, our task does not return a value. In this case,
    we need to explicitly wait on the task to complete if we do not want our main
    thread to continue after starting the task (or at least scheduling it in the threadpool).
    We do this using the `Task.Wait` method in the `Task` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了等待任务完成的三个方法。前两个例子使用了`Task.Wait`方法来告诉我们的程序等待任务。由于任务是在不同的线程上运行的，我们必须等待它完成，然后才能继续在主线程中执行程序的执行。在这两个例子中，我们的任务不返回任何值。在这种情况下，如果我们不希望主线程在启动任务（或至少在线程池中安排它）后继续执行，我们需要显式地等待任务完成。我们使用`Task`类中的`Task.Wait`方法来完成这个操作。
- en: The first time, we told our program to wait on the task to complete and then
    move on. The second time, we set a timeout value in the `Wait` method. This tells
    our main thread to wait for the amount of time in the timeout parameter and then
    move on. Then we checked the `Task.IsComplete` property to see whether our task
    has completed or not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们告诉程序等待任务完成并继续执行。第二次，我们在`Wait`方法中设置了一个超时值。这告诉主线程等待超时参数中的时间，然后继续执行。然后我们检查`Task.IsComplete`属性，以查看任务是否已完成。
- en: 'Since the task was set to run for longer than the timeout value, the task was
    still running when our main thread continued execution. That is why the `IsComplete`
    property is `false` and the `else` portion of our `if` statement gets executed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务被设置为运行时间超过超时值，当我们的主线程继续执行时，任务仍在运行。这就是为什么`IsComplete`属性是`false`，以及我们的`if`语句的`else`部分被执行的原因：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can play around with this code and make the task run for less time than
    the timeout value and see what happens.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试修改这段代码，让任务运行的时间少于超时值，看看会发生什么。
- en: Next, we ran a task using the `Worker1` method that returns a `double` value.
    What did we see here? We did not place a `Task.Wait` command but our main program
    still waited on the task to complete before continuing on with its execution.
    Why is that?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用返回`double`值的`Worker1`方法运行了一个任务。我们在这里看到了什么？我们没有放置`Task.Wait`命令，但我们的主程序仍然在任务完成之前等待，然后继续执行。为什么是这样？
- en: We know it waited until the task was completed because when we wrote the `Task.Result`
    value to the console, it had a value and was not `null`. In this case, we do not
    need to use the `Task.Wait` method explicitly because the main thread will wait
    on the task to complete; it needs to wait until the `Task.Result` property is
    set. By defining a task with a return value, we are telling our main thread implicitly
    to wait on the task to complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: So, as we have seen, if we do not return a value in our task, then we need to
    explicitly tell our program to wait. However, if we return a value, we are implicitly
    telling our program to wait on the task to complete.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to control the execution of our main thread when we start
    many concurrent tasks at once. In this case, if our tasks return values, we might
    not implicitly want to wait on every task to complete. Maybe we just want to wait
    on one task to complete.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: In our current program, we used the `Thread.SpinWait` method. This method is
    different from the `Thread.Sleep` method. The `Thread.Sleep` method waits for
    a specified time whereas the `SpinWait` method starts a loop for the specified
    iterations passed to the method. So, in this case, the speed of the processor
    will dictate the duration because the clock speed will determine how fast it can
    complete the number of iterations. By using this instead of a `Sleep` method,
    it also allows the scheduler to perform context switching if thread priorities
    dictate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for multiple tasks to complete
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we examined how to explicitly and implicitly wait on
    a task to complete. Now, let's see how we can control execution and waiting when
    we start many tasks instead of just one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we may want to wait on one task out of a group to finish. Sometimes,
    we might want to wait on all of the tasks to finish, and other times we might
    want to wait on a certain condition of tasks to finish before proceeding.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows all of the `Wait` and `When` methods provided
    with the `Task` class. The `Wait` methods are as shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'The `When` methods are as shown:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Both images are references from [http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate how to perform different `Wait` and `When` techniques in
    this chapter, but this is to give you further ideas on what is possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating a simple program to demonstrate how the `WaitAll` method
    works by populating three circles with random numbers once three tasks complete.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, we need to create a WPF application using Visual Studio. Open
    Visual Studio and create a new WPF project called `RandomCircles`. Once we have
    created this project, proceed by performing the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Go into the design mode in Visual Studio and add the following controls to
    the `MainWindow.xaml` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three Ellipse controls and name them `Circle1`, `Circle2`, and `Circle3`.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set their height and width properties to `120` for all three circles. This is
    done in the `MainWindow.xaml` file using the **Design** mode in Visual Studio.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add three textboxes and place them inside the circles. Name them `text1`,
    `text2`, and `text3`. Set the `Text` property on all three to an empty string
    and make their `Background` property the same color as the `Fill` property on
    the Ellipse controls.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, add a button control and name it `btnRandomAll`. Set the `Content` property
    on this control to `Random All`.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, your `MainWindow.xaml` file should look like the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_05.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, let's go to the `MainWindow.xaml.cs` code behind this file. We need to
    add a `using` statement for the `Threading` namespace.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `System.Threading.Tasks` namespace should already be included when you created
    the WPF project, but check to make sure whether it is there.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s add a worker method to provide work for the tasks to perform, which
    we are about to create. Create a `Worker1` method that is `private` and returns
    a string value. Add the following code to it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`SpinWait` is used here to demonstrate how processor speed can affect the speed
    of a function. `SpinWait` is very inefficient and does consume CPU resources more
    than `Sleep()`.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s create an event handler for `btnRandomAll`—a click event called
    `btnRandomAll_Click`. Inside this method, add the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That should be all you need to have a program that runs three tasks in separate
    threads. Each of these tasks will spin for a random time. The main thread will
    wait on all of these tasks to complete and then return a string that has the random
    number used by the task and the current time in milliseconds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s compile and run our new program. The following is what random
    circles should look like when it is first started:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random All** button once and see what the output looks
    like. The following is what we got when we ran it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random All** button a second time and see what the program
    looks like. The following screenshot is what we got:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make some changes to our program and try running it again. Make
    the following changes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Ellipse control and name it `Circle4`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new textbox control and name it `text4` and set the `Text` property to
    an empty string.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another button control and name it `btnRandomFirst` and set the `Content`
    property to `RandomFirst`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an event handler to the button, `btnRandomFirst`, and name it `btnRandomFirst_Click`.
    Add the following code to the event handler:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s compile and run our program. The following is the output before
    an action is taken:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Random First** button once and the output should look like
    the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Finally, let''s click on the **Random First** button a second time and look
    at the results. They should look like the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_11.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: How it works
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a minute to go through what we just did with this program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: First, our `Worker1` method that performs our *tasks* is a simple worker bee.
    It generates a random number and then does a `Thread.SpinWait` for that number
    of iterations. Then it returns the current time in milliseconds. So, every time
    this method is run as a task in a separate thread, it will run for a random amount
    of time. If multiple copies of this method are running in different threads, then
    they will each finish at a different time because `SpinWait` will run for a different
    randomly generated number of iterations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on the **Random All** button, the event handler is fired. The
    event handler starts three separate tasks each running the `Worker1` method using
    the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created a `Task` array with a string value `TResult` using this command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we wait on all of the tasks in the tasks array using this command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, we display the results of each task and see that they each have a different
    random number and finish at a different time even though each task is executing
    the same method.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we created a second button that does much of the same work except for
    this time instead of the `Task.WaitAll` command, we use this command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, in this case, we only wait for any of the three tasks to complete before
    continuing execution in our main thread. You can verify this by clicking on the
    **Random First** button many times. Each time it can be either task 0, 1, or 2
    that finishes first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Take some time to play with these two commands and make sure you have a full
    understanding of how each works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We will not spend time on this book playing with the `Continue`, `ContinueAll`,
    `When`, and `WhenAll` methods of the `Task` class, but take some time to experiment
    with these functionalities. These methods allow you to execute a task when other
    tasks have completed. So, you can chain task executions together. The alternative
    to these is to wait on tasks to complete and then start new tasks. The `Continue`
    and `When` methods allow you to combine this into one statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore canceling tasks. Depending on your requirements,
    you might want to cancel a task that you have started, before it ends.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a task
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore canceling a task. Now that we know how to start one or more tasks
    and how to coordinate waiting on one or more of these tasks, what if something
    happens after we have started a group of tasks and we need to stop them?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Task cancellation is accomplished in the .NET framework by using **cancellation
    tokens**. The delegate used when running a task needs to have code to support
    cancelation and then any other code that needs to cancel a task can request cancelation
    of the task.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `CancellationToken` structure in .NET manages notification that an operation
    should be canceled. It has a property, `IsCancellationRequested`, that you can
    use to see if a cancellation request has been issued. This structure is a member
    of the `System.Threading` namespace and is used by threads and tasks to manage
    cancellation requests in a multithreaded environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Merely requesting to cancel a task will not cancel the task. The task delegate
    must support cancellation tokens. There are two ways that a delegate can choose
    to cancel. The delegate can simply return from execution, or it can throw an `OperationCanceledException`
    using the `ThrowIfCancellationRequested` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main differences to these two methods of cancelation. If the
    delegate just returns from execution, then the following happens:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The task is put in a state of `TaskStatus.RanToCompletion` instead of `TaskStatus.Canceled`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code requesting to cancel the task does not know if the task simply finished
    or was canceled before finishing.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the task delegate implements the latter method for canceling (throwing an
    `OperationCanceledException`), then the following happens:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The task is put in a state of `TaskStatus.Canceled`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The requesting code can check this status and determine if the task was canceled
    or just finished.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, now we will create a WPF application to allow the user to cancel tasks.
    We will demonstrate how to create cancellation tokens, monitor the task state
    to see if it is canceled, and then do some processing when it is canceled. This
    will also use the `Task.ContinueWith` method. This method allows us to execute
    a task when another task has completed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we will start 10 tasks. Each task will take an integer parameter
    as input and will multiply it by the numbers from 1 to 10 million and take a sum
    of the results. It will then return a `double` value that is the result. While
    this may not be the world's most exciting computation, it will take a little time
    depending on your processor speed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: We will start each task with a task cancelation token pass to it and create
    `ContinueWith` tasks for it. One will *continue with* if the task runs to completion,
    and the other will *continue with* if the task is canceled. We will also have
    a **Cancel** button that allows you to cancel at any time and stop the tasks in
    progress.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up Visual Studio and create a new WPF application called `TaskCancel`.
    In the designer window in the `MainWindow.xaml` file, let's add the following
    items.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two button controls: one named `btnStart` and other named `btnCancel`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add a click event handler for each button: `btnStart_Click` and `btnCancel_Click`
    respectively.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a text block control named `textBlock1`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your `MainWindow.xaml` file should look like the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Now, move to the `MainWindow.xaml.cs` code behind the file. Let''s add the
    following items:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `using` statement for the `System.Threading` namespace:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, inside the class definition at the top, let''s add our cancelation token:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let''s add a method that will execute inside our 10 tasks. We will call
    this method `AddMultiple`. It takes an integer parameter and returns a value that
    is the datatype `double`. Add the following code to it:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, let''s add the code to the click event handler of `btnStart` that will
    start the 10 tasks:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let''s add the code to the click event handler of `btnCancel`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is all we have to do. Now, let's compile and run our application. But this
    time, let's not run it through Visual Studio. We will run the application directly.
    Go to the `bin\Release` folder in our project directory and double-click on the
    `TaskCancel.exe` application. We will explain shortly why we are doing this and
    what happens when we run it in Visual Studio.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, it should look like the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Start** button. Then click on the **Cancel** button. You
    can decide how fast to click on the **Cancel** button but you should see an output
    like the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_06_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: If you try running it in Visual Studio directly, you will notice that when you
    click on the **Cancel** button, an unhandled exception occurs. You can press *F5*
    a couple of times and it will continue on. But why does this happen?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The `ThrowIfCancellationRequested` method has *cooperative cancellation*. This
    throws an exception to indicate that it has accepted the cancellation requested
    and will stop. This exception is handled by .NET in the TPL and shouldn't be handled
    by your code. Since Visual Studio looks for all unhandled exceptions and shows
    them in debug mode, you will see it when running the application in debug mode
    through Visual Studio. There is a way to turn this off through the **Options-Debugging**
    settings under **Tools**, but we do not recommend it because it can mask other
    exceptions that you want to see. Nevertheless, the exception we encounter here
    is a nuisance when debugging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've successfully canceled running tasks, let's see how we did it.
    First, we defined a cancellation token using `CancellationTokenSourcets`. Then
    we instantiated it using `ts = new CancellationTokenSource()`. This gives us a
    cancellation token that we can work with.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Let's skip, briefly, to the end. To cancel tasks, we just call the token's `Cancel`
    method, `ts.Cancel()`, in the **Cancel** button's click event handler. This will
    indicate to any task, which is using this cancelation token, that they need to
    cancel. Now it is up to the tasks to monitor the token and perform the cancelation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take a look at the **Start** button''s click method. Here, we create
    and start 10 tasks using the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we call the `Task.Factory.StartNew` command and pass it the delegate for
    the task to execute and the cancellation token.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we also call the `ContinueWith` command to tell the task what to do after
    it finishes. We set up two of these depending on how the task finishes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the first one, we pass the parameter, `TaskContinuationOptions.OnlyOnCanceled`,
    and for the second one, we pass the parameter, `TaskContinuationOptions.OnlyOnRanToCompletion`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: So, if the task is canceled, the second `ContinueWith` command is executed and,
    if the task runs to completion, the first `ContinueWith` command is executed.
    In each of these `ContinueWith` commands, we pass a lambda expression to execute,
    which prints the results of the task. This is how we update the UI with the status
    of each task, once it has completed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: From the output you can see which tasks run to completion and which tasks are
    canceled. Also, note that the output is not in sequential order. Since the 10
    tasks are scheduled with the threadpool and the different cores on the machine
    we run have different workloads, the tasks finish in different orders.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a look at error handling with tasks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Task exception handling
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, we have learned how to start, coordinate, and cancel tasks. Now, let's
    talk about error handling with tasks. In C#, when we discuss error handling, we
    are really talking about the `try..catch..finally` structure. In this book, we
    assume you are familiar with the operation of a `try..catch` block.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: A task has a lifecycle of states that it can be in. A task can be idle (scheduled),
    running, pending, cancelled, faulted, or completed. Each task has a `status` property
    that defines the current state of the task. We saw this in the last section and
    used `OnlyOnCanceled` and `OnlyOnRanToCompletion` as the options for `TaskContinuationOptions`
    for our `ContinueWith` methods.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: So, when we talk about exception handling with TPL, we are referring to faulted
    tasks. There are several ways a task can reach a faulted status, for example,
    when the task delegate fails and throws an exception. A **faulted task** is basically
    a task that resulted in an error and carries the exception with it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code will incur an exception if you perform one of the following on a
    faulted task:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在故障任务上执行以下操作之一，您的代码将引发异常：
- en: Waiting on a task
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待任务
- en: Using the task's result value
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务的结果值
- en: Performing an `Await` on the task
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任务执行`Await`
- en: So, when you use the `Wait`, `WaitAll`, `Await`, or `Result` methods of a task,
    you should surround these statements with a `try..catch` block. The first two
    will always throw an exception of the `AggregateException` type, which is a container
    for multiple exceptions. The `Await` will throw the actual exception occurred
    by the task's delegate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您使用任务的`Wait`、`WaitAll`、`Await`或`Result`方法时，应该用`try..catch`块包围这些语句。前两者将始终抛出`AggregateException`类型的异常，它是一个多个异常的容器。`Await`将抛出任务委托实际发生的异常。
- en: These are the basics of task exception handling. We want to do a `try..catch`
    around the `Result`, `Wait`, or `Await` of a task.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是任务异常处理的基本知识。我们希望在任务的`Result`、`Wait`或`Await`周围执行`try..catch`。
- en: 'But what if we start a task and do not care about waiting on it or its results,
    but we want to know if it incurs an exception? How do we know if a start-and-forget
    task has a problem? In this case, we can use a simple technique with the help
    of the `ContinueWith` command. Look at the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们启动一个任务，并不关心等待它或其结果，但我们想知道它是否引发了异常？我们如何知道一个启动后忘记的任务是否有问题？在这种情况下，我们可以使用`ContinueWith`命令的简单技术。看看以下命令：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we create a task to execute on a `ContinueWith` command if the
    task is in an `OnlyOnFaulted` state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果任务处于`OnlyOnFaulted`状态，我们创建一个任务来在`ContinueWith`命令上执行。
- en: So, you can perform exception handling with a `try..catch` on the result while
    waiting on a task or, if you are not waiting on the task or result, you can create
    a `ContinueWith` task to handle the exception.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在等待任务时对结果执行`try..catch`异常处理，或者如果您没有等待任务或结果，您可以创建一个`ContinueWith`任务来处理异常。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at ways to wait on a task, cancel, chain, and
    perform exception handling with tasks. We have now covered all of the aspects
    that need to work with tasks in the TPL and the techniques needed to handle all
    of the scenarios your design might encounter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了等待任务、取消、链式操作以及使用任务执行异常处理的方法。我们现在已经涵盖了所有需要在TPL中与任务一起工作的方面以及处理您的设计可能遇到的所有场景所需的技巧。
- en: We encourage you to further explore the techniques presented in this chapter
    and explore the world of task-based parallelism. The days of working directly
    with threads and the `BackgroundWorker` component will soon become a distant memory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您进一步探索本章中介绍的技巧，并探索基于任务的并行世界的奥秘。直接与线程和`BackgroundWorker`组件工作的日子很快就会成为遥远的记忆。
- en: These last two chapters have been an overview of TPL and task-based parallelism.
    In the next chapter, we will cover data-based parallelism and working with data
    collections in a concurrent manner.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这两个章节是关于TPL和基于任务的并行概述。在下一章中，我们将介绍基于数据的并行以及以并发方式处理数据集合。
