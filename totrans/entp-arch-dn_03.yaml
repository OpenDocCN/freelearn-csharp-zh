- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reaching Business Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the first chapter explaining the problems information systems globally
    face and the second one on the general theory of industrialization, it’s time
    for some actual battle-proved methods! Though we will not get our hands on the
    code or deploy software before *Part 2* of the book, this third chapter is much
    more applied and will show the principle of what is called business/IT alignment.
    The idea behind this principle is that the software system should reflect the
    structure of the business domain it aims to automate as much as possible. In a
    way, this is applying **Conway’s law** (which will be explained) backward, using
    it to obtain the desired result. In practice, it is important to know the map
    to rule on the ground, so we will be using an information system mapping technique
    based on the four-layer diagram pushed forward by **CIGREF** (short for **Club
    Informatique des Grandes Entreprises Françaises**), among other organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Software for business and the principle of alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conway’s law applied to application and systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the CIGREF diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the four-layer diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and antipatterns of alignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After describing the method and drawing similarities with the **TOGAF** (short
    for **The Open Group Architecture Framework**) framework or other methods, we
    will apply it to a sample IT system so that you really can benefit from it as
    soon as you have finished this chapter. Finally, we will see best practices, but
    also anti-patterns in business alignment. Just like any other method, business/IT
    alignment using the four-layer approach has its advantages and its limits. It
    is especially important to know them to apply the method as efficiently as possible
    and also to know how to use it to determine when and where there are alignment
    problems in the information system under study.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As said in the introduction, this chapter will be more practical than the two
    previous, theoretical, ones. This means a reading prerequisite—since we will talk
    about methods of analyzing information systems, you should have previous analytical
    contact with them at least. Sure, everyone uses them nowadays, but you will need
    a bit more than just experience using them, in particular some knowledge about
    the different parts they are made of. Nothing fancy here, but you need to understand
    the difference between software and hardware and that information systems are
    generally there to automate business processes, which are sets of human and computer-based
    tasks organized toward reaching a goal. You will also need to be able to recognize
    the different parts of such a system. If we call them systems instead of simply
    software applications, this is because they are more complex and made of several
    modules. You need to understand this and be able to tell which parts the system
    is made of.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to be able to classify these parts of the system. Are they
    classified by function or by some more concrete, IT-related criteria, such as
    their position on the on-premises servers versus in the cloud? Are they autonomous
    or do they communicate a lot with other functions, and if so, with which interfaces
    and protocols? This is certainly just general knowledge or common sense for most
    of us, but this is something you will need to be able to read this chapter nonetheless.
    This will help you to point out critical questions. For example, when talking
    about interactions between parts of the systems, are we talking about business
    dependencies or concrete, IT-related streams of data? To give you a better understanding
    of the difference, let’s go over some illustrations. An example of business dependency
    is when the ordering system depends on the customer’s list. Indeed, we can record
    a company with our orders, but it does not make much sense to record an order
    without knowing the customer who buys the products listed in it. On the other
    hand, an example of IT-related data streams is when the ordering system accesses
    the customer’s database to propose an existing record.
  prefs: []
  type: TYPE_NORMAL
- en: Software for business and the principle of alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point of the book, it should already be quite clear, but it does not
    harm us to recall that we are only talking about professional information systems.
    In short, we put ourselves in a case where software really means business: applications
    that are mission-critical for companies, information systems that help production
    for a commercial company or a non-profit organization, etc. All recommendations
    that follow would not make any sense on small systems and would be way too complicated
    if applied to a simple piece of software application.'
  prefs: []
  type: TYPE_NORMAL
- en: This being said, the hypothesis is that, since there is a business, there is
    good knowledge of it; we know who the participants in the business are, what the
    stakes and objectives of the business are, which strategy is being conducted (even
    if it is not 100% clearly defined, as happens in a lot of companies), etc. This
    last one is of utmost importance; there is no need to design an information system
    if the strategic direction has not been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It should be emphasized that the definition (even if not completely precise)
    of the business strategy is an absolute prerequisite to an analysis of enterprise
    architecture and the mapping of the information system. As an analyst with many
    years of experience with information systems, I always refuse a project if I realize
    in the first meetings that there is no company-level strategy, and I recommend
    anyone to do the same. If you are reading this chapter thinking about how you
    are going to define an information system and realize there is no business-defined
    strategy, you are better off stopping reading right now and coming back when this
    essential information becomes clearer. Trust me on this one—if you realize the
    upcoming steps before the vision of the objectives of the information systems
    is (at least globally) clear, you are going to waste a lot of your time and do
    more harm than good.
  prefs: []
  type: TYPE_NORMAL
- en: Why is all this so important? Because you are going to use the definition of
    your target business to design the information system to be aligned with it. Technology
    should always be at the service of the users, so knowing the business beforehand
    is what is going to drive the design of the information system (again, there is
    no need for a perfectly detailed strategy, but at least a vision or a direction).
    This is what is called business/IT alignment or, in the context of this book,
    simply alignment. We will see that this is the only stable method you need to
    obtain a sound and future-proof information system, free from the problems that
    have been described in the first chapter. But before we dive more into the method
    of achieving business/IT alignment, let’s just take a look at other methods that
    are not business-related but technically driven and learn where they apply and
    what their limits are when designing complex information systems.
  prefs: []
  type: TYPE_NORMAL
- en: The jungle of technical recommendations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are a true software professional and worry about the quality of your
    deliverables, you most certainly have read a lot about technical methods that
    help in addressing the issue and improving your software skills. You have heard
    about **V-cycle**; **Agile methods** to organize software teams; **extreme programming**;
    **test-driven development**; **behavior-driven development** for practices; programming
    patterns to improve code structure; development-specific **key performance indicators**
    to follow the quality of code; and so many more that a complete chapter would
    not be enough to describe them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though there is interest and things to learn from most of them, their sheer
    number shows the limits of such methods: they are only true in given contexts
    (otherwise, due to the number, some would oppose others) and, sadly, most of the
    people writing about them often forget to define this perimeter because they are
    interested in explaining the technique itself. The more the technique has helped
    them to lift a given obstacle, the more they will tend to present it as an essential,
    go-to recommendation. In extreme cases, the person recommending the practice does
    not realize the small size of the context operated and will consider this practice
    as universal, encouraging others to use it without limit.'
  prefs: []
  type: TYPE_NORMAL
- en: This is of course where the critical thinking of the reader is expected, but
    at the same time, the reader should logically be someone who knows less about
    the domain of expertise of the writer, and it may be difficult for him/her to
    spot the limits of the content. “A little knowledge is a dangerous thing”, and
    the internet is polluted with people who just learned a new trick and will gladly
    expose it to the community as the solution to everything. This enthusiasm is understandable,
    and I have certainly done this in my blogs or general training activities, but
    that does not mean there is no solution and, again, the way forward is to improve
    the critical thinking of the reader.
  prefs: []
  type: TYPE_NORMAL
- en: An example with KISS, DRY, and WET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take an example of some practices that you have certainly heard of: **KISS**
    (**keep it simple, stupid**) and **DRY** (**don’t repeat yourself**). The first
    one states that simplicity should always prevail when creating a software implementation.
    This is particularly true in Agile methods since additional features or feedback
    from the users will certainly force the rewriting of the code. The second one
    implies that code should never be repeated and that similar blocks of code should
    be put into a unique function called from the different places in the code where
    the same function is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Before any further analysis, we should note that there seems to be a similarity,
    or at least quite a strong link, between the two recommendations. After all, if
    we reduce the code repetition, we make things simpler (or at least they may appear
    so, but this is the subject of the following). We may thus question the use of
    the two approaches, but again, software engineering is not an industry yet, so
    every craftsmanship has its own tools and uses. Fair enough…
  prefs: []
  type: TYPE_NORMAL
- en: But the real point of analysis of these two methods is their context of application.
    As with most technical best practices, they do not blindly apply to everything
    and their use should be carefully pondered. Sure, it makes sense to unify a simple
    function to display a warning when you find it many times in the same class, but
    how about the same situation with two classes in distinct software applications
    where the warning label slightly differs? If the text is not the same, maybe this
    is because the warning is on a situation that is not the same, so we should analyze
    the condition on which they are called. However, as the software modules are not
    the same, the variables will not necessarily be the same, so it is going to be
    difficult to analyze the similarity of the situations prompting the warning dialog
    display. And how about coupling? If we decide to keep only one code, which application
    module should have it? Or should we make another module that stores the code of
    the dialog box? And in this case, what about the fact that the life cycle of two
    applications now influences the versions of this common library, which could certainly
    become an issue? Sometimes, unifying code can do more harm than good.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of discussion has brought lots of reflections, and a new good practice
    has been proposed by the acronym **WET** (opposite to DRY), standing for **write
    everything three times**. Indeed, the hesitations exposed mean that, to find the
    right decision, it is beneficial to wait and gather some more clues on the actual
    similarity of the contexts of use, and the creator of the method proposes to write
    the code three times before thinking about unifying it. This is a sound approach,
    as it avoids the “black or white” approach of the DRY principle and opens a whole
    domain of a gray area corresponding to the actual truth: it depends on the context.
    Writing the code, writing it a second time and observing the similarities, then
    writing it a third time and analyzing the return on the investment of unification
    certainly is a sound approach... but does this make it a law that every programmer
    should obey? Of course, no—again, critical thinking applies, and the three times
    may not apply to you. Maybe you will need five, maybe you will decide the limit
    will be time-based and not based on the number of occurrences (wait for one year
    of maintenance, for example). It is up to you, and I suspect three times was chosen
    partly because it made for quite a humorous opposition to the DRY principle.'
  prefs: []
  type: TYPE_NORMAL
- en: All this is to say that lots of technical, code-related methods that are used
    in software development are sometimes presented as hard truth or generally applicable
    best practices, but, most of the time, they are just principles that apply to
    a given context, and can (and must) be bent to fit others.
  prefs: []
  type: TYPE_NORMAL
- en: The particular case of internal toolboxes/frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we switch to solutions on the issue just explained (and do not worry,
    there are some), a most-observed example of how best practices applied without
    a thorough context analysis can lead to bad situations is the development of bespoke
    company frameworks. During the writing of this chapter, I stumbled upon a great
    article from Aaron Stannard ([https://aaronstannard.com/dry-gone-bad-bespoke-company-framework/](https://aaronstannard.com/dry-gone-bad-bespoke-company-framework/))
    that happens to perfectly reflect my own analysis on frameworks after 25 years
    of programming with or without them, creating some and cursing myself to have
    done so, adoring some others and realizing they brought a huge value to the software
    I was responsible for, etc.
  prefs: []
  type: TYPE_NORMAL
- en: Aaron Stannard explains in this article how the DRY principle applied too strongly
    has harsh consequences on teams that develop specialized frameworks to unify coding
    and, in the end, they obtain results that were the opposite of those that were
    expected in terms of boilerplate code reduction, scale capacity, and quality of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some frameworks bring huge value to software applications and information systems,
    and you will easily locate them:'
  prefs: []
  type: TYPE_NORMAL
- en: Everyone knows them and is happy to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newcomers consider the framework helpful in making them more productive and
    quicker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users can describe in very few sentences what the framework does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework has very little dependencies and can be used easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is so important that developers will go as far as doing the thing they hate
    to keep it going: documenting it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the opposite side, there are frameworks in code that hinder the programming
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: They have been created by a few experts and the rest of the team does not use
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newcomers tend to write the equivalent code directly and question the fact that
    the framework would have helped them be more productive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They sometimes do so many things that none of their features are stable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They bring some other constraints (operating on just one type of database, requiring
    script modules, elevation of privileges, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their functioning is in the mind of the experts (often, a single person, which
    is dangerous for the company), and training their colleagues on the use of it
    is somewhat of a challenge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difficulty in knowing where you are between these two ends of the spectrum
    is linked to the fact that the creators of the framework will, of course, be biased
    about their “baby”. They would always overestimate the time saved by using it
    or forget or overestimate the time to maintain it, the time to teach it to others
    in the team, the risk that the company is taking by putting an important dependency
    in the hands of one person, and so on. If you have to evaluate the use of a framework,
    you should put all these factors in a spreadsheet and coldly evaluate the return
    on investment in the short, middle, and long term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the modern programming platform has now brought so many tools that
    the very existence of frameworks can be questioned. For example, **.NET Core framework**
    version 8.0 has such a large ecosystem and **Base Class Library** that all purposes
    for which frameworks were created ten years ago have simply disappeared:'
  prefs: []
  type: TYPE_NORMAL
- en: Object/relational mapping is taken charge of by **Entity Framework**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API request/response with mapping to objects is handled by **ASP.NET Web API**
    and integrated **JSON**/**XML** serialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring is taken care of by the logging stacks that can be plugged into any
    third-party listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The consistent page description is done with **Blazor**, with style handling
    included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment on mobile applications is realized through **Multi-platform App UI**
    (**MAUI**), which also unifies with the Windows frontend, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So my advice on this question of the frameworks is to wait as much as possible
    before creating a framework and trying to avoid it as much as possible (most of
    the time, admit it, you want to create the framework not because it is good for
    your business, but because it is fun to code). If it has to come, it will do so,
    and this is where emerging code architecture (we will come back to this notion
    soon if you have not heard about it) makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only stable guide: aligning to your users’ business'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After this long digression, we come back to our initial consideration of the
    difficulty of knowing when to apply best practices and so-called “principles”
    in software. Yet, we desperately need guidance for the architecture of information
    systems because the stakes are too high and we have seen how bad the impact can
    be on business if we fail at this. So how do we know? Is there a sound and stable
    way that always applies? Some actual laws that we will be indeed able to truly
    rely on when designing something as essential for a company’s future as the structure
    of an information system? Yes, there is, and it is not a technical rule, but a
    method for technical decisions: always relate them to the business of the information
    system. This is the root of business/IT alignment.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I am going to repeat this rule and explain it in many different
    ways, as it is so important for a correct information system architecture—what
    drives the design of the information systems is the structure of the business.
    This is particularly true for the concepts, and creating a successful software
    backbone for a company always starts with a perfect understanding of the business.
    What is a customer? What products do we sell? What are the main processes of the
    company that ought to be computerized? Most of these questions sound trivial,
    but they are only so because human brains can adapt to the background context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take the very first question: what is a customer? This is so obvious
    for anyone in the company that the question is rarely asked, and it would sound
    quite ridiculous if any employee questioned it. “Customers are companies we do
    business with”. All right, but how about individuals? Yes, sometimes we also deal
    with individuals; this is the difference between B2B and B2C. And what if we question
    the term “doing business with”? What frequency and volumes are we talking about?
    Sure, any volume may be taken into account, and a person buying a simple bolt
    from you may be considered a customer in the exact same way as a company acquiring
    thousands of them a month. But how about time? Would you consider someone who
    has bought a product from you twenty years ago still a customer? No, certainly
    not. How about one year ago? Yes, of course... In this case, where is the limit?
    Ten years? Five? Decisions, decisions, decisions!'
  prefs: []
  type: TYPE_NORMAL
- en: About this previous example, you may find companies where managers do not agree
    on the exact definition of a customer between marketing and commerce... So, how
    would you expect a dumb computer to decide this? The hard truth is that, if you
    want to replace some tasks with software and data streams, you will have to make
    everything absolutely crystal clear for it to work. This is where most of the
    information systems fail—they have not been designed with a perfectly accurate
    view of the business, leaving some details to the implementation or use of the
    system by humans. It may work for some time when humans compensate for the missing
    knowledge in the computer, but sooner or later, there will be trouble. In the
    best case, the system will never be as efficient as expected. In the worst case,
    people leaving the company with their compensating knowledge will cause the system
    to come to a halt.
  prefs: []
  type: TYPE_NORMAL
- en: What does this example show us? First, one should be extremely clear with the
    business definitions when it comes to making a software information system deal
    with them. The second is that, very often, these concepts are business rules,
    which means they are not perfectly stable but depend on how the business is run.
    The definition of the customer may change in time if your boss decides one day
    that the list of customers should not present the ones that have not bought anything
    from you in the last three years, where this duration previously was five years.
    If this situation is bound to happen from time to time, it is of course of utmost
    importance that its impact on the information system is limited. Putting this
    logic in a unified line of code or, even better, in a parameter is a great move
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: On the contrary, storing the list of customers and their definitions in a single
    table will cause great coupling because the definition (name, address, contacts,
    etc.) will not change when the “customer status” does. If removing a company from
    the customers’ list means you have to delete the entry from your databases, there
    may be an impact on other functions that still need this data (for example, guarantee
    management, accountants, etc.). We will come back to this example in *Chapter
    9* with some more details on how to model it correctly, but for now, please remember
    that business thinking must always guide how your software concepts will work.
    Alignment is not something that arises from nothing or goes both ways—it is driven
    by functions, and the software should blindly follow the business domain ontology.
  prefs: []
  type: TYPE_NORMAL
- en: In fact—and this will be the last bit in this section—sticking to the business
    domain reality should even go one step further and in particular stick with it
    *in time*. This means that your model should always accommodate time since the
    business always varies. Change is the only constant in life; businesses cannot
    escape this and rather are highly dependent on it. With ever-changing business
    rules, more and more complex organizations, and higher functional sophistication,
    the information system must be designed from the beginning to accommodate change.
    Management of time is so important that the next chapter will be completely dedicated
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Digression on the digital transformation of companies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we are talking about software representation of the business domains,
    we might as well expand on this and observe how software has “eaten the world”
    (*Why Software Is Eating The World*, Marc Andreessen, 2011) and why this active
    digital transformation relates to the business alignment concepts talked about
    previously. A schema is worth a thousand words, and *Figures 3.1* and *3.2* should
    explain the main difference digital transformation makes to how we operate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the digital transformation, the human operator was at the center of
    the business operations and operated both in the real world and on the computerized
    vision of the business (or parts of it, as we saw earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Schema for when the human operator was at the center of business
    operations](img/B21293_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Schema for when the human operator was at the center of business
    operations
  prefs: []
  type: TYPE_NORMAL
- en: 'The digital transformation brings a whole new approach where software becomes
    the main tool of operation for the human and operates in the real world on behalf
    of the human user. The hardware and software systems receive orders and signals
    from the human interfaces and the sensors, translate them, and send them back
    to the human operator (through graphical user interfaces) as well as on the concrete
    reality (through mechanical operators or other ways):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Schema for digital transformation](img/B21293_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Schema for digital transformation
  prefs: []
  type: TYPE_NORMAL
- en: This has a particular consequence that IT is now at the center of the picture,
    interacting both with the real world and with humans. Depending on your point
    of view, computers helped humans to not get their hands dirty with direct interactions,
    or they took us away from direct interactions with the world and all the risks
    associated with potential bias and the wrong representation of reality. Social
    networks are the paramount manifestation of these negative impacts and, as software
    engineers, you should always be aware of this kind of risk and design systems
    accordingly, as their impact on the real world is now well established and people
    working in the field should keep a moral, responsible approach.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this made the digital transformation and the interaction between humans
    and computers clearer. Let’s now concentrate on how humans can impact the way
    software is organized and talk about something called Conway’s law.
  prefs: []
  type: TYPE_NORMAL
- en: Conway’s law applied to application and systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked a lot about the limits of so-called “laws of software” in the first
    section of this chapter, so you may wonder why I will now spend several paragraphs
    talking about something that, at first sight, may seem similar. Nothing could
    be more different... Conway’s law is a true, stable guide for information systems
    design, as it does not state a recommendation but draws a theory from multiple
    observations and lets one decide its own conclusion on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Melvin Conway stated in 1967 that “any organization that designs a system will
    produce a design whose structure is a copy of the organization’s communication
    structure”. In our case study, which is information systems, this means that the
    architecture of the resulting system will reflect the structural organization
    of the team defining it, and this would imply the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A team with a strong separation between frontend and backend will produce a
    system where these two software functions are indeed independent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A team where people are grouped depending on their business domain knowledge
    will produce an information system with clear-cut business-aligned services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A team of only one person would give birth to a very cohesive, monolith-like
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A team with no or low communication between its parts would create a system
    where modules do not correctly interoperate with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last example may look like an extreme, but, sadly, this is the case with
    most information systems because the teams are generally composed with a single
    piece of software in mind, resulting in many applications composing the system
    without the interoperation having been thought out in advance. Thus, links are
    established in an upon-needed, point-to-point manner, resulting in brittle links
    and inefficient systems.
  prefs: []
  type: TYPE_NORMAL
- en: Since this initial empirical observation from Conway, the eponym law has been
    verified many times and, though it cannot be demonstrated like a mathematical
    law can, it is nowadays considered something largely reliable. It is considered
    such a strong law that system designers have started using the law to structure
    teams in ways that would bring a desired shape to the resulting system. In this
    approach, the law is not only seen as a consequence but as a helping tool to shape
    the system as needed. What I am talking about comes from my own experience but
    also has been formalized under the name of the **inverse Conway maneuver** since
    many other software engineers have had the same approach. Martin Fowler, for example,
    puts this law forward ([https://martinfowler.com/bliki/ConwaysLaw.html](https://martinfowler.com/bliki/ConwaysLaw.html))
    and even draws a relationship with **domain-driven design** (**DDD**). This will
    be further explained in an upcoming chapter specifically aimed at explaining the
    importance of semantics—related to the concept of ubiquitous language in DDD—in
    designing the parts of an information system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the inverse Conway maneuver, one can influence the resulting design of
    a system by working on the communication and structure of the teams working on
    designing it. This is a great way to achieve the much-desired business alignment
    that we have talked about since the beginning of the chapter. By defining the
    teams alongside the business domains and giving them business-related concepts
    to talk about with each other, the resulting system will be made of modules with
    clear-cut functional responsibilities and well-structured interoperations between
    modules, favoring the long-time evolution of the resulting system.
  prefs: []
  type: TYPE_NORMAL
- en: Influencing the alignment of a system is great, but, most of the time, one will
    be exposed to an existing one, with the only possibility of understanding its
    state. This is where we need a way to analyze the existing alignment, and this
    is where a dedicated method of diagramming is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the CIGREF diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, business alignment has much to see with vocabulary and the
    right expression of concepts that are related to the functional domains. For those
    of us who are more comfortable with schemas, there exists a more graphical way
    to visualize this alignment, and it is called the **four-layer diagram**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In France (where I am from), it has been popularized by the Club Informatique
    des Grandes Entreprises Françaises (a large French company club for software architecture),
    but this is a very widespread way of thinking and no ownership has been claimed
    on this idea, at least that I know of. The concept is quite simple and is about
    separating the different levels of an information system, each using the levels
    I will present to work. At the top of the diagram, one will find the business
    processes that the system serves, and one level down are the business functions
    that are needed for this. These two layers are purely functional and are not even
    related to software; some tasks and functions could be realized by humans without
    any impact. The two technical layers at the bottom are respectively software and
    hardware, the former using the latter. This way of specifying a system (or rather
    its outermost structure) can be schematized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.\uFEFF3 – Four-layer diagram](img/B21293_03_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Four-layer diagram
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive a bit deeper into each of the levels in the following sections, and
    in particular show how each level’s content is represented in detail, as this
    schema is only symbolic and does not contain the actual contents of each layer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the chapter (and in subsequent parts of the book), we will refer
    often to these four layers or levels by their number, starting from the top (**Level
    1**, **Level 2**, **Level 3**, and **Level 4**). The next section details **Level
    1**, and so on…
  prefs: []
  type: TYPE_NORMAL
- en: Process level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A business process is a series of tasks organized toward reaching a defined
    objective. Since we talk about IT, at least some of them will of course be automated,
    but there can be man-activated tasks as well. Processes are used to structure
    a business or any organization’s activities, and **business process modeling**
    (this is the accepted name) is about representing these to document, better comprehend,
    and improve the efficiency of the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a standard for business process representation, namely **BPMN**, which
    stands for **Business Process Modeling and Notation**. This standard currently
    is in version 2.0\. You certainly have already seen this kind of diagram, which
    reads itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – BPMN example](img/B21293_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – BPMN example
  prefs: []
  type: TYPE_NORMAL
- en: 'In this very short and undetailed example of a new process in a company, you
    will find the most used components of the BPMN standard:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are boxes, generally filled with text starting with a verb describing
    the activity represented. Icons inside the task may specify whether it is automated,
    has user inputs, is entirely manual, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrows between tasks indicate the flow of information in the process and, as
    a consequence, the order in which the tasks are processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diamond-shaped boxes intervene in this stream of information to incorporate
    complexities such as choices or parallel activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events are represented by circles. A process will always have a start and one
    or more ends. It can also have intermediate events and all those can reflect types
    of events, such as time-based, message-based, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For more information about BPMN, I strongly recommend studying the BPMN poster
    available at [http://www.bpmb.de/index.php/BPMNPoster](http://www.bpmb.de/index.php/BPMNPoster).
  prefs: []
  type: TYPE_NORMAL
- en: Though Layer 1 of the CIGREF diagram is mostly based on BPMN diagrams, as they
    are the standard for business processes representation and the main subject of
    this layer, one can also find in this layer some additional information that goes
    together. For example, business domain-related rules can be specified as **DMN**
    (**Decision Modeling Notation**) and are added to this first level, as they have
    impacts on the business processes themselves. DMN is, by the way, a “sub-norm”
    included in the BPMN standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what one tries to obtain, the layer one map may be very coarse
    and with few details. This is an example from an animal genetics company I advised,
    which already had a complete ISO-9001 diagramming of its processes and simply
    needed to know which parts of the information system related to which business
    process (intentionally blurred for confidentiality reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Example of a processes map](img/B21293_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Example of a processes map
  prefs: []
  type: TYPE_NORMAL
- en: Since this customer of mine did not have any problem with the processes themselves,
    their representation remained very light during the whole alignment project. The
    only subtlety in this was that operational processes had been separated from support
    processes and piloting ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrarily, the following diagram is only one of many processes in layer 1
    of a map I created for another customer, this time an organization where IT problems
    mainly came from a lack of definition in the processes (and, of course, when objectives
    are not clear, it is hard to have an efficient IT system). In the following diagram,
    the readability of the text is not intended, as I only want you to look at the
    overall process diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Detailed process](img/B21293_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Detailed process
  prefs: []
  type: TYPE_NORMAL
- en: Layer 1 is of course the most important level of the map of your information
    system because nothing depends on it. All other levels depend on the one above,
    but the processes layer has to be designed from scratch, purely based on the business
    domain knowledge. And, as explained, if processes are not clear or badly designed,
    this will of course affect the software and, in time, the efficiency of the whole
    information.
  prefs: []
  type: TYPE_NORMAL
- en: It is hard to stress enough how important this layer is. This does not mean
    that it has to be drawn with many details; these are only necessary once someone
    spots a problem in the process and needs to know it in depth to improve or correct
    it. But the first layer has got to be correct and cover the whole perimeter of
    the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Functional level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second level of the CIGREF map indicates what functions can be used by the
    tasks of the processes above to realize them. This is still a functional layer,
    but this time, the organization is different as the atoms of this layer are about
    who can do what.
  prefs: []
  type: TYPE_NORMAL
- en: There are indeed functions that do not vary with processes. Business processes
    must be able to change according to strategy, but some things remain stable. In
    our example shown in *Figure 3**.3*, to welcome a newcomer to a company, one of
    the tasks was to take his or her picture. This may be useful for other things
    in other processes, but the very act of taking a picture is a function of the
    organization, may be realized by a given person, and necessitates dedicated materials
    such as a camera. It is thus a function and has to be registered in this second
    layer. Many processes may point to it, but the function will remain in one place
    on the second-level map, together with its stable attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the most important of these attributes are linked to the organization
    of the functions inside the organization. Things may vary, and there is no fixed
    standard for this, but there is at least a good metaphor that has been used for
    decades and bears good results, which consists of creating a parallelism between
    information systems and cities’ organizations (in France, this approach is called
    “urbanization”). This metaphor leads to decomposing the second layer of the CIGERF
    map in three levels of depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zones/areas** are the larger groups in the layer. They correspond to how
    the whole system (or city, in our metaphor) is organized. In a city, one will
    find commercial, industrial, and living areas that are generally clearly separated;
    one should find the same in the functional layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Quarters/neighborhoods** are a finer subdivision corresponding to the local
    organization of a system, with people, businesses, or, in our case, IT functions
    potentially talking to each other.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blocks/islands** are the fine divisions inside which people know each other
    and interact often. In the corresponding IT definition, these contain functions
    that are closely related because they use the same tool or because the same team
    operates them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I am often asked what kind of decomposition should be used, at least for the
    top-most level. This is a difficult one, as the **business capability map** (**BCM**)
    (as this second layer of the CIGREF map is often called) is most of the time simply
    non-existent in companies. Lots of them have a clear view of their processes due
    to ISO 9001 certification and the relative standardization of the approach. Companies
    can also track down their software layer, at least for the biggest blocks for
    which they are billed. But in the middle, this BCM is quite often forgotten, and
    we will see a bit further that this is the source of loss of misalignments in
    the systems.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that this layer is forgotten is in itself a big part of the problem
    in many information systems, as leaders may favor the process layer (the objectives)
    and put less effort into the BCM (how to realize them). Yet, a vision without
    a plan is just a wish, as the proverb says, and a well-crafted functional organization
    of the system is a great step forward to success.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this metaphor with urban development, the business capability map is cut
    in the same way that would be associated with the composition of a large city;
    just like there are industrial, commercial, and living areas in a city, there
    will be a global organization in an information system, often in the following
    five areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Master data management** is where the most important data of the information
    system is managed (customers, products, etc.). This data will be used by many
    parts and actors of the system. As such, it deserves dedicated governance (a clear
    definition of who is in charge, with what practices and tools, etc.) and to have
    its own dedicated zone in the second layer of the map. When governance is not
    clear on such important data, it often happens that different groups will duplicate
    them, which is not only costly but can bring complicated problems when exchanges
    need to be realized.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shared tools** are not data but still commonly used functions that one will
    refer to in many other parts of the information system and most processes’ tasks.
    They are often classified in a dedicated zone, where one will find office automation
    tools, content management software, identity and authorization management, and
    so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Externally oriented functions** (sometimes called “collaborative”) are for
    all functions that are about interoperation or exchange with functions that are
    outside the scope of the information system itself. This is typically where one
    will find an extranet or commercial websites, connections with partners, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Governance/piloting** is the zone where functions used to supervise the system
    itself will be found. Reporting functions will be placed there, as well as key
    performance indicators, high-management functions, and so on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Business-oriented functions** are the last, but not least, area. This is
    where a company will organize all the functions corresponding to its core value
    and operational domain. If you are a company that builds mechanical parts, you
    will find there all the functions associated with engineering, production, stocks,
    selling, maintenance, and installation. If you work in e-business, there will
    be buying and selling functions, logistics, web operation, security, etc. There
    will also be some groups of functions that support the core business, such as
    human resources, legal, and administrative functions, which are general to most
    companies. When the entity is well organized, it is evident (and proof of good
    alignment) that the quarters in this zone correspond to the different directions
    in the organizational chart. Conversely, if it is hard for you to tell whether
    a given function is under such a direction or service, this may be a sign of a
    lack of alignment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next figure is an example of a BCM that follows the five zones principle,
    with the main one decomposed following the organizational chart directions. Again,
    this is just a commonly observed pattern and not a recommendation whatsoever.
    One should adjust the BCM decomposition as one sees fit to obtain alignment. Again,
    in terms of the text readability of the following diagram, the text content is
    not important but only the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – BCM example](img/B21293_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – BCM example
  prefs: []
  type: TYPE_NORMAL
- en: 'For the anecdote, these five areas are also found in the French government’s
    information system BCM, with the four supporting areas surrounding and the business-oriented
    functions in the middle, which are, in this context, separated by the different
    ministries the French government is composed of. I’ve highlighted the separations
    with black lines, as that is what I intended to show you (the readability of text
    is not intended):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – French government BCM](img/B21293_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – French government BCM
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to the importance of this second layer of the CIGREF. As stated,
    the first one indicates the vision and what value brings the company to the market,
    but the second is about how to operationally implement this vision, and this is
    where things are lacking in disorganized information systems. In the dozens of
    information systems I have been able to watch or help refine, the BCM is *always*
    the least-controlled layer. This absence of correct handling of it is the root
    cause of the information system not giving satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Software layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the next two layers of the CIGREF map, we enter the realm of technology.
    For now, processes and functions were purely business-related and one could very
    well use them for a computer-free information system. But this is not what we
    have today, and the subject of analysis in this book. We will work on computer-based,
    at least partially automated systems here, and the two technical layers that the
    top ones rely on are about implementing the function with computers. Their separation
    is extremely easy: the third layer is everything that is “soft”, which means immaterial,
    virtual, and non-concrete, whereas the fourth layer groups everything that is
    concrete. To say it as simply as possible: if you can touch it (computer, network
    cables, appliances, data centers —even if the walls do not belong to you), it
    will go to the next layer that we will cover a bit later. If it is technical but
    not “touchable”, such as a software application, a database, a stream of information,
    an API implementation, etc., it belongs in the third level in the CIGREF map,
    which we will detail right now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This third level is in general quite easy for the companies to create in its
    first implementation: looking at bills and asking people what software they use
    is generally enough to find out the 80% most important uses of software in your
    system. But, even if exhaustive referencing is not the goal, this may not be enough
    for two reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: First, there may be some “hidden” software that has been bought by a service
    without the company knowing (this is called **shadow IT** and can be a problem
    where maintenance or strong ownership is needed). There is a risk that they will
    not appear on the map if they are strategic, and this might become a problem also
    if people using them suddenly leave and the associated functions collapse without
    anyone understanding why. If you have heard stories of a company having software
    problems after a key person retired, this is what we are talking about.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem is that software is not only applications but also data,
    and data is usually harder to locate and follow in a system. Sure, you can locate
    databases with their commercial licenses or the IP and port they use. But you
    will find data in so many other places, such as dreaded Excel worksheets. Again,
    who has not heard of an Excel workbook that was so important for the company that
    everyone knew about it? In one of the companies I accompanied in business/IT alignment,
    there was “Serge’s Excel file”, which everyone kept telling me about when I was
    trying to figure out where the source of truth was for the articles and prices
    for the company. It turned out that, in this company of almost a thousand employees,
    there was no governance at all on product information management, and this person
    called Serge, at some point when he desperately needed the information, took the
    job of collecting the data from commerce, administration, and engineering and
    putting it together in an Excel workbook, trying his best to follow the changes,
    new products, end-of-life dates, changes in price, etc. As this was not his primary
    job, he had little time to do so and the content of the file was neither complete
    nor free from errors. But since this was the only source of data available, everybody
    quickly copied Serge’s file or referred to it with server links. The managers
    never considered the fragility of this approach to a hugely important source of
    data (maybe even the primary referential of a commercial company together with
    the list of customers), and guess what happened when Serge eventually left the
    company? The system slowly decayed because it was nobody’s job to maintain the
    one-person, non-documented work. Information became dirtier, orders started to
    be false, prices could not be adjusted because most people using the information
    in the file or in the connectors that had been created on it had no clue where
    the data was coming from, etc.
  prefs: []
  type: TYPE_NORMAL
- en: One may object that what I am talking about is not part of the third layer but
    relates to the second one, and indeed, master data management and data governance
    and ownership have to be detailed on the second level. But in this case, I wanted
    to show that a poor technical implementation (which definitely belongs to the
    third layer) and a lack of understanding about where the data in its software
    form stands were the root of the problem that went right up to the first level
    of the map and derailed two of the main processes of the company, namely production,
    and sales.
  prefs: []
  type: TYPE_NORMAL
- en: 'Categorizing the content of this third layer really depends on a lot of factors.
    Some companies with strong internal IT and programming capacities will tend to
    have the applications and data grouped by the technical team that operates on
    it. I have seen others grouping the software layer by technology, as their main
    concern was to operate the technologies internally even though they were—for the
    most part—bought on the shelf. In some cases, software can be sorted by editors.
    And there are many other ways to sort it. In the next example (once again blurred
    for confidentiality reasons), the cutting has been done using functional domains,
    as the company was quite big and the software application and data’s responsibility
    had been affected by the business directions and services (which is quite a good
    practice, as software should always be at the service of the functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Software layer](img/B21293_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Software layer
  prefs: []
  type: TYPE_NORMAL
- en: Hardware layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As explained before, the hardware layer lists and organizes everything from
    the information system that is concrete. After all, the important bits of computerized
    systems are data and virtual functions that dramatically accelerate the processes,
    but we should never forget that, even though in a remote cloud location nobody
    really cares, all this is realized by electrons flowing in electronic chips and
    board, with power supplies, cabling, hard disks, and screens somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'This layer is nowadays very standardized and under control and, in dozens of
    information systems where I have analyzed shortcomings in alignment and performance,
    virtually none of them exposed this limitation due to a hardware problem. In fact,
    it is so rare that in most of the CIGREF maps I have done, the fourth layer is
    very thin, with almost no details, or sometimes it’s not even represented at all.
    For example, if we take the big picture of the different layers I have shown you
    as samples, it so happens that nothing was represented for the hardware layer:'
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 3.10 – Three layers only (the readability of the text is not\
    \ intended)](img/B21293_03_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Three layers only (the readability of the text is not intended)
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, something that company owners know very well will always remind us
    of the existence of this layer, namely their costs. And even if the machines are
    more and more virtualized and made invisible, the financial costs are still there.
    With time, the ecological impact of information systems and data centers eventually
    also becomes a part of the equation, making this layer more visible as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you have to draw a hardware layer, you will find lots of excellent diagramming
    systems that distinguish between server types, can provide dedicated icons and
    metadata so you can list hardware atoms separately, etc. All in all, again, this
    is a very controlled and standardized layer, which certainly explains why we rarely
    have to work on it when talking about IT alignment, other than referring to it
    to complete the software costs and balancing the sum to the benefits expected
    from the first two layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide an example of a hardware layer, here is a chronological series of
    such a layer diagram in a company that progressively externalized its IT (the
    orange bits were servers operated directly by the IT service):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Hardware layer](img/B21293_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Hardware layer
  prefs: []
  type: TYPE_NORMAL
- en: Due to the relatively low importance of the representation of this layer (and
    not of the layer itself, of course), we will not go deeper into descriptions of
    how to use the diagram to map a hardware layer. The groupings, also, are quite
    obvious; most of the time, they are based on data centers with the physical location
    on the top, separate physical servers, then virtual machines, etc. Networks are
    also represented with standard symbols and, all in all, diagrams are generic for
    this layer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the four-layer diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principles of the CIGREF mapping should now be clear, so we can see how
    to use this technique to improve alignment and, thus, the efficiency of the information
    systems. As said, the first action to take when taking control of a system is
    to create a map of it. Otherwise, there is simply no way to be comfortable with
    handling such complex sets. This means of course that creating the map for the
    existing state of the information system is the very first action to take, and
    a CIGREF map is great for that. But lots of questions still remain on how to do
    so. This section contains a few battle-proven pieces of advice on how to use the
    mapping technique.
  prefs: []
  type: TYPE_NORMAL
- en: As an important note, do not worry if you do not know precisely how to use the
    CIGREF method by the end of this chapter. For now, I will just show you how to
    draw it and how to spot problems of business/IT alignment in it, but the rest
    of the book will present lots of other examples of the CIGREF map in action for
    many different purposes. This means it will hopefully become clearer how powerful
    it is in analyzing and structuring an information system and you should not feel
    concerned if you do not know yet precisely how it is going to be used in practice.
  prefs: []
  type: TYPE_NORMAL
- en: What should we map?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, one should never map the entire system in detail. It is, of course,
    essential to have a coarse map covering the whole perimeter of it to understand
    what we are dealing with, but only the parts of the system that need attention
    should be mapped in detail. That may sound obvious, but there have been so many
    times with teams I’ve advised where I realized, a few weeks after explaining the
    method, that they had diagrammed absolutely everything in the information system.
    Thus, this advice needs to be put forward.
  prefs: []
  type: TYPE_NORMAL
- en: It just seems like a natural reaction, in particular for teams with heavy problems
    in their system, to map everything, as it gives a sensation of recovering a bit
    of control. Sadly, this is not only a waste of time during the creation of the
    map, but also a waste of time afterward, when people will try and adjust the diagram
    following the evolution of the system. This is not what system diagramming is
    for. The map is used to anticipate evolution and force it as much as possible
    in the direction we have decided. Thus, it should only be done in detail on parts
    of the system that we are working on. Diagramming in advance is a waste because
    we will have to do it again once we get to work on this portion of the system
    in most cases. Mapping everything is a waste of time for the same reason, and
    even more, because there are (hopefully) parts of the system we will never work
    on, simply because they work fine already!
  prefs: []
  type: TYPE_NORMAL
- en: Again, that may sound obvious when explained but, when one starts mapping an
    information system, there seems to be some kind of frenzy mapping happening and
    I have seen many times well-educated and experienced people realizing that they
    had worked for nothing (the best example I have is an organization with thousands
    of employees where the IT team had diagrammed a process for establishing badges
    to access the internal restaurant; this diagram was of course never used and certainly
    not even read by anyone else than its creators).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema visually explains how a map should evolve in time, with
    parts of a system being detailed only when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Mapping evolution](img/B21293_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Mapping evolution
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the other consequences of this—and more subtle—is that the parts of
    the information system that have been diagrammed in detail should, after the diagram
    has been used to improve them, not be updated anymore. In Figure 3.12, this is
    what happens to the quarter that had been refined in the second step. In the fourth
    step, it is not detailed anymore. That may sound counterintuitive; indeed, once
    the effort has been made to detail this quarter, why just abandon it? The same
    reason applies: if this quarter is now well organized and alignment has been reached
    between business and IT, there is a chance that either we will not come back to
    it or, if we do, the map will have changed. So why bother wasting time on it?'
  prefs: []
  type: TYPE_NORMAL
- en: How to start drawing a four-layer diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with an empty sheet is always difficult; it is even more difficult
    when the IT problems are such that the activity of the company is impacted. To
    ease starting the mapping activity, it is sometimes easier to use paper or a whiteboard
    to give a first view of the system. I like showing the following “first draft”
    of an information system I have been called to analyze because of the anecdote
    that comes with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Using CIGREF](img/B21293_01_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Using CIGREF
  prefs: []
  type: TYPE_NORMAL
- en: This industrial company had difficulties in stabilizing the streams of data
    for scientific analyses and communication of the results to their customers. We
    (the IT team and myself) started spending a few hours drawing the four main processes,
    the incomplete but close enough BCM, and the applications involved in them together
    with the stream of data. At that point, we were about to evaluate the frequency
    of the exchanges that were drawn to determine the weakness. Then, the director
    of the company came by and, looking for a few seconds at what we had done, pointed
    his finger at two of the Post-it notes representing applications and said “Well,
    the problem is apparently here”. This person did not have any technical or IT
    background whatsoever but, seeing that lots of streams would go in and out of
    these two entities, he immediately understood that they were holding back the
    efficiency of the system and, in particular, its ability to evolve. It turned
    out after additional analysis that one of the applications was obsolete and the
    second one had a complexity problem. The system was thus redesigned to improve
    and the main steps were to integrate a new application for the first one and to
    create a superset of APIs exposing the legacy functionalities in a cleaner way
    for the second one.
  prefs: []
  type: TYPE_NORMAL
- en: This shows the power of good information system mapping, as it helps all actors—and
    not only technical-savvy ones—understand what is going on in their IT, which now
    is, almost everywhere, their main working tool.
  prefs: []
  type: TYPE_NORMAL
- en: A generic difficulty when aligning information systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems that almost always happens in the system and has an impact
    on its map is that confusion is frequent between the processes in layer 1 and
    the dependencies in layer 3\. Most functional people tend to think that their
    IT system implements processes exactly like they have been designed; how naive
    of them... Software is not necessarily made in-house and, when bought on the shelf,
    there is almost no chance that it perfectly fits the company’s process. Of course,
    everyone at the beginning of a new software project will swear that they will
    abide by the editor’s logic and adjust their process to keep the solution generic
    and avoid costly specific customizations. But the reality in most of these situations
    is that IT will end up integrating the software hammering circles in square holes
    and the result will not be clean.
  prefs: []
  type: TYPE_NORMAL
- en: This lack of distinction also happens when functional people express themselves
    in technical terms without fully understanding the consequences of what they say
    on the system. Come on, we’ve all at some point had managers or big bosses talk
    about ESB or ETL as if they were able to write the Camel route themselves in XML!
    This overconfidence in IT’s simplicity also brings interesting statements of project
    duration once a BPMN is drawn and functional authors are convinced that it can
    simply be executed, just like it was a WS-BPEL schema with endpoints already existing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take an example and imagine you have been provided with a BPMN schema
    such as this (the French labels do not matter; simply observe the structure of
    the diagram and the fact that all tasks are manual):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Manual process](img/B21293_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Manual process
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that the diagram of data streams corresponding to the realization
    of this process, as given by the IT, is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Process in software](img/B21293_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Process in software
  prefs: []
  type: TYPE_NORMAL
- en: It does not need any technical expertise to realize that there is no relationship
    whatsoever between the tasks in the process and the streams of data that have
    been created between the software applications and databases. So, a fair part
    of the job of mapping the information system will be about drawing relationships
    between the tasks and the corresponding streams of data. In the end, you may realize
    that some of these streams are incomplete, needing others to compensate for the
    lack of data. You may find streams that bring too much data into software that
    should not even have the authorization to see it. You may even find streams of
    data that simply serve no known purpose anymore.
  prefs: []
  type: TYPE_NORMAL
- en: To relate the two layers, you will have to create a strong business capability
    map, as layer 2 will be used as an indirection between the processes and their
    software implementation. This is why BCM is so important and, if you operate on
    information systems, you will realize that this is often missing, simply because
    it is lesser known than processes and software/hardware. Yet, BCM is essential
    to reduce coupling and favor the evolution of the system by providing a way to
    create dependencies without being stuck by technical implementations that are
    hard to change once set in place or having to change the IT because a process
    has been modified in the way the company operates. The BCM, in this case, acts
    as an indirection layer that makes possible the evolution of layer 1 with limited
    impact on layer 3 and vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following schema sums this up, and, by the way, I often tell my students
    that if they only remember one slide from my course on IT alignment, it should
    be this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Coupling done well](img/B21293_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Coupling done well
  prefs: []
  type: TYPE_NORMAL
- en: Evolving the information system in time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, after mapping the existing state of the information system, the next
    step is to improve it, and this calls for a strategy with multiple steps to make
    it more realistic. Again, the CIGREF map is here to help by explaining clearly
    what needs to be adjusted at each step and showing how the dependencies need to
    be taken care of. If one changes a function by plugging it into a new and improved
    software application, all tasks depending on this function will need to evolve
    to take advantage of this, except of course if there is 100% compatibility, and
    in this case, we can consider that the function itself does not change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal at the end of these steps is to reach a state as close to (and cost-effective)
    a realistic and nicely aligned system as possible, which could be schematized
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Ideal alignment](img/B21293_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Ideal alignment
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this may sound ideal, and, most of the time, we will never reach
    alignment for the complete system. But local alignment can be reached, as shown
    in the next schema, which I exported from one of my customers who managed to align
    one of their most important support processes (namely, handling newcomers, as
    this was a company with high structural turnover) in such a way that the efforts
    needed would drop by an estimated factor of ten and the duration of the process
    would reduce to a third of the initial measured time. This was achieved via the
    automation of some of the tasks, but the alignment made this automation possible,
    as the process was entirely manual beforehand due to a clear lack of structure
    in the IT (the company was in a non-technical business and put a limited budget
    in its IT, only realizing after it reached an almost desperate state how important
    it had become for their activities). The following diagram is blurred for confidentiality
    reasons; we intended to showcase only the flow of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Applied alignment](img/B21293_03_18_(replacement).jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Applied alignment
  prefs: []
  type: TYPE_NORMAL
- en: We will come back in the next chapter to the evolution of the information system
    in time. For now, just keep in mind that the CIGREF map has to be used to establish
    the actual situation but can also be used to model a desired future situation
    and every step in between.
  prefs: []
  type: TYPE_NORMAL
- en: The four-layer diagram method for service providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may wonder about the use of the CIGREF map when buying software as a service
    and whether it means that we do not draw anything in the hardware layer. The answer
    comes back to the use you want to have of your map, as you do not map for the
    pleasure of having something complete but because your use case needs you to be
    precisely aware of how your information system is working in its details. This
    means that, if your interest is in software alignment functions, you have absolutely
    no use in knowing where the servers are physically, and, in this case, there is
    no use in drawing anything in the fourth layer; you will simply leave it empty.
    On the other hand, suppose one of your concerns is about the locality of your
    data because your board has a constraint on data sovereignty. In this case, you
    will indicate the precise region in which the data centers supporting the software
    are located in the fourth layer. This way, it will be easy to spot something that
    is outside the allowed regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This comes back to a very important piece of advice: only map what you really
    need. It is very easy to get carried away and map lots of things that you actually
    do not really care about. In particular, the hardware layer is generally quite
    easy to map because automatic network exploration applications can help and good
    system administrators often have agents on every machine deployed for security
    and software inventory. So, people tend to have a very precise drawing of the
    fourth layer, even when their problem is about function to software alignment.
    In this case, you’d be better off replacing the whole hardware layer with a few
    general blocks—typically the data centers used, including your own server room—and
    labeling them with the associated cost, as this is (in this case) the only information
    that will help you.'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about services, an equivalent question can be asked the other way around,
    namely about the CIGREF representation for a software editor or integrator that
    would provide a software service to its customers. How should we represent this?
    Is the cloud used for the customers a part of the information system of the editor?
    Should it be drawn in a particular way?
  prefs: []
  type: TYPE_NORMAL
- en: Again, the notion of the usefulness of the map should drive our response to
    this. Imagine the problem at hand—and thus the reason why you establish a map—is
    that you have a problem of coupling between your internal functions and your offer
    for your customers. This can be a security problem because ransomware on one side
    could easily propagate to the other. This may also come from the accounting team,
    which does not know which machines and services should be billed to customers
    and which costs should remain internal. It could also come from system management
    difficulties, such as the fact that shutting down a supposedly internal server
    eventually had an impact on your production. In this case, the right approach
    would be to draw the current, unique information system and then to draw the target
    map, which is composed of two distinct information systems and a precise representation
    of the interactions remaining between them (for example, sending the usage data
    from the production information system to the internal information system so that
    accounting can establish billing for the different tenants).
  prefs: []
  type: TYPE_NORMAL
- en: This is typically where you would use the zone for “externally oriented functions”
    of your business capability map (layer 2 of the CIGREF representation). In the
    production information system, you would find in this zone the function for “reporting
    data usage per tenant” or “sending total API calls per tenant”. And in the internal
    information system, you would find, of course, in the “business” zone/“accounting”
    quarter, the function to handle this data and calculate the bill for the tenant.
    Another example would be functions such as “request tenant access blocking” or
    “archive tenant” that you would find in the “externally oriented functions” zone.
    They would typically be called by the internal information system to instruct
    the production information system that a customer has not paid the bill and should
    be at least blocked, and maybe later, completely removed.
  prefs: []
  type: TYPE_NORMAL
- en: Another example of a link between the two systems is, of course, when the internal
    software-production workflow has produced a validated, complete new release of
    the software sold to the customers (this is the main role of the software editing
    company). There has to be a link somewhere since the information system exposing
    this software to customer tenants will use this deliverable to update its services
    at some point. One of the best ways to establish this link while keeping very
    low coupling is to create a container registry that will be filled with images
    coming from the first system (with the right tags, of course) and consumed by
    the second information system by pulling the images it needs to expose in the
    tenants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only remaining question is where the registry should be placed, and the
    answer—if you need a very stable one—is to have one on each side: a registry that
    centralizes all the production from your continuous integration as a software
    editing company on one side and another registry that serves as an image cache
    on the other side. This makes it easier for your continuous deployment as an integrating
    company to keep on creating tenants even if the first registry is not accessible
    anymore. This clean separation can even be used to implement some high-level rules,
    such as “only contained images with the STABLE tag should be put into production”,
    by caching only those in the second Docker registry.'
  prefs: []
  type: TYPE_NORMAL
- en: One might argue that, since there are calls between the two systems in this
    case, that might mean they are a single system and should be represented as so.
    Again, the map is not here to reflect the full reality of the world but to help
    you carry out your duty in information management. If the orientation you wish
    to have is a good separation of concerns (and for security reasons, it should
    be), then your map should represent your goal, as it will help you in doing everything
    that is needed to reach this objective.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, another argument could be opposed to this vision, by stating that,
    today, every information system on the planet has some kind of connection together,
    may it only be by the internet network, that covers almost every local system.
    Also, when companies buy others, they connect their information systems, sometimes
    in such a tightly knitted way that they become a single system in the end. Again,
    this only depends on your strategy, so the CIGREF map should simply be aligned
    with the vision.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and antipatterns of alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several years of consulting on information systems have led me to observe that
    most problems relate to a few misalignments in the system, themselves belonging
    to only a few patterns. Having worked for quite some time in a limited business
    domain, it was a surprise to realize after a few years when I started working
    with agricultural cooperatives, chemical risk analysis companies, lawyers societies,
    and other companies within very different fields, that these patterns (or rather,
    antipatterns since they cause problems) were the same everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Dalila Tamzalit, who is a researcher at French CNRS, took up with me to classify
    these antipatterns and document a method to find them and exploit information
    to better align information systems that suffer from them. This led to an article
    published in the International Conference on Information Systems Development in
    2021 (available at [https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/](https://aisel.aisnet.org/isd2014/proceedings2021/managingdevops/3/)).
    You will find in the next section a summary of some of the information that could
    help in managing business alignment.
  prefs: []
  type: TYPE_NORMAL
- en: The sad reality of alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, it should be known that most information systems, as was explained in
    [*Chapter 1*](B21293_01.xhtml#_idTextAnchor014), suffer from basic problems that
    limit their efficiency. In terms of a four-layer diagram, these problems can be
    summarized as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Common problems](img/B21293_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Common problems
  prefs: []
  type: TYPE_NORMAL
- en: Processes may be well understood, since there is rarely any BCM, but the corresponding
    realization of the processes is often done with point-to-point ad hoc interop
    that quickly brings the system to a “spaghetti dish lookalike” where streams of
    data happen in an uncontrolled way.
  prefs: []
  type: TYPE_NORMAL
- en: What we can aim for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It was already stated, and it may sound logical, but we do not aim for a completely
    aligned system. A well-designed system for two business processes may be as simple
    as the following, where a bit more than ten well-adjusted streams of data implemented
    the full business needs with the same amount of applications (the majority of
    them already exist, in this example, and being simply correctly plugged) and almost
    no additional hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: "![F\uFEFFigure 3.20 – Good alignment (the text is blurred for confidentiality\
    \ reasons)](img/B21293_03_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Good alignment (the text is blurred for confidentiality reasons)
  prefs: []
  type: TYPE_NORMAL
- en: The main antipatterns in alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now the goal is clear, let’s come back to our alignment antipatterns and present
    the main four of them (we only explain what they are, and how they can be fought
    against and reduced will be covered in the rest of the book):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Purely technical integration** happens when a process is not designed in
    the first layer but directly implemented into the software. The consequence is
    that any change in company strategy, domain-based rules, or even simple optimization
    of the process will lead to a change in software. This is the root cause of hearing
    “We do not evolve quickly enough, as we are dragged down by IT” or “It is not
    possible to have this business function due to software limitations” (and its
    variant “adding this new data attribute in the whole software chain, from interface
    to reporting, will take six months and need a new release of four applications”).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The symbolic representation of this antipattern is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Antipattern number 1: Pure Technical Integration](img/B21293_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.21 – Antipattern number 1: Pure Technical Integration'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applicative silos** appear when two parts of the organization have worked
    on their IT needs without talking to each other. The resulting system shows the
    result of this as two independent systems in the diagram. There may be some cases
    where complete isolation is thought to be important (human resources, finance,
    other highly confidential zones), but, from experience, there always comes a time
    when links have to be established between the different zones. This may come as
    a harsh reality in these cases, as data has been completely duplicated, uses different
    formats, or uses technologies that have not been chosen to ease interoperation,
    etc. The main risk in this case is that data sources are simply opened to the
    other area, which will cause major authorization problems. In one of the worst
    cases I have seen, full HR data had been made available to the ERP by a trainee
    to implement the reimbursement of travel fees, which was of course a major breach
    of confidentiality and exposed the company to potential GDPR issues until it was
    corrected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The symbolic representation of this antipattern is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Antipattern number 2: Silos](img/B21293_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.22 – Antipattern number 2: Silos'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monoliths** are applications that concentrate a lot of functions. This in
    itself is not necessarily a problem, as a given application may implement everything
    that is used by a business domain. The problem arises because these applications
    also implement functions that should be shared or already exist in other parts
    of the system. Data duplication is a huge problem in information systems, as they
    never correspond from one side to the other, which makes it hard to know which
    source is the closest to the truth, resulting in bad decisions or false computations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The symbolic representation of this antipattern is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Antipattern number 3: Monolith](img/B21293_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.23 – Antipattern number 3: Monolith'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional multiple implementations** are a problem because the different
    implementations have almost no chance of working in a compatible way. One can
    easily understand that, if a financial budget summary is computed in a given way
    in an application and in a different way in a second application that is supposed
    to do the same thing, it is difficult to take intelligent actions to manage the
    company. One such case I witnessed at a newspaper company showed a different number
    of readers depending on which application was queried, with deltas that were so
    large that, in some situations, the newspaper could not know without additional
    calculation whether they were gaining or losing readers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The symbolic representation of this antipattern is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Antipattern number 4: Functional Multiple Implementations](img/B21293_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.24 – Antipattern number 4: Functional Multiple Implementations'
  prefs: []
  type: TYPE_NORMAL
- en: Some other antipatterns and a proposed classification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Only the four most important antipatterns have been shown, and the whole set
    of **business/IT alignment antipatterns** (**BITA**, in its proposed short form)
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Antipatterns classification](img/B21293_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Antipatterns classification
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this classification to improve alignment in the existing information
    system, each of them comes with a structured identity card with the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – ID card for an antipattern](img/B21293_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – ID card for an antipattern
  prefs: []
  type: TYPE_NORMAL
- en: A full explanation of how the antipatterns appear and—more importantly—the standard
    actions to correct them can also be found in the complete article cited before.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the full article on GitHub, which will show you the amount of
    such information available on the first BITA: [https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Business-IT%20Alignment%20Anti-Patterns%20A%20Thought%20from%20an%20Empirical.pdf](https://github.com/PacktPublishing/Enterprise-Architecture-with-.NET/blob/main/Business-IT%20Alignment%20Anti-Patterns%20A%20Thought%20from%20an%20Empirical.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This taxonomy, coming from experience, has led us to propose a structured way
    to improve information alignment that can be summarized in the following BPMN
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – Proposed method to detect antipatterns in an Information System](img/B21293_03_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – Proposed method to detect antipatterns in an Information System
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to try and apply this method to your information systems of
    study and send feedback. This will be useful to the academic community and hopefully
    for the other readers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This quite long chapter showed how a formalized diagramming technique can be
    used to obtain a better understanding of an information system and also document
    the evolutions it will have to follow. A map is a prerequisite to control a given
    ground, and a schema is worth a thousand words, which makes this step a must in
    any information system architecture activity.
  prefs: []
  type: TYPE_NORMAL
- en: Since IT is quite a specific context, we needed a dedicated way of drawing a
    map of an information system, and this is what the CIGREF map is about. Its four-layer
    arrangement helps separate the business-oriented aspects (processes and atomic
    functions) from the technical aspects (software and hardware).
  prefs: []
  type: TYPE_NORMAL
- en: This way of representing an information system also helps in visualizing its
    alignment, by checking that the third layer (the software bits) is well adjusted
    to the second layer (the business capability map) it implements. The business/IT
    alignment is the most important measure of quality and capacity to evolve for
    complex information systems and a feature that must be sought.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will extend the present one by taking into account the dimension
    of time. We have quickly talked about this in a previous section, explaining that
    the CIGREF map could be used to document the actual state of an information system,
    but also the desired future states it should progressively reach (the Big Bang
    approach is never a practical alternative). But, as you will see, time appears
    in many other aspects of information systems and can be quite a difficult parameter
    to handle.
  prefs: []
  type: TYPE_NORMAL
