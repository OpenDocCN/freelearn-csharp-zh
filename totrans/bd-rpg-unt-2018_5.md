# 游戏大师和游戏机制

在第 1 章到第 4 章中，我们学习了如何制作我们 RPG 设计和实现所需的一些必要组件。例如，你应该对如何组织和安排你的玩家角色和非玩家角色资产和组件有一个很好的理解。

下面是本章内容的概述：

+   游戏大师

    +   管理游戏设置和场景

    +   场景管理

+   完善 GameMaster

    +   级别控制器

    +   音频控制器

+   玩家数据管理

    +   PC 类增强

    +   角色定制类更新

+   UI 控制器的更改

+   测试

在本章中，我们将对迄今为止所做的一切进行更多调整和更新。

# 游戏大师

尽管我们已经创建了 `GameMaster.cs` 脚本，但我们并没有真正利用它来管理我们的游戏。我们创建了一些游戏资产的部分，并使用它们进行快速测试。现在是时候开始考虑如何将所有这些结合起来，为我们的 RPG 创建一个更好的游戏管理器。

我希望 `GameMaster.cs` 执行以下几件事情。具体如下：

+   每个特定场景的 UI 控制器引用

+   在场景中拥有玩家角色的引用

+   在场景中拥有非玩家角色（NPC）的引用

+   拥有音频源的引用以进行控制

+   应始终有一个 `GameMaster` 类的实例可用

在创建我们的 GameMaster 时，我们将根据需要添加或删除一些元素。让我们从将用户界面与 GameMaster 集成开始。

打开主菜单场景。它应该看起来像以下截图：

![](img/00107.jpeg)

以下截图显示了为我们设计的 RPG 主菜单：

![](img/00108.jpeg)

这相当简单，只是为了说明概念。当玩家点击选项按钮时，他们将获得选项窗口，在那里他们可以调整游戏中的音量。完成操作后，他们将点击关闭按钮并返回主菜单。

这是主菜单场景的层次结构窗口截图：

![](img/00109.jpeg)

# 管理游戏设置和音频

创建一个名为 `uiController` 的空 GameObject。我们现在需要创建一个 UI 控制器脚本，该脚本将处理用户交互。创建一个新的 C# 脚本并命名为 `UiController.cs`。

注意：随着我们的进展，本章中的脚本将进行更新和修改。

UI 控制器的列表如下：

[PRE0]

目前，我们只定义了几个函数：`DisplaySettings()` 和 `MainVolume()`。这些函数非常简单；它们引用了用于显示设置面板以及检索音量控制滑块值的 UI 组件。然后，这些信息被传递到 `GameMaster.cs` 脚本以进行进一步处理。

我们需要对 `GameMaster.cs` 脚本进行一些更改。以下是代码列表：

[PRE1]

这段代码需要一点解释。首先要理解的最重要概念是 Singleton 的概念。这是通过首先定义一个静态变量来完成的，该变量将用于保存我们的 `GameMaster` 实例：

[PRE2]

然后，在我们的 `Awake()` 函数中，我们需要以下代码：

[PRE3]

在 `Awake()` 函数中，我们正在检查 `instance` 变量是否已初始化。它将 `instance` 变量初始化一次。接下来的检查确保我们始终只有一个实例。换句话说，如果由于错误而再次实例化 `GameMaster` 对象，它将被销毁。代码的最后一条，`DotDestroyOnLoad()`，将确保当从当前场景移动到下一个场景时，GameObject 不会被销毁。

在 `Start()` 函数中，我们检查 `uiController` 是否存在，如果存在，我们就获取它的引用。一旦我们有了 `uiController` 的引用，我们确保设置面板默认是禁用的，也就是说，是隐藏的。

`MasterVolume()` 函数由 `UIController.cs` 脚本调用，然后传递从定义的滑块中获取的实际音量值来控制背景音乐的音量。

# 管理场景

下一个我想实现的是让 `GameMaster` 控制游戏的不同场景加载。让我们看看 `GameMaster.cs` 将如何看起来，随着场景管理的添加：

[PRE4]

[PRE5]

我们已经讨论了 `Awake()` 函数的作用，现在让我们看看下一个重要的函数，`OnLevelWasLoaded()`。看看以下代码：

[PRE6]

`OnLevelWasLoaded()` 函数是在场景加载后由 Unity 调用的。我们在 `GameMaster` 脚本中使用此函数执行一些任务。我们首先做的事情是获取我们当前所在的场景。这些信息将用于稍后确定 `GameMaster` 将执行什么操作。

我们检查是否处于角色定制场景。这是玩家在开始游戏之前可以定制 PC 的地方。如果我们处于角色定制场景，我们想要获取场景中 `Base` GameObject 的引用。如果你还记得，`Base` GameObject 上附加了 `CharacterCutomization.cs` 脚本，该脚本用于定制角色。

如果我们处于任何其他场景，那么我们想要获取玩家角色的引用，以及场景开始时玩家角色的起始位置（如果有的话）。

然后，我们使用 `DetermineLevel()` 函数来确定我们当前所在的级别，以便进行更多配置。

当前实现用于启动游戏和加载级别的两个函数由 `StartGame()` 函数和 `LoadLevel()` 函数处理。

[PRE7]

`SceneName` 类旨在使在 C# 代码中引用场景名称变得更加容易。这使得在项目中更改实际场景名称变得更容易，但代码中的调用名称保持一致。

到目前为止，一切都很顺利，但我们可以尝试让它变得更好。

# 改进GameMaster

我们目前拥有的代码是可行的，但它并不十分整洁。让我们继续改进代码结构。让我们创建一个新的脚本，命名为`GameLevelController.cs`。这个新的脚本将处理我们的等级管理逻辑。

# 等级控制器

`GameLevelController.cs`的代码列表如下：

[PRE8]

我所做的是基本上将所有处理等级管理的代码移动到了`GameLevelController.cs`文件中。我们的`GameMaster`脚本来驱动LevelController类。我们稍后会看到这一点。

# 音频控制器

下一个代码清理工作是我想要对音频进行的。让我们创建一个新的脚本，命名为`GameAudioController.cs`。新脚本的代码如下：

[PRE9]

代码相当直接。现在，让我们看看`GameMaster.cs`的样子：

[PRE10]

如你所见，代码更容易阅读，并且结构也更好。GameMaster正在使用控制器来执行每个具体任务。这也使得维护我们游戏中不同任务中的代码更容易。例如，所有与音频相关的代码现在可以实现在控制器中，等等。

为了使所有这些工作，你必须确保你已经正确地将你的`uiController`GameObject连接到`UiController.cs`类，以便当用户与选项/设置菜单交互时进行通信，如下面的截图所示：

![图片](img/00110.jpeg)

UI元素事件

你的项目现在应该已经定义了以下标签：

![图片](img/00111.jpeg)

这些在C#代码中用于在运行时识别GameObject。

# 玩家数据管理

我们还没有保存代表玩家定制的数据的实际数据。下一步是增强我们的`PlayerCharacter.cs`和`BarbarianCharacterCustomization.cs`脚本，以便实际上在我们的PC对象中保存所选数据。

# PC类增强

要做到这一点，我们需要修改我们的`PlayerCharacter.cs`代码。新的代码列表如下：

[PRE11]

我们定义了几个枚举类型，用于描述玩家角色定制的不同部分。使用枚举在我们的代码中有几个优点，其中一些是命名常量，名称描述了它们的作用，类型安全，并且更容易更改枚举的值，而无需检查代码中的数百个不同位置。

如前几章所述，角色定制代码与你的角色模型以及你如何为游戏使用角色模型绑定紧密相关。

你需要修改你的UI元素的名称，以匹配新的代码。

看看下面的截图：

![图片](img/00112.jpeg)

连接UI元素事件

为了确保代码能够正常工作，你需要配置一些事情。首先，你需要正确命名你的UI元素，以匹配枚举。前面的截图展示了代表肩垫的一个UI元素。

# 角色定制类更新

驱动角色定制的活动附加到具有 `CharacterCustomization.cs` 脚本组件的 `Base` 预制件上。`CharacterCustomization.cs` 脚本如下所示：

[PRE12]

在列出的代码中，我们所做的是添加了一个名为 `PlayerCharacterData` 的新变量，其类型为 `PlayerCharacter`。`PlayerCharacter` 类是我们定义并增强的玩家角色类，用于包含我们的玩家角色的数据，如下所示：

[PRE13]

我们接下来需要实现的是检测玩家通过角色定制 UI 选择的哪个选项，并适当地设置 `PlayerCharacter` 对象中的数据。请看以下代码：

[PRE14]

对于所有可以定制的玩家角色不同部分，实现概念是相同的。以下是一个例子：

[PRE15]

上述代码是用于定制玩家角色身体类型的。它首先尝试解析并转换由 UI 组件传递给函数的值。接下来，它设置 `PlayerCharacter` 对象中的 `selectedClothing` 变量。如果由于某种原因，传递的值在枚举中不存在，我们将为 `selectedClothing` 变量分配默认值。同时也有调试语句来提供关于当前值的反馈。

# 游戏关卡控制器的更改

游戏关卡控制器现在也需要更新，以便对 `GameMaster` 对象进行必要的更改。我们需要更新 `LoadLevel()` 函数，如下所示：

[PRE16]

这将确保 `GameMaster` 被更新为正确的玩家角色数据。让我们继续测试代码。

# 测试

从 `Main Menu` 场景开始，确保场景中有以下 GameObjects：`uiController` 和 `_GameMaster`。`uiController` GameObject 应该附加 `UiController.cs`，而 `_GameMaster` 应该附加以下组件：`GameMaster.cs` 和一个用于背景音乐的 `AudioSource` 组件。

在层次结构窗口中选择 `_GameMaster` GameObject，并运行游戏。选择开始游戏按钮。这将加载角色定制场景。`_GameMaster` GameObject 应仍然被选中。如果不是，请从层次结构窗口中选择它，进行一些角色定制，然后点击保存按钮。请参考以下截图：

![图片](img/00113.jpeg)

第一级应该已经加载了你在上一步中为角色所做的定制和你的角色。因此，从视觉上看，你的角色保留了你所做的所有定制，从数据角度来看，当你查看检查器窗口中的 `_GameMaster` GameObject 时，你会注意到数据已经正确保存，如前一张截图所示。

# 摘要

本章主要是代码。我们增强了`GameMaster`类以处理游戏设置和场景管理。我们开始本章时让`GameMaster`处理用户界面、玩家角色数据和游戏设置，目前只是背景音乐的音量。

我们添加了一个新的UI元素，用于显示游戏的设置面板。目前，它只包含主音量控制。接下来，我们在`UiController`类和`GameMaster`类中添加了必要的代码，以处理设置窗口的显示，以及从UI组件传递到`UiController`再到`GameMaster`类的滑块值。

我们还将`GameMaster`类设计为单例模式。在软件工程中，单例模式是一种设计模式，它限制一个类的实例只能有一个对象。这种模式非常适合`GameMaster`，因为我们只需要在任何给定时间内游戏生命周期中有一个活跃的实例。

我们还研究了如何执行场景管理。我们定义了一个名为`SceneName`的静态类，其中包含标识我们游戏中场景引用的常量字符串变量。

然后，我们采取下一步改进`GameMaster`和代码内部结构。我们创建了一个新类，称为`GameLevelController.cs`，该类处理场景管理，这反过来又由`GameMaster`驱动。我们实际上从`GameMaster`类中提取了级别处理的逻辑，并在`GameLevelController`类中重新工作并改进了它。

接下来，我们开发了一个`AudioController`类，该类基本上管理我们游戏中的音频。这个类也是由`GameMaster`驱动的。到这时，`GameMaster`已经是一个精简的脚本，负责管理所有其他组件。

接下来的重大挑战是如何处理玩家角色数据。具体来说，如何在玩家定制角色后，内部保存角色定制数据。为了保存数据，我们必须修改`PlayerCharacter.cs`类。

我们创建了几个枚举，代表可以定制的角色各个部分，例如护肩、体型、武器类型、头盔类型等等。我们使用枚举来使它们在代码中更容易引用。

这种方法迫使我们修改了之前实现的现有角色定制设置。我们必须更新UI组件以反映为每个可定制类型定义的枚举，还必须修改`BarbarianCharacterCustomization.cs`类以处理新的更改。

`BarbarianCharacterCustomization`类实现了一个PC类型变量来跟踪定制，并最终将数据传递给`GameMaster`。在这个过程中，我们还改进了`BarbarianCharacterCustomization`类的默认值等案例处理。

最后，我们对游戏进行了测试运行，以确保一切按设计实施的方式正常工作。

在本章中，我们编写了大量的代码。在下一章，我们将开始构建我们的库存系统，是的，这将涉及更多的代码！
