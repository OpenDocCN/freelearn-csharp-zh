- en: Chapter 4. XamChat – a Cross-platform App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to truly learn a programming skill, in my opinion, is to take on
    a simple project that requires you to exercise that skill. This gives new developers
    a project where they can focus on the concepts they are trying to learn without
    the overhead of fixing bugs or following customer requirements. To increase our
    understanding of Xamarin and cross-platform development, let's develop a simple
    app called **XamChat** for iOS and Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Our sample application concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model layer of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking a web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ViewModel layer of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting our sample application concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept is simple: a chat application that uses a standard Internet connection
    as an alternative to send text messages. There are several popular applications
    like this on the Apple App Store, probably due to the cost of text messaging and
    support for devices such as the iPod Touch or iPad. This will be a neat real-world
    example that can be useful for users, and will cover specific topics in developing
    applications for iOS and Android.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start with the development, let''s list the set of screens that we''ll
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Login / sign up**: This screen will include a standard login and sign-up
    process for the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List of conversations**: This screen will include a button to start a new
    conversation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List of friends**: This screen will provide a way to add new friends when
    we start a new conversation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conversation**: This screen will have a list of messages between you and
    another user, and an option to reply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So a quick wireframe layout of the application will help you grasp a better
    understanding of the layout of the app. The following figure shows you the set
    of screens to be included in your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting our sample application concept](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Developing our Model layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have a good idea of what the application is, the next step is to develop
    the business objects, or Model layer, of this application. Let's start by defining
    a few classes that will contain the data to be used throughout the app. It is
    recommended, for the sake of organization, to add these to a `Models` folder in
    your project. This is the bottom layer of the MVVM design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a class that represents a user. The class can be created
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward so far; let''s move on to create classes representing
    a conversation and a message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using strings as identifiers for the various objects. This
    will simplify our integration with Azure Mobile Services in the later chapters.
    `UserId` is the value that will be set by the application to change the user that
    the object is associated with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go ahead and set up our solution by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new solution and a new **Portable Library** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `XamChat.Core` and the solution `XamChat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also choose to use a **Shared Project** for this project, but I chose
    to use a portable class library because it encourages better programming practices
    in general.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing a mock web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times when developing a mobile application, you might need to begin the
    development of your application before the real backend web service is available.
    To prevent the development from halting entirely, a good approach would be to
    develop a mock version of the service. This is also helpful when you need to write
    unit tests, or just need to add a real backend to your app later.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s break down the operations our app will perform against a web
    server. The operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in with a username and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register a new account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the user's list of friends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add friends by their usernames.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a list of the existing conversations for the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a list of messages in a conversation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s define an interface that offers a method for each scenario. The
    method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're simplifying any asynchronous communication with a web
    service by leveraging the **Task Parallel Library** (**TPL**) from the .NET base
    class libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Since communicating with a web service can be a lengthy process, it is always
    a good idea to use the `Task<T>` class for these operations. Otherwise, you can
    inadvertently run a lengthy task on the user interface thread, which will prevent
    user input during the operation. `Task` is definitely needed for web requests,
    since users could be using a cellular Internet connection on iOS and Android,
    and it will give us the ability to use the `async` and `await` keywords down the
    road.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement a fake service that implements this interface. Place classes
    such as `FakeWebService` in the `Fakes` folder of the project. Let''s start with
    the class declaration and the first method of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We started off with a `SleepDuration` property to store a number in milliseconds.
    This is used to simulate an interaction with a web server, which can take some
    time. It is also useful for changing the `SleepDuration` value in different situations.
    For example, you might want to set this to a small number when writing unit tests
    so that the tests execute quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we implemented a simple `Sleep` method to return a task that introduces
    a delay of a number of milliseconds. This method will be used throughout the fake
    service to cause a delay on each operation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Login` method merely used an `await` call on the `Sleep` method
    and returned a `new User` object with the appropriate `Username`. For now, any
    username or password combination will work; however, you might wish to write some
    code here to check specific credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement a few more methods to continue our `FakeWebService` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For each of these methods, we used exactly the same pattern as the `Login` method.
    Each method will delay and return some sample data. Feel free to mix the data
    with your own values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `GetConversations` method required by the interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we just create a new array of the `Conversation` objects with arbitrary
    IDs. We also make sure to match up the `UserId` values with the IDs we have used
    on the `User` objects so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s implement `GetMessages` to retrieve a list of messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we are adding some arbitrary data here, and mainly making sure that
    `UserId` and `ConversationId` match our existing data so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we will write one more method to send a message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Most of these methods are very straightforward. Note that the service doesn't
    have to work perfectly; it should merely complete each operation successfully
    with a delay. Each method should also return test data of some kind to be displayed
    in the UI. This will give us the ability to implement our iOS and Android applications
    while filling in the web service later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to implement a simple interface for persisting application settings.
    Let''s define an interface named `ISettings` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are making `ISettings` synchronous, but you might want to set up the `Save`
    method to be asynchronous and return `Task` if you plan on storing settings in
    the cloud. We don't really need this with our application since we will only be
    saving our settings locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later on, we''ll implement this interface on each platform using Android and
    iOS APIs. For now, let''s just implement a fake version that will be used later
    when we write unit tests. We will implement the interface with the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the fake version doesn't actually need to do anything; we just need
    to provide a class that will implement the interface and not throw any unexpected
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes the Model layer of the application. Here is a final class diagram
    of what we have implemented so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a mock web service](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Writing the ViewModel layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseViewModel` class is a great place to place any common functionality
    that you plan on reusing throughout your application. For this app, we only need
    to implement some functionality to indicate whether the ViewModel layer is busy.
    We provided a property and an event that the UI will be able to subscribe to and
    display a wait indicator on the screen. We also added some fields for the services
    that will be needed. Another common functionality that could be added would be
    validation for user inputs; however, we don't really need it for this application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our LoginViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a base class for all of the ViewModel layers, we can implement
    a ViewModel layer for the first screen in our application, the **Login** screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement a `LoginViewModel` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, we implemented the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We subclassed `BaseViewModel` to get access to `IsBusy` and the fields that
    contain common services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added the `Username` and `Password` properties to be set by the View layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `User` property to be set when the login process is completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We implemented a `Login` method to be called from View, with validation on the
    `Username` and `Password` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `IsBusy` during the call to the `Login` method on `IWebService`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the `User` property by awaiting the result from `Login` on the web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basically, this is the pattern that we'll follow for the rest of the ViewModel
    layers in the application. We provide properties for the View layer to be set
    by the user's input, and methods to call for various operations. If it is a method
    that could take some time, such as a web request, you should always return `Task`
    and use the `async` and `await` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we used `try` and `finally` blocks for setting `IsBusy` back to `false`.
    This will ensure that it gets reset properly even when an exception is thrown.
    We plan on handling the error in the View layer so that we can display a native
    pop up to the user displaying a message.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our RegisterViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have finished writing our `ViewModel` class to log in, we will now
    need to create one for the user's registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement another ViewModel layer to register a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These properties will handle inputs from the user. Next, we need to add a `Register`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `RegisterViewModel` class is very similar to the `LoginViewModel` class,
    but has an additional `ConfirmPassword` property for the UI to be set. A good
    rule to follow for when to split the ViewModel layer's functionality is to always
    create a new class when the UI has a new screen. This helps you keep your code
    clean and somewhat follow the **Single Responsibility Principal (SRP)** for your
    classes. The **SRP** states that a class should only have a single purpose or
    responsibility. We'll try to follow this concept to keep our classes small and
    organized, which can be more important than usual when sharing code across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our FriendViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next on the list is a ViewModel layer to work with a user's friend list. We
    will need a method to load a user's friend list and add a new friend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement the `FriendViewModel` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll need a method to load friends. This method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll need a method to add a new friend and then update the list
    of friends contained locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, this class is fairly straightforward. The only thing new here is that
    we added some logic to update the list of friends and sort them within our client
    application and not the server. You can also choose to reload the complete list
    of friends if you have a good reason to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our MessageViewModel class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final required ViewModel layer will handle messages and conversations. We
    need to create a way to load conversations and messages and send a new message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start implementing our `MessageViewModel` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s implement a method to retrieve a list of conversations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we need to retrieve a list of messages within a conversation. We
    will need to pass the conversation ID to the service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to write some code to send a message and update the local
    list of messages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the ViewModel layer of our application and the entirety of the
    shared code used on iOS and Android. For the `MessageViewModel` class, you could
    have also chosen to put the `GetConversations` and `Conversations` properties
    in their own class, since they can be considered as a separate responsibility,
    but it is not really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the final class diagram of our ViewModel layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing our MessageViewModel class](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since all the code we've written so far is not dependent on the user interface,
    we can easily write unit tests against our classes. This step is generally taken
    after the first implementation of a `ViewModel` class. Proponents of **Test Driven
    Development** (**TDD**) would recommend writing tests first and implementing things
    afterward, so choose which method is best for you. In either case, it is a good
    idea to write tests against your shared code before you start using them from
    the View layer, so that you can catch bugs before they hold up your development
    on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin projects take advantage of an open source testing framework called **NUnit**.
    It was originally derived from a Java testing framework called **JUnit**, and
    it is the de-facto standard for unit testing C# applications. Xamarin Studio provides
    several project templates for writing tests with **NUnit**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new project for unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s set up a new project for unit tests by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new **NUnit Library** **Project** to your solution, which is found under
    the **C#** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `XamChat.Tests` to keep things consistent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let's set the library to a Mono/.NET 4.5 project under **Project Options**,
    then navigate to **Build** | **General** | **Target Framework**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on **Project References** and choose **Edit References**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Projects** tab, add a reference to **XamChat.Core**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `Test.cs` file and you will notice the following required attributes
    that make up a unit test using NUnit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`using NUnit.Framework`: This attribute is the main statement to be used to
    work with NUnit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[TestFixture]`: This decorates a class to indicate that the class has a list
    of methods for running tests'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Test]`: This decorates a method to indicate a test'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the required C# attributes, there are several others that are
    useful for writing tests, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[TestFixtureSetUp]`: This decorates a method that runs before all the tests
    contained within a text fixture class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[SetUp]`: This decorates a method that runs before each test in a test fixture
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[TearDown]`: This decorates a method that runs after each test in a test fixture
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[TestFixtureTearDown]`: This decorates a method that runs after all the tests
    in a text fixture class have been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ExpectedException]`: This decorates a method that is intended to throw an
    exception. It is useful for test cases that are supposed to fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[Category]`: This decorates a test method and can be used to organize different
    tests; for example, you might categorize them as fast and slow tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next concept to learn about writing tests with NUnit is how to write **assertions**.
    An assertion is a method that will throw an exception if a certain value is not
    true. It will cause a test to fail and give a descriptive explanation as to what
    happened. NUnit has a couple of different sets of APIs for assertions; however,
    we will use the more readable and fluent versions of the APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of a fluent-style API is using the `Assert.That` method. The
    following example this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, you can assert the opposite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Or any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Assert.That(myVariable, Is.GreaterThan(0));`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.That(myBooleanVariable, Is.True);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.That(myObject, Is.Not.Null);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to explore the APIs. With code completion in Xamarin Studio, you should
    be able to discover useful static members or methods on the `Is` class to use
    within your tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin writing specific tests for our application, let''s write a
    static class and method to create a global setup to be used throughout our tests.
    You can rewrite `Test.cs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We'll use this method throughout our tests to set up fake services in our Model
    layer. Additionally, this replaces the existing services so that our tests execute
    against new instances of these classes. This is a good practice in unit testing
    to guarantee that no old data is left behind from a previous test. Also, notice
    that we set `SleepDuration` to `0`. This will make our tests run very quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a `ViewModels` folder in our test project and adding
    a class named `LoginViewModelTests` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice our use of a `SetUp` method. We recreate the objects used in every test
    to make sure that no old data is left over from the previous test runs. Another
    point to note is that you must return a `Task` when using `async`/`await` in a
    test method. Otherwise, NUnit would not be able to know when a test completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, use the NUnit menu found docked to the right of Xamarin Studio,
    by default. Go ahead and run the test using the **Run Test** button that has a
    gear icon. You will get a successful result similar to what is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing assertions](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also view the **Test Results** pane, which will show you the extended
    details if a test fails, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing assertions](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see what happens when a test fails, go ahead and modify your test to assert
    against an incorrect value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get a very descriptive error in the **Test Results** pane, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing assertions](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s implement another test for the `LoginViewModel` class; let''s make
    sure that we get the appropriate outcome if the username and password fields are
    blank. The test is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the test as it is, we will get an exception and the test will fail.
    Since we expect an exception to occur, we can decorate the method to make the
    test pass only if an exception occurs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in our ViewModel, the Exception type is thrown if a field is blank.
    You can also change the type of expected exception in cases where it is a different
    exception type.
  prefs: []
  type: TYPE_NORMAL
- en: More tests are included with the sample code along with this book. It is recommended
    that you write tests against each public operation on each `ViewModel` class.
    Additionally, write tests for any validation or other important business logic.
    I would also recommend that you write tests against the Model layer; however,
    this is not needed in our project yet since we only have fake implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the concept of building a sample application
    called XamChat. We also implemented the core business objects for the application
    in the Model layer. Since we do not have a server to support this application
    yet, we implemented a fake web service. This gives you the flexibility to move
    forward with the app without building a server application. We also implemented
    the ViewModel layer. This layer will expose operations in a simple way to the
    View layer. Finally, we wrote tests covering the code we've written so far using
    NUnit. Writing tests against shared code in a cross-platform application can be
    very important, as it is the backbone of more than one application.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you should have completed the shared library
    for our cross-platform application in its entirety. You should have a very firm
    grasp on our application's architecture and its distinct Model and ViewModel layers.
    You should also have a good understanding of how to write fake versions of parts
    of your application that you might not be ready to implement yet. In the next
    chapter, we will implement the iOS version of XamChat.
  prefs: []
  type: TYPE_NORMAL
