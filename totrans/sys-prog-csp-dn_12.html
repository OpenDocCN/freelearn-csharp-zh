<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-259"><a id="_idTextAnchor260"/>12</h1>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor261"/>The One with the Security Safeguards</h1>
			<p><em class="italic">Security essentials for </em><em class="italic">systems programming</em></p>
			<p>Security is<a id="_idIndexMarker980"/> more critical these days than ever. Software never stands alone; it always works with hardware and other software packages. Attackers do whatever they can to find the weakest link in the chain. As developers, we must ensure our software is not the weakest link.</p>
			<p>Security is not a “thing” but a mindset and a process. It is a never-ending quest to find the best solution, keeping in mind maintainability and useability. As system programmers, we have to trade off security against performance and memory usage.</p>
			<p>This makes building secure software a challenge. But let’s be honest – isn’t that sort of challenge the reason we chose this profession?</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Why do we need to care about security as system programmers?</li>
				<li>How to work with strings securely</li>
				<li>How to handle keys in your systems</li>
				<li>What are the requirements around credentials and privileges?</li>
				<li>How do you transfer data safely across a network?</li>
			</ul>
			<p>Security is an important but complicated topic. I will not cover everything there is to say about security. Still, as a system programmer, I will touch upon the most important things you should know. But let’s not talk too loudly – we must keep our secrets to ourselves! So, make sure nobody is listening in, and then follow me.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor262"/>Technical requirements</h1>
			<p>You will find all the code in this chapter at this URL: <a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter12</a>.</p>
			<p>If you want to follow along when I discuss Azure Key Vault, you need a subscription to Azure. You can create one here: <a href="https://azure.microsoft.com/en-us/free">https://azure.microsoft.com/en-us/free</a>.</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor263"/>Security for system programmers</h1>
			<p>When I <a id="_idIndexMarker981"/>started programming, security was not an issue. Imagine this – my computer had one connection, the one to the power outlet on the wall. And, of course, the computer was attached to a television to display whatever it needed to show. Yes, a TV. I did not have a monitor; I could not afford one back then. I started the machine up, and it would load the OS and the basic programming environment from ROM. And that was it. This setup was extremely secure – there were no attachments to anything that could interfere with my machine and data. I kept the computer in my bedroom, so physical security was also taken care of (no one goes into a teenager’s bedroom voluntarily; the mess was unbelievable).</p>
			<p>Fast-forward to today. My desktop computer is always on and always connected to the internet. Some systems I have written run on a virtual machine with a cloud provider; others are serverless and waiting for connections.</p>
			<p>My firewalls and application gateways inform me that other systems constantly try to connect to all those environments and machines. I have the feeling that all of those machines are under constant threat.</p>
			<p>Security is something everybody in the software industry needs to be aware of all the time. Only adding security measures at the end of the development cycle is the best way to ensure attackers have access to your system. You are bound to forget something. Security must be considered at every step, from the initial design to maintaining a running system.</p>
			<p>As I said in the second paragraph of this chapter, security is a mindset. You need to ask yourself continuously, “Can someone take advantage of the things I am doing?”</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor264"/>What could happen if we have a vulnerability?</h2>
			<p>I can<a id="_idIndexMarker982"/> almost hear you say, “Hey, I write low-level code, not some fancy customer-facing website. Why should I be bothered with all this?” That is a reasonable response, but there are ways you, as a system programmer, should be very aware of the risks. If you aren’t, the results could be catastrophic. Let me outline some of the things that could happen:</p>
			<ul>
				<li><strong class="bold">Privilege escalation</strong>: A lot of the code we write runs with elevated privileges. Hackers who exploit a vulnerability can escalate their privilege from regular users to administrators, giving them extensive control over a system.</li>
				<li><strong class="bold">Data theft</strong>: Hackers who gain access to your system can use that to steal sensitive information, such as the following:<ul><li>User data, such as personal information and credit card information</li><li>Confidential business data, including trade secrets, intellectual property, and internal communications</li><li>System logs and configurations that might contain information about other systems, so they can be targeted as well</li></ul></li>
				<li><strong class="bold">Code injection</strong>: Hackers might exploit vulnerabilities such as buffer overflows or inadequate input validation to inject malicious code into a process. This action might enable them to do the following:<ul><li><strong class="bold">Execute arbitrary commands</strong>: They can run any code, potentially installing malware, ransomware, or other malicious software</li><li><strong class="bold">Alter system behavior</strong>: Change how a system behaves, causing instability or hiding their activities</li></ul></li>
				<li><strong class="bold">Denial of service or distributed denial of service</strong>: Attackers can disrupt the normal operation of a system by doing the following:<ul><li><strong class="bold">Overloading a process</strong>: Sending excessive requests or data, causing a system to crash or become unresponsive.</li><li><strong class="bold">Resource exhaustion</strong>. Consuming system resources such as CPU, memory, or disk space, leading to performance degradation or system crashes</li></ul></li>
				<li><strong class="bold">Backdoors and persistent access</strong>: Once they have control over a background <a id="_idIndexMarker983"/>process, hackers can do the following:<ul><li><strong class="bold">Install backdoors</strong>: Create hidden entry points to re-access a system even if the initial vulnerability is patched</li><li><strong class="bold">Establish persistence</strong>: Modify a process to restart or maintain their presence on the system, even after a reboot or restart</li></ul></li>
				<li><strong class="bold">Spying and surveillance</strong>: Hackers can use compromised systems to monitor and collect data over an extended period:<ul><li><strong class="bold">Keystroke logging</strong>: Capture what users type, potentially stealing passwords and other sensitive information</li><li><strong class="bold">Screen capture</strong>: Periodically take screenshots to monitor users’ activity</li><li><strong class="bold">Network traffic monitoring</strong>: Capture data being sent to and received from other systems</li></ul></li>
				<li><strong class="bold">Spreading malware</strong>: A compromised system can be used as a launchpad for further attacks:<ul><li><strong class="bold">Lateral movement</strong>: Use a compromised system to move to other systems within a network</li><li><strong class="bold">Propagation</strong>: Spread malware to other devices or processes, creating a larger attack surface</li></ul></li>
				<li><strong class="bold">Manipulating data</strong>: Hackers can alter data processed by a background process:<ul><li><strong class="bold">Data corruption</strong>: Introduce errors or malicious modifications to data</li><li><strong class="bold">Tampering with logs</strong>: Modifying or deleting log entries to cover their tracks makes detecting a breach harder.</li></ul></li>
			</ul>
			<p>As you can see, there <a id="_idIndexMarker984"/>are a lot of things that can go wrong if we leave our systems vulnerable. To hammer the point home, imagine a background process that monitors a serial port and handles data from an external device. That process runs 24/7, and since it deals with the lower-level Win32, we run it as an administrator. But we made a mistake somewhere, and a hacker accessed our process. The following is a potential scenario that might happen:</p>
			<ol>
				<li><strong class="bold">Exploiting the vulnerability</strong>: The hacker finds and exploits a buffer overflow vulnerability in the process.</li>
				<li><strong class="bold">Privilege escalation</strong>: They escalate their privilege to gain administrative rights.</li>
				<li><strong class="bold">Data theft</strong>: They extract the entire database of user credentials and personal information.</li>
				<li><strong class="bold">Installing a backdoor</strong>: They install a backdoor to maintain access and monitor user activities.</li>
				<li><strong class="bold">Data manipulation</strong>: They alter account balances and change bank information for accounts payable.</li>
				<li><strong class="bold">Disruption</strong>: Finally, they launch a DDOS attack, bringing your whole company down.</li>
			</ol>
			<p>If you think this is exaggerated, I suggest you go online and find articles about security hacks. If you look hard enough, you will find many examples. Most companies are reluctant to share their experiences, but the data is there.</p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor265"/>How to protect yourself</h2>
			<p>If I have<a id="_idIndexMarker985"/> scared you a little bit, good. It can be scary. But do not worry too much – following some good security practices can avert many of these risks. In fact, the rest of this chapter is all about what you, as a developer, should do to protect your systems. However, besides the coding aspect of security, there are several other things you should be doing:</p>
			<ul>
				<li><strong class="bold">Holding regular security audits</strong>: Continuously review and audit your code and systems for vulnerabilities. I really would suggest hiring an external party for this. They have a lot more experience, and they are not likely to have the same blind spots as the people who developed the systems.</li>
				<li><strong class="bold">Input validation</strong>: Ensure all inputs are properly validated and sanitized. Just do not trust anything coming in from an external source.</li>
				<li><strong class="bold">Least privilege principle</strong>: Run processes with the minimum necessary privileges to limit potential damages.</li>
				<li><strong class="bold">User modern security practices</strong>: Employ encryption, secure coding practices, and up-to-date third-party libraries.</li>
				<li><strong class="bold">Monitoring and logging activities</strong>: Keep detailed logs and monitor for suspicious activities to quickly detect and respond to breaches.</li>
			</ul>
			<p>So, now you <a id="_idIndexMarker986"/>know why security is important. Now, let’s investigate how to do that in our code.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor266"/>Working with strings</h1>
			<p>Your <a id="_idIndexMarker987"/>application likely has <strong class="bold">strings</strong>. Most of them are irrelevant to the outside world; if you write “Hello World” to a console, an attacker probably couldn’t care less about that. But other strings are a lot more interesting to these people. Consider connection strings to a database, for instance. They can be an excellent resource for a hacker. Then, there are other data, such as user information, passwords, and credit card information.</p>
			<p>We can distinguish between two types of strings:</p>
			<ul>
				<li>Strings that are part of your code and thus are compiled in the binaries</li>
				<li>Strings that are handled in your code and originate from an outside process or go to an outside process</li>
			</ul>
			<p>Let’s see whether we can protect this sensitive data.</p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor267"/>Protecting settings</h2>
			<p>First, we <a id="_idIndexMarker988"/>deal with the strings in your application that are part of your code base. Think of things such as passwords and connection strings. In an ideal world, you store this information in an external file. The reason for this is that by not having them in your source code, you can change them without recompiling your code.</p>
			<p>Imagine that a breach has been detected somewhere in your organization. The security department tells everybody to update their passwords. In your case, that would mean opening Visual Studio, loading the solution, changing the password to the database server, recompiling, and finally, redeploying the system. Or, on second thought, you could just change the password in the config file. I know what I would prefer to do!</p>
			<p>Still, having a password in a config file is a pretty bad idea. If you have the password as part of your code, an attacker must decompile your assembly to find it. If we store the password in a text file, all the attacker has to do is open that file and read the password. To counter that, we encrypt the password.</p>
			<p>We have discussed encryption several times before, so I am sure you can figure out how to do this. But all the techniques we have looked at so far require a password to be part of the source code, and we just determined that that is a bad idea. Storing a password in a config file to enable decrypting the rest of the file sounds even worse. There must be a better way. There is.</p>
			<p>Let’s investigate this.</p>
			<p>I have a sample application that has some sensitive information. I have this information in a file called <code>appsettings.json</code>. You know – a typical .NET-based configuration file. It looks like this:</p>
			<pre class="source-code">
{
  "MyPublicSettings": {
    "Setting1": "Value1",
    "Setting2": "Value2",
    "Setting3": "Value3"
  },
  "MySecretSettings": {
    "MySecretSetting1": "SecretValue1",
    "MySecretSetting2": "SecretValue2"
  }
}</pre>			<p>We <a id="_idIndexMarker989"/>have two sections – insensitive data and data we do not want others to read. We need to protect the latter. Now, the way we handle this is a bit inconvenient. We must write a separate program to encrypt the data before writing the code that uses this file.</p>
			<p>Start a<a id="_idIndexMarker990"/> new <strong class="bold">console application</strong> and add the following NuGet packages:</p>
			<p><code>Microsoft.Extensions.Configuration</code></p>
			<p><code>Microsoft.Extensions.Configuration.FileExtensions</code></p>
			<p><code>Microsoft.Extensions.Configuration.Json</code></p>
			<p><code>Microsoft.Extensions.DependencyInjection</code></p>
			<p><code>Microsoft.AspNetCore.DataProtection</code></p>
			<p>These packages are needed to read and use configuration files, and <code>Microsoft.AspNetCore.DataProtection</code> is there to protect our data.</p>
			<p>To begin, we have to set up the dependency injection infrastructure. The data protection tools use this; they require packages to be injected when required. So, the first lines of our code look like this:</p>
			<pre class="source-code">
var serviceCollection = new ServiceCollection();
serviceCollection.AddDataProtection();
var serviceProvider = serviceCollection.BuildServiceProvider();
var dataProtector = serviceProvider.GetDataProtector("MySecureData");</pre>			<p>We first create a <code>ServiceCollection</code> instance. Then, we call <code>AddDataProtection()</code> to that collection so that all required packages are loaded and ready to use. After getting <code>serviceProvider</code>, we get an instance of an <code>IDataProtector</code> interface by calling <code>GetDataProtector()</code>. This method expects a parameter – a string describing the purpose. This string can be anything you want; it acts as a label so that you can group items. Think of it as labeling your encrypted data so<a id="_idIndexMarker991"/> that you can later track what belongs to what.</p>
			<p>Then, we read the config file into the configuration infrastructure:</p>
			<pre class="source-code">
var configuration = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile("appsettings.json")
    .Build();</pre>			<p>Do not forget to mark your <code>appsettings.json</code> file as <code>Copy when newer</code> in Solution Explorer; otherwise, your code will not load it.</p>
			<p>OK, now for the funny part – we reread the configuration file, but this time as text. We do this because we will replace the sensitive strings with encrypted versions. This is the code to read it:</p>
			<pre class="source-code">
var json = File.ReadAllText("appsettings.json");</pre>			<p>The <code>json</code> string now holds our complete settings file. It’s time to start encrypting!</p>
			<p>First, we read the section we want to protect, iterate through all the items in that section, encrypt the values, and then change the strings in the <code>json</code> variable. Finally, we write the new string to the configuration file. This is what that looks like:</p>
			<pre class="source-code">
var secretSection = configuration.GetSection("MySecretSettings");
foreach (var key in secretSection.GetChildren())
{
    var originalValue = key.Value;
    var encryptedValue = dataProtector.Protect(originalValue);
    var oldValue = $"\"{key.Key}\": \"{originalValue}\"";
    var newValue = $"\"{key.Key}\": \"{encryptedValue}\"";
    json = json.Replace(oldValue, newValue);
}
File.WriteAllText("appsettings.json", json);</pre>			<p>The <a id="_idIndexMarker992"/>call to <code>dataProtector.Protect()</code> does all the hard work for us. It takes a string and encrypts it. We replace the old value with the new one and write it in the file.</p>
			<p>If you open the <code>appsettings.json</code> file (the one in the folder with the debug build, not the original one!), you will see that the secret strings are not human-readable anymore. So, anyone opening that file will not have access to our secrets!</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor268"/>Reading encrypted data</h2>
			<p>In an <a id="_idIndexMarker993"/>application where you intend to use secret strings, you can simply read the data from the configuration file and decrypt them. That goes like this:</p>
			<pre class="source-code">
configuration.Reload();
var encryptedSection = configuration.GetSection("MySecretSettings");
var someSecretValue = encryptedSection["MySecretSetting1"];
var decryptedValue = dataProtector.Unprotect(someSecretValue);
$"Encrypted value was: {someSecretValue}\nDecrypted this becomes: {decryptedValue}".Dump();</pre>			<p>First, I reload the configuration to ensure the object has the encrypted strings. Then, I get the section and read the first setting and its value. Finally, I use <code>dataProtector</code> to decrypt the string. The result is a lovely, unencrypted, readable string.</p>
			<p>Of course, you should not do encryption and decryption in production systems using the same program. You need to split them up. When you do, remember to use the same string for the purpose. If you do not do that, you will get an exception telling you that the decryption did not work. Try this:</p>
			<pre class="source-code">
var secondProtector = serviceProvider.GetDataProtector("AnotherSection");
var decryptedValue = secondProtector.Unprotect(someSecretValue);</pre>			<p>I call <code>GetDataProtector()</code> with a new purpose string, and I use that to unprotect the string. That <a id="_idIndexMarker994"/>will not work. If I use <code>"MySecureString"</code> instead of <code>"AnotherSection"</code>, it works again, even though I have a new <code>DataProtector</code>.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor269"/>Where are the keys?</h2>
			<p>You may<a id="_idIndexMarker995"/> wonder why I never specified a password to encrypt and decrypt. The answer is that the framework generates one for me. It is more or less hidden in the <code>"%LocalAppData%\ASP.NET\DataProtection-Keys"</code> folder. This special folder is where the runtime stores and reads the keys. Open that folder, pick one of the XML files, and open it to see what it contains.</p>
			<p>You can specify another folder where the system stores the keys. Change the start of the program, where we call <code>AddDataProtection()</code> to add the data protection classes to <code>serviceCollection</code>, to look like this:</p>
			<pre class="source-code">
serviceCollection
    .AddDataProtection()
    .PersistKeysToFileSystem(new DirectoryInfo(myKeyFolder));</pre>			<p>This line of code tells the system to use the folder specified in <code>myKeyFolder</code> to store the keys.</p>
			<p>In a production system, you can distribute the key file and store it in a known location. Of course, any attacker with access to your <code>appsettings.json</code> file probably has no problem finding the key file. There must be better ways to deal with this. And there are, but I will deal with that in the next part. First, I want to talk about the strings that are in memory. Those can be hardcoded strings in your code or decrypted strings from your settings file. Are those a potential security risk? Let’s find out!</p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor270"/>Handling strings in memory</h2>
			<p>You might<a id="_idIndexMarker996"/> think encrypted strings in a configuration file are safe. After all, nobody can read them. Only your program can access them, provided it can access the key file. The program can read and decrypt the settings in memory, making everything safe and secure. Unfortunately, that is not the case. Finding that kind of information in a running program is not hard.</p>
			<h3>Disclosing strings in your application</h3>
			<p>Let’s<a id="_idIndexMarker997"/> assume we have the following code:</p>
			<pre class="source-code">
var myOpenString = "This is my Open String";
Console.ReadLine();</pre>			<p>I agree. This isn’t the most exciting piece of code you have ever seen, but it does what it needs to do. It loads a string in memory and then waits for the user to press a key to abort the program.</p>
			<p>Suppose I compile this in <a id="_idIndexMarker998"/>release mode and start the handy <strong class="bold">WinDbg</strong> tool (you can install that by going to the Microsoft Store and searching for it). In that case, I can do all sorts of inspections on a running program. With some digging around, I finally found this result:</p>
			<pre class="source-code">
Name:        System.String
MethodTable: 00007ffaf832ec08
EEClass:     00007ffaf830a500
Tracked Type: false
Size:        66(0x42) bytes
File:        C:\Program Files\dotnet\shared\Microsoft.NETCore.App\8.0.5\System.Private.CoreLib.dll
String:      This is my Open String
Fields:
              MT    Field   Offset                 Type VT
Attr            Value Name
00007ffaf82b1188  400033b        8         System.Int32  1 instance               22 _stringLength
00007ffaf82bb538  400033c        c          System.Char  1 instance               54 _firstChar
00007ffaf832ec08  400033a       c8        System.String  0   static 000001ee80000008 Empty</pre>			<p>WinDbg gives <a id="_idIndexMarker999"/>me all sorts of information about the <code>System.String</code> object found at a specific memory location. Part of that information is the contents of that string – <code>"This is my </code><code>Open String"</code>.</p>
			<p>My sample program is straightforward, so finding the information wasn’t hard. But the fact that I can actually do this by just attaching it to a running program shows you what a hacker can do. If your program takes encrypted data from an <code>appsettings.json</code> file and keeps that string in memory, you might as well not encrypt your data at all.</p>
			<p>There must be a better way.  And guess what – there is!</p>
			<h3>Using SecureStrings</h3>
			<p>We’ve <a id="_idIndexMarker1000"/>discovered that strings in memory are not secure. The people behind the BCL thought of this as well and gave us an alternative – <code>SecureString</code>.</p>
			<p>That sounds like a <a id="_idIndexMarker1001"/>beautiful idea, but <code>SecureString</code> is less convenient than a “real” string. Not by far. However, it does have one advantage – the data in it is encrypted.</p>
			<p>Creating <code>SecureString</code> is easy enough:</p>
			<pre class="source-code">
using var secureString = new SecureString();</pre>			<p>But that doesn’t really help us. We want some data in it. That’s not hard, but you must copy the data one character at a time:</p>
			<pre class="source-code">
var sourceString = "This is a big secret";
foreach (var c in sourceString)
{
    secureString.AppendChar(c);
}
secureString.MakeReadOnly();</pre>			<p>Now, <code>secureString</code> contains some data. The nice thing is that the data is encrypted and not <a id="_idIndexMarker1002"/>readable anymore. The call to <code>MakeReadOnly()</code> is important. By making it read-only, you ensure that the string is not changeable anymore, which helps in performance.</p>
			<p><code>SecureString</code> is <a id="_idIndexMarker1003"/>mainly used to store passwords. A lot of classes in the BCL that need passwords accept <code>SecureString</code> as their parameter. For instance, these are some of the classes that can work with <code>SecureString</code> instances:</p>
			<ul>
				<li><code>ProcessStartInfo</code>: When starting a new process, you can provide a password as <code>SecureString</code> using the <code>ProcessStartInfo</code> struct, or by calling an overload of <code>Process.Start()</code> that accepts <code>SecureString</code>.</li>
				<li><code>NetworkCredential</code>: When you need to identify a resource with a network resource, you can use <code>NetworkCredential</code> to pass along the required parameters, such as the username, password, and domain. The password can be an instance of the <code>SecureString</code> class.</li>
				<li><code>CspParameters</code> and <code>X509Certificate</code>: These are important if you are dealing with certificates, and they also allow <code>SecureString</code> instances.</li>
			</ul>
			<p>So, now we have a secure string. Great. But we still have an issue. Can you spot it? I will give you a minute while you look at the code that we last discussed.</p>
			<p>The problem, of course, is where we seed the secure string. We create a string in memory with the <code>"This is a big secret"</code> contents and transfer it to the secure string. But the original string is still in memory.</p>
			<p>We would have had the same issue if we had read an encrypted string from a configuration file, decrypted it, and copied it to the secure string. The original, decrypted string is still in memory and can be read externally.</p>
			<p>The only way to circumvent it is to erase that provisional string as soon as you finish it. The unencrypted strings should be in memory for as long as possible. Technically, it is still vulnerable, but the attacker has to break the running application exactly when the strings are in memory. The attack window is still there, but it is very, very small.</p>
			<p>Erasing a <a id="_idIndexMarker1004"/>string is not the same as assigning a new value – strings are<a id="_idIndexMarker1005"/> immutable. When you try to change the string, you get a new instance, and the old data is still readable. The only way to completely eradicate it from memory is to erase the chars that form the string. You can erase a string from memory with something similar to this code:</p>
			<pre class="source-code">
void OverwriteAndClearString(ref string str)
{
    if (str == null) return;
    unsafe
    {
        fixed (char* ptr = str)
        {
            for (int i = 0; i &lt; str.Length; i++)
            {
                ptr[i] = '\0'; // Overwrite with null characters
            }
        }
    }
    str = null; // Dereference the string
}</pre>			<p>You have to set the <code>'0'</code>. Since <code>0</code> denotes the end of the string, it is harder to see the original length of the string.</p>
			<p>I am not saying you need to call this method for every string. But suppose you are dealing with strings that you absolutely do not want to leak. In that case, this might solve the intermediate problem of copying data to a secure string.</p>
			<p>But where <a id="_idIndexMarker1006"/>do we get the decryption keys from? We can distribute <a id="_idIndexMarker1007"/>them as shown previously, but there are other ways. Let’s discuss those! However, before doing that, let’s think about what we have learned. This was a complicated topic; dealing with strings in memory is not something many C# developers think about. But therein lies the problem – since people do not think about it, they are unaware of any risks.</p>
			<p>Conversely, you now know about the risks and are ready to deal with them if you encounter the need for this level of security.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor271"/>Using key management</h1>
			<p>Keys are the <a id="_idIndexMarker1008"/>best-kept secrets of your application. Keys are used to encrypt and decrypt a lot of sensitive data. This means the keys themselves are even more sensitive; they hold the power to unlock all your secrets. Storing a key in a text file next to an executable might not be the best way to treat this valuable piece of data.</p>
			<p>How and where you store the keys depends on where you run your program. If your application lives in the cloud, you should use a cloud-based key management system. If you run your systems on a machine you can touch, you need another solution.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor272"/>Using the Azure Key Vault</h2>
			<p>The <strong class="bold">Azure Key Vault</strong> is a<a id="_idIndexMarker1009"/> centralized, cloud-based secret and key management solution. It is straightforward to set up and easy to use. Its main<a id="_idIndexMarker1010"/> purpose is to guard secrets and keys for Azure-based applications. However, it can also be used by applications running on-premise.</p>
			<p>I will not teach you how to create a key vault here; plenty of resources can help you. For instance, this is a good resource from Microsoft itself: <a href="https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal">https://learn.microsoft.com/en-us/azure/key-vault/general/quick-create-portal</a>.</p>
			<p>Once you have a key vault deployed and have added a secret, retrieving that secret is simple. But before we look at the code to get that secret, we must ensure access to the resource. That <a id="_idIndexMarker1011"/>means we make notes of the following items:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-11">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Item name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Key vault name</p>
						</td>
						<td class="No-Table-Style">
							<p><code>mykeyvault</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of the key vault you specified when you created it</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Secret name</p>
						</td>
						<td class="No-Table-Style">
							<p><code>MySecretValue</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of the secret</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1: Values to find the Azure Key Vault secret</p>
			<p>Obviously, you <a id="_idIndexMarker1012"/>should change these values to match your setup.</p>
			<p>In the C# application, we need to add a couple of NuGet packages:</p>
			<ul>
				<li><code>Azure.Identity</code> to enable authentication</li>
				<li><code>Azure.Security.KeyvaultSecrets</code></li>
			</ul>
			<p>Once you have installed those packages, the code to get the secrets out of the key vault is very straightforward. For instance, you can use this helper method:</p>
			<pre class="source-code">
public async Task&lt;string&gt; GetSecretAsync(string keyVaultUrl, string secretName)
{
    var client =
        new SecretClient(
            new Uri(keyVaultUrl),
            new DefaultAzureCredential());
    var secret =
        await client.GetSecretAsync(secretName);
    return secret.Value.Value;
}</pre>			<p>This code snippet shows how to use the <code>SecretClient</code> class from the previously installed package to access the secrets in the key vault. To authenticate this request, I use the <code>DefaultAzureCredential</code> class. Using this class means I authenticate against the Azure URL with the current user’s credentials.</p>
			<p>In a <a id="_idIndexMarker1013"/>production<a id="_idIndexMarker1014"/> system, you would not do that. Instead, you should probably create a registration for your system and use that to authenticate. Authentication in Azure is a topic that deserves its own book, but the following URL should get you on your way: <a href="https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line">https://learn.microsoft.com/en-us/dotnet/azure/sdk/authentication/?tabs=command-line</a>.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor273"/>Using environment variables</h2>
			<p>Even when <a id="_idIndexMarker1015"/>using Azure (and not using the default credentials), you <a id="_idIndexMarker1016"/>need to store some sort of access key, secret ID, or user ID and password before you can use the resources. The same applies when you store data encrypted in your <code>appsettings.json</code> file – you need a key to decrypt. As we saw in a previous sample, you can ask the .NET runtime to create a key for you and store it in a known place. That is one way of solving this issue, but there is also a much simpler way. We can use environment variables.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Environment variables are convenient, but they are not secure – not by a long shot. Everybody can look up their values if they have physical access to the machine. Never store sensitive information in environment variables unless you can be confident the virtual or physical machine is secure.</p>
			<p>An environment variable is simply a key-value pair that lives in Windows. It is usually used to contain settings from outside of the process. This is why they can be useful for holding data we need to identify resources; they can change on the fly without changing or restarting our application.</p>
			<h3>Environment variable scopes</h3>
			<p>Where precisely <a id="_idIndexMarker1017"/>these variables live and how long they persist depends on the kind of environment variable. The variables<a id="_idIndexMarker1018"/> can have a scope that affects where they persist (and how long they do so). These are the options we have:</p>
			<ul>
				<li><strong class="bold">Process scope</strong>: These <a id="_idIndexMarker1019"/>variables are only available to the process that defined them, or any child processes that the main process spawns. They can be useful for temporary values that can be discarded if the process goes out of memory.</li>
				<li><strong class="bold">User scope</strong>: They <a id="_idIndexMarker1020"/>are specific to the currently logged-in user. They are available to all processes that run under that user’s credentials. These variables persist across logins.</li>
				<li><strong class="bold">Machine scope (or system scope)</strong>: These<a id="_idIndexMarker1021"/> variables are available to all users and processes on a machine. They require administrative privileges to set and modify but not to read.</li>
				<li><strong class="bold">Session scope</strong>: These<a id="_idIndexMarker1022"/> variables are scoped to a user session. This scope is more or less the same as the user scope, but the variables are discarded as the session ends. That happens, for instance, if the user logs off.</li>
				<li><strong class="bold">Volatile environment variables</strong>: This<a id="_idIndexMarker1023"/> is a special category mainly used by a system. They are intended to be temporary. Users typically do not handle or even access these. An example is the settings set during boot time that can be removed once the login process ends.</li>
			</ul>
			<p>As you can see, there are a lot of different scopes, some of which most users have never even heard of before. Make sure you pick the correct one!</p>
			<h3>Setting environment variables</h3>
			<p>Of course, we <a id="_idIndexMarker1024"/>can use our C# code to set variables. However, we usually do not do that; in our case, we want to set some secret data outside our application and then use it in our code. This means we have to set the data from the outside. Setting the values is typically done during the installation of our software. However, during development, you have to do it manually.</p>
			<p>Setting these variables is very easily done from a PowerShell session, and the exact syntax depends on the scope you want to achieve.</p>
			<h4>Process scope</h4>
			<p>I only<a id="_idIndexMarker1025"/> add this here for completeness. After all, if we set a variable so that we can read it in our application, using the <strong class="bold">process scope</strong> does not make sense. The variable is set in the scope of the PowerShell session and thus is not readable in our application. But anyway, here is how you do it. In PowerShell, enter this command:</p>
			<pre class="console">
$env:MY_SECRET_ID = 12345678</pre>			<p>This command creates a new variable named <code>"MY_SECRET_ID"</code> in memory and assigns it the <code>12345678</code> value.</p>
			<p>If you read the data, you’ll be surprised to see that it is almost as simple as setting it:</p>
			<pre class="source-code">
Write-Host $env:MY_SECRET_ID</pre>			<p>This command should return the <code>12345678</code> string.</p>
			<p>After setting and reading the data, you might want to erase it. Again, this is very easy to do:</p>
			<pre class="console">
$env:MY_SECRED_ID = $null</pre>			<p>Note that that last command happens automatically if you close the PowerShell session.</p>
			<h4>User scope</h4>
			<p><strong class="bold">User scope</strong> is the<a id="_idIndexMarker1026"/> first useable scope for our purposes. Setting this variable goes like this in PowerShell:</p>
			<pre class="console">
setx MY_SECRET_ID 87654321</pre>			<p>This command creates a new variable and sets the data. The variable is stored in the Windows Registry under the <code>HKEY_CURRENT_USER\Environment</code> key. Windows keeps this value across reboots. Since the data is stored in <code>HKEY_CURRENT_USER</code>, you can only read the data in processes belonging to that user. That means you can read it during debugging<a id="_idIndexMarker1027"/> in <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>), but only if you run VS under the same credentials.</p>
			<h4>Machine scope</h4>
			<p>The broadest scope<a id="_idIndexMarker1028"/> is the <strong class="bold">machine scope</strong>. Setting data is just as simple as using the user scope, with one tiny addition:</p>
			<pre class="console">
setx MY_GLOBAL_SECRET_ID 87654321 /m</pre>			<p>The use of <code>/m</code> at the end makes this variable a machine-scoped one. This means it is stored in a different location as well; you can now find this variable in the Windows Registry under the <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</code> key. This variable is persisted across reboots and is accessible to all users and processes on that machine.</p>
			<h3>Reading the variables in your code</h3>
			<p>There is little use<a id="_idIndexMarker1029"/> in storing data somewhere if it is impossible to read. So, let’s investigate how we can use that data in our C# application.</p>
			<p>To read the data, you only need one line of code, which is this:</p>
			<pre class="source-code">
string mySecretdId =
   Environment.GetEnvironmentVariable("MY_SECRET_ID");</pre>			<p>However, remember that <code>MY_SECRET_ID</code> was set using the user scope. So, if you run your PowerShell command as an administrator, you must also run VS as an administrator. Otherwise, the code returns an empty string.</p>
			<p>Do you want to see how to read the machine-scoped variable? I thought you might. This is how:</p>
			<pre class="source-code">
var mySecretdId =
 Environment.GetEnvironmentVariable("MY_GLOBAL_SECRET_ID");</pre>			<p>Yes, that is the same code, with the only change being the variable name we are looking for. Not all code in this book is hard to understand!</p>
			<p>There are <a id="_idIndexMarker1030"/>many more ways to handle keys, but you have now seen two of the most used ones. You now know how to use Azure Key Vault and have learned a lot about environmental variables. Let’s move on!</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor274"/>Using the right privilege level</h1>
			<p>Most systems<a id="_idIndexMarker1031"/> do not need to run as admin. Requiring your application to have admin rights is a potential security risk. It would be best to ensure your application runs on the lowest security level possible to avoid potential leaks.</p>
			<p>However, sometimes you have no choice. There are certain cases where admin-level privilege is needed. The bad news is that this happens often in the world where we, system programmers, live. Our systems need an admin level more than a regular program does.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor275"/>Admin-level scenarios</h2>
			<p>Let’s <a id="_idIndexMarker1032"/>investigate some areas where elevated privileges are needed if we <a id="_idIndexMarker1033"/>want our system to do what it needs to do:</p>
			<ul>
				<li><code>C:\Windows\System32</code> directory is a good example of a protected directory. You need elevated rights if you want to read something from that folder.</p></li>
				<li><code>HKEY_LOCAL_MACHINE</code> key. That area cannot be reached without the proper security level.</p></li>
				<li><strong class="bold">Service management</strong>:<p class="list-inset">Starting, stopping, or configuring Windows services is another nice example of requiring <a id="_idIndexMarker1036"/>admin-level privileges. Also, installing and uninstalling these services need that level of trust. Since we work a lot with background processes, we can imagine scenarios where we need to control those processes from other processes. That means elevating the level again.</p></li>
				<li><strong class="bold">Network configuration</strong>:<p class="list-inset">Modifying network <a id="_idIndexMarker1037"/>settings is also a reason you might need elevated privileges. These tasks include changing an IP address, configuring network adapters, and adjusting firewall rules.</p></li>
				<li><strong class="bold">System monitoring </strong><strong class="bold">and diagnostics</strong>:<p class="list-inset">Some of <a id="_idIndexMarker1038"/>the performance counters or diagnostics tools require elevated privileges. Also, reading system logs in an event or other logs requires admin access.</p></li>
			</ul>
			<p>This is not an <a id="_idIndexMarker1039"/>exhaustive list; there are other areas as well. If you run into one of those, you will find out soon enough – your system won’t work and crash with a nice exception.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor276"/>Impersonating as an admin</h2>
			<p>If your system<a id="_idIndexMarker1040"/> does something from the preceding list, you might be tempted to install your system with admin credentials. That way, you are sure it always works. But as we have discussed before, that is not necessarily a good idea. It would be much better to go to the administrator level only when needed. When done, revert to the regular, less privileged user account.</p>
			<p>How can we do that? First, we must create an account with admin-level rights on the machine where our software will run. I would not use the generic administrator account found on machines; you are better off using a dedicated account.</p>
			<p>On my machine, I created an account named <code>MySecureAdmin</code>. I gave it the extremely safe password <code>P@ssw0rd!</code>. No, that’s not a password I would use in real life, but for this demonstration, it will suffice. This account is a local admin. And finally, my machine has the name <code>DennisMachine</code>. This is all the information you would need if you wanted to log in as an administrator.</p>
			<p>The<a id="_idIndexMarker1041"/> technique to temporarily act as another user in your application is called impersonating. Let me show you how that is done.</p>
			<p>I have created a console application and added a new class called <code>ImpersonationHelper</code>. The class imports two methods from the Win32 API – <code>LogonUser</code> and <code>CloseHandle</code>. This is their signature:</p>
			<pre class="source-code">
[DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]
public static extern bool LogonUser(
    string lpszUsername,
    string lpszDomain,
    string lpszPassword,
    int dwLogonType,
    int dwLogonProvider,
    out SafeAccessTokenHandle phToken);
[DllImport("kernel32.dll", CharSet = CharSet.Auto)]
public static extern bool CloseHandle(IntPtr handle);</pre>			<p>The <code>LogonUser</code> API resides in the “<code>advapi32.dll"</code> DLL, while the <code>CloseHandle</code> API can be found in <code>"kernel32.dll"</code>.</p>
			<p>Next, I declare two constants that we will need later on:</p>
			<pre class="source-code">
private const int LOGON32_LOGON_BATCH = 4;
private const int LOGON32_PROVIDER_DEFAULT = 0;</pre>			<p>That is all we <a id="_idIndexMarker1042"/>need to start impersonating. This is the code that does that:</p>
			<pre class="source-code">
public static void RunAsAdmin(
    string userName, string domain,
    string password, Action action)
{
    var returnValue = LogonUser(
        userName, domain,
        password, LOGON32_LOGON_BATCH,
        LOGON32_PROVIDER_DEFAULT,
        out var safeAccessTokenHandle);
    if (!returnValue)
    {
        var ret = Marshal.GetLastWin32Error();
        throw new Win32Exception(ret);
    }
    try
    {
        WindowsIdentity.RunImpersonated(safeAccessTokenHandle, () =&gt; {           action(); });
    }
    finally
    {
        safeAccessTokenHandle.Dispose();
    }
}</pre>			<p>Let me <a id="_idIndexMarker1043"/>explain what is going on here.</p>
			<p>The method gets all the required information to log into Windows – the username, password, and domain. We also give it the code we want to run under these credentials in the form of an <code>Action</code>.</p>
			<p>We call <code>LogonUser()</code> and give it the username, domain, and password. Then, we specify the login type; we give it <code>LOGON32_LOGON_BATCH</code>. This type is used for batch servers. Batch servers execute code on behalf of a user without their intervention. In contrast, a standard login would use <code>LOGON32_LOGON_INTERACTIVE</code>. The <code>BATCH</code> option results in higher performance, which is very convenient for us. After this, we give it the login provider and instruct it to use the default provider by passing <code>LOGON32_PROVIDER_DEFAULT</code>.</p>
			<p>If all goes well, we will get a pointer in <code>SafeAccessTokenHandle</code>. If it does not work, we get an error.</p>
			<p>With that handle, we can call <code>WindowsIdentity.RunImpersonated()</code>, which in turn calls our action.</p>
			<p>Do not forget to call <code>Dispose()</code> on the handle!</p>
			<p>Using this code is straightforward:</p>
			<pre class="source-code">
var userName = Environment.UserName;
$"Current user: {userName}".Dump();
var adminUserName = "MySecureAdmin";
var domain = "dennismachine";
var password = "P@ssw0rd!";
ImpersonationHelper.RunAsAdmin(
    adminUserName, domain, password, () =&gt;
{
    var otherUserName = Environment.UserName;
    $"Username {otherUserName}".Dump();
});</pre>			<p>This code uses our new class to temporarily log in as another user. But before that, it shows the current username. I do the same in the <code>Action</code>, but the results will differ. We are now logged in as the new user, which should also be shown on the screen.</p>
			<p>There is<a id="_idIndexMarker1044"/> no need to log out – the call to <code>LogonUser()</code> doesn’t alter the logged-in state of that user; it is just required to get the handle. The moment we dispose of the handle, the impersonation also terminates. This means we are now back operating under the standard credentials. Run this sample and see what happens.</p>
			<p>Impersonation is another nice tool in your toolbelt, but use it sparingly. Only increase the trust level in your applications if you absolutely need it. Oh, and I am sure I do not need to remind you that storing usernames and passwords in plain code in your application is terrible, especially if they belong to admin-level users. Right?</p>
			<p>Many developers, by default, assume their code needs admin-level privileges. After reading this section, you now know better. We discussed the situations where admin-level is required, but please remember that less is more, especially regarding privilege levels! And if you need admin-level privileges in your code, you know how to take care of that temporarily before returning to a normal level.</p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor277"/>How to transmit network data securely</h1>
			<p>As we have seen, keeping <a id="_idIndexMarker1045"/>data sensitive on your machine is hard. But things get even more complicated once we leave the safe haven of the machine we control and venture into the wasteland of networks.</p>
			<p>I probably do not have to remind you that you should never use a public website that uses an HTTP connection instead of an HTTPS connection. The “S,” after all, stands for “Secure.” That is what we want – we want our data to be encrypted, and we want to be confident that the server we talk to is secure and belongs to the party we think it belongs to.</p>
			<p>The same applies to our code – if we talk to an outside system, we want to ensure that our data is not being tampered with or intercepted. That also applies to other systems when they connect to us – we want to give those users the same sense of security. How do we achieve that? The answer is simple – we do the same as those HTTPS servers. The next question is, how do we implement that? And that is slightly more complicated. But don’t worry – I will walk you through it step by step.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor278"/>How HTTPS works</h2>
			<p>Let me ask you a <a id="_idIndexMarker1046"/>question. How do you know you can trust the website you visit? Just because it says HTTPS in the address bar? But what does that mean? How can that be a guarantee? To answer that, we need to look at what HTTPS actually means.</p>
			<p><strong class="bold">HTTPS</strong> stands for <strong class="bold">Hyper Text Transport Protocol Secure</strong>. This is a variation of regular<a id="_idIndexMarker1047"/> HTTP traffic – it has added security. Let’s examine the flow:</p>
			<ol>
				<li>In your browser, you enter a URL: <a href="https://www.microsoft.com">https://www.microsoft.com</a>.</li>
				<li>The browser resolves the domain name to an IP address.</li>
				<li>The client initiates a TCP connection with the server using a three-way handshake (SYN, SYN-ACK, and ACK).</li>
				<li>The client sends a <code>"ClientHello"</code> message to the server. This message includes the following:<ul><li>Supported TLS versions</li><li>Supported cipher suites</li><li>Supported compression methods</li><li>A randomly generated value (client random)</li><li>Session IDs and extensions (optional)</li></ul></li>
				<li>The server then responds with a <code>"ServerHello"</code> message, which includes the following:<ul><li>The chosen TLS version</li><li>The chosen cipher suite</li><li>The chosen compression method</li><li>A randomly generated value (server random)</li><li>The session ID (if supported and desired)</li></ul></li>
				<li>The<a id="_idIndexMarker1048"/> server sends its digital certificate, including its public key and a digital signature, from a trusted certificate authority.</li>
				<li>Then, the server may (if required) send a <code>"</code><code>ServerKeyExchange"</code> message.</li>
				<li>After that, the server requests a client certificate for mutual authentication.</li>
				<li>Finally, the server sends a <code>"ServerHelloDone"</code> message, indicating that this is the end of the handshake.</li>
				<li>The client then optionally sends its own certificate (if requested).</li>
				<li>The client sends a <code>"ClientKeyExchange"</code> message. The contents depend on the algorithm chosen. For instance, if RSA is chosen, the client encrypts a pre-master secret with the server’s public key and sends that to the server.</li>
				<li>The client sends a <code>"CertificateVerify"</code> message to prove it owns the client certificate. This involves signing a hash of the handshake messages using the client’s private key.</li>
				<li>Both parties then generate the session keys (symmetric keys) for encryption and authentication, using the pre-master secret and the random values exchanged earlier.</li>
				<li>The client then sends a <code>"ChangeCipherSpec"</code> message to inform the server that, from now on, all messages will be encrypted using the negotiated keys and algorithms.</li>
				<li>The server also sends a <code>"</code><code>ChangeCipherSpec"</code> message.</li>
				<li>The client sends a <code>"Finished"</code> message, which is a hash of all the handshake messages encrypted with the session key.</li>
				<li>The server responds with its <code>"Finished"</code> key, with the same sort of information.</li>
			</ol>
			<p>From now on, the<a id="_idIndexMarker1049"/> client and the server can use the keys and algorithms to encrypt and decrypt the data flow.</p>
			<p>If you think this sounds complicated, you are right. The good news is that we do not have to worry about this. All of the classes in the BCL dealing with HTTP handle this for us. All you have to do is connect to a secure server, specify that you want to use SSL, and you are good to go.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor279"/>Certificates and certificate authorities</h2>
			<p>The <a id="_idIndexMarker1050"/>preceding steps outline how the client and server exchange keys securely. However, a key question remains – how do they know they can trust each other?</p>
			<p>The answer to that question lies in the use of certificates. A certificate is a digital document containing information about the certificate’s owner. It includes the following information:</p>
			<ul>
				<li><strong class="bold">Subject</strong>: The entity that the certificate represents (for instance, the website’s domain name)</li>
				<li><strong class="bold">Issuer</strong>: Who issued the certificate</li>
				<li><strong class="bold">Public key</strong>: The public key of the entity</li>
				<li><strong class="bold">Validity period</strong>: The date range in which the certificate is valid</li>
				<li><strong class="bold">Serial number</strong>: A unique identifier for the certificate</li>
				<li><strong class="bold">Signature</strong>: The digital signature of the issuer, verifying that the certificate is genuine and has not been tampered with</li>
			</ul>
			<p>If you get a certificate from a website, you can use that to verify that the site you are connecting to is indeed the one it claims to be. If the information on the certificate doesn’t match what is expected, you had better not use that site.</p>
			<p>But how can you be sure that the certificate is valid? This question leads us to the last part of the SSL infrastructure – certificate authorities.</p>
			<p>A certificate has to be obtained from a third party. These companies sell certificates, but only after they have verified that the one requested a certificate is who they say they are. We call these<a id="_idIndexMarker1051"/> companies <strong class="bold">certificate authorities</strong> (<strong class="bold">CAs</strong>). These authorities are regularly audited to make sure they can be trusted. This starts a whole chain – a CA has its own certificate. However, that certificate is a root certificate; it is implicitly trusted. No organization guarantees the CA’s certificate is valid. But if we trust that root certificate, we can assume that all certificates signed with that root certificate are also safe. Then, we can use the secondary certificate to sign another certificate. We can build a whole tree of trusted certificates, all of which can be traced back to the CA that issued the original certificate.</p>
			<p>Windows<a id="_idIndexMarker1052"/> keeps track of all the trusted root certificates and stores them on the local machine. That way, the software can compare the hashes with the data it receives from the HTTPS server and make sure the certificate is secure.</p>
			<p>To see these root certificates, run the <code>mmc.exe</code> command on your machine. Then, press <em class="italic">CTRL</em> + <em class="italic">M</em> to add the <strong class="bold">Certificates</strong> snap-in. Open the tree on the left to see all the trusted root certificate authorities. This is what it looks like on my machine:</p>
			<div><div><img alt="Figure 1﻿2.1: Root certificates in Windows" src="img/B20924_13_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Root certificates in Windows</p>
			<p>Your list will undoubtedly differ from mine, but these are all trusted root certificates. Windows regularly updates this list to make sure it is still valid.</p>
			<p>You must get a certificate from one of these CA organizations to set up a HTTPS server. They all have a slightly different process, so I suggest you investigate some of them to see if they are suitable for you. It doesn’t matter which CA you use; all certificates suit your purposes. Some <a id="_idIndexMarker1053"/>are faster than others, and others are cheaper than others. Just pick what you feel is the best option for you.</p>
			<p class="callout-heading">Be aware of free certificates!</p>
			<p class="callout">I will be very clear about this – there are no free certificates to be had at the time of writing. A few CAs issued free certificates, but that doesn’t happen anymore. The demands for verification have significantly increased; the CA needs to be more thorough than ever to combat cybercrime. And that costs money. If you see a CA that offers a free certificate, do not fall for it. Remember that if something sounds too good to be true, it probably is. Some CA organizations provide a free certificate, but they have other demands. You have to build your software on their pipelines, or you have to host with them. Ultimately, you still pay for it.</p>
			<p>So, now we know what a certificate is and how to get one. But let’s be honest – if you want to play around with certificates or are still in development, you might not be ready to purchase a certificate. If that is your situation, then I have good news. There is a free alternative – you can make your own certificate!</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor280"/>Creating a development certificate</h2>
			<p>Yes, you<a id="_idIndexMarker1054"/> can create your own certificate. But this is just for experimental or development purposes. You cannot use it in a production system; the verification will fail, since your certificate is not vouched for by a CA.</p>
			<p>The tools to create a certificate are part of the SDK installed with VS. Let’s make a certificate!</p>
			<p>In a developer command prompt or PowerShell terminal, enter the following command:</p>
			<pre class="console">
MakeCert -r -pe -ss PrivateCertStore -n "CN=localhost" -sv testcer.pvk testcer.cer</pre>			<p><code>MakeCert</code>, part of the SDK, is the tool to create a certificate. There are many options, but we do not need most of them. I have given you the minimum we need for our purpose. Let’s <a id="_idIndexMarker1055"/>investigate what we did by looking at the parameters:</p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-9">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Parameter</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-r</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This means the certificate is self-signed and not signed by a CA.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>pe</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This marks the private key as exportable. The private and public keys are all part of the certificate, so you need this option if you want a copy of the private key.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>ss PrivateCertStore</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The specifies the certificate store where the generated certificate will be placed. In our case, we use <code>PrivateCertStore</code>, one of those entries in the Management console we looked at earlier.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>n "CN=localhost"</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the <code>localhost</code> (<strong class="bold">CN</strong> means <strong class="bold">common name</strong>) so that the clients know which domain this certificate belongs to.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>-</code><code>sv testcer.pvk</code></p>
						</td>
						<td class="No-Table-Style">
							<p>We marked the private key as exportable; this option does the export. The private key is stored in the <code>testcer.pvk</code> file.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>testcer.cer</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The filename of the certificate</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.2: Parameters for MakeCert</p>
			<p>If you run the <code>MakeCert</code> command, you will be asked to enter passwords. Make sure you remember them and store them somewhere secure!</p>
			<p>This command results in two files – <code>testcer.cer</code> (the certificate) and <code>testcer.pvk</code> (the private key). Make sure you treat these files as confidential; they contain your private keys.</p>
			<p>The certificate can now be used, but not for everything we want to use it for. Later, we will use the certificate to encrypt data streams, but that will require a different format. These tools need a <code>pfx</code> format. Luckily, converting a <code>.cer</code> file to a <code>.pfx</code> file is easy enough. Just enter this command:</p>
			<pre class="console">
pvk2pfx -pvk .\testcer.pvk -spc .\testcer.cer -pfx testcer.pfx -po "password"</pre>			<p>The <code>pvk2pfx</code> tool takes the exported private key and the certificate and converts them into a <code>.pfx</code> file. The parameters speak for themselves.</p>
			<p>The certificate we created<a id="_idIndexMarker1056"/> is now stored in the certificate store under the <code>PrivateCertStore</code> section. But we also need to store the newly generated <code>.pfx</code>  file in the certificate store for later use. To do this, enter the following command:</p>
			<pre class="console">
certutil -importpfx testcer.pfx</pre>			<p>In this case, the <code>certutil</code> command invoked another handy tool to take the new <code>testcer.pfx</code> file and store it in the right place.</p>
			<p>And that is all there is to it. We now have our own certificate, so let’s secure some network traffic!</p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor281"/>Securing TCP streams</h2>
			<p>If you have a<a id="_idIndexMarker1057"/> web server, such as IIS, you can import the <code>.pfx</code> file there. That way, you can use HTTPS on your local network. Again, this is not SSL; other clients will not accept that self-signed certificate. It is for development only.</p>
			<p>However, I am not currently interested in setting up a HTTPS server. I am more concerned about the other network communication types we discussed previously. For instance, how can we secure simple, straightforward TCP communications? If we want to use sockets, how do we secure that? The answer is to use SSL, as we have seen with HTTPS. Let’s build some secure code!</p>
			<p>I have created two console applications. One is a server waiting for incoming TCP connections; the other is the client connecting to that server.</p>
			<p>Let’s have a look at the server code first. I have created a new class called <code>SecureServer</code>. This class gets a constructor that takes the required information to set up the server. It looks like this:</p>
			<pre class="source-code">
public SecureServer(int port,
    string certificatePath,
    string certificatePassword)
{
    _port = port;
    _serverCertificate = new X509Certificate2(
        certificatePath,
        certificatePassword);
}</pre>			<p>We pass the<a id="_idIndexMarker1058"/> file path to the certificate we just created and the password in the port that the TCP socket listens to (I told you to write that down, didn’t I?). We store the port number in a local variable and use the other two variables to create an instance of the <code>X509Certificate2</code> class.</p>
			<p>Next is the method that starts the server. We investigated that before (in <a href="B20924_09.xhtml#_idTextAnchor181"><em class="italic">Chapter 8</em></a>, <em class="italic">The One with the Network Navigation</em>), so there shouldn’t be any surprises here. Here it is:</p>
			<pre class="source-code">
public async Task StartAsync()
{
    "Server is starting...".Dump();
    var listener = new TcpListener(IPAddress.Any, _port);
    listener.Start();
    $"Server is listening on port {_port}...".Dump();
    while (true)
    {
        var clientSocket = await listener.AcceptSocketAsync();
        _ = HandleClientConnection(clientSocket);
    }
}</pre>			<p>We create an<a id="_idIndexMarker1059"/> instance of <code>TcpListener</code>, tell it to use any IP address on the machine, and give it the correct port. Then, we call <code>Start()</code> to accept incoming connections. In a never-ending loop, we wait for a client to connect. If that happens, we accept the connection with a call to <code>AcceptSocketAsync()</code> and pass the handling of the connection to a method called <code>HandleClientConnection()</code>. Let’s look at that one next.</p>
			<p>The first half of the method looks like this:</p>
			<pre class="source-code">
private async Task HandleClientConnection(Socket clientSocket)
{
    try
    {
        await using var sslStream =
            new SslStream(
                new NetworkStream(clientSocket),
                false);
        await sslStream.AuthenticateAsServerAsync(
            _serverCertificate,
            false,
            SslProtocols.Tls12,
            true);
        $"Client connected: {clientSocket.RemoteEndPoint}".Dump();</pre>			<p>Instead of using a normal stream, we use a specialized one called <code>SslStream</code>. This takes <code>NetworkStream</code> and a parameter, indicating whether the stream should be kept open when we finish it (we don’t want that, so we give it a <code>False</code>).</p>
			<p>Then, we <a id="_idIndexMarker1060"/>call <code>AuthenticateAsServerAsync()</code> on that <code>SslStream</code>, giving it the certificate, tell it that we do not require a client certificate, also tell it that we want to use TLS version 1.2, and finally, inform the method that we want to check the certificate revocation (hence the <code>True</code>). This one line of code makes sure the server does all the steps needed for it to set up a secure connection.</p>
			<p>The rest of the method is straightforward – we read data coming in and display it. This is the rest of that method:</p>
			<pre class="source-code">
        var buffer = new byte[1024];
        var bytesRead =
            await sslStream.ReadAsync(
                buffer,
                0,
                buffer.Length);
        var receivedString =
            Encoding.UTF8.GetString(
                buffer,
                0,
                bytesRead);
        $"Received from client: {receivedString}".Dump();
    }
    catch (Exception ex)
    {
        ex.Message.Dump();
    }
}</pre>			<p>And that is all! Well, almost – we need to use this method as well. But that is even simpler. In the <code>Main()</code> method, use this code:</p>
			<pre class="source-code">
var certificatePath = @"d:\Certificate\testcer.pfx";
var certificatePassword = "password";
var server = new SecureServer(
    8081,
    certificatePath,
    certificatePassword);
await server.StartAsync();</pre>			<p>With all this, we <a id="_idIndexMarker1061"/>have a working and secure socket server!</p>
			<p>Next up, the client! For the client, I did a similar thing. I added a new class called <code>SecureClient</code> with the following constructor:</p>
			<pre class="source-code">
public SecureClient(
    string server,
    int port)
{
    _server = server;
    _port = port;
}</pre>			<p>This constructor takes two parameters – the name of the server and the port it wants to connect to.</p>
			<p>Next, we define a method called <code>ConnectAsync()</code> that allows the client to connect:</p>
			<pre class="source-code">
public async Task ConnectAsync()
{
    using var clientSocket = new TcpClient(_server, _port);
    await using var networkStream = clientSocket.GetStream();
    await using var sslStream =
        new SslStream(
            networkStream,
            false,
            ValidateServerCertificate);
    try
    {
        await sslStream.AuthenticateAsClientAsync(_server);
        "SSL authentication successful".Dump();
        var message = $"Hello, server! {DateTime.Now.TimeOfDay}";
        var messageBytes = Encoding.UTF8.GetBytes(message);
        await sslStream.WriteAsync(messageBytes, 0, messageBytes.Length);
    }
    catch (Exception ex)
    {
        ex.Message.Dump(ConsoleColor.Red);
    }
}</pre>			<p>This method<a id="_idIndexMarker1062"/> starts with familiar code – we create an instance of <code>TcpClient</code> and give it the server and port. After that, we open <code>NetworkStream</code> from that <code>TcpClient</code>. But then things get more interesting – we create a new instance of the <code>SslStream</code> class, giving it <code>NetworkStream</code>, the same <code>False</code> that indicates that we do not want to keep the stream open when we are done with it, and a callback method called <code>ValidateServerCertificate</code>. After that, we call <code>AuthenticateAsClientAsync()</code> to make sure the client and the server exchange messages, as<a id="_idIndexMarker1063"/> described previously.</p>
			<p>The rest of this method is nothing special – we just write the bytes to the stream.</p>
			<p>Let’s look at the <code>ValidateServerCertificate()</code> callback method next:</p>
			<pre class="source-code">
private static bool ValidateServerCertificate(
    object sender,
    X509Certificate certificate, X509Chain chain,
    SslPolicyErrors sslPolicyErrors)
{
    if (sslPolicyErrors == SslPolicyErrors.None)
    {
        "Server certificate is valid".Dump();
        return true;
    }
    "Server certificate is invalid".Dump(ConsoleColor.Red);
    return false;
}</pre>			<p>This method is called when we create <code>SslStream</code> and is part of validating the server’s certificate. The method itself is straightforward – we just check to see whether there are any errors in the <code>SslPolicyErrors</code> enum. If there are, we return <code>false</code>. This is picked up by the <code>SslStream</code> class, which will raise an exception.</p>
			<p class="callout-heading">A developers’ trick – simplify your development</p>
			<p class="callout">If you are developing a solution like this but do not have a valid certificate, there is a quick hack you can use. Change the validation method to always return <code>True</code>. That way, your client will accept all sorts of certificates, regardless of their validity. Just do not use this technique in production code!</p>
			<p>Using this <a id="_idIndexMarker1064"/>class is easy. This is the code:</p>
			<pre class="source-code">
var secureClient = new SecureClient("localhost", 8081);
await secureClient.ConnectAsync();</pre>			<p>Just a word of warning – this is only for development purposes. The code itself is fine for any scenario, but the certificate we created is not. We signed it ourselves, so no real client should accept it. Next, we specified that the server’s name is <code>"localhost</code>”. This apparently only works on your machine, not across a network. You could change that when you create the certificate, of course.</p>
			<p>And there you have it – a working TCP client using a secure channel. You have made it much harder, if not impossible, for a hacker to eavesdrop and listen in on your communications!</p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor282"/>Next steps</h1>
			<p>I have to be honest with you. We only touched briefly on the subject of security. There are hundreds, if not thousands, of books on this topic. But the information I gave you should help you get in the right mindset. Remember that a system is only as secure as the weakest link. And security is something that you should consider from the beginning, not added as an afterthought.</p>
			<p>One final warning – do not try to reinvent the wheel and come up with your own algorithms. Your solutions are never as good as what teams of hundreds of crypto and security experts can come up with. Trust them to do their job so that you can focus on yours.</p>
			<p>That being said, we did cover a lot of ground. We discussed the following:</p>
			<ul>
				<li>The need for security in modern applications</li>
				<li>How data is represented in memory and how to protect against that</li>
				<li>How to handle keys in Azure Key Vault but also in simple things such as environment variables</li>
				<li>How to deal with the proper privilege level</li>
				<li>How to secure your network communications</li>
			</ul>
			<p>However, there is one thing that we mentioned briefly but did not cover in detail – how to pass credentials securely from our development machine to a production environment. How do we ensure the environment variables are set when deploying our solutions? This and other questions are part of the deployment strategies we can use, which happens to be the topic of the next chapter!</p>
		</div>
	</body></html>