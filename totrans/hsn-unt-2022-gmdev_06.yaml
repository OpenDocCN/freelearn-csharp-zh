- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Movement and Spawning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现运动和生成
- en: In the previous chapter, we learned about the basics of scripting, so now let’s
    create the first script for our game. We will see the basics of how to move objects
    through scripting using the `Transform` component, which will be applied to the
    movement of our player with the keyboard keys, the constant movement of bullets,
    and other object movements. Also, we will see how to create and destroy objects
    during the game, such as the bullets our player and enemy shoot and the enemy
    wave spawners. These actions can be used in several other scenarios, so we will
    explore a few to reinforce the idea.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了脚本的基础知识，所以现在让我们为我们的游戏创建第一个脚本。我们将看到如何使用`Transform`组件通过脚本移动对象的基础知识，这将应用于我们的玩家通过键盘按键的运动、子弹的恒定运动以及其他对象的运动。此外，我们还将看到如何在游戏中创建和销毁对象，例如玩家和敌人射击的子弹以及敌人波生成器。这些操作可以在多个场景中使用，所以我们将探索几个以加强这个概念。
- en: 'In this chapter, we will examine the following scripting concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下脚本概念：
- en: Implementing movement
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现运动
- en: Implementing spawning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现生成
- en: Using the new Input System
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的输入系统
- en: We will start by scripting components to move our character through the keyboard,
    and then we will make our player shoot bullets. Something to consider is that
    we are going to first see the C# version and then show the Visual Scripting equivalent
    in each section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过脚本组件来控制我们的角色通过键盘移动，然后我们将让我们的玩家射击子弹。需要考虑的是，我们将首先看到每个部分的C#版本，然后展示视觉脚本等效版本。
- en: Implementing movement
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现运动
- en: 'Almost every object in the game moves one way or another: the player character
    with the keyboard; the enemies through AI; the bullets that simply move forward;
    and so on. There are several ways of moving objects in Unity, so we will start
    with the simplest one, that is, through the `Transform` component.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎游戏中的每个对象都以某种方式移动：玩家角色通过键盘；敌人通过AI；简单的向前移动的子弹等等。在Unity中有几种移动对象的方法，所以我们将从最简单的一种开始，即通过`Transform`组件。
- en: 'In this section, we will examine the following movement concepts:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下运动概念：
- en: Moving objects through `Transform`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`Transform`移动对象
- en: Using input
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用输入
- en: Understanding Delta Time
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Delta Time
- en: First, we will explore how to access the `Transform` component in our script
    to drive the player movement, to later apply movement based on the player’s keyboard
    input. Finally, we are going to explore the concept of Delta Time to make sure
    the movement speeds are consistent on every computer. We are going to start learning
    about the `Transform` API to make a simple movement script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨如何在脚本中访问`Transform`组件以驱动玩家运动，以便稍后根据玩家的键盘输入应用运动。最后，我们将探索Delta Time的概念以确保在每台计算机上运动速度的一致性。我们将开始学习`Transform`
    API以创建一个简单的运动脚本。
- en: Moving objects through Transform
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Transform移动对象
- en: '`Transform` is the component that holds the translation, rotation, and scale
    of the object, so every movement system such as physics or pathfinding will affect
    this component. Sometimes, we want to move the object in a specific way according
    to our game by creating our own script, which will handle the movement calculations
    we need and modify `Transform` to apply them.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform`是包含对象的平移、旋转和缩放的组件，因此每个运动系统，如物理或路径查找，都会影响此组件。有时，我们想要通过创建自己的脚本来根据我们的游戏以特定方式移动对象，该脚本将处理我们需要的运动计算并修改`Transform`以应用它们。'
- en: 'One concept implied here is that components alter other components. The main
    way of coding in Unity is to create components that interact with other components.
    Here, the idea is to create one that accesses another and tells it to do something:
    in this case, to move. To create a script that tells `Transform` to move, do the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里隐含的一个概念是组件会改变其他组件。在Unity中编码的主要方式是创建与其他组件交互的组件。在这里，想法是创建一个可以访问另一个并告诉它做某事：在这种情况下，移动。要创建一个告诉`Transform`移动的脚本，请执行以下操作：
- en: 'Create and add a script called `PlayerMovement` to our character, like we did
    in the previous chapter. In this case, it would be the animated 3D model we downloaded
    previously (drag the 3D asset from the **Project** view to the scene). Remember
    to move the script to the **Scripts** folder after creation:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加一个名为`PlayerMovement`的脚本到我们的角色中，就像我们在上一章中所做的那样。在这种情况下，它将是之前下载的动画3D模型（从**项目**视图拖动3D资产到场景中）。记住在创建后，将脚本移动到**脚本**文件夹中：
- en: '![](img/B18585_06_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_01.png)'
- en: 'Figure 6.1: Creating a Player Movement script in the character'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：在角色中创建玩家移动脚本
- en: Double-click the created script asset to open an IDE to edit the code.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击创建的脚本资产以打开IDE进行代码编辑。
- en: 'We are moving, and the movement is applied to every frame. So this script will
    use only the `Update` function or method, and we can remove `Start` (it is a good
    practice to remove the unused functions):'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在移动，这种移动应用于每个帧。因此，这个脚本将只使用`Update`函数或方法，我们可以移除`Start`（移除未使用的函数是一种良好的实践）：
- en: '![](img/B18585_06_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_02.png)'
- en: 'Figure 6.2: A component with just the Update event function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：仅包含Update事件函数的组件
- en: 'To move our object along its local forward axis (*z* axis), add the `transform.Translate(0,0,1);`
    line to the `Update` function, as shown in *Figure 6.3*:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使我们的对象沿着其局部前进轴（*z轴*）移动，请将`transform.Translate(0,0,1);`行添加到`Update`函数中，如图*图6.3*所示：
- en: Every component inherits a `Transform` field (to be specific, a **getter**)
    that is a reference to the `Transform` of the GameObject the component is placed
    in; it represents the sibling `Transform` of our component. Through this field,
    we can access the `Translate` function of the `Transform`, which will receive
    the offset to apply to the x, y, and z local coordinates.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都继承了一个`Transform`字段（具体来说，是一个**获取器**），它是对放置该组件的GameObject的`Transform`的引用；它代表我们组件的兄弟`Transform`。通过这个字段，我们可以访问`Transform`的`Translate`函数，该函数将接收应用于x、y和z局部坐标的偏移量。
- en: '![](img/B18585_06_03.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_03.png)'
- en: 'Figure 6.3: A simple Move Forward script'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：一个简单的向前移动脚本
- en: Save the file and play the game to see the movement. Ensure the camera is pointing
    at the character to properly see the effect of the script.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并玩游戏以查看移动。确保相机指向角色，以便正确查看脚本的效果。
- en: 'You will notice that the player is moving too fast. That’s because we are using
    a fixed speed of 1 meter, and because `Update` is executing all frames, we are
    moving 1 meter per frame. In a standard 30 FPS game, the player will move 30 meters
    per second, which is too much, but probably our computer is running the game with
    way more FPS than that. We can control the player’s speed by adding a `speed`
    field and using the value set in the editor instead of the fixed value of 1\.
    You can see one way to do this in the *Figure 6.4*, but remember the other options
    we discussed in *Chapter 5*, *Introduction to C# and Visual Scripting*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到玩家移动得太快。这是因为我们正在使用固定的1米速度，并且因为`Update`在所有帧上执行，所以我们每帧移动1米。在一个标准的30 FPS游戏中，玩家每秒将移动30米，这太多了，但可能我们的计算机以远高于这个FPS的速度运行游戏。我们可以通过添加`speed`字段并使用编辑器中设置的值而不是固定的1米值来控制玩家的速度。您可以在*图6.4*中看到一种实现方式，但请记住我们在*第5章*，*C#和视觉脚本简介*中讨论的其他选项：
- en: '![](img/B18585_06_04.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_04.png)'
- en: 'Figure 6.4: Creating a speed field and using it as the z speed of the movement
    script'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：创建速度场并将其用作移动脚本的z速度
- en: 'Now if you save the script to apply the changes and set the **Speed** of the
    player in the Editor, you can play the game and see the results. In my case, I
    used `0.1`, but you might need another value (more on this in the *Understanding
    Delta Time* section):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您保存脚本以应用更改并在编辑器中设置玩家的**速度**，您就可以玩游戏并查看结果。在我的情况下，我使用了`0.1`，但您可能需要另一个值（关于这一点，请参阅*理解Delta时间*部分）：
- en: '![](img/B18585_06_05.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_05.png)'
- en: 'Figure 6.5: Setting speed of 0.1 meters per frame'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：设置每帧0.1米的速度
- en: Now, for the Visual Scripting version, first remember to not mix the C# and
    Visual Scripting versions of our scripts, not because it is not possible, but
    because we want to keep things simple for now. So, you can either delete the script
    from the player object and add the Visual Scripting version, or you can create
    two player objects and enable and disable them to try both versions. I recommend
    creating one project for the C# version of the scripts and then creating a second
    project to experiment with the Visual Script version.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于视觉脚本版本，首先请记住不要混合我们的脚本的C#和视觉脚本版本，不是因为不可能，而是因为我们现在想保持事情简单。因此，您可以从玩家对象中删除脚本并添加视觉脚本版本，或者您可以创建两个玩家对象并启用和禁用它们以尝试两种版本。我建议为脚本的C#版本创建一个项目，然后创建第二个项目以实验视觉脚本版本。
- en: 'The Visual Scripting Graph of this script will look like the following image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的视觉脚本图将如下所示：
- en: '![](img/B18585_06_06.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_06.png)'
- en: 'Figure 6.6: Setting a speed of 0.1 meters per frame'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：设置每帧0.1米的速度
- en: As you can see, we added a **Script Machine** component to our `Player` GameObject.
    Then, we pressed the **New** button in the **Script Machine** component to create
    a new **Graph** called `PlayerMovement`. We also created a **Float** variable
    called `speed` with the value of `0.1`. In the **Graph**, we added the **On Update**
    event node and attached it to the **Translate (X,Y,Z)** node of the **Transform**,
    which, similarly to the C# version, will move along the local axes of the object.
    Finally, we connected the **Z** parameter pin of **Translate** to the `GetVariable`
    node representing the speed we created in the GameObject. If you compare this
    **Graph** with the code we used in the C# version, they are essentially the same
    **Update** method and `Translate` function. If you don’t remember how to create
    this **Graph**, you can go back to *Chapter 5*, *Introduction to C# and Visual
    Scripting*, to recap the process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在`Player`GameObject中添加了一个**脚本机**组件。然后，我们在**脚本机**组件中按下**新建**按钮，创建了一个名为`PlayerMovement`的新**图**。我们还创建了一个名为`speed`的**浮点**变量，其值为`0.1`。在**图**中，我们添加了**更新**事件节点并将其连接到**Transform**的**平移（X,Y,Z）**节点，这与C#版本类似，将沿着对象的局部轴移动。最后，我们将**平移**的**Z**参数引脚连接到表示我们在GameObject中创建的速度的`GetVariable`节点。如果您将这个**图**与我们在C#版本中使用的代码进行比较，它们基本上是相同的**更新**方法和`Translate`函数。如果您不记得如何创建这个**图**，您可以回到*第5章*，*C#和视觉脚本简介*，回顾这个过程。
- en: You will notice that the player will move automatically. Now let’s see how to
    execute the movement based on **player input** such as the keyboard and mouse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到玩家会自动移动。现在让我们看看如何根据**玩家输入**（如键盘和鼠标）来执行移动。
- en: Using Input
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用输入
- en: Unlike NPCs, we want the player’s movement to be driven by the player’s input,
    based on which keys they press, the mouse movement, and so on. To know whether
    a certain key has been pressed, such as the *Up* arrow, we can use the `Input.GetKey(KeyCode.W)`
    line, which will return a Boolean, indicating whether the key specified in the
    `KeyCode` enum is pressed, which is *W* in this case. We can combine the `GetKey`
    function with an `If` statement to make the translation execute when the key is
    pressed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与NPC不同，我们希望玩家的移动由玩家的输入驱动，基于他们按下的键、鼠标移动等。为了知道是否按下了某个键，例如*向上*箭头，我们可以使用`Input.GetKey(KeyCode.W)`这一行，它将返回一个布尔值，指示`KeyCode`枚举中指定的键是否被按下，在这种情况下是*W*。我们可以将`GetKey`函数与`If`语句结合使用，以便在按键时执行翻译。
- en: 'Let’s start by implementing the keyboard movement by following these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤实现键盘移动：
- en: 'Make the forward movement execute only when the *W* key is pressed with the
    code, as shown in the next screenshot:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下面的代码，使向前移动仅在按下*W*键时执行，如下一个截图所示：
- en: '![](img/B18585_06_07.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_07.png)'
- en: 'Figure 6.7: Conditioning the movement until the W key is pressed'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：在按下W键之前条件化移动
- en: 'We can add other movement directions with more `If` statements to move backward
    and *A* and *D* to move left and right, as shown in the following screenshot.
    Notice how we used the minus sign to inverse the speed when we needed to move
    in the opposite axis direction:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过添加更多的`If`语句来添加其他移动方向，例如向后移动使用*A*和*D*来移动左右，如下一个截图所示。注意我们如何使用负号在需要沿相反轴方向移动时反转速度：
- en: '![](img/B18585_06_08.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_08.png)'
- en: 'Figure 6.8: Checking the W, A, S, and D key pressure'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：检查W、A、S和D键的按下状态
- en: 'In case you also want to consider the arrow keys, you can use an `OR` inside
    `if`, as shown in the following screenshot:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您也想考虑箭头键，您可以在`if`语句中使用`OR`，如下面的截图所示：
- en: '![](img/B18585_06_09.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_09.png)'
- en: 'Figure 6.9: Checking the W, A, S, D, and arrow key pressure'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：检查W、A、S、D和箭头键的按下状态
- en: Save the changes and test the movement in **Play** mode.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改，并在**播放**模式下测试移动。
- en: Something to take into account is that, first, we have another way to map several
    keys to a single action by configuring the Input Manager—a place where action
    mappings can be created. Second, at the time of writing this, Unity has released
    a new Input System that is more extensible than this one.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，首先，我们还有另一种方法通过配置输入管理器将多个键映射到单个动作——这是一个可以创建动作映射的地方。其次，在撰写本文时，Unity发布了一个比这个更可扩展的新输入系统。
- en: For now, we will use this one because it is simple enough to make our introduction
    to scripting with Unity easier, but in games with complex input, it is recommended
    to look for more advanced tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将使用这个，因为它足够简单，可以使我们的Unity脚本入门更容易，但在具有复杂输入的游戏中，建议寻找更高级的工具。
- en: 'Now, for the Visual Scripting version, the graph will look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于可视化脚本版本，图表将看起来像这样：
- en: '![](img/B18585_06_10.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_10.png)'
- en: 'Figure 6.10: Input movement in Visual Scripting'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：可视化脚本中的输入移动
- en: As you can see, the graph has grown in size considerably compared to the C#
    version, which serves as an example of why developers prefer to code instead of
    using visual tools. Of course, we have several ways to split this graph into smaller
    chunks and make it more readable, and also consider I needed to squeeze the nodes
    together to be in the same image. Also, in the graph, we only see the example
    graph to move forward and backward, but you can easily extrapolate the necessary
    steps for lateral movement based on this one. As usual, you can also check the
    GitHub repository of the project to see the completed files.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，与C#版本相比，图表的大小显著增加，这可以作为开发者为什么更喜欢编码而不是使用可视化工具的例子。当然，我们有几种方法可以将这个图表拆分成更小的块，使其更易于阅读，并且还需要考虑我需要将节点挤压到同一张图片中。此外，在图表中，我们只看到了用于前进和后退的示例图表，但你可以很容易地根据这个图表推断出横向移动所需的步骤。像往常一样，你还可以检查项目的GitHub仓库以查看完成的文件。
- en: Looking at the graph, you can quickly observe all the similarities to the C#
    version; we chained `If` nodes to the **On Update** event node in a way that if
    the first `If` node condition is true, it will execute the **Translate** in the
    player’s forward direction. If that condition is false, we chained the **False**
    output node to another **If** that checks the pressure of the other keys, and
    in that case, we moved backward using the **Multiply (Scalar)** node to inverse
    the speed.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 观察图表，你可以快速观察到它与C#版本的相似之处；我们将`If`节点链接到**更新事件**节点，如果第一个`If`节点条件为真，它将在玩家的前方方向执行**平移**。如果该条件为假，我们将**False**输出节点链接到另一个检查其他按键压力的**If**节点，在这种情况下，我们使用**乘法（标量）**节点来反转速度。
- en: You can notice nodes like `If` that have more than one **Flow Output** pin to
    branch the execution of the code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以注意到像`If`这样的节点，它们有多个**流程输出**引脚来分支代码的执行。
- en: 'You can also notice the usage of the **GetKey (Key)** node, the Visual Scripting
    version of the same **GetKey** function we used previously. When looking at this
    node in the **Search** box, you will see all the versions of the function, and
    in this case, we selected the **GetKey(Key)** version; the one that receives a
    name (string) works differently, and we are not covering that one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以注意到**获取键（Key）**节点的使用，这是之前使用的相同**获取键**函数的可视化脚本版本。当你在**搜索**框中查看这个节点时，你会看到该函数的所有版本，在这种情况下，我们选择了**GetKey(Key)**版本；接收名称（字符串）的那个版本工作方式不同，我们不会介绍那个版本：
- en: '![](img/B18585_06_11.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_11.png)'
- en: 'Figure 6.11: All versions of Input GetKey'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：所有版本的输入获取键
- en: 'We also used the `Or` node to combine the two **GetKey (Key)** functions into
    one condition to give to the `If`. These conditional operators can be found in
    the **Logic** category of the **Search** box:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`Or`节点将两个**获取键（Key）**函数组合成一个条件，提供给`If`。这些条件运算符可以在**搜索**框的**逻辑**类别中找到：
- en: '![](img/B18585_06_12.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_12.png)'
- en: 'Figure 6.12: The Boolean Logic operators'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：布尔逻辑运算符
- en: One thing to highlight is the usage of the **Multiply** node to multiply the
    value of the speed variable by –1\. We needed to create a **Float Literal** node
    to represent the –1 value. Next, surely all programmers will notice some limitations
    regarding how we used the `If` node’s `True` and `False` output pins, but we will
    address that in a moment. Finally, consider that this implementation has the problem
    of blocking the second input read if the first is successful; we will discuss
    a way to fix this when we add rotation to our character later in this section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的一点是使用**乘法**节点将速度变量的值乘以-1。我们需要创建一个**浮点字面值**节点来表示-1这个值。接下来，当然所有程序员都会注意到我们如何使用`If`节点的`True`和`False`输出引脚存在一些限制，但我们会稍后解决这个问题。最后，考虑到这种实现方式在第一个输入成功读取时可能会阻塞第二个输入读取；当我们在本节稍后添加旋转时，我们将讨论一种修复这个问题的方法。
- en: 'Now, let’s implement the mouse controls. In this section, we will only cover
    rotation with mouse movement; we will shoot bullets in the next section: *Implementing
    spawning*. In the case of mouse movement, we can get a value saying how much the
    mouse has moved both horizontally and vertically. This value isn’t a Boolean but
    a number: a type of input usually known as an **axis**.The value of an axis will
    indicate the intensity of the movement, and the sign of that number will indicate
    the direction. For example, if Unity’s `"Mouse X"` axis says `0.5`, it means that
    the mouse moved to the right with a moderate speed, but if it says `-1`, it moved
    quickly to the left, and if there is no movement, it will say `0`. The same goes
    for sticks in gamepads; the axis named **Horizontal** represents the horizontal
    movement of the left stick in common joysticks, so if the player pulls the stick
    fully to the left, it will say `-1`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现鼠标控制。在本节中，我们只涵盖鼠标移动引起的旋转；在下一节中我们将实现发射子弹：*实现生成*。在鼠标移动的情况下，我们可以得到一个值，表示鼠标在水平和垂直方向上移动了多少。这个值不是一个布尔值，而是一个数字：通常被称为**轴**的输入类型。轴的值将指示移动的强度，而该数字的符号将指示方向。例如，如果Unity的`"Mouse
    X"`轴显示`0.5`，这意味着鼠标以适中的速度向右移动，但如果显示`-1`，则快速向左移动，如果没有移动，则显示`0`。游戏手柄的摇杆也是如此；名为**水平**的轴表示常见摇杆中左摇杆的水平移动，因此如果玩家将摇杆完全向左拉，它将显示`-1`。
- en: 'We can create our own axes to map other common joystick pressure-based controls,
    but for our game, the default ones are enough. To detect mouse movement, follow
    these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的轴来映射其他基于游戏手柄压力的常见控制，但对我们游戏来说，默认的轴就足够了。要检测鼠标移动，请按照以下步骤操作：
- en: 'Use the `Input.GetAxis` function inside `Update`, next to the movement `if`
    statements, as shown in the following screenshot, to store the value of this frame’s
    mouse movement into a variable:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`函数内部，紧挨着移动的`if`语句，使用`Input.GetAxis`函数，如以下截图所示，将这一帧鼠标移动的值存储到一个变量中：
- en: '![](img/B18585_06_13.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_13.png)'
- en: 'Figure 6.13: Getting the horizontal movement of the mouse'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：获取鼠标的水平移动
- en: 'Use the `transform.Rotate` function to rotate the character. This function
    receives the degrees to rotate in the x, y, and z axes. In this case, we need
    to rotate horizontally, so we will use the mouse movement value as the y-axis
    rotation, as shown in the next screenshot:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`transform.Rotate`函数来旋转角色。这个函数接收x、y和z轴上要旋转的度数。在这种情况下，我们需要水平旋转，所以我们将使用鼠标移动值作为y轴旋转，如下一个截图所示：
- en: '![](img/B18585_06_14.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_14.png)'
- en: 'Figure 6.14: Rotating the object horizontally based on mouse movement'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14：根据鼠标移动水平旋转对象
- en: 'If you save and test this, you will notice that the character will rotate but
    very quickly or slowly, depending on your computer. Remember, this kind of value
    needs to be configurable, so let’s create a `rotationSpeed` field to configure
    the speed of the player in the editor:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存并测试这段代码，你会注意到角色会旋转，但速度非常快或非常慢，这取决于你的电脑。记住，这类值需要可配置，所以让我们在编辑器中创建一个`rotationSpeed`字段来配置玩家的速度：
- en: '![](img/B18585_06_15.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_15.png)'
- en: 'Figure 6.15: The speed and rotation speed fields'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15：速度和旋转速度字段
- en: 'Now we need to multiply the mouse movement value by the speed, so, depending
    on the `rotationSpeed`, we can increase or reduce the rotation amount. As an example,
    if we set a value of `0.5` in the rotation speed, multiplying that value by the
    mouse movement will make the object rotate at half the previous speed, as shown
    in the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将鼠标移动值乘以速度，因此，根据`rotationSpeed`的值，我们可以增加或减少旋转量。例如，如果我们设置旋转速度为`0.5`，将这个值乘以鼠标移动将使对象以之前速度的一半旋转，如下面的截图所示：
- en: '![](img/B18585_06_16.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_16.png)'
- en: 'Figure 6.16: Multiplying the mouse movement by the rotation speed'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16：将鼠标移动乘以旋转速度
- en: 'Save the code and go back to the editor to set the rotation speed value. If
    you don’t do this, the object won’t rotate because the default value of the float
    type fields is `0`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存代码并返回编辑器设置旋转速度值。如果你不这样做，对象将不会旋转，因为浮点类型字段的默认值是`0`：
- en: '![](img/B18585_06_17.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_17.png)'
- en: 'Figure 6.17: Setting the rotation speed'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：设置旋转速度
- en: 'The Visual Scripting additions to achieve rotation will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现旋转的视觉脚本添加将看起来像这样：
- en: '![](img/B18585_06_18.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_18.png)'
- en: 'Figure 6.18: Rotating in Visual Scripting'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：在视觉脚本中旋转
- en: The first thing to notice here is the usage of the **Sequence** node. An output
    pin can only be attached to one other node, but in this case, **On Update** needs
    to do two different things, to rotate and to move, each one being independent
    of the other. **Sequence** is a node that will execute all its output pins one
    after the other, regardless of the results of each one. You can specify the number
    of output pins in the **Steps** input box; in this example, two is enough.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要注意的第一件事是**Sequence**节点的使用。一个输出引脚只能连接到另一个节点，但在这个情况下，**On Update**需要执行两件不同的事情，旋转和移动，每件都是独立的。**Sequence**是一个节点，它将依次执行所有输出引脚，而不考虑每个节点的结果。你可以在**Steps**输入框中指定输出引脚的数量；在这个例子中，两个就足够了。
- en: In the output pin `0`, the first one, we added the rotation code, which is pretty
    self-explanatory given it is essentially the same as the movement code with slightly
    different nodes (**Rotate (X, Y, Z)** and **GetAxis**). Then, to Output Pin 1,
    we attached the `If` that checks the movement input—the one we did at the beginning
    of this section. This will cause the rotation to be executed first and the movement
    second.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出引脚`0`，第一个引脚，我们添加了旋转代码，鉴于它基本上与移动代码相同，只是节点略有不同（**Rotate (X, Y, Z)**和**GetAxis**）。然后，我们将`If`节点连接到输出引脚1，这是我们在本节开头所做的。这将导致旋转先执行，然后是移动。
- en: Regarding the limitation we mentioned before, it’s basically the fact we cannot
    execute both **Forward** and **Backward** rotations, given that if the forward
    movement keys are pressed, the first `If` will be true. Because the backward key
    rotation is checked in the false output pin, they won’t be checked in such cases.
    Of course, as our first movement script it might be enough but consider the lateral
    movement. If we continue the `If` chaining using `True` and `False` output pins,
    we will have a scenario where we can only move in one direction. So we cannot
    combine, for example, `Forward` and `Right` to move diagonally.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们之前提到的限制，基本上是因为我们无法同时执行**前进**和**后退**旋转，因为如果按下前进移动键，第一个`If`语句将为真。由于后退键旋转是在假输出引脚上检查的，所以在这种情况下它们不会被检查。当然，作为我们的第一个移动脚本，可能已经足够了，但考虑横向移动。如果我们继续使用`True`和`False`输出引脚来链接`If`语句，我们将面临只能在一个方向上移动的情况。因此，我们不能组合例如`Forward`和`Right`来斜向移动。
- en: 'A simple solution to this issue is to put the `If` nodes in the sequence instead
    of chaining them, so all the `If` nodes are checked, as the original C# did. You
    can see an example of this in the next image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是将`If`节点放在序列中而不是链接它们，这样所有的`If`节点都会被检查，就像原始的C#一样。你可以在下一张图片中看到一个例子：
- en: '![](img/B18585_06_19.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_19.png)'
- en: 'Figure 6.19: Sequencing Ifs'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：序列化If语句
- en: Something to consider here is that the chaining of the `Ifs` and any kind of
    node can be removed by right-clicking the circle pins on both ends of the line
    that connects them. Now that we have completed our movement script, we need to
    refine it to work in every machine by exploring the concept of Delta Time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的是，可以通过右键单击连接它们的线条两端圆形引脚来移除`If`语句和任何类型的节点的链接。现在我们已经完成了我们的移动脚本，我们需要通过探索Delta时间概念来对其进行细化，以便在每台机器上都能正常工作。
- en: Understanding Delta Time
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Delta时间
- en: Unity’s **Update** loop executes as fast as the computer can. You can specify
    in Unity the desired frame rate, but achieving that depends exclusively on whether
    your computer can reach that, which depends on lots of factors, not only hardware,
    so you cannot expect to always have consistent FPS. You must code your scripts
    to handle every possible scenario. Our current script is moving at a certain speed
    per frame, and the *per frame* part is important here.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的**Update**循环以计算机能够达到的速度执行。你可以在Unity中指定所需的帧率，但能否实现这完全取决于你的电脑能否达到这个速度，这又取决于许多因素，而不仅仅是硬件，所以你不能期望总是有稳定的FPS。你必须编写代码来处理所有可能的情况。我们当前的脚本是以每帧一定的速度移动的，这里的**每帧**部分很重要。
- en: We have set the movement speed to 0.1, so if my computer runs the game at 120
    FPS, the player will move 12 meters per second. Now, what happens on a computer
    where the game runs at 60 FPS? As you may guess, it will move only 6 meters per
    second, making our game have inconsistent behavior across different computers.
    This is where Delta Time saves the day.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将移动速度设置为0.1，所以如果我的电脑以120 FPS运行游戏，玩家将每秒移动12米。那么，在游戏以60 FPS运行的电脑上会发生什么呢？正如你可能猜到的，它将只以每秒6米的速度移动，使得我们的游戏在不同电脑上具有不一致的行为。这就是Delta时间发挥作用的地方。
- en: '**Delta Time** is a value that tells us how much time has passed since the
    previous frame. This time depends a lot on our game’s graphics, number of entities,
    physics bodies, audio, and countless aspects that will dictate how fast your computer
    can process a frame. As an example, if your game runs at 10 FPS, it means that,
    in a second, your computer can process the `Update` loop 10 times, meaning that
    each loop takes approximately `0.1` seconds; in the frame, Delta Time will provide
    that value. In the next diagram, you can see an example of 4 frames taking different
    times to process, which can happen in real-life cases:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间差**是一个告诉我们自上一帧以来过去了多少时间的值。这个时间很大程度上取决于我们的游戏图形、实体数量、物理体、音频以及无数将决定你的电脑处理帧速度的方面。例如，如果你的游戏以10
    FPS运行，这意味着在一秒钟内，你的电脑可以处理`Update`循环10次，这意味着每个循环大约需要`0.1`秒；在帧中，时间差将提供这个值。在下一张图中，你可以看到一个例子，4个帧处理不同时间，这在现实生活中可能会发生：'
- en: '![](img/B18585_06_20.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_20.png)'
- en: 'Figure 6.20: Delta Time values varying in different frames of the game'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：游戏不同帧中的时间差值变化
- en: 'Here, we need to code in such a way as to change the *per frame* part of the
    movement to *per second*; we need to have consistent movement per second across
    different computers. A way to do that is to move proportionally to the Delta Time:
    the higher the Delta Time value, the longer that frame is, and the further the
    movement should be to match the real time that has passed since the last update.
    We can think about our `speed` field’s current value in terms of `0.1` meters
    per second; our Delta Time saying `0.5` means that half a second has passed, so
    we should move half the speed, `0.05`.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要编写代码以将移动的**每帧**部分改为**每秒**；我们需要在不同电脑上保持每秒一致的移动。实现这一点的办法是按比例移动到时间差：时间差值越高，帧越长，移动应该越远，以匹配自上次更新以来经过的真实时间。我们可以用`0.1`米每秒来考虑我们的`speed`字段当前值；我们的时间差说`0.5`意味着半秒已经过去，所以我们应该移动一半的速度，`0.05`。
- en: After two frames a second have passed, the sum of the movements of the frames
    (2 x 0.05) matches the target speed, `0.1`. Delta Time can be interpreted as the
    percentage of a second that has passed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 经过两帧一秒后，帧移动的总和（2 x 0.05）与目标速度`0.1`相匹配。时间差可以解释为已经过去的一秒的百分比。
- en: 'To make the Delta Time affect our movement, we should simply multiply our speed
    by Delta Time every frame because the Delta Time can be different every frame,
    so let’s do that:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要让时间差影响我们的移动，我们只需在每一帧将速度乘以时间差即可，因为时间差可能每帧都不同，所以让我们这样做：
- en: 'We access Delta Time using Time.deltaTime. We can start affecting the movement
    by multiplying the Delta Time in every Translate:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用Time.deltaTime来访问时间差。我们可以通过在每次Translate中乘以时间差来开始影响移动：
- en: '![](img/B18585_06_21.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_21.png)'
- en: 'Figure 6.21: Multiplying speed by Delta Time'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：将速度乘以时间差
- en: 'We can do the same with the rotation speed, by chaining the mouse and speed
    multiplications:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过链式连接鼠标和速度乘法来对旋转速度做同样的事情：
- en: '![](img/B18585_06_22.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_22.png)'
- en: 'Figure 6.22: Applying Delta Time to the rotation code'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：将时间差应用于旋转代码
- en: If you save and play the game, you will notice that the movement will be slower
    than before. That’s because now `0.1` is the movement per second, meaning `10`
    centimeters per second, which is pretty slow; try raising those values. In my
    case, `10` for speed and `180` for rotation speed was enough, but the rotation
    speed depends on the player’s preferred sensibility, which can be configurable,
    but let’s keep that for another time.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存并播放游戏，你会注意到移动会比之前慢。这是因为现在`0.1`是每秒的移动量，意味着每秒10厘米，这相当慢；尝试增加这些值。在我的情况下，速度为`10`，旋转速度为`180`就足够了，但旋转速度取决于玩家的偏好灵敏度，这可以配置，但让我们留到以后再说。
- en: 'The Visual Scripting change for rotation will look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转的可视化脚本更改将看起来像这样：
- en: '![](img/B18585_06_23.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_23.png)'
- en: 'Figure 6.23: Applying Delta Time to Rotate Visual Script'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：将时间差应用于旋转可视化脚本
- en: For movement, you can easily extrapolate from this example or remember to check
    the project on GitHub. We simply chained another **Multiply** node with **Get
    Delta Time**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动，你可以轻松地从这个例子中推断出来，或者记得检查GitHub上的项目。我们只是简单地连接了另一个**乘法**节点和**获取时间差**。
- en: We just learned how to mix the Input System of Unity, which tells us about the
    state of the keyboard, mouse, and other input devices, with the basic `Transform`
    movement functions. This way, we can start making our game feel more dynamic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何混合Unity的输入系统，它告诉我们关于键盘、鼠标和其他输入设备的状态，以及基本的`Transform`移动函数。这样，我们可以开始使我们的游戏感觉更加动态。
- en: Now that we have finished the player’s movement, let’s discuss how to make the
    player shoot bullets using `Instantiate` functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了玩家的移动，让我们讨论如何使用`Instantiate`函数让玩家射击子弹。
- en: Implementing spawning
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现生成
- en: We have created lots of objects in the editor that define our level, but once
    the game begins, and according to the player’s actions, new objects must be created
    to better fit the scenarios generated by player interaction. Enemies might need
    to appear after a while, or bullets must be created according to the player’s
    input; even when enemies die, there’s a chance of spawning a power-up. This means
    that we cannot create all the necessary objects beforehand but should create them
    dynamically, and that’s done through scripting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在编辑器中创建了大量的对象来定义我们的关卡，但一旦游戏开始，根据玩家的操作，必须创建新的对象以更好地适应玩家交互生成的场景。敌人可能过一段时间后出现，或者必须根据玩家的输入创建子弹；即使敌人死亡，也有可能生成一个道具。这意味着我们无法事先创建所有必要的对象，而应该动态地创建它们，这通过脚本完成。
- en: 'In this section, we will examine the following spawning concepts:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查以下生成概念：
- en: Spawning objects
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成对象
- en: Timing actions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时动作
- en: Destroying objects
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁对象
- en: We will start seeing the Unity `Instantiate` function, which allows us to create
    instances of Prefabs at runtime, such as when pressing a key, or in a time-based
    fashion, such as making our enemy spawn bullets once every certain amount of time.
    Also, we will learn how to destroy these objects to prevent our scene from starting
    to perform badly due to too many objects being processed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始看到Unity的`Instantiate`函数，它允许我们在运行时创建Prefab的实例，例如在按下一个键时，或者以基于时间的模式，例如让我们的敌人每隔一定时间发射一次子弹。此外，我们还将学习如何销毁这些对象，以防止场景因为处理过多的对象而开始表现不佳。
- en: Let’s start with how to shoot bullets according to the player’s input.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根据玩家输入如何射击子弹开始。
- en: Spawning objects
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成对象
- en: To spawn an object in runtime or **Play** mode, we need a description of the
    object, which components it has, and its settings and possible sub-objects. You
    might be thinking about Prefabs here, and you are right; we will use an instruction
    that will tell Unity to create an instance of a Prefab via scripting. Remember
    that an instance of a Prefab is an object created based on the Prefab—basically
    a clone of the original one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时或**播放**模式下生成一个对象，我们需要描述该对象，它具有哪些组件，以及其设置和可能的子对象。你可能在这里想到了Prefab，你是对的；我们将使用一个指令来告诉Unity通过脚本创建Prefab的实例。记住，Prefab的实例是基于Prefab创建的对象——基本上是原始对象的克隆。
- en: 'We will start with shooting player’s bullets, so first let’s create the bullet
    Prefab by following these steps:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从射击玩家的子弹开始，所以首先让我们按照以下步骤创建子弹Prefab：
- en: Create a sphere in GameObject | 3D Object | Sphere. You can replace the sphere
    mesh with another bullet model if you want, but we will keep the sphere in this
    example for now.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GameObject | 3D Object | 球体中创建一个球体。如果你想，可以用另一个子弹模型替换球体网格，但在这个例子中我们将保持球体。
- en: Rename the sphere `Bullet`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体重命名为`Bullet`。
- en: Create a material by clicking on the **+** button of the Project window, choosing
    the option **Material**, and calling it `Bullet`. Remember to place it inside
    the `Materials` folder.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击项目窗口的**+**按钮，选择**材质**选项，并将其命名为`Bullet`来创建一个材质。请记住将其放置在`Materials`文件夹内。
- en: 'Check the **Emission** checkbox in the material and set the **Emission Map**
    and **Base Map** colors to red. Remember, the emission color will make the bullet
    shine, especially with the bloom effect in our post-processing volume:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质中勾选**发射**复选框，并将**发射贴图**和**基础贴图**颜色设置为红色。记住，发射颜色会使子弹发光，尤其是在我们的后期处理体积中带有光晕效果：
- en: '![](img/B18585_06_24.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_24.png)'
- en: 'Figure 6.24: Creating a red bullet material with emission color'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：创建带有发射颜色的红色子弹材质
- en: Apply the **Material** to the **Sphere** by dragging the material to it.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将材质拖动到球体上来应用**材质**。
- en: Set the Scale to a smaller value—`0.3, 0.3, 0.3` worked in my case.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将缩放设置为更小的值——`0.3, 0.3, 0.3`在我的情况下是有效的。
- en: Create a script called `ForwardMovement` to make the bullet constantly move
    forward at a fixed speed. You can create it both with C# and Visual Scripting,
    but for simplicity, we are only going to use C# in this case.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ForwardMovement`的脚本，使子弹以固定的速度不断向前移动。你可以用C#和视觉脚本创建它，但为了简单起见，我们在这个例子中只使用C#。
- en: I suggest you try to solve this by yourself first and look at the screenshot
    in the next step with the solution later as a little challenge to recap the movement
    concepts we saw previously. If you don’t recall how to create a script, please
    look at *Chapter 5*, *Introduction to C# and Visual Scripting*, and check the
    previous section to see how to move objects.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我建议你先自己尝试解决这个问题，然后在下一步查看带有解决方案的截图，作为一个小挑战来回顾我们之前看到的运动概念。如果你不记得如何创建脚本，请查看*第5章*，*C#和视觉脚本简介*，并查看前面的部分以了解如何移动对象。
- en: 'The next screenshot shows you what the script should look like:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个截图显示了脚本应该是什么样子：
- en: '![](img/B18585_06_25.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_25.png)'
- en: 'Figure 6.25: A simple ForwardMovement script'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：一个简单的ForwardMovement脚本
- en: 'Add the script (if not already there) to the bullet and set the speed to a
    value you see fit. Usually, bullets are faster than the player but that depends
    on the game experience you want to get. In my case, `20` worked fine. Test it
    by placing the bullet near the player and playing the game:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本（如果尚未添加）添加到子弹中，并将速度设置为合适的值。通常，子弹比玩家移动得快，但这取决于你想要获得的游戏体验。在我的情况下，`20`就足够了。通过将子弹放置在玩家附近并玩游戏来测试它：
- en: '![](img/B18585_06_26.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_26.png)'
- en: 'Figure 6.26: A ForwardMovement script in the bullet'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：子弹中的ForwardMovement脚本
- en: 'Drag the bullet `GameObject` instance to the `Prefabs` folder to create a **Bullet**
    Prefab. Remember that the Prefab is an asset that has a description of the created
    bullet, like a blueprint of how to create a bullet:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将子弹`GameObject`实例拖到`Prefab`文件夹中创建一个**子弹**预制件。记住，预制件是一个资产，它描述了创建的子弹，就像创建子弹的蓝图：
- en: '![](img/B18585_06_27.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_27.png)'
- en: 'Figure 6.27: Creating a Prefab'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：创建预制件
- en: Remove the original bullet from the scene; we will use the Prefab to create
    bullets when the player presses a key (if ever).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中移除原始子弹；当玩家按下键时（如果有的话），我们将使用预制件来创建子弹。
- en: 'Now that we have our bullet Prefab, it is time to instantiate it (clone it)
    when the player presses a key. To do that, follow these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了子弹预制件，是时候在玩家按下键时实例化它（克隆它）了。为此，请按照以下步骤操作：
- en: Create and add a script to the player’s `GameObject` called `PlayerShooting`
    and open it.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并添加一个名为`PlayerShooting`的脚本到玩家的`GameObject`中，并打开它。
- en: We need a way for the script to have access to the Prefab to know which Prefab
    to use from probably the dozens we will have in our project. All of the data our
    script needs, which depends on the desired game experience, is in the form of
    a field, such as the speed field used so far. So in this case, we need a field
    of the `GameObject` type—a field that can reference or point to a specific Prefab,
    which can be set using the editor.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种方法让脚本能够访问预制件，以便知道从我们可能在我们项目中拥有的几十个预制件中选择哪一个。我们脚本所需的所有数据，这些数据取决于期望的游戏体验，都是以字段的形式存在的，例如迄今为止使用的速度字段。因此，在这种情况下，我们需要一个`GameObject`类型的字段——一个可以引用或指向特定预制件的字段，这可以通过编辑器来设置。
- en: 'Adding the field code would look like this:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加字段代码看起来像这样：
- en: '![](img/B18585_06_28.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_28.png)'
- en: 'Figure 6.28: The Prefab reference field'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：预制件参考字段
- en: As you might have guessed, we can use the `GameObject` type to not only reference
    Prefabs but also other objects. Imagine an enemy AI needing a reference to the
    player object to get its position, using `GameObject` to link the two objects.
    The trick here is considering that Prefabs are just regular GameObjects that live
    outside the scene; you cannot see them, but they are in memory, ready to be copied
    or instantiated. You will only see them through copies or instances that are placed
    in the scene with scripting or via the editor, as we have done so far.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，我们可以使用`GameObject`类型来不仅引用预制件，还可以引用其他对象。想象一下，一个敌人AI需要引用玩家对象来获取其位置，使用`GameObject`来连接这两个对象。这里的技巧是考虑到预制件只是存在于场景外的普通`GameObject`；你无法看到它们，但它们在内存中，准备被复制或实例化。你只能通过在场景中放置的副本或实例来看到它们，就像我们迄今为止所做的那样，通过脚本或编辑器。
- en: 'In the editor, click on the circle toward the right of the property and select
    the `Bullet` Prefab. Another option is to just drag the `Bullet` Prefab to the
    property. This way, we tell our script that the bullet to shoot will be that one.
    Remember to drag the Prefab and not the bullet in the scene (that one should be
    deleted by now):'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，点击属性右侧的圆圈并选择 `Bullet` Prefab。另一种选择是将 `Bullet` Prefab 直接拖到属性上。这样，我们告诉我们的脚本要射击的子弹将是那个。记住，要拖动
    Prefab 而不是场景中的子弹（那个现在应该已经被删除了）：
- en: '![](img/B18585_06_29.png)Figure 6.29: Setting the Prefab reference to point
    the bullet'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B18585_06_29.png)图 6.29：设置 Prefab 引用以指向子弹'
- en: 'We will shoot the bullet when the player presses the left mouse button, so
    place the proper if statement to handle that in the Update event function, like
    the one shown in the next screenshot:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家按下左鼠标按钮时，我们将射击子弹，所以请在 Update 事件函数中放置适当的 if 语句来处理它，就像下一个截图所示：
- en: '![](img/B18585_06_30.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_30.png)'
- en: 'Figure 6.30: Detecting the pressure of the left mouse button'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.30：检测左鼠标按钮的压力
- en: You will notice that this time, we used GetKeyDown instead of GetKey, the former
    being a way to detect the exact frame the pressure of the key started; this if
    statement will execute its code only in that frame, and until the key is released
    and re-pressed, it won’t enter again. This is one way to prevent bullets from
    spawning in every frame, but just for fun, you can try using GetKey instead to
    check how it would behave. Also, KeyCode.Mouse0 is the mouse button number that
    belongs to left-click, KeyCode.Mouse1 is the right-click, and KeyCode.Mouse2 is
    the middle click.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到这次，我们使用了 GetKeyDown 而不是 GetKey，前者是一种检测键压力开始的确切帧的方法；这个 if 语句只会在那个帧执行其代码，直到键被释放并重新按下，它才不会再次进入。这是防止子弹在每一帧生成的一种方法，但为了好玩，你可以尝试使用
    GetKey 来检查它会如何表现。此外，KeyCode.Mouse0 是属于左键点击的鼠标按钮编号，KeyCode.Mouse1 是右键点击，KeyCode.Mouse2
    是中键点击。
- en: 'Use the Instantiate function to clone the Prefab, passing the reference to
    it as the first parameter. This will create a clone of the previously mentioned
    Prefab that will be placed in the scene:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Instantiate 函数来克隆 Prefab，将对其的引用作为第一个参数传递。这将创建一个之前提到的 Prefab 的副本，并将其放置在场景中：
- en: '![](img/B18585_06_31.png)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_31.png)'
- en: 'Figure 6.31: Instantiating the Prefab'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 6.31：实例化 Prefab
- en: 'If you save the script and play the game, you will notice that when you press
    the mouse, a bullet will be spawning, but probably not in the place you are expecting.
    If you don’t see it, try to check the Hierarchy for new objects; it will be there.
    The problem here is that we didn’t specify the desired spawn position, and we
    have two ways of setting that, which we will see in the next steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存脚本并播放游戏，你会注意到当你按下鼠标时，会生成子弹，但可能不是你期望的位置。如果你看不到它，试着检查 Hierarchy 中的新对象；它会在那里的。这里的问题是我们没有指定期望的生成位置，我们有两种方法可以设置它，我们将在接下来的步骤中看到：
- en: 'The first way is to use the `transform.position` and `transform.rotation` inherited
    fields from `MonoBehaviour`, which will tell us our current position and rotation.
    We can pass them as the second and third parameters of the `Instantiate` function,
    which will understand that this is the place we want our bullet to appear. Remember
    that it is important to set the rotation to make the bullet face the same direction
    as the player, so it will move that way:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一种方法是使用从 `MonoBehaviour` 继承的 `transform.position` 和 `transform.rotation` 继承字段，这将告诉我们我们的当前位置和旋转。我们可以将它们作为
    `Instantiate` 函数的第二个和第三个参数传递，这样它就会明白这是我们希望子弹出现的位置。记住，设置旋转很重要，这样子弹就会面向与玩家相同的方向，以便它能够那样移动：
- en: '![](img/B18585_06_32.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_32.png)'
- en: 'Figure 6.32: Instantiating the Prefab in our position and rotation'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.32：在我们的位置和旋转中实例化 Prefab
- en: 'The second way is by using the previous version of `Instantiate`, but saving
    the reference returned by the function, which will be pointing to the clone of
    the Prefab. This allows us to change whatever we want from it. In this case, we
    will need the following three lines; the first will instantiate and capture the
    clone reference, the second will set the position, and the third the rotation.
    We will also use the `transform.position` field of the clone, but this time to
    change its value by using the `=` (assignment) operator:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是通过使用 `Instantiate` 的前一个版本，但保存函数返回的引用，这将指向Prefab的克隆。这允许我们从中更改任何我们想要的内容。在这种情况下，我们需要以下三行；第一行将实例化和捕获克隆引用，第二行将设置位置，第三行设置旋转。我们还将使用克隆的
    `transform.position` 字段，但这次使用 `=`（赋值）运算符来更改其值：
- en: '![](img/B18585_06_33.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_33.png)'
- en: 'Figure 6.33: The longer version of instantiating a Prefab in a specific position'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33：在特定位置实例化Prefab的较长版本
- en: Remember that you can check the project’s GitHub repository linked in the *Preface*
    to see the full script finished. Now you can save the file with one of the versions
    and try to shoot.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，您可以在 *前言* 中链接的项目GitHub仓库查看完整的脚本。现在您可以使用其中一个版本保存文件并尝试射击。
- en: 'If you try the script so far, you should see the bullet spawn in the player’s
    position, but in our case, it will probably be the floor. The problem here is
    that the player’s character pivot is there, and usually, every humanoid character
    has the pivot in their feet. We have several ways to fix that. The most flexible
    one is to create a **Shoot Point**, an empty GameObject child of the player, placed
    in the position we want the bullet to spawn. We can use the position of that object
    instead of the player’s position by following these steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试到目前为止的脚本，您应该会看到子弹在玩家的位置生成，但在我们的情况下，它可能是在地板上。这里的问题是玩家的角色枢轴就在那里，通常，每个类人角色都有枢轴在他们的脚上。我们有几种方法可以解决这个问题。最灵活的一种是创建一个
    **射击点**，它是玩家的一个空GameObject子对象，放置在我们想要子弹生成的位置。我们可以使用该对象的位置而不是玩家的位置，通过以下步骤：
- en: Create an empty `GameObject` in **GameObject | Create Empty**. Rename it `ShootPoint`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **GameObject | 创建空对象** 中创建一个空 `GameObject`。将其重命名为 `ShootPoint`。
- en: 'Make it a child of the player’s GameObject and place it where you want the
    bullet to appear, probably a little higher and further forward:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它作为玩家的GameObject的子对象，放置在您想要子弹出现的位置，可能稍微高一点和更向前一些：
- en: '![](img/B18585_06_34.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_34.png)'
- en: 'Figure 6.34: An empty ShootPoint object placed inside the character'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34：放置在角色内部的空ShootPoint对象
- en: 'As usual, to access the data of another object, we need a reference to it,
    such as the Prefab reference, but this time it needs to point to our shoot point.
    We can create another `GameObject` type field, but this time drag `ShootPoint`
    instead of the Prefab. The script and the object set would look as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，要访问另一个对象的数据，我们需要一个对该对象的引用，例如Prefab引用，但这次它需要指向我们的射击点。我们可以创建另一个 `GameObject`
    类型字段，但这次拖动 `ShootPoint` 而不是Prefab。脚本和对象集将如下所示：
- en: '![](img/B18585_06_35.png)![](img/B18585_06_36.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_35.png)![](img/B18585_06_36.png)'
- en: 'Figure 6.35: The Prefab and ShootPoint fields and how they are set in the editor'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：Prefab和ShootPoint字段以及它们在编辑器中的设置
- en: 'We can access the position of the `ShootPoint` by using the `transform.position`
    field of it again, as shown in the following screenshot:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `ShootPoint` 的 `transform.position` 字段再次访问其位置，如下面的截图所示：
- en: '![](img/B18585_06_37.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_37.png)'
- en: 'Figure 6.36: The Prefab and ShootPoint fields and how they are set in the editor'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：Prefab和ShootPoint字段以及它们在编辑器中的设置
- en: 'The Visual Scripting version of **ForwardMovement** will look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**ForwardMovement** 的视觉脚本版本将看起来像这样：'
- en: '![](img/B18585_06_38.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_38.png)'
- en: 'Figure 6.37: ForwardMovement with Visual Scripting'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：使用视觉脚本的前进运动
- en: 'And `PlayerShooting` will look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerShooting` 将看起来像这样：'
- en: '![](img/B18585_06_39.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_39.png)'
- en: 'Figure 6.38: Instantiating in the PlayerShooting Visual Script'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.38：PlayerShooting视觉脚本中的实例化
- en: As you can see, we added a second **Script Machine** component with a new graph
    called **Player Shooting**. We also added a new variable, `bulletPrefab`, of type
    `GameObject` and dragged the **Bullet** Prefab to it, and a second `GameObject`
    typed variable called `shootPoint`, to have the reference to the bullet’s spawn
    position. The rest of the script is essentially the counterpart of the C# version
    without any major differences. Something to highlight here is how we connected
    the `Transform GetPosition` and `Transform GetRotation` nodes to the `GetVariable`
    node belonging to the `shootPoint`; in this way, we are accessing the position
    and rotation of the shooting point. If you don’t specify that, it will use the
    player’s position and rotation, which in the case of our model is in the player’s
    character’s feet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们添加了一个名为**Player Shooting**的新图的第二个**脚本机器**组件。我们还添加了一个新的变量，`bulletPrefab`，类型为`GameObject`，并将**Bullet**预制体拖动到其中，以及一个名为`shootPoint`的第二个`GameObject`类型变量，以便引用子弹的生成位置。脚本的其他部分基本上是C#版本的对应物，没有太大差异。这里要强调的是，我们如何将`Transform
    GetPosition`和`Transform GetRotation`节点连接到`shootPoint`所属的`GetVariable`节点；这样，我们就可以访问射击点的位置和旋转。如果您没有指定，它将使用玩家的位置和旋转，在我们的模型中，这位于玩家角色的脚下。
- en: 'You will notice that now shooting and rotating with the mouse has a problem;
    when moving the mouse to rotate, the pointer will fall outside the **Game** View,
    and when clicking, you will accidentally click the editor, losing the focus on
    the **Game** View, so you will need to click the **Game** View again to regain
    focus and use input again. A way to prevent this is to disable the cursor while
    playing. To do this, follow these steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到现在使用鼠标射击和旋转存在问题；当移动鼠标进行旋转时，指针将超出**游戏视图**，当点击时，您会意外地点击编辑器，失去对**游戏视图**的焦点，因此您需要再次点击**游戏视图**以恢复焦点并再次使用输入。防止这种情况的一种方法是游戏时禁用光标。为此，请按照以下步骤操作：
- en: Add a `Start` event function to our Player Movement Script.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Start`事件函数添加到我们的`Player Movement Script`脚本中。
- en: 'Add the two lines you can see in the following screenshot to your script. The
    first one will make the cursor visible, and the second one will lock it in the
    middle of the screen, so it will never abandon the **Game** View. Consider the
    latter; you will need to reenable the cursor when you switch back to the main
    menu or the pause menu, to allow the mouse to click the UI buttons:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下截图中的两行代码添加到您的脚本中。第一行将使光标可见，第二行将锁定光标在屏幕中间，这样它就不会离开**游戏视图**。考虑后者；当您切换回主菜单或暂停菜单时，您需要重新启用光标，以便鼠标可以点击UI按钮：
- en: '![](img/B18585_06_40.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_40.png)'
- en: 'Figure 6.39: Disabling the mouse cursor'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.39：禁用鼠标光标
- en: Save and test this. If you want to stop the game, you could either press *Ctrl*
    + *Shift* + *P* (*Command* + *Shift* + *P* on Mac) or press the *Esc* key to reenable
    the mouse. Both options only work in the editor; in the real game, you will need
    to reset `Cursor.visible` to `true` and `Cursor.lockState` to `CursorLockMode.None`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并测试此脚本。如果您想停止游戏，可以按*Ctrl* + *Shift* + *P*（在Mac上为*Command* + *Shift* + *P*）或按*Esc*键重新启用鼠标。这两个选项仅在编辑器中有效；在真实游戏中，您需要将`Cursor.visible`重置为`true`，将`Cursor.lockState`重置为`CursorLockMode.None`。
- en: 'The Visual Scripting equivalent will look like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉脚本等效的代码如下所示：
- en: '![](img/B18585_06_41.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_41.png)'
- en: 'Figure 6.40: Disabling the mouse cursor in Visual Scripting'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.40：在视觉脚本中禁用鼠标光标
- en: Now that we have covered the basics of object spawning, let’s see an advanced
    example by combining it with timers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了对象生成的基础知识，让我们通过结合定时器来查看一个高级示例。
- en: Timing actions
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时动作
- en: Not entirely related to spawning, but usually used together, timing actions
    is a common task in video games. The idea is to schedule something to happen later;
    maybe we want the bullet to be destroyed after a while to prevent memory overflow,
    or we want to control the spawn rate of enemies or when they should spawn. That’s
    exactly what we are going to do in this section, starting with the second, the
    **enemy waves**.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与生成不完全相关，但通常一起使用，定时动作是视频游戏中的常见任务。想法是安排稍后发生某事；也许我们希望子弹过一段时间后销毁以防止内存溢出，或者我们想要控制敌人的生成速率或它们应该何时生成。这正是本节将要做的，从第二个开始，即**敌军波次**。
- en: The idea is that we want to spawn enemies at a certain rate in different moments
    of the game; maybe we want to spawn enemies from second 1 to 5 at a rate of 2
    per second, getting 10 enemies, and giving the player up to 20 seconds to finish
    them, programming another wave starting at 25 seconds. Of course, this depends
    a lot on the exact game you want, and you can start with an idea like this one
    and modify it after some testing to find the exact way you want the wave system
    to work. In our case, we will apply timing by implementing a simple wave system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是希望在游戏的各个时刻以一定的速率生成敌人；也许我们希望在 1 到 5 秒之间以每秒 2 个的速率生成敌人，总共生成 10 个敌人，并给玩家最多 20
    秒的时间来完成它们，然后在 25 秒时编程下一波。当然，这很大程度上取决于你想要的精确游戏，你可以从一个像这样的想法开始，并在测试后对其进行修改以找到你想要的波系统工作的确切方式。在我们的案例中，我们将通过实现一个简单的波系统来应用计时。
- en: 'First of all, we need an enemy, and for now, we will simply use the same 3D
    model we used for the player, but add a Forward Movement script to simply make
    it move forward; later in this book, we will add AI behavior to our enemies. I
    suggest you try to create this Prefab by yourself and look at the following steps
    once you have tried it, to check the correct answer:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个敌人，目前我们将简单地使用与玩家相同的 3D 模型，但添加一个 Forward Movement 脚本以使其向前移动；在本书的稍后部分，我们将为敌人添加
    AI 行为。我建议你自己尝试创建这个 Prefab，并在尝试后查看以下步骤，以检查正确答案：
- en: 'Drag the downloaded Character FBX model to the scene to create another instance
    of it, but rename it to `Enemy` this time:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将下载的 Character FBX 模型拖到场景中以创建它的另一个实例，但这次将其重命名为 `Enemy`：
- en: Add the `ForwardMovement` script created for the bullets but this time to `Enemy`,
    and set it at a speed of `10` for now.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将为子弹创建的 `ForwardMovement` 脚本添加到 `Enemy` 中，并暂时将其速度设置为 `10`。
- en: Drag the `Enemy` GameObject to the Project to create a Prefab based on that
    one; we will need to spawn it later. Remember to choose **Prefab Variant**, which
    will keep the Prefab linked with the original model to make the changes applied
    to the model automatically apply to the Prefab.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Enemy` GameObject 拖到项目中以创建基于该 GameObject 的 Prefab；我们稍后需要生成它。请记住选择 **Prefab
    Variant**，这将使 Prefab 与原始模型保持链接，以便对模型所做的更改自动应用到 Prefab 上。
- en: Remember also to destroy the original `Enemy` from the scene.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要记得从场景中销毁原始的 `Enemy`。
- en: 'Now, to schedule actions, we will use the `Invoke` functions to create timers.
    They are basic but enough for our requirements. Let’s use them by following these
    steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了安排动作，我们将使用 `Invoke` 函数来创建计时器。它们很简单，但对于我们的需求来说足够了。让我们按照以下步骤使用它们：
- en: Create an empty GameObject at one end of the base and call it `Wave1a`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基地的一端创建一个空 GameObject 并将其命名为 `Wave1a`。
- en: Create and add a script called `WaveSpawner` to it.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其创建并添加一个名为 `WaveSpawner` 的脚本。
- en: 'Our spawner will need four fields: the `Enemy` `Prefab` to spawn, the `startTime`
    of the wave, the `endTime`, and the spawn rate of the enemies (how much time should
    be between each spawn). The script and the settings will look like the following
    screenshot:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的生成器需要四个字段：要生成的 `Enemy` Prefab、波的 `startTime`、`endTime` 和敌人的生成速率（每个生成之间应该有多少时间）。脚本和设置将类似于以下截图：
- en: '![](img/B18585_06_42.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_42.png)'
- en: 'Figure 6.41: The fields of the wave spawner script'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.41：波生成器脚本的字段
- en: 'We will use the `InvokeRepeating` function to schedule a custom function to
    repeat periodically. You will need to schedule the repetition just once; Unity
    will remember that, so don’t do it every frame. This is a good reason to use the
    `Start` event function instead. The first argument of the function is a string
    (text between the quotation marks) with the name of the other function to execute
    periodically, and unlike `Start` or `Update`, you can name the function whatever
    you want. The second argument is the time to start repeating, our `startTime`
    field, in this case. Finally, the third argument is the repetition rate of the
    function—how much time needs to happen between each repetition—this being the
    `spawnRate` field. You can find how to call that function in the next screenshot,
    along with the custom `Spawn` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `InvokeRepeating` 函数来安排一个周期性重复的自定义函数。你需要只安排一次重复；Unity 会记住这一点，所以不要在每一帧都做。这是使用
    `Start` 事件函数的好理由。函数的第一个参数是一个字符串（引号之间的文本），包含要周期性执行的另一个函数的名称，与 `Start` 或 `Update`
    不同，你可以随意命名该函数。第二个参数是开始重复的时间，即我们的 `startTime` 字段。最后，第三个参数是函数的重复速率——每次重复之间需要多少时间——这是
    `spawnRate` 字段。你可以在下一个截图中找到如何调用该函数，以及自定义的 `Spawn` 函数：
- en: '![](img/B18585_06_43.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_43.png)'
- en: 'Figure 6.42: Scheduling a Spawn function to repeat'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.42：调度一个重复的Spawn函数
- en: 'Inside the `Spawn` function, we can put the spawning code as we know, using
    the `Instantiate` function. The idea is to call this function at a certain rate
    to spawn one enemy per call. This time, the spawn position will be in the same
    position as the spawner, so place it carefully:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Spawn`函数内部，我们可以像我们知道的，使用`Instantiate`函数来放置生成代码。想法是以一定的速率调用这个函数来生成每个调用一个敌人。这次，生成位置将与生成器相同，所以请小心放置：
- en: '![](img/B18585_06_44.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_44.png)'
- en: 'Figure 6.43: Instantiating in the Spawn function'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.43：在Spawn函数中实例化
- en: 'If you test this script by setting the Prefab `startTime` and `spawnRate` fields
    to some values greater than 0, you will notice that the enemies will start spawning
    but never stop, and you can see that we didn’t use the `endTime` field so far.
    The idea is to call the `CancelInvoke` function, the one function that will cancel
    all the `InvokeRepeating` calls we made, but after a while. We will delay the
    execution of `CancelInvoke` using the `Invoke` function, which works similarly
    to `InvokeRepeating`, but this one executes just once. In the next screenshot,
    you can see how we added an `Invoke` call to the `CancelInvoke` function in `Start`,
    using the `endTime` field as the time to execute `CancelInvoke`. This will execute
    `CancelInvoke` after a while, canceling the first `InvokeRepeating` call that
    spawns the Prefab:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过将Prefab的`startTime`和`spawnRate`字段设置为大于0的值来测试这个脚本，你会注意到敌人会开始生成但永远不会停止，你可以看到我们到目前为止还没有使用`endTime`字段。想法是调用`CancelInvoke`函数，这是我们用来取消所有`InvokeRepeating`调用的一个函数，但过一段时间后。我们将使用`Invoke`函数延迟执行`CancelInvoke`，它的工作方式与`InvokeRepeating`类似，但这个函数只执行一次。在下一张截图，你可以看到我们如何在`Start`中添加一个`Invoke`调用到`CancelInvoke`函数，使用`endTime`字段作为执行`CancelInvoke`的时间。这将延迟执行`CancelInvoke`，取消第一个生成Prefab的`InvokeRepeating`调用：
- en: '![](img/B18585_06_45.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_45.png)'
- en: 'Figure 6.44: Scheduling a Spawn repetition but canceling after a while with
    CancelInvoke'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.44：使用CancelInvoke取消Spawn重复调度
- en: This time, we used `Invoke`to delay the call to `CancelInvoke`. We didn’t create
    a custom function because `CancelInvoke` doesn’t receive arguments. If you need
    to schedule a function with arguments, you will need to create a wrapper function
    without parameters that calls the desired one and schedules it, as we did with
    `Spawn`, where the only intention is to call `Instantiate` with specific arguments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用了`Invoke`来延迟调用`CancelInvoke`。我们没有创建一个自定义函数，因为`CancelInvoke`不接受参数。如果你需要安排一个带有参数的函数，你需要创建一个没有参数的包装函数，该函数调用所需的函数并安排它，就像我们在`Spawn`中所做的那样，那里的唯一目的是用特定的参数调用`Instantiate`。
- en: 'Now you can save and set some real values to our spawner. In my case, I used
    the ones shown in the following screenshot:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以保存并设置一些真实值到我们的生成器。在我的例子中，我使用了以下截图所示的内容：
- en: '![](img/B18585_06_46.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_46.png)'
- en: 'Figure 6.45: Spawning enemies from second 1 to 5 of the gameplay every 0.5
    seconds, 2 per second'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.45：在游戏第1秒到第5秒内，每0.5秒生成2个敌人
- en: 'You should see the enemies being spawned one next to the other, and because
    they move forward, they will form a row of enemies. This behavior will change
    later with AI. Now, the Visual Scripting version will look like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到敌人一个接一个地生成，并且由于它们向前移动，它们将形成一排敌人。这种行为将在AI之后改变。现在，视觉脚本版本将看起来像这样：
- en: '![](img/B18585_06_47.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_47.png)'
- en: 'Figure 6.46: Spawning enemies in Visual Scripting'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.46：在视觉脚本中生成敌人
- en: While we could use the `InvokeRepeating` approach in Visual Scripting, here
    we can see some benefits of the Visual approach, given it sometimes has more flexibility
    than coding. In this case, we used the `Wait For Seconds` node at the beginning
    of the `Start`, a node that basically will hold the execution of the flow for
    a couple of seconds. This will create the initial delay we had in the original
    script; that’s why we used the `startTime` as the amount of `Delay`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在视觉脚本中使用`InvokeRepeating`方法，但在这里我们可以看到视觉方法的一些好处，因为它有时比编码更具灵活性。在这种情况下，我们在`Start`的开始处使用了`Wait
    For Seconds`节点，这个节点基本上会暂停流程的执行几秒钟。这将创建原始脚本中的初始延迟；这就是为什么我们使用了`startTime`作为`Delay`的量。
- en: Now, after the wait, we used a `For` loop; for this example, we changed the
    concept of the script, as we want to spawn a specific number of enemies instead
    of spawning during a time. The `For` loop is essentially a classic `For` that
    will repeat whatever is connected to the `Body` output pin the number of times
    specified by the `Last` input pin.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在等待之后，我们使用了一个`For`循环；在这个例子中，我们改变了脚本的概念，因为我们想要生成特定数量的敌人，而不是在一段时间内生成。`For`循环本质上是一个经典的`For`循环，它将重复连接到`Body`输出引脚的内容，重复次数由`Last`输入引脚指定的次数。
- en: We connected that pin to a variable to control the number of enemies we want
    to spawn. Then, we connected an `Instantiate` to the `Body` output pin of the
    `For` loop to instantiate our enemies, and then a `Wait For Seconds`, to stop
    the flow for a time before the loop can continue spawning enemies.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将那个引脚连接到一个变量，以控制我们想要生成的敌人数量。然后，我们将一个`Instantiate`连接到`For`循环的`Body`输出引脚，以实例化我们的敌人，然后是一个`Wait
    For Seconds`，在循环可以继续生成敌人之前停止流动一段时间。
- en: 'Something interesting is that if you play the game now, you will receive an
    error in the console that will look like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果你现在玩游戏，你将在控制台收到一个错误，看起来像这样：
- en: '![](img/B18585_06_48.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_48.png)'
- en: 'Figure 6.47: Error when using Wait nodes'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.47：使用等待节点时的错误
- en: 'You can even go back to the graph editor and see that the conflicting node
    will be highlighted in red:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以回到图编辑器，看到冲突的节点将以红色突出显示：
- en: '![](img/B18585_06_49.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_49.png)'
- en: 'Figure 6.48: Node causing the error'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.48：导致错误的节点
- en: The issue here is that in order for the `Wait For Seconds` nodes to work, you
    need to mark the `Start` event as a **Coroutine**. This will basically allow the
    event to be paused for an amount of time and be resumed later. The same concept
    exists in C#, but as it is simpler to implement here in Visual Scripting than
    in C#, we decided to go with this approach here.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，为了让“等待秒数”节点正常工作，你需要将“开始”事件标记为**协程**。这基本上允许事件暂停一段时间，然后稍后继续。这个概念在C#中同样存在，但由于在视觉脚本中实现起来比在C#中简单，我们决定在这里采用这种方法。
- en: To solve this error, just select the `On Start` event node and check the **Coroutine**
    checkbox in the **Graph Inspector** pane on the left of the **Script Graph** editor.
    If you don’t see it, consider clicking the **Info** button (circle with *i*) in
    the top-left part of the editor.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，只需选择“开始”事件节点，并在“脚本图”编辑器左侧的**图检视器**面板中勾选**协程**复选框。如果你看不到它，请考虑在编辑器的左上角点击**信息**按钮（带*i*的圆圈）。
- en: A coroutine is a function that can be paused and resumed later, and that’s exactly
    what the `Wait` node does. Coroutines also exist in `MonoBehaviours`, but let’s
    keep things simple for now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一个可以被暂停并在稍后继续执行的功能，这正是“等待”节点所做的事情。协程也存在于`MonoBehaviours`中，但现在让我们保持简单。
- en: '![](img/B18585_06_50.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_50.png)'
- en: 'Figure 6.49: Marking Start as a coroutine'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.49：将开始标记为协程
- en: Now that we have discussed timing and spawn, let’s discuss timing and `Destroy`
    to prevent our bullets from living forever in the memory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了时间和生成，让我们讨论时间和`Destroy`，以防止我们的子弹在内存中永远存在。
- en: Destroying objects
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁对象
- en: 'We can use the `Destroy` function to destroy object instances. The idea is
    to make the bullets have a script that schedules their own auto-destruction after
    a while to prevent them from living forever. We will create the script by following
    these steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Destroy`函数来销毁对象实例。想法是让子弹有一个脚本，在一段时间后安排自己的自动销毁，以防止它们永远存在于内存中。我们将通过以下步骤创建脚本：
- en: Select the Prefab of `Bullet` and add a script called `Autodestroy` to it, as
    you did with other objects using the **Add Component > New Script** option. This
    time, the script will be added to the Prefab, and each instance of the Prefab
    you spawn will have it.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“子弹”的预制件，并添加一个名为“Autodestroy”的脚本，就像你使用**添加组件 > 新脚本**选项对其他对象所做的那样。这次，脚本将被添加到预制件中，你生成的每个预制件实例都将拥有它。
- en: 'You can use the `Destroy` function, as shown in the next screenshot, to destroy
    the object just once in `Start`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用如图所示的`Destroy`函数，在`Start`中一次性销毁对象：
- en: '![](img/B18585_06_51.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_51.png)'
- en: 'Figure 6.50: Destroying an object when it starts'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.50：在开始时销毁对象
- en: The `Destroy` function expects the object to destroy as the first argument,
    and here, we are using the `gameObject` reference; a way to point to the GameObject
    our script is placed into to destroy it. If you use the `this` pointer instead
    of `GameObject`, we will be destroying only the `Autodestroy` component we are
    creating.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Destroy`函数期望将要销毁的对象作为第一个参数，在这里，我们使用`gameObject`引用；这是一种指向我们的脚本放置的GameObject并销毁它的方法。如果你使用`this`指针而不是`GameObject`，我们只会销毁我们创建的`Autodestroy`组件。'
- en: Of course, we don’t want the bullet to be destroyed as soon as it is spawned,
    so we need to delay the destruction. You may be thinking about using `Invoke`,
    but unlike most functions in Unity, `Destroy` can receive a second argument, which
    is the time to wait until destruction.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想子弹一出现就被销毁，因此我们需要延迟销毁。你可能正在考虑使用`Invoke`，但与Unity中的大多数函数不同，`Destroy`可以接收第二个参数，即等待销毁的时间。
- en: 'Create a delay field to use as the second argument of `Destroy`, as shown in
    the next screenshot:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个延迟字段，用作`Destroy`的第二个参数，如下一张截图所示：
- en: '![](img/B18585_06_52.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_52.png)'
- en: 'Figure 6.51: Using a field to configure the delay to destroy the object'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.51：使用字段配置销毁对象的延迟
- en: Set the `delay` field to a proper value; in my case, 5 was enough. Now check
    how the bullets despawn after a while by looking at them being removed from the
    Hierarchy.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`delay`字段设置为适当的值；在我的情况下，5就足够了。现在检查子弹过一段时间后如何从Hierarchy中移除，以查看其消失。
- en: 'The Visual Scripting equivalent will look like this:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视觉脚本中的等效操作将如下所示：
- en: '![](img/B18585_06_53.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_53.png)'
- en: 'Figure 6.52: Destroying in Visual Scripting'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.52：在视觉脚本中销毁
- en: Regarding this version, notice how we use the **Component Destroy (Obj, T)**
    version of the `Destroy` node, which includes the delay time.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个版本，注意我们如何使用**组件销毁（Obj, T）**版本的`Destroy`节点，它包括延迟时间。
- en: Look for the `Object Pool`concept, which is a way to recycle objects instead
    of creating them constantly; you will learn that sometimes creating and destroying
    objects is not that performant.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找`Object Pool`概念，这是一种回收对象而不是不断创建对象的方法；你会了解到有时创建和销毁对象并不那么高效。
- en: Now, we can create and destroy objects at will, which is something very common
    in Unity scripting. In the next section, we will discuss how to modify the scripts
    we have done so far to support the new Unity Input System.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以随意创建和销毁对象，这在Unity脚本中是非常常见的。在下一节中，我们将讨论如何修改我们迄今为止所编写的脚本以支持新的Unity输入系统。
- en: Using the new Input System
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的输入系统
- en: We have been using the **Input** class to detect the buttons and axes being
    pressed, and for our simple usage that is more than enough. But the default Unity
    input system has its limitations regarding extensibility to support new input
    hardware and mappings.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用**Input**类来检测被按下的按钮和轴，对于我们的简单使用来说，这已经足够了。但是，默认的Unity输入系统在扩展性方面有其局限性，无法支持新的输入硬件和映射。
- en: 'In this section, we will explore the following concepts:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下概念：
- en: Installing the new Input System
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新的输入系统
- en: Creating Input Mappings
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建输入映射
- en: Using Mappings in scripts
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本中使用映射
- en: Let’s start exploring how to install the new Input System.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索如何安装新的输入系统。
- en: Installing the new Input System
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装新的输入系统
- en: To start using the new Input System, it needs to be installed like any other
    package we have installed so far, using the **Package Manager**. The package is
    just called **Input System**, so go ahead and install it as usual. In this case
    we are using version 1.4.2, but a newer one may be available when you read this
    chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用新的输入系统，它需要像我们迄今为止安装的任何其他包一样安装，使用**包管理器**。这个包只是叫做**Input System**，所以继续像往常一样安装。在这种情况下我们使用的是版本1.4.2，但当你阅读这一章时可能有一个更新的版本可用。
- en: '![](img/B18585_06_54.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_54.png)'
- en: 'Figure 6.53: Installing the new Input System package'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.53：安装新的输入系统包
- en: 'By default, when you install the Input System, it will prompt you to enable
    the new Input System with a window like the one in the following image. If that
    appears, just click **Yes** and wait for Unity to restart:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你安装输入系统时，它将弹出一个窗口，如以下图像所示，提示你启用新的输入系统。如果出现这种情况，只需点击**是**并等待Unity重新启动：
- en: '![](img/B18585_06_55.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_55.png)'
- en: 'Figure 6.54: Switching the active Input System'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.54：切换活动输入系统
- en: If for some reason that didn’t appear, the other alternative is going to **Edit
    | Project Settings** and then going to **Player | Other Settings | Configuration**
    to set the **Active Input Handling** property to **Input System Package (New)**.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因没有出现，另一种选择是**编辑 | 项目设置**，然后转到**玩家 | 其他设置 | 配置**，将**活动输入处理**属性设置为**输入系统包（新**）。
- en: There’s an option called **Both** to keep both enabled, but let’s stick with
    just one.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**Both**的选项可以同时启用两者，但让我们坚持只使用一个。
- en: '![](img/B18585_06_56.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_56.png)'
- en: 'Figure 6.55: Switching the active Input System'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.55：切换活动输入系统
- en: Now that we have the system installed and set up, let’s explore how to create
    the Input Mappings needed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装并设置了系统，让我们来探索如何创建所需的输入映射。
- en: Creating Input Mappings
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建输入映射
- en: The new system has a way to directly request the current state of a button or
    thumbstick to the gamepad, mouse, keyboard, or whatever other device we have,
    like what we did so far with the previous Input System. But doing so would prevent
    us from using one of the best features of the system, the Input Mappings.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统有一种直接请求按钮或摇杆当前状态的方法，无论是游戏手柄、鼠标、键盘还是我们拥有的其他设备，就像我们之前在旧输入系统中所做的那样。但这样做会阻止我们使用系统最好的功能之一，即输入映射。
- en: The idea of an Input Mapping is to abstract the Input Actions from the Physical
    Input. Instead of thinking about the space bar, the left thumbstick of a gamepad,
    or the right click of a mouse, you think in terms of actions, like move, shoot,
    or jump. In code, you will ask if the `Shoot` button has been pressed, or the
    current value of the `Move` axes, like we did with the mouse axes rotatation.
    While the previous system supported a certain degree of Input Mapping, the one
    in the new Input System is way more powerful and easier to configure.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 输入映射的概念是将输入动作从物理输入中抽象出来。不是考虑空格键、游戏手柄的左摇杆或鼠标的右键点击，而是用动作来思考，比如移动、射击或跳跃。在代码中，你会询问是否按下了“射击”按钮，或者“移动”轴的当前值，就像我们处理鼠标轴旋转一样。虽然之前的系统支持一定程度的输入映射，但新输入系统的输入映射功能更强大，配置也更简单。
- en: '| **Action** | **Mappings** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **动作** | **映射** |'
- en: '| Shoot | Left Mouse Button, Left Control, X button of the gamepad |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 射击 | 左鼠标按钮、左控制键、游戏手柄的X按钮 |'
- en: '| Jump | Space, Y button of gamepad |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 跳跃 | 空格键、游戏手柄的Y按钮 |'
- en: '| Horizontal Movement | A and D keys, Left and Right arrows, gamepad Left Stick
    |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 水平移动 | A和D键、左右箭头、游戏手柄的左摇杆 |'
- en: 'Figure 6.56: Example of the Input Mapping table'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.56：输入映射表的示例
- en: The power of this idea is that the actual keys or buttons that will trigger
    these actions are configurable in the Unity editor, allowing any game designed
    to alter the exact keys to control the entire game without changing the code.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的强大之处在于，实际触发这些动作的键或按钮可以在Unity编辑器中配置，允许任何游戏设计者更改控制整个游戏的精确键，而不需要更改代码。
- en: We can even map more than one button to the same action, even from different
    devices, so we can make the mouse, keyboard, and gamepad trigger the same action,
    greatly simplifying our code. Another benefit is that the user can also rebind
    the keys with some custom UI we can add to our game, which is very common in PC
    games.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将多个按钮映射到同一个动作，甚至来自不同的设备，这样我们就可以让鼠标、键盘和游戏手柄触发同一个动作，极大地简化了我们的代码。另一个好处是，用户还可以使用我们添加到游戏中的某些自定义UI重新绑定键，这在PC游戏中非常常见。
- en: 'The easiest way to start creating an Input Mapping is through the **Player
    Input** component. This component, as the name suggests, represents the input
    of a particular player, allowing us to have one of those on each player in our
    game to support split-screen multiplayer, but let’s focus on single-player. Adding
    this script to our player will allow us to use the **Create Actions...** button
    to create a default Input Mapping asset. This asset, as a material, can be used
    by several players, so we modify it and it will affect all of them (for example,
    adding the `Jump` Input Mapping):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 开始创建输入映射最简单的方法是通过**玩家输入**组件。这个组件，正如其名所示，代表特定玩家的输入，允许我们在游戏中的每个玩家都有一个，以支持分屏多人游戏，但让我们专注于单人游戏。将此脚本添加到我们的玩家中，将允许我们使用**创建动作...**按钮创建默认的输入映射资产。这个资产，作为一个材料，可以被多个玩家使用，因此我们修改它，它将影响所有玩家（例如，添加“跳跃”输入映射）：
- en: '![](img/B18585_06_57.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_57.png)'
- en: 'Figure 6.57: Creating Input Action assets using the Player Input component'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.57：使用玩家输入组件创建输入动作资产
- en: 'After clicking that button and saving the asset location in the save prompt,
    you will see the following screen:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 点击该按钮并保存资产位置在保存提示中后，你会看到以下屏幕：
- en: '![](img/B18585_06_58.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_58.png)'
- en: 'Figure 6.58: The default Input Mapping file'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.58：默认输入映射文件
- en: The first part to understand from this asset is the **Action Maps** section
    (left panel). This allows us to create separate Action Maps for different situations,
    for example, for driving and on-foot controls in games like GTA. By default, **Player**
    and **UI** mappings are created, to separate the mappings for the player controlling
    and navigating through the UI. If you check the **Player Input** component again,
    you will see that the **Default Map** property is set to **Player**, which means
    that we will only care for the player controlling the Input Mappings in this GameObject;
    any UI action pressed won’t be considered. We can switch the active map in runtime
    at will, for example, to disable the character controller input when we are in
    the pause menu, or switch to the driving mappings while in a car, using the same
    buttons but for other purposes.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个资源中首先需要理解的部分是**动作映射**部分（左侧面板）。这允许我们为不同的情况创建单独的动作映射，例如，在像GTA这样的游戏中，为驾驶和步行控制创建动作映射。默认情况下，创建了**玩家**和**用户界面**映射，以区分玩家控制和通过用户界面导航的映射。如果你再次检查**玩家输入**组件，你会看到**默认映射**属性设置为**玩家**，这意味着我们只会关注在这个GameObject中控制输入映射的玩家；任何按下的UI动作都不会被考虑。我们可以在运行时随意切换活动映射，例如，在暂停菜单中禁用角色控制器输入，或者在车内切换到驾驶映射，使用相同的按钮但用于其他目的。
- en: 'If you select an Action Map in the left panel, you will see all the actions
    it contains in the **Actions** list in the middle panel. In the case of the **Player**,
    we have the **Move**, **Look**, and **Fire** mappings, which are exactly the inputs
    we will use in our game. Bear in mind you can add more if you need to use the
    **+** button, but for now, let’s stick with the default ones. When you select
    any action from the list, you will see their configurations in the **Action Properties**
    panel, the one on the right:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择左侧面板中的动作映射，你将在中部面板的**动作**列表中看到它包含的所有动作。在**玩家**的情况下，我们有**移动**、**观察**和**射击**映射，这正是我们将在游戏中使用的输入。记住，如果你需要使用**+**按钮添加更多，但现在让我们坚持使用默认的映射。当你从列表中选择任何动作时，你将在**动作属性**面板中看到它们的配置，即右侧的面板：
- en: '![](img/B18585_06_59.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_59.png)'
- en: 'Figure 6.59: The Move (left) and Fire (right) action configurations'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.59：移动（左侧）和射击（右侧）动作配置
- en: As you can see, there’s a property called **Action Type** that will dictate
    which kind of input we are talking about. If you select **Move** in the middle
    panel, you can see it’s a **Value** action type with **Control Type** being `Vector2`,
    meaning it will return the x and y axis values, the horizontal and vertical values—the
    kind we expect from any thumbstick in a gamepad. In the previous system, we got
    those values from separated 1D axes, like the **Mouse X** and **Mouse Y** axes,
    but here they are combined into a single variable for convenience. On the other
    hand, the **Fire** action is of type **Button**, which has the capacity not only
    to check its current state (pressed or released) but also do checks like if it
    has just been pressed or just released, the equivalents to `GetKey`, `GetKeyDown`,
    and `GetKeyUp` from the previous system.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有一个名为**动作类型**的属性，它将决定我们正在讨论哪种类型的输入。如果你在中部面板中选择**移动**，你可以看到它是一个**值**动作类型，**控制类型**为`Vector2`，这意味着它将返回x轴和y轴的值，水平和垂直的值——这是我们期望从任何游戏手柄的摇杆中得到的。在之前的系统中，我们从分离的1D轴（如**鼠标X**和**鼠标Y**轴）中获取这些值，但在这里它们被合并成一个变量以方便使用。另一方面，**射击**动作类型为**按钮**，它不仅能够检查其当前状态（按下或释放），还能进行检查，如检查它是否刚刚被按下或刚刚被释放，这是之前系统中`GetKey`、`GetKeyDown`和`GetKeyUp`的等价物。
- en: Now that we understand which actions we have and of which type each one is,
    let’s discuss how the Physical Input will trigger them. You can click the arrow
    on the left of each action in the middle panel to see its physical mappings. Let’s
    start exploring the **Move** Action Mappings.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们有哪些动作以及每个动作的类型，让我们讨论物理输入如何触发它们。你可以点击中部面板中每个动作左侧的箭头以查看其物理映射。让我们开始探索**移动**动作映射。
- en: 'In this case, we have 4 mappings:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有4个映射：
- en: '**Left Stick [Gamepad]**: The left stick of the gamepad'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左侧摇杆 [游戏手柄]**：游戏手柄的左侧摇杆'
- en: '**Primary 2D Axis [XR Controller]**: The main stick of the VR controllers'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要2D轴 [XR控制器]**：VR控制器的摇杆'
- en: '**Stick [Joystick]**: Main stick for arcade-like joysticks or even flight sticks'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摇杆[操纵杆]**：用于街机式操纵杆或甚至飞行操纵杆的主要摇杆'
- en: '**WASD**: A composite input simulating a stick through the W, A, S, and D keys'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASD**：通过W、A、S和D键模拟摇杆的复合输入'
- en: 'If you select any of them, you can check their configurations; let’s compare
    the left stick and WASD as an example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了其中任何一个，你可以检查它们的配置；让我们以左摇杆和WASD为例：
- en: '![](img/B18585_06_60.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_60.png)'
- en: 'Figure 6.60: The left stick mapping (left) and the WASD key mapping (right)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.60：左摇杆映射（左）和WASD键映射（右）
- en: 'In the case of the **Left Stick**, you can see the **Path** property that allows
    you to pick all the possible hardware physical controls that provide `Vector2`
    values (the x and y axes). In the case of the **WASD** key mapping, you can see
    it is a composite binding of type **2D Vector**, which, as stated previously,
    allows us to simulate a 2D Axis with other inputs—keys in this case. If you expand
    the **WASD** Input Mappings in the middle panel, you can see all inputs that are
    being composited for this 2D axis, and see their configurations by selecting them:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在**左摇杆**的情况下，你可以看到允许你选择所有可能提供`Vector2`值（x轴和y轴）的硬件物理控制的**路径**属性。在**WASD**键映射的情况下，你可以看到它是一个类型为**2D向量**的复合绑定，正如之前所述，这允许我们使用其他输入（在这种情况下是键）来模拟2D轴。如果你展开中间面板中的**WASD**输入映射，你可以看到所有正在组合到这个2D轴的输入，并通过选择它们来查看它们的配置：
- en: '![](img/B18585_06_61.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_61.png)'
- en: 'Figure 6.61: The inputs considered for the WASD composite 2D axis'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.61：考虑的WASD复合2D轴的输入
- en: In this case, it maps not only the W, A, S, and D buttons but also the 4 keyboard
    arrows. Each one of those mappings has a path to select the physical button, but
    also the **Composite Part** setting, allowing us to specify which direction this
    input will pull the simulated stick.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，它不仅映射了W、A、S和D按钮，还包括了4个键盘箭头。每个映射都有一个路径来选择物理按钮，还有一个**复合部分**设置，允许我们指定这个输入将拉动模拟摇杆的方向。
- en: And with this, we have just scratched the surface of what this system is capable
    of, but for now, let’s keep things simple and use these settings as they are.
    Remember a new asset was created with the same name as our game (*SuperShooter*
    in our case) in the root of the project. You can reopen this Action Mapping window
    by double-clicking it whenever you want. Now let’s see how we can use these inputs
    in our code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们只是刚刚触及了这个系统所能做到的表面，但现在让我们保持简单，并使用这些设置。记住，在项目的根目录中创建了一个与我们的游戏同名的新资产（在我们的例子中是*SuperShooter*）。你可以通过双击它来随时重新打开这个动作映射窗口。现在让我们看看我们如何在代码中使用这些输入。
- en: Using Mappings in our scripts
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的脚本中使用映射
- en: This system provides several ways to detect the input state. The **Player Input**
    component has a **Behavior** property to switch between some of the available
    modes. The simplest one is the one called **Send Messages**, the one that we will
    use, which will execute methods in our code when the keys are pressed. In this
    mode, each action in the mappings will have its own event, and you can see all
    of them in the tooltip at the bottom of the component. As you add mappings, more
    will appear.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统提供了几种检测输入状态的方法。**玩家输入**组件有一个**行为**属性，可以在一些可用模式之间切换。最简单的一个是称为**发送消息**的模式，我们将使用它，当按键被按下时，它将在我们的代码中执行方法。在这个模式下，映射中的每个动作都将有自己的事件，你可以在组件底部的工具提示中看到所有这些。随着你添加映射，将出现更多。
- en: '![](img/B18585_06_62.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_62.png)'
- en: 'Figure 6.62: All the input events for the default mapping'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.62：默认映射的所有输入事件
- en: 'From the list, we will need three, `OnMove`, `OnLook`, and `OnFire`. We can
    modify our `PlayerMovement` script like in the following screenshot to use them:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中，我们需要三个，`OnMove`、`OnLook`和`OnFire`。我们可以像以下截图那样修改我们的`PlayerMovement`脚本以使用它们：
- en: '![](img/B18585_06_63.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18585_06_63.png)'
- en: 'Figure 6.63: Player movement with the new Input System'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.63：使用新输入系统的玩家移动
- en: The first difference you will notice is that we don’t request the status of
    the input in the `Update` method like we did before. Instead, we listen to the
    `OnMove` and `OnLook` events, which provide us with an `InputValue` parameter
    containing the current state of those axes. The idea is that every time these
    axes change value, these events will execute, and if the values didn’t change,
    like when the player keeps pushing the stick all the way to the right, they won’t
    be executed. That’s why we need to store the current value in the `movementValue`
    and `lookValue` variables, to use the latest value of the axis later in the `Update`
    and apply the movement in every frame. Consider those are private, meaning they
    won’t appear in the editor, but that’s fine for our purposes. Also, observe that
    we added the `using UnityEngine.InputSystem` line at the top of the file to enable
    the usage of the new Input System in our script.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到的一个不同点是，我们不再像以前那样在`Update`方法中请求输入状态。相反，我们监听`OnMove`和`OnLook`事件，这些事件为我们提供了一个包含那些轴当前状态的`InputValue`参数。想法是每次这些轴的值发生变化时，这些事件都会执行，如果值没有变化，比如当玩家一直将摇杆推到最右边时，它们将不会执行。这就是为什么我们需要在`movementValue`和`lookValue`变量中存储当前值，以便在`Update`方法中稍后使用轴的最新值，并在每一帧应用移动。请记住，这些是私有的，意味着它们不会出现在编辑器中，但对我们来说这没问题。此外，注意我们在文件顶部添加了`using
    UnityEngine.InputSystem`行，以启用脚本中新的输入系统的使用。
- en: In this version of the `PlayerMovement` script, we used the axis input type
    like we did with the mouse before but also for movement, unlike the previous version
    that used buttons. This is the preferred option most of the time, so we will stick
    with that version. Observe how we use a single `transform.Translate` to move;
    we need to use the x axis of `movementValue` to move the x axis of our player
    but use the y axis of `movementValue` to move the z axis of our player. We don’t
    want to move our player vertically, so that’s why we needed to split the axis
    this way.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的`PlayerMovement`脚本中，我们使用了与鼠标相同的轴输入类型，但这次也用于移动，而之前的版本使用的是按钮。这通常是首选选项，所以我们将坚持使用这个版本。观察我们如何使用单个`transform.Translate`来移动；我们需要使用`movementValue`的x轴来移动玩家的x轴，但使用`movementValue`的y轴来移动玩家的z轴。我们不希望玩家垂直移动，这就是为什么我们需要以这种方式拆分轴。
- en: The `InputValue` parameter has the `Get<Vector2>()` method, which will give
    us the current value of both axes, given `Vector2` is a variable that contains
    the x and y properties. Then, we multiply the vector by the movement or rotation
    speed according to the case. You will notice that we don’t multiply by `Time.deltaTime`
    in the axis events, but we do that in the `Update`. That’s because `Time.deltaTime`
    can change between frames, so storing the movement value considering the `Time.deltaTime`
    of the last time we moved the stick won’t be useful for us. Also, notice how `movementValue`
    is a `Vector2`, just a combination of the x and y axes, while `lookValue` is a
    simple float. We did it this way because we will rotate our character only following
    the lateral movement of the mouse; we don’t want to rotate it up and down. Check
    that we do `value.Get<Vector2>().x`, with emphasis on the `.x` part, where we
    extract just the horizontal part of the axis for our calculations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputValue`参数有`Get<Vector2>()`方法，它将给出两个轴的当前值，假设`Vector2`是一个包含x和y属性的变量。然后，我们根据情况将向量乘以移动或旋转速度。你会注意到我们在轴事件中不乘以`Time.deltaTime`，但在`Update`中这样做。这是因为`Time.deltaTime`可以在帧之间变化，所以考虑到我们上次移动摇杆时的`Time.deltaTime`来存储移动值对我们来说将没有用。此外，注意`movementValue`是一个`Vector2`，只是x和y轴的组合，而`lookValue`是一个简单的浮点数。我们这样做是因为我们将只根据鼠标的水平移动来旋转角色；我们不希望它上下旋转。检查我们是否做了`value.Get<Vector2>().x`，重点在于`.x`部分，其中我们只提取轴的横向部分用于计算。'
- en: 'Regarding the `PlayerShooting` component, we need to change it to this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`PlayerShooting`组件，我们需要将其更改为如下：
- en: '![](img/B18585_06_64.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_64.png)'
- en: 'Figure 6.64: PlayerShooting script using the new Input System'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.64：使用新输入系统的PlayerShooting脚本
- en: 'This case is simpler, as we don’t need to execute the shooting behavior each
    frame, we only need to execute something at the very same moment the input is
    pressed, which is exactly when the `OnFire` event will be executed. If you need
    to also detect when the key was released, you can add the `InputValue` parameter
    as we did with `OnMove` and `OnLook`, and consult the `isPressed` property:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，情况更简单，因为我们不需要在每一帧执行射击行为，我们只需要在输入被按下的那一刻执行某些操作，这正是`OnFire`事件将被执行的时刻。如果你需要检测键被释放的情况，你可以添加`InputValue`参数，就像我们在`OnMove`和`OnLook`中做的那样，并咨询`isPressed`属性：
- en: '![](img/B18585_06_65.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_65.png)'
- en: 'Figure 6.65: Getting the state of the button'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.65：获取按钮的状态
- en: 'Regarding the Visual Script Machine version of our scripts, first, you will
    need to refresh the **Visual Script Node Library** by going to **Edit | Project
    Settings | Visual Scripting** and clicking the **Regenerate Nodes** button. If
    you don’t do this, you won’t see the new Input System nodes:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们脚本的Visual Script Machine版本，首先，你需要通过转到**Edit | Project Settings | Visual
    Scripting**并点击**Regenerate Nodes**按钮来刷新**Visual Script Node Library**。如果你不这样做，你将看不到新的Input
    System节点：
- en: '![](img/B18585_06_66.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_66.png)'
- en: 'Figure 6.66: Regenerating Visual Scripting nodes to support the new Input System'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.66：重新生成支持新Input System的可视脚本节点
- en: 'Now, the `PlayerShooting` visual script would look like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlayerShooting`可视脚本将看起来像这样：
- en: '**![](img/B18585_06_67.png)**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**![图片](img/B18585_06_67.png)**'
- en: 'Figure 6.67: Instantiating bullets with the new input system'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.67：使用新输入系统实例化子弹
- en: The new **On Input System Event Button** node allows us to detect when an action
    button has been pressed and react accordingly. You can pick the specific action
    in the **Input Action** parameter, and you can even make the node react to the
    pressure, release, or hold states of the button with the option right below the
    node’s title. There is a bug where the **Input Action** property might not show
    any option; in such cases, try removing and adding the node again in the graph,
    and check that you added the `ScriptMachine` component to the same GameObject
    that has the `PlayerInput` component. Also check you have selected the Player
    GameObject in the hierarchy.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 新的**On Input System Event Button**节点允许我们检测当动作按钮被按下时，并相应地做出反应。你可以在**Input Action**参数中选择特定的动作，甚至可以通过节点标题下方的选项使节点对按钮的压力、释放或保持状态做出反应。存在一个bug，即**Input
    Action**属性可能不会显示任何选项；在这种情况下，尝试在图中删除并重新添加节点，并确保你已将`ScriptMachine`组件添加到具有`PlayerInput`组件的同一GameObject中。还要检查你是否已选择了玩家GameObject。
- en: 'Regarding movement, it can be achieved this way:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动，可以这样实现：
- en: '![](img/B18585_06_68.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18585_06_68.png)'
- en: 'Figure 6.68: Moving with the new Input System'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.68：使用新Input System移动
- en: In this case, we used the **On Input System Event Vector2** node. This time,
    we used the `OnHold` mode, which means that, unlike the C# version, it won’t execute
    just when the axis changes, but all the frames when the axis is pressed act like
    an `Update`; that, however, will only execute when the user is pressing the stick.
    The output pin of the node is the `Vector2` value, so we multiply it by the `speed`
    variable (declared in the `Variables` component of our player) and by `DeltaTime`.
    Finally, we use the `Vector2` `GetX` and `Vector2` `GetY` nodes to translate over
    the x and z axes. You may have trouble when rewiring the **Multiply** nodes with
    the new **Input System** node, given the return type is different compared to
    the previously used node (a `Vector2` instead of a single float). I recommend
    just deleting all nodes in this graph and redoing it to be sure everything is
    fine.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，我们使用了**On Input System Event Vector2**节点。这次，我们使用了`OnHold`模式，这意味着，与C#版本不同，它不会仅在轴变化时执行，而是在轴被按下的所有帧都会像`Update`一样执行；然而，这只会当用户按下摇杆时执行。节点的输出引脚是`Vector2`值，所以我们将其乘以`speed`变量（在玩家`Variables`组件中声明）和`DeltaTime`。最后，我们使用`Vector2
    GetX`和`Vector2 GetY`节点在x和z轴上平移。当重新连接**Multiply**节点到新的**Input System**节点时，可能会遇到麻烦，因为返回类型与之前使用的节点不同（从单个`float`变为`Vector2`）。我建议直接删除此图中的所有节点，并重新构建以确保一切正常。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We created our first real scripts, which provide useful behavior. We discussed
    how to move a GameObject based on input and instantiate Prefabs via scripting
    to create objects at will according to the game situation. Also, we saw how to
    schedule actions, in this case, spawning, but this can be used to schedule anything.
    We saw how to destroy the created objects, to prevent increasing the number of
    objects to an unmanageable level. Finally, we explored the new Input System to
    provide maximum flexibility to customize our game’s input. We will be using these
    actions to create other kinds of objects, such as sounds and effects, later in
    this book.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了我们的第一个真正的脚本，它提供了有用的行为。我们讨论了如何根据输入移动GameObject，并通过脚本实例化预制体以根据游戏情况随意创建对象。此外，我们还看到了如何安排动作，在这种情况下是生成，但这可以用来安排任何事物。我们看到了如何销毁创建的对象，以防止对象数量增加到无法管理的水平。最后，我们探索了新的输入系统，以提供最大的灵活性来自定义我们游戏的输入。我们将在本书的后面部分使用这些动作来创建其他类型的对象，例如声音和效果。
- en: Now you are able to create any type of movement or spawning logic your objects
    will need and make sure those objects are destroyed when needed. You might think
    that all games move and create shooting systems the same way, and while they are
    similar, being able to create your own movement and shooting scripts allows you
    to customize those aspects of the game to behave as intended and create the exact
    experience you are looking for.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您能够创建任何类型的移动或生成逻辑，确保所需的对象在必要时被销毁。您可能会认为所有游戏都以相同的方式移动和创建射击系统，尽管它们相似，但能够创建自己的移动和射击脚本允许您自定义游戏中的这些方面，使其按预期行为并创建您所寻找的精确体验。
- en: In the next chapter, we will be discussing how to detect collisions to prevent
    the player and bullets from passing through walls and much more.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何检测碰撞以防止玩家和子弹穿过墙壁以及更多内容。
