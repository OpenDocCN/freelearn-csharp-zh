- en: '*Chapter 7*: LINQ Performance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LINQ has a reputation for being slow. But contrary to people's views, there
    are ways to use LINQ that ensure optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to perform LINQ queries with performance
    in mind. Depending on how you use LINQ, different methods that return the same
    result can behave and perform differently. And so, in this chapter, you will learn
    how best to perform queries on LINQ to improve the performance of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will benchmark different ways to determine the most performative ways
    to obtain the last element of a LINQ query. You will learn about the performance
    penalty of using the `let` keyword in LINQ statements, and why you should avoid
    using it. Benchmarking different `Group By` methods, you will gain insight into
    the most performant way to perform GroupBy queries using LINQ. When performing
    queries and data manipulation using LINQ, there may be times when you need to
    use closures. By writing parametrized and non-parameterized closures, you will
    see that parameterized closures perform much better than non-parameterized closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our sample database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our in-memory sample data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying a database using LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the last value of a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using the let keyword in LINQ queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing Group By performance in LINQ queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the skills to securely store secrets
    and query databases and in-memory data using efficient LINQ. You will also be
    able to understand the performance impact of using the `let` keyword in your queries
    and performing efficient filtering and grouping of data using LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow along with this chapter, you will need access to the following
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server Management Studio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The book''s source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a sample database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be demonstrating the difference between how different
    collection interfaces handle data, and for the demonstrations, you require access
    to database data. To do so, you will create a database, add a table, and populate
    it with data. You will use SQL Server for your database engine, and use SQL Server
    Management Studio to develop your sample database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the `CH07_LinqPerformance.Data` source code folder, you will find a database
    creation script called `SampleData.Product.sql` that creates the database and
    populates it with data. You can run this script in SQL Server Management Studio.
    This will save you from having to run through setting up the database in this
    section. But if you are new to SQL Server, you may want to run through this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add your database, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open SQL Server Management Studio and connect to your database engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the **Databases** folder in **Object Explorer** as shown in
    *Figure 7.1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1: The SQL Server Management Studio Object Explorer tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: The SQL Server Management Studio Object Explorer tab'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **New Database** from the context menu. This will display the **New
    Database** dialog as shown in *Figure 7.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2: The SQL Server Management Studio New Database dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: The SQL Server Management Studio New Database dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered `SampleData` for the database name, click on the **OK**
    button to create the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the database by expanding the `Products` as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Table 7.1: The Products table design'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_7.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.1: The Products table design'
  prefs: []
  type: TYPE_NORMAL
- en: Save the table and then expand the **Tables** folder. Right-click on the **Products**
    table and select **Edit Top n records** where *n* will be the number of configured
    records to edit, which is *200* by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the data shown in the following figure to the **Product** table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Table 7.2: The Product table row data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_7.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7.2: The Product table row data'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a database with a single table filled with data that we will use
    later in the chapter. In the next section, we will be adding our in-memory sample
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our in-memory sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be studying LINQ performance, therefore, you are going to need a collection
    to work with. You will work with a collection of `Person` objects. Each person
    will be named from the Greek alphabet. A `Person` object will consist of a `FirstName`,
    `LastName`, and `FullName` property. The `FullName` property will be an interpolated
    string that combines the first and last name of the person.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now begin coding our LINQ coding combined with **benchmarking**, so
    that we can measure the performance of our LINQ statements:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new .NET 6.0 console application called `CH07_LinqPerformance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the NuGet package `BenchmarkDotNet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `Person` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This structure defines the `Person` with their `FirstName`, `LastName`, and
    computed `FullName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a new class called `LinqPerformance` with the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These `using` statements provide you with access to benchmarking, generic collections,
    and LINQ classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have declared a list of people and two arrays. Both these arrays contain
    the surnames of people in lowercase that belong to those groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the global setup class that will prepare your collection for benchmarking
    various LINQ queries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have your sample database and in-memory sample data in place for the
    topics we will be covering in this chapter. So, let us start by investigating
    various ways of querying a database and their effects on LINQ query performance.
  prefs: []
  type: TYPE_NORMAL
- en: Database query performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in [*Chapter 6*](B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117), *The
    .NET Collection*, how `IEnumerator` is different from `IEnumerable`, and how `IEnumerator`
    performs faster than `IEnumerable` when iterating through an in-memory collection.
    Now, we will query a database and iterate through the resulting collection using
    various benchmarked techniques. To do so, we will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new class called `IEnumeratorVsIQueryable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be connecting to a SQL Server database and will have the information
    you need to keep secret. Your `secret.json` files do not get checked into version
    control. So, right-click on the project and select **Manage User Secrets** from
    the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dialog will pop up informing you that additional packages are required. Click
    on **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3: Dialog Informing you that additional packages are required to
    manage user secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Dialog Informing you that additional packages are required to manage
    user secrets'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio will then open the `secrets.json` file in a new tab. This is where
    you will add your user secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **Package Manager Console** and add the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These packages enable you to connect to and extract data from the SQL Server
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `secrets.json` file with the connection string to the database
    you created at the start of the chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This connection string will be used to connect to your database, perform a query
    that returns some data, and enable you to iterate through that data and perform
    operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a folder called `Configuration`, and in that folder, add a class called
    `SecretsManager` with an empty static constructor and the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need these `using` statements for your file I/O and system configuration
    such as obtaining secrets from a `secrets.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line at the top of the `SecretsManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This line declares your static configuration property that is used to obtain
    your configuration data within your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code gets the environment variables for the .NET Core environment. It then
    gets the code to see if it is running in a software development environment or
    production environment. The configuration is then built for the environment it
    will be running in. So, if we are in debug mode, the configuration will be built
    for the development environment. And if we are in release mode, the configuration
    will be built for the production environment. If we are in development, then we
    add our `secrets` class as defined by the `T` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder, `Models`, and add the `Product` class using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Product` class provides the model for our product data with `Id`, `Name`,
    and `Description` properties that are set via the constructor. We also override
    the `ToString` method to return a textual representation of the property values.
  prefs: []
  type: TYPE_NORMAL
- en: Add a `using` statement for `System.ComponentModel.DataAnnotations`. Change
    the struct to a class, and add the `[Key]` attribute to the `Id` property. We
    need these changes since we are using Entity Framework to connect to a database
    and extract data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `CH07_LinqPerformance.Data` folder, add the `DatabaseContext` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have declared our `DatabaseContext` class, which inherits from the `DbContext`
    class. Now we'll need to add its internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following items to the `DatabaseContext` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we have declared our `DbSet` of products property, which will
    hold a collect of our `Product` class, and a connection string member variable
    that will hold the string that connects us to our database. Our constructor is
    then declared, which takes in a connection string, which we pass into the `GetOptions`
    method that then gets passed into the base class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetOptions` method to the `DatabaseContext` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method returns the `DbContextOptions` for our SQL Server database connection.
    The connection string used is the one that is stored in our `secrets.json` file
    in development and in `appsettings.json` when in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `OnModelCreating` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are configuring our `Product` class that will be used in our `DbSet`.
    We are declaring that the `Id` field is our primary key and that the `Name` field
    has a maximum length of 50 while the `Description` field has a maximum length
    of 255.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `DatabaseSettings` class to the `Configuration` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class has a single property called `ConnectionString` that will hold your
    connection string to our `SampleData` database. Notice that the name of the class
    and property match the name of the JSON section and property!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add `appsettings.json` to the root of your project with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file has the same layout as the `secrets.json` file and the `DatabaseSettings`
    class. This file is used to store your connection string. In development, it is
    set in the secrets file, and in production, it is set in Azure. Now that you have
    your database configuration in place, you can add your benchmarking code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class in the root of the project called `DatabaseQueryAndIteration`
    that implements `IDisposable` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code declares our class and defines the fact that it implements `IDisposable`.
    It is also configured to be benchmarked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `IDisposable` interface in our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code disposes of our managed resources and suppresses the call to the class
    finalizer method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have everything in place to benchmark the methods in this class, access
    database resources, and clean up after ourselves. Add the following code to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `_context` variable provides us with our database access. The `GlobalSetup()`
    method gets our connection string from our secrets file, and creates a new `DatabaseContext`
    using the safely stored connection string. The `GlobalSetup()` method will run
    before our benchmarks. The `GlobalCleanup()` method calls the `Dispose(disposing)`
    method to clean up our managed resources after our benchmarks have finished running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `QueryDb()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `QueryDb()` method performs a simple LINQ query on the database by selecting
    products with an ID of greater than `1`. It then iterates each product in the
    `IQueryable<Product>` list and writes the product name out to the debug window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `QueryDbAsList()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QueryDbAsList()` performs the same query as `QueryDb()`, except the processed
    type is of type `List<Product>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `QueryDbAsIEnumerable()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `QueryDbAsIEnumerable()` method performs the same query as `QueryDbAsList`,
    but processes a type of `IEnumerable<Product>` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `QueryDbAsIEnumerator()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`QueryDbAsIEnumerator()` does the same as the previous methods but operates
    on a type of `IEnumerator<Product>` and iterates using a `while` loop instead
    of a `foreach` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method in this class that we need to add is the `QueryDbAsIQueryable()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is the same as `QueryDb` but explicitly operates on a type of `IQueryable<Product>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the code in the `Main` method within the `Program` class with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code runs your benchmarks. Do a release build of the code and run the
    executable from the command line. You should see a summary report similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: The different times and memory allocation of various database
    query types using LINQ'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: The different times and memory allocation of various database query
    types using LINQ'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us summarize what we learn from the summary report after running our query
    benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: In terms of memory usage, the worst performer is the `QueryDb()` method followed
    by the `QueryDbAsList()` method. `QueryDbAsIEnumerable()` and `QueryDbAsIQueryable()`
    are both slightly better than the previous two. But the best performing method
    in terms of memory allocation out of all five methods is the `QueryDbAsIEnumerator()`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speed wise, the `QueryDb()` method was the worst again. Followed by `QueryDbAsIEnumerable()`,
    then `QueryDbAsList()`, and then `QueryDbAsIQueryable()`. And again, the best
    performer in terms of speed is the `QueryDbAsIEnumerator()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we can see that the best performing method for querying and iterating a
    database in both speed and memory usage terms is the `QueryDbAsIEnumerator()`
    method out of all the methods we've chosen to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be investigating which is the fastest method for
    obtaining the last item in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the last value of a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You are now going to see how the LINQ method that obtains the last element
    in the collection is really slow when compared to directly accessing the item
    by its index. This will be accomplished using benchmarking to measure the performance
    of different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Main` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `LinqPerformance` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `GetLastPersonVersion1()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method gets the last person in the collection using the LINQ-provided `Last()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GetLastPersonVersion2()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are using the index of the list to extract the last person in the
    list. At this point, it is worth noting that the difference between the two methods
    is that in the first method, this `Last()` method call is actually declared in
    `System.Linq.Enumerable`. The method signature is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, the `Last()` call in the `GetLastPersonVersion1()` method performs various
    checks before the last value is returned. But the `GetLastPersonVersion2()` method
    does not perform these checks, and immediately returns the value at the last position.
    This explains why the method used in `GetLastPersonVersion1()` is much slower
    than accessing an element by its index in `GetLastPersonVersion2()`, as you will
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Get Last Person example performance using the Last() method and
    direct index access'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Get Last Person example performance using the Last() method and
    direct index access'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the summary report of the benchmarks we have just run, it is evident
    that using the index for direct access is better than using the `Last()` method
    call in terms of improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how we can quickly access the last element in a collection. Let
    us now consider why we should avoid using the `let` keyword in LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using the let keyword in LINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `let` keyword to declare a variable and assign it a value to
    use in your LINQ query if the value is to be used several times within the query.
    At first glance, this may seem like you are improving performance since you only
    perform a single assignment, and then use the same variable several times. But
    this is not actually the case. Using the `let` keyword in your LINQ queries can
    actually decrease the performance of your LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us work through some benchmark examples. In the `LinqPerformance` class,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `ReadingDataWithoutUsingLet()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we are selecting people from the `_people` list with a last
    name of *Omega*, and a first name of *Upsilon* using LINQ without the `let` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `ReadingDataUsingLet()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we are also selecting people from the `_people` list with a
    last name of *Omega* and a first name of *Upsilon*. But this time, we use the
    `let` keyword for both the filters and use them in the `where` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and run the executable from the command line. You should
    see results similar to those shown in *Figure 7.6*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6: BenchmarkDotNet results for reading data with and without using
    the let keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: BenchmarkDotNet results for reading data with and without using
    the let keyword'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from these results, the use of the `let` keyword in our query
    reduced the performance. The processing time increased and so did the memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will see websites that promote the use of the `let` keyword in LINQ queries
    to improve performance and readability. But as you have seen in the example we
    have worked through, using the `let` keyword can seriously slow down the performance
    of your queries and increase memory usage. So, as a rule of thumb, take to measuring
    your performance for your particular queries and choosing the method that performs
    best for your query task.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen how the use of the `let` keyword can increase
    the time taken and memory used to perform a simple `select` query using LINQ.
    This performance decrease can become a real problem when working with large volumes
    of data. In the next section, we will look at several methods for grouping data
    and see which method performs the best.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing Group By performance in LINQ queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at three different ways of performing the same
    `Group By` operation. Each way provides a different performance level. You will
    see by the end of this section which method is best for performing fast `Group
    By` queries. The methods that we add in this section will be added to the `LinqPerformance`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: For our scenario, we want to get a list of people from a collection that all
    share the same name. To extract those people, we will perform a `Group By` operation.
    Then, we will extract all those for whom the group count is greater than one,
    and then add them to a list of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add our three methods that use the `GroupBy` clause to return a list
    of people:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GroupByVersion1()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are grouping on the person's last name. We then filter the
    groups to include only those groups with a count greater than *1*. Those groups
    are then selected and then returned as a list of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `GroupByVersion2()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we obtain an enumerator by grouping people by their last name
    and then filtering the groups to only include those groups with a count of *2*
    or more. Then we declare a new list of people. We then loop through the enumerator
    and obtain the current `IGrouping<string, Person>`. The grouping is then iterated
    through, and each person in the group is added to the list of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `GroupByVersion3()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `GroupByVersion3()` method is the same as and behaves the same as the `GroupByVersion2()`
    method, but with one main difference. We convert the list of people to an array
    before we perform the `Group By`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following annotations to the top of the `LinqPerformance` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These annotations will expand the data contained in the summary report as you
    will see shortly. Do a release build of the project and then run the project from
    the command line to benchmark these three methods. You should see the following
    benchmark summary report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: The BenchmarkDotNet Group By summary report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: The BenchmarkDotNet Group By summary report'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, our first attempt at performing a `Group By` operation takes
    *2.204* microseconds, our second attempt takes *2.011* microseconds, and our third
    and final attempt takes *2.204* microseconds. So, we can see that converting our
    list to an array before performing a `Group By` speeds things up. Our final version
    is *0.243* microseconds faster than our original version, and that is despite
    the fact that more code is involved!
  prefs: []
  type: TYPE_NORMAL
- en: The section that follows will take you through the benchmarking of five different
    ways to provide filtering of lists. You will see how the different methods affect
    the performance of LINQ queries.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at various ways to filter a list using LINQ.
    We will see that the various ways all perform differently. By the end of this
    section, you will know the best way to filter a list for increased performance.
    You will be writing two different benchmarks that demonstrate query performance
    differences when using the `let` keyword and not using the `let` keyword. Let''s
    begin writing our benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FilterGroupsVersion1()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first of our benchmarks filters people that belong to `_group1` and `_group2`.
    Since the arrays are in lowercase, `LastName` is also converted to lowercase.
    The filtered people are then returned as a list of people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FilterGroupsVersion2()` benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This does the same as our first benchmark. The main difference is that we introduce
    the `lastName` variable using the `let` keyword, and assign it the lowercase `LastName`
    of the person.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the project in release mode and run it from the command line. The benchmarks
    will be generated, and you should see a benchmark report similar to the one in
    *Figure 7.8*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8: Benchmark Report for LINQ with and without using the let keyword'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Benchmark Report for LINQ with and without using the let keyword'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the summary report that using the `let` keyword slows things down
    considerably. And so, we will now investigate why the `let` keyword slows things
    down.
  prefs: []
  type: TYPE_NORMAL
- en: Open `CH07_LinqPerformance.dll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand `FilterGroupsVersion1` and `FilterGroupsVersion2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the method `FilterGroupsVersion1` to reveal the intermediate
    language generated by the compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, do the same with the `FilterGroupsVersion2` method. When you compare the
    IL for both methods, you will clearly see that the IL for `FilterGroupsVersion2`
    contains more lines of code than the IL for `FilterGroupsVersion1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And that explains why the `let` version of the code performs slower than the
    original code that does not use the `let` keyword. But can we do better than `FilterGroupsVersion1`
    in terms of performance? Well, it turns out that, yes, we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `FilterGroupsVersion3` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we create a new people list. We then loop through the `_people`
    list. For each person, we get them from the `_people` list. We then assign the
    lowercase form of their name to a local variable. Using this variable, we check
    to see if either `_group1` or `_group2` contains the names. If they do, then the
    person is added to the `_people` list. Once the iteration has finished, the `_people`
    collection is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the code again. You should see the following report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3''s
    performance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3''s
    performance'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have three different versions of the code that produce the
    same output, and each one's execution time is different. Between these three different
    methods, `FilterGroupsVersion3` is by far the quickest method in achieving the
    desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have another go at improving the performance of our LINQ filter query.
    Add the `FilterGroupsVersion4` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It can be seen that the only difference between `FilterGroupsVersion3` and `FilterGroupsVersion4`
    is the ordering of the `if` condition check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the project and run the benchmark tests. *Figure 7.10* shows the performance
    summary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4''s
    performance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4''s
    performance'
  prefs: []
  type: TYPE_NORMAL
- en: It is clear from the benchmark report that version 4 of our filter is the winning
    method in terms of performance. So, why is version 4 better than version 3? The
    `_group2` array contains fewer items than `_group1`. If you understand the business
    domain, you will be able to order the filter checks in such a way that the arrays
    with fewer items will be checked first.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how using the `let` keyword slows things down. But you have also
    seen how the ordering of checks in a conditional statement can also have an impact
    on performance. Placing the check with the least elements first within a conditional
    check statement will improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at closures in LINQ statements and how they
    affect query performance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand closures from a C# perspective, and apply
    them to LINQ queries. Let's start with the definition of computer programming
    closures according to the content on Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia: "In programming languages, a closure, also lexical closure or function
    closure, is a technique for implementing lexically scoped name binding in a language
    with first-class functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Operationally, a closure is a record storing a function together with an environment.
  prefs: []
  type: TYPE_NORMAL
- en: The environment is a mapping associating each free variable of the function
    (variables that are used locally but defined in an enclosing scope) with the value
    or reference to which the name was bound when the closure was created.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a plain function, a closure allows the function to access those captured
    variables through the closure's copies of their values or references, even when
    the function is invoked outside their scope."
  prefs: []
  type: TYPE_NORMAL
- en: To understand what's being said here, we will begin by understanding what first-class
    functions are.
  prefs: []
  type: TYPE_NORMAL
- en: A first-class function is a method that is treated by C# as a first-class data
    type. This means that you can assign a method to a variable and pass it around,
    and you can invoke it as you would a normal method. First-class functions can
    be created using anonymous methods and lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Free variables are variables that are not parameter variables to a method, and
    they are variables that are not local to that method, which, in plain English,
    means that they are variables that exist outside of a method, but are being referenced
    within a method's closing scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to apply closures to a LINQ expression and benchmark them. The
    first one will be using LINQ with a closure that takes parameters, and the second
    one will be using LINQ with a closure that uses free variables. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqPerformance` class, comment out the current `[Benchmark]` annotated
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `LinqClosureUsingParameters` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `LinqClosureUsingParameters` method, we declare closure using a delegate
    with parameters. We declare a variable called `IsBetween` and assign the `Between`
    method to it. Then we perform a LINQ query and filter the results by calling `IsBetween`.
    The result is that we will have only those people whose last name's first letters
    are between A and G.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use free variables. So, let us now look at a different example
    that uses free variables. Add the `LinqClosureUsingVariables` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `LinqClosureUsingVariables` method, we declare our closure using free
    variables to declare the first and last characters used for filtering the dataset.
    We then assign the `Between` method to the `IsBetweenAG` variable. Then, we perform
    a LINQ query and filter the results by passing in the last name of each individual
    into the `IsBetweenAG` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method called `NonLinqFilter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we simply filter a list using its own `FindAll` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are in Release mode and then run your project. You should end
    up with results similar to those in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11: Closure benchmarks with and without parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Closure benchmarks with and without parameters'
  prefs: []
  type: TYPE_NORMAL
- en: As we can clearly see in the benchmarks of *Figure 7.11*, closures with parameters
    are faster and allocate less memory than closures without parameters. But it is
    far better to use a list's own `FindAll` method for filtering as it is faster
    and uses less allocated memory than LINQ and closures.
  prefs: []
  type: TYPE_NORMAL
- en: A situation when you may need to apply your own custom closures for use in LINQ
    queries is when you have complex data manipulation and query generation that cannot
    be dealt with easily with normal LINQ. In this case, closures would be of benefit
    to you. Having performed the benchmarking of closures, you now know to use closures
    with parameters for optimal performance when using LINQ. But if you don't need
    to use LINQ, then using a list's own methods may be more advantageous. And if
    you do have to work on lists, then it could pay to do the filtering of the dataset
    using non-LINQ methods first, then perform your LINQ queries on the filtered lists.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is now complete. But before we move on to [*Chapter 8*](B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152),
    *File and Stream I/O*, let us summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied LINQ performance by benchmarking a variety of ways
    to query, group, filter, and iterate data obtained from databases and in-memory
    collections. The most performant way to query a database was found to be using
    the `IEnumerator` interface. By disassembling code, we saw that the `let` keyword
    can degrade performance due to the extra lines of IL code produced by the compiler.
    We also saw how accessing the last element in a collection using its index is
    faster than calling the `Last()` method. And we also learned that filtering lists
    by filtering on objects with the least items first improves filter performance
    operations. Closures provided better overall performance when passing in parameters,
    compared to not passing in parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at file and stream I/O performance.
    But for now, see if you can answer the following questions, and check out the
    further reading material to solidify what you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name some ways to improve LINQ performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is wrong with using the `let` keyword in a LINQ query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to improve the performance of a `Group By` query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What performs better, closures with parameters, or closures without parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Console User Secrets**: [https://github.com/jasonshave/ConsoleSecrets](https://github.com/jasonshave/ConsoleSecrets).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimising LINQ**: [https://mattwarren.org/2016/09/29/Optimising-LINQ/](https://mattwarren.org/2016/09/29/Optimising-LINQ/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Five Tips to Improve LINQ to SQL Performance**: [https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx](https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make your C# applications faster with LINQ joins**: [https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins](https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ Stinks – code smells in your LINQ**: [https://markheath.net/post/linq-stinks](https://markheath.net/post/linq-stinks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How to get a value out of a Span<T> with Linq expression trees?**: [https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees](https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linq ToLookup Method in C#**: [https://dotnettutorials.net/lesson/linq-tolookup-operator/](https://dotnettutorials.net/lesson/linq-tolookup-operator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ (C#) – ToLookup Operator Example And Tutorial**: [https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php](https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Simple Explanation of C# Closures**: [https://www.simplethread.com/c-closures-explained/](https://www.simplethread.com/c-closures-explained/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
