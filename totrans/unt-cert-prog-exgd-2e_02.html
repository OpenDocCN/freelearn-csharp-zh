<html><head></head><body>
		<div id="_idContainer072">
			<h1 id="_idParaDest-47"><em class="italic"><a id="_idTextAnchor048"/>Chapter 2</em>: Adding and Manipulating Objects</h1>
			<p>In the previous chapter, we discussed the importance of the Official Unity Programmer exam and what benefits it can produce for any developer who is looking to reassure either themselves or others in understanding programming in Unity. We also discussed the building blocks of being a programmer in general and our game's design brief.</p>
			<p>As we are programmers working on a game engine, it is likely you will be working for a range of industries. In many of these industries, you will be issued with a technical brief/documentation (well, you should be!) for building an application. With this project, we are making a game, and the game design brief is effectively the blueprint for making this game. In this chapter, we will be applying the majority of our code, game objects, prefabs, and more based on the guidance of the brief and the game framework. We will be reminding ourselves of the brief and game framework during this chapter and will transfer specific information into our code.</p>
			<p>With regard to our code, we will be covering the importance of interfaces and scriptable objects to help structure and uniform our code, preventing it from bloating unnecessarily, which we covered in <a href="B18381_01_Epub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting Up and Structuring Our Project</em>, with SOLID principles. We will also be getting used to the Unity Editor and becoming familiar with game objects, prefabs, and importing three-dimensional models to animate.</p>
			<p>In this chapter, we'll be covering the following topics:</p>
			<ul>
				<li>Setting up our Unity project</li>
				<li>Introducing our interface (<strong class="source-inline">IActorTemplate</strong>)</li>
				<li>Introducing our <strong class="source-inline">ScriptableObject</strong> (<strong class="source-inline">SOActorModel</strong>)</li>
				<li>Setting up our <strong class="source-inline">Player</strong>, <strong class="source-inline">PlayerSpawner</strong>, and <strong class="source-inline">PlayerBullet</strong> scripts</li>
				<li>Planning and creating our enemy</li>
				<li>Setting up our <strong class="source-inline">EnemySpawner</strong> and enemy script</li>
			</ul>
			<p>The next section will outline the exam objectives covered in this chapter.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Core exam skills covered in this chapter</h1>
			<p><em class="italic">Programming core interactions</em>:</p>
			<ul>
				<li>Implement and configure game object behavior and physics.</li>
				<li>Implement and configure input and controls.</li>
				<li>Implement and configure camera views and movement.</li>
			</ul>
			<p><em class="italic">Working in the art pipeline</em>:</p>
			<ul>
				<li>Understand lighting and write scripts that interact with Unity's lighting API.</li>
				<li>Understand two- and three-dimensional animation and write scripts that interact with Unity's animation API.</li>
			</ul>
			<p><em class="italic">Programming for scene and environment design</em>:</p>
			<ul>
				<li>Identify methods for implementing game object instantiation, destruction, and management.</li>
				<li>Demonstrate knowledge of developer testing and its impact on the software development process, including Unity Profiler and traditional debugging and testing techniques.</li>
				<li>Recognize techniques for structuring scripts for modularity, readability, and re-usability.</li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>The project content for this chapter can be found at <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_02</a>.</p>
			<p>You can download the entire chapter project files at <a href="https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition">https://github.com/PacktPublishing/-Unity-Certified-Programmer-Exam-Guide-Second-Edition</a>.</p>
			<p>All content for this chapter is held in the relevant <strong class="source-inline">unitypackage</strong> file, including a <strong class="source-inline">Complete</strong> folder that contains all of the work we'll carry out in the chapter, so if at any point you need some reference material or extra guidance, be sure to check it out.</p>
			<p>Check out the following video to see the <em class="italic">Code in Action</em>: <a href="https://bit.ly/3yfWyt5">https://bit.ly/3yfWyt5</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Setting up our Unity project</h1>
			<p>Things can get<a id="_idIndexMarker095"/> messy quickly in a project if we don't manage our files correctly by placing them in the allocated folders. If you want to structure your folders your own way, or during the book, you decide to stray away from how I'm doing it, that's also fine. Just try and be conscious of your future self or other people working on this project when it comes to finding and organizing files.</p>
			<p>Open the project up if you haven't already and create the following folders:</p>
			<ul>
				<li><strong class="source-inline">Model</strong> contains 3D models (the player ship, enemies, bullets, and so on).</li>
				<li><strong class="source-inline">Prefab</strong> holds instances of game objects (these are created within Unity).</li>
				<li><strong class="source-inline">Scene</strong> stores our first-level scene as well as other levels.</li>
				<li><strong class="source-inline">Script</strong> contains all of our code.</li>
				<li><strong class="source-inline">Material</strong> stores our game object materials.</li>
				<li><strong class="source-inline">Resources</strong> stores assets and objects to load into our game.</li>
				<li><strong class="source-inline">ScriptableObject</strong> are data containers that are capable of storing large amounts of data.<p class="callout-heading">Tip</p><p class="callout">You should know what a prefab is, as it's one of the main parts of what makes Unity so quick and easy to use. However, if you don't: it's typically your game object with its settings and components stored in an instance. You can store your game objects in your <strong class="bold">Project</strong> window as prefabs by dragging the game object from the <strong class="bold">Hierarchy</strong> window. A blue box icon will be generated following the game object's name, and if you select the prefab in the <strong class="bold">Project</strong> window, its <strong class="bold">Inspector</strong> window details will show all its stored values. If you would like to know more about prefabs, you can check out the documentation at <a href="https://docs.unity3d.com/Manual/Prefabs.html">https://docs.unity3d.com/Manual/Prefabs.html</a>.</p></li>
			</ul>
			<p>The following screenshot shows <a id="_idIndexMarker096"/>you how to create these folders:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.01_B18381.jpg" alt="Figure 2.1 – Creating a folder in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Creating a folder in the Unity Editor</p>
			<p>Next, we will <a id="_idIndexMarker097"/>create subfolders; we need to do the following:</p>
			<ol>
				<li>Within our <strong class="source-inline">Prefab</strong> folder, create another two folders, <strong class="source-inline">Enemies</strong> and <strong class="source-inline">Player</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.02_B18381.jpg" alt="Figure 2.2 – Folders created in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Folders created in the Unity Editor</p>
			<p><strong class="source-inline">Resources</strong> is a special folder that Unity recognizes. It will allow us to load assets while the game is <a id="_idIndexMarker098"/>running. For more information about the <strong class="source-inline">Resources</strong> folder, check the documentation at <a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html">https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity6.html</a>.</p>
			<p class="callout-heading">Further Information</p>
			<p class="callout">It's worth mentioning the <strong class="source-inline">StreamingAssets</strong> folder at this point. Even though we aren't using it in this project, it relates well to how similar (and how different) it is to the <strong class="source-inline">Resources</strong> folder.</p>
			<p class="callout">The <strong class="source-inline">Resources</strong> folder imports assets and converts them into internal formats that will be compatible with the target platform. So, for example, a PNG file will get converted and compressed when the project is being built.</p>
			<p class="callout">The <strong class="source-inline">StreamingAssets</strong> folder will hold the PNG file, not convert or compress it. For more information on Streaming Assets, check out the following link: <a href="https://docs.unity3d.com/Manual/StreamingAssets.html">https://docs.unity3d.com/Manual/StreamingAssets.html</a>.</p>
			<p>Provided in the <em class="italic">Technical requirements</em> section is the download link for the GitHub repository of this chapter. Once downloaded, double-click the <strong class="source-inline">Chapter2.unitypackage</strong> file, and we will be given a list of assets to import into our Unity project:</p>
			<ul>
				<li><strong class="source-inline">Player_ship.fbx</strong></li>
				<li><strong class="source-inline">enemy_wave.fbx</strong></li>
			</ul>
			<p>The following screenshot shows the <strong class="bold">Import</strong> window of the assets we are about to bring into our project:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_2.03_B18381.jpg" alt="Figure 2.3 – Importing assets into your project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Importing assets into your project</p>
			<p>Make sure all assets are ticked and click the <strong class="bold">Import</strong> button at the bottom-right corner of the window. We <a id="_idIndexMarker099"/>can now move on to organizing our files and folders in the <strong class="bold">Project</strong> window in the next section.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Creating prefabs</h2>
			<p>In this section, we <a id="_idIndexMarker100"/>are going to create three prefabs: the player, the player's bullet, and the enemy. These prefabs will hold components, settings, and other property values for our game that we can instantiate throughout our game.</p>
			<p>Let's start by making our <strong class="source-inline">player_ship.fbx</strong> file into a prefab instance by doing the following.</p>
			<p>Sometimes, when importing any three-dimensional file, it may contain extra data that we might not need. For example, our <strong class="source-inline">player_ship</strong> model comes with its own material and animation properties. We don't require any of these, so let's remove these properties before continuing to import our models fully into our Unity project.</p>
			<p>To remove the <strong class="bold">Animation</strong> and <strong class="bold">Material</strong> properties from our <strong class="source-inline">player_ship</strong> model, we need to do the following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to <strong class="source-inline">Assets/Model</strong> and select the <strong class="source-inline">player_ship</strong> file.</li>
				<li>In the <strong class="bold">Inspector</strong> window, select the <strong class="bold">Materials</strong> button.</li>
				<li>Make sure the<strong class="bold"> Material Creation Mode</strong> is set to <strong class="bold">None</strong> from the drop-down list, and then click the <strong class="bold">Apply</strong> button.</li>
				<li>Now, click the <strong class="bold">Animation</strong> button next to the <strong class="bold">Materials</strong> button.</li>
				<li>Untick the <strong class="bold">Import Animation</strong> checkbox, followed by clicking the <strong class="bold">Apply</strong> button.</li>
				<li>Select the <strong class="bold">Rig</strong> button next to the <strong class="bold">Animation</strong> button.</li>
				<li>Select the current value in the <strong class="bold">Animation Type</strong> drop-down menu and select <strong class="bold">None</strong>, followed by the <strong class="bold">Apply</strong> button.</li>
				<li>That's all<a id="_idIndexMarker101"/> of the <strong class="bold">Material</strong> and <strong class="bold">Animation</strong> information removed from our <strong class="source-inline">player_ship</strong> model.<p class="callout-heading">Important Information</p><p class="callout">Throughout the book, whenever we select a three-dimensional model, make sure to run through the same process, as we will not require imported extras such as the ones we just removed. This means I would like you now to repeat the process we have just gone through with the <strong class="source-inline">enemy_wave.fbx</strong> model.</p></li>
			</ol>
			<p>Let's continue preparing our <strong class="source-inline">player_ship</strong> model for our game:</p>
			<ol>
				<li value="1">Click and drag <strong class="source-inline">player_ship</strong> from <strong class="source-inline">Assets/Model</strong> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Select the <strong class="source-inline">player_ship</strong> in the <strong class="bold">Hierarchy</strong> window and set its name and <strong class="bold">Transform</strong> properties to the following values:<ul><li><strong class="bold">Game Object name</strong>: <strong class="source-inline">player_ship</strong></li><li><strong class="bold">Tag</strong>: <strong class="bold">Player</strong> (easier to detect when colliding with enemies or other collisions)</li><li><strong class="bold">Transform</strong>: All values set to <strong class="source-inline">0</strong> apart from <strong class="bold">Scale</strong>, which is set to <strong class="source-inline">1</strong> on all axes</li></ul></li>
			</ol>
			<p>The following screenshot shows the <strong class="source-inline">player_ship</strong> values in the <strong class="bold">Inspector</strong> window:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_2.04_B18381.jpg" alt="Figure 2.4 – The player_ship values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The player_ship values in the Inspector window</p>
			<ol>
				<li value="3">Click <a id="_idIndexMarker102"/>and drag the <strong class="source-inline">player_ship</strong> from the <strong class="bold">Hierarchy</strong> window into the <strong class="source-inline">Assets/Prefab/Player</strong> folder.</li>
			</ol>
			<p>When creating a prefab, sometimes you might be asked if this is an <strong class="bold">Original</strong> or <strong class="bold">Variant</strong>:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_2.05_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The Create Prefab Dialog</p>
			<p>A variant prefab will be a copy of an original prefab but will also carry any changes made from the prefab it originates from. So, for example, if the original prefab was a car with 4 wheels, the variant will have the same. If the original prefab changes it's numbers from 4 to 3, the variant will copy the original prefab.</p>
			<p>Note that <strong class="source-inline">player_ship</strong> in the <strong class="bold">Hierarchy</strong> window has turned blue, which means it has become a prefab.</p>
			<ol>
				<li value="4">Delete the <strong class="source-inline">player_ship</strong> from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>We are going<a id="_idIndexMarker103"/> to use a similar process to create our <strong class="source-inline">enemy_wave</strong> prefab, but we will also need to create its own name tag because there isn't an <strong class="bold">Enemy</strong> tag... yet.</p>
			<h3>An Enemy prefab and custom tags</h3>
			<p>In this<a id="_idIndexMarker104"/> section, we<a id="_idIndexMarker105"/> are going to create an <strong class="source-inline">enemy_wave</strong> prefab along with a custom tag. The tag will be used to identify and categorize all related enemies under one tag.</p>
			<p>To create an <strong class="source-inline">enemy_wave</strong> prefab and custom name tag, follow these instructions:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, drag the <strong class="source-inline">enemy_wave.fbx</strong> file from <strong class="source-inline">Assets/Model</strong> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>With the <strong class="source-inline">enemy_wave</strong> file selected in the <strong class="bold">Hierarchy</strong> window, update the following values in the <strong class="bold">Inspector</strong> window:<ul><li><strong class="bold">Game Object name</strong>: <strong class="source-inline">enemy_wave</strong>.</li><li><strong class="bold">Transform</strong>: All values set to <strong class="source-inline">0</strong> apart from <strong class="bold">Scale</strong>, which is set to <strong class="source-inline">1</strong> on all axes:</li></ul></li>
			</ol>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_2.06_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The enemy_wave values in the Inspector window</p>
			<p>Now, let's <a id="_idIndexMarker106"/>create a new tag for the <strong class="source-inline">enemy_wave</strong> game <a id="_idIndexMarker107"/>object by doing the following:</p>
			<ol>
				<li value="1">Choose the <strong class="bold">Untagged</strong> parameter in the <strong class="bold">Inspector</strong> window.</li>
				<li>From the <strong class="bold">Tag</strong> drop-down menu, select <strong class="bold">Add Tag...</strong>.</li>
				<li>The <strong class="bold">Inspector</strong> window will now show the <strong class="bold">Tags &amp; Layers</strong> window.</li>
				<li>Click the <strong class="bold">+</strong> to add a new tag, as circled in the following screenshot.</li>
				<li>Enter <strong class="source-inline">Enemy</strong> in the pop-up window, as shown in the following screenshot, and then click the <strong class="bold">Save</strong> button:</li>
			</ol>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_2.07_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Add a tag to the Tags &amp; Layers list</p>
			<ol>
				<li value="6">Back in the <strong class="bold">Hierarchy</strong> window, select the <strong class="source-inline">enemy_wave</strong> game object to bring back our <strong class="bold">Inspector</strong> window details.</li>
				<li>Click the <strong class="bold">Untagged</strong> parameter again.</li>
				<li>We can now see <strong class="bold">Enemy</strong> in our drop-down list, so select it.</li>
				<li>Drag the <strong class="source-inline">enemy_wave</strong> game object from the <strong class="bold">Hierarchy</strong> window into <strong class="source-inline">Assets/Prefab/Enemies</strong>.</li>
				<li>Delete <strong class="source-inline">enemy_wave</strong> from the <strong class="bold">Hierarchy</strong> window</li>
			</ol>
			<p>We now move on to our third prefab creation – the player's bullet. But this time, we won't import <a id="_idIndexMarker108"/>a three-dimensional model – we are goin<a id="_idIndexMarker109"/>g to create one in the Unity Editor, and then create a prefab from it in the next section.</p>
			<h3>Creating the player's bullet prefab</h3>
			<p>Next, we are <a id="_idIndexMarker110"/>going to create the<a id="_idIndexMarker111"/> visuals for the player's bullet in the Unity Editor. We will make a blue sphere and give it a surrounding light source. Let's start by creating a three-dimensional sphere game object.</p>
			<p>In the <strong class="bold">Hierarchy</strong> window, right-click, and from the drop-down list, select <strong class="bold">3D Object</strong> | <strong class="bold">Sphere</strong>.</p>
			<p>With the newly created <strong class="source-inline">Sphere</strong> in the <strong class="bold">Hierarchy</strong> window still selected, make the following changes to the <strong class="bold">Inspector</strong> window:</p>
			<ol>
				<li value="1">Change the game object name from <strong class="source-inline">Sphere</strong> to <strong class="source-inline">player_bullet</strong>.</li>
				<li>Change <strong class="bold">Tag</strong> from <strong class="bold">Untagged</strong> to <strong class="bold">Player</strong>. The tag name makes it easier to identify later on in the chapter.</li>
				<li>The <strong class="bold">Transform</strong> parameters are all set to <strong class="source-inline">0</strong>, apart from the <strong class="bold">Scale</strong> values for the bullets, which should be slightly larger, with a <strong class="bold">Scale</strong> value of <strong class="source-inline">2</strong> on all axes.</li>
			</ol>
			<p>The following screenshot shows all three changes:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_2.08_B18381.jpg" alt="Figure 2.8 – The player_bullet values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – The player_bullet values in the Inspector window</p>
			<p>Next, we will<a id="_idIndexMarker112"/> give the <strong class="source-inline">player_bullet</strong> game<a id="_idIndexMarker113"/> object a new blue material.</p>
			<h4>Creating and applying a material to the player's bullet</h4>
			<p>In this section, we <a id="_idIndexMarker114"/>will be creating a simple unlit material that will not take up much of the device's performance, thanks to the simplicity of the material. To create a basic material and apply it to the <strong class="source-inline">player_bullet</strong> object, do the following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">Assets/Material</strong> folder.</li>
				<li>Inside the <strong class="source-inline">Material</strong> folder, make a new folder (the same way we did in the <em class="italic">Setting up our Unity project</em> section) and name the folder <strong class="source-inline">Player</strong>. That way, any material related to the player can be stored inside.</li>
				<li>Double click the newly created <strong class="source-inline">Player</strong> folder and right-click in the <strong class="bold">Project</strong> window (in the open space in the right section of the window) again, and from the drop-down list, select <strong class="bold">Create</strong> | <strong class="bold">Material</strong>.</li>
				<li>A new material file will be made. Rename it <strong class="source-inline">player_bullet</strong>.</li>
				<li>Select the <strong class="source-inline">player_bullet</strong> material, and in the <strong class="bold">Inspector</strong> window, change the material from a <strong class="bold">Standard</strong> shader to <strong class="bold">Unlit</strong> | <strong class="bold">Color</strong> by following the three steps in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_2.09_B18381.jpg" alt="Figure 2.9 – Creating an Unlit Color Material&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – Creating an Unlit Color Material</p>
			<p>The <strong class="bold">Inspector</strong> window will remove the majority of the properties and strip the material <a id="_idIndexMarker115"/>back to something simpler and easier to perform on any device.</p>
			<ol>
				<li value="6">Still in the <strong class="bold">Inspector</strong> window, click the <strong class="bold">Main Color</strong> swatch parameter and change it to a cyan color with the following values: <strong class="bold">R</strong>: <strong class="source-inline">0</strong>, <strong class="bold">G</strong>: <strong class="source-inline">190</strong>, <strong class="bold">B</strong>: <strong class="source-inline">255</strong>, and <strong class="bold">A</strong>: <strong class="source-inline">255</strong>.</li>
			</ol>
			<p>We have created and calibrated our player's bullet, so now, we can apply the material to the <strong class="source-inline">player_bullet</strong> prefab by doing the following:</p>
			<ol>
				<li value="7">Select the <strong class="source-inline">player_bullet</strong> prefab in the following location of the <strong class="bold">Project</strong> window: <strong class="source-inline">Assets/Prefab/Player</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong> window, under the <strong class="bold">Mesh Renderer</strong> component, click the small round radio button to the right of the <strong class="bold">Element 0</strong> parameter and type <strong class="source-inline">player_bullet</strong> in the drop-down list until you see the material, and then select it.</li>
			</ol>
			<p>The following screenshot shows the <strong class="source-inline">player_bullet</strong> prefab's <strong class="bold">Mesh Renderer</strong> component updated to our new unlit material: </p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_2.10_B18381.jpg" alt="Figure 2.10 – player_bullet now has a player_bulletMat material&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – player_bullet now has a player_bulletMat material</p>
			<p>In <a href="B18381_04_Epub.xhtml#_idTextAnchor087"><em class="italic">Chapter 4</em></a><em class="italic">, Applying Art, Animation, and Particles</em>, we will return to materials and art in general, which will be of note if you found this interesting. We will also play around <a id="_idIndexMarker116"/>with particle systems to create a fleet of stars rushing past the player's ship.</p>
			<p>The last component we will add to our player's bullet is a surrounding light to give our bullet an energy glow.</p>
			<h4>Adding a light to the player's bullet</h4>
			<p>In this section, we<a id="_idIndexMarker117"/> will be adding a light component to the player's bullet to hide the impression that all that we are doing is firing spheres. It will also introduce us to Unity's point light, which acts as a glowing ball.</p>
			<p>To add and customize a ball of light to the player's bullet, we need to do the following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">Assets/Prefab/Player</strong> folder, select the <strong class="source-inline">player_bullet</strong> prefab, and drag it into the <strong class="bold">Hierarchy</strong> window (if it isn't in the Hierarchy window already).</li>
				<li>In the <strong class="bold">Inspector</strong> at the bottom of the components listed, click the <strong class="bold">Add Component</strong> button and select <strong class="bold">Light</strong> from the drop-down list.</li>
			</ol>
			<p>The <strong class="source-inline">player_bullet</strong> prefab will now have a <strong class="bold">Light</strong> component attached to it. We just need to change three property values to make the light suit the game object more. </p>
			<ol>
				<li value="3">Change the following property values in the <strong class="source-inline">player_bullet</strong> file's <strong class="bold">Light</strong> component:<ul><li><strong class="bold">Range</strong>: <strong class="source-inline">50</strong></li><li><strong class="bold">Color</strong>: <strong class="bold">R</strong>: <strong class="source-inline">0</strong>, <strong class="bold">G</strong>: <strong class="source-inline">190</strong>, <strong class="bold">B</strong>: <strong class="source-inline">255</strong>, and <strong class="bold">A</strong>: <strong class="source-inline">255</strong></li><li><strong class="bold">Intensity</strong>: <strong class="source-inline">20</strong></li></ul></li>
			</ol>
			<p>The following<a id="_idIndexMarker118"/> screenshot shows the <strong class="bold">Light</strong> component after the values have been updated:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_2.11_B18381.jpg" alt="Figure 2.11 – The Light component values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – The Light component values in the Inspector window</p>
			<p>Before moving onto the next section, because we have taken an existing prefab and added a material and a light component, we need to click the <strong class="bold">Override</strong> button to confirm the new changes.</p>
			<p>The following screenshot shows the <strong class="bold">Overrides</strong> button at the top-right corner of the <strong class="bold">Inspector</strong> window for our <strong class="source-inline">player_bullet</strong> prefab:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_2.12_B18381.jpg" alt="Figure 2.12 – Updating the player_bullet prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 2.12 – Updating the player_bullet prefab</p>
			<ol>
				<li value="4">Finally, click on <strong class="bold">Apply All</strong> to accept our updated light settings and then delete the <strong class="source-inline">player_bullet</strong> from the <strong class="bold">Hierarchy</strong>.</li>
			</ol>
			<p>In the next<a id="_idIndexMarker119"/> section, we will continue to update our three prefabs by applying Unity's own physics system, the <strong class="bold">Rigidbody</strong> component, to help detect collisions.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Adding Rigidbody components and fixing game objects</h2>
			<p>Because <a id="_idIndexMarker120"/>this<a id="_idIndexMarker121"/> game<a id="_idIndexMarker122"/> involves collisions<a id="_idIndexMarker123"/> with game objects, we need to apply collision detection to the player, the player's bullets, and the enemy. Unity offers a range of different shapes to wrap around a game object that functions as an invisible shield; we can set our code to react to contact being made with the shield.</p>
			<p>Before we add colliders to the player and enemy game objects (the <strong class="bold">Sphere</strong> game object automatically comes with a collider), we need to add a Unity component called <strong class="bold">Rigidbody</strong>. If a game object is going to collide with at least one other game object, it requires a <strong class="bold">Rigidbody</strong> component, which can affect a game object's mass, gravity, drag, constraints, and more. If you would like to know more about <strong class="bold">Rigidbody</strong> components, check out the documentation at <a href="https://docs.unity3d.com/Manual/class-Rigidbody.html">https://docs.unity3d.com/Manual/class-Rigidbody.html</a>.</p>
			<p class="callout-heading">Rigidbody Joints</p>
			<p class="callout">Unity has other physics types apart from the collider. <strong class="bold">Joints</strong> also require the <strong class="bold">Rigidbody</strong> system, and they come in different forms, such as <strong class="bold">Hinge</strong>, <strong class="bold">Spring</strong>, and others.</p>
			<p class="callout">These <strong class="bold">Joints</strong> will simulate at a fixed point; for example, the <strong class="bold">Hinge</strong> <strong class="bold">Joint</strong> would be good at making a door swing back and forth around a door hinge's pivot point. </p>
			<p class="callout">If you would like to know more about Joints, check the documentation at <a href="https://docs.unity3d.com/Manual/Joints.html">https://docs.unity3d.com/Manual/Joints.html</a>.</p>
			<p>Let's add<a id="_idIndexMarker124"/> the <strong class="bold">Rigidbody</strong> component <a id="_idIndexMarker125"/>to the <strong class="source-inline">player_ship</strong> and <strong class="source-inline">player_bullet</strong> prefabs<a id="_idIndexMarker126"/> in <a id="_idIndexMarker127"/>one go:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to <strong class="bold">Prefab | Player</strong>.</li>
				<li>Hold <em class="italic">Ctrl</em> (<em class="italic">command</em> on a Mac) and click on the <strong class="source-inline">player_ship</strong> and <strong class="source-inline">player_bullet</strong> files.</li>
				<li>In the <strong class="bold">Inspector</strong> window, click the <strong class="bold">Add Component</strong> button.</li>
				<li>From the drop-down menu, type <strong class="source-inline">Rigidbody</strong>.</li>
				<li>Select <strong class="bold">Rigidbody</strong> (not <strong class="bold">Rigidbody 2D</strong>).</li>
				<li>The <strong class="bold">Rigidbody</strong> component has now been assigned to our two game objects.</li>
				<li>With the two game objects still selected in the <strong class="bold">Inspector</strong> window, under <strong class="bold">Rigidbody</strong>, make sure that the <strong class="bold">Gravity</strong> checkbox isn't ticked. If it was, our game objects would begin to sink into the scene while the game is being played.</li>
			</ol>
			<p>Now, we can add colliders to our <strong class="source-inline">player_ship</strong> and <strong class="source-inline">enemy_wave</strong> game objects (our <strong class="source-inline">player_bullet</strong> already has a <strong class="bold">SphereCollider</strong>). We will be adding a <strong class="bold">SphereCollider</strong> to our game objects because it's the cheapest collider to use, relative to performance costs:</p>
			<ol>
				<li value="1">Click and drag the <strong class="source-inline">player_ship</strong> prefab from the <strong class="bold">Project</strong> window location of <strong class="source-inline">Assets/Prefab/Player</strong> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>With the <strong class="source-inline">player_ship</strong> still selected in the <strong class="bold">Hierarchy</strong> window, click the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> window and type <strong class="source-inline">Sphere Collider</strong> in the drop-down menu.</li>
				<li>As soon as you see <strong class="bold">SphereCollider</strong> in the list, click it to add it to the <strong class="source-inline">player_ship</strong> game object.</li>
			</ol>
			<p>You will notice a green wireframe around the <strong class="source-inline">player_ship</strong> in the <strong class="bold">Scene</strong> window (with the <strong class="source-inline">player_ship</strong> still selected in the <strong class="bold">Hierarchy</strong> window, hover your mouse in the <strong class="bold">Scene</strong> window and press <em class="italic">F</em> on the<a id="_idIndexMarker128"/> keyboard <a id="_idIndexMarker129"/>to<a id="_idIndexMarker130"/> zoom <a id="_idIndexMarker131"/>in on the ship if you can't see it). This is the <strong class="source-inline">player_ship</strong> collider that will be used to detect hits. It may be too big for the purpose of a hitbox, so let's reduce its size.</p>
			<ol>
				<li value="4">With the <strong class="source-inline">player_ship</strong> prefab still selected in the <strong class="bold">Hierarchy</strong> window, alter the <strong class="bold">Radius</strong> of the <strong class="bold">SphereCollider</strong> component to <strong class="source-inline">0.3</strong> in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_2.13_B18381.jpg" alt="Figure 2.13 – The triggered sphere collider added to the player_ship prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.13 – The triggered sphere collider added to the player_ship prefab</p>
			<ol>
				<li value="5">Also, while we still have the <strong class="source-inline">player_ship</strong> prefab selected, check the <strong class="bold">Is Trigger</strong> box, as shown in the previous screenshot. This will make the <strong class="source-inline">player_ship</strong> prefab look for another collider without causing any form of potential physics collision.</li>
				<li>Click <strong class="bold">Override</strong> at the top-right corner followed by <strong class="bold">Apply All</strong> in  the <strong class="bold">Inspector</strong> window to update the modifications we've made to our prefab with its <strong class="bold">Rigidbody</strong> and <strong class="bold">SphereCollider</strong> components.</li>
				<li>We can now select the <strong class="source-inline">player_ship</strong> prefab in the <strong class="bold">Hierarchy</strong> window and press <em class="italic">Delete</em> on our keyboard, as we no longer need it in our <strong class="bold">Scene</strong>.</li>
			</ol>
			<p>We <a id="_idIndexMarker132"/>now <a id="_idIndexMarker133"/>need<a id="_idIndexMarker134"/> to <a id="_idIndexMarker135"/>apply the same methodology to the <strong class="bold">SphereCollider</strong> component of our <strong class="source-inline">player_bullet</strong>:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, click and drag the <strong class="source-inline">player_bullet</strong> prefab from <strong class="source-inline">Assets /Prefab/Player</strong> into the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Check the <strong class="bold">Is Trigger</strong> box and adjust the <strong class="bold">Radius</strong> in the <strong class="bold">SphereCollider</strong> component in the <strong class="bold">Inspector</strong> window.</li>
				<li>Click <strong class="bold">Overrides</strong> and then <strong class="bold">Apply All</strong> at the top-right corner of the <strong class="bold">Inspector</strong> window to confirm the <strong class="source-inline">player_bullet</strong> changes, and delete the <strong class="source-inline">player_bullet</strong> prefab from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>The last game object we need to update is the <strong class="source-inline">enemy_wave</strong> prefab. We have already covered the steps with the <strong class="source-inline">player_ship</strong> and <strong class="source-inline">player_bullet</strong> prefabs, so it's not ideal to repeat the instructions in full; however, we need to do the following:</p>
			<ol>
				<li value="1">Briefly, I want you to drag and drop the <strong class="source-inline">enemy_wave</strong> prefab from its location at <strong class="source-inline">Assets/Prefab/Enemies</strong> in the <strong class="bold">Project</strong> window into the <strong class="bold">Hierarchy</strong> window..</li>
				<li>Add a <strong class="bold">SphereCollider</strong> component to the <strong class="source-inline">enemy_wave</strong> prefab in the <strong class="bold">Inspector</strong> window.</li>
				<li>Adjust the <strong class="bold">SphereCollider</strong> component so that <strong class="bold">Is Trigger</strong> is checked and the <strong class="bold">Radius</strong> value fits around the <strong class="source-inline">enemy_wave</strong> prefab with the correct proportions, as we did with <strong class="source-inline">player_ship</strong>.</li>
				<li>The <strong class="source-inline">enemy_wave</strong> prefab doesn't require a <strong class="bold">Rigidbody</strong> component, as it will be colliding with relevant game objects that hold one themselves.</li>
				<li>Finally, <strong class="bold">Override, Apply All </strong>the prefab changes and remove the <strong class="source-inline">enemy_wave</strong> prefab from the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>Use the following <a id="_idIndexMarker136"/>screenshot as a reference for the preceding<a id="_idIndexMarker137"/> mini-brief, and if you get stuck, use<a id="_idIndexMarker138"/> the <a id="_idIndexMarker139"/>previous steps that we discussed in this section:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_2.14_B18381.jpg" alt="Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.14 – The trigger collider added and scaled to the enemy_wave prefab</p>
			<p>Hopefully, that went well for you. If you get stuck at any point, refer to the <a href="https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage">https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/blob/main/Chapter_02/ProjectFIles/Chapter-02-Complete.unitypackage</a> folder containing all the completed files to check them out and compare.</p>
			<p>Before moving on, note that if a game object is pink, such as our <strong class="source-inline">enemy_wave</strong> object in the previous screenshot, it simply means that it doesn't have a material attached. In other cases, it can also mean there is something wrong with the shader attached to the material.</p>
			<p>We can fix this pink issue by doing the following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to <strong class="source-inline">Assets/Prefab/Enemies</strong>.</li>
				<li>Drag and drop enemy_wave into the Hierarchy window. Expand the drop down next to <strong class="source-inline">enemy_wave</strong> in the Hierarchy window..</li>
				<li>Select the first game object, titled <strong class="source-inline">enemy_wave_core</strong>.</li>
				<li>In the <strong class="bold">Inspector</strong> window, select the small <strong class="bold">remote</strong> circle next to the <strong class="bold">Element 0</strong> parameter<a id="_idIndexMarker140"/> in the <strong class="bold">Mesh Renderer</strong> component (denoted<a id="_idIndexMarker141"/> by <strong class="bold">1</strong> in the following screenshot), and<a id="_idIndexMarker142"/> then<a id="_idIndexMarker143"/> select <strong class="bold">Default-Material</strong> (denoted by <strong class="bold">2</strong>) from the drop-down list, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_2.15_B18381.jpg" alt="Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.15 – Adding a Default Material to the enemy_wave_core gameobject</p>
			<ol>
				<li value="5">Follow the same steps for its sibling game object, <strong class="source-inline">enemy_wave_ring</strong>.</li>
			</ol>
			<p>The <strong class="source-inline">enemy_wave</strong> object will now have a default material applied.If any changes were made to the prefab be sure to click <strong class="bold">Override, Apply All</strong>.</p>
			<p class="callout-heading">Attributes</p>
			<p class="callout">If a game object requires a component such as <strong class="source-inline">Rigidbody</strong>, we can place, above the class name, what is effectively a reminder to the script that the game object needs it:</p>
			<p class="callout"><strong class="source-inline">[RequireComponent(typeof(Rigidbody))]</strong></p>
			<p class="callout">If the game object doesn't have the component, the script will create one, and if we try to remove the <strong class="source-inline">Rigidbody</strong> component, we will receive a message in the Unity Editor that it is a required component.</p>
			<p class="callout">This code isn't a requirement as such, more of a good practice with components in general.</p>
			<p class="callout">If you would like to know more about the <strong class="source-inline">RequireComponent</strong> attribute, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/RequireComponent.html">https://docs.unity3d.com/ScriptReference/RequireComponent.html</a>.</p>
			<p>So, now we <a id="_idIndexMarker144"/>have <a id="_idIndexMarker145"/>our <a id="_idIndexMarker146"/>colliders and <strong class="bold">Rigidbody</strong> components<a id="_idIndexMarker147"/> applied to our game objects. This gives us the ability to create a reaction when colliders come into contact with each other.</p>
			<p>Because we are starting to build up our project, let's quickly discuss saving our scenes, projects, and so on.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Saving and publishing our work</h2>
			<p>It's easy to<a id="_idIndexMarker148"/> get stuck into our project, but as a brief reminder, save your work as often as possible. That way, if anything bad happens, you can always revert back.</p>
			<p>Because we have created and saved our <strong class="source-inline">testLevel</strong> scene from the previous chapter, we can also add this scene to the <strong class="bold">Build Settings</strong> window. The reason for this is so that Unity is aware of what scenes we want to include in our project. It is also a requirement when it comes to packaging up our game as a build for deployment.</p>
			<p>To add our scene to <strong class="bold">Build Settings</strong>, do the following:</p>
			<ol>
				<li value="1">At the top of the Unity Editor, click <strong class="bold">File | Build Settings</strong>. The <strong class="bold">Build Settings</strong> window will appear.</li>
				<li>Click the <strong class="bold">Add Open Scenes</strong> button to add the <strong class="source-inline">testLevel</strong> scene.</li>
				<li>The following screenshot shows the <strong class="bold">Add Open Scenes</strong> button circled, as well as an arrow pointing to the number index of our <strong class="source-inline">testLevel</strong> scene. When we add more scenes later, each scene will be numbered:</li>
			</ol>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_2.16_B18381.jpg" alt="Figure 2.16 – Adding the testLevel scene to the Scenes In Build list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.16 – Adding the testLevel scene to the Scenes In Build list</p>
			<ol>
				<li value="4">Close<a id="_idIndexMarker149"/> the <strong class="bold">Build Settings</strong> window. We will come back to this when we have more scenes to add in the next chapter.</li>
				<li>It's a good habit to save the project by clicking <strong class="bold">File | Save Project</strong>.</li>
			</ol>
			<p>Let's now continue with setting up <a id="_idIndexMarker150"/>our scene camera in the Unity Editor.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Unity Editor Layout</h2>
			<p>For our <a id="_idIndexMarker151"/>side-scrolling shooter game <em class="italic">Killer Wave</em>, we need control over a camera to display the aspect ratio and visible depth of the scene, and to make sure we show the correct amount of our game's environment.</p>
			<p>Let's get started and decide on the screen ratio of our game. We'll create our own resolution, which will be fairly common across most platforms. </p>
			<p>To change the <strong class="bold">Game</strong> window's screen ratio to a custom aspect, do the following:</p>
			<ol>
				<li value="1">Click the current aspect ratio under the <strong class="bold">Game</strong> window tab and select the <strong class="bold">+</strong> symbol.</li>
				<li>Enter the custom aspect ratio values shown in the following screenshot.</li>
				<li>Click <strong class="bold">OK</strong> once done, and select the <strong class="source-inline">1080</strong> resolution we have just made:</li>
			</ol>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_2.18_B18381.jpg" alt="Figure 2.18 – Setting a custom Game window resolution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.17 – Setting a custom Game window resolution</p>
			<p>It is good to be aware of the need to make our game's artwork support (or to give it the scope to extend to) as many screen ratios as possible, especially if we ever wanted to make a game for portable devices such as tablets or mobile phones. This is because nearly every major brand of phone and tablet comes in different ratio sizes, and we don't want to start squashing and squeezing our content, as it won't look right. It's also possible that our small mobile games will become successful and could later be ported to a console or PC. If that's the case, we need to make the game screen support these ratios too. The main point to take from all of this is that we are targeting our game to cover all possible common screen ratios. The more platforms (consoles, portable devices, and so on) we can cover with flexible screen ratios, the easier it will be to extend our game out to those devices without requiring extra work. We explain more about screen size ratios in <a href="B18381_08_Epub.xhtml#_idTextAnchor150"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding Custom Fonts and UI</em>, and <a href="B18381_09_Epub.xhtml#_idTextAnchor161"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating a 2D Shop Interface and In-Game HUD</em>, where we discuss UI display settings. Additionally, in <a href="B18381_13_Epub.xhtml#_idTextAnchor219"><em class="italic">Chapter 13</em></a>, <em class="italic">Effects, Testing, Performance, and Alt Controls</em>, we will explain how to display our game screen on a raw image component.</p>
			<p>Before we continue any further with our project, it's probably a good time to confirm our understanding of Unity's own UI layout. The following screenshot shows the Unity Editor, where<a id="_idIndexMarker152"/> I have outlined and labeled the relevant windows:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_2.19_B18381.jpg" alt="Figure 2.19 – The Unity editor window layout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.18 – The Unity Editor window layout</p>
			<p>Typically, the <a id="_idIndexMarker153"/>Unity Editor window is made up of five main windows:</p>
			<ul>
				<li><strong class="bold">Scene</strong>: This is our two-/three-dimensional workspace.</li>
				<li><strong class="bold">Game</strong>: This window is what the end user will see. By default, the <strong class="bold">Game</strong> tab shares the same space as the <strong class="bold">Scene</strong> window.</li>
				<li><strong class="bold">Hierarchy</strong>: All game objects in our scene will be listed here.</li>
				<li><strong class="bold">Inspector</strong>: When an object is selected, information about it will be displayed here.</li>
				<li><strong class="bold">Project</strong>: This is our Unity project folder. Consider it a structure of files and folders that we <a id="_idIndexMarker154"/>can use in our game.<p class="callout-heading">Tip</p><p class="callout">To drag each window around individually, left-click and drag the name of the tab, and it will then snap into different locations.</p></li>
			</ul>
			<p>My <strong class="bold">Game</strong> window is set to <strong class="bold">1080</strong>, and because I don't have the luxury of a second screen, I've clicked its name tab (<strong class="bold">Game</strong>) and pulled it down in the bottom-right corner. The window is small, but as you can see at the top of the <strong class="bold">Game</strong> window, the scale is set to 1x, which means I have a full picture; nothing is hidden or cut out of view.</p>
			<p>To check that we <a id="_idIndexMarker155"/>have the main camera's <strong class="bold">Transform</strong> properties reset to their default settings, make sure that <strong class="bold">Position</strong>, <strong class="bold">Rotation</strong>, and <strong class="bold">Scale</strong> are all set to <strong class="source-inline">0</strong>. We can also reset the <strong class="bold">Transform</strong> option as follows:</p>
			<ol>
				<li value="1">With the main camera selected in the <strong class="bold">Hierarchy</strong> window, click the three dots at the top-right corner of the <strong class="bold">Transform</strong> panel in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:  </li>
			</ol>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_2.20_B18381.jpg" alt="Figure 2.20 – The Transform settings cog location&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.19 – The Transform settings cog location</p>
			<ol>
				<li value="2">When the dropdown appears, click <strong class="bold">Reset</strong>.</li>
			</ol>
			<p>Continuing with setting up our main camera, let's get rid of the landscape background in our <strong class="bold">Scene</strong>/<strong class="bold">Game</strong> window by changing its <strong class="bold">Background</strong> setting:</p>
			<ol>
				<li value="3">Click the <strong class="bold">Main Camera</strong> in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>In the <strong class="bold">Inspector</strong> window, we have the <strong class="bold">Camera</strong> component with a property called <strong class="bold">Clear Flags</strong>. Click the <strong class="bold">Skybox</strong> value. </li>
				<li>A dropdown <a id="_idIndexMarker156"/>will appear. Click <strong class="bold">Solid Color</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_2.21_B18381.jpg" alt="Figure 2.21 – Changing Background to a Solid Color&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.20 – Changing Background to a Solid Color</p>
			<ol>
				<li value="6">We will now be presented with a blue background, which is less distracting.</li>
				<li>If you don't like blue, you can change it to any color in the <strong class="bold">Background</strong> property. I'm going to make mine black by changing the Red, Green, Blue, and Alpha (RGBA) values to <strong class="bold">R</strong>: <strong class="source-inline">0</strong>, <strong class="bold">G</strong>: <strong class="source-inline">0</strong>, <strong class="bold">B</strong>: <strong class="source-inline">0</strong>, and <strong class="bold">A</strong>: <strong class="source-inline">255</strong>, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_2.22_B18381.jpg" alt="Figure 2.22 – Setting Background color values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.21 – Setting Background color values</p>
			<p>Great, now let's<a id="_idIndexMarker157"/> move on to coding these properties for our main camera.</p>
			<h3>Updating our camera properties via a script</h3>
			<p>We now<a id="_idIndexMarker158"/> have our main camera's behavior set in our <strong class="bold">Scene</strong>. Next, we need to code this into a script so that whenever a scene is loaded, Unity will read the script and understand how the main camera should be set up.</p>
			<p>Observing our framework again, let's see where the camera script should be placed:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_2.23_B18381.jpg" alt="Figure 2.23 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.22 – Killer Wave UML</p>
			<p>As you can see in the diagram, there is no reference to the camera, so should we make a script to support this? Arguably, the only reason to make a script based on the camera would be if the<a id="_idIndexMarker159"/> camera had a complex purpose filled with multiple properties and functions. The camera in our game, however, is put in place when the game starts. Later on, on the third level, the camera will move from left to right with a simple component script, but it doesn't hold any other complexity. It would, therefore, be more ideal to use the <strong class="source-inline">GameManager</strong>, as it only takes up a small role. If the game became bigger and the camera took on more of a role, then this might justify the camera having a class of its own. Others might disagree based on personal preference, but this is the approach we'll take.</p>
			<p>Let's make the <strong class="source-inline">GameManager</strong> script, as follows:</p>
			<ol>
				<li value="1">Create a script in the same way that we created a folder. Right-click the open space area in the <strong class="bold">Project</strong> window, and a dropdown will appear. Click <strong class="bold">Create | C# Script</strong>, as follows:</li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_2.24_B18381.jpg" alt="Figure 2.24 – Creating a C# script in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.23– Creating a C# script in the Unity Editor</p>
			<ol>
				<li value="2">The script appears <a id="_idIndexMarker160"/>with the title <strong class="source-inline">NewBehaviourScript</strong>. We don't want to call it that, so type (in camel case) <strong class="source-inline">GameManager</strong>.<p class="callout-heading">What's camel casing? </p><p class="callout">Camel casing is a way to avoid spacing between words. This is fairly common with programming, as spaces are typically not welcomed for various reasons. Each new word starts with a capital letter, so in this case, the M in <strong class="source-inline">GameManager</strong> is the hump of the camel. However, variables typically start with lowercase, as you will see shortly.</p></li>
			</ol>
			<p>We now have our <strong class="source-inline">GameManager</strong> script. Notice how Unity is trying to be helpful by changing the icon to a silver cog because what we are doing is a recognized method with Unity:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_2.25_B18381.jpg" alt="Figure 2.25 – The GameManager icon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.24 – The GameManager icon</p>
			<p>As we did when placing our three-dimensional models into the <strong class="bold">Model</strong> folder, move the <strong class="source-inline">GameManager</strong> into the <strong class="source-inline">Script</strong> folder.</p>
			<p>Good. Now, before we open our script to code in it, we need to attach it to a game object in our<a id="_idIndexMarker161"/> scene so that when the scene runs, the script attached to the game object also runs.</p>
			<p>To create our <strong class="source-inline">GameManager</strong> game object, we need to do the following:</p>
			<ol>
				<li value="1">Right-click in an open space in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>From the drop-down menu, select <strong class="bold">Create Empty</strong>.</li>
				<li>Right-click the newly created game object and select <strong class="bold">Rename</strong> from the drop-down menu.</li>
				<li>Rename this game object <strong class="source-inline">GameManager</strong>.</li>
				<li>Finally, with the <strong class="source-inline">GameManager</strong> game object still selected, click the <strong class="bold">Add Component</strong> button in the far-right <strong class="bold">Inspector</strong> window.</li>
				<li>Type <strong class="source-inline">GameManager</strong> from the drop-down menu until you see the <strong class="source-inline">GameManager</strong> script and select it.<p class="callout-heading">Tip</p><p class="callout">Whenever we make an empty game object, we must be sure that all of its <strong class="bold">Transform</strong> property values are reset to their default values unless we are specifically changing them.</p><p class="callout">To reset a game object's <strong class="bold">Transform</strong> value, make sure that the game object we are resetting is selected. Click the metal cog at the top-right corner of the <strong class="bold">Inspector</strong> window, and then select <strong class="bold">Reset</strong>.</p></li>
			</ol>
			<p>Double-click the <strong class="source-inline">GameManager</strong> script to open it up in your IDE (Visual Studio or whatever <a id="_idIndexMarker162"/>IDE you use), and then proceed as follows:</p>
			<ol>
				<li value="1">Inside the <strong class="source-inline">GameManager</strong> script, we will be faced with the <strong class="source-inline">UnityEngine</strong> library being imported into our script to add extra functionality to Unity's own components:<p class="source-code"><strong class="bold">using UnityEngine;</strong></p><p class="source-code"><strong class="bold">      public class GameManager : MonoBehaviour </strong></p><p class="source-code"><strong class="bold">      {</strong></p></li>
			</ol>
			<p>Also in the preceding code, we have the name of our script along with <strong class="source-inline">MonoBehaviour</strong> being inherited yet again to add more functionality to our script. <strong class="source-inline">MonoBehaviour</strong> is also required if the game object that attaches to this script needs to be used in the Unity Editor.</p>
			<p>Let's start adding some of our own code into our <strong class="source-inline">GameManager</strong> script.</p>
			<ol>
				<li value="2">Create an empty method, <strong class="source-inline">CameraSetup</strong>, and then run this method in the <strong class="source-inline">Start</strong> function:<p class="source-code">    void Start()</p><p class="source-code">              {</p><p class="source-code">             CameraSetup();  </p><p class="source-code">         }</p><p class="source-code">         void CameraSetup()</p><p class="source-code">         {</p><p class="source-code">     </p><p class="source-code">         }</p></li>
				<li>Inside the <strong class="source-inline">CameraSetup</strong> method, add a reference to the camera and set the position and angle of the camera to zero apart from its <em class="italic">z</em> axis. We'll set <strong class="source-inline">Z</strong> to <strong class="source-inline">-300</strong>, which will<a id="_idIndexMarker163"/> move the camera back and ensure all game objects are in the shot:<p class="source-code">GameObject gameCamera =</p><p class="source-code">         GameObject.FindGameObjectWithTag("MainCamera");</p><p class="source-code">     </p><p class="source-code">     //Camera Transform</p><p class="source-code">     gameCamera.transform.position = new Vector3(0,0,-300);</p><p class="source-code">     gameCamera.transform.eulerAngles = new Vector3(0,0,0);</p></li>
				<li>Next, we will change the properties of the camera within our <strong class="source-inline">CameraSetup</strong> method:<p class="source-code"> //Camera Properties</p><p class="source-code">      gameCamera.GetComponent&lt;Camera&gt;().clearFlags =</p><p class="source-code">         CameraClearFlags.SolidColor;</p><p class="source-code">      gameCamera.GetComponent&lt;Camera&gt;().backgroundColor = </p><p class="source-code">         new Color32(0,0,0,255);</p><p class="source-code">      }</p></li>
			</ol>
			<p>This does the following:</p>
			<ul>
				<li>Removes the sky background and replaces it with a solid color</li>
				<li>Changes the solid color from the default blue to black</li>
			</ul>
			<ol>
				<li value="5">Finally, save the script.</li>
			</ol>
			<p>Now, you <a id="_idIndexMarker164"/>should have something like this:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_2.26_B18381.jpg" alt="Figure 2.26 – The current code layout for the GameManager script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.25– The current code layout for the GameManager script</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you would like to change other settings relating to the camera, you can find out about them at <a href="https://docs.unity3d.com/ScriptReference/Camera.html">https://docs.unity3d.com/ScriptReference/Camera.html</a>.</p>
			<p>Press the <strong class="bold">Play</strong> button in the upper middle of the editor window, or by using the shortcut <em class="italic">Ctrl</em> + <em class="italic">P</em> (<em class="italic">Command</em> + <em class="italic">P</em> on the Mac). The following screenshot shows where the <strong class="bold">Play</strong> button is located:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_2.27_B18381.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.26 – The Play, Pause, and Step button locations</p>
			<p>With the scene in play mode, we can now check out the <strong class="bold">Main Camera</strong> game object's properties by doing the following:</p>
			<ol>
				<li value="1">In <a id="_idIndexMarker165"/>the <strong class="bold">Hierarchy</strong> window, select <strong class="bold">Main Camera</strong>.</li>
			</ol>
			<p>Observe the <strong class="bold">Inspector</strong> window in the next screenshot to see the following changes our script has made.</p>
			<ol>
				<li value="2">In the <strong class="bold">Transform</strong> component of the <strong class="bold">Inspector</strong> window, we can see that the <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> properties are set to the same values set in our script (denoted by <strong class="bold">1</strong> in the following screenshot).</li>
				<li>In the <strong class="bold">Camera</strong> component of the <strong class="bold">Inspector</strong> window, we can see that the <strong class="bold">Clear Flags</strong> and <strong class="bold">Background</strong> values are also set to the same values set in our script (denoted by <strong class="bold">2i</strong> and <strong class="bold">2ii</strong>).</li>
			</ol>
			<p>The following screenshot shows the <strong class="bold">Main Camera</strong> component properties being updated in Play mode:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_2.28_B18381.jpg" alt="Figure 2.28 – Main Camera values changing with our script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.27 – Main Camera values changing with our script</p>
			<p>Now, hopefully, our properties should be the same as what we have scripted (with no errors). If not, you will likely have an error message in the <strong class="bold">Console</strong> window. If there is an error, it will likely tell you what line the error is on. You can also double-click the error, and it will take you to the line the error is on.</p>
			<p>To double-check <a id="_idIndexMarker166"/>everything has worked, change the <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> of the camera in the editor, and then press the <strong class="bold">Play</strong> button. The properties for the camera should now be set to our script's <strong class="bold">Position</strong> and <strong class="bold">Rotation</strong> properties. </p>
			<p>At this point, while the editor is still playing, we can also make a prefab of the camera:</p>
			<ol>
				<li value="1">Click and drag the <strong class="bold">Camera</strong> from the <strong class="bold">Hierarchy</strong> window down into the <strong class="bold">Project</strong> window, and we will generate a blue cube with the camera's name or an empty icon. Depending on the scale of our icons, the size of the icon can be altered by moving the slider shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_2.29_B18381.jpg" alt="Figure 2.29 – The slider in the bottom right of the Project window zooms in and out of thumbnails&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.28 – The slider in the bottom right of the Project window zooms in and out of thumbnails</p>
			<ol>
				<li value="2">Move this camera prefab into the <strong class="source-inline">Prefab</strong> folder.</li>
			</ol>
			<p>You might be thinking, <em class="italic">why didn't we just make a prefab of the camera in the first place instead of fiddling with its property settings in code?</em> However, two key things are important <a id="_idIndexMarker167"/>here: firstly, we are studying for an exam that is likely to cover such properties; and secondly, you now know how to change these settings dynamically through code.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Another benefit to scripting Unity's components is that we can sometimes be offered more functionality than what is displayed in the Editor. For example, the <strong class="source-inline">Camera</strong> component has a <strong class="source-inline">layerCullDistances</strong> property that is only accessible via scripting. This can offer functionality such as skipping the rendering of smaller game objects in the far distance to increase a game's performance.</p>
			<p class="callout">To read more about <strong class="source-inline">layerCullDistances</strong>, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html">https://docs.unity3d.com/ScriptReference/Camera-layerCullDistances.html</a>.</p>
			<p>This brings this section to a close. So far, we have covered the following:</p>
			<ul>
				<li>Setting up a ratio for our game camera</li>
				<li>Setting up our Unity Editor with individual windows</li>
				<li>Changing the properties of our <strong class="bold">Camera</strong> component in the Unity Editor</li>
				<li>Repeating the changes we made to our camera in the <strong class="source-inline">GameManager</strong> script</li>
				<li>Adding our <strong class="source-inline">GameManager</strong> script to our scene as a game object</li>
			</ul>
			<p>As a programmer, the importance of being able to understand and change the settings in the Unity Editor (but also being able to do the same in code) can be expanded to other components that are in the editor. This is what we will do next, with a focus on directional light.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Setting up our light</h2>
			<p>As a default<a id="_idIndexMarker168"/> setup, each scene comes with a directional light, and currently, this is all we need to get going; ideally, we want the scene to be well lit.</p>
			<p>With the directional light already present in the scene as the default light, select it in the <strong class="bold">Hierarchy</strong> window. In the <strong class="bold">Inspector</strong> window, set the <strong class="bold">Directional Light</strong>'s <strong class="bold">Transform</strong> <strong class="bold">Rotation</strong> values to the following: <strong class="bold">X</strong>: <strong class="source-inline">50</strong>, <strong class="bold">Y</strong>: <strong class="source-inline">-30</strong>, and <strong class="bold">Z</strong>: <strong class="source-inline">0</strong>.</p>
			<p>When we put our player ship into the scene, this will light it up well, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_2.30_B18381.jpg" alt="Figure 2.30 – The player ship lit up&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.29 – The player ship lit up</p>
			<p class="callout-heading">Different Lights</p>
			<p class="callout">Unity provides three different types of real-time lights. As well as the <strong class="bold">directional</strong> light we mentioned, it also provides a <strong class="bold">point</strong> light, which is like a 360° glow that we will cover in <a href="B18381_04_Epub.xhtml#_idTextAnchor087"><em class="italic">Chapter 4</em></a>, <em class="italic">Applying Art, Animation, and Particles</em>. The third type of light is a spotlight or, as Unity refers to it, a <strong class="bold">spot</strong>. The <strong class="bold">spot</strong> can also have masks applied, so it can project images known as cookies.</p>
			<p class="callout">For more information about the three types of lights, check out <a href="https://docs.unity3d.com/Manual/Lighting.html">https://docs.unity3d.com/Manual/Lighting.html</a>.</p>
			<p>We can now make<a id="_idIndexMarker169"/> sure these settings stay in place by adding them to the <strong class="source-inline">GameManager</strong> script. We can also alter the light's color.</p>
			<h3>Updating our light properties via a script</h3>
			<p>In the <strong class="source-inline">GameManager</strong>, we <a id="_idIndexMarker170"/>will set the <strong class="bold">Transform</strong> <strong class="bold">Rotation</strong> values and change the color tint from a light yellow to a cold blue:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">GameManager</strong> script and enter the following method:<p class="source-code">void LightSetup()</p><p class="source-code">       {</p><p class="source-code">          GameObject dirLight = GameObject.Find("Directional Light");</p><p class="source-code">          dirLight.transform.eulerAngles = new Vector3(50,-30,0);</p><p class="source-code">          dirLight.GetComponent&lt;Light&gt;().color = </p><p class="source-code">             new Color32(152,204,255,255);</p><p class="source-code">       }</p></li>
				<li>Add <strong class="source-inline">LightSetup();</strong> in the scope of the <strong class="source-inline">Start</strong> function.</li>
				<li>Save the script. </li>
			</ol>
			<p>The <strong class="source-inline">LightSetup</strong> method does three things:</p>
			<ol>
				<li value="1">It grabs the light from the scene and stores it as a reference.</li>
				<li>It sets the rotation of the light with <strong class="source-inline">EulerAngles</strong>.</li>
				<li>Finally, it changes the light's color.<p class="callout-heading">EulerAngles</p><p class="callout"><strong class="source-inline">eulerAngles</strong> allows us to give <strong class="source-inline">Vector3</strong> coordinates instead of <strong class="source-inline">Quaternion</strong> values. <strong class="source-inline">eulerAngles</strong> makes rotations less complicated to work with. More information about <strong class="source-inline">eulerAngles</strong> can be found at <a href="https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html">https://docs.unity3d.com/ScriptReference/Transform-eulerAngles.html</a>.</p></li>
			</ol>
			<p>That's all we need to do with our light. As with the camera, we can access the light and change its properties via a script.</p>
			<p>We have become <a id="_idIndexMarker171"/>familiar with our light by changing its settings in the Unity Editor and the <strong class="source-inline">GameManager</strong> script. Next, we will set up our interface for the majority of our game objects.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor057"/>Introducing our interface – IActorTemplate</h1>
			<p>The <strong class="source-inline">IActorTemplate</strong> interface<a id="_idIndexMarker172"/> is what we are using to prompt damage control, death, and scriptable object assets. The reason for using an interface such as this is that it ties general uses together between classes that inherit it. </p>
			<p>A total of six classes <a id="_idIndexMarker173"/>will be using the <strong class="source-inline">IActorTemplate</strong> interface, which is as follows:</p>
			<ul>
				<li><strong class="source-inline">Player</strong></li>
				<li><strong class="source-inline">PlayerBullet</strong></li>
				<li><strong class="source-inline">PlayerSpawner</strong></li>
				<li><strong class="source-inline">Enemy</strong></li>
				<li><strong class="source-inline">EnemyBullet</strong></li>
				<li><strong class="source-inline">EnemySpawner</strong></li>
			</ul>
			<p>The following diagram shows the <strong class="source-inline">IActorTemplate</strong> interface with a partial overview of our game framework:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_2.31_B18381.jpg" alt="Figure 2.31 – IActorTemplate UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.30 – IActorTemplate UML</p>
			<p>Let's create our<a id="_idIndexMarker174"/> interface and explain its content along the way:</p>
			<ol>
				<li value="1">Create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">IActorTemplate</strong>.</li>
				<li>Open the script and enter the following code:<p class="source-code">public interface IActorTemplate</p><p class="source-code">      {</p><p class="source-code">      int SendDamage();</p><p class="source-code">      void TakeDamage(int incomingDamage);</p><p class="source-code">      void Die();</p><p class="source-code">      void ActorStats(SOActorModel actorModel);</p><p class="source-code">      }</p></li>
				<li>Make sure to save the script.</li>
			</ol>
			<p>The code we just entered looks like we have declared a class, but it acts fundamentally differently. Instead of using the <strong class="source-inline">class</strong> keyword, we enter <strong class="source-inline">interface</strong> followed by the name of the interface, <strong class="source-inline">IActorTemplate</strong>. It's not a requirement to start any interface name with an <strong class="source-inline">I</strong>, but it makes the script easily identifiable.</p>
			<p>Within the <strong class="source-inline">interface</strong>, we make a list of methods that act like contracts to whichever class implements them. For example, the <strong class="source-inline">Player</strong> script that we'll create later on in the chapter inherits the <strong class="source-inline">IActorTemplate</strong> interface. The <strong class="source-inline">Player</strong> script must declare the function names from <strong class="source-inline">IActorTemplate</strong> or the <strong class="source-inline">Player</strong> script will throw an error.</p>
			<p>Inside the scope of the <strong class="source-inline">interface</strong>, we declare methods without accessors (it doesn't require <strong class="source-inline">private</strong> or <strong class="source-inline">public</strong> at the beginning of each method). Methods also don't require any <a id="_idIndexMarker175"/>content in them (that is, they are empty bodies). </p>
			<p>For more <a id="_idIndexMarker176"/>information about interfaces, check out <a href="https://learn.unity.com/tutorial/interfaces">https://learn.unity.com/tutorial/interfaces</a>.</p>
			<p>The last method in our <strong class="source-inline">interface</strong> is <strong class="source-inline">ActorStats</strong>, which takes a <strong class="source-inline">SOActorModel</strong> type. <strong class="source-inline">SOActorModel</strong> is a scriptable object that we are going to explain and create in the next section.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor058"/>Introducing our ScriptableObject – SOActorModel</h1>
			<p>In this section, we <a id="_idIndexMarker177"/>are going to cover scriptable objects<a id="_idIndexMarker178"/> and their benefits. Similar to our <strong class="source-inline">interface</strong>, scriptable objects cover the same six classes. The reason for this is that our <strong class="source-inline">interface</strong> uses the <strong class="source-inline">SOActorModel</strong> and, therefore, creates an attachment with the other variables. </p>
			<p>It is also good to remind ourselves of <a id="_idIndexMarker179"/>the <strong class="bold">Game Design Document </strong>(<strong class="bold">GDD</strong>) and how it is incorporated into the overview of the creation of our game.</p>
			<p>Our game has three series of game objects that will hold similar properties: <strong class="source-inline">EnemyWave</strong>, <strong class="source-inline">EnemyFlee</strong>, and <strong class="source-inline">Player</strong>. These properties will include health, speed, score value, and more. The difference between each of these as described in the game design brief is the way they act and also how they are instantiated in our game.</p>
			<p><strong class="source-inline">Player</strong> will be instantiated at every level, <strong class="source-inline">EnemyWave</strong> will be spawned from <strong class="source-inline">EnemySpawner</strong>, and <strong class="source-inline">EnemyFlee</strong> will be placed in particular areas of the third level.</p>
			<p>All of the aforementioned game objects will relate to the <strong class="source-inline">SOActorModel</strong> object.</p>
			<p>The following diagram is also a partial view of our game framework, showing the scriptable object<a id="_idIndexMarker180"/> and <a id="_idIndexMarker181"/>the six classes that inherit it:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_2.32_B18381.jpg" alt="Figure 2.32 – SOActorModel UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.31 – SOActorModel UML</p>
			<p>Similar to what was mentioned with the <strong class="source-inline">interface</strong> script is that the name of the scriptable object name starts with <strong class="source-inline">SO</strong>, which isn't a standard way of naming the script, but it's easier to identify as a <strong class="source-inline">ScriptableObject</strong>. </p>
			<p>The purpose of this scriptable object is to hold general values for each of the game objects it's being given to. For example, all game objects have a name, so within our <strong class="source-inline">SOActorModel</strong> is a <strong class="source-inline">string</strong> named <strong class="source-inline">actorName</strong>. This <strong class="source-inline">actorName</strong> will be used to name the type of enemy, spawner, or bullet it is.</p>
			<p>Let's create a scriptable object, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window in the Unity Editor, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">SOActorModel</strong>.</li>
				<li>Open<a id="_idIndexMarker182"/> the <a id="_idIndexMarker183"/>script and enter the following code:<p class="source-code">using UnityEngine; </p><p class="source-code">     [CreateAssetMenu(fileName = "Create Actor", menuName = </p><p class="source-code">         "Create  Actor")]</p><p class="source-code">     public class SOActorModel : ScriptableObject </p><p class="source-code">     </p><p class="source-code">     { </p><p class="source-code">          public string actorName;</p><p class="source-code">          public AttackType attackType;</p><p class="source-code">     </p><p class="source-code">          public enum AttackType</p><p class="source-code">           {</p><p class="source-code">              wave, player, flee, bullet</p><p class="source-code">           }</p><p class="source-code">          public string description;</p><p class="source-code">          public int health;</p><p class="source-code">          public int speed;</p><p class="source-code">          public int hitPower;</p><p class="source-code">          public GameObject actor;</p><p class="source-code">          public GameObject actorsBullets;</p><p class="source-code">     }</p></li>
				<li>Save<a id="_idIndexMarker184"/> the script.</li>
			</ol>
			<p>Inside the <strong class="source-inline">SOActorModel</strong>, we will be naming most, if not all, of these variables in the <strong class="source-inline">Player</strong> script. Similar to how an <strong class="source-inline">interface</strong> signs a contract with a class, the <strong class="source-inline">SOActorModel</strong> does the same because it's being inherited, but isn't as strict as an <strong class="source-inline">interface</strong> by throwing an error if the content from the scriptable object isn't applied.</p>
			<p>The following is an overview of the <strong class="source-inline">SOActorModel</strong> code we just entered.</p>
			<p>We named our scriptable object <strong class="source-inline">SOActorModel</strong> as a generic term to try and cover as many game <a id="_idIndexMarker185"/>objects as will likely use the scriptable object. This way of <a id="_idIndexMarker186"/>working also supports the SOLID principles we covered in the first chapter by encouraging us to try and keep our code concise and efficient.</p>
			<p>The main categories we'll <a id="_idIndexMarker187"/>cover for this script are as follows:</p>
			<ul>
				<li><strong class="bold">Importing libraries</strong>: As you can see, the only library we have imported in the <strong class="source-inline">SOActorModel</strong> script is <strong class="source-inline">using UnityEngine</strong>; no other libraries are required.</li>
				<li><strong class="bold">Creating an asset</strong>: The <strong class="source-inline">CreateAssetMenu</strong> attribute creates an extra selection from the drop-down list in the <strong class="bold">Project</strong> window in the Unity Editor when we right-click and select <strong class="bold">Create</strong>, as shown in the following screenshot:</li>
			</ul>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_2.33_B18381.jpg" alt="Figure 2.33 – Creating an Actor in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.32 – Creating an Actor in the Unity Editor</p>
			<ul>
				<li><strong class="bold">Inheritance</strong>: We aren't <a id="_idIndexMarker188"/>inheriting <strong class="source-inline">MonoBehaviour</strong> but <strong class="source-inline">ScriptableObject</strong> instead, as it's a requirement when it comes to creating an asset.</li>
				<li><strong class="bold">Variables</strong>: Finally, these <a id="_idIndexMarker189"/>are the variables that will be sent to our selected classes.</li>
			</ul>
			<p>In the<a id="_idIndexMarker190"/> following <a id="_idIndexMarker191"/>sections, we are going to create assets from the scriptable object script to give our scripts different values.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Creating a PlayerSpawner ScriptableObject asset</h2>
			<p>With <a id="_idIndexMarker192"/>our <strong class="source-inline">SOActorModel</strong> <strong class="source-inline">ScriptableObject</strong> made, we can now create an asset that will act as a template that can be used not just by programmers but also by designers who want to tweak game properties/settings without needing to know how to code.</p>
			<p>To create an <strong class="source-inline">Actor Model</strong> asset, do the following: </p>
			<ol>
				<li value="1">Back in the Unity Editor, in the <strong class="bold">Project</strong> window, right-click and choose <strong class="bold">Create | Create Actor</strong>.</li>
				<li>Rename the newly created asset file in the <strong class="bold">Project</strong> window <strong class="source-inline">Player_Default</strong> and store the file in the <strong class="source-inline">Assets/Resources</strong> folder.</li>
				<li>Click on the new asset, and in the <strong class="bold">Inspector</strong> window, you'll see the content of the asset.</li>
			</ol>
			<p>The following screenshot shows the <strong class="source-inline">Actor Model</strong> asset's fields, where I have entered my own values: </p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_2.34_B18381.jpg" alt="Figure 2.34 – Player values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.33 – Player values</p>
			<p>Let's break down <a id="_idIndexMarker193"/>each of the values that have been added to our newly created asset:</p>
			<ul>
				<li><strong class="bold">Actor Name</strong>: The name of the actor (in our case, this is <strong class="source-inline">Player</strong>).</li>
				<li><strong class="bold">Ship Type</strong>: Choose which category this game object belongs to.</li>
				<li><strong class="bold">Description</strong>: Designer/internal notes that don't affect the game but can be helpful.</li>
				<li><strong class="bold">Health</strong>: How many times the player can get hit before dying.</li>
				<li><strong class="bold">Speed</strong>: The movement speed of the player.</li>
				<li><strong class="bold">Hit Power</strong>: Determines how much damage the player will cause if they collide with the enemy.</li>
				<li><strong class="bold">Actor</strong>: Place the <strong class="source-inline">player_ship</strong> prefab here (<strong class="source-inline">Assets/Prefab/Player</strong></li>
				<li><strong class="bold">Actors Bullets</strong>: Place the <strong class="source-inline">player_bullet</strong> prefab here (<strong class="source-inline">Assets/Prefab /Player/</strong>).</li>
			</ul>
			<p>We will add this asset to our <strong class="source-inline">PlayerSpawner</strong> script once it's built later on in the chapter. Let's<a id="_idIndexMarker194"/> move on to the next scriptable object asset.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Creating an EnemySpawner ScriptableObject asset</h2>
			<p>In this <a id="_idIndexMarker195"/>section, we are going to make our enemy asset attach to <strong class="source-inline">EnemySpawner</strong> for later on in the chapter. For the sake of keeping our work fresh and complete, let's continue with that before moving on to the <strong class="source-inline">EnemySpawner</strong> script.</p>
			<p>To make an enemy asset, follow these instructions:</p>
			<ol>
				<li value="1">Back in the Editor, in the <strong class="bold">Project</strong> window, right-click and choose <strong class="bold">Create | Create Actor</strong>.</li>
				<li>Rename the new file to refer to what it's being attached to (<strong class="source-inline">BasicWave Enemy</strong>) and store the file in the <strong class="source-inline">Assets/ScriptableObject</strong> location.</li>
				<li>Click on the new script, and our <strong class="bold">Inspector</strong> window will show the content of our script.</li>
			</ol>
			<p>The following screenshot shows what the <strong class="source-inline">BasicWave Enemy</strong> asset is going to look like once we've finished:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_2.35_B18381.jpg" alt="Figure 2.35 – The Basic Wave Enemy values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.34 – The Basic Wave Enemy values</p>
			<p>Let's briefly go through each of the values for our enemy:</p>
			<ul>
				<li><strong class="bold">Actor Name</strong>: <strong class="source-inline">enemy_wave</strong>.</li>
				<li><strong class="bold">Ship Type</strong>: Here, this is <strong class="source-inline">Wave</strong>. This explains what type of enemy it is and how it attacks the player.</li>
				<li><strong class="bold">Description:</strong> Here, this reads <strong class="source-inline">Typically in groups</strong>. As mentioned before, it's more of a guideline than a rule to comment on anything.</li>
				<li><strong class="bold">Health</strong>: <strong class="source-inline">1</strong>, which means it takes 1 hit to die. </li>
				<li><strong class="bold">Speed</strong>: <strong class="source-inline">-50</strong>, because our enemy is moving from right to left, so we give it a minus figure.</li>
				<li><strong class="bold">Hit Power</strong>: <strong class="source-inline">1</strong>, which means that if this enemy collides with the player, it will cause 1 hit point of damage.</li>
				<li><strong class="bold">Actor</strong>: Place the <strong class="source-inline">enemy_wave</strong> prefab here (<strong class="source-inline">Assets/Prefab/Enemies</strong>).</li>
				<li><strong class="bold">Actors Bullets</strong>: This enemy doesn't fire bullets.</li>
			</ul>
			<p>Hopefully, you can<a id="_idIndexMarker196"/> see how useful scriptable objects are. Imagine continuing to develop this game with <strong class="source-inline">50</strong> enemies, where all we need to do is create an asset and customize it.</p>
			<p>We are going to move on to the final scriptable object asset for this chapter in the next section.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Creating a PlayerBullet ScriptableObject Asset</h2>
			<p>In this <a id="_idIndexMarker197"/>section, we are going to create an asset for the player's bullet for when they fire. As with the last two sections, create an asset, name it <strong class="source-inline">PlayerBullet</strong>, and store it in the same folder as the other assets.</p>
			<p>The following screenshot shows the final results for the <strong class="source-inline">PlayerBullet</strong> asset:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_2.36_B18381.jpg" alt="Figure 2.36 – The Player Bullet values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.35 – The Player Bullet values</p>
			<p>Let's briefly go <a id="_idIndexMarker198"/>through each variable's values:</p>
			<ul>
				<li><strong class="bold">Actor Name</strong>: <strong class="source-inline">player_bullet</strong>.</li>
				<li><strong class="bold">Ship Type</strong>: Bullet.</li>
				<li><strong class="bold">Description</strong>: It is optional to enter any details about the asset here.</li>
				<li><strong class="bold">Health</strong>: Our bullet has a health value of <strong class="source-inline">1</strong>.</li>
				<li><strong class="bold">Speed</strong>: <strong class="source-inline">700</strong>.</li>
				<li><strong class="bold">Hit Power</strong>: <strong class="source-inline">1</strong> sends a hit point of 1.</li>
				<li><strong class="bold">Actor</strong>: Place the <strong class="source-inline">player_bullet</strong> prefab here (<strong class="source-inline">Assets/Prefab/Player</strong>).</li>
				<li><strong class="bold">Actors Bullets</strong>: <strong class="bold">None (Game Object)</strong>.</li>
			</ul>
			<p>In a later chapter, when we build a shop for our game, we will be able to buy power-ups for our player's ship. One of the power-ups will be similar to the one that we just made, but the <strong class="bold">Actor Name</strong> will be different, and the <strong class="bold">Hit Power</strong> will have a higher number.</p>
			<p>Now, we can move on to the next section and create the player's scripts and attach these assets to them.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/>Setting up our Player, PlayerSpawner, and PlayerBullet scripts</h1>
			<p>In the following series of sections, we are going to create three of the scripts that will cover the following: spawning the player, the player's controls, and the player's bullet.</p>
			<p>The scripts we will be creating and including are as follows:</p>
			<ul>
				<li><strong class="source-inline">PlayerSpawner</strong>: Creates and calibrates the player</li>
				<li><strong class="source-inline">Player</strong>: Player controls and general functionality</li>
				<li><strong class="source-inline">PlayerBullet</strong>: Bullet movement and general functionality</li>
				<li><strong class="source-inline">IActorTemplate</strong>: A template of the expected rules assigned to a given object (already made)</li>
				<li><strong class="source-inline">SOActorModel</strong>: A set of values that can be altered by non-programmers (already made)</li>
			</ul>
			<p>We will cover all of these scripts thoroughly and break down each of their purposes, as well as how they depend on and communicate with one another. We will start with the <strong class="source-inline">PlayerSpawner</strong>, which will create the player's ship and issue its values.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/>Setting up our PlayerSpawner script</h2>
			<p>The purpose<a id="_idIndexMarker199"/> of the <strong class="source-inline">PlayerSpawner</strong> script is to be attached to a game object, resulting in the player appearing at its position in the game. The <strong class="source-inline">PlayerSpawner</strong> script will also set the player's values when it is created. For example, if our player had a particular speed value, or if they had received an upgrade from the shop, the <strong class="source-inline">PlayerSpawner</strong> script would grab these values and apply them to the <strong class="source-inline">Player</strong> script.</p>
			<p>The following diagram shows a partial view of the <strong class="source-inline">PlayerSpawner</strong> class in the game's framework and its relationship with the other classes around it:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_2.37_B18381.jpg" alt="Figure 2.37 – PlayerSpawner UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.36 – PlayerSpawner UML</p>
			<p>As we can <a id="_idIndexMarker200"/>see, the <strong class="source-inline">PlayerSpawner</strong> script is connected to four other scripts:</p>
			<ul>
				<li><strong class="source-inline">Player</strong>: <strong class="source-inline">PlayerSpawner</strong> is connected to <strong class="source-inline">Player</strong> because it creates the player.</li>
				<li><strong class="source-inline">SOActorModel</strong>: This is a <strong class="source-inline">ScriptableObject</strong> that gives the <strong class="source-inline">PlayerSpawner</strong> its values, which are then passed on to the <strong class="source-inline">Player</strong>.</li>
				<li><strong class="source-inline">IActorTemplate</strong>: This is the <strong class="source-inline">interface</strong> that generalizes the script with other common functions.</li>
				<li><strong class="source-inline">GameManager</strong>: This will send and receive general game information from and to the <strong class="source-inline">PlayerSpawner</strong> script.</li>
			</ul>
			<p>Before we create our <strong class="source-inline">PlayerSpawner</strong> script, it would be good housekeeping to create an empty game object to store anything to do with our player, their bullets, and whatever else the player might create in our <strong class="source-inline">testLevel</strong> scene.</p>
			<p>Make and name the game object by following these steps:</p>
			<ol>
				<li value="1">Right-click the <strong class="bold">Hierarchy</strong> window in its open space.</li>
				<li>A drop-down list will appear. From the list, select <strong class="bold">Create Empty</strong>.</li>
				<li>Name the game object <strong class="source-inline">_Player</strong>.</li>
			</ol>
			<p>That's all that we need to do. Now, let's make a start with the <strong class="source-inline">PlayerSpawner</strong> script:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">PlayerSpawner</strong>.</li>
				<li>Open the<a id="_idIndexMarker201"/> script and make sure that we have the following library entered at the top of our script:<p class="source-code"><strong class="bold">using UnityEngine;</strong></p></li>
			</ol>
			<p>We only require <strong class="source-inline">using UnityEngine</strong>, as it covers all of the objects we need in the script.</p>
			<ol>
				<li value="3">Continue by making sure our class is labeled as follows:<p class="source-code"><strong class="bold">public class PlayerSpawner : MonoBehaviour</strong> </p><p class="source-code">     {</p></li>
			</ol>
			<p>It is common in Unity to inherit <strong class="source-inline">MonoBehaviour</strong> to give the script more functionality within Unity. Its common purpose is so the script can be attached to a game object. </p>
			<ol>
				<li value="4">Continue by entering the script's variables:<p class="source-code">   SOActorModel actorModel;</p><p class="source-code">        GameObject playerShip;</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">PlayerSpawner</strong> class, we add two global variables: the first variable is the <strong class="source-inline">actorModel</strong>, which holds a scriptable object asset that will contain values for the player ship, and the second variable will hold our player ship once it's been created from our <strong class="source-inline">CreatePlayer</strong> method.</p>
			<ol>
				<li value="5">Continue by entering the script's <strong class="source-inline">Start</strong> function:<p class="source-code">void Start()</p><p class="source-code">      {</p><p class="source-code">        CreatePlayer();</p><p class="source-code">      }</p></li>
			</ol>
			<p>After the global variables, we add a <strong class="source-inline">Start</strong> function that will run automatically as soon as the game object holding the <strong class="source-inline">PlayerSpawner</strong> script is active at runtime.</p>
			<p>Inside the scope of the <strong class="source-inline">Start</strong> function is a method that we are going to create called <strong class="source-inline">CreatePlayer</strong>.</p>
			<ol>
				<li value="6">Continue <a id="_idIndexMarker202"/>by entering the <strong class="source-inline">CreatePlayer</strong> method:<p class="source-code">void CreatePlayer()</p><p class="source-code">       {</p><p class="source-code">         //CREATE PLAYER</p><p class="source-code">         actorModel = Object.Instantiate(Resources.Load</p><p class="source-code">            ("Player_Default")) </p><p class="source-code">                as SOActorModel;</p><p class="source-code">         playerShip = GameObject.Instantiate(actorModel.actor) </p><p class="source-code">            as GameObject;</p><p class="source-code">         playerShip.GetComponent&lt;Player&gt;().ActorStats(actorModel);</p><p class="source-code">      </p><p class="source-code">     //SET PLAYER UP</p><p class="source-code">     </p><p class="source-code">      }</p><p class="source-code">     }</p></li>
			</ol>
			<p>I have split the <strong class="source-inline">CreatePlayer</strong> method into two commented-out parts (<strong class="source-inline">//CREATE PLAYER</strong> and <strong class="source-inline">//SET PLAYER UP</strong>) due to its size.</p>
			<p>This first part of the <strong class="source-inline">CreatePlayer</strong> method will <strong class="source-inline">instantiate</strong> the player ship's <strong class="source-inline">ScriptableObject</strong> asset and store it in the <strong class="source-inline">actorModel</strong> variable. We then <strong class="source-inline">instantiate</strong> a game object that refers to our <strong class="source-inline">ScriptableObject</strong> that holds the game object called <strong class="source-inline">actor</strong> in our game object variable named <strong class="source-inline">playerShip</strong>. Finally, we apply our <strong class="source-inline">ScriptableObject</strong> asset to the <strong class="source-inline">playerShip</strong> method called <strong class="source-inline">ActorStats</strong> that exists in the <strong class="source-inline">Player</strong> component script (which we will create later on in this chapter).</p>
			<ol>
				<li value="7">Continue <a id="_idIndexMarker203"/>on inside the <strong class="source-inline">CreatePlayer</strong> method to add the second half:<p class="source-code">//SET PLAYER UP</p><p class="source-code">     playerShip.transform.rotation = Quaternion.Euler(0,180,0);</p><p class="source-code">     playerShip.transform.localScale = new Vector3(60,60,60);</p><p class="source-code">     playerShip.name = "Player";</p><p class="source-code">     playerShip.transform.SetParent(this.transform);</p><p class="source-code">     playerShip.transform.position = Vector3.zero;</p></li>
			</ol>
			<p>In the second half of the <strong class="source-inline">CreatePlayer</strong> method, we add more code at the same point where we have commented <strong class="source-inline">//SET PLAYER UP</strong>.</p>
			<p>The code from <strong class="source-inline">//SET PLAYER UP</strong> onward is dedicated to setting up the player's ship in the correct position at the start of the level. </p>
			<p>The code does the following: </p>
			<ul>
				<li>Sets the rotation of the player's ship to face the right way.</li>
				<li>Sets the scale of the player ship to <strong class="source-inline">60</strong> on all axes.</li>
				<li>When we <strong class="source-inline">instantiate</strong> any game object, Unity will add <strong class="source-inline">(Clone)</strong> to the end of the game object's name. We can rename it <strong class="source-inline">Player</strong>.</li>
				<li>We make the <strong class="source-inline">playerShip</strong> game object a child of the <strong class="source-inline">_Player</strong> game object in the <strong class="bold">Hierarchy</strong> window so that we can easily find it.</li>
				<li>Finally, we reset the player ship's position.</li>
			</ul>
			<p>That is our <strong class="source-inline">PlayerSpawner</strong> script coded. Now, in the next section, we need to create and attach<a id="_idIndexMarker204"/> this script to a game object and name it. Make sure to save the script before moving on.</p>
			<h3>Creating the PlayerSpawner game object</h3>
			<p>In this<a id="_idIndexMarker205"/> section, we will create a game object that will hold our newly created <strong class="source-inline">PlayerSpawner</strong> script, and then we will position the <strong class="source-inline">PlayerSpawner</strong> game object in the <strong class="source-inline">testLevel</strong> scene.</p>
			<p>To create and set up our <strong class="source-inline">PlayerSpawner</strong> game object, we need to do the following:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, create an empty game object and name it <strong class="source-inline">PlayerSpawner</strong>.</li>
				<li>Drag and drop the <strong class="source-inline">PlayerSpawner</strong> game object onto the <strong class="source-inline">_Player</strong> (remember that <strong class="source-inline">_Player</strong> is the empty game object in our scene) game object to make the <strong class="source-inline">PlayerSpawner</strong> its child.</li>
			</ol>
			<p>Because our <strong class="source-inline">PlayerSpawner</strong> game object doesn't have anything visually applied to it, we can give it an icon.</p>
			<ol>
				<li value="3">With the <strong class="source-inline">PlayerSpawner</strong> game object still selected in the <strong class="bold">Inspector</strong> window, click the multi-colored box to the left of its name. A selection of colors will be offered, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/Figure_2.38_B18381.jpg" alt="Figure 2.38 – Selecting an icon for the PlayerSpawner&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.37 – Selecting an icon for the PlayerSpawner</p>
			<ol>
				<li value="4">Pick a color. Now, the <strong class="source-inline">PlayerSpawner</strong> game object will be given a label to show us where it is in the scene. This will now appear in the <strong class="bold">Scene</strong> window.<p class="callout-heading">Tip</p><p class="callout">If you still can't see the icon in the <strong class="bold">Scene</strong> window, make sure <strong class="bold">3D icons</strong> are turned off. You can check by clicking the <strong class="bold">Gizmos</strong> button in the top right of the <strong class="bold">Scene</strong> window and unchecking the <strong class="bold">3D Icons</strong> box.</p></li>
			</ol>
			<p>With<a id="_idIndexMarker206"/> the <strong class="source-inline">PlayerSpawner</strong> game object sitting inside the <strong class="source-inline">_Player</strong> game object in the <strong class="bold">Hierarchy</strong> window, we now need to give it the following <strong class="bold">Transform</strong> property values, which will help two things. The first thing is to help set the boundaries of our ship within the game's screen ratio (we will explain more about this in the next chapter); the second is for later on in the book, where we will make the player ship animate in the screen view. For now, we just need to give our <strong class="source-inline">PlayerSpawner</strong> game object the following values:</p>
			<ol>
				<li value="1">With the <strong class="source-inline">PlayerSpawner</strong> game object still selected, in the <strong class="bold">Inspector</strong> window, give it the following <strong class="bold">Transform</strong> values:</li>
			</ol>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/Figure_2.39_B18381.jpg" alt="Figure 2.39 – PlayerSpawner Transform values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.38 – PlayerSpawner Transform values in the Inspector window</p>
			<ol>
				<li value="2">While still in the <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Component</strong> and type <strong class="source-inline">PlayerSpawner</strong> until you see the script appear in the drop-down list.</li>
				<li>Click the <strong class="source-inline">PlayerSpawner</strong> script to add this to the <strong class="source-inline">PlayerSpawner</strong> game object.</li>
			</ol>
			<p>We can't move the ship yet, nor can we fire because we haven't coded this in yet. In the following <a id="_idIndexMarker207"/>section, we will go through the player's controls, then we will move on to coding our player and its bullet to travel across the screen.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>Setting up our Input Manager</h2>
			<p>Remember that <a id="_idIndexMarker208"/>this is a side-scrolling shooter game, so the controls will be two-dimensional even though our visuals are three-dimensional. Our focus now is to get the <strong class="source-inline">Players</strong> controls set up. To do this, we need to access the <strong class="bold">Input Manager</strong>:</p>
			<ol>
				<li value="1">Select <strong class="bold">Edit</strong>, followed by <strong class="bold">Project Settings</strong>, and then select <strong class="bold">Input Manager</strong> from the list:</li>
			</ol>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_2.40_B18381.jpg" alt="Figure 2.40 – Selecting the Input Manager in the Unity editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.39 – Selecting the Input Manager in the Unity Editor</p>
			<p>The <strong class="bold">Input Manager</strong> will offer a list of all available controls for our game. We will first check what the <a id="_idIndexMarker209"/>controls are set to by default. There are a lot of options here, but as mentioned, we only need to browse through the properties that matter to us, namely the following:</p>
			<ul>
				<li><strong class="bold">Horizontal</strong>: Moves the player's ship along its x-axis</li>
				<li><strong class="bold">Vertical</strong>: Moves the player's ship along its y-axis</li>
				<li><strong class="bold">Fire1</strong>: Makes our player shoot</li>
			</ul>
			<p>To check these three properties, we need to do the following:</p>
			<ul>
				<li>Expand the <strong class="bold">Axes</strong> dropdown by clicking the arrow next to it.</li>
				<li>Expand <strong class="bold">Horizontal</strong>, as shown in the following screenshot:</li>
			</ul>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_2.41_B18381.jpg" alt="Figure 2.41 – The Input Manager&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.40 – The Input Manager</p>
			<ul>
				<li><strong class="bold">Horizontal</strong>: The<a id="_idIndexMarker210"/> left button configures horizontal negatively (<strong class="source-inline">-1</strong>), and the right button configures it positively (<strong class="source-inline">+1</strong>). Alternative key presses to this effect are <em class="italic">A</em> for left and <em class="italic">D</em> for right.</li>
			</ul>
			<p>If we had analog controls such as a joystick or a steering wheel, we would likely need to be concerned about the influence of gravity when the player releases the controls and it returns to its center. Dead refers to the center of the analog controls. Sometimes, controllers can be unbalanced and naturally lean to one side, so by increasing the dead zone, we can eliminate false feedback from the player that could be detected as a movement. </p>
			<ul>
				<li><strong class="bold">Vertical</strong>: This is the same as <strong class="bold">Horizontal</strong>, apart from the fact that the negative button is down (<strong class="source-inline">-1</strong>) and the positive button is up (<strong class="source-inline">+1</strong>). Alternative buttons are <em class="italic">S</em> for down and <em class="italic">W</em> for up.</li>
				<li><strong class="bold">Fire1</strong>: This has a similar layout to <strong class="bold">Vertical</strong>, but with <em class="italic">Ctrl</em> as <strong class="bold">Fire</strong> (<em class="italic">Command</em> on a Mac) (that is, the positive button), with the alternative (positive) button being <strong class="source-inline">mouse 0</strong> (that is, the left mouse button). For now, remove <strong class="source-inline">mouse 0</strong> from the alternative button.</li>
			</ul>
			<p>To find out more about the <strong class="bold">Input Manager</strong> window, click the little blue book at the top-right corner of the <strong class="bold">Input Manager</strong> panel.</p>
			<p>Our controls <a id="_idIndexMarker211"/>are now set in the <strong class="bold">Input Manager</strong> window, so let's move on to coding the <strong class="source-inline">Player</strong> script to take advantage of these controls.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor065"/>Setting up our Player script</h2>
			<p>The <strong class="source-inline">Player</strong> script will<a id="_idIndexMarker212"/> be attached to the player ship game object, from which the player will be able to move and shoot, as well as inflict and receive damage. We will also make the player ship not go outside of the screenplay area. Before we continue, let's remind ourselves where the <strong class="source-inline">Player</strong> script lies in our game framework:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_2.42_B18381.jpg" alt="Figure 2.42 – Player UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.41 – Player UML</p>
			<p>The <strong class="source-inline">Player</strong> script will<a id="_idIndexMarker213"/> be in contact with the following scripts:</p>
			<ul>
				<li><strong class="source-inline">PlayerBullet</strong>: The <strong class="source-inline">Player</strong> script will create bullets to fire.</li>
				<li><strong class="source-inline">PlayerSpawner</strong>: The <strong class="source-inline">Player</strong> script is created from the <strong class="source-inline">PlayerSpawner</strong>.</li>
				<li><strong class="source-inline">IActorTemplate</strong>: Contains damage control and the properties for <strong class="source-inline">Player</strong>.</li>
				<li><strong class="source-inline">GameManager</strong>: Extra information such as the number of lives, the score, the level, and whatever upgrades the player ship has accumulated will be stored in <strong class="source-inline">GameManager</strong>.</li>
				<li><strong class="source-inline">SOActorModel</strong>: Holds <strong class="source-inline">ScriptableObject</strong> properties for <strong class="source-inline">Player</strong>.</li>
			</ul>
			<p>Now that we are familiar with the <strong class="source-inline">Player</strong> script's relation to the other scripts, we can start coding it:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window<a id="_idIndexMarker214"/> of the Unity Editor, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">Player</strong>.</li>
				<li>Open the script and add the <strong class="source-inline">IActorTemplate</strong> interface to the existing default code:<p class="source-code">using UnityEngine;</p><p class="source-code">      </p><p class="source-code">      public class Player : MonoBehaviour, IActorTemplate</p><p class="source-code">      {</p></li>
			</ol>
			<p>The script will by default import a <strong class="source-inline">UnityEngine</strong> library (including some others), the name of the class, and <strong class="source-inline">MonoBehaviour</strong>. All of these are essential to make the script work in the Unity Editor.</p>
			<ol>
				<li value="3">Continuing with the <strong class="source-inline">Player</strong> script, enter the following global variables:<p class="source-code">         int travelSpeed;</p><p class="source-code">         int health;</p><p class="source-code">         int hitPower;</p><p class="source-code">         GameObject actor;</p><p class="source-code">         GameObject fire;    </p><p class="source-code">     </p><p class="source-code">         public int Health</p><p class="source-code">         {</p><p class="source-code">             get {return health;}</p><p class="source-code">             set {health = value;}</p><p class="source-code">         }</p><p class="source-code">        </p><p class="source-code">         public GameObject Fire</p><p class="source-code">         {</p><p class="source-code">             get {return fire;}</p><p class="source-code">             set {fire = value;}</p><p class="source-code">         }</p><p class="source-code">     </p><p class="source-code">         GameObject _Player;</p><p class="source-code">         </p><p class="source-code">         float width;</p><p class="source-code">         float height;</p><p class="source-code">      </p></li>
			</ol>
			<p>We have entered <a id="_idIndexMarker215"/>a mixture of integers, floats, and game objects in our global variables; starting from the top, the first six variables will be updated from the player's <strong class="source-inline">SOActorModel</strong> script. <strong class="source-inline">travelSpeed</strong> is the speed of the player's ship, <strong class="source-inline">health</strong> is how many hits the player can take before dying, <strong class="source-inline">hitPower</strong> is the damage the ship will cause when colliding into something that can receive damage (the enemy), <strong class="source-inline">actor</strong> is the three-dimensional model used to represent the player, and finally, the <strong class="source-inline">fire</strong> variable is the three-dimensional model from which the player fires. If that seemed a little rushed, go back to the <em class="italic">Introducing our ScriptableObject – SOActorModel</em> section, where we went into more detail about these variables.</p>
			<p>The two public properties of <strong class="source-inline">Health</strong> and <strong class="source-inline">Fire</strong> are there to give access to our two <strong class="source-inline">private health</strong> and <strong class="source-inline">fire</strong> variables from other classes that require access. </p>
			<p>The <strong class="source-inline">_Player</strong> variable will be used as a reference to the <strong class="source-inline">_Player</strong> game object in the scene. </p>
			<p>The last two variables of <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong> will be used to store the measured results of the world space dimensions of the screen that the game is played in. We <a id="_idIndexMarker216"/>will discuss these two more in the next block of code.</p>
			<p>Before we begin the following <strong class="source-inline">Start</strong> function code block, you may question why we would pick <strong class="source-inline">Start</strong> over <strong class="source-inline">Awake</strong> when it comes to running a function's code content. Both functions run once at runtime; the only noticeable difference is that <strong class="source-inline">Awake</strong> runs when the object is created. <strong class="source-inline">Start</strong> is executed when it's enabled, as can be seen in the documentation at <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.</p>
			<p>For simplicity in our Unity project, we will vary between which of the two functions to use. This is so we avoid conflicts between several <strong class="source-inline">Awake</strong> functions running at the same time. As an example, one script may try to update its Text UI, but the variable updating the text may still be null at runtime because the script with the variable is still waiting for its content to be updated.</p>
			<p>There is a way to avoid conflicts between several <strong class="source-inline">Awake</strong> functions being called by several scripts at runtime, by going to Unity's <strong class="bold">Script Execution Order</strong> in <strong class="bold">Edit</strong> | <strong class="bold">Project Settings</strong> | <strong class="bold">Script Execution Order</strong>.</p>
			<p>If you would like to know more about the <strong class="bold">Script Execution Order</strong>, check the documentation at <a href="https://docs.unity3d.com/Manual/class-MonoManager.html">https://docs.unity3d.com/Manual/class-MonoManager.html</a>.</p>
			<ol>
				<li value="4">Continuing with entering code into the <strong class="source-inline">Player</strong> script, next up, we will type out the <strong class="source-inline">Start</strong> function along with its content:<p class="source-code"> void Start()</p><p class="source-code">      {</p><p class="source-code">        height = 1/(Camera.main.WorldToViewportPoint (new</p><p class="source-code">           Vector3(1,1,0)).y - .5f);</p><p class="source-code">        width = 1/(Camera.main.WorldToViewportPoint(new Vector3(1,1,0))</p><p class="source-code">           .x - .5f);</p><p class="source-code">        </p><p class="source-code">        _Player = GameObject.Find("_Player");</p><p class="source-code">      }</p></li>
			</ol>
			<p>As previously<a id="_idIndexMarker217"/> mentioned, the <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> variables will store our world space measurements. These are required so that we can clamp the player's ship inside the screen. Both the height and width lines of code use similar methods; the only difference is with the axis we are reading.</p>
			<p>The <strong class="source-inline">Camera.main</strong> component refers to the camera in our scene, and the function it uses, <strong class="source-inline">WorldToViewportPoint</strong>, is to take the results from the game's three-dimensional world space and convert the results into viewport space. If you aren't sure what viewport space is, it's similar to what we know as a screen resolution, except its measurements are in points and not pixels, and these points are measured from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. The following diagram shows the comparison between screen and viewport measurements:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_2.43_B18381.jpg" alt="Figure 2.43 – Screen versus viewport measurements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.42 – Screen versus viewport measurements</p>
			<p>So, with<a id="_idIndexMarker218"/> viewports, no matter what the screen's resolution is, the full height and width are <strong class="source-inline">1</strong> and everything between that is a fraction. So, for the height, we feed <strong class="source-inline">Vector3</strong> to <strong class="source-inline">WorldToViewportPoint</strong>, where <strong class="source-inline">Vector3</strong> represents a world space value, followed by <strong class="source-inline">-0.5f</strong>, which sets its offset back to <strong class="source-inline">0</strong>. Then, we divide <strong class="source-inline">1</strong> (which is our full-screen size) by the result of our formula. This will give us our current world space height of the screen. We then apply the same principles for the width and use <strong class="source-inline">x</strong> instead of <strong class="source-inline">y</strong> and store the result.</p>
			<p>Finally, the last line of code takes the reference of the <strong class="source-inline">_Player</strong> game object in the scene and stores it into our variable.</p>
			<ol>
				<li value="5">Continuing with the <strong class="source-inline">Player</strong> script, we have our <strong class="source-inline">Update</strong> function that is called on every frame. Enter the function along with the following two methods:<p class="source-code"> void Update ()</p><p class="source-code">      {</p><p class="source-code">          //Movement();</p><p class="source-code">          //Attack();</p><p class="source-code">      }</p></li>
			</ol>
			<p>The <strong class="source-inline">Update</strong> function runs the <strong class="source-inline">Movement</strong> method and <strong class="source-inline">Attack</strong> method on every frame. We will go into depth about these two methods later on in the chapter, for now we will comment ("//") these two methods out to avoid the script not being able to run. </p>
			<p>The next method we are going to put into our <strong class="source-inline">Player</strong> script is the <strong class="source-inline">ActorStats</strong> method. This method is a requirement, as we declare it in the interface we are inheriting.</p>
			<ol>
				<li value="6">Just after the <a id="_idIndexMarker219"/>scope of our <strong class="source-inline">Update</strong> function, enter the following piece of code:<p class="source-code">public void ActorStats(SOActorModel actorModel)</p><p class="source-code">      {</p><p class="source-code">          health = actorModel.health;</p><p class="source-code">          travelSpeed = actorModel.speed;</p><p class="source-code">          hitPower = actorModel.hitPower;</p><p class="source-code">          fire = actorModel.actorsBullets;</p><p class="source-code">      }</p></li>
			</ol>
			<p>The code we have just entered assigns values from the player's <strong class="source-inline">SOActorModel</strong> <strong class="source-inline">ScriptableObject</strong> asset that we made earlier on in the chapter.</p>
			<p>This method doesn't get run in our script but gets accessed by other classes, the reason being that these variables hold values regarding our player and don't need to be anywhere else.</p>
			<ol>
				<li value="7">Save the <strong class="source-inline">Player</strong> script.</li>
			</ol>
			<p>Before we test what we have so far, we need to attach our <strong class="source-inline">Player</strong> script to our <strong class="source-inline">player_ship</strong> in the <strong class="bold">Project</strong> window.</p>
			<ol>
				<li value="8">In the <strong class="bold">Project</strong> window, navigate to <strong class="source-inline">Assets/Prefab</strong> and select the <strong class="source-inline">player_ship</strong> prefab.</li>
				<li>Select the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> window. Type <strong class="source-inline">Player</strong> until the script appears and then select it.</li>
			</ol>
			<p>With our <strong class="bold">Hierarchy</strong> window containing the <strong class="source-inline">_Player</strong>, <strong class="source-inline">PlayerSpawner</strong>, and the <strong class="source-inline">GameManager</strong> game objects, it's time to test out the game. We can see the player ship get created in our <strong class="bold">Game</strong> window by pressing <strong class="bold">Play</strong> in the Editor.</p>
			<p>The following screenshot shows our game in <strong class="bold">Play</strong> mode; note the <strong class="bold">Hierarchy</strong> window on the left with the <strong class="source-inline">PlayerSpawner</strong> game object as the parent of the <strong class="source-inline">Player</strong> game object; also note the <strong class="bold">Game</strong> window with its black background, and in the center, the player's ship<a id="_idIndexMarker220"/> is facing right and is located in the center of the screen. Finally, the far-right image shows our <strong class="bold">Scene</strong> window with our <strong class="source-inline">PlayerSpawner</strong> icon:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_2.44_B18381.jpg" alt="Figure 2.44 – The current Player setup in our game&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.43 – The current Player setup in our game</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Before moving on to the next section, create a prefab of the <strong class="source-inline">PlayerSpawner</strong> game object by dragging and dropping it into the <strong class="bold">Project</strong> window to <strong class="source-inline">Assets/Player</strong>. That way, if you lose the scene for whatever reason along with its <strong class="bold">Hierarchy</strong> content, you can drag and drop your prefab back in. This should be a rule with any common active game object.</p>
			<p>Let's move on to the next section where we'll continue to work on the <strong class="source-inline">Player</strong> script, but this time, we will look at what happens when our player's game object comes into contact with an enemy.</p>
			<h3>Colliding with an enemy – OnTriggerEnter</h3>
			<p>In this section, we <a id="_idIndexMarker221"/>are going to add a function to our <strong class="source-inline">Player</strong> script<a id="_idIndexMarker222"/> that will check to see what has collided with our player's game object during runtime. Currently, the only thing that can collide with our player is an enemy, but we can still demonstrate the use of Unity's own <strong class="source-inline">OnTriggerEnter</strong> function, which handles most of the work for us:</p>
			<ol>
				<li value="1">Continuing after the scope of our last method (<strong class="source-inline">ActorStats</strong>) in the <strong class="source-inline">Player</strong> script, we are going to add the following code that detects our enemy colliding with the player's ship:<p class="source-code">  void OnTriggerEnter(Collider other)</p><p class="source-code">       {</p><p class="source-code">         if (other.tag == "Enemy")</p><p class="source-code">         {</p><p class="source-code">           if (health &gt;= 1)</p><p class="source-code">           {</p><p class="source-code">            if (transform.Find("energy +1(Clone)"))</p><p class="source-code">             {</p><p class="source-code">              Destroy(transform.Find("energy +1(Clone)").              gameObject);</p><p class="source-code">              health -= other.GetComponent&lt;IActorTemplate&gt;</p><p class="source-code">                ().SendDamage();</p><p class="source-code">             }</p><p class="source-code">             else</p><p class="source-code">             {</p><p class="source-code">                 health -= 1;</p><p class="source-code">             }</p><p class="source-code">           }</p><p class="source-code">           </p><p class="source-code">           if (health &lt;= 0)</p><p class="source-code">           {</p><p class="source-code">             Die();</p><p class="source-code">           }</p><p class="source-code">         }</p><p class="source-code">       }</p></li>
			</ol>
			<p>Let's explain some of the code we have just entered into the <strong class="source-inline">Player</strong> script:</p>
			<ul>
				<li><strong class="source-inline">OnTriggerEnter(Collider other)</strong> is a function that Unity recognizes to check what has entered into the player's trigger collider.</li>
				<li>We use an <strong class="source-inline">if</strong> statement to check whether the <strong class="source-inline">tag</strong> to the collider is called <strong class="source-inline">Enemy</strong>. Note <a id="_idIndexMarker223"/>when we create our enemy, we <a id="_idIndexMarker224"/>will give them an <strong class="source-inline">Enemy</strong> <strong class="source-inline">tag</strong> so they are easily identified. If the <strong class="source-inline">tag</strong> is equal to <strong class="source-inline">Enemy</strong>, we drop it into that <strong class="source-inline">if</strong> statement.</li>
				<li>The next <strong class="source-inline">if</strong> statement checks to see whether our player's <strong class="source-inline">health</strong> is equal to or more than <strong class="source-inline">1</strong>. If it is, that means the player can take a hit and continue without dying and also means we can go into its <strong class="source-inline">if</strong> statement.</li>
				<li>We approach the third <strong class="source-inline">if</strong> statement that checks to see whether the collider has a game object named <strong class="source-inline">energy +1(Clone)</strong>. The name of this object is the name of the shield the player can purchase in the game shop, which we will add in <a href="B18381_06_Epub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Purchasing In-Game Items and Advertisements</em>. If the player has this <strong class="source-inline">energy +1(Clone)</strong> object, we can <strong class="source-inline">Destroy</strong> it with Unity's premade function. We also deduct the player's extra health from the enemies' <strong class="source-inline">SendDamage</strong> function. We will discuss <strong class="source-inline">SendDamage</strong> later on in the chapter.</li>
				<li>Following the third <strong class="source-inline">if</strong> statement is an <strong class="source-inline">else</strong> condition where, in the event that the player doesn't have an <strong class="source-inline">energy +1(Clone)</strong> game object, they get their health deducted.</li>
				<li>Finally, if the player's <strong class="source-inline">health</strong> is at a value of zero or under, we run the <strong class="source-inline">Die</strong> method, which we will cover later in the chapter.<p class="callout-heading">Tip</p><p class="callout">Don't forget to keep saving your work as we continue to add more code to the project.</p></li>
			</ul>
			<p>Let's <a id="_idIndexMarker225"/>continue with our <strong class="source-inline">Player</strong> script <a id="_idIndexMarker226"/>and add the functionality so that the player can receive and send damage from and to the enemy respectively.</p>
			<ol>
				<li value="2">In the next method, we are going to add two methods. The first method (<strong class="source-inline">TakeDamage</strong>) will take an integer called <strong class="source-inline">incomingDamage</strong> and use whatever the value is to deduct from our player's <strong class="source-inline">health</strong> value.</li>
			</ol>
			<p>The second method (<strong class="source-inline">SendDamage</strong>) will <strong class="source-inline">return</strong> an integer of our <strong class="source-inline">hitPower</strong> value.</p>
			<ol>
				<li value="3">Just below and outside of the scope of our <strong class="source-inline">ActorStats</strong> method, now add the following code:<p class="source-code">public void TakeDamage(int incomingDamage)</p><p class="source-code">      {</p><p class="source-code">        health -= incomingDamage;</p><p class="source-code">      }</p><p class="source-code">      </p><p class="source-code">      public int SendDamage()</p><p class="source-code">      {</p><p class="source-code">        return hitPower;</p><p class="source-code">      }</p></li>
			</ol>
			<p>Let's continue with another method for the <strong class="source-inline">Player</strong> script and make it possible for the player to<a id="_idIndexMarker227"/> control<a id="_idIndexMarker228"/> the player ship around the <strong class="bold">Game</strong> window.</p>
			<h3>The Movement method</h3>
			<p>In this <a id="_idIndexMarker229"/>section, we<a id="_idIndexMarker230"/> will code the <strong class="source-inline">Movement</strong> method, which will take input from the player's joypad/keyboard and also make use of the <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> floats to keep the player's ship within the scree:.</p>
			<ol>
				<li value="1">Still in the <strong class="source-inline">Player</strong> script, make a start with the following method using the following content to check for the player's input:<p class="source-code">void Movement()</p><p class="source-code">     {</p><p class="source-code">       if (Input.GetAxisRaw("Horizontal") &gt; 0)</p><p class="source-code">       {</p><p class="source-code">          if (transform.localPosition.x &lt; width +              width/0.9f)</p><p class="source-code">          {</p><p class="source-code">            transform.localPosition += new Vector3</p><p class="source-code">               (Input.GetAxisRaw("Horizontal")</p><p class="source-code">                 *Time.deltaTime*travelSpeed,0,0);                                                                                                                            </p><p class="source-code">          }</p><p class="source-code">       }</p><ul><li>The <strong class="source-inline">Movement</strong> method will consist of detecting movement in four directions being made from the player; we'll start with when the player presses right on the controller/keyboard. We run an <strong class="source-inline">if</strong> statement that checks whether the Input Manager has detected any movement from the <strong class="source-inline">Horizontal</strong> property. If the <strong class="source-inline">GetAxisRaw</strong> detects a value higher than zero, we fall into the <strong class="source-inline">if</strong> statement's condition. Note that <strong class="source-inline">GetAxisRaw</strong> has no smoothing, so the player's ship will instantly move unless extra code is added.</li><li>Next, we have another <strong class="source-inline">if</strong> statement; this checks whether the player has exceeded past the <strong class="source-inline">width</strong> (that is, of the screen's world space that we calculated earlier on in the chapter). We've also added an extra partial <strong class="source-inline">width</strong> to avoid the geometry of the player's ship leaving the screen. If the player's position is still under the <strong class="source-inline">width</strong> (and its buffer) value, we run the content inside the <strong class="source-inline">if</strong> statement.</li><li>The player's<a id="_idIndexMarker231"/> position is updated with a <strong class="source-inline">Vector3</strong> struct, which<a id="_idIndexMarker232"/> holds the value of the <strong class="source-inline">Horizontal</strong> direction, multiplied by time per frame and by the <strong class="source-inline">travelSpeed</strong> we set from our <strong class="source-inline">ScriptableObject</strong>.</li></ul></li>
				<li>Let's continue in the <strong class="source-inline">Movement</strong> method and add a similar <strong class="source-inline">if</strong> statement for moving the player ship to the left:<p class="source-code">if (Input.GetAxisRaw("Horizontal") &lt; 0)</p><p class="source-code">        {</p><p class="source-code">          if (transform.localPosition.x &gt; width +               width/6)</p><p class="source-code">          {</p><p class="source-code">           transform.localPosition += new Vector3</p><p class="source-code">             (Input.GetAxisRaw("Horizontal")</p><p class="source-code">               *Time.deltaTime*travelSpeed,0,0);                                                                       </p><p class="source-code">          }</p><p class="source-code">        } </p></li>
			</ol>
			<p>As we can see, the code is close to the previous block; the only difference is that our first <strong class="source-inline">if</strong> statement checks whether we are moving left; the second <strong class="source-inline">if</strong> statement checks whether the player's position is greater than the width and a slightly different buffer.</p>
			<p>Apart from that, the <strong class="source-inline">if</strong> statement and its content serve the same position, just in the opposite direction.</p>
			<ol>
				<li value="3">Let's continue with our <strong class="source-inline">Movement</strong> method and add the <strong class="source-inline">if</strong> statement code for moving<a id="_idIndexMarker233"/> the<a id="_idIndexMarker234"/> player's ship down:<p class="source-code">if (Input.GetAxisRaw("Vertical") &lt; 0)</p><p class="source-code">     {</p><p class="source-code">         if (transform.localPosition.y &gt; -height/3f)</p><p class="source-code">         {</p><p class="source-code">          transform.localPosition += new Vector3</p><p class="source-code">           (0,Input.GetAxisRaw("Vertical")*Time.deltaTime*travelSpeed,0);</p><p class="source-code">         }</p><p class="source-code">     }</p></li>
			</ol>
			<p>Yet again, we follow the same rule from the previous two <strong class="source-inline">if</strong> statements, but this time, instead of <strong class="source-inline">Horizontal</strong>, we add the <strong class="source-inline">Vertical</strong> <strong class="source-inline">string</strong> property. In the second <strong class="source-inline">if</strong> statement, we check whether the player's y-axis is higher than a negative <strong class="source-inline">height/3</strong>. The reason why we divide by this value is that later on in the book (<a href="B18381_09_Epub.xhtml#_idTextAnchor161"><em class="italic">Chapter 9</em></a><em class="italic">, Creating a 2D Shop Interface and In-Game HUD</em>), we will be adding graphics at the bottom of the screen that will restrict the player's view.</p>
			<ol>
				<li value="4">Let's move on to the last <strong class="source-inline">if</strong> statement in the <strong class="source-inline">Movement</strong> method, moving up:<p class="source-code">if (Input.GetAxisRaw("Vertical") &gt; 0)</p><p class="source-code">        {</p><p class="source-code">         if (transform.localPosition.y &lt; height/2.5f)</p><p class="source-code">        {</p><p class="source-code">         transform.localPosition += new Vector3</p><p class="source-code">           (0,Input.GetAxisRaw("Vertical")*Time.deltaTime*travelSpeed,0);</p><p class="source-code">        }</p><p class="source-code">       }</p><p class="source-code">     }</p></li>
			</ol>
			<p>As before, this <strong class="source-inline">if</strong> statement carries a similar role, but this time, it's checking whether <a id="_idIndexMarker235"/>the player's position is under the <strong class="source-inline">height/2.5f</strong> value. A<a id="_idIndexMarker236"/> buffer is applied to stop the three-dimensional geometry from leaving the top of the screen.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When making a game, sometimes it occurs that when the player moves diagonally, their speed increases. This is because the player is effectively pressing two directions at the same time instead of just one.</p>
			<p class="callout">To ensure a direction has just the magnitude of <strong class="source-inline">1</strong>, we can use Unity's pre-made <strong class="source-inline">Normalize</strong> function.</p>
			<p class="callout">To find out more about this function, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html">https://docs.unity3d.com/ScriptReference/Vector3.Normalize.html</a>.</p>
			<ol>
				<li value="5">Don't forget to save the script.</li>
			</ol>
			<p>We will continue with the <strong class="source-inline">Player</strong> script by adding the <strong class="source-inline">Die</strong> method.</p>
			<h3>The Die method</h3>
			<p>Adding<a id="_idIndexMarker237"/> the <strong class="source-inline">Die</strong> method to the <strong class="source-inline">Player</strong> script will make it possible for<a id="_idIndexMarker238"/> our player to be destroyed. Currently, inside the <strong class="source-inline">Die</strong> method is a Unity function called <strong class="source-inline">Destroy</strong>; this function will delete whatever game object is within its parameter. </p>
			<p>Enter the following method in the <strong class="source-inline">Player</strong> script to destroy the player:</p>
			<p class="source-code">public void Die()</p>
			<p class="source-code">      {</p>
			<p class="source-code">          Destroy(this.gameObject);</p>
			<p class="source-code">      }</p>
			<p>Let's move on to the last method in the <strong class="source-inline">Player</strong> script, which is to attack.</p>
			<h3>The Attack method</h3>
			<p>In this<a id="_idIndexMarker239"/> section, we <a id="_idIndexMarker240"/>will add content to the <strong class="source-inline">Attack</strong> method in the <strong class="source-inline">Player</strong> script.</p>
			<p>The purpose of this <strong class="source-inline">Attack</strong> method is to receive input from the player, create a bullet, point the bullet in the correct direction, and make the bullet a child of the <strong class="source-inline">Player</strong> game object to keep our <strong class="bold">Hierarchy</strong> window tidy.</p>
			<p>Enter the following <strong class="source-inline">Attack</strong> method into the <strong class="source-inline">Player</strong> script to allow the player to fire bullets:</p>
			<p class="source-code">public void Attack()</p>
			<p class="source-code">      {</p>
			<p class="source-code">       if (Input.GetButtonDown("Fire1"))</p>
			<p class="source-code">         {</p>
			<p class="source-code">             GameObject bullet = GameObject.Instantiate</p>
			<p class="source-code">                (fire,transform.position,Quaternion.Euler</p>
			<p class="source-code">                  (new Vector3(0, 0, 0))) as GameObject;</p>
			<p class="source-code">             bullet.transform.SetParent(_Player.transform);</p>
			<p class="source-code">             bullet.transform.localScale = new Vector3(7,7,7);</p>
			<p class="source-code">         }</p>
			<p class="source-code">       }</p>
			<p class="source-code">     </p>
			<p>Inside the <strong class="source-inline">Attack</strong> method, we call an <strong class="source-inline">if</strong> statement that checks whether the player has pressed the <strong class="source-inline">Fire1</strong> button (<em class="italic">Left Ctrl</em> on Windows; <em class="italic">command</em> if you are using a Mac). If <a id="_idIndexMarker241"/>the<a id="_idIndexMarker242"/> player has pressed the <strong class="source-inline">Fire1</strong> button, we will drop into the <strong class="source-inline">if</strong> statement's scope.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When a developer refers to the scope of a function, <strong class="source-inline">if</strong> statement, class, and so on, they are referring to what is happening between the opening and closing of the curly braces. For example, if the following code has a higher value in its <strong class="source-inline">money</strong> variable, the following <strong class="source-inline">if</strong> statement will run:</p>
			<p class="callout">     </p>
			<p class="callout">     <strong class="source-inline">if (money &gt; costOfPizza)</strong></p>
			<p class="callout">     <strong class="source-inline">{</strong></p>
			<p class="callout">     <strong class="source-inline">//Whatever happens between the top and bottom of the two curly braces is within the if statements scope.</strong></p>
			<p class="callout">     <strong class="source-inline">}</strong></p>
			<p>Within the <strong class="source-inline">if</strong> statement, we make another <strong class="source-inline">if</strong> statement to make sure that when clicking the mouse, we are clicking on the screen and not anything UI-related. This will become more relevant when we look at adding a Pause button in <a href="B18381_10_Epub.xhtml#_idTextAnchor173"><em class="italic">Chapter 10</em></a>, <em class="italic">Pausing the Game, Altering Sound, and a Mock Test</em>. If we do click on something UI-related, we call <strong class="source-inline">return</strong>, which means we exit the <strong class="source-inline">if</strong> statement so that we don't fire a shot.</p>
			<p>Because we have entered the movement and attack function content we can scroll back up to the <strong class="source-inline">Update</strong> function and remove the comments we added.</p>
			<p>Our <strong class="source-inline">Update</strong> function will now look like the following:</p>
			<p class="source-code">void Update()</p>
			<p class="source-code">{</p>
			<p class="source-code">	Movement();</p>
			<p class="source-code">	Attack();</p>
			<p class="source-code">}</p>
			<p>Next, we <strong class="source-inline">Instantiate</strong> our <strong class="source-inline">PlayerBullet</strong> game object from its instance name, <strong class="source-inline">fire</strong>. We also face the <strong class="source-inline">fire</strong> game object to the right, relative to the screen, and move it toward oncoming enemies. We store the results of creating and orienting our game object in a variable named <strong class="source-inline">bullet</strong>.</p>
			<p>We then set the size of the bullet to be seven times larger than its original size, which makes it look bigger.</p>
			<p>Finally, within the <strong class="source-inline">if</strong> statement, we make our <strong class="source-inline">bullet</strong> game object sit within a single game object with the variable name <strong class="source-inline">_Player</strong>.</p>
			<p>That is all of the code required for the <strong class="source-inline">Player</strong> script! Make sure to save the script before<a id="_idIndexMarker243"/> moving <a id="_idIndexMarker244"/>on.</p>
			<p>In the next section, we are going to move on to a different player script that controls what happens when the player fires their bullet.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/>Setting up our PlayerBullet script</h2>
			<p>In this section, we <a id="_idIndexMarker245"/>will be creating a bullet that will travel across the screen from the player's ship.</p>
			<p>You will notice how similar the <strong class="source-inline">PlayerBullet</strong> script is to the <strong class="source-inline">Player</strong> script because it carries the <strong class="source-inline">IActorTemplate</strong> and <strong class="source-inline">SOActorModel</strong> scripts, which are already coded into the <strong class="source-inline">Player</strong> script.</p>
			<p>Let's create our <strong class="source-inline">PlayerBullet</strong> script:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window of the Unity Editor, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">PlayerBullet</strong>.</li>
				<li>Open the script and check/enter the following code at the top of the script:<p class="source-code"><strong class="bold">using UnityEngine;</strong></p></li>
			</ol>
			<p>By default, we require the <strong class="source-inline">UnityEngine</strong> library, as previously mentioned.</p>
			<ol>
				<li value="3">Let's continue by checking the correct class name and entering the following inheritance:<p class="source-code"><strong class="bold">public class PlayerBullet : MonoBehaviour, IActorTemplate {</strong></p></li>
			</ol>
			<p>We declare the <strong class="source-inline">public</strong> class and by default inherit <strong class="source-inline">MonoBehaviour</strong>. We also inherit the <strong class="source-inline">IActorTemplate</strong> interface to give our game object-related methods from the other game object scripts, such as <strong class="source-inline">SendDamage</strong> and <strong class="source-inline">TakeDamage</strong>.</p>
			<ol>
				<li value="4">Enter the<a id="_idIndexMarker246"/> following global variables into the <strong class="source-inline">PlayerBullet</strong> script:<p class="source-code">GameObject actor;</p><p class="source-code">     int hitPower;</p><p class="source-code">     int health;</p><p class="source-code">     int travelSpeed;</p><p class="source-code">      </p><p class="source-code">     [SerializeField]</p><p class="source-code">     SOActorModel bulletModel;</p></li>
			</ol>
			<p>All the variables we add are <strong class="source-inline">private</strong>. The last variable has a <strong class="source-inline">SerializeField</strong> attribute added. <strong class="source-inline">SerializeField</strong> makes it possible for this variable to be visible in the <strong class="bold">Inspector</strong> window, so even though it's <strong class="source-inline">private</strong>, we can still drag and drop assets into its field (which we will do shortly). More information on the <strong class="source-inline">SerializeField</strong> attributes can be found at <a href="https://docs.unity3d.com/ScriptReference/SerializeField.html">https://docs.unity3d.com/ScriptReference/SerializeField.html</a>.</p>
			<ol>
				<li value="5">Next, we'll move on and enter the <strong class="source-inline">Awake</strong> function along with its content:<p class="source-code">void Awake()</p><p class="source-code">      {</p><p class="source-code">          ActorStats(bulletModel);</p><p class="source-code">      }</p></li>
			</ol>
			<p>In our <strong class="source-inline">Awake</strong> function is the <strong class="source-inline">ActorStats</strong> method, which is a requirement because we are inheriting an <strong class="source-inline">interface</strong> that declares it.</p>
			<ol>
				<li value="6">Continue by entering the <strong class="source-inline">SendDamage</strong> and <strong class="source-inline">TakeDamage</strong> methods:<p class="source-code"> public int SendDamage()</p><p class="source-code">      {</p><p class="source-code">        return hitPower;</p><p class="source-code">      }</p><p class="source-code">      </p><p class="source-code">      public void TakeDamage(int incomingDamage)</p><p class="source-code">      {</p><p class="source-code">        health -= incomingDamage;</p><p class="source-code">      }</p></li>
			</ol>
			<p>As <a id="_idIndexMarker247"/>mentioned already in this chapter, we require these methods to send and receive damage.</p>
			<ol>
				<li value="7">Moving on, we enter the <strong class="source-inline">Die</strong> method along with its content:<p class="source-code"> public void Die()</p><p class="source-code">      {</p><p class="source-code">          Destroy(this.gameObject);</p><p class="source-code">      }</p></li>
			</ol>
			<p>Another method to include from our <strong class="source-inline">interface</strong> is the <strong class="source-inline">Die</strong> method.</p>
			<ol>
				<li value="8">Next, enter the <strong class="source-inline">ActorStats</strong> method:<p class="source-code"> public void ActorStats(SOActorModel actorModel)</p><p class="source-code">      {</p><p class="source-code">        hitPower = actorModel.hitPower;</p><p class="source-code">        health = actorModel.health;</p><p class="source-code">        travelSpeed = actorModel.speed;</p><p class="source-code">        actor = actorModel.actor;</p><p class="source-code">      }</p></li>
			</ol>
			<p>The last method that we inherit from our <strong class="source-inline">interface</strong> is the <strong class="source-inline">ActorStats</strong> method, which will hold our <strong class="source-inline">ScriptableObject</strong> asset. This asset will then be assigned to our <strong class="source-inline">PlayerBullet</strong> script's global variables.</p>
			<ol>
				<li value="9">The next function is the <strong class="source-inline">OnTriggerEnter</strong>, along with its <strong class="source-inline">if</strong> statement<a id="_idIndexMarker248"/> condition checks, as follows:<p class="source-code">void OnTriggerEnter(Collider other)</p><p class="source-code">      {</p><p class="source-code">      if (other.tag == "Enemy")</p><p class="source-code">      {</p><p class="source-code">          if(other.GetComponent&lt;IActorTemplate&gt;() != null)</p><p class="source-code">          {</p><p class="source-code">              if (health &gt;= 1)</p><p class="source-code">              {</p><p class="source-code">                  health -= other.GetComponent&lt;IActorTemplate&gt;</p><p class="source-code">                    ().SendDamage();</p><p class="source-code">              }</p><p class="source-code">              if (health &lt;= 0)</p><p class="source-code">              {</p><p class="source-code">                  Die();</p><p class="source-code">              }</p><p class="source-code">          }</p><p class="source-code">       }</p><p class="source-code">      }</p></li>
			</ol>
			<p>In the preceding block of code, we run a check to see whether our bullet has collided with an <strong class="source-inline">"Enemy"</strong> tagged collider. If the collider is tagged as <strong class="source-inline">"Enemy"</strong> to the player, we then check to see whether the collider holds an <strong class="source-inline">IActorTemplate</strong> interface. If it doesn't, then it's likely the <strong class="source-inline">"Enemy"</strong> collider is an obstacle. Otherwise, we deduct <strong class="source-inline">health</strong> from the <strong class="source-inline">Enemy</strong> game object and check to see whether it's dead.</p>
			<ol>
				<li value="10">Now, let's<a id="_idIndexMarker249"/> enter Unity's <strong class="source-inline">Update</strong> function for the bullet's movement:<p class="source-code">void Update ()</p><p class="source-code">      {</p><p class="source-code">        transform.position += new</p><p class="source-code">           Vector3(travelSpeed,0,0)*Time.deltaTime;</p><p class="source-code">      }</p></li>
			</ol>
			<p>The <strong class="source-inline">Update</strong> function adds to its x-axis each frame based on its <strong class="source-inline">travelSpeed</strong> value multiplied by <strong class="source-inline">Time.deltaTime</strong> (<strong class="source-inline">Time.deltaTime</strong> is the time in seconds from the last frame).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">If you would like to know more about <strong class="source-inline">Time.deltaTime</strong>, check the documentation at <a href="https://docs.unity3d.com/ScriptReference/Time-deltaTime.html">https://docs.unity3d.com/ScriptReference/Time-deltaTime.html</a>.</p>
			<ol>
				<li value="11">Next, enter Unity's <strong class="source-inline">OnBecameInvisible</strong> function:<p class="source-code">    void OnBecameInvisible() </p><p class="source-code">         {</p><p class="source-code">           Destroy(gameObject);</p><p class="source-code">         }</p><p class="source-code">     }</p></li>
			</ol>
			<p>This last function will remove any unnecessary bullets that have left the screen. This will help the performance of our game and keep it tidy. Make sure you have saved the script before continuing.</p>
			<p>Next, we need <a id="_idIndexMarker250"/>to apply the <strong class="source-inline">PlayerBullet</strong> script to our <strong class="source-inline">player_bullet</strong> prefab:</p>
			<ol>
				<li value="1">Navigate to <strong class="source-inline">Assets/Prefab/Player</strong> and select <strong class="source-inline">player_bullet</strong>.</li>
				<li>With <strong class="source-inline">Player_Bullet</strong> selected, click the <strong class="bold">Add Component</strong> button in the <strong class="bold">Inspector</strong> window and type <strong class="source-inline">PlayerBullet</strong> until you see the <strong class="source-inline">PlayerBullet</strong> script.</li>
				<li>Select the script and add the <strong class="source-inline">PlayerBullet</strong> asset to it from the <strong class="bold">Bullet Model</strong> field (drag the asset into the field or click the remote button to the right of its field).</li>
			</ol>
			<p>The following screenshot shows our <strong class="source-inline">player_bullet</strong> with its script and asset:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_2.45_B18381.jpg" alt="Figure 2.45 – The player_bullet components in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.44 – The player_bullet components in the Inspector window</p>
			<p>We can now <a id="_idIndexMarker251"/>move on to the next section about making enemies for the player to attack!</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor067"/>Planning and creating our enemy</h1>
			<p>We have a <a id="_idIndexMarker252"/>player that moves, shoots, and takes damage; we can now start looking into creating an enemy that shares these attributes.</p>
			<p>To remind ourselves of the genre we are making, our game carries the same traits as classic arcade shooters such as Konami's <em class="italic">Gradius</em>, Capcom's <em class="italic">UN Squadron</em>, and Irem's <em class="italic">R-Type</em> (<a href="https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png">https://github.com/retrophil/Unity-Certified-Programmer-Exam-Guide-2nd-Edition/blob/main/Reference/shootEmUps.png</a>). Typically, with these types of games, the player is swarmed by enemies coming from the right of the screen and exiting to the left.</p>
			<p>In this section, we will be repeating similar aspects of the <strong class="source-inline">PlayerSpawner</strong> and <strong class="source-inline">Player</strong> scripts. The <strong class="source-inline">EnemySpawner</strong> script needs to be tweaked so that it will instantiate a given number of enemy ships at a certain rate.</p>
			<p>The <strong class="source-inline">Enemy</strong> game objects will be moving on their own, so there needs to be some extra code applied to their behavior. Before we go into creating our first enemy script, let's look at a part of our game framework and note that the layout is basically the same as the player's side of the game framework:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_2.46_B18381.jpg" alt="Figure 2.46 – EnemySpawner and Enemy UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.45 – EnemySpawner and Enemy UML</p>
			<p>Before we <a id="_idIndexMarker253"/>jump into the <strong class="source-inline">EnemySpawner</strong> script, let's do the same housekeeping we did for our player game objects, namely creating an empty game object and storing all game objects relating to it in that one game object. The reason we did this is to remove the clutter in the <strong class="bold">Hierarchy</strong> window, so let's do the same for our enemies:</p>
			<ol>
				<li value="1">Right-click in the <strong class="bold">Hierarchy</strong> window's open space.</li>
				<li>A drop-down list will appear; select <strong class="bold">Create Empty</strong>.</li>
				<li>Name the game object <strong class="source-inline">_Enemies</strong>.</li>
			</ol>
			<p>Let's move on to our enemy scripts.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor068"/>Setting up our EnemySpawner and Enemy scripts</h1>
			<p>In this<a id="_idIndexMarker254"/> section, we<a id="_idIndexMarker255"/> are going to make a start on our <strong class="source-inline">EnemySpawner</strong> script and game object. The purpose of the <strong class="source-inline">EnemySpawner</strong> script is to have a game object spawn an enemy game object a series of times at a set rate. As soon as our <strong class="source-inline">testLevel</strong> scene begins, our enemy spawners will start releasing enemies. It will then be up to the enemies to move to the left of the screen. This is fairly simple, and as mentioned briefly in the previous section, the <strong class="source-inline">EnemySpawner</strong> uses the same <strong class="source-inline">interface</strong> and scriptable object as the <strong class="source-inline">PlayerSpawner</strong> to <strong class="source-inline">instantiate</strong> enemies. Let's start by creating our <strong class="source-inline">EnemySpawner</strong> script:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window in the Unity Editor, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">EnemySpawner</strong>.</li>
				<li>Open the script and enter the following code:<p class="source-code"><strong class="bold">using System.Collections;</strong></p><p class="source-code">     <strong class="bold">using UnityEngine;</strong></p></li>
			</ol>
			<p>As usual, we are using the default <strong class="source-inline">UnityEngine</strong> library.</p>
			<p>We are also going to be using another library, called <strong class="source-inline">System.Collections</strong>. This is required when we come to use <strong class="source-inline">Coroutines</strong>, which will be explained later in this section.</p>
			<ol>
				<li value="3">Next, we will check/enter the class name and its inheritance:<p class="source-code"><strong class="bold">public class EnemySpawner : MonoBehaviour</strong></p><p class="source-code"><strong class="bold">     {</strong></p></li>
			</ol>
			<p>Make sure the class is named <strong class="source-inline">EnemySpawner</strong> and that it also inherits <strong class="source-inline">MonoBehaviour</strong> by default.</p>
			<ol>
				<li value="4">Following this, add four global variables to the <strong class="source-inline">EnemySpawner</strong> script:<p class="source-code"> [SerializeField]</p><p class="source-code">      SOActorModel actorModel;</p><p class="source-code">      [SerializeField]</p><p class="source-code">      float spawnRate;</p><p class="source-code">      [SerializeField]</p><p class="source-code">      [Range(0,10)]</p><p class="source-code"> int quantity;</p><p class="source-code">      GameObject enemies;</p></li>
			</ol>
			<p>All variables entered in the previous code have an accessibility level of <strong class="source-inline">private</strong>, and all of the variables apart from the <strong class="source-inline">enemies</strong> variable have a <strong class="source-inline">SerializeField</strong> and a <strong class="source-inline">Range</strong> attribute of between <strong class="source-inline">0</strong> to <strong class="source-inline">10</strong> applied. The reason <a id="_idIndexMarker256"/>for<a id="_idIndexMarker257"/> this is so that we or other designers can easily change the spawn rate and quantity of enemies from our <strong class="source-inline">EnemySpawner</strong> in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_2.47_B18381.jpg" alt="Figure 2.47 – Enemy spawn rate slider&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.46 – Enemy spawn rate slider</p>
			<ol>
				<li value="5">Now, let's enter Unity's <strong class="source-inline">Awake</strong> function along with some content:<p class="source-code">void Awake()</p><p class="source-code">      {</p><p class="source-code">          enemies = GameObject.Find("_Enemies");</p><p class="source-code">          StartCoroutine(FireEnemy(quantity, spawnRate));</p><p class="source-code">      }</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">Awake</strong> function, we make an instance from the empty <strong class="source-inline">_Enemies</strong> game object divider and store it in the <strong class="source-inline">enemies</strong> variable.</p>
			<p>The second line of code inside our <strong class="source-inline">Awake</strong> function is a <strong class="source-inline">StartCoroutine</strong>.</p>
			<p class="callout-heading">Important Information</p>
			<p class="callout"><strong class="source-inline">StartCoroutine()</strong> and <strong class="source-inline">IEnumerator</strong> go hand in hand with each other. They act similarly to a method, taking parameters and running the code inside it. The main difference with coroutines is that they can be delayed by frame updates or time. You can consider them a more advanced version of Unity's own <strong class="source-inline">Invoke</strong> function.</p>
			<p class="callout">To find out more about coroutines and how to implement them in <strong class="source-inline">IEnumerator</strong> instances, check Unity's documentation at <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.StartCoroutine.html</a>.</p>
			<p>This will be<a id="_idIndexMarker258"/> used <a id="_idIndexMarker259"/>to run our method of creating an enemy, but as you may also notice, it takes two parameters. The first is the <strong class="source-inline">quantity</strong> of enemies it holds and the second is the <strong class="source-inline">spawnRate</strong>, which delays each spawned enemy.</p>
			<ol>
				<li value="6">Next, in our <strong class="source-inline">EnemySpawner</strong> script, we have the <strong class="source-inline">FireEnemy</strong>, which will be used to run a cycle of creating and positioning each enemy, before waiting to repeat the process.</li>
				<li>Next, below and outside of the <strong class="source-inline">Awake</strong> function, we can add our <strong class="source-inline">IEnumerator</strong>:<p class="source-code">IEnumerator FireEnemy(int qty, float spwnRte)</p><p class="source-code">      {</p><p class="source-code">       for (int i = 0; i &lt; qty; i++)</p><p class="source-code">       {</p><p class="source-code">        GameObject enemyUnit = CreateEnemy();</p><p class="source-code">        enemyUnit.gameObject.transform.SetParent(this.transform);</p><p class="source-code">        enemyUnit.transform.position = transform.position;</p><p class="source-code">        yield return new WaitForSeconds(spwnRte); </p><p class="source-code">       }</p><p class="source-code">        yield return null;</p><p class="source-code">       }</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">FireEnemy</strong> <strong class="source-inline">IEnumerator</strong>, we start a <strong class="source-inline">for</strong> loop that will iterate over its <strong class="source-inline">qty</strong> value.</p>
			<p>Within the <strong class="source-inline">for</strong> loop, the following is added:</p>
			<ul>
				<li>A method that we haven't covered yet, called <strong class="source-inline">CreateEnemy</strong>. The result of <strong class="source-inline">CreateEnemy</strong> will <a id="_idIndexMarker260"/>be turned into a game object <a id="_idIndexMarker261"/>instance called <strong class="source-inline">enemyUnit</strong>.</li>
				<li>The <strong class="source-inline">enemyUnit</strong> is the enemy flying out of the <strong class="source-inline">EnemySpawner</strong> game object.</li>
				<li>Our <strong class="source-inline">EnemySpawner</strong> position is issued to our <strong class="source-inline">enemyUnit</strong>.</li>
				<li>We then wait however many seconds the <strong class="source-inline">spwnRte</strong> value is set to.</li>
				<li>Finally, the process is repeated up until the <strong class="source-inline">for</strong> loop has reached its total.</li>
			</ul>
			<ol>
				<li value="8">Finally, below and outside of the <strong class="source-inline">FireEnemy</strong> <strong class="source-inline">IEnumerator</strong>, add the following method:<p class="source-code">GameObject CreateEnemy()</p><p class="source-code">     {</p><p class="source-code">       GameObject enemy = GameObject.Instantiate(actorModel.actor) </p><p class="source-code">          as GameObject;</p><p class="source-code">       enemy.GetComponent&lt;IActorTemplate&gt;().ActorStats(actorModel);</p><p class="source-code">       enemy.name = actorModel.actorName.ToString();</p><p class="source-code">       return enemy;</p><p class="source-code">     }</p><p class="source-code">     }</p></li>
			</ol>
			<p>As we mentioned, there is a method called <strong class="source-inline">CreateEnemy</strong>. Apart from the obvious, this method will do the following:</p>
			<ol>
				<li value="1"><strong class="source-inline">Instantiate</strong> the <strong class="source-inline">enemy</strong> game object from its <strong class="source-inline">ScriptableObject</strong> asset.</li>
				<li>Apply values to our enemy from its <strong class="source-inline">ScriptableObject</strong> asset.</li>
				<li>Name the enemy game object from its <strong class="source-inline">ScriptableObject</strong> asset.</li>
			</ol>
			<p>Don't forget to save the script.</p>
			<p>We can now <a id="_idIndexMarker262"/>move <a id="_idIndexMarker263"/>on to the next section where we will create and prepare the <strong class="source-inline">EnemySpawner</strong> with its game object.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/>Adding our script to the EnemySpawner game object</h2>
			<p>Finally, we<a id="_idIndexMarker264"/> need to attach our <strong class="source-inline">EnemySpawner</strong> script to an empty game object so that we can use it in our <strong class="source-inline">testLevel</strong> scene. To set up the <strong class="source-inline">EnemySpawner</strong> game object, do the following:</p>
			<ol>
				<li value="1">Create an empty game object and name it <strong class="source-inline">EnemySpawner</strong>.</li>
				<li>As we did with the <strong class="source-inline">_Player</strong> and <strong class="source-inline">PlayerSpawner</strong>, we need to move the <strong class="source-inline">EnemySpawner</strong> game object inside the <strong class="source-inline">_Enemies</strong> game object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>After moving the <strong class="source-inline">EnemySpawner</strong> game object into the <strong class="source-inline">_Enemies</strong> game object, we now need to update the <strong class="source-inline">EnemySpawner</strong> game object's <strong class="bold">Transform</strong> property values in the <strong class="bold">Inspector</strong> window:</li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_2.48_B18381.jpg" alt="Figure 2.48 – The EnemySpawner Transform values in the Inspector window&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.47 – The EnemySpawner Transform values in the Inspector window</p>
			<ol>
				<li value="4">Still in the <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Component</strong> and type <strong class="source-inline">EnemySpawner</strong> until you see it in the list, and then click it.</li>
			</ol>
			<p>Also, for a visual <a id="_idIndexMarker265"/>aid in the <strong class="bold">Scene</strong> window, it is recommended to add an <strong class="bold">Inspector</strong> icon to the <strong class="source-inline">EnemySpawner</strong> game object, as we did with our <strong class="source-inline">PlayerSpawner</strong> game object in the <em class="italic">Creating the PlayerSpawner game object</em> section.</p>
			<p>The following screenshot shows the icon I gave to my <strong class="source-inline">EnemySpawner</strong>:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_2.49_B18381.jpg" alt="Figure 2.49 – The EnemySpawner icon&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.48 – The EnemySpawner icon</p>
			<p>We can now add an enemy to our <strong class="bold">Enemy Spawner</strong> along with the <strong class="bold">Spawn Rate</strong> and <strong class="bold">Quantity</strong> values specified in the <strong class="bold">Inspector</strong> window. The following screenshot shows an example of a filled-in <strong class="source-inline">EnemySpawner</strong> game object with its script in the <strong class="bold">Inspector</strong> window:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_2.50_B18381.jpg" alt="Figure 2.50 – The EnemySpawner component holding the BasicWave Enemy actor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.49 – The EnemySpawner component holding the BasicWave Enemy actor</p>
			<p>We can now <a id="_idIndexMarker266"/>move on to creating our enemy script in the next section.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor070"/>Setting up our enemy script</h2>
			<p>As with our player<a id="_idIndexMarker267"/> ship being created from the <strong class="source-inline">PlayerSpawner</strong>, our first enemy will be created from its <strong class="source-inline">EnemySpawner</strong>. The enemy script will hold similar variables and functions, but it will also have its own movement, similar to the <strong class="source-inline">PlayerBullet</strong> moving along its <em class="italic">x</em> axis.</p>
			<p>Let's make a start and create our enemy script:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window of the Unity Editor, create a script in the <strong class="source-inline">Assets/Scripts</strong> folder with the filename <strong class="source-inline">EnemyWave</strong>. </li>
				<li>Open the script and check/enter the following required library code at the top of the script:<p class="source-code"><strong class="bold">using UnityEngine;</strong></p></li>
			</ol>
			<p>Like the majority of our classes, we require the <strong class="source-inline">UnityEngine</strong> library.</p>
			<ol>
				<li value="3">Check and enter the class name and its inheritance:<p class="source-code"><strong class="bold">public class EnemyWave : MonoBehaviour, IActorTemplate</strong></p><p class="source-code"><strong class="bold">     {</strong></p></li>
			</ol>
			<p>We have a <strong class="source-inline">public class</strong> named <strong class="source-inline">EnemyWave</strong> that inherits <strong class="source-inline">MonoBehaviour</strong> by default but also adds our <strong class="source-inline">IActorTemplate</strong> interface.</p>
			<ol>
				<li value="4">Within the <strong class="source-inline">EnemyWave</strong> class, enter<a id="_idIndexMarker268"/> the following global variables:<p class="source-code"> int health;</p><p class="source-code">      int travelSpeed;</p><p class="source-code">      int fireSpeed;</p><p class="source-code">      int hitPower;</p><p class="source-code">      </p><p class="source-code">      //wave enemy</p><p class="source-code">      [SerializeField]</p><p class="source-code">      float verticalSpeed = 2;</p><p class="source-code">      [SerializeField]</p><p class="source-code">      float verticalAmplitude = 1;</p><p class="source-code">      Vector3 sineVer;</p><p class="source-code">      float time;</p></li>
			</ol>
			<p>The global variables for the <strong class="source-inline">EnemyWave</strong> class are the top four variables updated with values from its <strong class="source-inline">ScriptableObject</strong> asset. The other variables are specific to the enemy, and we have given two of these variables <strong class="source-inline">SerializeField</strong> attributes for debugging purposes in the <strong class="bold">Inspector</strong> window. </p>
			<ol>
				<li value="5">Add Unity's <strong class="source-inline">Update</strong> function along with its content:<p class="source-code">void Update ()</p><p class="source-code">      {</p><p class="source-code">          Attack();</p><p class="source-code">      }</p></li>
			</ol>
			<p>After the global variables, we add an <strong class="source-inline">Update</strong> function containing an <strong class="source-inline">Attack</strong> method.</p>
			<ol>
				<li value="6">Add our <strong class="source-inline">ScriptableObject</strong> method, <strong class="source-inline">ActorStats</strong>, and its content:<p class="source-code">public void ActorStats(SOActorModel actorModel)</p><p class="source-code">      {</p><p class="source-code">          health = actorModel.health;</p><p class="source-code">          travelSpeed = actorModel.speed;</p><p class="source-code">          hitPower = actorModel.hitPower;</p><p class="source-code">      }</p></li>
			</ol>
			<p>We have <a id="_idIndexMarker269"/>our <strong class="source-inline">ActorStats</strong> method that takes in a <strong class="source-inline">ScriptableObject</strong> <strong class="source-inline">SOActorModel</strong>. This <strong class="source-inline">ScriptableObject</strong> then applies the variable values it holds and applies them to the <strong class="source-inline">EnemyWave</strong> script's variables.</p>
			<ol>
				<li value="7">Still in the <strong class="source-inline">EnemyWave</strong> script, add the <strong class="source-inline">Die</strong> method along with its content:<p class="source-code">public void Die()</p><p class="source-code">      {</p><p class="source-code">          Destroy(this.gameObject);</p><p class="source-code">      }</p></li>
			</ol>
			<p>Another familiar method if you have been following along is the <strong class="source-inline">Die</strong> method, which is called when the enemy has been destroyed by the player. </p>
			<ol>
				<li value="8">Add Unity's <strong class="source-inline">OnTriggerEnter</strong> function to the <strong class="source-inline">EnemyWave</strong> script:<p class="source-code">void OnTriggerEnter(Collider other)</p><p class="source-code">      {</p><p class="source-code">        // if the player or their bullet hits you.</p><p class="source-code">        if (other.tag == "Player")</p><p class="source-code">        {</p><p class="source-code">           if (health &gt;= 1)</p><p class="source-code">           {</p><p class="source-code">              health -= other.GetComponent&lt;IActorTemplate&gt;</p><p class="source-code">                ().SendDamage();</p><p class="source-code">           }</p><p class="source-code">           if (health &lt;= 0)</p><p class="source-code">           {</p><p class="source-code">              Die();</p><p class="source-code">           }</p><p class="source-code">         }</p><p class="source-code">       }</p><p class="source-code">      </p></li>
			</ol>
			<p>Unity's own <strong class="source-inline">OnTriggerEnter</strong> function will check to see whether they have collided with <a id="_idIndexMarker270"/>the player and, if so, will send damage, and the enemy will destroy themselves with the <strong class="source-inline">Die</strong> method.</p>
			<ol>
				<li value="9">Continue and enter the <strong class="source-inline">TakeDamage</strong> and <strong class="source-inline">SendDamage</strong> methods:<p class="source-code">public void TakeDamage(int incomingDamage)</p><p class="source-code">      {</p><p class="source-code">        health -= incomingDamage;</p><p class="source-code">      }</p><p class="source-code">      public int SendDamage()</p><p class="source-code">      {</p><p class="source-code">        return hitPower;</p><p class="source-code">      }</p></li>
			</ol>
			<p>Another common set of methods from the <strong class="source-inline">IActorTemplate</strong> interface is to send and receive damage from the <strong class="source-inline">EnemyWave</strong> script.</p>
			<p>Next is the <strong class="source-inline">Attack</strong> method, which controls the movement/attack of the enemy. This method is called in the <strong class="source-inline">Update</strong> function on every frame.</p>
			<p>With this attack, we will make the enemy move from right to left in a wavy animation (like a snake) instead of just going straight right to left. The following image shows our<a id="_idIndexMarker271"/> enemies moving from right to left in a wavy line:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_2.51_B18381.jpg" alt="Figure 2.51 – The enemies' wave attack pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.50 – The enemies' wave attack pattern</p>
			<ol>
				<li value="10">Enter the following <strong class="source-inline">Attack</strong> method code into the <strong class="source-inline">EnemyWave</strong> script:<p class="source-code">public void Attack()</p><p class="source-code">      {</p><p class="source-code">        time += Time.deltaTime;</p><p class="source-code">        sineVer.y = Mathf.Sin(time * verticalSpeed) *     verticalAmplitude;</p><p class="source-code">        transform.position = new Vector3(transform.            position.x + travelSpeed * Time.deltaTime,</p><p class="source-code">        transform.position.y + sineVer.y,</p><p class="source-code">        transform.position.z);</p><p class="source-code">      }}</p></li>
			</ol>
			<p>The <strong class="source-inline">Attack</strong> method starts with <strong class="source-inline">Time.deltaTime</strong> being collected in a <strong class="source-inline">float</strong> variable labeled <strong class="source-inline">time</strong>. </p>
			<p>We then use a premade function from Unity that returns a sine (<a href="https://docs.unity3d.com/ScriptReference/Mathf.Sin.html">https://docs.unity3d.com/ScriptReference/Mathf.Sin.html</a>) using our <strong class="source-inline">time</strong> variable, multiplied by a set speed from the <strong class="source-inline">verticalSpeed</strong> variable, followed by the result being multiplied by <strong class="source-inline">verticalAmplitude</strong>.</p>
			<p>The end result is stored in the <strong class="source-inline">Vector3</strong> <em class="italic">y</em> axis. What this basically does is make our enemy ship move up and down. The <strong class="source-inline">verticalSpeed</strong> parameter sets its speed and <strong class="source-inline">verticalAmplitude</strong> alters how far it goes up and down.</p>
			<p>Then, we do a <a id="_idIndexMarker272"/>similar task to what we did with the <strong class="source-inline">PlayerBullet</strong> to make the enemy ship move along the <em class="italic">x</em> axis, and we also add a sine calculation to its <strong class="source-inline">Y</strong> position for it to move up and down.</p>
			<p>Make sure to save the script before we wind down this chapter.</p>
			<p>Before we summarize, click <strong class="bold">Play</strong> in the Editor, and hopefully, if all is well, you will have a player ship that you will be able to fly around within the boundaries of the <strong class="bold">Game</strong> window's aspect ratio; enemies will come floating into the screen and move from right to left; you will be able to destroy these enemies with your bullets. These enemies will also be able to destroy you if they make contact with you. Finally, our <strong class="bold">Hierarchy</strong> window is all neat and well-structured both before and after playing our game. The following screenshot shows what I have just explained: </p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_2.52_B18381.jpg" alt="Figure 2.52 – The Game window with the current gameplay and the Hierarchy game object structured&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.51 – The Game window with the current gameplay and the Hierarchy game object structured</p>
			<p>You have done so much already! The good news is that you've just conquered one of the biggest chapters <a id="_idIndexMarker273"/>in the book – quite sneaky of me, I know. But we already have the backbone of our game, and most importantly, we've covered a good chunk of the Unity Programmer exam.</p>
			<p>Understandably, you may have come across some possible issues on the way, and you may feel stuck. Don't worry if this is the case – check the <strong class="source-inline">Complete</strong> folder for this chapter to load up the Unity project and compare the code in that folder with your own to double-check. Make sure you have the right game objects in your scene, check that the right game objects are tagged, check the radius size of your <strong class="bold">Sphere</strong> colliders, and if you have any errors or warnings appear in the <strong class="bold">Console</strong> window, double-click them, and they will<a id="_idIndexMarker274"/> take you to the code that's causing the issue.</p>
			<p>Let's wrap up this chapter and talk about our game so far.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Summary</h1>
			<p>We have reached the end of this chapter, and we have conquered the majority of our game framework, as we can see in the following diagram:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_2.53_B18381.jpg" alt="Figure 2.53 – Killer Wave UML&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.52 – Killer Wave UML</p>
			<p>We have created a game framework that would need only a few changes whether we added 1 or 1,000 more enemies to our game. Some of the benefits of this use of reusable code and <strong class="source-inline">ScriptableObject</strong> is that it will benefit non-programmers, save time, and prevent collaborators from being bogged down in the code.</p>
			<p>We have also made it possible that if and when we want to add more <strong class="source-inline">EnemySpawner</strong> points, we can drag and drop more prefabs into our scene and update its <strong class="source-inline">ScriptableObject</strong> to change the enemy without coding in exact <strong class="source-inline">Vector3</strong> locations.</p>
			<p>We've covered other common Unity features, including instantiating game objects such as enemies and player bullets. </p>
			<p>In the next chapter, we will be covering the following scripts:</p>
			<ul>
				<li><strong class="source-inline">ScoreManager</strong>: When an enemy is destroyed, the player will receive a score.</li>
				<li><strong class="source-inline">ScenesManager</strong>: If the player dies, one life will be deducted; if the player loses all of their lives, the level will reset.</li>
				<li><strong class="source-inline">Sounds</strong>: Our ships and bullets will also have added sounds.</li>
			</ul>
			<p>Finally, we will be updating the overall structure of our code.</p>
		</div>
	</body></html>