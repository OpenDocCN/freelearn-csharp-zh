- en: '*Chapter 12*: NavMesh, Timeline, and a Mock Test'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to cover two main functionalities that Unity offers
    developers for issuing **AI** to our game objects and for animation that supports
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: Unity has a ready-made system for our game objects to issue a path-finding algorithm
    where a game object can be given an area to patrol. This can be very handy in
    a series of games that use enemy soldiers to walk up and down a corridor looking
    for the player. A soldier can react depending on the behavior given to them.
  prefs: []
  type: TYPE_NORMAL
- en: The other functionality we will be covering is the **Timeline** component, which
    is used for animation in scenarios such as cutscenes in games/films. You may be
    thinking that we already covered an animation system back in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087),
    *Applying Art, Animation, and Particles*. Yes, you are right, but for a more complex
    animation that holds multiple game objects and animations, transitions and states
    can get complex pretty easily. Also, Timeline supports a series of tracks that
    work specifically with our code, and we can add our own custom animation tracks
    to our timeline.
  prefs: []
  type: TYPE_NORMAL
- en: These two main features will be assigned to our Killer Wave game project. The
    **Navigation Mesh** (**NavMesh**) controls a flock of small **Non-Player-Character**
    (**NPC**) robots that will move away from our player's ship as if they're panicking
    to stay alive.
  prefs: []
  type: TYPE_NORMAL
- en: Timeline will be used to apply a mid-level cutscene where our player will see
    the end-of-level boss rush past them and lights in the scene will flash red.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will end this chapter with the last mini-mock test, which will include
    questions covering the content from this chapter and previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the final scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing AI with NavMesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the timeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by reviewing what skills are covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The core exam skills covered in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Programming core interaction*:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing behaviors and interactions of game objects and environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying methods to implement camera views and movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working in an art pipeline*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowledge of materials, textures, and shaders: The Unity rendering API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowledge of lighting: The Unity lighting API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowledge of two-dimensional and three-dimensional animation: The Unity animation
    API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Programming for the scene and environment design*:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining scripts for pathfinding with the Unity navigation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  prefs: []
  type: TYPE_NORMAL
- en: All the content for this chapter is held in the chapter's `unitypackage` file,
    including a `Complete` folder that holds all of the work we'll carry out in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3LsC0B4](https://bit.ly/3LsC0B4).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the final scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to prepare our new `level3` scene in two parts
    – the first part of our game will have some three-dimensional art assets for the
    player to potentially collide with. Also, the environment will be used for our
    new fleeing enemies. The second part of this section is used to upgrade our camera's
    behavior so that instead of it being static, we now require it to move across
    the level. The player will also be given the same fixed speed as the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this section, we will have an environment set up, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Our third level assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Our third level assets
  prefs: []
  type: TYPE_NORMAL
- en: The arrow going from left to right in the previous screenshot shows the path
    of the camera. Once it reaches a particular point, it will stop, and the level
    will end shortly after.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that within the `level3Env` prefab is a game object that
    holds a script called `BossTrigger`. This game object contains a box collider,
    a rigid body, and a `BossTriggerBox` script.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the `BossTrigger` game object is to activate the `BossTrigger`
    collider. We will discuss this further in the *Exploring the timeline* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by moving our `level3` file''s environment into the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Scene` and double-click on the `level3` scene file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Assets/Prefab`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `level3Env` prefab into the `_SceneAssets` game object in
    the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `level3Env` from the `2500`, `17`, and `-24`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0.55`, `0.55`, and `0.55`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our scene setup, which is ready for our player
    to fly into:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The level 3 assets in place'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – The level 3 assets in place
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to make some changes to our `level3` scene so that it acts in a
    way that ensures the camera supports the new environment and the environment itself
    doesn't have extra assets that we don't need, such as the animating texture quad
    for the background and the prefab particle system for the stars flying past. Be
    aware, if any of these game objects are in a prefab state, be sure to unpack (right
    click game object in **Hierarchy** **Prefab | Unpack**) them otherwise we will
    be changing the content in levels 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alter the `level3` scene in the **Hierarchy** window by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the aforementioned two assets sit within the `GameSpeed` game object
    in the `GameSpeed` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We won't be using any directional lighting in our scene, so also remove `Directional
    Light` from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, for the sake of running our `level3` scene without going through the entire
    game loop, we can drop our `GameManager` prefab from the `Assets/Prefab` folder
    location into the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our `level3` will now look like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Our Hierarchy layout so far'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.03_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Our Hierarchy layout so far
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to make it so that the **Camera** component supports a far clipping-plane
    value. To do this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `1300`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, we have adjusted the clipping plane of the camera to show all of the `level3`
    file's environment, removed the `GameSpeed` game object that helps art assets
    for our previous levels, and added `GameManager` to `level3` to make development
    easier. We now need to turn our focus toward making the camera actually move instead
    of creating the illusion it is moving, as with `level1` and `level2`.
  prefs: []
  type: TYPE_NORMAL
- en: I have created a small script that will make the camera move from one point
    to another; everything inside the script demonstrates elements of code that we
    have already covered throughout this book. So, there's no need for you to create
    the script, but understanding it is obviously the main purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to attach the script to the main camera in our scene to control
    its movement. Follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `CameraMovement` until you see the script appear in the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **CameraMovement** script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `box collider` into the drop-down list. When it appears, select it
    and check its **Is Trigger** box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In brief, this script will translate along its *x* axis after 6 seconds when
    active. When the script reaches a particular point, it will stop; it will also
    make sure that the player stops traveling with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s modify our `Player` script to act on the movement of the camera for
    `level3`:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Script` and double-click on the `Player` script to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `Player` script, at the top where we have our global variables,
    enter the private variable and its property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `camTravelSpeed` variable that we just entered will be used as an extra
    multiplier to set the pace of the player's ship when the camera moves along the
    *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: The second variable, `movingScreen`, will hold the result of `Time.deltaTime`
    multiplied by `camTravelspeed`. Later, `movingScreen` will be used when it comes
    to comparing the player's ship's *x* axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Start` function, add the following line at the bottom of its function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `Start` function, we will add our `width float` measurement to `movingScreen`
    (this happens after `width` has been updated in the `Start` function), as this
    will be the starting position before it receives its increments from `Time.deltaTime`
    and `camTravelspeed`.
  prefs: []
  type: TYPE_NORMAL
- en: Still inside the `Player` script, scroll down to the `Movement` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `Movement` method, enter the following code, which will multiply
    our player''s ship''s speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the code that we've just entered, we will run a check to see whether `camTravelSpeed`
    has increased from our new `CameraMovement` script. If `camTravelSpeed` has been
    updated, we fall into the scope of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `if` statement, we will increment the player's ship's *x* axis to
    the right, multiplied by `Time.deltaTime` and `camTravelSpeed`.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we do is add the `movingScreen` value that originally holds
    the current `width` of our playing area. However, because the screen is moving,
    we need to increment the playing area so that the player doesn't get left behind
    or go too far out of the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: The last amendment we add to our `Player` script is our horizontal movements,
    still in the `Movement` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down until you get to where the player can press the *right arrow* to
    move (`Input.GetAxisRaw("Horizontal") > 0`). Within the scope of the `if` statement,
    we can amend the second `if` statement to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the player presses the *right arrow* on their keyboard/joypad, we can run
    a check to see whether the player's *x* axis is less than the `movingScreen` float
    value; plus, we will include a buffer to push the player further to the edge of
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then do the same for when the player presses the *left arrow* on the
    keyboard/joystick within the second `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar rules apply where we make use of the `movingScreen` variable, which
    is constantly incremented along with a slight buffer to keep our player's ship
    within the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: Save the `Player` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we move on to the next script, we need to uncomment two lines of code
    in our new `CameraMovement` script so that it can interact with the `Player` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `CameraMovement` script and uncomment the two following lines by
    removing `//`. The first line to uncomment is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line to uncomment is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, these two lines of code can alter the speed of the player ship.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update our `GameManager` script so that it recognizes the difference
    between `level1`, `level2`, and `level3`, which has a moving camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s move to the `GameManager` script and add two main elements – the
    camera speed and noticing the difference between scenes. Let''s start by opening
    the `GameManager` script:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Script`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `GameManager` script to open it in your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may or may not have looked into the `CameraMovement` script that we attached
    to the main camera, but inside that script is a variable called `camSpeed`. This
    variable manipulates the camera's speed; in our `GameManager` script, we set the
    speed of the main camera.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway from this is that the `CameraMovement` script will manipulate
    the camera's speed from what is set in the `GameManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GameManger` script, scroll down to the method titled `CameraSetup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to make this method take a variable to alter the camera''s speed.
    Change the `CameraSetup` method to take a `float` value in its parameter. The
    `CameraSetup` method will first look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will then change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `CameraSetup` method, we need to transfer `camSpeed` to the new
    `CameraMovement` script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the line of code we add to our `CameraSetup` method needs to be added
    after the main camera has been stored in a `gameCamera` variable. Before continuing
    we also need to remove the reference to the `CameraSetup` from the `PlayerSpawner`
    script as we also don't need this anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PlayerSpawner` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll to the bottom and remove: `GameManager.Instance.CameraSetup()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script and return to the `GameManager` script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing to do in the `GameManager` script is to update the `LightandCameraSetup`
    method so that when the `CameraSetup` method within it is called, it takes a value
    that sets the main camera's speed. So, in `level1` and `level2`, we want the camera
    to continue to not move; in `level3`, we will need to apply speed to the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within `LightandCameraSetup`, replace its original `switch` statement with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, before, our `switch` statement had all the cases run `LightSetup` and `CameraSetup`
    within cases `3`, `4`, and `5`. But now, in the previous code, we have split the
    roles up. In cases `3` and `4`, we run `LightSetup` as usual, and now, because
    `CameraSetup` now takes a `float` value, we set the camera speed to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In case `5`, which is the build number for our `level3` scene, we ignore `LightSetup`,
    as we won't be using a directional light in this scene. We run `CameraSetup` but
    give it a value of `150`, which will also be the speed we set the `camSpeed` variable
    within the method.Save the `GameManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press `level3` scene plays out. The following screenshot shows what we have
    so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Level 3 in Play mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.04_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Level 3 in Play mode
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous screenshot shows a series of events of what happens after we press
    **Play** in the Unity Editor Let''s go through each event sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: The `level3` scene before pressing **Play** (denoted by **1.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scene is in play mode and sets up the camera position and background (denoted
    by **2.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UI for the level is animated, and the enemies start floating into the game
    window (denoted by **3.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The player enters the level, and the scene pauses for a few seconds before the
    player gets control of their ship (denoted by **4.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The camera begins to move along with the radar camera, following the progress
    of the player and the oncoming enemies (denoted by **5.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will add our second enemy type (flee enemy), which will
    flee across the span of our new art.
  prefs: []
  type: TYPE_NORMAL
- en: Developing AI with NavMesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to introduce a new enemy that will attempt to
    flee with frenzy-type behavior from our player's ship. This enemy's behavior will
    be implemented with the use of Unity's built-in `NavMesh` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, this built-in feature from Unity can answer a lot of problems
    with regard to games with NPCs, similar to ones in the Metal Gear Solid game,
    where the player has to sneak around and not get detected by the enemy soldiers.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMesh` gives the enemy soldiers a path to walk around, and then if they
    see the player, their behavior changes from `Patrolling` to `Attack`.'
  prefs: []
  type: TYPE_NORMAL
- en: So, with our game, we are going to implement `NavMesh` but make it so that our
    enemies react differently to how they would in *Metal Gear Solid*. We will add
    multiple flee enemies in clusters to our third-level scene. This chaotic, distracting
    behavior will make the final level more challenging for our players.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our fleeing enemy with a cylindrical radius
    around it. This radius is called the agent radius and can be altered to stop other
    obstacles and enemies from intersecting with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Fleeing enemies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.05_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Fleeing enemies
  prefs: []
  type: TYPE_NORMAL
- en: Before we add these fleeing enemies to our scene, we need to tell the fleeing
    enemies where they can move around by baking a NavMesh first.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to select the game object that we will use to bake, which also
    means we need to deselect game objects that don''t need to be **Navigation Static**.
    To bake a NavMesh, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `_SceneAssets` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `_SceneAssets`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `_SceneAssets` selected and the static dropdown
    (denoted by **1.**), followed by **Navigation Static** being unticked (denoted
    by **2.**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Unticking Navigation Static'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.06_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Unticking Navigation Static
  prefs: []
  type: TYPE_NORMAL
- en: A window pops up asking whether we want to apply the changes to all the child
    objects. Select **Yes, change children**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we have just deactivated all of our environment art assets in the `level3`
    scene so that they are not recognized for navigation baking. We now need to turn
    on one of the child game objects within the `_SceneAssets` hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `corridorFloorNav`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_SceneAssets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`corridorFloor`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows that from the `corridorFloorNav` (denoted by
    **1.**):'
  prefs: []
  type: TYPE_NORMAL
- en: With `corridorFloorNav` selected, make sure its **Mesh Renderer** component
    is ticked in the **Inspector** window (denoted by **2.**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, select **Navigation Static** for this game object (denoted by **3.**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Turning on the ''corridorFloorNav'' game object, Mesh Renderer,
    and the ''Navigation Static'' layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.07_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Turning on the 'corridorFloorNav' game object, Mesh Renderer,
    and the 'Navigation Static' layer
  prefs: []
  type: TYPE_NORMAL
- en: We now need to check the `CorridorFloorNav` mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Window** at the top of the Unity Editor and then click on **AI | Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s likely that the **Navigation** window will appear at the top-right corner
    of the Editor If it doesn''t and has appeared as a floating window somewhere in
    the Unity Editor simply click and hold on the **Navigation** tab and dock it next
    to the **Inspector** tab, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Navigation window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.08_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – The Navigation window
  prefs: []
  type: TYPE_NORMAL
- en: In the **Navigation** window, click on the **Bake** button at the top to give
    us our **Navigation** bake options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It's also worth noting that a game object that is manipulated in the NavMesh
    is referred to as an agent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this window, we are presented with a series of options for our navigation
    bake. This may look a little intimidating at first, but the blue cylinder is basically
    our agent (the fleeing enemy) and the following parameters are based on how flexible
    our agent is with the navigation path it''ll be walking around. Let''s briefly
    go through each of the options so that we are aware of its features before we
    bake:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agent Radius**: This will create an invisible shield around our agent so
    that they can''t clip into other agents, walls, doors, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent Height**: Similar to **Agent Radius**, this gives our agent an invisible
    height; this can be useful for the game object that the NavMesh is manipulating
    to pass through doors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Max Slope**: We can alter, in degrees, how much of a slope our agent can
    walk up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Height**: This is similar to the **Max Slope** property, but in this
    case, this controls how much our agent is allowed to move up a step/stair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drop Height**: Enter a value for the maximum height the character can drop
    down from (associated with the **Off Mesh Link** component).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jump Distance**: This specifies the value for the jump distance between the
    character and the object (associated with the **Off Mesh Link** component).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Information about the **Off Mesh Link** component can be found at [https://docs.unity3d.com/Manual/class-OffMeshLink.html](https://docs.unity3d.com/Manual/class-OffMeshLink.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Manual Voxel**: A voxel is a three-dimensional measurement that is used to
    scale the accuracy of our navigation bake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Voxel Size**: If the **Manual Voxel** option is ticked, this means we can
    give each agent tighter precision. The lower the number, the more accurate our
    agent will be; note that this will make the NavMesh take longer to bake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Min Region Area**: This specifies a minimum area that a surface must have
    for it to be included in the NavMesh.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height Mesh**: This checkbox will create a height mesh, which will improve
    the movement accuracy. This will also make navigation baking slower.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the navigation bake settings we just went through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The Navigation window with the ''Bake'' tab selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.09_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.9 – The Navigation window with the 'Bake' tab selected
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, the **Bake** properties of our default setup window will work just
    fine as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Bake** button at the bottom right of the **Navigation** window
    and wait until the meter at the bottom-right corner of the Editor completes, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Exporting Tiles for your NavMesh'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.10_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.10 – Exporting Tiles for your NavMesh
  prefs: []
  type: TYPE_NORMAL
- en: Once the navigation bake has completed, `corridorFloorNav` in our **Scene**
    window will have a NavMesh sitting on top of its mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t see the navigation-baked mesh, make sure that the **Show NavMesh**
    checkbox is ticked at the bottom-right corner of the mesh. The following screenshot
    shows our NavMesh and the **Navmesh Display** box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the ''Scene'' window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.11_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.11 – Our navigation mesh and its display at the bottom-right corner
    of the 'Scene' window
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to do in this section is turn off the `corridorFloorNav` game
    object's **Mesh Renderer** component. We only needed this component to be active
    for the NavMesh to be baked.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn off the `corridorFloorNav` game object''s **Mesh Renderer** component,
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `corridorFloorNav` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, uncheck the **Mesh Renderer** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the highlighted box that needs unchecking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Unticking the ''corridorFloorNav'' mesh'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.12_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.12 – Unticking the 'corridorFloorNav' mesh
  prefs: []
  type: TYPE_NORMAL
- en: This is all that is needed to allow our fleeing enemies to move around.
  prefs: []
  type: TYPE_NORMAL
- en: Further Information
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to find out more about the **Navigation** window, check out
    [https://docs.unity3d.com/Manual/Navigation.html](https://docs.unity3d.com/Manual/Navigation.html).
  prefs: []
  type: TYPE_NORMAL
- en: So far in this section, we have discussed the requirements of AI and how it
    is used in games and how we are going to apply such methods to our fleeing enemies,
    with the use of the `NavMesh` system that Unity offers as standard.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our NavMesh baked for our agents to move around on, we can
    look into setting up our `NavMeshAgent` component to give our agents a set speed,
    acceleration, stopping distance, and more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing our agents – NavMeshAgent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be continuing from setting up our NavMesh but shifting
    the focus toward the agent (the fleeing enemy game object). The agent will be
    moving around the baked NavMesh.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary for the fleeing enemy game object to be able to react and move
    within the NavMesh but also be able to move in a way that suits the behavior of
    what we're trying to achieve. For example, the enemy is to flee with an element
    of panic; so, we need to consider characteristics such as when the enemy decides
    to move, how quickly the enemy will react, and how fast the enemy can move. These
    properties, and more, come from a component called `NavMeshAgent`.
  prefs: []
  type: TYPE_NORMAL
- en: '`NavMeshAgent` is a required component that will be attached to each of the
    fleeing enemy game objects. The purpose of this component is to make it so that
    the game object is recognized as an agent and will stick to the NavMesh.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add `NavMeshAgent` to the fleeing enemy, we need to create a prefab
    of the enemy so that we have a place where we can grab and clone copies of multiple
    enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Model` folder and drag `enemy_flee.fbx` to the bottom of the
    **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag `enemy_flee` from the `Assets/Prefab/Enemies`. When the window pops up
    asking if you want a variant or original. Pick original. As there is only one
    type of this enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s our fleeing enemy created; now, we can apply a material to it by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `Assets/Prefab/Enemies` folder and select the `enemy_flee` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** window, select the remote button of the **Mesh Renderer**
    component (denoted by **1**. in the following screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A dropdown will appear. Type `darkRed` in the search bar at the top if you can't
    see the material on the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `darkRed` from the dropdown (denoted by **2.** in the following).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, make sure that the `0` value and that the `1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `enemy_flee` prefab with its update material
    and the correct **Transform** values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Adding the ''darkRed'' material to the ''enemy_flee'' Mesh
    Renderer Materials slot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.13_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.13 – Adding the 'darkRed' material to the 'enemy_flee' Mesh Renderer
    Materials slot
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed in the previous screenshot that `enemy_flee` has hard,
    shiny edges. We can make these appear smoother in our three-dimensional model
    import settings by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Model` folder and select `enemy_flee`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** window, change the property value for **Normals** from
    **Import** to **Calculate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now adjust the **Smoothing Angle** value with the slider to change the
    smoothness between angles, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Smoothing the edges of our enemy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.14_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Smoothing the edges of our enemy
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, you can see three distinct stages in making the
    model look smoother. This can be done with any three-dimensional model imported
    into Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're happy with the **Smoothing Angle** value, click on **Apply** at
    the bottom-right corner of the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Coming back to `enemy_flee` in the **Hierarchy** window, as this is an enemy,
    we also need to give it an **Enemy** tag so that the player recognizes it as such
    if and when they collide with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Tag** parameter at the top of the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Enemy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `enemy_flee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Our enemy being given an ''Enemy'' tag'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.15_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – Our enemy being given an 'Enemy' tag
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to apply `NavMeshAgent` to the `enemy_flee` game object. With
    `enemy_flee` still selected, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Add Component** button in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A drop-down list will appear. Type in `nav` and select `NavMeshAgent` from the
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`enemy_flee` now has `NavMeshAgent` attached to it. As previously mentioned,
    let''s go through each of the properties. The following screenshot also shows
    the `NavMeshAgent` default values (these may differ from your default values,
    but don''t be concerned, as we will be changing the majority of the values):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – The ''Nav Mesh Agent'' component (its own default values –
    ignore them)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.16_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – The 'Nav Mesh Agent' component (its own default values – ignore
    them)
  prefs: []
  type: TYPE_NORMAL
- en: '**Agent Type**: By default, there is only one agent type. This holds a preset
    of the name of the agent, the radius, height, step height, and max slope. To find
    out more about these values, check the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base Offset**: This will change the placement of the agent mesh, which wraps
    around the fleeing enemy in the form of a cylinder that can only be seen in the
    **Scene** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: The maximum speed value, based on world units per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular Speed**: Sets how quickly the agent can rotate in degrees per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceleration**: Maximum acceleration based on world units per second squared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stopping Distance**: Agents will stop when they are at a particular measurement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Braking**: The agent will slow down gradually before reaching a complete
    stop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radius**: The agent''s spatial area will increase the scale of the agent
    cylinder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: This will increase the height of the agent''s cylinder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality**: The ranges of the accuracy of obstacle avoidance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: Agents of a lower priority will be ignored by this agent when
    performing avoidance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Traverse Off Mesh Link**: If you want the agent to move between gaps,
    keep this checked; otherwise, custom animation will move the agent across the
    gap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto Repath**: If the agent is no longer on the path they are walking, with
    this option checked, they will try and make their way back to the nearest point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Area Mask**: With navigation baking, we can set which area this agent belongs
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `NavMeshAgent`, we will set its agents to a high speed, rotation, and acceleration
    value to make these enemies react fast to match their fleeing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `NavMeshAgent` values for the `enemy_flee` prefab to the ones shown
    in the following screenshot. However, it''s recommended to change and alter the
    values to make the enemies behave differently. Theres no wrong approach. But as
    a guide, match the ones in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/Figure_12.17_B18381.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – 'Nav Mesh Agent' with set values
  prefs: []
  type: TYPE_NORMAL
- en: Click **Overrides | Apply All** at the top-right corner of the **Inspector**
    window to confirm your prefab changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we created the fleeing enemy prefab and gave it a material.
    We also applied a `NavMeshAgent` component to our enemy so that it's calibrated
    and ready to react.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the fleeing enemy looks like with its `NavMeshAgent`
    component wrapped around it, which can only be seen in the **Scene** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.18_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Our enemy with its NavMeshAgent collider wrapped around it
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will give the fleeing enemy prefab a collider so that
    when the player makes contact with it, the player and the enemy are destroyed
    with the soon-to-come scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a capsule collider to our fleeing enemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to add a capsule collider to the fleeing enemy
    so that a collision can be detected from the player''s ship when they collide
    with each other:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `enemy_flee` prefab still selected, scroll down to the bottom of the
    **Inspector** window and click on **Add Component**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `Capsule` into the drop-down window until you see **Capsule Collider**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Capsule Collider** from the drop-down list. The fleeing enemy will
    now have a capsule collider wrapped around them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, tick the **Is Trigger** checkbox in the **Capsule Collider** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `enemy_flee` prefab's settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `enemy_flee` game object in **Hierarchy** and delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `enemy_flee` with its capsule collider; these
    values may differ to yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – ''enemy_flee'' with its capsule collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.19_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – 'enemy_flee' with its capsule collider
  prefs: []
  type: TYPE_NORMAL
- en: The fleeing enemy is nearly ready to be tried out in the game. We just need
    to add a script to tell the game object what to do when it gets within a certain
    distance of the player. We will cover this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our fleeing enemy script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be making it so that the fleeing enemy detects when
    the player is getting close to them. If the player is too close, we will make
    it so that the enemy begins to flee.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be taking a script that is partially made and import it into this chapter,
    as the majority of the `EnemyFlee` script will contain a similar setup to the
    previous enemy that we made in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,
    Adding and Manipulating Objects*. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the `Assets/Script`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `EnemyFlee` script to begin adding its navigation code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `EnemyFlee` script will contain similar-looking code to the `EnemyWave`
    script. The enemies in our game will carry the same properties, such as giving
    and taking damage when hit or dying, detecting a collision, and inheriting their
    own scriptable object asset. There's no real need to go through this process again.
    What we are interested in is how the `enemy_flee` game object acts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the fleeing behavior to the `EnemyFlee` script, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the script, add the AI library to give our script access to the
    **Navigation Agent** files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our script, we will need access to the `NavMeshAgent` component (which is
    attached to our `enemy_flee` game object). The AI library gives us this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down in the script to where our global variables are (`health`, `travelSpeed`,
    `fireRate`, and so on) and add the following variables that we will be using with
    our navigation setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first variable will be used to store the reference to the player's ship,
    as we will be comparing its distance later on. The `bool` value will be used as
    part of a delayed start for our script. We will talk more about this later on
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`enemyDistanceRun` will be used as a rule to "act" within the measured distance
    between the player and our fleeing enemy. We have also added the `SerializeField`
    attribute to this, as it will be handy to change these values in the **Inspector**
    window while keeping this variable private. Do try a different value if you think
    200 is too low. Experiment!'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have `NavMeshAgent`, which will be required to receive data from
    the player and fleeing enemy results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Start` function that will require a short delay to get a reference
    from the player ship. Enter the following code. We will go through each step to
    see why there is a delay and the standard `ActorStats` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Start` function contains the `ActorStats` method, which will update our
    enemy's abilities (the health value, points added to the score, and so on), similar
    to our `enemy_wave` game object. We will also run an `Invoke` function, which
    takes the name of the method we wish to run along with a parameter that determines
    when the method will be run.
  prefs: []
  type: TYPE_NORMAL
- en: We are running a short `0.5f` second delay, giving the player's ship time to
    be instantiated into the scene before we take a reference from it. We set a Boolean
    value to `true` to say that the `update` function can run the content within it,
    which we will cover shortly. The final thing we do is take reference from the
    `NavMeshAgent` component attached to the game object.
  prefs: []
  type: TYPE_NORMAL
- en: We need to add a slight amendment to our speed value in our `ActorStats` method.
    Because we are affecting `NavMeshAgent_speed`, we need to manipulate this directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the enemies'' speed adjustable, add the following line of code within
    `ActorStats` of the `EnemyFlee` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The enemy flee speed value is now hooked up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the last piece of our code, the `Update` function will be measuring
    and reacting to and from the distance of our fleeing enemy and the player. Enter
    the following `Update` function and its content, and we will go through each step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Update` function, we will run an `if` statement to check whether the
    `gameStarts` Boolean value is `true`; if it is `true`, we then check to see whether
    `player_ship` is still in the scene. And if that is `true`, we move on to the
    content in that `if` statement. Within this `if` statement, we use `Vector3.Distance`
    to measure the distance between the player's ship and the fleeing enemy. We then
    store the measurement as a `float` value called `distance`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we run a check to see whether the distance measured is less than the `enemyDistanceRun`
    value, which is currently set to `200`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `distance` variable's value is lower, then that means the player's ship
    is too close to the fleeing enemy, so we run the following steps for it to react.
  prefs: []
  type: TYPE_NORMAL
- en: Store the `Vector3` variable, which minuses the player's position from our own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then add this `Vector3` variable to the fleeing enemy's `newPos` position
    of `Vector3`, which will be the direction for the enemy flee to run in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we send this `newPos` position to `NavMeshAgent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the `EnemyFlee` script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now ready to attach the `EnemyFlee` script to our `enemy_flee` prefab.
    Let''s do this now; then, we will be able to test the results:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Unity Editor navigate to the `Assets/Prefab/Enemies` folder in the
    **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `enemy_flee` prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `EnemyFlee`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Enemy Flee` script from the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `BasicFlee_Enemy`, and then store it in `Assets/ScriptableObject`.
    Drag the Actor into the Actor Model area of the `EnemyFlee` script in the **Inspector**
    window, as shown in the following screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the scriptable object asset for the `EnemyFlee`
    script''s **Actor Model** parameter on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – The ''enemy_flee'' game object holding its ''EnemyFlee'' script
    and updated fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.20_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – The 'enemy_flee' game object holding its 'EnemyFlee' script and
    updated fields
  prefs: []
  type: TYPE_NORMAL
- en: We now need to make our `enemy_flee` script recognizable on the radar map in
    the game HUD, as with the `enemy_wave` game object. As a reminder, we made a `radarPoint`
    object before in [*Chapter 9*](B18381_09_Epub.xhtml#_idTextAnchor161), *Creating
    a 2D Shop Interface and In-Game HUD*. So, in this chapter, we're going to speed
    things up and use a ready-made `radarPoint` object to attach to the `enemy_flee`
    game object. The only difference with the ready-made `radarPoint` game object
    is that I have attached a small script called `RadarRotation` that will make the
    `radarPoint` sprite always face the camera, regardless of which rotation the `enemy_flee`
    game object makes.
  prefs: []
  type: TYPE_NORMAL
- en: The `RadarRotation` script takes the current rotation in the `Awake` function,
    followed by reapplying the rotation on `LateUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: What Is LateUpdate?
  prefs: []
  type: TYPE_NORMAL
- en: '`LateUpdate` is the last function called in Unity''s execution order game logic.
    The benefit to this is that there is no fighting between the rotation of the `radarPoint`
    object and the `enemy_flee` rotation being called at the same time. If you would
    like to learn more about the execution order, check out [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To attach the pre-made `radarPoint` object to the `enemy_flee` prefab, we need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the `enemy_flee` prefab from `Assets/Prefab/Enemies` into the **Hierarchy**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the `radarPoint` object from `Assets/Prefab/Enemies` onto the
    `enemy_flee` prefab in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, drag and drop the `RadarRotation` script from `Assets/Script` into the
    `enemy_flee` `radarPoint` object point toward the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once applied, select the `enemy_flee` prefab from the **Hierarchy** window,
    and then click on **Overrides | Apply All** at the top-right corner of the **Inspector**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `enemy_flee` prefab holding the `radarPoint`
    object, along with the `radarPoint` object in the **Inspector** window, as a reference
    to help avoid any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.21 – The ''radarPoint'' game object and its Transform property
    values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.21_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – The 'radarPoint' game object and its Transform property values
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `enemy_flee` prefab is now ready to be trialed out in `enemy_flee` from
    its current location to the `_Enemies` game object in the `enemy_flee` now is
    in the **Hierarchy** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.22 – The ''Enemies'' game object children in the Hierarchy window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.22_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.22 – The 'Enemies' game object children in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the `enemy_flee` prefab to somewhere near the start of the level. I have
    placed mine at the following **Transform** values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.23 – The ''enemy_flee'' game object placement in level 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.23_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.23 – The 'enemy_flee' game object placement in level 3
  prefs: []
  type: TYPE_NORMAL
- en: If you also have the `EnemySpawner` object in the scene close to the start of
    the level, push it back along the *x* axis as far as `1000` to get it out of the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `enemy_flee` object should now start panicking and moving around to
    try and escape from you!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Feel free to select the `enemy_flee` object in the **Hierarchy** window and
    press *Left* + *Ctrl* (*Command* on macOS) + *D* on your keyboard to spread a
    few fleeing enemies around to make the level more interesting, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Duplicated ''enemy_flee'' game objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.24_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.24 – Duplicated 'enemy_flee' game objects
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows our new fleeing enemies trying to escape from
    the player in pure panic!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Enemies fleeing from the player!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.25_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.25 – Enemies fleeing from the player!
  prefs: []
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's the end of this section, and hopefully, you now feel comfortable with
    this introduction to using the NavMesh and agents. As you can imagine, our fleeing
    enemy could have other events attached to it, such as shooting bullets at the
    player when at a safe distance, taking cover around a corner, and calling for
    help. Adding a series of events to an NPC would require a finite state machine
    to go through each appropriate event.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced a new enemy that acted differently from our current
    wave enemy. We also became familiar with the ready-made path-finding algorithms
    offered by Unity, such as `NavMesh`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to move on to the next section, where we will introduce the timeline,
    which works as an animator but can also be used with regard to blending the logical
    behavior with our components – for example, to make a light blend into a different
    color by using scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Timeline** is a component in the Unity Editor that is intended to put a sequence
    of animations together, which is attractive to industries such as film and TV.
    **Timeline** is also welcomed in games that may have cutscenes to help tell a
    story or introduce a player to a level. Unity also has two other useful components
    – **Animator Controller** and **Animation** **Clips** – as you will know if you
    have been following this book, as we covered these other components in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    They carry out the same tasks, but as a scene becomes busier with a series of
    individual animation clips, things can get messy quickly in the animator controller,
    with the multiple states transitioning between each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the animator controller with multiple states
    and transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26 – An example of how chaotic Animator Controllers can get'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.26_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.26 – An example of how chaotic Animator Controllers can get
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeline** supports three tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing animations and clips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning game objects on or off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three capabilities on their own limit **Timeline** – for example, if we
    want to change the color of light, **Timeline** wouldn't be able to change the
    individual property alone. To change the color of light, we will need to change
    the light's property values in the **Animation** window itself. However, with
    some extra scripting to our timeline, we can introduce dragging and dropping game
    objects that hold components, such as a light component, where changes can be
    made on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to start by animating a large robotic craft in
    the timeline. Then, we will discuss playables and how they can extend a timeline's
    functionality. Finally, we will implement additional tracks to the timeline to
    control the color of the lights and fade the level into darkness once the player
    reaches the end of the level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by creating our `Timeline` game object and adding a **Timeline**
    component to it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to get more familiar with the **Timeline** component
    and create some of our own animations with a large flying robot. When setting
    up the timeline, we will also discuss the components and properties that are involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a timeline to our scene, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor's `Assets/Scene`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `level3` to load the scene if it isn't loaded already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click in the **Hierarchy** window and select **Create Empty** from the
    dropdown to create an empty game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `GameObject` twice slowly to rename it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `GameObject` `Timeline`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our `Timeline` game object still selected in the **Hierarchy** window,
    we can now open our **Timeline** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the Unity Editor, click on **Window | Sequencing** and then **Timeline**;
    the following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27 – Selecting the ''Timeline'' game object and opening a Timeline
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.27_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.27 – Selecting the 'Timeline' game object and opening a Timeline window
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s likely that the **Timeline** window will appear in the same window layout
    as your scene, which isn''t ideal, as we want to see our **Scene** while animating.
    To move the **Timeline** window to a better place, click on the name of the **Timeline**
    tag and drag it down to the bottom of the screen, where the **Console** and **Project**
    windows are. The following screenshot shows my current Unity Editor layout proportions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28 – Window placements in the Unity Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.28_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.28 – Window placements in the Unity Editor
  prefs: []
  type: TYPE_NORMAL
- en: We can now continue to create our `Timeline` asset, where we will be creating
    our new animations for all of our game objects and their components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a playable `Timeline` asset, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `Timeline` game object still selected in the **Hierarchy** window,
    click on the **Create** button in the **Timeline** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A window browser will appear to let us select where we want to save our playable
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the playable file a name (something relevant to what it's going to be used
    for; I'm naming mine `level3`) and click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `Timeline` asset has been created.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been following along with this book, at first glance, the **Timeline**
    window will likely look like the **Animation** window we saw in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*. If so, that's good! A good section of
    the controls and methodology will be familiar to you. One of the main differences
    of **Timeline** is that any of the game objects can be dragged into the **Timeline**
    window without needing to have any kind of hierarchical relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our **Timeline** window holding the **Timeline**
    game object in its first **Timeline** track:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29 – The Timeline window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.29_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.29 – The Timeline window
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the **Inspector** window, our **Timeline** game object has gained
    some extra components. The following screenshot shows two of the added components
    – **Playable Director** and **Animator**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30 – The ''Timeline'' game object holding the Playable Director
    and Animator components in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.30_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.30 – The 'Timeline' game object holding the Playable Director and
    Animator components in the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: We worked with the **Animator** component in [*Chapter 4*](B18381_04_Epub.xhtml#_idTextAnchor087)*,
    Applying Art, Animation, and Particles*, so for more details about this particular
    component, refer back to that chapter. Also, we don't actually do anything with
    the **Animator** component; it's just a required component for our **Timeline**
    setup.
  prefs: []
  type: TYPE_NORMAL
- en: The other component we gain when creating a `Timeline` asset file is **Playable
    Director**. It's the responsibility of this component to keep a relationship between
    the timeline and the game objects/components that are being manipulated. So, let's
    go through each of the properties under the **Playable Director** component to
    briefly get a general understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have **Playable**. When we click on the **Create** button in the **Timeline**
    window, we create a **Playable** file. This file holds all of the animations and
    game object/component instances relating to the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have **Update Method**. This parameter offers four properties that
    control how time affects the timeline. These properties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Digital Signal Processing** (**DSP**) helps to improve accuracy between our
    timeline and its audio to prevent it from going out of sync.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game Time**: The time for the timeline will be sourced from the game''s time.
    This also means the time can be scaled (that is, slowed down or paused).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unscaled Game Time**: This option works the same as the **Game Time** property,
    but it is not affected by scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual**: This property uses the clock time we give it through scripting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have **Play On Awake**. If this checkbox is ticked, our timeline will
    play as soon as the scene is active.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next parameter is **Wrap Mode**. This property determines what happens
    when the timeline has finished playing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hold**: When the timeline reaches the end, it holds on to the last frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loop**: The timeline repeats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**None**: The timeline plays and then resets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initial Time** adds a delay in seconds before the timeline begins.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have **Bindings**. When a game object or component is dragged into
    the **Timeline** window, the **Bindings** list will update and show what object
    is connected to the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed the timeline and introduced it to our scene. We have
    also gone through the components that are required to make the timeline work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are more familiar with the timeline and the components that work
    in conjunction with it, in the next subsections, we are going to incorporate our
    large boss ship into our `level3` scene and animate it through the timeline.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the boss game object in our scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to take a static UFO-looking game object from
    our imported project files, drop it into the scene, and attach it to the timeline.
    From there, we will animate our UFO so that it spins and moves across the scene
    on two occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bring the large boss `UFO` game object into our scene before animating it,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop the `boss.prefab` object from `Assets/Prefab/Enemies` into the
    `_Enemies` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we need to position the boss so that it's in our scene but out of view
    of the camera. That way, when it comes to animating the boss in the timeline,
    we can change its position and rotation when required.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `boss` game object in the `0`, `0`, and `-2000`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`, `0`, and `0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1`, `1`, and `1`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `boss` object still selected in the **Hierarchy** window, press *F*
    on your keyboard to see what it looks like in the **Scene** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the imported `boss` prefab, which contains a
    list of components and property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.31 – The ''boss'' game object tagged as ''Enemy'', positioned with
    the Transform component, and finally, set as a trigger with a scaled radius in
    Sphere Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.31_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.31 – The 'boss' game object tagged as 'Enemy', positioned with the
    Transform component, and finally, set as a trigger with a scaled radius in Sphere
    Collider
  prefs: []
  type: TYPE_NORMAL
- en: 'The `boss` object holds the following component and property values, as shown
    in the previous screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: Tagged as **Enemy** (denoted by **1.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Transform** property values are set to the ones detailed under *step 2*
    (denoted by **2.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`80` (denoted by **3.**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BossScript` makes the `boss` game object invincible to the player, and if
    the player makes contact with the boss, the player will die (denoted by **4.**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the `boss` object is an enemy, it has a `radarPoint` object that is
    picked up on the radar (denoted by **5.**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, we need to add a `RadarRotation` script
    to the `radarPoint` game object, which is a child of the `boss` game object. This
    script will make `radarPoint` always face the camera:'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the `boss` content in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `radarPoint`, and then drag and drop the `RadarRotation` script from
    `Assets/Script`, moving it from the **Project** window to the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the `boss` game object in the `BossScript` from `Assets/Script`
    into the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the `boss` object is in the scene, we can add it to the timeline in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the boss for the timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to take the `boss` game object from our `boss`
    object greet the player at the end of the level before jetting off after the player.
  prefs: []
  type: TYPE_NORMAL
- en: Further sections will continue to make use of the timeline, including using
    specialized `boss` object animated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To animate the `boss` object in the timeline, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object, and in the **Inspector** window, untick **Play
    On Awake**, as we will be triggering the **Timeline** animation ourselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To trigger the `BossTrigger` game object, which we mentioned at the beginning
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have the main camera recognized as a trigger, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the main camera in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Component** button in the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `Box Collider`, and when you see it in the drop-down list, select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick the **Is Trigger** box under the **Box Collider** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now continue setting up our `boss` game object into it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Timeline** tab, which, as you will know if you have been following
    along with the previous sections, is found at the bottom of the Unity Editor
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Timeline` game object and the `Timeline` game object from the **Timeline**
    window because we aren't going to animate it.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `Timeline` object in the **Timeline** window and select **Delete**
    from the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `Timeline` game object being deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.32 – Deleting the ''Timeline'' game object from the Timeline window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.32_B18381.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.32 – Deleting the 'Timeline' game object from the Timeline window
  prefs: []
  type: TYPE_NORMAL
- en: With the `Timeline` game object still selected in the `boss` game object from
    the **Hierarchy** window down into the **Timeline** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A dropdown will appear with a choice of three selections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Activation Track**: Turns a game object on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation Track**: Animates the game object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Audio Track**: Sets particular audio on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we want to animate our `boss` game object, we will choose **Animation
    Track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now have the `boss` game object in our `boss` game object will gain
    an **Animator** component in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what our timeline currently looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.33 – Timeline holding the ''boss'' game object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.33_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.33 – Timeline holding the 'boss' game object
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will start adding keyframes to our **Timeline** window, which will
    affect our boss''s position and rotation. Let''s start by locking our **Timeline**
    window so that when we click on another game object, it will remain active:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Timeline** window tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the padlock button at the top-right corner of the **Timeline** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The padlock button is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.34 – Locking the Timeline window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.34_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.34 – Locking the Timeline window
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next section, where we will start adding keyframes
    to the timeline and make our `boss` game object move and rotate in two phases
    of the third level. Let's start with phase one.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the boss in the timeline – phase one
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will be adding keyframes to the `boss` game object. This
    will make the `boss` game object travel from one point to another while rotating
    on its center pivot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start adding keyframes for the `boss` game object, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `boss` game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now start recording our boss's position and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: In the `boss` game object name; the button should begin to flash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the `0`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.35 – The Timeline frame set to zero'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.35_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.35 – The Timeline frame set to zero
  prefs: []
  type: TYPE_NORMAL
- en: In the `1675`, `0`, and `600`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.36 – The ''boss'' game object''s current location in our level
    3 scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.36_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.36 – The 'boss' game object's current location in our level 3 scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to animate the `boss` object from one end of the corridor to the other,
    we need to add another keyframe for the boss. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the record button still flashing in the `112` or change the value of the
    `112`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `boss` game object in the `3160`, `0`, and `600`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `20`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The **Timeline** and **Animation** windows have the same navigation rules with
    regard to zooming and panning in either window. Holding down the middle mouse
    button and moving the mouse will pan. Rolling the middle mouse wheel up or down
    zooms in and out. Hovering the mouse cursor over the animation bar and pressing
    *F* on the keyboard shows all the keyframes on the window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the record button next to the `boss` game object in the **Timeline**
    window to stop recording.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and scrub (`boss` game object move from left to right while rotating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a bird''s-eye view of the `boss` game object
    moving from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.37 – The ''boss'' game object will move from left to right'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.37_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.37 – The 'boss' game object will move from left to right
  prefs: []
  type: TYPE_NORMAL
- en: Later on, when we play the third level, we will see a moment where the `boss`
    game object rushes past the player in the distance. For now, we will continue
    by adding more keyframes to our **Timeline** window before moving on to looking
    at playables.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to phase two of animating our `boss` game object.
  prefs: []
  type: TYPE_NORMAL
- en: Animating the boss in the timeline – phase two
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we are going to animate our boss for a second time before the
    level ends as some form of resolution for the ending of this third and final level.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue from the same **Timeline** track that we started in
    the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s continue animating our boss from where we left off:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep the **Timeline** window padlocked to stop the window from losing its display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `boss` object from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the record button next to the `boss` object's name in the **Timeline**
    window so that the button flashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `1012` into the **Frame** parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `boss` object still selected in the `boss` object''s position and
    rotation values to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`4545`, `0`, and `600`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows where our boss sits in phase two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.38 – The ''boss'' game object positions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.38_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.38 – The 'boss' game object positions
  prefs: []
  type: TYPE_NORMAL
- en: With the record button still flashing, move to frame `1180` in the `boss` game
    object to the following `6390`, `0`, and `600`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-90`, and `20`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1193` in the `boss` game object to the following `6390`,
    `0`, and `207`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `450`, and `0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1215` in the `boss` game object to the following `5520`,
    `0`, and `50`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `90`, and `-40`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1380` in the `boss` game object to the following `5510`,
    `0`, and `50`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `90`, and `0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1400` in the `boss` game object to the following `5510`,
    `0`, and `50`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-70`, and `-40`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to frame `1420` in the `boss` game object to the following `7540`,
    `0`, and `50`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`60`, `-70`, and `0`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `boss` game object in the **Timeline** window to stop recording.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows a bird''s-eye view of each of these positions
    with their **Timeline** frame numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.39 – The Timeline frame numbers of where the ''boss'' game object
    will be'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.39_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.39 – The Timeline frame numbers of where the 'boss' game object will
    be
  prefs: []
  type: TYPE_NORMAL
- en: If you want to adjust the `boss` game object rotation more, it is recommended
    to have **boss** selected in the **Hierarchy** window. Make sure the local position
    is selected (denoted by **1** in the following screenshot) and, with the Timeline
    still in record mode, rotate the *z* axes several times (denoted by **2**).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.40 – Rotating the ''boss'' game object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.40_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.40 – Rotating the 'boss' game object
  prefs: []
  type: TYPE_NORMAL
- en: Finally, scrub backward and forward (move the **Timeline** indicator) in **Timeline**
    to see the result you are given.
  prefs: []
  type: TYPE_NORMAL
- en: When you are happy, stop recording.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, the `boss` game object flies in from
    the left to the right toward where the player will be. The boss will stop rotating,
    pause, turn around, and zip off to the far right.
  prefs: []
  type: TYPE_NORMAL
- en: Let's press `level3` scene so far, with the boss versus our player's ship throughout
    the `level3` scene.
  prefs: []
  type: TYPE_NORMAL
- en: The player moves through the level, and the boss animation is seen on two occasions.
    What we do see that we likely shouldn't is the large yellow dot of the boss even
    when the boss has moved on. It would be good if we could make the boss disappear
    off the radar when we can't see the game object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `boss` object on the left screen, which
    is not visible on the right screen but still detected on the radar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.41 – The ''boss'' game object''s radar is still detecting the boss'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.41_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.41 – The 'boss' game object's radar is still detecting the boss
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make use of the timeline before ending this section to simply turn the
    `radarPoint` game object off and then on when we see the `boss` game object. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Timeline` game object from the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Timeline` tab to see the `boss` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the boss's `radarPoint` object from the **Hierarchy** window
    into the **Timeline** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Timeline** dropdown appears. This time, select **Activation Track**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `radarPoint` track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now add an activation clip to decide when the player should and shouldn''t
    see the `radarPoint` object. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the track of the `radarPoint` object and select **Add Activation
    Clip**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.42 – In the Timeline window, add an activation clip for our ''radarPoint''
    game object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.42_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.42 – In the Timeline window, add an activation clip for our 'radarPoint'
    game object
  prefs: []
  type: TYPE_NORMAL
- en: An `boss` game object to be active on two occasions – once when the boss moves
    past the player in the open-space area of the environment, and once at the end
    when the boss approaches the player head-on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the first occasion, we need to set the `35` and `95` on the timeline. We
    can do this by clicking and dragging its bar down to the `95` mark, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.43 – Setting the activity of the ''radarPoint'' game object between
    set frames'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.43_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.43 – Setting the activity of the 'radarPoint' game object between
    set frames
  prefs: []
  type: TYPE_NORMAL
- en: For the second occasion, we can set the `boss` object from around `1020` to
    `1420`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat this process by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click and create an activation clip on the `radarPoint` track.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale the **Active** bar between the two **Timeline** points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now set the settings so that the `boss` game object and its `radarPoint`
    object are active at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully introduced a timeline to our scene and customized it so
    that it accommodates a new game object that needs to be animated throughout the
    third and final level of our game. In the next section, we are going to look further
    into extending the features of the timeline by introducing animating lights.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the timeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to add more functionality to the timeline by
    increasing its standard track selection, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.44 – Expanding the functionality of our Timeline will be done next'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.44_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.44 – Expanding the functionality of our Timeline will be done next
  prefs: []
  type: TYPE_NORMAL
- en: From this new extended track selection list, as shown in the previous screenshot,
    we will make use of **Light Control Track**.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to see a bigger selection from the drop-down list; this, however,
    is beyond the scope of this book. However, if you are interested, I will direct
    you to what to read to find out how to extend the list later on in this section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will increase our tracklist with the aid of the
    Asset Store and download a free asset from Unity to increase our **Timeline**
    functionality. Then, we will animate the lights in our scene, which wouldn't have
    been possible before.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Default Playables to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take a shortcut in scripting to extend the timeline's
    functionality by going to the Unity Asset Store and downloading a free package
    called **Default Playables**. We will discuss the main features of playables and
    what they entail, but it is too lengthy to discuss it as a scripting approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Playables organize, mix, and blend data through a playable graph to create
    a single output. To download and import **Default Playables** to our list, do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your web browser and go to the Unity Asset Store: [https://assetstore.unity.com/](https://assetstore.unity.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the `default playables` and press *Enter* on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the only selection from the thumbnail list – **Default Playables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Default Playables** shop screen, click on the **Download** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once downloaded, we can now import the asset into our project by clicking on
    the **Add to My Assets** button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.45_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.45 – Downloading and importing the free Default Playables package
    into our project from the Asset Store
  prefs: []
  type: TYPE_NORMAL
- en: '**Default Playables** can now be downloaded from your Unity project via **Package
    Manager**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Manager** gives us access to assets we''ve downloaded from the **Asset
    Store** and also other "packages" we can add to our project. We will talk about
    **Package Manager** more in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To download **Default Playables** into our project, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Unity Editor, click **Window**, followed by **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Package Manager** will load in a new window. At the top-left corner of the
    window, select **Packages:**, followed by **My Assets** from the dropdown, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.46_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.46 – Selecting "My Assets" from the dropdown in the Package Manager
    window
  prefs: []
  type: TYPE_NORMAL
- en: We will now be presented with the assets we own from the Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top-right corner of `default playable` to shorten the list on the left
    side, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.47 – The Package Manager search bar highlighted at the top-right
    corner'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.47_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.47 – The Package Manager search bar highlighted at the top-right corner
  prefs: []
  type: TYPE_NORMAL
- en: Select **Default Playables** at the left side of the window, followed by clicking
    **Download**, and then the **Import** button (at the bottom-right corner of the
    window).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will then be presented with a list of folders and files that will be imported
    into the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Import** button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.48 – The Default Playables files to be imported into the project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.48_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.48 – The Default Playables files to be imported into the project
  prefs: []
  type: TYPE_NORMAL
- en: We now have extra functionality added to our timeline, with an added folder
    in our `Assets` folder called `DefaultPlayables`. Also, as mentioned, to add even
    more functionality (such as timeline tracks) to the timeline, check out the file
    inside the `DefaultPlayables` folder named `DefaultPlayablesDocumentation`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next section, where we will make use of manipulating
    the lights in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating light components in the timeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will continue working on the same timeline and expand it
    to hold more tracks. In the last section, we introduced a free-to-download asset
    from the Asset Store called **Default Playables** to save us from writing code
    from scratch and to offer new playables. This asset gave us the ability to add
    new tracks to our timeline. To continue adding new tracks, we will manipulate
    the lights in our third-level scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a light component to the timeline, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the **Timeline** window is still locked, which we set in the *Preparing
    the boss for the timeline* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click at the bottom-left open-space corner of the **Timeline** window
    and select **Light Control Track**, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.49 – Adding ''Light Control Track'' to the Timeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.49_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.49 – Adding 'Light Control Track' to the Timeline
  prefs: []
  type: TYPE_NORMAL
- en: We now have an empty light component track added to our timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add an **Animation** clip by right-clicking on the timeline''s
    track line and selecting **Add Light Control Clip**, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.50 – Adding control to our lights with the control clip'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.50_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.50 – Adding control to our lights with the control clip
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `LightControlClip` object in our timeline. Click on this clip
    and look at the **Inspector** window. There are a few options here, but we are
    going to focus mainly on **Color**, **Intensity**, and **Range**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These properties will directly change the values of the light that sits in the
    **None (Light)** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set your **Light Control Clip** values to the ones shown in the following screenshot
    in your **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.51 – Copying the values from your ''Light Control Clip'' to the
    ones in this screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.51_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.51 – Copying the values from your 'Light Control Clip' to the ones
    in this screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will set the duration of this clip to `100`. We can do this by either
    changing the value of the `LightControlClip` to the `100` mark, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.52 – Setting the duration of the light control clip to 100'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.52_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.52 – Setting the duration of the light control clip to 100
  prefs: []
  type: TYPE_NORMAL
- en: Because this light is going to flash white and then red, ideally, it would make
    sense to have a loop between the two transitions. However, for the sake of blending
    and filling up the timeline, we are going to do it this way.
  prefs: []
  type: TYPE_NORMAL
- en: Select `LightControlClip` and press *Ctrl* (*command* on the macOS) + *D* 25
    times to spam the track line with light control clips.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the second `LightControlClip` object from the left and change its **Color**
    property from white to red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for clips `4`, `6`, `8`, `10`, `12`, `14`, `16`, `18`, `20`,
    `22`, `24`, and `26`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, zoom into the second `LightControlClip` object and move it 50% of the
    way across to its previous clip to create a blend between the color of the light,
    as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.53 – 1st light clip splicing into the 2nd light clip'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.53_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.53 – 1st light clip splicing into the 2nd light clip
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue moving each clip 50% of the way across to the previous clip''s location
    to make the lights flash white to red until the level finishes. The following
    screenshot shows the position of the third clip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.54 – The 2nd light clip splicing into the 3rd'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.54_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.54 – The 2nd light clip splicing into the 3rd
  prefs: []
  type: TYPE_NORMAL
- en: Once we've merged the clips, we can now duplicate our light track asset so that
    more than one light can flash.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the track asset and press *Ctrl* (*Command* on macOS) + *D* four times.
    The following screenshot uses the ***** symbol to highlight where to click, along
    with the duplicates made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.55 – Duplicating the track asset'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.55_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.55 – Duplicating the track asset
  prefs: []
  type: TYPE_NORMAL
- en: As these are all the same types of tracks, we can put them into a track group
    to keep our timeline tidy.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the open-space area at the bottom left of the timeline and select
    **Track Group** from the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our track group is made. Now, click and hold the top light track asset while
    holding down *Shift*, and click on the bottom light track asset to select all
    of the light track assets. Still holding down the left mouse button, drag these
    track assets into the track group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Lights`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the **+** button to expand and collapse the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the final result of the timeline lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.56 – The track group called ''Lights'' holding all our light track
    assets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.56_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.56 – The track group called 'Lights' holding all our light track assets
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make a track group, follow the same process for the
    `boss` object and its `radarPoint` object, and call the track group `Boss`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step is to drag and drop the five lights that will flash red and white
    into the **Game** window.
  prefs: []
  type: TYPE_NORMAL
- en: Either click on the small, round remote button next to `light00`, `light01`,
    `light02`, `light03`, and `light04` into each parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrub or drag the **Timeline** indicator backward and forward on the timeline
    to see the selected lights flashing red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows our player on the third level with a new set
    of AI enemies, a large boss flying in the background, and flashing lights:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.57 – The midway of level 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.57_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.57 – The midway of level 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now would be a good time to apply the pause screen, if you haven''t already
    done so, to all three scenes. Follow these instructions if you don''t feel comfortable
    doing this on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `level3` scene saved, load up `level1` from the `Assets/Scene` folder
    from the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Canvas` and `EventSystem` game objects, and then press *C* to copy them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the `level3` scene back up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Canvas` game object from the **Hierarchy** window and press *Delete*
    on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* (*Command* on macOS) + *V* to paste `EventSystem` and `Canvas`
    from the level that contains the pause screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand `Canvas` and then the `LevelTitle` game object in the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Level` game object, and change the `level 1` to `level` `3` in the
    **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process for `level2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows `level3` paused:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.58 – The pause screen working for level 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.58_B18381.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.58 – The pause screen working for level 3
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to summarizing what we have covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced a new concept to our game to make it more interesting
    than just taking place in space. Our camera and player needed to be slightly tweaked
    for the final level to support side-scrolling, instead of them being static in
    one screen, as is the case on the previous two levels. We also introduced a second
    enemy that can move around the floor, dodging other enemies in a panic-like state.
    The fleeing enemy used the navigation system that comes with Unity as standard,
    and we gave the enemy a floor to run around on. Lastly, we introduced the **Timeline**
    feature, which is related to the original animation system we used in [*Chapter
    4*](B18381_04_Epub.xhtml#_idTextAnchor087)*, Applying Art, Animation, and Particles*.
    We also discovered how **Timeline** lets any game object or component be animated
    in it without needing some form of hierarchical link between the game objects.
    Also, we extended the timeline to cover other components, such as lights, which
    we can't animate alone with the **Timeline** feature.
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaways from this chapter are the introduction of AI with a navigation
    system that can also be used for other behaviors in other games and the introduction
    of the timeline and its use to encourage creativity in projects, such as cutscenes,
    films, and animated TV sequences.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at polishing the visuals of our game, and
    we will see what tools can help us in optimizing performance and testing for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Before you move on to the next chapter, try out the following mock test, as
    this is the last mini-mock test in this book before the big one.
  prefs: []
  type: TYPE_NORMAL
- en: Mock test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are developing a game where your player is inside an office with other staff
    workers around them. When your player walks to a particular point, a trigger event
    is called to move the staff into another room with the use of **Playable Director**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You notice that when the game is paused and then un-paused, the audio and animation
    are out of sync with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Which property in the **Playable Director** component will likely fix this issue?
  prefs: []
  type: TYPE_NORMAL
- en: Set the wrap mode to **Hold**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the update method to **DSP**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Initial Time** to the current time (the time when the game is paused).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the update method to **Unscaled Game Time**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a set of playables linked within our playable graph. We need to remove
    one of these playables and its inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which **PlayerGraph** function should we use?
  prefs: []
  type: TYPE_NORMAL
- en: '`DestroyOutput`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DestroyPlayable`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DestroySubgraph`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Destroy`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have developed an eight-ball pool game. One of the testers has come back
    to you, saying that the frame rate of the game drops too low when one of the players
    breaks the balls up at the start of a game. All of the balls have rigid body sphere
    colliders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we improve the drop in the frame rate?
  prefs: []
  type: TYPE_NORMAL
- en: Use a less expensive shader on the objects that are colliding with one another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the maximum allowed timestep to a range of 8–10 fps to account for this
    worst-case scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the rigid bodies so that they are kinematic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use box and capsule colliders instead of sphere colliders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `NavMesh` modifier do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier determines what stage of the build process the NavMesh
    is baked at.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier describes the AI of each agent in the scene.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier allows NavMesh baking to occur outside the main thread
    so that it can be dynamically baked at runtime.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A `NavMesh` modifier adjusts how a game object behaves during NavMesh baking
    and can, for example, only affect certain agents.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why does it help to only have the necessary boxes checked in the layer collision
    matrix?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unchecking boxes will hide layers so that they're not rendered.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking boxes will indicate which collisions can be ignored.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking boxes will show which layers are colliding in the frame debugger.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unchecking boxes will reduce the number of layer collisions the physics system
    needs to check.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When we create a `Timeline` asset for a game object, what component is created
    and added to our game object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableBinding`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableDirector`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableOutput`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PlayableGraph`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In your first-person shooter, which you are testing, you notice that when the
    alarm is sounded, the enemy guards come running toward the player. When you observe
    the enemy guards advancing, you close the door on them but notice that their arms
    and heads are coming through the door that you have closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What setting do you need to increase to stop these arms and heads coming through
    objects that they shouldn't?
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Height**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Max Slope**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Agent Height**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Agent Radius**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have got yourself involved in a classic Save the Mayor rescue game. Your
    player is a trained vigilante trying to eliminate potential attackers to harm
    the city's mayor. One of the attackers gets too close, and you take a shot to
    warn them off. The attacker runs away but returns shortly after, crawling toward
    the mayor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `NavMesh` agent property can simulate this cautious behavior?
  prefs: []
  type: TYPE_NORMAL
- en: '**Area Mask**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auto Braking**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Stopping Distance**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Priority**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations – Save the Mayor was a massive success, and you have been asked
    to start development straight away on Save the Mayor 2! Your vigilante is back,
    and this time, he can jump *and* run and jump across building rooftops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yet again, you have applied the `NavMesh` agent so that your vigilante can run
    and jump across buildings in a linear path. You have correctly hooked all your
    animation controls up but have noticed that your vigilante isn't animating when
    it comes to jumping between building rooftops.
  prefs: []
  type: TYPE_NORMAL
- en: What setting or property do we need to change to solve this issue?
  prefs: []
  type: TYPE_NORMAL
- en: Uncheck `NavMesh` agent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the `NavMesh` agent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **Height Mesh** property in the **Bake** settings under **Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the jump distance in the **Bake** settings under **Navigation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are working on a third-person game, and our character is using a finite state
    machine to react to their states. We currently have it set so that if we get too
    close to a particular character, they will attempt to run and hug us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What finite state machine component is the programmer working on?
  prefs: []
  type: TYPE_NORMAL
- en: '**Actions**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transitions**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Events**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Rules**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these tracks can the timeline not add without applying additional coding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Activation Track**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Animation Track**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Light Control Track**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Playable Track**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: One of the 3D artists has supplied you with a series of three-dimensional models
    to be applied to one of the start up scenes for the project you are currently
    developing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When importing the models into the scene, you notice that all the models have
    sharp edges. You have asked the artist to make the models smoother.
  prefs: []
  type: TYPE_NORMAL
- en: Is there anything else that can be done on the developer side to possibly fix
    these sharp three-dimensional model edges?
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the normals to a particular smoothing angle value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the files through Unity instead of dragging and dropping the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply materials to each three-dimensional model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure there is lighting in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `LateUpdate` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replaces the standard `Update` function when frames are overloaded.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LateUpdate` takes fewer resources to run, which makes it ideal for mobile
    platforms.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An update is only called once on every frame. `LateUpdate` is called every three
    frames.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LateUpdate` is the last item in the execution order before rendering.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using `GameObject.Find` (if any)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There aren't any; it's slow and demanding.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If not called on every frame, it makes coding useful for referencing.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameObject.Find` is deprecated.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameObject.Find` searches through library asset data outside of the Unity
    project.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Do we have to import the `UnityEngine` library and `MonoBehaviour` with every
    script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, as long as they are not applied to a game object.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, or the Unity engine rejects the script.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, as they act as a header to all scripts.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only `MonoBehaviour` must be inherited in all cases.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: When moving from one scene to another, you notice that the second scene is much
    darker, even though it uses the same art and lighting as the scene before it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we make the lighting act how it should in the scene?
  prefs: []
  type: TYPE_NORMAL
- en: Make sure all the lights are turned off before being turned on in the second
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep all the lights on from the first scene when moving into the second scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Duplicate the lights from the previous scene over to the new one when loaded
    up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off **Auto Generate** in the lighting settings and manually generate the
    lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of `Debug.Log()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is useful if developers want to know the value of a variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It sends string values to each variable.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: There aren't any; it's deprecated, so we don't use it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It logs information into Unity's database.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the Audio Mixer useful to developers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, it's specifically built for audio users; developers use an AudioSource.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, as it can be used to hold all the sounds in one central point.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Only if the developer is skilled in handling audio alone.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, it helps the performance of the audio.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do some developers prefer JSON over PlayerPrefs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PlayerPrefs was released before JSON, which gives it a bigger following.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JSON can be used with more data types and is a more compatible API.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Both are good; it's just a matter of personal preference.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JSON is owned by Unity, so it incorporates a lot of features.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we use a trigger box instead of a collider?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Triggers and colliders carry out the same task.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Triggers have more functionality and cost less to run than colliders.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A trigger can call code when another collider/trigger enters it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Triggers have different colored boxes.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
