["```cs\n    [Fact]\n    public void\n      ViewModel_Initialized_PropertiesSetCorrectly()\n    {\n    }\n    ```", "```cs\n    //Arrange\n    string id = \"id1\";\n    string title = \"title1\";\n    bool isFavorite = false;\n    string image = \"image1\";\n    //Act\n    var sut = new RecipeListItemViewModel(id, title,\n        isFavorite, image);\n    //Assert\n    Assert.Equal(id, sut.Id);\n    Assert.Equal(title, sut.Title);\n    Assert.Equal(isFavorite, sut.IsFavorite);\n    Assert.Equal(image, sut.Image);\n    ```", "```cs\n    [Fact]\n    public void\n      VM_Initialized_SubscribedToFavoriteUpdateMessage()\n    {\n        //Arrange, Act\n        var sut = new RecipeListItemViewModel(\n            \"id\", \"title\", true, \"image\");\n        //Assert\n        Assert.True(WeakReferenceMessenger.Default\n            .IsRegistered<FavoriteUpdateMessage>(sut));\n    }\n    ```", "```cs\n    [Fact]\n    public void\n      FavoriteUpdateMsgReceived_SameId_FavoriteUpdated()\n    {\n        //Arrange\n        var id = \"id\";\n        var originalValue = false;\n        var updateToValue= !originalValue;\n        var sut = new RecipeListItemViewModel(\n            \"someid\", \"title\", originalValue, \"image\");\n        //Act\n        WeakReferenceMessenger.Default.Send(\n            new FavoriteUpdateMessage(\n                id, updatedFavorite));\n        //Assert\n        Assert.Equal(updatedFavorite, sut.IsFavorite);\n    }\n    ```", "```cs\n    [Fact]\n    public void FavoriteUpdateMsgReceived_DifferentId\n      _FavoriteNotUpdated()\n    {\n        //Arrange\n        var originalValue = false;\n        var updateToValue= !originalValue;\n        var sut = new RecipeListItemViewModel(\n            \"someid\", \"title\", originalValue, \"image\");\n        //Act\n        WeakReferenceMessenger.Default.Send(\n            new FavoriteUpdateMessage(\n                \"otherid\", updatedFavorite));\n        //Assert\n        Assert.Equal(originalValue, sut.IsFavorite);\n    }\n    ```", "```cs\n    public void\n      ViewModel_Initialized_PropertiesSetCorrectly(\n        string id, string title, bool isFavorite,\n    Arrange phase and use the provided parameters directly to instantiate our ViewModel:\n\n    ```", "```cs\n\n    ```", "```cs\n    [Theory]\n    [InlineData(\"id1\", \"title1\", false, \"image1\")]\n    [InlineData(\"id2\", \"title2\", true, \"image2\")]\n    [InlineData(\"foo\", \"bar\", true, null)]\n    [InlineData(null, null, false, null)]\n    ```", "```cs\n[Theory]\n[InlineData(true, false)]\n[InlineData(false, true)]\n[InlineData(true, true)]\n[InlineData(false, false)]\npublic void\n    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(\n    bool originalValue, bool updateToValue)\n{\n    //Arrange\n    var id = \"id\";\n    var sut = new RecipeListItemViewModel(\n        id, \"title\", originalValue, \"image\");\n    //Act\n    WeakReferenceMessenger.Default.Send(\n        new FavoriteUpdateMessage(id, updateToValue));\n    //Assert\n    Assert.Equal(updateToValue, sut.IsFavorite);\n}\n```", "```cs\n[Theory]\n[InlineData(true, false)]\n[InlineData(false, true)]\n[InlineData(true, true)]\n[InlineData(false, false)]\npublic void FavoriteUpdateMsgReceived_\n  DifferentId_FavoriteNotUpdated(\nbool originalValue, bool updateToValue)\n{\n    //Arrange\n    var sut = new RecipeListItemViewModel(\n        \"someid\", \"title\", originalValue, \"image\");\n    //Act\n    WeakReferenceMessenger.Default.Send(\n        new FavoriteUpdateMessage(\n        \"otherid\", updateToValue));\n    //Assert\n    Assert.Equal(originalValue, sut.IsFavorite);\n}\n```", "```cs\n    const int MinValueStart = 5;\n    const int MinValueEnd = 10;\n    const int MaxValueStart = 11;\n    const int MaxValueEnd = 15;\n    readonly EmptyOrWithinRangeAttribute sut;\n    ```", "```cs\n    sut = new Faker<EmptyOrWithinRangeAttribute>()\n        .RuleFor(r => r.MinLength, f =>\n            f.Random.Int(MinValueStart, MinValueEnd))\n        .RuleFor(r => r.MaxLength, f =>\n            f.Random.Int(MaxValueStart, MaxValueEnd))\n        .Generate();\n    ```", "```cs\n    [Fact]\n    public void Value_WithinRange_IsValid()\n    {\n        //Arrange\n        var input = new Faker().Random.String2(\n            sut.MinLength, sut.MaxLength);\n        //Act\n        var isValid = sut.IsValid(input);\n        //Assert\n        Assert.True(isValid);\n    }\n    ```", "```cs\n    [Fact]\n    public void Value_TooShort_IsNotValid()\n    {\n        //Arrange\n        var input = new Faker().Random.String2(\n            1, MinValueStart - 1);\n        //Act\n        var isValid = sut.IsValid(input);\n        //Assert\n        Assert.False(isValid);\n    }\n    ```", "```cs\n    [Fact]\n    public void Value_Empty_IsValid()\n    {\n        //Arrange\n        var input = string.Empty;\n        //Act\n        var isValid = sut.IsValid(input);\n        //Assert\n        Assert.True(isValid);\n    }\n    ```", "```cs\n//Arrange, Act\nvar sut = AutoFaker.Generate<RecipeListItemViewModel>();\n//Assert\nAssert.True(WeakReferenceMessenger.Default\n    .IsRegistered<FavoriteUpdateMessage>(sut));\n```", "```cs\npublic void\n    FavoriteUpdateMsgReceived_SameId_FavoriteUpdated(\n    bool originalValue, bool updateToValue)\n{\n    //Arrange\n    var id = AutoFaker.Generate<string>();\n    var sut = new RecipeListItemViewModel(id,\n        AutoFaker.Generate<string>(),\n        originalValue,\n        AutoFaker.Generate<string>());\n    //Act\n    WeakReferenceMessenger.Default.Send(new\n        FavoriteUpdateMessage(id, updateToValue));\n    //Assert\n    Assert.Equal(updateToValue, sut.IsFavorite);\n}\n```", "```cs\npublic RecipeDetailViewModel(\n    IRecipeService recipeService,\n    IFavoritesService favoritesService,\n    IRatingsService ratingsService,\n    INavigationService navigationService,\n    IDialogService dialogService)\n{\n...\n}\n```", "```cs\nvar recipeServiceMock = new Mock<IRecipeService>();\n```", "```cs\nvar sut = new RecipeDetailViewModel\n  (recipeServiceMock with fake method implementations. We can configure our mock object with specific method behaviors. Consider the LoadRecipe method of IRecipeService:\n\n```", "```cs\n\n Here’s how to instruct Moq to mimic this method:\n\n```", "```cs\n\n With the `Setup` method, we can tell Moq which method we want to simulate. In our example, we’re targeting the `LoadRecipe` method. `It.IsAny<string>` is a matcher, which signifies that we’re indifferent to the exact value passed into the method. In simpler terms, any string value will trigger the behavior we’re defining here. Speaking of which, `ReturnsAsync` specifies the result our mock method should produce. For example, we’re returning a successful result containing dummy `RecipeDetail` data. In essence, this code configures `recipeServiceMock` to always produce a specific result for any call to `LoadRecipe`, ensuring our tests are predictable and not reliant on real implementations. Let’s see how we can add a set of new tests.\nApplying mocking in our ViewModel tests\nTo start testing `RecipeDetailViewModel`, let’s add a new class named `RecipeDetailViewModelTests` to the test project and follow these steps:\n\n1.  Add the following fields to the `RecipeDetailViewModelTests` class:\n\n    ```", "```cs\n\n     2.  Instantiate these fields in the class’s constructor, as shown here:\n\n    ```", "```cs\n\n    In this previous code block, we’re instantiating all of our mock classes and using them to instantiate the `sut` object. By putting this in the constructor, we don’t have to repeat this code in every unit test. We can even already provide some default mock implementations, as shown with `_ratingServiceMock`. If, for a specific test, we need a different behavior for `_ratingServiceMock`, we can easily override the default behavior set in the constructor in the test itself. When we specify a new behavior in the test method, Moq will use the most recent setup, ensuring flexibility in our tests.\n\n     3.  In the first test, we want to validate that the parameter that is being used to navigate to the detail page, is effectively being passed to the injected `IRecipeService`’s `LoadRecipe` method to retrieve the detail information. Start by adding the following method to this class:\n\n    ```", "```cs\n\n     4.  Let’s have a look at this test’s `Arrange` step:\n\n    ```", "```cs\n\n    In the `Arrange` step, we’re generating a `recipeId` using `AutoFaker`. This value is put in a Dictionary named parameters which we’ll use in the next step. We’re also configuring the behavior of the `_recipeServiceMock`’s `LoadRecipe` method. As we’re not interested in what exactly is being returned in this test, we’ll leave it to `AutoFaker` to generate a `RecipeDetail` instance.\n\n     5.  Add the following code below the `Arrange` steps:\n\n    ```", "```cs\n\n    By calling the ViewModel’s `OnNavigatedTo` method and passing a dictionary, we can mimic navigating to the ViewModel. This should trigger the load of the recipe’s detail information, using the passed-in `\"id\"` item from the dictionary.\n\n     6.  Validating whether the `LoadRecipe` method of the injected `IRecipeService` is correctly called can be achieved like this:\n\n    ```", "```cs\n\n    The `Verify` method on a `Mock` object allows us to check whether a specific method was invoked or not. Note that we’re explicitly specifying that the `LoadRecipe` should have been called with the `recipeId` parameter. Also, with `Times.Once` we define that the method, with the given parameter, should have been called exactly once. If that isn’t the case, an exception will be thrown that will fail the test.\n\nThis powerful feature of Moq ensures that certain interactions (method calls) take place as expected. But by using Moq, we can also make our tests predictable, allowing us to check for particular output values. The following test shows how we can validate whether the data returned by the `IRecipeService`’s `LoadRecipe` method is correctly mapped on to the ViewModel:\n\n```", "```cs\n\n A generated `recipeDetail` is what the `_recipeServiceMock`’s `LoadRecipe` method returns. After navigating to the ViewModel, we can check whether the properties match the value of the returned `recipeDetail` variable, assuring us the values are correctly mapped.\nThin UI, deep tests\nOne of the pinnacle benefits of the MVVM pattern, especially when coupled with DI, is the depth of our unit testing capability. Let’s look at an example that demonstrates this. Traditionally, interactions such as dialog prompts or navigation might be considered to be UI testing. But here, we’ll see how we can validate these interactions through simple unit tests. The `IDialogService` and `INavigationService`, while seeming intrinsically linked to UI, are injected as platform-independent dependencies. This abstraction ensures that our tests remain agnostic to the final UI layer, whether it’s a mobile app, a web interface, or desktop software. As a result, the UI layer remains incredibly thin, and our confidence in the bulk of our application logic – verified through these tests — remains high. Let’s dive into an example: when the `RecipeDetailViewModel` is unable to load the recipe detail, a prompt should be shown asking the user to retry. If the user selects **No**, the app should automatically navigate back to the previous page. Here’s what this test looks like:\n\n```", "```cs\n\n In the previous code block, we’re configuring `_recipeServiceMock` so that it returns a `Fail` result every time the `LoadRecipe` method is called. `_dialogServiceMock` is configured so that when the `AskYesNo` method is invoked, a `false` value is returned. This mimics the user selecting `No` in the presented dialog. With all this in place, we can check that the dialog is being shown and that back navigation is triggered as a result of the user selecting `No` in the retry dialog.\nThis demonstrates how, with the right architecture and tools, even intricate interactions that touch upon UI elements can be captured, controlled, and tested – all without direct dependency on platform-specific components. This platform-independent unit testing not only ensures that our application remains both maintainable and reliable but also hardens its adaptability across various platforms. It underscores the power of the MVVM pattern!\nHowever, there is still some code to be tested that is platform-specific. Let’s have a look at that before we end this chapter.\nTesting MAUI-specific code\nAs shown in the previous examples, the majority of our code can be tested independently of the platform. But let’s not forget that there is code in our MAUI project as well that could benefit from some unit tests.\nLet’s start by adding a new project to hold our tests for the `Recipes.Mobile` project:\n\n1.  Add a new `Recipes.Mobile.UnitTests`.\n2.  Once the project has been created, add a reference to the `Recipes.Mobile` project.\n3.  Add the **AutoBogus** NuGet package to this project.\n\nThe `Recipes.Mobile.UnitTests` project doesn’t target any specific frameworks other than `net8.0`. Because of that, we need to make sure `net8.0` is on the list of target frameworks of the MAUI project as well. Also, we need to make sure that when the `Recipes.Mobile` project targets this additional `net8.0` framework, it doesn’t output an EXE file. Let’s see how to properly configure this:\n\n1.  Open the `Recipes.Mobile.csproj` file by clicking on the project name in the **Solution Explorer** in **Visual Studio** or by right-clicking the project and selecting **Edit** **Project File**.\n2.  Add `net8.0` to the `TargetFrameworks` tag, as shown here:\n\n    ```", "```cs\n\n     3.  Find the `OutputType` tag in the `.csproj` file and update the following:\n\n    ```", "```cs\n\nOnce the `Recipes.Mobile` project is configured, we also need to add one thing to the `Recipes.Mobile.UnitTests` project. In its `.csproj` file, find the first `PropertyGroup` tag and add the following: `<UseMaui>true</UseMaui>`.\nWith all of this in place, writing tests for functionality in the `Recipes.Mobile` project isn’t any different from the tests we’ve written so far. Let’s have a look at how to test the `RatingToStarsConverter` class:\n\n1.  Start by creating a new class called `RatingToStarsConverterTests`.\n2.  This converter makes for a good data-driven test. We can specify the input and expected output through method parameters, as shown in the following code block:\n\n    ```", "```cs\n\n    The passed-in input value is the value we want our converter to convert. The result is compared to the converted value by using `Assert.Equal`.\n\n     3.  Add the `Theory` attribute and the following `InlineData` attributes for different – edge-case – scenarios to this method:\n\n    ```", "```cs\n\nThis test method successfully validates if the `RatingToStarsConverter` converts a given value to a string representing star-icons. Not only are happy paths tested, but also the expected behavior when passing in invalid data.\nOne other thing we can test is the `InstructionsDataTemplateSelector` class. The following steps show you how this can be done:\n\n1.  Add a new class `InstructionsDataTemplateSelectorTests` to the `Recipes.Mobile.UnitTests` project.\n2.  Here’s what a test for this `TemplateSelector` could look like:\n\n    ```", "```cs\n\n    In this test, we’re creating a template that gets assigned to the `NoteTemplate` property of the sut. The `SelectTemplate` method of the sut gets invoked, passing in a generated `NoteViewModel`. We expect the returned `DataTemplate` to be the one we created and assigned to the `NoteTemplate` property.\n\nWith simple tests like these, we can easily validate the behavior of a `TemplateSelector` without deploying and running our app once! Testing if the `InstructionsDataTemplateSelector` works as expected for an `InstructionViewModel` or an unsupported ViewModel, should be pretty straightforward.\nSummary\nIn this chapter, we delved into unit testing within the MAUI framework, specifically focusing on testing ViewModels and some MAUI components. It’s worth noting that while we focused on these areas, the tools and techniques discussed are equally effective for testing services, repositories, and other integral parts of your application. Beyond just validating the code’s functionality, unit testing acts as a safety net, ensuring maintainability and robustness by reducing the chances of regression bugs. This powerful approach empowers us to iterate faster, removing the constant need for cumbersome deployments or manual checks. Leveraging mock implementations, we can seamlessly mimic and validate countless scenarios, and this validation remains ingrained in our code base. As we add or modify features, this ensures every intricate use case remains covered. A key takeaway is the significant portion of our app that can be tested independently of platform-specific details. This not only enhances adaptability but solidifies the effectiveness of the MVVM pattern. In conclusion, unit testing in MAUI isn’t just a checkbox; it’s a foundational element that drives us to build robust applications with agility and confidence. In the next and final chapter of this book, we’ll be looking at some troubleshooting and debugging tips that might come in handy when building an MVVM app with .NET MAUI.\nFurther reading\nTo learn more about the topics that were covered in this chapter, take a look at the following resources:\n\n*   xUnit: [https://xunit.net/](https://xunit.net/)\n*   Bogus for .NET: [https://github.com/bchavez/Bogus](https://github.com/bchavez/Bogus)\n*   AutoBogus: [https://github.com/nickdodd79/AutoBogus](https://github.com/nickdodd79/AutoBogus)\n*   Moq: [https://github.com/devlooped/moq](https://github.com/devlooped/moq)\n*   *Unit testing C# in .NET Core using dotnet test and* *xUnit*: [https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test](https://learn.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test)\n\n```"]