- en: Implementing Power-Ups with the Visitor Pattern
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问者模式实现升级
- en: In this chapter, we are going to implement a power-up mechanic for our game.
    Power-ups have been a core ingredient of video games since their early inception.
    One of the first games that implemented power-ups is *Pac-Man* from 1980\. In
    the game, you could eat Power Pellets that would give Pac-Man temporary invincibility.
    Another classic example is the mushrooms in *Mario Bros.*, which made Mario taller
    and more robust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为我们的游戏实现一个升级机制。自游戏早期开始，升级一直是视频游戏的核心成分之一。第一个实现升级的游戏之一是1980年的*吃豆人*。在游戏中，你可以吃掉能量豆，使Pac-Man获得暂时的无敌状态。另一个经典例子是*马里奥兄弟*中的蘑菇，它使马里奥变得更高大更强壮。
- en: The power-up ingredients that we will build will be similar to the classics
    but with a little more granularity. Instead of having a power-up boost a singular
    ability of an entity, we can create combos that give out multiple benefits at
    once. For instance, we could have a power-up named "**Protector**"that adds durability
    to the front-facing shield and increments the strength of the primary weapon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的升级成分将与经典类似，但具有更多的粒度。我们不仅可以使一个实体的单一能力得到升级，还可以创建组合，一次提供多个好处。例如，我们可以有一个名为“**保护者**”的升级，它增加了面向前方的护盾的耐久性，并增加了主要武器的强度。
- en: And so, in this chapter, we are going to implement a power-up mechanic that's
    scalable and configurable, not just for us programmers but also for designers
    that might be assigned the responsibility of creating and adjusting unique power-up
    ingredients. We will achieve this using a combination of the Visitor pattern and
    a unique Unity API feature named ScriptableObjects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将实现一个可扩展和可配置的升级机制，不仅对我们程序员来说如此，而且对于可能被分配创建和调整独特升级成分的设计师来说也是如此。我们将通过结合访问者模式和独特的Unity
    API功能ScriptableObjects来实现这一点。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic principles behind the Visitor pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者模式背后的基本原理
- en: The implementation of a power-up mechanic for a racing game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为赛车游戏实现一个升级机制
- en: This section includes simplified code examples for the sake of simplicity and
    readability. If you wish to review a complete implementation in the context of
    an actual game project, open the `FPP` folder in the GitHub project, the link
    for which can be found under the *Technical requirements* section.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码示例并提高可读性，本节包含了一些简化的代码示例。如果你希望在真实游戏项目的上下文中查看完整的实现，请打开GitHub项目中的`FPP`文件夹，该链接可以在*技术要求*部分找到。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter is hands-on. You will need to have a basic understanding of Unity
    and C#. We will be using the following Unity engine and C# language concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是实践性的。你需要对Unity和C#有一个基本的了解。我们将使用以下Unity引擎和C#语言概念：
- en: Interfaces
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: ScriptableObjects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScriptableObjects
- en: If you are unfamiliar with these concepts, please review them before starting
    this chapter. The code files for this chapter can be found on [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)[.](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请在开始本章之前复习它们。本章的代码文件可以在[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)找到[.](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter10)
- en: Check out the following video to see the code in action: [https://bit.ly/3eeknGC](https://bit.ly/3eeknGC)[.](https://bit.ly/3eeknGC)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[https://bit.ly/3eeknGC](https://bit.ly/3eeknGC)[.](https://bit.ly/3eeknGC)
- en: We often use ScriptableObjects in the code examples of this book because when
    building game systems and mechanics, it is essential to make them easily configurable
    by non-programmers. The process of balancing systems and authoring new ingredients
    usually falls under the responsibility of game and level designers. Therefore,
    we use ScriptableObjects because it offers a consistent way of establishing an
    authoring pipeline to create and configure in-game assets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的代码示例中经常使用ScriptableObjects，因为在构建游戏系统和机制时，使非程序员能够轻松配置它们是至关重要的。平衡系统和编写新成分的过程通常属于游戏和关卡设计师的责任。因此，我们使用ScriptableObjects，因为它提供了一种一致的方式来建立创作管道，以创建和配置游戏中的资产。
- en: Understanding the Visitor pattern
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解访问者模式
- en: The primary purpose of the Visitor pattern is simple once you grasp it; a *Visitable* object
    permits a *Visitor* to operate on a specific element of its structure. This process
    allows the visited object to acquire new functionality from visitors without being
    directly modified. This description might seem very abstract at first, but it
    is easier to visualize if we imagine an object as a structure instead of a closed-off
    container of data and logic. Therefore, it is possible with the Visitor pattern
    to traverse an object's structure, operate on its elements, and extend its functionality
    without modifying it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了它，访问者模式的初衷就很简单；一个*可访问*对象允许一个*访问者*对其结构中的特定元素进行操作。这个过程允许被访问的对象从访问者那里获得新的功能，而无需直接修改。这种描述一开始可能看起来非常抽象，但如果我们将对象想象成一个结构而不是一个封闭的数据和逻辑容器，它就更容易可视化。因此，使用访问者模式，我们可以遍历对象的结构，对其元素进行操作，并扩展其功能，而无需修改它。
- en: Another way to imagine the Visitor pattern in action is by visualizing the bike
    in our game colliding with a power-up. Like an electronic current, the power-up
    flows through the inner structure of the vehicle. Components marked as visitable
    get visited by the power-up, and new functionalities are added, but nothing is
    modified.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种想象访问者模式在游戏中发挥作用的方法是想象我们的游戏中的自行车与一个能量提升器相撞。就像电子电流一样，能量提升器流经车辆的内部结构。标记为可访问的组件会被能量提升器访问，并添加新的功能，但没有任何修改。
- en: 'In the following diagram, we can visualize those principles:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以可视化这些原则：
- en: '![](img/84326d4d-0653-464b-9d6c-eb5f5d361c0f.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/84326d4d-0653-464b-9d6c-eb5f5d361c0f.png)'
- en: Figure 10.1 - UML diagram of the Visitor pattern
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 访问者模式的UML图
- en: 'There are two key participants in this pattern that we need to know well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们需要熟悉两个关键参与者：
- en: '**IVisitor** is the interface that a class that wishes to be a visitor must
    implement. The visitor class will have to implement a visitor method per visitable
    element.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IVisitor**是希望成为访问者的类必须实现的接口。访问者类将必须为每个可访问元素实现一个访问者方法。'
- en: '**IVisitable** is the interface that classes that wish to become visitable
    must implement. It includes an `accept()` method that offers an entry point to
    a visitor object to come and visit.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IVisitable**是希望成为可访问的类必须实现的接口。它包括一个`accept()`方法，为访问者对象提供一个入口点来访问。'
- en: Before proceeding, it is essential to declare that the code example that we
    will review in the upcoming sections breaks a potential rule of the Visitor pattern.
    In the example, the visitor object changes some of the properties of the visited
    objects. However, whether this transgresses the integrity of the pattern and invalidates
    its original design intention is open to debate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们必须声明，我们将在接下来的部分中审查的代码示例违反了访问者模式的一个潜在规则。在这个例子中，访问者对象更改了一些被访问对象的属性。然而，这种违规是否破坏了模式的完整性并使其原始设计意图无效，是一个值得讨论的问题。
- en: Nevertheless, in this chapter, we focus more on how the Visitor pattern permits
    us to traverse the elements that compose the structure of visitable objects. In
    our use case, this structure represents the core elements of our bike, which include
    the engine, shield, and primary weapon.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在本章中，我们更关注访问者模式如何使我们能够遍历组成可访问对象结构的元素。在我们的用例中，这个结构代表了我们自行车的核心元素，包括引擎、护盾和主要武器。
- en: The Visitor is considered by some to be one of the hardest patterns to understand.
    So don't feel bad if you don't grasp its core concepts at first. I believe one
    reason it's a difficult pattern to learn is that it's one of the hardest patterns
    to explain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者被认为是最难理解的模式之一。所以如果你一开始没有掌握其核心概念，请不要感到难过。我相信它之所以难以学习，是因为它是最难解释的模式之一。
- en: Benefits and drawbacks of the Visitor pattern
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的优缺点
- en: I've written a short list of the benefits and drawbacks of using this pattern.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经列出了一份使用此模式的好处和缺点的简短列表。
- en: 'The following are the benefits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些益处：
- en: '**Open/Closed**: You can add new behaviors that can work with objects of different
    classes without modifying them directly. This approach follows the object-oriented
    programming principle of Open/Closed that states that entities should be open
    for extension but closed for modification.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放/封闭**：你可以添加新的行为，这些行为可以与不同类的对象一起工作，而无需直接修改它们。这种方法遵循面向对象编程原则中的开放/封闭原则，即实体应该对扩展开放，但对修改封闭。'
- en: '** Single Responsibility**: The Visitor pattern can adhere to the single responsibility
    principle in the sense you can have an object (visitable) that holds the data
    and another object (visitor) is responsible for introducing specific behaviors.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：访问者模式可以在某种意义上遵守单一职责原则，即你可以有一个对象（可访问者）来存储数据，另一个对象（访问者）负责引入特定的行为。'
- en: 'The following are some of the potential drawbacks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些潜在的缺点：
- en: '**Accessibility**: Visitors could lack the necessary access to specific private
    fields and methods of the elements that they are visiting. Therefore, we might
    need to expose more public properties in our classes than we usually would if
    we didn''t use the pattern.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可访问性**：访问者可能缺乏访问它们访问的特定元素的私有字段和方法所需的必要权限。因此，如果我们不使用该模式，我们可能需要在我们的类中暴露比通常更多的公共属性。'
- en: '**Complexity**: We could argue that the Visitor pattern is structurally more
    complex than straightforward patterns such as the Singleton, State, and Object
    Pool. Therefore, it could bring a degree of complexity to your code base that
    other programmers might find confusing if they are not familiar with the structure
    and intricacies of the pattern.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：我们可以争论，访问者模式在结构上比像单例、状态和对象池这样的直接模式更复杂。因此，它可能会给代码库带来其他程序员可能觉得令人困惑的复杂性，如果他们不熟悉该模式的结构和复杂性。'
- en: The Visitor uses a software engineering concept in its fundamental design named **Double
    Dispatch**. The simplest definition of the concept is that it's a mechanism that
    relegates a method call to different concrete methods depending on the types of
    two objects implicated in the call at runtime. *It's not essential to comprehend
    this concept completely to follow the example of the pattern presented in this
    chapter.*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者使用了一种名为**双重分派**的软件工程概念来设计其基本架构。这个概念最简单的定义是，它是一种机制，根据运行时调用中涉及的两个对象类型将方法调用委托给不同的具体方法。*完全理解这个概念并不是理解本章中展示的模式的示例所必需的。*
- en: Designing a power-up mechanic
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计增强效果机制
- en: 'As mentioned at the beginning of this chapter, the power-up is a staple of
    video games. And it''s a core ingredient of our game. But first, we will review
    some of the key specifications of our mechanic:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，增强效果是视频游戏的一个基本元素。它是我们游戏的核心成分。但首先，我们将回顾我们机制的一些关键规范：
- en: '**Granularity**: Our power-up entities will have the ability to boost multiple
    properties at the same time. For example, we could have a power-up that increases
    offensive capabilities such as the primary weapon''s range while repairing the
    front-facing shield.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒度**：我们的增强实体将能够同时增强多个属性。例如，我们可能有一个增强效果，它增加攻击能力，如主要武器的射程，同时修复前向护盾。'
- en: '**Time**: The power-up effects are not temporal so they don''t expire after
    a certain amount of time. And the benefits of the next power-up are added on top
    of the previous one until they hit the maximum settings of the boosted properties.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间**：增强效果不是时间相关的，因此它们不会在一段时间后过期。下一个增强效果的益处会叠加到前一个效果之上，直到达到增强属性的极限设置。'
- en: Take note that these specifications are limited to the following code example,
    but are not final. We could easily make the benefits of a power-up temporary or
    change the overall design of the mechanic with slight changes to the code example
    presented in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些规范仅限于以下代码示例，但并非最终版本。我们可以轻松地将增强效果的益处设置为临时性的，或者通过修改下一节中展示的代码示例的微小变化来改变整个机制的整体设计。
- en: Our level designers will position the power-ups in strategic points across the
    race track; they will have 3D shapes that are easy to spot at high speed. The
    player will have to collide with a power-up to activate the abilities and benefits
    it contains.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的水平设计师将在赛道上的战略点上定位增强效果；它们将具有在高速下易于识别的3D形状。玩家必须与增强效果发生碰撞以激活其包含的能力和益处。
- en: We will use a combination of the Visitor pattern and ScriptableObjects to implement
    this game mechanic so designers can author new variations of power-ups without
    needing to write a single line of code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结合使用访问者模式和 ScriptableObjects 来实现这个游戏机制，以便设计师可以编写新的提升变体，而无需编写任何代码。
- en: In video games, the core difference between an item and a power-up is that a
    player can collect items, store them, and choose when to use their benefits. But
    in contrast, a power-up takes effect immediately after the player touches it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在视频游戏中，物品和提升之间的核心区别是玩家可以收集物品、存储它们并在需要时使用它们的益处。但相比之下，提升在玩家接触后立即生效。
- en: Implementing a power-up mechanic
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现提升机制
- en: In this section, we will write the necessary skeleton code to implement a power-up
    system with the Visitor pattern. Our goal is to have a valid proof of concept
    by the end of this section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写必要的骨架代码来实现具有访问者模式的提升系统。我们的目标是到本节结束时有一个有效的概念证明。
- en: Implementing the power-up system
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现提升系统
- en: 'Let''s look at the steps for implementation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现步骤：
- en: 'We''ll start by writing a core element of the pattern, the `Visitor` interface:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先编写模式的核心元素，即 `Visitor` 接口：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next up, we are going to code an interface that each visitable element will
    have to implement:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个接口，每个可访问元素都必须实现：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have our primary interfaces, let''s implement the main class that
    makes our power-up mechanism work; because of its length, we will review it in
    two parts:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了主要接口，让我们实现使提升机制工作的主要类；由于其长度，我们将分两部分进行回顾：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first thing to notice is that this class is a `ScriptableObject` with a
    `CreateAssetMenu` attribute. Therefore, we will be able to use it to create new
    power-up assets from the Asset menu. And then, we will be able to configure the
    parameters of each new power-up in the engine''s Inspector. But another important
    detail is that this class implements the `IVisitor` interface, which we will review
    in the following part:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个类是一个带有 `CreateAssetMenu` 属性的 `ScriptableObject` 类。因此，我们将能够从资产菜单中创建新的提升资产。然后，我们可以在引擎的检查器中配置每个新提升的参数。但另一个重要的细节是，这个类实现了
    `IVisitor` 接口，我们将在下一部分进行回顾：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, for each visitable element, we have a unique method associated
    with it; inside each of them, we implement the operation we want to execute when
    visiting a specific element.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，对于每个可访问元素，我们都有一个与之关联的独特方法；在它们内部，我们实现了在访问特定元素时要执行的操作。
- en: In our case, we are changing specific properties of the visited object while
    taking into account the defined maximum values. Therefore, we encapsulate the
    expected behavior of a power-up when it visits a specific visitable element of
    the bike's structure inside individual `Visit()` methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们正在更改访问对象的具体属性，同时考虑到定义的最大值。因此，我们将提升在访问自行车结构特定可访问元素时预期的行为封装在单个 `Visit()`
    方法中。
- en: We need to change specific values, modify operations, and add new behaviors
    for a particular visitable element; we can do these things inside this single
    class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改特定值、修改操作和为特定可访问元素添加新行为；我们可以在单个类中完成这些事情。
- en: 'Next up is the `BikeController` class, responsible for controlling the bike''s
    key components that comprise its structure:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是 `BikeController` 类，它负责控制构成自行车结构的自行车关键组件：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the class is implementing the `Accept()` method from the `IBikeElement`
    interface. This method will get called automatically when the bike collides with
    a power-up item positioned on the race track. And through this method, a power-up
    entity will be able to pass a visitor object to the `BikeController`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该类正在实现 `IBikeElement` 接口的 `Accept()` 方法。当自行车与位于赛道上的提升物品相撞时，将自动调用此方法。通过此方法，提升实体将能够将访客对象传递给
    `BikeController`。
- en: The controller will proceed to forward the received visitor object to each of
    its visitable elements. And the visitable elements will get their properties updated
    as configured in the instance of the visitor object. Hence, this is how the power-up
    mechanism is triggered and operates.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将依次将接收到的访客对象转发给其每个可访问元素。可访问元素将根据访客对象实例中的配置更新其属性。因此，这就是提升机制被触发和运行的方式。
- en: 'It''s time to implement our individual visitable elements, starting with our
    skeleton `BikeWeapon` class:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候实现我们各自的访问元素了，从我们的骨骼 `BikeWeapon` 类开始：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is the `BikeEngine` class; take note that in a complete implementation,
    this class would have the responsibility of simulating some of the behaviors of
    an engine, including activating the turbocharger, managing the cooling system,
    and controlling the speed:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是`BikeEngine`类；请注意，在完整的实现中，这个类将负责模拟一些引擎的行为，包括激活涡轮增压，管理冷却系统，以及控制速度：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And finally, `BikeShield`, the name of which implies its main function, is
    done as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`BikeShield`的名称暗示了其主要功能，其实现如下：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we can see, each individual visitable bike element class implements the `Accept()`
    method, thus making themselves visitable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每个单独的可访问自行车元素类都实现了`Accept()`方法，从而使自己变得可访问。
- en: Testing the power-up system implementation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试`PowerUp`系统实现
- en: 'To quickly test our implementation in your own instance of Unity, you need
    to follow these steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速测试您自己的Unity实例中的实现，您需要遵循以下步骤：
- en: Copy all the scripts we just reviewed into your Unity project.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚审查的所有脚本复制到您的Unity项目中。
- en: Create a new scene.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景。
- en: Add a GameObject to the scene.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个GameObject添加到场景中。
- en: 'Attach the following `ClientVisitor` script to the new GameObject:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`ClientVisitor`脚本附加到新的GameObject上：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Go to the **Assets/Create** menu option and create three `PowerUp` assets.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**资产/创建**菜单选项并创建三个`PowerUp`资产。
- en: Configure and name the new `PowerUp` assets with your desired parameters.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您期望的参数配置并命名新的`PowerUp`资产。
- en: Name the new `PowerUp` assets and adjust their parameters in the Inspector.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中为新`PowerUp`资产命名并调整其参数。
- en: Add the new `PowerUp` assets to the public properties of the `ClientVisitor`
    component.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`PowerUp`资产添加到`ClientVisitor`组件的公共属性中。
- en: 'Once you start the scene, you should see the following GUI buttons and debug
    output on your screen:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始场景，您应该在屏幕上看到以下GUI按钮和调试输出：
- en: '![](img/c84cf0c5-925b-4d5f-af9f-4cd806b5e0ee.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c84cf0c5-925b-4d5f-af9f-4cd806b5e0ee.png)'
- en: Figure 10.2 - Screenshot of the code example in action
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 - 代码示例运行时的截图
- en: But you might be asking yourself, how do I create an actual pickup entity that
    I can spawn on the race track?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能想知道，我该如何创建一个实际的拾取实体，我可以在赛道上生成它？
- en: 'A quick way to do this is simply to create a `Pickup` class like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的一个快速方法是简单地创建一个类似于以下的`Pickup`类：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By attaching this script to a GameObject with a collider component configured
    as a trigger, we can detect when an entity with the `BikeController` component
    enters the trigger. Then we just need to call its `Accept()` method and pass the
    `PowerUp` instance. Setting up triggers is beyond the scope of this chapter, but
    I recommend looking at the FPP project in the Git repo to review how we set it
    up in a playable prototype of the game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此脚本附加到一个配置为触发器的碰撞器组件的GameObject上，我们可以检测具有`BikeController`组件的实体何时进入触发器。然后我们只需调用它的`Accept()`方法并传递`PowerUp`实例。设置触发器超出了本章的范围，但我建议查看Git仓库中的FPP项目，以了解我们如何在游戏的可玩原型中设置它。
- en: Reviewing the power-up system implementation
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查`PowerUp`系统实现
- en: We were able to combine the structure of the Visitor pattern and the API features
    of ScriptableObjects to create a power-up mechanic that permits anyone on our
    project to author and configure new power-ups without writing a single line of
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够结合访问者模式的结构和ScriptableObjects的API功能，创建一个允许我们项目中的任何人为其编写和配置新的`PowerUp`而无需编写任何代码的机制。
- en: If we need to adjust how power-ups affect various components of our vehicle,
    we can do so by modifying a single class. So, in conclusion, we achieved a degree
    of scalability while keeping our code easily maintainable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要调整`PowerUp`对我们车辆各个组件的影响，我们可以通过修改单个类来实现。因此，总的来说，我们在保持代码易于维护的同时，实现了一定程度的可扩展性。
- en: The implementations of the standard software design patterns in this book are
    experimental and adapted in creative ways. We are adapting them to utilize Unity
    API features and adjusting them for game development use cases. So we should not
    consider the examples to be academic or standardized references, just interpretations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中对标准软件设计模式的实现是实验性的，并且以创新的方式进行了调整。我们将它们调整为利用Unity API功能，并调整以适应游戏开发用例。因此，我们不应将示例视为学术或标准化的参考，而应将其视为解释。
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter of the book, we built a power-up mechanic for our game using
    the Visitor pattern as our foundation. We also established a workflow to create
    and configure power-ups. Therefore, we combined the technical and creative mindsets,
    which is the core of game development.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一章节中，我们使用访问者模式作为基础，为我们的游戏构建了一个增强机制。我们还建立了一个工作流程来创建和配置增强功能。因此，我们结合了技术和创造性思维，这是游戏开发的核心。
- en: In the next chapter, we are going to design and implement attack maneuvers for
    enemy drones. We are going to use the Strategy pattern as the foundation of our
    system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将设计和实现敌方无人机的攻击机动。我们将使用策略模式作为我们系统的基石。
