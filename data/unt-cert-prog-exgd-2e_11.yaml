- en: '*Chapter 11*: Storing Data and Audio Mixer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：存储数据和音频混合器'
- en: In this chapter, we will be looking at common ways of storing and sending data
    for our game. This will also involve us making use of Unity's ready-made **Audio
    Mixer** for us to store the player's volume settings for the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨为我们的游戏存储和发送数据的常见方法。这还将涉及我们使用 Unity 的现成 **音频混合器** 来存储玩家的游戏音量设置。
- en: As you may recall, in the previous chapter, we had begun making our own pause
    screen from scratch. We will be carrying on with this in this chapter. We still
    need to work on the music and sound effects slider on the pause screen. We will
    hold all Audio Source controls for each sound to be played in the **Audio Mixer**.
    The **Audio Mixer** will act as a central point for all sound and can also be
    manipulated via scripting, which we will also be doing in this chapter. If our
    game had more sound effects and more music, an **Audio Mixer** controlling the
    game's sound from one place would help us avoid getting tangled up with all the
    different audio source components attached to game objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所忆，在前一章中，我们从头开始制作自己的暂停屏幕。我们将在本章继续这一工作。我们仍然需要处理暂停屏幕上的音乐和音效滑块。我们将保留所有要在 **音频混合器**
    中播放的音频源控制。**音频混合器** 将作为所有声音的中心点，也可以通过脚本进行操作，我们将在本章中这样做。如果我们的游戏有更多的音效和音乐，一个控制游戏声音的
    **音频混合器** 从一个地方控制所有声音，将帮助我们避免与所有附加到游戏对象的不同的音频源组件纠缠在一起。
- en: We will be making use of storing the volume settings with Unity's own `PlayerPrefs`,
    which stores data locally on the platform playing the game. This is also known
    as persistent data because we can turn off the machine that holds the volume information
    and when the machine is turned back on, the data remains on the system. We will
    introduce serializing our objects into data and deserializing the data back into
    objects. This is useful if we want to send batches of data onto a database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Unity 自带的 `PlayerPrefs` 来存储音量设置，它会在游戏运行的平台本地存储数据。这也被称为持久数据，因为我们可以在关闭包含音量信息的机器后，当机器重新开启时，数据仍然保留在系统中。我们将介绍将我们的对象序列化成数据，并将数据反序列化回对象。如果我们想将数据批量发送到数据库，这很有用。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using the **Audio Mixer**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **音频混合器**
- en: Storing data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储数据
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Core exam skills covered in this chapter
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖的核心考试技能
- en: 'The following are the core exam skills that will be covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在本章中将要涵盖的核心考试技能：
- en: '*Programming core interactions*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*编程核心交互*：'
- en: Implement and configure game object behavior and physics.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象的行为和物理。
- en: '*Developing application systems*:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*开发应用程序系统*：'
- en: Interpret scripts for application interface flow such as menu systems, UI navigation,
    and application settings.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析应用界面流程的脚本，例如菜单系统、UI 导航和应用设置。
- en: Analyze scripts for user progression features such as scoring, leveling, and
    in-game economies utilizing technologies such as Unity Analytics and `PlayerPrefs`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析用于用户进度功能的脚本，例如得分、等级和游戏内经济，利用 Unity Analytics 和 `PlayerPrefs` 等技术。
- en: Identify scripts for saving and retrieving application and user data.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于保存和检索应用程序和用户数据的脚本。
- en: '*Programming for scene and environment design*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*为场景和环境设计编程*：'
- en: Determine scripts for implementing audio assets.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现音频资源的脚本。
- en: '*Working in professional software development teams*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*在专业软件开发团队中工作*：'
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别构建模块化、可读性和可重用性脚本的技巧。
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The project content for this chapter can be found at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_11](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_11).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目内容可以在 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_11](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Chapter_11)
    找到。
- en: You can download the entirety of each chapter's project files at [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载每个章节的项目文件的全部内容，地址为 [https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition)。
- en: All content for this chapter is held in the chapter's `unitypackage` file, including
    a `Complete` folder that contains all of the work that we'll carry out in this
    chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有内容都保存在章节的`unitypackage`文件中，包括一个包含本章我们将执行的所有工作的`Complete`文件夹。
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3EYHpxf](https://bit.ly/3EYHpxf).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码执行情况*：[https://bit.ly/3EYHpxf](https://bit.ly/3EYHpxf)。
- en: Using the Audio Mixer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用音频混音器
- en: As the game grows, it's useful to have a mixer channel that focuses on all the
    allocated volume levels and sound effects. Otherwise, if not for a separate mixer
    channel, we would be clicking on various game objects and adjusting each of their
    components in the **Inspector** window.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着游戏的增长，有一个专注于所有分配的音量和音效的混音器通道是有用的。否则，如果没有单独的混音器通道，我们就需要在**检查器**窗口中点击各种游戏对象并调整它们的每个组件。
- en: 'For our game, we are going to keep this simple and create three **Audio Groups**
    with no added effects. Let''s take a look at what each **Audio Group** will focus
    on:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们将保持简单，创建三个没有任何附加效果的**音频组**。让我们看看每个**音频组**将关注什么：
- en: '**Master Audio Group**: Controls the master for the entire game'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主音频组**：控制整个游戏的主音量'
- en: '**Music Audio Group**: Controls the music of each level'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**音乐音频组**：控制每个级别的音乐'
- en: '**Effects Audio Group**: Controls the sound effects of the bullets firing from
    our player''s ship'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**效果音频组**：控制玩家飞船发射的子弹音效'
- en: 'The following screenshot shows **Audio Mixer** and the setup for the three
    **Audio Groups**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了**音频混音器**和三个**音频组**的设置：
- en: '![Figure 11.1 – Audio Mixer window with Master, Music, and Effects Audio Groups'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.1 – 带有主、音乐和效果音频组的音频混音器窗口'
- en: '](img/Figure_11.01_B18381.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.01_B18381.jpg]'
- en: Figure 11.1 – Audio Mixer window with Master, Music, and Effects Audio Groups
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.1 – 带有主、音乐和效果音频组的音频混音器窗口
- en: Further Information
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: If you would like to know more about the layout of **Audio Mixer**, check out
    the documentation at [https://docs.unity3d.com/Manual/AudioMixerOverview.html](https://docs.unity3d.com/Manual/AudioMixerOverview.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于**音频混音器**布局的信息，请查看[https://docs.unity3d.com/Manual/AudioMixerOverview.html](https://docs.unity3d.com/Manual/AudioMixerOverview.html)上的文档。
- en: 'Let''s now start by creating the **Audio Mixer** within the Unity Editor, by
    following these steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在开始创建Unity编辑器中的**音频混音器**，按照以下步骤进行：
- en: In the `Assets` and right-click on an open space within the folder.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`资产`中右键单击文件夹内的空白区域。
- en: 'From the drop-down menu, select **Create**, followed by **Audio Mixer**. The
    following screenshot shows the selection being made:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**创建**，然后选择**音频混音器**。以下截图显示了选择过程：
- en: '![Figure 11.2 – Create an Audio Mixer'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.2 – 创建音频混音器'
- en: '](img/Figure_11.02_B18381.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.02_B18381.jpg]'
- en: Figure 11.2 – Create an Audio Mixer
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.2 – 创建音频混音器
- en: With that, a new `MasterMixer`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样，就有一个新的`MasterMixer`。
- en: Before we hook up the mixer to the `LevelMusic` and `Player_Bullet` game objects
    (because these are the two game objects making the sounds), we need to go into
    the **Audio Mixer** and create **Music** and **Effects** mixers first (we only
    have the master **Audio Group** on its own at the moment).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将混音器连接到`LevelMusic`和`Player_Bullet`游戏对象（因为这些是制造声音的两个游戏对象）之前，我们需要进入**音频混音器**并首先创建**音乐**和**效果**混音器（我们目前只有单独的**音频组**）。
- en: 'Let''s have a closer look at our `MasterMixer`, double-click the `MasterMixer`
    file in the **Project** window. We will be presented with the following screen:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`MasterMixer`，在**项目**窗口中双击`MasterMixer`文件。我们将看到以下屏幕：
- en: '![Figure 11.3 – Audio Mixer window with Master Audio Group'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.3 – 带有主音频组的音频混音器窗口'
- en: '](img/Figure_11.03_B18381.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.03_B18381.jpg]'
- en: Figure 11.3 – Audio Mixer window with Master Audio Group
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.3 – 带有主音频组的音频混音器窗口
- en: 'The previous screenshot shows our setup for the **Audio Mixer**. It consists
    of four categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们的**音频混音器**设置。它由四个类别组成：
- en: '`MasterMixer`.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MasterMixer`。'
- en: '**Snapshots**: Consider this a save state for our mixer. We can have multiple
    snapshots, such as a physical Hi-Fi where we can select different saved presets
    (Rock, Disco, Classical, and so on). Snapshots are used in the same way as presets;
    it saves us time so that we don''t always have to adjust the mixer settings.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**快照**：将此视为混音器的保存状态。我们可以有多个快照，例如物理Hi-Fi，我们可以选择不同的已保存预设（摇滚、迪斯科、古典等）。快照的使用方式与预设相同；它节省了我们的时间，这样我们就不必总是调整混音器设置。'
- en: '`MasterMixer` will be our two groups – one for **Music** and the other for
    **Effects**. We will create these soon.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MasterMixer`将是我们两个分组 – 一个用于**音乐**，另一个用于**效果**。我们很快就会创建这些。'
- en: '**Views**: Used to save different **Audio Mixer** UI layouts.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视图**：用于保存不同的**音频混音器**UI布局。'
- en: Don't worry too much about the details as we are going to focus mainly on **groups**.
    There is more we can do with Audio Mixers. Check the official Unity documentation
    to find out more at [https://docs.unity3d.com/Documentation/Manual/AudioMixer.html](https://docs.unity3d.com/Documentation/Manual/AudioMixer.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心细节，因为我们主要将关注**分组**。我们可以用音频混音器做更多的事情。查看官方Unity文档以获取更多信息，链接为[https://docs.unity3d.com/Documentation/Manual/AudioMixer.html](https://docs.unity3d.com/Documentation/Manual/AudioMixer.html)。
- en: 'To add two extra volume mixers next to our **Master**, we need to do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要在**Master**旁边添加两个额外的音量混音器，我们需要执行以下操作：
- en: 'Right-click **Master** under the **Groups** section and select **Add child
    group**. We will gain a new mixer, as shown in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**分组**部分下的**Master**，然后选择**添加子分组**。我们将获得一个新的混音器，如下面的截图所示：
- en: '![Figure 11.4 – Creating a new Audio Group'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 – 创建新的音频分组'
- en: '](img/Figure_11.04_B18381.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.04_B18381.jpg)'
- en: Figure 11.4 – Creating a new Audio Group
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 创建新的音频分组
- en: Right-click **New Group** (circled in the previous screenshot) and select **Rename**
    from the drop-down menu.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击上一个截图中的**New Group**（已圈出），然后从下拉菜单中选择**重命名**。
- en: Rename `New Group` to `Music`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`New Group`重命名为`Music`。
- en: Repeat *steps 1-3* to create another `Effects`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1-3*以创建另一个`Effects`。
- en: 'The following screenshot shows what the **Audio Mixer** window will look like
    now, with all three ASVs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了现在带有所有三个ASV的**音频混音器**窗口将看起来像什么：
- en: '![Figure 11.5 – Audio Mixer with all three Audio Groups'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – 包含所有三个音频分组的音频混音器'
- en: '](img/Figure_11.05_B18381.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.05_B18381.jpg)'
- en: Figure 11.5 – Audio Mixer with all three Audio Groups
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – 包含所有三个音频分组的音频混音器
- en: Great! Now, we can move on to hooking these `LevelMusic` game object, which
    is a child of the `GameManager` game object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以继续连接这些`LevelMusic`游戏对象，它是`GameManager`游戏对象的子对象。
- en: 'To update our `LevelMusic` game object''s **Audio Source** component, do the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们的`LevelMusic`游戏对象的**音频源**组件，请执行以下操作：
- en: Load up the `bootUp` scene from the Unity Editor.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity编辑器加载`bootUp`场景。
- en: In the `GameManager` game object and select the `LevelMusic` game object.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameManager`游戏对象中，选择`LevelMusic`游戏对象。
- en: Back in the **Project** window, click the arrow to the left of **MasterMixer**
    to expand its content.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，点击**MasterMixer**左侧的箭头以展开其内容。
- en: 'Click the **Music** child group and drag it into the **Output** field of LevelMusic''s
    **Audio Source**, as shown in the following screenshot:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Music**子分组，并将其拖入LevelMusic的**音频源**的**输出**字段，如下面的截图所示：
- en: '![Figure 11.6 – Drag the Music Audio Group to the LevelMusic Audio Source Output
    field'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 将音乐音频分组拖到LevelMusic音频源输出字段'
- en: '](img/Figure_11.06_B18381.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.06_B18381.jpg)'
- en: Figure 11.6 – Drag the Music Audio Group to the LevelMusic Audio Source Output
    field
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 将音乐音频分组拖到LevelMusic音频源输出字段
- en: Click **Overrides |Apply All** in the **Inspector** window to update the GameManager's
    prefab settings.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中点击**覆盖|应用全部**以更新GameManager的预制件设置。
- en: 'Now, we need to do something similar for our `player_bullet` prefab. To update
    its **Audio Source** with the **Effects** mixer, do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为我们的`player_bullet`预制件做类似的事情。要使用**Effects**混音器更新其**音频源**，请执行以下操作：
- en: In the `Assets/Prefab/Player` folder. There, you should find our `player_bullet`
    game object.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Prefab/Player`文件夹中。在那里，你应该找到我们的`player_bullet`游戏对象。
- en: Select `player_bullet` (denoted as `player_bullet` for **Audio Source** **Output**
    (denoted as **3**).
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`player_bullet`（表示为`player_bullet`的**音频源****输出**（表示为**3**）。
- en: 'The following screenshot shows what the `player_bullet` game object''s **Audio
    Source** should look like in the **Inspector** window:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`player_bullet`游戏对象的**音频源**在**检查器**窗口中应该看起来像什么：
- en: '![Figure 11.7 – Drag the player_bullet''s Audio Group Effects into the Audio
    Source Output field'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 – 将player_bullet的音频分组效果拖入音频源输出字段'
- en: '](img/Figure_11.07_B18381.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.07_B18381.jpg)'
- en: Figure 11.7 – Drag the player_bullet's Audio Group Effects into the Audio Source
    Output field
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 将player_bullet的音频分组效果拖入音频源输出字段
- en: Now, the **Audio Mixer** is nearly ready to be connected to our pause screen's
    **Music** and **Effects** sliders. We need to do one more thing before we move
    on to the next section, and that is to make the **audio group's** volume accessible
    so we can make it communicate with the pause screen's audio sliders. To do this,
    we need to set our **Audio Mixer's** Attenuation Volume property to open or **expose**
    it to our scripts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**音频混音器**几乎准备好连接到暂停屏幕的**音乐**和**效果**滑块。在我们进入下一节之前，我们需要做最后一件事，那就是使**音频组的**音量可访问，以便我们可以使其与暂停屏幕的音频滑块进行通信。为此，我们需要将我们的**音频混音器的**衰减音量属性设置为打开或**暴露**给我们的脚本。
- en: 'To expose and name our **audio groups**, we need to do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要暴露并命名我们的**音频组**，我们需要执行以下操作：
- en: In the **Project** window, go to **MasterMixer** and expand its content so that
    we can see its groups.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，转到**MasterMixer**并展开其内容，以便我们可以看到其组。
- en: Select the **Music** group.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**音乐**组。
- en: In the **Inspector** window, we are presented with the **Music** **Group's**
    properties. We want to expose **Volume** so that we can alter it with our script.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，我们看到了**音乐****组**的属性。我们想要暴露**音量**，以便我们可以用我们的脚本修改它。
- en: 'Right-click **Volume** (In the **Inspector** window, under **Attenuation**)
    and select **Expose ''Volume (of Music)'' to script**, as shown in the following
    screenshot:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**音量**（在**检查器**窗口中，位于**衰减**下）并选择**将“音量（音乐）”暴露给脚本**，如图下所示：
- en: '![Figure 11.8 – In the Inspector window, right-click Attenuation Volume and
    select Expose ''Volume (of Music) to script'''
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.8 – 在检查器窗口中，右键点击衰减音量并选择将“音量（音乐）”暴露给脚本'''
- en: '](img/Figure_11.08_B18381.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.08_B18381.jpg]'
- en: Figure 11.8 – In the Inspector window, right-click Attenuation Volume and select
    Expose 'Volume (of Music) to script'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.8 – 在检查器窗口中，右键点击衰减音量并选择将“音量（音乐）”暴露给脚本'
- en: Now, we also have the option to give the exposed volume a reference name instead
    of its default name of `MyExposedParam`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也有选择给暴露的音量一个引用名称，而不是其默认名称`MyExposedParam`。
- en: 'To change the reference of the exposed **Music** **Volume**, do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改暴露的**音乐****音量**的引用，请执行以下操作：
- en: Back in the `MasterMixer` file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `MasterMixer` 文件。
- en: As you may have noticed, in the top-right corner of **Audio Mixer**, we are
    notified that we have **Exposed Parameters (1)** (denoted by **1** in the following
    screenshot). The **1** is the **Music** **Volume** that we just exposed.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，在**音频混音器**的右上角，我们被告知我们有**暴露参数（1**）（在下述截图中的**1**表示）。这个**1**是我们刚刚暴露的**音乐****音量**。
- en: Click **Exposed Parameters (1)** (denoted by **1**).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**暴露参数（1**）（标记为**1**）。
- en: Right-click the **MyExposedParam Volume (of Music)** (denoted by **2**).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**我的暴露参数音量（音乐**）（标记为**2**）。
- en: Select **Rename** from the drop-down menu (denoted by **3**).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择**重命名**（标记为**3**）。
- en: In the parameter that appears, rename it `musicVol` (denoted by **4**).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的参数中，将其重命名为`musicVol`（标记为**4**）。
- en: 'The following screenshot shows the stages we just spoke about in the preceding
    steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们在前面的步骤中提到的阶段：
- en: '![Figure 11.9 – Renaming MyExposedParam to musicVol'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.9 – 将 MyExposedParam 重命名为 musicVol'
- en: '](img/Figure_11.09_B18381.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.09_B18381.jpg]'
- en: Figure 11.9 – Renaming MyExposedParam to musicVol
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.9 – 将 MyExposedParam 重命名为 musicVol
- en: I hope you understood this process well, because I want you to do it again but
    with the `effectsVol`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你们已经很好地理解了这个过程，因为我希望你们再次执行这个过程，但这次是使用 `effectsVol`。
- en: 'Finally, we will have our exposed volume references named like so in our **Audio
    Mixer**:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的**音频混音器**中，我们将暴露的音量引用命名为如下：
- en: '![Figure 11.10 – Both of the exposed parameters are renamed'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.10 – 两个暴露的参数都已重命名'
- en: '](img/Figure_11.10_B18381.png)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.10_B18381.png]'
- en: Figure 11.10 – Both of the exposed parameters are renamed
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 11.10 – 两个暴露的参数都已重命名
- en: 'Nice work! Before we move on to the next section, let''s briefly recap what
    we have covered so far in this section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！在我们进入下一节之前，让我们简要回顾一下本节我们已经涵盖的内容：
- en: We introduced the **Audio Mixer** and its benefits.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了**音频混音器**及其优点。
- en: We created **Audio Groups** for our Mixer.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为我们的混音器创建了**音频组**。
- en: We attached the **Audio Mixer** to our game object's Audio Source.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将**音频混音器**附加到了游戏对象的音频源上。
- en: We exposed the **Audio Mixer** to our scripts.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将**音频混音器**暴露给了我们的脚本。
- en: In the next section, we are going to code our pause screen's **Volume** and
    **Effects** sliders.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将编写暂停屏幕的**音量**和**效果**滑块的代码。
- en: Attaching the Audio Mixer to UI sliders
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将音频混音器附加到 UI 滑块
- en: In this section, we are going to write two methods (`SetMusicLevelFromSlider`
    and `SetEffectsLevelFromSlider`) that attach our pause screen's **Music** and
    **Effects** sliders to the **Audio Mixer** that we created in the previous section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写两个方法（`SetMusicLevelFromSlider`和`SetEffectsLevelFromSlider`），将我们的暂停屏幕的**音乐**和**效果**滑块连接到我们在上一节中创建的**音频混音器**。
- en: 'Let''s start by adding the **Music** slider to our **Audio Mixer** via the
    script, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先通过脚本将**音乐**滑块添加到我们的**音频混音器**中，如下所示：
- en: In the `PauseComponent` script, which should be located in `Assets/Script`,
    and open it.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PauseComponent`脚本中，它应位于`Assets/Script`，并打开它。
- en: Because we are going to access the **Audio Mixer**, we need an extra Unity library
    to let this happen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将要访问**音频混音器**，我们需要一个额外的Unity库来实现这一点。
- en: 'At the top of our `PauseComponent` script, add the following line of code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`PauseComponent`脚本顶部，添加以下代码行：
- en: '[PRE0]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, add a field that will store a reference for our **Audio Mixer**:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个字段来存储我们的**音频混音器**的引用：
- en: '[PRE1]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to add two more variables for the `masterMixer` variable, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为`masterMixer`变量添加两个更多变量，如下所示：
- en: '[PRE2]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the script and return to the Unity Editor.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity编辑器。
- en: Load up the `level1` scene where we started creating our pause screen.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载我们开始创建暂停屏幕的`level1`场景。
- en: Select the `PauseContainer` game object from the **Hierarchy** window.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中选择`PauseContainer`游戏对象。
- en: 'In the `PauseComponent`. Here, we can drag the two sliders from the **Hierarchy**
    window and our **MasterMixer** from the **Project** window, as shown in the following
    screenshot:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PauseComponent`。在这里，我们可以从**层次结构**窗口拖动两个滑块，以及从**项目**窗口中的**MasterMixer**，如下截图所示：
- en: '![Figure 11.11 – Dragging each game object and file into their directed fields'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 – 将每个游戏对象和文件拖入其指定的字段]'
- en: '](img/Figure_11.11_B18381.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B18381.jpg)'
- en: Figure 11.11 – Dragging each game object and file into their directed fields
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 将每个游戏对象和文件拖入其指定的字段
- en: Now that our three references (music slider, effects slider, and master mixer)
    are hooked up to their parameters, we can return to our `PauseComponent` script
    and code in a method for each of the pause screen's volume sliders.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将三个引用（音乐滑块、效果滑块和主混音器）连接到它们的参数，我们可以返回到我们的`PauseComponent`脚本并为暂停屏幕的每个音量滑块编写一个方法。
- en: 'To add functionality so that our **Music** slider controls the **Music** mixer,
    do the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加功能，使我们的**音乐**滑块控制**音乐**混音器，请执行以下操作：
- en: 'In the `PauseComponent` script, add a `public` method within the `PauseComponent`
    class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PauseComponent`脚本中，在`PauseComponent`类内添加一个`public`方法：
- en: '[PRE3]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `public` method we have just entered, `SetMusicLevelFromSlider`, will work
    as an event from the `masterMixer`. Within this variable, we call its `SetFloat`
    function, which takes two parameters. The first is the reference name of the mixer
    (we called this `musicVol` earlier in this chapter), while the second is what
    value it is receiving to be changed. We are sending the value from our pause screen's
    **Music** slider.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚进入的`public`方法`SetMusicLevelFromSlider`将作为`masterMixer`的事件。在这个变量中，我们调用它的`SetFloat`函数，该函数接受两个参数。第一个是混音器的引用名称（我们在本章中将其称为`musicVol`），而第二个是要更改的值。我们正在发送来自暂停屏幕的**音乐**滑块的值。
- en: Save the script and return to the Unity Editor.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本并返回到Unity编辑器。
- en: 'Next, we need to attach our `SetMusicLevelFromSlider` method. To make the **Music**
    slider communicate with the method, follow these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要附加我们的`SetMusicLevelFromSlider`方法。为了使**音乐**滑块与该方法通信，请按照以下步骤操作：
- en: Still in our `level1` scene, in the `Music` game object.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在我们的`level1`场景中，在`Music`游戏对象中。
- en: In the **Inspector** window, click the **+** button at the bottom of the **Inspector**
    window to allow an event to be attached to the **Slider** component (denoted by
    **1** in the following screenshot).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**检查器**窗口底部的**+**按钮，以便将事件附加到**滑块**组件（以下截图中的**1**所示）。
- en: Drag the `PauseContainer` game object from the **Hierarchy** window to the **None
    (Object)** parameter (denoted by **2**).
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PauseContainer`游戏对象从**层次结构**窗口拖到**无（对象**）参数（以下截图中的**2**所示）。
- en: Click the `SetMusicLevelFromSlider` (denoted by **3**).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`SetMusicLevelFromSlider`（以下截图中的**3**所示）。
- en: 'The following screenshot references the previous instructions for the `Music`
    game object in the **Inspector** window:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图引用了**检查器**窗口中`Music`游戏对象的先前说明：
- en: '![Figure 11.12 – Three steps in updating the Music game object''s music slider
    event'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12 – 更新音乐游戏对象的音乐滑块事件的三个步骤]'
- en: '](img/Figure_11.12_B18381.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.12_B18381.jpg](img/Figure_11.12_B18381.jpg)'
- en: Figure 11.12 – Three steps in updating the Music game object's music slider
    event
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 更新音乐游戏对象音乐滑块事件的三个步骤
- en: If we go back to the **bootUp** scene and click **Play** in the Unity Editor
    and then, in the **Game** window, click the game's pause button when it appears,
    we will be able to turn the music up and down with the **Music** slider.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到**启动**场景，在Unity编辑器中点击**播放**，然后在**游戏**窗口中，当游戏暂停按钮出现时点击它，我们将能够通过**音乐**滑块调节音量大小。
- en: 'Now, we need to repeat this in a similar fashion for our **Effects** slider
    volume to work:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要以类似的方式重复此过程，以便我们的**效果**滑块音量能够工作：
- en: 'Return to the `PauseComponent` script and enter the following method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`PauseComponent`脚本，并输入以下方法：
- en: '[PRE4]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, the code is virtually the same as the code for `SetMusicLevelFromSlider`,
    apart from the variable names.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码几乎与`SetMusicLevelFromSlider`的代码相同，除了变量名不同。
- en: Save the script.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Return to the Unity Editor and repeat the same procedure for dragging the `PauseComponent`
    game object but this time with the `Effects` game object and selecting `SetEffectsLevelFromSlider`,
    as shown in the following screenshot:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Unity编辑器，重复相同的步骤拖动`PauseComponent`游戏对象，但这次是使用`Effects`游戏对象，并选择`SetEffectsLevelFromSlider`，如下面的截图所示：
- en: '![Figure 11.13 – Updating the Effects game object audio slider'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.13 – Updating the Effects game object audio slider](img/Figure_11.13_B18381.jpg)'
- en: '](img/Figure_11.13_B18381.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.13_B18381.jpg](img/Figure_11.13_B18381.jpg)'
- en: Figure 11.13 – Updating the Effects game object audio slider
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 – 更新效果游戏对象音频滑块
- en: Finally, test to see if the **Effects** slider works when we run the game.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试一下当我们运行游戏时，**效果**滑块是否工作。
- en: This will obviously only work in `level1` as `level2` and `level3` don't have
    the extra game objects. In the next chapter, we will be making a new `level3`,
    so if you can hold on until then, it'll save going through the process of removing
    and adding scenes again.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然只能在`level1`中工作，因为`level2`和`level3`没有额外的游戏对象。在下一章中，我们将创建一个新的`level3`，所以如果你能等到那时，就可以避免再次经历删除和添加场景的过程。
- en: 'In this section, we covered the following functionality for the `PauseComponent`
    script:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了`PauseComponent`脚本的以下功能：
- en: Ensuring it recognizes Audio Mixer
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它识别音频混音器
- en: Ensuring that the **Music** and **Effects** UI sliders alter **Audio Groups**
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保**音乐**和**效果**UI滑块改变**音频组**
- en: In the next section, we are going to start looking at how to store our data.
    We will use the pause screen one more time to show the benefit of our game remembering
    our volume settings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始探讨如何存储我们的数据。我们将再次使用暂停屏幕来展示游戏记住我们的音量设置的好处。
- en: Storing data
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储数据
- en: In this section, we are going to cover how we are going to store our data, such
    as the game's volume settings so that when we play our game, we don't have to
    keep setting the volume settings to where they were before. We want the game to
    remember them for us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何存储我们的数据，例如游戏的音量设置，这样当我们玩游戏时，我们就不必不断将音量设置回之前的位置。我们希望游戏能为我们记住这些设置。
- en: 'There are multiple ways we can store data. The ones we are going to cover are
    the two most common choices for Unity development. They are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据有多种方式。我们将介绍的是Unity开发中最常见的两种选择。它们如下：
- en: '`PlayerPrefs` shortly to save our volume settings so that when we turn our
    game off and back on, it will remember our settings. `PlayerPrefs` is easily accessible
    from outside the game with a text file reader. When it comes to development, make
    sure you don''t use `PlayerPrefs` to store sensitive information such as credit
    card details or things that would give a player an unfair advantage such as storing
    lives, energy, score, in-game credit, and so on. For more information about `PlayerPrefs`,
    check Unity''s description at [https://docs.unity3d.com/Documentation/ScriptReference/PlayerPrefs.html](https://docs.unity3d.com/Documentation/ScriptReference/PlayerPrefs.html).'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`PlayerPrefs`来保存我们的音量设置，这样当我们关闭并重新打开游戏时，它会记住我们的设置。`PlayerPrefs`可以通过文本文件读取器轻松地从游戏外部访问。在开发过程中，确保不要使用`PlayerPrefs`来存储敏感信息，例如信用卡详情或会给玩家不公平优势的信息，如存储生命值、能量、得分、游戏内信用等。有关`PlayerPrefs`的更多信息，请查看Unity的描述[https://docs.unity3d.com/Documentation/ScriptReference/PlayerPrefs.html](https://docs.unity3d.com/Documentation/ScriptReference/PlayerPrefs.html)。
- en: '`PlayerPrefs` is that it uses data types such as `int`, `float`, and `string`,
    just like `PlayerPrefs`, but also `object` (our classes act as blueprints so that
    we can make objects), `array`, `bool`, and `null`.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PlayerPrefs` 的特点是它使用类似于 `PlayerPrefs` 的数据类型，如 `int`、`float` 和 `string`，但还包括
    `object`（我们的类作为蓝图，以便我们可以创建对象）、`array`、`bool` 和 `null`。'
- en: It's wise to use this form of **application programming interface** (**API**)
    for transferring game data (lives, levels, player progress, energy, and so on),
    but don't store highly personal details locally with regards to in-game credit,
    bank details, personal addresses, and emails, unless you are using some form of
    encryption.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种形式的 **应用程序编程接口**（**API**）来传输游戏数据（生命值、关卡、玩家进度、能量等）是明智的，但不要将有关游戏内信用、银行详情、个人地址和电子邮件的高度个人详细信息本地存储，除非你正在使用某种形式的加密。
- en: Information
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: An API basically tells us how applications communicate with each other.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 API 基本上告诉我们应用程序之间是如何相互通信的。
- en: For more information about JSON with Unity, check the documentation at [https://docs.unity3d.com/Documentation/Manual/JSONSerialization.html](https://docs.unity3d.com/Documentation/Manual/JSONSerialization.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Unity 中的 JSON 的更多信息，请查看[https://docs.unity3d.com/Documentation/Manual/JSONSerialization.html](https://docs.unity3d.com/Documentation/Manual/JSONSerialization.html)
    的文档。
- en: 'In the following sections, we are going to cover these two ways of storing
    data on the basis they are officially covered by Unity and are likely to be mentioned
    in your exam:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将基于它们是官方支持的，并且可能会在考试中提到的两种方式来介绍如何在 Unity 中存储数据：
- en: '`PlayerPrefs` and volume settings'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerPrefs` 和音量设置'
- en: JSON and storing game stats
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 和存储游戏统计数据
- en: Adding JSON variables
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 JSON 变量
- en: Let's make a start by looking at how to use `PlayerPrefs` and revisit our pause
    screen one last time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何使用 `PlayerPrefs` 开始，并再次回顾我们的暂停屏幕。
- en: PlayerPrefs and volume settings
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PlayerPrefs 和音量设置
- en: 'As we know, our game has volume controls for its music and sound effects on
    the pause screen. To make our game remember these volume settings, even when the
    game has been turned off and back on again, we need to do the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们的游戏在暂停屏幕上有音乐和音效的音量控制。为了使我们的游戏记住这些音量设置，即使游戏已经关闭并重新打开，我们需要做以下操作：
- en: In the `Assets/Script`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Script`。
- en: Double-click the `PauseComponent` script.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `PauseComponent` 脚本。
- en: 'Scroll down to the `SetMusicLevelFromSlider` method and add the following extra
    line of code at the bottom but within the method''s scope. The following code
    shows what the method now looks like with the added code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 `SetMusicLevelFromSlider` 方法，并在方法范围内但底部添加以下额外的代码行。以下代码显示了添加代码后方法现在的样子：
- en: '[PRE5]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we used the `value` from our music `<Slider>` component
    and applied its `float` `value` to the `PlayerPrefs` `float` with `musicVolume`
    as our key (the reference name to identify the `PlayerPrefs` value).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了音乐 `<Slider>` 组件的 `value`，并将其 `float` `value` 应用到 `PlayerPrefs`
    的 `float` 上，其中 `musicVolume` 作为我们的键（用于识别 `PlayerPrefs` 值的参考名称）。
- en: 'Do the same for the `effects` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `effects` 方法也做同样的操作：
- en: '[PRE6]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's our `PlayerPrefs` file ready to store the music and effects volume. The
    next thing to do is reapply the music/effects volume the next time we load the
    level from our `PlayerPrefs`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的 `PlayerPrefs` 文件就准备好了，可以存储音乐和音效音量。接下来要做的是在下次从 `PlayerPrefs` 加载关卡时重新应用音乐/音效音量。
- en: 'To grab the music volume setting from our `PlayerPrefs`, do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的 `PlayerPrefs` 中获取音乐音量设置，请执行以下操作：
- en: Reopen the `PauseComponent` script.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开 `PauseComponent` 脚本。
- en: 'Within the `PauseComponent` class, enter the following code at the bottom of
    the `Awake` function:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PauseComponent` 类中，在 `Awake` 函数的底部输入以下代码：
- en: '[PRE7]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are reapplying our saved `PlayerPrefs` values for
    our music and effects volume (which are both floats) to our Audio Mixer's **Audio
    Groups**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在重新应用我们保存的 `PlayerPrefs` 值（音乐和音效音量，都是浮点数）到音频混音器的 **音频组**。
- en: The volumes that we want the mixers to have are now set. The last thing we need
    to do is to set both volume sliders to their UI positions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要混音器拥有的音量现在已设置。我们最后需要做的是将两个音量滑块设置到它们的 UI 位置。
- en: 'To update the `PauseComponent`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新 `PauseComponent`：
- en: '[PRE8]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code is a method that returns a `float` value called `GetMusicLevelFromMixer`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个返回名为 `GetMusicLevelFromMixer` 的 `float` 值的方法。
- en: 'Let''s go through the steps of this `GetMusicLevelFromMixer`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `GetMusicLevelFromMixer` 的步骤：
- en: In this method, we create a `float` variable called `musicMixersValue`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，我们创建了一个名为 `musicMixersValue` 的 `float` 变量。
- en: 'The line after `musicMixersValue` checks to see whether the `masterMixer` instance
    contains an `musicVol`. We know it does because we set it earlier when we exposed
    each of the volume settings from the **Audio Mixer**, as shown in the following
    screenshot:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `musicMixersValue` 之后的行检查 `masterMixer` 实例是否包含 `musicVol`。我们知道它包含，因为我们之前在将每个音量设置从
    **音频混音器** 公开时设置了它，如下面的截图所示：
- en: '![Figure 11.14 – Our named exposed parameters'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.14 – 我们命名的公开参数'
- en: '](img/Figure_11.14_B18381.png)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.14_B18381.png)'
- en: Figure 11.14 – Our named exposed parameters
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – 我们命名的公开参数
- en: So, if `masterMixer` does contain a `float` value with the name (key) of `musicVol`,
    we will store it in a `float` named `musicMixersValue`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，如果 `masterMixer` 包含一个名为（键）`musicVol` 的 `float` 值，我们将将其存储在名为 `musicMixersValue`
    的 `float` 中。
- en: '`masterMixer.GetFloat` will send a `true` or `false` value if `masterMixer`
    does or does not contain a `float` that is also stored in a `bool` value, respectively.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `masterMixer` 包含一个在 `bool` 值中存储的 `float`，则 `masterMixer.GetFloat` 将发送一个 `true`
    或 `false` 值；否则，它将返回 `0`。
- en: If the `bool` value is `true`, the `float` value from `masterMixer` is returned
    from the method; otherwise, it will return `0`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `bool` 值为 `true`，则方法会返回 `masterMixer` 中的 `float` 值；否则，它将返回 `0`。
- en: Next, we need to call this `GetMusicLevelFromMixer` and make it so it sends
    its value to the music slider. Let's code this in now.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用这个 `GetMusicLevelFromMixer` 并使其将值发送到音乐滑块。现在让我们编写这段代码。
- en: 'Within the `PauseComponent` script, at the top, in the `Awake` function, add
    the following code below the two `masterMixer` coded lines:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PauseComponent` 脚本中，在顶部，在 `Awake` 函数中，在两个 `masterMixer` 编码行下面添加以下代码：
- en: '[PRE9]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding piece of code, we are sending the result from our `GetMusicLevelFromMixer`
    to the value of our `musicSlider` when the level starts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们在关卡开始时将 `GetMusicLevelFromMixer` 的结果发送到 `musicSlider` 的值。
- en: 'That''s our music slider set. Now, we need to repeat this process for our effects
    slider. The process is the same, apart from using the effect slider''s variables,
    so without repeating the same process, I want you to do the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的音乐滑块设置。现在，我们需要为我们的效果滑块重复此过程。过程是相同的，只是使用效果滑块的变量，所以不重复相同的步骤，我想让你做以下操作：
- en: Create a `GetEffectsLevelFromMixer` method using the same code pattern as `GetMusicLevelFromMixer`
    but using `effectsVol` instead of `musicVol`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与 `GetMusicLevelFromMixer` 相同的代码模式创建一个 `GetEffectsLevelFromMixer` 方法，但使用 `effectsVol`
    而不是 `musicVol`。
- en: Assign the results of `GetEffectsLevelFromMixer` to the `effectsSlider` variable
    in the `Awake` function. Use the `musicSlider` variable for reference.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Awake` 函数中将 `GetEffectsLevelFromMixer` 的结果分配给 `effectsSlider` 变量。使用 `musicSlider`
    变量作为参考。
- en: Give it a go – if you're struggling, check out the `Complete` folder in this
    book's GitHub repository.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 – 如果你遇到困难，请查看本书 GitHub 存储库中的 `Complete` 文件夹。
- en: Save the script and return to the Unity Editor. Play the first level, change
    the volume, quit the game, and return to the first level to see if our volume
    has been saved for the music and effects sliders.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并返回到 Unity 编辑器。播放第一关，调整音量，退出游戏，然后返回到第一关，查看我们的音量是否已保存到音乐和效果滑块。
- en: Now, we will move on and learn how to store and send data in a slightly different
    way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续学习如何以稍微不同的方式存储和发送数据。
- en: JSON and storing game stats
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON 和存储游戏统计数据
- en: JSON is great for creating, storing, and updating information across our game.
    As we mentioned earlier in this chapter, JSON is typically used for sending data
    from our game to a server online where the JSON data can be delivered to another
    set of data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 非常适合在我们的游戏中创建、存储和更新信息。正如我们在本章前面提到的，JSON 通常用于将游戏中的数据发送到在线服务器，JSON 数据可以传递到另一组数据。
- en: The best way JSON was explained to me is with an analogy of me being at a restaurant,
    sitting at a table (my game); the waiter comes over and takes my (JSON) order,
    then sends it to the kitchen (the online server). Finally, the waiter returns
    with my food.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我对 JSON 的最佳解释是一个类比，我就像在一家餐厅，坐在餐桌旁（我的游戏）；服务员过来，接收我的（JSON）订单，然后将其发送到厨房（在线服务器）。最后，服务员带着我的食物回来。
- en: With regards to coding JSON, we are storing variables in a single class, then
    serializing the class (object) into data (system memory or file). From there,
    we can transfer this data to an actual file or upload it to a server on a database.
    This whole process can also be reversed, where we take the data and return it
    as an object. This is called deserializing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JSON 编码，我们是在一个单独的类中存储变量，然后序列化这个类（对象）为数据（系统内存或文件）。从那里，我们可以将此数据传输到实际的文件或上传到数据库服务器。整个过程也可以反过来，即我们取数据并将其返回为对象。这被称为反序列化。
- en: Now, let's move on to coding some JSON values.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续编写一些 JSON 值。
- en: Adding JSON variables
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 JSON 变量
- en: The objective of working with JSON is to create a simple way of storing and
    updating data with JSON. In our project, we will provide a simple example of storing
    statistical data for our game. When the player completes the game, we will store
    data and put it in JSON format.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSON 的目的是创建一种简单的方式来存储和更新数据。在我们的项目中，我们将提供一个存储游戏统计数据的简单示例。当玩家完成游戏时，我们将存储数据并将其放入
    JSON 格式。
- en: 'The three variables we are going to store are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要存储的三个变量如下：
- en: '`livesLeft`: How many lives the player has left'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`livesLeft`：玩家剩余的生命值'
- en: '`completed`: When the player has completed the game'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`completed`：当玩家完成游戏时'
- en: '`score`: Stores the player''s score'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`：存储玩家的得分'
- en: 'Let''s make a start by creating a new script that will receive our game''s
    three statistical updates. These will then be converted into JSON format. Follow
    these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的脚本开始，该脚本将接收我们游戏的三个统计更新。然后，这些更新将被转换为 JSON 格式。按照以下步骤操作：
- en: Create a new script (if you don't know how to do that, revisit the *Updating
    our camera properties via script* section in [*Chapter 2*](B18381_02_Epub.xhtml#_idTextAnchor048)*,*
    *Adding and Manipulating Objects*).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的脚本（如果你不知道如何操作，请回顾[*第2章*](B18381_02_Epub.xhtml#_idTextAnchor048)*，*添加和操作对象*）中的*通过脚本更新我们的相机属性*部分。
- en: Call the new script `GameStats`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新脚本命名为`GameStats`。
- en: Before we open the `GameStats` script, I recommend that you keep your files
    stored in the `Assets/Script` folder location.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们打开`GameStats`脚本之前，我建议你将文件存储在`Assets/Script`文件夹位置。
- en: 'Next, we can open the `GameStats` script and code in the following variables:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以打开`GameStats`脚本并编写以下变量：
- en: '[PRE10]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how the `GameStats` script doesn't require a library or need to inherit
    `MonoBehaviour`. We don't require either of these extra functionalities.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`GameStats`脚本不需要库或需要继承`MonoBehaviour`。我们不需要这些额外的功能。
- en: When the player completes the game, we will take these three readings and store
    them in JSON format. From there, we can convert this data into a JSON file. This
    process is known as **serialization**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家完成游戏时，我们将这三个读数以 JSON 格式存储。从那里，我们可以将此数据转换为 JSON 文件。这个过程被称为**序列化**。
- en: Serialization/Deserialization
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化/反序列化
- en: These two terms basically refer to the direction that data is stored in.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个术语基本上指的是数据存储的方向。
- en: '**Serialization**: This refers to converting an object from our script and
    turning it into bytes (a file, in our case).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化**：这指的是将我们的脚本中的对象转换为字节（在我们的例子中是一个文件）。'
- en: '**Deserialization**: As you can probably imagine, deserialization is the opposite
    of serialization. This means we are taking our raw data (file) and converting
    it into objects.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**反序列化**：正如你可能想象的那样，反序列化是序列化的相反。这意味着我们正在将我们的原始数据（文件）转换为对象。'
- en: Save the script.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Next, we need to write some code that will update the player's lives, time and
    date, and score. We are going to do this when we play through the game and complete
    level 3\. In this case, we need to go to our `ScenesManager` and update the code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一些代码来更新玩家的生命值、时间和日期以及得分。我们将在玩游戏并完成第 3 级时这样做。在这种情况下，我们需要前往我们的`ScenesManager`并更新代码。
- en: 'To update our `ScenesManager` so that it takes a reading of our player''s stats
    and converts them into JSON format, we need to do the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新我们的`ScenesManager`，使其能够读取玩家的统计数据并将它们转换为 JSON 格式，我们需要做以下操作：
- en: In the Unity Editor, go to where our `ScenesManager` script is. This should
    be in the `Assets/Script` folder.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中，前往我们的`ScenesManager`脚本所在的位置。这应该在`Assets/Script`文件夹中。
- en: Double-click the file to open it in our IDE and scroll down to the point where
    we check to see if the game has ended. This is located in the `GameTimer` method.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件以在 IDE 中打开它，并滚动到检查游戏是否结束的位置。这位于`GameTimer`方法中。
- en: 'The following screenshot shows where in the `ScenesManager` script we need
    to add our new method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 `ScenesManager` 脚本中需要添加我们的新方法的位置：
- en: '![Figure 11.15 – Placement marked where to add new code in our ScenesManager
    script'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.15 – 在我们的 ScenesManager 脚本中标记了添加新代码的位置'
- en: '](img/Figure_11.15_B18381.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.15_B18381.jpg)'
- en: Figure 11.15 – Placement marked where to add new code in our ScenesManager script
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – 在我们的 ScenesManager 脚本中标记了添加新代码的位置
- en: In the preceding screenshot, there is an asterisk (`string` parameter, which
    will be the name of the level we have completed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，有一个星号（`string` 参数，它将是已完成的关卡名称）。
- en: 'Enter the following method name where the ***** is in the previous screenshot:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的截图中的 ***** 处输入以下方法名称：
- en: '[PRE11]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to create the `SendInJsonFormat` method. Scroll down to a point
    in the `ScenesManager` script where we are still inside its class but not another
    method and enter the following:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `SendInJsonFormat` 方法。在 `ScenesManager` 脚本中向下滚动到一个点，我们仍然在其类内部，但不在另一个方法中，并输入以下内容：
- en: '[PRE12]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous code, we go through this series of steps:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下一系列步骤：
- en: We have our `SendInJsonFormat` method, which takes a `string` parameter.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个 `SendInJsonFormat` 方法，它接受一个 `string` 参数。
- en: Inside the `SendInJsonFormat` method, we set an `if` statement that checks if
    the `lastLevel` string contains the `level3` value.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SendInJsonFormat` 方法内部，我们设置了一个 `if` 语句，检查 `lastLevel` 字符串是否包含 `level3` 值。
- en: 'If `lastLevel` is equal to the `level3` string, we go through the following
    steps inside the `if` statement:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `lastLevel` 等于 `level3` 字符串，我们将在 `if` 语句内部执行以下步骤：
- en: We create an instance of the `GameStats` class we made earlier in this chapter.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `GameStats` 类的实例，该类是在本章早期创建的。
- en: We access its `livesLeft` `public` variable and apply the static `playerLives`
    variable from the `GameManager` class.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们访问其 `livesLeft` `public` 变量，并应用来自 `GameManager` 类的静态 `playerLives` 变量。
- en: The next variable shows the date and time we completed the game. We send the
    command from the `System` library, which gives us the date and time, and we cast
    this as a `string` (`ToString()`). We send this result to the `gameStats` instance
    into the `completed` variable.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个变量显示了我们完成游戏的日期和时间。我们从 `System` 库中发送命令，该库提供了日期和时间，并将其转换为 `string`（`ToString()`）。我们将此结果发送到
    `gameStats` 实例的 `completed` 变量中。
- en: The last variable we send data is the player's score. We get this from the `playerScore`
    `static` variable from our `ScoreManager` class.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们发送数据的最后一个变量是玩家的得分。我们从 `ScoreManager` 类的 `playerScore` `static` 变量中获取它。
- en: Now that we have applied the three variables to our `gameStats` instance, we
    can use Unity's `JsonUtility` class to send our `gameStats` into the `ToJson`
    function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将三个变量应用到我们的 `gameStats` 实例上，我们可以使用 Unity 的 `JsonUtility` 类将我们的 `gameStats`
    发送到 `ToJson` 函数。
- en: We can also make the JSON data readable by adding `true` to the parameter so
    that when we send a `log` command to the console to see that this has worked correctly,
    we can read the results.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过将 `true` 添加到参数中来使 JSON 数据可读，这样当我们向控制台发送 `log` 命令以查看此操作是否正确执行时，我们可以读取结果。
- en: Save the script and jump back into the Unity Editor and complete the game from
    the `bootUp` scene to the `gameOver` scene.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本，然后回到 Unity 编辑器，并从 `bootUp` 场景完成游戏到 `gameOver` 场景。
- en: 'The following screenshot shows the console log when I played through the game
    and completed level 3:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我在玩游戏并完成第 3 级时控制台的日志输出：
- en: '![Figure 11.16 – Console window giving stats about our game'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.16 – 显示我们游戏统计信息的控制台窗口'
- en: '](img/Figure_11.16_B18381.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.16_B18381.jpg)'
- en: Figure 11.16 – Console window giving stats about our game
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – 显示我们游戏统计信息的控制台窗口
- en: As you can see, we have the data from our script but displayed in JSON format.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有来自我们脚本的但以 JSON 格式显示的数据。
- en: This information can be saved to a physical file or can be sent to a server
    to keep a record of our player's gameplay and/or deserialize the results later
    on with our project (check out the following tip if you are interested in this).
    The point is that we are storing and carrying data that can be sent away for us
    or another system to pick up, store, and alter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息可以保存到物理文件，或者可以发送到服务器以记录我们的玩家游戏情况，并在以后的项目中反序列化结果（如果您对此感兴趣，请查看以下提示）。关键是我们在存储和携带数据，这些数据可以被发送出去，供我们或其他系统拾取、存储和修改。
- en: Further Information
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: At this point, we have successfully taken the variables from our object and
    converted them into JSON data format (serialization).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功从我们的对象中提取变量，并将它们转换为 JSON 数据格式（序列化）。
- en: Now, imagine if we altered our data (changed its values) and wanted to bring
    that data back into our game's code and into a class. The reverse method would
    be `GameStats loadJsonData = JsonUtility.FromJson<GameStats>(json);`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们更改了我们的数据（更改其值），并希望将那些数据带回到我们的游戏代码和类中。反向方法将是 `GameStats loadJsonData =
    JsonUtility.FromJson<GameStats>(json);`。
- en: This would update our `GameStats` variables from the JSON file. You can imagine
    that this would be handy for saving and loading data in games.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新我们的 `GameStats` 变量，从 JSON 文件中。您可以想象这将方便在游戏中保存和加载数据。
- en: 'Next, we will take the most current JSON data file and send it to the device
    (the machine we play the game on). To make and store a JSON file containing our
    custom-made stats, do the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将最新的 JSON 数据文件发送到设备（我们玩游戏的那台机器）。为了创建和存储包含我们自定义统计数据的 JSON 文件，请执行以下操作：
- en: Return to the `ScenesManager` script.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `ScenesManager` 脚本。
- en: Scroll to where we created the `SendInJsonFormat` method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到我们创建的 `SendInJsonFormat` 方法处。
- en: 'Within the method''s `if` statement, at the bottom, inside the scope of the
    `if` statement, add the following two lines of code:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法的 `if` 语句的底部，在 `if` 语句的作用域内，添加以下两行代码：
- en: '[PRE13]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code block shows that we don't necessarily need to add `Debug.Log`
    and shows us where the next line of code is creating and storing our JSON file.
    Each platform will store data in different folders. For more information on the
    locations for different platforms, please refer to Unity's own documentation about
    persistent data at [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块显示我们不一定需要添加 `Debug.Log`，并显示了下一行代码创建和存储我们的 JSON 文件的位置。每个平台都会在不同的文件夹中存储数据。有关不同平台的位置信息，请参阅
    Unity 关于持久数据的官方文档 [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)。
- en: 'My system is a Windows PC, so `Debug.Log` will display the following location
    on my system:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我的系统是 Windows PC，所以 `Debug.Log` 将在我的系统上显示以下位置：
- en: '![Figure 11.17 – Windows location of JSON file'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.17 – Windows location of JSON file'
- en: '](img/Figure_11.17_B18381.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.17_B18381.jpg](img/Figure_11.17_B18381.jpg)'
- en: Figure 11.17 – Windows location of JSON file
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – JSON 文件的 Windows 位置
- en: The second line of the code we just entered is using a system library and uses
    a function (`Application.persistentDataPath`) that will refer to our device's
    local storage. Then, after the function, we add the name we want to use to refer
    to our JSON file (`/GameStatsSaved.json`), along with the format type, which is
    `json`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚输入的代码的第二行正在使用系统库，并使用一个函数 (`Application.persistentDataPath`)，该函数将引用我们的设备本地存储。然后，在函数之后，我们添加了我们想要用来引用我们的
    JSON 文件的名字 (`/GameStatsSaved.json`)，以及格式类型，即 `json`。
- en: Save the script.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: 'Return to the Unity Editor, play all the way to the end of the game, and go
    to the location that is displayed on the console screen. The following screenshot
    shows the location of the file that our game has made:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Unity 编辑器，玩到游戏结束，并前往控制台屏幕上显示的位置。以下截图显示了我们的游戏创建的文件位置：
- en: '![Figure 11.18 – Windows location of our JSON file'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.18 – Windows location of our JSON file'
- en: '](img/Figure_11.18_B18381.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.18_B18381.jpg](img/Figure_11.18_B18381.jpg)'
- en: Figure 11.18 – Windows location of our JSON file
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – 我们 JSON 文件的 Windows 位置
- en: 'Double-click the file to view its content. As you will see, this is where our
    game''s stats are kept, as shown in the following screenshot:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件以查看其内容。正如您将看到的，这是我们游戏统计数据存储的地方，如下面的截图所示：
- en: '![Figure 11.19 – The content of our JSON file'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.19 – The content of our JSON file'
- en: '](img/Figure_11.19_B18381.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.19_B18381.jpg](img/Figure_11.19_B18381.jpg)'
- en: Figure 11.19 – The content of our JSON file
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19 – 我们 JSON 文件的内容
- en: With this, we are now aware of how to store non-sensitive data such as our game's
    volume (`PlayerPrefs`), as well as how to create, store, and send other types
    of data in JSON format.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在知道了如何存储非敏感数据，例如我们的游戏音量 (`PlayerPrefs`)，以及如何创建、存储和发送其他类型的 JSON 格式数据。
- en: Now, let's summarize this chapter.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结本章内容。
- en: Further Information
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: For more information about all of these events, check the official Unity documentation
    at [https://docs.unity3d.com/Manual/UnityAnalyticsEvents.html](https://docs.unity3d.com/Manual/UnityAnalyticsEvents.html).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于所有这些事件的信息，请查看官方 Unity 文档 [https://docs.unity3d.com/Manual/UnityAnalyticsEvents.html](https://docs.unity3d.com/Manual/UnityAnalyticsEvents.html)。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter covered a variety of topics, including understanding Unity's Audio
    Mixer, which is where we can control the sounds in our game, and altering levels
    with our script. Then, we moved on and looked at storing data with `PlayerPrefs`
    and custom storage in JSON format in order to recognize the differences between
    the two ways of storing data. For JSON, we converted our data from object-based
    data into bytes and stored the results in a file (serialization).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了各种主题，包括理解Unity的音频混音器，这是我们控制游戏中的声音的地方，以及使用我们的脚本调整级别。然后，我们继续前进，探讨了使用`PlayerPrefs`和JSON格式的自定义存储来存储数据，以便识别两种存储数据方式之间的差异。对于JSON，我们将基于对象的数据转换为字节，并将结果存储在文件中（序列化）。
- en: In future projects, you will likely make use of the coding we covered in the
    last two chapters regarding storing and reapplying data such as music and sound
    effect volume sliders. Hopefully, you will also be able to go further with this
    data by using other components in your projects so that your game can send out
    data onto the cloud and monitor your players' progress as helpful feedback to
    improve development.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来的项目中，你可能会用到我们在前两章中介绍的编码，比如存储和重新应用数据，例如音乐和音效音量滑块。希望你能通过在项目中使用其他组件，进一步利用这些数据，使你的游戏能够将数据发送到云端，并监控玩家的进度，作为有助于改进开发的反馈。
- en: In the next chapter, we are going to look at pathfinding and how to improve
    the overall performance of our game.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨路径查找以及如何提高我们游戏的整体性能。
