- en: Chapter 12. F# and OOP Principles/Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。F#和面向对象原则/设计模式
- en: Previous chapters were aimed at developing and honing your taste for the usage
    patterns of functional programming, paying very occasional attention to comparison
    with OOP arrangements. This chapter caters to those of you who have an OOP background
    and may be anxiously expecting for the book to begin meticulously porting each
    and every one of the of **23 original Gang of Four object-oriented design patterns**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns)
    ), one by one into F#.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章旨在发展和磨练你对函数式编程使用模式的品味，偶尔会关注与面向对象安排的比较。这一章是为那些有面向对象背景并且可能焦急地期待着这本书开始细致地将**23个原始的四人帮面向对象设计模式**
    ([https://en.wikipedia.org/wiki/Design_Patterns](https://en.wikipedia.org/wiki/Design_Patterns))）逐个移植到F#的人准备的。
- en: I may disappoint you, as all topics covered so far indicate that staying with
    the functional-first facet of F# promoted by the book may make some of these patterns
    just irrelevant, intrinsic, or ubiquitous. In other words, the original patterns
    may morph into something much less fundamental compared to their role in the OOP
    world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能让你失望，因为到目前为止所涵盖的所有主题都表明，坚持书中提倡的F#的函数优先特性可能会使一些模式变得无关紧要、固有或普遍。换句话说，原始模式可能演变成与面向对象世界中的角色相比不那么根本的东西。
- en: A similar transformation applies to OOP principles, collectively known as **SOLID**
    ([https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design))
    ). That is, from a functional programming standpoint, these principles may become
    either granted, irrelevant, or just respected, without much extra effort required
    from developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的转变也适用于面向对象的原则，统称为**SOLID** ([https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)))）。也就是说，从函数式编程的角度来看，这些原则可能变得要么是默认的、无关紧要的，或者只是受到尊重，而不需要开发者付出太多的额外努力。
- en: 'The goal of this chapter is to briefly demonstrate some cases of the morphing
    outlined in the preceding paragraphs. In this chapter, we will take a look at
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是简要展示前述段落中概述的演变案例。在本章中，我们将探讨以下主题：
- en: How OOP SOLID principles get morphed within the functional-first paradigm, and
    what exactly happens to each of these five pillars
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在以函数优先的范式内将面向对象（OOP）的SOLID原则进行演变，以及这五个支柱中每一个具体发生了什么变化
- en: How some of the specific design patterns (Command, Template, Strategy) diminish
    in role, or just become simply equivalent to bits and pieces of the functional-first
    paradigm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些具体的设计模式（命令、模板、策略）如何减少其作用，或者仅仅等同于函数优先范式的一些片段
- en: I will not attempt to lay out an exhaustive, thorough review. In the end, this
    book aims to develop skills and techniques of the functional-first paradigm, not
    any other paradigms supported by F#.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会尝试进行详尽无遗的综述。最终，这本书旨在发展函数优先范式的技能和技术，而不是F#支持的任何其他范式。
- en: Morphing SOLID principles
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则的演变
- en: Let's consider how the functional programming paradigm morphs the five basic
    principles of the object-oriented design known under this bold acronym of **SOLID**
    .
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑函数式编程范式如何演变这个以粗体字母**SOLID**命名的面向对象设计的基本原则。
- en: Single Responsibility Principle
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'The gist of **Single Responsibility Principle** ([https://en.wikipedia.org/wiki/Single_responsibility_principle](https://en.wikipedia.org/wiki/Single_responsibility_principle)
    ) ( **SRP** ), standing for the letter "S" in **SOLID** , in OOP terms is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**单一职责原则** ([https://en.wikipedia.org/wiki/Single_responsibility_principle](https://en.wikipedia.org/wiki/Single_responsibility_principle))（**SRP**），代表**SOLID**中的字母"S"，在面向对象术语中是：'
- en: '*"There should never be more than one reason for a class to change"*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个类不应该有超过一个改变的理由"*'
- en: In other words, if a class implementation is to be changed in response to two
    or more independent modifications to a functionality, this is an evidence of the
    **Single Responsibility Principle** ( **SRP** ) violation in its design. Following
    this principle in the OOP world entails designs consisting of many lean classes
    in lieu of fewer but bulkier classes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果一个类的实现需要响应两个或更多独立的功能性修改，这将是其设计中违反**单一职责原则**（**SRP**）的证据。在面向对象世界中遵循这一原则意味着设计由许多精简的类组成，而不是较少但更庞大的类。
- en: 'If we consider a function as a degenerate case of class free of encapsulated
    data and having only the single method, then this is nothing but a quintessence
    of SRP applied. The following figure illustrates this transformation:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将函数视为一个没有封装数据且只有一个方法的类退化情况，那么这不过是单一职责原则（SRP）的精髓。以下图展示了这一转换：
- en: '![Single Responsibility Principle](img/Image00060.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![单一职责原则](img/Image00060.jpg)'
- en: Honoring Single Responsibility Principle in functional programming
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中尊重单一职责原则
- en: When we program in idiomatic F#, we compose the functions of a single purpose
    together. In other words, SRP is naturally promoted and enforced in F#.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用惯用的F#进行编程时，我们将单一目的的函数组合在一起。换句话说，SRP在F#中自然得到提升和强制执行。
- en: Open/Closed Principle
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: '**Open/Closed Principle** ([https://en.wikipedia.org/wiki/Open/closed_principle](https://en.wikipedia.org/wiki/Open/closed_principle)
    ) ( **OCP** ), representing the letter "O" in **SOLID** , states that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放/封闭原则** ([https://en.wikipedia.org/wiki/Open/closed_principle](https://en.wikipedia.org/wiki/Open/closed_principle)
    ) ( **OCP** )，代表**SOLID**中的字母"O"，指出：'
- en: '*"software entities (classes, modules, functions, etc.) should be open for
    extension, but closed for modification"*'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"软件实体（类、模块、函数等）应当对扩展开放，但对修改封闭"*'
- en: 'In the pure OOP realm, such a property is granted by **inheritance** , both
    by direct **implementation inheritance** (that is, substituting a superclass with
    its subclass) and by **polymorphic implementation** (that is, just another implementation
    of a given interface that keeps itself closed to a modification but is open to
    additionally implementing other interfaces). Both of these forms of OCP are near,
    clear, and dear to the OOP facet of F#; however, they are not idiomatic to any
    extent. The functional-first mechanisms of extension in idiomatic F# are type
    augmentation and composition. The following figure serves as a cheat sheet here,
    as we have devoted a fair amount of attention in the book to these extension methods:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯面向对象领域，这种属性是通过**继承**赋予的，无论是直接的**实现继承**（即用子类替换超类）还是**多态实现**（即给定接口的另一种实现，它对自己封闭于修改，但开放于额外实现其他接口）。这两种形式的OCP在F#的面向对象方面几乎是清晰、亲切的；然而，它们在F#中并不构成习惯。F#中函数式首选的扩展机制是类型增强和组合。以下图作为备忘单，因为我们已在书中对这些扩展方法投入了大量关注：
- en: '![Open/Closed Principle](img/Image00061.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![开放/封闭原则](img/Image00061.jpg)'
- en: Honoring Open/Closed Principle in functional programming
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中尊重开放/封闭原则
- en: The figure above shows in a very compelling manner how simple, succinct, and
    to the point the extensibility mechanics is within the functional-first idioms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上图以非常引人入胜的方式展示了在函数式首选习惯中，扩展机制是如何简单、简洁且切中要害的。
- en: Liskov Substitution Principle
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Liskov替换原则
- en: 'The letter "L" in **SOLID** comes from **Liskov Substitution Principle** ([https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
    ) ( **LSP** ) that states:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID**中的字母"L"来自**Liskov替换原则** ([https://en.wikipedia.org/wiki/Liskov_substitution_principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
    ) ( **LSP** )，该原则指出：'
- en: '*"objects in a program should be replaceable with instances of their subtypes
    without altering the correctness of that program"*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"程序中的对象应当可以用其子类型实例替换，而不会改变该程序的正确性"*'
- en: 'As formulated **LSP** is concerned purely with OOP inheritance, it does not
    seem related to idiomatic F#. Nevertheless, I would mention at least the following
    three F# functional-first idioms that strongly enforce this principle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如此表述的**LSP**纯粹关注于面向对象继承，这似乎与惯用的F#无关。然而，我至少要提到以下三个严格遵循此原则的F#函数式首选习惯：
- en: '**Referential transparency** : If a function is pure and produces a certain
    result given an argument of type `T` , then given the corresponding instance of
    type `S` that is a subtype of `T` as an argument, it must produce the identical
    result indeed'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用透明性**：如果一个函数是纯函数并且给定一个类型`T`的参数产生一个确定的结果，那么给定一个类型`S`的相应实例作为参数，其中`S`是`T`的子类型，它必须确实产生相同的结果'
- en: '**F# function argument type substitution** : Based on what has been discussed
    in the preceding bullet point, if we have a type `''S` that derives from type
    `''T` , then an instance of `''S` can be used as a substitute for the corresponding
    instance of `''T` ; so for the following function `f` : `''T -> ''R` , expression
    `f(''S())` *does not require any coercion* of the argument, as the following snippet
    demonstrates (`Ch12_1.fsx` ):'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F# 函数参数类型替换**：基于前面讨论的要点，如果我们有一个从类型 `''T` 继承的类型 `''S`，那么 `''S` 的一个实例可以用作 `''T`
    对应实例的替代；因此，对于以下函数 `f`：`''T -> ''R`，表达式 `f(''S())` *不需要任何强制转换*，如下代码片段所示 (`Ch12_1.fsx`
    )：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Immutability** : If we have built a valid immutable instance of `''S` , it
    cannot anyhow be invalidated by using it as a substitute for the instance of `''T`
    by the virtue of its immutability'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性**：如果我们构建了一个有效的不可变实例 `''S`，则不能通过将其用作 `''T` 实例的替代来利用其不可变性而使其无效'
- en: Interface Segregation Principle
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: 'Standing for the letter "I" in **SOLID** , **Interface Segregation Principle**
    ([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    ) ( **ISP** ) claims that:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SOLID** 原则中代表字母 "I" 的 **接口隔离原则** ([https://en.wikipedia.org/wiki/Interface_segregation_principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
    ) ( **ISP** ) 声称：
- en: '*"many client-specific interfaces are better than one general-purpose interface"*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"许多特定于客户端的接口比一个通用接口更好"*'
- en: In other words, an interface that a client is linked with should not introduce
    dependencies that are not used by the client. The **ISP** is just SRP being applied
    to interfaces. Idiomatic F# fully supports ISP by statelessness and naturally
    segregated functions representing interfaces that contain exactly one method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个客户端与之关联的接口不应引入客户端未使用的依赖。**ISP** 只是 SRP 在接口上的应用。惯用的 F# 通过无状态和自然隔离的函数（代表包含恰好一个方法的接口）完全支持
    ISP。
- en: Dependency Inversion Principle
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: 'The letter " **D** " in **SOLID** stands for **Dependency Inversion Principle**
    ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    ) ( **DIP** ) stating:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOLID** 原则中的字母 " **D** " 代表 **依赖倒置原则** ([https://en.wikipedia.org/wiki/Dependency_inversion_principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
    ) ( **DIP** )，该原则指出：'
- en: '*"depend upon abstractions, do not depend upon concretions"*'
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"依赖抽象，不要依赖具体实现"*'
- en: 'The following figure shows how **DIP** is achieved in OOP: if an instance of
    class `A` refers the instance of class `B` , this is a direct dependency violating
    DIP. This problem may be fixed by making an instance of class `A` dependent on
    the interface `IB` . So far, so good, but something must implement `IB` , right?
    Let it be the instance of class `B` , which is now a dependent of `IB` , so the
    inversion of dependency takes place.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在面向对象编程（OOP）中如何实现 **DIP**：如果类 `A` 的一个实例引用了类 `B` 的一个实例，这违反了 DIP 的直接依赖。这个问题可以通过使类
    `A` 依赖于接口 `IB` 来解决。到目前为止，一切顺利，但必须有人实现 `IB`，对吧？让它成为类 `B` 的一个实例，现在它是 `IB` 的一个依赖，因此发生了依赖反转。
- en: 'It is easy to notice that in idiomatic F#, the role of dependency inversion
    plays a vanilla higher-order function: for example, function `f` has a parameter
    function, `g`  which is used in defining `f` . When `f` is called, any of the
    argument functions `a` , `b` , or `c` may play the role of `g` as long as their
    signatures conform to `g` :'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易注意到，在惯用的 F# 中，依赖倒置的作用就像一个普通的更高阶函数：例如，函数 `f` 有一个参数函数 `g`，它在定义 `f` 时被使用。当调用
    `f` 时，任何符合 `g` 签名的参数函数 `a`、`b` 或 `c` 都可以扮演 `g` 的角色：
- en: '![Dependency Inversion Principle](img/Image00062.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![依赖倒置原则](img/Image00062.jpg)'
- en: Honoring Dependency Inversion Principle in functional programming
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中遵循依赖倒置原则
- en: Diminishing patterns
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少模式
- en: Similarly to **SOLID** principles, many OOP design patterns in the context of
    idiomatic functional-first F# either diminish (sometimes to the extent of disappearing)
    or significantly morph. Let's take a quick look at some instances of such transformation.
    I will be using samples taken from the code base I authored, implementing payment
    applications for Jet.com. Samples are somewhat simplified to align with the book
    format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 **SOLID** 原则，在惯用的以函数式编程为第一语言的 F# 上下文中，许多面向对象的设计模式要么减少（有时减少到消失），要么显著变形。让我们快速看一下这种转换的一些实例。我将使用我从代码库中提取的样本，这些样本用于实现
    Jet.com 的支付应用程序。样本被简化以符合书籍格式。
- en: The Command design pattern
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: The **Command Design Pattern** ([https://en.wikipedia.org/wiki/Command_pattern](https://en.wikipedia.org/wiki/Command_pattern)
    ) in OOP stands for a behavioral design pattern where all the information required
    to perform an action at a later time is encapsulated in an object. But wait a
    minute; doesn't this exactly coincide with what a function is? That's right; almost
    any idiomatic F# pattern of dealing with a higher-order function to traverse a
    data structure while applying a lower-order function to each element can be considered
    an occurrence of the Command pattern. Mapping, folding, you name it - all fit
    into this category. Doing what the Command pattern prescribes is an ubiquitous
    idiom in functional-first F#.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令设计模式** ([https://zh.wikipedia.org/wiki/命令模式](https://zh.wikipedia.org/wiki/命令模式)
    ) 在面向对象编程中代表了一种行为设计模式，其中所有在稍后执行动作所需的信息都被封装在一个对象中。但是等等；这难道不是与函数的定义完全一致吗？没错；几乎任何使用高阶函数遍历数据结构并对其每个元素应用低阶函数的
    F# 习惯用法都可以被视为命令模式的实例。映射、折叠，无论你叫它什么——所有这些都属于这个类别。按照命令模式的规定行事是函数式优先的 F# 中的一个普遍习语。'
- en: 'Let''s consider an example: an order flow of a merchant participating in an
    e-commerce marketplace consists of transactions, each representing either **sale**
    or **refund** . By taking any continuous sequence of elements of the order flow,
    its running balance can be found. Now, the factor that makes things more interesting
    is that some orders may be nullified during an established period of time since
    their introduction being canceled. We are charged with tracking a running total
    for the marketplace finance department.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子：一个参与电子商务市场的商家的订单流程由一系列交易组成，每个交易代表**销售**或**退款**。通过取订单流程的任何连续元素序列，可以找到其运行余额。现在，使事情更有趣的因素是，一些订单在引入后的一段时间内可能被取消，从而被取消。我们负责为市场财务部门跟踪运行总账。
- en: 'The functional-first aspect of F# allows for a very clean, idiomatic solution.
    I begin with two core domain objects, representing order types and customer transactions,
    combining the order type and its cost of goods (`Ch12_2.fsx` ):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: F# 的函数式优先特性允许我们有一个非常干净、习惯用法式的解决方案。我开始于两个核心领域对象，代表订单类型和客户交易，结合订单类型及其商品成本（`Ch12_2.fsx`）：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I continue with two core functions accounting for the total based on the order
    type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我继续使用两个核心函数，根据订单类型计算总数：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Equipped with this, it is time to define our **commands** in the pattern''s
    sense. Both `Order` and `Cancellation` will take a running total and a transaction
    and return a new running total adjusted accordingly (note that `Cancellation`
    mirrors `Order` in terms of the total):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这些知识，现在是时候在模式的意义上定义我们的**命令**了。`Order`和`Cancellation`都将接受一个运行总账和一笔交易，并返回一个相应调整后的新运行总账（注意，`Cancellation`在总账方面与`Order`相对应）：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I''m done! Let me just demonstrate the built code in action by applying it
    to a sample order flow in FSI. The results are presented in the following screenshot,
    where a sequence of some `orderFlow` transactions is run through orders yielding
    `totalForward` of $271.86 and then through cancelation, eventually yielding the
    expected running total `totalBackward` of $0.00:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我完成了！让我通过在 FSI 中应用一个示例订单流程来演示构建的代码的实际效果。结果在下面的屏幕截图中展示，其中一系列`orderFlow`交易通过订单产生`totalForward`为271.86美元，然后通过取消操作，最终产生预期的运行总账`totalBackward`为0.00美元：
- en: '![The Command design pattern](img/Image00063.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![命令设计模式](img/Image00063.jpg)'
- en: Command pattern as idiomatic F# folding
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式作为习惯用法 F# 折叠
- en: The Template design pattern
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板设计模式
- en: The **Template design pattern** ([https://en.wikipedia.org/wiki/Template_method_pattern](https://en.wikipedia.org/wiki/Template_method_pattern)
    ) in OOP defines a common skeleton of an algorithm or a program, of which components
    can be overwritten but the general structure stays unchanged. Again, achieving
    this effect following the route that has functions as first class objects is trivial.
    For example, passing functions as parameters will work nicely, so the pattern
    diminishes to non-existing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板设计模式** ([https://zh.wikipedia.org/wiki/模板方法模式](https://zh.wikipedia.org/wiki/模板方法模式)
    ) 在面向对象编程中定义了一个算法或程序的共同骨架，其中组件可以被重写，但总体结构保持不变。再次强调，通过将函数作为一等对象来实现这一效果是微不足道的。例如，传递函数作为参数将工作得很好，因此这个模式就变得无关紧要了。'
- en: Idiomatic F# is even richer than this approach, allowing functions to cohesively
    keep participating in an interface and providing any of the concrete implementations
    in the form of an object expression.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 惯用 F# 的方法甚至比这更丰富，它允许函数连贯地参与接口，并以对象表达式的形式提供任何具体的实现。
- en: 'Let''s turn to a corresponding code sample taken from the enterprise codebase
    of Jet.com payment applications. The process of paying a partner participating
    in the Jet.com marketplace consists of three consecutive steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向从 Jet.com 支付应用程序的企业代码库中提取的相应代码示例。在 Jet.com 市场中参与支付的合作伙伴的支付过程包括三个连续的步骤：
- en: Obtaining payment requisites and the amount due based on the merchant ID.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据商户 ID 获取支付需求和应付金额。
- en: Formatting a payment for the use of a specific payment method.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化特定支付方式的支付。
- en: Submitting payment advice to the bank for execution.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向银行提交支付建议以执行。
- en: 'The template keeps the preceding parts together, allowing you to change each
    of the pieces to the case at the same time. As shown in the previous example,
    I begin with defining a few core domain entities (`Ch12_3.fsx` ):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '模板将前面的部分保持在一起，允许你同时更改每个部分以适应情况。正如前一个示例所示，我首先定义了一些核心领域实体 (`Ch12_3.fsx` ):'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `PayBy` represents a specific payment instrument (`Check` /`ACH` /`Wire`
    ), formatted `Payment` is just a type abbreviation, `BankReqs` represents a merchant's
    bank requisites for the account to accept the deposited payment, and `Merchant`
    wires together the merchant ID and bank requisites.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PayBy` 代表一种特定的支付工具（支票/`ACH`/电汇），格式化的 `Payment` 只是一个类型缩写，`BankReqs` 代表商户的银行要求，以便账户接受存入的支付，而
    `Merchant` 将商户 ID 和银行要求连接起来。
- en: 'Now I define the template as an interface that reflects parts of the payment
    process being cohesive (`Ch12_3.fsx` ):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我定义了一个模板作为接口，它反映了支付流程的部分连贯性 (`Ch12_3.fsx` ):'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This piece is quite straightforward; `GetPaymentDue` retrieves the given merchant's
    requisites and payment amount due from the relevant persisted store, `FormatPayment`
    performs the required payment advice formatting, and `SubmitPayment` takes care
    of delivering the advice to Jet's bank. Note that I intentionally didn't specify
    the payment format here as this detail may be delayed for the implementation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分相当直接；`GetPaymentDue` 从相关持久存储中检索给定商户的要求和应付金额，`FormatPayment` 执行所需的支付建议格式化，而
    `SubmitPayment` 负责将建议交付给 Jet 的银行。请注意，我故意没有在这里指定支付格式，因为这个细节可能需要延迟到实现阶段。
- en: 'Then, here, I provide a specific (mock) implementation for `ITemplate` . Still,
    you can see that this arrangement allows plenty of flexibility; in particular,
    I made a specific payment instrument a parameter of the implementation (`Ch12_3.fsx`
    ):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，在这里，我为 `ITemplate` 提供了一个具体的（模拟）实现。尽管如此，你可以看到这种安排提供了很大的灵活性；特别是，我将特定的支付工具作为实现的一个参数
    (`Ch12_3.fsx` ):'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, I wrap everything together into the function using the template (`Ch12_3.fsx`
    ):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我使用模板将所有内容封装到函数中 (`Ch12_3.fsx` ):'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As usual, in order to see this code in action, I turn to FSI, presenting the
    results of running some mock payments in the following screenshot. I''ve omitted
    the complete script source from here for the sake of fitting the figure within
    a single book page:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，为了看到这段代码的实际效果，我转向 FSI，展示了以下截图中的模拟支付结果。出于使图示适应单页书的考虑，我省略了完整的脚本源代码：
- en: '![The Template design pattern](img/Image00064.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![模板设计模式](img/Image00064.jpg)'
- en: Template pattern disappearing in idiomatic F#
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模板模式在 F# 中的惯用表达消失
- en: The Strategy pattern
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略模式
- en: The **Strategy pattern** ([https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    ) is simply about adjusting the algorithm behavior in runtime by implementing
    a family of algorithms and using them interchangeably. Once again, what could
    suit this purpose better than a functional-first setting with functions as first-class
    language citizens?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**策略模式** ([https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern)
    ) 简单来说，就是通过实现一系列算法并在运行时相互替换来调整算法的行为。再次强调，还有什么比将函数作为一等公民的功能优先设置更适合这个目的呢？'
- en: To illustrate the use of the Strategy pattern, I will use just another use case
    from Jet.com's Payment system. In its shipping operations, Jet.com uses multiple
    carriers, and due to the significant volume of shipments, it processes carrier
    invoices electronically. The gist of this processing is the loading of invoices
    from each carrier into a staging data table, and then merging the contents of
    this data table with corresponding persistent stores in the **upsert** ([https://en.wikipedia.org/wiki/Merge_(SQL)](https://en.wikipedia.org/wiki/Merge_(SQL))
    ) manner.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明策略模式的使用，我将使用来自Jet.com支付系统的一个另一个用例。在其运输操作中，Jet.com使用多个承运人，由于运输量巨大，它通过电子方式处理承运人发票。这种处理的核心是将每个承运人的发票加载到一个临时数据表中，然后以**upsert**（[https://en.wikipedia.org/wiki/Merge_(SQL)](https://en.wikipedia.org/wiki/Merge_(SQL)））的方式合并这个数据表的内容。
- en: 'I approach the implementation of this **EDI** ([https://en.wikipedia.org/wiki/Electronic_data_interchange](https://en.wikipedia.org/wiki/Electronic_data_interchange)
    ) by outlining the implementation of the core behavior first (`Ch12_4.fsx` ):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过首先概述核心行为的实现来实施这个**EDI**（[https://en.wikipedia.org/wiki/Electronic_data_interchange](https://en.wikipedia.org/wiki/Electronic_data_interchange)）接口的实现（`Ch12_4.fsx`）：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding snippet indicates that the supported invoice formats are either
    `Excel` or `CSV` , and there are two generic functions available to load invoices,
    somehow delivered to a location in any acceptable format, into a data table, and
    to merge the filled data table with the existing contents of the corresponding
    persistent store.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段表明，支持的发票格式是`Excel`或`CSV`，并且有两个通用函数可用于将发票加载到数据表中，这些发票以任何可接受的格式交付到某个位置，并将填充的数据表与相应持久存储的现有内容合并。
- en: 'So far, so good; these two functions may be made accessible via an interface
    whose implementation is to be specific for each of the supported carriers (`Ch12_4.fsx`
    ):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；这两个函数可能通过一个接口来访问，该接口的实现将针对每个支持的承运人具体化（`Ch12_4.fsx`）：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, I provide specific implementations of the preceding interface for two
    of the carriers Jet.com engages into order shipments, namely FedEX and LaserShip
    (`Ch12_4.fsx` ):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我为Jet.com用于订单运输的两个承运人——联邦快递（FedEX）和LaserShip——提供了前面接口的具体实现（`Ch12_4.fsx`）：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now stay with me; we have two objects of the `ILoadVendorInvoices` type, each
    encapsulating its own carrier specifics. However, we can use them uniformly for
    EDI, as shown in the following function (`Ch12_4.fsx` ):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请跟我来；我们有两个`ILoadVendorInvoices`类型的对象，每个对象封装了自己的承运人特定信息。然而，我们可以统一地使用它们进行EDI，如下面的函数所示（`Ch12_4.fsx`）：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just beautiful; now we can use instances of `LoadFedex` and `LoadLasership`
    to switch the behavior of EDI processing exactly in a manner the Strategy pattern
    prescribes. Let''s turn to FSI for the demonstration. The following screenshot
    shows the results:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 真是太美了；现在我们可以使用`LoadFedex`和`LoadLasership`的实例来精确地切换EDI处理的模式，这正是策略模式所规定的。让我们转向FSI进行演示。以下截图显示了结果：
- en: '![The Strategy pattern](img/Image00065.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式](img/Image00065.jpg)'
- en: Strategy pattern expressed using F# idioms
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用F#惯用语法表达的策略模式
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter highlighted that the functional-first approach does not blindly
    contradicts principles and patterns of object-oriented programming. Sometimes
    it also supports and amplifies them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章强调了功能优先的方法并不盲目地与面向对象编程的原则和模式相矛盾。有时它也支持并增强了它们。
- en: I'm going to devote the final chapter of this book to the subject of troubleshooting
    functional-first code, as it has certain specifics.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把本书的最后一章奉献给功能优先代码的故障排除主题，因为它有一些特定的内容。
