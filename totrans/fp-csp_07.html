<html><head></head><body>
		<div id="_idContainer025">
			<h1 id="_idParaDest-235" class="chapter-number"><a id="_idTextAnchor332"/>7</h1>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor333"/>Functors and Monads</h1>
			<p>Moving from higher-order functions and delegates, we step into the world of functors, key players in functional programming. They allow us to work with wrapped values, such as lists or computational outcomes, in a structured way. This chapter explores <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Functors</span></li>
				<li><span class="No-Break">Functor laws</span></li>
				<li>Applicative functors <span class="No-Break">and laws</span></li>
				<li>Monads and <span class="No-Break">monad laws</span></li>
			</ul>
			<p>As always, the following are three self-check tasks to help you understand the existing knowledge of functors <span class="No-Break">and monads.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor334"/>Task 1 – Functor usage</h1>
			<p>Given a <strong class="source-inline">Result&lt;List&lt;Tower&gt;, string&gt;</strong> type that represents a list of towers, where <strong class="source-inline">Tower</strong> is a class containing properties such as <strong class="source-inline">Id</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Damage</strong>, the task is to use the <a id="_idIndexMarker387"/>functor concept to apply a function to each tower that appends “(Upgraded)” to the end of its name to indicate that the tower has <span class="No-Break">been upgraded:</span></p>
			<pre class="source-code">
public class Tower
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Damage { get; set; }
}
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(List&lt;Tower&gt; towers)
{
    // Write your code here
}</pre>			<h1 id="_idParaDest-238"><a id="_idTextAnchor335"/>Task 2 – Applicative functor</h1>
			<p>Imagine you have two functions wrapped in the <strong class="source-inline">Result</strong> type: <strong class="source-inline">Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage</strong> checks whether a tower’s <a id="_idIndexMarker388"/>damage is within acceptable limits, and <strong class="source-inline">Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName</strong> checks whether the tower’s name meets certain criteria. Given a <strong class="source-inline">Result&lt;Tower, string&gt;</strong> representing a single tower, use applicative functors to apply both validation functions to the tower, ensuring both <span class="No-Break">validations pass:</span></p>
			<pre class="source-code">
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Damage &lt; 100);
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Name.Length &gt; 5 &amp;&amp; !tower.Name.Contains("BannedWord"));</pre>			<h1 id="_idParaDest-239"><a id="_idTextAnchor336"/>Task 3 – Monad usage</h1>
			<p>Given a <a id="_idIndexMarker389"/>sequence of operations needed to upgrade a tower—<strong class="source-inline">FetchTower</strong>, <strong class="source-inline">UpgradeTower</strong>, and <strong class="source-inline">DeployTower</strong>—with each potentially failing and returning <strong class="source-inline">Result&lt;Tower, string&gt;</strong>, use the monad concept to chain these operations together for a given tower ID. Ensure that if any step fails, the entire operation short-circuits and returns <span class="No-Break">the error:</span></p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; FetchTower(int towerId) { /* Fetches tower based on ID */ }
public Result&lt;Tower, string&gt; UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }
public Result&lt;Tower, string&gt; DeployTower(Tower tower) { /* Attempts to deploy the tower */ }</pre>			<p>If you successfully <a id="_idIndexMarker390"/>wrote the solutions for all three tasks, you are awesome! If you struggle or don’t know how to solve the tasks now, don’t worry, you will be awesome after completing this chapter and <span class="No-Break">solving them.</span></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor337"/>What’s a functor?</h1>
			<p>Julia decided <a id="_idIndexMarker391"/>to use an analogy from Steve’s game to explain the concept <span class="No-Break">of functors.</span></p>
			<p>Julia: <em class="italic">Imagine a functor as a special upgrade station in your tower defense game. This station can take any tower and enhance it, but it always outputs a tower - just an </em><span class="No-Break"><em class="italic">improved version.</em></span></p>
			<p>Steve: <em class="italic">That makes sense. So it’s like a consistent way to transform things without changing their </em><span class="No-Break"><em class="italic">core nature?</em></span></p>
			<p>The term <strong class="bold">functor</strong> originates from category theory, a field of mathematics that deals with complex structures and mappings. In the world of programming, we adopt a simplified version of this concept to make it practical for data manipulation. In simple terms, functors are specialized containers that can hold data and have the ability to apply a function to every piece of data they hold, while keeping the overall structure intact. Imagine them as magic boxes that transform whatever is inside without altering the <span class="No-Break">box itself.</span></p>
			<p>However, not every data container that can apply functions to its elements is a functor. There are two laws that a container needs to abide by in order to be counted as <span class="No-Break">a functor:</span></p>
			<p><strong class="bold">Identity law</strong>: Applying <a id="_idIndexMarker392"/>the <strong class="source-inline">identity</strong> function to a functor should yield <a id="_idIndexMarker393"/>the same functor. In other words, if you map the <strong class="source-inline">identity</strong> function over a functor, the functor should <span class="No-Break">remain unchanged.</span></p>
			<p><strong class="bold">Composition law</strong>: Composing <a id="_idIndexMarker394"/>two functions and then mapping <a id="_idIndexMarker395"/>the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other. This means that functor mappings should be composable in a way that doesn’t depend on the order in which <span class="No-Break">they’re applied.</span></p>
			<p>I know it may sound a bit complicated, so let’s discuss these laws <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor338"/>Identity law</h2>
			<p>The Identity <a id="_idIndexMarker396"/>law states that the application of the <strong class="source-inline">identity</strong> function to <a id="_idIndexMarker397"/>our container returns the same container. The “identity function” here is a function that always returns its input. In code, we can represent it with the help of <span class="No-Break"><strong class="source-inline">Func&lt;T, T&gt;</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Func&lt;T, T&gt; identity = x =&gt; x;</pre>			<p>And the usage of this function can be shown <span class="No-Break">like this:</span></p>
			<pre class="source-code">
int number = 29;
int result = identity(number);
Console.WriteLine(result);
  // Output: 29
string text = "Hello Functional programming in C# readers!";
string resultText = identity(text);
Console.WriteLine(resultText);
  // Output: Hello Functional programming in C# readers!</pre>			<p>At first glance, the identity function seems useless, but it plays a big role in mathematical proofs in functional programming. Returning to functors, the Identity law means that if we map the identity function to our container, we should return the same result. Let’s move on to the <span class="No-Break">second law.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor339"/>Composition law</h2>
			<p>This law <a id="_idIndexMarker398"/>states that either we compose two functions and then <a id="_idIndexMarker399"/>map the result over our container or map these functions consequently; the result will be the same. To understand how it can be applied to our code, let’s first create <span class="No-Break">two functions:</span></p>
			<pre class="source-code">
Book AddPages(Book book, int pages) =&gt; new Book { Title = book.Title, Pages = book.Pages + pages };
Book AppendSubtitle(Book book, string subtitle) =&gt; new Book { Title = $"{book.Title}: {subtitle}", Pages = book.Pages };</pre>			<p>One function adds pages to the book and returns it; another appends a subtitle to the book’s title <a id="_idIndexMarker400"/>and returns the result. Quite simple, right? Now, with the <a id="_idIndexMarker401"/>help of these functions, we can express our Composition law <span class="No-Break">in code:</span></p>
			<pre class="source-code">
List&lt;Book&gt; books = new()
{
    new Book { Title = "C# Basics", Pages = 100 },
    new Book { Title = "Advanced C#", Pages = 200 }
};
// Apply AddPages to each book and then apply AppendSubtitle
var sequentialApplicationResult = books.Select(book =&gt; AddPages(book, 50)).Select(book =&gt; AppendSubtitle(book, "Updated Edition"));
// Apply AddPages then AppendSubtitle to each book
var combinedApplicationResult = books.Select(book =&gt; AppendSubtitle(AddPages(book, 50), "Updated Edition"));
// Print the results
Console.WriteLine("books.Select(AddPages).Select(AppendSubtitle): " + string.Join(", ", sequentialApplicationResult.Select(b =&gt; b.Title)));
Console.WriteLine("books.Select(book =&gt; AppendSubtitle(AddPages(book, 50))): " + string.Join(", ", combinedApplicationResult.Select(b =&gt; b.Title)));
// Output:
// books.Select(AddPages).Select(AppendSubtitle): C# Basics: Updated Edition, Advanced C#: Updated Edition
// books.Select(book =&gt; AppendSubtitle(AddPages(book, 50))): C# Basics: Updated Edition, Advanced C#: Updated Edition</pre>			<p>As we can <a id="_idIndexMarker402"/>understand from the output, the resulting collections are equal, thus <a id="_idIndexMarker403"/>our <strong class="source-inline">List&lt;Book&gt;</strong> container abides by the <span class="No-Break">Composition law.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor340"/>Creating our own functor</h2>
			<p>Note that a container doesn’t need to contain a set of elements to be considered a functor. Let’s <a id="_idIndexMarker404"/>recall the <strong class="source-inline">Result</strong> type we used in <a href="B21069_05.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> and make an enhanced version of it by adding the <strong class="source-inline">Map</strong> method to be able to apply functions to the <span class="No-Break">inner value:</span></p>
			<pre class="source-code">
public class Result&lt;TValue, TError&gt;
{
    private TValue _value;
    private TError _error;
    public bool IsSuccess { get; private set; }
    private Result(TValue value, TError error, bool isSuccess)
    {
        _value = value;
        _error = error;
        IsSuccess = isSuccess;
    }
    public TValue Value
    {
        get
        {
            if (!IsSuccess) throw new InvalidOperationException("Cannot fetch Value from a failed result.");
            return _value;
        }
    }
    public TError Error
    {
        get
        {
            if (IsSuccess) throw new InvalidOperationException("Cannot fetch Error from a successful result.");
            return _error;
        }
    }
    public static Result&lt;TValue, TError&gt; Success(TValue value) =&gt; new Result&lt;TValue, TError&gt;(value, default, true);
    public static Result&lt;TValue, TError&gt; Failure(TError error) =&gt; new Result&lt;TValue, TError&gt;(default, error, false);
    public Result&lt;TResult, TError&gt; Map&lt;TResult&gt;(Func&lt;TValue, TResult&gt; mapper)
    {
        return IsSuccess
            ? Result&lt;TResult, TError&gt;.Success(mapper(_value!))
            : Result&lt;TResult, TError&gt;.Failure(_error!);
    }
}</pre>			<p>The <strong class="source-inline">Map</strong> method applies <a id="_idIndexMarker405"/>the incoming function to the value if the container <a id="_idIndexMarker406"/>holds a value; otherwise, no function is called and the error result is returned. And as the <strong class="source-inline">Result</strong> type now can apply functions to the underlying value, it starts to obey the two functor laws. Let’s see that with the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
Book AddPages(Book book, int pages) =&gt; new Book { Title = book.Title, Pages = book.Pages + pages };
Book AppendSubtitle(Book book, string subtitle) =&gt; new Book { Title = $"{book.Title}: {subtitle}", Pages = book.Pages };
Func&lt;Book, Book&gt; identity = book =&gt; book;
var success = Result&lt;Book, string&gt;.Success(new Book { Title = "C# Basics", Pages = 100 });
var error = Result&lt;Book, string&gt;.Failure("Error message");
// Identity law
var successAfterIdentity = success.Map(identity);
// successAfterIdentity should have value "C# Basics", 100 pages
var errorAfterIdentity = error.Map(identity);
// errorAfterIdentity should have the "Error message" error
// Composition law
Func&lt;Book, Book&gt; composedFunction = book =&gt; AppendSubtitle(AddPages(book, 50), "Updated Edition");
var success = Result&lt;Book, string&gt;.Success(new Book { Title = "C# Basics", Pages = 100 });
// Applying composed function directly
var directComposition = success.Map(composedFunction);
// directComposition should hold value "C# Basics: Updated Edition", 150 pages
// Applying functions one after the other
var stepwiseComposition = success.Map(book =&gt; AddPages(book, 50)).Map(book =&gt; AppendSubtitle(book, "Updated Edition"));
// stepwiseComposition should also hold value "C# Basics: Updated Edition", 150 pages</pre>			<p>Although we <a id="_idIndexMarker407"/>cannot directly retrieve the inner value for now, it can be seen using the debugger or the <strong class="source-inline">Dump()</strong> extension method in <strong class="source-inline">LinqPad</strong>. And as we can see, our <strong class="source-inline">Result</strong> type became <span class="No-Break">a functor.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor341"/>Functor benefits</h2>
			<p>Transforming our <strong class="source-inline">Result&lt;TValue, TError&gt;</strong> type into a functor offers several concise <a id="_idIndexMarker408"/>advantages, enhancing error handling and operational outcomes in <span class="No-Break">functional programming:</span></p>
			<ul>
				<li><strong class="bold">Streamlined error handling</strong>: Integrates both success and error outcomes in one structure, simplifying <span class="No-Break">error management</span></li>
				<li><strong class="bold">Composable operations</strong>: Facilitates chaining operations on successful results, with automatic error propagation, improving <span class="No-Break">code reusability</span></li>
				<li><strong class="bold">Enhanced readability</strong>: The <strong class="source-inline">Map</strong> function’s intent is clear—transform the value on success, or bypass an error, making the code <span class="No-Break">more understandable</span></li>
				<li><strong class="bold">Type safety and clarity</strong>: The explicit success and error states in the type signature enhance predictability and safety, ensuring comprehensive <span class="No-Break">outcome handling</span></li>
			</ul>
			<p>Sounds exciting, right? And we can make our class even better by making it an <span class="No-Break">applicative functor.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor342"/>Applicative functors</h1>
			<p>An <strong class="bold">applicative functor</strong> is a type <a id="_idIndexMarker409"/>of functor that allows for the application of a function encapsulated within a functor to a value that is also wrapped within a functor. This concept translates into enabling operations that can gracefully handle multiple layers of computational contexts, such as error handling or <span class="No-Break">asynchronous operations.</span></p>
			<p>While functors allow us to apply a function to a wrapped value, applicative functors extend this capability by enabling the application of functions that are themselves wrapped in a context. This distinction is crucial for operations where the function application itself may result in a computational context, such as failure, delay, or uncertainty. Let’s look at the difference using the book publishing <span class="No-Break">system example.</span></p>
			<p>Consider a function that calculates royalties based on book sales and another function that adjusts these royalties based on market conditions. Both functions might fail due to various reasons, and their outputs might be wrapped in <strong class="source-inline">Result</strong> types to signify success or failure. Applicative functors allow us to apply these potentially failing functions to potentially failing inputs, orchestrating complex operations that gracefully handle multiple layers <a id="_idIndexMarker410"/>of <span class="No-Break">potential failures.</span></p>
			<pre class="source-code">
Result&lt;Func&lt;int, decimal&gt;, string&gt; CalculateRoyaltiesFunc = new Result&lt;Func&lt;int, decimal&gt;, string&gt;(sales =&gt; sales * 0.1m);
Result&lt;Func&lt;decimal, decimal&gt;, string&gt; AdjustRoyaltiesFunc = new Result&lt;Func&lt;decimal, decimal&gt;, string&gt;(royalties =&gt; royalties * 1.05m);</pre>			<p>In this example, <strong class="source-inline">CalculateRoyaltiesFunc</strong> is a function that takes the number of sales and calculates the royalties as 10% of the sales. <strong class="source-inline">AdjustRoyaltiesFunc</strong> is a function that takes an initial royalty amount and adjusts it by a factor of <strong class="source-inline">1.05</strong> to account for <span class="No-Break">market conditions.</span></p>
			<p>Now, let’s assume we have a <strong class="source-inline">Result&lt;int, string&gt;</strong> representing the number of book sales, which could <span class="No-Break">also fail:</span></p>
			<pre class="source-code">
Result&lt;int, string&gt; salesResult = new Result&lt;int, string&gt;(150);</pre>			<p>To calculate the adjusted royalties, we first apply <strong class="source-inline">CalculateRoyaltiesFunc</strong> to <strong class="source-inline">salesResult</strong>, and then apply <strong class="source-inline">AdjustRoyaltiesFunc</strong> to <span class="No-Break">the result:</span></p>
			<pre class="source-code">
var royaltiesResult = salesResult
    .Apply(CalculateRoyaltiesFunc)
    .Apply(AdjustRoyaltiesFunc);
// the royaltiesResult holds the value 15.75</pre>			<p>For the sake of better understanding, let’s pretend that our first function returns <span class="No-Break">an error:</span></p>
			<pre class="source-code">
Result&lt;Func&lt;int, decimal&gt;, string&gt; CalculateRoyaltiesFunc = Result&lt;Func&lt;int, decimal&gt;, string&gt;.Failure("Can't calculate royalties");</pre>			<p>If we try to calculate <strong class="source-inline">royaltiesResult</strong> again, <strong class="source-inline">IsSuccess</strong> will be <strong class="source-inline">false</strong> and the <strong class="source-inline">Error</strong> property will contain the string <strong class="source-inline">"Can't calculate royalties"</strong>. The same situation <a id="_idIndexMarker411"/>will happen if the <strong class="source-inline">AdjustRoyaltiesFunc</strong> call results in an error. Both methods can fail; however, thanks to the <strong class="source-inline">Apply</strong> method, we can call them both in a safe manner. Sounds great, but what does this <strong class="source-inline">Apply</strong> method <span class="No-Break">look like?</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor343"/>The Apply method implementation</h2>
			<p>To implement <a id="_idIndexMarker412"/>the applicative functor <a id="_idIndexMarker413"/>pattern, we introduced the <strong class="source-inline">Apply</strong> method. This method takes <strong class="source-inline">Result</strong> that contains a function and applies it to the value inside the current <strong class="source-inline">Result</strong> instance if both are successful. If either the function or the value is wrapped in a failed <strong class="source-inline">Result</strong>, the <strong class="source-inline">Apply</strong> method propagates <span class="No-Break">the error:</span></p>
			<pre class="source-code">
public Result&lt;TResult, TError&gt; Apply&lt;TResult&gt;(Result&lt;Func&lt;TValue, TResult&gt;, TError&gt; resultFunc)
{
    if (resultFunc.IsSuccess &amp;&amp; this.IsSuccess)
    {
        return Result&lt;TResult, TError&gt;.Success(resultFunc.Value(this.Value));
    }
    else
    {
        var error = resultFunc.IsSuccess ? this._error! : resultFunc.Error;
        return Result&lt;TResult, TError&gt;.Failure(error);
    }
}</pre>			<p>As you can see, nothing special here. First, we ensure that both the current container state and the incoming <strong class="source-inline">Result&lt;Func&lt;TValue, TResult&gt;, TError&gt;</strong> state are successful. Then, we return a new <strong class="source-inline">Result&lt;TResult, TError&gt;</strong>. If either of the <strong class="source-inline">IsSuccess</strong> properties is <strong class="source-inline">false</strong>, a corresponding error is returned. However, an <strong class="source-inline">Apply</strong> method is <a id="_idIndexMarker414"/>not enough for a class to be considered <a id="_idIndexMarker415"/>an applicative functor; it must abide by applicative <span class="No-Break">functor laws.</span></p>
			<p>As Steve was grasping the concept of functors, Julia introduced a <span class="No-Break">new challenge.</span></p>
			<p>Julia: <em class="italic">Now, what if you wanted to apply multiple upgrades to a tower at once, but some upgrades might fail? This is where applicative functors come </em><span class="No-Break"><em class="italic">in handy.</em></span></p>
			<p>Steve: <em class="italic">Multiple upgrades at once? That could really streamline my </em><span class="No-Break"><em class="italic">upgrade system!</em></span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor344"/>Applicative functor laws</h2>
			<p>There are <a id="_idIndexMarker416"/>four applicative functor laws: Identity, Homomorphism, Interchange, and Composition. Let’s go through each <span class="No-Break">of them.</span></p>
			<h3>Identity law</h3>
			<p>The Identity <a id="_idIndexMarker417"/>law states that applying the identity <a id="_idIndexMarker418"/>function to a <strong class="source-inline">Result</strong>-wrapped value should yield the original <strong class="source-inline">Result</strong> without <span class="No-Break">any change:</span></p>
			<pre class="source-code">
// Identity function
Func&lt;int, int&gt; identity = x =&gt; x;
// Result-wrapped value, representing, for example, a count of books
var bookCount = Result&lt;int, string&gt;.Success(10);
// Applying the identity function to the bookCount
var identityApplied = bookCount.Map(identity);
// The identity operation should not alter the original Result
Console.WriteLine(identityApplied.IsSuccess &amp;&amp; identityApplied.Value == 10);  // Output: True</pre>			<h3>Homomorphism law</h3>
			<p>This law <a id="_idIndexMarker419"/>demonstrates that applying a <a id="_idIndexMarker420"/>function to a value and then wrapping it is equivalent to wrapping the value and then applying the function within <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Func&lt;int, double&gt; calculateRoyalties = sales =&gt; sales * 0.15;
int bookSales = 100;
// Applying function then wrapping
var directApplication = Result&lt;double, string&gt;.Success(calculateRoyalties(bookSales));
// Wrapping then applying function
var wrappedApplication = Result&lt;int, string&gt;.Success(bookSales).Map(calculateRoyalties);
// Both operations should yield the same result
Console.WriteLine(directApplication.IsSuccess &amp;&amp; wrappedApplication.IsSuccess &amp;&amp; directApplication.Value == wrappedApplication.Value);  // Output: True</pre>			<h3>Interchange law</h3>
			<p>This law <a id="_idIndexMarker421"/>indicates that applying a wrapped function <a id="_idIndexMarker422"/>to a wrapped value should be equivalent to applying a function that applies its argument to the <span class="No-Break">wrapped value.</span></p>
			<p>For this law, we would need to extend our <strong class="source-inline">Result</strong> type to support applying a <strong class="source-inline">Result</strong>-wrapped function to a <strong class="source-inline">Result</strong>-wrapped value, which is not directly supported by the provided <strong class="source-inline">Result</strong> type structure. However, the conceptual application would look something like this in a system that <span class="No-Break">supports it:</span></p>
			<pre class="source-code">
Result&lt;Func&lt;int, double&gt;, string&gt; wrappedCalculateRoyalties = new Result&lt;Func&lt;int, double&gt;, string&gt;(calculateRoyalties);
Result&lt;int, string&gt; salesResult = Result&lt;int, string&gt;.Success(bookSales);
// Wrapped function applied to wrapped value
var applied = salesResult.Apply(wrappedCalculateRoyalties);
// Equivalent to applying a function that takes a function and applies it to the value
Func&lt;Func&lt;int, double&gt;, Result&lt;double, string&gt;&gt; applyFuncToValue = func =&gt; Result&lt;double, string&gt;.Success(func(bookSales));
var interchangeResult = wrappedCalculateRoyalties.Map(applyFuncToValue);
// The results of applied and interchangeResult should be equivalent</pre>			<h3>Composition law</h3>
			<p>The Composition law ensures that when we compose two or more functions and apply them to <a id="_idIndexMarker423"/>a functor, the order of function application <a id="_idIndexMarker424"/>does not affect the outcome. This property, known as associativity, is central to the Composition law. It ensures that if we have functions f, g, and h, composing them and then applying them to a functor F yields the same result regardless of how the functions are grouped <span class="No-Break">during composition.</span></p>
			<p>For instance, consider two functions, f(x) = x + 1 and g(x) = x * 3. According to the Composition law, composing f and g and then applying them to a value inside a functor should yield the same result as applying f to the functor and then g. Expressed mathematically, F.map(g(f(x))) is equivalent <span class="No-Break">to F.map(f).map(g).</span></p>
			<p>This associative property allows us to reason about composed functions confidently, knowing that the grouping of function applications does not impact the final outcome when applied to a functor. This principle enhances the predictability and reliability of functional programming, allowing developers to compose complex transformations succinctly <span class="No-Break">and safely.</span></p>
			<p>For this law, similar to the Interchange law, we need a mechanism to compose functions within the <strong class="source-inline">Result</strong> context, which our current <strong class="source-inline">Result</strong> type definition does not directly support. Conceptually, it would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Func&lt;int, double&gt; calculateRoyalties = sales =&gt; sales * 0.15;
Func&lt;double, double&gt; adjustForMarket = royalties =&gt; royalties * 1.05;
// Composition of functions outside the Result context
Func&lt;int, double&gt; composed = sales =&gt; adjustForMarket(calculateRoyalties(sales));
// Applying composed function to a Result-wrapped value
var composedApplication = Result&lt;int, string&gt;.Success(bookSales).Map(composed);
// The result of composedApplication should be equivalent to applying each function within the Result context in sequence</pre>			<p>As you can see our <strong class="source-inline">Result</strong> type abides by all these laws and can be counted as an applicative functor. From here, we need to take one more step to make it <span class="No-Break">a monad.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor345"/>Monads</h1>
			<p>Steve was excited about functors but still struggled to see their full potential in his game logic. Julia knew it was time to <span class="No-Break">introduce monads.</span></p>
			<p>Julia: <em class="italic">Let’s take your game’s upgrade system a step further. Imagine a series of operations: checking the player’s gold, deducting the cost, and applying the upgrade. Each step depends on the previous one succeeding. This is where </em><span class="No-Break"><em class="italic">monads shine.</em></span></p>
			<p>Steve: <em class="italic">That sounds exactly like what I need for my upgrade system. How do monads </em><span class="No-Break"><em class="italic">handle this?</em></span></p>
			<p>A <strong class="bold">monad</strong> represents an <a id="_idIndexMarker425"/>evolution of the concepts we explored with functors and applicative functors. While a functor allows us to map a function over a wrapped value and an applicative functor enables applying wrapped functions to wrapped values, monads introduce the ability to chain operations in a way that handles the context of those operations—be it errors, lists, options, or other computational contexts. Thus, we can say that a monad is an applicative functor that adheres to some <span class="No-Break">additional laws.</span></p>
			<p>The essence of a monad is its ability to flatten layers of wrapping caused by applying functions that return wrapped values. This is crucial in avoiding deeply nested structures when performing multiple operations in sequence. Let’s break down this concept with an example from our book <span class="No-Break">publishing system.</span></p>
			<p>Imagine a scenario where we need to fetch a manuscript, edit it, and then format it for publishing. Each of these operations might fail and return <strong class="source-inline">Result&lt;TValue, TError&gt;</strong>, leading to nested <strong class="source-inline">Result&lt;Result&lt;...&gt;&gt;</strong> types. Monads allow us to perform these operations sequentially in a <span class="No-Break">cleaner way.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor346"/>The Bind method</h2>
			<p>The key <a id="_idIndexMarker426"/>to monads is the <strong class="source-inline">Bind</strong> method (often called <strong class="source-inline">flatMap</strong> or <strong class="source-inline">SelectMany</strong> in different <a id="_idIndexMarker427"/>languages and frameworks). This method <a id="_idIndexMarker428"/>applies a <a id="_idIndexMarker429"/>function to the wrapped value, which returns the same kind of wrapper, and then flattens <span class="No-Break">the result:</span></p>
			<pre class="source-code">
public Result&lt;TResult, TError&gt; Bind&lt;TResult&gt;(Func&lt;TValue, Result&lt;TResult, TError&gt;&gt; func)
    {
        return IsSuccess ? func(_value!) : Result&lt;TResult, TError&gt;.Failure(_error!);
    }</pre>			<p>With <strong class="source-inline">Bind</strong>, we can chain operations without nesting. Let’s apply this to our <span class="No-Break">publishing system:</span></p>
			<pre class="source-code">
Result&lt;Manuscript, string&gt; FetchManuscript(int manuscriptId) { ... }
Result&lt;EditedManuscript, string&gt; EditManuscript(Manuscript manuscript) { ... }
Result&lt;FormattedManuscript, string&gt; FormatManuscript(EditedManuscript edited) { ... }
var manuscriptId = 101;
var publishingPipeline = FetchManuscript(manuscriptId)
    .Bind(EditManuscript)
    .Bind(FormatManuscript);</pre>			<p>In this pipeline, each step is applied only if the previous one succeeds, with any failure immediately short-circuiting <span class="No-Break">the chain.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor347"/>Monad laws</h2>
			<p>As well as <a id="_idIndexMarker430"/>functors, monads must satisfy their laws to ensure consistency and predictability and there are three of them: Left Identity, Right Identity, <span class="No-Break">and Associativity.</span></p>
			<h3>Left Identity</h3>
			<p>Wrapping a <a id="_idIndexMarker431"/>value and then binding with a function is the same as <a id="_idIndexMarker432"/>just applying the function to <span class="No-Break">the value:</span></p>
			<pre class="source-code">
Func&lt;int, Result&lt;double, string&gt;&gt; calculateRoyalties = sales =&gt; new Result&lt;double, string&gt;(sales * 0.15);
int bookSales = 100;
var leftIdentity = Result&lt;int, string&gt;.Success(bookSales).Bind(calculateRoyalties);
var directApplication = calculateRoyalties(bookSales);
// leftIdentity should be equivalent to directApplication</pre>			<h3>Right Identity</h3>
			<p>Binding a <a id="_idIndexMarker433"/>wrapped value with a function that simply re-wraps <a id="_idIndexMarker434"/>the value should yield the original <span class="No-Break">wrapped value:</span></p>
			<pre class="source-code">
var manuscriptResult = Result&lt;Manuscript, string&gt;.Success(new Manuscript());
var rightIdentity = manuscriptResult.Bind(manuscript =&gt; Result&lt;Manuscript, string&gt;.Success(manuscript));
// rightIdentity should be equivalent to manuscriptResult</pre>			<h3>Associativity</h3>
			<p>The order <a id="_idIndexMarker435"/>of binding <a id="_idIndexMarker436"/>operations should <span class="No-Break">not matter:</span></p>
			<pre class="source-code">
var associativity1 = FetchManuscript(manuscriptId).Bind(EditManuscript).Bind(FormatManuscript);
var associativity2 = FetchManuscript(manuscriptId).Bind(manuscript =&gt; EditManuscript(manuscript).Bind(FormatManuscript));
// associativity1 should be equivalent to associativity2</pre>			<h2 id="_idParaDest-251"><a id="_idTextAnchor348"/>Utilizing monads</h2>
			<p>Monads shine in operations that involve sequences of computations where each step might fail <a id="_idIndexMarker437"/>or produce a new context. In our book publishing system, we can extend this pattern to handle user input validation, database transactions, or network calls, ensuring our code remains clean, readable, <span class="No-Break">and maintainable:</span></p>
			<pre class="source-code">
Result&lt;Publication, string&gt; PublishManuscript(FormattedManuscript formatted) { ... }
var finalResult = FetchManuscript(manuscriptId)
    .Bind(EditManuscript)
    .Bind(FormatManuscript)
    .Bind(PublishManuscript);</pre>			<p>This approach not only simplifies error handling by propagating errors automatically but also keeps the happy path code clear and straightforward, without the need for manual checks or <span class="No-Break">nested conditionals.</span></p>
			<p>Monads are like smart containers that help manage a series of steps, particularly when you’re dealing with tricky situations such as errors or tasks that take time to complete. By getting a handle on functors and then leveling up to monads, you can make your code not only more expressive but also easier to maintain and more reliable. Think about how we simplified tasks in our book publishing examples; monads and their friends can really untangle complicated logic and make dealing with mistakes a lot smoother, making your whole code base friendlier and less daunting to <span class="No-Break">work with.</span></p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor349"/>Key takeaways</h1>
			<p>As we conclude this chapter on functors and monads, let’s take a moment to summarize what <span class="No-Break">we’ve learned:</span></p>
			<ul>
				<li><strong class="bold">Fundamental concept of functors</strong>: Functors are integral to functional programming for data manipulation. They act as “magic boxes” that allow us to apply a function to the data they hold, transforming the contents while maintaining the <span class="No-Break">original structure.</span></li>
				<li><strong class="bold">Not all containers are functors</strong>: For a data container to be considered a functor, it must adhere to two critical laws: the Identity law and the Composition law. These laws ensure that functors operate predictably and consistently within their <span class="No-Break">intended paradigms.</span></li>
				<li><strong class="bold">Identity law</strong>: The Identity law emphasizes that mapping an identity function (a function that returns its input) over a functor should leave the functor unchanged. This law underscores the non-intrusive nature of <span class="No-Break">functor transformations.</span></li>
				<li><strong class="bold">Composition law</strong>: The Composition law asserts that the order in which functions are composed and applied to a functor does not affect the final outcome. This law highlights the composability and flexibility of functors in <span class="No-Break">functional programming.</span></li>
				<li><strong class="bold">Practical implementation with the Result type</strong>: Through the <strong class="source-inline">Result&lt;TValue, TError&gt;</strong> type example, we explored how functors can be practically implemented to enhance error handling and operational outcomes. The <strong class="source-inline">Map</strong> method demonstrated the application of functions to the encapsulated value within the functor, adhering to the <span class="No-Break">functor laws.</span></li>
				<li><strong class="bold">Applicative functors</strong>: The chapter also introduced the concept of applicative functors, which build upon basic functors by allowing the application of functions wrapped within a functor to values also wrapped within a functor. This capability enables handling multiple layers of computational <span class="No-Break">contexts gracefully.</span></li>
				<li><strong class="bold">Applicative functor laws</strong>: Applicative functors are governed by additional laws, including Identity, Homomorphism, Interchange, and Composition. These laws further ensure the reliable and predictable behavior of applicative functors in <span class="No-Break">complex operations.</span></li>
				<li><strong class="bold">Monads</strong>: The discussion set the stage for the evolution into monads, which extend the concepts of functors and applicative functors by enabling the chaining of operations that handle the context of those operations, such as errors or <span class="No-Break">asynchronous computations.</span></li>
			</ul>
			<p>In closing, functors and monads are not just theoretical constructs; they are pragmatic tools that can transform your code from ordinary to exceptional. Embrace the opportunities they offer, and watch as your programming skills reach new heights of expressiveness and efficiency. <span class="No-Break">Happy coding!</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor350"/>Exercises</h1>
			<p>After explaining the concepts, Julia challenged Steve to apply what <span class="No-Break">he’d learned.</span></p>
			<p>Julia: <em class="italic">Now that you understand the basics, why don’t you try refactoring your game’s upgrade system using monads? It should make your code more robust and easier to </em><span class="No-Break"><em class="italic">reason about.</em></span></p>
			<p>Steve: <em class="italic">That’s a great idea! I can already see how this could simplify some of my more complex </em><span class="No-Break"><em class="italic">game logic.</em></span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor351"/>Exercise 1</h2>
			<p>Given a <strong class="source-inline">Result&lt;List&lt;Tower&gt;, string&gt;</strong> type that represents a list of towers, where <strong class="source-inline">Tower</strong> is a class containing properties such as <strong class="source-inline">Id</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Damage</strong>, the task is to use the functor concept to apply a function to each tower that appends “(Upgraded)” to the end of its name to indicate that the tower has <span class="No-Break">been upgraded:</span></p>
			<pre class="source-code">
public class Tower
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Damage { get; set; }
}
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(List&lt;Tower&gt; towers)
{
    // Write your code here
}</pre>			<h2 id="_idParaDest-255"><a id="_idTextAnchor352"/>Exercise 2</h2>
			<p>Imagine you have two functions wrapped in the <strong class="source-inline">Result</strong> type: <strong class="source-inline">Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage</strong> checks whether a tower’s damage is within acceptable limits, and <strong class="source-inline">Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName</strong> checks whether the tower’s name meets certain criteria. Given a <strong class="source-inline">Result&lt;Tower, string&gt;</strong> representing a single tower, use applicative functors to apply both validation functions to the tower, ensuring both <span class="No-Break">validations pass:</span></p>
			<pre class="source-code">
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateDamage = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Damage &lt; 100);
public Result&lt;Func&lt;Tower, bool&gt;, string&gt; ValidateName = new Result&lt;Func&lt;Tower, bool&gt;, string&gt;(tower =&gt; tower.Name.Length &gt; 5 &amp;&amp; !tower.Name.Contains("BannedWord"));</pre>			<h2 id="_idParaDest-256"><a id="_idTextAnchor353"/>Exercise 3</h2>
			<p>Given a sequence of operations needed to upgrade a tower—<strong class="source-inline">FetchTower</strong>, <strong class="source-inline">UpgradeTower</strong>, and <strong class="source-inline">DeployTower</strong>—with each potentially failing and returning <strong class="source-inline">Result&lt;Tower, string&gt;</strong>, use the monad concept to chain these operations together for a given tower ID. Ensure that if any step fails, the entire operation short-circuits and returns <span class="No-Break">the error:</span></p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; FetchTower(int towerId) { /* Fetches tower based on ID */ }
public Result&lt;Tower, string&gt; UpgradeTower(Tower tower) { /* Upgrades the tower and can fail */ }
public Result&lt;Tower, string&gt; DeployTower(Tower tower) { /* Attempts to deploy the tower */ }</pre>			<p>These exercises aim to help you reinforce the concepts learned throughout this chapter and understand how to apply them in <span class="No-Break">different scenarios.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor354"/>Solutions</h1>
			<p>I hope you did all the exercises and just want to check out my solutions. If not, don’t worry, everything comes with experience. Now, let’s look at <span class="No-Break">the solutions.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor355"/>Exercise 1</h2>
			<p>Use the <strong class="source-inline">Map</strong> method to apply a function to each tower in the list that appends “(Upgraded)” to <span class="No-Break">its name:</span></p>
			<pre class="source-code">
public Result&lt;List&lt;Tower&gt;, string&gt; UpgradeTowers(Result&lt;List&lt;Tower&gt;, string&gt; towersResult)
{
    return towersResult.Map(towers =&gt;
        towers.Select(tower =&gt;
        {
            tower.Name += " (Upgraded)";
            return tower;
        }).ToList());}</pre>			<p>This solution demonstrates how functors can encapsulate data and behavior, allowing for operations on contained data while preserving the context (success or failure) of the <span class="No-Break">entire operation:</span></p>
			<ul>
				<li><strong class="source-inline">towersResult.Map(...)</strong>: This line uses the <strong class="source-inline">Map</strong> function, which is fundamental to the functor pattern. It applies a given function to the contained value if the <strong class="source-inline">Result</strong> is successful, without affecting the outer <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> structure.</span></li>
				<li><strong class="source-inline">towers.Select(tower =&gt; ...)</strong>: Inside <strong class="source-inline">Map</strong>, a <strong class="source-inline">Select</strong> LINQ method iterates over each <strong class="source-inline">Tower</strong> object in the list, applying a lambda function that modifies the <span class="No-Break"><strong class="source-inline">Name</strong></span><span class="No-Break"> property.</span></li>
				<li><strong class="source-inline">tower.Name += " (Upgraded)"</strong>: This operation appends <strong class="source-inline">"(Upgraded)"</strong> to the name of each tower, indicating that it has <span class="No-Break">been upgraded.</span></li>
			</ul>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor356"/>Exercise 2</h2>
			<p>The applicative functor pattern extends the functor’s capabilities by allowing functions themselves to be wrapped in a context (such as <strong class="source-inline">Result</strong>). This solution uses this capability to apply multiple validation functions, wrapped in <strong class="source-inline">Result</strong> types, to a single video also wrapped <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public Result&lt;bool, string&gt; ValidateTower(Result&lt;Tower, string&gt; towerResult)
{
    var damageValidated = towerResult.Apply(ValidateDamage);
    var nameValidated = towerResult.Apply(ValidateName);
    return damageValidated.Bind(damageResult =&gt;
        nameValidated.Map(nameResult =&gt; damageResult &amp;&amp; nameResult));
}</pre>			<p>Here, we handle multiple potential failure points in a composable manner, showcasing the power of applicative functors in functional <span class="No-Break">error handling:</span></p>
			<ul>
				<li><strong class="source-inline">towerResult.Apply(ValidateDamage)</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">towerResult.Apply</strong></span><strong class="source-inline">
(ValidateName)</strong>: These lines demonstrate the applicative functor’s <strong class="source-inline">Apply</strong> method. It takes <strong class="source-inline">Result</strong> containing a function and applies it to another <strong class="source-inline">Result</strong> containing a value, effectively unwrapping both and applying the function to <span class="No-Break">the value.</span></li>
				<li>The chaining of <strong class="source-inline">Bind</strong> and <strong class="source-inline">Map</strong> ensures that if any validation fails, the entire validation process short-circuits and returns the failure. Otherwise, it combines the results of both validations into a single <span class="No-Break">Boolean value.</span></li>
			</ul>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor357"/>Exercise 3</h2>
			<p>Monads extend the concept of applicative functors by allowing the chaining of operations that return a wrapped type, such as <strong class="source-inline">Result&lt;Tower, string&gt;</strong>, enabling a seamless and error-propagating sequence <span class="No-Break">of operations:</span></p>
			<pre class="source-code">
public Result&lt;Tower, string&gt; ProcessAndDeployTower(int towerId)
{
    return FetchTower(towerId)
        .Bind(UpgradeTower)
        .Bind(DeployTower);
}</pre>			<p>This solution shows monads’ ability to manage sequences of dependent operations within a context, making error handling more intuitive and linear, and thus significantly simplifying complex <span class="No-Break">business logic:</span></p>
			<ul>
				<li><strong class="source-inline">FetchTower(towerId).Bind(UpgradeTower).Bind(DeployTower)</strong>: This line illustrates the essence of monads through the <strong class="source-inline">Bind</strong> method. Each function in the chain (<strong class="source-inline">FetchTower</strong>, <strong class="source-inline">UpgradeTower</strong>, and <strong class="source-inline">DeployTower</strong>) potentially returns a <strong class="source-inline">Result&lt;Tower, string&gt;</strong>, and <strong class="source-inline">Bind</strong> ensures that each subsequent function is only executed if the previous <span class="No-Break">one succeeded.</span></li>
				<li>The monadic pattern here guarantees that if any step in the process fails, the error is immediately propagated through the chain, bypassing subsequent steps and returning the <span class="No-Break">failure result.</span></li>
			</ul>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor358"/>Summary</h1>
			<p>In this chapter, we discussed functors and their role in functional programming. We started with the basics, explaining that functors are like smart containers. They can hold data and also apply a function to that data while keeping their <span class="No-Break">original shape.</span></p>
			<p>We looked at how functors work, showing how they let us run functions on the data they hold without needing to unpack and repack the container. We also covered the two main rules that functors follow: the Identity and <span class="No-Break">Composition laws.</span></p>
			<p>Through examples, we saw how functors can be used in different situations, such as working with lists or handling errors more smoothly. We explored creating our own functors, which opens up new ways to tailor our code to fit exactly what we need. We made the full journey from functors to applicative functors and monads, learned about the laws that each of these “containers” adhere to, and saw them in some <span class="No-Break">practical scenarios.</span></p>
			<p>As we wrap up this chapter, you should have a solid foundation in using functors and monads in your projects. They’re a simple yet powerful tool that can make a big difference in how you approach coding. Next up, in <a href="B21069_08.xhtml#_idTextAnchor360"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Recursion and Tail Calls</em>, we’ll dive into the recursion domain, where functions call themselves, and look at how tail calls can make recursion <span class="No-Break">more efficient.</span></p>
		</div>
	

		<div id="_idContainer026" class="Content">
			<h1 id="_idParaDest-262" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor359"/>Part 3:Practical Functional Programming</h1>
			<p>In this part, we move from theory to practice, exploring how to apply functional programming concepts to real-world scenarios. We’ll start with recursion and tail calls, learning how to write efficient recursive functions. Then, we’ll explore currying and partial application, techniques that allow you to create more flexible and reusable functions. Finally, we’ll look at how to combine functions to create powerful data processing pipelines, bringing together many of the concepts learned throughout <span class="No-Break">the book.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21069_08.xhtml#_idTextAnchor360"><em class="italic">Chapter 8</em></a><em class="italic">, Recursion and Tail Calls</em></li>
				<li><a href="B21069_09.xhtml#_idTextAnchor397"><em class="italic">Chapter 9</em></a><em class="italic">, Currying and Partial Application</em></li>
				<li><a href="B21069_10.xhtml#_idTextAnchor426"><em class="italic">Chapter 10</em></a><em class="italic">, Pipelines and Composition</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer027">
			</div>
		</div>
		<div>
			<div id="_idContainer028" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>