- en: Presenting ASP.NET Core MVC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示 ASP.NET Core MVC
- en: In this chapter, you will learn how to implement an application presentation
    layer. More specifically, you will learn how to implement a web application based
    on ASP.NET Core MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何实现应用程序的表现层。更具体地说，你将学习如何基于 ASP.NET Core MVC 实现一个网络应用程序。
- en: 'ASP.NET Core is a .NET framework for implementing web applications. ASP.NET
    Core has been partially described in previous chapters, so this chapter focuses
    mainly on ASP.NET Core MVC. More specifically, the contribution of this chapter
    is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 是一个用于实现网络应用程序的 .NET 框架。ASP.NET Core 在前面的章节中已有部分描述，因此本章主要关注 ASP.NET
    Core MVC。更具体地说，本章的贡献如下：
- en: Understanding the presentation layers of web applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络应用程序的表现层
- en: Understanding the ASP.NET Core MVC structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 结构
- en: What is new in .NET Core 3.0 for ASP.NET Core?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 3.0 为 ASP.NET Core 带来了哪些新特性？
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 与设计原则之间的联系
- en: Use case – implementing a web app in ASP.NET Core MVC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 在 ASP.NET Core MVC 中实现网络应用程序
- en: We will review and give further details on the structure of the ASP.NET Core
    framework that, in part, was discussed in [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*, and [Chapter 4](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml),
    *Deciding the Best Cloud-Based Solution*. Here, the main focus is on how to implement
    web-based presentation layers based on the so-called **Model View Controller**
    (**MVC**) architectural pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾并进一步详细说明 ASP.NET Core 框架的结构，这部分内容已在[第 12 章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)，*使用
    .NET Core 应用服务导向架构*和[第 4 章](049a0a4b-74b6-41a1-92db-87a4f8af9fd1.xhtml)，*决定最佳基于云的解决方案*中讨论过。在这里，主要关注的是如何基于所谓的
    **模型-视图-控制器**（**MVC**）架构模式实现基于网络的表示层。
- en: We will also analyze all of the new features available in the last ASP.NET Core
    3.0 version and the architectural patterns included in the ASP.NET Core MVC framework
    and/or used in typical ASP.NET Core MVC projects. Some of these patterns were
    discussed in [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design
    Patterns and .NET Core Implementation*, and [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml),
    *Understanding the Different Domains in Software Solutions*, whereas some others,
    such as the MVC pattern itself, are new.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将分析在最新的 ASP.NET Core 3.0 版本中可用的所有新功能，以及包含在 ASP.NET Core MVC 框架中或用于典型 ASP.NET
    Core MVC 项目的架构模式。其中一些模式已在[第 9 章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml)，*设计模式和
    .NET Core 实现*和[第 10 章](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml)，*理解软件解决方案中的不同领域*中讨论过，而其他一些模式，如
    MVC 模式本身，则是新的。
- en: You will learn how to implement an ASP.NET Core MVC application, and how to
    organize the whole Visual Studio solution with the practical example at the end
    of this chapter. This example describes a complete ASP.NET Core MVC application
    for editing the packages of the WWTravelClub book use case.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何实现一个 ASP.NET Core MVC 应用程序，以及如何使用本章末尾的实用示例来组织整个 Visual Studio 解决方案。这个示例描述了一个完整的
    ASP.NET Core MVC 应用程序，用于编辑 WWTravelClub 书籍用例的包。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2017 or the 2019 free Community Edition
    or better with all database tools installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要 Visual Studio 2017 或 2019 免费社区版或更高版本，并安装所有数据库工具。
- en: All concepts are clarified with practical examples based on the WWTravelClub
    book use case. The code for this chapter is available at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有概念都通过基于 WWTravelClub 书籍用例的实用示例进行了阐明。本章的代码可在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8)找到。
- en: Understanding the presentation layers of web applications
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络应用程序的表现层
- en: 'This chapter discusses an architecture for the implementation of presentation
    layers of web-based applications based on the ASP.NET Core framework. Presentation
    layers of web applications are based on three techniques:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了基于 ASP.NET Core 框架实现网络应用程序表现层的架构。网络应用程序的表现层基于三种技术：
- en: 'Mobile or desktop native applications that exchange data with servers through
    REST or SOAP services: We have not discussed them since they are strictly tied
    to the client device and its operating system, therefore, analyzing them, which
    would require a dedicated book, is completely beyond the scope of this book.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过REST或SOAP服务与服务器交换数据的移动或桌面原生应用程序：我们尚未讨论它们，因为它们严格绑定到客户端设备和其操作系统，因此，分析它们（这需要专门的书籍）完全超出了本书的范围。
- en: '**Single Page Applications** (**SPA**): These are HTML-based applications whose
    dynamic HTML is created on the client either in JavaScript or with the help of
    WebAssembly (a kind of cross-browser assembly that can be used as a high-performance
    alternative to JavaScript). Like native applications, SPAs exchange data with
    the server through REST or SOAP services, but they have the advantage of being
    independent of the device and its operating system since they run in a browser.
    SPA frameworks are complex subjects that require dedicated books, so they cannot
    be described in this book. Some related links are listed in the *Further reading* section.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单页应用程序**（**SPA**）：这些是基于HTML的应用程序，其动态HTML在客户端由JavaScript或借助WebAssembly（一种跨浏览器的汇编，可以用作JavaScript的高性能替代品）创建。与原生应用程序类似，SPAs通过REST或SOAP服务与服务器交换数据，但它们的优势在于独立于设备和其操作系统，因为它们在浏览器中运行。SPA框架是复杂的话题，需要专门的书籍来讨论，因此本书中无法对其进行描述。一些相关的链接列在*进一步阅读*部分。'
- en: 'HTML pages created by the server whose content depends on the data to be shown
    to the user: The ASP.NET Core MVC framework, which will be discussed in this chapter,
    is a framework for creating such dynamic HTML pages.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由服务器创建的HTML页面，其内容取决于要展示给用户的数据：本章将要讨论的ASP.NET Core MVC框架是一个用于创建此类动态HTML页面的框架。
- en: The remainder of this chapter focuses on how to create HTML pages on the server
    side and, more specifically, on ASP.NET Core MVC, which is introduced in the next
    section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将重点介绍如何在服务器端创建HTML页面，以及更具体地，介绍下一节中将要介绍的ASP.NET Core MVC。
- en: Understanding the ASP.NET Core MVC structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ASP.NET Core MVC结构
- en: ASP.NET Core is based on the concept of the Generic Host explained in the *Using
    Generic Hosts* subsection of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*. The basic
    architecture of ASP.NET Core is outlined in the *A short introduction to ASP.NET
    Core* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core基于在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的*使用通用主机*子节中解释的通用主机概念，*将微服务架构应用于企业应用程序*。ASP.NET
    Core的基本架构在[第12章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)的*ASP.NET Core简介*子节中进行了概述，*使用.NET
    Core应用服务导向架构*。
- en: It is worth reminding readers that the host configuration is delegated to the
    `Startup` class defined in the `Startup.cs` file by calling the `.UseStartup<Startup>()`
    method of the `IWebHostBuilder` interface. `ConfigureServices(IServiceCollection
    services)` of the `Startup` class defines all services that can be injected in
    object constructors through DI. DI is described in detail in the *Using Generic
    Hosts* subsection of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    Microservice Architecture to Your Enterprise Application*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值得提醒读者的是，通过调用`IWebHostBuilder`接口的`.UseStartup<Startup>()`方法，主机配置被委托给在`Startup.cs`文件中定义的`Startup`类。`Startup`类的`ConfigureServices(IServiceCollection
    services)`方法定义了所有可以通过依赖注入（DI）注入对象构造函数的服务。依赖注入在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)的*使用通用主机*子节中进行了详细描述，*将微服务架构应用于企业应用程序*。
- en: The `Configure(IApplicationBuilder app, IHostingEnvironment env)` startup method,
    instead, defines the so-called ASP.NET Core pipeline that was briefly described
    in *A short introduction to ASP.NET Core* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*, and that will be described
    in more detail in the next subsection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Configure(IApplicationBuilder app, IHostingEnvironment env)`启动方法定义了所谓的ASP.NET
    Core管道，这在[第12章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)的*使用.NET Core应用服务导向架构*子节中的*ASP.NET
    Core简介*子节中简要描述过，将在下一子节中详细介绍。
- en: How ASP.NET Core pipeline works
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core管道的工作原理
- en: ASP.NET Core furnishes a set of configurable modules you may assemble according
    to your needs. Each module takes care of functionality that you may need or not.
    Examples of functionalities are authorization, authentication, static file processing,
    protocol negotiation, CORS handling, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 提供了一组可配置的模块，您可以根据需要组装这些模块。每个模块负责您可能需要或不需要的功能。功能示例包括授权、身份验证、静态文件处理、协议协商、CORS
    处理等。
- en: You can put together all of the modules you need by inserting them into a common
    processing framework called the **ASP.NET Core pipeline**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将它们插入一个称为 **ASP.NET Core 管道** 的通用处理框架来组合您需要的所有模块。
- en: 'More specifically, ASP.NET Core requests are processed by pushing a context
    object through a pipeline of ASP.NET Core modules, as shown in the following diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，ASP.NET Core 请求通过将上下文对象推入 ASP.NET Core 模块的管道进行处理，如下面的图所示：
- en: '![](img/3dc434b8-b536-432f-b483-fc03f411b4ab.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dc434b8-b536-432f-b483-fc03f411b4ab.png)'
- en: The object that is inserted in the pipeline is an `HttpContext` instance that
    contains the whole data of the incoming request. More specifically the `Request`
    property of `HttpContext` contains an `HttpRequest` object whose properties represent
    the incoming request in a structured way. There are properties for headers, cookies,
    request path, parameters, form fields, and the request body.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 插入管道的对象是一个包含传入请求全部数据的 `HttpContext` 实例。更具体地说，`HttpContext` 的 `Request` 属性包含一个
    `HttpRequest` 对象，其属性以结构化的方式表示传入请求。有用于头部、cookies、请求路径、参数、表单字段和请求体的属性。
- en: The various modules can contribute to the construction of the final response
    by writing in an `HttpResponse` object contained in the `Response` property of
    the `HttpContext` instance. The `HttpResponse` class is similar to the `HttpRequest`
    class, but its properties refer to the response being built.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的模块可以通过向 `HttpContext` 实例的 `Response` 属性中包含的 `HttpResponse` 对象写入来共同贡献最终响应的构建。`HttpResponse`
    类与 `HttpRequest` 类类似，但其属性指的是正在构建的响应。
- en: Some modules can build an intermediate data structure that is then used by other
    modules in the pipeline. In general, such intermediary data can be stored in custom
    entries of `IDictionary<object, object>` contained in the `Items` property of
    the `HttpContext` object. However, there is a predefined property, `User`, which
    contains information on the currently logged user. The logged-in user is not computed
    automatically but must be computed by an authentication module. The *ASP.NET Core
    services authorization* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*, explains how to add
    the standard module that performs JWT token-based authentication to the ASP.NET
    Core pipeline.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块可以构建一个中间数据结构，然后由管道中的其他模块使用。通常，这种中间数据可以存储在 `HttpContext` 对象的 `Items` 属性中包含的
    `IDictionary<object, object>` 的自定义条目中。然而，有一个预定义的属性 `User`，它包含有关当前登录用户的信息。登录用户不是自动计算的，而必须由身份验证模块计算。[第
    12 章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml) 的 *Applying Service-Oriented
    Architectures with .NET Core* 部分的 *ASP.NET Core 服务授权* 子部分解释了如何将基于 JWT 令牌的身份验证的标准模块添加到
    ASP.NET Core 管道中。
- en: '`HttpContext` has also a `Connection` property that contains information on
    the underlying connection established with the client and a `WebSockets` property
    that contains information on possible WebSocket-based connections established
    with the clients.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 还有一个 `Connection` 属性，它包含与客户端建立的基础连接的信息，以及一个 `WebSockets` 属性，它包含与客户端建立的可能基于
    WebSocket 的连接的信息。'
- en: '`HttpContext` also has a `Features` property that contains `IDictionary<Type,
    object>`, which specifies the features supported by the web server that hosts
    the web application and by the modules of the pipeline. Features can be set with
    the `.Set<Type>(Type o)` method and can be retrieved with the `.Get<Type>()` method.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 还有一个 `Features` 属性，它包含 `IDictionary<Type, object>`，该属性指定了托管 Web
    应用程序的 Web 服务器以及管道模块所支持的功能。功能可以通过 `.Set<Type>(Type o)` 方法设置，并通过 `.Get<Type>()`
    方法检索。'
- en: Web server features are automatically added by the framework, when all other
    features are added by pipeline modules while they process `HttpContext`. Features
    are not specific for the incoming request but depend just on the application-hosting
    environment, and on the modules added to the ASP.NET Core pipeline.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有其他功能由管道模块在处理 `HttpContext` 时添加时，框架会自动添加 Web 服务器功能。功能不是针对传入请求的特定功能，而仅取决于应用程序托管环境和添加到
    ASP.NET Core 管道的模块。
- en: '`HttpContext` gives access also to the dependency injection engine through
    its `RequestServices` property. You can get an instance of a type managed by the
    dependency engine by calling the `.RequestService.GetService(Type t)` method.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpContext` 通过其 `RequestServices` 属性也提供了对依赖注入引擎的访问。你可以通过调用 `.RequestService.GetService(Type
    t)` 方法来获取由依赖引擎管理的类型的一个实例。'
- en: The `HttpContext` instance that is created for processing a web request is not
    available only to modules, but also to the application code through DI. It is
    enough to insert an `IHttpContextAccessor` parameter in the constructor of a class
    that is automatically dependency injected, such as a controller (see later on
    in this section), and then access its `HttpContext` property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为处理网络请求而创建的 `HttpContext` 实例不仅对模块可用，而且通过依赖注入对应用程序代码也可用。只需在自动依赖注入的类（如控制器）的构造函数中插入一个
    `IHttpContextAccessor` 参数，然后访问其 `HttpContext` 属性即可。
- en: 'A module is any class with the following structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是任何具有以下结构的类：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In general, each module processes the `HttpContext` instance passed by the previous
    module in the pipeline, then calls `await _next.Invoke(context)` to invoke the
    modules in the remainder of the pipeline. When all other modules finish their
    processing and the response for the client has been prepared, each module can
    perform further post-processing of the response in the code that follows the `_next.Invoke(context)`
    call.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个模块处理由管道中前一个模块传递的 `HttpContext` 实例，然后调用 `await _next.Invoke(context)` 来调用管道中剩余的模块。当所有其他模块完成处理并且客户端的响应已经准备就绪时，每个模块都可以在
    `_next.Invoke(context)` 调用之后的代码中执行进一步的响应后处理。
- en: 'Modules are registered in the ASP.NET Core pipeline by calling the `UseMiddleware<T>`
    method in the `Startup.cs` file''s `Configure` method, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `Startup.cs` 文件的 `Configure` 方法中调用 `UseMiddleware<T>` 方法，将模块注册到 ASP.NET
    Core 管道中，如下所示：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modules are inserted in the pipeline in the same order when `UseMiddleware`
    is called. Since each functionality added to an application might require several
    modules and might require operations other than adding modules, you usually define
    an `IApplicationBuilder` extension such as `UseMyFunctionality`, as shown in the
    following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `UseMiddleware` 时，模块按相同的顺序插入到管道中。由于添加到应用程序中的每个功能可能需要几个模块，并且可能需要除添加模块之外的操作，因此你通常定义一个
    `IApplicationBuilder` 扩展，如 `UseMyFunctionality`，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After that, the whole functionality can be added to the application by calling
    `app.UseMyFunctionality(...)`. For instance, the ASP.NET Core MVC functionality
    is added to the ASP.NET Core pipeline by calling `app.UseEndpoints(....)`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以通过调用 `app.UseMyFunctionality(...)` 将整个功能添加到应用程序中。例如，通过调用 `app.UseEndpoints(....)`
    将 ASP.NET Core MVC 功能添加到 ASP.NET Core 管道中。
- en: 'Often, functionalities added with each `app.Use...` require that some .NET
    types are added to the application DI engine. In these cases, we also define an
    `IServiceCollection` extension named `AddMyFunctionality` that must be called
    in the `Startup.cs` file''s `ConfigureServices(IServiceCollection services)` method.
    For instance, ASP.NET Core MVC requires a call like the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过每个 `app.Use...` 添加的功能需要将一些 .NET 类型添加到应用程序依赖注入引擎中。在这些情况下，我们还会定义一个名为 `AddMyFunctionality`
    的 `IServiceCollection` 扩展方法，该方法必须在 `Startup.cs` 文件的 `ConfigureServices(IServiceCollection
    services)` 方法中调用。例如，ASP.NET Core MVC 需要调用如下所示的方法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you don't need to change the default MVC options, you can simply call `services.AddControllersWithViews()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要更改默认的 MVC 选项，你可以简单地调用 `services.AddControllersWithViews()`。
- en: The next subsection describes another important feature of the ASP.NET Core
    framework, namely, how to handle application configuration data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 ASP.NET Core 框架的另一个重要功能，即如何处理应用程序配置数据。
- en: Loading configuration data and using it with the options framework
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载配置数据并使用选项框架
- en: 'When an ASP.NET Core application starts, it reads configuration information
    (such as a database connection string) from the `appsettings.json` and `appsettings.[EnvironmentName].json`
    files, where `EnvironmentName` is a string value that depends on where the application
    is deployed. Typical values for `EnvironmentName` are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ASP.NET Core 应用程序启动时，它会从 `appsettings.json` 和 `appsettings.[EnvironmentName].json`
    文件中读取配置信息（如数据库连接字符串），其中 `EnvironmentName` 是一个字符串值，取决于应用程序部署的位置。`EnvironmentName`
    的典型值如下：
- en: '`Production` is used for production deployment.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Production` 用于生产部署。'
- en: '`Development` is used during development.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Development` 用于开发。'
- en: '`Staging` is used when the application is tested in staging.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序在预发布环境中进行测试时，使用 `Staging`。
- en: The two JSON trees extracted from the `appsettings.json` and `appsettings.[EnvironmentName].json` files
    are merged into a unique tree where values contained in `[EnvironmentName].json` override
    the values contained in the corresponding paths of `appsettings.json`. This way,
    the application can be run with different configurations in different deployment
    environments. In particular, you may use a different database connection string,
    and hence, a different database instance in each different environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `appsettings.json` 和 `appsettings.[EnvironmentName].json` 文件中提取的两个 JSON 树合并成一个唯一的树，其中
    `[EnvironmentName].json` 中包含的值会覆盖 `appsettings.json` 中相应路径的值。这样，应用程序可以在不同的部署环境中运行不同的配置。特别是，你可以使用不同的数据库连接字符串，因此，每个不同的环境都可以有不同的数据库实例。
- en: 'The `[EnvironmentName]` string is taken from the `ASPNETCORE_ENVIRONMENT` operating
    system environment variable. In turn, `ASPNETCORE_ENVIRONMENT` can be automatically
    set during the application''s deployment with Visual Studio in two ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`[EnvironmentName]` 字符串是从操作系统的 `ASPNETCORE_ENVIRONMENT` 环境变量中获取的。反过来，`ASPNETCORE_ENVIRONMENT`
    可以通过两种方式在 Visual Studio 中自动设置应用程序的部署：'
- en: 'During Visual Studio deployment, Visual Studio publish wizard creates an XML
    publish profile. If the publish wizard allows you to choose the `ASPNETCORE_ENVIRONMENT`
    from a drop-down list, you are done:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 部署期间，Visual Studio 发布向导创建一个 XML 发布配置文件。如果发布向导允许你从下拉列表中选择 `ASPNETCORE_ENVIRONMENT`，则已完成：
- en: '![](img/accbb45b-1268-4812-8662-e57450fc2900.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/accbb45b-1268-4812-8662-e57450fc2900.png)'
- en: 'Otherwise, you may proceed as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可以按照以下步骤操作：
- en: Once you fill in the information in the wizard, save the publish profile without
    publishing.
  id: totrans-59
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在向导中填写了信息，请保存发布配置文件而不进行发布。
- en: Then, edit the profile with a text editor and add an XML property such as, `<EnvironmentName>Staging</EnvironmentName>`.
    Since all already defined publish profiles can be selected during the application
    publication, you may define a different publish profile for each of your environments,
    and then, you may select the one you need during each publication.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用文本编辑器编辑配置文件，并添加一个 XML 属性，例如，`<EnvironmentName>Staging</EnvironmentName>`。由于在应用程序发布期间可以选择所有已定义的发布配置文件，因此你可以为每个环境定义不同的发布配置文件，然后在每次发布时选择所需的配置文件。
- en: 'The value to set `ASPNETCORE_ENVIRONMENT` to during deployment can also be
    specified in the Visual Studio ASP.NET Core project file (`.csproj`) of your application
    by adding the following code:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署期间设置 `ASPNETCORE_ENVIRONMENT` 的值也可以通过在应用程序的 Visual Studio ASP.NET Core 项目文件（`.csproj`）中添加以下代码来指定：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'During development in Visual Studio, the value to give to `ASPNETCORE_ENVIRONMENT`
    when the application is run can be specified in the `Properties\launchSettings.json` file
    of the ASP.NET Core project. The `launchSettings.json` file contains several named
    groups of settings. These settings configure how to launch the web application
    when it is run from Visual Studio. You may choose to apply all settings of a group
    by selecting the group name with the drop-down list next to Visual Studio''s run
    button:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中进行开发时，当应用程序运行时，`ASPNETCORE_ENVIRONMENT` 的值可以在 ASP.NET Core
    项目的 `Properties\launchSettings.json` 文件中指定。`launchSettings.json` 文件包含几个命名的设置组。这些设置配置了从
    Visual Studio 运行时如何启动 Web 应用程序。你可以通过选择位于 Visual Studio 运行按钮旁边的下拉列表中的组名来选择应用一个组的所有设置：
- en: '![](img/358b4f47-0e3f-42c5-8e6f-427bae29c0b0.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/358b4f47-0e3f-42c5-8e6f-427bae29c0b0.png)'
- en: Your selection in this drop-down list will be shown in the run button, the default
    selection being IIS Express.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在此下拉列表中的选择将显示在运行按钮中，默认选择为 IIS Express。
- en: 'The following code shows a typical `launchSettings.json` file in which you
    can either add a new group of settings or change the settings of the existing
    default groups:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了一个典型的 `launchSettings.json` 文件，其中你可以添加一个新的设置组或更改现有默认组的设置：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The named groups of settings are under the `profiles` properties. There, you
    may choose where to host the application (`IISExpress`), to launch the browser,
    and the values of some environment variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的命名组位于 `profiles` 属性下。在那里，你可以选择应用程序托管的位置（`IISExpress`）、启动浏览器以及一些环境变量的值。
- en: The current environment loaded from the `ASPNETCORE_ENVIRONMENT` operating system
    environment variable can be tested through the `IHostingEnvironment` interface
    during the ASP.NET Core pipeline definition since an `IHostingEnvironment` instance
    is passed as a parameter to the `Startup.cs` file's `Configure` method. `IHostingEnvironment` is
    also available to the remainder of the user code through DI.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 管道定义期间，可以通过 `IHostingEnvironment` 接口测试从 `ASPNETCORE_ENVIRONMENT`
    操作系统环境变量加载的当前环境，因为 `IHostingEnvironment` 实例被作为参数传递给 `Startup.cs` 文件的 `Configure`
    方法。`IHostingEnvironment` 也通过 DI 可用于用户代码的其余部分。
- en: '`IHostingEnvironment.IsEnvironment(string environmentName)` checks whether
    the current value of `ASPNETCORE_ENVIRONMENT` is `environmentName`. There are
    also specific shortcuts for testing development (`.IsDevelopment()`), production
    (`.IsProduction()`), and staging (`.IsStaging()`). `IHostingEnvironment` also contains
    the current root directory of the ASP.NET Core application (`.WebRootPath`) and
    the directory reserved for static files (`.ContentRootPath`) that are served as
    they are by the web server (CSS, JavaScript, images, and so on).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`IHostingEnvironment.IsEnvironment(string environmentName)` 检查当前 `ASPNETCORE_ENVIRONMENT`
    的值是否为 `environmentName`。同时，也有针对测试开发（`.IsDevelopment()`）、生产（`.IsProduction()`）和预发布（`.IsStaging()`）的特定快捷方式。`IHostingEnvironment`
    还包含 ASP.NET Core 应用程序的当前根目录（`.WebRootPath`）和由 Web 服务器直接提供的服务静态文件目录（`.ContentRootPath`）（CSS、JavaScript、图片等）。'
- en: 'Both `launchSettings.json` and all publish profiles can be accessed as children
    of the Properties node in Visual Studio Explorer, as shown in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`launchSettings.json` 和所有发布配置文件都可以在 Visual Studio 探索器中作为属性节点下的子节点访问，如下面的截图所示：'
- en: '![](img/235193fd-a520-44cf-b78f-bd62d4737dbf.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/235193fd-a520-44cf-b78f-bd62d4737dbf.png)'
- en: 'Once `appsettings.json` and `appsettings.[EnvironmentName].json` are loaded, the configuration
    tree resulting from their merge can be mapped to the properties of .NET objects.
    For example, let''s suppose we have an `Email` section of the `appsettings` files
    that contains all of the information needed to connect to an email server, as
    shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了 `appsettings.json` 和 `appsettings.[EnvironmentName].json`，合并后的配置树可以映射到
    .NET 对象的属性。例如，假设我们有一个 `appsettings` 文件的 `Email` 部分，其中包含连接到电子邮件服务器所需的所有信息，如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, the whole `Email` section can be mapped to an instance of the following
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，整个 `Email` 部分 可以映射到以下类的实例：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code that performs the mapping must be inserted in the `ConfigureServices` method
    in the `Startup.cs` file since the `EmailConfig` instance will be available through
    DI. The code we need is shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 执行映射的代码必须插入到 `Startup.cs` 文件中的 `ConfigureServices` 方法，因为 `EmailConfig` 实例将通过
    DI 获取。所需的代码如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the preceding settings, classes that need `EmailConfig` data must declare
    an `IOptions<EmailConfig> options` parameter that will be provided by the DI engine.
    An `EmailConfig` instance is contained in `options.Value`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置之后，需要 `EmailConfig` 数据的类必须声明一个由 DI 引擎提供的 `IOptions<EmailConfig> options`
    参数。`EmailConfig` 实例包含在 `options.Value` 中。
- en: The next subsection describes the basic ASP.NET Core pipeline modules needed
    by an ASP.NET Core MVC application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了 ASP.NET Core MVC 应用程序所需的基本 ASP.NET Core 管道模块。
- en: Defining the ASP.NET Core MVC pipeline
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 ASP.NET Core MVC 管道
- en: If you create a new ASP.NET Core MVC project in Visual Studio, a standard pipeline
    is created in the `Startup.cs` file's `Configure` method. There, if needed, you
    may add further modules or change the configuration of the existing modules.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Visual Studio 创建一个新的 ASP.NET Core MVC 项目，`Startup.cs` 文件的 `Configure`
    方法将创建一个标准管道。在那里，如果需要，你可以添加更多模块或更改现有模块的配置。
- en: 'The initial code of the `Configure` method handles errors and performs basic
    HTTPS configuration:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure` 方法的初始代码处理错误并执行基本的 HTTPS 配置：'
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If there are errors, if the application is in a development environment, the
    module installed by `UseDeveloperExceptionPage` adds a detailed error report to
    the response, while the module installed by `UseDatabaseErrorPage` processes and
    adds details of Entity Framework database errors, if any, to the response. These
    modules are valuable debugging tools.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，如果应用程序处于开发环境，`UseDeveloperExceptionPage` 安装的模块会在响应中添加详细的错误报告，而 `UseDatabaseErrorPage`
    安装的模块会处理并添加任何实体框架数据库错误的详细信息到响应中。这些模块是宝贵的调试工具。
- en: If an error occurs when the application is not in development mode, `UseExceptionHandler`
    restores the request processing from the path it receives as an argument, that
    is, from `/Home/Error`. In other words, it simulates a new request with the `/Home/Error`
    path. This request is pushed into the standard MVC processing until it reaches
    the endpoint associated with the `/Home/Error` path, where the developer is expected
    to place the custom code that handles the error.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不在开发模式下发生错误，`UseExceptionHandler` 会从它接收的参数路径恢复请求处理，即从`/Home/Error`。换句话说，它模拟了一个带有`/Home/Error`路径的新请求。这个请求被推入标准的MVC处理流程，直到它达到与`/Home/Error`路径关联的端点，在那里开发者预计会放置处理错误的自定义代码。
- en: 'When the application is not in development, `UseHsts` adds the `Strict-Transport-Security`
    header to the response that informs the browser that the application must be accessed
    only with HTTPS. After this declaration, compliant browsers should automatically
    convert any HTTP request to the application into an HTTPS request for the time
    specified in the `Strict-Transport-Security` header. As a default, `UseHsts` specifies
    30 days as the time in the header, but you may specify a different time and other
    header parameters by adding an `options` object in the `ConfigureServices` method
    of `Startup.cs`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序不在开发模式下时，`UseHsts` 将`Strict-Transport-Security`头添加到响应中，告知浏览器应用程序必须仅通过HTTPS访问。在此声明之后，符合规定的浏览器应自动将任何对应用程序的HTTP请求转换为HTTPS请求，时间为`Strict-Transport-Security`头中指定的时间。默认情况下，`UseHsts`将30天指定为头中的时间，但您可以通过在`Startup.cs`的`ConfigureServices`方法中添加一个`options`对象来指定不同的时间和其他头参数：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`UseHttpsRedirection` causes an automatic redirection to an HTTPS URL when
    an HTTP URL is received, in a way to force a secure connection. Once the first
    HTTPS secure connection is established, the `Strict-Transport-Security` header
    prevents future redirections that might be used to perform man-in-the-middle attacks.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseHttpsRedirection` 在接收到HTTP URL时导致自动重定向到HTTPS URL，以强制建立安全连接。一旦建立了第一个HTTPS安全连接，`Strict-Transport-Security`头会阻止可能用于执行中间人攻击的后续重定向。'
- en: 'The following code shows the remainder of the default pipeline:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了默认管道的其余部分：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`UseStaticFiles` makes accessible from the web all files contained in the `wwwroot`
    folder of the project (typically CSS,  JavaScript, images, and font files) through
    their actual path.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseStaticFiles` 使得项目`wwwroot`文件夹中的所有文件（通常是CSS、JavaScript、图片和字体文件）可以通过它们的实际路径从网络上访问。'
- en: '`UseCookiePolicy` ensures that cookies are processed by the ASP.NET Core pipeline
    only if the user has given consent for cookie usage. Consent to cookie usage is
    given through a consent cookie, that is, cookie processing is enabled only if
    this consent cookie is found among the request cookies. This cookie must be created
    by JavaScript when the user clicks a consent button. The whole string that contains
    both the consent cookie names and its contents can be retrieved from the `HttpContext.Features`,
    as shown in the following snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseCookiePolicy` 确保只有在用户同意使用cookie的情况下，ASP.NET Core管道才会处理cookie。对cookie使用的同意是通过一个同意cookie给出的，也就是说，只有在请求cookie中找到这个同意cookie时，才会启用cookie处理。这个cookie必须由JavaScript在用户点击同意按钮时创建。包含同意cookie名称及其内容的整个字符串可以从`HttpContext.Features`中检索到，如下面的代码片段所示：'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CanTrack` is `true` only if consent is required and has not been given yet.
    When the consent cookie is detected, `CanTrack` is set to `false`. This way, `showBanner` is
    `true` only if consent is required and has not been given yet. Therefore, it tells
    us whether to ask the user for consent or not.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要同意且尚未给出时，`CanTrack` 才为`true`。当检测到同意cookie时，`CanTrack` 被设置为`false`。这样，只有当需要同意且尚未给出时，`showBanner`
    才为`true`。因此，它告诉我们是否需要向用户请求同意。
- en: 'Options of the consent module are contained in a `CookiePolicyOptions` instance
    that must be configured manually with the options framework. The following code
    snippet shows the default configuration code scaffolded by Visual Studio that
    configures `CookiePolicyOptions` in the code instead of using the configuration
    file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同意模块的选项包含在一个`CookiePolicyOptions`实例中，必须使用选项框架手动配置。以下代码片段显示了Visual Studio生成的默认配置代码框架，它配置了代码中的`CookiePolicyOptions`而不是使用配置文件：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`UseAuthentication` enables authentication schemes. As a default, it only enables
    cookie-based authentication, that is, an authentication scheme where the authentication
    token is placed in a cookie. The authentication cookie is created during user
    login.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthentication` 启用认证方案。默认情况下，它仅启用基于 cookie 的认证，即认证令牌放置在 cookie 中的认证方案。认证
    cookie 在用户登录期间创建。'
- en: 'Cookies authorization options (such as the cookie name) and other authentication
    schemes can be enabled by configuring an options object in the `ConfigureServices`
    method, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `ConfigureServices` 方法中配置一个选项对象，可以启用 cookie 授权选项（如 cookie 名称）和其他认证方案，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code specifies a custom authentication cookie name and adds JWT-based
    authentication for the REST service contained in the application. Both `AddCookie`
    and `AddJwtBearer` have overloads that accept the name of the authentication scheme
    before the action where you can define the authentication scheme options. Since
    the authentication scheme name is necessary to refer to a specific authentication
    scheme, when it is not specified, a default name is used:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码指定了一个自定义的认证 cookie 名称，并为应用程序中包含的 REST 服务添加了基于 JWT 的认证。`AddCookie` 和 `AddJwtBearer`
    都有重载，可以在定义认证方案选项的动作之前接受认证方案名称。由于认证方案名称是引用特定认证方案所必需的，因此当它未指定时，将使用默认名称：
- en: The standard name contained in `CookieAuthenticationDefaults.AuthenticationScheme`
    for cookie authentication
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CookieAuthenticationDefaults.AuthenticationScheme` 中包含的标准名称用于 cookie 认证'
- en: The standard name contained in `JwtBearerDefaults.AuthenticationScheme` for
    JWT authentication
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JwtBearerDefaults.AuthenticationScheme` 中包含的标准名称用于 JWT 认证'
- en: The name passed in `o.DefaultScheme` selects the authentication scheme used
    for filling the `User` property of `HttpContext`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `o.DefaultScheme` 中传入的名称选择用于填充 `HttpContext` 的 `User` 属性的认证方案。
- en: For more information about JWT authentication, please refer to the *ASP.NET
    Core services authorization* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JWT 认证的更多信息，请参阅第 12 章 *使用 .NET Core 应用服务架构* 的 *ASP.NET Core 服务授权* 子节，[链接](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)。
- en: '`UseAuthorization` enables authorization based on the `Authorize` attribute.
    Options can be configured with an `AddAuthorization` method placed in the `ConfigureServices`
    method. These options allow the definition of policies for claims-based authorization.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseAuthorization` 通过 `Authorize` 属性启用基于授权的授权。可以通过在 `ConfigureServices` 方法中放置一个
    `AddAuthorization` 方法来配置选项。这些选项允许定义基于声明的授权策略。'
- en: For more information on authorization, please refer to the *ASP.NET Core services
    authorization* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml), *Applying
    Service-Oriented Architectures with .NET Core*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 关于授权的更多信息，请参阅第 12 章 *使用 .NET Core 应用服务架构* 的 *ASP.NET Core 服务授权* 子节，[链接](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)。
- en: '`UseRouting` and `UseEndpoints` handle the so-called ASP.NET Core endpoints. An
    endpoint is an abstraction of a handler that serves specific classes of URLs.
    URLs are transformed into an `Endpoint` instance by using patterns. When a pattern
    matches a URL, an `Endpoint` instance is created and filled with both the pattern
    name and data extracted from the URL as a consequence of matching URL parts with
    named parts of the pattern, as shown in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 和 `UseEndpoints` 处理所谓的 ASP.NET Core 端点。端点是服务特定类 URL 的处理程序的抽象。通过使用模式将
    URL 转换为 `Endpoint` 实例。当模式与 URL 匹配时，会创建一个 `Endpoint` 实例，并填充模式名称以及从 URL 中提取的数据，这些数据是匹配
    URL 部分与模式命名字段的结果，如下面的代码片段所示：'
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`UseRouting` adds a module that processes the request path to get the request
    `Endpoint` instance and adds it to the `HttpContext.Features` dictionary under
    the `IEndpointFeature` type. The actual `Endpoint` instance is contained in the
    `Endpoint` property of `IEndpointFeature`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseRouting` 添加了一个模块，该模块处理请求路径以获取请求 `Endpoint` 实例，并将其添加到 `HttpContext.Features`
    字典中的 `IEndpointFeature` 类型下。实际的 `Endpoint` 实例包含在 `IEndpointFeature` 的 `Endpoint`
    属性中。'
- en: Each pattern also contains the handler that should process all requests that
    match the pattern. This handler is passed to `Endpoint` when the `Endpoint` is
    created.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模式都包含一个处理程序，该处理程序应处理所有与模式匹配的请求。当创建 `Endpoint` 时，此处理程序会被传递给 `Endpoint`。
- en: '`UseEndpoints` instead adds the middleware that invokes the handler associated
    with the request endpoint. It is placed at the end of the pipeline since the execution
    of the handler is expected to produce the final response.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseEndpoints` 则添加了调用请求端点相关处理程序的中间件。它放置在管道末尾，因为预期处理程序的执行将生成最终的响应。'
- en: 'As the following code snippet shows, patterns are processed in the `UseRouting` middleware
    but they are specified in the `UseEndpoints` method. This splitting is not necessary
    but is done for coherence with the previous ASP.NET Core versions that contained
    no method analogous to `UseRouting`, but a unique call at the end of the pipeline.
    In the new version, patterns are still defined in `UseEndpoints`, which is placed
    at the end of the pipeline, but `UseEndpoints` just creates a data structure containing
    all patterns, when the application starts. Then, this data structure is processed
    by the `UseRouting` middleware, as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，模式在 `UseRouting` 中间件中处理，但它们是在 `UseEndpoints` 方法中指定的。这种拆分不是必需的，但为了与之前包含没有类似
    `UseRouting` 方法，而是在管道末尾进行唯一调用的 ASP.NET Core 版本保持一致。在新版本中，模式仍然在 `UseEndpoints`
    中定义，它位于管道末尾，但 `UseEndpoints` 只在应用程序启动时创建一个包含所有模式的数据库结构。然后，这个数据结构由 `UseRouting`
    中间件处理，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`MapControllerRoute` defines the patterns associated with the MVC engine that
    will be described in the next subsection. There are other methods that define
    other types of patterns. A call such as `.MapHub<MyHub>("/chat")` maps paths to
    hubs that handle WebSockets, whereas `.MapHealthChecks("/health")` maps paths
    to ASP.NET Core components that return application health data. You can also directly
    map a pattern to a custom handler with `.MapGet`, which intercepts GET requests,
    and `.MapPost`, which intercepts POST requests. The following in an example of
    `MapGet`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute` 定义了与 MVC 引擎关联的模式，这些模式将在下一小节中描述。还有其他方法定义了其他类型的模式。例如，`.MapHub<MyHub>("/chat")`
    将路径映射到处理 WebSocket 的中心节点，而 `.MapHealthChecks("/health")` 将路径映射到返回应用程序健康数据的 ASP.NET
    Core 组件。您还可以使用 `.MapGet` 直接将模式映射到自定义处理程序，它拦截 GET 请求，以及 `.MapPost`，它拦截 POST 请求。以下是一个
    `MapGet` 的示例：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Patterns are processed in the order in which they are defined until a matching
    pattern is found. Since the authentication/authorization middleware is placed
    after the routing middleware, it can process the `Endpoint` request to verify
    whether the current user has the required authorizations to execute the `Endpoint`
    handler. Otherwise, a 401 (Unauthorized) or 403 (Forbidden) response is immediately
    returned. Only requests that survive authentication and authorization have their
    handlers executed by the `UseEndpoints` middleware.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 模式按照它们定义的顺序进行处理，直到找到匹配的模式。由于身份验证/授权中间件放置在路由中间件之后，它可以处理 `Endpoint` 请求以验证当前用户是否具有执行
    `Endpoint` 处理程序所需的授权。否则，将立即返回 401（未授权）或 403（禁止）响应。只有通过身份验证和授权的请求才会由 `UseEndpoints`
    中间件执行其处理程序。
- en: 'With the ASP.NET Core RESTful API described in [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml), *Applying
    Service-Oriented Architectures with .NET Core*, ASP.NET Core MVC also uses attributes
    placed on controllers or on controller methods to specify authorization rules.
    However, an instance of `AuthorizeAttribute` can be also added to a pattern to
    apply its authorization constraints to all URLs matching that pattern, as shown
    in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 12 章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml) 中描述的 ASP.NET Core RESTful
    API，*使用 .NET Core 应用服务架构*，ASP.NET Core MVC 也使用放置在控制器或控制器方法上的属性来指定授权规则。然而，可以将 `AuthorizeAttribute`
    的实例添加到模式中，以将其授权约束应用于匹配该模式的所有 URL，如下面的示例所示：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code makes the health check path available only to administrative
    users.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使健康检查路径仅对管理员用户可用。
- en: Defining controllers and ViewModels
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义控制器和 ViewModels
- en: The various `.MapControllerRoute` calls in `UseEndpoints` associate URL patterns
    to controllers and to methods of these controllers, where controllers are classes
    that inherit from the `Microsoft.AspNetCore.Mvc.Controller` class. Controllers
    are discovered by inspecting all of the application's `.dll` files and are added
    to the DI engine. This job is performed by the call to `AddControllersWithViews`
    in the `ConfigureServices` method of the `startup.cs` file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UseEndpoints`中的各种`.MapControllerRoute`调用将URL模式关联到控制器和这些控制器的方法，其中控制器是继承自`Microsoft.AspNetCore.Mvc.Controller`类的类。控制器是通过检查应用程序的所有`.dll`文件来发现的，并添加到DI引擎中。这项工作是通过在`startup.cs`文件的`ConfigureServices`方法中的调用`AddControllersWithViews`来完成的。
- en: The pipeline module added by `UseEndpoints` takes the controller name from the
    `controller` pattern variable, and the name of the controller method to invoke
    from the `action` pattern variable. Since, by convention, all controller names
    are expected to end with the `Controller` suffix, the actual controller type name
    is obtained from the name found in the `controller` variable by adding this suffix.
    Hence, for instance, if the name found in `controller` is `"Home"`, then the `UseEndpoints`
    module tries to get an instance of the `HomeController` type from the DI engine.
    All of the controller public methods can be selected by the routing rules. Use
    of a controller public method can be prevented by decorating it with the `[NonAction]`
    attribute. All controller methods available to the routing rules are called action
    methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseEndpoints`添加的管道模块从`controller`模式变量中获取控制器名称，并从`action`模式变量中获取要调用的控制器方法名称。由于按照惯例，所有控制器名称都预期以`Controller`后缀结尾，因此实际的控制器类型名称是通过在`controller`变量中找到的名称添加此后缀来获得的。例如，如果`controller`变量中找到的名称是`"Home"`，那么`UseEndpoints`模块会尝试从DI引擎中获取`HomeController`类型的实例。所有控制器公开的方法都可以通过路由规则进行选择。可以通过使用`[NonAction]`属性来防止使用控制器公开方法。所有可供路由规则使用的控制器方法都称为操作方法。'
- en: MVC controllers work like the API controllers that we described in the *Implementing
    REST services with ASP.NET Core* subsection of [Chapter 12](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml),
    *Applying Service-Oriented Architectures with .NET Core*. The only difference
    is that API controllers are expected to produce JSON or XML, while MVC controllers
    are expected to produce HTML. For this reason, while API controllers inherit from
    the `ControllerBase` class, MVC controllers inherit from the `Controller` class,
    which, in turn, inherits from the `ControllerBase` class and adds its methods
    that are useful for HTML generation, such as invoking views, which are described
    in the next subsection, and creating a redirect response.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器的工作方式与我们在[第12章](3ec4db7b-e570-41d0-94fb-2bdbd6dc4a9a.xhtml)的*Applying
    Service-Oriented Architectures with .NET Core*小节中描述的*Implementing REST services
    with ASP.NET Core*中的API控制器类似。唯一的区别是API控制器预期生成JSON或XML，而MVC控制器预期生成HTML。因此，虽然API控制器从`ControllerBase`类继承，MVC控制器则从`Controller`类继承，而`Controller`类反过来又从`ControllerBase`类继承并添加了用于HTML生成的有用方法，例如调用视图（将在下一小节中描述）和创建重定向响应。
- en: MVC controllers may use also a routing technique similar to one of the API controllers,
    that is, routing based on controllers and controller method attributes. This behavior
    is enabled by calling the `.MapDefaultControllerRoute()` method in `UseEndpoints`.
    If this call is placed before all `MapControllerRoute` calls, then controller
    routes have priority on `MapControllerRoute` patterns; otherwise, the converse
    is true.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MVC控制器也可以使用类似于API控制器的一种路由技术，即基于控制器和控制器方法属性的路由。这种行为是通过在`UseEndpoints`中调用`.MapDefaultControllerRoute()`方法来启用的。如果这个调用放在所有`MapControllerRoute`调用之前，那么控制器路由在`MapControllerRoute`模式上具有优先级；否则，情况相反。
- en: All attributes we have seen for API controllers can be also used with MVC controllers
    and action methods (`HttpGet`, `HttpPost`, `...Authorize`, and so on). Developers
    can write their own custom attributes by inheriting from the `ActionFilter` class
    or other derived classes. I will not give details on this right now, but these
    details can be found in the official documentation referred to in the *Further
    reading* section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所看到的所有用于API控制器的属性也可以用于MVC控制器和操作方法（`HttpGet`、`HttpPost`、`...Authorize`等）。开发者可以通过从`ActionFilter`类或其他派生类继承来编写自己的自定义属性。我现在不会详细介绍这一点，但这些详细信息可以在*进一步阅读*部分中提到的官方文档中找到。
- en: When the `UseEndpoints` module invokes a controller, all of its constructor
    parameters are filled by the DI engine since the controller instance itself is
    returned by the DI engine, and since DI automatically fills constructor parameters
    with DI in a recursive fashion.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `UseEndpoints` 模块调用控制器时，由于控制器实例本身由依赖注入（DI）引擎返回，并且由于依赖注入（DI）以递归方式自动填充构造函数参数，因此所有构造函数参数都由依赖注入（DI）引擎填充。
- en: 'Action method parameters, instead, are taken from the following sources:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，操作方法参数来自以下来源：
- en: Request headers
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求头
- en: Variables in the pattern matched by the current request
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前请求匹配的模式中的变量
- en: Query string parameters
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串参数
- en: Form parameters (in the case of POST requests)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单参数（在POST请求的情况下）
- en: '**Dependency injection** (**DI**)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）'
- en: While the parameters filled with DI are matched by type, all other parameters
    are matched by *name* ignoring the letter casing. That is, the action method parameter
    name must match the header, query-string, form, or pattern variable. When the
    parameter is a complex type, a match is searched for each property, using the
    property name for the match. In the case of nested complex types, a match is searched
    for each path and the name associated with the path is obtained by chaining all
    property names in the path and separating them with dots. For instance, the name
    associated with a path composed by `Property1`, `Property2`, ...., `Propertyn`,
    is `Property1.Property2.Property3...Propertyn`. The name obtained this way must
    match a header name, pattern variable name, query string parameter name, and so
    on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用依赖注入（DI）填充的参数按类型匹配时，所有其他参数都按名称匹配，忽略字母大小写。也就是说，操作方法参数名称必须与标题、查询字符串、表单或模式变量匹配。当参数是复杂类型时，会为每个属性搜索匹配，使用属性名称进行匹配。在嵌套复杂类型的情况下，会为每个路径搜索匹配，并通过将路径中的所有属性名称链接起来并使用点分隔来获取与路径关联的名称。例如，由
    `Property1`、`Property2`、......、`Propertyn` 组成的路径关联的名称是 `Property1.Property2.Property3...Propertyn`。通过这种方式获得的名称必须与标题名称、模式变量名称、查询字符串参数名称等匹配。
- en: 'By default, simple type parameters are matched with pattern variables and query
    string variables, while complex types parameters are matched with form parameters.
    However, the preceding defaults can be changed by prefixing the parameters with
    attributes as detailed here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，简单类型参数与模式变量和查询字符串变量进行匹配，而复杂类型参数与表单参数进行匹配。但是，可以通过在此处详细说明的属性前缀更改前面的默认设置：
- en: '`[FromForm]` forces a match with form parameters.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromForm]` 强制与表单参数进行匹配。'
- en: '`[FromHeader]` forces a match with a request header.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromHeader]` 强制与请求头进行匹配。'
- en: '`[FromRoute]` forces a match with pattern variables.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromRoute]` 强制与模式变量进行匹配。'
- en: '`[FromQuery]` forces a match with a query string variable.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromQuery]` 强制与查询字符串变量进行匹配。'
- en: '`[FromServices]` forces the use of DI.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromServices]` 强制使用依赖注入（DI）。'
- en: 'During the match, the string extracted from the selected source is converted
    into the type of the action method parameter using the current thread culture.
    If either a conversion fails or no match is found for a not nullable action method
    parameter, then the whole action method invocation process fails, and a 404 response
    is automatically returned. For instance, in the following example, the `id` parameter
    is matched with query string parameters or pattern variables since it is a simple
    type, while `myclass` properties and nested properties are matched with form parameters
    since `MyClass` is a complex type. Finally, `myservice` is taken from DI since
    it is prefixed with the `[FromServices]` attribute:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配过程中，从所选来源提取的字符串使用当前线程的文化类型转换为操作方法参数。如果转换失败或找不到非可空操作方法参数的匹配项，则整个操作方法调用过程失败，并自动返回404响应。例如，在以下示例中，由于
    `id` 参数是简单类型，因此它与查询字符串参数或模式变量进行匹配，而 `myclass` 属性和嵌套属性由于 `MyClass` 是复杂类型，因此与表单参数进行匹配。最后，由于
    `myservice` 前缀为 `[FromServices]` 属性，因此从依赖注入（DI）中获取：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If no match is found for the `id` parameter, a 404 response is automatically
    returned since integers are not nullable. If, instead, no `MyService` instance
    is found in the DI container, an exception is thrown because in this case the
    failure doesn't depend on a wrong request but a design error.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到 `id` 参数的匹配项，由于整数不可为空，将自动返回404响应。相反，如果在依赖注入（DI）容器中找不到 `MyService` 实例，则抛出异常，因为在这种情况下，失败不取决于错误的请求，而是设计错误。
- en: MVC controllers return an `IActionResult` interface or a `Task<IActionResult>`
    result if they are declared as `async`. `IActionResult` has a unique `ExecuteResultAsync(ActionContext)`
    method that, when invoked by the framework, produces the actual response.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MVC 控制器被声明为 `async`，则返回 `IActionResult` 接口或 `Task<IActionResult>` 结果。`IActionResult`
    有一个独特的 `ExecuteResultAsync(ActionContext)` 方法，当框架调用它时，会产生实际的响应。
- en: 'For each different `IActionResult`, MVC controllers have methods that return
    them. The most commonly used `IActionResult` is `ViewResult`, which is returned
    by a `View` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种不同的 `IActionResult`，MVC 控制器都有返回它们的方法。最常用的 `IActionResult` 是 `ViewResult`，它由
    `View` 方法返回：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`ViewResult` is a very common way for a controller to create an HTML response.
    More specifically, the controller interacts with business/data layers to produce
    an abstraction of the data that will be shown in the HTML page. This abstraction
    is an object called a **ViewModel**. The ViewModel is passed as a second argument
    to the `View` method, while the first argument is the name of an HTML template
    called View that is instantiated with the data contained in the ViewModel.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewResult` 是控制器创建 HTML 响应的一种非常常见的方式。更具体地说，控制器与业务/数据层交互，以生成将在 HTML 页面上显示的数据的抽象。这个抽象是一个称为
    **ViewModel** 的对象。ViewModel 作为 `View` 方法的第二个参数传递，而第一个参数是名为 View 的 HTML 模板的名称，该模板使用
    ViewModel 中包含的数据进行实例化。'
- en: 'Summing up, the MVC controllers'' processing sequence is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，MVC 控制器的处理顺序如下：
- en: Controllers perform some processing to create the ViewModel, which is an abstraction
    of the data to show on the HTML page.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器执行一些处理以创建 ViewModel，它是要在 HTML 页面上显示的数据的抽象。
- en: Then, controllers create `ViewResult` by passing a View name and ViewModel to
    the `View` method.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，控制器通过将视图名称和 ViewModel 传递给 `View` 方法来创建 `ViewResult`。
- en: The MVC framework invokes `ViewResult` and causes the template contained in
    the View to be instantiated with the data contained in the ViewModel.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MVC 框架调用 `ViewResult` 并使 View 中包含的模板与 ViewModel 中的数据实例化。
- en: The result of the template instantiation is written in the response with adequate
    headers.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板实例化的结果写入响应中，并带有适当的头信息。
- en: This way, the controller performs the conceptual job of HTML generation by building
    a ViewModel, while the View, that is, the template, takes care of all the graphical
    details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，控制器通过构建 ViewModel 执行 HTML 生成的概念性工作，而视图，即模板，则负责所有图形细节。
- en: Views are described in greater detail in the next subsection, while the Model
    (ViewModel) View Controller pattern is discussed in more detail in the *Connection
    between ASP.NET Core MVC and design principles* section of this chapter. Finally,
    a practical example is given in the *Use case – web app in ASP.NET Core MVC* section
    of this chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中更详细地描述了视图，而在本章的 *ASP.NET Core MVC 与设计原则之间的联系* 部分更详细地讨论了模型（ViewModel）视图控制器模式。最后，在本章的
    *用例 - ASP.NET Core MVC 中的 Web 应用* 部分给出了一个实际示例。
- en: Another common `IActionResult` is `RedirectResult`, which creates a redirect
    response, hence forcing the browser to move to a specific URL. Redirects are often
    used after the user has successfully submitted a form that completes a previous
    operation. In this case, it is common to redirect the user to a page where they
    can select another operation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的 `IActionResult` 是 `RedirectResult`，它创建一个重定向响应，从而强制浏览器移动到特定的 URL。重定向通常在用户成功提交完成先前操作的表单后使用。在这种情况下，通常会将用户重定向到可以选择另一个操作的页面。
- en: 'The simplest way to return `RedirectResult` is by bypassing a URL to the `Redirect`
    method. This is the advised way to perform a redirect to a URL that is outside
    the web application. When the URL is within the web application, instead, it is
    advisable to use the `RedirectToAction` method, which accepts the controller name,
    the action method name, and the desired parameters for the target action method.
    The framework uses this data to compute a URL that causes the desired action method
    to be invoked with the provided parameters. This way, if the routing rules are
    changed during the application development or maintenance, the new URL is automatically
    updated by the framework with no need to modify all occurrences of the old URL
    in the code. The following code shows how to call `RedirectToAction`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `RedirectResult` 的最简单方法是通过绕过 `Redirect` 方法的 URL。这是建议用于将 URL 重定向到 web 应用程序外部的
    URL 的方法。当 URL 在 web 应用程序内部时，相反，建议使用 `RedirectToAction` 方法，该方法接受控制器名称、操作方法名称和目标操作方法所需参数。框架使用这些数据来计算导致所需操作方法使用提供的参数调用的
    URL。这样，如果在应用程序开发或维护期间更改了路由规则，框架会自动更新新 URL，无需修改代码中所有旧 URL 的出现。以下代码显示了如何调用 `RedirectToAction`：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another useful `IActionResult` is `ContentResult`, which can be created by
    calling the `Content` method. `ContentResult` allows you to write any string to
    the response and to specify its MIME type, as shown in the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 `IActionResult` 是 `ContentResult`，可以通过调用 `Content` 方法来创建。`ContentResult`
    允许您将任何字符串写入响应，并指定其 MIME 类型，如下例所示：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, the `File` method returns `FileResult`, which writes binary data in
    the response. There are several overloads of this method that allow the specification
    of a byte array, a stream, or the path of a file, plus the MIME type of the binary
    data.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`File` 方法返回 `FileResult`，它在响应中写入二进制数据。此方法有几个重载，允许指定字节数组、流或文件的路径，以及二进制数据的
    MIME 类型。
- en: Now, let's move to describe how actual HTML is generated in Views.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来描述在 Views 中实际生成的 HTML。
- en: Understanding Razor Views
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Razor 视图
- en: 'ASP.NET Core MVC uses a language called Razor to define the HTML templates
    contained in the Views. Razor views are files that are compiled into .NET classes
    either at their first usage, when the application is built, or when the application
    is published. As a default, both pre-compilation on each build and on publish
    are enabled, but this behavior can be changed by adding the following code to
    the web application project file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 使用名为 Razor 的语言来定义 Views 中包含的 HTML 模板。Razor 视图是文件，它们在首次使用时、在构建应用程序时或在应用程序发布时编译成
    .NET 类。默认情况下，每次构建和发布时的预编译都是启用的，但可以通过向 web 应用程序项目文件中添加以下代码来更改此行为：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Views can also be precompiled into views libraries by choosing a Razor view
    library project in the windows that appear after you have chosen an ASP.NET Core
    project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在选择 ASP.NET Core 项目后出现的窗口中选择一个 Razor 视图库项目，视图也可以预先编译成视图库。
- en: 'Also, after the compilation, views remain associated with their paths, which
    become their full names. Each controller has an associated folder under the Views
    folder with the same name as the controller, which is expected to contain all
    the views used by that controller. The following screenshot shows the folder associated
    with the `HomeController` and its Views:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，编译后，视图仍然与其路径相关联，这些路径成为它们的完整名称。每个控制器在 Views 文件夹下都有一个与其同名的关联文件夹，预计将包含该控制器使用的所有视图。以下截图显示了与
    `HomeController` 和其视图关联的文件夹：
- en: '![](img/518c957c-8d20-4875-86ce-d93a9df56ba0.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/518c957c-8d20-4875-86ce-d93a9df56ba0.png)'
- en: The preceding screenshot also shows the Shared folder, which is expected to
    contain all the views used by several controllers. The controller refers to views
    in the `View` method through their paths without the `.cshtml` extension. If the
    path starts with `/`, the path is interpreted as relative to the application root.
    Otherwise, as a first attempt, the path is interpreted as relative to the folder
    associated with the controller and, if no view is found there, the view is searched
    in the Shared folder.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了共享文件夹，它预计将包含由多个控制器使用的所有视图。控制器通过它们的路径（不带 `.cshtml` 扩展名）在 `View` 方法中引用视图。如果路径以
    `/` 开头，则路径被视为相对于应用程序根的相对路径。否则，作为第一次尝试，路径被视为相对于与控制器关联的文件夹的相对路径，如果在那里找不到视图，则视图将在共享文件夹中搜索。
- en: Hence, for instance, the `Privacy.cshtml` View file in the preceding screenshot
    can be referred to from within `HomeController` as `View("Privacy", MyViewModel)`.
    If the name of the View is the same as the name of the action method, we can simply
    write `View(MyViewModel)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，前面截图中的 `Privacy.cshtml` 视图文件可以在 `HomeController` 中引用，作为 `View("Privacy",
    MyViewModel)`。如果视图的名称与动作方法的名称相同，我们可以简单地写成 `View(MyViewModel)`。
- en: 'Razor views are a mix of HTML code with C# code, plus some Razor-specific statements.
    They all begin with a header that contains the type of ViewModel that the View
    is expected to receive:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 视图是 HTML 代码与 C# 代码以及一些 Razor 特定语句的混合。它们都以一个包含视图预期接收的 ViewModel 类型的标题开始：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each view may contain also some `using` statements whose effect is the same
    as the `using` statements of standard code files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图也可以包含一些 `using` 语句，其效果与标准代码文件中的 `using` 语句相同：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`@using` statements declared in the special `_ViewImports.cshtml` file, that
    is, in the root of the Views folder, are automatically applied to all views.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊文件 `_ViewImports.cshtml` 中声明的 `@using` 语句，即位于 Views 文件夹的根目录，将自动应用于所有视图。
- en: 'Each view can also require instances of types from the DI engine in its header
    with the syntax shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图也可以在其标题中使用语法要求，要求来自 DI 引擎的类型实例：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code requires an instance of the `IViewLocalizer` interface and
    places it in the `Localizer` variable. The remainder of the View is a mix of C#
    code, HTML, and Razor control flow statements. Each area of a view can be either
    in HTML mode or C# mode. The code in a View area that is in HTML mode is interpreted
    as HTML, while the code in a View area that is in C# mode is interpreted as C#.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码需要一个 `IViewLocalizer` 接口的实例，并将其放置在 `Localizer` 变量中。视图的其余部分是 C# 代码、HTML
    和 Razor 控制流语句的混合。视图的每个区域可以是 HTML 模式或 C# 模式。在 HTML 模式下的视图区域中的代码被解释为 HTML，而在 C#
    模式下的视图区域中的代码被解释为 C#。
- en: The topic that follows explains Razor flow of control statements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题解释 Razor 控制流语句。
- en: Learning Razor flow of control statements
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 Razor 控制流语句
- en: 'If you want to write some C# code in an HTML area, you can create a C# area
    with the `@{..}` flow of control Razor statement, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 HTML 区域中编写一些 C# 代码，可以使用 `@{..}` 控制流 Razor 语句创建一个 C# 区域，如下所示：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding example shows that it is enough to write an HTML tag to create
    an HTML area inside of the C# area and so on recursively. As soon as the HTML
    tag closes, you are again in C# mode.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，只需编写一个 HTML 标签就足以在 C# 区域内创建一个 HTML 区域，依此类推。一旦 HTML 标签关闭，您就又回到了 C# 模式。
- en: 'C# code produces no HTML, while HTML code is added to the response in the same
    order it appears. You can add text computed with C# code while in HTML mode by
    prefixing any C# expression with `@`. If the expression is complex, composed of
    a chain of properties and method calls, it must be enclosed by parentheses. The
    following code shows some examples:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: C# 代码不会产生 HTML，而 HTML 代码会按照出现的顺序添加到响应中。在 HTML 模式下，您可以通过在 C# 表达式前加上 `@` 来添加使用
    C# 代码计算出的文本。如果表达式复杂，由属性链和方法调用组成，则必须用括号括起来。以下代码显示了几个示例：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Types are converted into strings using the current culture settings (see the
    *Connection between ASP.NET Core MVC and design principles* section for details
    on how to set the culture of each request). Moreover, strings are automatically
    HTML encoded to avoid the `<` and `>` symbols that might interfere with the view
    HTML. HTML encoding can be prevented with the `@HTML.Raw` function, as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类型使用当前的区域设置转换为字符串（有关如何设置每个请求的文化的详细信息，请参阅 *ASP.NET Core MVC 与设计原则之间的联系* 部分）。此外，字符串会自动进行
    HTML 编码，以避免可能干扰视图 HTML 的 `<` 和 `>` 符号。可以使用 `@HTML.Raw` 函数防止 HTML 编码，如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In an HTML area, alternative HTML can be selected with the `@if` Razor statement:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 区域中，可以使用 `@if` Razor 语句选择替代的 HTML：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An HTML template can be instantiated several times with the `for`, `foreach`,
    and `while` Razor statements, as shown in the following examples:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 模板可以使用 `for`、`foreach` 和 `while` Razor 语句实例化多次，如下面的示例所示：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Please do not confuse the statements described so far with the usual C# `if`,
    `for`, `foreach`, and `while` statements, since they are Razor-specific statements
    whose syntax is similar to their standard C# counterparts.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将前面描述的语句与通常的 C# `if`、`for`、`foreach` 和 `while` 语句混淆，因为它们是 Razor 特定的语句，其语法与它们的标准
    C# 对应项类似。
- en: Razor views can contain comments that do not generate any code. Any text included
    within `@*...*@` is considered a comment and is removed when the page is compiled. The
    next topic describes properties that are available in all Views.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Razor视图可以包含不会生成任何代码的注释。任何包含在`@*...*@`内的文本都被视为注释，并在页面编译时被移除。下一个主题将描述所有视图中都可用到的属性。
- en: Understanding Razor View properties
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Razor视图属性
- en: Some standard variables are predefined in each view. The most important variable
    is `Model`, which contains the ViewModel passed to the view. For instance, if
    we pass a `Person` model to a view, then `<span>@Model.Name</span>` displays the
    name of the `Person` passed to the view.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图中都预定义了一些标准变量。最重要的变量是`Model`，它包含传递给视图的ViewModel。例如，如果我们向视图传递一个`Person`模型，那么`<span>@Model.Name</span>`将显示传递给视图的`Person`的名称。
- en: The `ViewData` variable contains `IDictionary<string, object>`, which is shared
    with the controller that invoked the view. That is, all controllers also have
    a `ViewData` property containing `IDictionary<string, object>`, and every entry
    that is set in the controller is available also in the `ViewData` variable of
    the invoked view. `ViewData` is an alternative to the ViewModel for a controller
    to pass information to its invoked view.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewData`变量包含`IDictionary<string, object>`，它与调用视图的控制器共享。也就是说，所有控制器也都有一个包含`IDictionary<string,
    object>`的`ViewData`属性，并且控制器中设置的每个条目在调用的视图的`ViewData`变量中也是可用的。`ViewData`是控制器向其调用的视图传递信息的ViewModel的替代方案。'
- en: The `User` variable contains the currently logged user, that is, the same instance
    contained in the current request's `Http.Context.User` property. The `Url` variable
    contains an instance of the  `IUrlHelper` interface whose methods are utilities
    for computing URLs of application pages. For instance, `Url.Action("action", "controller",
    new {par1=valueOfPar1,...})` computes the URL that causes the action method *action* of
    the *controller* to be invoked with all parameters specified in the anonymous
    object passed as its parameters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`变量包含当前登录的用户，即当前请求的`Http.Context.User`属性中包含的相同实例。`Url`变量包含一个`IUrlHelper`接口的实例，其方法用于计算应用程序页面的URL。例如，`Url.Action("action",
    "controller", new {par1=valueOfPar1,...})`计算导致控制器中名为*controller*的动作方法*action*被调用，并且使用匿名对象作为其参数中指定的所有参数的URL。'
- en: The `Context` variable contains the whole request `HttpContext`. The `ViewContext`
    variable contains data about the context of the view invocation, included metadata
    about the action method that invoked the view.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`变量包含整个请求的`HttpContext`。`ViewContext`变量包含关于视图调用上下文的数据，包括调用视图的动作方法的相关元数据。'
- en: The next topic describes how Razor enhances HTML tag syntax.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将描述Razor如何增强HTML标签语法。
- en: Using Razor tag helpers
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Razor标签助手
- en: In ASP.NET Core MVC, the developer can define the so-called tag helpers that
    either enhance existing HTML tags with new tag attributes or define new tags.
    While Razor views are compiled, any tag is matched against existing tag helpers.
    When a match is found, the source tag is replaced with HTML created by the tag
    helpers. Several tag helpers may be defined for the same tag. They are all executed
    in an order that can be configured with a priority attribute associated with each
    tag helper.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core MVC中，开发者可以定义所谓的标签助手，这些标签助手可以增强现有的HTML标签以添加新的标签属性或定义新的标签。当Razor视图被编译时，任何标签都会与现有的标签助手进行匹配。当找到匹配时，源标签会被标签助手创建的HTML替换。可以为同一标签定义多个标签助手。它们都按照可以配置的优先级属性关联的顺序执行。
- en: All tag helpers defined for the same tag may cooperate during the processing
    of each tag instance because they are passed as a shared data structure where
    each of them may apply a contribution. Usually, the final tag helper that is invoked
    processes this shared data structure to produce the output HTML.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为同一标签定义的所有标签助手可以在处理每个标签实例时进行合作，因为它们被传递为一个共享的数据结构，其中每个标签助手都可以应用贡献。通常，最后被调用的标签助手处理这个共享数据结构以生成输出HTML。
- en: Tag helpers are classes that inherit from the `TagHelper` class. This topic
    doesn't discuss how to create new tag helpers but introduces the main predefined
    tag helpers that come with ASP.NET Core MVC. A complete guide on how to define
    tag helpers is available in the official documentation that is referenced in the
    *Further reading* section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 标签助手是继承自`TagHelper`类的类。本主题不讨论如何创建新的标签助手，而是介绍随ASP.NET Core MVC一起提供的预定义主要标签助手。有关如何定义标签助手的完整指南可在官方文档中找到，该文档在*进一步阅读*部分有引用。
- en: 'To use a tag helper, you must declare the `.dll` file containing it with a
    declaration like in the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用标签辅助器，你必须使用如下声明来声明包含它的 `.dll` 文件：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you would like to use just one of the tag helpers defined in the `.dll` file,
    you must replace `*` with the tag name.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想使用 `.dll` 文件中定义的一个标签辅助器，你必须将 `*` 替换为标签名称。
- en: 'The preceding declaration can be placed either in each view that uses the tag
    helpers defined in the library or, once and for all, in the `_ViewImports.cshtml` file
    in the root of the Views folder. As a default, `_ViewImports.cshtml` adds all
    predefined ASP.NET Core MVC tag helpers with the following declaration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明可以放置在每个使用库中定义的标签辅助器的视图中，或者一次性放置在 Views 文件夹根目录下的 `_ViewImports.cshtml` 文件中。默认情况下，`_ViewImports.cshtml`
    会添加所有预定义的 ASP.NET Core MVC 标签辅助器，如下所示：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The anchor tag is enhanced with attributes that automatically compute the URL
    and that invoke a specific action method with given parameters, as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点标签通过自动计算 URL 并使用给定参数调用特定动作方法得到增强，如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A similar syntax is added to the `form` tags:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的语法被添加到 `form` 标签中：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `script` tag is enhanced with attributes that allow falling back to a different
    source if the download fails. Typical usage is to download scripts from some cloud
    service to optimize the browser cache and to fall back to a local copy of the
    script in case of failure. The following code uses the fallback technique to download
    the `bootstrap` JavaScript file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 标签通过允许在下载失败时回退到不同源得到增强。典型用法是从某些云服务下载脚本以优化浏览器缓存，并在失败时回退到脚本的本地副本。以下代码使用回退技术下载
    `bootstrap` JavaScript 文件：'
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`asp-fallback-test` contains a JavaScript test that verifies whether the download
    succeeded. In the preceding example, the test verifies whether a JavaScript object
    has been created.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp-fallback-test` 包含一个 JavaScript 测试，用于验证下载是否成功。在上面的示例中，测试验证是否已创建 JavaScript
    对象。'
- en: 'The `environment` tag can be used to select different HTML for different environments
    (development, staging, and production). Its typical usage is selecting the debug
    version of JavaScript files during development, as shown in this example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`environment` 标签可用于选择不同环境（开发、测试和生成）的不同 HTML。它的典型用法是在开发期间选择 JavaScript 文件的调试版本，如下例所示：'
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is also a `cache` tag, which caches its content in memory to optimize
    rendering speed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `cache` 标签，它将内容缓存在内存中以优化渲染速度：
- en: '[PRE38]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As a default, content is cached for 20 minutes, but the tag has attributes to
    define when the cache expires, such as `expires-on="{datetime}"`, `expires-after="{timespan}"`,
    and `expires-sliding="{timespan}"`. Here, the difference between `expires-sliding` and `expires-after`
    is that, in the second attribute, the expiration time count is reset each time
    the content is requested. The `vary-by` attribute causes the creation of a different
    cache entry for each different value passed to `vary-by`. There are also attributes
    such as `vary-by-header`—which creates a different entry for each different value
    assumed by the request header specified in the attribute, `vary-by-cookie`, and
    so on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，内容会被缓存 20 分钟，但标签具有定义缓存何时过期的属性，例如 `expires-on="{datetime}"`、`expires-after="{timespan}"`
    和 `expires-sliding="{timespan}"`。在这里，`expires-sliding` 和 `expires-after` 之间的区别在于，在第二个属性中，每次请求内容时都会重置过期时间的计数。`vary-by`
    属性会导致为传递给 `vary-by` 的每个不同值创建不同的缓存条目。还有如 `vary-by-header` 等属性——为属性中指定的请求头中假设的每个不同值创建不同的条目，`vary-by-cookie`
    等。
- en: 'All `input` tags, that is, `textarea`, `input`, and `select`, have an `asp-for`
    attribute that accepts a properties path rooted in the view ViewModel as their
    value. For instance, if the view has a `Person` ViewModel, we may have something
    like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `input` 标签，即 `textarea`、`input` 和 `select`，都有一个 `asp-for` 属性，它接受以视图 ViewModel
    为根的属性路径作为其值。例如，如果视图有一个 `Person` ViewModel，我们可能会有如下所示的内容：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first effect of the preceding code is to assign the value of the `Town`
    nested property to the `value` attribute of the `input` tag. In general, if the
    value is not a string, it is converted into a string using the current request
    culture.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一个效果是将嵌套属性 `Town` 的值分配给 `input` 标签的 `value` 属性。一般来说，如果值不是字符串，它将使用当前请求文化将其转换为字符串。
- en: However, it also sets the name of the input field to `Address.Town` and the
    ID of the input field to `Address_Town` since dots are not allowed in tag IDs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它也设置了输入字段的名称为 `Address.Town` 并将输入字段的 ID 设置为 `Address_Town`，因为点在标签 ID 中是不允许的。
- en: A prefix can be added to these standard names by specifying it in `ViewData.TemplateInfo.HtmlFieldPrefix`.
    For instance, if the previous property is set to `MyPerson`, the name becomes `MyPerson.``Address.Town`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 `ViewData.TemplateInfo.HtmlFieldPrefix` 中指定前缀来向这些标准名称添加前缀。例如，如果前面的属性设置为
    `MyPerson`，则名称变为 `MyPerson.``Address.Town`。
- en: If the form is submitted to an action method that has the same `Person` class
    as one of its parameters, the name `Address.Town` given to the `input` field will
    cause the `Town` property of this parameter to be filled with the `input` field.
    In general, the string contained in the `input` field is converted into the type
    of the property they are matched with using the current request culture. Summing
    up, names of `input` fields are created in such a way that a complete `Person`
    model can be recovered in the action method when the HTML page is posted.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表单提交到具有与其中一个参数相同的 `Person` 类的动作方法，则分配给 `input` 字段的 `Address.Town` 名称将导致此参数的
    `Town` 属性被 `input` 字段填充。一般来说，`input` 字段中包含的字符串将转换为它们匹配的属性的类型，使用当前请求文化。总结来说，`input`
    字段的名称是以这种方式创建的，当 HTML 页面提交时，可以在动作方法中恢复完整的 `Person` 模型。
- en: The same `asp-for` attribute can be used in a `label` tag to cause the label
    to refer to the input field with the same `asp-for` value.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的 `asp-for` 属性可以在 `label` 标签中使用，使标签引用具有相同 `asp-for` 值的输入字段。
- en: 'The following code is an example of an `input`/`label` pair:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个 `input`/`label` 对的示例：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When no text is inserted in the label, the text shown in the label is taken
    from a `Display` attribute that decorates the property (`Town`, in the example),
    if any; otherwise, the name of the property is used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当标签中没有插入文本时，标签中显示的文本来自装饰属性的 `Display` 属性（如果有），例如示例中的 `Town` 属性；否则，使用属性的名称。
- en: If `span` or `div` contains a `data-valmsg-for="Address.Town"` error attribute,
    then validation messages concerning the  `Address.Town` input will be inserted
    automatically inside that tag. The validation framework is described in the *Connection
    between ASP.NET Core MVC and design principles* section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `span` 或 `div` 包含 `data-valmsg-for="Address.Town"` 错误属性，则有关 `Address.Town`
    输入的验证消息将自动插入该标签内。验证框架在 *ASP.NET Core MVC 与设计原则之间的联系* 部分中描述。
- en: 'It is also possible to automatically create a validation error summary by adding
    the attribute that follows to `div` or `span`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过将以下属性添加到 `div` 或 `span` 中来自动创建验证错误摘要：
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If the attribute is set to `ValidationSummary.ModelOnly`, only messages that
    are not associated with specific `input` fields will be shown in the summary,
    and if the value is `ValidationSummary.All`, all error messages will be shown.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性设置为 `ValidationSummary.ModelOnly`，则仅在摘要中显示与特定 `input` 字段不相关的消息，如果值为 `ValidationSummary.All`，则显示所有错误消息。
- en: The `asp-items` attribute allows specifying the options of `select` through
    `IEnumerable<SelectListItem>`, where each `SelectListItem` contains both the text
    and value of each option. `SelectListItem` contains also an optional `Group` property
    you can use to organize into groups the options shown in `select`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`asp-items` 属性允许通过 `IEnumerable<SelectListItem>` 指定 `select` 的选项，其中每个 `SelectListItem`
    包含每个选项的文本和值。`SelectListItem` 还包含一个可选的 `Group` 属性，您可以使用它将 `select` 中显示的选项组织成组。'
- en: The next topic shows how to reuse view code.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将展示如何重用视图代码。
- en: Reusing view code
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用视图代码
- en: ASP.NET Core MVC includes several techniques for reusing view code. The most
    important is the layout page.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 包含了多种用于重用视图代码的技术。其中最重要的是布局页面。
- en: In each web application, several pages share the same structure, for instance,
    the same main menu or the same left or right bar. In ASP.NET Core, this common
    structure is factored out in views called layout pages/views.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个网络应用程序中，多个页面共享相同的结构，例如，相同的主菜单或相同的左侧或右侧栏。在 ASP.NET Core 中，这种公共结构被提取到称为布局页面/视图的视图中。
- en: 'Each view can specify the view to use as its layout page with the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图都可以使用以下代码指定其布局页面：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If no layout page is specified, a default layout page, defined in the `_ViewStart.cshtml` file
    located in the `Views` folder, is used. The default content of `_ViewStart.cshtml` is
    as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定布局页面，则使用位于 `Views` 文件夹中的 `_ViewStart.cshtml` 文件中定义的默认布局页面。`_ViewStart.cshtml`
    的默认内容如下：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Therefore, the default layout page in the files scaffolded by Visual Studio
    is `_Layout.cshtml`, which is contained in the `Shared` folder.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由 Visual Studio 生成的文件中的默认布局页面是 `_Layout.cshtml`，它位于 `Shared` 文件夹中。
- en: 'The layout page contains the HTML shared with all of its children pages, the
    HTML page headers, and the page references to CSS and JavaScript files. The HTML
    produced by each view is placed inside of its layout place, where the layout page
    calls the `@RenderBody()` method, as shown in the following example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 布局页面包含与其所有子页面共享的 HTML、HTML 页面标题以及指向 CSS 和 JavaScript 文件的页面引用。每个视图生成的 HTML 都放置在其布局页面的内部，布局页面在这里调用
    `@RenderBody()` 方法，如下例所示：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`ViewState` of each `View` is copied into `ViewState` of its layout page, so
    `ViewState` can be used to pass information to the view layout page. Typically,
    it is used to pass the view title to the layout page that use it to compose the
    page''s title header, as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `View` 的 `ViewState` 都会被复制到其布局页面的 `ViewState` 中，因此 `ViewState` 可以用来将信息传递到视图布局页面。通常，它用于将视图标题传递到使用它来组成页面标题头的布局页面，如下所示：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: While the main content produced by each view is placed in a single area of its
    layout page, each layout page can also define several sections placed in different
    areas where each view can place further secondary contents.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每个视图生成的主要内容都放置在其布局页面的单个区域中，但每个布局页面也可以定义几个放置在不同区域中的部分，每个视图可以在这些部分中放置进一步的次要内容。
- en: 'For instance, suppose a layout page defines a `Scripts` section, as shown here:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设布局页面定义了一个 `Scripts` 部分，如下所示：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, the view can use the previously defined section to pass some view specific
    JavaScript references, as shown here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，视图可以使用之前定义的部分来传递一些特定的 JavaScript 引用，如下所示：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If an action method is expected to return HTML to an Ajax call, it must produce
    an HTML fragment instead of a whole HTML page. Therefore, in this case, no layout
    page must be used. This is achieved by calling the `PartialView` method instead
    of the `View` method in the controller action method. `PartialView` and `View` have
    exactly the same overloads and parameters.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果期望操作方法返回 HTML 以响应对 Ajax 的调用，它必须生成一个 HTML 片段而不是整个 HTML 页面。因此，在这种情况下，必须使用 `PartialView`
    方法而不是控制器操作方法中的 `View` 方法。`PartialView` 和 `View` 具有完全相同的重载和参数。
- en: 'Another way to reuse view code is to factor out a view fragment that''s common
    to several views into another view that is called by all previous views. A view
    can call another view with the `partial` tag, as shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用视图代码的另一种方式是将几个视图共有的视图片段提取到另一个由所有先前视图调用的视图中。视图可以使用 `partial` 标签调用另一个视图，如下所示：
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code invokes `_viewname` and passes it to the object contained
    in `Model.ModelProperty.NestedProperty` as its `ViewModel`. When a view is invoked
    by the `partial` tag, no layout page is used since the called view is expected
    to return an HTML fragment.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调用 `_viewname` 并将其传递给 `Model.ModelProperty.NestedProperty` 中包含的对象作为其 `ViewModel`。当一个视图通过
    `partial` 标签被调用时，不使用布局页面，因为期望被调用的视图返回一个 HTML 片段。
- en: The `ViewData.TemplateInfo.HtmlFieldPrefix` property of the called view is set
    to the `"ModelProperty.NestedProperty"` string. This way, possible input fields
    rendered in `_viewname.cshtml` will have the same name as if they were rendered
    directly by the calling view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用视图的 `ViewData.TemplateInfo.HtmlFieldPrefix` 属性被设置为 `"ModelProperty.NestedProperty"`
    字符串。这样，在 `_viewname.cshtml` 中渲染的可能输入字段将具有与它们直接由调用视图渲染时相同的名称。
- en: 'Instead of specifying the ViewModel of `_viewname` through a property of the
    caller view (ViewModel), you can also pass an object directly that is contained
    in a variable or returned by a C# expression by replacing `for` with `model`,
    as shown in this example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过调用视图的属性（ViewModel）来指定 `_viewname` 的 ViewModel 之外，您还可以通过将 `for` 替换为 `model`，直接传递包含在变量中或由
    C# 表达式返回的对象，如下例所示：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this case, `ViewData.TemplateInfo.HtmlFieldPrefix` of the called view keeps
    its default value, that is, the empty string.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，被调用视图的 `ViewData.TemplateInfo.HtmlFieldPrefix` 保持其默认值，即空字符串。
- en: 'A view can also call something more complex than another view, that is, another
    controller method that, in turn, renders a view. Controllers that are designed
    to be invoked by views are called **view components**. The following code is an
    example of component invocation:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 视图还可以调用比另一个视图更复杂的东西，即另一个控制器方法，该方法反过来又渲染一个视图。设计为被视图调用的控制器称为 **视图组件**。以下代码是组件调用的示例：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Parameter names must match the ones used in the view component method. However,
    both component name and parameter names must be translated into kebab case, that
    is, all characters must be transformed into lowercase and all characters that
    in the original name were in uppercase and each word must be separated by a `-`.
    For instance, `MyParam` must be transformed into `my-param.`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 参数名称必须与视图组件方法中使用的名称匹配。然而，组件名称和参数名称都必须转换为kebab case，即所有字符都必须转换为小写，原始名称中所有大写字符都必须转换为小写，并且每个单词必须由一个`-`分隔。例如，`MyParam`必须转换为`my-param.`。
- en: Actually, view components are classes that derive from the `ViewComponent` class.
    When a component is invoked, the framework looks for either an `Invoke` method
    or an `InvokeAsync` method and passes it to the parameters defined in the component
    invocation. `InvokeAsync` must be used if the method is defined as `async`; otherwise,
    we must use `Invoke`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，视图组件是继承自`ViewComponent`类的类。当组件被调用时，框架会寻找一个`Invoke`方法或`InvokeAsync`方法，并将其传递给组件调用中定义的参数。如果方法被定义为`async`，则必须使用`InvokeAsync`；否则，我们必须使用`Invoke`。
- en: 'The following code is an example of a view component definition:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个视图组件定义的示例：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The previously defined component must be invoked with a call such as the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的组件必须使用如下所示的调用进行调用：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the component is invoked by a view of a controller called  `MyController`,
    `ViewName` is searched in the following paths:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件被名为`MyController`的控制器视图调用，`ViewName`将在以下路径中进行搜索：
- en: '`/Views/MyController/Components/MyTest/ViewName`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/MyController/Components/MyTest/ViewName`'
- en: '`/Views/Shared/Components/MyTest/ViewName`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/Views/Shared/Components/MyTest/ViewName`'
- en: Now, let's look at the new features that came along with .NET Core 3.0.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看随着.NET Core 3.0一起出现的新特性。
- en: What is new in .NET Core 3.0 for ASP.NET Core?
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 3.0对于ASP.NET Core的新特性是什么？
- en: The main innovation introduced by ASP.NET 3.0 is that the routing engine was
    factored out of the MVC engine and is now available for other handlers. In previous
    versions, routes and routing were a part of the MVC handler added with `app.UseMvc(....)`;
    that now has been replaced by `app.UseRouting()` plus `UseEndpoints(...)`, which
    can route requests not only to controllers but also to other handlers.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 3.0引入的主要创新是将路由引擎从MVC引擎中分离出来，现在它可用于其他处理器。在之前的版本中，路由和路由是使用`app.UseMvc(....)`添加到MVC处理器的部分；现在已被`app.UseRouting()`加上`UseEndpoints(...)`所取代，这不仅可以将请求路由到控制器，还可以路由到其他处理器。
- en: 'Endpoints and their associated handlers are now defined in `UseEndpoints`,
    as shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 端点和它们关联的处理器现在在`UseEndpoints`中定义，如下所示：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`MapControllerRoute` associates patterns with controllers, but we may use also
    something such as `endpoints.MapHub<ChatHub>("/chat")`, which associates a pattern
    with a hub that handles WebSocket connections. In the previous section, we have
    seen that patterns can be associated also with custom handlers using `MapPost`
    and `MapGet`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapControllerRoute`将模式与控制器关联，但我们也可以使用类似`endpoints.MapHub<ChatHub>("/chat")`的东西，它将模式与处理WebSocket连接的hub关联。在上一节中，我们已经看到模式也可以通过`MapPost`和`MapGet`与自定义处理器关联。'
- en: 'An independent router also allows us to add authorizations not only to controllers
    but also to any handler, as shown here:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的路由器还允许我们不仅向控制器添加授权，还可以向任何处理器添加授权，如下所示：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the 3.0 version, ASP.NET Core has an independent JSON formatter and doesn''t
    depend on the third-party Newtonsoft JSON serializer any more. However, if you
    have more sophisticated needs, you have still the option to replace the minimal
    ASP.NET Core JSON formatter with Newtonsoft JSON serializer by installing the
    `Microsoft.AspNetCore.Mvc.NewtonsoftJson` NuGet package and configuring controllers,
    as shown here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在3.0版本中，ASP.NET Core有一个独立的JSON格式化程序，不再依赖于第三方Newtonsoft JSON序列化程序。然而，如果您有更复杂的需求，您仍然可以选择通过安装`Microsoft.AspNetCore.Mvc.NewtonsoftJson`
    NuGet包并配置控制器来用Newtonsoft JSON序列化程序替换最小化的ASP.NET Core JSON格式化程序，如下所示：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here, `AddNewtonsoftJson` has also an overload that accepts configuration options
    for the Newtonsoft JSON serializer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`AddNewtonsoftJson`还有一个接受Newtonsoft JSON序列化程序配置选项的重载：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In previous versions, you were forced to add both controllers and views to the
    DI engine. In version 3, we can still inject both controllers and views with `services.AddControllersWithViews`
    but you can also add controllers with `AddControllers` if you are going to implement
    REST endpoints only.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，您被迫向 DI 引擎添加控制器和视图。在版本 3 中，我们仍然可以使用 `services.AddControllersWithViews`
    注入控制器和视图，但如果您只打算实现 REST 端点，您也可以使用 `AddControllers` 添加控制器。
- en: 'In previous versions, ASP.NET Core had a custom implementation of `IWebHostBuilder`,
    which was completely independent of `HostBuilder`, which is the standard implementation
    of `IHostBuilder` used to configure a generic host. The following code shows how
    the ASP.NET Core host was configured before version 3.0:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的版本中，ASP.NET Core 有一个自定义的 `IWebHostBuilder` 实现，它与 `HostBuilder` 完全独立，而 `HostBuilder`
    是用于配置通用主机的标准 `IHostBuilder` 实现。以下代码显示了在版本 3.0 之前如何配置 ASP.NET Core 主机：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'ASP.NET Core 3.0, instead, uses a type that inherits from `HostBuilder` and
    adds the methods of `IWebHostBuilder`, as shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，ASP.NET Core 3.0 使用一个继承自 `HostBuilder` 的类型，并添加了 `IWebHostBuilder` 的方法，如下所示：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As a first step, `Host.CreateDefaultBuilder` creates a standard `HostBuilder`, `ConfigureWebHostDefaults`
    copies data contained in this `HostBuilder` in a derived class that also implements
    `IWebHostBuilder` and lets the developer configure this `IWebHostBuilder` in the
    action that it receives as an argument. `IWebHostBuilder`, once configured, is
    returned as `IHostBuilder` so that all web-specific things remain hidden.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，`Host.CreateDefaultBuilder` 创建了一个标准的 `HostBuilder`，`ConfigureWebHostDefaults`
    将 `HostBuilder` 中包含的数据复制到一个派生类中，该类也实现了 `IWebHostBuilder`，并允许开发者在接收到的动作中配置这个 `IWebHostBuilder`。一旦配置完成，`IWebHostBuilder`
    就作为 `IHostBuilder` 返回，这样所有特定于 Web 的事情都保持隐藏。
- en: This way development paths of `HostBuilder` and `WebHostBuilder` have been merged,
    and new enhancements and extension methods of `IHostBuilder` are automatically
    available also for the ASP.NET Core host.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`HostBuilder` 和 `WebHostBuilder` 的发展路径已经合并，`IHostBuilder` 的新增强和扩展方法也自动对 ASP.NET
    Core 主机可用。
- en: Understanding the connection between ASP.NET Core MVC and design principles
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 ASP.NET Core MVC 和设计原则之间的联系
- en: The whole ASP.NET Core framework is built on top of the design principles and
    patterns that we analyzed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, [Chapter
    6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data in C# -
    Entity Framework Core*, [Chapter 9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml),
    *Design Patterns and .NET Core Implementation*, [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml),
    *Understanding the Different Domains in Software Solutions*, and [Chapter 11](4e308a45-a1ff-4a45-bea9-ba648b1e9ccd.xhtml),
    *Implementing Code Reusability in C# 8*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 ASP.NET Core 框架都是建立在我们在 [第 5 章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，*将微服务架构应用于您的企业应用程序*，[第
    6 章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)，*在 C# 中与数据交互 - Entity Framework
    Core*，[第 9 章](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml)，*设计模式和 .NET Core 实现*，[第
    10 章](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml)，*理解软件解决方案中的不同领域*，以及 [第 11 章](4e308a45-a1ff-4a45-bea9-ba648b1e9ccd.xhtml)，*在
    C# 8 中实现代码重用* 中分析的设计原则和模式之上。
- en: All functionalities are provided through DI so that each of them can be replaced
    without affecting the remainder of the code. However, providers needed by ASP.NET
    Core pipeline modules are grouped into option objects instead of being added individually
    to the DI engine to conform to the SOLID Single Responsibility Principle.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 所有功能都通过 DI 提供，以便每个功能都可以替换，而不会影响代码的其他部分。然而，ASP.NET Core 管道模块所需的提供者被分组到选项对象中，而不是单独添加到
    DI 引擎中，以符合 SOLID 单一责任原则。
- en: Moreover, configuration data, instead of being available from a unique dictionary
    created from a configuration file, is organized into option objects thanks to
    the options framework we described in the first section of this chapter. This
    is an application of the SOLID Interface Segregation Principle.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，配置数据，而不是从配置文件创建的唯一字典中可用，是通过我们在本章第一部分中描述的选项框架组织到选项对象中的。这是 SOLID 接口隔离原则的应用。
- en: 'However, ASP.NET Core also applies other patterns that are specific instances
    of the general Separation of Concerns principle, which is a generalization of
    the Single Responsibility Principle. They are as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ASP.NET Core 还应用了其他特定于一般关注点分离原则的通用模式，这是单一责任原则的泛化。它们如下所示：
- en: The middleware modules architecture (ASP.NET Core pipeline)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件模块架构（ASP.NET Core 管道）
- en: Factoring out validation and globalization from the application code
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序代码中分解验证和全球化
- en: The MVC pattern itself
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC 模式本身
- en: We will analyze all of these in the various subsections that follow.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的各个子节中分析所有这些内容。
- en: Advantages of the ASP.NET Core pipeline
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道优势
- en: 'The ASP.NET Core pipeline architecture has two important advantages:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 管道架构有两个重要优势：
- en: All different operations performed on the initial request are factored out into
    different modules, according to the Single Responsibility Principle.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据单一职责原则，所有在初始请求上执行的不同操作都被分解到不同的模块中。
- en: The modules that perform these different operations don't need to call each
    other because each module is invoked once and for all by the ASP.NET Core framework.
    This way, the code for each module is not required to perform any action that
    is connected with responsibilities assigned to other modules.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行这些不同操作的模块不需要相互调用，因为每个模块都由 ASP.NET Core 框架一次性调用。这样，每个模块的代码就不需要执行与分配给其他模块的责任相关的任何操作。
- en: This ensures maximum independence of functionalities and simpler code. For instance,
    once authorization and authentication modules are on, no other module needs to
    worry about authorization anymore. Each controller code can focus on application-specific
    business stuff.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了功能的最大独立性以及代码的简化。例如，一旦授权和身份验证模块启动，其他模块就无需再担心授权问题。每个控制器代码可以专注于特定于应用程序的业务内容。
- en: Server-side and client-side validation
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端和客户端验证
- en: Validation logic has been completely factored out from the application code
    and has been confined in the definition of validation attributes. The developer
    needs to just specify the validation rule to apply to each model property by decorating
    the property with an adequate validation attribute.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 验证逻辑已经完全从应用程序代码中分解出来，并被限制在验证属性的定义中。开发者只需通过在属性上装饰适当的验证属性来指定应用于每个模型属性的验证规则。
- en: Validation rules are checked automatically when action method parameters are
    instantiated. Both errors and paths in the model (where they occurred) are then
    recorded in a dictionary that is contained in the `ModelState` controller property.
    The developer has the responsibility to verify whether there are errors by checking
    `ModelState.IsValid`, in which case the developer must return the same ViewModel
    to the same view so that the user can correct all errors.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当动作方法参数实例化时，验证规则会自动进行检查。随后，错误和模型中的路径（它们发生的位置）将被记录在 `ModelState` 控制器属性中包含的字典中。开发者有责任通过检查
    `ModelState.IsValid` 来验证是否存在错误，在这种情况下，开发者必须返回相同的 ViewModel 到相同的视图，以便用户可以纠正所有错误。
- en: 'Error messages are automatically shown in the view with no action required
    to the developer. The developer is only required to do the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息会自动在视图中显示，无需开发者采取任何行动。开发者只需执行以下操作：
- en: Add `span` or `div` with `data-valmsg-for attribute` next to each input field
    that will be automatically filled with the possible error.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个将被自动填充可能错误输入字段的旁边添加带有 `data-valmsg-for` 属性的 `span` 或 `div`。
- en: Add `div` with an `asp-validation-summary` attribute that will be automatically
    filled with the validation error summary. See the *Tag helpers* topic for more
    details.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加带有 `asp-validation-summary` 属性的 `div`，它将被自动填充验证错误摘要。有关更多详细信息，请参阅 *标签助手* 主题。
- en: 'It is enough to add some JavaScript references by invoking the `_ValidationScriptsPartial.cshtml`
    view with the `partial` tag to enable the same validation rules also on the client-side,
    so that errors are shown to the user before the form is posted to the server.
    Some predefined validation attributes are contained in the `System.ComponentModel.DataAnnotations`
    and `Microsoft.AspNetCore.Mvc` namespaces and include the following attributes:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 只需通过调用带有 `partial` 标签的 `_ValidationScriptsPartial.cshtml` 视图来添加一些 JavaScript
    引用，就可以在客户端启用相同的验证规则，这样在表单提交到服务器之前，错误就会显示给用户。`System.ComponentModel.DataAnnotations`
    和 `Microsoft.AspNetCore.Mvc` 命名空间中包含一些预定义的验证属性，包括以下属性：
- en: The `Required` attribute requires the user to specify a value for the property
    that it decorates. An implicit `Required` attribute is automatically applied to
    all non-nullable properties such as all floats, integers, and decimals since they
    can't have a `null` value.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Required`属性要求用户为其装饰的属性指定一个值。对于所有非空属性（如所有浮点数、整数和小数）自动应用隐式的`Required`属性，因为它们不能有`null`值。'
- en: The `Range` attribute constrains numeric quantities within a range.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Range`属性限制了数字数量在某个范围内。'
- en: They also include attributes that constrain string lengths.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们还包括限制字符串长度的属性。
- en: Custom error messages can be inserted directly in the attributes, or attributes
    can refer to the property of resource types containing them.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接在属性中插入自定义错误消息，或者属性可以引用包含它们的资源类型属性。
- en: The developer can define its custom attributes by providing the validation code
    both in C# and in JavaScript for client-side validation.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者可以通过提供C#和JavaScript中的验证代码来定义其自定义属性，以进行客户端验证。
- en: 'Attribute-based validation can be replaced by other validation providers, such
    as fluent validation that defines validation rules for each type using a fluent
    interface. It is enough to change a provider in a collection contained in the
    MVC options object that can be configured through an action passed to the `services.AddControllersWithViews`
    method. MVC options are configured as shown here:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用其他验证提供者替换基于属性的验证，例如使用流畅接口为每个类型定义验证规则的流畅验证。只需更改包含在可以通过传递给`services.AddControllersWithViews`方法的操作配置的MVC选项对象中的提供者即可。MVC选项的配置如下所示：
- en: '[PRE59]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The validation framework automatically checks whether numeric and date inputs
    are well formatted according to the selected culture.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 验证框架会自动检查数字和日期输入是否根据所选文化格式良好。
- en: ASP.NET Core globalization
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core全球化
- en: In multicultural applications, pages must be served according to the language
    and culture preferences of each user. Typically, multicultural applications can
    serve their content in a few languages, and they can handle dates and numeric
    formats in several more languages. In fact, while the content in all supported
    languages must be produced manually, .NET Core has the native capability of formatting
    and parsing dates and numbers in all cultures.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在多文化应用中，页面必须根据每个用户的语言和文化偏好进行服务。通常，多文化应用可以在几种语言中提供其内容，并且可以处理多种语言的日期和数字格式。实际上，尽管所有支持的语言内容都必须手动生成，但.NET
    Core具有在所有文化中格式化和解析日期和数字的本地能力。
- en: For instance, a web application might support unique content for all English-based
    cultures (en),  but all known English-based cultures for numbers and dates formats
    (en-US, en-GB, en-CA, and so on).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个Web应用程序可能支持所有基于英语的文化（en）的独特内容，但对于所有已知的基于英语的数字和日期格式（en-US、en-GB、en-CA等）的内容。
- en: The culture used for numbers and dates in a .NET thread is contained in the `Thread.CurrentThread.CurrentCulture` property.
    Hence, by setting this property to `new CultureInfo("en-CA")`, numbers and dates
    will be formatted/parsed according to the Canadian culture. `Thread.CurrentThread.CurrentUICulture`,
    instead, decides the culture of the resource files, that is, it selects a culture-specific
    version of each resource file or view. Accordingly, a multicultural application
    is required to set the two cultures associated to the request thread and to organize
    multilingual content into language dependent resource files and/or views.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET线程中用于数字和日期的文化包含在`Thread.CurrentThread.CurrentCulture`属性中。因此，通过将此属性设置为`new
    CultureInfo("en-CA")`，数字和日期将根据加拿大文化进行格式化/解析。相反，`Thread.CurrentThread.CurrentUICulture`决定资源文件的文化，即它选择每个资源文件或视图的文化特定版本。因此，多文化应用程序需要设置与请求线程相关的两个文化，并将多语言内容组织到语言相关的资源文件和/或视图中。
- en: 'According to the Separation of Concerns principle, the whole logic used to
    set the request culture according to the user preferences is factored out into
    a specific module of the ASP.NET Core pipeline. To configure this module, as a
    first step, we set the supported date/numbers cultures, as in the following example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 根据关注点分离原则，用于根据用户偏好设置请求文化的整个逻辑被分解为ASP.NET Core管道的特定模块。作为第一步，我们设置支持的日期/数字文化，如下例所示：
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we set the languages supported for the content. Usually, a version of
    the language that is not specific for any country is selected to keep the number
    of translations small enough, as shown here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置支持的内容语言。通常，选择不针对任何国家的语言版本以保持翻译数量足够小，如下所示：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we add the culture middleware to the pipeline, as shown here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文化中间件添加到管道中，如下所示：
- en: '[PRE62]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the culture requested by the user is explicitly found among the ones listed
    in `supportedCultures` or `supportedUICultures`, it is used without modifications.
    Otherwise, since `FallBackToParentCultures` and `FallBackToParentUICultures` are
    `true`, the parent culture is tried, that is, for instance, if the required `fr-FR`
    culture is not found among those listed, then the framework searches for its generic
    version, `fr`. If this attempt also fails, the framework uses the cultures specified
    in `DefaultRequestCulture`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户请求的文化在`supportedCultures`或`supportedUICultures`中明确列出，则使用它而不做修改。否则，由于`FallBackToParentCultures`和`FallBackToParentUICultures`为`true`，将尝试父文化，即例如，如果所需的`fr-FR`文化在列出的那些中找不到，那么框架将搜索其通用版本，`fr`。如果这次尝试也失败了，框架将使用在`DefaultRequestCulture`中指定的文化。
- en: 'By default, the `culture` middleware searches the culture selected for the
    current user with three providers that are tried in the order shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`culture`中间件通过以下顺序尝试三个提供者来搜索为当前用户选择的文化：
- en: The middleware looks for the `culture` and `ui-culture` query string parameters.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间件会查找`culture`和`ui-culture`查询字符串参数。
- en: 'If the previous step fails, the middleware looks for a cookie named `.AspNetCore.Culture`,
    the value of which is expected to be as in this example: `c=en-US|uic=en`.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前一个步骤失败，中间件会查找名为`.AspNetCore.Culture`的cookie，其值预期如下示例：`c=en-US|uic=en`。
- en: If both previous steps fail, the middleware looks for the `Accept-Language`
    request header sent by the browser, which can be changed in the browser settings,
    and that is initially set to the operating system culture.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前两个步骤都失败了，中间件会查找浏览器发送的`Accept-Language`请求头，这个可以在浏览器设置中更改，并且最初设置为操作系统的文化。
- en: With the preceding strategy, the first time a user requests an application page,
    the browser culture is taken (the provider listed in *step 3*). Then, if the user
    clicks a language-change link with the right query string parameters, a new culture
    is selected by provider 1\. Usually, after a language link is clicked, the server also generates
    a language cookie to remember the user's choice through provider 2.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的策略，当用户第一次请求应用程序页面时，浏览器文化被采用（在*步骤3*中列出的提供者）。然后，如果用户点击带有正确查询字符串参数的语言更改链接，提供者1将选择一个新的文化。通常，在点击语言链接后，服务器也会生成一个语言cookie，通过提供者2记住用户的选择。
- en: The simplest way to provide content localization is to provide a different view
    for each language. Hence, if we would like to localize the `Home.cshtml` view
    for different languages, we must provide views named `Home.en.cshtml`, `Home.es.cshtml`,
    and so on. If no view specific for the `ui-culture` thread is found, the not localized
    `Home.cshtml` version of the view is chosen.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 提供内容本地化的最简单方法是为每种语言提供不同的视图。因此，如果我们想为不同的语言本地化`Home.cshtml`视图，我们必须提供名为`Home.en.cshtml`、`Home.es.cshtml`等视图。如果没有找到特定于`ui-culture`线程的视图，将选择未本地化的`Home.cshtml`视图版本。
- en: 'View localization must be enabled by calling the `AddViewLocalization` method,
    as shown here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`AddViewLocalization`方法启用视图本地化，如下所示：
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Another option is to store simple strings or HTML fragments in resource files
    specific for all supported languages. The usage of resource files must be enabled
    by calling the `AddLocalization` method in the configure services section, as
    shown here:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将简单的字符串或HTML片段存储在针对所有支持的语言特定的资源文件中。必须在配置服务部分调用`AddLocalization`方法来启用资源文件的使用，如下所示：
- en: '[PRE64]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`ResourcesPath` is the root folder where all resource files will be placed.
    If it is not specified, the empty string is assumed, and resource files will be
    placed in the web application root. Resource files for a specific view, say the
    `/Views/Home/Index.cshtml` view, must have a path like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourcesPath`是所有资源文件将被放置的根文件夹。如果没有指定，则假定是空字符串，资源文件将放置在Web应用程序的根目录中。特定视图的资源文件，例如`/Views/Home/Index.cshtml`视图，必须具有如下路径：'
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Hence, if `ResourcesPath` is empty, resources must have the `/Views/Home/Index.<culture
    name>.resx` path, that is, they must be placed in the same folder as the view.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `ResourcesPath` 为空，资源必须具有 `/Views/Home/Index.<culture name>.resx` 路径，即它们必须放置在与视图相同的文件夹中。
- en: 'Once key-value pairs to all resource files associated with a view are added,
    localized HTML fragments can be added to the view as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了与视图关联的所有资源文件的键值对，就可以按照以下方式将本地化 HTML 片段添加到视图中：
- en: Inject `IViewLocalizer` in the view with `@inject IViewLocalizer Localizer`.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@inject IViewLocalizer Localizer` 在视图中注入 `IViewLocalizer`。
- en: Where needed, replace the text in the View with accesses to the `Localizer`
    dictionary, such as `Localizer["myKey"]`, where `"myKey"` is a key used in the
    resource files.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在需要的地方，将视图中的文本替换为对 `Localizer` 字典的访问，例如 `Localizer["myKey"]`，其中 `"myKey"` 是资源文件中使用的键。
- en: 'The following code shows an example of the `IViewLocalizer` dictionary:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了 `IViewLocalizer` 字典的示例：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If localization fails because the key is not found in the resource file, the
    key itself is returned. Strings used in data annotation, such as validation attributes,
    are used as a key in resource files if data annotation localization is enabled,
    as shown here:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本地化失败，因为资源文件中没有找到键，则返回键本身。如果启用了数据注释本地化，则用于数据注释中的字符串（如验证属性）用作资源文件中的键，如下所示：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Resource files for data annotations applied to a class whose full name is,
    say, `MyWebApplication.ViewModels.Account.RegisterViewModel`, must have the following
    path:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于具有全名 `MyWebApplication.ViewModels.Account.RegisterViewModel` 的类的数据注释资源文件必须具有以下路径：
- en: '[PRE68]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It is worth to point out that the first segment of the namespace that corresponds
    to the `.dll` application name is replaced by `ResourcePath`. If `ResourcesPath`
    is empty and if you use the default namespaces created by Visual Studio, then
    resource files must be placed in the same folder of the classes they are associated
    with.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，与 `.dll` 应用程序名称对应的命名空间的第一部分被替换为 `ResourcePath`。如果 `ResourcesPath` 为空，并且您使用
    Visual Studio 创建的默认命名空间，那么资源文件必须放置在与它们关联的类相同的文件夹中。
- en: It is possible to localize strings and HTML fragments in controllers or wherever
    dependencies can be injected by associating each group of resource files with
    a type, such as `MyType`, and then injecting either `IHtmlLocalizer<MyType>` for
    HTML fragments or `IStringLocalizer<MyType>` for strings that need to be HTML
    encoded.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将每个资源文件组与一个类型关联（例如 `MyType`），然后注入 `IHtmlLocalizer<MyType>` 用于 HTML 片段或 `IStringLocalizer<MyType>`
    用于需要 HTML 编码的字符串，在控制器或可以注入依赖项的地方本地化字符串和 HTML 片段。
- en: Their usage is identical to the usage of `IViewLocalizer`. The path of the resource
    files associated with `MyType` is computed as in the case of data annotations.
    If you would like to use a unique group of resource files for the whole application,
    a common choice is to use the `Startup` class as the reference type (`IStringLocalizer<Startup >` and
    `IHtmlLocalizer<Startup >`). Another common choice is the creation of various
    empty classes to use as reference types for various groups of resource files.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的用法与 `IViewLocalizer` 的用法相同。与数据注释的情况一样，计算与 `MyType` 关联的资源文件的路径。如果您希望为整个应用程序使用一组唯一的资源文件，一个常见的做法是将
    `Startup` 类用作参考类型（`IStringLocalizer<Startup>` 和 `IHtmlLocalizer<Startup>`）。另一个常见的做法是创建各种空类，用作各种资源文件组的参考类型。
- en: After having learned how to manage globalization in your ASP.NET Core projects,
    in the next subsection, we can move to the description of the more important pattern
    used by ASP.NET Core MVC to enforce the *Separation of Concerns*, the MVC pattern
    itself.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何在 ASP.NET Core 项目中管理全球化之后，在下一个子节中，我们可以转向描述 ASP.NET Core MVC 用来强制执行 *关注点分离*
    的更重要的模式，即 MVC 模式本身。
- en: The MVC pattern
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC 模式
- en: MVC is a pattern for the implementation of presentation layers of a web application.
    The basic idea is to apply a *Separation of Concerns* between the logic of the
    presentation layer and its graphics. Logic is taken care of by controllers, while
    graphics are factored out into views. Controllers and views communicate through
    the model, which is often called the ViewModel to distinguish it from the models
    of the business and data layers
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一种用于实现 Web 应用程序表示层的模式。其基本思想是在表示层的逻辑和其图形之间应用 *关注点分离*。逻辑由控制器处理，而图形则分解到视图中。控制器和视图通过模型进行通信，该模型通常被称为
    ViewModel，以区别于业务和数据层的模型。
- en: However, what is the logic of a presentation layer? In [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml),
    *Understanding the Importance of Software Architecture*, we saw that software
    requirements can be documented with use cases that describe the interaction between
    the user and the system. Roughly, the logic of the presentation layer consists
    of the management of use cases, hence, roughly, use cases are mapped to controllers
    and every single operation of a use case is mapped to an action method of those
    controllers. Hence, controllers take care of managing the protocol of interaction
    with the user and rely on the business layer for any business processing involved
    during each operation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表示层的逻辑是什么？在[第 1 章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)《理解软件架构的重要性》中，我们了解到软件需求可以通过描述用户与系统之间交互的用例来记录。大致来说，表示层的逻辑包括用例的管理，因此，大致来说，用例映射到控制器，每个用例的每个操作都映射到这些控制器的操作方法。因此，控制器负责管理与用户的交互协议，并在每个操作中涉及的业务处理方面依赖于业务层。
- en: Each action method receives data from the user, performs some business processing
    and, depending on the results of this processing, decides what to show to the
    user and encodes it in the ViewModel. Views receive ViewModels that describe what
    to show to the user and decide the graphics to use, that is, HTML to use.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作方法都从用户那里接收数据，执行一些业务处理，并根据处理结果决定向用户展示什么，并将其编码在 ViewModel 中。视图接收 ViewModel，描述要向用户展示的内容，并决定使用哪种图形，即使用哪种
    HTML。
- en: 'What are the advantages of separating logic and graphics into two different
    components? The main advantages are listed here:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 将逻辑和图形分离成两个不同组件的优势是什么？主要优势如下：
- en: Changes in graphics do not affect the remainder of the code, so you can experiment
    with various graphic options to optimize the interaction with the user without
    putting the reliability of the remainder of the code at risk.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形的变化不会影响代码的其他部分，因此您可以在不危及代码其他部分可靠性的情况下尝试各种图形选项来优化与用户的交互。
- en: The application can be tested by instantiating controllers and passing the parameters,
    with no need to use testing tools that operate on the browser pages. In this way,
    tests are easier to implement. Moreover, they do not depend on the way graphics
    are implemented, so they do not need to be updated each time graphic changes.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可以通过实例化控制器并传递参数进行测试，无需使用在浏览器页面上操作的测试工具。这样，测试更容易实现。此外，它们不依赖于图形的实现方式，因此不需要在图形更改时更新。
- en: It is easier to split the job between developers that implements controllers
    and graphic designers that implements views. Often, graphical designers have difficulties
    with Razor, so they might just furnish an example HTML page that developers transform
    into Razor views that operate on the actual data.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现控制器的开发人员和实现视图的图形设计师之间分配工作更容易。通常，图形设计师在 Razor 中会遇到困难，所以他们可能只提供一个示例 HTML 页面，开发人员将其转换为在真实数据上操作的
    Razor 视图。
- en: Now, let's look at how to create a web app in ASP.NET Core MVC.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在 ASP.NET Core MVC 中创建 Web 应用。
- en: Use case – implementing a web app in ASP.NET Core MVC
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 在 ASP.NET Core MVC 中实现 Web 应用
- en: In this section, as an example of the ASP.NET Core application, we will implement
    the administrative panel for managing destinations and packages of the `WWTravelClub` book
    use case. The application will be implemented with the **Domain-Driven Design**
    (**DDD**) approach described in [Chapter 10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml),
    *Understanding the Different Domains in Software Solutions*, therefore, a good
    understanding of that chapter is a fundamental prerequisite for reading this section.
    The subsections that follow describe, the overall application specifications and
    organization and then the various application parts.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将以 ASP.NET Core 应用程序的示例，实现 `WWTravelClub` 书籍用例的行政面板，用于管理目的地和包裹。该应用程序将使用第
    10 章[理解软件解决方案中的不同领域](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml)中描述的**领域驱动设计**（**DDD**）方法来实现，因此，对该章节的良好理解是阅读本节的基本先决条件。接下来的小节将描述整体应用程序规范和组织，然后是应用程序的各个部分。
- en: Defining application specifications
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序规范
- en: 'The destinations and packages have been described in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*. Here, we will use exactly
    the same data model, with the necessary modifications to adapt it to the DDD approach.
    The administrative panel must allow packages, a destinations listing, and CRUD
    operations on them. To simplify the application, the two listings will be quite
    simple: the application will show all destinations sorted according to their names
    and all packages sorted starting from the ones with a higher-end validity date.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地和包已在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中描述，*在C#中与数据交互 - Entity
    Framework Core*。在这里，我们将使用完全相同的数据模型，并对其进行必要的修改以适应DDD方法。行政面板必须允许包、目的地列表以及对其的CRUD操作。为了简化应用程序，这两个列表将非常简单：应用程序将按名称排序显示所有目的地，并按高端有效日期排序显示所有包。
- en: 'Moreover, we suppose the following things:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们假设以下事项：
- en: The application that shows destinations and packages to the user shares the
    same database used by the administrative panel. Since only the administrative
    panel application needs to modify data, there will be just one write copy of the
    database with several read-only replicas.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户展示目的地和包的应用程序与行政面板使用的相同数据库。由于只有行政面板应用程序需要修改数据，因此将只有一个写数据库副本和几个只读副本。
- en: Price modifications and package deletions are immediately used to update the
    user shopping carts. For this reason, the administrative application must send
    asynchronous communications about price changes and package removals. We will
    not implement the whole communication logic, but we will just add all such events
    to an event table, which should be used as input to a parallel thread in charge
    of sending these events to all relevant microservices.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格修改和包删除会立即用于更新用户的购物车。因此，管理应用程序必须发送有关价格变化和包移除的异步通信。我们不会实现整个通信逻辑，但我们会将所有此类事件添加到事件表中，该表应作为发送这些事件到所有相关微服务的并行线程的输入使用。
- en: Here, we will give the full code for just the package management, while most
    of the code for destination management is left as an exercise for the reader.
    The full code is available in the `chapter 13` folder of the GitHub repository
    associated with this book. In the remainder of the section, we will describe the
    application overall organization and we will discuss some relevant samples of
    code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将提供包管理的完整代码，而大部分目的地管理的代码将留给读者作为练习。完整代码可在与本书相关的GitHub存储库的`chapter 13`文件夹中找到。在本节的剩余部分，我们将描述应用程序的整体组织，并讨论一些相关的代码示例。
- en: Defining the application architecture
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序架构
- en: 'The application is organized along with the guidelines described in [Chapter
    10](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml), *Understanding Different Domains
    in a Software Solution*, considering the DDD approach and using SOLID principles
    to map your domain sections. That is, the application is organized within three
    layers, each implemented as a different project:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的组织遵循[第10章](2a42483c-2193-4bd4-91b4-0fdce94f6ed1.xhtml)中描述的指南，*理解软件解决方案中的不同领域*，考虑到DDD方法和使用SOLID原则来映射您的领域部分。也就是说，应用程序在三个层内组织，每个层都作为不同的项目实现：
- en: 'There''s a data layer that contains repository implementation and classes describing
    database entities. It is a .NET Core library project. However, since it needs
    some HTTP stack interfaces and classes, we must add a reference not only to the
    .NET Core SDK but also to the ASP.NET Core SDK. This can be done as follows:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个数据层，其中包含存储库实现和描述数据库实体的类。它是一个.NET Core库项目。然而，由于它需要一些HTTP堆栈接口和类，我们必须不仅添加对.NET
    Core SDK的引用，还要添加对ASP.NET Core SDK的引用。可以按以下方式完成：
- en: Right-click on the project icon in the solution explorer and select Edit project
    file.
  id: totrans-377
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目图标，然后选择编辑项目文件。
- en: In the edit window, replace `<Project Sdk="Microsoft.NET.Sdk">` with `<Project
    Sdk="Microsoft.NET.Sdk.web">` and save.
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑窗口中，将 `<Project Sdk="Microsoft.NET.Sdk">` 替换为 `<Project Sdk="Microsoft.NET.Sdk.web">`
    并保存。
- en: Since, after this modification, Visual Studio automatically turns this library
    project into an application project, please right-click on the project again and
    select Properties. In the project property window, replace Console Application with
    Class Library in the Output Type drop-down list.
  id: totrans-379
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在此修改后，Visual Studio会自动将此库项目转换为应用程序项目，请再次右键单击项目并选择属性。在项目属性窗口中，在“输出类型”下拉列表中将“控制台应用程序”替换为“类库”。
- en: There's also a domain layer that contains repository specifications, that is,
    interfaces that describe repository implementations and DDD aggregates. In our
    implementation, we decided to implement aggregates by hiding forbidden operations/properties
    of root data entities behind interfaces. Hence, for instance, the `Package` data
    layer class, which is an aggregate root, has a corresponding `IPackage` interface
    in the domain layer that hides all the property setters of the `Package` entity.
    The domain layer also contains the definitions of all the domain events, while
    the corresponding event handlers are defined in the application layer.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层还包含仓储规范，即描述仓储实现和 DDD 聚合的接口。在我们的实现中，我们决定通过隐藏根数据实体的禁止操作/属性来隐藏聚合的实现。因此，例如，`Package`
    数据层类，它是一个聚合根，在领域层有一个相应的 `IPackage` 接口，隐藏了 `Package` 实体的所有属性设置器。领域层还包含所有领域事件的定义，而相应的事件处理器在应用层定义。
- en: Finally, there's the application layer, that is, the ASP.NET Core MVC application,
    where we define DDD queries, commands, command handlers, and event handlers. Controllers
    fill query objects and execute them to get ViewModels they can pass to views.
    They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces and `IUnitOfWork`
    coming from the domain layer to manage and coordinate transactions.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，是应用层，即 ASP.NET Core MVC 应用程序，在这里我们定义 DDD 查询、命令、命令处理器和事件处理器。控制器填充查询对象并执行它们以获取可以传递给视图的
    ViewModels。它们通过填充命令对象并执行相关的命令处理器来更新存储。反过来，命令处理器使用来自领域层的 `IRepository` 接口和 `IUnitOfWork`
    来管理和协调事务。
- en: The application uses the Query Command Segregation pattern; therefore, it uses
    command objects to modify the storage and the query object to query it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用查询命令分离模式；因此，它使用命令对象来修改存储，并使用查询对象来查询它。
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly on the ViewModels used by the controller
    Views with `Select` LINQ methods. You may also decide to hide the LINQ implementation
    behind the same repository classes used for the storage update operations.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的使用和实现都很简单：控制器填充它们的参数，然后调用它们的执行方法。反过来，查询对象有直接的 LINQ 实现，它们使用 `Select` LINQ
    方法直接在控制器视图使用的 ViewModels 上投影结果。你也可以决定将 LINQ 实现隐藏在用于存储更新操作的相同仓储类后面。
- en: However, since repositories don't know anything about ViewModels, which is presentation
    layer stuff, in this case, you are forced to use intermediate objects defined
    in the domain layer (DTOs), which must then be copied into ViewModels. This would
    make the definition of new queries and the modification of existing queries time-consuming
    operations since you are forced to modify several classes. In any case, it is
    good practice to hide query objects behind interfaces so their implementations
    can be replaced by fake implementations when you test controllers.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于仓储不知道 ViewModels 的任何信息，这是表示层的内容，在这种情况下，你被迫使用领域层中定义的中间对象（DTOs），然后必须将它们复制到
    ViewModels 中。这会使定义新的查询和修改现有查询变得耗时，因为你被迫修改多个类。无论如何，将查询对象隐藏在接口后面是一种良好的实践，这样在测试控制器时可以替换它们的实现。
- en: The chain of objects and calls involved in the execution of commands, instead,
    is more complex since it requires the construction and modification of aggregates
    and the definition of the interaction between several aggregates and between aggregates
    and other applications through domain events.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行过程中涉及的对象和调用链更为复杂，因为它需要构建和修改聚合，并定义多个聚合之间以及聚合与其他应用程序之间的交互。
- en: 'The following diagram is a sketch of how storage update operations are performed:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是存储更新操作执行过程的草图：
- en: '![](img/021af0cc-d971-4a14-8e91-bc4bd5998063.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/021af0cc-d971-4a14-8e91-bc4bd5998063.png)'
- en: A controller's action method receives one or more ViewModels and performs validation.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器的操作方法接收一个或多个 ViewModels 并执行验证。
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    defined in the domain layer. They are used to fill the properties of a command
    object.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个包含要应用更改的 ViewModels 被隐藏在领域层定义的接口后面。它们用于填充命令对象的属性。
- en: A command handler matching the previous command is retrieved via DI in the controller
    action method (through the`[FromServices]` parameter attribute we described in
    the *Controllers and ViewModels* subsection). Then, the handler is executed.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器操作方法中通过依赖注入检索与之前命令匹配的命令处理器（通过我们描述的 `[FromServices]` 参数属性）。然后执行处理器。
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all `IRepostory` implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and to modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each `IRepository`, and the concurrency exceptions returned by the data layer
    to organize their operations as transactions. It is worth pointing out that each
    aggregate has its own `IRepository`, and that the whole logic for updating each
    aggregate is defined in the aggregate itself and not in its associated `IRepository`
    to keep the code more modular.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 *步骤 3* 中讨论的命令处理器时，ASP.NET Core DI 引擎自动注入其构造函数中声明的所有参数。特别是，它注入了执行所有命令处理器事务所需的全部
    `IRepostory` 实现所需的所有参数。命令处理器通过调用其构造函数中接收到的这些 `IRepository` 实现的方法来构建聚合并修改已构建的聚合来完成其工作。聚合要么代表已存在的实体，要么代表新创建的实体。处理器使用包含在每个
    `IRepository` 中的 `IUnitOfWork` 接口和数据层返回的并发异常来组织它们的操作作为事务。值得注意的是，每个聚合都有自己的 `IRepository`，并且更新每个聚合的整个逻辑都定义在聚合本身中，而不是在其关联的
    `IRepository` 中，以保持代码更模块化。
- en: Behind the scenes, in the data layer, `IRepository` implementations use Entity
    Framework to perform their job. Aggregates are implemented by root data entities
    hidden behind interfaces defined in the domain layer, while `IUnitOfWork` methods
    that handle transactions and that pass changes to the database are implemented
    with `DBContext` methods. In other words, `IUnitOfWork` is implemented with the
    application's `DBContext`.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在幕后，在数据层中，`IRepository` 实现使用 Entity Framework 来执行其任务。聚合通过领域层中定义的接口背后的根数据实体来实现，而处理事务并将更改传递到数据库的
    `IUnitOfWork` 方法则使用 `DBContext` 方法实现。换句话说，`IUnitOfWork` 是通过应用程序的 `DBContext` 实现的。
- en: Domain events are generated during each aggregate processing and added to the
    aggregates themselves by calling their `AddDomainEvent` methods. However, they
    are not triggered immediately. Usually, they are triggered at the end of all the
    aggregates' processing and before changes are passed to the database; however,
    this is not a general rule.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个聚合处理过程中生成领域事件，并通过调用它们的 `AddDomainEvent` 方法将它们添加到聚合本身。然而，它们不会立即触发。通常，它们在所有聚合处理结束后、更改传递到数据库之前触发；但这并不是一个普遍的规则。
- en: The application handles errors by throwing exceptions. A more efficient approach
    would be to define a request-scoped object in the dependency engine where each
    application subpart may add its errors as domain events. However, while this approach
    is more efficient, it increases the complexity of the code and the application
    development time.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过抛出异常来处理错误。一个更有效的方法是在依赖注入引擎中定义一个请求作用域对象，每个应用程序子部分都可以将其错误添加为领域事件。然而，虽然这种方法更有效，但它增加了代码和应用程序开发复杂度。
- en: 'The Visual Studio solution is composed of three projects:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 解决方案由三个项目组成：
- en: There's a project containing the domain layer called `PackagesManagementDomain`,
    which is a standard 2.0 library.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含领域层的项目名为 `PackagesManagementDomain`，这是一个标准的 2.0 库。
- en: There's a project containing the whole data layer called `PackagesManagementDB`,
    which is a .NET Core 3.0 library.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含整个数据层的项目名为 `PackagesManagementDB`，这是一个 .NET Core 3.0 库。
- en: Finally, there's an ASP.NET Core MVC 3.0 project called `PackagesManagement` that
    contains both application and presentation layers. When you define this project,
    select no authentication, otherwise the user database will be added directly to
    the ASP.NET Core MVC project instead of adding it to the database layer. We will
    add the user database manually in the data layer.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，有一个名为 `PackagesManagement` 的 ASP.NET Core MVC 3.0 项目，该项目包含应用程序和表示层。当你定义此项目时，请选择不启用身份验证，否则用户数据库将直接添加到
    ASP.NET Core MVC 项目中，而不是添加到数据库层。我们将在数据层中手动添加用户数据库。
- en: Let's start by creating the `PackagesManagement` ASP.NET Core MVC project so
    that the whole solution has the same name as the ASP.NET Core MVC project. Then,
    let's add the other two library projects to the same solution.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建`PackagesManagement` ASP.NET Core MVC项目，以便整个解决方案的名称与ASP.NET Core MVC项目的名称相同。然后，让我们将其他两个库项目添加到同一个解决方案中。
- en: Finally, let the ASP.NET Core MVC project reference both projects, while `PackagesManagementDB` references
    `PackagesManagementDomain`. We suggest you define your own projects and then copy
    the code of this book's GitHub repository into them as you progress through reading
    this section.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让ASP.NET Core MVC项目引用这两个项目，而`PackagesManagementDB`引用`PackagesManagementDomain`。我们建议您定义自己的项目，然后在阅读本节的过程中将本书GitHub仓库中的代码复制到它们中。
- en: The next subsection describes the code of the `PackagesManagementDomain` data
    layer project.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了`PackagesManagementDomain`数据层项目的代码。
- en: Defining the domain layer
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义领域层
- en: Once the `PackagesManagementDomain` standard 2.0 library project is added to
    the solution, let's add a `Tools` folder to the project root. Then, let's place
    there all `DomainLayer` tools contained in the code associated with `chapter 10`.
    Since the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection` NuGet packages.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`PackagesManagementDomain`标准2.0库项目添加到解决方案中，让我们在项目根目录中添加一个`Tools`文件夹。然后，将代码中与`第10章`相关的所有`DomainLayer`工具放置在那里。由于该文件夹中的代码使用数据注释并定义DI扩展方法，我们还必须添加对`System.ComponentModel.Annotations`和`Microsoft.Extensions.DependencyInjection`
    NuGet包的引用。
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (remember, we implemented aggregates as interfaces), namely, `IDestination`, `IPackage`,
    and `IPackageEvent`. Here, `IPackageEvent` is the aggregate associated with the
    table where we will place events to be propagated to other applications.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个包含所有聚合定义的`Aggregates`文件夹（记住，我们将聚合体实现为接口），即`IDestination`、`IPackage`和`IPackageEvent`。在这里，`IPackageEvent`是与我们将放置要传播到其他应用程序的事件的表相关联的聚合体。
- en: 'As an example, let''s analyze `IPackage`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们分析`IPackage`：
- en: '[PRE69]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It contains the same properties of the `Package` entity, which we saw in [Chapter
    6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data in C# -
    Entity Framework Core*. The only differences are the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含与我们在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中看到的`Package`实体的相同属性，*在C#中与数据交互
    - Entity Framework Core*。唯一的区别如下：
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它继承自`IEntity<int>`，这为聚合体提供了所有基本功能。
- en: It has no `Id` property since it is inherited from `IEntity<int>`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有`Id`属性，因为它继承自`IEntity<int>`。
- en: All properties are read-only, and it has an `Update` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `Update` method)
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有属性都是只读的，并且它有一个`Update`方法，因为所有聚合体只能通过用户域中定义的更新操作（在我们的情况下，是`Update`方法）进行修改。
- en: Now, let's also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages. If you would like to add the logic
    to manage destinations, you must define an analogous interface for the `IDestination`
    aggregate.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也添加一个`DTOs`文件夹。在这里，我们放置所有用于将更新传递给聚合体的接口。这些接口由用于定义此类更新的应用层ViewModel实现。在我们的案例中，它包含`IPackageFullEditDTO`，我们可以用它来更新现有包。如果您想添加管理目的地的逻辑，您必须为`IDestination`聚合体定义一个类似的接口。
- en: 'An `IRepository` folder contains all repository specifications, namely `IDestinationRepository`,
    `IPackageRepository`, and `IPackageEventRepository`. Here, `IPackageEventRepository`
    is the repository associated with the `IPackageEvent` aggregate. As an example,
    let''s have a look at the `IPackageRepository` repository:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`IRepository`文件夹包含所有存储库规范，即`IDestinationRepository`、`IPackageRepository`和`IPackageEventRepository`。在这里，`IPackageEventRepository`是与`IPackageEvent`聚合体相关联的存储库。例如，让我们看看`IPackageRepository`存储库：
- en: '[PRE70]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods, in our case, just the methods to create a
    new package, to retrieve an existing package, and to delete an existing package.
    The logic to modify an existing package is included in the `Update` method of
    `IPackage`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库总是只包含几个方法，因为所有业务逻辑都应该表示为聚合方法，在我们的案例中，就是创建新包、检索现有包和删除现有包的方法。修改现有包的逻辑包含在 `IPackage`
    的 `Update` 方法中。
- en: 'Finally, as with all domain layer projects, `PackagesManagementDomain` contains
    an event folder with all domain event definitions. In our case, the folder is
    named `Events` and contains the package-deleted event and the price-changed event:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与所有领域层项目一样，`PackagesManagementDomain` 包含一个事件文件夹，其中包含所有领域事件定义。在我们的案例中，文件夹名为
    `Events`，包含包删除事件和价格变更事件：
- en: '[PRE71]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When an aggregate sends all its changes to another application, it must have
    a version property. The application that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order they are received
    may differ from the order they were sent. For this purpose, events that are used
    to publish changes outside of the application have both `OldVersion` (the version
    before the change) and `NewVersion` (the version after the change) properties.
    Events associated with delete events have no `NewVersion`, since after being deleted,
    an entity can't store any versions.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个聚合将所有更改发送到另一个应用程序时，它必须有一个版本属性。接收更改的应用程序使用此版本属性来按正确顺序应用所有更改。显式版本号是必要的，因为更改是异步发送的，所以它们接收的顺序可能与发送的顺序不同。为此目的，用于在应用程序外部发布更改的事件具有
    `OldVersion`（更改前的版本）和 `NewVersion`（更改后的版本）属性。与删除事件相关的事件没有 `NewVersion`，因为实体在被删除后无法存储任何版本。
- en: The next subsection explains how all interfaces defined in the domain layer
    are implemented in the data layer.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将解释在领域层中定义的所有接口如何在数据层中实现。
- en: Defining the data layer
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据层
- en: The data layer project contains references to the `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we use Entity
    Framework Core with SQL server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which is needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting with Data
    in C# - Entity Framework Core*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层项目包含对 `Microsoft.AspNetCore.Identity.EntityFrameworkCore` 和 `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet 包的引用，因为我们使用的是与SQL服务器结合的Entity Framework Core。它引用 `Microsoft.EntityFrameworkCore.Tools`
    和 `Microsoft.EntityFrameworkCore.Design`，这是在[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中
    *在C#中使用Entity Framework Core与数据交互* 的 *Entity Framework Core迁移* 部分中生成数据库迁移所必需的。
- en: 'We have a `Models` folder that contains all database entities. They are similar
    to the ones in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml), *Interacting
    with Data in C# - Entity Framework Core*. The only differences are as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `Models` 文件夹，其中包含所有数据库实体。它们与[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中所述的类似，即
    *在C#中使用Entity Framework Core与数据交互*。唯一的区别如下：
- en: They inherit from `Entity<T>`, which contains all basic features of aggregates.
    Please notice that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in [Chapter 6](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml),
    *Interacting with Data in C# - Entity Framework Core*. In our example, all entities
    are aggregate roots.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们继承自 `Entity<T>`，该类包含所有聚合的基本特征。请注意，从 `Entity<T>` 继承仅适用于聚合根；所有其他实体必须按照[第6章](8c8a9dbc-3bfc-4291-866f-fdd1a62c16ef.xhtml)中所述进行定义，即
    *在C#中使用Entity Framework Core与数据交互*。在我们的示例中，所有实体都是聚合根。
- en: They have no `Id` since it is inherited from `Entity<T>`.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有 `Id`，因为它是从 `Entity<T>` 继承的。
- en: Some of them have an `EntityVersion` property that is decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version that is needed for sending property
    all entity changes to other applications. The `ConcurrencyCheck` attribute is
    needed to prevent concurrency errors while updating the entity version without
    suffering the performance penalty implied by a transaction.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些具有 `EntityVersion` 属性，该属性被 `[ConcurrencyCheck]` 属性装饰。它包含发送所有实体属性更改到其他应用程序所需的实体版本。`ConcurrencyCheck`
    属性用于在更新实体版本时防止并发错误，同时避免事务带来的性能惩罚。
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that, this time, no-one will write
    the same entity in the database during its execution.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，当保存实体更改时，如果带有 `ConcurrencyCheck` 属性的字段值与实体在内存中加载时读取的值不同，则会抛出一个并发异常，通知调用方法，有人在读取实体之后但在我们尝试保存其更改之前修改了此值。这样，调用方法可以重复整个操作，希望这次在执行过程中没有人会在数据库中写入相同的实体。
- en: 'It is worth analyzing the `Package` entity:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析 `Package` 实体：
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate when
    the price changes add `PackagePriceChangedEvent` to the entity list of events.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当价格更改时，`FullUpdate` 方法是更新 `IPackage` 聚合的唯一方式，此时将 `PackagePriceChangedEvent`
    添加到事件实体列表中。
- en: 'The `MainDBContext.cs` file contains the data layer database context definition.
    It doesn''t inherit from `DBContext` but from the following predefined context
    class:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDBContext.cs` 文件包含数据层数据库上下文定义。它不继承自 `DBContext`，而是继承自以下预定义的上下文类：'
- en: '[PRE73]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This context defines the user's tables needed for the authentication. In our
    case, we opted for the `IdentityUser<T>` standard and the `IdentityRole<S>` respectively
    for users and roles and used integers for both the `T` and `S` Entity keys. However,
    we may also use classes that inherit from `IdentityUser` and `IdentityRole` and
    add then further properties.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 此上下文定义了用于身份验证的用户表。在我们的案例中，我们选择了 `IdentityUser<T>` 标准和 `IdentityRole<S>` 分别用于用户和角色，并且对于
    `T` 和 `S` 实体键都使用了整数。然而，我们也可以使用从 `IdentityUser` 和 `IdentityRole` 继承的类并添加更多属性。
- en: In the `OnModelCreating` method, we must call `base.OnModelCreating(builder)` in
    order to apply the configuration defined in `IdentityDbContext`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnModelCreating` 方法中，我们必须调用 `base.OnModelCreating(builder)` 以应用在 `IdentityDbContext`
    中定义的配置。
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, rollback, and commit a transaction:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDBContext` 实现了 `IUnitOfWork` 接口。以下代码展示了所有开始、回滚和提交事务的方法实现：'
- en: '[PRE74]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: However, they are rarely used by command classes in a distributed environment
    since retrying the same operation until no concurrency exception is returned usually
    ensures better performance than transactions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分布式环境中，命令类很少使用它们，因为直到没有返回并发异常为止重试相同的操作通常比事务确保更好的性能。
- en: 'It is worth analyzing the implementation of the method that passes all changes
    applied to `DBContext` to the database:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析将所有应用于 `DBContext` 的更改传递到数据库的方法实现：
- en: '[PRE75]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The preceding implementation just calls the `SaveChangesAsync DBContext` context method
    that saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches from the context all entities involved in the concurrency
    error. This way, next time a command retries the whole failed operation, their
    updated versions will be reloaded from the database.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现只是调用了 `SaveChangesAsync DBContext` 上下文方法将所有更改保存到数据库，但随后它会拦截所有并发异常，并将所有涉及并发错误的实体从上下文中分离出来。这样，下次命令重试整个失败操作时，它们的更新版本将重新从数据库中加载。
- en: 'The `Repositories` folder contains all repository implementations. It is worth
    analyzing the implementation of the `IPackageRepository.Delete` method:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repositories` 文件夹包含所有仓储实现。值得分析 `IPackageRepository.Delete` 方法的实现：'
- en: '[PRE76]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It reads the entity from the database and formally removes it from the `Packages`
    dataset. This will force the entity to be deleted in the database when changes
    are saved to the database. Moreover, it adds `PackageDeleteEvent` to the aggregate
    list of events.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 它从数据库中读取实体，并正式将其从 `Packages` 数据集中删除。这将强制实体在更改保存到数据库时在数据库中被删除。此外，它将 `PackageDeleteEvent`
    添加到聚合事件列表中。
- en: The `Extensions` folder contains the `DBExtensions` static class that, in turn,
    defines two extension methods to be added to the application DI engine and the
    ASP.NET Core pipeline respectively. Once added to the pipeline, these two methods
    will connect the database layer to the application layer.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`Extensions` 文件夹包含 `DBExtensions` 静态类，它反过来定义了要添加到应用程序 DI 引擎和 ASP.NET Core 管道中的两个扩展方法。一旦添加到管道中，这两个方法将连接数据库层到应用程序层。'
- en: 'The `IServiceCollection` extension of `AddDbLayer` accepts (as its input parameters)
    the database connection string and the name of the `.dll` file that contains all
    migrations. Then, it does the following:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDbLayer` 的 `IServiceCollection` 扩展接受（作为其输入参数）数据库连接字符串和包含所有迁移的 `.dll` 文件名。然后，它执行以下操作：'
- en: '[PRE77]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: That is, it adds the database context to the DI engine and defines its options,
    namely, that it uses SQL Server, the database connection string, and the name
    of the `.dll` that contains all migrations.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它将数据库上下文添加到依赖注入引擎中，并定义其选项，即它使用 SQL Server、数据库连接字符串以及包含所有迁移的 `.dll` 文件名。
- en: 'Then, it does the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它执行以下操作：
- en: '[PRE78]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That is, it adds and configures all the types needed to handle database-based
    authentication. In particular, it adds the `UserManager` and `RoleManager` types,
    which the application layer can use to manage users and roles. `AddDefaultTokenProviders`
    adds the provider that creates the authentication tokens using data contained
    in the database when users log in.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它添加并配置了处理基于数据库的身份验证所需的所有类型。特别是，它添加了 `UserManager` 和 `RoleManager` 类型，应用程序层可以使用这些类型来管理用户和角色。`AddDefaultTokenProviders`
    添加了在用户登录时使用数据库中包含的数据创建身份验证令牌的提供者。
- en: Finally, it discovers and adds to the DI engine all repository implementations
    by calling the `AddAllRepositories` method that is defined in the DDD tools we
    added to the domain layer project.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它通过调用定义在添加到领域层项目的 DDD 工具中的 `AddAllRepositories` 方法，发现并添加所有仓库实现到依赖注入引擎中。
- en: The `UseDBLayer` extension method ensures migrations are applied to the database
    by calling `context.Database.Migrate()` and then populates the database with some
    initial objects. In our case, it uses `RoleManager` and `UserManager` to create
    an administrative role and an initial administrator. Then, it creates some sample
    destinations and packages.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseDBLayer` 扩展方法通过调用 `context.Database.Migrate()` 确保迁移应用到数据库，然后使用一些初始对象填充数据库。在我们的例子中，它使用
    `RoleManager` 和 `UserManager` 创建一个管理角色和一个初始管理员。然后，它创建一些示例目的地和包。'
- en: 'To create migrations, we must add the aforementioned extension methods to the
    ASP.NET Core MVC `Startup.cs` file, as shown here:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建迁移，我们必须将上述扩展方法添加到 ASP.NET Core MVC 的 `Startup.cs` 文件中，如下所示：
- en: '[PRE79]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Please be sure that both the authorization and authentication modules have been
    added to the ASP.NET Core pipeline, otherwise, the authentication/authorization
    engine will not work.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保已将授权和身份验证模块添加到 ASP.NET Core 管道中，否则身份验证/授权引擎将无法工作。
- en: 'Then, we must add the connection string to the `appsettings.json` file, as
    shown here:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将连接字符串添加到 `appsettings.json` 文件中，如下所示：
- en: '[PRE80]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Finally, let's add `Microsoft.EntityFrameworkCore.Design` to the ASP.NET Core
    project.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将 `Microsoft.EntityFrameworkCore.Design` 添加到 ASP.NET Core 项目中。
- en: We are forced to configure all database stuff in the startup project because
    migration tools use the startup project DI engine to create and apply migrations.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被迫在启动项目中配置所有数据库相关内容，因为迁移工具使用启动项目的依赖注入引擎来创建和应用迁移。
- en: 'At this point, let''s open Visual Studio Package Manager Console and select
    `PackageManagementDB` as the default project and then launch the following command:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们打开 Visual Studio 包管理器控制台，将 `PackageManagementDB` 作为默认项目，然后运行以下命令：
- en: '[PRE81]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The preceding command will scaffold the first migration. We may apply it to
    the database with the `Update-Database` command. Please note that if you copy
    the project from GitHub, you don't need to scaffold migrations since they have
    already been created, but you just need to update the database.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令将构建第一个迁移。我们可以使用 `Update-Database` 命令将其应用到数据库中。请注意，如果您从 GitHub 复制项目，由于迁移已经创建，因此不需要构建迁移，但只需更新数据库即可。
- en: The next subsection describes the application layer.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节描述了应用程序层。
- en: Defining the application layer
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序层
- en: 'As a first step, for simplicity, let''s freeze the application culture to `en-US` by
    adding the code that follows to the ASP.NET Core pipeline:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，为了简化，让我们通过将以下代码添加到 ASP.NET Core 管道中来冻结应用程序文化为 `en-US`：
- en: '[PRE82]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, let''s create a `Tools` folder and place the `ApplicationLayer` code
    there, which you may find in the `chapter 10` code of the GitHub repository associated
    with this book. With these tools in place, we can add the code that automatically
    discovers and adds all queries, command handlers, and event handlers to the DI
    engine, as shown here:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个`Tools`文件夹，并将`ApplicationLayer`代码放在那里，你可以在与本书相关的GitHub仓库的`第10章`代码中找到它。有了这些工具，我们可以添加代码，自动发现并添加所有查询、命令处理程序和事件处理程序到DI引擎中，如下所示：
- en: '[PRE83]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let''s have a look at the query that lists all packages:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个`Queries`文件夹来放置所有查询及其相关接口。例如，让我们看看列出所有包的查询：
- en: '[PRE84]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The query object is automatically injected in the application DB context. The
    `GetAllPackages` method uses LINQ to project all of the required information into
    `PackageInfosViewModel` and sorts all results in descending order on the `EndValidityDate`
    property.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对象会自动注入到应用程序数据库上下文中。`GetAllPackages`方法使用LINQ将所有所需信息投影到`PackageInfosViewModel`中，并按`EndValidityDate`属性降序排序所有结果。
- en: '`PackageInfosViewModel` is placed in the `Models` folder together with all
    other ViewModels. It is good practice to organize ViewModels in folders, by defining
    a different folder for each controller. It is worth analyzing the ViewModel used
    for editing packages:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`PackageInfosViewModel`放在`Models`文件夹中，与其他所有ViewModel一起。将ViewModel组织到文件夹中是一种好习惯，为每个控制器定义不同的文件夹。分析用于编辑包的ViewModel是值得的：'
- en: '[PRE85]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It has a constructor that accepts an `IPackage` aggregate. This way, package
    data is copied into the ViewModel that is used to populate the edit view. It implements
    the `IPackageFullEditDTO` DTO interface defined in the domain layer. This way,
    it can be directly used to send `IPackage` updates to the domain layer.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 它的构造函数接受一个`IPackage`聚合。这样，包数据就会被复制到用于填充编辑视图的ViewModel中。它实现了在领域层定义的`IPackageFullEditDTO`
    DTO接口。这样，它可以直接用于将`IPackage`更新发送到领域层。
- en: 'All properties contain validation attributes that are automatically used by
    client-side and server-side validation engines. Each property contains a `Display`
    attribute that defines the label to give to the input field that will be used
    to edit the property. It is better to place the field labels in the ViewModels
    than placing them directly in the views since, this way, the same names are automatically
    used in all views that use the same ViewModel. The following code block lists
    all its properties:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 所有属性都包含验证属性，这些属性会被客户端和服务器端验证引擎自动使用。每个属性都包含一个`Display`属性，它定义了用于编辑属性的输入字段的标签。将字段标签放在ViewModel中比直接放在视图中更好，因为这样，相同的名称会自动在所有使用相同ViewModel的视图中使用。以下代码块列出了所有属性：
- en: '[PRE86]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `Commands` folder contains all commands. As an example, let''s have a look
    at the command used to modify packages:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`Commands`文件夹包含所有命令。例如，让我们看看用于修改包的命令：'
- en: '[PRE87]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Its constructor must be invoked with an implementation of the `IPackageFullEditDTO`
    DTO interface, that, in our case, is the edit ViewModel we described before. Command
    handlers are placed in the `Handlers` folder. It is worth analyzing the command
    that updates packages:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 其构造函数必须使用`IPackageFullEditDTO` DTO接口的实现来调用，在我们的情况下，是之前描述的编辑ViewModel。命令处理程序放在`Handlers`文件夹中。分析更新包的命令是值得的：
- en: '[PRE88]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Its constructor has automatically injected the `IPackageRepository` repository
    and an `IEventMediator` instance needed to triggers events handler. The following
    code also shows the implementation of the standard `HandleAsync` command handler
    method:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 其构造函数自动注入了`IPackageRepository`存储库和一个用于触发事件处理程序的`IEventMediator`实例。以下代码还显示了标准`HandleAsync`命令处理程序方法的实现：
- en: '[PRE89]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Command operations are repeated until no concurrency exception is returned. `HandleAsync`
    uses the repository to get an instance of the entity to modify. If the entity
    is not found (it has been deleted), the commands stop its execution. Otherwise,
    all changes are passed to the retrieved aggregate. Immediately after the update,
    all events contained in the aggregate are triggered. In particular, if the price
    has changed, the event handler associated with the price change is executed. The
    concurrency check ensures that the package version is updated properly (by incrementing
    its previous version number by 1) and that the price changed event is passed the
    right version numbers.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 命令操作会重复执行，直到没有并发异常返回。`HandleAsync` 使用仓储来获取要修改的实体实例。如果实体未找到（已被删除），则命令停止其执行。否则，所有更改都会传递给检索到的聚合。更新后，立即触发聚合中包含的所有事件。特别是，如果价格已更改，则执行与价格更改相关的事件处理器。并发检查确保包版本正确更新（通过将其前一个版本号增加1）并且价格更改事件传递了正确的版本号。
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let''s
    have a look at the price changed event handler:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件处理器放置在 `Handlers` 文件夹中。作为一个例子，让我们看看价格更改事件处理器：
- en: '[PRE90]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The constructor has automatically injected the `IPackageEventRepository` repository
    that handles the database table with all events to send to other applications.
    The `HandleAsync` implementation simply calls the repository method that adds
    a new record to this table.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数自动注入了处理所有要发送到其他应用的数据库事件的 `IPackageEventRepository` 仓储。`HandleAsync` 的实现简单地调用向此表添加新记录的仓储方法。
- en: All records in the table handled by `IPackageEventRepository`, which can be
    retrieved and sent to all interested microservices by a parallel task defined
    in the DI engine with a call such as `services.AddHostedService<MyHostedService>();` as
    detailed in the *Using Generic Hosts* subsection of [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml), *Applying
    Microservice Architecture to Your Enterprise Application*. However, this parallel
    task is not implemented in the GitHub code associated with this chapter.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `IPackageEventRepository` 处理的表中的所有记录，可以通过在 DI 引擎中定义的并行任务（例如使用 `services.AddHostedService<MyHostedService>();`）检索并发送到所有感兴趣的微服务。如第5章的“使用通用宿主”小节中详细说明，[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用”。然而，这个并行任务并未在与此章节相关的
    GitHub 代码中实现。
- en: The next subsection describes how controllers and views are designed.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小节将描述控制器和视图是如何设计的。
- en: Controllers and views
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器和视图
- en: We need to add two more controllers to the one automatically scaffolded by Visual
    Studio, namely, `AccountController`, which takes care of user login/logout and
    registration, and `ManagePackageController` to handle all package-related operations.
    It is enough to right-click on the `Controllers` folder and then select Add |
    Controller. Then, choose the controller name and select the empty MVC controller
    to avoid that Visual Studio might scaffold code you don't need.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向 Visual Studio 自动生成的控制器中添加两个额外的控制器，即 `AccountController`，它负责用户登录/注销和注册，以及
    `ManagePackageController` 来处理所有与包相关的操作。只需在 `Controllers` 文件夹上右键单击，然后选择添加 | 控制器。然后，选择控制器名称，并选择空
    MVC 控制器以避免 Visual Studio 可能生成您不需要的代码。
- en: 'For simplicity, `AccountController` just has login and logout methods, so you
    can log in just with the initial administrator user. However, you can add further
    action methods that use the `UserManager` class to define, update, and delete
    users. The `UserManager` class can be provided through DI, as shown here:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，`AccountController` 只包含登录和注销方法，因此您只需使用初始管理员用户即可登录。然而，您可以添加进一步的动作方法，这些方法使用
    `UserManager` 类来定义、更新和删除用户。`UserManager` 类可以通过 DI 提供，如下所示：
- en: '[PRE91]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`SignInManager` takes care of login/logout operations. The `Logout` action
    method is quite simple and is shown here:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`SignInManager` 负责登录/注销操作。`Logout` 动作方法相当简单，如下所示：'
- en: '[PRE92]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It just calls the `signInManager.SignOutAsync` method and then redirects the
    browser to the home page. To avoid it being called by clicking a link it is decorated
    with `HttpPost`, so it can only be invoked via a form submit.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用 `signInManager.SignOutAsync` 方法，然后将浏览器重定向到主页。为了避免通过点击链接调用它，它被装饰为 `HttpPost`，因此只能通过表单提交来调用。
- en: 'Login instead requires two action methods. The first one is invoked via `Get`
    and shows the login form, where the user must place their username and password.
    It is shown here:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 登录则需要两个动作方法。第一个是通过 `Get` 调用的，显示登录表单，用户必须在此处输入用户名和密码。如下所示：
- en: '[PRE93]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'It receives `returnUrl` as its parameter when the browser is automatically
    redirected to the login page by the authorization module. This happens when an
    unlogged user tries to access a protected page. `returnUrl` is stored in the `ViewState`
    dictionary that is passed to the login view. The form in the login view passes
    it back, together with the username and password, to the controller when it is
    submitted, as shown in this code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当授权模块自动将浏览器重定向到登录页面时，它将`returnUrl`作为其参数接收。这发生在未登录的用户尝试访问受保护页面时。`returnUrl`存储在传递给登录视图的`ViewState`字典中。登录视图中的表单将其连同用户名和密码一起提交回控制器，如下所示：
- en: '[PRE94]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The form post is intercepted by an action method with the same `Login` name
    but decorated with the `[HttpPost]` attribute, as shown here:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 表单提交被具有相同`Login`名称但带有`[HttpPost]`属性的同一动作方法拦截，如下所示：
- en: '[PRE95]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The preceding method receives the `Login` model used by the login view together
    with the `returnUrl` query string parameter. The `ValidateAntiForgeryToken` attribute
    verifies a token (called an anti-forgery token) that MVC forms automatically add
    to a hidden field to prevent cross-site attacks.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法接收登录视图使用的`Login`模型以及`returnUrl`查询字符串参数。`ValidateAntiForgeryToken`属性验证一个令牌（称为反伪造令牌），MVC表单自动将其添加到隐藏字段中，以防止跨站攻击。
- en: 'As a first step, the action method logs the user out if they are already logged
    in:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，动作方法如果用户已经登录，则将其注销：
- en: '[PRE96]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Otherwise, it verifies whether there are validation errors, in which case,
    it shows the same view filled with the data of the ViewModel to let the user correct
    their errors:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它验证是否存在验证错误，在这种情况下，它显示相同的视图，并用ViewModel的数据填充，以便用户纠正错误：
- en: '[PRE97]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If the model is valid, `_signInManager` is used to log in the user:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型有效，使用`_signInManager`登录用户：
- en: '[PRE98]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If the result returned by the operation is successful, the action method redirects
    the browser to `returnUrl`, if not null, otherwise to the home page:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作返回的结果是成功的，动作方法会将浏览器重定向到`returnUrl`，如果该值不为空，否则重定向到主页：
- en: '[PRE99]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If, the login fails, it adds an error to `ModelState` and shows the same form
    to let the user try again.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录失败，它将错误添加到`ModelState`中，并显示相同的表单让用户再次尝试。
- en: '`ManagePackagesController` contains an `Index` method that shows all packages
    in table format:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagePackagesController`包含一个`Index`方法，以表格格式显示所有包：'
- en: '[PRE100]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This action method is injected into the proper query object by DI, invokes it,
    and inserts the resulting `IEnumerable` in the `Items` property of a `PackagesListViewModel` instance.
    It is a good practice to include `IEnumerables` in ViewModels, so if necessary,
    other properties can be added without modifying the existing view code. Results
    are shown in a Bootstrap 4 table since Bootstrap 4 CSS is automatically scaffolded
    by Visual Studio.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 此动作方法通过依赖注入（DI）注入到适当的查询对象中，调用它，并将结果`IEnumerable`插入到`PackagesListViewModel`实例的`Items`属性中。在ViewModel中包含`IEnumerable`是一个好的实践，因此如果需要，可以添加其他属性而无需修改现有的视图代码。结果在Bootstrap
    4表格中显示，因为Bootstrap 4 CSS是由Visual Studio自动生成的。
- en: 'The result is shown here:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![](img/48ba7e1c-5f3d-487f-9bde-cc4e5097e872.png)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48ba7e1c-5f3d-487f-9bde-cc4e5097e872.png)'
- en: 'The New package link (it is shaped like a Bootstrap 4 button, but it is a link)
    invokes a controller `Create` action method, while the delete and edit links in
    each row invoke a `Delete` and `Edit` action method and pass them the ID of the
    package shown in the row. Here is the implementation of the two-row links:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 新包链接（它看起来像Bootstrap 4按钮，但实际上是一个链接）调用控制器`Create`动作方法，而每行中的删除和编辑链接调用`Delete`和`Edit`动作方法，并将该行显示的包ID传递给它们。以下是两个链接的实现：
- en: '[PRE101]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'It is worth describing the code of the `HttpGet` and `HttpPost` `Edit` action
    methods:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 值得描述的是`HttpGet`和`HttpPost`的`Edit`动作方法的代码：
- en: '[PRE102]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `Edit` method of `HttpGet` uses `IPackageRepository` to retrieve the existing
    package. If the package is not found, that means it has been deleted by some other
    user, and the browser is redirected again to the list page to show the updated
    list of packages. Otherwise, the aggregate is passed to the `PackageFullEditViewModel`
    ViewModel that is rendered by the `Edit` view.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpGet`的`Edit`方法使用`IPackageRepository`检索现有包。如果找不到包，这意味着它已被其他用户删除，浏览器再次重定向到列表页面以显示更新后的包列表。否则，聚合传递给由`Edit`视图渲染的`PackageFullEditViewModel`
    ViewModel。'
- en: 'The view used to render the package must render `select` with all possible
    package destinations, so it needs an instance of the `IDestinationListQuery` query
    that was implemented to assist with the destination selection HTML logic. This
    query is injected directly in the view since it is a view responsibility to decide
    how to enable the user to select a destination. The code that injects the query
    and uses it is shown here:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 用于渲染包的视图必须渲染包含所有可能的包目标位置的`select`，因此它需要一个实现以辅助目标选择HTML逻辑的`IDestinationListQuery`查询实例。由于视图的责任是决定如何使用户能够选择目标，因此该查询直接注入到视图中。下面展示了注入查询并使用它的代码：
- en: '[PRE103]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The action method that processes the post of the view form is given here:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 处理视图表单后文的动作方法如下所示：
- en: '[PRE104]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: If `ModelState` is valid, `UpdatePackageCommand` is created and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ModelState`有效，则创建`UpdatePackageCommand`及其相关处理程序被调用；否则，视图将再次显示给用户，以便他们能够纠正所有错误。
- en: 'The new links to the package list page and login page must be added to the
    main menu, which is in the `_Layout` view, as shown here:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将指向包列表页面和登录页面的新链接添加到主菜单中，该菜单位于`_Layout`视图中，如下所示：
- en: '[PRE105]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '`logoutForm` is an empty form whose only purpose is to send a post to the `Logout`
    action method. It has been added at the end of the body, as shown here:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '`logoutForm`是一个空表单，其唯一目的是向`Logout`动作方法发送一个post请求。它已添加到正文末尾，如下所示：'
- en: '[PRE106]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Now, the application is ready! You can run it, log in, and start to manage packages.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已准备就绪！您可以运行它，登录，并开始管理包。
- en: Summary
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the ASP.NET Core pipeline and various modules that
    compose an ASP.NET Core MVC application in detail, such as authentication/authorization,
    the options framework, and routing. Then, we described how controllers and Views
    map requests to response HTML. We also analyzed all the improvements introduced
    in version 3.0.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细分析了ASP.NET Core管道以及组成ASP.NET Core MVC应用程序的各种模块，例如身份验证/授权、选项框架和路由。然后，我们描述了控制器和视图如何将请求映射到响应HTML。我们还分析了3.0版本中引入的所有改进。
- en: Finally, we analyzed all the design patterns implemented in the ASP.NET Core
    MVC framework, and, in particular, the importance of the Separation of Concerns principle and
    how ASP.NET Core MVC implements it with the ASP.NET Core pipeline and in its validation
    and globalization modules. Finally, we focused in more detail on the importance
    of Separation of Concerns between the presentation layer logic and graphics and
    how the MVC pattern ensures it.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了在ASP.NET Core MVC框架中实现的所有设计模式，特别是关注点分离原则的重要性以及ASP.NET Core MVC如何通过ASP.NET
    Core管道及其验证和全球化模块来实现它。最后，我们更详细地关注了表示层逻辑和图形之间的关注点分离的重要性，以及MVC模式如何确保这一点。
- en: The next chapter discusses best practices that will help you to program safe,
    simple, and maintainable software.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论有助于您编写安全、简单且可维护软件的最佳实践。
- en: Questions
  id: totrans-534
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can you list all the middleware modules scaffolded by Visual Studio in an ASP.NET
    Core project?
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否列出Visual Studio在ASP.NET Core项目中生成的所有中间件模块？
- en: Does the ASP.NET Core pipeline module need to inherit from a base class or implement
    some interface?
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core管道模块是否需要继承自基类或实现某些接口？
- en: Is it true that a tag must have just one tag helper defined for it or an exception
    is thrown?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否正确，一个标签必须只定义一个标签助手，否则会抛出异常？
- en: Do you remember how to test in a controller if validation errors occurred?
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还记得如何在控制器中测试是否发生了验证错误吗？
- en: What is the instruction in a layout view to include the output of the main view
    called?
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局视图中，包含主视图输出的指令被称为什么？
- en: How are secondary sections of the main view invoked in a layout view?
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局视图中，如何调用主视图的次要部分？
- en: How does a controller invoke a view?
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器如何调用视图？
- en: As a default, how many providers are installed in the globalization module?
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，全球化模块中安装了多少个提供程序？
- en: Are ViewModels the only way for controllers to communicate with their invoked
    views?
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ViewModels是否是控制器与其调用的视图通信的唯一方式？
- en: Further reading
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details on the ASP.NET MVC framework are available in its official documentation
    at [https://docs.microsoft.com/en-US/aspnet/core/.](https://docs.microsoft.com/en-US/aspnet/core/) More
    details on Razor syntax can be found at [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&tabs=visual-studio).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 ASP.NET MVC 框架的详细信息可以在其官方文档中找到，请访问 [https://docs.microsoft.com/en-US/aspnet/core/](https://docs.microsoft.com/en-US/aspnet/core/)。更多关于
    Razor 语法的信息可以在 [https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&tabs=visual-studio](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-3.0&tabs=visual-studio)
    查找。
- en: Documentation on the creation custom tag helpers that were not discussed in
    this chapter can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring).
    Documentation on the creation of custom controller attributes can be found at [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters.](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章未讨论的创建自定义标签辅助器的文档可以在 [https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring](https://docs.microsoft.com/en-US/aspnet/core/mvc/views/tag-helpers/authoring)
    找到。关于创建自定义控制器属性的文档可以在 [https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters.](https://docs.microsoft.com/en-US/aspnet/core/mvc/controllers/filters)
    找到。
- en: 'The definition of custom validation attributes is discussed in this article:
    [https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/).'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义验证属性的定义在本篇文章中讨论：[https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/](https://blogs.msdn.microsoft.com/mvpawardprogram/2017/01/03/asp-net-core-mvc/)。
- en: For alternative approaches to the construction of presentation layers for web
    applications, the official documentation of Blazor is at[ https://dotnet.microsoft.com/apps/aspnet/web-apps/client](https://dotnet.microsoft.com/apps/aspnet/web-apps/client).
    A good introduction to all the techniques and tools needed to implement a modern
    JavaScript-based Single Page Application is found in this book: [https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers](https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers),
    which describes TypeScript, advanced JavaScript features, WebPack, and the Angular
    SPA framework.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 关于构建 Web 应用程序表示层的替代方法，Blazor 的官方文档位于 [https://dotnet.microsoft.com/apps/aspnet/web-apps/client](https://dotnet.microsoft.com/apps/aspnet/web-apps/client)。本书介绍了实现基于现代
    JavaScript 的单页应用程序所需的所有技术和工具，是一本很好的入门书籍：[https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers](https://www.packtpub.com/application-development/hands-typescript-c-and-net-core-developers)，其中描述了
    TypeScript、高级 JavaScript 功能、Webpack 以及 Angular SPA 框架。
