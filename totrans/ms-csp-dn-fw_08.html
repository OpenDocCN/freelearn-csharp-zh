<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Open Source Programming</h1></div></div></div><p>In this chapter, we're going to review the current state of open source programming with Microsoft technologies and tools. This is something that has been referred to by many technology evangelists as the open source ecosystem.</p><p>In this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">We'll start with the initial movements in this area and explore how they have evolved over time, summarizing the most important initiatives that any developer can access at this moment.</li><li class="listitem">Later, we'll revise some of the most popular implementations, either on the side of tools (IDEs) or APIs and languages.</li><li class="listitem">We'll look at programming with open source solutions, such as Node.js, how it's is supported within Visual Studio and how easy it is to create a project that uses Node with this environment, as well as how other IDE choices are available, such as Visual Studio Code.</li><li class="listitem">Later, we'll go through perhaps the two most important and adopted open source initiatives in Microsoft: the Roslyn project, a set of APIs and services that provide extended support for the development experience; and TypeScript, the new language created by C# author Anders Hejlsberg, which allows programmers to use advanced JavaScript features today, with excellent support of IDEs and total backwards compatibility.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec38"/>Historical open source movements</h1></div></div></div><p>Microsoft began to<a id="id613" class="indexterm"/> pave the way in open source as far back as 2003, when the first moves were made in order to adopt GPL Licensing on some products, the most noticeable being the effort to standardize the .NET Framework platform in general and the C# Language in particular.</p><p>Actually, it was soon approved as a standard by ECMA (ECMA-334) and ISO (ISO/IEC 23270:2006).</p><p>Later on, the <a id="id614" class="indexterm"/>Mono Project (Xamarin) (<a class="ulink" href="https://en.wikipedia.org/wiki/Mono_(software)">https://en.wikipedia.org/wiki/Mono_(software)</a>), which is now part of Microsoft, provided versions of .NET capable of running in Linux and MacOS. This was probably the first serious attempt to make C# universal. The Mono licensing model<a id="id615" class="indexterm"/> was clearly open (<a class="ulink" href="http://www.mono-project.com/docs/faq/licensing/">http://www.mono-project.com/docs/faq/licensing/</a>), although their IDE was not (Xamarin Studio).</p><p>However, the <a id="id616" class="indexterm"/>acquisition of Xamarin by Microsoft brought even better news to developers, since now, clients of Visual Studio Community Edition could find Xamarin tools and libraries embedded in the IDE with all the value of building Android, iOS, and Windows Phone solutions seamlessly. Likewise, there's a free release of the product called <a id="id617" class="indexterm"/>Xamarin Studio Community Edition.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec76"/>Other projects and initiatives</h2></div></div></div><p>However, what's been discussed so far was only part of the landscape. From 2005, they started to contribute to well-known open source initiatives, such as Linux and Hadoop, in order to use internally open source products and tools and publish some results.</p><p>Some of the best-known projects were the .NET Foundation initiative<a id="id618" class="indexterm"/> and <a id="id619" class="indexterm"/>WinJS, a library to use JavaScript that allows access to the Windows APIs and that appeared aligned with the Windows 8 suite of operating systems, permitting developers to build applications made with HTML5, CSS3, and JavaScript.</p><p>Azure<a id="id620" class="indexterm"/> has been another important division where Microsoft started to show its interest in open source. To previous movements supporting Linux and MacOS directly in Azure, we have to add the recent announcement of SQL Server<a id="id621" class="indexterm"/> running in Linux (<a class="ulink" href="http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux">http://blogs.microsoft.com/blog/2016/03/07/announcing-sql-server-on-linux</a>), and the availability of PowerShell for Mac OS and Linux.</p><p>The latest announcements, officially confirmed in November's Connect() event, only deepen that philosophy: Microsoft becomes a Platinum Partner of the Linux Foundation, one in three virtual machines running in Azure is a Linux "distro", and the inclusion of Bash in Windows 10 allows the native installation of several Linux "distros" in the system.</p><p>On the other side, Google has become a member of the .NET Foundation and it's actively collaborating in the standardization of C#. Microsoft is as of this moment, the company with the highest amount of "open source" projects contributing in Github.</p><p>Finally, the recent collaboration with Samsung and the Tizen initiative only extends the number of collaborations with the open source world.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec77"/>Open source code for the programmer</h2></div></div></div><p>What about the programmer? As we<a id="id622" class="indexterm"/> mentioned, to the announcement of the free Visual Studio Community Edition in 2013 followed the declaration that this tool is going to be free in later editions along with the opening of Xamarin Studio:</p><div><img src="img/image00565.jpeg" alt="Open source code for the programmer"/></div><p style="clear:both; height: 1em;"> </p><p>This change was proposed in the spring of 2015 with the publication of Visual Studio Code, (free and available for Windows, Linux, and MacOS). It's a development tool that joins the capabilities of an editor with the debugging features of an IDE.</p><p>How was Visual <a id="id623" class="indexterm"/>Studio Code coded so that it would work on the three platforms? Three projects? Not quite. It was done thanks to the other big movement that started in 2010, which we introduced in <a class="link" title="Chapter 4. Comparing Approaches for Programming" href="part0028.xhtml#aid-QMFO2">Chapter 04</a> <em>Comparing Approaches to Programming</em> and that I'll cover later in this chapter: TypeScript.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec54"/>Other languages</h3></div></div></div><p>Open source projects also appear with other tools and languages such as Node.js, now used as another type of project from Visual Studio (any version), Python, PHP, or Apache/Cordova. All these technologies are now part of the installable/programmable projects available from the IDE. This goes for GitHub as well, whose engineers collaborate to integrate it better with Visual Studio and Visual Studio Code.</p><p>In the case of <a id="id624" class="indexterm"/>Node.js, you have to install the templates for Visual Studio (a one-time, pretty straightforward operation), and you will be shown several templates when you select in to build a new project, as shown in the following screenshot:</p><div><img src="img/image00566.jpeg" alt="Other languages"/></div><p style="clear:both; height: 1em;"> </p><p>If you work with one of these projects, you'll discover that common tools on other platforms are, by default, available here as well, such as Grunt, Bower, NPM. Gulp, and so on.</p><p>Just for the sake <a id="id625" class="indexterm"/>of completeness, let's perform a basic demo of Node.js with these templates and see how it works. If you select <strong>Basic Node.js Express Application</strong>, a whole application will be generated from the templates, including the files required to launch a working instance of Node.js and a simple web page that uses Node as the localhost web server.</p><div><h3 class="title"><a id="tip14"/>Tip</h3><p>For detailed information on Node, you can check another title in this "Mastering" series, with detailed documentation, explanations and demos: "Mastering Node.js", by Sandro Pasquali (<a class="ulink" href="https://www.packtpub.com/web-development/mastering-nodejs">https://www.packtpub.com/web-development/mastering-nodejs</a>).</p></div><p>By default, the project uses the <a id="id626" class="indexterm"/>Express library, which works seamlessly with Node. The view engine is also the most common one in these projects (it's called Jade, and you can change it at any time or use one of the alternatives available).</p><p>When reviewing the files generated, you'll notice a number of libraries that have been downloaded and updated in our project. This is the result of the IDE's interaction with the <code class="literal">package.json</code> configuration file, which establishes the libraries that the application depends on:</p><div><pre class="programlisting">{
  "name": "ExpressApp1",
  "version": "0.0.0",
  "description": "ExpressApp1",
  "main": "app.js",
  "author": {
    "name": "Marino",
    "email": ""
  },
  "dependencies": {
    "express": "3.4.4",
    "jade": "*",
    "stylus": "*"
  }
}</pre></div><p>This file instructs the IDE to download all libraries required and all the dependencies these libraries rely upon.</p><p>At launch, two windows <a id="id627" class="indexterm"/>will open. On the one hand, Console will open, and on the other hand, an instance of the default browser will open. In the console, Node.js is listening on two ports: the debugging port [<code class="literal">5858</code>] and the Express port [<code class="literal">1337</code>], which take care of web requests, as shown in the following screenshot:</p><div><img src="img/image00567.jpeg" alt="Other languages"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see in the preceding figure, two requests have been made at runtime: the rendered page (which Jade generates from the basic source code in the <code class="literal">index.jade</code> file) and the style sheet, which was referenced in the <code class="literal">layout.jade</code> file that serves as the master page in this demo. Both worked fine (<code class="literal">200</code> status).</p><p>On the other hand, the resulting page from mixing these two .<code class="literal">jade</code> files (the actual master or the main page) is shown in the selected browser (note that you can select more than one browser to create a multi-browser debugging session):</p><div><img src="img/image00568.jpeg" alt="Other languages"/></div><p style="clear:both; height: 1em;"> </p><p>Independently of the aspects of<a id="id628" class="indexterm"/> Node.js programming and its tools, you'll observe that the tool's support is very complete, so we can even mix projects that use different technologies in a single solution, and we don't depend on an installation of IIS for debugging purposes anymore:</p><div><img src="img/image00569.jpeg" alt="Other languages"/></div><p style="clear:both; height: 1em;"> </p><p>Other remarkable areas where the community is very active in the Microsoft Open Source ecosystem are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Entity Framework Core (now in version 1.1)</li><li class="listitem">Microsoft Edge, where users can vote for new features under consideration and use the JavaScript internal engine (Chakra) for their own purposes (just like with Chrome's V8 engine)<div><h3 class="title"><a id="note22"/>Note</h3><p>You can read more about, and collaborate on, these projects at <a class="ulink" href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter">https://developer.microsoft.com/en-us/microsoft-edge/platform/status/backdropfilter</a>, as shown in the previous figure.</p></div></li><li class="listitem">.NET Core<a id="id629" class="indexterm"/> is the latest member in the .NET family, which enables the building of applications that work on any platform: Windows, Linux, or MacOS</li><li class="listitem">The Roslyn and TypeScript projects</li></ul></div><p>And, many, many more</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>The Roslyn project</h1></div></div></div><p>Also<a id="id630" class="indexterm"/> called .NET Compiler Platform<a id="id631" class="indexterm"/> and headed by Anders Hejlsberg, Roslyn is a set of tools and services that help the developer control, manage, and extend the capabilities of any source code editor or IDE and take care of the code in a number of ways, including edition, parsing, analyzing, and compilation. It is part of the .NET Foundation initiative:</p><div><img src="img/image00570.jpeg" alt="The Roslyn project"/></div><p style="clear:both; height: 1em;"> </p><p>Actually, all the magic behind the editors (Intellisense, code snippets, code suggestions, refactoring, and so on) is managed by Roslyn.</p><p>Overall, using Roslyn, you will be able to do the following:</p><div><ul class="itemizedlist"><li class="listitem">Create custom, specific code examination tools, which can be incorporated in the editors in Visual Studio 2015 and other compatible tools. Along with this, you can expand the live code examination engine with your own guidelines. This implies that you can write diagnostics and code fixes (known as analyzers) and code refactoring rules for your APIs or your particular programming needs.</li><li class="listitem">Furthermore, the Visual Studio Editor will identify code issues as you write, squiggling the code that requires consideration and proposing the best possible fixes.</li><li class="listitem">You can instrument code generation, produce IL code (remember the demos we saw in previous chapters), and perform everyday, code-related jobs inside your .NET applications thanks to the compiler APIs.</li><li class="listitem">Also, extensions <a id="id632" class="indexterm"/>are possible by building personalized plugins that can execute outside Visual Studio and also configure MSBuild and exploit the C# compiler to perform code-related jobs.</li><li class="listitem">Create REPLs (read-evaluate-print loops) with your own IDE, which is able to examine and execute C# code.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec78"/>Differences from traditional compilers</h2></div></div></div><p>Usually, compilers <a id="id633" class="indexterm"/>behave as black boxes or like a function in the source code, where the code to be compiled is the argument, there's something going on in the middle, and an output is generated at the other end. The process entails an inner, deep understanding of the code they are dealing with, but such information is not available to developers. Besides, this information is dismissed after the translated output is produced.</p><p>The mission of Roslyn is to open the black box and allow developers to not only know what's going on behind the scenes, but—ultimately—also have the capability to create their own tools and code checkers and extend the traditional possibilities created by old compilers.</p><p>The official documentation for Roslyn<a id="id634" class="indexterm"/> (<a class="ulink" href="https://github.com/dotnet/roslyn">https://github.com/dotnet/roslyn</a>), explains the main changes of this approach by comparing the classical compiler pipeline with the set of services proposed by Roslyn:</p><div><img src="img/image00571.jpeg" alt="Differences from traditional compilers"/></div><p style="clear:both; height: 1em;"> </p><p>As the figure shows, every part of the pipeline has been replaced with APIs that allow you to write code that can be parsed, create <strong>Syntax Tree API</strong>, and generate a whole symbol map out of it, performing the required <strong>Binding and Flow Analysis APIs</strong> in order to finally use the <strong>Emit API</strong> to generate the resulting binaries.</p><p>The way Roslyn<a id="id635" class="indexterm"/> handles these phases is by creating object models for each of them. A deep study on the capabilities and opportunities offered by this set of services and tools is beyond the scope of this book, but I would like to present an introductory view of these possibilities, along with some demo code so that it's possible to start building you own utensils: projects that read code and help identify potential issues and how to fix them.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec79"/>Getting started with Roslyn</h2></div></div></div><p>There are some <a id="id636" class="indexterm"/>requirements that apply before you start using Roslyn from Visual Studio. The first one is to have the Git extension installed: you can find it—as with many others—in the <strong>Extensions and Updates</strong> tool in the <strong>Tools</strong> menu.</p><p>After installation, create a new project in Visual Studio, select the C# Language, and under the <strong>Extensibility</strong> item, choose <strong>Download the .NET Compiler Platform SDK</strong>, as shown in the following screenshot:</p><div><img src="img/image00572.jpeg" alt="Getting started with Roslyn"/></div><p style="clear:both; height: 1em;"> </p><p>An <code class="literal">index.html</code> web page will appear, containing a button linked to downloads for syntax tree visualizers, templates for analyzers, and so on. Note that if you have more than one edition of Visual Studio installed, you will be notified by the <code class="literal">.vsix</code> installer about which products you want the extensions to be installed in.</p><p>Several options appear as available in different contexts now. On the one hand, if you go to the <strong>Tools/Options</strong> menu and check the <strong>Text Editors</strong> item, you can find new options to control the way this language is managed within Visual Studio Editors on the C# side: options to format code for Intellisense, and so on.</p><p>On the other hand, after reloading Visual Studio, if you go back to Extension and Updates, you will find that new types of projects are available now, including <strong>Stand-Alone Code Analysis Tool</strong>, <strong>Analyzer With Code Fix (NuGet + VSIX)</strong>, <strong>Code Refactoring (VSIX)</strong>, and <strong>VSIX Project</strong>, this last one being specific to installations of plugins and the <a id="id637" class="indexterm"/>like. You should get an offer like the one shown in the following screenshot:</p><div><img src="img/image00573.jpeg" alt="Getting started with Roslyn"/></div><p style="clear:both; height: 1em;"> </p><p>Let's start with a simple class and see what we can do with the options. So, I create a new project (a Console one is just fine) and get rid of the using declarations included by default.</p><p>Even with the default initial code we have, Roslyn will read and convert it into a Syntax Tree representation, where everything (every word, whitespace, curly brace, and so on) has a place in the tree and can be managed accordingly. This tree can be examined using the new window available in <strong>View</strong> | <strong>Other Windows</strong> | <strong>Syntax Visualizer</strong> installed by the previous process.</p><p>As soon as we click on the source code (that is, in the middle of the <code class="literal">class</code> word), the window will show the result of the code analysis (we show the legend as well):</p><div><img src="img/image00574.jpeg" alt="Getting started with Roslyn"/></div><p style="clear:both; height: 1em;"> </p><p>You'll notice <a id="id638" class="indexterm"/>that the tree starts with something called <strong>CompilationUnit</strong>, with the main <strong>NamespaceDeclaration</strong> node hanging from it. Therefore, every single element in the source code is now recognizable and manageable.</p><p>If we want to see this tree in a more visual manner, we can right-click on the <strong>CompilationUnit</strong> contextual menu and select the <strong>View Directed Syntax Graph</strong> option, which will show a <code class="literal">.dgml</code> file in the editor with a colored tree in which every color in the legend represents one element in the code.</p><p>When passing the mouse over one element, its properties are shown in a tooltip (also, right-clicking on a single node shows a contextual menu of possible options):</p><div><img src="img/image00575.jpeg" alt="Getting started with Roslyn"/></div><p style="clear:both; height: 1em;"> </p><p>The blue nodes characterize the high-level nodes of the C# grammar that can be divided into smaller units. The green ones are called <em>syntax tokens</em> and are, somehow, like the atoms or basic units of the syntax tree (they cannot be divided into anything smaller).</p><p>The rest of the <a id="id639" class="indexterm"/>nodes (white and gray nodes) are the so-called <em>trivia</em> nodes, and they're not relevant to compilation as they are the parts of the source text considered <em>largely insignificant for normal understanding of the code, such as whitespace, comments, and preprocessor directives</em>, according to the official documentation.</p><p>Besides, there is another very useful online tool (open source) called Source <a id="id640" class="indexterm"/>Visualizer, which is<a id="id641" class="indexterm"/> available at <a class="ulink" href="http://source.roslyn.io/">http://source.roslyn.io/</a> and shows how Roslyn is coded, along with its source code.</p><p>You're allowed to navigate through the whole tree of elements found in the Roslyn project and check them out, reviewing how they are coded to serve as an inspiration for your own code.</p><p>For example, if we click on the left tree in the search for the CSharp compiler, we can see how it is coded and all the details linked to it, as the following screenshot shows:</p><div><img src="img/image00576.jpeg" alt="Getting started with Roslyn"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec80"/>A first look at Microsoft Code Analysis Services</h2></div></div></div><p>Along the course of<a id="id642" class="indexterm"/> this book, and probably long before, you may have noticed the large amount of options available within the source code editors in order to facilitate usual operations, notify errors before compilations, and suggest changes among other things (remember, for example, when talking about the implementation of the <code class="literal">IDispose</code> interface, how the IDE suggested several possible implementations for us).</p><p>From Visual Studio 2015 onwards, these features are just some of the many tools powered by Roslyn. One of the most popular among them is the set of services linked to Code Analyzers.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec55"/>Code Analyzers</h3></div></div></div><p>They're not anything new since they have been at our disposal for years within Visual Studio. However, as part of the work with Roslyn, these features—and many others—were rewritten in order to permit the use of extra functionalities.</p><p>They are usually <a id="id643" class="indexterm"/>divided into three main categories: Code Analyzers, Code Visualizers, and Code Refactors. The three can work together to perform more complex tasks and help the developer in a variety or ways: programmers often need to work with some code they didn't write, or they simply want to know something about the quality of someone else's code:</p><div><ul class="itemizedlist"><li class="listitem">The first category (Code Analyzers) takes care of the generated tree that we saw in the basic demo earlier. These analyzers split the code into pieces, use some type of taxonomy to identify every unit, and place the resulting set in a fashion that can be managed later on by other tools.</li><li class="listitem">Code Visualizers<a id="id644" class="indexterm"/> are responsible for presenting code in a readable manner. They can also provide us with tips about quality and mistakes.</li><li class="listitem">Code Refactors<a id="id645" class="indexterm"/> are small fragments of code that—when applied to a previously recognized block—are able to suggest changes and even apply those changes, directly substituting the original code.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec56"/>An entire open source sample for you to check: ScriptCS</h3></div></div></div><p>There's an open source project that can give you an idea about some of these possibilities. It's called <a id="id646" class="indexterm"/>ScriptCS. Remember, we mentioned that with Roslyn, you can build a tool similar to the REPL (read-evaluate-print-loop) available for Node.js, Ruby, and Python, for example. I mean a tool that can examine and execute C# code.</p><p>To test it, just go to the <a id="id647" class="indexterm"/>ScriptCS website (<a class="ulink" href="http://scriptcs.net/">http://scriptcs.net/</a>) and download the project. It's a Visual Studio solution made up of several projects that shed some light about the possibilities this technology offers.</p><p>Once compiled, if you launch the program, you'll see a console application, which suggests that you write some code to analyze and execute. The tool will use the compiler, and it works in a manner very similar to the Console tool in browsers.</p><p>The aspect will be like<a id="id648" class="indexterm"/> what is shown in the following screenshot. Note that I write three separate sentences, and only after writing the one that produces an output, we get the results in the console:</p><div><img src="img/image00577.jpeg" alt="An entire open source sample for you to check: ScriptCS"/></div><p style="clear:both; height: 1em;"> </p><p>Of course, Roslyn services are creating a class behind the scenes for us and are inserting that code within, later calling the compiler, executing the code, and redirecting the output to the Console window, where we see the results.</p><p>It becomes useful when we just want to check out a simple piece of code without building a whole project.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec57"/>A basic project using Microsoft.CodeAnalysis</h3></div></div></div><p>Let's start <a id="id649" class="indexterm"/>working with these tools, creating<a id="id650" class="indexterm"/> a simple Console application and installing Microsoft.CodeAnalysis tools directly from NuGet Package Manager Console.</p><p>We can type <code class="literal">Install-Package Microsoft.CodeAnalysis</code>, and we'll see the installation process in which all the required dependencies are downloaded, with the last message shown saying something like <code class="literal">Successfully installed 'Microsoft.CodeAnalysis 1.3.2' to [TheNameOfYourProject]</code>.</p><p>In the main method, we are going to load a C# file in order to analyze its contents. With this purpose, we have created a <code class="literal">Person.cs</code> file with the following contents:</p><div><pre class="programlisting">using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace ConsoleRoselyn1
{
  class Person
  {
    public int id { get; set; }
    public string Name { get; set; }
    public int Age { get; set; }
    internal Person Create()
    {
      Person p = new Person();
      p.id = 1;
      p.Name = "Chris Talline";
      p.Age = 33;
      return p;
    }
    internal string PersonData()
    {
      var p = Create();
      return p.id.ToString() + "-" + p.Name + "-" + 
        p.Age.ToString();
    }
  }
}</pre></div><p>Later on, we're <a id="id651" class="indexterm"/>defining a new entry point, <code class="literal">InitialParser.cs</code>, which is going to take care of the analysis. We'll establish this class<a id="id652" class="indexterm"/> as the entry point of the application, and in its main method, we start by reading the file to be checked, using the same class as earlier (CSharpSyntaxTree)—only, this time, we load the file contents early in order to pass them to the <code class="literal">ParseText</code> static method of the class:</p><div><pre class="programlisting">// Fist, we localize and load the file to check out
string filename = @"[Path-to-your-Project]\Person.cs";
string content = File.ReadAllText(filename);
// Now we have to analyze the contents
// So, we use the same class as before. Notice 
// it returns a SyntaxTree object.
SyntaxTree tree = CSharpSyntaxTree.ParseText(content);</pre></div><p>Observe that <code class="literal">ParseText</code> returns a <code class="literal">SyntaxTree</code> object. This is fundamental for analysis since it allows you to iterate over the whole tree in order to inspect how the Tree Object Model was implemented when it was applied to our <code class="literal">Person</code> class.</p><p>If you want to have a clear view of why certain objects are selected to recover the code's properties, remember that the Syntax Tree Viewer that we discussed earlier achieves many of the actions that we are going to perform here, and it offers the corresponding name of the element as we move from one point in the code to another.</p><p>For instance, if you<a id="id653" class="indexterm"/> click on the code right inside <a id="id654" class="indexterm"/>the <code class="literal">class</code> keyword, the Syntax Tree Visualizer will move exactly to that point in the tree, indicating the name associated with the Object Model, as the next screenshot shows:</p><div><img src="img/image00578.jpeg" alt="A basic project using Microsoft.CodeAnalysis"/></div><p style="clear:both; height: 1em;"> </p><p>Now, we have a very nice tool to suggest which classes and classes' members we should identify in the API in order to obtain references to the elements that compose the Syntax Tree.</p><p>If we want to obtain the name of the first class defined in the code (there's only one, but the syntax tree will show as many as there were), first, we need to access the root of the tree. We do that by calling <code class="literal">GetRoot()</code> in the tree object previously obtained.</p><p>Once we have the root element, a look at the methods used throws some light on the possibilities we have. Here are some of these methods, just to name a few:</p><div><ul class="itemizedlist"><li class="listitem">We can go down or up, looking for descendants in search of ancestors since we have access to the whole list of nodes</li><li class="listitem">We can find a given node or check the contents of any node in search for something special</li><li class="listitem">We can read a node's text</li><li class="listitem">We can even insert or remove any of them (refer to the following screenshot):</li></ul></div><div><img src="img/image00579.jpeg" alt="A basic project using Microsoft.CodeAnalysis"/></div><p style="clear:both; height: 1em;"> </p><p>Given that all<a id="id655" class="indexterm"/> collections provided by the <a id="id656" class="indexterm"/>APIs are generic collections, we can ask for nodes of a concrete type using the <code class="literal">OfType&lt;element&gt;</code> syntax. That's what we do next in order to get the <code class="literal">ClassDeclarationSyntax</code> object of our <code class="literal">Person</code> class, so we print it to the console as follows:</p><div><pre class="programlisting">ClassDeclarationSyntax personClass = root.DescendantNodes().OfType&lt;ClassDeclarationSyntax&gt;().First();
Console.WriteLine("Class names");
Console.WriteLine("-----------");
Console.WriteLine(personClass.Identifier);</pre></div><p>We can go on and obtain the method's names in the class using the objects already declared. So, in this case, we'll ask for all the <code class="literal">MethodDeclarationSyntax</code> objects available after the <code class="literal">DescendantNodes()</code> call and go through them, printing their names:</p><div><pre class="programlisting">Console.WriteLine("\nMethod names");
Console.WriteLine("------------"); personClass.DescendantNodes().OfType&lt;MethodDeclarationSyntax&gt;().ToList().ForEach(method =&gt; Console.WriteLine(method.Identifier));</pre></div><p>So, we can go for the properties, knowing that the syntax tree categorizes them as <code class="literal">PropertyDeclarationSyntax</code> objects:</p><div><pre class="programlisting">// And the properties
Console.WriteLine("\nProperties");
Console.WriteLine("----------");
personClass.DescendantNodes()
.OfType&lt;PropertyDeclarationSyntax&gt;().ToList()
.ForEach(property =&gt; Console.WriteLine(property.Identifier));</pre></div><p>The previous code<a id="id657" class="indexterm"/> generates the <a id="id658" class="indexterm"/>following output:</p><div><img src="img/image00580.jpeg" alt="A basic project using Microsoft.CodeAnalysis"/></div><p style="clear:both; height: 1em;"> </p><p>This is one of the recommended procedures to iterate over the syntax tree and recover information about its members, although in this case, we're just reading data and presenting the results.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec81"/>The first approach to code refactoring</h2></div></div></div><p>Based on the previous ideas and APIs, let's look at how to program those diagnosing and refactoring features that Visual Studio offers. That's the main reason for Extensibility.</p><p>Just remember <a id="id659" class="indexterm"/>something about the building and parsing behavior of Visual Studio. Many of these features are disabled by default. The whole set of analysis' capabilities is found—for any project—in the <code class="literal">Project/Properties/Code Analysis</code> tab and is presented with two main options:</p><div><ol class="orderedlist arabic"><li class="listitem">Enable <strong>Code Analysis</strong> on <strong>Build</strong>, which, internally, defines the <code class="literal">CODE_ANALYSIS</code> constant and forces the active set of features to be run against the current code before each compilation. Also, note that you can configure the behavior, changing the severity of any issue to be <code class="literal">Warning</code>, <code class="literal">Error</code>, <code class="literal">Info</code>, <code class="literal">Hidden</code>, or <code class="literal">None</code>.</li><li class="listitem">Select one the available rule sets, which the IDE offers. By default, <strong>Microsoft Managed Recommended Rules</strong> is active, but there are many others to choose and you can even activate/deactivate every single rule in those sets. The following screenshot shows these options:<div><img src="img/image00581.jpeg" alt="The first approach to code refactoring"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div><p>That said, we're going to create one of these projects that appeared after the installation of the SDK that we did earlier.</p><p>What we'll do is select the type of project named Analyzer with code Fix (VSIX) and look at how it is programmed and what the principal units of code are. Then, we'll cover debugging since it works in a peculiar way with respect to any other debugging scenario.</p><p>After creating the<a id="id660" class="indexterm"/> new project, you'll notice the presence of three individual projects in the solution: the analyzer itself, another one for testing purposes, and finally, the one with the <code class="literal">.vsix</code> extension, which serves as the deploying mechanism.</p><p>Let's focus on the first one. To honor its name, there are two classes implied: one for analysis (<code class="literal">DiganosticAnalyzer.cs</code>) and another in charge of code fixing (<code class="literal">CodeFixProvider.cs</code>). It's important to recognize these roles and keep the code like this, even when we want to extend the default functionality.</p><p>It doesn't matter that the project's purpose is a bit simple: it searches for a class definition that contains a lowercase letter and marks it as a target for <code class="literal">CodeFixProvider</code> to advise about this situation.</p><p>To perform this first task of finding the code, the <code class="literal">Analyzer2Analyzer</code> class, which inherits from <code class="literal">DiagnosticAnalyzer</code> performs the following actions (we explain them one by one since it's not obvious at first):</p><div><ol class="orderedlist arabic"><li class="listitem">First, the class is decorated with the <code class="literal">[DiagnosticAnalyzer]</code> attribute, indicating that the language to be used will be CSharp.</li><li class="listitem">Then, at the class level, it declares some strings of type <code class="literal">LocalizableString</code>. The reason is that this could work in different versions of Visual Studio with different locales. This is why the arguments these strings are assigned to are read from a resource file (created for this purpose). Take a look at the <code class="literal">Resources.resx</code> file's contents to check how the strings are saved.</li><li class="listitem">It creates a <code class="literal">DiagnosticDescriptor</code> instance (the rule to be checked), which will be in charge of creating a <code class="literal">Description</code> instance of a given diagnostic. It takes a few arguments to describe the issue to look for, and one of them is Severity, which, by default, is just a warning.</li><li class="listitem">It overrides the read-only <code class="literal">SupportedDiagnostics</code> property to return a new instance of an <code class="literal">InmutableArray</code> array based on the previous rule.</li><li class="listitem">It overrides the <code class="literal">Initialize</code> method, which receives a context object of type <code class="literal">SymbolAnalysisContext</code>, which is in charge of registering the corresponding action we want to perform on the code.<div><ul class="itemizedlist"><li class="listitem">In this demo, it calls the <code class="literal">RegisterSymbolAction</code> method to register two things: the method to be used in the analysis and the category to which such analysis belongs. (Actually, it passes <code class="literal">AnalyzeSymbol</code> as the name of the method).</li><li class="listitem">Also, note that the <code class="literal">RegisterSymbolAction</code> method will be called as many times as required in order to iterate on all instances of symbols that might meet the condition to be tested.</li></ul></div></li><li class="listitem">Finally, it declares the <code class="literal">AnalyzeSymbol</code> method that receives the context, looks at the symbol to be checked, and if it meets the diagnosis (in this demo, if it has any lowercase letter in its name), it creates a <code class="literal">Diagnostic</code> object and indicates the context to call <code class="literal">ReportDiagnostic</code>, which activates whatever action is programmed for this case.</li></ol><div></div><p>As we can see, although <a id="id661" class="indexterm"/>there are not many lines, it's not a simple code. That's why we need to understand how the internals of Roslyn work in order to follow the right actions involved in the context to check for a certain issue. The complete code is as follows:</p><div><pre class="programlisting">using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Linq;

namespace Analyzer2
{
  [DiagnosticAnalyzer(LanguageNames.CSharp)]
  public class Analyzer2Analyzer : DiagnosticAnalyzer
  {
    public const string DiagnosticId = "Analyzer2";

    // You can change these strings in the Resources.resx file. If you do not want your analyzer to be localize-able, you can use regular strings for Title and MessageFormat.
    // See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Localizing%20Analyzers.md for more on localization
    private static readonly LocalizableString Title = new LocalizableResourceString(nameof(Resources.AnalyzerTitle), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormat), Resources.ResourceManager, typeof(Resources));
    private static readonly LocalizableString Description = new LocalizableResourceString(nameof(Resources.AnalyzerDescription), Resources.ResourceManager, typeof(Resources));
    private const string Category = "Naming";

    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);

    public override ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }

    public override void Initialize(AnalysisContext context)
    {
      // TODO: Consider registering other actions that act on syntax instead of or in addition to symbols
      // See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Actions%20Semantics.md for more information
      context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);
    }

    private static void AnalyzeSymbol(SymbolAnalysisContext context)
    {
      // TODO: Replace the following code with your own analysis, generating Diagnostic objects for any issues you find
      var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;

      // Find just those named type symbols with names containing lowercase letters.
      if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))
      {
        // For all such symbols, produce a diagnostic.
        var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);

        context.ReportDiagnostic(diagnostic);
      }
    }
  }
}</pre></div><p>Although the<a id="id662" class="indexterm"/> counterpart (CodeFixer) has some more lines of code, you will be able to read the rest of the code—and understand how it operates—by taking a look at <code class="literal">Analyzer2CodeFixProvider</code> included in the <code class="literal">CodeFixProvider.cs</code> file.</p><p>The two important methods here are the override to <code class="literal">RegisterCodeFixesAsync</code>, which receives <code class="literal">CodeFixContext</code> (required to launch the <code class="literal">fixing</code> action) and the <code class="literal">fixing</code> action represented in the demo by the <code class="literal">MakeUppercaseAsync</code> method.</p><p>When this method is called, it returns a <code class="literal">Task&lt;Solution&gt;</code> object and receives all the required information to perform the task, plus a <code class="literal">CancellationToken</code> object to allow the user to ignore the fix suggestion offered in the contextual dialog box. Of course, it's responsible for <a id="id663" class="indexterm"/>changing the code if the user accepts the modification.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec58"/>Debugging and testing the demo</h3></div></div></div><p>To test these <a id="id664" class="indexterm"/>demos, a new instance of Visual Studio is launched, which <a id="id665" class="indexterm"/>will have the Analyzer registered and active when loaded. For this case, I launched the project, and in the new instance of the IDE, I opened the previous project to understand how it recognizes names of identifiers with lowercase letters.</p><p>So, proceed in this manner, and open our previous <code class="literal">Person.cs</code> file (or any other similar file for that matter) to check this diagnosis in action. You will see a red squiggling underline on the declaration of the <code class="literal">Person</code> class.</p><p>When you place your cursor underneath the word <code class="literal">Person</code>, a tooltip will show up, advising you of a potential problem (in this case, there's no problem at all):</p><div><img src="img/image00582.jpeg" alt="Debugging and testing the demo"/></div><p style="clear:both; height: 1em;"> </p><p>Up until this point, we were dealing with the first class analyzed (the <code class="literal">Analyzer2Analyzer</code> class). But now, we're offered a double option: the yellow bulb, with a contextual menu and the <strong>Show potential fixes</strong> link. Both take to the same window, showing the potential fixes in all places where this fix could be applied.</p><p>Also, note how these fixes are marked with color. In this case, the color is green, indicating that fixes will not provoke another diagnosis issue, but if it does, we will be notified accordingly:</p><div><img src="img/image00583.jpeg" alt="Debugging and testing the demo"/></div><p style="clear:both; height: 1em;"> </p><p>We also have the<a id="id666" class="indexterm"/> option of <strong>Preview changes</strong>, which, in turn, presents another (scrollable) <a id="id667" class="indexterm"/>window in order to examine in detail what would happen to our code if we accept the suggestion (shown in the following screenshot):</p><div><img src="img/image00584.jpeg" alt="Debugging and testing the demo"/></div><p style="clear:both; height: 1em;"> </p><p>To deploy the project, you <a id="id668" class="indexterm"/>can follow two different approaches: use the <code class="literal">NuGet</code> package <a id="id669" class="indexterm"/>generated (you will see it in the <code class="literal">Bin/Debug</code> folder after compilation as usual) or use the <code class="literal">.vsix</code> binaries generated by the compiler, which are also available in the same subdirectory, only in the Vsix project this time.</p><p>In the first case, you should follow the indications in the <code class="literal">Readme.txt</code> file (what follows is a citation of the previously mentioned file):</p><p>To try out the <a id="id670" class="indexterm"/>NuGet package:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a local NuGet feed<a id="id671" class="indexterm"/> by following the instructions here: <a class="ulink" href="http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds">http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds</a>.</li><li class="listitem">Copy the <code class="literal">.nupkg</code> file into that folder.</li><li class="listitem">Open the target project in Visual Studio 2015.</li><li class="listitem">Right-click on the project node in Solution Explorer and choose <strong>Manage NuGet Packages</strong>.</li><li class="listitem">Select the NuGet feed you created on the left-hand side.</li><li class="listitem">Choose your <a id="id672" class="indexterm"/>analyzer from the list and click on <strong>Install</strong>.</li></ol><div></div><p>If you want to automatically deploy the <code class="literal">.nupkg</code> file to the local feed folder when you build this project, follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Right-click on this project in Solution Explorer and choose <strong>Unload Project</strong>.</li><li class="listitem">Right-click on this project and click on <strong>Edit</strong>.</li><li class="listitem">Scroll down to the <strong>AfterBuild</strong> target.</li><li class="listitem">In the <strong>Exec</strong> task, change the value inside <strong>Command</strong> after the <code class="literal">–OutputDirectory</code> path to point to your local NuGet feed folder.</li></ol><div></div><p>The other choice is to launch the <code class="literal">.vsix</code> file (the extension will be recognized by the system). This will install the package in Visual Studio after asking for conformity, just like any other package that you might have previously installed.</p><p>Up to this point, we have introduced Roslyn and its capabilities. Now, we're going to visit the other big open source project, which is getting more hype due to its importance in many web projects, including Angular, Ionic, and many others: TypeScript.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>TypeScript</h1></div></div></div><p>We revert here to the study of TypeScript<a id="id673" class="indexterm"/> that we started in <a class="link" title="Chapter 4. Comparing Approaches for Programming" href="part0028.xhtml#aid-QMFO2">Chapter 04</a> <em>Comparing Approaches to Programming</em>, and that served as an introduction to the language, the tools to use, its integration with Visual Studio and a basic coverage of its possibilities.</p><p>In that chapter, I promised to review the characteristics of the language since it is the other big Microsoft project related to open source since its inception, and it's just gaining momentum and increasing adoption all over the world. TypeScript is, in the words of its own creator, <em>a JavaScript that scales</em>.</p><div><h3 class="title"><a id="tip15"/>Tip</h3><p>However, if you want to deep dive into the language and its possibilities, take a look at the<a id="id674" class="indexterm"/> excellent "Mastering TypeScript" by Nathan Rozentals, available at <a class="ulink" href="https://www.packtpub.com/web-development/mastering-typescript">https://www.packtpub.com/web-development/mastering-typescript</a>.</p></div><p>Let's remind ourselves that the project started around 2010 as a response to the growing popularity of JavaScript—not only in the browsers, but also on the servers. This means writing applications with not just hundreds of thousands, but sometimes millions of lines of code. The language itself lacks some features that we're accustomed to in large-scale application developments.</p><p>As we mentioned<a id="id675" class="indexterm"/> earlier, until ECMAScript 2015, we didn't have classes or modules or any static type system. This static type system is exactly what empowers tools such as V. Studio, Eclipse, JetBrains, and others to enable those features that we're used to in the development cycle.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec82"/>Debugging TypeScript</h2></div></div></div><p>Thanks to that static <a id="id676" class="indexterm"/>type system, TypeScript offers developers experiences parallel to those we would have using the C# language, and that includes debugging, as well.</p><p>As for debugging, TypeScript does not present any extra configuration or difficulties. Since it transpiles to plain JavaScript, all typical resources for JavaScript are usable here as well.</p><p>This is especially useful when using the embedded debugger of Visual Studio because you can set breakpoints in the TypeScript code as well (not only in JavaScript) and debug, as always, watching values at runtime and inspecting elements involved in the process.</p><p>For instance, in the previous code that we used in <a class="link" title="Chapter 4. Comparing Approaches for Programming" href="part0028.xhtml#aid-QMFO2">Chapter 4</a>, <em>Comparing Approaches for Programming</em>, we can mark a breakpoint in the <code class="literal">sorted.map</code> call and watch the values of every element in the array, check the value of this, have access to the <code class="literal">Globals</code> definition, and—in general—witness all the goodness we would expect in a complete, extended, debugging session.</p><p>Just remember that you have to use Internet Explorer (the default browser for Visual Studio).</p><p>You can also use Edge as the default browser if you attach the Visual Studio debugger to the process in this manner using the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Launch the execution and go to the <strong>Visual Studio Debugger</strong> menu.</li><li class="listitem">Enter the <strong>Attach to Process</strong> option, and in the dialog box, select the <strong>Attach to</strong> option to mark Script code.</li><li class="listitem">Finally, in the list of processes, select the <strong>MicrosoftEdgeCP.exe</strong> process in the list and mark a breakpoint.</li><li class="listitem">When you reload the page, the execution will stop at the breakpoint.</li></ol><div></div><p>In addition, you can use Chrome to debug TypeScript code inside as well!</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Debugging TypeScript with Chrome</h2></div></div></div><p>Just open the<a id="id677" class="indexterm"/> previous code using Chrome as the navigator of<a id="id678" class="indexterm"/> your choice. Then, press <em>F12</em>, and you will get access to the <strong>Sources</strong> tab. From there, select the <code class="literal">app.ts</code> file and mark any line with a breakpoint.</p><p>When you reload the page, you will discover how the code stops in the TypeScript line you marked, and all variables and objects implied in the execution are perfectly available. The next screenshot illustrates this excellent feature:</p><div><img src="img/image00585.jpeg" alt="Debugging TypeScript with Chrome"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="tip16"/>Tip</h3><p>Note that Firefox doesn't support the <code class="literal">insertAdjacentElement</code> method. You should use <code class="literal">appendChild</code> instead.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Interfaces and strong typing</h2></div></div></div><p>Let's think of a <a id="id679" class="indexterm"/>more complex object similar to a C# object, containing a field, <a id="id680" class="indexterm"/>methods with more than one signature (overloaded), and so on.</p><p>For example, we can declare a <code class="literal">Calculator</code> interface with the following definition:</p><div><pre class="programlisting">interface Calculator {
  increment?: number,
  clear(): void,
  result(): number,
  add(n: number): void,
  add(): void,
  new (s: string): Element;
}</pre></div><p>The notion of state is provided with an optional increment field (the same syntax as in C#), and four methods are defined. The first two are standard declarations, but the other two deserve a review.</p><p>The <code class="literal">add</code> method is overloaded. We have two definitions: one that gets a number and another with no arguments (both return void). When<a id="id681" class="indexterm"/> using an object that implements the <code class="literal">Calculator</code> interface, we'll discover that the editor recognizes overloading just as we would expect from a <a id="id682" class="indexterm"/>similar object programmed in C# (refer to the next figure):</p><div><img src="img/image00586.jpeg" alt="Interfaces and strong typing"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, the <code class="literal">new</code> method is the way we define a constructor inside an interface. This constructor receives a string but returns <code class="literal">Element</code>. <code class="literal">Element</code> is, in turn, defined as an interface that represents <a id="id683" class="indexterm"/>an object in a document (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Element">https://developer.mozilla.org/en-US/docs/Web/API/Element</a>). It's something that belongs to the DOM (Document Object Model); so, with TypeScript, we can manage almost any DOM component, just like we could in plain old JavaScript.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Implementing namespaces</h2></div></div></div><p>Most evolved languages<a id="id684" class="indexterm"/> allow the concept of namespace. A namespace permits the developer to create areas of code that are totally separated from each other, avoiding the collision of member's names and functionalities.</p><p>TypeScript includes this concept using the <code class="literal">module</code> keyword. A module is a fragment of JavaScript whose members are private to the module. That is, they're not available outside the module unless we declare them in an explicit manner. This is something we do using the export keyword.</p><p>So, a module is declared using a simple, intuitive syntax:</p><div><pre class="programlisting">module Utilities {
  // export generates a "closure" in JS 
  export class Tracker2 {
    count = 0;
    start() {
      // Something starts here...
      // Check the generated JS
    }
  }
}</pre></div><p>Later, the module's <a id="id685" class="indexterm"/>exported members are accessible using the dot notation:</p><div><pre class="programlisting">var t = new Utilities.Tracker2();
t.start();</pre></div><p>Module declarations also admit several levels of indentation to clearly separate different areas of code:</p><div><pre class="programlisting">module Acme.core.Utilities {
  export var x: number = 7;
  export class Tracker2 {
    count = 0;
    start() {
      // Something here 
    }
  }
}
// This requires "nested access"
Acme.core.Utilities.x;</pre></div><p>To simplify access to nested modules, we can also define an alias with the <code class="literal">import</code> keyword, which is especially useful when areas tend to grow:</p><div><pre class="programlisting">// Use of the "Import" technique
import ACU = Acme.core.Utilities;
ACU.x;
var h = new ACU.Tracker2();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec86"/>Declarations, scope, and Intellisense</h2></div></div></div><p>We must not assume that<a id="id686" class="indexterm"/> objects created by the "context" (the browser or the user agent) are accessed in TypeScript by default. For example, the document object that a navigator creates to represent the DOM is not strictly part of the language.</p><p>However, it's very easy to make these members accessible simply by declaring them using the<a id="id687" class="indexterm"/> <strong>declare</strong> keyword. Also, for this case, the TypeScript compiler automatically supplies a declaration because by default, it includes a <code class="literal">'lib.d.ts'</code> file, which provides interface declarations for the built-in JavaScript library as well as the Document Object Model.</p><p>As the official <a id="id688" class="indexterm"/>documentation says, if you want additional help for other libraries, all you have to do is declare them, and the corresponding <code class="literal">.ts</code> library will be used. Imagine that we want to change the title of the document; according to the earlier code, we should write the following:</p><div><pre class="programlisting">declare var document: Document;
document.title = "Hello";  // Ok because document has been declared</pre></div><p>If we need support for jQuery, to mention a popular library, all we have to do is declare it in this way:</p><div><pre class="programlisting">declare var $;</pre></div><p>From this point, any reference to the <code class="literal">$</code> symbol will offer the expected Intellisense in the editor provided that the description file for this library has been referenced.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec59"/>Scope and encapsulation</h3></div></div></div><p>Other important <a id="id689" class="indexterm"/>concepts in relation to the scope and visibility of members are the namespace and module declarations. A namespace allows the programmer to declare private members to a named module, making them invisible for the code not being included inside; so, they're similar to the concept of namespace that we've already seen and that is typical in .NET programming.</p><p>If we want to expose any member of a namespace, the exports keyword allows such definition so that we can have a partially exposed namespace with private members. For instance, take a look at the following code:</p><div><pre class="programlisting">namespace myNS {
  var insideStr = "Inside a Module";
  export function greeter() {
    return insideStr;
  }
}
myNS.greeter();
myNS.insideStr;</pre></div><p>If we check this code inside Visual Studio, we'll <a id="id690" class="indexterm"/>see an advice from the compiler as we pass over the last sentence, indicating that property <code class="literal">insideStr</code> doesn't exist inside the <code class="literal">MyNS</code> module (which really means that from a namespace perspective, this member is not declared accessible or maybe it doesn't exist).</p><p>On the other hand, no <a id="id691" class="indexterm"/>advice is given in reference to the exposed greeter method, since the exports clause was used in its <a id="id692" class="indexterm"/>declaration (for other OOP languages, we would say that the greeter member is public).</p><div><img src="img/image00587.jpeg" alt="Scope and encapsulation"/></div><p style="clear:both; height: 1em;"> </p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Classes and class inheritance</h2></div></div></div><p>As we've seen, classes<a id="id693" class="indexterm"/> are a key part of TypeScript, and their declaration syntax is almost identical to the C# declarations we all know.</p><p>That is, we can declare <a id="id694" class="indexterm"/>private members, customized constructors, methods, access properties, and even static members so that they can be accessed using the name of the class instead of a variable instance. Take a look at this code written by Anders Hejlsberg in an online demo and published by Channel 9 (<a class="ulink" href="https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript">https://channel9.msdn.com/posts/Anders-Hejlsberg-Introducing-TypeScript</a>, in case you want to follow all the details and comments that this author provides):</p><div><pre class="programlisting">class PointWithColor {
  x: number;
  y: number;
  // Private members 
  private color: string;
  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
    this.color = "Blue"; // Intellisense -in- the class
  }
  distance() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  // We can also (ES5) turn distance into a property
  get distanceP() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  // And declare static members
  static origin = new PointWithColor(0, 0)
}</pre></div><p>As you can see, there's a <a id="id695" class="indexterm"/>color declaration using the <code class="literal">private</code> keyword, a customized <a id="id696" class="indexterm"/>constructor, a read-only property (get <code class="literal">distanceP</code>), and a static declaration (<code class="literal">origin</code>) to establish the initial point of drawing.</p><p>Optionally, there is a variant of the { get; set; } construction of C# in the class' constructor, which allows you to simplify declarations and assign an initial value to the constructor's arguments.</p><p>With this syntax, we can write a simplified variation of the previous class, as follows:</p><div><pre class="programlisting">class PointWithColor2 {
  // Private members 
  private color: string;
  // The following declaration produces the same effect 
  // as the previous as for accessibility of its members 
  // Even, assigning default values
  constructor(public x: number = 0, public y: number = 0) {
    this.color = "Red"; 
  }
  distance() { return Math.sqrt(this.x * this.x + this.y * this.y); }
  get distanceP() { return Math.sqrt(this.x * this.x + this.y * this.y); }
  static origen = new PointWithColor(0, 0)
}</pre></div><p>Of course, in order to properly implement OOP, we also need inheritance. Inheritance is achieved using the <code class="literal">extends</code> keyword in the declaration of a class. So, we can define a new, inherited version of the previous class as follows:</p><div><pre class="programlisting">class PointWithColor3D extends PointWithColor {
  // It uses the base class constructor, otherwise
  // creates a customized one.
  constructor(x: number, y: number, public z: number) {
    super(x, y);
  }
  // Method overloading 
  distance() {
    var d = super.distance();
    return Math.sqrt(d * d + this.z * this.z);
  }
}</pre></div><p>The previous<a id="id697" class="indexterm"/> code uses another specific keyword here, <code class="literal">super</code>, in order to refer<a id="id698" class="indexterm"/> to the parent class. There's much more to the language, and we recommend the detailed documentation found at GitHub (<a class="ulink" href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md">https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md</a>) for more details and code snippets.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec60"/>Functions</h3></div></div></div><p>In the Greeter class discussed in<a id="id699" class="indexterm"/> the initial demo, the <code class="literal">start()</code> and <code class="literal">stop() </code>methods didn't have any return value. You can express a return value for a function in exactly the same way as we do with parameters: appending a colon (<code class="literal">:</code>) at the end, thus allowing us to express the whole signature of any function. So, for the typical <code class="literal">add</code> function, we can write the following:</p><div><pre class="programlisting">add(x: number, y: number): number {
    return x + y;
}</pre></div><p>One the most common practices in the language is to use interfaces to declare user-defined object types. Once declared, the interface will be checked against any member proclaiming its implementation:</p><div><pre class="programlisting">interface Person {
    name: string, 
    age?: number  // the age is optional
}

function add(person: Person) {
    var name = person.name; // Ok
}

add({ name: "Peter" });  // Ok
add({ age: 37 });  // Error, name required
add({ name: "Irene", age: 17 });  // Ok</pre></div><p>As you can see, <code class="literal">age</code> is declared with the same syntax as what we used with C# for optional values, except that no default value is required.</p><p>Similarly, we can declare a<a id="id700" class="indexterm"/> type and assign it a value in the same sentence:</p><div><pre class="programlisting">// Declare and initialize
var person: {
    name: string;
    age: number;
    emails: string[];
} = {
        name: 'John',
        age: 5,
        emails: ['john@site.com', 'john@anothersite.net']
    }</pre></div><p>If we declare a function using the lambda expression as one of the argument's syntaxes, the compiler infers that the type of the argument is a function:</p><div><pre class="programlisting">function funcWithLambda(x: () =&gt; string) {
    x(); // Intellisense
}</pre></div><p>This is how it is displayed in the IDE:</p><div><img src="img/image00588.jpeg" alt="Functions"/></div><p style="clear:both; height: 1em;"> </p><p>An interface may allow<a id="id701" class="indexterm"/> you also to declare method overloading. Take a look at this declaration and note the double definition for the <code class="literal">doSomething</code> method:</p><div><pre class="programlisting">interface Thing {
    a: number;
    b: string;
    doSomething(s: string, n?: number): string; //methods
    // Method overloading
    doSomething(n: number): number;
}

function process(x: Thing) {
    x.doSomething("hola"); // Intellisense
    x.doSomething(3); // Ok
}</pre></div><p>A variant of the previous declaration allows us to declare overloading and include a data field for the <code class="literal">doSomething</code> member:</p><div><pre class="programlisting">// Methods with properties
// Equivalent to the previous + data
interface Thing3 {
    a: number;
    b: string;
    // Here we add a field data to doSomething
    doSomething: {
        (s: string): string;
        (n: number): number;
        data: any;
    };
}</pre></div><p>Later, we can refer <code class="literal">Thing3</code> using the following syntax:</p><div><pre class="programlisting">function callThing3(x: Thing3) {
    x.doSomething("hello"); // Intellisense (overloading)
    x.doSomething(3);
    x.doSomething.data; // method with properties
}</pre></div><p>Here, you can see how the three different references to the overloaded forms of <code class="literal">doSomething</code> are considered valid by the compiler. We even have the possibility of declaring constructors and indexers (much like in C#):</p><div><pre class="programlisting">interface Thing4 {
    // Constructor
    new (s: string): Element;
    // Indexer
    [index: number]: Date;
}

function callThing4(x: Thing4) {
    // return new x("abc").getAttribute() -&gt; returns Element
    return x[0].getDay(); // Date info
}</pre></div><p>Another possibility is<a id="id702" class="indexterm"/> based on TypeScript's ability of defining an interface to enforce the return type:</p><div><pre class="programlisting">interface Counter {
    delete(): void;
    add(x: number): void;
    result(): number;
}

function createCounter(): Counter {
    var total = 0;
    return {
        delete: function () { total = 0 },
        add: function (value: number) {
            total += value;
        },
        result: function () { return total; }
    };
}

var a = createCounter();
a.add(5); //Ok

// It's also useful for event handlers
window.onmousemove = function (e) {
    var pos = e.clientX; // Intellisense in the event
    // You can use the "Go to Definition" option -&gt;
    // which takes you to "lib.d.ts" library
}</pre></div><p>I want you to check the definition of any member, remember that right-clicking and selecting "<strong>Go to Definition</strong>" will open the corresponding <code class="literal">lib.d.ts</code> file and show the original definition of any member; for example, the <code class="literal">clientX</code> member of the <code class="literal">event</code> object will show the following information:</p><div><img src="img/image00589.jpeg" alt="Functions"/></div><p style="clear:both; height: 1em;"> </p><p>In the same way, we<a id="id703" class="indexterm"/> can import declarations from other libraries and use this technique to check those implementations: this includes jQuery, Bootstrap, and so on. The site <a id="id704" class="indexterm"/>Definitely Typed (<a class="ulink" href="https://github.com/DefinitelyTyped/DefinitelyTyped">https://github.com/DefinitelyTyped/DefinitelyTyped</a>) holds hundreds of these definitions.</p><p>Moreover, there is still another way to declare overloaded functions: you can declare several signature methods and finish the block with a real function definition and implementation. This is done in order to avoid TypeScript from showing errors at compile time, although the final implementation in JavaScript will only consist of one function given that JavaScript doesn't have types.</p><p>In this way, the previous definitions are taken as overloaded versions of the last definition, such as what is shown in the next piece of code:</p><div><pre class="programlisting">class OverloadedClass {
    overloadedMethod(aString: string): void;
    overloadedMethod(aNumber: number, aString: string): void;
    overloadedMethod(aStringOrANumber: any, aString?: string): void {
        // Version checking is performed on the first argument
        if (aStringOrANumber &amp;&amp; typeof aStringOrANumber == "number")
            alert("Second version: aNumber = " + aStringOrANumber +
                ", aString = " + aString);
        else
            alert("First version: aString = " + aStringOrANumber);
    }
}</pre></div></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec61"/>Arrays and interfaces</h3></div></div></div><p>We can also use the concept of interface to <a id="id705" class="indexterm"/>declare conditions, types, and<a id="id706" class="indexterm"/> behaviors related to array elements.</p><p>Take a look at this code in which we enforce type and behavior for an array of mountains:</p><div><pre class="programlisting">interface Mountain {
    name: string;
    height: number;
}
// Mountain interface declared
var mountains: Mountain[] = [];
// Every added element is checked
mountains.push({
    name: 'Pico de Orizaba',
    height: 5636,
});
mountains.push({
    name: 'Denali',
    height: 6190
});
mountains.push({
    name: 'Mount Logan',
    height: 5956
});

function compareHeights(a: Mountain, b: Mountain) {
    if (a.height &gt; b.height) {
        return -1;
    }
    if (a.height &lt; b.height) {
        return 1;
    }
    return 0;
}
// Array.sort method expects a comparer which takes 2 arguments
var mountainsByHeight = mountains.sort(compareHeights);
// Read the first element of the array (Highest)
var highestMoutain = mountainsByHeight[0];
console.log(highestMoutain.name); // Denali</pre></div><p>The <code class="literal">Mountain</code> interface<a id="id707" class="indexterm"/> makes sure that every element belonging to the <code class="literal">mountains</code> array actually implements the <code class="literal">Mountain</code> definition so that it can be compared later, which is something you can check if you include this code in an HTML script section. In the Console output, the "Denali" mountain is correctly sorted to be the highest by the <code class="literal">sort</code> method of the array.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec88"/>More TypeScript in action</h2></div></div></div><p>So, let's take a look at <a id="id708" class="indexterm"/>some more TypeScript in action, starting with some other simple code. After creating an empty solution in Visual Studio and adding a JavaScript file (a <code class="literal">.js</code> extension), here, I'm using a code pattern offered in several demos on the official site in order to illustrate some changes these tools can offer. So, I type the following (a short function to sort an array and return the results):</p><div><pre class="programlisting">// JavaScript source code
function sortByName(arg) {
  var result = arg.slice(0);
  result.sort(function (x, y) {
    return x.name.localCompare(y.name);
  });
  return result;
};</pre></div><p>When we pass the mouse over the <code class="literal">arg</code> argument, the editor is unable to tell anything about the type of argument (with only this code, it is impossible to know anything else). If we write <code class="literal">sortByName</code> a couple of lines after the function, the editor recognizes the name, but it can't add any more information about it:</p><div><img src="img/image00590.jpeg" alt="More TypeScript in action"/></div><p style="clear:both; height: 1em;"> </p><p>Now, let's add a new file of the same name and copy the contents of the previous file inside, only changing the extension to <code class="literal">.ts</code> (TypeScript). Even with exactly the same content, the editor's behavior changes.</p><p>First, when you now pass the cursor over the argument, it says that it's of type <code class="literal">any</code>. This happens when you pass over the s<code class="literal">ortByName</code> declaration outside the function as well.</p><p>However, it can get even better. Since the function expects you to operate with an array of a type that has a <code class="literal">name</code> and <code class="literal">age</code> property, we can declare that object as an interface which includes both properties, such as a <code class="literal">Person</code> interface (or any other interface that complies with this requirement). Now, we can explicitly define that <code class="literal">arg</code> is an array of type <code class="literal">Person</code>, indicating it in the argument declaration after a colon, so we have the following:</p><div><pre class="programlisting">interface Person {
  name: string, 
  age: number
}
function sortByName(arg: Person[]) {}</pre></div><p>And here, the<a id="id709" class="indexterm"/> magic starts to happen. When I pass the cursor over the argument, it now indicates the type it should receive, but also, if I hover over the <code class="literal">arg.slice(0)</code> code fragment, it gives me a detailed explanation of what it expects to receive, and when I move my cursor down, I see that there's a red squiggle under the <code class="literal">localCompare</code> method call, signifying that such a method doesn't exist on type string (because it recognizes that name is of the type defined previously).</p><p>You can see both hints in the following (compound) screenshot:</p><div><img src="img/image00591.jpeg" alt="More TypeScript in action"/></div><p style="clear:both; height: 1em;"> </p><p>So, there's a bunch of extra information available just by making a few changes in the code in order to instruct TypeScript about the types we're dealing with. We see this if we try to rewrite the <code class="literal">name.local…</code> call in the search for help.</p><p>If we do this, and retype the sentence, when we press the dot symbol next to <code class="literal">return.name</code>, we'll be given a list of possible values that the <code class="literal">name</code> property admits, including the correct form of writing the sentence that was misspelled, as shown in the next screenshot. We also see extra information about the parameters that <code class="literal">localeCompare</code> should receive and the number of overloads that it defines:</p><div><img src="img/image00592.jpeg" alt="More TypeScript in action"/></div><p style="clear:both; height: 1em;"> </p><p>Actually, since <a id="id710" class="indexterm"/>TypeScript supports advanced features, you can use them right now with total backward compatibility: for instance, we can change the function argument we pass to the sort method into a lambda expression, just as if we were using ECMAScript 2015.</p><p>Let's take a look at the entire example. We'll define an array of hardware appliances along with their prices and identification numbers. The target is to sort the array by name and dynamically generate an output in a page, showing the names and prices in the sorted array.</p><p>This is the code we'll use:</p><div><pre class="programlisting">interface Entity {
  name: string,
  price: number, 
  id : number
}

var hardware: Entity[] = [
  { name: "Mouse", price: 9.95, id: 3 },
  { name: "Keyboard", price: 27.95, id: 1 },
  { name: "Printer", price: 49.95, id: 2 },
  { name: "Hard Drive", price: 72.95, id: 4 },
];

function sortByName(a: Entity[]) {
  var result = a.slice(0);

  result.sort(function (x, y) {
    return x.name.localeCompare(y.name);
  });
  return result;
}
window.onload = () =&gt; {
  var sorted = sortByName(hardware);
  sorted.map((e) =&gt; {
    var elem = document.createElement("p");
    document.body.insertAdjacentElement("beforeEnd", elem);
    elem.innerText = e.name.toString() + " - " + e.price.toString();
  });
}</pre></div><p>First, the <code class="literal">Entity</code> declaration <a id="id711" class="indexterm"/>guarantees that the later array definition of type <code class="literal">Entity[]</code> is recognized by the editor. At the time of putting everything together, the <code class="literal">window.onload</code> event uses a lambda expression with no arguments.</p><p>In the body of this expression, a sorted array is produced from the original definition, and then the new <code class="literal">map</code> method included in JavaScript 5 is called, allowing us to pass a callback function to be executed for every element in the array.</p><p>Again, we use a lambda expression to define the callback function, where <code class="literal">e</code> will represent—sequentially—the elements of the array (<code class="literal">entities</code>). We will have Intellisense in the edition even when using the properties of <code class="literal">e</code> so that we ensure that all members end up correctly spelled.</p><p>The execution shows the <a id="id712" class="indexterm"/>list of elements, ordered by name, including the <code class="literal">name</code> and <code class="literal">price</code> fields, just as we expected:</p><div><img src="img/image00593.jpeg" alt="More TypeScript in action"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec89"/>The DOM connection</h2></div></div></div><p>The "DOM connection" we mentioned <a id="id713" class="indexterm"/>earlier is very helpful in a variety of cases. Imagine that we want an alert dialog indicating the X coordinate of the mouse when the cursor moves over the window. We could program something like this:</p><div><pre class="programlisting">window.onmousemove = function (e) {
  alert("Mouse moved at X coord: " + e.clientX);
};</pre></div><p>If we pass the mouse over the <code class="literal">e</code> argument (representing the event object), we'll be shown a tooltip containing the event definition as well. And if we write <code class="literal">e.</code> (dot)…, Intellisense will again show up knowing exactly what can be done with that object. (Refer to the following figure):</p><div><img src="img/image00594.jpeg" alt="The DOM connection"/></div><p style="clear:both; height: 1em;"> </p><p>Where does this extra Intellisense come from? We have the ability to check this feature in the same manner as we would in other languages in Visual Studio. Just mark <code class="literal">onmousemove</code> or the <code class="literal">e</code> object, and in the contextual menu, select <strong>Go to Definition</strong> or <strong>Peek definition</strong>.</p><p>The IDE opens a new window pointing to the definition extracted from a file called <code class="literal">Lib.d.ts</code> and shows every detail. As mentioned previously, this file is the declaration file for <a id="id714" class="indexterm"/>the entire <a id="id715" class="indexterm"/>DOM and all the JavaScript's standard runtime libraries (it contains about 8,000 lines of code declarations).</p><p>Also, anyone can write these declaration files and upload them to the DefinitelyTyped site, since its completely open source:</p><div><img src="img/image00595.jpeg" alt="The DOM connection"/></div><p style="clear:both; height: 1em;"> </p><p>So, let's summarize some of the most important points discussed up until this point:</p><div><ul class="itemizedlist"><li class="listitem">We count on a formalization of the JavaScript types that allow excellent edition tools</li><li class="listitem">We find type inference and structural typing since the very beginning</li><li class="listitem">It all works with existing JavaScript, with no modifications</li><li class="listitem">Once the code is compiled, everything goes away, and the resulting code is nothing but plain JavaScript of the version of your choice</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we went through some of the most important projects that Microsoft promotes as part of its Open Source ecosystem.</p><p>First, we reviewed the evolution of "open source" projects since the initial movements and revised some of the new tools and technologies under the open source initiatives, including how to program with Node.js from Visual Studio.</p><p>Then, we moved on to the Roslyn set of tools and services and explored how to install the tools, identify the Syntax Object Model, and program a basic analyzer with code refactoring capabilities and understand how to debug it.</p><p>Finally, we took a tour of the main language features of TypeScript, studying some of the most meaningful and proper definitions of the language and checking the excellent support we get in the code editor thanks to its static type system.</p><p>In the next chapter, we'll cover the concept of Software Architecture, from high-level abstract concepts to low-level implementation. I will outline a step-by-step guide on designing a .NET application from the ground up.</p></div></body></html>