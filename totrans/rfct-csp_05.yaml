- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-Oriented Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we saw how refactoring can help improve classes and their
    methods. In this chapter, we’ll explore the bigger picture with creative uses
    of **object-oriented programming** (**OOP**) to refactor a series of classes into
    more maintainable forms. These tools will help you perform larger and more impactful
    refactorings and make a bigger difference in improving your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes via refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling inheritance with abstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring for better encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving classes with interfaces and polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The starting code for this chapter is available from GitHub at [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    in the `Chapter05/Ch5BeginningCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the flight search system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter’s code focuses on a flight scheduling system for Cloudy Skies Airlines.
  prefs: []
  type: TYPE_NORMAL
- en: The flight scheduling system is a simple one that tracks all active flights
    through a `FlightScheduler` class and allows external callers to search for flights
    of interest. This class in turn tracks flights through a collection of `IFlightInfo`
    instances, which may either be a `PassengerFlightInfo` or a `FreightFlightInfo`
    instance, depending on whether the flight carries passenger or freight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level interactions of these classes can be seen in *Figure 5**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling
    system](img/B21324_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Classes involved in the Cloudy Skies Airline flight scheduling
    system
  prefs: []
  type: TYPE_NORMAL
- en: The code currently works and even uses polymorphism effectively to track a variety
    of different flights. That being said, there are some opportunities for improvement,
    as we’ll see. Throughout this chapter, we’ll make targeted improvements while
    demonstrating the breadth of refactoring possibilities present when using object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing classes via refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s not uncommon for solutions to have organizational challenges such as misnamed
    files or types existing in the wrong file or namespace.
  prefs: []
  type: TYPE_NORMAL
- en: These problems may seem small, but they can make it harder for developers to
    find the code they’re looking for – particularly when first joining the project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few refactorings that help developers navigate code more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Moving classes to individual files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common mistake I’ve seen teams make is putting multiple types inside of
    the same file. Usually, a file starts with a single class or interface and then
    a developer decides to add a related type. Instead of putting the new type in
    a file of its own, the class gets added to the existing file. Once this happens
    for a few small classes, it tends to snowball after that with developers continuing
    to add new types to the file as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with the use of the word “type” in the .NET world, a
    type is a generic term that refers to anything supported by the **common type
    system** (**CTS**). Essentially, if you can use it to declare a variable, it’s
    probably a type. Some examples of types include classes, interfaces, structs,
    enums, and the various record type variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IFlightInfo.cs` file from the Flight Scheduling System has a few different
    types defined in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'While this example might not seem so bad, having multiple types in a single
    file does cause a few problems:'
  prefs: []
  type: TYPE_NORMAL
- en: New developers who are looking for a specific type have trouble finding which
    file contains that type without using search features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Version control systems, such as git, track changes to each file. This can increase
    confusion when teams must merge code or even determine what changed in any given
    software release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fix for this is to move each type to its own dedicated file. This can be
    done by going to the **Quick Actions** menu on a type whose name doesn’t match
    the file name. Next, select the **Move type to [new file name].cs** option as
    shown in *Figure 5**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Moving a type to its own file](img/B21324_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Moving a type to its own file
  prefs: []
  type: TYPE_NORMAL
- en: Selecting this option removes the type from the original file and creates a
    new file containing only the type you selected.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to repeat this for every type that doesn’t match the name of the
    file in Visual Studio. One of the extra refactoring tools that ReSharper and Rider
    provide allows you to perform this refactoring for every type in the file, folder,
    or solution. This can be particularly handy if you encounter a single file with
    hundreds of types in it.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming files and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, you’ll find cases where a file and the type that it contains don’t
    match. This often happens when developers create a new class and then decide to
    rename it later without using the rename refactoring built into Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AirportInfo.cs` file and its `Airport` class are an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Usually, the fix for this is to rename the file to match the name of the type
    (though occasionally you’ll determine the file was named correctly) and the class
    should be renamed to match the name of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With either option, open the **Quick Actions** menu on the type in question
    and select either **Rename file** or **Rename type** to ensure the file and type
    name match. See the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Options to rename the file or rename the type](img/B21324_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Options to rename the file or rename the type
  prefs: []
  type: TYPE_NORMAL
- en: I chose to rename the file to `Airport.cs`, as either option will ensure that
    the file and type have the same name. This naming consistency is a small improvement,
    but it helps developers navigate your project more easily over time.
  prefs: []
  type: TYPE_NORMAL
- en: Changing namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET uses **namespaces** to organize types into a hierarchical structure. By
    convention, these namespaces should match the folders inside the project in **Solution
    Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: The project will start with a namespace such as `Packt.CloudySkiesAir.Chapter5`,
    and each folder nested inside of a project adds to this namespace. For example,
    a `Filters` folder in that project should use a `Packt.CloudySkiesAir.Chapter5.Filters`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: When classes don’t use the expected namespace, it can lead to confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a practical example, let’s look at the `Airport.cs` file in the root of
    the `Chapter5` project as shown in *Figure 5**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A project with the Airport class directly nested inside of the
    project](img/B21324_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A project with the Airport class directly nested inside of the
    project
  prefs: []
  type: TYPE_NORMAL
- en: 'In this scenario, you would expect the `Airport` class to live in the `Packt.CloudySkiesAir.Chapter5`
    namespace. However, the file uses a different namespace, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This discrepancy can be fixed through manual editing of the namespace declaration
    or by using the **Change namespace to match folder structure** under **Quick Action**
    refactoring, as shown in *Figure 5**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Changing the namespace to match the folder structure](img/B21324_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Changing the namespace to match the folder structure
  prefs: []
  type: TYPE_NORMAL
- en: I personally recommend using the `using` statements to other files as needed
    to support the namespace change.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding partial classes and regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to refactoring and inheritance, I want to cover two related
    **anti-patterns** I’ve seen in C# code when dealing with large classes.
  prefs: []
  type: TYPE_NORMAL
- en: When developers have large classes with many different blocks of related code,
    there’s a temptation to use several language features to make organizing the file
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers use the `#region` preprocessor directive to create regions of
    code that can expand and collapse.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could use a statement such as `#region Stuff I don''t want
    to look at right now` with a matching `#endregion` statement on its own line.
    This would create a collapsible region of code in the editor, as the collapsed
    region from lines 33–84 in *Figure* *5**.6* illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A collapsed region of code](img/B21324_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A collapsed region of code
  prefs: []
  type: TYPE_NORMAL
- en: '`#region` is viewed as a bad thing to rely on for code organization; it leads
    to extremely large classes instead of refactoring code into more maintainable
    patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: So, why does it exist at all?
  prefs: []
  type: TYPE_NORMAL
- en: The `#region` directive was introduced to help hide auto-generated code commonly
    built into older versions of .NET applications. This is code that developers were
    not expected to work with and often encouraged not to modify for fear of breaking
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, .NET got **partial classes** to help in scenarios that regions were
    previously used in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial classes are classes that are defined in *multiple files* within the
    *same project*. This will allow you to have `FlightScheduler.ItemManagement.cs`
    and `FlightScheduler.Search.cs` files that each contain parts of the larger class.
    This lets you define a large class over multiple files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like region directives, partial classes are intended to support automatically
    generated code. While I personally prefer partial classes to `#region` directives,
    I view both as anti-patterns when they are applied to reducing pains caused by
    large classes.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when your classes are big enough for you to want to consider `#region`
    or partial classes, you are violating the single responsibility principle and
    your class should be broken up into multiple smaller classes that are distinctly
    different from one another.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the single responsibility principle and other design principles
    in [*Chapter 8*](B21324_08.xhtml#_idTextAnchor173), *Avoiding Code Anti-patterns*
    *with SOLID*.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered some of the ways refactoring can help organize your code,
    let’s dive into refactorings related to inheritance. This is a collection of refactorings
    that involve either overriding methods, introducing inheritance, or altering in-place
    inheritance relationships to improve the maintainability of code.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding ToString
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ToString` is one of the four methods that any .NET object is guaranteed to
    have due to the `virtual` definition of `ToString` on `System.Object`. This method
    is used whenever an object is converted to a string and can be particularly handy
    for logging and debugging purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes overriding `ToString` can simplify your code in unexpected ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `BuildFlightIdentifier` method in `FreightFlightInfo.cs`.
    This method relies on the `DepartureLocation` and `ArrivalLocation` properties
    of type `Airport` to produce a string:'
  prefs: []
  type: TYPE_NORMAL
- en: FreightFlightInfo.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s annoying to have to drill into these location properties to reach their
    `Code` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `Airport` overrides the `ToString` method and returns the airport code,
    we would be able to simplify the readability of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To do this, you can either go to `Airport.cs` and add the override manually
    or use the built-in refactoring option through the **Generate overrides...** refactoring
    (see *Figure 5**.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Generating overrides on a class](img/B21324_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Generating overrides on a class
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, you’ll need to specify which methods or properties you want to
    override. As shown in the following image, any abstract or virtual member of a
    class you’re inheriting from will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Selecting the members to override](img/B21324_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Selecting the members to override
  prefs: []
  type: TYPE_NORMAL
- en: Selecting `ToString()` and clicking **OK** generates a stubbed-out method that
    can be quickly replaced with an actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this class, the `ToString` method should return the airport code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this override in place, existing code can still use the `Code` property
    without issues. However, any code that previously tried to write an `Airport`
    object to the console now will see its code instead of the namespace and name
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of `ToString` in .NET is to return a string with
    the namespace and the name of the type. In this case that would have been `Packt.CloudySkiesAir.Chapter5.AirTravel.Airport`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should look at everywhere the `Code` property is currently being read
    from and see if it would be more readable to rely on the `ToString` override instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this in any edition of Visual Studio 2022 by right-clicking on the
    `Code` property declaration and choosing **Find All References**, as shown in
    *Figure 5**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – The Find All References context menu option](img/B21324_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – The Find All References context menu option
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens a new pane with all references of that property highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Find All References results](img/B21324_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Find All References results
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then modify these areas to use `ToString` where appropriate, such as
    in this modification to `PassengerFlightInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'One added benefit of overriding `ToString` in your objects is an improved display
    of the class when viewing the Visual Studio debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – ToString override displaying in debugging tools](img/B21324_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – ToString override displaying in debugging tools
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore debugging more in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*:
    Defensive* *Coding Techniques*.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating equality methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, equality for reference types (such as classes) is done using **reference
    equality** –determining whether the two objects are located at the same location
    in the **heap**.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it’s more convenient to compare different properties on two objects
    to see if their values are equivalent, even if the two objects represent two separate
    locations on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code from the `FlightScheduler` class shows how its `Search`
    method checks to make sure the airport you’re searching for has the same airport
    code and country. Note the repeated logic when determining if two airports are
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code could be simplified by overriding equality members with our own customized
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Equality members
  prefs: []
  type: TYPE_NORMAL
- en: '.NET provides two methods to determine equality: `Equals` and `GetHashCode`.
    The `Equals` method determines whether two objects are equivalent while `GetHashCode`
    is used to determine which major “bucket” an object is sorted into for `Dictionary`
    and `HashSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: You should never override only one of these two methods; whenever you override
    `Equals`, you will need to override `GetHashCode` as well. Furthermore, you want
    to make sure you use a good implementation of `GetHashCode` that evenly and consistently
    distributes objects in your class into different hash values.
  prefs: []
  type: TYPE_NORMAL
- en: .NET also provides an `IEquatable<T>` interface that you can implement for strongly
    typed equality comparisons, which can improve performance. Implementing `IEquatable<T>`
    is generally recommended when overriding equality members but is not detailed
    in this book. See the *Further reading* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality and hash codes can get complex very quickly, but thankfully we have
    some very good tooling for generating equality members in Visual Studio. Just
    select your class and then choose **Generate Equals and GetHashCode…** from the
    **Quick Actions** menu, as shown in *Figure 5**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Generating equality member overrides](img/B21324_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Generating equality member overrides
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select this, Visual Studio will ask you what members should contribute
    to equality and hash code checks, as shown in *Figure 5**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Selecting equality members](img/B21324_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Selecting equality members
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the members that *must* be equal and click **OK** to generate your overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: Airport.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, Visual Studio generated a pattern matching the `Equals` implementation
    that compares the relevant properties. Additionally, the `GetHashCode` implementation
    uses the newer `HashCode.Combine` method to safely simplify the process of hash
    code generation for you.
  prefs: []
  type: TYPE_NORMAL
- en: Updating equality members
  prefs: []
  type: TYPE_NORMAL
- en: If you ever add new properties to your class that should factor into equality
    checks, be sure to update `Equals` and `GetHashCode` to include these properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'With custom equality members in place, code that previously checked both the
    airport `Code` and `Country` can be simplified to use the equality operator (`==`)
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightScheduler.cs – Search
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Overriding equality members can be handy when you have many similar objects
    on the heap that contain identical values. This can happen when working with **web
    services** or other places where **deserialization** occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Equality and records
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t always need to override equality members to get value-based equality.
    In [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*: Defensive Coding Techniques*,
    we’ll explore strategic uses of the `record` keyword for controlling equality.
    In fact, whenever I find myself thinking about overriding equality members, I
    usually decide to make my class a record instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a base class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you’ll encounter cases with a high degree of duplication between classes.
    These classes are conceptually related and share not just similar member signatures,
    but identical implementations of those members.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, it often makes sense to introduce a base class that defines
    the common shared code. **Inheritance** then allows us to remove the common code
    from multiple classes in the system and maintain it in a centralized place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our flight scheduler example (see *Figure 5**.14*), the passenger and freight
    flight classes have several shared properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Shared members between freight and passenger flights](img/B21324_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Shared members between freight and passenger flights
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, go to either of the two classes and choose **Extract base
    class...** from the **Quick** **Actions** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Extracting a base class](img/B21324_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Extracting a base class
  prefs: []
  type: TYPE_NORMAL
- en: Next, name the new class and select which members you want to move into it,
    as shown in *Figure 5**.16*. You can also decide whether you want any of those
    members to be declared as abstract, but note that this will mark your class as
    abstract as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Configuring the new base class](img/B21324_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Configuring the new base class
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click **OK**, the new class will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The class you started with now inherits from this new class and the non-abstract
    members you selected have been removed from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: PassengerFlightInfo.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extracting a base class can be very helpful for promoting code reuse, but it’s
    only half of the refactoring work; extracting a base class did not modify your
    other class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the related flight class to also inherit from the new class, you’ll
    have to make that change manually by specifying the base class and removing any
    members that were “pulled up” to that class:'
  prefs: []
  type: TYPE_NORMAL
- en: FreightFlightInfo.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The result of this is that our two flight classes are now focused on the things
    that are distinct to them. Additionally, if new logic needs to be added for every
    flight, it can now be added to the base class and all inheriting classes will
    receive it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving interface implementations up the inheritance tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One oddity you might have noticed in the last two code listings is that even
    though `FreightFlightInfo` and `PassengerFlightInfo` both now inherit from `FlightInfoBase`,
    they both separately implement the `IFlightInfo` interface, as shown in *Figure
    5**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo](img/B21324_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Passenger and Freight flights separately implementing IFlightInfo
  prefs: []
  type: TYPE_NORMAL
- en: When every class inheriting from a base class implements an interface, there’s
    usually a good chance that you can pull the interface implementation up into the
    base class itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, `FlightInfoBase` has all required members defined by the `IFlightInfo`
    interface. So, it makes sense to implement the interface, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the change in place, we can remove the `IFlightInfo` implementation from
    both `PassengerFlightInfo` and `FreightFlightInfo`. This simplifies the class
    definitions while still inheriting the interface implementation, as pictured here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase](img/B21324_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The IFlightInfo interface implementation “pulled up” into FlightInfoBase
  prefs: []
  type: TYPE_NORMAL
- en: By pulling the interface up into the base class, we now *guarantee* that any
    class inheriting from this class will also implement the `IFlightInfo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling inheritance with abstract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve covered some refactoring patterns around inheritance, let’s look
    at using **abstract classes** and other C# features to restrict our classes and
    ensure they’re used appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating intent with abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One quirk about our current design is that it is possible to instantiate a
    new instance of `FlightInfoBase` simply by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While it might not make sense to you – for a new flight to exist that isn’t
    explicitly a passenger or freight flight, because the `FlightInfoBase` class is
    not marked as abstract – there’s nothing preventing anyone from instantiating
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark a class as abstract, add the `abstract` keyword to its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Marking classes as abstract when you do not intend for anyone to instantiate
    them accomplishes a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: It communicates that the class is not intended to be instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The compiler now prevents others from instantiating your class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we’ll see next, it allows you to add abstract members to your class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing abstract members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that `FlightInfoBase` is abstract, it opens new possibilities for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: For example, both `FreightFlightInfo` and `PassengerFlightInfo` have `BuildFlightIdentifier`
    methods and `ToString` overrides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Repeated members in flight info classes](img/B21324_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Repeated members in flight info classes
  prefs: []
  type: TYPE_NORMAL
- en: While the implementation details of the `BuildFlightIdentifier` method differ,
    `ToString` overrides the return of the result of `BuildFlightIdentifier`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of these commonalities by pulling both methods into the
    base class using **Pull [Member name] up...**, as shown in *Figure 5**.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Pulling members up to the base type](img/B21324_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Pulling members up to the base type
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the members you want to pull up into the parent class, making sure
    to check the **Mark abstract** checkbox for any member you want the *definition*
    of to be pulled up without also having its *implementation* pulled up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Selecting destination and making members abstract](img/B21324_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Selecting destination and making members abstract
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this is that `FlightInfoBase` now has the `ToString` override
    as well as an abstract definition for the `BuildFlightIdentifier`:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With `BuildFlightIdentifier` abstract, our original method call remains in
    place, but it is now marked as an override:'
  prefs: []
  type: TYPE_NORMAL
- en: PassengerFlightInfo.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the **Pull Members Up** refactoring does not modify other classes
    that also inherit from the same base class, so you now must add the override manually
    in the other flight class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Making this refactoring has simplified our code: the individual flight classes
    no longer need to override `ToString`. More importantly, if we ever add a new
    type of flight, the compiler will force it to provide a valid flight identifier
    through a `BuildFlightIdentifier` override.'
  prefs: []
  type: TYPE_NORMAL
- en: Sealed methods and classes
  prefs: []
  type: TYPE_NORMAL
- en: While we’re talking about abstract, virtual, and overriding methods, we should
    touch on `sealed`. The `sealed` keyword has almost the opposite effect. When a
    class is marked with `sealed`, it cannot be inherited from. When a *method* is
    marked with `sealed`, that method may not be overridden further in inheriting
    classes. Both uses of the `sealed` keyword exist to protect what a class does
    from external modification. Additionally, there can be some performance benefits
    to marking members as sealed.
  prefs: []
  type: TYPE_NORMAL
- en: Converting abstract methods to virtual methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, you’ll mark a method as abstract and later realize that many overrides
    of this method have similar implementations. When this occurs, it can make sense
    to move the method from `abstract` to `virtual` in order to provide a base implementation
    that others can *optionally* override.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `FlightInfoBase` class defines `BuildFlightIdentifier` as abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This would imply that each implementation of this method *should* be different
    from the others. However, let’s take a look at the actual implementations of this:'
  prefs: []
  type: TYPE_NORMAL
- en: PassengerFlightInfo.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: FreightFlightInfo.cs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the strings for both methods are built, they both start with the flight
    identifier, the departure airport, and the arrival airport.
  prefs: []
  type: TYPE_NORMAL
- en: If we ever wanted to change the way all flights display this basic information,
    we’d need to change every class inheriting from `FlightInfoBase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can modify `FlightInfoBase` to provide a good starting point with
    this shared information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, two things have happened:'
  prefs: []
  type: TYPE_NORMAL
- en: New flight classes no longer *need* to override `BuildFlightIdentifier`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing overrides can call `base.BuildFlightIdentifier()` to get the common
    format of the basic flight information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, it makes sense to continue to override the method, but we can
    now change the code to take advantage of common formatting at the base level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PassengerFlightInfo.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`FreightFlightInfo.cs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Combining our abstract class with a virtual method lets us keep flight formatting
    logic in one centralized place while still giving us the freedom to extend the
    class and modify its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring for better encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another core tenet of object-oriented programming is **encapsulation**. With
    encapsulation, you assert control of the data in your classes and ensure others
    work with data in ways that make sense both immediately and as the code grows
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: The following refactorings deal with the various pieces of data composing classes
    along with the data passed along to methods as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest encapsulation refactoring allows you to wrap all uses of a field
    into a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, the `PassengerFlightInfo` class has a `_passengers`
    field storing the count of passengers on the flight, and this field is used throughout
    the class when referring to the passenger count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code isn’t bad, and I’d be fine with this logic in a production application.
    However, it does have a few potential drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing outside of the class can read the count of passengers on the flight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several places modify the `_passengers` field. If we wanted to add validation
    or do something every time the value changes, we’d have to modify several different
    methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping all uses of the `_passengers` field into a property can help with this
    by giving us a centralized place to perform validation and a property for things
    outside of the class to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **Encapsulate field** refactoring in the **Quick Action** menu
    to quickly wrap an existing field into a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Encapsulating the passengers field into a property](img/B21324_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Encapsulating the passengers field into a property
  prefs: []
  type: TYPE_NORMAL
- en: 'This adds a property that your class can use to read and modify the value in
    a centralized location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that this refactoring does make the setter public by default, which
    would allow code outside of the class to modify the `passengers` value. If you
    don’t want this, you can mark the property as having a `private` or `protected`
    set instead.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping parameters into a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As software systems grow, more features get added along with the code needed
    to support them. This can cause methods that were once simple to grow significantly
    in complexity and the information they require to operate.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not unusual for a method that took three parameters in the early days of
    a project to suddenly find itself needing seven or eight parameters to function
    after a significant amount of development occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '`FlightScheduler`’s search method is an example of this since there are so
    many things that can factor into a flight search:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightScheduler.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This method currently takes in eight different pieces of information, which
    makes calls to the method extremely hard to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While I made that example a little hard to read on purpose, in my experience,
    complex method signatures exist in the real world. These complex methods can lead
    to subtle bugs due to confusion over which value you’re passing to which parameter
    as you read a long list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this code, it’s easy to imagine new things that someone might want
    to search for with regard to flights, including low and high prices, in-flight
    beverage service, free Wi-Fi, and the type of aircraft being flown. Each one of
    these new search features would further expand both the method definition and
    every caller to the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common solution to this problem is to encapsulate related pieces of information
    into a new class. In our case, we can define a new `FlightSearch` class to wrap
    everything related to searching for a flight:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightSearch.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This new class allows us to track information on searches in a centralized
    place and significantly improves the signature of the search method:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightScheduler.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `FlightSearch` class shrunk the method signature from eight parameters
    to just one. Additionally, if new search logic needs to be added in the future,
    these pieces of information can be added to the `FlightSearch` object without
    needing to further modify the `Search` method’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, changing the signature of the search method breaks callers to
    the method until they are updated to use the new search object. To fix this, you
    have a few options:'
  prefs: []
  type: TYPE_NORMAL
- en: Update all usages of the `Search` method to pass a `FlightSearch` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a temporary overload of the Search method that passes a `FlightSearch`
    object to the new method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is somewhat self-explanatory, so let’s take a look at the second
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ll create an overload of the `Search` method that takes in the eight
    old parameters, creates a `FlightSearch` object, and passes it to the new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we marked this method as obsolete. This will warn programmers trying
    to use it and tell them what method to use instead (see *Figure 5**.23*). Marking
    things with the `Obsolete` attribute helps guide developers towards the more recent
    version. Typically, a method will be marked as obsolete and then removed from
    the project later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – An obsolete warning telling the developer which method to use
    instead](img/B21324_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – An obsolete warning telling the developer which method to use
    instead
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that we were able to simplify our method and provide a
    safe place for the data that the method needs to grow over time by introducing
    a class.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing classes for common sets of parameters significantly speeds up development
    time for teams, particularly when these same objects are passed around throughout
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping properties into a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you’ll find classes with sets of properties that are related to each
    other. For example, the `FlightInfoBase` class needs to track both the airport
    a plane departs from or arrives at and the time and date of that event:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, information about the arrival and departure need both their
    `Airport` and the associated `DateTime` to make sense. If we needed to track the
    terminal, gate, or runway in the future, we’d need to add in properties for both
    arrival and departure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these sets of properties grow together, it makes sense to wrap them
    together in their own `AirportEvent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we need to expand the information we track on each leg of a flight,
    we can add it to this class and it will be available to both arrivals and departures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, for this to fully work we’ll need to modify `FlightInfoBase` to
    use the new class instead of tracking its properties separately:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightInfoBase.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this change on its own won’t be enough until we update the `IFlightInfo`
    interface to match our new signature:'
  prefs: []
  type: TYPE_NORMAL
- en: IFlightInfo.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, the compiler is now satisfied with our flight classes, but
    there are now compiler errors in `FlightScheduler`’s `ScheduleFlight` method:'
  prefs: []
  type: TYPE_NORMAL
- en: FlightScheduler.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is still trying to set the old properties, so it will need to be
    updated to use `AirportEvent` objects instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`FlightScheduler` also has a few more compiler errors in the search method
    due to uses of the old properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'These pieces of code will need to reference the new properties instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that for this simple change of wrapping properties together
    into a new object we had to make a number of changes just to get the code to compile
    again.
  prefs: []
  type: TYPE_NORMAL
- en: This can be normal when making structural changes like this, but the compiler
    supports you on your refactoring journey here by ensuring your code makes structural
    sense as you make your changes. In fact, I wouldn’t be brave enough to make some
    of these changes without being able to lean a little on the compiler to help me
    find places where I missed using the old way of doing things. I would encourage
    you to view the compiler as an ally on your refactoring journey.
  prefs: []
  type: TYPE_NORMAL
- en: Favoring composition over inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s close our discussion on encapsulation by exploring the directive to *favor
    composition over inheritance*. This was a phrase I heard a lot in the early days
    of my career, though it took me a while to grasp its meaning and implications.
  prefs: []
  type: TYPE_NORMAL
- en: By favoring composition over inheritance, we make a conscious decision that
    classes should *have something* instead of *being something*. If a class has another
    object it can hand off a responsibility instead of relying on inheritance to make
    the class more special and able to handle a specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the flight scheduling system, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudy Skies Airlines has decided it wants to offer charter flights. These are
    small flights that carry both passengers and cargo paid for by various companies.
    In this case, a charter flight is neither a passenger flight nor a freight flight,
    but in fact a bit of both.
  prefs: []
  type: TYPE_NORMAL
- en: 'A direct implementation of this using inheritance would look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note here that a single class has both cargo and passengers.
  prefs: []
  type: TYPE_NORMAL
- en: On its own, this isn’t so bad, but what if we wanted our charter flight to hold
    multiple pieces of cargo? We’d now need to have a collection of cargo strings
    with their charter companies (which might be different from one another).
  prefs: []
  type: TYPE_NORMAL
- en: Any customizations to this cargo or how it would be displayed would require
    either additional customization of this class or a separate but related class
    also inheriting from `FlightInfoBase`. It’s not too hard to imagine this system
    spawning a swarm of related classes such as `BulkCargoFlightInfo`, `ExpressFlightInfo`,
    `MedicalFlightInfo`, `HazardousCargoFlightInfo`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: While this inheritance-based approach would work, using **composition** will
    result in more maintainable code and fewer classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composition lets us say that an individual flight is *composed of* cargo items.
    Cargo items can be defined using a simple `CargoItem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This simple approach stores the item type and its quantity and provides a string
    representation of the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then incorporate this into an alternative version of `CharterFlightInfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach allows a charter flight to be composed of different cargo items.
    Each item is then displayed in the `BuildFlightIdentifier` method using its `ToString`
    method. See the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – CharterFlightInfo is composed of CargoItems](img/B21324_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – CharterFlightInfo is composed of CargoItems
  prefs: []
  type: TYPE_NORMAL
- en: Composing our charter flight with `CargoItems` gives us additional flexibility.
    Not only does this arrangement pattern allow a charter flight to have multiple
    cargo items, but it also allows it to do so without you having to declare different
    classes for different cargo loads.
  prefs: []
  type: TYPE_NORMAL
- en: Improving classes with interfaces and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re nearly at the close of this chapter on object-oriented refactoring. However,
    before we close the chapter, let’s discuss a few places where introducing interfaces
    and polymorphism can help further improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment, our `CharterFlightInfo` class stores a list of `CargoItem`s
    representing its cargo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Each cargo item the charter flight includes must be a `CargoItem` or something
    that inherits from it. For example, if we were to create the `HazardousCargoItem`
    we discussed in the last section and try to store it in the cargo collection,
    it *must* inherit from `CargoItem` to compile.
  prefs: []
  type: TYPE_NORMAL
- en: In many systems, you don’t want to force people to inherit from your classes
    if they want to customize the system’s behavior. In these places, it can be helpful
    to introduce an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that with our `CargoItem` class by selecting the class and then choosing
    **Extract interface…** from the **Quick** **Actions** menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Extracting an interface](img/B21324_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Extracting an interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve done this, as shown in *Figure 5**.25*, you now need to specify
    which members of the class should be included in the interface as well as what
    the interface should be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Customizing the extracted interface](img/B21324_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – Customizing the extracted interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Name your interface `ICargoItem`, select both `ItemType` and `Quantity`, and
    then click `ICargoItem` interface in a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also modify `CargoItem` to implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that by default, extracting an interface will introduce both getters and
    setters on properties. If you do not need your interface to expose a way of modifying
    a property, you can remove the `set` from the property definition in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Removing the set *does not prevent you* from having a setter on your property
    in `CargoItem`; it just means you’re not *required* to have a setter on the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new interface in hand, let’s go in and modify `CharterFlightInfo`
    to store `ICargoItem`s instead of `CargoItem`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This change allows us to store anything that implements the interface and improves
    the flexibility of what `CharterFlightInfo` can store. However, this does introduce
    another interface to your code, which slightly increases the complexity and can
    slow down development time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when introducing interfaces. Interfaces that exist for the sake of
    added abstraction will ultimately do more harm than good in your application.
    However, interfaces that are implemented by more than one class or designed to
    give another set of developers greater freedom or flexibility can ultimately do
    a lot of good in a software system.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk more about the appropriate place for interfaces in [*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)
    when we explore SOLID. For now, let’s move on to a newer feature in C# interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Providing default interface implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we’re exploring interfaces, let’s see how **default interface implementations**
    can simplify the experience of implementing an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Default interface implementations allow you to provide a default implementation
    inside the interface. When a class chooses to implement this interface, it is
    not *forced to* provide implementations of methods with default implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what this means by adding a `ManifestText` property with a default
    getter and a `LogManifest` method with a default implementation to `ICargoItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: By adding these new members to the interface, we’d normally break anything that
    implemented the interface, such as the `CargoItem` class, unless it had those
    members. However, because we provided a *default implementation* of both properties,
    `CargoItem` no longer *must* provide implementations. Instead, it effectively
    inherits these default implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still provide a version of these new members. If we did, that version
    would be used instead of the default implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: CargoItem.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: I don’t like default interface implementations very much because they confuse
    the concept of an interface with a contract to provide certain members.
  prefs: []
  type: TYPE_NORMAL
- en: However, I must concede that when adding a simple member to an interface, it
    sometimes makes sense to add a default implementation so that you don’t need to
    change existing implementations of the interface. This can save you from having
    to add the same code to many different implementations of your interface throughout
    your solution. Additionally, default interface implementations reduce the work
    needed for classes trying to implement the interface by providing a default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you are working with an interface, you are intentionally supporting
    **polymorphism** in your application. This is the ability to treat different objects
    based on their similarities instead of on their differences.
  prefs: []
  type: TYPE_NORMAL
- en: The `ICargoItem` approach introduced earlier with charter flights is an example
    of polymorphism. A charter flight doesn’t care about what type of cargo it has
    as long as the cargo implements the interface. This means that we can load a charter
    flight full of different types of cargo and the class works fine with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter’s code has another place that could strongly benefit from polymorphism:
    the `FlightScheduler` `Search` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This method has some very repetitive code (much of it omitted) that checks to
    see if the search object specifies a property. If the property was specified,
    the potential results are filtered down to only include those that match the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search method uses this approach to filter based on:'
  prefs: []
  type: TYPE_NORMAL
- en: Departure and arrival locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum/maximum departure time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum/maximum arrival time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum/maximum flight length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not too hard to imagine new things we might filter for, such as the price
    of the flight, whether the flight has a beverage service or even the type of aircraft.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative approach would be to take in a collection of filter objects.
    These filter objects would determine whether each flight should be included in
    the results through a common `FlightFilterBase` class and a `ShouldInclude` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, `Search` could be modified to loop over all filters and only
    include results that pass through all the provided filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This cuts our `Search` method down from over 40 lines long to only 3 lines of
    code through polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative implementation
  prefs: []
  type: TYPE_NORMAL
- en: An interface would also work fine instead of an abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this design, we can create a series of classes that inherit from
    `FlightFilterBase` to provide specific filtering capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Distinct filter classes to help simplify our search code](img/B21324_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – Distinct filter classes to help simplify our search code
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have dedicated filters that filter out flights that don’t match their
    specific criterion. For example, the `AirportFilter` would filter out flights
    that don’t specify an airport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Each individual filter class is small and easy to understand, maintain, and
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if we want to add a new way of filtering flights in the future,
    all we need to do is add a new class inheriting from `FlightFilterBase`. No modifications
    would be needed for the `Search` method to support this because all the method
    needs is a collection of individual filters. The `Search` method doesn’t need
    to know which filters are involved – it just needs to call the `ShouldInclude`
    method and interpret the result.
  prefs: []
  type: TYPE_NORMAL
- en: I find a lot of beauty in polymorphic solutions and have found my programming
    style changing over the years in search of more opportunities to take advantage
    of polymorphism through inheritance or interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing and testing our refactored code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With these changes made, let’s take a step back and look at the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We took a flight search system and used object-oriented programming techniques
    to improve its flexibility and maintainability by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reorganizing the code into appropriate files and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a base class and improving code reuse in flight information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a large number of parameters by moving them into a new class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing another new class to manage common information about airport events
    including both an airport and a time component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a charter flight class with a flexible cargo tracking system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a polymorphic way of searching flights that will be more flexible
    and maintainable over time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored code
  prefs: []
  type: TYPE_NORMAL
- en: The final refactored code from this chapter is available in the [https://github.com/PacktPublishing/Refactoring-with-CSharp](https://github.com/PacktPublishing/Refactoring-with-CSharp)
    repository inside of the `Chapter05/Ch5RefactoredCode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: As always, refactoring should never be done without testing the code to make
    sure that no new defects were introduced in the refactoring process. Running the
    tests (see *Figure 5**.28*) provided in the solution shows a full slate of passing
    tests, which will suffice for now until we get to *Part 2* and explore testing
    in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Test Explorer showing that all tests pass](img/B21324_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – Test Explorer showing that all tests pass
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the various ways that object-oriented programming
    techniques such as inheritance, encapsulation, and polymorphism can be used to
    refactor code toward more maintainable forms.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring can be a complex endeavor, and yet so many of the fundamental concepts
    of object-oriented programming can come together to build elegant, flexible, and
    maintainable solutions.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes *Part 1* of the book. In the next part of the book, we’ll look
    at how testing can give you the safety and freedom needed to safely refactor your
    code and move forward with confidence that your changes have improved the application
    without breaking anything.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Does your code follow a well-structured and consistent namespace hierarchy with
    not too many or too few classes in each namespace?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is there any part of your code that might be improved by using inheritance to
    promote code reuse?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you think of any repetitive rules or other structures in your code that
    might benefit from polymorphism?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information about materials discussed in this chapter at
    these URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance in* *C#:* [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/inheritance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Sealed* *Modifier*: [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*IEquatable<T>:* [https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1](https://learn.microsoft.com/en-us/dotnet/api/system.iequatable-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Refactoring Safely'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the second part of the book, we’ll cover coding techniques such as unit tests
    that help ensure your refactoring efforts don’t result in unintentional changes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on various testing frameworks and standard testing practices
    before moving on to discussions about programming best practices and writing SOLID
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The final two chapters in this part focus on more advanced testing strategies
    and ways the C# language can help you detect and prevent errors from reaching
    your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21324_06.xhtml#_idTextAnchor133)*, Unit Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21324_07.xhtml#_idTextAnchor161)*, Test-Driven Development*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21324_08.xhtml#_idTextAnchor173)*, Avoiding Code Anti-Patterns
    with SOLID*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21324_09.xhtml#_idTextAnchor189)*, Advanced Unit Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21324_10.xhtml#_idTextAnchor209)*, Defensive Coding Techniques*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
