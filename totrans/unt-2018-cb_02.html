<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Responding to User Events for Interactive UIs</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following:</p>
<ul>
<li>Creating UI Buttons to move between scenes</li>
<li>Animating button properties on mouse-over</li>
<li>Organizing image panels and changing panel depths via buttons</li>
<li>Displaying the value of an interactive UI Slider</li>
<li>Displaying a countdown timer graphically with a UI Slider</li>
<li>Setting custom mouse cursors for 2D and 3D GameObjects</li>
<li>Setting custom mouse cursors for UI controls</li>
<li>Interactive text entry with an Input Field</li>
<li>Toggles and radio buttons via Toggle Groups</li>
<li>Creating text and image icon UI Dropdown menus</li>
<li>Displaying a radar to indicate the relative locations of objects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Almost all the recipes in this chapter involve different i<span class="KeyWordPACKT">nteractive</span> UI controls. Although there are different kinds of interactive UI controls, the basic way to work with them, and have scripted actions respond to user actions, is all based on the same idea: events triggering the execution of object method functions.</p>
<p>Then, for fun, and an example of a very different kind of UI, the final recipe demonstrates how to add to your game a sophisticated real-time communication of the relative positions of objects in the scene (that is, a radar!).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The big picture</h1>
                </header>
            
            <article>
                
<p>The UI can be used for three main purposes:</p>
<ol>
<li>To display <strong><span class="KeyWordPACKT">static (unchanging) values</span></strong>, such as the name or logo image of the game, or word labels such as <span class="ScreenTextPACKT">Level</span> and <span class="ScreenTextPACKT">Score</span>, that tell us what the numbers next to them indicate (recipes for these can be found in the <a href="920700d7-96cd-4015-b17c-ee2451bc648e.xhtml" target="_blank">Chapter 1</a>, <em>Displaying Data with Core UI Elements</em>).</li>
<li>To display <strong><span class="KeyWordPACKT">values that change due to our scripts</span></strong>, such as timers, scores, or the distance from our Player character to some other object (an example of this is the radar recipe at the end of this chapter).</li>
<li><strong><span class="KeyWordPACKT">Interactive</span></strong> UI controls, whose purpose is to allow the Player to communicate with the game scripts via their mouse or touchscreen. These are the ones we'll look at in detail in this chapter.</li>
</ol>
<p>The core concept for working with Unity Interactive UI controls is the <em>registration of an object's public method to be informed when a particular event occurs</em>. For example, we can add a UI Dropdown to a scene named DropDown 1, and then write a <kbd><span class="CodeInTextPACKT">MyScript</span></kbd> script class containing a <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> public method to do some action. But nothing will happen until we do two things:</p>
<ol>
<li>We need to add an <em>instance of the script class as a component</em> on a GameObject in the scene (which we'll name <kbd><span class="KeyWordPACKT">go1</span></kbd> for our example <span>–</span> although we can also add the script instance to the UI GameObject itself if we choose to).</li>
<li>In the <span class="KeyWordPACKT">UI Dropdown</span>'s properties, we need to <em>register the GameObject's public method</em> of its script component to respond to the <kbd>On Value Changed</kbd> event messages:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/2e7f83bb-dd87-4eca-bb4a-f20e054e3632.jpg" style="width:39.33em;height:17.75em;"/></div>
<p>The <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> public method of the <kbd><span class="CodeInTextPACKT">MyScript</span></kbd> script will typically retrieve the value selected by the user in the Dropdown and do something with it <span>–</span> for example, confirm it to the user, change the music volume, or change the game difficulty. The <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> method will be invoked (executed) each time GameObject <span class="KeyWordPACKT">go1</span> receives the <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> message. In the DropDown 1's properties, we need to register GameObject <span class="KeyWordPACKT">go1's</span> scripted component <span class="CodeInTextPACKT">MyScript</span>'s <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> public method as an event listener for <span class="KeyWordPACKT">On Valu</span>e Changed events. We need to do all this at <strong><span class="KeyWordPACKT">Design-Time</span></strong> (that is, in the Unity editor before running the scene):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/3e2ebc59-b702-4b80-aec7-143f8f20b371.jpg"/></div>
<p>At <strong><span class="ScreenTextPACKT">runtime</span></strong> (when the scene in the built application is running), if the user changes the value in the drop-down menu of <span class="KeyWordPACKT">UI Dropdown</span> GameObject <span class="KeyWordPACKT">DropDown 1</span> (step 1 in the diagram), this will generate an <span class="KeyWordPACKT">On Value Changed</span> event. <span class="KeyWordPACKT">DropDown 1</span> will update its display on screen, to show the user the newly-selected value (step 2a). It will also send messages to all the GameObject components registered as listeners to <strong>On Value Changed</strong> events (step 2b). In our example, this will lead to the <kbd><span class="CodeInTextPACKT">NewValueAction()</span></kbd> method in GameObject <span class="KeyWordPACKT">go1's</span> scripted component being executed (step 3).</p>
<p>Registering public object methods is a very common way to handle events such as user interaction or web communications, which may occur in different orders, may never occur, or may happen several times in a short period. Several software <span class="KeyWordPACKT">Design Patterns</span> describe ways to work with these event setups, such as the <em>Observer Pattern</em> and the <em>Publisher-Subscriber</em> pattern (we'll learn more about this pattern in <span class="ItalicsPACKT"><a href="04f5a183-ae0b-4d73-8e78-c90fd75c9a64.xhtml" target="_blank">Chapter 16</a>, <em>Design Patter</em></span><span class="ItalicsPACKT"><em>ns</em></span>).</p>
<p>Core GameObjects, components, and concepts relating to interactive Unity UI development include:</p>
<ul>
<li> <strong><span class="ScreenTextPACKT">Visual UI</span> controls</strong>: The visible UI controls themselves include <span class="ScreenTextPACKT">Button</span>, <span class="ScreenTextPACKT">Image</span>, <span class="ScreenTextPACKT">Text</span>, and <span class="ScreenTextPACKT">Toggle</span>. These are the UI controls the user sees on the screen, and uses their mouse/touchscreen to interact with. These are the GameObjects that maintain a list of object-methods that have subscribed to user-interaction events.</li>
<li><strong><span class="ScreenTextPACKT">Interaction UI</span> controls</strong>: These are non-visible components that are added to GameObjects; examples include Input Field and Toggle Group.</li>
<li><strong><span class="ScreenTextPACKT">Panel</span></strong>: UI objects can be grouped together (logically and physically) with UI <span class="ScreenTextPACKT">Panels</span>. <span class="ScreenTextPACKT">Panels</span> can play several roles, including providing a GameObject parent in the <span class="ScreenTextPACKT">Hierarchy</span> for a related group of controls. They can provide a visual background image to graphically relate controls on the screen, and they can also have scripted resize and drag interactions added, if desired.</li>
<li><strong><span class="ScreenTextPACKT">Sibling Depth</span></strong>: The bottom-to-top display order (what appears on the top of what) for a UI element is determined initially by their sequence in the <span class="ScreenTextPACKT">Hierarchy</span>. At <strong><span class="KeyWordPACKT">Design-Time</span></strong>, this can be manually set by dragging GameObjects into the desired sequence in the <span class="ScreenTextPACKT">Hierarchy</span>. At <strong><span class="KeyWordPACKT">Run-Time</span></strong>, we can send messages to the <span class="ScreenTextPACKT">Rect Transforms</span> of GameObjects to dynamically change their <span class="ScreenTextPACKT">Hierarchy</span> position (and therefore, the display order), as the game or user interaction demands. This is illustrated in the <span class="ItalicsPACKT"><em>Organizing images inside panels and changing panel depths via buttons</em></span> recipe.</li>
</ul>
<p>Often, a UI element exists with most of the components that you may need for something in your game, but you may need to adapt it somehow. An example of this can be seen in the recipe that makes a UI Slider non-interactive, instead using it to display a red-green progress bar for the status of a countdown timer. See this in the <em>Displaying a countdown timer graphically with a UI Slider</em> recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating UI Buttons to move between scenes</h1>
                </header>
            
            <article>
                
<p>As well as scenes where the player plays the game, most games will have menu screens, which display to the user messages about instructions, high scores, the level they have reached so far, and so on. Unity provides <span class="KeyWordPACKT">UI Buttons</span> to offer users a simple way to indicate their choices.</p>
<p>In this recipe, we'll create a very simple game consisting of two screens, each with a button to load the other one, as illustrated in the screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/873bd5cc-73d8-4132-94e1-db89a8f3c865.png" style="width:19.17em;height:3.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a button-navigable multi-scene game, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>Save the current (empty) scene, in a new folder, <kbd><span class="CodeInTextPACKT">_Scenes</span></kbd><span>, naming the scene <span class="ScreenTextPACKT"><span class="packt_screen">page1. </span></span></span></li>
<li>Add a <strong><span class="KeyWordPACKT">UI Text</span></strong> <span>object positioned at the top center of the scene, containing large white text that says </span><span class="ScreenTextPACKT"><span class="packt_screen">Main Menu (page 1)</span></span>.</li>
<li>Add a <strong><span class="KeyWordPACKT">UI Button</span></strong> to the scene positioned in the middle-center of the screen. In the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>, click on the show children triangle to display the <strong><span class="KeyWordPACKT">Text</span></strong> child of this GameObject button. Select the <strong><span class="KeyWordPACKT">Text</span></strong> GameObject, and in the <strong><span class="KeyWordPACKT">Inspector</span></strong> for the <span class="KeyWordPACKT"><span class="packt_screen">Text</span></span> property of the <span class="packt_screen"><span class="KeyWordPACKT">Text (Script)</span></span> component, enter the text <span class="ScreenTextPACKT"><span class="packt_screen">goto page 2</span></span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c2d5b99-fa37-4e6a-935d-bfe90904ea40.png" style="width:36.92em;height:11.67em;"/></div>
<ol start="5">
<li>Create a second scene, named <span class="packt_screen">page2</span>, with <span class="KeyWordPACKT">UI Text</span> <span class="CodeInTextPACKT">= <span class="packt_screen">Instructions (page 2)</span></span>, and a <strong><span class="KeyWordPACKT">UI Button</span></strong> with the <span class="CodeInTextPACKT">goto page 1 text</span>. You can either repeat the preceding steps, or you can duplicate the <span class="ScreenTextPACKT"><span class="packt_screen">page1</span></span> scene file, naming the duplicate <span class="ScreenTextPACKT"><span class="packt_screen">page2</span></span>, and edit the <span class="KeyWordPACKT">UI Text</span> and <span class="KeyWordPACKT">UI Button Text</span> appropriately</li>
<li>Add both scenes to the <span class="KeyWordPACKT">Build</span>, which is the set of scenes that will end up in the actual application built by Unity. To add the <span class="ScreenTextPACKT">scene1</span> to the <span class="KeyWordPACKT">Build</span>, open scene <span class="KeyWordPACKT">page1,</span> then choose menu: <span class="KeyWordPACKT"><span class="packt_screen">File</span> | <span class="packt_screen">Build Settings</span></span><span class="packt_screen">...</span> then click on the <span class="KeyWordPACKT"><span class="packt_screen">Add Current</span></span> button so that the <span class="KeyWordPACKT"><span class="packt_screen">page1</span></span> scene becomes the first scene on the list of <span class="KeyWordPACKT">Scenes in the Build</span>. Now open scene <span class="KeyWordPACKT"><span class="packt_screen">page2</span></span> and repeat the process, so both scenes have been added to the <span class="KeyWordPACKT">Build</span>.</li>
</ol>
<div class="packt_infobox">We cannot tell Unity to load a scene that has not been added to the list of scenes in the build. This makes sense since when an application is built we should never try to open a scene that isn't included as part of that application.</div>
<ol start="7">
<li>Ensure you have scene <span class="KeyWordPACKT"><span class="packt_screen">page1</span></span> open.</li>
<li>Create a C# script class, <span class="CodeInTextPACKT"><kbd>SceneLoader</kbd>,</span> in a new folder, <kbd><span class="CodeInTextPACKT">_Scripts</span></kbd><span>, containing the following code, and add an instance as a scripted component to the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.SceneManagement; 

public class SceneLoader : MonoBehaviour { 
    public void LoadOnClick(int sceneIndex) { 
        SceneManager.LoadScene(sceneIndex); 
    } 
} </pre>
<ol start="9">
<li><span>Select the <span class="ScreenTextPACKT"><span class="packt_screen">Button</span></span> in the <span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span> and click on the plus sign (<span class="ScreenTextPACKT"><span class="packt_screen">+)</span></span> button at the bottom of the <strong><span class="ScreenTextPACKT"><span class="packt_screen">Button (Script)</span></span></strong> component, in the <span class="ScreenTextPACKT"><span class="packt_screen"><strong>Inspector</strong></span> view</span>, to create a new <kbd><span class="ScreenTextPACKT">OnClick</span></kbd> event handler for this button (that is, an action to perform when the button is clicked).</span></li>
<li><span>Drag the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span> from the <span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span> over the <span class="ScreenTextPACKT">Object</span> slot immediately below the menu saying <span class="ScreenTextPACKT"><span class="packt_screen">Runtime Only</span></span>. This means that when the <span class="ScreenTextPACKT">Button</span> receives an <kbd><span class="ScreenTextPACKT">OnClick</span></kbd> event, we can call a public method from a scripted object inside the <span class="ScreenTextPACKT"><span class="packt_screen">Main Camera</span></span>.</span></li>
</ol>
<ol start="11">
<li>Select the <kbd><span class="CodeInTextPACKT">LoadOnClick</span></kbd> <span>method from the <span class="ScreenTextPACKT"><span class="packt_screen">SceneLoader</span></span> drop-down list (initially showing <span class="ScreenTextPACKT"><span class="packt_screen">No Function</span></span>). Type</span> <span class="CodeInTextPACKT"><span class="packt_screen">1</span></span> <span>(the index of the scene we want to be loaded when this button is clicked) in the text box, below the method's drop-down menu. This integer, <span class="ScreenTextPACKT"><span class="packt_screen">1</span></span>, will be passed to the method when the button receives an</span> <kbd><span class="CodeInTextPACKT">OnClick</span></kbd> event message, as shown here:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77109497-bde4-46a5-bcc2-d7ca372aa435.png"/></div>
<ol start="12">
<li>Save the current scene (<span class="KeyWordPACKT"><span class="packt_screen">page1</span></span>).</li>
<li>Open <span class="ScreenTextPACKT"><span class="packt_screen">page2</span></span> and follow the same steps to make the <span class="ScreenTextPACKT"><span class="packt_screen">page2</span></span> button load <span class="ScreenTextPACKT"><span class="packt_screen">page1</span></span>. That is, add an instance of the  <kbd><span class="CodeInTextPACKT">SceneLoader</span></kbd> script class to the m<span class="KeyWordPACKT">ain camera</span>, then add an <kbd><span class="KeyWordPACKT">OnClick</span></kbd> event action to the button, which calls <kbd><span class="CodeInTextPACKT">LoadOnClick</span></kbd>, and passes the integer <span class="packt_screen"><span class="ScreenTextPACKT">0</span>,</span> so scene <span class="packt_screen">page<span class="ScreenTextPACKT"><span class="packt_screen">1</span></span></span> is loaded.</li>
<li>Save scene <span class="ScreenTextPACKT"><span class="packt_screen">page2</span></span>.</li>
<li>When you run the <span class="ScreenTextPACKT">page1 scene,</span> you will be presented with your <span class="ScreenTextPACKT"><span class="packt_screen">Main Menu</span></span> text and a button, which when clicked, makes the game load the <span class="ScreenTextPACKT"><span class="packt_screen">page2</span> scene</span>. On scene <span class="ScreenTextPACKT">page2,</span> you'll have a button to take you back to <span class="ScreenTextPACKT"><span class="packt_screen">page1</span></span>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have created two scenes, and added both of these scenes to the game's build. You added a UI Button, and some UI Text to each scene.</p>
<div class="packt_infobox">Note, the <span class="KeyWordPACKT">Build</span> sequence of scenes is actually a scripted <span class="KeyWordPACKT">array</span>, which count from 0, then 1, and so on, so <span class="ScreenTextPACKT">page1</span> has index 0, and <span class="ScreenTextPACKT">page2</span> has index 1.</div>
<p>When a <span class="KeyWordPACKT">UI Button</span> is added to the <span class="KeyWordPACKT">Hierarchy</span> panel, a child <span class="KeyWordPACKT">UI Text</span> object is also automatically created, and the content of the <span class="KeyWordPACKT">Text</span> property of this <span class="KeyWordPACKT">UI Text</span> child is the text that the user sees on the button.</p>
<p>You created a script class, and added an instance as a component to the <span class="KeyWordPACKT"><span class="packt_screen">Main Camera</span></span>. In fact, it didn't really matter where this script instance was added, as long as it was in one of the GameObjects of the scene. This is necessary since the <kbd><span class="KeyWordPACKT">OnClick</span></kbd> event action of a button can only execute a method (function) of a component in a GameObject in the scene.</p>
<p>For the button of each scene, you then added a new <kbd><span class="KeyWordPACKT">OnClick</span></kbd> event action, which invokes (executes) the <kbd><span class="CodeInTextPACKT">LoadOnClick</span></kbd> method of the <span class="CodeInTextPACKT">SceneLoader</span> scripted component in the <span class="KeyWordPACKT">Main Camera</span>. This method inputs the integer index of the scene in the project's <span class="KeyWordPACKT">Build</span> <span>settings, so that the button on the <span class="ScreenTextPACKT"><span class="packt_screen">page1</span></span></span> scene gives integer 1 as the scene to be loaded, and the button for <span class="ScreenTextPACKT"><span class="packt_screen">page2</span></span> gives integer 0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Color tint when mouse pointer is over the button</h1>
                </header>
            
            <article>
                
<p>There are several ways in which we can visually inform the user that the button is interactive when they move their mouse cursor over it. The simplest is to add a <span class="KeyWordPACKT"><span class="packt_screen">Color Tin</span>t</span> <span>that will appear when the mouse is over the button – this is the default <strong><span class="ScreenTextPACKT">Transition</span></strong>. With the <span class="ScreenTextPACKT"><span class="packt_screen">Button</span></span> selected in the <span class="ScreenTextPACKT"><span class="packt_screen">Hierarchy</span></span>, choose a tint color (for example, red), for the <span class="ScreenTextPACKT"><span class="packt_screen">Highlighted Color</span></span> property of the <span class="ScreenTextPACKT">Button (Script)</span> component, in the <span class="ScreenTextPACKT"><span class="packt_screen">Inspector</span></span> tab:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/d23e51c5-6e25-4999-91db-d9d8079f5233.png" style="width:38.67em;height:15.75em;"/></div>
<p><span>Another form of visual <span class="ScreenTextPACKT">Transition</span> to inform the user of an active button is <span class="KeyWordPACKT">Sprite Swap</span>. In this case, properties for different images for <span class="ScreenTextPACKT">Targeted</span>/<span class="ScreenTextPACKT">Highlighted</span>/<span class="ScreenTextPACKT">Pressed</span>/<span class="ScreenTextPACKT">Disabled</span> are available in the <strong><span class="ScreenTextPACKT">Inspector</span></strong> panel. The default <span class="ScreenTextPACKT">Targeted Graphic</span> is the built-in Unity <strong><span class="ScreenTextPACKT">Button</span> <span class="ScreenTextPACKT">(Image)</span></strong> – this is the grey rounded rectangle default when GameObject buttons are created. Dragging in a very different-looking image for the <span class="ScreenTextPACKT"><strong>Highlighted</strong> Sprite</span> is an effective alternative to set a Color Tint. We have provided a</span> <kbd><span class="CodeInTextPACKT">rainbow.png</span></kbd> <span>image with the project for this recipe that can be used for the <span class="ScreenTextPACKT">Button</span> mouse over <span class="ScreenTextPACKT">Highlighted</span> <span class="ScreenTextPACKT">Sprite</span>. The screenshot shows the button with this rainbow background image:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1b4ac2db-ba46-4d00-ab55-88fc75d4f8e0.png" style="width:16.67em;height:2.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Animating button properties on mouse-over</h1>
                </header>
            
            <article>
                
<p>At the end of the previous recipe, we illustrated two ways to visually communicate buttons to users. The <span class="packt_screen">Animation</span> of button properties can be a highly effective, and visually interesting, way to reinforce to the user that the item their mouse is currently over is a clickable, active button. One common animation effect is for a button to get larger when the mouse is over it, and then it shrinks back to its original size when the mouse pointer is moved away. Animation effects are achieved by choosing the <span class="KeyWordPACKT"><span class="packt_screen">Animation</span></span> option for the <span class="KeyWordPACKT">Transition</span> property of a <kbd><span class="KeyWordPACKT">Button</span></kbd> GameObject, and by creating an animation controller with triggers for the <span class="ScreenTextPACKT">Normal</span>, <span class="ScreenTextPACKT">Highlighted</span>, <span class="ScreenTextPACKT">Pressed,</span> and <span class="ScreenTextPACKT">Disabled</span> states.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To animate a button for enlargement when the mouse is over it (the <span class="KeyWordPACKT"><span class="packt_screen">Highlighted</span></span> state), do the following:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>Create a <strong><span class="KeyWordPACKT">UI Button</span></strong>.</li>
<li>In the <strong><span class="KeyWordPACKT">Inspector Button (Script)</span></strong> component, set the <strong><span class="KeyWordPACKT">Transition</span></strong> property to <strong><span class="ScreenTextPACKT">Animation</span></strong>.</li>
<li>Click the <strong><span class="ScreenTextPACKT">Auto Generate Animation</span></strong> button (just below the <strong><span class="KeyWordPACKT">Disabled Trigger</span></strong> property) for the <strong><span class="KeyWordPACKT">Button (Script)</span></strong> component:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/84439d36-92e0-45ef-82a8-734c5ee91987.png"/></div>
<ol start="5">
<li>Save the new controller (in new folder <kbd><span class="CodeInTextPACKT">Animations</span></kbd>), naming it <strong><span class="ScreenTextPACKT">button-animation-controller</span></strong>.</li>
<li>Ensure that the <strong><span class="KeyWordPACKT">Button</span></strong> GameObject is selected in the <span class="KeyWordPACKT">Hierarchy</span>. In the <span class="KeyWordPACKT">Animation</span> panel, select the <strong><span class="ScreenTextPACKT">Highlighted</span></strong> clip from the drop-down menu:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/fde4a896-a33a-4d1e-a0f2-29e964ec9a34.png"/></div>
<ol start="7">
<li>In the <strong><span class="KeyWordPACKT">Animation</span></strong> panel, click on the red <span class="KeyWordPACKT">record</span> circle button, and then click on the <strong><span class="ScreenTextPACKT">Add Property</span></strong> button, choosing to record changes to the <span class="KeyWordPACKT"><span class="packt_screen">Rect Transform | Scale</span></span> property.</li>
</ol>
<ol start="8">
<li>Two keyframes will have been created. Delete the second one at <kbd><span class="ScreenTextPACKT">1:00</span></kbd> (since we don't want a "bouncing" button):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dd86535c-4ace-447d-9d88-835b54167f09.png"/></div>
<ol start="9">
<li>Select the frame at <kbd><span class="ScreenTextPACKT">1:00</span></kbd> by clicking one of the diamonds (both turn <span class="ScreenTextPACKT">blue</span> when selected), then press the <em><span class="CodeInTextPACKT">Backspace</span>/<span class="CodeInTextPACKT">Delete</span></em> key.</li>
<li>Select the first keyframe at <kbd><span class="ScreenTextPACKT">0:00</span></kbd> (the only one now!). In the Inspector, set <span>the <span class="ItalicsPACKT">X</span> and <span class="ItalicsPACKT">Y</span> scale properties of the</span> <strong><span class="KeyWordPACKT">Rect Transform</span></strong> component to (<kbd><span class="CodeInTextPACKT">1.2</span>, <span class="CodeInTextPACKT">1.2</span></kbd>).</li>
<li>Click on the red <span class="ScreenTextPACKT">record</span> circle button for the second time to end the recording of the animation changes.</li>
<li>Save and run your scene, and you will see that the button smoothly animates to get larger when the mouse is over it, and then smoothly returns to its original size when the mouse has moved away.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have created a button, and set its <span class="KeyWordPACKT"><span class="packt_screen">Transition</span></span> mode to <span class="ScreenTextPACKT"><span class="packt_screen">Animation</span></span>. This makes Unity require an <span class="KeyWordPACKT">Animation Controller</span> with four states: <span class="ScreenTextPACKT"><span class="packt_screen">Normal</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Highlighted</span></span>, <span class="ScreenTextPACKT"><span class="packt_screen">Pressed</span></span>, and <span class="ScreenTextPACKT"><span class="packt_screen">Disabled</span></span>. You then made Unity automatically create an <span class="KeyWordPACKT">Animation Controller</span> with these four states.</p>
<p>Then, you edited the <span class="KeyWordPACKT">Animation</span> for the <span class="ScreenTextPACKT">Highlighted</span> (mouse-over) state, deleting the second <span class="KeyWordPACKT">keyframe</span>, and making the only <span class="KeyWordPACKT">keyframe</span> a version of the <span class="KeyWordPACKT">Button</span> made larger to a scale of 1.2.</p>
<p>When the mouse is not over the <span class="KeyWordPACKT">Button</span>, it's unchanged and <span class="ScreenTextPACKT">Normal</span> state settings are used. When the mouse moves over the <span class="KeyWordPACKT">Button</span>, the <span class="KeyWordPACKT">Animation Controller</span> smoothly in-betweens the settings of the <span class="KeyWordPACKT">Button</span> to become those of its <span class="ScreenTextPACKT">Highlighted</span> state (that is, bigger). When the mouse is moved away from the <span class="KeyWordPACKT">Button</span>, the <span class="KeyWordPACKT">Animation Controller</span> smoothly in-betweens the settings of the <span class="KeyWordPACKT">Button</span> to become those of its <span class="ScreenTextPACKT">Normal</span> state (<span>that is,</span> its original size).</p>
<div class="packt_infobox">The following web pages offer video and web-based tutorials on UI animations:<br/>
<br/>
<span>The Unity button transitions tutorial is available at</span><span class="URLPACKT"><a href="http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions"> http://unity3d.com/learn/tutorials/modules/beginner/ui/ui-transitions.<br/>
<br/></a></span> <span>Ray Wenderlich's great tutorial (part 2), including the button animations, is available at</span><a href="http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2"><span class="URLPACKT"> http://www.raywenderlich.com/79031/unity-new-gui-tutorial-part-2</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing image panels and changing panel depths via buttons</h1>
                </header>
            
            <article>
                
<p><span class="KeyWordPACKT">UI Panels</span> are provided by Unity to allow UI controls to be grouped and moved together, and also to visually group elements with an <span class="KeyWordPACKT">Image</span> background (if desired). The <span class="KeyWordPACKT">sibling depth</span> is what determines which UI elements will appear above or below others. We can see the sibling depth explicitly in the <span class="KeyWordPACKT">Hierarchy</span>, since the top-to-bottom sequence of UI GameObjects in the <span class="KeyWordPACKT">Hierarchy</span> sets the sibling depth. So, the first item has a depth of 1, the second has a depth of 2, and so on. The UI GameObjects with larger sibling depths (further down the <span class="KeyWordPACKT">Hierarchy</span> and so drawn later) appear above the UI GameObjects with lower sibling depths.</p>
<p>In this recipe, we'll create three <span class="KeyWordPACKT">UI Panels</span><span>, each showing a different playing card image. We'll also add four triangle arrangement buttons to change the display order (move to bottom, move to</span> top, move up one, and move down one):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c677aba-f531-433a-9d1b-6b0df593bc21.png" style="width:16.58em;height:15.25em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the images that you need in a folder named <kbd><span class="CodeInTextPACKT">Images</span></kbd> in the <kbd><span class="CodeInTextPACKT">02_03</span></kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p><span>To create the UI <span class="ScreenTextPACKT">Panels</span> whose layering can be changed by clicking buttons, follow these steps:</span></p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>Create a new <strong><span class="KeyWordPACKT">UI Panel</span></strong> GameObject named <strong><span class="ScreenTextPACKT">Panel-jack-diamonds</span></strong>. Do the following to this <span class="KeyWordPACKT">Panel</span>:
<ul>
<li>For the <strong><span class="ScreenTextPACKT">Image (Script)</span></strong> <span>component, drag the</span> <kbd><strong><span class="ScreenTextPACKT">jack_of_diamonds</span></strong></kbd> <span>playing card image asset file from the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel into the</span> <strong><span class="ScreenTextPACKT">Source Image</span></strong> <span>property. Select the</span> <strong><span class="ScreenTextPACKT">Color</span></strong> <span>property and increase the</span> <strong><span class="ScreenTextPACKT">Alpha</span></strong> <span>value to</span> <kbd><span class="ScreenTextPACKT">255</span></kbd> <span>(so this background image of the panel is no longer partly transparent).</span></li>
<li>For the <strong><span class="KeyWordPACKT">Rect Transform</span></strong> <span>property, position it in the</span> <span class="ScreenTextPACKT">middle-center</span> <span>part of the screen, and size it with</span> <strong><span class="KeyWordPACKT">Width</span></strong> <span>=</span> <kbd><span class="ScreenTextPACKT">200</span></kbd> <span>and</span> <strong><span class="KeyWordPACKT">Height</span></strong> <span>=</span> <kbd><span class="ScreenTextPACKT">300</span></kbd><span>.</span></li>
</ul>
</li>
<li>Create a <strong><span class="KeyWordPACKT">UI Button</span></strong> <span>named <strong><span class="ScreenTextPACKT">Button-move-to-front</span></strong>. In the <strong>Hierarchy</strong>, c</span>hild this button to <strong><span class="ScreenTextPACKT">Panel-jack-diamonds</span></strong>. Delete the <strong><span class="ScreenTextPACKT">Text</span></strong> child GameObject of this button (since we'll use an icon to indicate what this button does).</li>
<li><span>With the <strong><span class="ScreenTextPACKT">Button-move-to-front</span></strong> GameObject selected in the</span> <strong><span class="KeyWordPACKT">Hierarchy</span></strong>, do the following in the <span class="KeyWordPACKT">Inspector</span>:
<ul>
<li>In the <span class="KeyWordPACKT"><strong>Rect Transform</strong>,</span> <span>position the button</span> <span class="ScreenTextPACKT">top-center</span> <span>of the player card image so that it can be seen at the top of the playing card. Size the image to</span> <strong><span class="KeyWordPACKT">Width</span></strong> <span>=</span> <kbd><span class="ScreenTextPACKT">16</span></kbd> <span>and</span> <strong><span class="KeyWordPACKT">Height</span></strong> <span>=</span> <kbd><span class="ScreenTextPACKT">16</span></kbd><span>. Move the icon image down slightly, by setting</span> <strong><span class="KeyWordPACKT">Pos Y</span></strong> <span>=</span> <kbd><span class="ScreenTextPACKT">-5</span></kbd> <span>(to ensure we can see the horizontal bar above the triangle).</span></li>
<li>For the <strong><span class="ScreenTextPACKT">Source Image</span></strong> <span>property of the</span> <strong><span class="ScreenTextPACKT">Image (Script)</span></strong> <span>component, select the arrangement triangle icon image:</span> <span><kbd><span class="ScreenTextPACKT">icon_move_to_front</span></kbd></span><span>.</span></li>
<li>Add an <strong><span class="KeyWordPACKT">OnClick</span></strong> <span>event handler by clicking on the plus sign (</span><strong><span class="ScreenTextPACKT">+</span></strong><span>) at the bottom of the</span> <strong><span class="ScreenTextPACKT">Button (Script)</span></strong> <span>component.</span></li>
<li>Drag <strong><span class="ScreenTextPACKT">Panel-jack-diamonds</span></strong> <span>from the</span> <strong><span class="ScreenTextPACKT">Hierarchy</span></strong> <span>over to the</span> <strong><span class="ScreenTextPACKT">Object</span></strong> <span>slot (immediately below the menu saying</span> <strong><span class="ScreenTextPACKT">Runtime Only</span></strong><span><span>).</span></span></li>
<li>Select the <span><kbd><span class="ScreenTextPACKT">RectTransform.SetAsLastSibling</span></kbd></span> <span>method from the drop-down function list (initially showing</span> <strong><span class="ScreenTextPACKT">No Function</span></strong><span>):</span></li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4254ab98-f133-4652-b80e-46b7decce6cb.png"/></div>
<ol start="5">
<li>Repeat step 2; create a second Panel named <strong>Panel-2-diamonds</strong> with its own <strong>move-to-front</strong> button, and <strong>Source Image</strong> of <kbd>2_of_diamonds</kbd>. Move and position this new panel slightly to the right of <strong>Panel-jack-diamonds</strong>, allowing both the <strong>move-to-front</strong> buttons to be seen.</li>
<li>Save your <strong>Scene</strong> and run the game. You will be able to click the <strong>move-to-front</strong> button on either of the cards to move that card's panel to the front. If you run the game with the Game panel not maximized, you'll actually see the panels changing order in the list of the children of the <strong><span class="ScreenTextPACKT">Canvas</span></strong> in the <strong><span class="ScreenTextPACKT">Hierarchy</span></strong>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have created two <strong><span class="KeyWordPACKT">UI Panels</span></strong>, each panel contains a background <strong><span class="KeyWordPACKT">Image</span></strong> of a playing card and a <strong>UI</strong> <strong><span class="KeyWordPACKT">Button</span></strong> whose action will make its parent panel move to the front. You set the <strong><span class="KeyWordPACKT">Alpha</span></strong> (transparency) setting of the background image's <strong><span class="KeyWordPACKT">Color</span></strong> to <kbd><span class="ScreenTextPACKT">255</span></kbd> (no transparency).</p>
<p>You added an <kbd><span class="ScreenTextPACKT">OnClick</span></kbd> event action to the button of each <strong>UI</strong> <span class="KeyWordPACKT"><strong>Panel</strong></span>. The action sends a <kbd><span class="KeyWordPACKT">SetAsLastSibling</span></kbd> message to the <span class="KeyWordPACKT"><strong>Button's</strong> <strong>Panel</strong></span> parent. When the <strong><span class="KeyWordPACKT">OnClick</span></strong> message is received, the clicked <strong><span class="KeyWordPACKT">Panel</span></strong> is moved to the bottom (end) of the sequence of GameObjects in the <strong><span class="KeyWordPACKT">Canvas</span></strong>, and therefore this <strong><span class="KeyWordPACKT">Panel</span></strong> is drawn last of the <strong><span class="KeyWordPACKT">Canvas</span></strong> objects, and so appears visually in front of all other GameObjects.</p>
<p>The button's action illustrates how the <strong><span class="ScreenTextPACKT">OnClick</span></strong> function does not have to be the calling of a public method of a scripted component of an object, but it can be sending a message to one of the non-scripted components of the targeted GameObject. In this recipe, we send the <kbd><strong><span class="ScreenTextPACKT">SetAsLastSibling</span></strong></kbd> message to the <span class="ScreenTextPACKT"><strong>Rect Transform</strong></span> <span>of the <span class="ScreenTextPACKT">Panel</span> where the <span class="ScreenTextPACKT">Button</span> is located.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Moving up or down by just one position, using scripted methods</h1>
                </header>
            
            <article>
                
<p>While the <strong>Rect Transform</strong> offers a useful <kbd><span class="KeyWordPACKT">SetAsLastSibling</span></kbd> (move to front) and <kbd><span class="KeyWordPACKT">SetAsFirstSibling</span></kbd> (move to back), and even <kbd><span class="KeyWordPACKT">SetSiblingIndex</span></kbd> (if we knew exactly what position in the sequence to type in), there isn't a built-in way to make an element move up or down just one position in the sequence of GameObjects in the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>. However, we can write two straightforward methods in C# to do this, and we can add buttons to call these methods, providing full control of the top-to-bottom arrangement of the UI controls on the screen. To implement four buttons (move-to-front/move-to-back/up one/down one), do the following:</p>
<ol>
<li>Create a C# script class called <kbd><span class="CodeInTextPACKT">ArrangeActions</span></kbd><span>, containing the following code, and add an instance as a scripted component to each of your <strong><span class="ScreenTextPACKT">Panels</span></strong>:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 

public class ArrangeActions : MonoBehaviour { 
   private RectTransform panelRectTransform; 
 
   void Awake() { 
         panelRectTransform = GetComponent&lt;RectTransform&gt;(); 
   }  

   public void MoveDownOne() { 
         int currentSiblingIndex = panelRectTransform.GetSiblingIndex(); 
         panelRectTransform.SetSiblingIndex( currentSiblingIndex - 1 ); 
   } 
   
   public void MoveUpOne() { 
         int currentSiblingIndex = panelRectTransform.GetSiblingIndex(); 
         panelRectTransform.SetSiblingIndex( currentSiblingIndex + 1 );           
   } 
}</pre>
<ol start="2">
<li>Add a second <strong>UI Button</strong> to each card panel, this time using the arrangement triangle icon image called <kbd><span class="ScreenTextPACKT">icon_move_to_front</span></kbd><span>, and set the <strong><span class="ScreenTextPACKT">OnClick</span></strong> event function for these buttons to <kbd><span class="ScreenTextPACKT">SetAsFirstSibling</span></kbd>.</span></li>
<li>Add two further <strong>UI Buttons</strong> to each card panel with the up and down triangle icon images: <kbd><span class="ScreenTextPACKT">icon_down_one</span></kbd> and <kbd><span class="ScreenTextPACKT">icon_up_one</span></kbd><span>. Set the <strong><span class="ScreenTextPACKT">OnClick</span></strong> event-handler function for the down-one buttons to call the</span> <kbd><span class="CodeInTextPACKT">MoveDownOne()</span></kbd> method, and set the functions for the up-one buttons to call the <kbd><span class="CodeInTextPACKT">MoveUpOne()</span></kbd> method.</li>
<li>Copy one of the <strong>UI Panels</strong> to create a third card (this time showing the Ace of diamonds). Arrange the three cards so that you can see all four buttons for at least two of the cards, even when those cards are at the bottom (see the screenshot at the beginning of this recipe).</li>
<li>Save the <strong>Scene</strong> and run your game. You will now have full control over the layering of the three card panels.</li>
</ol>
<div class="packt_tip">Note, we should avoid <em>negative</em> sibling depths, so we should probably test for the currentSiblingIndex value before subtracting 1:<br/>
<kbd>if(currentSiblingIndex &gt; 0)<br/></kbd><kbd>      panelRectTransform.SetSiblingIndex( currentSiblingIndex - 1 );</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying the value of an interactive UI Slider</h1>
                </header>
            
            <article>
                
<p>This recipe illustrates how to create an interactive <strong><span class="KeyWordPACKT">UI Slider</span></strong>, and execute a C# method each time the user changes the <strong>UI <span class="KeyWordPACKT">Slider</span></strong> value:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/05acc1b3-9377-40c3-a4a7-ba89420cb03a.png" style="width:20.33em;height:3.75em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a <strong>UI Slider</strong> and display its value on the screen, follow these steps:</p>
<ol>
<li>Create a new 2D project.</li>
</ol>
<ol start="2">
<li>Add a <strong><span class="KeyWordPACKT">UI Text</span></strong> GameObject to the scene with a <strong><span class="KeyWordPACKT">Font</span></strong> size of <kbd><span class="CodeInTextPACKT">30</span></kbd> and placeholder text, such as <span class="CodeInTextPACKT"><span class="packt_screen">slider value here</span></span> (this text will be replaced with the slider value when the scene starts). Set <strong><span class="KeyWordPACKT">Horizontal-</span></strong> and <span class="KeyWordPACKT"><strong>Vertical- Overflow</strong></span> to <strong><span class="KeyWordPACKT">Overflow</span></strong>.</li>
<li>In the <strong><span class="KeyWordPACKT">Hierarchy</span></strong> add a <strong>UI Slider </strong>GameObject to the scene <span>–</span> choose menu: <span class="KeyWordPACKT"><span class="packt_screen">GameObject | UI | Slider</span></span>.</li>
<li>In the <strong><span class="KeyWordPACKT">Inspector</span></strong>, modify the settings for the position of the <strong>UI <span class="KeyWordPACKT">Slider</span></strong> GameObject's <strong><span class="ScreenTextPACKT">Rect Transform</span></strong> to the top-middle part of the screen.</li>
<li>In the <strong><span class="KeyWordPACKT">Inspector</span></strong>, modify settings for <strong>Position</strong> of the <strong><span class="KeyWordPACKT">UI Text's</span> <span class="KeyWordPACKT">Rect Transform</span></strong> to just below the slider (top, middle, then <strong><span class="ScreenTextPACKT">Pos Y</span></strong> = <kbd><span class="ScreenTextPACKT">-30</span></kbd>).</li>
<li>In the <strong><span class="KeyWordPACKT">Inspector</span></strong>, set the <strong><span class="KeyWordPACKT">UI Slider's</span> <span class="ScreenTextPACKT">Min Value</span></strong> to <kbd><span class="CodeInTextPACKT">0</span></kbd>, the <strong><span class="ScreenTextPACKT">Max Value</span></strong> to <kbd><span class="CodeInTextPACKT">20</span></kbd>, and check the <strong><span class="ScreenTextPACKT">Whole Numbers</span></strong> checkbox:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c24362c0-a292-4e65-8b9c-952697a07e82.png" style="width:32.67em;height:21.08em;"/></div>
<ol start="7">
<li>Create a C# script class called <kbd><span class="CodeInTextPACKT">SliderValueToText</span></kbd>, containing the following code, and add an instance as a scripted component to the <strong><span class="KeyWordPACKT">Text</span></strong> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

public class SliderValueToText : MonoBehaviour { 
   public Slider sliderUI; 
   private Text textSliderValue; 

   void Awake() {
         textSliderValue = GetComponent&lt;Text&gt;(); 
   } 

   void Start() { 
         ShowSliderValue(); 
   } 

   public void ShowSliderValue () { 
         string sliderMessage = "Slider value = " + sliderUI.value; 
         textSliderValue.text = sliderMessage; 
   } 
} </pre>
<ol start="8">
<li>Ensure that the <strong><span class="KeyWordPACKT">Text</span></strong> GameObject is selected in the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>. Then, in the <strong><span class="KeyWordPACKT">Inspector</span></strong>, drag the <strong><span class="ScreenTextPACKT">Slider</span></strong> GameObject into the public <strong><span class="KeyWordPACKT">Slider UI</span></strong> variable slot for the <strong><span class="CodeInTextPACKT">Slider</span> <span class="CodeInTextPACKT">Value</span> <span class="CodeInTextPACKT">To</span> <span class="CodeInTextPACKT">Text</span> <span class="CodeInTextPACKT">(Script)</span></strong> scripted component:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e06acc58-c7da-40a5-aea4-42725c00ddfe.png"/></div>
<ol start="9">
<li>Ensure that the <strong><span class="KeyWordPACKT">Slider</span></strong> GameObject is selected in the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>. Then, in the <strong><span class="KeyWordPACKT">Inspector</span></strong>, drag the <strong><span class="KeyWordPACKT">Text</span></strong> GameObject into the public <strong><span class="KeyWordPACKT">None (Object)</span></strong> slot for the <strong><span class="KeyWordPACKT">Slider (Script)</span></strong> scripted component, in the section for <strong><span class="KeyWordPACKT">On Value Changed (Single)</span></strong> <span class="KeyWordPACKT">- as shown in the screenshot:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/52ff1c10-af95-4396-94aa-eef952d24413.png"/></div>
<div>
<div class="packt_infobox"><span class="KeyWordPACKT"><strong>Registering an object to receive UI event messages</strong><br/>
<br/></span> You have now told Unity to which object a message should be sent each time the slider is<span> </span>changed.</div>
</div>
<ol start="10">
<li>From the drop-down menu, select <strong><span class="ScreenTextPACKT">SliderValueToText</span></strong> and the <kbd><span class="CodeInTextPACKT">ShowSliderValue()</span></kbd> method, as shown in the following screenshot. This means that each time the slider is updated, the <span class="CodeInTextPACKT"><kbd>ShowSliderValue()</kbd> </span>method, in the scripted object, in the <strong><span class="ScreenTextPACKT">Text</span></strong> GameObject will be executed:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5b3df604-b62e-435b-b6a2-9b10347a1f6c.png"/></div>
<ol start="11">
<li>When you run the <strong>Scene</strong>, you will now see a <strong>UI Slider</strong>. Below it, you will see a text message in the form <kbd><span class="CodeInTextPACKT">Slider</span> <span class="CodeInTextPACKT">value</span> <span class="CodeInTextPACKT">=</span> <span class="CodeInTextPACKT">&lt;n&gt;</span></kbd>.</li>
<li>Each time the <strong>UI Slider</strong> is moved, the text value shown will be (almost) instantly updated. The values should range from <kbd><span class="CodeInTextPACKT">0</span></kbd> (the leftmost of the slider) to <kbd><span class="CodeInTextPACKT">20</span></kbd> (the rightmost of the slider).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created a <strong><span class="ScreenTextPACKT">UI Slider</span></strong> GameObject, and set it to be whole numbers in the range of <kbd><span class="CodeInTextPACKT">0</span></kbd> ... <kbd><span class="CodeInTextPACKT">20</span></kbd>.</p>
<p>You have added an instance of the <kbd><span class="CodeInTextPACKT">SliderValueToText</span></kbd> C# script class t<span>o the</span><span> </span><strong><span class="KeyWordPACKT">UI Text</span><span> </span></strong><span>GameObject</span><span>.</span></p>
<p>The <span class="CodeInTextPACKT"><kbd>Awake()</kbd> </span>method caches references to the <span class="KeyWordPACKT">Text</span> component in the <span class="CodeInTextPACKT">textSliderValue variable</span>.</p>
<p>The <kbd><span class="CodeInTextPACKT">Start()</span></kbd> method invokes the <span class="CodeInTextPACKT"><kbd>ShowSliderValue()</kbd> </span>method, so that the display is correct when the scene begins (that is, the initial slider value is displayed).</p>
<p>The <kbd><span class="CodeInTextPACKT">ShowSliderValue()</span></kbd> method gets the value of the slider and then updates the text displayed to be a message in the form of <kbd><span class="CodeInTextPACKT">Slider value = &lt;n&gt;</span></kbd>.</p>
<p>You added the <kbd><span class="CodeInTextPACKT">ShowSliderValue()</span></kbd> method of the <strong><span class="CodeInTextPACKT">SliderValueToText</span></strong> scripted component <span>to the</span><span> </span><strong><span class="ScreenTextPACKT">Slider</span></strong><span> </span><span>GameObject's list of</span><span> </span><strong><span class="ScreenTextPACKT">On Value Changed</span><span> </span></strong><span>event listeners</span><span>. So, each time the slider value changes, it sends a message to call the</span> <kbd><span class="CodeInTextPACKT">ShowSliderValue()</span></kbd> <span>method, and so the new value is updated on the screen.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a countdown timer graphically with a UI Slider</h1>
                </header>
            
            <article>
                
<p>There are many cases where we wish to inform the player of the <span class="KeyWordPACKT">proportion</span> of time remaining, or at the completion of some value at a point in time, for example, a loading progress bar, the time or health remaining compared to the starting maximum, or how much the player has filled up their water bottle from the fountain of youth. In this recipe, we'll illustrate how to remove the interactive "handle" of a <strong><span class="KeyWordPACKT">UI Slider</span></strong>, and change the size and color of its components to provide us with an easy-to-use, general purpose progress/proportion bar. In this recipe, we'll use our modified <strong>UI Slider</strong> to graphically present to the user how much time remains for a countdown timer:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17ced000-edba-4800-9630-5d537802d356.png" style="width:14.83em;height:7.00em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the script and images that you need in the folders named <kbd>_<span class="CodeInTextPACKT">Scripts</span></kbd> and <span class="CodeInTextPACKT">Images</span> in the <kbd><span class="CodeInTextPACKT">02_05</span></kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a digital countdown timer with a graphical display, follow these steps:</p>
<ol>
<li>Create a new 2D project.</li>
<li>Import the <kbd><strong><span class="CodeInTextPACKT">CountdownTimer</span></strong></kbd> script and the <kbd><span class="CodeInTextPACKT">red_square</span></kbd> and <kbd><span class="CodeInTextPACKT">green_square</span></kbd> images to this project.</li>
<li>Add a <strong><span class="KeyWordPACKT">UI Text</span></strong> GameObject to the scene with a <strong><span class="KeyWordPACKT">Font</span></strong> size of <kbd><span class="CodeInTextPACKT">30</span></kbd> and placeholder text such as <strong>UI S</strong><span class="CodeInTextPACKT"><strong>lider</strong> value here</span> (this text will be replaced with the slider value when the scene starts). Set <strong><span class="KeyWordPACKT">Horizontal-</span></strong> and <strong><span class="KeyWordPACKT">Vertical- Overflow</span></strong> to <strong><span class="KeyWordPACKT">Overflow</span></strong>.</li>
<li>In the <strong><span class="ScreenTextPACKT">Hierarchy</span></strong>, add a<strong><span class="KeyWordPACKT"> Slider</span></strong> GameObject to the scene <span>–</span> choose menu: <kbd><span class="KeyWordPACKT">GameObject | UI | Slider</span></kbd>.</li>
<li>In the <strong><span class="ScreenTextPACKT">Inspector</span></strong>, modify the settings for the <strong>Position</strong> of the<strong> <span class="KeyWordPACKT">Slider</span></strong> GameObject's <strong><span class="ScreenTextPACKT">Rect Transform</span></strong> to the top-middle part of the screen.</li>
<li>Ensure that the <strong><span class="KeyWordPACKT">Slider</span></strong> GameObject is selected in the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>.</li>
<li>Deactivate the <strong><span class="ScreenTextPACKT">Handle Slide Area</span></strong> child GameObject (by unchecking it)</li>
<li>You'll see the "drag circle" disappear in the <strong><span class="KeyWordPACKT">Game</span></strong> panel (the user will not be dragging the slider, since we want this slider to be display-only):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cd18eb19-ba49-4761-bc8b-2059bbd0e4f2.png" style="width:37.92em;height:13.25em;"/></div>
<ol start="9">
<li>Select the <strong><span class="ScreenTextPACKT">Background</span></strong> child:
<ul>
<li>Drag the <kbd><span class="CodeInTextPACKT">red_square</span></kbd> image into the <strong><span class="KeyWordPACKT">Source Image</span></strong> property of the <strong><span class="KeyWordPACKT">Image (Script)</span></strong> component in the <strong><span class="KeyWordPACKT">Inspector</span></strong></li>
</ul>
</li>
<li>Select the <span class="ScreenTextPACKT">Fill</span> child of the <span class="ScreenTextPACKT">Fill Area</span> child:
<ul>
<li>Drag the <kbd><span class="CodeInTextPACKT">green_square</span></kbd> image into the <strong><span class="KeyWordPACKT">Source Image</span></strong> property of the <strong><span class="KeyWordPACKT">Image (Script)</span></strong> component in the <strong><span class="KeyWordPACKT">Inspector</span></strong></li>
</ul>
</li>
<li>Select the <strong><span class="ScreenTextPACKT">Fill Area</span></strong> child:
<ul>
<li>In the <strong><span class="ScreenTextPACKT">Rect Transform</span></strong> component, use the <strong><span class="KeyWordPACKT">Anchors</span></strong> preset position of <span class="ScreenTextPACKT">left-middle</span></li>
<li>Set <strong><span class="KeyWordPACKT">Width</span></strong> <span>to</span> <kbd><span class="ScreenTextPACKT">155</span></kbd> <span>and</span> <strong><span class="KeyWordPACKT">Height</span></strong> <span>to</span> <kbd><span class="ScreenTextPACKT">12</span></kbd><span>:</span></li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8666f436-e0d5-4ef4-84c5-61d9b833df10.png"/></div>
<ol start="12">
<li>Create a C# script class called <kbd><span class="CodeInTextPACKT">SliderTimerDisplay</span></kbd> that contains the following code, and add an instance as a scripted component to the <strong><span class="ScreenTextPACKT">Slider</span></strong> GameObject:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

[RequireComponent(typeof(CountdownTimer))] 
public class SliderTimerDisplay : MonoBehaviour { 
   private CountdownTimer countdownTimer; 
   private Slider sliderUI; 

   void Awake() { 
         countdownTimer = GetComponent&lt;CountdownTimer&gt;(); 
         sliderUI = GetComponent&lt;Slider&gt;(); 
   } 

   void Start() { 
         SetupSlider(); 
         countdownTimer.ResetTimer( 30 ); 
   } 

   void Update () { 
         sliderUI.value = countdownTimer.GetProportionTimeRemaining(); 
         print (countdownTimer.GetProportionTimeRemaining()); 
   } 

   private void SetupSlider () { 
         sliderUI.minValue = 0; 
         sliderUI.maxValue = 1; 
         sliderUI.wholeNumbers = false; 
   } 
} </pre>
<p>Run your game and you will see the slider move with each second, revealing more and more of the red background to indicate the time remaining.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You hid the <strong><span class="KeyWordPACKT">Handle Slide Area</span></strong> child so that the <strong><span class="KeyWordPACKT">UI Slider</span></strong> is for display only, and cannot be interacted with by the user. The <strong><span class="KeyWordPACKT">Background</span></strong> color of the <strong><span class="KeyWordPACKT">UI Slider</span></strong> was set to red, so that, as the counter goes down, more and more red is revealed <span>–</span> warning the user that the time is running out.</p>
<p>The <strong><span class="KeyWordPACKT">Fill</span></strong> of the <strong>UI <span class="KeyWordPACKT">Slider</span></strong> was set to green, so that the proportion remaining is displayed in green <span>–</span> the more green displayed, the greater the value of the slider/timer.</p>
<p>An instance of the provided <strong><span class="CodeInTextPACKT">CountdownTimer</span></strong> script class was automatically added as a component to the Slider via <kbd><span class="CodeInTextPACKT">[RequireComponent(...)]</span></kbd>.</p>
<p>The <span class="CodeInTextPACKT"><kbd>Awake()</kbd> </span>method caches references to the <strong><span class="CodeInTextPACKT">CountdownTimer</span></strong> and <strong><span class="CodeInTextPACKT">Slider</span></strong> components in the <kbd><span class="CodeInTextPACKT">countdownTimer</span></kbd> and <span class="CodeInTextPACKT"><kbd>sliderUI</kbd> variables</span>.</p>
<p>The <span class="CodeInTextPACKT"><kbd>Start()</kbd> </span>method calls the <kbd><span class="CodeInTextPACKT">SetupSlider()</span></kbd> method and then resets the countdown timer to start counting down from 30 seconds.</p>
<p>The <kbd><span class="CodeInTextPACKT">SetupSlider()</span></kbd> method sets up this slider for float (decimal) values between <kbd><span class="CodeInTextPACKT">0.0</span></kbd> and <kbd><span class="CodeInTextPACKT">1.0</span></kbd>.</p>
<p>In each frame, the <span class="CodeInTextPACKT"><kbd>Update()</kbd> </span>method sets the slider value to the float returned by calling the <span class="CodeInTextPACKT"><kbd>GetProportionRemaining()</kbd> </span>method from the running timer. At runtime, Unity adjusts the proportion of red/green displayed in the <span class="KeyWordPACKT">Slider</span> to match the slider's value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting custom mouse cursors for 2D and 3D GameObjects</h1>
                </header>
            
            <article>
                
<p>Cursor icons are often used to indicate the nature of the interaction that can be done with the mouse. Zooming, for instance, might be illustrated by a magnifying glass; shooting, on the other hand, is usually represented by a stylized target. In this recipe, we will learn how to implement custom mouse cursor icons to better illustrate your gameplay <span>–</span> or just to escape the Windows, macOS, and Linux default UI:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span><img src="assets/01301f05-5a91-4ed1-bbc6-28b3a4922d95.png" style="width:19.42em;height:3.42em;"/><br/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the folders that you'll need in the <kbd><span class="CodeInTextPACKT">02_06</span></kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To make a custom cursor appear when the mouse is over a GameObject, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>Import the provided folder, called <kbd><span class="CodeInTextPACKT">Images</span></kbd>. Select the <kbd><span class="ScreenTextPACKT">unity_logo</span></kbd> image in the <strong><span class="KeyWordPACKT">Project</span></strong> panel, and in the <strong><span class="KeyWordPACKT">Inspector</span></strong> change the <strong><span class="KeyWordPACKT">Texture T</span></strong><span class="KeyWordPACKT">ype</span> to <strong><span class="ScreenTextPACKT">Sprite (2D and UI)</span></strong>. This is because we'll use this image for a <strong>2D Sprite</strong> GameObject, and it requires this <strong><span class="KeyWordPACKT">Texture</span> Type</strong> (it won't work with the <strong><span class="ScreenTextPACKT">Default</span></strong> type).</li>
</ol>
<ol start="3">
<li>Add a <strong><span class="KeyWordPACKT"><span class="packt_screen">2D Object | Sprite</span></span></strong> GameObject to the scene. Name this <strong><span class="KeyWordPACKT">New Sprite</span></strong>, if this wasn't the default name when created.
<ul>
<li>In the <span class="KeyWordPACKT"><strong>Inspector</strong>,</span> set the <strong><span class="KeyWordPACKT">Sprite</span></strong> property of the <strong><span class="KeyWordPACKT">Sprite Renderer</span></strong> component to the <kbd><span class="ScreenTextPACKT">unity_logo</span></kbd> image. In the GameObjects <strong><span class="KeyWordPACKT">Transform</span></strong> component, set the scaling to <kbd><span class="CodeInTextPACKT">(3,3,3)</span></kbd>, and if necessary, reposition the <strong><span class="KeyWordPACKT">Sprite</span></strong> to be centered in the <strong>Game</strong> panel when the <strong>Scene</strong> runs.</li>
<li>Add to the <strong><span class="KeyWordPACKT">Sprite</span></strong> <span>GameObject a</span> <kbd><span class="KeyWordPACKT">Physics 2D | Box Collider</span></kbd><span>. This is needed for this GameObject to receive</span> <kbd><span class="KeyWordPACKT">OnMouseEnter</span></kbd> <span>and</span> <kbd><span class="KeyWordPACKT">OnMouseExit</span></kbd> <span>event messages.</span></li>
</ul>
</li>
<li>Import the provided folder called <kbd><span class="CodeInTextPACKT">IconsCursors</span></kbd>. Select all three images in the <strong><span class="KeyWordPACKT">Project</span></strong> panel, and in the <span class="KeyWordPACKT"><strong>Inspector</strong>,</span> change the <strong><span class="KeyWordPACKT">Texture Type</span></strong> to <strong><span class="ScreenTextPACKT">Cursor</span></strong>. This will allow us to use these images as mouse cursors without any errors occurring.</li>
<li>Create a C# script class called <kbd><span class="CodeInTextPACKT">CustomCursorPointer</span></kbd><span>, containing the following code, and add an instance as a scripted component to the <strong><span class="ScreenTextPACKT">New Sprite</span></strong> GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using System.Collections; 

public class CustomCursorPointer : MonoBehaviour { 
  public Texture2D cursorTexture2D; 
  private CursorMode cursorMode = CursorMode.Auto; 
  private Vector2 hotSpot = Vector2.zero; 

  public void OnMouseEnter() { 
    SetCustomCursor(cursorTexture2D); 
  } 

  public void OnMouseExit() { 
    SetCustomCursor(null); 
  } 

  private void SetCustomCursor(Texture2D curText){ 
    Cursor.SetCursor(curText, hotSpot, cursorMode); 
  } 
}</pre>
<div class="packt_infobox">Event methods <kbd><span class="CodeInTextPACKT">OnMouseEnter()</span></kbd> and <kbd><span class="CodeInTextPACKT">OnMouseExit()</span></kbd> have been deliberately declared as <span class="CodeInTextPACKT">public</span>. This will allow these methods to also be called from UI GameObjects when they receive the <kbd><span class="CodeInTextPACKT">OnPointerEnterExit</span></kbd> events.</div>
<ol start="6">
<li>With the <strong>New Sprite</strong> item selected in the <strong>Hierarchy</strong>, drag the <kbd>CursorTarget</kbd> image into the public <strong>Cursor Texture 2D</strong> variable slot in the <strong>Inspector</strong> for the <strong>Customer Cursor Pointer (Script)</strong> component.</li>
<li>Save and run the current <strong>Scene</strong>. When the mouse pointer moves over the Unity logo sprite, it will change to the custom <strong><span class="CodeInTextPACKT">CursorTarget</span></strong> image that you chose.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You created a <strong><span class="KeyWordPACKT">Sprite</span></strong> GameObject and assigned it the Unity logo image. You imported some cursor images, and set their <span class="KeyWordPACKT"><strong>Texture</strong> <strong>Type</strong></span> to <strong><span class="ScreenTextPACKT">Cursor</span></strong>, so they could be used to change the image for the user's mouse pointer. You added a <strong><span class="KeyWordPACKT">Box Collider</span></strong> to the sprite GameObject so that it would receive <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> and <kbd><span class="ScreenTextPACKT">OnMouseExit</span></kbd> event messages.</p>
<p>You created the <span class="CodeInTextPACKT"><kbd><strong>CustomCursorPointer</strong></kbd> script class</span><span>, and added an instance-object of this class to the sprite GameObject – this script tells Unity to change the mouse pointer when an <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> message is received, that is, when the user's mouse pointer moves over the part of the screen where the Unity logo sprite image is being rendered. When an <kbd><span class="ScreenTextPACKT">OnMouseExit</span></kbd> event is received (the users mouse pointer is no longer over the cube part of the screen), the system is told to go back to the operating system's default cursor. This event should be received within a few milliseconds of the user's mouse exiting from the collider.</span></p>
<p>Finally, you selected the image <kbd><span class="CodeInTextPACKT">CursorTarget</span></kbd> to be the custom mouse-pointer cursor image the user sees when the mouse is over the Unity logo image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting custom mouse cursors for UI controls</h1>
                </header>
            
            <article>
                
<p><span>The previous recipe demonstrated how to change the mouse pointer for 2D and 3D GameObjects receiving <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> and <kbd><span class="ScreenTextPACKT">OnMouseExit</span></kbd> events. Unity UI controls do not receive <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> and <kbd><span class="ScreenTextPACKT">OnMouseExit</span></kbd> events. Instead, UI controls can be made to respond to <kbd><span class="ScreenTextPACKT">PointerEnter</span></kbd> and <kbd><span class="ScreenTextPACKT">PointerExit</span></kbd> events if we add a special</span> <strong><span class="KeyWordPACKT">Event Trigger</span></strong> component to the UI GameObject. In this recipe, we'll change the mouse pointer to a custom magnifying glass cursor when it moves over a <strong><span class="KeyWordPACKT">UI Button</span></strong> GameObject:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21b28fb7-a234-420a-a718-912a3c5f0b93.png" style="width:25.00em;height:2.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we'll use the same asset files as for the previous recipe, and its <span class="CodeInTextPACKT"><kbd>CustomCursorPointer</kbd> </span><span class="KeyWordPACKT">C#</span><span> </span><span>script class</span><span>, all of which can be found in the</span> <kbd><span class="CodeInTextPACKT">02_07</span></kbd> <span>folder.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To <span>set a custom mouse pointer when the mouse moves over a UI control GameObject,<br/>
do the following:</span></p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>Import the provided <span class="CodeInTextPACKT"><kbd>IconsCursors</kbd> folder</span><span>. Select all three images in the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel, and in the</span> <strong><span class="KeyWordPACKT">Inspector</span></strong> <span>change the</span> <strong><span class="KeyWordPACKT">Texture Type</span></strong> <span>to</span> <strong><span class="ScreenTextPACKT">Cursor</span></strong><span>. This will allow us to use these images as mouse cursors without any errors occurring.</span></li>
<li>Import the provided <span class="CodeInTextPACKT"><kbd>_Scripts</kbd> folder</span><span>, containing the</span> <span class="CodeInTextPACKT"><kbd>CustomCursorPointer</kbd> </span><span>C# script class.</span></li>
<li>Add a <strong><span class="KeyWordPACKT">UI Button</span></strong> <span>GameObject to the scene, leaving this named as <span class="ScreenTextPACKT"><strong>Button</strong>.</span></span></li>
</ol>
<ol start="5">
<li>Add an instance of the <span class="CodeInTextPACKT"><kbd>CustomCursorPointer</kbd> </span>C# script class <span>to the <span class="ScreenTextPACKT"><strong>Button</strong> GameObject</span>.</span></li>
<li>With the <strong>Button</strong> GameObject selected in the <span class="ScreenTextPACKT"><strong>Hierarchy</strong></span>, drag the <kbd><span class="CodeInTextPACKT">CursorZoom</span></kbd> <span>image into the public <strong><span class="ScreenTextPACKT">Cursor Texture 2D</span></strong> variable slot in the <strong><span class="ScreenTextPACKT">Inspector</span></strong> for the <strong><span class="ScreenTextPACKT">Customer Cursor Pointer (Script)</span></strong> component.</span></li>
<li>In the <strong><span class="ScreenTextPACKT">Inspector</span></strong><span class="ScreenTextPACKT">,</span> <span>add an</span> <strong><span class="ScreenTextPACKT">Event Triggers</span></strong> <span>component to GameObject</span> <strong><span class="ScreenTextPACKT">Button</span></strong><span>. Choose menu:</span> <span class="packt_screen"><span class="ScreenTextPACKT">Add Component</span> <span>|</span> <span class="ScreenTextPACKT">Event</span> <span>|</span> <span class="ScreenTextPACKT">Event Trigger</span></span><span>.</span></li>
<li>Add a <strong><span class="ScreenTextPACKT">PointerEnter</span></strong> <span>event to your</span> <strong><span class="ScreenTextPACKT">Event Trigger</span></strong> <span>component, click on the plus (</span><strong><span class="ScreenTextPACKT">+</span></strong><span>) button to add an event handler slot, and drag GameObject</span> <strong><span class="ScreenTextPACKT">Button</span></strong> <span>into the </span><strong>Object</strong> <span>slot.</span></li>
<li>From the <strong><span class="ScreenTextPACKT">Function</span></strong> <span>drop-down menu, choose</span> <strong><span class="ScreenTextPACKT">CustomCursorPointer</span></strong> <span>and then choose the</span> <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> <span>method:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ca3871d1-3bfa-4acf-9a95-b3b2be861d1f.png" style="width:44.58em;height:13.92em;"/></div>
<ol start="10">
<li>Add a <strong>Pointer Exit</strong> event to your <strong>Event Trigger</strong> component, and make it call the <kbd>OnMouseExit()</kbd> method from <strong>CustomCursorPointer</strong> when this event is received.</li>
<li><span>Save and run the current <strong>Scene</strong>. When the mouse pointer moves over the <strong>UI </strong><span class="ScreenTextPACKT"><strong>Button</strong>,</span> it will change to the custom</span> <kbd><strong><span class="CodeInTextPACKT">CursorZoom</span></strong></kbd> image that you chose.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You have imported some cursor images, and set their <strong><span class="KeyWordPACKT">Texture Type</span></strong> to <strong><span class="ScreenTextPACKT">Cursor</span></strong>, so they could be used to change the image for the user's mouse pointer. You also created a <strong><span class="KeyWordPACKT">UI Button</span></strong> <span>GameObject and added to it an <strong><span class="ScreenTextPACKT">Event Triggers</span></strong> component.</span></p>
<p>You added an instance of the <kbd><span class="CodeInTextPACKT">CustomCursorPointer</span></kbd> <span>C# script class </span><span>to the <strong>Button</strong> GameObject, and selected the magnifying-glass-style</span> <kbd><span class="CodeInTextPACKT">CursorZoom</span></kbd> <span>image.</span></p>
<p>You created a <strong><span class="ScreenTextPACKT">PointerEnter</span></strong> event, and linked it to invoke the <kbd><span class="ScreenTextPACKT">OnMouseEnter</span></kbd> method of the instance of the <span class="CodeInTextPACKT"><kbd>CustomCursorPointer</kbd> script</span> <span>in the <strong>Button</strong> GameObject (which changes the mouse pointer image to the custom mouse cursor).</span></p>
<p>You created a <strong>PointerExit</strong> event, and linked it to invoke the <kbd><span class="ScreenTextPACKT">OnMouseExit</span></kbd> method of the instance of the <kbd><span class="CodeInTextPACKT">CustomCursorPointer</span></kbd> <span>C# script class </span><span>to the <strong>Button</strong> GameObject</span><span> (which resets the mouse cursor back to the system default).</span></p>
<p>Essentially, you have redirected <strong>PointerEnter/Exit</strong> events to invoke the <strong>OnMouseEnter/Exit</strong> methods of the <kbd><span>CustomCursorPointer</span></kbd><span> C# script class</span><span> so we can manage custom cursors for 2D, 3D, and UI GameObjects with the same scripting methods.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interactive text entry with an Input Field</h1>
                </header>
            
            <article>
                
<p>While often we just wish to display non-interactive text messages to the user, there are times (such as name entry for high scores) where we want the user to be able to enter text or numbers into our game. Unity provides the <span class="KeyWordPACKT">UI Input Field</span> component for this purpose. In this recipe, we'll create an Input Field that prompts the user to enter their name:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b3f06f63-a811-466f-8a4c-e418768a5568.png" style="width:29.17em;height:2.92em;"/></div>
<p>Having interactive text on the screen isn't of much use unless we can <em>retrieve</em> the text entered to use in our game logic, and we may need to know each time the user changes the text content and act accordingly. This recipe adds an event-handler C# script that detects each time the user has completed editing the text, and updates an extra message on screen confirming the newly-entered content.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create an interactive text input box to the user, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>In the <strong><span class="ScreenTextPACKT">Inspector</span></strong><span>, change the background of the</span> <strong><span class="ScreenTextPACKT">Main Camera</span></strong> <span>to solid white.</span></li>
</ol>
<ol start="3">
<li>Add a <strong><span class="ScreenTextPACKT">UI Input Field</span></strong> to the <strong>Scene</strong>. Position this to the <span class="ScreenTextPACKT">top-center</span> <span>of the screen.</span></li>
<li>Add a <strong><span class="KeyWordPACKT">UI Text</span></strong> <span>GameObject to the scene, naming it</span> <strong><span class="ScreenTextPACKT">Text-prompt</span></strong><span>. Position this to the left of</span> <strong><span class="KeyWordPACKT">Input Field</span></strong><span>. Change the <strong>Text</strong> property of this GameObject to</span> <span class="ScreenTextPACKT"><span class="packt_screen">Name:</span>.</span></li>
<li>Create a new <strong><span class="KeyWordPACKT">UI Text</span></strong> <span>GameObject named <strong><span class="ScreenTextPACKT">Text-display</span></strong>. Position this to the right of the</span> <strong><span class="KeyWordPACKT">Input Text</span></strong> <span>control, and color its text</span> <span class="ScreenTextPACKT">red</span><span>.</span></li>
<li>Delete all of the content of the <strong><span class="ScreenTextPACKT">Text</span></strong> <span>property of this new GameObject (so initially the user won't see any text on</span> screen <span>for this GameObject).</span></li>
<li>Add an instance of the <kbd><span class="CodeInTextPACKT">DisplayChangedTextContent</span></kbd> <span>C# script class to the <strong><span class="ScreenTextPACKT">Text-display</span></strong> GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

public class DisplayChangedTextContent : MonoBehaviour { 
   public InputField inputField; 
   private Text textDisplay; 

   void Awake() { 
         textDisplay = GetComponent&lt;Text&gt;(); 
   } 

   public void DisplayNewValue () { 
         textDisplay.text = "last entry = '" + inputField.text + "'"; 
   } 
} </pre>
<ol start="8">
<li>With <strong><span class="KeyWordPACKT">Text-display</span></strong> selected in the <strong><span class="KeyWordPACKT">Hierarchy</span></strong>, from the <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel drag the <strong><span class="ScreenTextPACKT">Input Field</span></strong> GameObject into the public</span> <strong><span class="KeyWordPACKT">Input Field</span> </strong>variable of the <strong><span class="KeyWordPACKT">Display Changed Content (Script)</span></strong> component:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/68735db8-5fcd-4255-a441-65c6354d8caf.png" style="width:38.92em;height:11.42em;"/></div>
<ol start="9">
<li>With <strong><span class="KeyWordPACKT">Input Field</span></strong> selected in the <span class="KeyWordPACKT"><strong>Hierarchy</strong>,</span> <span>add an <strong><span class="ScreenTextPACKT">End Edit (String)</span></strong> event to the list of event handlers for the</span> <strong><span class="ScreenTextPACKT">Input Field</span> <span class="ScreenTextPACKT">(Script)</span></strong> <span>component. Click on the plus (<strong><span class="ScreenTextPACKT">+</span></strong>) button to add an event-handler slot, and drag the</span> <strong><span class="ScreenTextPACKT">Text-display</span></strong> <span>GameObject into the <strong><span class="ScreenTextPACKT">Object</span></strong> slot.</span></li>
<li>From the <strong><span class="ScreenTextPACKT">Function</span></strong> <span>drop-down menu, choose</span> <strong><span class="ScreenTextPACKT">DisplayChangedTextContent</span></strong> <span>and then choose the</span> <kbd><span class="ScreenTextPACKT">DisplayNewValue</span></kbd> <span>method.</span></li>
<li>Save and run the <strong>Scene</strong>. Each time the user types in new text and then presses <span class="KeyPACKT">Tab</span> or <span class="KeyPACKT">Enter</span>, the <span class="ScreenTextPACKT">End Edit</span> event will fire, and you'll see a new content text message displayed in red on the screen.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The core of interactive text input in Unity is the responsibility of the <strong><span class="KeyWordPACKT">Input Field</span></strong> component. This needs a reference to a <strong><span class="KeyWordPACKT">UI Text</span></strong> GameObject. To make it easier to see where the text can be typed, <strong>Text Input</strong> (as do Buttons) include a default rounded rectangle image, with a white background.</p>
<p>There are usually three <strong><span class="KeyWordPACKT">Text</span></strong> GameObjects involved with the user text input:</p>
<ul>
<li>The static <span class="KeyWordPACKT">prompt text,</span> in our recipe, displaying to the user the text <span class="packt_screen">Name:</span></li>
<li>The faint <span class="KeyWordPACKT">placeholder text</span><span>, reminding users where and what they should type.</span></li>
<li>The <span class="KeyWordPACKT">editable text</span> <span>object (with the font and color settings) that is actually displayed to the user, showing the characters as they type.</span></li>
</ul>
<p>You created an <strong><span class="KeyWordPACKT">Input Field</span></strong> GameObject, which automatically provides two child <strong><span class="KeyWordPACKT">Text</span></strong> GameObjects, named <strong>Placeholder</strong> and <strong>Text</strong>. These represent the faint placeholder text, and the editable text, which you renamed <strong>Text-input</strong>. You then added a third <strong>Text</strong> GameObject, <strong>Text-prompt</strong>, containing text <span class="packt_screen">Name:</span>.</p>
<p>The built-in scripting that is part of <strong><span class="KeyWordPACKT">Input Field</span></strong> <span>components does lots of work for us. At runtime, a <strong><span class="ScreenTextPACKT">Text</span></strong><span class="ScreenTextPACKT"><strong>-Input</strong> Input Caret</span> GameObject is created – displaying the blinking vertical line to inform the user where their next letter will be typed. When there is no text content, the faint placeholder text will be displayed. As soon as any characters have been typed, the placeholder will be hidden and the characters typed will appear in black text. Then, if all the characters are deleted, the placeholder will appear again.</span></p>
<p>You then added a red fourth <strong>Text</strong> GameObject <strong><span class="KeyWordPACKT">Text-display</span></strong>, to confirm to the user what they last entered in the <strong>Input Field</strong>. You created the <kbd><span class="CodeInTextPACKT">DisplayChangedTextContent</span></kbd> <span>C</span><span># script class</span><span>, and added an instance as a component of the <span class="ScreenTextPACKT"><strong>Text-display</strong> GameObject</span>. You linked the</span> <strong><span class="KeyWordPACKT">Input</span></strong> <span><strong>Field</strong> GameObject to the </span><span class="KeyWordPACKT"><strong>Input Field</strong> public variable</span><span> of the scripted component (so the script can access the text content entered by the user).</span></p>
<p>You registered an <strong><span class="KeyWordPACKT">End Edit</span></strong> event handler of the <strong>Input Field</strong>, so that each time the user finished editing text (by pressing <em><span class="CodeInTextPACKT">Enter</span></em>), the <kbd><span class="CodeInTextPACKT">DisplayNewValue()</span></kbd> method of your <kbd><span class="CodeInTextPACKT">DisplayChangedTextContent</span></kbd> scripted object is invoked (executed), and the red text content of <strong><span class="KeyWordPACKT">Text-display</span></strong> updated to tell the user what the newly edited text contained.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Limiting the type of content that can be typed</h1>
                </header>
            
            <article>
                
<p><span>The <strong><span class="ScreenTextPACKT">Content Type</span></strong> of the <strong><span class="ScreenTextPACKT">Input Field (Script)</span></strong>, can be set (restricted) to several specific types of text input, including</span> <span class="KeyWordPACKT">email</span> addresses, <span class="KeyWordPACKT">integer</span> or <span class="KeyWordPACKT">decimal numbers</span> only, or the <span class="KeyWordPACKT">password text</span> (where an asterisk is displayed for each entered character). Learn more about <span class="KeyWordPACKT">Input Fields</span> on the Unity Manual page: <a href="https://docs.unity3d.com/Manual/script-InputField.html"><span class="URLPACKT">https://docs.unity3d.com/Manual/script-InputField.html</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Toggles and radio buttons via Toggle Groups</h1>
                </header>
            
            <article>
                
<p>Users make choices, and often, these choices have <em>one of two</em> options (for example, sound on or off), or sometimes <em>one of several</em> possibilities (for example, difficulty level as easy/medium/hard). Unity <strong><span class="KeyWordPACKT">UI Toggles</span></strong> allows users to turn options on and off; and when combined with <strong><span class="KeyWordPACKT">Toggle Groups</span></strong>, they restrict choices to one of the group of items. In this recipe, we'll first explore the basic <span class="KeyWordPACKT">Toggle</span><span>, and a script to respond to a change in values. Then, we'll extend the example to illustrate</span> <strong><span class="KeyWordPACKT">Toggle Groups</span></strong>, and styling these with round images to make them look more like traditional radio buttons.</p>
<p>The screenshot shows how the button's status changes are logged in the <strong><span class="KeyWordPACKT">Console</span></strong> panel when the scene is running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bacaea1e-3e22-4edc-9941-a46ce48400a8.png" style="width:30.92em;height:7.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the images that you'll need in a folder named <kbd><span class="CodeInTextPACKT">UI</span> <span class="CodeInTextPACKT">Demo</span> <span class="CodeInTextPACKT">Textures</span></kbd> in the <kbd><span class="CodeInTextPACKT">02_09</span></kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To display an on/off UI Toggle to the user, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li>In the <strong><span class="KeyWordPACKT">Inspector</span></strong><span>, change the</span> <span class="KeyWordPACKT">Background</span> <span>color of the</span> <strong><span class="KeyWordPACKT">Main Camera</span></strong> <span>to white.</span></li>
<li>Add <strong><span class="KeyWordPACKT">UI Toggle</span></strong> <span>to the scene.</span></li>
<li>For the <strong><span class="KeyWordPACKT">Label</span></strong> <span>child of the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong> <span>GameObject, set the</span> <strong><span class="KeyWordPACKT">Text</span></strong> <span>property</span> to <span class="ScreenTextPACKT"><span class="packt_screen">First Class</span></span><span>.</span></li>
<li>Add an instance of the C# script class called <kbd><span class="CodeInTextPACKT">ToggleChangeManager</span></kbd> <span>to the </span><strong>Toggle</strong> <span>GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

public class ToggleChangeManager : MonoBehaviour { 
   private Toggle toggle; 

   void Awake () { 
         toggle = GetComponent&lt;Toggle&gt;();     
   } 

   public void PrintNewToggleValue() { 
         bool status = toggle.isOn; 
         print ("toggle status = " + status); 
   } 
} </pre>
<ol start="6">
<li>With the <strong><span class="KeyWordPACKT">Toggle</span></strong> GameObject selected, add an <strong><span class="KeyWordPACKT">On Value Changed</span></strong> event to the list of event handlers for the <strong><span class="KeyWordPACKT">Toggle (Script)</span></strong> component, click on the plus (<strong>+</strong>) button to add an event-handler slot, and drag <strong><span class="KeyWordPACKT">Toggle</span></strong> into the <strong><span class="KeyWordPACKT">Object</span></strong> slot.</li>
<li>From the <strong><span class="KeyWordPACKT">Function</span></strong> <span>drop-down menu, choose</span> <strong><span class="KeyWordPACKT">ToggleChangeManager</span></strong> <span>and then choose the</span> <kbd><span class="KeyWordPACKT">PrintNewToggleValue</span></kbd> <span>method.</span></li>
<li>Save and run the <strong>Scene</strong>. Each time you check or uncheck the <strong><span class="KeyWordPACKT">Toggle</span></strong> <span>GameObject, the</span> <strong><span class="KeyWordPACKT">On Value Changed</span></strong> <span>event will fire, and you'll see a new text message printed into the <strong>Console</strong> window by our script, stating the new</span> <span class="KeyWordPACKT">Boolean</span> <span>true/false value of the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong><span>.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you create a Unity <strong><span class="KeyWordPACKT">UI Toggle</span></strong> GameObject, it comes with several child GameObjects automatically <span>–</span> <strong><span class="KeyWordPACKT">Background</span></strong>, <strong><span class="KeyWordPACKT">Checkmark</span></strong>, and the text <strong><span class="KeyWordPACKT">Label</span></strong>. Unless we need to style the look of a <strong><span class="KeyWordPACKT">Toggle</span></strong> in a special way, all that is needed is simply to edit the text <strong><span class="KeyWordPACKT">Label</span></strong> so that the user knows what option or feature this <strong><span class="KeyWordPACKT">Toggle</span></strong> is going to turn on/off.</p>
<p>The <kbd><span class="CodeInTextPACKT">Awake()</span></kbd> method of the <span class="CodeInTextPACKT"><kbd>ToggleChangeManager</kbd> </span><span>C# class</span><span> caches a reference to the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong> <span>component in the GameObject where the script instance is located. When the game is running, each time the user clicks on the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong> <span>to change its value, an</span> <strong><span class="KeyWordPACKT">On Value Changed</span></strong> <span>event is fired. We then register the</span> <kbd><span class="CodeInTextPACKT">PrintNewToggleValue()</span></kbd><span> method, which is to be executed when such an event occurs. This method retrieves, and then prints out to the</span> <strong><span class="KeyWordPACKT">Console</span></strong> <span>panel, the new</span> <span class="KeyWordPACKT">Boolean</span> <span>true/false value of the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details that you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding more Toggles and a Toggle Group to implement mutually-exclusive radio buttons</h1>
                </header>
            
            <article>
                
<p>Unity <strong><span class="KeyWordPACKT">UI Toggles</span></strong> are also the base components if we wish to implement a group of mutually-exclusive options in the style of <em>radio buttons</em>. We need to group related radio button <strong>UI Toggles</strong> together, so when one turns on, all the others in the group turn off.</p>
<p>We also need to change the visual look if we want to adhere to the usual style of radio buttons as circles, rather than the square <strong>UI <span class="KeyWordPACKT">Toggle</span></strong> default images:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/38859625-98f2-41a4-8890-2feb6140fa9c.png"/></div>
<p>To create a group of related toggles in the visual style of radio buttons, do the following to the project you just created:</p>
<ol>
<li>Import the <kbd><span class="CodeInTextPACKT">UI Demo Textures</span></kbd> folder into the project.</li>
<li>Remove the C# script class <kbd><span class="CodeInTextPACKT">ToggleChangeManager</span></kbd> <span>component from the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong> <span class="CodeInTextPACKT">GameObject</span><span>.</span></li>
<li><span>Rename the</span> <strong><span class="KeyWordPACKT">Toggle</span></strong> <span class="CodeInTextPACKT">GameObject</span> <span>as</span> <strong><span class="KeyWordPACKT">Toggle-easy</span></strong><span>.</span></li>
<li>Select the <strong><span class="KeyWordPACKT">Canvas</span></strong> <span>GameObject, and in the <strong>Inspector</strong> add a</span> <strong><span class="KeyWordPACKT">UI | Toggle Group</span></strong> <span>component.</span></li>
<li><span>With the</span> <span class="KeyWordPACKT"><strong>Toggle-easy</strong></span> <span>GameObject selected, in the</span> <strong><span class="KeyWordPACKT">Inspector</span></strong> <span>drag the</span> <strong><span class="KeyWordPACKT">Canvas</span></strong> <span>GameObject into the</span> <strong><span class="KeyWordPACKT">Toggle Group</span></strong> <span>property of the</span> <strong><span class="KeyWordPACKT">Toggle (Script)</span></strong> <span>component.</span></li>
<li>Change the <strong><span class="KeyWordPACKT">Label</span></strong> <span>text to <strong><span class="ScreenTextPACKT"><span class="packt_screen">Easy</span></span></strong>, and tag this GameObject with a new tag called <kbd><span class="ScreenTextPACKT">Easy</span></kbd>.</span></li>
<li>Select the <strong><span class="ScreenTextPACKT">Background</span></strong> child GameObject of <strong><span class="ScreenTextPACKT">Toggle-easy</span></strong>, and in the <kbd><span class="ScreenTextPACKT">Image (Script)</span></kbd> component, drag the <kbd><span class="CodeInTextPACKT">UIToggleBG</span></kbd> <span>image into the <strong><span class="ScreenTextPACKT">Source Image</span></strong> property (a circle outline).</span></li>
</ol>
<ol start="8">
<li>Ensure that the <strong><span class="ScreenTextPACKT">Is On</span></strong> property of the <strong><span class="ScreenTextPACKT">Toggle (Script)</span></strong> component is checked, and then select the <strong><span class="ScreenTextPACKT">Checkmark</span></strong> child GameObject of <strong><span class="ScreenTextPACKT">Toggle-easy</span>.</strong> In the <strong><span class="ScreenTextPACKT">Image (Script)</span></strong> component, drag the <kbd><span class="CodeInTextPACKT">UIToggleButton</span></kbd> <span>image into the <strong><span class="ScreenTextPACKT">Source Image</span></strong> property (a filled circle).</span></li>
</ol>
<div class="packt_infobox">Of the three choices (easy, medium, and hard) that we'll offer to the user, we'll set the easy option to be the one that is supposed to be initially selected. Therefore, we need its Is On property to be checked, which will lead to its checkmark image being displayed.<br/>
<br/>
To make these Toggles look more like radio buttons, the background of each is set to the circle outline image of <kbd>UIToggleBG</kbd>, and the checkmark (which displays the Toggles that are on) is filled with the circle image called <kbd>UIToggleButton</kbd>.</div>
<ol start="9">
<li>Duplicate the <strong>Toggle-easy</strong> GameObject, naming the copy <strong>Toggle-medium</strong>. Set its <strong>Rect Transform</strong> property <strong>Pos Y</strong> to <kbd>-25</kbd> (so, this copy is positioned below the easy option), and uncheck the <strong>Is On</strong> property of the <strong>Toggle (Script)</strong> component. Tag this copy with a new tag called <kbd>Medium</kbd>.</li>
<li>Duplicate the <strong><span class="ScreenTextPACKT">Toggle-medium</span></strong> GameObject, naming the copy <strong><span class="ScreenTextPACKT">Toggle-hard</span></strong>. Set its <strong><span class="ScreenTextPACKT">Rect Transform</span></strong> property <strong><span class="ScreenTextPACKT">Pos Y</span></strong> to <kbd><span class="CodeInTextPACKT">-50</span></kbd> <span>(so this copy is positioned below the medium option). Tag this copy with a new tag called <kbd><span class="ScreenTextPACKT">Hard</span></kbd>.</span></li>
<li>Add an instance of the <span class="CodeInTextPACKT"><kbd>RadioButtonManager</kbd> </span>C# script class <span>to the </span><strong>Canvas</strong> <span>GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using System.Collections; 
using UnityEngine.UI; 

public class RadioButtonManager : MonoBehaviour { 
  private string currentDifficulty = "Easy"; 

  public void PrintNewGroupValue(Toggle sender){ 
    // only take notice from Toggle just switched to On 
    if(sender.isOn){ 
      currentDifficulty = sender.tag; 
      print ("option changed to = " + currentDifficulty); 
    } 
  } 
}</pre>
<ol start="12">
<li>Select the <strong>Toggle-easy</strong> GameObject in the <strong>Project</strong> panel. Now do the following:
<ul>
<li>Since we based this on the <strong>First Class</strong> toggle, there is already an <span class="ScreenTextPACKT"><strong>On Value Changed</strong></span> event to the list of event handlers for the <strong><span class="ScreenTextPACKT">Toggle (Script)</span></strong> component. Drag the <strong><span class="KeyWordPACKT">Canvas</span></strong> GameObject in the target object slot (under the drop-down showing <strong><span class="ScreenTextPACKT">Runtime Only</span></strong>).</li>
<li>From the <strong><span class="ScreenTextPACKT">Function</span></strong> <span>drop-down menu, choose</span> <strong><span class="ScreenTextPACKT">RadioButtonManager</span></strong><span>, and then choose the</span> <kbd><span class="ScreenTextPACKT">PrintNewGroupValue</span></kbd> <span>method.</span></li>
<li>In the <strong><span class="ScreenTextPACKT">Toggle</span></strong> <span>parameter slot, which is initially</span> <strong><span class="CodeInTextPACKT">None (Toggle)</span></strong><span>, drag the</span> <strong><span class="ScreenTextPACKT">Toggle-easy</span></strong> <span>GameObject.</span> Your <span class="ScreenTextPACKT"><strong>On Value</strong> <strong>Changed</strong></span> <span>settings in the</span> <span class="KeyWordPACKT">Inspector</span> <span>should look as shown in the following screenshot:</span></li>
</ul>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65dd1ee8-292b-4ff6-b111-c2de1efdb65e.png"/></div>
<ol start="13">
<li>Do the same for the <strong>Toggle-medium</strong> and <strong>Toggle-hard</strong> GameObjects <span>–</span> so each Toggle object calls the <kbd>PrintNewGroupValue(...)</kbd> method of a C# scripted component called <kbd>RadioButtonManager</kbd> in the <strong>Canvas</strong> GameObject, passing itself as a parameter.</li>
<li>Save and run the <strong>Scene</strong>. Each time you check one of the three radio buttons, the <strong><span class="ScreenTextPACKT">On Value Changed</span></strong> <span>event will fire, and you'll see a new text message printed into the</span> <strong><span class="ScreenTextPACKT">Console</span></strong> <span>window by our script, stating the tag of whichever</span> <strong><span class="ScreenTextPACKT">Toggle</span></strong> <span>(radio button) was just set to true (</span><strong><span class="ScreenTextPACKT">Is On</span></strong><span>).</span></li>
</ol>
<p>By adding a <strong><span class="KeyWordPACKT">Toggle Group</span></strong> component to the <strong><span class="KeyWordPACKT">Canvas</span></strong>, and having each <strong><span class="KeyWordPACKT">Toggle</span></strong> GameObject link to it, the three radio buttons can tell the <strong><span class="KeyWordPACKT">Toggle Group</span></strong> when they have been selected, and the other member of the group are then deselected. If you had several groups of radio buttons in the same scene, one strategy is to add the <strong><span class="KeyWordPACKT">Toggle Group</span></strong> component to one of the <strong>Toggles</strong>, and have all the others link to that one.</p>
<div class="packt_infobox">We store the current radio button value (the last one switched On) in the currentDifficulty class property. Since variables declared outside a method are remembered, we could, for example, add a public method, such as <kbd>GetCurrentDifficulty()</kbd>, which could tell other scripted objects the current value, regardless of how long it's been since the user last changed their option.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating text and image icon UI Dropdown menus</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we created radio-style buttons with a <strong>Toggle Group</strong>, to present the user with a choice of one of many options. Another way to offer a range of choices is with a drop-down menu. Unity provides the <strong><span class="KeyWordPACKT">UI Dropdown</span></strong> control for such menus. In this recipe, we'll offer the user a drop-down choice for the suit of a deck of cards (hearts, clubs, diamonds, or spades).</p>
<p>Note, the <strong>UI Dropdown</strong> created by default includes a scrollable area, in case there isn't space for all the options. We'll learn how to remove the GameObjects and components, to reduce complexity when such a feature is not required.</p>
<p><span>Then we'll learn how to add icon images with each menu option, as shown in the screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0b3d3774-ac65-4916-a0af-a9eceab985e2.png" style="width:11.25em;height:7.67em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the image that you need in a folder named <span class="CodeInTextPACKT">Images</span> in the <kbd><span class="CodeInTextPACKT">02_10</span></kbd> folder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a <strong><span class="KeyWordPACKT">UI Dropdown</span></strong> control GameObject, follow these steps:</p>
<ol>
<li>Create a new Unity 2D project.</li>
<li><span>Add</span> <strong><span class="KeyWordPACKT">UI Dropdown</span></strong> <span>to the scene.</span></li>
</ol>
<ol start="3">
<li>In the <strong>Inspector</strong>, for the <strong><span class="KeyWordPACKT">Dropdown (Script)</span></strong> <span>component, change the list of <strong>Options</strong> from</span> <span class="ScreenTextPACKT"><span class="packt_screen">Option A, Option B,</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">Option C</span></span> <span>to</span> <span class="ScreenTextPACKT"><span class="packt_screen">Hearts, Clubs, Diamonds,</span></span> and <span class="ScreenTextPACKT"><span class="packt_screen">Spades</span></span><span>. You'll need to click the plus (<strong>+</strong>) button to add space for the fourth option of</span> <strong><span class="ScreenTextPACKT">Spades</span></strong><span>.</span></li>
</ol>
<ol start="4">
<li>Add an instance of the C# script class called <kbd><span class="CodeInTextPACKT">DropdownManager</span></kbd> <span>to the</span> <strong><span class="KeyWordPACKT">Dropdown</span></strong> <span>GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

public class DropdownManager : MonoBehaviour  { 
    private Dropdown dropdown; 

    private void Awake() { 
        dropdown = GetComponent&lt;Dropdown&gt;(); 
    } 

    public void PrintNewValue() { 
        int currentValue = dropdown.value; 
        print ("option changed to = " + currentValue); 
   } 
} </pre>
<ol start="5">
<li>With the <strong><span class="KeyWordPACKT">Dropdown</span></strong> GameObject selected, add an <strong><span class="KeyWordPACKT">On Value Changed</span></strong> event to the list of event handlers for the <span class="KeyWordPACKT"><strong>Dropdown</strong> <strong>(Script)</strong></span> component, click on the plus (<strong>+</strong>) button to add an event-handler slot, and drag <strong><span class="KeyWordPACKT">Dropdown</span></strong> into the <strong><span class="KeyWordPACKT">Object</span></strong> slot.</li>
<li>From the <strong><span class="KeyWordPACKT">Function</span></strong> <span>drop-down menu, choose</span> <strong><span class="KeyWordPACKT">DropdownManager</span></strong> <span>and then choose the</span> <kbd><span class="KeyWordPACKT">PrintNewValue</span></kbd> <span>method.</span></li>
<li>Save and run the <strong>Scene</strong>. Each time you change the <strong><span class="KeyWordPACKT">Dropdown</span></strong><span>, the</span> <strong><span class="KeyWordPACKT">On Value Changed</span></strong> <span>event will fire, and you'll see a new text message printed into the <strong>Console</strong> window by our script, stating the</span> <strong><span class="KeyWordPACKT">Integer</span></strong> <span>index of the chosen</span> <strong><span class="KeyWordPACKT">Dropdown</span></strong> <span>value (<kbd>0</kbd> for the first item, <kbd>1</kbd> for the second item and so on):</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/85e24ad8-f22a-49c2-9711-d97c913cfc3b.png" style="width:19.67em;height:13.42em;"/></div>
<ol start="8">
<li>Select the <strong><span class="KeyWordPACKT">Template</span></strong> child GameObject of the <strong><span class="KeyWordPACKT">Dropdown</span></strong> in the <strong><span class="KeyWordPACKT">Project</span></strong> panel, and in its <strong>Rect Transform</strong> reduce its height to <kbd>50</kbd>. When you run the <strong>Scene</strong>, you should see a scrollable area, since not all options fit within the <strong>Template's</strong> height:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2ba11998-516a-47aa-ac44-bf08d8837fa5.png" style="width:12.42em;height:6.58em;"/></div>
<ol start="9">
<li>Delete the <strong><span class="KeyWordPACKT">Scrollbar</span></strong> child of the <strong><span class="KeyWordPACKT">Template</span></strong> GameObject, and remove the <strong><span class="KeyWordPACKT">Scroll Rect (Script)</span></strong> component of the <strong><span class="KeyWordPACKT">Template</span></strong> GameObject. When you run the <strong>Scene</strong> now, you'll only see the first two options (<span class="ScreenTextPACKT"><strong>Hearts</strong> and <strong>Clubs</strong></span>), with no way to access the other two options. When you are sure your <strong><span class="KeyWordPACKT">Template's</span></strong> height is sufficient for all its options, you can safely remove these scrollable options to simplify the GameObjects in your scene.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When you create a Unity <strong><span class="KeyWordPACKT">UI DropDown</span></strong> <span>GameObject, it comes with several components and child GameObjects automatically – <span class="ScreenTextPACKT"><strong>Label</strong>, <strong>Arrow</strong></span>, and <strong><span class="ScreenTextPACKT">Template</span></strong> (and</span> <strong><span class="KeyWordPACKT">ViewPort</span></strong> and <span class="KeyWordPACKT"><strong>Scrollbar</strong>, and so on</span>). <strong>Dropdowns</strong> work by duplicating the <strong><span class="KeyWordPACKT">Template</span></strong> GameObject for each of the <strong><span class="KeyWordPACKT">Options</span></strong> listed in the <strong><span class="KeyWordPACKT">Dropdown (Script)</span></strong> component. Both <strong><span class="KeyWordPACKT">Text</span></strong> and <strong><span class="KeyWordPACKT">Sprite</span></strong> image values can be given for each option. The properties of the <strong><span class="KeyWordPACKT">Template</span></strong> GameObject are used to control the visual style and behavior of the <strong><span class="KeyWordPACKT">Dropdown's</span></strong> thousands of possible settings.</p>
<p>You first replaced the default options (<span class="packt_screen">Option A, Option B</span>, and so on) in the <strong><span class="KeyWordPACKT">Dropdown (Script)</span></strong> component. You then created a C# script class, <kbd><span class="CodeInTextPACKT">DropdownManager</span></kbd>, that when attached to your <strong><span class="KeyWordPACKT">Dropdown</span></strong>, and having its <kbd><span class="KeyWordPACKT">PrintNewValue</span></kbd> method registered for <strong>On Value Changed</strong> events, means that we can see the <strong><span class="KeyWordPACKT">Integer</span></strong> index of the option each time the user changes their choice. Item index values start counting at zero (as with many computing items), so <kbd>0</kbd> for the first item, <kbd>1</kbd> for the second item, and so on.</p>
<p>Since the default <strong><span class="KeyWordPACKT">Dropdown</span></strong> GameObject created includes a <strong><span class="KeyWordPACKT">Scroll Rect (Script)</span></strong> component and a <strong><span class="KeyWordPACKT">Scrollbar</span></strong> child GameObject, when you reduced the height of the <strong>Template</strong>, you could still scroll through the options. You then removed these items so that your <strong>Dropdown</strong> had no scrolling feature anymore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding images to a Dropdown control</h1>
                </header>
            
            <article>
                
<p>There are two pairs of items Unity uses to manage how <strong><span class="KeyWordPACKT">Text</span></strong> and <strong><span class="KeyWordPACKT">Images</span></strong> are displayed:</p>
<ul>
<li>The <strong><span class="KeyWordPACKT">Caption Text</span></strong> and <strong><span class="KeyWordPACKT">Image</span></strong> GameObjects are used to control how the currently-selected item for the <strong><span class="KeyWordPACKT">Dropdown</span></strong> is displayed <span>–</span> the part of the <strong><span class="KeyWordPACKT">Dropdown</span></strong> we always see, whether the <strong><span class="KeyWordPACKT">Dropdown</span></strong> is being interacted with or not.</li>
<li>The <span class="KeyWordPACKT"><strong>Item Text</strong> and <strong>Image</strong></span> GameObjects are part of the <strong><span class="KeyWordPACKT">Template</span></strong> GameObject, and they define how each option is displayed as a row when the <strong><span class="KeyWordPACKT">Dropdown</span></strong> menu items are being displayed <span>–</span> the rows displayed when the user is actively working with the <strong><span class="KeyWordPACKT">Dropdown</span></strong> GameObject.</li>
</ul>
<p>So we have to add an <strong><span class="KeyWordPACKT">Image</span></strong> in two places (<strong><span class="KeyWordPACKT">Caption</span></strong> and <span class="KeyWordPACKT"><strong>Template</strong> Item</span>), in order to get a <strong><span class="KeyWordPACKT">Dropdown</span></strong> working fully with image icons for each option.</p>
<p>To add a <strong>Sprite</strong> image with each <strong>Text</strong> item in the <strong>Dropdown</strong>, do the following:</p>
<ol>
<li>Import the provided <kbd><span class="CodeInTextPACKT">Images</span></kbd> <span>folder.</span></li>
<li>In the <strong>Inspector</strong>, for the <strong><span class="KeyWordPACKT">Dropdown (Script)</span></strong> <span>component, for each item in the list of <strong>Options</strong></span> <span class="ScreenTextPACKT"><strong>Hearts</strong>, <strong>Clubs</strong>, <strong>Diamonds</strong>, and <strong>Spades</strong>,</span> <span>drag</span> <span>the associated <strong>Sprite</strong> image from the <kbd><span class="KeyWordPACKT">card_suits</span></kbd> folder in the <strong><span class="KeyWordPACKT">Project</span></strong> panel (</span><kbd><span class="KeyWordPACKT">hearts.png</span></kbd> <span>for</span> <span class="KeyWordPACKT"><strong>Hearts</strong>, and so on</span><span>).</span></li>
<li>Add a <strong><span class="KeyWordPACKT">UI Image</span></strong> <span>in the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel, and child this <strong>Image</strong> to the <strong>Dropdown</strong> GameObject</span><span>.</span></li>
<li>Drag the <kbd><span class="ScreenTextPACKT">hearts.png</span></kbd> <span>Image from the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel into the</span> <strong><span class="KeyWordPACKT">Source Image</span></strong> <span>property of the</span> <strong><span class="KeyWordPACKT">Image (Script)</span></strong> <span>for the</span> <strong><span class="KeyWordPACKT">Image</span></strong> <span>GameObject. Size this Image to <kbd>25</kbd> x <kbd>25</kbd> in the <strong>Rect Transform</strong>, and drag it over the letter "<strong>H</strong>" in "<strong>Hearts</strong>" in the <strong>Label</strong> GameObject.</span></li>
<li>Move the <strong><span class="KeyWordPACKT">Label</span></strong> <span>GameObject to the right of the hearts image.</span></li>
<li>With <strong><span class="KeyWordPACKT">Dropdown</span></strong> <span>Selected in the <strong>Project</strong> panel, drag the</span> <strong><span class="KeyWordPACKT">Image</span></strong> <span>GameObject into the</span> <span class="KeyWordPACKT"><strong>Caption Image</strong></span> <span>property of the</span> <strong><span class="KeyWordPACKT">Dropdown (Script)</span></strong> <span>component.</span></li>
<li>Enable the <strong><span class="KeyWordPACKT">Template</span></strong> <span>GameObject (usually it is disabled).</span></li>
</ol>
<ol start="8">
<li>Duplicate the <strong><span class="KeyWordPACKT">Image</span></strong> <span>GameObject child of</span> <strong><span class="KeyWordPACKT">Dropdown</span></strong><span>, and name the copy</span> <strong><span class="KeyWordPACKT">Item Image</span></strong><span>. Child this <strong>Image</strong> in between the</span> <span class="KeyWordPACKT"><strong>Item</strong> <strong>Background</strong></span> <span>and</span> <strong><span class="KeyWordPACKT">Item Checkmark</span></strong> <span>GameObjects that are in</span> <strong><span class="KeyWordPACKT">Dropdown-Template-Content-Item</span></strong> <span>(the <strong>Item Image</strong> needs to appear below the white <strong>Item Background Image</strong>, otherwise it will be covered by the background and not be visible).</span></li>
<li>Since items in the <strong><span class="KeyWordPACKT">Dropdown</span></strong> <span>are slightly smaller, resize</span> <span class="KeyWordPACKT">Item Image</span> <span>to be <kbd>20</kbd> x <kbd>20</kbd> in its</span> <strong><span class="KeyWordPACKT">Rect Transform</span></strong><span>.</span></li>
<li>Position <strong><span class="KeyWordPACKT">Item Image</span></strong> <span>over the "<strong>O</strong>" of "<strong>Option A</strong>" of</span> <strong><span class="KeyWordPACKT">Item Text</span></strong><span>, and then move</span> <strong><span class="KeyWordPACKT">Item Text</span></strong> <span>to the right so that the icon and text are not on top of each other.</span></li>
<li>With <strong><span class="KeyWordPACKT">Dropdown</span></strong> <span>Selected in the <strong>Project</strong> panel, drag the</span> <strong><span class="KeyWordPACKT">Item Image</span></strong> <span>GameObject into the</span> <strong><span class="KeyWordPACKT">Item Image</span></strong> <span>property of the</span> <span class="KeyWordPACKT">D<strong>ropdown (Script)</strong></span> <span>component:</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7688bad7-9deb-4c0b-a0b7-3ad351c1acaa.png"/></div>
<ol start="12">
<li style="padding-left: 30px">Disable the <strong>Template</strong> GameObject, then run the scene to see your <strong><span class="KeyWordPACKT">Dropdown</span></strong> with icon images for each menu option.</li>
</ol>
<div class="packt_infobox">Unity <span class="KeyWordPACKT">UI Dropdowns</span> are powerful interface components <span>–</span> learn more about these controls from the Unity Manual at <a href="https://docs.unity3d.com/Manual/script-Dropdown.html"><span class="URLPACKT">https://docs.unity3d.com/Manual/script-Dropdown.html.</span></a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying a radar to indicate the relative locations of objects</h1>
                </header>
            
            <article>
                
<p>A radar displays the locations of other objects relative to the player, usually based on a circular display, where the center represents the player, and each graphical blip indicates how far away and what relative direction objects are to the player. Sophisticated radar displays will display different categories of objects with different colored or shaped blip icons.</p>
<p>In the screenshot, we can see two red square blips, indicating the relative position of the two red cube GameObjects tagged <span class="CodeInTextPACKT">Cube</span> near the player, and a yellow circle blip indicating the relative position of the yellow sphere GameObject tagged <span class="CodeInTextPACKT">Sphere</span>. The green circle radar background image gives the impression of an aircraft control tower radar or something similar:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/c0653d19-56ae-44d5-87ab-51d345421ca2.png"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we have prepared the images that you need in a folder named <span class="CodeInTextPACKT">Images</span> in <kbd><span class="CodeInTextPACKT">02_11</span></kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To create a radar to show the relative positions of the objects, follow these steps:</p>
<ol>
<li>Create a new 3D project, with a textured <strong><span class="KeyWordPACKT">Terrain</span></strong>. Import the <strong>Environment</strong> standard asset package contents, by choosing menu: <span class="ScreenTextPACKT"><span class="packt_screen">Assets | Import Package | Environment</span>.</span>
<ol>
<li><span>Create a terrain by navigating to the</span> <span class="ScreenTextPACKT"><span class="packt_screen">Create | 3D Object | Terrain</span></span> <span>menu.</span></li>
<li class="CDPAlignLeft CDPAlign"><span>Size the <strong>Terrain</strong></span> <span class="ScreenTextPACKT">20 x 20</span><span>, positioned at</span> <kbd><span class="ScreenTextPACKT">(-10, 0, -10)</span></kbd> <span>- so that its center is at <kbd><span class="ScreenTextPACKT">(0, 0, 0)</span></kbd>:</span><span><br/></span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/53fd93f2-6896-4a29-8a4c-b4ff879ed5a9.png" style="width:22.17em;height:22.75em;"/></p>
<ol start="3">
<li>Texture paint your <strong>T</strong><strong>errain</strong> with the <strong><span class="ScreenTextPACKT">SandA</span></strong><strong><span class="ScreenTextPACKT">lbedo</span></strong> option, as shown in the screenshot. You need to select the <strong><span class="KeyWordPACKT">Paintbrush</span></strong> tool in the <strong><span class="KeyWordPACKT">Terrain</span></strong> component, then click the <strong><span class="KeyWordPACKT">Edit Textures</span></strong> <span>button, and select the</span> <strong><span class="ScreenTextPACKT">SandAlbedo</span></strong> <span>texture from the imported</span> <strong><span class="KeyWordPACKT">Environme</span></strong><strong><span class="KeyWordPACKT">nt</span></strong> <span>assets:</span></li>
</ol>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d917b712-db0a-4e2e-a6ae-ef16ce9b5d2f.png" style="width:22.00em;height:20.00em;"/></p>
<ol start="2">
<li>Import the provided folder <kbd><span class="CodeInTextPACKT">Images</span></kbd>.</li>
<li>Create a <span class="KeyWordPACKT">3D Cube</span> <span>GameObject at</span> <strong><span class="KeyWordPACKT">Position</span></strong> <kbd><span class="CodeInTextPACKT">(2, 0.5, 2)</span></kbd><span>. Create a</span> <span class="KeyWordPACKT">Tag</span> <kbd><span class="ScreenTextPACKT">Cube</span></kbd> <span>and tag this GameObject with this new tag. Texture this GameObject with the red image called <kbd><span class="ScreenTextPACKT">icon32_square_yellow</span></kbd>, by dragging image <kbd><span class="ScreenTextPACKT">icon32_square_yellow</span></kbd> from the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel over this GameObject in the</span> <strong><span class="KeyWordPACKT">Hierarchy</span></strong> <span>panel.</span></li>
<li>Duplicate the <strong>cube</strong> GameObject, and move this new cube to <strong>Position</strong> <kbd><span class="CodeInTextPACKT">(6, 0.5, 2)</span></kbd><span>.</span></li>
<li>Create a 3D Sphere GameObject at Position <kbd><span class="CodeInTextPACKT">(0, 0.5, 4)</span></kbd><span>. Create a</span> <span class="KeyWordPACKT">Tag</span> <span>with the name</span> <kbd><span class="ScreenTextPACKT">Sphere</span></kbd> <span>and tag this GameObject with this new tag. Texture this GameObject with the red image called <kbd><span class="ScreenTextPACKT">icon32_square_yellow</span></kbd>.</span></li>
<li>Import the <strong><span class="ScreenTextPACKT">Characters</span></strong> <span>standard asset package into your project.</span></li>
<li>From the <kbd><span class="ScreenTextPACKT">Standard Assets</span></kbd> <span>folder in the</span> <strong><span class="ScreenTextPACKT">Project</span></strong> <span>panel, drag the prefab</span> <kbd><span class="ScreenTextPACKT">ThirdPersonController</span></kbd> <span>into the <strong>Scene</strong> and position it at <kbd>(0, 1, 0)</kbd>.</span></li>
<li>Tag this <strong><span class="ScreenTextPACKT">ThirdPersonController</span></strong> GameObject as <kbd><span class="ScreenTextPACKT">Player</span></kbd> (selecting this built-in tag means that the camera we'll add will automatically track this player object, without us having to manually set the <span class="KeyWordPACKT">target</span> <span>for the camera).</span></li>
<li>Remove the <strong><span class="ScreenTextPACKT">Main Camera</span></strong> <span>GameObject.</span></li>
<li>Import the <strong><span class="ScreenTextPACKT">Cameras</span></strong> <span>standard asset package into your project.</span></li>
<li>From the <kbd><span class="ScreenTextPACKT">Standard Assets</span></kbd> <span>folder in the</span> <strong><span class="ScreenTextPACKT">Project</span></strong> <span>panel, drag the prefab</span> <kbd><span class="ScreenTextPACKT">Multi-PurposeCameraRig</span></kbd> <span>into the <strong>Scene</strong>.</span></li>
<li><span>In the <strong><span class="ScreenTextPACKT">Hierarchy</span></strong> panel, add a <span class="packt_screen"><span class="ScreenTextPACKT">UI</span> | <span class="ScreenTextPACKT">RawImage</span></span> GameObject to the scene named <strong><span class="ScreenTextPACKT">RawImage-radar</span></strong>.</span></li>
</ol>
<ol start="13">
<li>Ensure that <span>the <strong><span class="ScreenTextPACKT">RawImage-radar</span></strong> GameObject is selected in the</span> <strong><span class="KeyWordPACKT">Hierarchy</span></strong> panel. From the <span class="CodeInTextPACKT"><kbd>Images</kbd> folder in the <strong>Project</strong> panel</span>, drag the <kbd><span class="CodeInTextPACKT">radarBackground</span></kbd> <span>image into the <strong><span class="ScreenTextPACKT">Raw Image (Script)</span></strong> public property</span> <strong><span class="KeyWordPACKT">Texture</span></strong>.</li>
<li>In <span class="KeyWordPACKT"><strong>Rect Transform</strong>,</span> <span>position <strong><span class="ScreenTextPACKT">RawImage-radar</span></strong> at the top-left using the <strong><span class="ScreenTextPACKT">Anchor Presets</span></strong> item. Then set both width and height to <kbd>200</kbd> pixels.</span></li>
<li>Create a new <strong><span class="KeyWordPACKT">UI RawImage</span></strong> <span>named <strong><span class="ScreenTextPACKT">RawImage-blip</span></strong>. Assign it the</span> <kbd><span class="CodeInTextPACKT">yellowCircleBlackBorder</span></kbd> T<span>exture image file from the <strong>Project</strong> panel. In the</span> <strong><span class="KeyWordPACKT">Project</span></strong> <span>panel, create a new empty prefab asset file named <kbd><span class="ScreenTextPACKT">blip-sphere</span></kbd>, and drag the <strong><span class="ScreenTextPACKT">RawImage-blip</span></strong> GameObject into this prefab to store all its properties.</span></li>
<li>Set the texture of GameObject <strong><span class="ScreenTextPACKT">RawImage-blip</span></strong> <span>to</span> <kbd><span class="CodeInTextPACKT">redSquareBlackBorder</span></kbd><span> from the <strong>Project</strong> panel. In the <strong>Project</strong> panel, create a new empty prefab asset file named <kbd><span class="ScreenTextPACKT">blip-cube</span></kbd>, and drag the <strong><span class="ScreenTextPACKT">RawImage-blip</span></strong> GameObject into this prefab to store all its properties.</span></li>
<li>Delete the <strong><span class="ScreenTextPACKT">RawImage-blip</span></strong> GameObject from the <strong><span class="KeyWordPACKT">Hierarchy</span></strong><span>.</span></li>
<li>Create a C# script class called <span class="CodeInTextPACKT"><kbd>Radar</kbd>,</span> containing the following code, and add an instance as a <span>scripted component to the <strong><span class="ScreenTextPACKT">RawImage-radar</span></strong> GameObject:</span></li>
</ol>
<pre style="padding-left: 60px">using UnityEngine; 
using UnityEngine.UI; 

public class Radar : MonoBehaviour { 
   public float insideRadarDistance = 20; 
   public float blipSizePercentage = 5; 
   public GameObject rawImageBlipCube; 
   public GameObject rawImageBlipSphere; 
   private RawImage rawImageRadarBackground; 
   private Transform playerTransform; 
   private float radarWidth; 
   private float radarHeight; 
   private float blipHeight; 
   private float blipWidth; 

   void Start() { 
         rawImageRadarBackground = GetComponent&lt;RawImage&gt;(); 
         playerTransform = GameObject.FindGameObjectWithTag("Player").transform; 
         radarWidth = rawImageRadarBackground.rectTransform.rect.width; 
         radarHeight = rawImageRadarBackground.rectTransform.rect.height; 
         blipHeight = radarHeight * blipSizePercentage / 100; 
         blipWidth = radarWidth * blipSizePercentage / 100; 
   } 

   void Update() { 
         RemoveAllBlips(); 
         FindAndDisplayBlipsForTag("Cube", rawImageBlipCube); 
         FindAndDisplayBlipsForTag("Sphere", rawImageBlipSphere); 
   } 

   private void FindAndDisplayBlipsForTag(string tag, GameObject prefabBlip) { 
         Vector3 playerPos = playerTransform.position; 
         GameObject[] targets = GameObject.FindGameObjectsWithTag(tag); 
         foreach (GameObject target in targets) { 
               Vector3 targetPos = target.transform.position; 
               float distanceToTarget = Vector3.Distance(targetPos, playerPos); 
               if ((distanceToTarget &lt;= insideRadarDistance)) 
                CalculateBlipPositionAndDrawBlip (playerPos, targetPos, prefabBlip); 
         } 
   }  

    private void CalculateBlipPositionAndDrawBlip (Vector3 playerPos, Vector3 targetPos, GameObject prefabBlip) { 
         Vector3 normalisedTargetPosition = NormaizedPosition(playerPos, targetPos); 
         Vector2 blipPosition = CalculateBlipPosition(normalisedTargetPosition); 
         DrawBlip(blipPosition, prefabBlip); 
   } 

   private void RemoveAllBlips() { 
         GameObject[] blips = GameObject.FindGameObjectsWithTag("Blip"); 
         foreach (GameObject blip in blips) 
               Destroy(blip); 
   } 

   private Vector3 NormaizedPosition(Vector3 playerPos, Vector3 targetPos) { 
         float normalisedyTargetX = (targetPos.x - playerPos.x) / insideRadarDistance; 
         float normalisedyTargetZ = (targetPos.z - playerPos.z) / insideRadarDistance; 
         return new Vector3(normalisedyTargetX, 0, normalisedyTargetZ); 
   } 

   private Vector2 CalculateBlipPosition(Vector3 targetPos) { 
         float angleToTarget = Mathf.Atan2(targetPos.x, targetPos.z) * Mathf.Rad2Deg; 
         float anglePlayer = playerTransform.eulerAngles.y; 
         float angleRadarDegrees = angleToTarget - anglePlayer - 90; 
         float normalizedDistanceToTarget = targetPos.magnitude; 
         float angleRadians = angleRadarDegrees * Mathf.Deg2Rad; 
         float blipX = normalizedDistanceToTarget * Mathf.Cos(angleRadians); 
         float blipY = normalizedDistanceToTarget * Mathf.Sin(angleRadians); 
         blipX *= radarWidth / 2; 
         blipY *= radarHeight / 2; 
         blipX += radarWidth / 2; 
         blipY += radarHeight / 2; 
         return new Vector2(blipX, blipY); 
   } 

   private void DrawBlip(Vector2 pos, GameObject blipPrefab) { 
         GameObject blipGO = (GameObject)Instantiate(blipPrefab); 
         blipGO.transform.SetParent(transform.parent); 
         RectTransform rt = blipGO.GetComponent&lt;RectTransform&gt;(); 
         rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, pos.x, blipWidth); 
         rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, pos.y, blipHeight); 
   } 
} </pre>
<p>Run your game. You will see two red squares and one yellow circle on the radar, showing the relative positions of the red cubes and yellow sphere. If you move too far away, the blips will disappear.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>A radar background is displayed on the screen. The center of this circular image represents the position of the player's character. You have created two prefabs; one for red square images to represent each red cube found within the radar distance, and one for yellow circles to represent yellow sphere GameObjects.</p>
<p>The <kbd><span class="CodeInTextPACKT">Radar</span></kbd> C# script class has been added to the radar <strong>UI Image</strong> GameObject. This class defines four public variables:</p>
<ul>
<li><strong><span class="CodeInTextPACKT">insideRadarDistance</span></strong>: This value defines the maximum distance in the scene that an object may be from the player to still be included on the radar (objects further than this distance will not be displayed on the radar).</li>
<li><strong><span class="CodeInTextPACKT">blipSizePercentage</span></strong><span>: This public variable allows the developer to decide how large each blip will be, as a proportion of the radar's image.</span></li>
<li><strong><span class="CodeInTextPACKT">rawImageBlipCube</span></strong> <span>and</span> <strong><span class="CodeInTextPACKT">rawImageBlipSphere</span></strong><span>: These are references to the prefab UI <span class="ScreenTextPACKT">RawImages</span> that are to be used to visually indicate the relative distance and position of cubes and spheres on the radar.</span></li>
</ul>
<p>Since there is a lot happening in the code for this recipe, each method will be described in its own section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Start() method</h1>
                </header>
            
            <article>
                
<p>The <kbd><span class="CodeInTextPACKT">Start()</span></kbd> <span>method first caches a reference to the <strong>Raw Image</strong> of the radar background image. Then it caches a reference to the <strong><span class="ScreenTextPACKT">Transform</span></strong> component of the player's character (tagged as <kbd><span class="ScreenTextPACKT">Player</span></kbd>). This allows the scripted object to know about the position of the Player's character in each frame. Next, the width and height of the radar image are cached – so, the relative positions for blips can be</span> calculated, based on the size of this background radar image. Finally, the size of each blip (<kbd>blipWidth</kbd> and <kbd>blipHeight</kbd>) is calculated, using the <kbd><span class="CodeInTextPACKT">blipSizePercentage</span></kbd> public variable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Update() method</h1>
                </header>
            
            <article>
                
<p>The <kbd><span class="CodeInTextPACKT">Update()</span></kbd> method calls the <kbd><span class="CodeInTextPACKT">RemoveAllBlips()</span></kbd> <span>method, which removes any old <strong><span class="ScreenTextPACKT">RawImage</span></strong> UI GameObjects of cubes and spheres that might currently be displayed. If we didn't remove old blips before creating the new ones, then you'd see "tails" behind each blip as new ones are created in different positions – which could actually be an interesting effect.</span></p>
<p>Next, the <span class="CodeInTextPACKT"><kbd>FindAndDisplayBlipsForTag(...)</kbd> </span><span>method is called twice. First, for the objects tagged <kbd><span class="ScreenTextPACKT">Cube</span></kbd>, to be represented on the radar with the</span> <kbd><span class="CodeInTextPACKT">rawImageBlipCube</span></kbd> <span>prefab and then again for objects tagged <kbd><span class="ScreenTextPACKT">Sphere</span></kbd>, to be represented on the radar with the</span> <kbd><span class="CodeInTextPACKT">rawImageBlipSphere</span></kbd> <span>prefab. As you might expect, most of the hard work for the radar is to be performed by the</span> <kbd><span class="CodeInTextPACKT">FindAndDisplayBlipsForTag(...)</span></kbd> method.</p>
<div class="packt_infobox">This code is a simple approach to creating a radar. It is very inefficient to make repeated calls to <kbd>FindGameObjectWithTag("Blip")</kbd> for every frame from the <kbd>Update()</kbd> method. In a real game, it would be much better to cache all created blips in something such as a <kbd>List</kbd> or <kbd>ArrayList</kbd>, and then simply loop through that list each time.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The FindAndDisplayBlipsForTag(...) method</h1>
                </header>
            
            <article>
                
<p><span>This method inputs two parameters: the string tag for the objects to be searched for, and a reference to the <kbd><span class="ScreenTextPACKT">RawImage</span></kbd> prefab to be displayed on the radar for any such tagged objects within the range.</span></p>
<p>First, the current position of the player's character is retrieved from the cached player <strong>Transform</strong> variable. Next, an array is constructed, referring to all GameObjects in the scene that have the provided tag. This array of GameObjects is looped through, and for each GameObject, the following actions are performed:</p>
<ul>
<li>The position of the target <span class="CodeInTextPACKT">GameObject</span> is retrieved.</li>
<li>The distance from this target position to the player's position is calculated.</li>
<li>If this distance is within the range (less than or equal to <kbd><span class="CodeInTextPACKT">insideRadarDistance</span></kbd><span>), then the</span> <span class="CodeInTextPACKT"><kbd>CalculateBlipPositionAndDrawBlip(...)</kbd></span> method <span>is called.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CalculateBlipPositionAndDrawBlip (...) method</h1>
                </header>
            
            <article>
                
<p>This method inputs three parameters: the position of the player, the position of the target, and a reference to the prefab of the blip to be drawn.</p>
<p>Three steps are now required to get the blip for this object to appear on the radar:</p>
<ol>
<li>The normalized position of the target is calculated by calling <kbd><span class="CodeInTextPACKT">NormalizedPosition(...)</span></kbd></li>
<li>The position of the blip on the radar is calculated from this normalized position by calling <kbd><span class="CodeInTextPACKT">CalculateBlipPosition(...)</span></kbd></li>
<li>The <kbd><span class="ScreenTextPACKT">RawImage</span></kbd> <span>blip is displayed by calling</span> <kbd><span class="CodeInTextPACKT">DrawBlip(...)</span></kbd> <span>and passing the blip position and the reference to the</span> <span class="ScreenTextPACKT">RawImage</span> <span>prefab that is to be created there</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The NormalisedPosition(...) method</h1>
                </header>
            
            <article>
                
<p>The <kbd><span class="CodeInTextPACKT">NormalizedPosition(...)</span></kbd> method inputs the player's character position and the target <span class="CodeInTextPACKT">GameObject</span> <span>position. It has the goal of outputting the relative position of the target to the player, returning a <strong>Vector3</strong> object with a triplet of <span class="ItalicsPACKT">X</span>, <span class="ItalicsPACKT">Y</span>, and <span class="ItalicsPACKT">Z</span> values. Note that since the radar is only 2D, we ignore the <span class="ItalicsPACKT">Y-</span>value of target GameObjects. So, the <span class="ItalicsPACKT">Y-</span>value of the <strong>Vector3</strong> object returned by this method will always be <kbd>0</kbd>. So, for example, if a target was at exactly the same location as the player, the returned <span class="ItalicsPACKT">X</span>, <span class="ItalicsPACKT">Y</span>, <span class="ItalicsPACKT">Z</span> <strong>Vector3</strong> object would be <kbd>(0, 0, 0)</kbd>.</span></p>
<p>Since we know that the target <span class="CodeInTextPACKT">GameObject</span> is no further from the player's character than <kbd><span class="CodeInTextPACKT">insideRadarDistance</span></kbd><span>, we can calculate a value in the <kbd>-1 ... 0 ... +1</kbd> range for the <span class="ItalicsPACKT">X</span> and <span class="ItalicsPACKT">Z</span> axis by finding the distance on each axis from the target to the player, and then dividing it by</span> <kbd><span class="CodeInTextPACKT">insideRadarDistance</span></kbd><span>. An <span class="ItalicsPACKT">X</span>-value of <kbd>-1</kbd> means that the target is fully to the left of the player (at a distance that is equal to</span> <span class="CodeInTextPACKT">insideRadarDistance</span><span>), and +1 means it is fully to the right. A value of 0 means that the target has the same <span class="ItalicsPACKT">X</span> position as the player's character. Likewise, for <kbd>-1 ... 0 ... +1</kbd> values in the <span class="ItalicsPACKT">Z-axis</span> (this axis represents how far, in front or behind us an object, is located, which will be mapped to the vertical axis in our radar).</span></p>
<p><span>Finally, this method constructs and returns a new <strong>Vector3</strong> object, with the calculated <span class="ItalicsPACKT">X</span> and <span class="ItalicsPACKT">Z</span> normalized values, and a <span class="ItalicsPACKT">Y</span>-value of zero.</span></p>
<div class="packt_infobox"><span class="KeyWordPACKT"><strong>The normalized position</strong><br/>
<br/></span> A normalized value is one that has been simplified in some way, so the context has been abstracted away. In this recipe, what we are interested in is where an object is relative to the player. So, our normal form is to get a value of the X and Z position of a target in the <kbd>-1</kbd> to <kbd>+1</kbd> range for each axis. Since we are only considering GameObject within our <kbd>insideRadarDistance</kbd> value, we can map these normalized target positions directly onto the location of the radar image in our UI.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CalculateBlipPosition(...) method</h1>
                </header>
            
            <article>
                
<p>First, we calculate <kbd><span class="CodeInTextPACKT">angleToTarget</span></kbd>: the angle from <kbd>(0, 0, 0)</kbd> to our normalized target position.</p>
<p>Next, we calculate <kbd><span class="CodeInTextPACKT">anglePlayer</span></kbd><span>: the angle the player's character is facing. This recipe makes use of the <span class="KeyWordPACKT">yaw</span> angle of the rotation, which is the rotation about the <span class="ItalicsPACKT">Y-axis, </span>that is, the direction that a character controller is facing. This can be found in the <span class="ItalicsPACKT">Y</span> component of a GameObject's</span> <kbd><span class="CodeInTextPACKT">eulerAngles</span></kbd> component of its transform. You can imagine looking from above and down at the character controller, and see what direction they are facing <span>–</span> this is what we are trying to display graphically with the radar.</p>
<p>Our desired radar angle (the <kbd><span class="CodeInTextPACKT">angleRadarDegrees</span></kbd> <span>variable) is calculated by subtracting the player's direction angle from the angle between the target and player, since a radar displays the relative angle from the direction that the player is facing, to the target object. In mathematics, an angle of zero indicates an <span class="ItalicsPACKT">east</span> direction. To correct this, we need to also subtract <kbd>90</kbd> degrees from the angle.</span></p>
<p>The angle is then converted into radians, since this is required for the Unity trigonometry methods. We then multiply the <kbd><span class="CodeInTextPACKT">Sin()</span></kbd> and <kbd><span class="CodeInTextPACKT">Cos()</span></kbd> <span>results by our normalized distances to calculate the <span class="ItalicsPACKT">X</span> and <span class="ItalicsPACKT">Y</span> values, respectively (see the following diagram):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0a325868-bf9e-4c56-8f79-8b4bd53b460d.png" style="width:24.33em;height:19.92em;"/></p>
<div class="packt_infobox">In this figure, alpha is the angle between player and target object, "a" is the adjacent side, "h" is the hypotenuse, and "o" is the side opposite the angle.</div>
<p>Our final position values need to be expressed as pixel lengths, relative to the center of the radar. So, we multiply our <kbd><span class="CodeInTextPACKT">blipX</span></kbd> and <kbd><span class="CodeInTextPACKT">blipY</span></kbd> values by half the width and the height of the radar; note that we multiply only with half the width, since these values are relative to the center of the radar. We then add half the width and height of the radar image to the <span class="CodeInTextPACKT">blipX</span>/<span class="CodeInTextPACKT">Y</span> values. So, these values are now positioned relative to the center.</p>
<p><span>Finally, a new <strong><span class="ScreenTextPACKT">Vector2</span></strong> object is created and returned, passing back these final calculated <span class="ItalicsPACKT">X</span> and <span class="ItalicsPACKT">Y</span> pixel values for the position of our blip icon.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The DrawBlip() method</h1>
                </header>
            
            <article>
                
<p>The <kbd><span class="CodeInTextPACKT">DrawBlip()</span></kbd> method takes the input parameters of the position of the blip (as a <strong><span class="CodeInTextPACKT">Vector2</span></strong> <span><span class="ItalicsPACKT">X</span>, <span class="ItalicsPACKT">Y</span> pair), and the reference to the <strong><span class="ScreenTextPACKT">RawImage</span></strong> prefab to be created at that location on the radar.</span></p>
<p>A new GameObject is created (<span class="KeyWordPACKT">Instantiated</span><span>) from the prefab, and is parented to the <strong>radar</strong> GameObject (of which the scripted object is also a component). A reference is retrieved from the <strong><span class="ScreenTextPACKT">Rect Transform</span></strong> of the new <strong><span class="ScreenTextPACKT">RawImage</span></strong> GameObject that has been created for the blip. Calls to the Unity <strong><span class="ScreenTextPACKT">RectTransform</span></strong> method</span> <br/>
<span class="CodeInTextPACKT"><kbd>SetInsetAndSizeFromParentEdge(...)</kbd></span>  <span>result in the blip GameObject being positioned at the provided horizontal and vertical locations over the radar image, regardless of where in the <span class="ScreenTextPACKT">Game</span> panel the background radar image has been located.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>There are some details you don't want to miss.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adapt for object heights and opaque obstacles</h1>
                </header>
            
            <article>
                
<p>This radar script scans 360 degrees all around the player, and only considers straight line distances in the X-Z plane. So, the distances in this radar are not affected by any height difference between the player and target GameObjects. The script can be adapted to ignore targets whose height is more than some threshold different to the player's height.</p>
<p><span>Also, as presented, this recipe radar <span class="ItalicsPACKT">sees</span> through</span> <em>everything</em>, even if there are obstacles between the player and the target. The recipe can be extended to not show obscured targets through the use of the <span class="KeyWordPACKT">Ray Casting</span> techniques. See the Unity scripting reference for more details about ray-casting: <a href="http://docs.unity3d.com/ScriptReference/Physics.Raycast.html"><span class="URLPACKT">http://docs.unity3d.com/ScriptReference/Physics.Raycast.html</span></a>.</p>


            </article>

            
        </section>
    </body></html>