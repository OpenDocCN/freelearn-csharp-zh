["```cs\n<TextBlock Text=\"Name:\" Style=\"{StaticResource\n  AttributeTitleStyle}\"/>\n```", "```cs\n_entryList = from entry in _entryList\n             where entry.Lastname.StartsWith(\"J\")\n             Lastname starting with J. By using the Remove method and not changing the entire collection, the CollectionChanged events are preserved:\n\n```", "```cs\n\n\t\t\tFinally, it’s best not to use observable collections for lists that do not change. The extra overhead they bring is not needed for static data. Bind to an `IList<T>`, `IEnumerable<T>`, or better yet, a traditional array of items instead. Check out this *C# 101* video to learn when to leverage arrays, lists, and collections in .NET: [https://learn.microsoft.com/shows/csharp-101/csharp-arrays-list-and-collections](https://learn.microsoft.com/shows/csharp-101/csharp-arrays-list-and-collections).\n\t\t\tUsing the XAML Binding Failures window\n\t\t\tVisual Studio 2019 version 16.7 introduced the new `Binding`, not `x:Bind`, as those issues are checked and caught by the compiler. Clicking the red indicator will take you to the **XAML Binding Failures** window while debugging. Binding failures were always available in the **Output** window while debugging, but they could be difficult to find. The new, dedicated window provides sorting and searching. Similar failures are also grouped to make it easy to address related items together:\n\t\t\t![Figure 11.9 – Checking the in-app toolbar﻿ for binding failures](img/B20908_11_09.jpg)\n\n\t\t\tFigure 11.9 – Checking the in-app toolbar for binding failures\n\t\t\tLet’s give it a try. Open the **XamlDebugging** solution from the GitHub repository for this chapter and follow along with these steps:\n\n\t\t\t\t1.  Open `Window` contains a `StackPanel` with two `TextBox` child elements:\n\n    ```", "```cs\n\n    `DataContext` does not exist, so what do you think will be reported in the binding failures? Let’s find out!\n\n    \t\t\t\t2.  Run the application and look at the in-app toolbar. There is an indication that we have one binding failure.\n\t\t\t\t3.  Click the red indicator on the toolbar to open the **XAML Binding Failures** window in Visual Studio:\n\n\t\t\t![Figure 11.10 – The XAML Binding Failures window](img/B20908_11_010.jpg)\n\n\t\t\tFigure 11.10 – The XAML Binding Failures window\n\t\t\tThe **Description** text in the window tells us **BindingExpression path error: ‘SomeText’ property not found on ‘Windows.Foundation.IReference`1<String>’**. This is useful information. It would be more useful if there was something telling us directly that the data context itself is not valid. However, if you had a dozen controls using this data context, and all the bindings were failing, it would become clear that there is a problem with the data context and not the individual bindings.\n\n\t\t\t\t1.  Let’s make sure the other binding is working correctly. Enter some text into the first `TextBox`:\n\n\t\t\t![Figure 11.11 – Binding Te﻿xtBoxes with ElementName](img/B20908_11_011.jpg)\n\n\t\t\tFigure 11.11 – Binding TextBoxes with ElementName\n\t\t\tThe text you enter should be duplicated in the second `TextBox` as your type. Our binding to `ElementName` is working as expected.\n\t\t\tI will leave fixing the data source as an exercise for you. Add a valid data source to the code behind it and see whether the binding error is cleared up.\n\t\t\tNow, let’s explore a few other XAML debugging tools available from the in-app toolbar.\n\t\t\tDebugging live data with Live Visual Tree and Live Property Explorer\n\t\t\tWhile the **XAML Binding Failures** window is new to Visual Studio, the in-app toolbar has been available to XAML developers since 2015\\. The toolbar floats over the active window in your application while you are debugging. There are several parts to the toolbar:\n\n\t\t\t\t*   **Go to Live Visual Tree**: Opens the **Live Visual** **Tree** window.\n\t\t\t\t*   **Show in XAML Live Preview**: This opens the **XAML Live Preview** window in Visual Studio.\n\t\t\t\t*   **Select Element**: Allows you to select an element in **Live Visual Tree** by clicking on it in the active window.\n\t\t\t\t*   **Display Layout Adorners**: This will highlight the element in the UI that is currently selected in **Live** **Visual Tree**.\n\t\t\t\t*   **Track Focused Element**: While the **Live Visual Tree** window is open, toggling this on will indicate in **Live Visual Tree** which element currently has focus on the UI.\n\t\t\t\t*   **Binding failures**: Indicates the number of current binding failures and opens the **XAML Binding Failures** window when clicked.\n\t\t\t\t*   **Scan for Accessibility Issues**: This opens the **Accessibility Checker** window and runs an accessibility check on the UI elements currently visible.\n\t\t\t\t*   **Hot Reload**: Indicates whether **XAML Hot Reload** is currently available. Clicking it will open the documentation on Microsoft Learn.\n\n\t\t\tLet’s explore a few of the most commonly used debugging tools. If you wish to get more information on the remaining tools, you can visit this page about XAML tools on Microsoft Learn: [https://learn.microsoft.com/visualstudio/xaml-tools/](https://learn.microsoft.com/visualstudio/xaml-tools/). Or, view this *Visual Studio Toolbox* episode about using the XAML tools in Visual Studio: [https://learn.microsoft.com/shows/visual-studio-toolbox/new-xaml-features-in-visual-studio](https://learn.microsoft.com/shows/visual-studio-toolbox/new-xaml-features-in-visual-studio). We’ll start with XAML Hot Reload.\n\t\t\tCoding with XAML Hot Reload\n\t\t\tXAML Hot Reload is a simple but powerful feature. Before Visual Studio 16.2, it was known as **XAML C# Edit & Continue**. Hot reload has been available to web developers for a while longer, and the name change for XAML helps to clear up some confusion for developers familiar with the concept in web development. The idea of hot reload is that you can make changes to your UI and the changes are reflected in the running application without having to stop debugging and recompile. Let’s try it with the **XamlDebugging** solution:\n\n\t\t\t\t1.  Start by running the application again. Make sure that the **Hot Reload** indicator in the toolbar shows that it is enabled. It should only be disabled if you are running an unsupported project type.\n\t\t\t\t2.  Now let’s make a change to `Background` color of `StackPanel` to `LightGray`:\n\n    ```", "```cs\n\n    \t\t\t\t3.  Save the file and look at the running application:\n\n\t\t\t![Figure 11.12 – Changing the UI without restarting the application](img/B20908_11_012.jpg)\n\n\t\t\tFigure 11.12 – Changing the UI without restarting the application\n\t\t\tThe background of the window is now light gray.\n\t\t\tThis is a huge time-saver when building a new UI. For a list of known limitations, see this Microsoft Learn article: [https://learn.microsoft.com/troubleshoot/developer/visualstudio/tools-utilities/xaml-hot-reload-troubleshooting#known-limitations](https://learn.microsoft.com/troubleshoot/developer/visualstudio/tools-utilities/xaml-hot-reload-troubleshooting#known-limitations).\n\t\t\tNow let’s look at another powerful debugging tool, the **Live Visual** **Tree** window.\n\t\t\tDebugging with Live Visual Tree and Live Property Explorer\n\t\t\tThe **Live Visual Tree** window allows developers to explore the elements in the current window of an application’s XAML **visual tree**. It is available to UWP and WinUI applications and other XAML frameworks. Let’s step through using **Live Visual Tree** and related XAML debugging tools:\n\n\t\t\t\t1.  While debugging the **XAMLDebugging** project, open the **Live Visual Tree** window. The visual tree contains the hierarchy of controls in the window with the **Show Just My XAML** button selected by default in the **Live Visual Tree** window’s toolbar:\n\n\t\t\t![Figure 11.13 – Viewing Live Visual Tree for the XamlDebugging p﻿roject (Show Just﻿ My XAML selected)](img/B20908_11_013.jpg)\n\n\t\t\tFigure 11.13 – Viewing Live Visual Tree for the XamlDebugging project (Show Just My XAML selected)\n\n\t\t\t\t1.  If you want to view the entire visual tree for your window, de-select **Show Just My XAML** on the toolbar and the tree will refresh:\n\n\t\t\t![Figure 11.14 – Viewing Live Visual Tree for the XamlDebugging project (all XAML)](img/B20908_11_014.jpg)\n\n\t\t\tFigure 11.14 – Viewing Live Visual Tree for the XamlDebugging project (all XAML)\n\t\t\tThere’s a lot more going on here. With `TextBox` is made up of 17 child elements with a `Grid` at the root of its template. This is a great way to learn how the controls we use are composed. Working with and modifying these templates is beyond the scope of this chapter, but I encourage you to explore them on your own. [*Chapter 7*](B20908_07.xhtml#_idTextAnchor152), *Fluent Design System for Windows Applications*, has additional information on using default styles and theme resources. This Microsoft Learn article on control templates is another great place to start: [https://learn.microsoft.com/windows/apps/design/style/xaml-control-templates](https://learn.microsoft.com/windows/apps/design/style/xaml-control-templates). For now, let’s switch back to the **Show Just My** **XAML** view.\n\n\t\t\t\t1.  From **Live Visual Tree**, right-click on a node to navigate to the XAML markup for the selected item by selecting **View Source**.\n\t\t\t\t2.  Next, right-click a node and select **Show Properties** to show the **Live Property Explorer** window, where you can inspect the current properties of the selected element. You can see how the properties are grouped based on where they have been set. Here, some are set by **Local** changes and others are set based on the **Style** for a **TextBox**. If you had multiple levels of inherited explicit styles and an implicit style, those would all be grouped here:\n\n\t\t\t![Figure 11.15 – Viewing the Live Property Explorer window for the Text1 TextBox](img/B20908_11_015.jpg)\n\n\t\t\tFigure 11.15 – Viewing the Live Property Explorer window for the Text1 TextBox\n\n\t\t\t\t1.  Look at the `Binding` markup extension. Expand the **Text** property node to view the details of the binding:\n\n\t\t\t![Figure 11.16 – View the binding details for the Text property of Text1](img/B20908_11_016.jpg)\n\n\t\t\tFigure 11.16 – View the binding details for the Text property of Text1\n\t\t\tThere is some very helpful information here. We can see the **Path** and **Mode** that were set in the XAML, the ones we did not set, and yet others that are read-only. **IsBindingValid** is **False** in this project, but it may be **True** if you fixed your data context from the previous section. When the binding is valid, **EvaluatedValue** will contain the current value for the **Text** property.\n\n\t\t\t\t1.  Select the second `TextBox` element in the tree and view the **Live Property Explorer** window. You can see that the default value for **Background** is **SolidColorBrush**.\n\t\t\t\t2.  Expand the **Background** node to view the resource details:\n\n\t\t\t![Figure 11.17 – Viewing the property details of Page.Background](img/B20908_11_017.jpg)\n\n\t\t\tFigure 11.17 – Viewing the property details of Page.Background\n\n\t\t\t\t1.  Try changing the **Color** property to white and see what happens in the XAML code and to the running application. The UI in the app should update, but the XAML file will remain unchanged.\n\t\t\t\t2.  Next, try adding markup to `MainWindow` to set the `MaxWidth` property of the second `TextBox` to `100`. What happens in `MaxWidth` when you’re finished.\n\t\t\t\t3.  Returning to `Grid` is more complex than `StackPanel`. `StackPanel` is preferred for layout if you are simply laying out a few elements horizontally or vertically. This unidirectional layout is what `StackPanel` was built to handle. As a rule of thumb, you should use the right control for the job and always keep performance in mind.\n\t\t\t\t4.  Now select the active node from the tree in your XAML file and enable **Select Element in the Running Application** from the toolbar. The **Track Focused Element** button on the toolbar will highlight the current tree node in the application’s window at runtime. This option is also available from the in-app toolbar.\n\t\t\t\t5.  To toggle the in-app toolbar on/off, you can use the **Enable in-app Toolbar** button on the **Live Visual** **Tree** toolbar.\n\n\t\t\tI encourage you to spend some time in these windows the next time you are debugging your application. Use them to help find issues with binding, resources, or custom control templates.\n\t\t\tNow let’s wrap up the chapter and review what we’ve learned.\n\t\t\tSummary\n\t\t\tIn this chapter, we have covered some essential tools and techniques for debugging your XAML applications. We learned how to debug installed applications on a local or remote PC. If you are developing WPF or UWP applications, tools such as **Live Visual Tree**, **Live Property Explorer**, and **Rapid XAML Toolkit** will all work for those projects as well. Leveraging these tools will shorten the time you spend debugging and help you deliver higher-quality software.\n\t\t\tIn the next chapter, we will explore the `WebView2` browser control. You will learn how to use `WebView2` to embed an ASP.NET Core Blazor **single-page application** (**SPA**) inside a WinUI 3 desktop application.\n\t\t\tQuestions\n\n\t\t\t\t1.  How can you debug a UWP application that is running on an Xbox?\n\t\t\t\t2.  How can you debug an application that is currently running on your machine?\n\t\t\t\t3.  How can you launch an application package installed on a remote machine for debugging?\n\t\t\t\t4.  What feature in Visual Studio allows you to change XAML properties at runtime and see them reflected in the running application?\n\t\t\t\t5.  Which window will show a hierarchy of the elements in the current window?\n\t\t\t\t6.  What is the default binding mode for most control properties with `x:Bind`?\n\t\t\t\t7.  Where can you view the runtime properties for the control currently selected in **Live** **Visual Tree**?\n\n```"]