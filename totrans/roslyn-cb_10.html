<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Command-Line Tools Based on Roslyn API</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Writing an application based on the Compiler Syntax API to parse and transform source files</li>
<li>Writing an application based on the Compiler Semantic API to display diagnostics and overload resolution results</li>
<li><span>Writing an application based on the Compiler Analyzer API to execute diagnostic analyzers and display analyzer diagnostics</span></li>
<li>Writing an application based on the <span>Workspaces API to</span> format and simplify all source files in the solution</li>
<li>Writing an application based on the Workspaces API to edit projects in a solution and display project properties</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>This chapter enables developers to write command-line tools using the Roslyn compiler and workspaces API to analyze and/or edit C# code. The article at (</span><a href="https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview">https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview</a>) provides <span>a very good introduction to the Roslyn APIs at each of these layers.</span></p>
<p><span>We will provide you a gist from the article:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="211" src="assets/34e6b225-9b74-4f36-a4e0-a1fc49c5acd0.png" width="454"/></div>
<ul>
<li><strong>Compiler API</strong>: The compiler layer contains the object models that correspond with information exposed at each phase of the compiler pipeline, both syntactic and semantic. The compiler layer also contains an immutable snapshot of a single invocation of a compiler, including assembly references, compiler options, and source code files. There are two distinct APIs that represent the C# language and the Visual Basic language. These two APIs are similar in shape but tailored for high fidelity to each individual language. This layer has no dependencies on Visual Studio components.</li>
<li><strong>Workspaces API</strong>: The Workspaces layer contains the Workspaces API, which is the starting point for doing code analysis and refactoring over entire solutions. It assists you in organizing all the information about the projects in a solution into a single object model, offering you direct access to the compiler layer object models without needing to parse files, configure options, or manage project to project dependencies. This layer has no dependencies on Visual Studio components.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an application based on the Compiler Syntax API to parse and transform source files</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will write a C# console application based on Roslyn Compiler APIs to parse a given source file into a syntax tree, and then perform the following syntax transformations:</span></p>
<ul>
<li>Edit all the class declarations with no explicit accessibility modifier to add an internal modifier.</li>
<li>Add documentation comment syntax trivia to all public class declarations with no documentation comments.</li>
<li>Remove empty class declarations with no members.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p><span>You will need to have the Visual Studio 2017 Community Edition installed on your machine to execute this recipe. You can install a free Community Edition from: <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open Visual Studio and create a new C# console application targeting .NET Framework 4.6 or higher, say <kbd>ConsoleApp</kbd><em>.</em></li>
<li>Install the <kbd>Microsoft.CodeAnalysis.CSharp</kbd> NuGet package (as of this writing, the latest stable version is <em>2.1.0</em>). For guidance on how to search and install the NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
</ol>
<ol start="3">
<li>Replace the source code in <kbd>Program.cs</kbd> with the source code from the attached code sample <kbd>\ConsoleApp\Program.cs</kbd>.</li>
<li>Build the project.</li>
<li>Open a Visual Studio developer command prompt, change the directory to the project root directory, and execute <kbd>bin\Debug\ConsoleApp.exe</kbd> with no arguments.</li>
<li>Verify the output shows incorrect usage: <kbd>Usage: ConsoleApp.exe &lt;%file_path%&gt;</kbd></li>
<li>Create a text file, say <kbd>test.cs</kbd>, with the following code at the project root directory:</li>
</ol>
<pre style="padding-left: 90px">
// Class with no accessibility modifier<br/>class C1<br/>{<br/>  void M() {}<br/>}<br/><br/>// Public class with no documentation comments<br/>public class C2<br/>{<br/>  void M() {}<br/>}<br/><br/>// Empty class with no members<br/>public class C3<br/>{<br/>}
</pre>
<ol start="8">
<li>Now, execute the application with <kbd>test.cs</kbd> as the argument: <kbd>bin\Debug\ConsoleApp.exe test.cs</kbd>.</li>
<li>Verify the expected transformed source is displayed in the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="390" src="assets/0d778001-bcef-4845-85fd-db54050e822e.png" width="800"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we wrote a C# console application based on Roslyn Compiler API to parse and transform source text. As mentioned earlier, our application demonstrates three core syntax operations on the parsed tree: edit, add, and remove. Let's walk through the code and understand how we implemented these operations:</p>
<pre style="padding-left: 90px">
public static void Main(string[] args)<br/>{<br/>  // Parse arguments to get source file.<br/>  var filePath = ParseArguments(args);<br/>  if (filePath == null)<br/>  {<br/>    return;<br/>  }<br/><br/>  // Parse text into SyntaxTree.<br/>  var tree = Parse(filePath);<br/>  var root = (CompilationUnitSyntax)tree.GetRoot();<br/><br/>  // Transform syntax tree to edit/add/remove syntax.<br/>  root = EditClassDeclarations(root);<br/>  root = AddDocCommentsToClassDeclarations(root);<br/>  root = RemoveEmptyClassDeclarations(root);<br/><br/>  Console.WriteLine("Transformed source:" + Environment.NewLine);<br/>  Console.WriteLine(root.ToFullString());<br/>}
</pre>
<p>The <kbd>Main</kbd> method invokes individual methods to perform the following operations:</p>
<ul>
<li><kbd>ParseArguments</kbd> to scan for the input file to parse and transform.</li>
<li>Read the text from this source file and <kbd>Parse</kbd> it into a syntax tree.</li>
<li>Get the compilation unit root of the parsed tree and perform the following transformations on the root:
<ul>
<li><kbd>EditClassDeclarations</kbd> : To add internal modifier to class with no accessibility modifier.</li>
<li><kbd>AddDocCommentsToClassDeclarations</kbd> : To add stub documentation comments to public class with no documentation comments.</li>
<li><kbd>RemoveEmptyClassDeclarations</kbd> : To remove class declarations with no members.</li>
</ul>
</li>
<li>Display the transformed text on the console.</li>
</ul>
<p>The <kbd>ParseArguments</kbd> method expects a single argument, which must be a full path to an existing file on the disk. Otherwise, it displays an error and bails out returning null.</p>
<pre>
private static string ParseArguments(string[] args)<br/>{<br/>  if (args.Length != 1)<br/>  {<br/>    Console.WriteLine(@"Usage: ConsoleApp.exe &lt;%file_path%&gt;");<br/>    return null;<br/>  }<br/><br/>  if (!File.Exists(args[0]))<br/>  {<br/>    Console.WriteLine($"File '{args[0]}' does not exist");<br/>    return null;<br/>  }<br/><br/>  return args[0];<br/>}
</pre>
<p>The <kbd>Parse</kbd> method reads the file contents from the input file and parses it using the parsing API <kbd>CSharpSyntaxTree.ParseText</kbd>.</p>
<pre>
private static SyntaxTree Parse(string filePath)<br/>{<br/> var text = File.ReadAllText(filePath);<br/> return CSharpSyntaxTree.ParseText(text);<br/>}
</pre>
<p>The <kbd>EditClassDeclarations</kbd> method walks the descendant nodes of the root to find all class declaration nodes whose modifier list has no accessibility modifier (public, private, internal, or protected).</p>
<pre>
private static CompilationUnitSyntax EditClassDeclarations(CompilationUnitSyntax root)<br/>{<br/>  // Get class declarations with no accessibility modifier.<br/>  var classDeclarations = root.DescendantNodes()<br/>    .OfType&lt;ClassDeclarationSyntax&gt;()<br/>    .Where(c =&gt; !c.Modifiers.Any(m =&gt; SyntaxFacts.IsAccessibilityModifier(m.Kind())));<br/><br/>  // Add modifier to these class declarations and replace in the original tree.<br/>  return root.ReplaceNodes(classDeclarations,<br/>  computeReplacementNode: (o, n) =&gt; AddModifier(n));<br/>}
</pre>
<p>Then it invokes the <kbd>ReplaceNodes</kbd> API on the root syntax node to replace each such class declaration with an updated node returned by the <kbd>AddModifier</kbd> helper. This helper adds a new internal modifier at the start of the current modifier list of the class declaration. It also takes care of moving any existing leading trivia of the class declaration to the new modifier and adds a whitespace trivia after the new modifier:</p>
<pre>
private static ClassDeclarationSyntax AddModifier(ClassDeclarationSyntax classDeclaration)<br/>{<br/>  var internalModifier = SyntaxFactory.Token(SyntaxKind.InternalKeyword)<br/>    .WithTrailingTrivia(SyntaxFactory.Whitespace(" "));<br/>  if (classDeclaration.HasLeadingTrivia)<br/>  {<br/>    // Move leading trivia for the class declaration to the new modifier.<br/>    internalModifier = internalModifier.WithLeadingTrivia(classDeclaration.GetLeadingTrivia());<br/>    classDeclaration = classDeclaration.WithLeadingTrivia();<br/>  }<br/><br/>  var newModifiers = classDeclaration.Modifiers.Insert(0, internalModifier);<br/>  return classDeclaration.WithModifiers(newModifiers);<br/>}
</pre>
<p>The <kbd>AddDocCommentsToClassDeclarations</kbd> method <span>walks the descendant nodes of the root to find all class declaration nodes whose modifier list has a public accessibility modifier and its first token has no leading documentation comment trivia.</span></p>
<pre>
private static CompilationUnitSyntax AddDocCommentsToClassDeclarations(CompilationUnitSyntax root)<br/>{<br/>  // Get public class declarations with no documentation comments.<br/>  var classDeclarations = root.DescendantNodes()<br/>    .OfType&lt;ClassDeclarationSyntax&gt;()<br/>    .Where(c =&gt; c.Modifiers.Any(m =&gt; m.Kind() == SyntaxKind.PublicKeyword) &amp;&amp;<br/>   !c.GetFirstToken().LeadingTrivia.Any(IsDocumentationComment));<br/><br/>  // Add stub documentation comment to these class declarations and replace in the original tree.<br/>  return root.ReplaceNodes(classDeclarations,<br/>  computeReplacementNode: (o, n) =&gt; AddDocumentationComment(n));<br/>}
</pre>
<p>Then, it invokes the <kbd>ReplaceNode</kbd><em>s</em> API on the root syntax node to replace each such class declaration with an updated node returned by the <kbd>AddDocumentationComment</kbd> helper. This helper creates an XML summary element with a <kbd>TODO</kbd> comment and creates a single line documentation comment with this stub summary element and adds this at end of the current leading trivia for the class declaration.</p>
<pre>
private static ClassDeclarationSyntax <em>AddDocumentationComment</em>(ClassDeclarationSyntax classDeclaration)<br/>{<br/> var summaryElement = SyntaxFactory.XmlSummaryElement(SyntaxFactory.XmlText("TODO: Add doc comments"));<br/> var documentationComment = SyntaxFactory.DocumentationComment(summaryElement);<br/> var newLeadingTrivia = classDeclaration.GetLeadingTrivia()<br/>  .Add(SyntaxFactory.Trivia(documentationComment))<br/>  .Add(SyntaxFactory.EndOfLine(Environment.NewLine));<br/>  return classDeclaration.WithLeadingTrivia(newLeadingTrivia);<br/>}
</pre>
<p>The <kbd>RemoveEmptyClassDeclarations</kbd> method <span>walks the descendant nodes of the root to find all class declaration nodes which have no members declarations (methods, fields, nested types, and so on) and then invokes the</span> <kbd>ReplaceNodes</kbd> <span>API on the root syntax node to remove all such declarations.</span></p>
<pre>
private static CompilationUnitSyntax RemoveEmptyClassDeclarations(CompilationUnitSyntax root)<br/>{<br/> // Get class declarations with no members.<br/> var classDeclarations = root.DescendantNodes()<br/>  .OfType&lt;ClassDeclarationSyntax&gt;()<br/>  .Where(c =&gt; c.Members.Count == 0);<br/><br/> // Remove these class declarations from the original tree.<br/> return root.RemoveNodes(classDeclarations, SyntaxRemoveOptions.KeepNoTrivia);<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an application based on the Compiler Semantic API to display diagnostics and overload resolution results</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will write a C# console application based on Roslyn Compiler APIs to create a compilation from the given source file and then perform the following semantic analyses:</span></p>
<ol>
<li>Compute and display the compilation diagnostics that would be produced by the C# compiler if the file were to be compiled.</li>
<li>Compute the <span class="packt_screen">symbol info</span> for each invocation (method call) in the source file and display the following semantic information for each call:<br/>
<ol>
<li>Overload resolution result (<a href="https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx">https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx</a>): Success or failure reason.</li>
<li>If overload resolution succeeded, the method symbol bound to the invocation.</li>
<li>Otherwise, if overload resolution failed and we have one or more candidate symbols, then display each candidate symbol.</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p><span>You will need to have the Visual Studio 2017 Community Edition installed on your machine to execute this recipe. You can install a free Community Edition from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open Visual Studio and create a new C# console application targeting .NET Framework 4.6 or higher, say <kbd>ConsoleApp</kbd><em>.</em></li>
<li>Install the <kbd>Microsoft.CodeAnalysis.CSharp</kbd> NuGet package (as of this writing, the latest stable version is <em>2.1.0</em>). For guidance on how to search and install NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Replace the source code in <kbd>Program.cs</kbd> with the source code from the attached code sample <kbd>\ConsoleApp\Program.cs</kbd>.</li>
<li>Build the project.</li>
<li>Open a Visual Studio developer command prompt, change the directory to the project root directory, and execute <kbd>bin\Debug\ConsoleApp.exe</kbd> with no arguments.</li>
<li>Verify the output shows incorrect usage: <kbd>Usage: ConsoleApp.exe &lt;%file_path%&gt;</kbd>.</li>
<li>Create a text file, say <kbd>test.cs</kbd>, with the following code at the project root directory:</li>
</ol>
<pre style="padding-left: 90px">
class C1<br/>{<br/> void F()<br/> {<br/>  M1();<br/>  M2(0);<br/>  M2(null);<br/> }<br/><br/> void M1()<br/> {<br/> }<br/><br/> void M2()<br/> {<br/> }<br/><br/> void M2(int x)<br/> {<br/> }<br/>}
</pre>
<ol start="8">
<li>Now, execute the application with <kbd>test.cs</kbd> as the argument: <kbd>bin\Debug\ConsoleApp.exe test.cs</kbd>.</li>
<li>Verify the expected diagnostics and invocation semantics with overload resolution results are displayed in the output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="348" src="assets/b7728e2d-18de-47de-885a-3ea256bb3819.png" width="800"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we wrote a C# console application based on the Roslyn Compiler API to create a compilation and analyze and display the diagnostics and overload resolution semantics for invocation expressions. These operations are very similar to what a C# compiler would do when compiling the source code. Let's walk through the code and understand how we implemented these operations:</p>
<pre>
public static void Main(string[] args)<br/>{<br/> // Parse arguments to get source file.<br/> var filePath = ParseArguments(args);<br/> if (filePath == null)<br/> {<br/>  return;<br/> }<br/><br/> // Parse text and create a compilation.<br/> var compilation = CreateCompilation(filePath);<br/><br/> // Display diagnostics in the compilation.<br/> DisplayDiagnostics(compilation);<br/><br/> // Display semantic information about invocations in the file.<br/> DisplayInvocations(compilation);<br/>}
</pre>
<p>The Main method invokes individual methods to perform the following operations:</p>
<ul>
<li><kbd>ParseArguments</kbd> to scan for the input file to parse and transform.</li>
<li><kbd>CreateCompilation</kbd> to create a C# compilation from a parsed syntax tree created with the text from this source file.</li>
<li><kbd>DisplayDiagnostics</kbd> to compute the compiler diagnostics and then display them.</li>
<li><kbd>DisplayInvocations</kbd> to analyze each invocation (method call) in a syntax tree and display the overload resolution result and bound symbols.</li>
</ul>
<p>Implementation of <kbd>ParseArguments</kbd> is identical to the one in the previous recipe, <em>Writing an application based on Compiler Syntax API to parse and transform source files.</em> Refer to the <em>How it works...</em>, section of that recipe for further explanation on this method.</p>
<p>The <kbd>CreateCompilation</kbd> method first reads the file contents from the input file and parses it using the parsing API <kbd>CSharpSyntaxTree.ParseText</kbd>. Then, it creates a metadata reference for the system assembly (corlib) using the location of the assembly containing the object type. It creates compilation options with output kind <kbd>DynamicallyLinkedLibrary</kbd> (<kbd>.dll</kbd>) and uses these inputs to create a C# compilation:</p>
<pre>
private static Compilation CreateCompilation(string filePath)<br/>{<br/> var text = File.ReadAllText(filePath);<br/> var tree = CSharpSyntaxTree.ParseText(text);<br/> var systemAssembly = MetadataReference.CreateFromFile(typeof(object).Assembly.Location);<br/> var options = new CSharpCompilationOptions(outputKind: OutputKind.DynamicallyLinkedLibrary);<br/> return CSharpCompilation.Create("TestAssembly",<br/>  syntaxTrees: new[] { tree },<br/>  references: new[] { systemAssembly },<br/>  options: options);<br/>}
</pre>
<p>The <kbd>DisplayDiagnostics</kbd> method computes the compilation diagnostics using the <kbd>Compilation.GetDiagnostics</kbd> API and then displays the diagnostic count and string representation of each diagnostic.</p>
<pre>
private static void DisplayDiagnostics(Compilation compilation)<br/>{<br/> var diagnostics = compilation.GetDiagnostics();<br/> Console.WriteLine($"Number of diagnostics: {diagnostics.Length}");<br/> foreach (var diagnostic in diagnostics)<br/> {<br/>  Console.WriteLine(diagnostic.ToString());<br/> }<br/><br/> Console.WriteLine();<br/>}
</pre>
<p>The <kbd>DisplayInvocations</kbd> method first gets the semantic model for the syntax tree in the compilation. Then, it iterates over the descendant nodes of the root to get all <kbd>InvocationExpressionSyntax</kbd> nodes. For each such invocation, it queries the symbol info of the expression from the semantic model. The symbol info contains information about the semantics of the invocation. We display the overload resolution success/fail result based on whether or not the candidate reason is <kbd>CandidateReason.None</kbd>. Then, we display the bound symbol or candidate symbols for the success and failure cases, respectively:</p>
<pre>
private static void DisplayInvocations(Compilation compilation)<br/>{<br/> var tree = compilation.SyntaxTrees.Single();<br/> var semanticModel = compilation.GetSemanticModel(tree);<br/> var invocations = tree.GetRoot().DescendantNodes().OfType&lt;InvocationExpressionSyntax&gt;();<br/> foreach (var invocation in invocations)<br/> {<br/>  Console.WriteLine($"Invocation: '{invocation.ToString()}'");<br/>  var symbolInfo = semanticModel.GetSymbolInfo(invocation);<br/><br/>  var overloadResolutionResult = symbolInfo.CandidateReason == CandidateReason.None ? "Succeeded" : symbolInfo.CandidateReason.ToString();<br/>  Console.WriteLine($" Overload resolution result: {overloadResolutionResult}");<br/><br/>  if (symbolInfo.Symbol != null)<br/>  {<br/>   Console.WriteLine($" Method Symbol: {symbolInfo.Symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}");<br/>  }<br/>  else if (!symbolInfo.CandidateSymbols.IsDefaultOrEmpty)<br/>  {<br/>   Console.WriteLine($" {symbolInfo.CandidateSymbols.Length} candidate symbols:");<br/>   foreach (var candidate in symbolInfo.CandidateSymbols)<br/>   {<br/>    Console.WriteLine($" Candidate Symbol: {candidate.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}");<br/>   }<br/>  }<br/><br/>  Console.WriteLine();<br/> }<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an application based on the Compiler Analyzer API to execute diagnostic analyzers and display analyzer diagnostics</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will write a C# console application based on Roslyn Compiler APIs that loads the given analyzer assembly, executes all diagnostic analyzers defined in this assembly on a given source file, and outputs all the reported analyzer diagnostics.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p><span>You will need to have the Visual Studio 2017 Community Edition installed on your machine to execute this recipe. You can install a free Community Edition from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a></span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open Visual Studio and create a new C# console application targeting .NET Framework 4.6 or higher, say <kbd>ConsoleApp</kbd>.</li>
<li>Install the <kbd>Microsoft.CodeAnalysis.CSharp</kbd> NuGet package (as of this writing, the latest stable version is <em>2.1.0</em>). For guidance on how to search and install the NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
<li>Replace the source code in <kbd>Program.cs</kbd> with the source code from the attached code sample <kbd>\ConsoleApp\Program.cs</kbd>.</li>
<li>Add a C# class library project <span>targeting .NET Framework 4.6 or higher to the solution, say</span> <em>Analyzer.</em></li>
<li><span>Install the</span> <kbd>Microsoft.CodeAnalysis</kbd> <span>NuGet package to this project (as of this writing, the latest stable version is</span> <em>2.1.0</em><span><span>).</span></span></li>
</ol>
<ol start="6">
<li><span>Replace the source code in</span> <kbd>Class1.cs</kbd> <span>with the diagnostic analyzer source code from the attached code sample</span> <kbd>\Analyzer\Class1.cs</kbd>. This file contains the code for the default symbol analyzer that reports a diagnostic for type names containing any lowercase characters.</li>
<li>Build the solution.</li>
<li>Open a Visual Studio developer command prompt, change the directory to the project root directory of <kbd>ConsoleApp</kbd>, and execute <kbd>bin\Debug\ConsoleApp.exe</kbd> with no arguments.</li>
<li>Verify the output shows incorrect usage: <kbd>Usage: ConsoleApp.exe &lt;%analyzer_file_path%&gt; &lt;%source_file_path%&gt;</kbd>.</li>
<li>Create a text file, say <kbd>test.cs</kbd>, at the project root directory of <kbd>ConsoleApp</kbd> with the following code:</li>
</ol>
<pre style="padding-left: 90px">
class ClassWithLowerCase<br/>{<br/>}<br/><br/>class OuterClassWithLowerCase<br/>{<br/> class NestedClassWithLowerCase<br/> {<br/> }<br/>}<br/><br/>class CLASS_WITH_UPPER_CASE<br/>{<br/>}
</pre>
<ol start="11">
<li>Now, execute the application with a relative path to analyzer assembly and <kbd>test.cs</kbd> as the arguments: <kbd>bin\Debug\ConsoleApp.exe ..\..\..\Analyzer\bin\Debug\Analyzer.dll test.cs</kbd>.</li>
<li>Verify that the expected analyzer diagnostics are displayed in the output:</li>
</ol>
<pre style="padding-left: 90px">
Number of diagnostics: 3<br/>(1,7): warning CSharpAnalyzers: Type name 'ClassWithLowerCase' contains lowercase letters<br/>(5,7): warning CSharpAnalyzers: Type name 'OuterClassWithLowerCase' contains lowercase letters<br/>(7,9): warning CSharpAnalyzers: Type name 'NestedClassWithLowerCase' contains lowercase letters
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we wrote a C# console application based on the Roslyn Compiler API to load and execute diagnostic analyzers from an analyzer assembly and report the diagnostics reported by the analyzers. These operations are very similar to what the C# compiler would do when you compile source files with <kbd>/analyzer:&lt;%analyzer_file_path%&gt;</kbd> command line switch. Let's walk through the code and understand how we implemented these operations:</p>
<pre>
public static void Main(string[] args)<br/>{<br/> // Parse arguments to get analyzer assembly file and source file.<br/> var files = ParseArguments(args);<br/> if (files.analyzerFile == null || files.sourceFile == null)<br/> {<br/>  return;<br/> }<br/><br/> // Parse source file and create a compilation.<br/> var compilation = CreateCompilation(files.sourceFile);<br/><br/> // Create compilation with analyzers.<br/> var compilationWithAnalyzers = CreateCompilationWithAnalyzers(files.analyzerFile, compilation);<br/><br/> // Display analyzer diagnostics in the compilation.<br/> DisplayAnalyzerDiagnostics(compilationWithAnalyzers);<br/>}
</pre>
<p>The Main method invokes individual methods to perform the following operations:</p>
<ul>
<li><kbd>ParseArguments</kbd> to scan for:
<ul>
<li>Analyzer assembly file.</li>
<li>Input source file on which the analyzers will be executed.</li>
</ul>
</li>
<li><kbd>CreateCompilation</kbd> to create a C# compilation from parsed syntax tree created with the text from the input source file.</li>
<li><kbd>CreateCompilationWithAnalyzers</kbd> to create a compilation instance with diagnostic analyzers from the given analyzer assembly file attached to it.</li>
<li><kbd>DisplayAnalyzerDiagnostics</kbd> to execute the analyzers to compute the analyzer diagnostics and then display them.</li>
</ul>
<p>Implementation of <kbd>ParseArguments</kbd> and <kbd>CreateCompilation</kbd> is identical to the one in the previous recipe, <em>Writing an application based on Compiler Syntax API to parse and transform source files.</em> Refer to the <em>How it works...</em>, section of that recipe for further explanation on these methods.</p>
<p>The <kbd>CreateCompilationWithAnalyzers</kbd> method takes the compilation and the analyzer assembly as the parameters:</p>
<pre>
private static CompilationWithAnalyzers <strong>CreateCompilationWithAnalyzers</strong>(string analyzerFilePath, Compilation compilation)<br/>{<br/> var analyzerFileReference = new AnalyzerFileReference(analyzerFilePath, new AnalyzerAssemblyLoader());<br/> var analyzers = analyzerFileReference.GetAnalyzers(LanguageNames.CSharp);<br/> var options = new CompilationWithAnalyzersOptions(<br/>  new AnalyzerOptions(ImmutableArray&lt;AdditionalText&gt;.Empty),<br/>  onAnalyzerException: (exception, analyzer, diagnostic) =&gt; throw exception,<br/>  concurrentAnalysis: false,<br/>  logAnalyzerExecutionTime: false);<br/> return new CompilationWithAnalyzers(compilation, analyzers, options);<br/> }
</pre>
<p>First, it creates <kbd>AnalyzerFileReference</kbd> (<a href="http://source.roslyn.io/#q=AnalyzerFileReference">http://source.roslyn.io/#q=AnalyzerFileReference</a>) with the analyzer file path and an instance of the analyzer assembly loader (<kbd>IAnalyzerAssemblyLoader</kbd> - details later in the section (<a href="http://source.roslyn.io/#q=IAnalyzerAssemblyLoader">http://source.roslyn.io/#q=IAnalyzerAssemblyLoader</a>)). It invokes the <kbd>AnalyzerReference.GetAnalyzers</kbd> API (<a href="http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers">http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers</a>) on this analyzer file reference to load the analyzer assembly with the given analyzer assembly loader, and then create instances of the diagnostic analyzers defined in this assembly.</p>
<p>It creates a default set of <kbd>CompilationWithAnalyzersOptions</kbd> (<a href="http://source.roslyn.io/#q=CompilationWithAnalyzersOptions">http://source.roslyn.io/#q=CompilationWithAnalyzersOptions</a>) for configuring the analyzer execution. The possible options include:</p>
<ul>
<li><kbd>AnalyzerOptions</kbd>: Analyzer options contain the set of additional non-source text files that are passed to the analyzers. In this recipe, we use an empty set. You can read more about additional files at <a href="https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md">https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md</a>.</li>
<li><kbd>onAnalyzerException</kbd> delegate: Delegate to be invoked when an analyzer throws an exception. In this recipe, we just re-throw this exception.</li>
<li><kbd>concurrentAnalysis</kbd>: Flag to control whether the analyzers should be run concurrently or not. In this recipe, we default this to false.</li>
<li><kbd>logAnalyzerExecutionTime</kbd>: Flag to control whether the relative execution times for each analyzer should be tracked. If set to true, then this data can be requested for each analyzer using the public API <kbd>CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync</kbd> (<a href="http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync">http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync</a>). This returns an <kbd>AnalyzerTelemetryInfo</kbd>, which has a property named <kbd>ExecutionTime</kbd> (<kbd>http://source.roslyn.io/#q=AnalyzerTelemetryInfo.ExecutionTime</kbd>). In this recipe, we default this to false.</li>
</ul>
<p>Finally, the method creates and returns a <kbd>CompilationWithAnalyzers</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a">http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a</a>) instance with the given compilation, analyzer file reference, and options.</p>
<p>We briefly mentioned our custom <kbd>AnalyzerAssemblyLoader</kbd> passed into the <kbd>AnalyzerFileReference</kbd> constructor above. It is implemented in our code as follows:</p>
<pre>
private class <strong>AnalyzerAssemblyLoader</strong> : IAnalyzerAssemblyLoader<br/>{<br/>  void IAnalyzerAssemblyLoader.AddDependencyLocation(string fullPath)<br/>  {<br/>  }<br/><br/>  Assembly IAnalyzerAssemblyLoader.LoadFromPath(string fullPath)<br/>  {<br/>    return Assembly.LoadFrom(fullPath);<br/>  }<br/>}
</pre>
<p>This analyzer assembly loader handles loading the analyzer assembly using the .NET APIs for assembly loading on the executing platform. In this recipe, we use .NET Framework API <kbd>Assembly.LoadFrom</kbd> (<a href="https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx">https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx</a>) to load the assembly from the given path.</p>
<div class="packt_infobox">We ignore the callbacks to add analyzer dependency locations in our custom <kbd>AnalyzerAssemblyLoader</kbd>, as our test analyzer assembly has no dependencies. We can enhance this assembly loader to track these locations and handle assembly loading for dependencies.</div>
<p><kbd>DisplayAnalyzerDiagnostics</kbd> takes the <kbd>CompilationWithAnalyzers</kbd> instance created earlier and executes the analyzers on the underlying compilation using <kbd>GetAnalyzerDiagnosticsAsync</kbd> API. It then walks through all the analyzer diagnostics and outputs the message for each diagnostic, with the line and column information:</p>
<pre>
private static void <strong>DisplayAnalyzerDiagnostics</strong>(CompilationWithAnalyzers compilationWithAnalyzers)<br/>{<br/> var diagnostics = compilationWithAnalyzers.GetAnalyzerDiagnosticsAsync(CancellationToken.None).Result;<br/> Console.WriteLine($"Number of diagnostics: {diagnostics.Length}");<br/> foreach (var diagnostic in diagnostics)<br/> {<br/>  Console.WriteLine(diagnostic.ToString());<br/> }<br/><br/> Console.WriteLine();<br/> }<br/><br/> return newSolution;<br/>}
</pre>
<div class="packt_tip">You can invoke the <kbd>CompilationWithAnalyzers.GetAnalysisResultAsync</kbd> (<a href="http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync">http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync</a>) public API to get a more fine-grained view of the analysis results. The returned <kbd>AnalysisResult</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8">http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8</a>) allows you to get separate syntax, semantic, and compilations diagnostics reported by each diagnostic analyzer and also allows you to get the analyzer telemetry info for each analyzer.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an application based on the Workspaces API to format and simplify all source files in the solution</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will write a C# console application based on Roslyn Workspaces APIs to load a C# solution into a workspace and then perform the following operations:</span></p>
<ol>
<li>Format the solution to change tabs to white spaces with a custom indentation size. This is a syntactic code refactoring.</li>
<li>Simplify the solution to change local declarations to have an explicit type specification instead of var. This is a semantic code refactoring.</li>
</ol>
<div class="packt_infobox">You can read the XML documentation comments and implementation details for the Formatter and Simplifier for additional information on these operations at: <a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002">http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002</a> and <a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac">http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac</a>, respectively.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p><span>You will need to have the Visual Studio 2017 Community Edition installed on your machine to execute this recipe. You can install a free Community Edition from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a></span>.<span><a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open Visual Studio and create a new C# console application targeting .NET Framework 4.6 or higher, say <kbd>ConsoleApp</kbd><em>.</em></li>
<li>Install the <kbd>Microsoft.CodeAnalysis.CSharp.Workspaces</kbd> NuGet package (as of this writing, the latest stable version is <em>2.1.0</em>). For guidance on how to search and install NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
</ol>
<ol start="3">
<li>Replace the source code in <kbd>Program.cs</kbd> with the source code from the attached code sample <kbd>\ConsoleApp\Program.cs</kbd>.</li>
<li>Build the project.</li>
<li>Open a Visual Studio developer command prompt, change the directory to the project root directory and execute <kbd>bin\Debug\ConsoleApp.exe</kbd> with no arguments.</li>
<li>Verify the output shows incorrect usage: <kbd>Usage: ConsoleApp.exe &lt;%solution_file_path%&gt;</kbd>.</li>
<li>Create a new C# console application, say <kbd>TestSolution</kbd>, and add one implicitly typed and one explicitly typed local declaration to the <kbd>Main</kbd> method (note the indent size of 4):</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="191" src="assets/1b8bc391-7f99-4ca0-b91a-82bcc557c9c2.png" width="408"/></div>
<ol start="8">
<li>Now, execute the application with full path to <kbd>TestSolution.sln</kbd> as the argument: <kbd>bin\Debug\ConsoleApp.exe &lt;%test_solution_path%&gt;</kbd>.</li>
<li>Verify the console output:</li>
</ol>
<pre style="padding-left: 90px">
Loading solution '&lt;%test_sln_path%&gt;'...<br/>Formatting solution...<br/>Simplifying solution...<br/>Solution updated.
</pre>
<ol start="10">
<li>Verify the new contents of the source file in <em>TestSolution now</em> has an indent size of 2 and no explicitly typed local declarations:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="176" src="assets/0e2b2aff-adf2-42a0-ab4d-e40859a988b9.png" width="380"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we wrote a C# console application based on Roslyn Workspaces API to format and simplify all the source files in a solution. These operations are very similar to what a Visual Studio IDE would do when you apply formatting and simplification quick fixes after setting the corresponding tools options. Let's walk through the code and understand how we implemented these operations:</p>
<pre>
public static void Main(string[] args)<br/>{<br/> // Parse arguments to get solution.<br/> var slnPath = ParseArguments(args);<br/> if (slnPath == null)<br/> {<br/>  return;<br/> }<br/><br/> // Create workspace.<br/> MSBuildWorkspace workspace = MSBuildWorkspace.Create();<br/><br/> // Open solution within the workspace.<br/> Console.WriteLine($"Loading solution '{slnPath}'...");<br/> Solution solution = workspace.OpenSolutionAsync(slnPath).Result;<br/><br/> // Format the solution.<br/> solution = FormatSolution(solution, workspace.Options);<br/><br/> // Simplify the solution.<br/> solution = SimplifySolution(solution, workspace.Options);<br/><br/> // Apply changes.<br/> ApplyChanges(workspace, solution);<br/>}
</pre>
<p>The <kbd>Main</kbd> method invokes individual methods to perform the following operations:</p>
<ul>
<li><kbd>ParseArguments</kbd>: To scan for the input file to parse and transform.</li>
<li><kbd>MSBuildWorkspace.Create</kbd>: To create a workspace and <kbd>Workspace.OpenSolutionAsync</kbd> to load the given solution in the workspace.</li>
<li><kbd>FormatSolution</kbd>: To format all the documents in the solution.</li>
<li><kbd>SimplifySolution</kbd>: To simplify all the documents in the solution.</li>
<li><kbd>ApplyChanges</kbd>: To apply the formatting and simplification changes to the workspace and persist these to the disk.</li>
</ul>
<p>Implementation of <kbd>ParseArguments</kbd> is identical to the one in the recipe, <em>Writing an application based on Compiler Syntax API to parse and transform source files.</em> Refer to the <em>How it works...</em>, section of that recipe for further explanation on this method.</p>
<p><kbd>MSBuildWorkspace</kbd> (<a href="http://source.roslyn.io/#q=MSBuildWorkspace">http://source.roslyn.io/#q=MSBuildWorkspace</a>) is a custom implementation of the core Roslyn Workspace, which uses the MSBuild (<a href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild">https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild</a>) project model for loading the solution/project files and allows reading and writing individual documents in the projects.</p>
<p>The <kbd>FormatSolution</kbd> method formats all documents in the solution. First, it modifies the options to prefer whitespace over tabs, with an indentation size of 2 (default is 4):</p>
<ul>
<li><kbd>FormattingOptions.UseTabs</kbd>: Value set to <kbd>false</kbd>.</li>
<li><kbd>FormattingOptions.IndentationSize</kbd>: Value set to <kbd>2</kbd>.</li>
</ul>
<pre>
private static Solution <strong>FormatSolution</strong>(Solution originalSolution, OptionSet options)<br/>{<br/> Console.WriteLine("Formatting solution...");<br/><br/> // Prefer whitespaces over tabs, with an indentation size of 2.<br/> options = options<br/>  .WithChangedOption(FormattingOptions.UseTabs, LanguageNames.CSharp, false)<br/>  .WithChangedOption(FormattingOptions.IndentationSize, LanguageNames.CSharp, 2);<br/><br/> Solution newSolution = originalSolution;<br/> foreach (var documentId in originalSolution.Projects.SelectMany(p =&gt; p.DocumentIds))<br/> {<br/>  Document document = newSolution.GetDocument(documentId);<br/><br/>  // Format the document.<br/>  Document newDocument = Formatter.FormatAsync(document, options).Result;<br/><br/>  // Update the current solution.<br/>  newSolution = newDocument.Project.Solution;<br/> }<br/><br/> return newSolution;<br/>}
</pre>
<p>It keeps track of the current solution snapshot in <kbd>newSolution</kbd><em>,</em> which is initialized to <kbd>originalSolution</kbd>. It then iterates over all the documents in the solution and does the following:</p>
<ul>
<li>Format the document by invoking <kbd>Formatter.FormatAsync</kbd> public API (<a href="http://source.roslyn.io/#q=Formatter.FormatAsync">http://source.roslyn.io/#q=Formatter.FormatAsync</a>) with the current document and options.</li>
<li>Update <kbd>newSolution</kbd> to point to the solution of the formatted <kbd>newDocument</kbd>.</li>
</ul>
<div class="packt_infobox">Note how we can't simply iterate over <kbd>originalSolution.Projects</kbd> or <kbd>project.Documents</kbd> because it will return objects from the unmodified <kbd>originalSolution</kbd>, not from the <kbd>newSolution</kbd>. We need to use the <kbd>ProjectId</kbd>/<kbd>DocumentIds</kbd> (that don't change) to look up the corresponding snapshots in the <kbd>newSolution</kbd>.</div>
<p>Finally, it returns the <kbd>newSolution</kbd> after all documents have been formatted.</p>
<p>The <kbd>SimplifySolution</kbd> method simplifies all documents in the solution. First, it modifies the options to prefer implicitly type local declaration, that is, user <kbd>var</kbd> over explicit type specification, by setting <kbd>SimplificationOptions.PreferImplicitTypeInLocalDeclaration</kbd> to <kbd>true</kbd>:</p>
<pre>
private static Solution <strong>SimplifySolution</strong>(Solution originalSolution, OptionSet options)<br/>{<br/> Console.WriteLine("Simplifying solution...");<br/><br/> // Prefer 'var' over explicit type specification.<br/> options = options.WithChangedOption(SimplificationOptions.PreferImplicitTypeInLocalDeclaration, true);<br/><br/> Solution newSolution = originalSolution;<br/> foreach (var documentId in originalSolution.Projects.SelectMany(p =&gt; p.DocumentIds))<br/> {<br/>  Document document = newSolution.GetDocument(documentId);<br/><br/>  // Add simplification annotation to the root.<br/>  var newRoot = document.GetSyntaxRootAsync().Result.WithAdditionalAnnotations(Simplifier.Annotation);<br/> <br/>  // Simplify the document.<br/>  Document newDocument = Simplifier.ReduceAsync(document.WithSyntaxRoot(newRoot), options).Result;<br/><br/>  // Update the current solution.<br/>  newSolution = newDocument.Project.Solution;<br/> }<br/><br/> return newSolution;<br/>}
</pre>
<p><kbd>SimplifySolution</kbd> has very identical implementation to the <kbd>FormatSolution</kbd> method for iterating the documents, simplifying them by invoking <kbd>Simplifier.ReduceAsync</kbd> public API (<a href="http://source.roslyn.io/#q=Simplifier.ReduceAsync">http://source.roslyn.io/#q=Simplifier.ReduceAsync</a>), storing the latest snapshot in <kbd>newSolution</kbd> after processing each document, and finally returning the new solution snapshot at the end. It has one important difference though. <kbd>Simplifier.ReduceAsync</kbd> only processes nodes with a special syntax annotation: <kbd>Simplifier.Annotation</kbd> (<a href="http://source.roslyn.io/#q=Simplifier.Annotation">http://source.roslyn.io/#q=Simplifier.Annotation</a>). Hence, before invoking this API, we add this syntax annotation to the root of the document.</p>
<p>The <kbd>ApplyChanges</kbd> method invokes the <kbd>Workspace.TryApplyChanges</kbd> public API (<a href="http://source.roslyn.io/#q=Workspace.TryApplyChanges">http://source.roslyn.io/#q=Workspace.TryApplyChanges</a>) with the new solution snapshot to apply the changes in the solution snapshot to the workspace. This also causes the <kbd>MSBuildWorkspace</kbd> to persist these changes onto the disk:</p>
<pre>
private static void <strong>ApplyChanges</strong>(Workspace workspace, Solution solution)<br/>{<br/> // Apply solution changes to the workspace.<br/> // This persists the in-memory changes into the disk.<br/> if (workspace.TryApplyChanges(solution))<br/> {<br/>  Console.WriteLine("Solution updated.");<br/> }<br/> else<br/> {<br/>  Console.WriteLine("Update failed!");<br/> }<br/>}
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing an application based on the Workspaces API to edit projects in a solution and display project properties</h1>
                </header>
            
            <article>
                
<p><span>In this section, we will write a C# console application based on Roslyn Workspaces APIs to load a C# solution into a workspace and then perform the following operations:</span></p>
<ul>
<li>Display project properties such as project file path, output file path, project language, assembly name, reference count, document count, and so on.</li>
<li>Add a new project to the solution.</li>
<li>Remove an existing project from the solution.</li>
<li>Edit project to add a project reference.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article>
                
<p><span>You will need to have the Visual Studio 2017 Community Edition installed on your machine to execute this recipe. You can install a free Community Edition from <a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15">https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15</a></span>.<span><a href="https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&amp;rel=15"/></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open Visual Studio and create a new C# console application targeting the .NET Framework 4.6 or higher, say <kbd>ConsoleApp</kbd><em>.</em></li>
<li>Install the <kbd>Microsoft.CodeAnalysis.CSharp.Workspaces</kbd> NuGet package (as of this writing, the latest stable version is <em>2.1.0</em>). For guidance on how to search and install the NuGet package to a project, refer to the recipe <em>Searching and installing analyzers through the NuGet package manager</em> in <a href="8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml">Chapter 2</a>, <em>Consuming Diagnostic Analyzers in .NET Projects</em>.</li>
</ol>
<ol start="3">
<li>Replace the source code in <kbd>Program.cs</kbd> with the source code from the attached code sample <kbd>\ConsoleApp\Program.cs</kbd>.</li>
<li>Build the project.</li>
</ol>
<ol start="5">
<li>Open a Visual Studio developer command prompt, change the directory to the project root directory, and execute <kbd>bin\Debug\ConsoleApp.exe</kbd> with no arguments.</li>
<li>Verify the output shows incorrect usage: <kbd>Usage: ConsoleApp.exe &lt;%solution_file_path%&gt;</kbd>.</li>
<li>Create a new C# class library solution, say <kbd>TestSolution</kbd>, and add one more class library project, say <kbd>ClassLibrary</kbd><em>,</em> to the solution. Now, execute the application with full path to <kbd>TestSolution.sln</kbd> as the argument: <kbd>bin\Debug\ConsoleApp.exe &lt;%test_solution_path%&gt;</kbd>.</li>
<li>Verify the console output shows the project properties for the initial solution with two projects, <kbd>TestSolution</kbd> and <kbd>ClassLibrary</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="355" src="assets/eaea8ea5-56ce-4166-98b9-d7d6e5c28e46.png" width="644"/></div>
<ol start="9">
<li>Press any key to continue and note the following operations were performed: add project to solution, remove project from solution, and edit existing project (add project reference).</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="91" src="assets/cbd48de2-5839-486a-8b70-5e7f7a908c6c.png" width="630"/></div>
<ol start="10">
<li>Press any key to continue and verify the solution now contains two projects <kbd>TestSolution</kbd> and <kbd>AddedClassLibrary</kbd>, and there is a project reference from <kbd>AddedClassLibrary</kbd> to <kbd>TestSolution</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="285" src="assets/ab01e219-8de4-4753-9aae-897a207e462d.png" width="699"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we wrote a C# console application based on Roslyn Workspaces API to perform various operations on a projects in a solution: add, remove, edit, and display project properties. The rich Workspaces APIs provide you with a powerful object model for analyzing and editing projects and documents in a solution. Let's walk through the code and understand how we implemented these operations:</p>
<pre>
public static void Main(string[] args)<br/>{<br/> // Parse arguments to get solution.<br/> string slnPath = ParseArguments(args);<br/> if (slnPath == null)<br/> {<br/>  return;<br/> }<br/><br/> // Create workspace.<br/> MSBuildWorkspace workspace = MSBuildWorkspace.Create();<br/><br/> // Open solution within the workspace.<br/> Console.WriteLine($"Loading solution '{slnPath}'...");<br/> Solution solution = workspace.OpenSolutionAsync(slnPath).Result;<br/><br/> // Display project properties.<br/> DisplayProjectProperties(solution);<br/><br/> // Add project AddedClassLibrary.<br/> WaitForKeyPress();<br/> solution = AddProject(solution, "AddedClassLibrary");<br/><br/> // Remove project ClassLibrary.<br/> solution = RemoveProject(solution, "ClassLibrary");<br/><br/> // Add project reference from AddedClassLibrary to TestSolution.<br/> solution = AddProjectReference(solution, referenceFrom: "AddedClassLibrary", referenceTo: "TestSolution");<br/><br/> // Display project properties.<br/> WaitForKeyPress();<br/> DisplayProjectProperties(solution);<br/>}
</pre>
<p>The Main method invokes individual methods to perform the following operations:</p>
<ul>
<li><kbd>ParseArguments</kbd>: To scan for the input file to parse and transform</li>
<li><kbd>MSBuildWorkspace.Create</kbd>: To create a workspace and <kbd>Workspace.OpenSolutionAsync</kbd> to load the given solution in the workspace</li>
<li><kbd>DisplayProjectProperties</kbd>: To display common properties for all projects in a solution.</li>
<li><kbd>AddProject</kbd>: To add a new project to the solution</li>
<li><kbd>RemoveProject</kbd>: To remove an existing project from a solution</li>
<li><kbd>AddProjectReference</kbd>: To add a project reference to an existing project in a solution</li>
</ul>
<p>Implementation of <kbd>ParseArguments</kbd> is identical to the one in the recipe, <em>Writing an application based on Compiler Syntax API to parse and transform source files.</em> Please refer to the <em>How it works...</em>, section of that recipe for further explanation on this method.</p>
<p><kbd>MSBuildWorkspace</kbd> (<a href="http://source.roslyn.io/#q=MSBuildWorkspace">http://source.roslyn.io/#q=MSBuildWorkspace</a>) is a custom implementation of the core Roslyn Workspace, which uses the MSBuild project model for loading the solution/project files, and allows reading and writing individual documents in the projects.</p>
<p><kbd>DisplayProjectProperties</kbd> displays common project properties such as project name, language, assembly name, references, documents, and so on:</p>
<pre>
private static void <strong>DisplayProjectProperties</strong>(Solution solution)<br/>{<br/> Console.WriteLine($"Project count: {solution.Projects.Count()}");<br/><br/> foreach (var project in solution.Projects)<br/> {<br/>  Console.WriteLine($" Project: {project.Name}");<br/>  Console.WriteLine($" Assembly name: {project.AssemblyName}");<br/>  Console.WriteLine($" Language: {project.Language}");<br/>  Console.WriteLine($" Project file: {project.FilePath}");<br/>  Console.WriteLine($" Output file: {project.OutputFilePath}");<br/>  Console.WriteLine($" Documents: {project.Documents.Count()}");<br/>  Console.WriteLine($" Metadata references: {project.MetadataReferences.Count()}");<br/>  Console.WriteLine($" Project references: {project.ProjectReferences.Count()}");<br/>  Console.WriteLine();<br/> }<br/><br/> Console.WriteLine();<br/>}
</pre>
<p>The <kbd>AddProject</kbd> method creates a barebones <kbd>ProjectInfo</kbd> (<a href="http://source.roslyn.io/#q=ProjectInfo">http://source.roslyn.io/#q=ProjectInfo</a>) with the given <kbd>projectName</kbd>, a unique Project ID, version stamp, assembly name, and C# language name:</p>
<pre>
private static Solution <strong>AddProject</strong>(Solution originalSolution, string projectName)<br/>{<br/> Console.WriteLine($"Adding project '{projectName}'...");<br/> var projectInfo = ProjectInfo.Create(<br/>  id: ProjectId.CreateNewId(),<br/>  version: new VersionStamp(),<br/>  name: projectName,<br/>  assemblyName: "AddedProjectAssembly",<br/>  language: LanguageNames.CSharp);<br/> return originalSolution.AddProject(projectInfo);<br/>}
</pre>
<p>It then invokes the <kbd>Solution.AddProject</kbd> API (<a href="http://source.roslyn.io/#q=Solution.AddProject">http://source.roslyn.io/#q=Solution.AddProject</a>) to add a new project with the created project info to the solution.</p>
<p>The <kbd>RemoveProject</kbd> method removes an existing project with the given <kbd>projectName</kbd> from the solution. It uses the <kbd>Solution.RemoveProject</kbd> API (<a href="http://source.roslyn.io/#q=Solution.RemoveProject">http://source.roslyn.io/#q=Solution.RemoveProject</a>) to remove the project:</p>
<pre>
private static Solution <strong>RemoveProject</strong>(Solution originalSolution, string projectName)<br/>{<br/> Console.WriteLine($"Removing project '{projectName}'...");<br/> var project = originalSolution.Projects.SingleOrDefault(p =&gt; p.Name == projectName);<br/> return originalSolution.RemoveProject(project.Id);<br/>}
</pre>
<p>The <kbd>AddProjectReference</kbd> method adds a project reference from the given <kbd>referenceFrom</kbd> project to the given <kbd>referenceTo</kbd> project. It searches for existing projects in the solution with the given names, creates a <kbd>ProjectReference</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4">http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4</a>) with project ID for the <kbd>referenceFrom</kbd> project, and uses the <kbd>Solution.AddProjectReference</kbd> (<a href="http://source.roslyn.io/#q=Solution.AddProjectReference">http://source.roslyn.io/#q=Solution.AddProjectReference</a>) to add the required reference.</p>
<pre>
private static Solution <strong>AddProjectReference</strong>(Solution originalSolution, string referenceFrom, string referenceTo)<br/>{<br/> Console.WriteLine($"Adding project reference from '{referenceFrom}' to '{referenceTo}'...");<br/> var projectReferenceFrom = originalSolution.Projects.SingleOrDefault(p =&gt; p.Name == referenceFrom);<br/> var projectReference = new ProjectReference(projectReferenceFrom.Id);<br/> var projectReferenceTo = originalSolution.Projects.SingleOrDefault(p =&gt; p.Name == referenceTo);<br/> return originalSolution.AddProjectReference(projectReferenceTo.Id, projectReference);<br/>}
</pre>
<p></p>


            </article>

            
        </section>
    </body></html>