- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Expressions and Statements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和语句
- en: 'Welcome to the first hands-on chapter of our journey! In this chapter, we are
    going to discuss expressions and statements, lambda expressions, and expression
    trees. These are the topics we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们旅程的第一个动手实践章节！在这一章中，我们将讨论表达式和语句、lambda 表达式和表达式树。这些是我们将要讨论的主题：
- en: Understanding the difference between expressions and statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解表达式和语句之间的区别
- en: Writing clear and declarative code using expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式编写清晰和声明性的代码
- en: Utilizing expression-bodied members, lambda expressions, anonymous methods,
    and local functions effectively
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效利用表达式成员、lambda 表达式、匿名方法和局部函数
- en: Manipulating expressions at runtime using expression trees
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用表达式树在运行时操作表达式
- en: Before we dive in, I want to tell you that I value your time, so most of the
    chapters will start with assessment tasks. These tasks are not meant to be solved
    all the time and are aimed to help you measure your existing understanding of
    the topic. If these tasks are no-brainers for you, you might want to skip the
    chapter for now. And vice versa, if the tasks are quite challenging for you, you
    might want to dedicate more time and effort to the chapter. At the end of each
    chapter with tasks, you will find the solutions section to check your answers.
    Now that you know the deal, let’s check the three tasks designed for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入之前，我想告诉你我重视你的时间，所以大多数章节都会从评估任务开始。这些任务并不总是需要解决，目的是帮助你衡量你对这个主题现有理解的程度。如果你觉得这些任务很容易，你可能现在想跳过这一章。反之，如果你觉得这些任务相当具有挑战性，你可能想为这一章投入更多的时间和精力。在每个带有任务的章节结束时，你将找到解决方案部分来检查你的答案。现在你知道了情况，让我们检查为这一章设计的三个任务。
- en: Task 1 – Name and count all expressions and all statements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 1 – 命名并计算所有表达式和所有语句
- en: 'Name and count all expressions and all statements in the code snippet below:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中命名并计算所有表达式和所有语句：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Task 2 – Use expressions instead of statements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 2 – 使用表达式而不是语句
- en: 'Refactor the code below to use expressions instead of statements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码重构为使用表达式而不是语句：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Task 3 – Create an expression tree
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务 3 – 创建一个表达式树
- en: Create an expression tree that is the lambda expression `(baseDamage, level)
    => baseDamage * level`. Then, compile and invoke it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表达式树，它是 lambda 表达式 `(baseDamage, level) => baseDamage * level`。然后编译并调用它。
- en: If you’re 100% sure that you know the answers to all three tasks, then you can
    confidently skip this chapter. However, there’s always a chance you might miss
    something useful, so instead of skipping the chapter entirely, you might want
    to save it for later. In any case, you can always come back and read it if you
    have any questions, or if anything becomes unclear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你百分之百确定你知道所有三个任务的答案，那么你可以自信地跳过这一章。然而，你可能会错过一些有用的东西，所以与其完全跳过这一章，你可能会想把它留到以后。无论如何，如果你有任何问题，或者任何东西变得不清楚，你都可以随时回来阅读。
- en: Understanding the difference between expressions and statements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解表达式和语句之间的区别
- en: At its core, an **expression** in C# is just a piece of code that evaluates
    to a value. Simple expressions include constants, variables, and method calls.
    On the other hand, a **statement** is a standalone unit of code that performs
    an action. In essence, it is an executable instruction. The best way to understand
    something is through practice. So, let’s not delay anymore and look at expressions
    and statements through examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，C# 中的 **表达式** 只是一段代码，它评估为一个值。简单的表达式包括常量、变量和方法调用。另一方面，**语句** 是一个独立的代码单元，执行一个动作。本质上，它是一个可执行的指令。理解某物的最佳方式是通过实践。所以，我们不再拖延，通过例子来查看表达式和语句。
- en: Example of expressions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式的示例
- en: 'Consider the following C# code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 C# 代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this snippet, 20, `pagesPerChapter`, `10`, and `pagesPerChapter * 10` are
    all expressions. Each of these pieces of code evaluates to a value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，20、`pagesPerChapter`、`10` 和 `pagesPerChapter * 10` 都是表达式。这些代码片段中的每一个都会评估为一个值。
- en: Example of statements
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句的示例
- en: 'Now, let’s identify statements:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们识别语句：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, var pagesPerChapter = 20; and var totalBookPages = pagesPerChapter * 10;
    are statements. The first line instructs the program to declare a pagesPerChapter
    variable and initialize it with a value of 20\. The second line instructs the
    program to multiply the value of pagesPerChapter by 10 and save it in the `totalBookPages`
    variable. Both are standalone code units that perform actions, fitting our definition
    of a statement.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`var pagesPerChapter = 20;` 和 `var totalBookPages = pagesPerChapter * 10;`
    是语句。第一行指示程序声明一个 `pagesPerChapter` 变量并将其初始化为20的值。第二行指示程序将 `pagesPerChapter` 的值乘以10并保存到
    `totalBookPages` 变量中。这两行都是独立的代码单元，执行动作，符合我们语句的定义。
- en: Key differences between expressions and statements
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式和语句之间的关键区别
- en: Although statements and expressions can sometimes look similar, remember that
    an expression produces a value and can be used in larger expressions. In contrast,
    a statement performs an action and serves as a part of a method or program structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语句和表达式有时看起来很相似，但请记住，表达式产生一个值并且可以用在更大的表达式中。相比之下，语句执行一个动作，并作为方法或程序结构的一部分。
- en: In C#, every expression can be turned into a statement, but not every statement
    can be an expression. For example, `x = y + 2` is a statement where `y + 2` is
    an expression. However, a `for` loop or an `if` statement cannot be expressions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，每个表达式都可以转换为语句，但并非每个语句都可以是表达式。例如，`x = y + 2` 是一个语句，其中 `y + 2` 是一个表达式。然而，一个
    `for` 循环或一个 `if` 语句不能是表达式。
- en: Guided exercise – finding expressions and statements in sample code
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指导练习——在示例代码中找到表达式和语句
- en: Let’s exercise your knowledge. Can you find and count all the expressions and
    statements in a slightly more complex code snippet?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们锻炼一下你的知识。你能否在稍微复杂一点的代码片段中找到并计数所有表达式和语句？
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we have 8 expressions and 4 statements. Specifically:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有8个表达式和4个语句。具体来说：
- en: '`5`, `1`, `chapter`, `bookCount`, `chapter <= bookCount`, `chapter++`, `1000`,
    `chapter * 1000`, `chapter`, `wordCount`, and `$"Chapter {chapter} contains {``wordCount}
    words."`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5`，`1`，`chapter`，`bookCount`，`chapter <= bookCount`，`chapter++`，`1000`，`chapter
    * 1000`，`chapter`，`wordCount` 和 `$"Chapter {chapter} contains {``wordCount} words."`'
- en: '`int bookCount = 5;`, `for(int chapter = 1; chapter <= bookCount; chapter++)`,
    `var wordCount = chapter * 1000;`, and `Console.WriteLine($"Chapter {chapter}
    contains {``wordCount} words.");`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int bookCount = 5;`，`for(int chapter = 1; chapter <= bookCount; chapter++)`，`var
    wordCount = chapter * 1000;` 和 `Console.WriteLine($"Chapter {chapter} contains
    {``wordCount} words.");`'
- en: Understanding the difference between expressions and statements helps you write
    better, clearer code. As you keep learning C#, you’ll get used to these basics
    and be able to make better software. Keep going with this knowledge, and let’s
    keep exploring functional programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解表达式和语句之间的区别有助于你编写更好的、更清晰的代码。随着你继续学习C#，你会习惯这些基础知识，并能够编写更好的软件。继续用这些知识探索，让我们继续探索函数式编程。
- en: How to use expressions for clear and simple code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用表达式编写清晰简单的代码
- en: Using short and clear code makes it easy to understand what it’s doing. It’s
    also easier for you and others to read later on. Using expressions in C# can help
    us do this. Let’s learn how to shape our code with expressions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简短清晰的代码使其容易理解它在做什么。这也使得你和其他人以后更容易阅读。在C#中使用表达式可以帮助我们做到这一点。让我们学习如何用表达式塑造我们的代码。
- en: The power of expressions – improving readability and maintainability
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式的力量——提高可读性和可维护性
- en: Expressions support the idea of immutability, a cornerstone of functional programming.
    Since expressions evaluate to a value and don’t modify the state of our program,
    they allow us to write code that’s less prone to bugs, easier to reason about,
    and simple to test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式支持不可变性的概念，这是函数式编程的基石。由于表达式会评估为一个值并且不会修改我们程序的状态，因此它们允许我们编写更少出错、更容易推理和简单测试的代码。
- en: One day, Steve received a phone call from his old friend Irene, a renowned author
    of children’s books. She had begun to notice that books with longer titles seemed
    to be more popular. To test her theory, she gathered the titles of all the top-selling
    books and asked Steve to develop a program to calculate the average title length
    associated with popularity.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天，史蒂夫收到了他老朋友艾琳的电话，她是一位著名的儿童书作家。她开始注意到，标题较长的书籍似乎更受欢迎。为了测试她的理论，她收集了所有畅销书的标题，并要求史蒂夫开发一个程序来计算与流行度相关的平均标题长度。
- en: 'Initially, Steve created the program in the manner he was accustomed to:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，史蒂夫以他习惯的方式创建了程序：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the code looked wordy, and he decided to practice a functional approach
    and rewrite the code. He replaced the `foreach` loop with a simple `Average` expression
    that computes the average character count:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码看起来很冗长，他决定练习函数式方法并重写代码。他将 `foreach` 循环替换为一个简单的 `Average` 表达式，该表达式计算平均字符数：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With what almost seemed like magic, all these computations became just a single
    line of code. One line of more functional and concise code using expressions instead
    of statements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎像魔法一样，所有这些计算都变成了单行代码。一行更函数式、更简洁的代码，使用表达式而不是语句。
- en: Techniques to convert statements to expressions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将语句转换为表达式的技巧
- en: A great step toward embracing functional programming in C# is turning your statements
    into expressions where possible. As we just saw, **LINQ** (which stands for **Language
    INtegrated Query**) can be a powerful tool in this transformation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中拥抱函数式编程的一大步是将你的语句尽可能转换为表达式。正如我们刚才看到的，**LINQ**（代表 **Language INtegrated
    Query**）在这个转换中可以成为一个强大的工具。
- en: In the previous example, we used the `Average` method from LINQ. These are extension
    methods available for any `IEnumerable<T>`, allowing us to perform complex operations
    on collections with simple, expressive code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了 LINQ 的 `Average` 方法。这些是针对任何 `IEnumerable<T>` 可用的扩展方法，允许我们通过简单、表达性强的代码在集合上执行复杂操作。
- en: We can further leverage other LINQ methods, such as `Where` for filtering, `OrderBy`
    for sorting, and `Aggregate` for reducing a collection to a single value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步利用其他 LINQ 方法，例如 `Where` 用于过滤，`OrderBy` 用于排序，以及 `Aggregate` 用于将集合缩减为单个值。
- en: 'Also, the code can be transformed to comply with the functional approach even
    without LINQ methods. For example, we can convert `if` statements into a conditional
    operator:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使没有 LINQ 方法，代码也可以转换为符合函数式方法的格式。例如，我们可以将 `if` 语句转换为条件运算符：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Moreover, all `for`, `while`, `foreach`, and so on loops can be replaced with
    recursive methods, which will be expressions when run. In addition, we can use
    the `Result` type instead of exceptions and higher-order functions, which will
    be discussed in later chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有 `for`、`while`、`foreach` 等循环都可以用递归方法替换，运行时它们将是表达式。此外，我们可以使用 `Result` 类型而不是异常和高级函数，这些将在后面的章节中讨论。
- en: Guided exercise – refactoring code using expressions
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指导练习 - 使用表达式重构代码
- en: Emily approached Steve with a request to help her create a program that would
    display the view count of her YouTube videos. However, Emily’s channel comprises
    both private and public videos, and she was interested in counting views only
    for her public ones.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 埃米莉向史蒂夫提出请求，希望他能帮助她创建一个程序，用于显示她 YouTube 视频的观看次数。然而，埃米莉的频道包含私有和公开的视频，她只对公开视频的观看次数感兴趣。
- en: 'Steve wrote a program in which the primary method of counting views looked
    like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫编写了一个程序，其中主要的计数方法看起来是这样的：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, Steve thought he should use this chance to get better at using the functional
    approach and expressions instead of statements. So, he made changes to his code
    using expressions and LINQ methods to make the code clearer and shorter. Now the
    new version looks like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，史蒂夫认为他应该利用这个机会提高使用函数式方法和表达式而不是语句的能力。因此，他使用表达式和 LINQ 方法对他的代码进行了修改，使代码更清晰、更简短。现在的新版本看起来是这样的：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s what we changed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的改变：
- en: The `if` statement has been replaced with the `Where` method. This method filters
    out the elements that do not satisfy a certain condition – in this case, where
    `v.IsPublic` is `false`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 语句已被 `Where` 方法替换。此方法过滤掉不满足特定条件的元素 - 在这种情况下，`v.IsPublic` 为 `false` 的元素。'
- en: The loop that manually adds each video’s views to `totalPublicViews` has been
    replaced with the `Select` method. This method transforms each element – in this
    case, it takes each video (`v`) and transforms it into its view count (`v.Views`).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将每个视频的观看次数添加到 `totalPublicViews` 的循环已被 `Select` 方法替换。此方法将每个元素转换为另一个元素 - 在这种情况下，它将每个视频
    (`v`) 转换为其观看次数 (`v.Views`)。
- en: Finally, the `Sum` method adds up the views from each of the public videos to
    get the total.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`Sum` 方法将每个公开视频的观看次数相加，得到总数。
- en: By using LINQ methods and expressions, the resulting code is clearer, more declarative,
    and more concise. We can now see at a glance what the code does – calculate the
    total number of views for all public videos – rather than how it does it. This
    is the power of expressions in C# – they allow for cleaner, more human-readable
    code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 LINQ 方法和表达式，生成的代码更清晰、更具声明性、更简洁。现在我们可以一眼看出代码的作用——计算所有公开视频的总观看次数——而不是它是如何做到的。这是
    C# 中表达式的力量——它们允许编写更干净、更易于阅读的代码。
- en: Lambda expressions, expression-bodied members, and anonymous methods
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 表达式、表达式成员和匿名方法
- en: Modern C# syntax offers a set of powerful tools for expressing complex functionality
    with elegance and brevity. Let’s take a closer look at these language features
    and how we can use them to make our code more functional, readable, and maintainable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 C# 语法提供了一套强大的工具，可以优雅而简洁地表达复杂的功能。让我们更仔细地看看这些语言特性以及我们如何使用它们来使我们的代码更功能化、更易于阅读和维护。
- en: What are lambda expressions?
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 lambda 表达式？
- en: Lambda expressions, denoted by the `=>` symbol, are a succinct way to create
    anonymous functions. Most likely, you use them daily when working with LINQ and
    similar functional programming constructs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式，由 `=>` 符号表示，是一种创建匿名函数的简洁方式。很可能，你在使用 LINQ 和类似的功能性编程结构时每天都在使用它们。
- en: 'So, let’s look at the following example where we define a lambda to square
    a number:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看以下示例，其中我们定义一个 lambda 来平方一个数字：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This defines a lambda expression that takes an integer, `x`, and returns its
    square. We can then use this function like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个接受整数 `x` 并返回其平方的 lambda 表达式。然后我们可以这样使用这个函数：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Lambda expressions offer great flexibility in parameter types and return values.
    They can take multiple parameters, return complex objects, or even have no parameters
    or return value at all.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式在参数类型和返回值方面提供了极大的灵活性。它们可以接受多个参数，返回复杂对象，甚至没有任何参数或返回值。
- en: Multiple parameters in lambda expressions
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式中的多个参数
- en: 'Of course, methods in C# can contain more than one parameter, and lambda expressions
    can do so as well. In LINQ, one of the easiest methods to demonstrate it is `SelectMany`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，C# 中的方法可以包含多个参数，lambda 表达式也是如此。在 LINQ 中，演示这一点的最简单方法之一是 `SelectMany`：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, in addition to the collection of books and the one-parameter lambda expression,
    `publisher => books.Where(book => book.PublisherId == publisher.Id)`, this method
    also takes a two-parameter lambda expression, `(publisher, book) => new { PublisherName
    = publisher.Name, BookTitle = book.Title }`. As you can see, we just need to add
    parenthesis to use any number of variables.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，除了书籍集合和一个参数的 lambda 表达式 `publisher => books.Where(book => book.PublisherId
    == publisher.Id)` 之外，此方法还接受一个双参数的 lambda 表达式 `(publisher, book) => new { PublisherName
    = publisher.Name, BookTitle = book.Title }`。正如你所看到的，我们只需要添加括号就可以使用任意数量的变量。
- en: Lambda expressions evolution
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式的演变
- en: 'Being a teacher in online C# courses, I like to illustrate the “evolution”
    of lambda expressions to my students. The first thing you need to know here is
    that this type of expression is just syntactic sugar over methods. Let’s look
    at this example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在线 C# 课程中的教师，我喜欢向我的学生展示 lambda 表达式的“演变”。首先你需要知道的是，这种表达式只是方法上的语法糖。让我们看看这个例子：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method calculates whether a book is popular or not and is written in an
    imperative way (tells how to do things, not what to do). To make it smaller, we
    can replace `if` with `return`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法计算一本书是否受欢迎，并以命令式方式（告诉如何做事情，而不是做什么）编写。为了使其更短，我们可以用 `return` 替换 `if`：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make it even shorter, let’s use expression-bodied member syntax:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它更短，让我们使用表达式成员语法：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we try to use the same conditions in the LINQ `Where` function, it will
    look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在 LINQ 的 `Where` 函数中使用相同的条件，它将看起来像这样：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do you see the similarities? This is basically one and the same, so we can
    use our function in the `Where` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到相似之处了吗？这基本上是同一回事，因此我们可以将我们的函数用在 `Where` 方法中：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is another example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个示例：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This happens because `Where` takes a `Func<T, bool>` type as its parameter,
    which is basically what our lambda expression is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `Where` 方法接受一个 `Func<T, bool>` 类型的参数，这基本上就是我们的 lambda 表达式。
- en: And now let me tell you that the example that we used to understand “lambda
    expressions evolution” is actually not a lambda expression. Lambda expressions
    are a syntactic sugar for anonymous methods, and we used an expression-bodied
    member here. So, let’s dig deeper and understand the difference between those
    two.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我告诉你，我们用来理解“lambda表达式演变”的例子实际上并不是一个lambda表达式。Lambda表达式是匿名方法的语法糖，我们在这里使用了表达式成员体。那么，让我们深入挖掘，了解这两个之间的区别。
- en: Understanding anonymous methods
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匿名方法
- en: 'Anonymous methods, as the name suggests, are methods without a name. This ability
    to write unnamed methods right at the place where they are used, especially as
    arguments to other methods, is a significant feature of functional programming
    languages. Here is an interesting fact: anonymous methods are one of the oldest
    features of C#; they were introduced with version 2.0.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，匿名方法是没有名称的方法。这种在它们被使用的地方直接编写无名称方法的能力，尤其是作为其他方法的参数，是函数式编程语言的一个重要特性。这里有一个有趣的事实：匿名方法是C#中最古老的功能之一；它们是在2.0版本中引入的。
- en: 'Here is a simple example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, `delegate(Video video){...}` is an anonymous method, and as
    you can see, it is used directly as an argument to the `ForEach` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`delegate(Video video){...}`是一个匿名方法，正如你所见，它被直接用作`ForEach`方法的参数。
- en: How do anonymous methods work?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名方法是如何工作的？
- en: Anonymous methods work by generating a hidden method at compile time. The compiler
    generates a unique name for the method that isn’t valid in the context of C# naming
    rules, ensuring no possible conflict with your method names.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法通过在编译时生成一个隐藏的方法来工作。编译器为该方法生成一个在C#命名规则上下文中无效的唯一名称，确保不会与你的方法名称发生冲突。
- en: When to use anonymous methods
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用匿名方法
- en: The use of anonymous methods is particularly suitable when the logic of the
    method doesn’t justify a full method declaration. If the code is short, easily
    understandable, and used only in one place, an anonymous method is a good choice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法的逻辑不足以证明完整方法声明的合理性时，使用匿名方法特别合适。如果代码短小、易于理解，并且只在一个地方使用，匿名方法是一个不错的选择。
- en: 'The most common scenarios for using anonymous methods include the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用匿名方法的常见场景包括以下几种：
- en: '**Working with LINQ**: LINQ heavily relies on delegates and anonymous methods,
    especially when filtering, ordering, or projecting data'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用LINQ**：LINQ大量依赖于委托和匿名方法，尤其是在过滤、排序或投影数据时'
- en: '**Event handling**: Anonymous methods can be used when attaching events, especially
    when the event handling code is simple'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：在附加事件时，尤其是当事件处理代码简单时，可以使用匿名方法'
- en: '**Asynchronous programming**: Tasks and threads often use anonymous methods'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**异步编程**：任务和线程经常使用匿名方法'
- en: Practical examples – applying these features in real code
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际示例 - 在实际代码中应用这些功能
- en: 'Another day on the street, Steve met his old friend Konstatos, founder of a
    small game studio that develops mobile games. Konstatos said that he wanted to
    analyze the behavior of a group of players he called “new whales.” Usually, people
    who spend much more money than others on something are called “whales.” So, he
    needed to get this subset of players using two conditions: firstly, they must
    have been registered in a game not earlier than a year ago, and secondly, they
    must have spent at least $10,000 since then.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一天在街上，史蒂夫遇到了他的老朋友Konstatos，他是一个小型游戏工作室的创始人，该工作室开发移动游戏。Konstatos说他想分析一组他称之为“新鲸鱼”的玩家的行为。通常，在某个事物上花费比其他人多得多的人被称为“鲸鱼”。因此，他需要使用两个条件来获取这个子集的玩家：首先，他们必须在一年前或之后注册过游戏，其次，他们必须在此之后至少花费了10,000美元。
- en: 'Steve happily agreed, and now, having practiced a lot on previous tasks, he
    came up with this functional solution:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 史蒂夫欣然同意，现在，在之前任务中大量练习之后，他想出了这个函数式解决方案：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Pay attention that the condition is broken down into two `Where` methods. You
    could do it with just one `Where` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，条件被分解为两个`Where`方法。你可以只用一个`Where`方法来完成：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, the cognitive load for `Where` with two conditions inside is greater,
    which is why the first approach is preferred. Plus, the first method reduces the
    number of affected lines when making further code changes, it’s easier to expand
    (you simply add new `Where` methods on new lines), and it causes fewer merge conflicts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当`Where`方法内部包含两个条件时，认知负载更大，这也是为什么首选第一种方法的原因。此外，第一种方法在进一步修改代码时减少了对受影响行数的修改，更容易扩展（你只需在新行上添加新的`Where`方法），并且引起更少的合并冲突。
- en: Okay, so now that we have seen anonymous methods, let’s look at expression-bodied
    members.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，既然我们已经看到了匿名方法，让我们看看表达式成员。
- en: Expression-bodied members
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式成员
- en: Expression-bodied members are a syntax shortcut that allows methods, properties,
    and other members to be defined using a lambda-like syntax, where the body of
    the member is defined by a single expression following the `=>` operator.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式成员是一种语法快捷方式，允许使用类似lambda的语法定义方法、属性和其他成员，其中成员体由`=>`运算符后的单个表达式定义。
- en: 'Consider the following traditional method for calculating royalty:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下传统的计算版税的方法：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s turn this into an expression-bodied member:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其转换为表达式成员：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ve condensed our method to a one-liner (a piece of functionality written
    in a single line), concise line. The improved brevity enhances readability, especially
    for simple methods and properties. It is important to remember that it is not
    obligatory for the code to use expression-bodied members to be considered functional
    style. In my work, I stick to the rule that only single-line expression-bodied
    members can exist. If the method body starts to contain two or more lines, it
    is better to have fewer merge conflicts and readability to use a regular syntax
    for methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将方法简化为单行（一行编写的功能），简洁的行。这种简化的简洁性提高了可读性，特别是对于简单的方法和属性。重要的是要记住，代码使用表达式成员并不是必须的，才能被认为是函数式风格。在我的工作中，我坚持只存在单行表达式成员的规则。如果方法体开始包含两行或更多，使用常规语法编写方法会更好，这样可以减少合并冲突并提高可读性。
- en: In the next section, we will tackle the powerful concept of expression trees
    and uncover their utility in C#. But first, take some time to absorb these concepts
    and see how you can use them to write more expressive and concise code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨强大的表达式树概念，并揭示其在C#中的实用性。但在那之前，花些时间吸收这些概念，看看您如何可以使用它们来编写更具有表现力和简洁的代码。
- en: Exercise – implementing lambda expressions and anonymous methods
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 – 实现lambda表达式和匿名方法
- en: 'In order for you to have more practice with a functional approach, here is
    a challenge to refactor the following code using expression-bodied members, lambda
    expressions, and anonymous methods:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你在函数式方法上更多练习，这里有一个挑战，要求使用表达式成员、lambda表达式和匿名方法重构以下代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: While it is quite an easy task, it can help us to clarify the difference between
    standard methods and lambda expressions, making our code in a more functional
    style.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这相当容易，但它可以帮助我们明确标准方法和lambda表达式之间的区别，使我们的代码更加函数式。
- en: Expression trees and how to use them to manipulate expressions at runtime
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式树及其在运行时操作表达式的方法
- en: 'Expression trees offer a unique capability in C#: the ability to treat code
    as data and manipulate it at runtime. They are central to the functionality of
    LINQ, allowing us to use the same query syntax for in-memory objects and external
    data sources. Let’s explore this fascinating feature. At a high level, an expression
    tree is a data structure that represents some code in a tree-like format, where
    each node is an expression. Expression trees are constructed from lambda expressions
    and allow you to inspect the code within the lambda as data.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树在C#中提供了一种独特的功能：能够将代码作为数据来处理，并在运行时对其进行操作。它们是LINQ功能的核心，允许我们使用相同的查询语法对内存对象和外部数据源进行查询。让我们探索这个迷人的特性。从高层次来看，表达式树是一种以树形格式表示某些代码的数据结构，其中每个节点都是一个表达式。表达式树由lambda表达式构建，允许您将lambda内的代码作为数据来检查。
- en: 'To illustrate this, consider a simple lambda expression:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑一个简单的lambda表达式：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s rewrite it as a binary expression:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其重写为二元表达式：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The difference might be not significant in code, but let’s look at the inner
    representation of our variables. Here is our `add`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的差异可能并不显著，但让我们看看我们变量的内部表示。这是我们的`add`：
- en: '![](img/B21069_02_001.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21069_02_001.jpg)'
- en: 'As you can see, it has only two fields: `Target`, the class in which this method
    is, and the `Method` field, with the method’s information. Not that much to look
    at. Now, let’s look at `addExpression`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它只有两个字段：`Target`，这是此方法所在的类，以及`Method`字段，包含方法信息。看起来并不多。现在，让我们看看`addExpression`：
- en: '![](img/B21069_02_002.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21069_02_002.jpg)'
- en: 'As you can see, the expression has `NodeType` as `Add` and two parts: `Left`
    and `Right`. Visually, it can be represented like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，表达式具有`NodeType`为`Add`和两个部分：`Left`和`Right`。从视觉上看，它可以表示如下：
- en: '![](img/B21069_02_003.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21069_02_003.jpg)'
- en: Not scary at all, right? If so, let’s move on to expression trees.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不吓人，对吧？如果是这样，让我们继续到表达式树。
- en: Building and manipulating expression trees
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和操作表达式树
- en: 'Building an expression tree manually provides a deeper understanding of its
    structure. Let’s recreate our addition expression:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 手动构建表达式树可以更深入地理解其结构。让我们重新创建我们的加法表达式：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code creates the same expression tree as before but shows the structure
    more clearly. The lambda is formed from a body, `(a + b)`, and a list of parameters,
    `(``a, b)`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个与之前相同的表达式树，但结构更清晰。lambda 由一个体 `(a + b)` 和一个参数列表 `(``a, b)` 组成：
- en: '![](img/B21069_02_004.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21069_02_004.jpg)'
- en: 'Now, our expression tree has two main branches, `Body` and `Parameters`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的表达式树有两个主要分支，`Body` 和 `Parameters`：
- en: '![](img/B21069_02_005.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21069_02_005.jpg)'
- en: 'That looks more like a tree to me. However, it has only one operation in it
    and real expression trees usually contain multiple operations. Let’s add a multiplication
    operation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更像是树。然而，它里面只有一个操作，而真实的表达式树通常包含多个操作。让我们添加一个乘法操作：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This example is much more interesting, and its inner representation is bigger:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子更有趣，其内部表示更大：
- en: '![](img/B21069_02_006.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21069_02_006.jpg)'
- en: 'And this is what our modified visual tree looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的修改后的视觉树看起来像什么：
- en: '![](img/B21069_02_007.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21069_02_007.jpg)'
- en: I hope that now you have a better understanding of what an expression tree looks
    like. This will help us to move forward to a more complex example.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在对表达式树的外观有了更好的理解。这将帮助我们前进到更复杂的例子。
- en: Creating and manipulating complex expression trees
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和操作复杂表达式树
- en: The other day, Irene asked Steve to meet her publisher. It appeared that the
    publisher wanted a program to easily filter popular books. Steve gladly agreed
    and created the advanced filter as an expression tree for their system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前几天，Irene 请求 Steve 和她的出版商见面。看起来出版商想要一个可以轻松过滤流行书籍的程序。Steve 高兴地同意了，并为他们的系统创建了一个高级过滤器作为表达式树。
- en: 'The filter checks whether a book’s title contains a specific keyword, whether
    its number of pages is more than a particular limit, and whether its rating is
    above a certain threshold. Therefore, the expression tree has three different
    expressions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器检查一本书的标题是否包含特定的关键词，其页数是否超过特定的限制，以及其评分是否高于某个阈值。因此，表达式树有三个不同的表达式：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The only thing they need to do in their publishing system is to use `filterExpression`
    to create a delegate for filtering books and use it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的发布系统中，他们需要做的唯一一件事就是使用 `filterExpression` 创建一个用于过滤书籍的委托，并使用它：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The real power of expression trees comes from their ability to be manipulated
    at runtime. You can dynamically build, modify, or even compile and run expression
    trees. This is a powerful tool for runtime code generation and provides the basis
    for technologies such as LINQ and Entity Framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树的真正力量来自于它们在运行时可以被操作的能力。你可以动态地构建、修改，甚至编译和运行表达式树。这是运行时代码生成的一个强大工具，并为 LINQ
    和 Entity Framework 等技术提供了基础。
- en: Querying data with expression trees – LINQ and beyond
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式树查询数据 – LINQ 以及更多
- en: LINQ uses expression trees under the hood to enable the same query syntax for
    different types of data. When you write a LINQ query against an `IQueryable<T>`,
    you’re actually building an expression tree. This tree is then passed to the query
    provider, which translates it into the appropriate format (such as SQL for a database).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 在底层使用表达式树来实现对不同类型数据的相同查询语法。当你对一个 `IQueryable<T>` 编写 LINQ 查询时，你实际上是在构建一个表达式树。然后，这个树被传递给查询提供者，它将其转换为适当的格式（例如，数据库的
    SQL）。
- en: 'Here’s an example of a LINQ query that gets translated into SQL by Entity Framework
    (a popular tool to work with databases in C#):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 LINQ 查询的例子，它被 Entity Framework（一个在 C# 中与数据库交互的流行工具）转换为 SQL：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When this query is run, Entity Framework generates an expression tree, converts
    it into SQL, sends it to the database, and materializes the results back into
    objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个查询运行时，Entity Framework 会生成一个表达式树，将其转换为 SQL，发送到数据库，并将结果实体化回对象。
- en: Guided exercise – constructing and manipulating expression trees
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指导练习 – 构建和操作表达式树
- en: To help you understand expression trees better, let’s look at this exercise.
    Our goal is to create an expression tree representing the lambda expression `(x,
    y) => x * y`. This represents a multiplication operation. Afterward, we’ll compile
    and invoke this expression, effectively performing the multiplication of two numbers.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解表达式树，让我们看看这个练习。我们的目标是创建一个表示lambda表达式`(x, y) => x * y`的表达式树。这代表一个乘法操作。之后，我们将编译并调用这个表达式，实际上执行两个数字的乘法。
- en: 'Let’s break down the steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解步骤：
- en: 'Define the parameters for the lambda expression. These are `x` and `y`, which
    are both of the `int` type:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义lambda表达式的参数。这些是`x`和`y`，它们都是`int`类型：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Construct the body of the lambda expression. This is the `x *` `y` operation:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建lambda表达式的主体。这是`x *` `y`操作：
- en: '[PRE33]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we combine the parameters and the body into a lambda expression:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将参数和主体组合成一个lambda表达式：
- en: '[PRE34]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that we have our expression tree, we can compile it into a delegate:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的表达式树，我们可以将其编译成一个委托：
- en: '[PRE35]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Invoke the delegate with two numbers:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个数字调用代理：
- en: '[PRE36]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Awesome! We have successfully created an expression tree that represents a lambda
    expression, compiled it, and invoked it. This is a fundamental step in understanding
    how expression trees in C# allow us to use code as data, opening up powerful,
    dynamic programming possibilities.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经成功创建了一个表示lambda表达式的表达式树，编译并调用了它。这是理解C#中的表达式树如何允许我们使用代码作为数据，开启强大、动态编程可能性的基本步骤。
- en: Keep practicing these steps with different lambda expressions. Mastery of expression
    trees lets you harness the full potential of C#, giving you capabilities such
    as dynamic code generation and manipulation, advanced querying abilities, and
    much more. Keep at it, you’re doing great!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用不同的lambda表达式不断练习这些步骤。掌握表达式树让你能够充分利用C#的潜力，赋予你诸如动态代码生成和操作、高级查询能力等能力。继续努力，你做得很好！
- en: Problem sets and exercises
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题集和练习
- en: 'After reading about expressions and statements, lambda expressions, and expression
    trees, Steve wrote an email to Julia, asking for the best way to get more hands-on
    experience. Julia congratulated Steve and sent him the list with five points that
    from her understanding every person trying to learn this topic should do:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了关于表达式和语句、lambda表达式和表达式树的内容后，Steve给Julia写了一封电子邮件，询问获得更多实践经验的最佳方法。Julia祝贺Steve并发送了一个包含五点的列表，据她理解，每个试图学习这个主题的人都应该做：
- en: '`IEnumerable<T>` and a predicate in the form of an expression tree and returns
    the filtered results. Use it to filter a list of strings based on their length.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`和一个表达式树形式的谓词，并返回过滤后的结果。使用它根据字符串的长度过滤字符串列表。'
- en: '**Refactor a class** with traditional methods into a version using expression-bodied
    members where appropriate. Compare the two versions.'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构一个类**，将其传统方法版本转换为使用表达式成员的版本。比较这两个版本。'
- en: '**Write an application** that takes a mathematical expression as a string at
    runtime, converts it into an expression tree, and evaluates it. The application
    should support operations such as addition, subtraction, multiplication, and division.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写一个应用程序**，该程序在运行时接受一个数学表达式作为字符串，将其转换为表达式树，并对其进行评估。该应用程序应支持加法、减法、乘法和除法等操作。'
- en: '**Design a mini query language** for querying in-memory objects. This language
    should support basic operations such as filtering and sorting. Use expression
    trees to implement it.'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计一个迷你查询语言**用于内存中对象的查询。这种语言应支持基本操作，如过滤和排序。使用表达式树来实现它。'
- en: '**Code review a project**. Find an open source project on GitHub that uses
    C#, and examine the code to identify where these features (expression-bodied members,
    lambda expressions, and anonymous methods) are used. Analyze how they contribute
    to the code’s readability and maintainability.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码审查一个项目**。在GitHub上找到一个使用C#的开源项目，并检查代码以确定这些功能（表达式成员、lambda表达式和匿名方法）的使用位置。分析它们如何有助于代码的可读性和可维护性。'
- en: Exercises
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In this section, you will help Steve to develop and refactor his tower defense
    game in a functional programming way.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将帮助Steve以函数式编程的方式开发并重构他的塔防游戏。
- en: Exercise 1
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: 'Name and count all expressions and all statements in the code snippet below:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中命名并计算所有表达式和所有语句：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exercise 2
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: Refactor the code below to use expressions instead of statements
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将下面的代码重构为使用表达式而不是语句
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exercise 3
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: Create an expression tree that is the lambda expression, `(x, y) => x * y`.
    Then, compile and invoke it to multiply two numbers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个表示 lambda 表达式 `(x, y) => x * y` 的表达式树，然后编译并调用它来乘以两个数字。
- en: Solutions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解答
- en: Exercise 1
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Expressions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '表达式:'
- en: '`new` `Vector2(5, 5)`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new` `Vector2(5, 5)`'
- en: '`5 (x-coordinate)`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5 (x-coordinate)`'
- en: '`5 (y-coordinate)`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5 (y-coordinate)`'
- en: '`new(position: new` `Vector2(5, 5))`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new(position: new` `Vector2(5, 5))`'
- en: '`1`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`level`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`'
- en: '`mainTower.MaxLevel`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mainTower.MaxLevel`'
- en: '`level <=` `mainTower.MaxLevel`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level <=` `mainTower.MaxLevel`'
- en: '`level++`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level++`'
- en: '`100`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100`'
- en: '`1.5`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.5`'
- en: '`1`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`'
- en: '`level - 1`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level - 1`'
- en: '`Math.Pow(1.5, level -` `1)`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math.Pow(1.5, level -` `1)`'
- en: '`100 * Math.Pow(1.5, level -` `1)`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`100 * Math.Pow(1.5, level -` `1)`'
- en: '`level (in` `string interpolation)`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level (in` `string interpolation)`'
- en: '`upgradeCost (in` `string interpolation)`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upgradeCost (in` `string interpolation)`'
- en: '`$"Upgrading to level {level} costs {``upgradeCost} gold"`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$"Upgrading to level {level} costs {``upgradeCost} gold"`'
- en: '`playerGold`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerGold`'
- en: '`upgradeCost`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upgradeCost`'
- en: '`playerGold >=` `upgradeCost`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerGold >=` `upgradeCost`'
- en: '`upgradeCost (``in subtraction)`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upgradeCost (``in subtraction)`'
- en: 'Statements:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 语句：
- en: '`Tower mainTower = new(position: new` `Vector2(5, 5));`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tower mainTower = new(position: new` `Vector2(5, 5));`'
- en: '`for (int level = 1; level <=` `mainTower.MaxLevel; level++)`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for (int level = 1; level <=` `mainTower.MaxLevel; level++)`'
- en: '`double upgradeCost = 100 * Math.Pow(1.5, level -` `1);`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double upgradeCost = 100 * Math.Pow(1.5, level -` `1);`'
- en: '`Console.WriteLine($"Upgrading to level {level} costs {``upgradeCost} gold");`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.WriteLine($"Upgrading to level {level} costs {``upgradeCost} gold");`'
- en: '`if (playerGold >=` `upgradeCost)`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if (playerGold >=` `upgradeCost)`'
- en: '`mainTower.Upgrade();`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mainTower.Upgrade();`'
- en: '`playerGold -=` `upgradeCost;`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerGold -=` `upgradeCost;`'
- en: 'Total: 22 expressions and 7 statements'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总计：22 个表达式和 7 个语句
- en: Exercise 2
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This refactored version uses LINQ expressions to filter active towers and sum
    their damage in a single line, eliminating the need for explicit loops and conditional
    statements.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重构版本使用 LINQ 表达式来过滤活动塔并计算它们的伤害总和，一行完成，消除了显式循环和条件语句的需求。
- en: Exercise 3
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This solution creates an expression tree representing `(baseDamage, level) =>
    baseDamage * level`, compiles it into a function, and then invokes that function
    to calculate a tower’s damage based on its base damage (10) and level (5).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案创建了一个表示 `(baseDamage, level) => baseDamage * level` 的表达式树，将其编译成函数，然后调用该函数来根据塔的基础伤害（10）和等级（5）计算塔的伤害。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we dove into functional programming in C#, focusing on expressions
    and statements, and the powerful tools that C# provides to elevate your code.
    Let’s summarize the key takeaways:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 C# 中的函数式编程，重点关注表达式和语句，以及 C# 提供的强大工具来提升你的代码。让我们总结一下关键要点：
- en: We learned the difference between expressions and statements. Functional programming
    often prefers expressions for their simple and direct style.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了表达式和语句之间的区别。函数式编程通常更喜欢表达式，因为它们的风格简单直接。
- en: We looked at expression-bodied members, which give a shorter and cleaner way
    to write methods and properties.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了表达式成员，它们提供了一种更短、更干净的方式来编写方法和属性。
- en: We studied lambda expressions and anonymous methods. Both help in writing clear,
    brief, and contained code.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了 lambda 表达式和匿名方法。两者都有助于编写清晰、简洁和紧凑的代码。
- en: We touched on expression trees, a special feature in C# that lets us handle
    code-like data. This is useful for things such as data queries in LINQ.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要介绍了表达式树，这是 C# 中的一个特殊功能，允许我们处理类似代码的数据。这对于 LINQ 中的数据查询等非常有用。
- en: Throughout, our goal was to understand not just how to use these tools but also
    why and when they’re helpful.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们的目标是理解不仅如何使用这些工具，还要了解为什么以及何时它们是有帮助的。
- en: Next, we’ll learn about pure functions, what makes a method “pure,” and what
    side effects mean.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习纯函数，一个方法为什么是“纯”的，以及副作用意味着什么。
