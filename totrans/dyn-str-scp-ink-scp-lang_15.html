<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer133">
			<h1 id="_idParaDest-175"><em class="italic"><a id="_idTextAnchor174"/>Chapter 12</em>: Procedural Storytelling with ink</h1>
			<p>In this chapter, we will review <strong class="bold">procedural storytelling</strong> using ink and Unity. Inkle, the company that created and maintains the narrative scripting language ink, has published multiple games that combine ink and Unity. These games use procedural storytelling to provide different experiences per session based on randomness and player choices. This chapter will introduce approaches to achieving this same general result: loading values in ink and coding collections in Unity.</p>
			<p>In the first topic, we will review the term <em class="italic">procedural storytelling</em> more generally. Based on concepts initially introduced in <a href="B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048"><em class="italic">Chapter 3</em></a>, <em class="italic">Sequences, Cycles, and Shuffling Text</em>, we will learn how to use a shuffle in ink to create dynamic content based on simple rules.</p>
			<p>Diving even deeper into ink, the second topic will demonstrate how to load values in ink. This process focuses on using ink to generate content for players based on simple rules.</p>
			<p>In the final topic, we will switch the emphasis from ink to Unity. We will use Unity to load values and call functions in ink to process values instead. This approach uses more complex code in Unity, but simpler code in ink.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introducing procedural storytelling in ink</li>
				<li>Loading values into ink</li>
				<li>Coding collections in Unity</li>
			</ul>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor175"/>Technical requirements</h1>
			<p>The examples in this chapter can be found online on GitHub: <a href="https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12">https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor176"/>Introducing procedural storytelling in ink</h1>
			<p>The<a id="_idIndexMarker468"/> term <em class="italic">procedural storytelling</em> takes its name from another<a id="_idIndexMarker469"/> term, <em class="italic">procedural generation</em>. The word "procedural" preceding "generation" means that content is created based on a sequence of <em class="italic">procedures</em>; that is, rules. When referring to generating assets such as 3D models or placing non-player characters within some world in a video game, the term <em class="italic">procedural generation</em> applies. When discussing planning, generating, or dynamically ordering content related to the story or experienced narrative of the player within an interactive project, the better term <a id="_idIndexMarker470"/>to use is <strong class="bold">procedural storytelling</strong>.</p>
			<p>Procedural storytelling occurs when a project uses rules to define how a player may interact with or encounter parts of its story content. For example, if a project has a set of rules to create dynamic names for its characters, a player in a science fiction setting may interact with a generated character name of <em class="italic">Neldronor</em>, while a different player might see the name <em class="italic">Vynear</em> for the same entity. Procedurally generating story content can also extend beyond substituting names to deciding which quests a player may have access to, when they encounter certain characters, or even the possible events that may happen in their play session.</p>
			<p>In this topic, we will cover three examples of simple patterns for understanding procedural generation in ink based on randomness. The first, <em class="italic">Random encounters</em>, will explain how to combine the use of a shuffle and threads in ink to create a listing of possible encounters for a player. The second pattern, <em class="italic">Weighted randomness</em>, uses the same concepts as the first pattern but defines the weighted probability a player might see some content. Both patterns are easy ways to add simple procedural generation to an existing project without too much disruption to its existing structure. The last section and pattern, <em class="italic">Conditional content</em>, will cover using the previous actions and input from a player to influence which encounter a player sees. It does so by using concepts from the two previous patterns.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor177"/>Random encounters</h2>
			<p>Many <a id="_idIndexMarker471"/>tabletop<a id="_idIndexMarker472"/> role-playing games use a <a id="_idIndexMarker473"/>concept known as a <strong class="bold">random table</strong>. In the material or book for the game, there is a table or list of possible things a player might encounter in a location or scene. The person running the game would roll some dice, consult the table to find the row matching the rolled number, and then tell the players what they encountered. This system creates the possibility for <em class="italic">random</em> encounters. Based on the random element of the dice, the player would see or interact with different things each time they used the same table to generate content for their game.</p>
			<p>Translated into a digital setting, the random tables of tabletop games can become a set of possible <a id="_idIndexMarker474"/>encounters. In ink, we can create this <a id="_idIndexMarker475"/>using a shuffle and threads:</p>
			<p class="source-code">{shuffle:</p>
			<p class="source-code">    - &lt;- encounter.animal</p>
			<p class="source-code">    - &lt;- encounter.machine</p>
			<p class="source-code">    - &lt;- encounter.person</p>
			<p class="source-code">}</p>
			<p>Because the shuffle will always pick one of its entries at random, each thread has the same probability of occurring. However, as is perhaps not as obvious, <em class="italic">each possible encounter is additional content</em>. Unlike a much more authored experience without any procedural storytelling functionality, even a simple addition such as a table of possible encounters means creating new content per possible encounter:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 1:</p>
			<p class="source-code">{shuffle:</p>
			<p class="source-code">    - &lt;- encounter.animal</p>
			<p class="source-code">    - &lt;- encounter.machine</p>
			<p class="source-code">    - &lt;- encounter.person</p>
			<p class="source-code">}</p>
			<p class="source-code">== encounter</p>
			<p class="source-code">= animal</p>
			<p class="source-code">You hear a soft thud and then see a face peering at you. The sound starts as if it is a meow and then turns into language the longer you listen. "Meee-Hello. Sorry. I'm not used to talking to people.</p>
			<p class="source-code">-&gt; DONE</p>
			<p class="source-code">= machine</p>
			<p class="source-code">The small machine buzzes to life in front of you. "Hi, there! I'm Ge8at10, but you can call me 'Great!'"</p>
			<p class="source-code">-&gt; DONE</p>
			<p class="source-code">= person</p>
			<p class="source-code">You look around and see a man standing awkwardly against a tree. He waves and then looks away before speaking. "Uh. Yeah. Over here. Hi."</p>
			<p class="source-code">-&gt; DONE</p>
			<p><em class="italic">Example 1</em> demonstrates using a shuffle in ink containing three different threads as a simple random encounter system. Each thread references a knot called <strong class="source-inline">encounter</strong> with a stitch named after the kind of encounter, such as <strong class="source-inline">animal</strong>. Based on random selection, the player would see one of three possible encounters.</p>
			<p>Using random encounters, as defined within a shuffle, is an easy way to add simple procedural storytelling in ink to a project. It does require adding extra content per entry in the shuffle, but such a pattern can be the least disruptive to an existing project. It is also possible to have additional sets and create more dynamic outcomes where a player might encounter any number of things across multiple settings, contexts, or levels where each usage is based on a shuffle and threads in ink.</p>
			<p>In the next section, we<a id="_idIndexMarker476"/> will examine weighted probabilities as part of controlling the randomness <a id="_idIndexMarker477"/>of a set of encounters. Instead of all entries having an equal probability of occurring, as is the case when using a shuffle, there may be situations where certain encounters should occur more often for players.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor178"/>Weighted randomness</h2>
			<p>The shuffle is<a id="_idIndexMarker478"/> powerful functionality in<a id="_idIndexMarker479"/> ink. It allows us to create a set of possible entries and then randomly select one. As was seen in the <em class="italic">Random encounters</em> section, a simple set of possible encounters can be created; then, a shuffle can be used to select one as needed. </p>
			<p>However, there may be situations where equally weighted probabilities are not wanted. For example, a developer may only want a player to encounter a character 30% of the time when traveling through a forest area in a game. For these situations, we want to <em class="italic">weight</em> the randomness of encounters.</p>
			<p>In ink, the <strong class="source-inline">RANDOM()</strong> function allows us to define the range of random whole numbers that are produced. If we wanted numbers between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong>, we could use <strong class="source-inline">RANDOM(1,10)</strong>. Based on the number that's returned by the <strong class="source-inline">RANDOM()</strong> function, it is possible to test<a id="_idIndexMarker480"/> values and only act if its result is in a certain range:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 2:</p>
			<p class="source-code">VAR percentage = 0</p>
			<p class="source-code">~ percentage = RANDOM(1,10)</p>
			<p class="source-code">{</p>
			<p class="source-code">    - percentage &lt;= 3: </p>
			<p class="source-code">        &lt;- encounter.brown_wizard</p>
			<p class="source-code">    - else:</p>
			<p class="source-code">        &lt;- encounter.travel</p>
			<p class="source-code">}</p>
			<p class="source-code">== encounter</p>
			<p class="source-code">= brown_wizard</p>
			<p class="source-code">As you move through the forest, you encounter a strange man on a sled driven by large rabbits. You talk for a moment before the man moves away from you and deeper into the forest.</p>
			<p class="source-code">-&gt; DONE</p>
			<p class="source-code">= travel</p>
			<p class="source-code">They travel through the forest.</p>
			<p class="source-code">-&gt; DONE</p>
			<p>In <em class="italic">Example 2</em>, the <strong class="source-inline">brown_wizard</strong> stitch is only encountered if the result from the use of <strong class="source-inline">RANDOM(1, 10)</strong> is less than or equal to <strong class="source-inline">3</strong>. This creates a 30% chance of the player encountering this character. This is an example of a <em class="italic">weighted</em> probability. Instead of an equal probability between the two encounters, one is weighted more than the other. The <strong class="source-inline">travel</strong> stitch is more likely to be encountered by the player than the other stitch, <strong class="source-inline">brown_wizard</strong>.</p>
			<p>In the previous section, <em class="italic">Random encounters</em>, we learned how to create different content within stitches and select them with equal probability using a shuffle. In this section, we controlled this randomness using a weighted probability with the <strong class="source-inline">RANDOM()</strong> function in ink. </p>
			<p>In the next section, we will combine this and the previous pattern for <em class="italic">conditional</em> content. Based on the previous options that were selected by a player, we can influence what the player <a id="_idIndexMarker481"/>encounters using both<a id="_idIndexMarker482"/> randomness and by comparing other values.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor179"/>Conditional content</h2>
			<p>In projects<a id="_idIndexMarker483"/> that don't use randomness, it is <a id="_idIndexMarker484"/>very common to use conditional blocks or choices to respond to what the player selects and how they are progressing through a story. As we saw in the <em class="italic">Random encounters</em> and <em class="italic">Weighted randomness</em> sections, we can also use shuffles and the <strong class="source-inline">RANDOM()</strong> function in ink to shape a story. In this section, we will look at an example of using both concepts together to create more complex procedures to generate connections between content for players.</p>
			<p>In the previous section, <em class="italic">Weighted randomness</em>, we saw how we can create a set of different conditional statements within a block to control what the player encounters next. In <em class="italic">Example 2</em>, this was the weighted outcomes of either the <strong class="source-inline">brown_wizard</strong> or <strong class="source-inline">travel</strong> stitch, with the <strong class="source-inline">travel</strong> stitch more likely to be seen by the player. However, players rarely want to only read the text in a game. They want to have some input over what happens as part of a story.</p>
			<p>By using labels with choices in ink, we can test whether a player selects a particular option and then influence the<a id="_idIndexMarker485"/> weighted outcome for the player:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3:</p>
			<p class="source-code">VAR percentage = 0</p>
			<p class="source-code">A vast forest stretches out before you and alongside the forest is a winding river.</p>
			<p class="source-code">* (travel_forest) [Enter the forest]</p>
			<p class="source-code">* (travel_river) [Travel by river]</p>
			<p class="source-code">-</p>
			<p class="source-code">~ percentage = RANDOM(1,10)</p>
			<p class="source-code">{</p>
			<p class="source-code">    - percentage &lt;= 3 &amp;&amp; travel_forest == 1: </p>
			<p class="source-code">        &lt;- encounter.brown_wizard</p>
			<p class="source-code">    - percentage &gt; 3 &amp;&amp; travel_forest == 1:</p>
			<p class="source-code">        &lt;- encounter.travel</p>
			<p class="source-code">    - travel_river == 1:</p>
			<p class="source-code">        &lt;- encounter.river</p>
			<p class="source-code">}</p>
			<p class="source-code">== encounter</p>
			<p class="source-code">= brown_wizard</p>
			<p class="source-code">As you move through the forest, you encounter a strange man on a sled driven by large rabbits. You talk for a moment before the man moves away from you and deeper into the forest.</p>
			<p class="source-code">-&gt; DONE</p>
			<p class="source-code">= travel</p>
			<p class="source-code">They travel through the forest.</p>
			<p class="source-code">-&gt; DONE</p>
			<p class="source-code">= river</p>
			<p class="source-code">You travel down the river safely.</p>
			<p class="source-code">-&gt; DONE</p>
			<p><em class="italic">Example 3</em> is an updated form of <em class="italic">Example 2</em>. However, instead of merely showing text, the player is presented with two options within a weave. Depending on which one they select, the story then branches along two possible paths. In the first, if the player chooses to travel in the forest, there is a 30% chance they will encounter a character. In the second, if a player chooses to travel by the river, they will not encounter the character.</p>
			<p>While some projects might use shuffle or weighted options, many more incorporate player selections and past choices with randomness. This not only gives the player more control over what they are experiencing, but it also allows the author to craft a story, along with certain predictable outcomes. Instead of trying to account for multiple outcomes <a id="_idIndexMarker486"/>when only using a shuffle, the use <a id="_idIndexMarker487"/>of the weave and its limited number of options shapes the possible paths of future encounters. Because there are only two options in the wave, there are only two possible main branches, with the weighted randomness only affecting one and not the other.</p>
			<p>In this topic, we have examined three different patterns for introducing or adjusting simple procedural storytelling rules in ink projects. In the first section, <em class="italic">Random encounters</em>, we learned how to create a set of equally weighted entries using a shuffle with threads to pull in different story content. In the second section, <em class="italic">Weighted randomness</em>, we explored how to control randomness with weighted outcomes where one outcome was more likely than another.</p>
			<p>In the last section, <em class="italic">Conditional content</em>, we combined randomness with the result of players selecting options and investigated how to create seemingly more advanced rules, where the number of choices within a weave has a stronger influence on the shape of the story than the randomness contained within any one branch.</p>
			<p>In the next topic, we will look at more complex patterns. For many projects, ink will be the driving force behind content generation and how the project uses procedural storytelling. We will look at how to load values into ink as part of examining how to write a grammar for <a id="_idIndexMarker488"/>stories, and then plan<a id="_idIndexMarker489"/> how players will encounter its different parts in dynamic ways.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor180"/>Loading values into ink</h1>
			<p>The <em class="italic">procedural</em> aspect<a id="_idIndexMarker490"/> of procedural storytelling can exist either primarily in ink or Unity. In this topic, we will examine the process of loading values into ink. We will center a design focused on letting ink make procedural decisions about what content a user might see or interact with during a play session.</p>
			<p>In the first section, <em class="italic">Substitution grammars</em>, we will consider how to use what we learned in the previous section, <em class="italic">Introducing procedural storytelling in ink</em>, to build a set of possible events for a player. This will lead us into the next section, <em class="italic">Story planning</em>, where we will apply rules to the grammars themselves. This will allow us to control how different sets of encounters are influenced by previous ones, creating simple formulas for complex stories.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor181"/>Substitution grammars</h2>
			<p>In <a id="_idIndexMarker491"/>linguistics, <strong class="bold">grammar</strong> describes the rules that <a id="_idIndexMarker492"/>define how a language works. For example, in English, there is a specific order of subject, verb, and object in sentences. In programming contexts, we can define what is called <strong class="bold">substitution grammar</strong>, where a set of rules describes how words or phrases are replaced with others. This can often be used to define a specific order, such as the use of subjects and verbs in an English sentence. In a programming context, dynamic constructions can be produced where dynamic or random values are <em class="italic">substituted</em> in specific places in the defined pattern.</p>
			<p>In ink, we can create functions to return values based on shuffles. By writing a grammar – that is, rules for what order entries appear in – we can create a simple substitution pattern where random entries are used from specific sets to create a dynamic text interaction:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 4:</p>
			<p class="source-code">First, we saw the {getLocation()}. Next, we visited the </p>
			<p class="source-code">  {getMarker()}.</p>
			<p class="source-code">== function getLocation() ==</p>
			<p class="source-code">~ return "{~tower|ruin|temple}"</p>
			<p class="source-code">== function getMarker() ==</p>
			<p class="source-code">~ return "{~grave|farmstead|ancient tree}"</p>
			<p>In <em class="italic">Example 4</em>, the <strong class="source-inline">getLocation()</strong> and <strong class="source-inline">getMarker()</strong> ink functions provide the substitutions within the grammar of the sentence. By placing shuffles within the functions and<a id="_idIndexMarker493"/> surrounding them with quotation<a id="_idIndexMarker494"/> marks, the text's result can be returned; that is, where the functions are called. Because all functions are global, this also means they can be used multiple times in the code.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Based on <em class="italic">Example 4</em>, it can be tempting to assume functions can also be used to generate possible divert targets using a shuffle. This is not the case. While variables can hold divert targets, functions are not allowed to divert in ink, and the language prevents combinations of calling functions and using the returned value to thread or divert to another section in a story.</p>
			<p>Functions in ink can be useful for generating and returning text. However, because of its design, ink does not allow functions to control story flow. In cases where each entry within a shuffle might also want to use diverting or threads, we can create an extended tunnel where each part of the tunnel acts as part of the grammar:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 5:</p>
			<p class="source-code"> location -&gt; marker -&gt; DONE</p>
			<p class="source-code">== location</p>
			<p class="source-code">First, we saw the &lt;&gt;</p>
			<p class="source-code">{shuffle:</p>
			<p class="source-code">    - tower</p>
			<p class="source-code">    - ruin</p>
			<p class="source-code">    - temple</p>
			<p class="source-code">}&lt;&gt;.</p>
			<p class="source-code">-&gt;-&gt;</p>
			<p class="source-code">== marker</p>
			<p class="source-code">Next, we saw the &lt;&gt;</p>
			<p class="source-code">{shuffle:</p>
			<p class="source-code">    - grave</p>
			<p class="source-code">    - farmstead</p>
			<p class="source-code">    - ancient tree</p>
			<p class="source-code">}&lt;&gt;.</p>
			<p class="source-code">-&gt;-&gt;</p>
			<p><em class="italic">Example 5</em> is a<a id="_idIndexMarker495"/> rewritten version of <em class="italic">Example 4</em> using an <a id="_idIndexMarker496"/>extended tunnel. For simple text substitution, the pattern shown in <em class="italic">Example 4</em>, which is using shuffles and functions, can be very useful. However, the pattern in <em class="italic">Example 5</em>, which is using knots and multi-line shuffles, allows each entry in the shuffle to potentially divert or use threads themselves. This is often the preferred pattern for creating a substitution grammar, where each part of the grammar can expand as needed.</p>
			<p>In this section, we learned how to use substitution grammar for text and then a more advanced one for incorporating tunnels. In the next section, we will apply substitution grammar as part of a planning process for stories. Loops and other conditional aspects will be introduced to create more advanced substitution grammars.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor182"/>Story planning</h2>
			<p>In the <a id="_idIndexMarker497"/>previous section, we saw how substitution<a id="_idIndexMarker498"/> grammars can provide us with a specific order of events. By using shuffles, we can pick random entries for each part and create a dynamic experience for a player. In the examples shown in the previous section, there was also only one entry per part of the grammar. There was one for <strong class="source-inline">location</strong>, one for <strong class="source-inline">marker</strong>, and then the tunnel ended. This is useful, but many games will want to create dynamic patterns based on previous entries. In other words, it is also possible to base the range of future entries on previous ones within a grammar.</p>
			<p>When we create a formula where previous entries can affect future entries as part of advanced grammar, we are using a concept called <strong class="bold">story planning</strong>. In procedural storytelling, story planning occurs when the story is <em class="italic">planned</em> based on rules for generating more complex patterns than simple substitution.</p>
			<p>As explained in <a href="B17597_03_Final_PG_ePub.xhtml#_idTextAnchor048"><em class="italic">Chapter 3</em></a>, <em class="italic">Sequences, Cycles, and Shuffling Text</em>, alternatives can be embedded inside each other. This means we can use alternatives inside of multi-line conditional blocks to create contexts where, based on previous values, random entries can be chosen:</p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 6:</p>
			<p class="source-code">VAR location_pick = 0</p>
			<p class="source-code">-&gt; location -&gt; marker -&gt; DONE</p>
			<p class="source-code">== location</p>
			<p class="source-code">First, we saw the &lt;&gt;</p>
			<p class="source-code">{shuffle:</p>
			<p class="source-code">    - tower</p>
			<p class="source-code">        ~ location_pick = "tower"</p>
			<p class="source-code">    - ruin</p>
			<p class="source-code">        ~ location_pick = "ruin"</p>
			<p class="source-code">    - temple</p>
			<p class="source-code">        ~ location_pick = "temple"</p>
			<p class="source-code">}&lt;&gt;.</p>
			<p class="source-code">-&gt;-&gt;</p>
			<p class="source-code">== marker</p>
			<p class="source-code">Next, we saw the &lt;&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    - location_pick == "tower":</p>
			<p class="source-code">       {shuffle:</p>
			<p class="source-code">            - grave</p>
			<p class="source-code">            - memorial stone</p>
			<p class="source-code">        }</p>
			<p class="source-code">    - else:</p>
			<p class="source-code">        {shuffle:</p>
			<p class="source-code">            - farmstead</p>
			<p class="source-code">            - ancient tree</p>
			<p class="source-code">        }</p>
			<p class="source-code">}&lt;&gt;.</p>
			<p class="source-code">-&gt;-&gt;</p>
			<p>In <em class="italic">Example 6</em>, a new <a id="_idIndexMarker499"/>variable has been introduced based<a id="_idIndexMarker500"/> on the code from <em class="italic">Example 5</em>. In this new version, the values of the <strong class="source-inline">marker</strong> knot are based on the <strong class="source-inline">location_pick</strong> variable. Within the extended tunnel moving from the <strong class="source-inline">location</strong> knot to the <strong class="source-inline">marker</strong> knot, the <strong class="source-inline">location_pick</strong> variable is changed. Depending on its value moving into the <strong class="source-inline">marker</strong> knot, different results can be produced. If the random entry from <strong class="source-inline">location</strong> is <strong class="source-inline">"tower"</strong>, the first two values, <strong class="source-inline">grave</strong> and <strong class="source-inline">memorial</strong> <strong class="source-inline">stone</strong>, are enabled. Otherwise, the <strong class="source-inline">farmstead</strong> and <strong class="source-inline">ancient</strong> <strong class="source-inline">tree</strong> values are.</p>
			<p>In this topic, we focused on loading and generating values in ink. In the first section, <em class="italic">Substitution grammars</em>, we learned how to create simple patterns. In this section, <em class="italic">Story planning</em>, we reviewed a simple example of story planning using a single variable for branching within the second part of a tunnel. Depending on the planning that's wanted, authors can create very complex grammars using different variables where previous values can branch out future calculations and ranges of entries in shuffles or other alternatives.</p>
			<p>In the next topic, we will move away from ink and back into Unity. When it comes to scripting narrative experiences, ink is an incredible language. However, ink does not work well with more complex value manipulations. In Unity, with the use of C#, we can perform much more complicated procedural storytelling approaches, where we can make decisions <a id="_idIndexMarker501"/>about which ink story to load and how to<a id="_idIndexMarker502"/> pass its values to make decisions internally.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor183"/>Coding collections in Unity</h1>
			<p>In the previous<a id="_idIndexMarker503"/> topic, we examined ways to have ink create and plan content for a player. In this section, we move back into Unity. Often, in large projects, story and otherwise, narrative content will be one of several complex interlocking mechanics in a game. In these cases, procedural storytelling will be one of multiple systems, and Unity, as the game engine driving the project, will be programmed to use one story over another as part of more complex operations and planning. In these cases, the narrative content is stored in what C# names <em class="italic">collections</em>. These can be something as simple as an array or a much more complex data structure capable of sorting its internal elements based on patterns or the values of their internal elements.</p>
			<p>In the first section, <em class="italic">Using multiple stories</em>, we will look at an example of moving the procedural storytelling aspect of a project from ink into Unity. Instead of working with shuffles in ink, we will use randomness in Unity to select between different possible stories within a collection and then remove them from future selections. This will allow us to concentrate on the story content in ink, creating dialog or player choices within separate files, and then use Unity to choose what to show a player.</p>
			<p>In the final section, <em class="italic">Conditionally choosing stories</em>, we will apply the concept of simple story planning, as shown in the <em class="italic">Story planning</em> subsection, using ink in Unity. Much like it did in ink, this will allow us to start to define a substitution grammar for how we want story content to appear to the player, but with the coded collections in Unity <a id="_idIndexMarker504"/>performing the work of selecting parts instead of ink.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor184"/>Using multiple stories</h2>
			<p>As we first <a id="_idIndexMarker505"/>explored in <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a>, <em class="italic">Quest Tracking and Branching Narratives</em>, in the <em class="italic">Tracking progress across multiple quests</em> topic, it is possible to use multiple ink files as separate instances of the <strong class="source-inline">Story</strong> class in a project. In that topic, each file was a separate quest. However, it is also possible to use each file as a scene within a larger story. In these cases, each ink file would represent a separate narrative experience for a player. This could become part of a session or a longer story, upon being selected by Unity, to show the player in a random order.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a> examples on GitHub under the name <strong class="source-inline">Chapter12-MultipleStories</strong>. Only select parts of the code will be shown as they relate to the concepts being examined.</p>
			<p>When you're using multiple ink files to break a story down into different scenes where each could be accessed independently of each other, the easiest way to approach this is to load them all at once. The following project uses a method named <strong class="source-inline">GetFiles()</strong> to process the compiled JSON files and create <strong class="source-inline">Story</strong> class instances. With each new object that's created, it is added to a <strong class="source-inline">List&lt;Story&gt;</strong> collection named <strong class="source-inline">Stories</strong>:</p>
			<p class="source-code">void GetFiles()</p>
			<p class="source-code">{</p>
			<p class="source-code">     string inkPath = Application.dataPath + "/Ink/";</p>
			<p class="source-code">     foreach (string file in Directory.GetFiles(inkPath,</p>
			<p class="source-code">       "*.json"))</p>
			<p class="source-code">     {</p>
			<p class="source-code">           string contents = File.ReadAllText(file);</p>
			<p class="source-code">           Stories.Add(new Story(contents));</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>In the <em class="italic">Random encounter</em> section of the <em class="italic">Introducing procedural storytelling in ink</em> topic, a shuffle was used to pick between different threads. In C#, the <strong class="source-inline">Random</strong> class works similarly. It provides random data based on some range. Using its <strong class="source-inline">Next()</strong> method<a id="_idIndexMarker506"/> and the <strong class="source-inline">Count</strong> property of the collection, it provides an index to select between entries in the <strong class="source-inline">List&lt;Story&gt;</strong> collection, which is populated by the <strong class="source-inline">GetFiles()</strong> method:</p>
			<p class="source-code">void PickRandomStory()</p>
			<p class="source-code">{</p>
			<p class="source-code">      if (Stories.Count &gt; 0)</p>
			<p class="source-code">     {</p>
			<p class="source-code">           System.Random rand = new System.Random();</p>
			<p class="source-code">           int index = rand.Next(Stories.Count);</p>
			<p class="source-code">           Story entry = Stories[index];</p>
			<p class="source-code">           Stories.RemoveAt(index);</p>
			<p class="source-code">           UpdateContent(entry);</p>
			<p class="source-code">     }</p>
			<p class="source-code">     else</p>
			<p class="source-code">     {</p>
			<p class="source-code">           SceneDescription.text = "(There are no more</p>
			<p class="source-code">             stories.)";</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>To prevent the same story from appearing again, the <strong class="source-inline">RemoveAt()</strong> method removes the entry from the <strong class="source-inline">List&lt;Story&gt;</strong> collection at random. This prevents the same story from being shown twice.</p>
			<p>Put together, the <strong class="source-inline">Start()</strong> method is used to call multiple other methods to parse the files and pick a random story. Based on the weave contained in the randomly picked <strong class="source-inline">Story</strong>, a method named <strong class="source-inline">UpdateContent()</strong>, which is called from <strong class="source-inline">PickRandomStory()</strong>, presents two options to the player as <strong class="source-inline">Button</strong> game objects. Clicking on either of these changes the value of a variable within the story. This is then shown to the player as updates to two variables, <strong class="source-inline">violence</strong> and <strong class="source-inline">peace</strong>, which are tracked in<a id="_idIndexMarker507"/> Unity:</p>
			<p class="source-code">void Start()</p>
			<p class="source-code">{</p>
			<p class="source-code">     Stories = new List&lt;Story&gt;();</p>
			<p class="source-code">     UpdateStatistics();</p>
			<p class="source-code">     GetFiles();</p>
			<p class="source-code">     PickRandomStory();</p>
			<p class="source-code">}</p>
			<p>While relatively simple, the project shown in this section illustrates an important aspect of balancing between ink and Unity as separate systems for procedural storytelling. The complexity of an ink story is not reflected in the C# code needed to pick it from a collection or show its contents. Simple code can be used in Unity to randomly select an ink story that, itself, uses randomness, substitution grammars, or its story planning in its design. In Unity, the C# <strong class="source-inline">Random</strong> class can be used without any knowledge of what an ink story is doing.</p>
			<p>In the next section, we will follow a similar movement to what we did in the <em class="italic">Introducing procedural storytelling in ink</em> topic. In this first section, we focused on using multiple ink stories with the C# <strong class="source-inline">Random</strong> class while picking between them equally. However, most projects will want to only select ink stories based on preconditions. In the next section, we will look at conditionally choosing between ink stories.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor185"/>Conditionally choosing stories</h2>
			<p>In the previous<a id="_idIndexMarker508"/> section, we saw how the C# <strong class="source-inline">Random</strong> class allows us to pick between objects based on the <strong class="source-inline">Story</strong> class as part of a collection, <strong class="source-inline">List&lt;Story&gt;</strong>. This has limited usefulness for most projects. Instead, most developers would prefer to have control over when an ink story is selected and the conditions under which it becomes available. In this section, we will look at a simple implementation of a system that checks the preconditions of a story before loading any of its contents. Values will be tracked across stories in the collection and, if the preconditions are met for the story, it will be considered available. If not, it will be ignored.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The completed project for this section can be found in the <a href="B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174"><em class="italic">Chapter 12</em></a> examples on GitHub under the name <strong class="source-inline">Chapter12-ConditionalStories</strong>. Only select parts of the code will be shown as they relate to the concepts being examined.</p>
			<p>To check the preconditions of ink stories, there needs to be a separate class, <strong class="source-inline">ConditionalStory</strong>, that contains the ink story and methods that originally appeared in the <em class="italic">Tracking quest values</em> subsection of the <em class="italic">Displaying and awarding player progression</em> section in <a href="B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159"><em class="italic">Chapter 11</em></a>, <em class="italic">Quest Tracking and Branching Narratives</em>, including simplified versions of <strong class="source-inline">ObserveVariables()</strong> and <strong class="source-inline">UpdateVariable()</strong>:</p>
			<p class="source-code">public void ObserveVariables(Story.VariableObserver</p>
			<p class="source-code">  callback)</p>
			<p class="source-code">{</p>
			<p class="source-code">      InkStory.ObserveVariables(new List&lt;string&gt;() {</p>
			<p class="source-code">        "violence", "peace" }, callback);</p>
			<p class="source-code">}</p>
			<p class="source-code">public void UpdateVariable(string name, object value)</p>
			<p class="source-code">{</p>
			<p class="source-code">      if(InkStory.variablesState.</p>
			<p class="source-code">        GlobalVariableExistsWithName(name))</p>
			<p class="source-code">      {</p>
			<p class="source-code">          if (!InkStory.variablesState[name].Equals(value))</p>
			<p class="source-code">          {</p>
			<p class="source-code">                 InkStory.variablesState[name] = value;</p>
			<p class="source-code">          }</p>
			<p class="source-code">      }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ConditionalStory</strong> class has a method called <strong class="source-inline">Available()</strong>. Internally, this uses the <strong class="source-inline">EvaluateFunction()</strong> method of the <strong class="source-inline">Story</strong> class to call an ink function named <strong class="source-inline">check()</strong>. Assuming the ink story contains the function, it will be called, and the result will be <a id="_idIndexMarker509"/>converted into a Boolean value:</p>
			<p class="source-code">public bool Available()</p>
			<p class="source-code">{</p>
			<p class="source-code">     bool result = false;</p>
			<p class="source-code">     if(InkStory.HasFunction("check"))</p>
			<p class="source-code">     {</p>
			<p class="source-code">           result = (bool)</p>
			<p class="source-code">              InkStory.EvaluateFunction("check");</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return result;</p>
			<p class="source-code">}</p>
			<p>Each story file has a conditional check that is fed back into the <strong class="source-inline">Available()</strong> method of the <strong class="source-inline">ConditionalStory</strong> class. If the <strong class="source-inline">check()</strong> ink function returns <strong class="source-inline">true</strong>, the story is available for use.</p>
			<p>Various changes have been made to the code shown in the previous section, <em class="italic">Using multiple stories</em>. The first is the use of <strong class="source-inline">ConditionalStory</strong> as a class containing an object based on the <strong class="source-inline">Story</strong> class. The second is the <strong class="source-inline">SelectStories()</strong> method. Unlike picking a random entry, it uses the <strong class="source-inline">FindAll()</strong> method of <strong class="source-inline">List&lt;ConditionalStory&gt;</strong> to search through its entries. If the <strong class="source-inline">Available()</strong> method, which is calling the <strong class="source-inline">check()</strong> ink function each time, reports <strong class="source-inline">true</strong>, it considers<a id="_idIndexMarker510"/> the story to be available:</p>
			<p class="source-code">List&lt;ConditionalStory&gt; selection = Stories.FindAll(e =&gt; </p>
			<p class="source-code">  e.Available());</p>
			<p class="source-code">if (selection.Count &gt; 0)</p>
			<p class="source-code">{</p>
			<p class="source-code">      System.Random rand = new System.Random();</p>
			<p class="source-code">      int index = rand.Next(selection.Count);</p>
			<p class="source-code">      ConditionalStory entry = selection[index];</p>
			<p class="source-code">      Stories.Remove(entry);</p>
			<p class="source-code">      UpdateContent(entry);</p>
			<p class="source-code">}</p>
			<p>If each ink story defines how and if it is available for use in a larger project, this allows the ink and C# code in Unity to be developed separately. To become available so that it can be selected, the <strong class="source-inline">check()</strong> function in ink must report <strong class="source-inline">true</strong> to the <strong class="source-inline">ConditionalStory</strong> class in C#. This creates a simple but easily repeatable pattern for creating conditional stories in Unity based on understanding how its collections work by using the <strong class="source-inline">FindAll()</strong> method, as specified in this section, and the <strong class="source-inline">Random</strong> class, as<a id="_idIndexMarker511"/> specified in the previous section, in C# to access individual entries based on their indices.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor186"/>Summary</h1>
			<p>The goal of this chapter was not to solve all problems with procedural storytelling or to cover every possible algorithm. The first topic, <em class="italic">Introducing procedural storytelling in ink</em>, reviewed the important concepts, such as how randomness can play a role in selecting content in ink. The second section, <em class="italic">Loading values into ink</em>, looked at how more advanced concepts such as grammars and story planning can be used with ink. Finally, in the <em class="italic">Coding collections in Unity</em> topic, we saw how Unity can be used to randomly select ink stories in a collection in the first section, as well as how some simple conditional testing can be incorporated by communicating between ink stories and C# classes in Unity.</p>
			<p>We have now completed the last chapter of this book and hope that you will walk away with different concepts to explore and with simple patterns to use for much more advanced projects. Procedural storytelling is a diverse and deep subject. Many researchers and developers have created and continue to explore possible ways to build substitution grammars, plan for stories, and use ink and Unity, either separately or together, to craft simple rules for complex stories and experiences for players.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor187"/>Questions</h1>
			<ol>
				<li>What is procedural storytelling?</li>
				<li>What is a random table?</li>
				<li>What is weighted randomness?</li>
				<li>What is substitution grammar?</li>
				<li>What is story planning?</li>
			</ol>
		</div>
	</div></body></html>