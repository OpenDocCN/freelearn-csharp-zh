- en: Chapter 7. Creating a Game with NGUI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：使用NGUI创建游戏
- en: In this final chapter, we will create a game using NGUI elements, and this will
    ensure that you understand them and know how to use them perfectly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将使用NGUI元素创建一个游戏，这将确保你理解它们并知道如何完美地使用它们。
- en: 'Together, we will learn how to create these basic game rules, which are as
    follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一起，我们将学习如何创建以下基本游戏规则：
- en: Enemies fall down from the top of our scrollable viewport.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 敌人从可滚动的视图中顶部掉落。
- en: The player drops Barriers on the Viewport—if the enemy collides with a built
    Barrier, he or she is destroyed along with the Barrier.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家在视图中放置障碍物——如果敌人与已建造的障碍物相撞，那么敌人和障碍物都会被摧毁。
- en: Some enemies have encrypted self-destruct code. The player clicks on the enemy
    to hack it. When the hacking process is complete, its destruct code is displayed
    above it.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些敌人有加密的自毁代码。玩家点击敌人以破解它。当破解过程完成后，其自毁代码将显示在其上方。
- en: The player must type in the code to destroy the enemy.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家必须输入代码来摧毁敌人。
- en: 'We will also add a health bar that will represent the player''s health points
    and will decrease when enemies hit the bottom of the screen. The game will look
    as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个表示玩家生命值的生命条，当敌人击中屏幕底部时，它会减少。游戏将看起来如下：
- en: '![Creating a Game with NGUI](img/8667OT_07_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![使用NGUI创建游戏](img/8667OT_07_01.jpg)'
- en: Enemy spawning
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人生成
- en: We want our enemies to spawn at the top of the viewport's background. At spawn,
    the Y value can be the same for each of the enemies, but we want a random X value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的敌人从视图中背景的顶部生成。在生成时，每个敌人的Y值可以相同，但我们希望有一个随机的X值。
- en: First of all, let's open our **Game** scene.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开我们的**Game**场景。
- en: Creating the enemies container
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌人容器
- en: Our enemies will be nested in a container placed at the top left-hand corner
    of our background in order to have the {0, 0} positioned at the top left-hand
    corner of the viewport.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将敌人嵌套在一个放置在我们背景顶部左角的容器中，以便将{0, 0}定位在视口的顶部左角。
- en: 'First, let''s create our enemies holder by performing the following steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过以下步骤创建我们的敌人持有者：
- en: 'Select our **Viewport** GameObject and perform the following steps:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Viewport**GameObject并执行以下步骤：
- en: Create a new child by pressing *Alt* + *Shift* + *N*.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Alt* + *Shift* + *N*创建一个新的子对象。
- en: Rename this new child as `Enemies`.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的子对象重命名为`Enemies`。
- en: 'Attach **Anchor** to it by navigating to **NGUI** | **Attach**. Then perform
    the following steps:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **Attach**将其附加**Anchor**。然后执行以下步骤：
- en: Drag our **Background** from Viewport into the **Container** field.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**Background**从视图中拖动到**Container**字段。
- en: Set its **Side** parameter to **TopLeft**.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**Side**参数设置为**TopLeft**。
- en: Ok, we now have our enemies container in which we will instantiate our **Enemy**
    prefab.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了敌人容器，我们将在这个容器中实例化我们的**Enemy**预制体。
- en: Creating the Enemy prefab
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌人预制体
- en: Let's create the **Enemy** prefab that will be instantiated as child of the
    **Enemies** GameObject. You must add the `Enemy.png` file included in the `Assets.zip`
    file to the **Game** atlas before you continue or you may create your own 128
    x 160 sprite. We will use a **Rigidbody** to detect collisions between the enemies
    and our barriers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个**Enemy**预制体，它将被实例化为**Enemies**GameObject的子对象。在继续之前，你必须将包含在`Assets.zip`文件中的`Enemy.png`文件添加到**Game**图集中，或者你可以创建自己的128
    x 160精灵。我们将使用**Rigidbody**来检测敌人和我们的障碍物之间的碰撞。
- en: 'Once the `Enemy.png` sprite has been added to the **Game** atlas, follow the
    given steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`Enemy.png`精灵添加到**Game**图集中，按照以下步骤操作：
- en: 'Select our **Viewport** GameObject and perform the following steps:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Viewport**GameObject并执行以下步骤：
- en: Create a new child with *Alt* + *Shift* + *N*.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Alt* + *Shift* + *N*创建一个新的子对象。
- en: Rename this new child as `Spaceship`.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的子对象重命名为`Spaceship`。
- en: Select our new **Spaceship** GameObject.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们新的**飞船**GameObject。
- en: 'Attach a collider to it by navigating to **NGUI** | **Attach a Collider** and
    perform the following steps:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **Attach a Collider**将其附加一个碰撞器，并执行以下步骤：
- en: Uncheck its **Is Trigger** Boolean to detect collisions.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消其**Is Trigger**布尔值以检测碰撞。
- en: Set **Size** to {`128`, `160`, `1`}.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Size**设置为{`128`, `160`, `1`}。
- en: 'Attach a **Rigidbody** component to it by navigating to **Component** | **Physics**
    and then perform the following steps:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**Component** | **Physics**将其附加一个**Rigidbody**组件，然后执行以下步骤：
- en: Uncheck its **Use Gravity** Boolean.
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消其**Use Gravity**布尔值。
- en: Check its **Is Kinematic** Boolean.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其**Is Kinematic**布尔值。
- en: Check the **Freeze Position** and **Freeze Rotation** Booleans for all its **Constraints**
    in order to avoid any unwanted behavior.
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其所有**约束**中的**冻结位置**和**冻结旋转**布尔值，以避免任何不希望的行为。
- en: 'With our selected **Spaceship** GameObject, create a new **Sprite** by navigating
    to **NGUI** | **Create** | **Sprite**:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们选定的**飞船**GameObject，通过导航到**NGUI** | **创建** | **精灵**创建一个新的**精灵**：
- en: Change its **Sprite** to our new **Enemy** sprite.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**精灵**更改为我们新的**敌人**精灵。
- en: Change its **Dimensions** to `128` x `160`.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**更改为`128` x `160`。
- en: Set its **Depth** to `1`.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**设置为`1`。
- en: Drag our **Spaceship** GameObject in your `Prefabs` folder.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**飞船**GameObject拖到你的`Prefabs`文件夹中。
- en: Delete our **Spaceship** instance from the scene.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从场景中删除我们的**飞船**实例。
- en: 'Ok, we now have our **Enemy** prefab ready. Let''s add a new script to it that
    will handle the enemy''s initialization and movement, and perform the following
    steps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了我们的**敌人**prefab。让我们向它添加一个新的脚本，该脚本将处理敌人的初始化和移动，并执行以下步骤：
- en: In the **Project** view, select our **Spaceship** prefab.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中选择我们的**飞船**prefab。
- en: Create and attach a new `EnemyController.cs` C# script to it.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其创建并附加一个新的 `EnemyController.cs` C# 脚本。
- en: Open this new `EnemyController.cs` script.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的 `EnemyController.cs` 脚本。
- en: 'Let''s create a new `Initialize()` method that will set the enemy''s position
    outside the game with a random X and a tween duration depending on the float value
    that is passed as a parameter in the following manner:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 `Initialize()` 方法，该方法将设置敌人的位置在游戏外，具有随机的 X 坐标和根据传递给参数的浮点值确定的缓动持续时间：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We used `spriteSize.x * 0.5f` in the preceding code because our enemy has a
    centered pivot and we want to avoid spawning it outside the background's width.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用 `spriteSize.x * 0.5f` 是因为我们的敌人有一个居中的枢轴，我们想要避免在背景宽度外生成它。
- en: The `_movementDuration` parameter is used to define how much time the enemy
    will take to cross our entire background; it is used as speed. But to balance
    the speed, a value of 10 is used, which means that the enemy will need 10 seconds
    to hit the bottom of the background.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`_movementDuration` 参数用于定义敌人穿越整个背景所需的时间；它用作速度。但为了平衡速度，使用了10的值，这意味着敌人需要10秒钟才能到达背景底部。'
- en: 'At this stage, your hierarchy should look as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你的层次结构应该如下所示：
- en: '![Creating the Enemy prefab](img/8667OT_07_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人预制体](img/8667OT_07_02.jpg)'
- en: Creating the enemy spawn controller
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建敌人生成控制器
- en: 'Before we can launch the game, we need to add an `EnemySpawnController.cs`
    script that will handle enemy spawn rates and instantiate enemies when needed.
    To add the script, perform the following steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以启动游戏之前，我们需要添加一个 `EnemySpawnController.cs` 脚本，该脚本将处理敌人生成速率并在需要时实例化敌人。要添加脚本，请执行以下步骤：
- en: Select the **Enemies** GameObject from **Viewport**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**视口**中选择**敌人**GameObject。
- en: Create and attach a new `EnemySpawnController.cs` C# script.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并附加一个新的 `EnemySpawnController.cs` C# 脚本。
- en: Open this new `EnemySpawnController.cs` script.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的 `EnemySpawnController.cs` 脚本。
- en: 'In this new script, we need to add a `SpawnEnemy()` coroutine that will be
    called at random intervals to instantiate **Enemy** prefabs and initialize them
    with the correct position and tween duration. First, we need to declare these
    variables as shown in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新脚本中，我们需要添加一个 `SpawnEnemy()` 协程，该协程将在随机间隔被调用以实例化**敌人**prefab，并使用正确的位置和缓动持续时间初始化它们。首先，我们需要声明以下代码片段中所示这些变量：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variables declared in the previous code will be used to control our random
    values. You may change them in the **Inspector** view. We need to assign our `enemyPrefab`
    variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中声明的变量将被用来控制我们的随机值。你可以在**检查器**视图中更改它们。我们需要分配我们的 `enemyPrefab` 变量。
- en: 'To do this, go back to Unity and follow the given steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请回到 Unity 并遵循以下步骤：
- en: Select the **Enemies** GameObject from **Viewport**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**视口**中选择**敌人**GameObject。
- en: Drag our **Spaceship** prefab from the **Project** view inside the **Enemy Prefab**
    field in **Enemy Spawn Controller**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**飞船**prefab从**项目**视图拖到**敌人生成控制器**中的**敌人预制体**字段内。
- en: 'Ok, the necessary variables are initialized. Now, let''s go back to our `EnemySpawnController.cs`
    script and add a new `SpawnEnemy()` coroutine by using the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，必要的变量已经初始化。现在，让我们回到我们的 `EnemySpawnController.cs` 脚本，并使用以下代码片段添加一个新的 `SpawnEnemy()`
    协程：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our coroutine is ready. Let''s start it when the game starts running. We can
    use the `Start()` method for this. Add this method just below our `SpawnEnemy()`
    coroutine in the following manner:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协程已经准备好了。让我们在游戏开始运行时启动它。我们可以使用`Start()`方法来做这件事。以下列方式在我们的`SpawnEnemy()`协程下方添加此方法：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the script and click on the play button. The first enemy is spawned after
    the `firstEnemyDelay`. After the first enemy, new enemies are spawned at random
    X positions, at random intervals, and at a random speed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并点击播放按钮。在`firstEnemyDelay`之后，第一个敌人被生成。在第一个敌人之后，新的敌人将在随机的X位置、随机的间隔和随机的速度生成。
- en: 'Your **Hierarchy** view should look as follows when a few enemies have spawned:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成几个敌人时，您的**层次结构**视图应如下所示：
- en: '![Creating the enemy spawn controller](img/8667OT_07_03.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人生成控制器](img/8667OT_07_03.jpg)'
- en: 'Spawned enemies move down and stop at the end of the Viewport''s background
    as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的敌人会向下移动，并在视口背景的末端停止，如下面的截图所示：
- en: '![Creating the enemy spawn controller](img/8667OT_07_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![创建敌人生成控制器](img/8667OT_07_04.jpg)'
- en: Forwarding events to viewport
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前向传递事件到视口
- en: Ok, we now have our mobile enemies, but we still have a slight problem. You
    may have noticed that you cannot drag the viewport if you click on an enemy. We
    had the same problem before with the **ActiveBarrier** prefab.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有了我们的移动敌人，但我们仍然有一个小问题。你可能已经注意到，如果你点击敌人，你将无法拖动视口。我们之前在**活动障碍物**预制体上也遇到了同样的问题。
- en: 'We need to add a **UIForwardEvents** component to the **Spaceship** prefab
    by performing the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过以下步骤将**UIForwardEvents**组件添加到**Spaceship**预制体上：
- en: In the **Project** view, select our **Spaceship** prefab.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中，选择我们的**Spaceship**预制体。
- en: 'Attach a **Forward Events** component to it by navigating to **Component**
    | **NGUI** | **Interaction**. Then perform the following steps:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**组件** | **NGUI** | **交互**将其附加一个**Forward Events**组件。然后执行以下步骤：
- en: Check its **OnPress** Boolean.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其**OnPress**布尔值。
- en: Check its **OnDrag** Boolean.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查其**OnDrag**布尔值。
- en: Open its attached `EnemyController.cs` script.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开其附带的`EnemyController.cs`脚本。
- en: 'Add the following line at the end of the `Initialize()` method of `EnemyController.cs`
    script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EnemyController.cs`脚本的`Initialize()`方法末尾添加以下行：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can now pan the viewport even if you click on an enemy. It is time to handle
    collisions with barriers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使点击敌人，你现在也可以平移视口。是时候处理与障碍物的碰撞了。
- en: Handling enemy collisions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理敌人碰撞
- en: We need to handle collisions between our enemies and ActiveBarriers. Since we
    have a Rigidbody attached to our **Enemy** prefab, it will receive the `OnTriggerEnter()`
    event when it hits the collider of an **ActiveBarrier** GameObject.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理我们的敌人与活动障碍物之间的碰撞。由于我们的**敌人**预制体上附加了Rigidbody，当它撞击**活动障碍物**游戏对象的碰撞器时，它将接收到`OnTriggerEnter()`事件。
- en: Once the collisions with ActiveBarriers are implemented, we'll add collisions
    with the bottom of the screen, which will reduce the player's health.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了与活动障碍物的碰撞，我们将添加与屏幕底部的碰撞，这将减少玩家的生命值。
- en: Collisions with active barriers
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与活动障碍物的碰撞
- en: 'First of all, we must disable the ActiveBarrier''s collider by default and
    enable it when the barrier is built in the following manner:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须默认禁用活动障碍物的碰撞器，并在以下方式中在障碍物建造时启用它：
- en: In the **Project** view, select our **ActiveBarrier** prefab.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中，选择我们的**活动障碍物**预制体。
- en: Disable its **Box Collider** component using its checkbox.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用复选框禁用其**Box Collider**组件。
- en: Open the `ActiveBarrierController.cs` script attached to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开附在其上的`ActiveBarrierController.cs`脚本。
- en: 'We will need a new `built` boolean that will help us know if the barrier has
    finished its building process. Along with our `UISlider` and `UILocalize` variables,
    declare the following:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个名为`built`的新布尔值，这将帮助我们了解障碍物是否完成了其建造过程。除了我们的`UISlider`和`UILocalize`变量外，声明以下内容：
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, add the following two lines at the end of the `BuildFinished()` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`BuildFinished()`方法末尾添加以下两行：
- en: '[PRE6]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Ok, now the collider is enabled only when the barrier is built. We can add
    a `HitByEnemy()` method with the concerned `enemy` passed as a parameter that
    will destroy the barrier and the enemy in the following manner:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在碰撞器仅在建造障碍物时启用。我们可以添加一个`HitByEnemy()`方法，将相关的`enemy`作为参数传递，以下列方式销毁障碍物和敌人：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we start two coroutines: one to kill the enemy and another one to remove
    the barrier. Let''s add the `RemoveBarrier()` coroutine now with the following
    code snippet:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们启动了两个协程：一个用于消灭敌人，另一个用于移除障碍。现在让我们添加`RemoveBarrier()`协程，使用以下代码片段：
- en: '[PRE8]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The coroutine in the previous code scales down the barrier before it is destroyed.
    We send a message to the parent (**Viewport**) because we need to decrease the
    `barrierCount` value.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一段代码中的协程在销毁障碍物之前将其缩小。我们向父级（**视口**）发送消息，因为我们需要减少`barrierCount`值。
- en: Let's add the `BarrierRemoved()` method in the `ViewportHolder.cs` script. In
    the **Hierarchy** view, select our **Viewport** GameObject and open the `ViewportHolder.cs`
    script attached to it.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ViewportHolder.cs`脚本中添加`BarrierRemoved()`方法。在**层次结构**视图中，选择我们的**视口**游戏对象，并打开附加到其上的`ViewportHolder.cs`脚本。
- en: 'In our `ViewportHolder.cs` script, add the following new `BarrierRemoved()`
    method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`ViewportHolder.cs`脚本中，添加以下新的`BarrierRemoved()`方法：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `barrierCount` value will be updated as soon as a barrier is destroyed.
    Now, let''s open the `EnemyController.cs` script and add the `Kill()` coroutine
    as shown in the following code snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦障碍物被销毁，`barrierCount`值将立即更新。现在，让我们打开`EnemyController.cs`脚本并添加如以下代码片段所示的`Kill()`协程：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great! All of our coroutines and methods are ready. Now, we need to call the
    `HitByEnemy()` method of the concerned **ActiveBarrier** when a collision occurs.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！我们所有的协程和方法都准备好了。现在，我们需要在发生碰撞时调用相关**ActiveBarrier**的`HitByEnemy()`方法。
- en: 'We just have to add the following `OnTriggerEnter()` method inside our `EnemyController.cs`
    script, which will call this method only if the collided object actually is a
    barrier:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需在`EnemyController.cs`脚本中添加以下`OnTriggerEnter()`方法，该方法仅在碰撞对象实际上是障碍物时调用：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Save all of the scripts and click on the play button.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有脚本并点击播放按钮。
- en: If you place a barrier on an enemy's trajectory, both of them will be destroyed
    when they collide! If the building process isn't over, nothing happens.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在敌人的轨迹上放置一个障碍物，当它们碰撞时，两者都将被摧毁！如果构建过程尚未完成，则不会发生任何事情。
- en: In the case where a barrier finishes its building process while an enemy is
    still inside it, a collision will occur. Perfect!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在障碍物完成其构建过程而敌人仍在其中时，将发生碰撞。太棒了！
- en: Now that the player can destroy his or her enemies, let's add a way for the
    enemies to destroy the player.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以摧毁他的或她的敌人了，让我们为敌人添加一种摧毁玩家的方法。
- en: Colliding with the bottom of the screen
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与屏幕底部的碰撞
- en: We can now add a collider at the bottom of the viewport's background that will
    destroy enemies and reduce the player's health. Before we do this, let's create
    a Healthbar with a HealthController script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在视口背景的底部添加一个碰撞器，这将摧毁敌人并减少玩家的生命值。在我们这样做之前，让我们创建一个带有HealthController脚本的Healthbar。
- en: Healthbar
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Healthbar
- en: To create this Healthbar, we need the `Button.png` file available in the `Assets.zip`
    file. If you haven't added it to the **Game** Atlas as a sliced sprite yet, please
    do so before you continue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此Healthbar，我们需要`Assets.zip`文件中可用的`Button.png`文件。如果您还没有将其作为切片精灵添加到**游戏**图集中，请在继续之前这样做。
- en: 'We will use a Progress Bar to create a Healthbar on which we will add a `HealthController.cs`
    script to handle the display of damage and health points. Perform the following
    steps to do so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用进度条在Healthbar上创建一个，我们将添加一个`HealthController.cs`脚本来处理伤害和生命值的显示。执行以下步骤：
- en: In the **Hierarchy** view, select the **UI** GameObject from **Anchor**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中，选择**UI**游戏对象从**锚点**。
- en: 'Open the **Widget Tool** window by navigating to **NGUI** | **Create a Widget**.
    Then perform the following steps:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建小部件**打开**小部件工具**窗口。然后执行以下步骤：
- en: Select our **Game** Atlas.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**游戏**图集。
- en: Select the **Progress Bar** template.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**进度条**模板。
- en: Select our **Button** sprite for the **Empty** field.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**空**字段中的我们的**按钮**精灵。
- en: Select our **Button** sprite for the **Full** field.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**满**字段选择我们的**按钮**精灵。
- en: With our **UI** GameObject selected, click on the **Add To** button.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的**UI**游戏对象选中后，点击**添加到**按钮。
- en: Select the new **Progress Bar** GameObject and rename it as `Healthbar`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的**进度条**游戏对象，并将其重命名为`Healthbar`。
- en: 'Attach an **Anchor** to it by navigating to **NGUI** | **Attach**. Then perform
    the following steps:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加**来为它附加一个**锚点**。然后执行以下步骤：
- en: Drag our **Viewport** GameObject in the **Container** field.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的**视口**游戏对象拖到**容器**字段中。
- en: Set the **Side** parameter to **Top**.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**侧边**参数设置为**顶部**。
- en: Set **Pixel Offset** to {`-160`, `-30`}.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**像素偏移**设置为{`-160`, `-30`}。
- en: 'Select the **Background** GameObject from **Healthbar** and perform the following
    steps:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Healthbar**中选择**背景**游戏对象并执行以下步骤：
- en: Set **Color Tint** to {`255`, `120`, `120`, `140`}.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**颜色色调**设置为{`255`, `120`, `120`, `140`}。
- en: Set **Dimensions** to `320` x `42`.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**尺寸**设置为`320` x `42`。
- en: Change **Sprite Type** to **Sliced**.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵类型**更改为**切片**。
- en: Click on the **Edit** button next to the **Sprite** field.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**精灵**字段旁边的**编辑**按钮。
- en: Set all four border values to `6` for slicing parameters.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有四个边框值设置为`6`作为切片参数。
- en: 'Select the **Foreground** GameObject from **Healthbar** and then perform the
    following steps:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**生命条**中选择**前景**游戏对象，然后执行以下步骤：
- en: Set **Color Tint** to {`25`, `245`, `255`, `255`}.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**颜色色调**设置为 `{`25`, `245`, `255`, `255`}`。
- en: Set **Dimensions** to `320` x `42`.
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**尺寸**设置为`320` x `42`。
- en: Change **Sprite Type** to **Sliced**.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**精灵类型**更改为**切片**。
- en: 'Ok, we have a configured health bar centered at the top of the screen. We need
    to add a script to it that will handle health points and modify the value of **Slider**
    accordingly. The steps to do so are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经在屏幕顶部中心配置了一个健康条。我们需要向其添加一个脚本，该脚本将处理生命值并相应地修改滑块的值。以下是执行此操作的步骤：
- en: In the **Hierarchy** view, select our **Healthbar** GameObject.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**视图中，选择我们的**生命条**游戏对象。
- en: Create and add a new `HealthController.cs` script to it.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其添加一个新的`HealthController.cs`脚本。
- en: Open this new `HealthController.cs` script.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开这个新的`HealthController.cs`脚本。
- en: 'In this new script, we will save a static reference to the instance of the
    `HealthController` class so that its methods are easily accessible from other
    scripts. First, let''s declare necessary variables and initialize them on `Awake()`
    as shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新脚本中，我们将保存对`HealthController`类实例的静态引用，以便其他脚本可以轻松访问其方法。首先，让我们声明必要的变量并在`Awake()`中初始化它们，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Ok, our variables are now initialized correctly. Let''s create a `Damage()`
    method that will reduce the `hp` value and update the slider as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们的变量现在已正确初始化。让我们创建一个`Damage()`方法，该方法将减少`hp`值并按以下方式更新滑块：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great! The `Damage()` method is ready. Let's create the **EndOfScreen** widget
    that will collide with the enemies.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！`Damage()`方法已经准备好了。让我们创建一个**EndOfScreen**小部件，它将与敌人发生碰撞。
- en: The EndOfScreen widget
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EndOfScreen小部件
- en: 'Let''s create the **EndOfScreen** widget that will help detect enemy collisions
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个**EndOfScreen**小部件，它将帮助检测敌人碰撞，如下所示：
- en: 'In the **Hierarchy** view, select our **Viewport** GameObject and perform the
    following steps:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**视图中，选择我们的**视口**游戏对象并执行以下步骤：
- en: Create a new child by pressing *Alt* + *Shift* + *N*.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 *Alt* + *Shift* + *N* 创建一个新的子对象。
- en: Rename this new child as `EndOfScreen`.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新子对象重命名为`EndOfScreen`。
- en: Attach a collider to it by navigating to **NGUI** | **Attach a Collider** and
    set **Size** to {`3840`, `43`, `1`}.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加一个碰撞器**将其附加一个碰撞器，并将**大小**设置为 `{`3840`, `43`, `1`}`。
- en: Attach **Anchor** to it by navigating to **NGUI** | **Attach**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **附加**将其附加到**锚点**。
- en: Drag the **Background** GameObject from **Viewport** in the **Container** field.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**容器**字段中的**视口**拖动**背景**游戏对象。
- en: Set its **Side** parameter to **Bottom**.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**侧边**参数设置为**底部**。
- en: Set its **Pixel Offset** to {`0`, `33`}.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**像素偏移**设置为 `{`0`, `33`}`。
- en: Click on the **Untagged / Add Tag…** button at the top of the **Inspector**
    view.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**视图的顶部点击**未标记/添加标签…**按钮。
- en: Create a new `DamageZone` tag.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`DamageZone`标签。
- en: Select our **EndOfScreen** GameObject.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**EndOfScreen**游戏对象。
- en: Set **Tag** to **DamageZone**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**标签**设置为**DamageZone**。
- en: Make sure our **EndOfScreen** GameObject is selected.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保我们的**EndOfScreen**游戏对象被选中。
- en: 'Create a new sprite by navigating to **NGUI** | **Create** | **Sprite** and
    perform the following steps:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建** | **精灵**创建一个新的精灵并执行以下步骤：
- en: Set its **Atlas** type to the **SciFi** Atlas.
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**图集**类型设置为**科幻**图集。
- en: Set its **Sprite** type to the **Honeycomb** sprite.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**精灵**类型设置为**蜂窝**精灵。
- en: Set its **Sprite Type** to **Tiled**.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**精灵类型**设置为**平铺**。
- en: 'Set its **Color Tint** values to **R**: `255`, **G**: `120`, **B**: `120`,
    and **A**: `255`.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将其**颜色色调**值设置为**R**: `255`, **G**: `120`, **B**: `120`, 和 **A**: `255`。'
- en: Set its **Depth** value to `2`.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**值设置为`2`。
- en: Set its **Dimensions** parameter to `3840` x `43`.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**尺寸**参数设置为`3840` x `43`。
- en: 'Good. We now have an **EndOfScreen** limit with a sprite and a collider. Now,
    we need to edit our `EnemyController.cs` script''s `OnTriggerEnter()` method to
    check if the collided object has the **DamageZone** tag and hurt the player if
    needed. Perform the following steps to do so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们现在有一个带有精灵和碰撞器的**EndOfScreen**限制。现在，我们需要编辑`EnemyController.cs`脚本中的`OnTriggerEnter()`方法，以检查碰撞的对象是否具有**DamageZone**标签，并在需要时伤害玩家。执行以下步骤以完成此操作：
- en: In the **Project** view, select our **SpaceShip** prefab and open the `EnemyController.cs`
    script attached to it.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中，选择我们的**飞船**预制件并打开附加到其上的`EnemyController.cs`脚本。
- en: 'Within the `EnemyController.cs` script, at the very first line of the `OnTriggerEnter()`
    method, add the following lines to check if the collided object has a **DamageZone**
    tag:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyController.cs`脚本中，在`OnTriggerEnter()`方法的非常第一行，添加以下行以检查碰撞对象是否有**DamageZone**标签：
- en: '[PRE14]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save all of the scripts and click on the play button. Now, our enemies are destroyed
    when they collide with the end of the Viewport, and the player's health is decreased!
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有脚本并点击播放按钮。现在，当敌人与Viewport的末端碰撞时，它们会被摧毁，玩家的生命值会减少！
- en: Now, let's add another way to destroy our enemies.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加另一种摧毁敌人的方法。
- en: Creating self-destruct code
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自毁代码
- en: Dropping barriers on the screen is not enough. We will use a self-destruct code
    to destroy enemies too.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上放置障碍物是不够的。我们将使用自毁代码来摧毁敌人。
- en: Each enemy will get a chance to have a self-destruct code. If it has one, an
    empty slider with **Code Encrypted** displayed inside it will appear above the
    concerned enemy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个敌人都有机会获得一个自毁代码。如果它有一个，将显示**Code Encrypted**的空滑动条将出现在相关敌人上方。
- en: 'When the player clicks on the enemy, the hacking process starts. When the hacking
    is complete, a word will appear as shown in the following screenshot, and the
    player will have to type it on his keyboard to destroy it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击敌人时，黑客过程开始。当黑客完成后，会出现一个单词，如以下截图所示，玩家必须在键盘上输入它来摧毁它：
- en: '![Creating self-destruct code](img/8667OT_07_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![创建自毁代码](img/8667OT_07_05.jpg)'
- en: The hacking slider
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客滑动条
- en: 'Let''s start by creating the hacking slider indicator inside our **Spaceship**
    prefab by performing the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在**Spaceship**预制体内部创建黑客滑动指示器开始，按照以下步骤操作：
- en: In the **Project** view, select our **Spaceship** prefab.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中，选择我们的**Spaceship**预制体。
- en: Drag it in the **Hierarchy** view as child of the **Viewport** GameObject.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它拖到**层次结构**视图中作为**Viewport**GameObject的子对象。
- en: 'Open the **Wiget Tool** window by navigating to **NGUI** | **Create a Widget**
    and then perform the following steps:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建小部件**并执行以下步骤来打开**小部件工具**窗口：
- en: Select the **Game** Atlas.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**游戏** Atlas.
- en: Select the **Progress Bar** template.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**进度条**模板。
- en: Select the **Button** sprite for the **Empty** field.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**按钮**精灵用于**空**字段。
- en: Select the **Button** sprite for the **Full** field.
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**按钮**精灵用于**满**字段。
- en: With our **Spaceship** instance selected, click on the **Add To** button.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的**Spaceship**实例，然后点击**添加到**按钮。
- en: 'Select the new **Progress Bar** GameObject and perform the following steps:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择新的**进度条**GameObject并执行以下步骤：
- en: Rename it as `DestructCode`.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`DestructCode`。
- en: Set its **Transform** position to {`-100`, `100`, `0`}.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**变换**位置设置为 `{`-100`, `100`, `0`}`。
- en: Set the value of **UISlider** to `0`.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UISlider**的值设置为`0`。
- en: 'Select the **Background** GameObject from **DestructCode**. Then perform the
    following steps:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**DestructCode**中选择**背景**GameObject。然后执行以下步骤：
- en: Change its **Color Tint** values to {`255`, `140`, `140`, `255`}.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**颜色色调**值更改为 `{`255`, `140`, `140`, `255`}`。
- en: Set its **Depth** value to `2`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**值设置为`2`。
- en: 'Select the **Foreground** GameObject from **DestructCode** and then perform
    the given steps:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**DestructCode**中选择**前景**GameObject然后执行给定的步骤：
- en: Change **Color Tint** to {`50`, `180`, `220`, `255`}.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**颜色色调**改为 `{`50`, `180`, `220`, `255`}`.
- en: Set its **Depth** value to `3`.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**深度**值设置为`3`。
- en: Ok, the slider is ready. Let's add a label that will display **Code Encrypted**
    and will change to the self-destruct code when the hacking process is finished.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，滑动条准备好了。让我们添加一个标签，它将显示**Code Encrypted**，并在黑客过程完成后变为自毁代码。
- en: In the **Hierarchy** view, select our **DestructCode** GameObject.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中，选择我们的**DestructCode**GameObject。
- en: 'Open the **Widget Tool** window by navigating to **NGUI** | **Create a Widget**
    and perform the given steps:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**NGUI** | **创建小部件**并执行给定的步骤来打开**小部件工具**窗口：
- en: Select the **SciFi Font – Normal** font.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**SciFi Font – Normal**字体。
- en: Select the **Label** template.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**标签**模板。
- en: 'Change the **Color** to **R**: `255`, **G**: `215`, **B**: `190`, and **A**:
    `255`.'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将**颜色**改为**R**: `255`, **G**: `215`, **B**: `190`, 和 **A**: `255`.'
- en: With the **DestructCode** GameObject selected, click on the **Add To** button.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**DestructCode**GameObject，然后点击**添加到**按钮。
- en: 'Select the new **Label** GameObject from **DestructCode** and perform the following
    steps:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**DestructCode**中选择新的**标签**GameObject并执行以下步骤：
- en: Set its **Transform** position to {`100`, `0`, `0`}.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**变换**位置设置为 `{`100`, `0`, `0`}`。
- en: Set its text to `Code Encrypted`.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其文本设置为 `Code Encrypted`.
- en: 'Your **Hierarchy** view and **Spaceship** should look as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你的**层次结构**视图和**Spaceship**应该看起来如下：
- en: '![The hacking slider](img/8667OT_07_06.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![黑客滑动条](img/8667OT_07_06.jpg)'
- en: 'Great! Let''s apply these new modifications to our **Spaceship** prefab by
    performing the following steps:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们通过以下步骤将这些新修改应用到我们的**飞船**预制体上：
- en: In the **Hierarchy** view, select our **Spaceship** GameObject.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**视图中，选择我们的**飞船**GameObject。
- en: Click on the **Apply** button at the top of the **Inspector** view to update
    the prefab.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**检查器**视图顶部的**应用**按钮以更新预制体。
- en: Delete the **Spaceship** instance from our **Hierarchy** view.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们的**层次**视图中删除**飞船**实例。
- en: Ok, we now have a slider that will indicate the hacking status and a label that
    will display the self-destruct code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在有一个滑动条将指示黑客状态，还有一个标签将显示自毁代码。
- en: Self-destruct code
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自毁代码
- en: 'Let''s add some self-destruct code and hacking status in the localization files.
    Open the `English.txt` and add the following lines:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地化文件中添加一些自毁代码和黑客状态。打开`English.txt`并添加以下行：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, open the `French.txt` file and add the following lines:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`French.txt`文件并添加以下行：
- en: '[PRE16]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Good! We now have our necessary localization strings.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们现在有了必要的本地化字符串。
- en: Assigning code to an enemy
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码分配给敌人
- en: We will now add a new `SetDestructCode()` method in our `EnemyController.cs`
    script that will assign a self-destruct code to our enemy during initialization.
    First, let's add the necessary global variables to it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在`EnemyController.cs`脚本中添加一个新的`SetDestructCode()`方法，该方法将在初始化时为我们的敌人分配自毁代码。首先，让我们向其中添加必要的全局变量。
- en: 'Open our `EnemyController.cs` script and add the following global variables:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们的`EnemyController.cs`脚本，并添加以下全局变量：
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We must set these variables. Add the following lines at the end of the `Initialize()`
    method:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须设置这些变量。在`Initialize()`方法的末尾添加以下行：
- en: '[PRE18]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ok, now, let''s add the `SetDestructCode()` method that will assign a self-destruct
    code to the enemy. This method will have a string parameter containing the key
    of the self-destruct code to be assigned, as shown in the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在，让我们添加一个`SetDestructCode()`方法，该方法将为敌人分配自毁代码。此方法将有一个包含要分配的自毁代码键的字符串参数，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Ok, we have a method that sets the correct destruct code. Now, let's create
    a `Hack()` coroutine that will be called to start the hacking process.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们有一个设置正确破坏代码的方法。现在，让我们创建一个将被调用来启动黑客过程的`Hack()`协程。
- en: The hacking process
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客过程
- en: The `Hack()` coroutine will gradually fill the hacking slider and display the
    enemy's self-destruct code when the hacking is complete.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hack()`协程将逐渐填充黑客滑动条，并在黑客完成时显示敌人的自毁代码。'
- en: 'Add the `Hack()` coroutine to the `EnemyController.cs` script using the following
    code snippet:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段将`Hack()`协程添加到`EnemyController.cs`脚本中：
- en: '[PRE20]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s add an `OnClick()` method that will actually launch the hacking
    process when the enemy is clicked on by the player. We do this in the following
    manner:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`OnClick()`方法，当玩家点击敌人时，实际上将启动黑客过程。我们这样做的方式如下：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ok, the methods are set for our enemy. Now, we can edit our `EnemySpawnController.cs`
    script to call the `SetDestructCode()` method when a new enemy is initialized
    and pass a random destruct code in parameter. First, we will add the necessary
    variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经为我们的敌人设置了方法。现在，我们可以编辑我们的`EnemySpawnController.cs`脚本，在初始化新敌人时调用`SetDestructCode()`方法，并将随机破坏代码作为参数传递。首先，我们将添加必要的变量。
- en: We will need a `List` array to store the enemies in the scene. A `List` is like
    an array but easier to manage with useful methods, such as `Add()` and `Remove()`.
    In order to use a `List`, you need to include a specific library.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个`List`数组来存储场景中的敌人。`List`类似于数组，但使用有用的方法（如`Add()`和`Remove()`）更容易管理。为了使用`List`，你需要包含一个特定的库。
- en: 'Open the `EnemySpawnController.cs` script and simply add the following line
    at the very beginning of the file, along with the two other include lines already
    present:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemySpawnController.cs`脚本，并在文件开头简单地添加以下行，以及已经存在的两个其他包含行：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, add these new global variables within our `EnemySpawnController` class:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`EnemySpawnController`类中添加这些新的全局变量：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ok, now initialize some of these variables in the new `Awake()` method:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在在新的`Awake()`方法中初始化一些这些变量：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we continue, let's assign the remaining variables in the **Inspector**
    view. Save the script, go back to Unity, and select our **Enemies** GameObject
    from **Viewport**.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们在**检查器**视图中分配剩余的变量。保存脚本，回到Unity，并从**视口**中选择我们的**敌人**GameObject。
- en: 'Now, set the **Word Keys** array and spawning values as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式设置**单词键**数组和生成值：
- en: '![The hacking process](img/8667OT_07_07.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![黑客过程](img/8667OT_07_07.jpg)'
- en: 'Good, our **Word Keys** array is now set up. Let''s return to our `EnemySpawnController.cs`
    script and add the following lines in the `SpawnEnemy()` coroutine at the very
    end of its `while()` loop:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的**单词键**数组现在已经设置好了。让我们回到`EnemySpawnController.cs`脚本，并在其`while()`循环的末尾添加以下行：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When an enemy is initialized, the previous code adds it to the `List` of enemies
    and sets its self-destruct code. Now, using the following code, let''s create
    the `GetRandomWord()` method that will return one of our predefined words:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人初始化时，前面的代码将其添加到敌人的`List`中并设置其自毁代码。现在，使用以下代码，让我们创建一个`GetRandomWord()`方法，它将返回我们预定义的单词之一：
- en: '[PRE26]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Good. Some of our enemies have a destruct code assigned. Let''s just add a
    method to remove an enemy from the `List`, which will be called each time an enemy
    is destroyed. The method is added as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们的一些敌人已经分配了破坏代码。让我们添加一个方法来从`List`中移除敌人，该方法将在每次摧毁敌人时被调用。方法添加如下：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Open the `EnemyController.cs` script. Within the `Kill()` coroutine, just before
    the `Destroy(gameObject)` line, add the following line to remove the enemy from
    the `List`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemyController.cs`脚本。在`Kill()`协程中，在`Destroy(gameObject)`行之前，添加以下行以从`List`中移除敌人：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Perfect. Save all of the scripts and hit the play button. If you click on an
    enemy that has the hacking slider, the hacking process starts and displays a destruct
    code when finished.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。保存所有脚本并点击播放按钮。如果你点击具有黑客滑块的敌人，黑客过程开始，并在完成后显示破坏代码。
- en: The last step is to handle the player's input in order to check if he or she
    types one of the enemies' self-destruct words.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是处理玩家的输入，以检查他或她是否输入了敌人的自毁单词。
- en: Handling player input
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理玩家输入
- en: We will use the `Update()` method of our `EnemySpawnController.cs` script to
    check which characters the player types with his or her keyboard. These characters
    will be stored one by one and will be compared to our enemies' destruct codes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`EnemySpawnController.cs`脚本的`Update()`方法来检查玩家使用键盘输入的字符。这些字符将逐个存储并与我们敌人的破坏代码进行比较。
- en: 'Open our `EnemySpawnController.cs` script and create a new `Update()` method:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们的`EnemySpawnController.cs`脚本并创建一个新的`Update()`方法：
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Save this script. Now, when you hack an enemy, you can destroy it by typing
    its self-destruct code! If multiple enemies have the same code, they will be destroyed
    simultaneously.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此脚本。现在，当你黑客一个敌人时，你可以通过输入其自毁代码来摧毁它！如果多个敌人具有相同的代码，它们将同时被摧毁。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Typing a word may scroll the viewport; this is because Q, A, S, and D are set
    as Horizontal and Vertical axes by default. Go to **Edit** | **Project Settings**
    | **Input** and delete (a, d) and (s, w) from the Horizontal and Vertical axes'
    Alt Positive Button and Alt Negative Button fields respectively.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个单词可能会滚动视口；这是因为Q、A、S和D被默认设置为水平轴和垂直轴。转到**编辑** | **项目设置** | **输入**，并分别从水平轴和垂直轴的Alt
    Positive Button和Alt Negative Button字段中删除(a, d)和(s, w)。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used everything we learned in the earlier chapters with
    respect to creating a simple game.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了前面章节中关于创建简单游戏所学的所有内容。
- en: We created an enemy spawning system, which instantiates enemies on the scene.
    Rigidbodies and colliders have been added to handle collisions between enemies
    in the barriers at the bottom of the screen.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个敌人生成系统，在场景中实例化敌人。刚体和碰撞体已添加以处理屏幕底部障碍物中敌人的碰撞。
- en: We also added a health bar widget that is linked to health points; if four enemies
    touch the end of the screen, the game restarts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个与生命值相关的健康条小部件；如果四个敌人触摸屏幕的末端，游戏将重新开始。
- en: The `Update()` method was used to handle player input and compare the typed
    word with destruct codes in order to destroy enemies if needed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了`Update()`方法来处理玩家输入，并将输入的单词与破坏代码进行比较，以便在需要时摧毁敌人。
- en: 'For now, the game is quite simple. Some ideas to enhance the game are as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，游戏相当简单。以下是一些增强游戏的想法：
- en: Add more self-destruct words
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多自毁单词
- en: Display what the player types on the screen (visual feedback)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示玩家输入的内容（视觉反馈）
- en: Slowly increase the spawning rate as the player destroys enemies
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着玩家摧毁敌人，逐渐增加敌人的出生率
- en: Slowly increase the enemy's speed as the player destroys enemies
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着玩家摧毁敌人，逐渐增加敌人的速度
- en: Add a scoring system
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加评分系统
- en: 'Implement the Time power (hint: Time.timeScale)'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现时间力量（提示：Time.timeScale）
- en: Implement the Bomb power
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现炸弹力量
- en: Make the hack time depend on barrierCount (more barriers, faster hacking)
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使破解时间取决于barrierCount（更多障碍，破解速度更快）
- en: Include the possibility of removing an ActiveBarrier with a right click
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含使用右键点击移除ActiveBarrier的可能性
- en: Add clickable objects to regain health; some enemies leave them behind
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可点击的对象以恢复生命值；一些敌人会留下这些对象
- en: Add a combo reward if the player destroys multiple enemies within 3 seconds
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家在3秒内摧毁多个敌人，则添加连击奖励
- en: Include harder words for hard difficulty
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在困难难度中包含更难懂的单词
- en: Insert a visual indicator (arrow) to show the direction of the enemies outside
    the screen
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕外显示敌人的方向时插入一个视觉指示器（箭头）
- en: Add more visual variety in the background (galaxies and so on) to help orientation
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在背景中添加更多视觉元素（如星系等）以帮助定位
- en: Display a game over screen with the main menu and restart buttons
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示带有主菜单和重启按钮的游戏结束屏幕
- en: Create tutorial pop ups
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建教程弹出窗口
- en: If you add some of the previous features, our game will become more interesting.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加了之前的一些功能，我们的游戏将变得更加有趣。
- en: In order to improve your knowledge of NGUI, you can refer to more tutorials
    at [http://www.tasharen.com/forum/index.php?topic=6754](http://www.tasharen.com/forum/index.php?topic=6754).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高你对NGUI的了解，你可以在[http://www.tasharen.com/forum/index.php?topic=6754](http://www.tasharen.com/forum/index.php?topic=6754)找到更多教程。
- en: The complete NGUI scripting documentation is available at [http://www.tasharen.com/ngui/docs/index.html](http://www.tasharen.com/ngui/docs/index.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的NGUI脚本文档可在[http://www.tasharen.com/ngui/docs/index.html](http://www.tasharen.com/ngui/docs/index.html)找到。
- en: That's it! We have now finished working with Unity and NGUI using this book.
    Thank you for your attention and I wish you all the best for your future projects.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！我们现在已经使用这本书完成了与Unity和NGUI的工作。感谢您的关注，并祝您未来的项目一切顺利。
