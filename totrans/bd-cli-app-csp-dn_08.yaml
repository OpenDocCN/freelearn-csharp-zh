- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Modular and Extensible CLI Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the pages of this book, we have added more and more functionalities
    to **Bookmarkr**, our beloved CLI application.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we have also added more and more lines of code to the `Program.cs`
    file. The length of this file has grown from 191 lines of code by the end of [*Chapter
    3*](B22400_03.xhtml#_idTextAnchor035) to 479 lines of code by the end of [*Chapter
    7*](B22400_07.xhtml#_idTextAnchor105).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a step back and refactor our code to make it more
    modular. This will make it easier to extend, test, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring is an essential part of the development life cycle. It should happen
    periodically in order to ensure that the quality of code is up to the standards.
  prefs: []
  type: TYPE_NORMAL
- en: By taking this necessary step, we will greatly simplify adding more features,
    enhance the readability and stability of our application, and even introduce testability
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, in this chapter, we‚Äôll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building the code map of the current application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding where to start refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the project structure to support refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the `Program` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the program to validate that the refactoring didn‚Äôt break anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing our refactoring to new boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 ‚Äì building a code map of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing when you refactor an application is to get to know what you
    are about to refactor. This means having a high-level view of the application
    and its dependencies. This helps you visualize all the moving parts involved and
    better plan your refactoring activities by identifying where to start.
  prefs: []
  type: TYPE_NORMAL
- en: If you have Visual Studio Enterprise edition, you can use its great architecture
    capabilities (such as code maps and dependency graphs) to visualize your code
    and its dependencies. However, since we are using Visual Studio Code (or if you
    don‚Äôt have the Enterprise edition of Visual Studio), we can do something else‚Ä¶
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we can run through the code and identify every moving part of it, but
    since this is a CLI application, let‚Äôs do something smarter. üòâ
  prefs: []
  type: TYPE_NORMAL
- en: Using the Help menu to build the code map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `System.CommandLine` is certainly great for learning how to use the application,
    but it is also great for figuring out the code map of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs start by displaying the help menu at the root command by typing this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 ‚Äì The help menu of the root command](img/B22400_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 ‚Äì The help menu of the root command
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will repeat this operation (aka displaying the help menu) for each
    of the subcommands of the root command, then for each subcommand of every subcommand,
    then for‚Ä¶ Okay, you get the idea! üòâ
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `link` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 ‚Äì The help menu of the link command](img/B22400_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 ‚Äì The help menu of the link command
  prefs: []
  type: TYPE_NORMAL
- en: 'When should we stop? Well, when the current command has no more subcommands.
    Here is an example with the `link` `add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 ‚Äì The help menu of the link add command](img/B22400_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 ‚Äì The help menu of the link add command
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing this exercise, we will get the following code map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 ‚Äì The code map of the Bookmarkr application](img/B22400_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 ‚Äì The code map of the Bookmarkr application
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now that we have a clearer view of the moving parts in our application,
    what should we do next?
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 ‚Äì deciding where to start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It‚Äôs now time to decide what to refactor first.
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend not to start with the root command first, but rather with
    the subcommands of that root command.
  prefs: []
  type: TYPE_NORMAL
- en: There is no right or wrong decision from there. You can pick up any subcommand
    you would like to start with. We will take the `export` command as an example
    in the remainder of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `export` command does not have a subcommand, it will still help
    us lay out the foundation of the refactored version of *Bookmarkr*. More specifically,
    it will help us do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the project structure to support our refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor it and hide its ‚Äúcomplexity‚Äù (aka moving parts to the root command)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactor the `Program` class and make it leaner, cleaner, and more concise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up dependency injection for interacting between commands and external services
    (such as `BookmarkService`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let‚Äôs start with designing the project structure that will support our refactoring
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 ‚Äì designing the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although one can design their project structure according to their tastes, I
    design mine in a way that makes it easy for whoever looks at my project to understand
    what it does and where each moving part is located.
  prefs: []
  type: TYPE_NORMAL
- en: Following this principle, all commands will be grouped in a folder named `Commands`.
    This folder will be created at the root of the project structure.
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be refactoring the `export` command, let‚Äôs create a subfolder
    named `Export` where all the code artifacts involved in the `export` command will
    be located.
  prefs: []
  type: TYPE_NORMAL
- en: Once we start refactoring another command, we will create a specific folder
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: What about subcommands of a command?
  prefs: []
  type: TYPE_NORMAL
- en: Following the principle of **encapsulation** in object-oriented programming,
    and since a subcommand can only be invoked through its parent command, I recommend
    locating subcommands in the same folder as their parent command.
  prefs: []
  type: TYPE_NORMAL
- en: An example of that is the `link add` command. The `add` subcommand can only
    be called through its parent (`link`) command. Hence, their life cycles are closely
    related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: For that matter, the code artifact of the `add` command will be located close
    to the code artifact of its parent command (`link`), within the `Link` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 ‚Äì refactoring the export command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the `Export` folder, let‚Äôs create a new C# file named `ExportCommand.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: Every command class (including `RootCommand`) derives from the `Command` base
    class. Furthermore, that base class provides an `AddCommand` method that takes
    a parameter of the `Command` type, which also means any class that derives from
    the `Command` class.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this, we can start refactoring the `export` command by making the
    `ExportCommand` class derive from `Command`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After importing the required `using` statement, specifying the `namespace`
    name, and adding the required class constructor, the first iteration of our class
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first things to move into this class are the options. The `export` command
    has only one option, `outputfileOption`.
  prefs: []
  type: TYPE_NORMAL
- en: I like the fact that every component of my class is well-segmented. That‚Äôs why
    I am a fan of regions. For that reason, let‚Äôs add a region dedicated to options
    and move the code for the `outputfileOption` option within this region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to associate this option with the command. We will do this by
    calling the `AddOption` method from within the constructor body, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to move is the call to the `SetHandler` method, which connects
    the command to its handler method. So, the updated version of the constructor
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last piece of code to move into the new class is the command handler
    method. Once again, we will create a new region for that and move that final piece
    of code. We will also change the `static` modifier to `private`. The reason is
    that the class is not static (hence the removal of the `static` keyword) and the
    command handler method is private to that class (hence the use of the `private`
    keyword):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you are typing (or copying and pasting üòâ) the code along the way, you can
    see at this point that the code does not compile because of two errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is straightforward to solve. It suffices to add the following
    statement at the top of the C# file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The second one is less obvious to solve. It indicates that the class can‚Äôt find
    an instance of the `BookmarkService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could simply create an instance of that service within the current
    class. However, since `BookmarkService` is an external dependency to the `ExportCommand`
    class, doing so will break the principle of **dependency inversion** advocated
    by object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, the principle of dependency inversion is one of the five SOLID
    principles of object-oriented programming and design. It states that high-level
    modules should not depend on low-level modules; both should depend on abstractions.
    Additionally, abstractions should not depend on details; details should depend
    on abstractions. This principle helps to decouple software modules, making the
    system more modular, flexible, and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: What does that practically mean? It means that we should inject an instance
    of `BookmarkService` into the `ExportCommand` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs do this!
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 ‚Äì applying the dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with the dependency inversion principle, you will certainly
    have already noticed that the `BookmarkService` class does not implement any interface.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs start by fixing this.
  prefs: []
  type: TYPE_NORMAL
- en: I am not familiar with the dependency inversion principle!
  prefs: []
  type: TYPE_NORMAL
- en: If you are not, there are plenty of great resources to explore this principle.
    It is not a complicated principle to understand, and quite frankly, after you
    learn about it, it will seem so obvious to you that you will be wondering why
    you did not know about it earlier.
  prefs: []
  type: TYPE_NORMAL
- en: A great explanation of that principle can be found at [https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/](https://www.c-sharpcorner.com/article/dependency-inversion-principle-in-c-sharp/).
  prefs: []
  type: TYPE_NORMAL
- en: I highly encourage you to go and review the implementation of the `BookmarkService`
    service before and after applying the dependency inversion principle in order
    to have a clear understanding of the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our project structure discussion, we will start by creating a new folder
    called `Services` that will group all our services classes. Within that folder,
    let‚Äôs create a specific folder for every service. In our case, we only have one
    service, so let‚Äôs create the `BookmarkService` folder. This folder will contain
    both the interface and the concrete implementation of our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The folder structure for our service will then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 ‚Äì The folder structure for the BookmarkService service](img/B22400_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 ‚Äì The folder structure for the BookmarkService service
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let‚Äôs extract the `IBookmarkService` interface out of the `BookmarkService`
    class. The code for that interface looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let‚Äôs make the `BookmarkService` class implement the `IBookmarkService`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we changed the namespace name for these artifacts in order to better
    convey their intention.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left to do now is to inject that service into the `ExportCommand`
    class. This means two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We will add a `private` property of the `IBookmarkService` type in the `ExportCommand`
    class that will allow us to invoke the methods of that service from within the
    command class (more specifically, from within the `OnExportCommand` method).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will inject an instance of that service through a constructor parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The updated code of the `ExportCommand` class looks like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code is very straightforward to understand and does not require any particular
    explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle may introduce complexity!
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection can introduce some overhead in simple applications by requiring
    additional setup and configuration, such as adding extra interfaces, classes,
    and indirection, which can be unnecessary for straightforward projects with few
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is important to find a balance between applying this principle
    without adding too much complexity to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: That is wonderful. We have come a long way since we started our refactoring
    journey!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last piece of code we haven‚Äôt refactored yet. It is the one for
    which we started this journey in the first place: the `Program` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs turn our attention to this class now‚Ä¶
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 ‚Äì refactoring the Program class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By refactoring the commands into their dedicated classes, the code to create
    and handle these commands will be removed from the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, the `Program` class will now only be used to compose our application.
    More specifically, the `Program` class will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate the root command and register its subcommands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate and configure the `CommandLineBuilder` class and start the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure logging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure dependency injection of the `BookmarkService` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the refactored code for the `Program` class (note that some parts of
    the code, including `using` statements, are not listed here for brevity and clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code is mostly straightforward to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only part that is worth an explanation is how we perform dependency injection
    of services (here, with `BookmarkService`):'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a variable of the `IBookmarkService` type that will be used to retrieve
    an instance of the injected service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We configure the dependency injection by leveraging the `HostBuilder` class
    provided by .NET and registering services to the `IServiceCollection` collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We retrieve the instance of the registered services by calling `GetRequiredService`
    on the `IServiceCollection` collection and store a reference to the retrieved
    service into the variable we declared earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating an instance of a new command, we pass that variable as a parameter
    to the command‚Äôs constructor so that the new command receives an instance of the
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And voila! The service is automatically instantiated and injected into the various
    commands that require it.
  prefs: []
  type: TYPE_NORMAL
- en: What‚Äôs great about this approach is that if we need to change the service implementation,
    all we need to do is modify the service registration to `IServiceCollection` and
    the rest will be magically taken care of.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the `Program.cs` file has shrunk from 479 lines of code to 115 lines
    of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'And the best part? Registering a new command to the root command is a matter
    of one extra line of code (aka, calling `AddCommand` on the root command and passing
    an instance of the new command to be registered), while injecting a new service
    is a matter of two lines of code: one for adding the service into the services
    collection and the other for getting a reference to that service in order to pass
    it to classes that require it.'
  prefs: []
  type: TYPE_NORMAL
- en: Beware of the pitfalls!
  prefs: []
  type: TYPE_NORMAL
- en: Common pitfalls in dependency injection include circular dependencies, where
    classes depend on each other, and unintended singleton behavior, which can arise
    from improper service lifetimes. Over-injection of dependencies can violate the
    Single-Responsibility Principle, while excessive reliance on service locators
    complicates testing. To avoid these issues, it‚Äôs crucial to manage service lifetimes
    carefully and follow best practices.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend that you check out the reading recommendations in [*Chapter
    14*](B22400_14.xhtml#_idTextAnchor236) in order to explore this topic more deeply
    when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Step 7 ‚Äì running the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perfect! We have completed the refactoring of the `export` command. Let‚Äôs run
    the code to ensure that it still works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to invoke the `export` command hasn‚Äôt changed. So, let‚Äôs invoke
    it the same way as before by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 ‚Äì Invoking the export command after refactoring](img/B22400_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 ‚Äì Invoking the export command after refactoring
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! The application still works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We have done a lot of refactoring to our application so far. But is that all?
    Or can we take it to another level?
  prefs: []
  type: TYPE_NORMAL
- en: Taking refactoring to new heights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have been wondering why we didn‚Äôt extract options and handler methods
    into their own code artifacts (such as classes).
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that options and handler methods (and also arguments) are usually
    unique to a specific command. For this reason, they are defined in the command
    class.
  prefs: []
  type: TYPE_NORMAL
- en: However, in situations where they would need to be used by more than one command,
    we would have extracted them into their own code artifact. This reasoning is important
    to keep in mind in order to avoid over-complexifying our design by over-abstracting
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of an option, we would have created a dedicated class. Here‚Äôs an
    example of `outputfileOption` we used in our `ExportCommand` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then use this option in any command by creating an instance of it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it would have looked for `ExportCommand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to how the `outputfileOption` property is declared (in
    the `Options` region) and how it is instantiated and initialized in the constructor.
    Its usage is no different from before.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a handler method, we would have created a base class that derives
    from `Command` (let‚Äôs call it `CommandWithBaseHandler`), add the handler method
    to it (allowing it to be overridden), and make our command classes derive from
    that `CommandWithBaseHandler` class rather than from the `Command` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CommandWithBaseHandler` class could have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `OnExportCommand` method has been marked as `virtual`. This
    means that it provides a default implementation in the `CommandWithBaseHandler`
    class but allows that implementation to be overridden if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then have modified the `ExportCommand` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! But where would these new code artifacts fit into our project structure?
    Great question!
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs update our project structure to accommodate these new artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the same principle regarding project structure that we applied so
    far, I suggest the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 ‚Äì The project structure for commands](img/B22400_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 ‚Äì The project structure for commands
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! We now have an application that is more modular and easily extensible.
    Everything has its own place so it‚Äôs easier to read and navigate the application‚Äôs
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Wait, extensible?!
  prefs: []
  type: TYPE_NORMAL
- en: You may not have noticed, but the refactoring exercise we have done throughout
    this chapter not only enhanced our application from a modularity standpoint but
    also from an extensibility standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it: we can now easily involve other teammates in the development
    of our application, making delivering new features to our users even faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Every team member can focus on their very own command, impacting only a small
    subset of code artifacts and, in most cases, they won‚Äôt modify the same files,
    reducing the number of merge conflicts that may occur when pushing their code
    into the source control.
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring also allows to speed up the onboarding process of new team
    members. Since every code artifact has its proper place, the code is easier to
    understand and to own. If you are looking for contributors to your application,
    this is a very important point to keep in mind!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we refactored *Bookmarkr* to make it more modular. Each command
    is now described in its own code file.
  prefs: []
  type: TYPE_NORMAL
- en: By taking the time to refactor our CLI application, we have greatly enhanced
    its readability, maintainability, testability, and extensibility. It is now easier
    to add new capabilities, such as new commands (of course) as well as new features
    to existing commands.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking about that, in the next chapter, we will see how to call external services
    and APIs to extend the capabilities of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Your turn!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following along with the provided code is a great way to learn through practice.
  prefs: []
  type: TYPE_NORMAL
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Task #1 ‚Äì refactor the remaining commands'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though this chapter proposes only one challenge, it will require effort
    on your side!
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the pages of this chapter, we have refactored the `export` command.
    You are now tasked with refactoring the other commands of the *Bookmarkr* application.
  prefs: []
  type: TYPE_NORMAL
- en: For that matter, you can follow the same strategy and steps we used in our previous
    refactoring activity. By practicing it again and again, you will gain mastery
    of this process.
  prefs: []
  type: TYPE_NORMAL
- en: You will find the version of the code that hasn‚Äôt been refactored in the `Program.Unrefactored.cs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs do this!
  prefs: []
  type: TYPE_NORMAL
