- en: Using the Right Controls for the Job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll first consider the existing controls that **Windows Presentation
    Foundation** (**WPF**) offers us and look at how we can use them to create the
    layouts that we require. We'll investigate the many ways that we can modify these
    controls to avoid the need to create new controls.
  prefs: []
  type: TYPE_NORMAL
- en: We'll examine the various levels of functionality that are built into the existing
    controls and then discover how to best declare our own controls when required.
    We'll take an in-depth look at the various options that we have and determine
    when it's best to use each one. Let's jump straight in and take a look at the
    various layout controls.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating the built-in controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a wide range of controls included in .NET Framework. They cover most
    common scenarios and it is rare that we will need to create our own controls in
    a typical form-based application. All of the UIÂ controls tend to have their functionality
    built up from a large number of common base classes.
  prefs: []
  type: TYPE_NORMAL
- en: All controls will share the same core-level base classes that provide the core-level
    functionalities and then a number of derived framework-level classes that provide
    the functionality that is associated with the WPF Framework, such as data binding,
    styling, and templating. Let's take a look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting framework abilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with the base classes in our application framework, the built-in WPF controls
    also have an inheritance hierarchy, with each successive base class offering some
    additional functionality. Let''s look at the `Button` class as an example. Here
    is the inheritance hierarchy of the `Button` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with every object in .NET Framework, we start with the `Object` class, which
    provides low-level services to all classes. These include object comparison, finalization,
    and the ability to output a customizable `string` representation of each object.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `DispatcherObject` class, which provides each object with thread
    affinity and associates them with a `Dispatcher` object. The `Dispatcher` class
    manages a prioritized queue of work items for individual threads. Only the thread
    that the associated `Dispatcher` object was created on can access each `DispatcherObject`
    directly and this enables derived classes to enforce thread safety.
  prefs: []
  type: TYPE_NORMAL
- en: After the `DispatcherObject` class, we have the `DependencyObject` class, which
    enables all derived classes to use the WPF property system and declare Dependency
    Properties. The `GetValue` and `SetValue` methods that we call to access and set
    their values are also provided by the `DependencyObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is the `Visual` class, which has the primary role of providing rendering
    support. All elements that are displayed in the UI will extend the `Visual` class.
    In addition to rendering each object, it also calculates their bounding box and
    provides support for hit testing, clipping, and transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Visual` class is the `UIElement` class, which provides a number
    of core services to all of its derived classes. These include the event and user
    input systems and the ability to determine the element's layout appearance and
    rendering behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Following on from that is the `FrameworkElement` class, which provides the first
    framework-level members, building upon the foundation of the core-level classes
    that it extends. It is the `FrameworkElement` class that enables data binding
    through the `DataContext` property and styling through the `Style` property.
  prefs: []
  type: TYPE_NORMAL
- en: It also provides events that relate to an object's lifetime, an upgrade of the
    core-level layout system to a full layout system and improved support for animations,
    among other things. This is typically the lowest-level class that we might want
    to extend if we were creating our own basic elements, as it enables derived classes
    to partake in the majority of the WPF UI capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The `Control` class extends the `FrameworkElement` class and is the base class
    for most of the WPF UI elements. It provides appearance templating through the
    use of its `ControlTemplate` functionality and a host of appearance-related properties.
    These include coloring properties, such as `Background`, `Foreground`, and `BorderBrush`,
    along with alignment and typeface properties.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Control` class is the `ContentControl` class, which enables controls
    to have one object of any CLR type as its content. This means that we can either
    set data objects or UI elements as the content, although we may need to provide
    a `DataTemplate` for the data objects if they are of a custom type.
  prefs: []
  type: TYPE_NORMAL
- en: The final class in the long line of parent classes that the `Button` class extends
    is the `ButtonBase` class. In fact, this is the base class for all buttons in
    WPF and it adds useful functionality for buttons. This includes automatically
    converting certain keyboard events to mouse events, so that users can interact
    with the buttons without using a mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` class itself adds little to its inherited members with only three
    related `bool` properties; two that specify whether a button is the default button
    and one that specifies whether the button is a cancel button. We'll see an example
    of this shortly. It has an additional two protected overridden methods that get
    called when the button is clicked or when an automation peer is created for it.
  prefs: []
  type: TYPE_NORMAL
- en: While WPF enables us to modify existing controls to such a degree that we rarely
    need to create our own, it is important to be aware of this inheritance hierarchy
    so that we can extend the appropriate and most lightweight base class that fulfills
    our requirements when we need to.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we wanted to create our own custom button, it would typically
    make more sense to extend the `ButtonBase` class, rather than the `Button` class,
    and if we wanted to create a totally unique control, we could extend the `FrameworkElement`
    class. Now that we have a good understanding of the make-up of the available controls,
    let's see how they are displayed by the WPF layout system.
  prefs: []
  type: TYPE_NORMAL
- en: Laying it on the line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, the layout system is responsible for attaining the sizes of each element
    to be displayed, positioning them on screen, and then drawing them. As controls
    can be contained within other controls, the layout system works recursively, with
    each child control's overall position being determined by the position of its
    parent panel control.
  prefs: []
  type: TYPE_NORMAL
- en: The layout system first measures each child in each panel in what is known as
    a measure pass. During this pass, each panel calls the `Measure` method of each
    child element and they specify how much space they would ideally like to have;
    this determines the `UIElement.DesiredSize` property value. Note that this is
    not necessarily how much space they will be given.
  prefs: []
  type: TYPE_NORMAL
- en: After the measure pass comes the arrange pass, when each panel calls the `Arrange`
    method of each child element. During this pass, the panels generate the bounding
    boxes of each of their child elements, dependent upon their `DesiredSize` values.
    The layout system will adjust these sizes to add any required margins or additional
    adjustments that may be needed.
  prefs: []
  type: TYPE_NORMAL
- en: It returns a value to the input parameter of the panels' `ArrangeOverride` method
    and each panel performs its own specific layout behavior before returning the
    possibly adjusted value. The layout system performs any remaining required adjustments
    before returning execution to the panel and completing the layout process.
  prefs: []
  type: TYPE_NORMAL
- en: We need to be careful when developing our applications to ensure that we do
    not unnecessarily trigger additional passes of the layout system, as this can
    lead to poor performance. This can occur when adding or removing items in a collection,
    applying transforms on the elements, or by calling the `UIElement.UpdateLayout`
    method, which forces a new layout pass.
  prefs: []
  type: TYPE_NORMAL
- en: Containing controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The existing controls can mostly be split into two main categories: those that
    provide layout support for other controls and those that make up the visible UI,
    and are arranged in it by the first category of controls. The first category of
    controls are of course panels and they provide a variety of ways to arrange their
    child controls in the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Some provide resizing capabilities, while others don't, and some are more efficient
    than others, so it's important to use the right panel for the job at hand. Additionally,
    different panels offer different layout behaviors, so it is good to know what
    the available panels are and what they each offer us in terms of layout.
  prefs: []
  type: TYPE_NORMAL
- en: All panels extend the abstract `Panel` class, and that extends the `FrameworkElement`
    class so it has all of the members and functionality of that class. However, it
    doesn't extend the `Control` class and so it cannot inherit its properties. It
    therefore adds its own `Background` property to enable users to color the gaps
    between the panel's various items.
  prefs: []
  type: TYPE_NORMAL
- en: The `Panel` class also provides a `Children` property that represents the items
    in each panel, although we do not typically interact with this property unless
    creating a custom panel. Instead, we can populate this collection by simply declaring
    our child elements directly within the panel element in XAML.
  prefs: []
  type: TYPE_NORMAL
- en: We are able to do this because the `Panel` class specifies the `Children` property
    in a `ContentPropertyAttribute` attribute in its class definition. While the `Content`
    property of a `ContentControl` normally enables us to add a single item of content,
    we are able to add multiple items into panels because their `Children` property,
    which is set as the content, is a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Another `Panel` class property that we might need to use is the `IsItemsHost`
    property, which specifies whether a panel is to be used as a container for the
    items of an `ItemsControl` element, or not. The default value is `false`, so it
    makes no sense to explicitly set this property to `false`. In fact, it is only
    ever required in a very particular situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'That situation is when we are replacing the default panel of an `ItemsControl`,
    or one of its derived classes, such as a `ListBox`, in a `ControlTemplate`. By
    setting this property to `true` on a panel element in a `ControlTemplate`, we
    are telling WPF to place the generated collection elements in the panel. Let''s
    see a quick example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple example, we are replacing the default internal items panel of
    the `ItemsControl` element with a horizontal `StackPanel`. Note that this is a
    permanent replacement and no one can make further changes to this without providing
    a new `ControlTemplate`. There is however a far easier way to achieve the same
    result and we saw an example of this in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this alternative example, we simply provide a new `ItemsPanelTemplate` for
    the `ItemsControl` through its `ItemsPanel` property. Using this code, the internal
    panel can still be easily changed without the need to provide a new `ControlTemplate`
    and so when we don't want other users to be able to swap out the inner panel,
    we use the first method, otherwise, we use this method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Panel` class also declares a `ZIndex`Â Attached Property, which can be used
    by child elements to specify a layered order within the panel. Child elements
    with higher values will appear above, or in front of, elements with lower values,
    although this property is ignored in panels that do not overlap their children.
    We'll see an example of this in the next section, so let's now focus on the panels
    that derive from the `Panel` class and what they offer us.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Canvas` class enables us to explicitly position child elements using combinations
    of the `Canvas.Top`, `Canvas.Left`, `Canvas.Bottom`, and `Canvas.Right`Â Attached
    Properties. This is vaguely similar to the old Windows Forms system of control
    placement.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when using WPF, we don''t typically layout UI controls in a `Canvas`.
    Instead, we tend to use them more for displaying shapes, constructing graphs,
    showing animations, or drawing applications. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates a number of important points, so let''s first see
    the visual output of this code before discussing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/148bd854-f1c2-43ad-b3e0-a4f4a759ddcc.png)'
  prefs: []
  type: TYPE_IMG
- en: The top-left rectangle is the output from one canvas, and the top-right and
    bottom ones are from two other canvas instances. They are all contained within
    a parent canvas element with a black background. The three inner canvases are
    spaced to give the effect that they each have a border. They have been declared
    in the order of top-left, top-right, bottom, and the last element to be declared
    is, the middle circle.
  prefs: []
  type: TYPE_NORMAL
- en: The left circle is being drawn in the top-left canvas and we can see where it
    is overlapping the canvas' apparent bottom border, which shows that it is not
    being clipped by its parent canvas. However, it is being clipped by the lower
    canvas element and this demonstrates that UI elements that are declared later
    will be displayed over the top of earlier declared elements.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the second canvas to be declared is clipping the middle circle,
    which was the last declared element. This demonstrates that setting the `Panel.ZIndex`
    property on an element to any positive number will position that element above
    all others that have not explicitly set this property. The default value for this
    property is zero, so an element that has this property set to `1` will be rendered
    on top of all elements that have not explicitly set a value for it.
  prefs: []
  type: TYPE_NORMAL
- en: The next element to be declared is the bottom rectangle and the right circle
    is declared within it. Now, as this element is declared after the top canvases,
    you might expect that the right circle would overlap the upper-right canvas. While
    this would normally be the case, this won't happen with our example for two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The first, as we've just found out, is because the upper-right panel has a higher
    `ZIndex` property value than the lower panel and the second reason is because
    we have set the `UIElement.ClipToBounds` property to `true`, which is used by
    the `Canvas` panel to determine whether it should clip the visual content of any
    children that may lie outside the bounds of the panel.
  prefs: []
  type: TYPE_NORMAL
- en: This is commonly used with animations, to enable a visual to be hidden out of
    the panel bounds and then slid into view in reaction to some event. We can tell
    that the right circle has been clipped by its parent panel because we can see
    its apparent top border, which is outside its bounds.
  prefs: []
  type: TYPE_NORMAL
- en: The last element to be declared is the middle circle and we can see that, apart
    from the overlapping canvas element with the higher `ZIndex` property value, it
    overlaps all of the other elements. Note that the `Canvas` panel does not perform
    any kind of resizing on its children, so it is not typically used for generating
    form type UI.
  prefs: []
  type: TYPE_NORMAL
- en: DockPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DockPanel` class is primarily used in the top levels of the control hierarchy
    to lay out the top-level controls. It provides us with the ability to dock controls
    to various parts of the screen, for example, a menu docked at the top, a context
    menu on the left, a status bar at the bottom and our main View content control
    in the remainder of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbf9e32a-b2b5-436c-b14b-db966f715504.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This layout shown in the preceding diagram can be easily achieved with just
    the following XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We specify where we want each element within the panel to be docked using the
    `DockPanel.Dock`Â Attached Property. We can specify the left, right, top, and bottom
    of the panel. The remaining space is normally filled by the last child that does
    not explicitly set one of the `Dock` property. However, if that is not the behavior
    that we want, then we can set the `LastChildFill` property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `DockPanel` will automatically resize itself to fit its content unless its
    dimensions are specified, either explicitly using the `Width` and `Height` properties,
    or implicitly by a parent panel. If it and its children both have dimensions specified
    for them, there is a chance that certain children will not be provided with enough
    space and not be displayed correctly, as the last child is the only child that
    can be resized by the `DockPanel`. It should also be noted that this panel does
    not overlap its child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the order that the children are declared in will affect the
    space and position that they are each provided with. For example, if we wanted
    the menu bar to fill the top of the screen, the context menu to take the remaining
    left side, and the View and the status bar to take the remaining space, we could
    just declare the context menu before the status bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This slight change would result in the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65d77aca-c368-4445-b302-cf68b18f9422.png)'
  prefs: []
  type: TYPE_IMG
- en: Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Grid` panel is by far the most commonly used when it comes to laying out
    typical UI controls. It is the most versatile and enables us to perform a number
    of tricks to end up with the layout that we require. It offers a flexible row-
    and column-based layout system that we can use to build UIs with a fluid layout.
    Fluid layouts are able to react and change size when users resize their application
    windows.
  prefs: []
  type: TYPE_NORMAL
- en: The `Grid` is one of the few panels that can resize all of its child elements
    depending on the space available,Â which makes it one of the most performance-intensive
    panels. Therefore, if we don't need the functionality that it provides, we should
    use a more performant panel, such as a `Canvas`Â or `StackPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: The children of a `Grid` panel can each set their `Margin` property to be laid
    out using absolute coordinates, in a similar fashion to the `Canvas` panel. However,
    this should be avoided wherever possible, because that will break the fluidity
    of our UI. Instead, we typically define our desired layout using the grid's `RowDefinitions`
    and `ColumnDefinitions` collections and the `Grid.Row` and `Grid.Column`Â Attached
    Properties.
  prefs: []
  type: TYPE_NORMAL
- en: While we can again hard code exact widths and heights for our rows and columns,
    we usually try to avoid doing so for the same reason. Instead, we generally take
    advantage of the grid's sizing behavior and declare our rows and columns, predominantly
    using one of two values.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `Auto` value, which takes its size from its content and the
    second is the default `*` star-sized value, which takes all of the remaining space.
    Typically, we set all columns or rows to `Auto` except the one(s) that contain(s)
    the most important data, which is/are set to `*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if we have more than one star-sized column, then the space is normally
    divided equally between them. However, if we need unequal divisions of the remaining
    space, then we can specify a multiplier number with the asterisk, which will multiply
    the proportion of space that that row or column will be provided with. Let''s
    see an example to help to clarify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example demonstrates a number of points, so let''s see the rendered output
    before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f16dcf8f-ac1f-47ae-bcf6-3995e5ee2e35.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have a very basic confirmation dialog control. It is formed with a
    `Grid` panel with three columns and two rows. Note that a single star-sizing is
    used as the default width and height values for the `ColumnDefinition` and `RowDefinition`
    elements respectively; we do not need to explicitly set them and can simply declare
    empty elements.Â Also note that star-sizing will only work when the `Grid` panel
    has some size set on it, as we have done here.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in our example, the second and third columns and the first row will
    use star-sizing and take all of the remaining space. The first column also uses
    star-sizing, however, it specifies a multiplier value of `2.5`. As such, it will
    be provided with two and a half times the amount of space that the other two columns
    will each have.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this first column is only used to push the buttons in the other two
    columns to the correct position. While the `TextBlock` element is declared in
    the first column, it does not only reside in that column, because it has also
    specified the `Grid.ColumnSpan`Â Attached Property, which allows it to spread out
    across multiple columns. The `Grid.RowSpan`Â Attached Property does the same for
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: The `Grid.Row` and `Grid.Column`Â Attached Properties are used by each element
    to specify which cell they should be rendered in. However, the default value for
    these properties is zero and so, when we want to declare an element within the
    first column or row of the panel, we can omit the setting of these properties,
    as has been done for the `TextBlock` in our example.
  prefs: []
  type: TYPE_NORMAL
- en: TheÂ OKÂ button has been declared in the second row and column and sets theÂ `IsDefault`Â key
    toÂ `true`, which enables users to invoke it by pressing theÂ *Enter*Â key on their
    keyboards. It is also responsible for the blue border on the button and we can
    use this property to style the default button differently in our own templates.Â TheÂ CancelÂ button
    sits next to it in the third column and sets theÂ `IsCancel`Â property toÂ `true`,
    which enables the users to select it by pressing theÂ *Esc*Â key on their keyboards.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could have set the lower `RowDefinition.Height` property to `26`
    instead of setting that on each button explicitly and the end result would have
    been the same, as the `Auto` value would be calculated from their height anyway.
    Also, note that the `Margin` property has been set on a few elements here for
    spacing purposes only, rather than for absolute positioning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two other useful properties declared by the `Grid` class. The first
    is the `ShowGridLines` property, which as you can imagine, shows the borders of
    the rows and columns in the panel when set to `true`. While not really required
    for simple layouts as in the previous example, this can be useful while developing
    more complicated layouts. However, due to its poor performance, this feature should
    never be utilized in production XAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what this looks like with visible grid lines now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d94f6a2d-482e-4cbe-94c1-4fc62ba50a95.png)'
  prefs: []
  type: TYPE_IMG
- en: The other useful property is the `IsSharedSizeScope` Attached Property, which
    enables us to share sizing information between two or more `Grid` panels. We can
    achieve this by setting this property to `true` on a parent panel and then specifying
    the `SharedSizeGroup` property on the relevant `ColumnDefinition` and/or `RowDefinition`
    elements of the inner `Grid` panels.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few conditions that we need to adhere to in order to get this to
    work and the first relates to scope. The `IsSharedSizeScope`Â property needs to
    be set on a parent element, but if that parent element is within a resource template
    and the definition elements that specify the `SharedSizeGroup` property are outside
    that template then it will not work. It will, however, work in the opposite direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other point to be aware of is that star-sizing is not respected when sharing
    sizing information. In these cases, the star values of any definition elements
    will be read as `Auto`, so we do not typically set the `SharedSizeGroup` property
    on our star-sized column. However, if we set it on the other columns, then we
    will be left with our desired layout. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have an `ItemsControl` that is data bound to a slightly
    edited version of our `Users` collection from our earlier examples. Previously,
    all of the user names were of a similar length, so one has been edited to demonstrate
    this point more clearly. The `ShowGridLines` property has also been set to `true`
    on the inner panels for the same reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example, we first set the `IsSharedSizeScope` Attached Property to `true`
    on the parent `Grid` panel and then apply the `SharedSizeGroup` property to the
    definitions of the inner `Grid` controls, which are declared inside the outer
    panel and within the `DataTemplate` element. Let''s see the rendered output of
    this code before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/677c3f7e-4a2b-4ee1-9b0b-3552f222bb37.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we have provided the same number of columns and group names for the
    columns inside and outside of the `DataTemplate` element, which is essential for
    this functionality to work. Also note that we have not set the `SharedSizeGroup`
    property on the middle column, which is star-sized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping just the other two columns will have the same visual effect as grouping
    all three, but without losing the star-sizing on the middle column. However, let''s
    see what would happen if we also set the `SharedSizeGroup` property on the middle
    column definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, we have lost the star-sizing on ourÂ middle column and the remaining
    space has now been applied to the last column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/298fd5a8-a489-4fbd-b0bb-0d200dc2a841.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Grid` panel within the template will be rendered for each item in the collection
    and so this will actually result in several panels, each with the same group names
    and therefore, also column spacing. It is important that we set the `IsSharedSizeScope`
    property to `true` on the `Grid` panel that is the common parent to all of the
    inner panels that we wish to share sizing information between.
  prefs: []
  type: TYPE_NORMAL
- en: StackPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `StackPanel` is one of the WPF panels that only provides limited resizing
    abilities to its child items. It will automatically set the `HorizontalAlignment`
    and `VerticalAlignment` properties of each of its children to `Stretch`, as long
    as they don''t have explicit sizes specified. In these cases alone, the child
    elements will be stretched to fit the size of the containing panel. This can be
    easily demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This panel literally lays each child element out one after the other, vertically
    by default, or horizontally when its `Orientation` property is set to `Horizontal`.
    Our example uses both orientations, so let''s take a quick look at its output
    before continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/512a4b8a-dba9-4cd1-8768-ffd0c4515acd.png)'
  prefs: []
  type: TYPE_IMG
- en: Our whole example is wrapped in a `Border` element with a black background.
    In its `Resources` section, we declared a few style properties for the `TextBlock`
    elements in our example. Inside the border, we declare our first `StackPanel`
    control, with its default vertical orientation. In this first panel, we have three
    `TextBlock` elements and another `StackPanel` wrapped in a border.
  prefs: []
  type: TYPE_NORMAL
- en: The first `TextBlock` element is automatically stretched to fit the width of
    the panel. The second adds a margin, but would otherwise also be stretched across
    the width of the panel. The third, however, has its `HorizontalAlignment` property
    explicitly set to `Center` and so it is not stretched to fit by the panel.
  prefs: []
  type: TYPE_NORMAL
- en: The inner panel has three `TextBlock` elements declared inside it and has its
    `Orientation` property set to `Horizontal`. Its children are therefore laid out
    horizontally. Its border is colored, so that it is easier to see its bounds. Note
    the use of the `SnapsToDevicePixels` property set on it.
  prefs: []
  type: TYPE_NORMAL
- en: As WPF uses device-independent pixel settings, thin straight lines can sometimes
    lie across individual pixel boundaries and appear anti-aliased. Setting this property
    to `true` will force the element to be rendered exactly in line with the physical
    pixels, using device-specific pixel settings and forming a clearer, sharper line.
  prefs: []
  type: TYPE_NORMAL
- en: The first `TextBlock` element in the lower panel is automatically stretched
    to fit the height of the panel. As with the elements in the upper panel, the second
    adds a margin, but would otherwise also be stretched across the height of the
    panel. The third, however, has its `VerticalAlignment` property explicitly set
    to `Center` and so it is not stretched vertically to fit by the panel.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, we have used the hexadecimal entity to add a new line in some
    of our text strings. This could also have been achieved using the `TextBlock.TextWrapping`
    property and hard coding a `Width` for each element, but this way is obviously
    far simpler.
  prefs: []
  type: TYPE_NORMAL
- en: UniformGrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UniformGrid` panel is a lightweight panel that provides a simple way to
    create a grid of items, where each item is of the same size. We can set its `Row`
    and `Column` properties to specify how many rows and columns we want our grid
    to have. If we do not set one or both of these properties, the panel will implicitly
    set them for us, depending upon the available space it has and the size of its
    children.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also provides us with a `FirstColumn` property that will affect the column
    that the first child item will be rendered in. For example, if we set this property
    to `2` then the first child will be rendered in the third column. This is perfect
    for a calendar control, so let''s take a look at how we might create the following
    output using the `UniformGrid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b28f00fa-c5ca-42b4-8dce-38c6edd9f46c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, a calendar control often needs to have blank spaces in the
    first few columns and so the `FirstColumn` property achieves this requirement
    simply. Let''s see the XAML that defines this calendar example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `StackPanel` that is used to stack one `UniformGrid` panel directly
    above an `ItemsControl` that uses another one as its `ItemsPanel` and specifies
    a font size to use within the control. The top `UniformGrid` panel declares a
    single row of seven columns and some basic `TextBlock` styles. It has seven child
    `TextBlock` items that output the names of the days in a week.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ItemsControl` element has its `Background` property set to `Black`Â to
    black out days not in the current month, and its `Padding` set to make the background
    appear like a border to the right and bottom of the calendar. The top and left
    borders come from the individual cells in theÂ `UniformGrid`Â panel.Â The `ItemsControl.ItemsSource`Â property
    is data bound to a `Days` property in our View Model, so let''s take a look at
    that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `Enumerable.Range` method to populate the collection. It
    provides a simple way to generate a contiguous sequence of integers from the supplied
    start and length input parameters. As a LINQ method, it is implemented using deferred
    execution and the actual values are not generated until actually accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The second `UniformGrid` panel, which is set as the `ItemsControl.ItemsPanel`,
    only specifies that it should have seven columns, but leaves the number of rows
    to be calculated from the number of data bound items. Note also that we have hard
    coded a value of `2` to the `FirstColumn` property, although in a proper control,
    we would typically data bind the value for the relevant month to it instead.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use a `DataTemplate` to define what each day on the calendar should
    look like. Note that we do not need to specify a value for its `DataType` property
    in this example, because we are data binding to the whole data source object,
    which in this case is just an integer. Let's now move on to investigate the `WrapPanel`
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: WrapPanel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `WrapPanel`Â panel is similar to `StackPanel`, except that it will stack
    its children in both directions by default. It starts by laying out the child
    items horizontally and when it runs out of space on the first row, it automatically
    wraps the next item onto a new row and continues to lay out the remaining controls.
    It repeats this process using as many rows as are required, until all of the items
    are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: However, it also provides an `Orientation` property like `StackPanel`, and this
    will affect its layout behavior. If the `Orientation` property is changed from
    the default value of `Horizontal` to `Vertical`, then the panel's child items
    will be laid out vertically, from top to bottom until there is no more room in
    the first column. The items will then wrap to the next column and will continue
    in this way until all of the items have been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'This panel also declares `ItemHeight` and `ItemWidth` properties that enable
    it to restrict items'' dimensions and to produce a layout behavior similar to
    the `UniformGrid` panel. Note that the values will not actually resize each child
    item, but merely restrict the available space that they are provided with in the
    panel. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that while similar to the output of a `UniformGrid` panel, the output
    of this example could not actually be achieved with that panel, because one of
    the child items is a different size to the others. Let''s see the visual output
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06ed28c9-6ec6-4af6-bf07-b1c918a2d724.png)'
  prefs: []
  type: TYPE_IMG
- en: We first declare the `WrapPanel` and specify that each child should only be
    provided with a height of `50` pixels, while the panel itself should be `150`
    pixels wide. In the `Resources` section, we set the width of each button to be
    `50` pixels wide, therefore enabling three buttons to sit next to each other on
    each row, before wrapping items to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we simply define the eleven buttons that make up the panel's children,
    specifying that the zero button should be twice as wide as the others. Note that
    this would not have worked if we had set the `ItemWidth` property to `50` pixels,
    along with the `ItemHeight` property. In that case, we would have seen half of
    the zero button, with the other half covered by the period button and a blank
    space where the period button currently is.
  prefs: []
  type: TYPE_NORMAL
- en: Providing custom layout behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the layout behavior of the built-in panels do not meet our requirements,
    we can easily define a new panel with custom layout behavior. All we need to do
    is to declare a class that extends the `Panel` class and to override its `MeasureOverride`
    and `ArrangeOverride` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the `MeasureOverride` method, we simply call the `Measure` method on each
    child item from the `Children` collection, passing in a `Size` element set to
    `double.PositiveInfinity`. This is equivalent to saying "set your `DesriredSize`
    property as if you had all of the space that you could possibly need" to each
    child item.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ArrangeOverride` method, we use the newly determined `DesriredSize`
    property value of each child item to calculate its required position and call
    its `Arrange` method to render it in that position. Let''s look at an example
    of a custom panel that positions its items equally around the circumference of
    a circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In our `CircumferencePanel` class, we first declare our own `Padding` property
    of type `Thickness`, which will be used to enable the users of the panel to lengthen
    or shorten the radius of the circle and therefore, adjust the position of the
    rendered items within the panel. The `MeasureOverride` method is a simple affair,
    as previously explained.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ArrangeOverride` method, we calculate the relevant angles to position
    the child items with, depending upon how many of them there are. We take the value
    of our `Padding` property into consideration when calculating the *X* and *Y*
    radiuses, so that users of our custom panel will be better able to control the
    position of the rendered items.
  prefs: []
  type: TYPE_NORMAL
- en: For each child item in the panel's `Children` collection, we first calculate
    the point on the circle where it should be displayed. We then offset that value
    using the value of the element's `DesiredSize` property, so that the bounding
    box of each item is centered on that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the element''s bounding box using a `Rect` element, with the
    offset point and the element''s `DesiredSize` property, and pass that to its `Arrange`
    method to render it. After each element is rendered, the current angle is changed
    for the next item. Remember that we can utilize this panel by adding a XAML namespace
    for the `Panels` CLR namespace and setting the `ItemsPanel` property of an `ItemsControl`
    or one of its derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Given some suitable data, we could use this panel to display the numbers on
    a clock control, for example. Let''s see the `Hours` property that the `ItemsSource`
    property of our example `ItemsControl` is data bound to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As the hour numerals must start with 12 and then go back to 1, we declare the
    collection with the 12 element initially. At some later stage, possibly during
    construction, we then add the remaining numbers to the collection and this is
    what it looks like when using our new panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2731651-1436-4647-b644-24033721c070.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes our coverage of the main panels that are available in WPF. While
    we don't have the space to have an in-depth look at every other WPF control, we'll
    find tips and tricks for a number of them throughout this book. Instead, let's
    now focus on a few essential controls and what they can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: Content controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this control is not often used directly, one use for it is to render a
    single data item according to a particular template. In fact, we often use a `ContentControl`
    to display our View Models and use a `DataTemplate` object that renders the associated
    View. Alternatively, we might use some form of `ItemsControl` to display a group
    of items and a `ContentControl` to display the selected item.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we found out earlier, when looking at the inheritance hierarchy of the `Button`
    control, the `ContentControl` class extends the `Control` class and adds the ability
    for derived classes to contain any single CLR object. Note that if we need to
    specify more than a single object of content, we can use a single panel object
    that contains further objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/238a62c4-8115-4466-b502-e4d5c6066fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: We can specify this content through the use of the `Content` property. However,
    the `ContentControl` class specifies the `Content` property in a `ContentPropertyAttribute`
    attribute in its class definition and this enables us to set the content by simply
    declaring the child element directly within the control in the XAML. This attribute
    is used by the XAML processor when it processes XAML child elements.
  prefs: []
  type: TYPE_NORMAL
- en: If the content is of type `string`, then we can use the `ContentStringFormat`
    property to specify a particular format for it. Otherwise, we can use the `ContentTemplate`
    property to specify a `DataTemplate` to use while rendering the content. Alternatively,
    the `ContentTemplateSelector` property is of type `DataTemplateSelector` and also
    enables us to select a `DataTemplate`, but based upon some custom condition that
    we may have. All derived classes have access to these properties in order to shape
    the output of their content.
  prefs: []
  type: TYPE_NORMAL
- en: However, this control is also able to display many primitive types without us
    having to specify a custom template. Let's move on to the next section now, where
    we'll find out exactly how it manages to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, there is a special element that is essential but often little understood.
    The `ContentPresenter` class basically presents content, as its name suggests.
    It is actually used internally within `ContentControl` objects to present their
    content.
  prefs: []
  type: TYPE_NORMAL
- en: That is its sole job and it should not be used for other purposes. The only
    time that we should declare these elements is within a `ControlTemplate` of a
    `ContentControl`Â element or one of its many derived classes. In these cases, we
    declare them where we want the actual content to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that specifying the `TargetType` property on a `ControlTemplate` when
    using a `ContentPresenter` will result in its `Content` property being implicitly
    data bound to the `Content` property of the relevant `ContentControl` element.
    We are however free to data bind it explicitly to whatever we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `ContentTemplate` and `ContentTemplateSelector` properties both mirror those
    of the `ContentControl` class and also enable us to select a `DataTemplate` based
    upon a custom condition. Like the `Content` property, both of these properties
    will also be implicitly data bound to the properties of the same names in the
    templated parent if the `TargetType` property of the `ControlTemplate` has been
    set.
  prefs: []
  type: TYPE_NORMAL
- en: This usually saves us from having to explicitly data bind these properties,
    although there are a few controls where the names of the relevant properties do
    not match up. In these cases, we can use the `ContentSource` property as a shortcut
    to data bind the `Content`, `ContentTemplate`, and `ContentTemplateSelector` properties.
  prefs: []
  type: TYPE_NORMAL
- en: If we set this property to `Header`, for example, the Framework will look for
    a property named `Header` on the `ContentControl` object to implicitly data bind
    to the `Content` property of the presenter. Likewise, it will look for properties
    named `HeaderTemplate` and `HeaderTemplateSelector` to implicitly data bind to
    the `ContentTemplate` and `ContentTemplateSelector` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is primarily used in a `ControlTemplate` for a `HeaderedContentControl`
    element or one of its derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There are specific rules that determine what the `ContentPresenter` will display.
    If the `ContentTemplate` or `ContentTemplateSelector` property is set, then the
    data object specified by the `Content` property will have the resulting data template
    applied to it. Likewise, if a data template of the relevant type is found within
    the scope of the `ContentPresenter` element, it will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: If the content object is a UI element, or one is returned from a type converter,
    then the element is displayed directly. If the object is a `string`, or a `string`
    is returned from a type converter, then it will be set as the `Text` property
    of a `TextBlock` control and that will be displayed. Likewise, all other objects
    simply have the `ToString` method called on them and then this output is rendered
    in a standardÂ `TextBlock`Â at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Items controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a fair number of examples of the `ItemsControl` class, but
    we'll now take a closer look at this control. In the simplest terms, an `ItemsControl`Â class
    contains a variable number of `ContentPresenter` elements and enables us to display
    a collection of items. It is the base class for most common collection controls,
    such as the `ListBox`, `ComboBox`, and `TreeView` controls.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these derived classes adds a specific look and set of capabilities,
    such as a border and the notion of a selected item. If we do not require these
    additional features and simply want to display a number of items, then we should
    just use the `ItemsControl`, because it is more efficient than its derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: When using the **Model-View-ViewModel** (**MVVM**) pattern, we typically data
    bind a collection that implements the `IEnumerable` interface from our View Model
    to the `ItemsControl.ItemsSource` property. However, there is also an `Items`
    property that will reflect the items in the data bound collection.
  prefs: []
  type: TYPE_NORMAL
- en: To clarify this further, either property can be used to populate the collection
    of items to display. However, only one can be used at a time, so if you have data
    bound a collection to the `ItemsSource` property, then you cannot add items using
    the `Items` property. In this case, the `Items` collection will become read-only.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to display a collection of items that don't implement the `IEnumerable`
    interface, then we will need to add them using the `Items` property. Note that
    the `Items` property is implicitly used when items are declared as the content
    of an `ItemsControl` element in XAML. However, when using MVVM, we generally use
    the `ItemsSource` property.
  prefs: []
  type: TYPE_NORMAL
- en: When displaying items in an `ItemsControl`, each item in the collection will
    implicitly be wrapped in a `ContentPresenter` container element. The type of container
    element will depend upon the type of collection control used. For example, a `ComboBox`
    would wrap its items in `ComboBoxItem` elements.
  prefs: []
  type: TYPE_NORMAL
- en: The `ItemContainerStyle` and `ItemContainerStyleSelector` properties enable
    us to provide a style for these container items. We must ensure that the styles
    that we provide are targeted to the correct type of container control. For example,
    if we were using a `ListBox`, then we would need to provide a style targeting
    the `ListBoxItem` type, as in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can explicitly declare these container items, although there is
    little point in doing so, as it will otherwise be done for us. Furthermore, when
    using MVVM, we do not typically work with UI elements, preferring to work with
    data objects in the View Models and data bind to the `ItemsSource` property instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already seen, the `ItemsControl` class has an `ItemsPanel` property
    of type `ItemsPanelTemplate`Â that enables us to change the type of panel that
    the collection control uses to layout its items. When we want to customize the
    template of an `ItemsControl`, we have two choices regarding how we render the
    control''s child items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We already saw an example of the preceding method in the previous section.
    In this way, we specify the actual items panel itself and set the `IsItemsHost`
    property to `true` on it to indicate that it is indeed to be used as the control''s
    items panel. Using the alternative method, we need to declare an `ItemsPresenter`
    element, which specifies where the actual items panel will be rendered. Note that
    this element will be replaced by the actual items panel being used at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As with the `ContentControl` class, the `ItemsControl` class also provides properties
    that enable us to shape its data items. The `ItemTemplate` and `ItemTemplateSelector`
    properties let us apply a data template for each item. However, if we just need
    a simple textual output, there are alternative methods where we canÂ avoid the
    need to define a data template at all.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `DisplayMemberPath` property to specify the name of the property
    from the object to display the value. Alternatively, we can set the `ItemStringFormat`
    property to format the output as a `string`, or as we saw earlier, just provide
    some meaningful output from the class'Â `ToString` method of the data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another interesting property is the `AlternationCount` property, which enables
    us to style alternating containers differently. We can set it to any number and
    the alternating sequence will repeat after that many items have been rendered.
    As a simple example, let''s use a `ListBox`Â because the `ListBoxItem` controls
    that will be wrapped around our items have appearance properties that we can alternate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the `AlternationCount` property to `3`, so we can have three different
    styles for our items and this pattern will be repeated for all three further items.
    We make a style for the item containers using the `ItemContainerStyle` property.
  prefs: []
  type: TYPE_NORMAL
- en: In this style, we use some simple triggers to change the color of the container
    background, depending on the value of the `AlternationIndex` property. Notice
    that the `AlternationCount` property starts at `0`, so the first item will have
    a red background, the second will have green, the third will have blue, then the
    pattern will repeat and the fourth will have red, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could have declared an `AlternationConverter` instance for
    each property that we wanted to alter and data bind them to the `AlternationIndex`
    property and the converter. We could create the same visual output using this
    XAML instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AlternationConverter` class works by simply returning the item from its
    collection that relates to the specified `AlternationIndex` value, where the first
    item is returned for index zero. Note that we need to include the parenthesis
    around the data bound class and property name because it is an Attached Property
    and we need to use a `RelativeSource.Self` binding because the property is set
    on the item container object itself. Let''s see the output of these two code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe7b34ae-96eb-4c4e-8cbc-9934751acd07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one more useful property that the `ItemsControl` class provides and
    that is the `GroupStyle` property, which is used to display the child items in
    groups. To group items in the UI, we need to accomplish a few simple tasks.Â We
    first need toÂ define XAML namespaces for ourÂ Â `Converters` project and the `ComponentModel`
    CLR namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to data bind a `CollectionViewSource`Â instance with one or more
    `PropertyGroupDescription` elements to our `Users` collection from the previous
    example. We then need to set that as the `ItemsSource` value for the `ItemsControl`
    and then set up its `GroupStyle`. Let''s see theÂ `StringToFirstLetterConverter`Â converter
    andÂ `CollectionViewSource` object that we need to declare in the local `Resources`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We specify the property that we want to use to group items by using the `PropertyName`
    property of the `PropertyGroupDescription` element. Note that in our case, we
    only have a few `User` objects, and so there would be no groups if we simply grouped
    by name. Therefore, we added a converter to return the first letter from each
    name to group on and specified it using the `Converter` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then added a basic `SortDescription` element to the `CollectionViewSource.SortDescriptions`
    collection in order to sort the `User` objects. We specified the `Name` property
    in the `PropertyName` property of the `SortDescription` element so that the `User`
    objects will be sorted by name. Letâs see the `StringToFirstLetterConverter` class
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this converter, we specify the data types that are involved in the implementation
    of the converter in the `ValueConversion` attribute, even though they are the
    same type. In the `Convert` method, we check the validity of our `value` input
    parameter and return the `DependencyProperty.UnsetValue` value if it is `null`.
    We then call the `ToString` method on it and if it is an empty string, we return
    theÂ `DependencyProperty.UnsetValue`Â value.Â For all valid `string` values, we simply
    return the first letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we do not need (or would not be able) to convert anything back using this
    converter, the `ConvertBack` method simply returns the `DependencyProperty.UnsetValue`
    value. By attaching this converter to the `PropertyGroupDescription` element,
    we are now able to group by the first letter of each name. Let''s now see how
    we can declare the `GroupStyle` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to use the `Binding.Source` property to access the `CollectionViewSource`
    object named `GroupedUsers` from the local `Resources` section. We then declare
    the data template that defines what each group header will look like in the `HeaderTemplate`
    property. Here we make use of the `StringToFirstLetterConverter` instance that
    has also been declared in a suitable resource collection and set a few basic style
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we specify a second data template, but one that defines what the items
    in each group should look like. We provide a very simple template that merely
    spaces the elements slightly and sets a few style properties. Let''s see the output
    of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d325ddef-c598-4132-af32-3c1955bb1387.png)'
  prefs: []
  type: TYPE_IMG
- en: Adorners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An adorner is a special kind of class that is rendered above all UI controls,
    in what is known as an adorner layer. Adorner elements in this layer will always
    be rendered on top of the normal WPF controls, regardless of their `Panel.ZIndex`
    property setting. Each adorner is bound to an element of type `UIElement` and
    independently rendered in a position that is relative to the adorned element.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the adorner is to provide certain visual cues to the application
    user. For example, we could use an adorner to display a visual representation
    of UI elements that are being dragged in a drag and drop operation. Alternatively,
    we could use an adorner to add handles to a UI control to enable users to resize
    the element.
  prefs: []
  type: TYPE_NORMAL
- en: As the adorner is added to the adorner layer, it is the adorner layer that is
    the parent of the adorner, rather than the adorned element. In order to create
    a custom adorner, we need to declare a class that extends the `Adorner` class.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a custom adorner, we need to be aware that we are responsible
    for writing the code to render its visuals. However, there are a few different
    ways to construct our adorner graphics; we can use the `OnRender` or `OnRenderSizeChanged`
    methods and a drawing context to draw basic lines and shapes, or we can use the
    `ArrangeOverride` method to arrange .NET controls.
  prefs: []
  type: TYPE_NORMAL
- en: Adorners receive events like other .NET controls, although if we don't need
    to handle them, we can arrange for them to be passed straight through to the adorned
    element. In these cases, we can set the `IsHitTestVisible` property to `false`
    and this will enable pass-through hit-testing of the adorned element. Let's look
    at an example of a resizing adorner that lets us resize shapes on a canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we investigate the adorner class, let''s first see how we can use it.
    Adorners need to be initialized in code, and so a good place to do this is in
    the `UserControl.Loaded` method, when we can be certain that the canvas and its
    items will have been initialized. Note that as adorners are purely UI related,
    initializing them in the control''s code behind does not present any conflict
    when using MVVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We access the adorner layer for the canvas that we will add the adorners to
    using the `AdornerLayer.GetAdornerLayer` method, passing in the canvas as the
    `Visual` input parameter. In this example, we attach an instance of our `ResizeAdorner`
    to each element in the canvas' `Children` collection and then add it to the adorner
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need a `Canvas` panel named `Canvas` and some shapes to resize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now seeÂ the code in our `ResizeAdorner` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have declared the `Adorners` namespace within the `Views` project,
    as this is the only place that it will be used. Inside the class, we declare the
    `VisualCollection` object that will contain the visuals that we want to render
    and then the visuals themselves, in the shape of `Thumb` controls.
  prefs: []
  type: TYPE_NORMAL
- en: We've chosen `Thumb` elements because they have built-in functionality that
    we want to take advantage of. They provide a `DragDelta` event that we will use
    to register the users' mouse movements when they drag each `Thumb`. These controls
    are normally used internally in the `Slider` and `ScrollBar` controls to enable
    users to alter values, so they're perfect for our purposes here.
  prefs: []
  type: TYPE_NORMAL
- en: We initialize these objects in the constructor, specifying a custom cursor and
    a different `DragDelta` event handler for each `Thumb` control. In these separate
    event handlers, we use the `HorizontalChange` or `VerticalChange` properties of
    the `DragDeltaEventArgs` object to specify the distance and direction of the mouse
    movement that triggered the event.
  prefs: []
  type: TYPE_NORMAL
- en: We use these values to move and/or resize the adorned element by the appropriate
    amount and direction. Note that we use the `Math.Max` method and the value `6`
    in our example to ensure that the adorned element cannot be resized smaller than
    the size of each `Thumb` element and the `Stroke` size of each adorned element.
  prefs: []
  type: TYPE_NORMAL
- en: After the four `DragDelta` event handlers, we find two different ways to render
    our adorner visuals. In the first method, we use the `DrawingContext` object that
    is passed into the `OnRender` method by the base class to manually draw shapes.
    This is somewhat similar to the way that we used to draw in the `Control.Paint`
    event handler methods when using `Windows.Forms`.
  prefs: []
  type: TYPE_NORMAL
- en: In this overridden method, we draw a rectangle that surrounds our element and
    is four pixels bigger than it in both dimensions. Note that we define a transparent
    background for the drawing brush, as we only want to see the rectangle border.
    Remember that adorner graphics are rendered on top of the adorned element, but
    we do not want to cover it.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ArrangeOverride` method, we use .NET Framework to render our `Visual`
    elements using their `Arrange` methods, as we would in a custom panel. Note that
    we could just as easily render our rectangle border in this method using a `Rectangle`
    element; the `OnRender` method was used in this example merely as a demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, we simply arrange each `Visual` element at the relevant position
    and size in turn. Calculating the appropriate positions can be achieved simply
    by dividing the width or height of each adorned element in half and subtracting
    half of the width or height of each thumb element.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get to the protected overridden `VisualChildrenCount` property and
    `GetVisualChild` method. The `Adorner` class extends the `FrameworkElement` class
    and that will normally return either zero or one from the `VisualChildrenCount`
    property, as each instance is normally represented by either no visual, or a single
    rendered visual.
  prefs: []
  type: TYPE_NORMAL
- en: In our case and other situations when a derived class has multiple visuals to
    render, it is a requirement of the layout system that the correct number of visuals
    is specified. For example, if we always returned the value `2` from this property,
    then only two of our thumbsÂ would be rendered on screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we also need to return the correct item from our visual collection
    when requested to from the `GetVisualChild` method. If, for example, we always
    returned the first visual from our collection, then only that visual would be
    rendered, as the same visual cannot be rendered more than once. Let''s see what
    our adorners look like when rendered above each of our shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ace8f73-a97b-45e1-bd69-aa16115d2aec.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying existing controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we find that the wide range of existing controls doesn't quite meet our
    needs, we might think that we need to create some new ones, as we would with other
    technologies. When using other UI languages, this might be the case, but with
    WPF, this is not necessarily true, as it provides a number of ways to modify the
    existing controls to suit our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: As we found out earlier, all classes that extend the `FrameworkElement` class
    have access to the framework's styling capabilities and those that extend the
    `Control` class can have their appearance totally changed through their `ControlTemplate`
    property. All of the existing WPF controls extend these base cases, and so possess
    these abilities.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these capabilities that enable us to change the look of the pre-existing
    WPF controls, we are also able to leverage the power of Attached Properties to
    add additional functionality to them too. In this section, we will investigate
    these different ways of modifying the existing controls.
  prefs: []
  type: TYPE_NORMAL
- en: Styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting the various properties of a control is the simplest way to alter its
    look and enables us to make either minor or more dramatic changes to it. As most
    UI elements extend the `Control` class, they mostly share the same properties
    that affect their appearance and alignment. When defining styles for controls,
    we should specify their type in the `TargetType` property, as this helps the compiler
    to verify that the properties that we are setting actually exist in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Failing to do so will result in the compiler stating that the member is not
    recognized or is not accessible. In these cases, we will need to specify the class
    type as well, in the format `ClassName.PropertyName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'One really useful property that the `Style` class declares is the `BasedOn`
    property. Using this property, we can base our styles on other styles and this
    enables us to create a number of incrementally different versions. Let''s highlight
    this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a simple style for the textboxesÂ in our application. We name
    it `TextBoxStyle` and then reference it in the `BasedOn` property of the second
    style. This means that all of the property setters and triggers declared in the
    first style will also apply to the bottom style. In the second style, we add a
    few further setters to make the applied textbox read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last point to note is that if we wanted to base a style on the default
    style of a control, we can use the value that we normally enter into the `TargetType`
    property as the key to identify the style that we want to base the new style on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's now move on to take a deeper look into resources.
  prefs: []
  type: TYPE_NORMAL
- en: Being resourceful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Styles are most often declared in the various `Resources` dictionaries of the
    application, along with various templates, application colors, and brushes. The
    `Resources` property is of type `ResourceDictionary` and declared in the `FrameworkElement`
    class and so virtually all UI elements inherit it and can therefore host our styles
    and other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the `Resources` property is of type `ResourceDictionary`, we do not
    need to explicitly declare this element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'While there are some occasions when we do need to explicitly declare the `ResourceDictionary`,
    it will be implicitly declared for us if we do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Every resource in each collection must have a key that uniquely identifies
    them. We use the `x:Key` directive to explicitly set this key, however, it can
    also be set implicitly as well. When we declare styles in any `Resources` section,
    we can specify the `TargetType` value alone, without setting the `x:Key` directive,
    in which case the style will be implicitly applied to all elements of the correct
    type that are in the scope of the style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the value for the `x:Key` directive is implicitly set to `{x:Type
    Button}`. Alternatively, we can set the `x:Key` directive explicitly, so that
    the style must also be applied explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Styles can have both values set as well, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'But a compilation error will be thrown if neither value is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding XAML would result in the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When a `StaticResource` with a specific key is requested, the lookup process
    first looks in the local control; if it has a style and that style has a resource
    dictionary, it checks that first; if there is no item with a matching key, it
    next looks in the resource collection of the control itself.
  prefs: []
  type: TYPE_NORMAL
- en: If there is still no match, the lookup process checks the resource dictionaries
    of each successive parent control until it reaches the `MainWindow.xaml` file.
    If it still does not find a match, then it will look in the application `Resources`
    section in the `App.xaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: '`StaticResource` lookups occur once upon initialization and will suit our requirements
    for most of the time. When using a `StaticResource` to reference one resource
    that is to be used within another resource, the resource being used must be declared
    beforehand. That is to say that a `StaticResource` lookup from one resource cannot
    reference another resource that is declared after it in the resource dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding XAML would result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Simply moving the declaration of the brush before the style would clear this
    error and get the application running again. However, there are certain situations
    when using a `StaticResource` to reference a resource isn't suitable. For example,
    we might need our styles to update during runtime in response to some programmatic
    or user interaction, such as a changing of the computer theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, we can use a `DynamicResource` to reference our resources and
    can rest assured that our styles will update when the relevant resources are changed.
    Note that the resource value is not looked up until it is actually requested,
    so this is perfect for resources that will not be ready until after the application
    starts. Note the following altered example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there will be no compilation error, as the `DynamicResource` will
    retrieve the value whenever it is set. While it's great to have this ability,
    it's important not to abuse it, as using the `DynamicResource` will negatively
    affect performance. This is because they repeatedly lookup the value each time
    it is requested, whether the values have changed or not. For this reason, we should
    only ever use a `DynamicResource` if we really need to.
  prefs: []
  type: TYPE_NORMAL
- en: One final point about resource styles to mention here relates to scope. While
    this topic has been mentioned elsewhere in this book, it is outlined again here
    as it is essential to understand the resource lookup procedure. Application resources
    that are declared in the `App.xaml` file are available application-wide, so this
    is a great place to declare our common styles.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is one of the furthest removed places that we can declare our
    styles, ignoring external resource dictionaries and theme styles. In general,
    the rule is that given a resource identifier conflict, the most local resources
    override those that are declared further away. Therefore, we can define our default
    styles in the application resources but retain the ability to override them locally.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, locally declared styles without an `x:Key` directive will be implicitly
    applied locally, but will not be applied to elements of the relevant type that
    are declared externally. We can, therefore, declare implicit styles in the `Resources`
    section of a panel for example and they will only be applied to elements of the
    relative type within the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Merging resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we have a large application and our application resources are becoming overcrowded,
    we have the option of splitting our default colors, brushes, styles, templates,
    and other resources into different files. In addition to organizational and maintenance
    benefits, this also enables our main resource files to be shared amongst our other
    applications, and so this promotes reusability too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we first need one or more additional resource files. We
    can add an additional resource file using Visual Studio, by right-clicking on
    the relevant project and selecting the Add option and then the Resource Dictionary...
    option. Upon executing this command, we will be provided with a file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of the occasions when we do need to explicitly declare the `ResourceDictionary`
    element. Once we have transferred our styles or other resources to this file,
    we can merge it into our main application resources file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we do not specify the `x:Key` directive for this resource dictionary.
    In fact, if we did specify this value on the dictionary, we would receive a compilation
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note also that we can set the `ResourceDictionary.MergedDictionaries` value
    either above or below our locally declared resources, but not anywhere in the
    middle of them. Within this property, we can declare another `ResourceDictionary`
    element for each external resource file that we want to merge and specify its
    location using a **Uniform Resource Identifier** (**URI**) in the `Source` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our external resource files reside in our startup project with our `App.xaml`
    file, we can reference them with relative paths, as shown in the preceding example.
    Otherwise, we will need to use the Pack URI notation. To reference a resource
    file from a referenced assembly, we would need to use the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, assuming that we had some resource files in a folder named `Styles`
    in a separate project, or other referenced assembly, we would merge the file using
    the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When merging resource files, it is important to understand how naming conflicts
    will be resolved. Although the `x:Key` directives that we set on our resources
    must each be unique within their declared resource dictionary, it is perfectly
    legal to have duplicated key values within separate resource files. As such, there
    is an order of priority that will be followed in these cases. Let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we have the aforementioned referenced resource file in a separate
    project and in that file, we have this resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we would need to add a reference to the `System.Xaml` assembly in
    that project in order to avoid errors. Now imagine that we also have the locally
    declared `Default Styles.xaml` resource file that was referenced in the previous
    example and in that file, we have this resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a `Default Styles 2.xaml` resource file with this resource in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we merge all of these resource files and add this additional
    resource in our application resource file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s imagine that we have this in the XAML of one of our Views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s assume that we have this in the local resources of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When running the application, our button text will be cyan, because the main
    rule of resource scope is that the highest priority resource that will be used
    will always be the most locally declared resource. If we removed or commented
    out the local brush declaration, the button text would then become purple when
    the application was next run.
  prefs: []
  type: TYPE_NORMAL
- en: If we removed the local purple brush resource from the control's `Resources`
    section, the application resources would be searched next in an attempt to resolve
    the `Brush` resource key. The next general rule is that the latest declared resource
    will be resolved. In this way, the button text would then become green, because
    of the locally declared resource in the `App.xaml` file, which would override
    the values from the merged dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: However, if this green brush resource was removed, an interesting thing would
    happen. Given the recently stated rules, we might expect that the button text
    would then be set to red by theÂ `Control Styles.xaml` resource file from the referenced
    assembly. Instead, it will be set to orange by the resource in the `Default Styles
    2.xaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: This is the result of a combination of the two rules together. The two locally
    declared resource files have a higher priority than the resource file from the
    referenced assembly because they have been declared more locally than it. The
    second of the two locally declared resource files takes precedence over the first
    because it was declared after the first.
  prefs: []
  type: TYPE_NORMAL
- en: If we removed the reference to the second of the locally declared resource files,
    the text would then be set to blue by the resource in the `Default Styles.xaml`
    file. If we then removed the reference to this file, we would finally see the
    red button text that would be set by the `Control Styles.xaml` file from the referenced
    assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, we have a number of `Trigger` classes that enable us to modify controls,
    albeit most commonly, just temporarily. All of them extend the `TriggerBase` base
    class and therefore inherit its `EnterActions` and `ExitActions` properties. These
    two properties enable us to specify one or more `TriggerAction` objects to apply
    when the trigger becomes active and/or inactive respectively.
  prefs: []
  type: TYPE_NORMAL
- en: While most trigger types also contain a `Setters` property that we can use to
    define one or more property setters that should occur when a certain condition
    is met, the `EventTrigger` class does not. Instead, it provides an `Actions` property
    that enables us to set one or more `TriggerAction` objects to be applied when
    the trigger becomes active.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, unlike the other triggers, the `EventTrigger` class has no concept
    of state termination. This means that the action applied by the `EventTrigger`
    will not be undone when the triggering condition is no longer true. If you hadn''t
    already guessed this, the conditions that trigger the `EventTrigger` instances
    are events, or `RoutedEvent` objects more specifically. Let''s investigate this
    type of trigger first with a simple example that we saw in the [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the trigger condition is met when the `FrameworkElement.Loaded`
    event is raised. The action that is applied is the start of the declared animation.
    Note that the `BeginStoryboard` class actually extends the `TriggerAction` class
    and this explains how we are able to declare it within the trigger. This action
    will be implicitly added into the `TriggerActionCollection` of the `EventTrigger`
    object, although we could have explicitly set it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the `EventTrigger` class, there are also `Trigger`, `DataTrigger`,
    `MultiTrigger` and `MultiDataTrigger` classes that enable us to set properties
    or control animations when a certain condition, or multiple conditions in the
    case of the multi triggers, are met. Each has its own merits, but apart from the
    `EventTrigger` class, which can be used in any trigger collection, there are some
    restrictions on where we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Each control that extends the `FrameworkElement` class has a `Triggers` property
    of type `TriggerCollection`, that enable us to specify our triggers. However,
    if you've ever tried to declare a trigger there, then you're probably aware that
    we are only allowed to define triggers of type `EventTrigger` there.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are further trigger collections that we can use to declare our
    other types of triggers. When defining a `ControlTemplate`, we have access to
    the `ControlTemplate.Triggers` collection. For all other requirements, we can
    declare our other triggers in the `Style.Triggers` collection. Remember that triggers
    defined in styles have a higher priority than those declared in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the remaining types of triggers and what they can do
    for us. We start with the most simple, the `Trigger` class. Note that anything
    that the property trigger can do, the `DataTrigger` class can also do. However,
    the property trigger syntax is simpler and does not involve data binding and so
    it is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, a few requirements to using a property trigger and they
    are as follows. The relevant property must be a Dependency Property. Unlike the
    `EventTrigger` class, the other triggers do not specify actions to be applied
    when the trigger condition is met, but property setters instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are able to specify one or more `Setter` objects within each `Trigger` object
    and they will also be implicitly added to the trigger''s `Setters` property collection
    if we do not explicitly specify it. Note that also unlike the `EventTrigger` class,
    all other triggers will return the original property value when the trigger condition
    is no longer satisfied. Let''s look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a button that will change the color of its text when the user mouse
    s over it. Unlike the `EventTrigger` however, its text color will return to its
    previously set color when the mouse is no longer over the button. Note also that
    property triggers use the properties of the controls that they are declared in
    for their conditions, as they have no way of specifying any other target.
  prefs: []
  type: TYPE_NORMAL
- en: 'As previously mentioned, the `DataTrigger` class can also perform this same
    binding. Let''s see what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, when using a `DataTrigger`, instead of setting the `Property`
    property of the `Trigger` class, we need to set the `Binding` property instead.
    In order to achieve the same functionality as the property trigger, we also need
    to specify the `RelativeSource.Self` enumeration member to set the binding source
    to the control that is declaring the trigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general rule of thumb is that when we are able to use a simple property
    trigger that uses a property of the host control in its condition, we should use
    the `Trigger` class. When we need to use a property of another control, or a data
    object in our trigger condition, we should use a `DataTrigger`. Let''s look at
    an interesting practical example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this style, we added a `DataTrigger` element that data binds to an `IsEditable`
    property that we could declare in a View Model class, that would determine whether
    the users could edit the data in the controls on screen or not. This would assume
    that an instance of the View Model was correctly set as the `UserControl.DataContext`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: If the value of the `IsEditable` property was `false`, then the `TextBox.IsReadOnly`
    property would be set to `true` and the control would become un-editable. Using
    this technique, we could make all of the controls in a form editable or un-editable
    by setting this property from the View Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The triggers that we have looked at so far have all used a single condition
    to trigger their actions or property changes. However, there are occasionally
    situations when we might need more than a single condition to trigger our property
    changes. For example, in one situation, we might want one particular style, and
    in another situation, we might want a different look. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two triggers. The first will change the button text
    to red when the mouse is over it. The second will change the button text to green
    if the mouse is over it *and* the button is focused.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we had to declare the two triggers in this order, as triggers are
    applied from top to bottom. Had we swapped their order, then the text would never
    change to green because the single trigger would always override the value set
    by the first one.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify as many `Condition` elements as we need within the `Conditions`
    collection and as many setters as we need within the `MultiTrigger` element itself.
    However, every condition must return true in order for the setters or other trigger
    actions to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be said for the last trigger type to be introduced here, the `MultiDataTrigger`.
    The difference between this trigger and the previous one is the same as that between
    the property trigger and the data trigger. That is, the data and multi-data triggers
    have a much wider range of target sources, while triggers and multi triggers only
    work with properties of the local control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the wider reach of the `MultiDataTrigger` class, due
    to its access to the wide range of binding sources. We have a `Show Errors` checkbox,
    a `No Errors`Â textblock, and let's say, some other form fields that are not displayed
    here. One of the conditions of this trigger uses the `ElementName` property to
    set the binding source to the checkbox and requires it to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: The other condition binds to an `IsValid` property from our View Model that
    would be set to `true` if there were no validation errors. The idea is that when
    the checkbox is checked and there are validation errors, the `Text` property of
    the `TextBlock` element will be data bound to another View Model property named
    `ErrorList`, which could output a description of the validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in this example, we explicitly declared the `Setters` collection
    property and defined our setter within it. However, that is optional and we could
    have implicitly added the setter to the same collection without declaring the
    collection, as shown in the previous `MultiTrigger` example.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving onto the next topic, let's take a moment to investigate the `EnterActions`
    and `ExitActions` properties of the `TriggerBase` class that enable us to specify
    one or more `TriggerAction` objects to apply when the trigger becomes active and/or
    inactive respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we cannot specify style setters in these collections, as they are
    not `TriggerAction` objects; setters can be added to the `Setters` collection.
    Instead, we use these properties to start animations when the trigger becomes
    active and/or inactive. To do that, we need to add a `BeginStoryboard` element,
    which extends the `TriggerAction` class. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Trigger` condition relates to the `IsMouseOver` property
    of the `TextBox` control. Note that declaring our animations in the `EnterActions`
    and `ExitActions` properties when using the `IsMouseOver` property is effectively
    the same as having two `EventTrigger` elements, one for the `MouseEnter` event
    and one for `MouseLeave` event.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the animation in the `EnterActions` collection will start as
    the user's mouse cursor enters the control and the animation in the `ExitActions`
    collection will start as the user's mouse cursor leaves the control.
  prefs: []
  type: TYPE_NORMAL
- en: We'll thoroughly cover animations later, in [Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml),
    *Mastering Practical Animations*, but in short, the animation that starts as the
    user's mouse cursor enters the control will fade in the control from being almost
    transparent to being opaque.
  prefs: []
  type: TYPE_NORMAL
- en: The other animation will return the `TextBox` control to an almost transparent
    state when the user's mouse cursor leaves the control. This creates a nice effect
    when a mouse is dragged over a number of controls with this style. Now that we
    have a good understanding of triggers, let's move on to find other ways of customizing
    the standard .NET controls.
  prefs: []
  type: TYPE_NORMAL
- en: Templating controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can greatly vary the look of each control using styles alone, there
    are occasionally situations when we need to alter their template to achieve our
    goal. For example, there is no direct way to change the background color of a
    button through styles alone. In these situations, we need to alter the control's
    default template.
  prefs: []
  type: TYPE_NORMAL
- en: 'All UI elements that extend the `Control` class provide access to its `Template`
    property. This property is of type `ControlTemplate` and enables us to completely
    replace the originally declared template that defines the normal look of the control.
    We saw a simple example in the [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),Â *Becoming
    Proficient with Data Binding*, but let''s now have a look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a button that we have altered to look like a circle. It is very
    basic, as we have not bothered to define any mouseover or click effects, but it
    shows that there is nothing scary about overriding the default template of a control
    and that it is simple to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b728e6a-0fac-480f-9952-0addb06bb33a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the `ContentPresenter` element is declared after the `Ellipse` element
    because the ellipse is not a content control and cannot have another element set
    as its content. This results in the content being drawn on top of the ellipse.
    A side effect of this is that we therefore need to add a panel inside the template,
    to enable us to provide more than a single piece of content.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that as with styles, we need to specify the `TargetType` property
    of the template. To clarify this a little, we need to specify it if we want to
    data bind to any properties of the control, or if the template contains a `ContentPresenter`
    element. Omitting this declaration will not raise a compilation error in the latter
    case, but the content will simply not appear in our templated control. It is therefore
    good practice to always set this property to the appropriate type.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, unlike styles, if we declared a `ControlTemplate` and set its `TargetType`
    property in a `Resources` collection without specifying the `x:Key` directive,
    it wouldÂ not be implicitly applied to all buttons in the application. In this
    case, we would receive a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we need to set the `x:Key` directive and explicitly apply the template
    to the `Template` property of the control. If we want our template to be applied
    to every control of that type then we need to set it in the default style for
    that type. In this case, we need to *not* set the `x:Key` directive of the style,
    so that it will be implicitly applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we would not typically hard code property values as we did in this
    template example, unless we did not want the users of our framework to be able
    to set their own colors on our templated controls. More often than not, we would
    make proper use of the `TemplateBinding` class to apply the values set from outside
    the control to the inner controls defined within our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: While this example is now far more verbose, it is also more practical and would
    enable users to set their own button properties. Setting thisÂ template in a default
    style would make the templated control far more reusable. Note that now, the hard
    coded values are made on the button control itself, with the exception of the
    `StrokeThickness` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no suitable property on the `Button` class that we could use to expose
    this inner control property. If this was a problem for us, we could expose the
    value of that property in a custom Attached Property and data bind to it on the
    button as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And we could do the following inside the control template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: However, even though we have improved our template, there are certain elements
    defined in the default templates that affect the way their containing controls
    look or work. If we remove these elements, as we have done in the preceding example,
    we will break that default functionality. For example, our example button no longer
    has focusing or interaction effects.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we may only need to slightly adjust the original template, in which
    case, we would typically start with the default `ControlTemplate` and then make
    our slight adjustment to it. If we had done this with our button example and simply
    replaced the visual aspects, then we could have retained the original interactivity
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: In days gone by, it could be quite difficult to find the default control templates
    for the various controls. We would previously need to try and track them down
    on the [docs.microsoft.com](http://docs.microsoft.com) website, or use Blend;
    now, however, we can use Visual Studio to provide it for us.
  prefs: []
  type: TYPE_NORMAL
- en: In the WPF designer, select the relevant control, or click on it with the mouse
    in a XAML file. With the relevant control selected or focused, press the *F4*
    key on your keyboard to open the Properties window. Next, open the Miscellaneous
    category to find the Template property, or type `Template` in the search field
    at the top of the Properties window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the little square to the right of the Template value field and select
    the Convert to New Resource... item in theÂ template options tooltip. In the popup
    dialog window that appears, name the new `ControlTemplate` to be added and decide
    where you want it to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba4093df-71fa-4c6f-a565-632761fa496b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have entered the required details, click the OK button to create a
    copy of the default template of your selected control in your desired location.
    As an example, let''s take a look at the default control template of the `TextBox`
    control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, most of the properties set on the inner controls have been exposed
    to the `TextBox` control through the use of the `TemplateBinding` class. At the
    end of the template are the triggers that react to various states, such as focus,
    mouseover, and enabled states.
  prefs: []
  type: TYPE_NORMAL
- en: However, inside the `Border` element, we see a `ScrollViewer` named `PART_ContentHost`.
    The fact that this is named with the `PART_` prefix specifies that this control
    is required within this template. All named parts of each UI element will be listed
    on the *[ControlType] Styles and Templates* pages on [docs.microsoft.com](http://www.docs.microsoft.com).
  prefs: []
  type: TYPE_NORMAL
- en: This named part control is required in the textbox because when the textbox
    is initialized, it programmatically adds the `TextBoxView` and `CaretElement`
    objects into the `ScrollViewer` object and these are the predominant elements
    that make up the textbox's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: These specially named elements also need to be registered within the declaring
    class and we'll find out more about that later in the chapter as well. It is therefore
    important that we include these named controls in our custom templates if we want
    to keep the existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we will not receive any compilation errors or even trace warnings
    if we do not include these named controls, and we are free to leave them out if
    we do not require their relevant functionality. This following example, while
    hardly functional, it still perfectly valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Although this `TextBox`Â control will indeed display the specified text value,
    it will have no containing box like a normal `TextBox`Â elementÂ would. What will
    happen when this template is rendered is that the `ContentPresenter` element will
    see a `string` and default to displaying it in a `TextBlock` element.
  prefs: []
  type: TYPE_NORMAL
- en: Its `Text` property will still be data bound to the `Text` property of our `TextBox`Â control
    and so, when focused, it will still behave like a normalÂ `TextBox`Â element and
    enable us to enter text. Of course, we won't see when it's focused because we
    didn't add any triggers to make that happen, and there won't be a caret as the
    `CaretElement` object will no longer be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, if we simply supply the required named control, even without anything
    else, we''ll still regain most of the original functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run our application, we have the caret and text cursor when the
    mouse is over the `TextBox`Â control, and so we have regained more of the functionality,
    but not the look. However usually, the best option is to keep as much of the original
    template as we can and only change the parts that we really need to.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using WPF, we have one further tool at our disposal to enable us to manipulate
    the built-in controls and avoid the need to create new ones. We are, of course,
    discussing Attached Properties, so let's extend an example that we started looking
    at in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),Â *Becoming Proficient
    with Data Binding*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a button that will enable us to set a second tooltip message
    to display when the control is disabled, we''ll need to declare two Attached Properties.
    One will hold the disabled tooltip message and the other will be the previously
    mentioned read-only property that temporarily holds onto the original tooltip
    value. Let''s look at our full `ButtonProperties` class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As with all Attached Properties, we start with a class that extends the `DependencyObject`
    class. In this class, we first declare the read-only `originalToolTipPropertyKey`
    field using the `RegisterAttachedReadOnly` method and the `OriginalToolTipProperty`
    property and its associated CLR getter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `RegisterAttached` method to register the `DisabledToolTip`
    property that will hold the value of the tooltip to be displayed when the control
    is disabled. We then see its CLR getter and setter methods and its all-important
    `PropertyChangedCallback` handling method.
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnDisabledToolTipChanged` method, we first cast the `dependencyObject`
    input parameter to its actual type of `Button`. We then use it to set the `ToolTipService.SetShowOnDisabled`
    Attached Property to `true`, which is required because we want the button's tooltip
    to be displayed when the button is disabled. The default value is `false`, so
    our Attached Property would not work without this step.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we determine whether we need to attach or detach the `Button_IsEnabledChanged`
    event-handling method depending on the `NewValue` and `OldValue` property values
    of the `DependencyPropertyChangedEventArgs` object. If the old value is `null`,
    then the property has not been set before and we need to attach the handler; if
    the new value is `null`, then we need to detach the handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Button_IsEnabledChanged` event-handling method, we first cast the `sender`
    input parameter to the `Button` type. We then use it to access the `OriginalToolTip`
    property and if it is `null`, we set it with the current value from the control's
    normal `ToolTip` property. Note that we need to pass the `originalToolTipPropertyKey`
    field into the `SetValue` method, as it is a read-only property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we utilize the `e.NewValue` property value to determine whether to
    set the original tooltip or the disabled tooltip into the control''s normal `ToolTip`
    property. Therefore, if the control is enabled, the `e.NewValue` property value
    will be `true` and the original tooltip will be returned; if the button is disabled,
    the disabled tooltip will be displayed. We could use this Attached Property as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from this simple example, Attached Properties enable us to easily
    add new functionality to the existing suite of UI controls. This again highlights
    how versatile WPF is and demonstrates that we often have no need to create completely
    new controls.
  prefs: []
  type: TYPE_NORMAL
- en: Combining controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we need to arrange a number of existing controls in a particular way, we
    typically use a `UserControl` object. This is why we normally use this type of
    control to build our Views. However, when we need to build a reusable control,
    such as an address control, we tend to separate these from our Views, by declaring
    them in a `Controls` folder and namespace within our Views project.
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring these reusable controls, it is customary to define Dependency
    Properties in the code behind and as long as there is no business-related functionality
    in the control, it is also OK to use the code behind to handle events. If the
    control is business-related, then we can use a View Model as we do with normal
    Views. Let''s take a look at an example of an address control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we declare this class within the `Controls` namespace and set
    up a XAML namespace prefix for it. We then see the `Grid` panel that is used to
    layout the address controls and notice that the `SharedSizeGroup` property is
    set on the `ColumnDefinition` element that defines the label column. This will
    enable the column sizes within this control to be shared with externally declared
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: We then see all of the `TextBlock` and `TextBox` controls that are data bound
    to the control's address fields. There's not much to note here except that the
    data bound properties are all accessed through a `RelativeSource` binding to an
    `Address` Dependency Property that is declared in the code behind file of the
    `AddressControl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that it''s fine to do this when using MVVM as long as we are not encapsulating
    any business rules here. Our control merely enables the users to input or add
    address information, which will be used by various Views and View Models. Let''s
    see this property now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple control with just one Dependency Property. We can see
    that the `Address` property is of type `Address`, so let''s have a quick look
    at that class next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have a very simple class that is primarily made up from the address
    related properties. Note the use of theÂ StringÂ Interpolation in the overridden
    `ToString` method to output a useful display of the class contents. Now we''ve
    seen the control, let''s take a look at how we can use it in our application.
    We can edit a View that we saw earlier, so let''s see the updated `UserView` XAML
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see the use of the `Grid.IsSharedSizeScope` property
    on the outermost `Grid` panel. Remember that the `SharedSizeGroup` property was
    set in the `AddressControl` XAML, although without this setting on the outer `Grid`,
    it does nothing by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the outer panel's column definitions, we can see that we have also
    set the `SharedSizeGroup` property to the same value of `Label`Â on the left column
    so that the two panels' columns will be aligned.
  prefs: []
  type: TYPE_NORMAL
- en: We can skip over the two styles that are declared in the panel's `Resources`
    section as in a proper application, these would most likely reside in the application
    resources file. In the remainder of the View, we simply have a couple of rows
    of user properties and thenÂ `AddressControl`.
  prefs: []
  type: TYPE_NORMAL
- en: This code assumes that we have declared an `Address` property of type `Address`
    in our `User` class and populated it with suitable values in the `UserViewModel`
    class. Note how we data bind the `Address` property of the `User` class to the
    `Address` property of the control, rather than setting the `DataContext` property.
    As the control's internal controls are data bound using `RelativeSource` bindings,
    which specify their own binding source, they do not require any `DataContext`
    to be set. In fact, doing so in this example would stop it from working.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using WPF, we can generally create the UI that we want using the many techniques
    already discussed in this book. However, in the cases where we require a totally
    unique control with both a custom drawn appearance and custom functionality, then
    we may need to declare a custom control.
  prefs: []
  type: TYPE_NORMAL
- en: Developing custom controls is very different than creating `UserControl` elements
    and it can take some time to master this. To start with, we will need to add a
    new project of type WPF Custom Control Library to declare them in. Also, instead
    of having a XAML page and a code behind file, we only have the code file. At this
    point, you may be wondering where we define what our control should look like.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, when defining a custom control, we declare our XAML in a separate file
    named `Generic.xaml`, which is added by Visual Studio when we add our controls
    project. To clarify, the XAML for all of the custom controls that we declare in
    this project will go into this file. This does not relate to controls that extend
    the `UserControl` class and we should not declare those in this project.
  prefs: []
  type: TYPE_NORMAL
- en: This `Generic.xaml` file gets added into a folder named `Themes` in the root
    directory of our WPF Custom Control Library project, as this is where the Framework
    will look for the default styles of our custom controls. As such, we must declare
    the UI design of our control in a `ControlTemplate` and set it to the `Template`
    property in a style that targets the type of our control in this file.
  prefs: []
  type: TYPE_NORMAL
- en: The style must be applied to all instances of our control and so the style is
    defined with the `TargetType` set, but without the `x:Key` directive. If you remember,
    this will ensure that it is implicitly applied to all instances of our control
    that don't have an alternative template explicitly applied.
  prefs: []
  type: TYPE_NORMAL
- en: A further difference is that we cannot directly reference any of the controls
    that are defined within the style in the `Generic.xaml` file. If you recall, when
    we provided a new template for the built-in controls, we were under no obligation
    to provide the same controls that were originally used. Therefore, if we tried
    to access a control from our original template that had been replaced, it would
    cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we generally need to access them by overriding the `FrameworkElement.OnApplyTemplate`
    method, which is raised once a template has been applied to an instance of our
    control. In this method, we should expect that our required control(s) will be
    missing and ensure that no errors occur if that is the case.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a simple example of a custom control that creates a meter that
    can be used to monitor CPU activity, RAM usage, audio loudness, or any other regularly
    changing value. We'll first need to create a new project of type WPF Custom Control
    Library and rename the `CustomControl1.cs` class that Visual Studio adds for us
    to `Meter.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we can only add a custom control to a project of this type and that
    when the project is added, Visual Studio will also add our `Themes` folder and
    `Generic.xaml` file, with a style for our control already declared inside it.
    Let''s see the code in the `Meter.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This is a relatively small class, with only two Dependency Properties and their
    associated CLR property wrappers and callback handlers. Of particular note is
    the class's static constructor and the use of the `DefaultStyleKeyProperty.OverrideMetadata`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: This is also added by Visual Studio when adding the class and is required to
    override the type-specific metadata of the `DefaultStyleKey` Dependency Property
    when we derive a custom class from the `FrameworkElement` class.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, this key is used by the Framework to find the default theme style
    for our control and so, by passing the type of our class into the `OverrideMetadata`
    method, we are telling the Framework to look for a default style for this type
    in our `Themes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, the theme styles are the last place that the Framework will
    look for the style of a specific type and declaring styles just about anywhere
    else in the application will override the default styles defined here.
  prefs: []
  type: TYPE_NORMAL
- en: The first Dependency Property is the main `Value` property of the control and
    this is used to determine the size of the visible meter bar. This property defines
    a default value of `0.0` and attaches the `CoerceValue` and `OnValueChanged` callback
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CoerceValue` handling method, we ensure that the output value always
    remains between `0.0` and `1.0`, as that is the scale that we will be using. In
    the `OnValueChanged` handler, we update the value of the other Dependency Property,
    `ClipRect`, dependent upon the input value.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first cast the `dependencyObject` input parameter to our `Meter`
    type and then pass that instance to the `SetClipRect` method. In this method,
    we calculate the relative size of the meter bar and define the `Rect` element
    for the `ClipRect` Dependency Property accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the CLR property wrapper for the `Value` Dependency Property and
    then the declaration of the `ClipRect` Dependency Property. Note that we declare
    it using a `DependencyPropertyKey` element, thus making it a read-only property,
    because it is only for internal use and has no value in being exposed publicly.
    The actual `ClipRect` Dependency Property comes from this key element.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we see the CLR property wrapper for the `ClipRect` Dependency Property
    and then we come to the aforementioned `OnApplyTemplate` method. In our case,
    the purpose of overriding this method is because often, data bound values will
    be set before the control's template has been applied and so we would not be able
    to correctly set the size of the meter bar from those values.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when the template has been applied and the control has been arranged
    and sized, we call the `SetClipRect` method in order to set the `Rect` element
    for the `ClipRect` Dependency Property to the appropriate value. Before this point
    in time, the `Height`Â and `Weight` properties of the `meter` instance will be
    `double.NaN` (where *NaN* is short for *Not a Number*) and cannot be used to size
    the `Rect` element correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When this method is called, we can rest assured that the `Height`Â and `Weight`
    properties of the `meter` instance will have valid values. Note that had we needed
    to access any elements from our template, we could have called the `FrameworkTemplate.FindName`
    method from this method, on the `ControlTemplate` object that is specified by
    our control's `Template` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had named a `Rectangle` element in our XAML `PART_Rectangle`, we could
    access it from the `OnApplyTemplate` method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we always need to check for `null`, because theÂ applied template
    may be a custom template that does not contain the `Rectangle` element at all.
    Note also that when we require the existence of a particular element in the template,
    we can decorate our custom control class declaration with a `TemplatePartAttribute`,
    that specifies the details of the required control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This will not enforce anything and will not raise any compilation errors if
    the named part is not included in a custom template, but it will be used in documentation
    and by various XAML tools. It helps users of our custom controls to find out which
    elements are required when they provide custom templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the inner workings of this control, let''s take a look
    at the XAML of the default style of our control in the `Generic.xaml` file to
    see how the `ClipRect` property is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: When each custom control class is created in a WPF Custom Control Library project,
    Visual Studio adds an almost empty default style that sets a basic `ControlTemplate`
    and targets the type of the class into the `Generic.xaml` file. We just need to
    define our custom XAML within this template.
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring the `ScaleColors` gradient brush resource within the template.
    Note that the default value for the `Offset` property of a `GradientStop` element
    is `0` and so we can omit the setting of this property if that is the value that
    we want it set to. Therefore, when we see a declared `GradientStop`, like the
    one with the `Color` property set to `LightGreen`, we know its `Offset` property
    is set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Our meter control is basically made up of a `Border` element that surrounds
    a `Rectangle` element. We useÂ `TemplateBinding`Â elements to data bind the `Background`,
    `BorderBrush`, and `BorderThickness` properties of the `Border` element and set
    its `SnapsToDevicePixels` property to `True`Â to avoid aliasing.
  prefs: []
  type: TYPE_NORMAL
- en: This enables users of the control to specify the border and background colors
    of the internal `Border` element of the meter control from outside the control.
    We could just as easily have exposed an additional brush property to replace the
    `ScaleColors` resource and enable users to define their own meter scale brush.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we couldn't use a `TemplateBinding` to data bind the `Value` property
    in the `ToolTip` element. This is not because we don't have access to it through
    the template, but because we need to use the `Binding.StringFormat` property and
    the `P` format specifier to transform our `double` property value to a percentage
    value.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, a `TemplateBinding` is a lightweight binding and does not offer
    this functionality. While it is beneficial to use it when we can, this example
    highlights the fact that we cannot use it in every circumstance.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we come to the all-important `Rectangle` element that is responsible
    for displaying the actual meter bar of our control. The `ScaleColors` brush resource
    is used here to paint the background of the rectangle. We set the `SnapsToDevicePixels`
    property to `true` on this element to ensure that the level that it displays is
    accurate and well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: The magic in this control is formed by the use of the `UIElement.Clip` property.
    Essentially, this enables us to provide any type of `Geometry` element to alter
    the shape and size of the visible portion of a UI element. The geometry shape
    that we assign here will specify the visible portion of the control.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we declare a `RectangleGeometry` class, whose size and location
    are specified by its `Rect` property. We therefore data bind our `ClipRect` Dependency
    Property to this `Rect` property, so that the sizes calculated from the incoming
    data values are represented by this `RectangleGeometry` instance, and therefore
    the visible part of the `Rectangle` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we do this so that the gradient that is painted on the meter bar remains
    constant and does not change with the height of the bar as its value changes.
    If we had simply painted the background of the rectangle with the brush resource
    and adjusted its height, the background gradient would move with the size of the
    meter bar and spoil the effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the whole rectangle is always painted with the gradient brush and
    we simply use its `Clip` property to just display the appropriate part of it.
    In order to use it in one of our Views, we''d first need to specify the `CustomControls`
    XAML namespace prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then declare a number of them, data bind some appropriate properties
    to their `Value` property, and set styles for them, just like any other control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Given some valid properties to data bind to, the preceding example would produce
    an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67f18285-8cda-41db-a3a0-14d808ed645f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've investigated the rich inheritance hierarchy of the built-in
    WPF controls, determining which abilities come from which base classes, and have
    seen how each control is laid out by their containing panels. We've examined the
    differences between the different panels and understand that some work better
    in certain conditions than others.
  prefs: []
  type: TYPE_NORMAL
- en: We've also uncovered the mysteries of the `ContentControl` and `ItemsControl`
    elements and now have a good understanding of `ContentPresenter` and `ItemsPresenter`
    objects. We moved on to discover a wide variety of ways for us to customize the
    built-in controls. Finally, we considered how best to make our own controls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will further investigate the built-in controls, paying
    particular attention to the polymorphic ability of derived classes to override
    base class methods. We will introduce a number of examples that each highlight
    certain problems, and demonstrate how to overcome them each in turn by extending
    the built-in controls and overriding particular base class methods.
  prefs: []
  type: TYPE_NORMAL
