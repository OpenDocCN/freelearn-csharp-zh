- en: Chapter 3. Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。控制器
- en: As discussed in the first chapter, all web applications receive requests from
    the server and produce a response, that is delivered back to the end user. A Controller
    does the job of receiving the request and producing the output based on the input
    data in ASP.NET MVC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如第一章所述，所有Web应用程序都从服务器接收请求并生成响应，该响应被发送回最终用户。在ASP.NET MVC中，控制器负责接收请求并根据输入数据生成输出。
- en: 'In this chapter, you''ll be learning about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Role of the Controller in ASP.NET MVC applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器在ASP.NET MVC应用程序中的作用
- en: Routing introduction and concepts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由简介和概念
- en: Creating your first ASP.NET 5 application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个ASP.NET 5应用程序
- en: Installation of the ASP.NET Core `NuGet` packages in your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中安装ASP.NET Core `NuGet`包
- en: Creation of your first Controller and `action` method, which returns a simple
    *Hello World*
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个控制器和`action`方法，该方法返回一个简单的*Hello World*
- en: Adding a View and making the changes that allow your Controller to use that
    View
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加视图并做出允许控制器使用该视图的更改
- en: Adding a Model and passing that Model data to your View
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加模型并将模型数据传递给视图
- en: Role of the Controller in ASP.NET MVC applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器在ASP.NET MVC应用程序中的作用
- en: 'At the high level, the Controller orchestrates between the Model and the View,
    and sends the output back to the user. This is also the place where authentication
    is usually done through action filters. Action filters will be discussed in detail
    in the *Filters* section of this chapter. The following figure illustrates the
    high-level flow of a request (with the steps) in ASP.Net MVC and shows us how
    the Controller fits into the big picture:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，控制器在模型和视图之间进行协调，并将输出发送回用户。这也是通常通过操作过滤器进行身份验证的地方。操作过滤器将在本章的*过滤器*部分详细讨论。以下图显示了ASP.Net
    MVC中请求（包括步骤）的高级流程，并展示了控制器如何融入整个画面：
- en: '![Role of the Controller in ASP.NET MVC applications](img/Image00021.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![控制器在ASP.NET MVC应用程序中的作用](img/Image00021.jpg)'
- en: 'The following is the sequence of events that will happen at high level when
    the user is accessing the ASP.NET Core application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问ASP.NET Core应用程序时，以下是在高层次上发生的事件序列：
- en: The user types the URL in the browser.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户在浏览器中输入URL。
- en: Based on the pattern of the URL, the routing engine selects the appropriate
    Controller.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据URL模式，路由引擎选择适当的控制器。
- en: The Controller talks to the Model to get any relevant data through its action
    methods. Action methods are methods within a `controller` class.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器通过其操作方法与模型通信，以获取任何相关数据。操作方法是在`controller`类中的方法。
- en: The Controller then passes the data to the View to present it in a viewable
    format, typically as HTML elements.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器随后将数据传递给视图，以便以可查看的格式呈现，通常为HTML元素。
- en: The View is finally delivered to the user, which he would be viewing in his
    browser.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图最终交付给用户，用户将在其浏览器中查看。
- en: Before discussing the controller, let us discuss the fundamentals of routing
    concepts, as the routing engine only chooses the appropriate `controller` and
    `action` method at runtime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论控制器之前，让我们讨论路由概念的基本原理，因为路由引擎仅在运行时选择适当的`controller`和`action`方法。
- en: Introduction to routing
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由简介
- en: The routing engine is responsible for getting the incoming request and routing
    that request to the appropriate Controller based on the URL pattern. We can configure
    the routing engine so that it can choose the appropriate controller based on the
    relevant information.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 路由引擎负责获取传入的请求，并根据URL模式将其路由到适当的控制器。我们可以配置路由引擎，使其能够根据相关信息选择适当的控制器。
- en: By convention, ASP.NET MVC follows this pattern:  **Controller/Action/Id** .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，ASP.NET MVC遵循以下模式：**控制器/操作/标识符**。
- en: If the user types the URL `http://yourwebsite.com/Hello/Greeting/1` , the routing
    engine selects the `Hello controller` class and `Greeting action` method within
    the `HelloController` , and passes the `Id` value as `1` . You can give default
    values to some of the parameters and make some of the parameters optional.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入URL `http://yourwebsite.com/Hello/Greeting/1`，路由引擎将选择`Hello控制器`类中的`Greeting操作`方法，并将`Id`值作为`1`传递。您可以给一些参数设置默认值，并使一些参数为可选。
- en: 'The following is the sample configuration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例配置：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding configuration, we are giving three instructions to the routing
    engine:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们向路由引擎提供了三条指令：
- en: Use the routing pattern `controller/action/id` .
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用路由模式`controller/action/id`。
- en: Use the default values `Hello` and `Greeting` for the `controller` and `action`
    respectively, if the values for `controller` or `action` are not supplied in the
    URL.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在URL中没有提供`controller`或`action`的值，则分别使用默认值`Hello`和`Greeting`。
- en: Make the `Id` parameter optional so that the URL does not need to have this
    information. If the URL contains this `Id` information, it will use it. Otherwise,
    the `Id` information will not be passed to the `action` method.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Id`参数设置为可选，这样URL就不需要包含此信息。如果URL包含此`Id`信息，则将使用它。否则，`Id`信息将不会传递给`action`方法。
- en: 'Let us discuss how the routing engine selects the `controller` classes, `action`
    methods, and `Id` values for different URLs:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论路由引擎如何为不同的URL选择`controller`类、`action`方法和`Id`值：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Reasoning: The `Hello` controller is passed as the default value as per the
    routing configuration, as no value is passed as the Controller in the URL.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 理由：根据路由配置，将`Hello`控制器作为默认值传递，因为在URL中没有传递`Controller`的值。
- en: 'The following `action` method will be picked up by the routing handler when
    the preceding URL is passed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递前面的URL时，以下`action`方法将被路由处理程序选中：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Reasoning: The `Hello` controller will be chosen as the URL contains `Hello`
    as the first parameter, and the `Greeting2` action method will be chosen as the
    URL contains `Greeting2` as the second parameter. Please note that the default
    value mentioned in the configuration would be picked only when no value is present
    in the URL. As the `id` parameter is optional and the URL does not contain the
    value for `id` , no value is passed to the `id` parameter.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理由：由于URL中第一个参数包含`Hello`，因此将选择`Hello`控制器。并且由于URL中第二个参数包含`Greeting2`，因此将选择`Greeting2`操作方法。请注意，只有在URL中没有值的情况下，才会选择配置中提到的默认值。由于`id`参数是可选的，并且URL中没有提供`id`的值，因此不会将任何值传递给`id`参数。
- en: 'The following action method `Greeting2` will be picked up by the routing handler
    when the preceding URL is passed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递前面的URL时，以下操作方法`Greeting2`将被路由处理程序选中：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Reasoning: As `Hello2` is passed as the first parameter, the `Hello2` controller
    will be selected, and `Greeting2` is the action method selected since `Greeting2`
    is passed as the second parameter. As the `id` parameter is optional and no value
    is passed for the parameter `id` , no value will be passed for the `id` .'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理由：由于第一个参数传递了`Hello2`，因此将选择`Hello2`控制器，并且由于第二个参数传递了`Greeting2`，因此选择了`Greeting2`作为操作方法。由于`id`参数是可选的，并且没有为`id`参数传递值，因此不会为`id`传递任何值。
- en: 'The following `action` method will be picked up by the routing handler when
    the preceding URL is passed:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递前面的URL时，以下`action`方法将被路由处理程序选中：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Reasoning: `Hello3` is the controller selected as it is mentioned as the first
    parameter, `Greeting4` is the action method, and `1` is the value passed as the
    `id` .'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 理由：`Hello3`是作为第一个参数提到的控制器，`Greeting4`是操作方法，而`1`是作为`id`传递的值。
- en: 'The following `action` method will be picked up the routing handler when the
    preceding URL is passed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递前面的URL时，以下`action`方法将被路由处理程序选中：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will discuss routing in detail in a later chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续章节中详细讨论路由。
- en: Once the request reaches the controller, the controller will create a response
    by talking to the Model and may pass the data to View and the View will then be
    rendered to the end user.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求到达控制器，控制器将通过与模型通信来创建响应，并且可能将数据传递给视图，然后视图将被渲染给最终用户。
- en: Creating ASP.NET 5 application
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ASP.NET 5 应用程序
- en: 'It''s time to get our hands dirty. Let us create a simple ASP.NET 5 application.
    Fire up Visual Studio and follow these steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候动手实践了。让我们创建一个简单的ASP.NET 5应用程序。启动Visual Studio并按照以下步骤操作：
- en: Create a project by selecting **File** | **New Project** in Visual Studio. The
    first option is for creating an earlier version of the ASP.NET Web application.
    The second option is for creating the ASP.NET Core application using the .NET
    Core framework. The third option is for creating the ASP.NET Core application
    using the .NET framework. The difference between the second and third option is
    that the .NET framework supports all the functionalities of existing .NET frameworks
    whereas .NET Core supports only the core functionalities. The advantage of using
    the .NET core library is that it can be deployed on any platform.![Creating ASP.NET
    5 application](img/Image00022.jpg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Visual Studio中选择**文件** | **新建项目**来创建一个项目。第一个选项是创建ASP.NET Web应用程序的早期版本。第二个选项是使用.NET
    Core框架创建ASP.NET Core应用程序。第三个选项是使用.NET框架创建ASP.NET Core应用程序。第二个和第三个选项之间的区别在于，.NET框架支持所有现有.NET框架的功能，而.NET
    Core只支持核心功能。使用.NET Core库的优势在于它可以在任何平台上部署。![创建ASP.NET 5应用程序](img/Image00022.jpg)
- en: Select the **Empty** template from the list of ASP.NET 5 templates. The second
    option is for creating the Web API application (for building the HTTP-based services)
    and the third option is for creating a web application containing some basic functionalities
    which you can run just from out of the box without you ever needing to write anything.![Creating
    ASP.NET 5 application](img/Image00023.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ASP.NET 5模板列表中选择**Empty**模板。第二个选项是用于创建Web API应用程序（用于构建基于HTTP的服务），第三个选项是用于创建包含一些基本功能的Web应用程序，你可以直接运行它，无需编写任何代码。![创建ASP.NET
    5应用程序](img/Image00023.jpg)
- en: Once you click  **OK** in the window as shown in the preceding screenshot, (after
    selecting the Empty template option) a solution will be created as shown in the
    following screenshot:![Creating ASP.NET 5 application](img/Image00024.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你在如图所示的窗口中点击**OK**（在选择了Empty模板选项之后），就会创建一个解决方案，如图所示：![创建ASP.NET 5应用程序](img/Image00024.jpg)
- en: When you run the application (by pressing **F5** ) without any changes, you'll
    get the simple **Hello World!** text on your screen as shown in the following
    screenshot:![Creating ASP.NET 5 application](img/Image00025.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行应用程序（通过按**F5**键）而不做任何更改时，你的屏幕上会显示简单的**Hello World!**文本，如图所示：![创建ASP.NET
    5应用程序](img/Image00025.jpg)
- en: We have not done any coding in this newly created application. So, have you
    thought about how it displays the text **Hello World!** ?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新创建的应用程序中，我们还没有编写任何代码。那么，你有没有想过它是如何显示文本**Hello World!**的？
- en: The answer lies in the `Startup.cs` file, which contains a class by the name
    of `Startup` . This class contains the `Main` method, which acts as the entry
    point for the web application. If you have used any of the previous versions of
    ASP.NET MVC, or even ASP.NET Web Forms, this would not be the case.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于`Startup.cs`文件，该文件包含一个名为`Startup`的类。这个类包含`Main`方法，它是Web应用程序的入口点。如果你使用过任何之前的ASP.NET
    MVC版本，或者甚至ASP.NET Web Forms，情况就不会是这样了。
- en: 'ASP.NET 5 runtime calls the `ConfigureServices` and `Configure` methods. For
    example, if you want to configure any service, you can add it here. Any custom
    configuration for your application can be added to this `Configure` method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET 5运行时调用`ConfigureServices`和`Configure`方法。例如，如果你想配置任何服务，你可以在这里添加。任何针对应用程序的定制配置都可以添加到这个`Configure`方法中：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are only a couple of statements in the `Configure` method. The first statement
    tells the run-time to use the `IISPlatformHandler` for handling all the incoming
    HTTP requests. Let us leave aside `async` , `await` , and `context` for the moment
    in the second statement, which we will discuss later. In essence, the second statement
    tells the run-time to return `Hello World!` for all the incoming requests irrespective
    of the incoming URL.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Configure`方法中只有几条语句。第一条语句告诉运行时使用`IISPlatformHandler`来处理所有传入的HTTP请求。现在我们先暂时放下`async`、`await`和`context`，这些我们稍后再讨论。本质上，第二条语句告诉运行时对于所有传入的请求，无论传入的URL是什么，都返回`Hello
    World!`。'
- en: When you type the URL `http://localhost:50140/Hello`  in your browser, it will
    still return the same **Hello World!** .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中输入URL `http://localhost:50140/Hello` 时，它仍然会返回相同的**Hello World!**。
- en: This is the reason we got the **Hello World!** when we ran the application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们运行应用程序时，我们得到了**Hello World!**。
- en: As we have chosen the **Empty** template while creating the ASP.NET 5 application,
    no component will have been installed. Even MVC wouldn't be installed by default
    when you select the **Empty** template as we did.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在创建 ASP.NET 5 应用程序时选择了 **Empty** 模板，因此没有任何组件被安装。即使选择 **Empty** 模板（如我们所做的那样），默认情况下也不会安装
    MVC。
- en: 'You can confirm it by opening the `project.json` file, where you can see no
    ASP.NET MVC is mentioned in the list of dependencies:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开 `project.json` 文件来确认，您可以在依赖项列表中看到没有提到 ASP.NET MVC：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So first, let us install the ASP.Net Core package for our application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们为我们的应用程序安装 ASP.Net Core 包。
- en: Installing the ASP.NET Core NuGet package in your application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中安装 ASP.NET Core NuGet 包
- en: 'Follow these steps to install the `NuGet` package of ASP.NET MVC:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤安装 ASP.NET MVC 的 `NuGet` 包：
- en: Right click on the project, and select the **Manage NuGet Packages** option:![Installing
    the ASP.NET Core NuGet package in your application](img/Image00026.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目，并选择 **管理 NuGet 包** 选项：![在您的应用程序中安装 ASP.NET Core NuGet 包](img/Image00026.jpg)
- en: Select the **Include Prerelease** checkbox so that the **NuGet Package Manager**
    will list out all the prerelease packages. Search for `MVC` and you'll get the
    **Microsoft.AspNet.MVC** package, as shown in the following result, and click
    on the **Install** button on the right-hand side:![Installing the ASP.NET Core
    NuGet package in your application](img/Image00027.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **包含预发布** 复选框，以便 **NuGet 包管理器** 列出所有预发布包。搜索 `MVC`，您将得到 **Microsoft.AspNet.MVC**
    包，如以下结果所示，然后点击右侧的 **安装** 按钮：![在您的应用程序中安装 ASP.NET Core NuGet 包](img/Image00027.jpg)
- en: Review the changes:![Installing the ASP.NET Core NuGet package in your application](img/Image00028.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看更改：![在您的应用程序中安装 ASP.NET Core NuGet 包](img/Image00028.jpg)
- en: Once you click on **Review Changes** , the following dialog box will appear
    where you need to accept the license terms:![Installing the ASP.NET Core NuGet
    package in your application](img/Image00029.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您点击 **查看更改**，将出现以下对话框，您需要接受许可条款：![在您的应用程序中安装 ASP.NET Core NuGet 包](img/Image00029.jpg)
- en: The **NuGet Package Manager** will download and install the ASP.NET Core and
    will update the `project.json` file and the associated references.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**NuGet 包管理器**将下载并安装 ASP.NET Core，并将更新 `project.json` 文件和相关引用。'
- en: 'Now, your `project.json` file will have updated dependencies. The second line
    `Microsoft.AspNet.Mvc` is added:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的 `project.json` 文件将更新依赖项。第二行 `Microsoft.AspNet.Mvc` 已添加：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, you can also update the `project.json` with the `NuGet` package
    along with the version information. The **NuGet Package Manager** will automatically
    download and install them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过更新 `project.json` 文件来添加 `NuGet` 包及其版本信息。**NuGet 包管理器**将自动下载并安装它们。
- en: ASP.NET Core is installed in our application. Now, we need to tell our application
    to use ASP.NET MVC.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core 已安装在我们的应用程序中。现在，我们需要告诉我们的应用程序使用 ASP.NET MVC。
- en: 'This needs a couple of changes to the `Startup.cs` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对 `Startup.cs` 文件进行一些更改：
- en: 'Configure the application to add the MVC service. This can be done by adding
    the following line to the `ConfigureServices` method of the `Startup` class:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置应用程序以添加 MVC 服务。这可以通过向 `Startup` 类的 `ConfigureServices` 方法中添加以下行来完成：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Configure the routing so that our correct controllers will be picked for the
    incoming requests based on the URL entered. The following code snippet needs to
    be updated in the `Configure` method of the `Startup.cs` file:app.UseMvc(routes
    => {
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置路由，以便根据输入的 URL 选取正确的控制器来处理传入的请求。以下代码片段需要更新在 `Startup.cs` 文件的 `Configure` 方法中：app.UseMvc(routes
    => {
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding statement, we are configuring the routes for our application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的语句中，我们正在配置我们应用程序的路由。
- en: In this chapter and most of the chapters in this book, we will write codes manually
    or choose an **Empty** template instead of relying on scaffolding templates. For
    those who are new to the term  **scaffolding** , scaffolding is a feature that
    generates all the necessary boilerplate code for you for the selected item (for
    example, the Controller) instead of you needing to write everything. Though I
    agree that scaffolding templates are useful and save time in generating the boilerplate
    code, they hide many of the details that beginners have to understand. Once you
    write code manually, you'll know all the intricacies of how each of the components
    is contributing to the big picture. Once you are strong in the fundamentals, you
    can use scaffolding templates to save you time in writing the boilerplate code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及本书中的大多数章节中，我们将手动编写代码或选择 **空** 模板，而不是依赖脚手架模板。对于那些对术语 **脚手架** 感到陌生的人来说，脚手架是一个功能，它会为你生成所选项目（例如，控制器）所需的所有必要样板代码，而不是你需要编写一切。虽然我同意脚手架模板很有用并且可以节省生成样板代码的时间，但它们隐藏了许多初学者必须理解的具体细节。一旦你手动编写代码，你就会了解每个组件如何为整体画面做出贡献的所有复杂性。一旦你在基础知识上变得强大，你就可以使用脚手架模板来节省你在编写样板代码上的时间。
- en: Our first Controller
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个控制器
- en: 'Before creating the Controller, we need to remove the following `app.Run` statement
    as this will return `Hello World!` for all the incoming requests. As we want incoming
    requests to be handled by the controllers, we need to remove the following code
    from the `Configure` method of the `Startup` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建控制器之前，我们需要删除以下 `app.Run` 语句，因为这将为所有传入的请求返回 `Hello World!`。由于我们希望传入的请求由控制器处理，我们需要从
    `Startup` 类的 `Configure` 方法中删除以下代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have installed the ASP.NET Core in our application. So, we are geared up
    to creating our first ASP.NET Core controller. Create a folder with the name `Controllers`
    and add a new Controller by selecting from the context menu as shown in the following
    screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用程序中安装了 ASP.NET Core。因此，我们准备创建我们的第一个 ASP.NET Core 控制器。创建一个名为 `Controllers`
    的文件夹，并从上下文菜单中选择添加一个新的控制器，如下面的截图所示：
- en: '![Our first Controller](img/Image00030.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个控制器](img/Image00030.jpg)'
- en: 'Once you select **Add** | **New Item** , you will be shown the following list
    of options. We are going to add an MVC controller class to our project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择 **添加** | **新建项**，你将看到以下选项列表。我们将向项目中添加一个 MVC 控制器类：
- en: '![Our first Controller](img/Image00031.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个控制器](img/Image00031.jpg)'
- en: 'A class will be created with the following content:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个包含以下内容的类：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All controllers, both MVC and Web API controllers, inherit from the `Controller`
    base class. In earlier versions of ASP.NET MVC, MVC controllers would inherit
    from the `Controller` class and Web API controllers would inherit from the `APIController`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控制器，无论是 MVC 还是 Web API 控制器，都继承自 `Controller` 基类。在 ASP.NET MVC 的早期版本中，MVC 控制器会继承自
    `Controller` 类，而 Web API 控制器会继承自 `APIController` 类。
- en: In the preceding `HomeController` class, we have a single action method by `Index`
     that returns the corresponding View. When you run the application as it is, you'll
    get a **500 Internal Server Error** . The reason being is that no View has been
    created for the `Index` action of the `HomeController` and ASP.NET Core tries
    to search for that View. As the View is not available, it returns a  **500 Internal
    Server Error** .
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `HomeController` 类中，我们有一个名为 `Index` 的单个操作方法，它返回相应的视图。当你以当前状态运行应用程序时，你会得到一个
    **500 内部服务器错误**。原因是 `HomeController` 的 `Index` 操作没有创建视图，而 ASP.NET Core 尝试搜索该视图。由于视图不可用，它返回一个
    **500 内部服务器错误**。
- en: 'Instead of creating and returning that View, let us make a simple change to
    this action method. Let us return a string, `Hello World! I am learning MVC 6!`
    , and change the return type of `IActionResult` :'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不创建并返回该视图，而是对这个操作方法进行简单的修改。让我们返回一个字符串，`Hello World! 我正在学习 MVC 6!`，并更改 `IActionResult`
    的返回类型：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the application. You''ll see the **Hello World! I am learning MVC 6!**
    in your browser as shown in the following screenshot. Please make sure that you
    remove the `app.Run` statement in the `Configure` method as mentioned earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。你将在浏览器中看到 **Hello World! 我正在学习 MVC 6!**，如下面的截图所示。请确保你已按照前面提到的在 `Configure`
    方法中删除了 `app.Run` 语句：
- en: '![Our first Controller](img/Image00032.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个控制器](img/Image00032.jpg)'
- en: Voila! We have changed the ASP.NET Core application to render the custom content
    instead of the boring *Hello World* . What we have done may seem like a marginal
    improvement, but we have used controllers and action methods in our ASP.NET Core
    application, which has brought a lot of structure and flexibility to the web application
    development.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经将 ASP.NET Core 应用程序更改为渲染自定义内容而不是无聊的 *Hello World*。我们所做的可能看起来是一个微小的改进，但我们已经在我们的
    ASP.NET Core 应用程序中使用了控制器和动作方法，这为 Web 应用程序开发带来了很多结构和灵活性。
- en: '![Our first Controller](img/Image00033.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个控制器](img/Image00033.jpg)'
- en: 'The following is the sequence of steps that occur when we run the application:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们运行应用程序时发生的步骤序列：
- en: The application runs on the URL `http://localhost:50140` , where `50140` is
    the port number selected by IIS Express to run the application on my local system.
    This number may vary.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序在 URL `http://localhost:50140` 上运行，其中 `50140` 是 IIS Express 在我的本地系统上运行应用程序所选的端口号。这个数字可能不同。
- en: As we have not passed any parameter, default values for the `Controller` and
    `action` method will be selected. In our case, `HomeController` will be chosen
    as the `Controller` and `Index` will be chosen as the `action` method in the `HomeController`
    . Since `ID` is the optional value and it is not passed, this `ID` parameter is
    ignored.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有传递任何参数，`Controller` 和 `action` 方法的默认值将被选择。在我们的情况下，`HomeController` 将被选为
    `Controller`，`Index` 将被选为 `HomeController` 中的 `action` 方法。由于 `ID` 是可选值且未传递，此 `ID`
    参数将被忽略。
- en: After the `Controller` and `action` methods are selected by the routing engine,
    control is passed to the `action` method of the selected controller. In our case,
    it will be the `Index` action method of the `HomeController` .
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在路由引擎选择 `Controller` 和 `action` 方法之后，控制权传递给所选控制器的 `action` 方法。在我们的情况下，它将是 `HomeController`
    的 `Index` 动作方法。
- en: In the `Index` action method, we are returning a string, `Hello World! I am
    learning ASP.Net MVC 6!` . This text is returned from the controller, which would
    then return back to the user.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Index` 动作方法中，我们返回一个字符串，`Hello World! I am learning ASP.Net MVC 6!`。此文本从控制器返回，然后返回给用户。
- en: IActionResult
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`IActionResult`'
- en: If you noticed, the default return type in the `action` method of the controller
    was `IActionResult` and then we changed the return type to the string in order
    to return the text `Hello World...` .
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，控制器中的 `action` 方法的默认返回类型是 `IActionResult`，然后我们将返回类型更改为字符串以返回文本 `Hello
    World...`。
- en: The `IActionResult`  is the interface that we can use to return different types
    of `ActionResult` , ranging from a simple string to complex JSON data, so, we
    don't need to change the `return` type of the `action` method to return the string.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`IActionResult` 是一个接口，我们可以用它来返回不同类型的 `ActionResult`，从简单的字符串到复杂的 JSON 数据，因此，我们不需要更改
    `action` 方法的 `return` 类型来返回字符串。'
- en: 'In the earlier example, I have changed the `return` type to the string to make
    things simple. Now, let us make a simple change to return the string by keeping
    the return type (`IActionResult` ) as it is:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我将 `return` 类型更改为字符串以使事情简单。现在，让我们通过保持 `return` 类型（`IActionResult`）不变来返回字符串：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While returning the string, we are using the `virtual` method, called `Content`
     from the `Controller` class (the base controller from where `HomeController`
    is inherited from) in the preceding `action` method. The purpose of this `Content()`
    method is to convert the string to the type `IActionResult` .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回字符串时，我们使用 `virtual` 方法，即 `Controller` 类（`HomeController` 继承自的基控制器）中先前的 `action`
    方法中的 `Content` 方法。`Content()` 方法的目的是将字符串转换为 `IActionResult` 类型。
- en: Now, run the application. We should be getting the same result.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行应用程序。我们应该得到相同的结果。
- en: '`IActionResult` is capable of returning different data types:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`IActionResult` 能够返回不同的数据类型：'
- en: '`ContentResult` : Can return a text result.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentResult` : 可以返回文本结果。'
- en: '`EmptyResult` : Returns a `null` result.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmptyResult` : 返回一个 `null` 结果。'
- en: '`FileResult` : Returns a binary output to write to the response.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileResult` : 返回二进制输出以写入响应。'
- en: '`HttpStatusCodeResult` : Provides a way to return.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HttpStatusCodeResult` : 提供了一种返回方式。'
- en: '`JavaScriptResult` : Returns a script that can be executed from the client
    side.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JavaScriptResult` : 返回可以在客户端执行的脚本。'
- en: '`JSonResult` : When you return a serialized JSON object.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSonResult` : 当你返回一个序列化的 JSON 对象时。'
- en: '`RedirectResult` : Redirects to another `action` method.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedirectResult` : 重定向到另一个 `action` 方法。'
- en: '`RedirectToRouteResult` : Represents a result that performs a redirection by
    using a specified route values dictionary.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedirectToRouteResult`：表示通过使用指定的路由值字典执行重定向的结果。'
- en: Adding Views
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加视图
- en: We were returning a simple string from the controller. Although that explains
    the concept of how the `Controller` and `action` method works, it is not of much
    practical use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前端控制器返回了一个简单的字符串。虽然这解释了`Controller`和`action`方法的工作原理，但它并没有太多的实际用途。
- en: 'Let us create a new `action` method by the name, `Index2` :'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的名为`Index2`的`action`方法：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we have created the `action` method that returns a View. But we still have
    not added the View for the same. By convention, ASP.NET MVC would try to search
    for our View in the folder `Views\{ControllerName}\{ActionMethod.cshtml}` . With
    respect to the preceding example, it will try to search for `Views\Home\Index2.cshtml`
    . Please note that the name of the `controller` folder-is `Home` , not `HomeController`
    . Only the prefix is needed as per convention. As this folder structure and file
    are not available, you'll get a **500 Internal Server Error** when you try to
    access this action method through the URL `http://localhost:50140/Home/Index2`
    .
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了返回视图的`action`方法。但我们对相同的视图还没有添加。按照惯例，ASP.NET MVC会尝试在`Views\{ControllerName}\{ActionMethod.cshtml}`文件夹中搜索我们的视图。根据前面的示例，它将尝试搜索`Views\Home\Index2.cshtml`。请注意，`controller`文件夹的名称是`Home`，而不是`HomeController`。按照惯例，只需要前缀。由于这个文件夹结构和文件不存在，当你尝试通过URL
    `http://localhost:50140/Home/Index2` 访问这个`action`方法时，你会得到一个**500内部服务器错误**。
- en: 'So, let us create a folder structure. Right-click on the solution, select **Add**
    | **New Folder** from the context menu, create a folder called `Views` , and then
    create a subfolder by the name `Home` within the `Views` folder:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个文件夹结构。右键单击解决方案，从上下文菜单中选择**添加** | **新建文件夹**，创建一个名为`Views`的文件夹，然后在`Views`文件夹内创建一个名为`Home`的子文件夹：
- en: '![Adding Views](img/Image00034.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![添加视图](img/Image00034.jpg)'
- en: Right click on the `Home` folder, and select **Add** | **New Item** from the
    context menu. A dialog will appear as shown in the following screenshot. Give
    the name of the file as `Index2.cshtml` , as our `action` method name is `Index2`
    . `cshtml` is the razor view engine (this will be discussed in detail in the *ViewEngines*
    section of the *Views* chapter) extension used when you are using C#.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击`Home`文件夹，从上下文菜单中选择**添加** | **新建项**。会出现一个对话框，如下面的截图所示。将文件名命名为`Index2.cshtml`，因为我们的`action`方法名为`Index2`。`cshtml`是当你使用C#时使用的razor视图引擎的扩展名（这将在*视图*章节的*视图引擎*部分详细讨论）。
- en: '![Adding Views](img/Image00035.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![添加视图](img/Image00035.jpg)'
- en: 'A file by the name `Index2.cshtml` will be created when you click the **Add**
    button in the preceding screen with the following content:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在前面的屏幕上点击**添加**按钮时，将创建一个名为`Index2.cshtml`的文件，内容如下：
- en: '![Adding Views](img/Image00036.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![添加视图](img/Image00036.jpg)'
- en: '`@*` is the comment syntax in the razor view engine. You can write any C# code
    within the `@{}` block.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`@*`是razor视图引擎中的注释语法。你可以在`@{}`块内编写任何C#代码。'
- en: 'Let us add a simple HTML block after the generated code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在生成的代码后添加一个简单的HTML块：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, when you run the application, you will get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行应用程序时，你会得到以下输出：
- en: '![Adding Views](img/Image00037.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![添加视图](img/Image00037.jpg)'
- en: 'The following diagram explains the request flow and how we generate the response
    through the View:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图解说明了请求流程以及我们如何通过视图生成响应：
- en: '![Adding Views](img/Image00038.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![添加视图](img/Image00038.jpg)'
- en: 读累了记得休息一会哦~
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读累了记得休息一会哦~
- en: '**公众号：古德猫宁李**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**公众号：古德猫宁李**'
- en: 电子书搜索下载
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 书单分享
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书单分享
- en: 书友学习交流
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书友学习交流
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
- en: 电子书搜索下载
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书搜索下载
- en: 电子书打包资源分享
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子书打包资源分享
- en: 学习资源分享
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习资源分享
- en: Adding Models
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模型
- en: 'Models represent your business domain classes. Now, we are going to learn about
    how to use the Models in our controller. Create a `Models` folder and add a simple
    `Employee` class. This is a just a plain old C# class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 模型代表你的业务域类。现在，我们将学习如何在控制器中使用模型。创建一个`Models`文件夹，并添加一个简单的`Employee`类。这是一个普通的C#类：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a new `action` method, `Employee` , in our `HomeController` , and create
    an object of the `Employee` Model with some values, and pass the Model to the
    View. Our idea is to use the Model employee values in the View to present them
    to the user:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`HomeController`中创建一个新的`action`方法`Employee`，创建一个带有一些值的`Employee`模型对象，并将模型传递给视图。我们的想法是在视图中使用模型员工值来向用户展示：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we need to add the respective View for this `action` method. Add a new
    Razor view file in the `View\Home folder` .
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为这个 `action` 方法添加相应的视图。在 `View\Home` 文件夹中添加一个新的 Razor 视图文件。
- en: 'Add the following code snippet. Whatever comes after the `@` symbol is considered
    as Razor code. In the following code, we are trying to access the properties of
    the `Model` object that is passed to our view. In our case, `Model` represents
    the `employee` object that we have constructed in our `action` method. You can
    access the object from View using the Model keyword:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码片段。在 `@` 符号之后的所有内容都被认为是 Razor 代码。在以下代码中，我们正在尝试访问传递给我们的视图的 `Model` 对象的属性。在我们的例子中，`Model`
    代表我们在 `action` 方法中构建的 `employee` 对象。您可以使用 Model 关键字从视图中访问该对象：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you run the application and type the URL `http://localhost:50140/Home/Employee`
    , you''ll see the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序并输入 URL `http://localhost:50140/Home/Employee` 时，你会看到以下输出：
- en: '![Adding Models](img/Image00039.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![添加模型](img/Image00039.jpg)'
- en: Passing data from Controller to View
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从控制器到视图传递数据
- en: We have just discussed how to pass the data from the Controller to the View
    using the `Model` object. While calling the View, we are passing the model data
    as a parameter. But there are times when you want to pass some temporary data
    to the View from the Controller. This temporary data may not deserve a `model`
    class. In such scenarios, we can use either `ViewBag` or `ViewData` .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论了如何使用 `Model` 对象从控制器传递数据到视图。在调用视图时，我们将模型数据作为参数传递。但有时你希望从控制器将一些临时数据传递到视图。这些临时数据可能不值得创建一个
    `model` 类。在这种情况下，我们可以使用 `ViewBag` 或 `ViewData`。
- en: '`ViewData` is the dictionary and `ViewBag` is the dynamic representation of
    the same value.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewData` 是字典，而 `ViewBag` 是相同值的动态表示。'
- en: 'Let us add the company name and company location property using `ViewBag` and
    `ViewData` as shown in the following code snippet:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下代码片段添加公司名称和公司位置属性，使用 `ViewBag` 和 `ViewData` 如下所示：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Make the respective changes in the View file as well so that we can display
    the `Company` name and `Company location` values:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 也要在视图文件中进行相应的更改，以便我们可以显示 `Company` 名称和 `Company location` 值：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the application after making the preceding changes:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行前面的更改后运行应用程序：
- en: '![Passing data from Controller to View](img/Image00040.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![从控制器到视图传递数据](img/Image00040.jpg)'
- en: '`ViewBag` and `ViewData` represent the same collection, even though the entries
    in the collection are accessed through different methods. `ViewBag` values are
    dynamic values and are executed at run-time, whereas the `ViewData` is accessed
    through the dictionary.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewBag` 和 `ViewData` 代表相同的集合，尽管集合中的条目是通过不同的方法访问的。`ViewBag` 值是动态值，在运行时执行，而
    `ViewData` 是通过字典访问的。'
- en: 'To test this, let us make a simple change to our `view` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，让我们对我们的 `view` 文件进行简单的更改：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Even though I have stored the `Company` value using `ViewBag` in the `Controller`
    , I am accessing the same using `ViewData` . The same is the case for the `Company
    Location` value, we have stored the value using `ViewData` in the Controller,
    but we are accessing the value using `ViewBag` .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在 `Controller` 中使用 `ViewBag` 存储了 `Company` 值，但我仍然使用 `ViewData` 访问相同的值。对于
    `Company Location` 值也是如此，我们在 `Controller` 中使用 `ViewData` 存储了值，但我们使用 `ViewBag`
    访问该值。
- en: When you run the application after making the preceding changes, you'll see
    the same result as you have seen before.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行前面的更改后运行应用程序，你会看到之前看到的结果。
- en: Filters
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器
- en: Filters in ASP.NET MVC enable you to run code before or after a particular stage
    in the execution pipeline. They can be configured globally per-controller or per-action.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET MVC 中的过滤器允许你在执行管道的特定阶段之前或之后运行代码。它们可以按控制器或按操作全局配置。
- en: There are different kinds of filters, and each filter is executed at a different
    stage in the pipeline. For example, action filters are executed when the `action`
    method is executed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的过滤器，每个过滤器在管道的不同阶段执行。例如，当 `action` 方法执行时，会执行动作过滤器。
- en: Let us use a simple example to see how an action filter (a type of filter) works.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来看看动作过滤器（一种过滤器）是如何工作的。
- en: I have created a simple controller, `DateController` , where I am just displaying
    the time. In this `action` method, I am using a predefined action filter by the
    name of `ResponseCache` , that caches the response for the duration specified
    in seconds. In the following code snippet, we have mentioned the duration as 600
    seconds. So, the response will be cached for 10 minutes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了一个简单的控制器，名为 `DateController`，其中我只是显示时间。在这个 `action` 方法中，我使用了一个名为 `ResponseCache`
    的预定义动作过滤器，该过滤器将响应缓存为指定的秒数。在下面的代码片段中，我们提到了持续时间是 600 秒。因此，响应将被缓存 10 分钟。
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When I run it for the first time, it displays the time as expected. But when
    you refresh the browser (which indirectly fires the request again), the time is
    not updated as the response is cached already by the application. In the following
    screenshot, even though the time is 7:43, the application is still showing as
    7:40:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次运行它时，它显示的时间与预期相符。但是当你刷新浏览器（这间接地再次触发了请求），时间没有更新，因为响应已经被应用程序缓存。在下面的屏幕截图中，尽管时间是
    7:43，但应用程序仍然显示为 7:40：
- en: '![Filters](img/Image00041.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![过滤器](img/Image00041.jpg)'
- en: The following are the predefined types of filters available in ASP.NET Core.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在 ASP.NET Core 中可用的预定义过滤器类型。
- en: Authorization filters
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权过滤器
- en: These are used for authorization and are mainly intended to determine whether
    the current user is authorized for the request being made.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于授权，主要目的是确定当前用户是否有权进行所提出的请求。
- en: Resource filters
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源过滤器
- en: These are the filters that handle the request after authorization and are the
    last one to handle the request before it leaves the filter pipeline. They are
    used to implement caching or by passing the filter pipeline.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在授权之后处理请求的过滤器，并且在请求离开过滤器管道之前是最后一个处理请求的。它们用于实现缓存或通过传递过滤器管道。
- en: Action filters
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作过滤器
- en: These wrap calls to individual `action` method calls and can manipulate the
    arguments passed in the action as well as the action result returned from it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装对单个 `action` 方法调用的调用，并且可以操作传递给 `action` 的参数以及从它返回的动作结果。
- en: Exception filters
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常过滤器
- en: These are used to manage the unhandled exceptions in ASP.NET MVC.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于管理 ASP.NET MVC 中的未处理异常。
- en: Result filters
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果过滤器
- en: This wrap the individual action results and they only run when the `action`
    method is executed successfully.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包装单个动作结果，并且只有在 `action` 方法成功执行时才会运行。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built our first ASP.NET 5 application from scratch
    and we have installed ASP.NET Core in our ASP.NET 5 application. We have learned
    how the controller fits into the overall ASP.NET MVC application and learned how
    to build your first controller with the `action` methods. We also learned about
    how to use Model and View in our Controller. We have also discussed different
    ways to pass the data from the Controller to the View using `ViewBag` and `ViewData`
    . We have also learned about filters in ASP.NET MVC and how to make use of predefined
    filters in ASP.NET Core.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始构建了我们的第一个 ASP.NET 5 应用程序，并在我们的 ASP.NET 5 应用程序中安装了 ASP.NET Core。我们学习了控制器如何融入整体的
    ASP.NET MVC 应用程序，并学习了如何使用 `action` 方法构建您的第一个控制器。我们还学习了如何在控制器中使用模型和视图。我们还讨论了使用
    `ViewBag` 和 `ViewData` 将数据从控制器传递到视图的不同方法。我们还学习了 ASP.NET MVC 中的过滤器以及如何在 ASP.NET
    Core 中使用预定义的过滤器。
