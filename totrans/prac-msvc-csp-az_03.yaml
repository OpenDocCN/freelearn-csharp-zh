- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Data to Relational and NoSQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating the first implementation of the service using minimal APIs, we
    build on that to read and write to databases. In this chapter, we will replace
    the in-memory repository built in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031)
    using **Entity Framework Core** (**EF Core**) to access a relational database
    – Microsoft SQL Server – and an Azure Cosmos DB NoSQL database using EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll create two libraries to access these databases, create EF Core context
    classes, specify the mappings from model classes, and configure the minimal APIs
    service to use one or the other database. After adding these changes, the games
    will be persisted and you can continue game runs when the service is restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll be exploring these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the models for the data to be stored in the databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and configuring an EF Core context to access Microsoft SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating migrations to update the database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and configuring an EF Core context to access Azure Cosmos DB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ch03` source code folder contains the code samples for this chapter. The
    most important projects for this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.Data.SqlServer` – This is the new library to access Microsoft
    SQL Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Data.Cosmos` – This is the new library to access Azure Cosmos
    DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesAPIs` – This is the web API project created in the previous
    chapter. In this chapter, the **dependency injection** (**DI**) container is updated
    to use .NET Aspire components to use SQL Server and Azure Cosmos DB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.Models` – This project just has a minimal change in this
    chapter, adding a property to the `Game` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – This project is updated with SQL Server and Azure Cosmos
    DB resources and forwarding configuration values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – This project is unchanged from the previous
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `analyzer` library from the previous chapter is not included in this chapter.
    Here, we’ll just use the `CNinnovation.Codebreaker.Analyzers` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: If you worked through the previous chapter to create the models and implemented
    the minimal APIs project, you can continue from there. You can also copy the files
    from the `ch02` folder if you didn’t complete the previous work and start from
    there. `ch03` contains all the updates from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than a development environment, you need Microsoft SQL Server and Azure
    Cosmos DB. You don’t need an Azure subscription at this point. SQL Server is installed
    together with Visual Studio. You can also download the SQL Server 2022 Developer
    Edition instead. This is easy via `winget` (but you can also download and install
    Windows installer packages instead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you use a Mac, you can use a Docker image for SQL Server. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    you can read more details on Docker and running SQL Server within a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: For easy use of SQL Server and Azure Cosmos DB, Docker images are used in this
    chapter. You can also use SQL Server, which is installed together with Visual
    Studio, and the Azure Cosmos DB emulator instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Azure Cosmos DB, an emulator to run it locally is available. You can
    install this NoSQL database emulator with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Cosmos emulator is only available on Windows. With Linux environments
    (and also on Windows and the Mac), you can use a Docker image to run the emulator.
    See [https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator](https://learn.microsoft.com/en-us/azure/cosmos-db/how-to-develop-emulator)
    for information on running the emulator. Read [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110)
    for more information on Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read and write your SQL Server data, within Visual Studio you can use SQL
    Server Object Explorer. Outside of Visual Studio, and with more functionality,
    use **SQL Server Management Studio** (**SSMS**), which can be installed with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The projects of this chapter and how they relate to each other are shown in
    *Figure 3**.1* with a C4 component diagram. The `gamesAPI` and `models` components
    have been created in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031). In this
    chapter, two projects for accessing SQL Server and Azure Cosmos DB databases will
    be added (`sqlDatabase` and `cosmosDatabase`). Depending on the configuration,
    the games API will use either the in-memory repository (created in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031))
    or one of the other `IGamesRepository` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Projects](img/B21217_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Projects
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start exploring the project containing the models while making a small
    change to the models.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the models for database mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating services, different models can be used for the database, the functionality,
    and the APIs. The database layer might have different requirements than the other
    layers. When creating a monolithic application, this usually is the case, but
    it also means that while maintaining the application and adding a field, all the
    different layers need to be touched and updated. When creating microservices with
    smaller scopes, there’s a good chance to use the same model with the database,
    the functionality of the application, and the APIs. This not only reduces maintenance
    costs but also improves performance in that not every layer creates new instances
    and copies the values around.
  prefs: []
  type: TYPE_NORMAL
- en: With the sample application, the `Game` and `Move` types with their generic
    counterparts created in the previous chapter are not that simple, but it’s possible
    to use them directly with EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the models and what must be mapped for the database, starting
    with the `Game` type:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Game.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Game` class contains properties of type `Guid`, `string`, `DateTime`, `TimeSpan`,
    `int`, and `bool`. All these properties can easily be mapped to database columns.
    Just the size of the string needs to be configured. With SQL Server, the convention
    to map a string is `nvarchar(max)`. This can be reduced in size. What’s more interesting
    is the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The class doesn’t define a parameterless constructor. While some tools require
    a parameterless constructor, both JSON serialization as well as EF Core nowadays
    don’t need one. EF Core supports constructors with parameters as long as the constructors
    map to simple properties – which is the case with the `Game` class. EF Core mapping
    supports properties with `get` and `set` accessors. If there’s just a `get` accessor
    available, the mapping will fail. A way around this is to use `private` fields.
    EF Core supports explicit mapping to fields. Another option is to use private
    `set` accessors – which are used with the `Game` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other interesting members are available with the `Game` class: the `FieldValues`
    property is of type `IDictionary<string, IEnumerable<string>>`. The field values
    define the possible options the user can choose from. All games of one game type
    usually have the same field values, but this can change over time. We shouldn’t
    expect these values to always stay the same. The application might change the
    colors or shapes to choose from over time. So, we can’t just ignore the property
    to be stored – this should be stored with the game. As for this type, a default
    mapping is not available, so we need to add a conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Codes` property is of type string array. EF Core 8.0 supports built-in
    mapping of collections of primitive types; that is, a list of arrays, integers,
    strings, and more. With the built-in functionality, the collection is stored in
    the JSON format in a string table. This fits the purpose. The `Codes` property
    contains a list of a solution. With the color-based game types, this is a list
    of up to five colors; with the shape game type, one string of the collection consists
    of a shape and a color with a delimiter. Using a version older than EF Core 8,
    a custom conversion would be required. With EF Core 8, this will map with the
    default functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The `Moves` property is typically a relation with relational databases. Using
    SQL Server, we will use the `Moves` table to store every move. It would be possible
    to store moves with a JSON column, but we’ll use a separate table and query for
    moves if needed. Using a NoSQL database, it’s a natural way to store moves within
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look into the `Move` type:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Move.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the `Move` class, `GuessPegs` (the guess of the player for the move) and
    `KeyPegs` (the result from the analyzer) can be serialized similarly to the `Codes`
    property from the `Game` type. What’s more interesting here is what’s *not* here.
    That is, the absence of a foreign key property like `GameId` or a direct `Game`
    property to establish a relationship between the `Move` and `Game` types. While
    using the `Move` type so far, this relationship was not required. With EF Core,
    it’s also not required to add this relationship to the model. EF Core supports
    a feature named **shadow properties**. These properties are not part of the model
    but are stored within the database and can be accessed while using the EF Core
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize what needs to be done to map the `Game` and `Move` types with
    EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: For simple string properties, the size of the database string needs to be defined
    with SQL Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FieldValues` property of type `IDictionary<string, IEnumerable<string>>`
    needs a **value converter**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Moves` property maps a collection to the `Move` type. With a relational
    database, `Move` objects should be stored in a separate `Moves` table. Because
    the `Move` type doesn’t define a primary key, **shadow properties** are needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Azure Cosmos DB, the moves should be stored in the game JSON document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: EF Core supports mapping via conventions, annotations, and the fluent API. Conventions
    are provider-specific. For example, a .NET string mapping to `nvarchar(max)` is
    a convention. Using nullability, a non-nullable property maps to a required database
    column, while a nullable property is not required. Conventions are overridden
    using annotations. Annotations are attributes such as `[StringLength(20)]`,which
    not only can be used to validate user input but also to specify the column to
    be `nvarchar(20)`. Using the fluent API, annotations can be overridden. The fluent
    API offers most options and overrides all the other settings. We’ll use the fluent
    API in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define a mapping to work with these models, both with a relational database
    and NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core with SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with a relational database to store games and moves in multiple
    tables. We need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class library project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the EF Core context
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Customize the mapping of simple properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create value conversions to map complex properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define relations between games and moves
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create shadow properties for the `Move` type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the repository contract
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the application model with SQL Server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the DI container with the minimal APIs project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a data class library using SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the class library project, you can use the .NET CLI as shown or use
    the class library project template from Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To access SQL Server with EF Core, add the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. This project also has a dependency on the `Codebreaker.GameAPIs.Models`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EF Core context for SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mapping to the database is specified with an EF Core context implemented
    with the `GamesSqlServerContext` class, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: An EF Core context class needs to derive from the `DbContext` base class. Using
    the context from a DI container, the connection string can be configured outside
    of the context. This requires using the constructor with the `DbContextOption`
    parameter, which needs to be forwarded to the base class.
  prefs: []
  type: TYPE_NORMAL
- en: The `GamesSqlServerContext` class implements the `IGamesRepository` interface,
    which we defined in [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031), to be used
    by the `GamesService` class. In [*Chapter 2*](B21217_02.xhtml#_idTextAnchor031),
    we implemented this interface with the `GamesMemoryRepository` in-memory repository
    class. The EF Core context class supports the repository pattern by implementing
    the same interface. This way, we can easily switch the in-memory repository by
    using `GamesSqlServerContext` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The overridden `OnModelCreating` method allows customization to map the model
    types to the database. With SQL Server, the default schema name is `dbo`. This
    is changed by invoking `modelBuilder.HasDefaultSchema`.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the complexity of the `OnModelCreating` method, `GameConfiguration`
    and `MoveConfiguration` classes are created to customize the mapping with the
    `Game` and `Move` types.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing that’s required with the context class is for properties of type
    `DbSet<TEntity>` to allow using properties to access mapped database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Creating the `codebreaker` solution had several iterations. One time, an abstract
    base class and generically derived class were used to support all the different
    game types. Using EF Core, it’s also possible to map inheritance, and this is
    also possible with the JSON serialization and the OpenAPI definition. EF Core
    can map an inheritance tree to a single table (**table-per-hierarchy** or **TpH**),
    to a table for every type (**table-per-type** or **TpT**), and a table for every
    concrete type (**table-per-concrete-type** or **TpC**).
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a complex class hierarchy for the model types to plan for
    future features that might be never needed, it often helps to have model types
    as simple as possible, depending on what’s required with the current version.
    A complex model design adds complexity in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: The `Game` class as it is defined now fulfills requirements for a group of different
    `Game` types as data holders. Functionality is abstracted away and done from the
    `analyzers` library, which just uses a contract to access the game.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices are used in a smaller scope, the **KISS** principle (**Keep
    It Simple, Stupid**) can help not only reduce work that needs to be done but also
    increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the mapping of simple properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The mapping of the `Game` class is specified with the `GameConfiguration` class.
    A configuration class that is applied using `ApplyConfiguration` with the context
    configuration needs to implement the `IEntityTypeConfiguration` generic interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation of this class, the key of the table is specified to
    map to the `Id` property. This would not be required, as convention defines that
    a property with the name `Id` or an ID prefixed with the class name maps to the
    primary key.
  prefs: []
  type: TYPE_NORMAL
- en: The fluent API `HasMaxLength` property is used to change the database types
    for the `GameType` and `PlayerName` properties. The `Codes` property is not such
    a simple property but can still be limited to a size of 120 characters.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration for the `Games` table is applied by invoking `ApplyConfiguration`
    from the context configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MoveConfiguration` class specifies a similar configuration for the `GuessPegs`
    and `KeyPegs` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For the `Move` type, shadow properties will be specified later in the *Defining
    relations between games and* *moves* section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating value conversion to map complex properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow mapping of types not directly supported by EF Core, value conversion
    can be used. The `FieldValues` property of type `IDictionary<string, IEnumerable<string>>`
    is not directly supported with the default mapping. With the game, the content
    of this value is not really that huge and also doesn’t need to be searched within.
    This allows us to map this to a `nvarchar`-type column.
  prefs: []
  type: TYPE_NORMAL
- en: Different options are available for the implementation. We will use a different
    one with SQL Server and with Azure Cosmos DB, but both options could be used with
    any of these providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of what the data looks like. Let’s imagine we have
    a dictionary such as the following with colors and shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Every value is prefixed with the key of the value. With the source repository,
    you’ll find a unit test to check for the implementation of this conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert this dictionary to a string, the `ToFieldsString` extension method
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/MappingExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation, using the LINQ `SelectMany` method, for every key in
    the dictionary, a value is created that’s prefixed by the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse functionality converts the string to a dictionary with the `FromFieldsString`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/MappingExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation, the complete string is first split using the `#` separator.
    Each resulting string contains a key and value separated with `:`. These results
    are added to a pair, to finally return a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are now used with the configuration of the `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/Configuration/GameConfiguration.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The column name and data type are specified using the fluent API’s `HasColumnName`,
    `HasColumnType`, and `HasMaxLength` properties. The `HasConversion` method is
    used to convert a type to be mapped to the database representation. This method
    has several overloads for different use cases. Here, the first parameter references
    an expression to convert the .NET property type to the database type, while the
    second parameter does the reverse. Here, we invoke the previously created extension
    methods. With the third parameter, an instance of the `ValueComparer` class is
    invoked. This is used to compare the value for equality.
  prefs: []
  type: TYPE_NORMAL
- en: Defining relations between games and moves
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the relational database, the `Games` table has a relation to the `Moves`
    table. One game maps to a list of moves. To make this possible, with the `Moves`
    table a foreign key named `GameId` is defined to reference the primary key of
    the `Games` table:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/Configuration/MoveConfiguration.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using `EntityTypeBuilder` for the `Move` type, invoking the `Property` method
    creates a `Move` type doesn’t have a property with this name. If there’s not a
    property with the same name, specifying the type is required as done here using
    the generic parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet maps this relationship to database tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GameConfiguration.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: EF Core supports one-to-one, one-to-many, and many-to-many relationships. With
    games and moves, a one-to-many relationship is defined with the `HasMany` and
    `WithOne` methods. The `HasForeignKey` method specifies the `GameId` value of
    the `Move` class to reference the ID of the game records.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the mapping from the classes to the tables, let’s implement the
    contract of the repository and add migrations to create the database.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we defined the `IGamesRepository` interface and implemented
    it with an in-memory representation. Now, let’s implement this interface to read
    and write to the SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and deleting games
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the implementation of the `AddGameAsync` and `DeleteGameAsync` methods
    of the contract to the `GamesSqlServerContext` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the `AddGameAsync` method, the passed `Game` object is added to the `Games`
    property of the EF Core context, which marks the entity as *added* with the change
    tracker. The `SaveChangesAsync` method creates `INSERT` statements in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `DeleteGameAsync` method receives the game ID with the parameter. Here,
    the `ExecuteDeleteAsync` method is invoked on the record matching the ID. `ExecuteDeleteAsync`
    and `ExecuteUpdateAsync` methods, available since EF Core 7, don’t use tracking
    and directly execute `DELETE` and `UPDATE` statements. This increases performance
    when change tracking is not necessary. When the record was not found to be deleted,
    this method returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting a 6x4 game creates this SQL statement to store the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let’s set a move with the next implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a move is set, some game information such as the last move number is updated
    as well. The implementation to add a move and update the game is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GameSqlServerContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Move` object is added to the context with the `Add` method, and the `Game`
    object is added with the `Update` method. This way, the change tracker is configured
    in that invoking the `SaveChangesAsync` method creates SQL `UPDATE` and `INSERT`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, one invocation of `SaveChangesAsync` creates one transaction. If
    updating the game fails, there’s a rollback for updating the move. In case you
    need multiple `SaveChangesAsync` instances within one transaction, the easiest
    option to use is ambient transactions (using the `TransactionScope` class from
    the `System.Transactions` namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Querying games
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve games, we need to implement `Getxx` methods. Let’s start with `GetGameAsync`
    to get the game by using the game ID:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `GetGameAsync` method uses the `SingleOrDefaultAsync` method to get either
    one or zero records. If the game ID is not found, `null` is returned. Behind the
    scenes, a query using `SELECT TOP(2)` is created to check if more than one record
    would be returned from this query. If this is the case, the `SingleOrDefaultAsync`
    method throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `Include` method is used to create a query that includes moves that relate
    to the returned query. Here, the SQL `LEFT JOIN` statement is used to join multiple
    tables. EF Core writes all the queries and updates to the log output. To better
    see which output maps to which LINQ methods, the `TagWith` method can be used.
    This tag is shown as a title with the log output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `TagWith` method is of great help with debugging and troubleshooting. Checking
    the log outputs to see SQL queries sent, the tag gives a fast way to see where
    this query was generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the log output from this query, including the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To query by date, player name, or some other query option, pass the `GamesQuery`
    object to the `GetGamesAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/GamesSqlServerContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of this method uses the `IQueryable` variable to add different
    LINQ query methods. Depending on the values passed with the `GamesQuery` parameter,
    multiple `Where` methods are added, in addition to `OrderBy` or `OrderByDescending`,
    to define the order of the result. To not return all the games played, only the
    first 500 games based on the filter are returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this method passing the player’s name and a date results in this SQL
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Include` method results in a `LEFT JOIN` operation to access the `Moves`
    table. Because of the `Take` method, `SELECT TOP` is used. Multiple invocations
    of the LINQ `Where` method results in a `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring user secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access the database, we need to retrieve some configuration values. Some
    of these configuration values are secrets that shouldn’t be part of the source
    code repository. During development time, you can use user secrets. User secrets
    are stored with the user profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize user secrets, use this .NET CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `UserSecretsId` property in the project file. Because all user
    secrets are stored with the user profile, this string is used to differentiate
    the configurations with multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set a configuration value with the secrets, use the `dotnet user-secrets`
    `set` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With the SQL Server Docker container we use, there are some requirements for
    the password. Be aware that you can’t use simple passwords. Three of four sets
    need to match: uppercase letters, lowercase letters, base 10 digits, and symbols.
    You can check the log output to see if there’s an issue with the password.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use Visual Studio and a context menu with Visual Studio to configure
    user secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the provider to read configuration values from user secrets by
    default is only used if the secret ID is configured and the application is running
    in the `Development` environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: User secrets cannot be used in production. The idea of user secrets is to not
    store secrets with a configuration file that’s pushed to a source code repository.
    Every developer working on this project needs to configure the configuration values
    for secrets. In production, you can use other services such as Azure Key Vault.
    This is covered in [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application model with SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run SQL Server, .NET Aspire makes it easy to run a Docker container. Just
    add this code to the application model in the `Codebreaker.AppHost` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSqlServer` method adds a SQL Server resource. Using this method, during
    development time, a Docker container is used. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    we’ll get into the details of Docker and add more configuration with this SQL
    Server Docker container. The name of this resource is sql. Optionally, a password
    can be passed to the `AddSqlServer` method. If a configuration parameter value
    is set with the resource name postfixed with -`password` (as we did), this `password`
    is used. Otherwise a random `password` is generated.. The `AddDatabase` method
    adds a database to the resource with the first parameter, the name of the resource
    that is used as a name for the connection string name, and the database name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow us to dynamically decide between different game repositories, we use
    the `DataStore` configuration to decide between in-memory, SQL Server, and Azure
    Cosmos DB on the startup of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/appsettings.json
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the database provider you want to use, change the value as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), *Flexible Configuration*,
    goes into the details of the `appsettings.json` file and environment-specific
    counterparts, as well as other options to store configuration values such as environmental
    variables, program arguments, and Azure App Configuration instances. In this chapter,
    all we need is to configure settings within `appsettings.json` as well as user
    secrets, which are covered with Azure Cosmos DB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration value is retrieved with the startup of the `AppHost` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In case the value is not configured, it defaults to the in-memory provider we
    created in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can change dependencies for the game APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `WithEnvironment` method creates an environment variable for the game APIs
    project with the `DataStore` key and the value that’s retrieved from the configuration.
    The `WithReference` method references the SQL Server resource and creates an environment
    variable for the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s configure the minimal APIs project to retrieve the configuration
    values from the `AppHost` project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the DI container with the minimal APIs project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the mapping of the model to the database is completed and the resource
    dependencies are defined with the Aspire `AppHost` project, the DI container can
    be configured to use the EF Core context.
  prefs: []
  type: TYPE_NORMAL
- en: The games API project needs a reference to the `Codebreaker.Data.SqlServer`
    project and the `Aspire.Microsoft.EntityFrameworkCore.SqlServer` NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the `DataStore` is retrieved with the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the retrieved configuration value for `DataStore`, we configure
    Azure Cosmos DB, SQL Server, or the in-memory repository that we implemented in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for SQL Server, which is called from the previous `switch/case`
    statement, is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the .NET Aspire SqlServer EF Core component, we can invoke the `AddSqlServerDbContext`
    API to configure the EF Core context with .NET Aspire. However, this API doesn’t
    provide the level of flexibility we need for working with different database providers.
    Thus, instead, we configure the EF Core context using EF Core APIs such as `AddDbContext`
    and `AddDbContextPool` and add Aspire functionality by using `EnrichSqlServerDbContext`.
    The `AddDbContextObjectPool` method configures to use the SQL Server EF Core provider,
    passing the connection string, which is passed via the `AppHost` project and thus
    needs to match the name configured with the top-level statements in the AppHost
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the `UseQueryTrackingBehavior` method adds one interesting aspect when
    using EF Core. By default, all queries are tracked within the EF Core context
    to allow the context to know about changes. Within the API service, the context
    is newly created with every new HTTP request. Thus, keeping this tracking state
    for every context is not required. Adding and updating entities are explicitly
    marked with the `Add` and `Update` methods. Setting the query tracking behavior
    to `QueryTrackingBehavior.NoTracking` disables tracking with all queries (unless
    overwritten with a query using the `AsTracking` method) and thus reduces the overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of turning tracking off by default, you can also use the option to turn
    tracking off with a single query using the `AsNoTracking` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `EnrichSqlServerDbContext` method adds health checks, logging, and telemetry
    configuration offered by the Aspire component. Logging and telemetry configuration
    are covered in [*Chapter 11*](B21217_11.xhtml#_idTextAnchor263), and health checks
    are covered in [*Chapter 12*](B21217_12.xhtml#_idTextAnchor294).
  prefs: []
  type: TYPE_NORMAL
- en: As the mappings and the repository contract are implemented, we can now continue
    to create the database using migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating migrations with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using EF Core, you can create the database with the `Database.EnsureCreatedAsync`
    context API method. However, this does not take schema changes into account. Over
    time, the database schema will change as new features are added – and it’s best
    to do this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21217_08.xhtml#_idTextAnchor183) describes how to automatically
    publish services to testing and production environments. With this, updating the
    database is important as well. When the database schema changes, updates should
    be published to the environments. EF Core offers **migrations** to record all
    schema changes and update the database schema programmatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the .NET EF Core tool
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the EF Core tool and create initial migrations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the model and add migrations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the database programmatically
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the .NET EF Core tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t have the EF Core .NET command-line tool installed yet, you can
    install it with the `dotnet` CLI as a global or a local tool. Here, we install
    it as a local tool to have a specific version of this tool as part of the `Codebreaker.Data.SqlServer`
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install local tools, a `tool-manifest` file first needs to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With the `tool-manifest` template, the `dotnet new` command creates a `.config`
    directory with a `dotnet-tools.json` file. This manifest file will contain all
    the tools that should be installed when working on the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as this manifest file is available, we can install the `dotnet-ef`
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This command configures this tool with the tool manifest file and installs it
    locally. In case you’ve installed another version of this tool globally, while
    the current directory of your command prompt is within the project folder, you
    use the tool version that’s specified with the tool manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get all the tools installed and configured with a tool manifest file, you
    can use the `tool` `restore` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `restore` command can be practically used when you clone a repository containing
    a tool manifest file. Using `dotnet tool restore`, all tools specified with the
    project are restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use this tool to create an initial migration for the actual context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`migrations` is a command of the `dotnet ef` tool. Using `add`, a new migration
    is added with the name that follows the `add` command (here, `InitGames`). The
    `-s` (or `--startup-project`) option specifies the project where the EF Core context
    is configured with the DI container, and the connection string to the database
    is specified. This is a different project than the project where the EF Core context
    is implemented (`Codebreaker.Data.Cosmos` and `Codebreaker.Data.SqlServer`); that’s
    why this option is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case creating the migration fails, check the error message. An error could
    be that you failed to specify a mapping, and here the errors are very detailed.
    While working around issues, you can temporarily ignore the properties of the
    model to see if the error is really based on a property mapping.
  prefs: []
  type: TYPE_NORMAL
- en: After a successful run of this tool, you’ll see a `Migrations` folder with the
    project. This folder contains a snapshot of the current state of the database,
    including all the table mappings, the property mappings, and the relations. This
    class is named based on the EF Core context suffixed by `ModelSnapshot`; for example,
    `GameSqlServerContextModelSnapshot`.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you add a new migration, the snapshot will be updated and a new `Migration`-derived
    class created that includes all the schema changes based on the previous migration.
    The migration is named with the migration name prefixed with the time. The generated
    class contains an `Up` method that will be invoked when the migration is applied
    to the SQL Server database and a `Down` method that will be invoked when the migration
    is dropped from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll use the `dotnet ef` tool to apply the migration to the database
    and create the database if it doesn’t exist yet. This can be done using the `dotnet
    ef database` `update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This command now uses the connection string from the startup project to apply
    migrations to the database. Using migrations to create the database, you’ll see
    all the games and moves tables created – along with the `_EFMigrationsHistory`
    table. Reading the content of this table, you’ll see all the migration names applied
    to the database. This information is checked when doing another update to the
    database schema using migrations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where creating the database fails while creating the migration
    succeeds. Mapping errors can be the reason here as well. Checking the error message
    again gives good details on the reason for the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating or updating the database programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using the command line to apply a migration, migrations can be started
    programmatically invoking the EF Core context with `context.Database.MigrateAsync`.
    Let’s implement this functionality with the `CreateOrUpdateDatabaseAsync` method,
    which is called from the application startup code for easy use of the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation, we check if the solution is configured to use SQL Server.
    In that case, the `MigrateAsync` method is invoked to update the database to the
    newest version.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `codebreaker` solution, this is really convenient – running the solution,
    everything is ready, including the database. From a security standpoint, in the
    production environment, the service running should not have a database connection
    string that is allowed to change the schema. Instead, a separate program can be
    used to update the database. This could be invoked from a GitHub action with automatic
    deployment. Using the `dotnet ef` tool, you can even create a standalone application
    to update the database schema: `dotnet ef migrations bundle` creates an application
    with the .NET runtime included, thus you can start this application from clients
    who don’t have the .NET runtime installed. You can also create a SQL script to
    start the migration if this is the preferred option by the database administrator:
    `dotnet ef` `migrations script`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s make a change to the model that influences the database schema.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216), we’ll differentiate anonymous
    from authenticated users. With this, game information will be stored when the
    game is played by an authenticated user. For this, we’ll add a `PlayerIsAuthenticated`
    flag to the `Game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Models/Game.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This new property is not defined to be ignored from the database. To update
    the database schema, we add a new migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The new migration is named `AddPlayerIsAuthenticated`. This change updates
    the snapshot in the `Migrations` folder and adds a new migration, as shown in
    this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.SqlServer/Migrations/ 20231225095931_AddPlayerIsAuthenticated.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With the `Up` method, updating a database from the previous version, the column
    is added to the database schema (`AddColumn`), and the `Down` method removes the
    column (`DropColumn`).
  prefs: []
  type: TYPE_NORMAL
- en: During development, you might often update the schema and create many migrations.
    Before publishing a new version of the application, it’s a good idea to combine
    migrations into one. Just pay attention to the version installed in production
    or staging environments. You should keep the migrations already deployed. Migrations
    that have been used only in your development environment can be removed with `dotnet
    ef migrations remove` (possibly called multiple times to always remove the last
    migration) – and finally, one invocation of `dotnet ef migrations add <Name of
    the migration>`, which then creates one migration with all schema changes since
    the last migration.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s run the solution using SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application with SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting the host application now, not only the game APIs service is running,
    but also SQL Server in a Docker container, as shown in *Figure 3**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – .NET Aspire resources with SQL Server](img/B21217_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – .NET Aspire resources with SQL Server
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the OpenAPI endpoint description to start games. Make sure to
    check into the details of the games API service. Details give information about
    the resource, the endpoints, and the environment variables, as shown in *Figure
    3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Environment variables](img/B21217_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: With the environment variables set for this service, check `DataStore` and `ConnectionStrings__CodebreakerSql`,
    which are set by the `AppHost` project.
  prefs: []
  type: TYPE_NORMAL
- en: Try to play a game using the HTTP files. Verify how records are added to the
    SQL Server database. However, when you stop the project and run the application
    again, the database is created from a fresh state. With Docker, we need volumes
    to map storage outside of the Docker container. This is covered in [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110).
  prefs: []
  type: TYPE_NORMAL
- en: After this, let’s move over to Azure Cosmos DB.
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core with Azure Cosmos DB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Azure Cosmos DB, Microsoft offers different databases with several APIs
    that make use of the same infrastructure. Most of these database offerings are
    NoSQL databases for different purposes. Azure Cosmos DB offers a JSON document
    store that can be accessed with the Mongo DB API. The Apache Cassandra API offers
    a wide column store where each row can have different columns. The Apache Gremlin
    query language can be used to access a graph version of the database. This is
    great to query for relations using vertices and edges. Azure Cosmos DB for PostgreSQL
    is a distributed high-performance relational database using the same infrastructure
    to read and write from a database network worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: For the `codebreaker` solution, we’ll use Azure Cosmos DB for NoSQL. Here, an
    EF Core provider is available. This allows us to use the same API as with SQL
    Server, but the mapping will be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the games and moves to Azure Cosmos DB, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class library project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the EF Core context
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a value converter to map complex types
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create embedded entities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the repository contract
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the application model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the DI container
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We created a SQL Server database when applying the migrations first. With Azure
    Cosmos DB, migrations are not available and are not needed. As JSON documents
    are stored, we are very flexible in the data to write. There is no concept of
    tables and relations between tables – we just store JSON documents within a container.
    One container can keep data of different kinds. A container can be used as a scaling
    unit, but you can also decide to specify the scaling with the complete database
    and share **request units** (**RU/s**) with different containers in a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'With containers, you also need to know about partitions. Partitions are used
    to scale containers for performance. Before specifying partitions, you need to
    know about some attributes of Azure Cosmos DB:'
  prefs: []
  type: TYPE_NORMAL
- en: A partition is limited to 20 GB storage. The size limit of a container is 1
    TB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing to the database, a transaction can only span writing to a single partition.
    If different data should be written within a transaction, this data should use
    the same partition key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10,000 RU/s is the maximum limit for a partition. With a container, the limit
    is 1,000,000 RU/s (with serverless, the container RU/s limit is 20,000). For the
    best-performance parallel reading of data, different partition keys should be
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum length of a partition key is 2048 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum size of one item to store is 2 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no limit on the distinct values of partition keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the game ID for the partition key. Games are created and updated
    independently of other games. It’s not necessary to write multiple games within
    one transaction. Running Azure Cosmos DB with a multi-region write configuration
    allows us to create games from different Azure regions with high performance.
    This makes the `Id` value of the game a good candidate for the partition key.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we’ll create a class library next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class library project for EF Core with NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to creating a library for SQL Server, we use a library to access Azure
    Cosmos DB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This library makes use of the `Microsoft.EntityFrameworkCore.Cosmos` NuGet package
    – and of course, a reference to the `Codebreaker.GameAPIs.Models` project is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EF Core context for Azure Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a context class to access Azure Cosmos DB, as shown with the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Similar to before, the custom context class derives from the `DbContext` base
    class and defines a constructor with context options, which allows us to configure
    the DI container with the connection string. The differences start now. With SQL
    Server, we defined the default schema name. This is not available with Azure Cosmos
    DB, but we can define the default container name using the `HasDefaultContainer`
    method. In case you have entities that should not be stored with the default container,
    these can be configured to use a different container with the help of the `ToContainer`
    method. The previously discussed partition key is configured by invoking the `HasPartitionKey`
    method. Using the `SetPartitionKey` and `ComputePartitionKey` methods, the partition
    key is configured as a **shadow property** with the same value as the game ID.
  prefs: []
  type: TYPE_NORMAL
- en: While `Id` is a good option for the partition key, other types that could be
    stored in the same container might not have an `Id` value. Thus, for the partition
    key, `PartitionKey` is used. With games, the `Id` value will be mapped to `PartitionKey`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing different object types to a single container requires the use of a discriminator
    value. By default, the discriminator value is the name of the class. By invoking
    the `HasDiscriminator` method, the default discriminator configuration is overridden
    by specifying the `Discriminator` shadow property. For `Game` types, the `GameV3`
    value is written. This allows us to differentiate game objects stored with incompatible
    new versions.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Cosmos DB stores JSON documents, thus only the `Game` type needs to be
    specified with a `DbSet` property, and not the `Move` type, as we did with SQL
    Server. Defining maximum sizes for string properties is not needed as well – there’s
    no schema describing this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a value converter to convert complex types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the SQL Server section, we converted the `Idictionary`-typed property, passing
    expressions to the `HasConversion` method to convert the dictionary to a string.
    The same could be done with Azure Cosmos DB, but now we’ll create a class deriving
    from `ValueConverter` and convert the dictionary to and from JSON, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.Cosmos/Utilities/FieldValueValueConverter.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: An EF Core value converter derives from the `ValueConverter` base class and
    specifies with the generic parameter what type to convert. With the `FieldValues`
    property, this is `IDictionary<string, IEnumerable<string>>`. The constructor
    of the base class requires parameters to convert to the database data type and
    to convert from the database data type. With the implementation, the `JsonSerializer`
    class from the `System.Text.Json` namespace is used to do the serialization and
    deserialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of this value converter is now passed to an overload of the `HasConversion`
    method with the `FieldValues` property configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `FieldValueValueConverter`, a `FieldValueComparer` instance is created.
    Instances of these two types are created to pass to the `HasConversion` method.
  prefs: []
  type: TYPE_NORMAL
- en: When creating the mapping for a relational database, much more was needed to
    configure. We reduced the code from the data context by creating configuration
    classes with every mapped table. This is not worthwhile doing here. The complete
    EF Core configuration, as well as the implementation of the repository interface,
    is done with the context class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating embedded entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about the relationship between games and moves? EF Core defines the `OwnsOne`
    and `OwnsMany` methods to define an owned relationship. With a relational database,
    `OwnsOne` adds columns of the owned type to the owner type. With the Azure Cosmos
    DB provider, invoking `OwnsMany` from `gameModel` and referencing the `Moves`
    property, moves will be stored as JSON within the game.
  prefs: []
  type: TYPE_NORMAL
- en: Since EF Core 7, this is the default behavior with related entity types with
    the Azure Cosmos DB provider. So, nothing needs to be configured to make this
    happen.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository contract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the implementation of the repository, there are many similarities to the
    implementation with SQL Server, but because of the different storage, some changes
    are necessary. Here, we’ll concentrate on the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.Data.Cosmos/GamesCosmosContext.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When adding or updating the game, the partition key needs to be set. Other than
    that, the code is the same as with SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a difference in what happens at runtime. Instead of using SQL `INSERT`
    and `UPDATE` statements, the Azure Cosmos DB provider executes `CreateItem` and
    `ReplaceItem` functions. When you check the log output, you can see the number
    of RUs required for every statement done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetGamesAsync` method defined previously also works with the Cosmos DB
    provider. This is the query created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing this query to the query to the SQL Server database, with Cosmos DB,
    it’s a lot simpler: joining of tables is not required. An interesting part of
    this query is the filtering on `Discriminator`. By default, every object stored
    in a container has a `Discriminator` filter that includes the type name. This
    allows the storage of different documents in the container. Queries for a specific
    type include the `Discriminator` filter.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you only store objects of the same type within one container, you can
    turn off storing with the `Discriminator` filter with the `HasNoDiscriminator`
    model definition method.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that not all LINQ queries translate successfully from the Cosmos DB
    provider. For example, `Include` and `Join` methods are not translated. While
    the `Include` method was used with SQL Server to include the moves with a query
    for a game, with a JSON document where the moves are stored within a game, this
    is not required. As there are no tables with NoSQL, `Join` is usually not required
    as well. In case you want to combine a list of different object types, create
    two queries and combine the results with the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the application model with Azure Cosmos DB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With SQL Server, we’ve been using a Docker container for SQL Server. Using Azure
    Cosmos DB, a Docker container is available as well. However, with Cosmos DB, this
    is just an emulator and should not be used for production. In [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    we’ll use the database running with Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Azure resources to the `AppHost` project, we need to add the `Aspire.Hosting.Azure`
    NuGet package. Let’s add Azure Cosmos DB to the Aspire `AppHost` application model:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the `AddAzureCosmosDB` method registers the Azure Cosmos DB resource.
    `codebreakercosmos` is the resource name, which needs to be lowercase and is used
    as the connection string to the Azure Cosmos DB account. Here, the name of the
    database is not part of the connection string. The database is specified by invoking
    the `AddDatabase` method and defines the name of the database. The `RunAsEmulator`
    method specifies a Docker image to run the database within a Docker container,
    but only within the development environment. Similar to before, the Cosmos DB
    resource is referenced from the games API project, which forwards the connection
    string with the `codebreakercosmos` key to this project. Be aware it’s not the
    name passed to `AddDatabase` (which was the case with SQL Server) because the
    database name is not part of the connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the DI container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the DI container with the games API project, we have to add the
    `Aspire.Microsoft.EntityFrameworkCore.Cosmos` NuGet package to use this Aspire
    component. The configuration of the DI container was already prepared with the
    configuration of the relational database. All that’s needed now is to add the
    Cosmos DB EF Core context, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameApis/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The .NET Aspire Azure Cosmos DB EF Core component offers the `AddCosmosDbContext`
    method, but similar to before, because we need the registration of the `IGamesRepository`
    interface, we use the EF Core `AddDbContext` method and add the Aspire component
    features by invoking the `EnrichCosmosDbContext` method. The `UseCosmos` method
    registers to use the EF Core provider for Azure Cosmos DB and assigns the connection
    string that is passed from the application model definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the database and the Cosmos DB container, we add the `else` part
    to the `CreateOrUpdateDatabaseAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameApis/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `Database.EnsureCreatedAsync` method creates the database and the Azure
    Cosmos DB container with the partition key specified.
  prefs: []
  type: TYPE_NORMAL
- en: Having the configuration in place, let’s start the application as before with
    SQL Server and check the stored games with your Azure Cosmos DB database while
    you set moves. Just make sure that the `DataStore` configuration is set to the
    correct database type. Using the HTTP files, don’t forget to use the returned
    game ID that is returned after creating the game.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we changed to using persistent storage with the API service
    using a relational and a NoSQL database. We created the database context to map
    the `Game` and `Move` types to tables in a relational database and to a JSON document
    with a NoSQL database – both using EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: To select which database to use in your environment, if you have relational
    data with a fixed schema, select SQL Server. If the schema is not required in
    your scenario, and changes to the data happen often, a NoSQL database can be the
    best option.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about how to map objects and how to deal with special mapping requirements
    based on the object model. Using a relational database, you also learned how to
    create migrations to update the database schema and to initially create the database.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use database resources with the .NET Aspire application model
    specified with the `AppHost` project.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the next chapter, it’s well deserved to play another game round.
    Just use the HTTP files to make your game run. With the state of the current implementation,
    the game can continue to run after you restart the service – the games and moves
    are persisted.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we create a library that can be used by client applications
    to invoke the web API so that it becomes more convenient to play the game.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value conversions: [https://learn.microsoft.com/ef/core/modeling/value-conversions](https://learn.microsoft.com/ef/core/modeling/value-conversions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance with EF Core: [https://learn.microsoft.com/ef/core/modeling/inheritance](https://learn.microsoft.com/ef/core/modeling/inheritance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Owned entity types: [https://learn.microsoft.com/ef/core/modeling/owned-entities](https://learn.microsoft.com/ef/core/modeling/owned-entities)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transactions: [https://learn.microsoft.com/ef/core/saving/transactions](https://learn.microsoft.com/ef/core/saving/transactions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Migrations: [https://learn.microsoft.com/ef/core/managing-schemas/migrations](https://learn.microsoft.com/ef/core/managing-schemas/migrations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Cosmos DB intro: [https://learn.microsoft.com/azure/cosmos-db/introduction](https://learn.microsoft.com/azure/cosmos-db/introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Limitations with the EF Core Cosmos provider: [https://learn.microsoft.com/ef/core/providers/cosmos/limitations](https://learn.microsoft.com/ef/core/providers/cosmos/limitations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Aspire SqlServer EF Core component: [https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/sql-server-entity-framework-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Aspire Microsoft EF Core Cosmos DB component: [https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component](https://learn.microsoft.com/en-us/dotnet/aspire/database/azure-cosmos-db-entity-framework-component)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
