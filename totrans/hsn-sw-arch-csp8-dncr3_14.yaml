- en: Implementing Code Reusability in C# 8
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C# 8 中实现代码重用
- en: Code reusability is one of the most important topics in software architecture.
    This chapter aims to discuss ways to enable code reuse and understand how .NET
    Standard goes in this direction to solve the problem of managing and maintaining
    a reusable library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用性是软件架构中最重要的主题之一。本章旨在讨论启用代码重用的方法，并了解 .NET Standard 如何朝这个方向努力以解决管理和维护可重用库的问题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the principles of code reuse
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码重用的原则
- en: The advantages of working with .NET Standard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 .NET Standard 合作的优势
- en: Creating reusable libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用库
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires the following things:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: You need Visual Studio 2017 or the 2019 free community edition or better with
    all the database tools installed.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要安装所有数据库工具的 Visual Studio 2017 或 2019 免费社区版或更高版本。
- en: 'A free Azure account: The *Creating an Azure Account* section in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding
    the Importance of Software Architecture*, explains how to create one.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费Azure账户：[第 1 章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)中的“*理解软件架构的重要性*”部分，*创建
    Azure 账户*，解释了如何创建一个。
- en: 'An Azure DevOps account: The *What is Azure DevOps?* section in [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml), *Documenting
    Requirements with Azure DevOps*, explains how to create one.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps 账户：[第 3 章](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml)中的“*什么是 Azure
    DevOps*”部分，*使用 Azure DevOps 记录需求*，解释了如何创建一个。
- en: You will find the sample code of this chapter at [https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11](https://github.com/PacktPublishing/Hands-On-Software-Architecture-with-CSharp-8/tree/master/ch11)找到本章的示例代码。
- en: Understanding the principles of code reusability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码重用性原则
- en: There is a single reason that you can always use to justify code reuse—you cannot
    spend your valuable time recreating the wheel if it is already running well in
    other scenarios. That is why most engineering domains are based on reusability
    principles. Think about the light switch you have in your house.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终使用单一的理由来证明代码重用——如果你在其他场景中已经运行良好，你不能浪费宝贵的时间重新造轮子。这就是为什么大多数工程领域都基于可重用性原则。想想你家里的灯开关。
- en: Can you imagine the number of applications that can be made with the same interface
    components? The fundamentals of code reuse are the same. Again, it is a matter
    of planning a good solution so part of it can be reused later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象出使用相同的界面组件可以制作多少个应用程序吗？代码重用的基本原则是相同的。再次强调，这是一个规划良好解决方案的问题，其中一部分可以在以后重用。
- en: 'In software engineering, code reuse is one of the techniques that can bring
    to software project a bunch of advantages, such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，代码重用是能够为软件项目带来一系列优势的技术之一，例如以下内容：
- en: There's confidence in the software, considering that the reused piece of code
    was already tested in another application
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到重用的代码部分已在另一个应用程序中经过测试，因此对软件有信心
- en: There's better usage of software architects since they can be dedicated to solving
    this kind of problem
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于软件架构师可以专注于解决这类问题，因此他们有更好的使用方式
- en: There's the possibility of bringing to the project a pattern that's already accepted
    by the market
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有可能将市场上已经接受的模式引入项目
- en: Development speed goes up due to the already implemented components
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于已经实现了组件，开发速度提高了
- en: Maintenance is easier
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护更容易
- en: These aspects indicate that code reuse shall be done whenever it is possible.
    It is your responsibility, as a software architect, to ensure the preceding advantages
    and, more than that, to incentivize your team to enable reuse in the software
    they are creating.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面表明，只要可能，就应该进行代码重用。作为软件架构师，确保上述优势并激励你的团队在创建的软件中启用重用是你的责任。
- en: What is not code reuse?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是非代码重用？
- en: The first thing you have to understand is that code reuse does not mean copying
    and pasting code from one class to another. Even if this code was written by another
    team or project, this does not indicate you are properly working with reusability
    principles. Let's imagine a scenario that we will find in this book's use case,
    the WWTravelClub evaluation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须首先理解的是，代码复用并不意味着从一类复制粘贴代码到另一类。即使这段代码是由另一个团队或项目编写的，这也不表明你正确地运用了复用原则。让我们想象一个场景，我们将在本书的使用案例中找到这个场景，即WWTravelClub评估。
- en: 'In the project scenario, you may want to evaluate different kinds of subjects,
    such as the Package, Destination Expert, City, Comments, and so on. The process
    for getting the evaluation average is the same, no matter which subject you are
    referring to. Due to this, you may want to *enable* reuse by copying and pasting
    the code for each evaluation. The (bad) result will be something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目场景中，你可能想评估不同类型的主题，例如包、目的地专家、城市、评论等。无论你指的是哪个主题，获取评估平均值的流程都是相同的。因此，你可能希望通过复制粘贴每个评估的代码来*启用*复用。(不好的)结果可能如下所示：
- en: '![](img/e162496d-58fb-41be-a669-778be8f1316d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e162496d-58fb-41be-a669-778be8f1316d.png)'
- en: In the preceding diagram, the process for calculating the evaluation average
    is decentralized, which means that the same code will be duplicated in different
    classes. This will cause a lot of trouble, especially if the same approach starts
    happening in other applications. For instance, if there is a new specification
    about how you have to calculate the average or if you just get a bug in the calculation
    formula, you will have to fix it in all instances of code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，计算评估平均值的流程是分散的，这意味着相同的代码将在不同的类中重复。这将造成很多麻烦，尤其是如果相同的做法开始在其他应用程序中发生。例如，如果有一个关于如何计算平均值的新规范，或者如果你只是计算公式中出现了错误，你将不得不在所有代码实例中修复它。
- en: What is code reuse?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是代码复用？
- en: 'The solution to the problem mentioned in the last section is quite simple.
    You have to analyze your code and select the parts of it that it would be a good
    idea to decouple from your application. The greatest reason why you should decouple
    it is related to how you are sure that this code can be reused in other parts
    of the application or even in another application:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 上节中提到的问题的解决方案相当简单。你必须分析你的代码，并选择那些从你的应用程序中解耦的部分。你应该解耦的最大原因与你如何确保这段代码可以在应用程序的其他部分或另一个应用程序中复用有关：
- en: '![](img/bb4e6ffc-dda0-4379-847f-24cbfa7ded04.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4e6ffc-dda0-4379-847f-24cbfa7ded04.png)'
- en: The centralization of the code brings to you, as a software architect, a different
    responsibility for it. You will have to keep in mind that a bug or an incompatibility
    of this code can cause damage to many parts of the application or different applications.
    On the other hand, once you have this code tested and running, you will be able
    to propagate its usage with no worries. Besides, if you need to evolve the average
    calculation process, you will have to change the code in a single class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的集中化给你，作为一个软件架构师，带来了不同的责任。你必须记住，这段代码的任何错误或不兼容都可能对应用程序的许多部分或不同的应用程序造成损害。另一方面，一旦你测试并运行了这段代码，你将能够无忧无虑地传播其使用。此外，如果你需要进化平均计算过程，你将不得不在一个类中更改代码。
- en: It is worth mentioning that the more you use the same code, the cheaper this
    development will become. Cost needs to be mentioned because, in general, the conception
    of reusable software costs more in the beginning.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，你使用相同代码的次数越多，这种开发方式就越便宜。需要提到成本，因为通常情况下，可复用软件的概念在开始时成本更高。
- en: Inserting reusability into your development cycle
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将复用引入你的开发周期
- en: If you understood that reusability will take you to another level of code implementation,
    you should have been thinking about how to make this technique available in your
    development cycle. As a matter of fact, creating and maintaining a component library
    is not very easy, due to the responsibility you will have and the lack of good
    tools to support the search for existent components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了复用将带你进入代码实现的另一个层次，你就应该开始思考如何在你的开发周期中实现这种技术。实际上，创建和维护组件库并不容易，因为你将承担的责任以及缺乏支持现有组件搜索的良好工具。
- en: 'On the other hand, there are some things that you may consider implementing
    in your software development process every time you initiate a new development:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有一些事情你可能在每次开始新的开发时都应考虑在软件开发过程中实施：
- en: '**Use** already implemented components from your user library, selecting features in
    the software requirements specification that need them.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用**用户库中已实现的组件，选择软件需求规范中需要它们的特性。'
- en: '**Identify **features in the software requirements specification that are candidates
    to be designed as library components.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**识别**软件需求规范中作为库组件设计候选者的功能。'
- en: '**Modify** the specification considering that these features will be developed
    using reusable components.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改**规范，考虑到这些功能将使用可重用组件来开发。'
- en: '**Design** the reusable components and be sure that they have the appropriate
    interfaces to be used in many projects.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**可重用组件，并确保它们具有适当的接口，以便在多个项目中使用。'
- en: '**Build** the project architecture with the new component library version.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**使用新组件库版本的项目架构。'
- en: '**Document** the component library version so every developer and team knows
    about it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录**组件库版本，以便每个开发者和团队都知道它。'
- en: The *use-identify-modify-design-build* process is a technique that you may consider
    implement every time you need to enable software reuse. As soon as you have the
    components you need to write for this library, you will need to decide on the
    technology that will provide these components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用-识别-修改-设计-构建* 过程是一种技术，你可能每次需要启用软件重用时都应考虑实施。一旦你有了为这个库编写所需的组件，你将需要决定将提供这些组件的技术。'
- en: During the history of software development, there were many approaches for doing
    this; some of them are discussed in [Chapter 5](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml),
    *Applying a Microservice Architecture to Your Enterprise Application*, in the
    *Microservices as the evolution of the concept of modul**e* section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的历史中，有许多实现这一目标的方法；其中一些在[第5章](49aed8bb-9a4a-4241-9efc-f53c3f53dd5a.xhtml)，“将微服务架构应用于您的企业应用程序”的*微服务作为模块概念的演变*部分中进行了讨论。
- en: Using .NET Standard for code reuse
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET Standard 进行代码重用
- en: .NET has evolved a lot since its first version. This evolution is not only related
    to the number of commands and performance issues, but the supported platforms
    too. As discussed in [Chapter 1](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml), *Understanding
    the Importance of Software Architecture*, you can run C# .NET in billions of devices,
    even if they are running Linux, Android, macOS, or iOS. For this reason, .NET
    Standard was first announced together with .NET Core 1.0, but the breaking changes
    happened with .NET Standard 2.0, when .NET Framework 4.6, .NET Core, and Xamarin
    were compatible with it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 自从第一个版本发布以来已经发展了很多。这种发展不仅与命令数量和性能问题相关，还与支持的平台相关。正如在[第1章](14b5c5da-4042-439e-9e5a-2e19ba4c4930.xhtml)，“理解软件架构的重要性”中讨论的那样，你可以在数十亿台设备上运行
    C# .NET，即使它们运行的是 Linux、Android、macOS 或 iOS。因此，.NET Standard 首次与 .NET Core 1.0
    一起宣布，但破坏性变化发生在 .NET Standard 2.0，当时 .NET Framework 4.6、.NET Core 和 Xamarin 都与之兼容。
- en: 'The key point is that .NET Standard is not only a kind of Visual Studio project.
    More than that, it is a formal specification available to all .NET implementations.
    As you can see in the following table, it covers everything from the .NET Framework
    to Unity ([https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions)):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于 .NET Standard 不仅是一种 Visual Studio 项目。更重要的是，它是一种对所有 .NET 实现都适用的正式规范。正如你在下表中所见，它涵盖了从
    .NET Framework 到 Unity ([https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions))
    的所有内容：
- en: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| .NET Standard | 1.0 | 1.1 | 1.2 | 1.3 | 1.4 | 1.5 | 1.6 | 2.0 | 2.1 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| .NET Core | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| .NET Core | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 1.0 | 2.0 | 3.0 |'
- en: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1¹ | 4.6.1¹ | 4.6.1¹
    | N/A² |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| .NET Framework | 4.5 | 4.5 | 4.5.1 | 4.6 | 4.6.1 | 4.6.1¹ | 4.6.1¹ | 4.6.1¹
    | N/A² |'
- en: '| Mono | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 5.4 | 6.2 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 单元 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 4.6 | 5.4 | 6.2 |'
- en: '| Xamarin.iOS | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.14 | 12.12
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.iOS | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.0 | 10.14 | 12.12
    |'
- en: '| Xamarin.Mac | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.8 | 5.12 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.Mac | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.0 | 3.8 | 5.12 |'
- en: '| Xamarin.Android | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 8.0 | 9.3 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Xamarin.Android | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 7.0 | 8.0 | 9.3 |'
- en: '| Unity | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1
    | TBD |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Unity | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1 | 2018.1
    | TBD |'
- en: '| Universal Windows Platform | 8.0 | 8.0 | 8.1 | 10.0 | 10.0 | 10.0.16299 |
    10.0.16299 | 10.0.16299 | TBD |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 通用 Windows 平台 | 8.0 | 8.0 | 8.1 | 10.0 | 10.0 | 10.0.16299 | 10.0.16299 |
    10.0.16299 | TBD |'
- en: The preceding table indicates that if you build a class library that's compatible
    with this standard, you will be able to reuse it in any of the platforms presented.
    Think about how fast your development process can become if you plan to do so
    in all your projects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表格表明，如果你构建一个与该标准兼容的类库，你将能够在所展示的任何平台上重用它。想想看，如果你计划在所有项目中这样做，你的开发过程会变得多快。
- en: Obviously, some components are not included in .NET Standard, but its evolution
    is continuous. It is worth mentioning that Microsoft's official documentation
    indicates that *the higher the version, the more APIs are available to you*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一些组件不包括在 .NET Standard 中，但其发展是持续的。值得一提的是，微软的官方文档指出，*版本越高，可用的 API 越多*。
- en: Creating a .NET Standard library
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 .NET Standard 库
- en: 'It is quite simple to create a class library compatible with .NET Standard.
    Basically, you need to choose the following project when creating the library:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与 .NET Standard 兼容的类库相当简单。基本上，你需要在创建库时选择以下项目：
- en: '![](img/00882bf3-8b23-4eae-9648-94bd40168c5f.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00882bf3-8b23-4eae-9648-94bd40168c5f.png)'
- en: 'Once you have concluded this part, you will notice that the only difference
    between a common class library and the one you created is the target framework
    defined in the project file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这部分，你会注意到，一个普通类库和你创建的类库之间的唯一区别是项目文件中定义的目标框架：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as your project is loaded, you can start coding the classes that you
    intend to reuse. The advantage of building reusable classes using this approach
    is that you will be able to reuse the written code in all of the project types
    we checked before. On the other hand, you will find out that some APIs that are
    available in .NET Framework do not exist in this type of project. You can follow
    the future of the standard at [https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1](https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的项目加载完毕，你就可以开始编写你打算重用的类。使用这种方法构建可重用类的优点是，你将能够在之前检查的所有项目类型中重用所编写的代码。另一方面，你会发现一些在
    .NET Framework 中可用的 API 在这类项目中不存在。你可以通过[https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1](https://github.com/dotnet/standard/tree/master/docs/planning/netstandard-2.1)来关注标准的未来。
- en: How does C# deal with code reuse?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 如何处理代码重用？
- en: There are many approaches where C# helps us deal with code reuse. The ability
    to build libraries, as we checked in the last topic, is one of them. The most
    important one is the fact that the language is object-oriented. Besides, it is
    worth mentioning the facilities that generics brought to C# language. This topic
    will discuss the last two mentioned.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C# 有许多方法帮助我们处理代码重用。我们之前检查的构建库的能力是其中之一。最重要的是，这种语言是面向对象的。此外，还值得一提的是泛型为 C# 语言带来的便利。本主题将讨论最后两个提到的内容。
- en: Object-oriented analysis
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象分析
- en: The object-oriented analysis approach gives us the ability to reuse code in
    different ways, from the facility of inheritance to the changeability of polymorphism.
    Complete adoption of object-oriented programming. will let you implement abstraction
    and encapsulation too.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象分析的方法使我们能够以不同的方式重用代码，从继承的便利性到多态的可变性。完全采用面向对象编程将让你也能够实现抽象和封装。
- en: 'The following screenshot presents using the object-oriented approach to make
    reuse easier. As you can see, there are different ways to calculate the grades
    of an evaluation, considering you can be a basic or a prime user of the system:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了使用面向对象的方法来简化重用。正如您所看到的，有不同方式来计算评估的等级，考虑到您可以是系统的基本用户或高级用户：
- en: '![](img/0b8c4c20-f04e-4b81-a553-3305d15e75c4.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b8c4c20-f04e-4b81-a553-3305d15e75c4.png)'
- en: There are two aspects to be analyzed as code reuse in this design. The first
    is that there's no need to declare the properties in each child class since inheritance
    is doing it for you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，代码重用有两个方面需要分析。第一个方面是，由于继承为你做了这件事，所以没有必要在每个子类中声明属性。
- en: 'The second is the opportunity we have to use polymorphism, enabling different
    behaviors for the same method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个机会是我们使用多态，为相同的方法启用不同的行为：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can check in the preceding code the usage of the polymorphism principle,
    where the calculation of evaluation for prime users will increase by 20%. Now,
    take a look at how easy it is to call different objects inherited by the same
    class. Since the collection content implements the same interface, `IContentEvaluated`,
    it can have basic and prime users too:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的代码中检查多态原则的使用，其中对初级用户的评估计算将增加 20%。现在，看看调用同一类继承的不同对象是多么容易。由于集合内容实现了相同的接口
    `IContentEvaluated`，它也可以有基本用户和初级用户：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object-oriented adoption can be considered mandatory when using C#. However,
    more specific usage will need study and practice. You, as a software architect,
    shall always incentivize your team to study object-oriented analysis. The more
    they have good abstraction abilities, the easier code reuse will become.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 C# 时，面向对象的采用可以被认为是强制性的。然而，更具体的用法需要学习和实践。作为软件架构师，你应该始终鼓励你的团队学习面向对象的分析。他们的抽象能力越强，代码复用就越容易。
- en: Generics
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics were introduced in C# in version 2.0, and it is definitely considered
    an approach that increases code reuse. It also maximizes type safety and performance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是在 C# 2.0 版本中引入的，它被认为是一种提高代码复用的方法。它还最大限度地提高了类型安全和性能。
- en: The basic principle of generics is that you can define in an interface, class,
    method, property, event, delegate, or even a placeholder that will be replaced
    with a specific type at a later time when one of the preceding entities will be
    used. The opportunity you have with this feature is incredible since you can use
    the same code to run different versions of the type, generically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的基本原理是，你可以在接口、类、方法、属性、事件、委托或甚至一个占位符中定义，这个占位符将在稍后某个实体被使用时，用特定的类型替换。这个特性为你提供了不可思议的机会，因为你可以使用相同的代码来运行不同版本的类型，实现泛型。
- en: 'The following code is a modification of `EvaluationService`, which was presented
    in the last section. The idea here is to enable the generalization of the service,
    giving the opportunity to define the goal of evaluation since its creation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是对上一节中介绍的 `EvaluationService` 的修改。这里的想法是使服务泛化，从其创建时就定义评估的目标：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This declaration indicates that any class that implements the `IContentEvaluaded` interface can
    be used for this service. Besides, the service will be responsible for creating
    the evaluated content.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明表明，任何实现了 `IContentEvaluaded` 接口的类都可以用于这个服务。此外，服务将负责创建评估内容。
- en: 'The following code implements exactly the evaluated content created since the
    construction of the service. This code uses `System.Reflection` and the generic
    definition from the class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了自服务构建以来创建的评估内容。这段代码使用了 `System.Reflection` 和来自类的泛型定义：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is worth mentioning that this code will work because all of the classes
    are in the same assembly. The result of this modification can be checked in the
    instance creation of the service:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这段代码将能够工作，因为所有类都在同一个程序集中。这个修改的结果可以在服务的实例创建中进行检查：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The good news is that now you have a generic service that will automatically
    instantiate the list object with the evaluations of the content you need. It worth
    mentioning that generics obviously will need more time dedicated to the first
    project construction. However, after the design is done, you will have a good,
    fast, and easy-to-maintain code. This is what we call reuse!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，现在你有一个泛型服务，它将自动实例化所需内容的评估列表对象。值得一提的是，泛型显然需要更多时间用于第一个项目的构建。然而，一旦设计完成，你将拥有一个良好、快速且易于维护的代码。这就是我们所说的复用！
- en: Use case – reusing code as a fast track to deliver good and safe software
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 代码复用作为快速交付优质和安全的软件的途径
- en: 'The final design of the solution for evaluating content for WWTravelClub can
    be checked as follows. This approach consists of the usage of many topics that
    were discussed in this chapter. First, all of the code is placed in a .NET Standard
    class library. This means that you can add this code to different types of solutions,
    such as .NET Core web apps and Xamarin apps for the Android and iOS platforms:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 评估 WWTravelClub 内容的解决方案的最终设计可以按以下方式检查。这种方法包括使用本章讨论的许多主题。首先，所有代码都放置在一个 .NET Standard
    类库中。这意味着您可以将此代码添加到不同类型的解决方案中，例如 .NET Core 网络应用程序和 Android 和 iOS 平台的 Xamarin 应用程序：
- en: '![](img/68fc31e7-4bde-409d-a30a-b6f1d2d55f2c.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68fc31e7-4bde-409d-a30a-b6f1d2d55f2c.png)'
- en: This design makes use of object-oriented principles such as inheritance, so
    you do not need to write properties and methods more than once that can be used
    in many classes; and polymorphism, so that you can change the behavior of the
    code without changing the name of the method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计利用了面向对象原则，如继承，因此您不需要在多个类中多次编写可被使用的属性和方法；以及多态，这样您可以在不更改方法名称的情况下更改代码的行为。
- en: To finish, the design abstracts the idea of the content by introducing generics
    as a tool that can facilitate the manipulation of similar classes, such as the
    ones we have in WWTravelClub to evaluate contents regarding cities, comments,
    destination experts, and travel packages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该设计通过引入泛型作为可以促进类似类（如我们在 WWTravelClub 中用于评估城市、评论、目的地专家和旅游套餐的类）操作的工具，抽象了内容的概念。
- en: The big difference between a team that incentivizes code reuse and one that
    does not is the velocity of delivering good software to end users. Of course,
    beginning this approach is not easy, but rest assured that you will get good results
    after some time working with it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在鼓励代码复用的团队和不鼓励代码复用的团队之间，最大的区别在于向最终用户提供优质软件的速度。当然，开始这种做法并不容易，但请放心，经过一段时间的工作，你将获得良好的结果。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter aimed to help you understand the advantages of code reuse. It also
    gave you an idea about what is not properly reused code. This chapter also presented
    approaches for reusing code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在帮助您了解代码复用的优势。它还让您对什么是未正确复用的代码有了概念。本章还介绍了代码复用的方法。
- en: Considering that technology without process does not take you anywhere, a process
    was presented to enable code reuse. This process is related to using already finished components
    from your library; identifying features in the software requirements specification
    that are candidates to be designed as library components; modifying the specification
    considering these features; designing the reusable components; and building the
    project architecture with the new component library version.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到没有流程的技术无法带您走得更远，本章提出了一种流程来启用代码复用。此流程与使用库中已经完成的组件相关；在软件需求规格说明书中识别可以作为库组件设计的候选功能；根据这些功能修改规格说明；设计可复用的组件；以及使用新的组件库版本构建项目架构。
- en: 'To finish, this chapter presented .NET Standard libraries as an approach to
    reuse code for different C # platforms, reinforced the principles of object-oriented
    programming as a way to reuse code, and presented generics as a sophisticated
    implementation to simplify the treatment of objects with the same characteristics. In
    the next chapter, we will be seeing how to apply **service-oriented architecture**
    (**SOA**) with .NET Core.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章将 .NET Standard 库作为在不同 C# 平台上复用代码的方法，强调了面向对象编程作为复用代码的方式，并介绍了泛型作为简化具有相同特性的对象处理的复杂实现。在下一章中，我们将看到如何使用
    .NET Core 应用 **服务导向架构**（**SOA**）。
- en: It is worth mentioning that SOA is considered a way to implement code reuse
    in sophisticated environments.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，SOA 被认为是复杂环境中实现代码复用的一种方式。
- en: Questions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can copy-and-paste be considered code reuse? What are the impacts of this approach?
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制和粘贴可以被认为是代码复用吗？这种方法的有哪些影响？
- en: How can you make use of code reuse without copying and pasting code?
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不复制和粘贴代码的情况下利用代码复用？
- en: Is there a process that can help code reuse?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有可以帮助代码复用的流程？
- en: What is the difference between .NET Standard and .NET Core?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Standard 和 .NET Core 之间的区别是什么？
- en: What are the advantages of creating a .NET Standard library?
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 .NET Standard 库有哪些优势？
- en: How does object-oriented analysis help with code reuse?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象分析如何帮助代码复用？
- en: How do generics help with code reuse?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型如何帮助代码复用？
- en: Further reading
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are some books and websites where you will find more information about
    this chapter:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些书籍和网站，您可以在其中找到更多关于本章的信息：
- en: '*Clean Architecture: A Craftsman''s Guide to Software Structure and Design*
    by Martin, Robert C. Pearson Education, 2018.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*整洁架构：软件结构与设计的工匠指南*》由Martin, Robert C. 著，Pearson Education，2018年。
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erica Gamma
    [et al.] Addison-Wesley, 1994.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计模式：可复用面向对象软件元素*》由Erica Gamma [等] 著，Addison-Wesley，1994年。
- en: '*Design Principles and Design Patterns* by Robert C. Martin, 2000.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《*设计原则与设计模式*》由Robert C. Martin 著，2000年。
- en: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://devblogs.microsoft.com/dotnet/introducing-net-standard/](https://devblogs.microsoft.com/dotnet/introducing-net-standard/)'
- en: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/net-standard-20-cookbook](https://www.packtpub.com/application-development/net-standard-20-cookbook)'
- en: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dotnet/standard/blob/master/docs/versions.md](https://github.com/dotnet/standard/blob/master/docs/versions.md)'
- en: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/pt-br/dotnet/csharp/programming-guide/generics/)'
