- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interface Brilliance: Designing User-Friendly UI'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything that is shown on the screen and transmitted through the speakers
    of a computer is a form of communication. In previous chapters, we used 3D models
    to let the user know that they are in a base in the middle of the mountains, and
    we reinforced that idea with the appropriate sound and music. But for our game,
    we need to communicate other information, such as the amount of life the player
    has left and the current score, and sometimes, it is difficult to express these
    things using the in-game graphics (there are some successful cases that manage
    to do this, such as *Dead Space*, but let’s keep things simple).
  prefs: []
  type: TYPE_NORMAL
- en: In order to transmit this information, we need to add another layer of graphics
    on top of our scene, which is usually called the **User Interface** (**UI**).
    This will contain different visual elements, such as text fields, bars, and buttons,
    to prepare the user to make an informed decision, based on things such as fleeing
    to a safe place when their life is low.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Canvas and RectTransform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canvas object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a responsive UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, these terms may mean nothing to you, but to simplify, think of the
    Canvas and RectTransform as the respective stage and actors of your UI drama.
    They’re crucial, and we’ll dive deep into how they work and play together.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use the Unity UI system to create
    interfaces capable of informing the user about the state of the game, allowing
    them to take action by pressing buttons.
  prefs: []
  type: TYPE_NORMAL
- en: We’re about to unravel how the Canvas and RectTransform work in unison to bring
    your game’s interface to life. It’s a bit like choreographing a dance – every
    element has its place and movement.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Canvas and RectTransform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are only going to focus on the in-game UI to communicate different information
    to the player using the Unity GUI system (or uGUI). At the time of writing, a
    new GUI system called UI Toolkit has been released. Even though we will introduce
    UI Toolkit, remember that uGUI isn’t going anywhere anytime soon. It’s crucial
    to grasp both to be versatile in your UI design approach. We will explore UI Toolkit
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are going to work with Unity UI, you first need to understand its two
    main concepts—the **Canvas** and **RectTransform**. The **Canvas** is the master
    object that will contain and render our UI, and **RectTransform** is the feature
    in charge of positioning and adapting each UI element on our screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI with the Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Positioning elements with RectTransform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by using the Canvas component to create our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI with the Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s put theory into practice by creating a Canvas-based UI. We’ll start with
    something simple to get the ball rolling.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components, but in order for them to work, they must be a
    child of a master GameObject with the Canvas component. This component is responsible
    for triggering the UI generation and drawing iterations over each child object.
    We can configure this component to specify exactly how that process works and
    adapt it to different possible requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you can simply create a canvas with the **GameObject** | **UI** |
    **Canvas** option. After doing that, you will see a rectangle in the scene, which
    represents the user’s screen, so you can put elements inside it and preview where
    they will be located relative to the user’s monitor.
  prefs: []
  type: TYPE_NORMAL
- en: You are probably wondering two things here. First, “*Why is the rectangle in
    the middle of the scene? I want it to always be on the screen!*” Don’t worry,
    because that will be exactly the case. When you edit the UI, you will see it as
    part of the level, as an object inside it, but when you play the game, it will
    always be projected over the screen, on top of every object. Also, you may be
    wondering why the rectangle is huge, and that’s because one pixel of the screen
    map corresponds to one meter on the scene when using the default **Canvas** **Render
    Mode**, the one called **Screen Space - Overlay**. There are other modes, but
    discussing them is outside of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, don’t worry about that; you will see all your UI elements with their
    proper size and position on the user’s screen when you see the game in the **Game**
    view. Consider setting the **Game** view size prior to editing it in the **Scene**
    view, given that the **Scene** view will follow the **Game** view dimensions.
    You can do that by clicking the dropdown saying **Free Aspect** at the top part
    of the **Game** panel and selecting the desired resolution or aspect ratio, **16:9
    Aspect** being the most used option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: A default image UI element—a white box'
  prefs: []
  type: TYPE_NORMAL
- en: Before adding elements to our UI, it’s worth noting that when you created the
    UI, a second object was created alongside the Canvas, called **EventSystem**.
    This object is not necessary to render a UI but is necessary if you want the UI
    to be interactable, which means including actions such as clicking buttons, introducing
    text in fields, or navigating the UI with the joystick. The **EventSystem** component
    is responsible for sampling the user input, such as with a keyboard, mouse, or
    joystick, and sending that data to the UI to react accordingly. We can change
    the exact buttons to interact with the UI, but the defaults are OK for now, so
    just know that you need this object if you want to interact with the UI. If for
    some reason you delete the object, you can recreate it again in **GameObject**
    | **UI** | **Event System**.
  prefs: []
  type: TYPE_NORMAL
- en: You’re building a great foundation. Keep this momentum going, as the principles
    you’re learning now will be vital as you advance.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning elements with RectTransform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components according to its usage, but you will see that
    most of them have one component in common—**RectTransform**. Each piece of the
    UI is essentially a rectangle filled with text or images and has different behavior,
    so it is important to understand how the **RectTransform** component works and
    how to edit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to experiment with this component, let’s create and edit the position
    of a simple white box element for the UI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to **GameObject | UI | Image**. After that, you will see that a new GameObject
    is created within the **Canvas** element. Unity will take care of setting any
    new UI element as a child of the Canvas; outside it, the element will not be visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_02_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: A default image UI element—a white box'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **2D** button in the top bar of the **Scene** view. This will
    just change the perspective of the **Scene** view to one that is better suited
    to edit the UI (and also 2D games):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, text, font, number  Description automatically
    generated](img/B21361_15_03_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: The 2D button location'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the Canvas in the **Hierarchy** window to make the UI fit entirely
    in the **Scene** view. This will allow us to edit the UI clearly. You can also
    navigate the UI using the mouse scroll wheel to zoom, and click and drag the scroll
    wheel to pan the camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **RectTransform** tool, which is the fifth button in the top-left
    part of the Unity Editor (or press the *T* key). This will enable the rectangle
    gizmo, which allows you to move, rotate, and scale 2D elements. While the transform
    tools we have used so far work with the UI, they are not ideal. One example is
    that changing the size of a UI element is not the same as scaling the element;
    we want to modify the width and height of the element but keep its scale for animations,
    preventing distortion in 9-sliced images (there’s more on this later in this chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, screenshot, design  Description automatically
    generated](img/B21361_15_04_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The rectangle gizmo button'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the rectangle gizmo, drag the object to move it, use the blue dots to
    change its size, or locate the mouse in a position near the blue dots until the
    cursor becomes a curved arrow to rotate it. Consider that resizing the object
    using this gizmo is not the same as scaling the object (there’ll be more on that
    shortly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_05_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The rectangle gizmo for editing 2D elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Inspector** window, notice that after changing the size of the UI
    element, the **Rect Transform** settings’ **Scale** property is still at `1`,
    `1`, `1`, but you can see how the **Width** and **Height** properties changed.
    **RectTransform** is essentially a classic transform but with **Width** and **Height**
    added (among other properties that we’ll explore later). You can set the exact
    values you want here, expressed in pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_06_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: The Rect Transform properties'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the very basics of how to position any UI object, let’s explore
    the different types of elements you can add to the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas object types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the simplest Canvas object type—a white box—but there are
    plenty of other object types we can use, such as images, buttons, and text. All
    of them use **RectTransform** to define their display area, but each one has its
    own concepts and configurations to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will explore the following Canvas object concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating assets for the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating UI controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s first start exploring how we can integrate images and fonts to use in
    our Canvas so that we can integrate them in our UI, using the **Images** and **Text**
    UI object types.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating assets for the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before making our UI use nice graphics assets, we need to integrate them properly
    into Unity to use them in our UI. In the following screenshot, you will find the
    UI design we propose for our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_07_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: UI design'
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we will add a **Pause** menu, which will be activated when
    the user presses *Esc*. It will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_08_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: The Pause menu design'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these designs, we can determine that we will need the following assets:'
  prefs: []
  type: TYPE_NORMAL
- en: The hero’s avatar image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A health bar image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Pause** menu background image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Pause** menu button image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Font for the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As always, we can find the required assets on the internet or in the Asset
    Store. In my case, I will use a mixture of both. Let’s start with the simplest
    one—the avatar. Follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the avatar you want from the internet, such as an image with the face
    of a character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to your project, either by dragging it to the **Project** window or by
    using the **Assets | Import New Asset** option. Add it to the `Sprites` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the texture, and in the **Inspector** window, set the **Texture Type**
    setting to **Sprite (2D and UI)**. All textures are prepared for use in 3D by
    default. This option prepares our texture to be used in 2D contexts, like the
    UI and also 2D games.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the bars, buttons, and the window background, I’ll show you how to pick
    the right assets from the Asset Store. It’s a goldmine for UI elements, and I’ll
    point out a few gems. In my case, I found the package in the following screenshot
    a good one to use with my UI. As usual, remember that this exact package might
    not be available right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If so, remember to look for another similar package, or pick the sprites from
    the GitHub repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a video game  Description automatically generated](img/B21361_15_09_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: Selected UI pack'
  prefs: []
  type: TYPE_NORMAL
- en: At first, the package contains lots of images configured the same way, as sprites,
    but we can further modify the import settings to achieve advanced behavior, which
    we will need for the buttons. The button asset comes with a fixed size, but what
    happens if you need a bigger button? One option is to use other button assets
    with different sizes, but this will lead to a lot of repetitions of the buttons
    and other assets, such as different-sized backgrounds for different windows, which
    will unnecessarily consume RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the **9-slicing** method, which consists of splitting
    an image so that the corners are separated from the other parts. This allows Unity
    to stretch the middle parts of the image to fit different sizes, keeping the corners
    at their original size, which, when combined with an image prepared for the 9-slices
    technique, can be used to create almost any size you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 15.10*, you can see a shape with nine slices in the bottom-left
    corner, and in the bottom-right corner of the same diagram, you can see the shape
    is stretched but keeps its corners at their original size. The top-right corner
    shows the shape stretched without slices. You can see how the non-sliced version
    is distorted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, rectangle, square, line  Description automatically
    generated](img/B21361_15_10_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: Sliced versus non-sliced image stretching'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can apply the nine slices to the button and the panel background
    images to use them in different parts of our game. In order to do this, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Package Manager using the **Window | Package Manager** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that Package Manager shows all the packages, by setting the dropdown
    to the right of the **+** button in the top-left part of the window to **Unity
    Registry**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the 2D Sprite package to enable the sprite editing tools (if it is not
    already installed).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the button sprite in the **Project** window, and click on the **Sprite
    Editor** button in the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_11_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: The Sprite Editor button in the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Sprite Editor** window, locate and drag the green dots at the edges
    of the image to move the slice rulers. Try to ensure that the slices are not located
    in the middle of the edges of the button. One thing to notice is that, in our
    case, we will work with three slices instead of nine because our button won’t
    be stretched vertically. If you don’t see the dots, try clicking the image to
    make them appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that after dragging the green dots, the **Border** properties (**L**, **T**,
    **R**, and **B**, which are left, top, right, and bottom, respectively) in the
    bottom-right corner changed. Those are the exact values you set by moving the
    green dots. Feel free to change them to more round numbers to allow the nine slices
    to work evenly. In our case, left and right became a round **60**, and top and
    bottom **50**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the **Apply** button in the top-right corner of the window and close
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_12_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: Nine slices in the Sprite Editor window'
  prefs: []
  type: TYPE_NORMAL
- en: Repeat *steps 4* to *6* for the **Background** panel image. In my case, you
    can see in *Figure 15.13* that this background is not completely prepared with
    nine slices in mind because all the middle areas of the image can be made smaller
    to save memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When displaying this image with a smaller width, the 9-slicing method will
    stretch the middle part and will look the same, so essentially, this is wasted
    memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_13_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: Nine slices in the Sprite Editor window'
  prefs: []
  type: TYPE_NORMAL
- en: By removing the middle parts, the image will look almost the same, but a big
    part of the memory was saved, as seen in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.14: Optimized 9-slices background. The middle part will be a 1px
    strip of pixels that will expand'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have prepared our sprites, we can find a font to customize the text
    of our UI. Before discussing how to import fonts, it is worth mentioning that
    we will use **TextMesh Pro**, a Unity package (already included in the project)
    that provides a text rendering solution much better than the old text component.
    If you have never used that component before, you shouldn’t worry about this detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must get fonts in the `.ttf` or `.otf` formats and import them into Unity.
    You can find lots of good, free font websites on the internet. I am used to working
    with the classic DaFont.com site, but there are plenty of other sites that you
    can use. In my case, I will work with the `Militech` font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot, graphics  Description automatically
    generated](img/B21361_15_15_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.15: My chosen font from DaFont.com to use in the project'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the font download comes with more than one file, you can just drag them
    all into Unity and then use the one that you like the most. Also, as usual, try
    to put the font inside a folder called `Fonts`. Now, these files’ format is not
    compatible with TextMesh Pro, our text rendering solution, so we must convert
    it using the **Font Asset Creator** window, as illustrated in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Window | TextMesh Pro | Font Asset** Creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If this is the first time you have used TextMesh Pro in your project, a window
    will appear. You must click the **Import TMP Essentials** option and wait for
    the import process to finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_16_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.16: TextMesh Pro first-run initialization'
  prefs: []
  type: TYPE_NORMAL
- en: Close the **TMP Importer** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Font Asset Creator**, drag your font from the **Project** view to **Source
    Font File**, or select it by clicking the **Target** button on the right (the
    circle with the point at the center).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Generate Font Atlas** button and wait a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_17_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.17: Converting font assets to TextMesh Pro'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Save** button, and save the converted font in the **Assets | TextMesh
    Pro | Fonts** folder. Saving here is important, so don’t forget to pick the correct
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.18: Saving the converted font in the correct folder (Mac)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve got the groundwork set up. Let’s add more elements and see our UI come
    to life. The skills you’re learning here will be invaluable as you progress to
    the later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Creating UI controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each UI component, a blend of images and text, needs thoughtful configuration.
    Let’s dive into how these elements come together to form an intuitive interface.
    We already have an image in our UI—the white rectangle we created previously.
    If you select it and look at the **Inspector** window, you will notice that it
    has an **Image** component, like the one in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_19_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.19: The Image component’s Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding these settings is crucial for optimal UI display. We’ll begin
    with the hero’s avatar, focusing on how to best represent it within our UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the rectangle gizmo, move the white rectangle to the top-left part of
    the UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing screenshot, rectangle, line, square  Description automatically
    generated](img/B21361_15_20_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.20: The white rectangle located in the top-left part of the UI'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Inspector** window, click on the circle to the right of the **Source
    Image** property and pick the downloaded hero avatar sprite:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_15_21_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.21: Setting the sprite of our Image component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the right aspect ratio ensures the image looks consistent on different
    screen sizes, avoiding any visual distortion. One way to do this is to click the
    **Set Native Size** button at the bottom of the Ima**ge** component to make the
    image use the same size as the original sprite. However, by doing this, the image
    can become too big, so you can reduce the image size by pressing *Shift* to modify
    both the **Width** and **Height** values. Another option is to check the **Preserve
    Aspect** checkbox to make sure the image fits the rectangle without stretching.
    In my case, I will use both:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with medium
    confidence](img/B21361_15_22_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.22: The Preserve Aspect and Set Native Size image options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an intuitive life bar is crucial for the player experience. Let’s
    create the life bars by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create another **Image** component using the **GameObject** | **UI** | **Image**
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the **Source Image** property to the life bar image you downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_23_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.23: The avatar and life bar'
  prefs: []
  type: TYPE_NORMAL
- en: Set the **Image Type** property to **Filled**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Fill Method** property to **Horizontal**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the **Fill Amount** slider to see how the bar is cut according to the
    value of the slider. We will change that value via scripting later in *Chapter
    18*, *Performance Wizardry: Optimizing Your Game with Profiler Tools*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_24_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.24: The Fill Amount slider, cutting the image width to 73% of its
    size'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my case, the bar image also comes with a bar frame, which lets you create
    another image, set the sprite, and position it on top of the life bar to frame
    it. The order in the hierarchy here impacts the visual stacking of these elements.
    This positioning is key for achieving the desired visual effect. So, in my case,
    I need to be sure the frame GameObject is below the health bar image in the hierarchy.
    Also, note that the bar frame image is not sliced, so there’s no need to use the
    **Sliced** **Image** **Type** in this case. Feel free to try slicing it and see
    the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_25_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.25: Putting one image on top of the other to create a frame effect'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat *steps 1* to *6* to create the base bar at the bottom, or just copy
    and paste the bar and the frame and place it at the bottom of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_26_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.26: The player’s and player’s base health bars'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **+** button in the **Project** window and select the **Sprites**
    | **Square** option. This will create a simple squared sprite with a 4x4 resolution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the sprite as the base bar of the player’s base health bar instead of the
    downloaded bar sprite. This time, we will use a plain-white image for the bar
    because, in my case, the original one is red, and tinting the color of a red image
    to green is not possible. However, a white image can be easily tinted. Take into
    account the details of the original bar—for example, the little shadow in my original
    bar won’t be present here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the base health bar and set the **Color** property to green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_27_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.27: A bar with a squared sprite and green tint'
  prefs: []
  type: TYPE_NORMAL
- en: One optional step would be to convert the bar frame image into a 9-sliced image
    to allow us to change the original width to fit the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s add the text fields for the **Score**, **Bullets**, **Remaining
    Waves**, and **Remaining Enemies** labels by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a text label using the **GameObject** | **UI** | **Text - TextMesh Pro**
    option (avoid the option that only says **Text**). This will be the **Score**
    label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Position the label in the top-right part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Inspector** window, set the content of the **Text Input** property
    to `Score: 0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Font Size** property to `20`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the converted font by clicking on the circle to the right of the **Font
    Asset** property and selecting the desired font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Alignment** property, select the **Horizontal Right Align** icon (the
    third button in the first row) and the **Vertical Center Align** icon (the second
    button in the second row):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_28_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.28: The settings for a text label'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat *steps 1* to *6* to create the other three labels (or just copy and
    paste the score three times). For the **Remaining Waves** label, you can use the
    left alignment option to better match the original design:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_29_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.29: All the labels for our UI'
  prefs: []
  type: TYPE_NORMAL
- en: Set the color of all the labels to white, as our scene will be mainly dark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have completed the original UI design, we can create the **Pause**
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an **Image** component for the menu’s background (**GameObject** | **UI**
    | **Image**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Background** panel sprite with the nine slices we made earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Image Type** property to **Sliced** if it is not already. This mode
    will apply the 9-slice scaling method to prevent the corners from stretching.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a chance that the image will stretch the corners anyway, which happens
    because sometimes the corners are quite big compared to the **RectTransform**
    settings’ **Size** property that you are using, so Unity has no option other than
    to do that. In this scenario, the correct solution is to have an artist who creates
    assets tailored to your game, but sometimes we don’t have that option. This time,
    we can just increase the **Pixels Per Unit** value of the sprite file, which will
    reduce the scale of the original image while preserving its resolution. In the
    following two screenshots, you can see the background image with a **Pixels Per
    Unit** value of `100`, and then again with `700`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remember to only do this for the 9-sliced or tiled-image types, or if you don’t
    have an artist to adjust it for you:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![A screenshot of a video game  Description automatically generated](img/B21361_15_30_PE.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 15.30: On top, a large 9-sliced image in a small RectTransform component,
    which is small enough to shrink the corners, and at the bottom, the same image
    with Pixels Per Unit set to 700'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a **TextMesh Pro** text field, position it where you want the **Pause**
    label to be in your diagram, set it to display the **Pause** text, and set the
    font. Remember that you can change the text color with the **Color** property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the text field onto the background image. The parenting system in **Canvas**
    works the same—if you move the parent, the children will move with it. The idea
    is that if we disable the panel, it will also disable the buttons and all its
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_31_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.31: The Pause label'
  prefs: []
  type: TYPE_NORMAL
- en: Create two buttons by going to **GameObject** | **UI** | **Button - TextMesh
    Pro** (avoid using the one that only says **Button**). Position them where you
    want them on the background image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set them as children of the **Pause** background image by dragging them into
    the **Hierarchy** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the buttons, and set the **Source Image** property of their **Image**
    components to use the button sprite that we downloaded earlier. Remember our **Pixels
    Per Unit** fix from *step 4* in this list if you have the same problem as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see that the button is essentially an image with a child **TextMesh
    Pro** text object. Change the font of each button and the text in each one to
    `Resume` and `Quit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_32_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.32: The Pause menu implementation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that you can hide the panel, by unchecking the checkbox to the right
    of the object name in the top part of the **Inspector** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer menu  Description automatically generated with
    medium confidence](img/B21361_15_33_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.33: Disabling a GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: Today, I still remember my first sessions of playtesting, where I handed my
    game over to unknown people with the dream of amazing them with my great game,
    just to discover it wasn’t quite the case. Among lots of things you will discover
    that are missing in your game is User Experience (also known as UX). The key to
    it is to understand how the game flow feels and improve it. While the UX is not
    restricted to the UI only, I recommend researching this concept before designing
    UIs for your game, as it will help your user to better understand your game and
    the information the UI tries to give.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how to import images and fonts to be integrated
    through the **Image**, **Text**, and **Button** components to create a rich and
    informative UI. Having done that, let’s discuss how to make them responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a responsive UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it is almost impossible to design a UI in a single resolution, and
    our target audience display devices can vary a lot. A PC has a variety of different
    kinds of monitors with different resolutions (such as 1080p and 4K) and aspect
    ratios (such as 16:9, 16:10, and ultra-wide), and the same goes for mobile devices.
    We need to prepare our UI to adapt to the most common displays, and Unity UI has
    the tools needed to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will explore the following UI responsiveness concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapting object positions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapting object sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to explore how the UI elements can adapt their position and size
    to different screen sizes using the advanced features of the **Canvas** and **RectTransform**
    components, such as **Anchors** and **Scalers**.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting object positions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To ensure our UI adjusts correctly across different devices, let’s focus on
    adapting object positions using anchors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, if we play our game, we will see how the UI fits nicely onto our
    screen. However, if for some reason we change the **Game** view size, we will
    see how objects start to disappear from the screen. In the following screenshots,
    you can see different-sized game windows and how the UI looks nice in one but
    bad in the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_34_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.34: The same UI but on different-sized screens'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we created the UI using whatever resolution we had in the
    editor, but as soon as we changed it slightly, the UI kept its design for the
    previous resolution. Also, if you look closely, you will see that the UI is always
    centered, such as in the second image, where the UI is cropped at its sides, or
    in the third image, where extra space is visible along the borders of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens because every single element in the UI has its own anchor, a little
    cross you can see when you select an object, such as the one in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_35_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.35: An anchor cross in the bottom-right part of the screen belonging
    to the hero avatar in the top-left part of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: The *x* and *y* position of the object is measured as a distance to that anchor,
    and the anchor has a position relative to the screen, with its default position
    being at the center of the screen. This means that on an *800 x 600* screen, the
    anchor will be placed at the *400 x 300* position, and on a *1920 x 1080* screen,
    the anchor will be located at the *960 x 540* position. If the *x* and *y* position
    of the element (the one in **RectTransform**) is **0**, the object will always
    be at a distance of 0 from the center. In the second screenshot of the previous
    three examples, the hero avatar falls outside of the screen because its distance
    from the center is greater than half the screen, and the current distance was
    calculated based on the previous bigger screen size. So, what we can do about
    that? Move the anchor!
  prefs: []
  type: TYPE_NORMAL
- en: By setting a relative position, we can position the anchor at different parts
    of our screen and make that part of the screen our reference position. In the
    case of our hero avatar, we can place the anchor in the top-left corner of the
    screen to guarantee that our avatar will be at a fixed distance from that corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select your player avatar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **RectTranform** component in **Inspector**, if not expanded yet,
    in a way that you can see its properties. This will reveal the anchors in the
    **Scene** view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the anchor cross with your mouse to the top-left part of the screen. If,
    for some reason, the anchor breaks into pieces when you drag it, undo the change
    (press *Ctrl* + *Z*, or *Command* + *Z* on Mac) and try to drag it by clicking
    in the center. We will break the anchor later. Check the avatar image **RectTransform**
    component to verify that the **Anchors** property’s **Min** and **Max** sub-properties
    have the same values as in *Figure 15.36*, meaning the object has correctly configured
    the anchors to be in the top-left part of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_36_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.36: An image with an anchor in the top-left part of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: Put the anchor of the **Health Bar** object and its frame in the same position.
    We want the bar to always be at the same distance from that corner so that it
    will move alongside the hero avatar if the screen size changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the anchor in the bottom-center part of the screen for the **Boss Bar**
    object so that it will always be centered. Later, we will deal with adjusting
    its size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the **Remaining Waves** label in the bottom-left corner, and **Remaining
    Enemies** in the bottom-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_37_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.37: The anchors for the life bar and the labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the **Score** and **Bullets** anchors in the top-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_38_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.38: The anchors for the Score and Bullets labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select any element, and drag the sides of the Canvas rectangle with your mouse
    to preview how the elements will adapt to their positions. Take into account that
    you must select any object that is a direct child of the Canvas; the text within
    the buttons won’t have that option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_39_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.39: Previewing the Canvas resizing'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our UI elements have adapted to their positions, let’s consider scenarios
    where the object size must adapt as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting object sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to consider when dealing with different aspect ratios is that
    our screen elements may not only move from their original design position (which
    we fixed in the previous section) but also may not fit into the original design.
    In our UI, we have the case of the health bar, where the bar clearly doesn’t adapt
    to the screen width when we preview it on a wider screen. We can fix this by breaking
    our anchors.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we break our anchors, the position and size of our object are calculated
    as a distance relative to the different anchor parts. If we split the anchor horizontally,
    instead of having **X** and **Width** properties we will have **Left** and **Right**
    properties, representing the distance between the left and right anchor. We can
    use this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the health bar, and drag the left part of the anchor all the way to the
    left part of the screen and the right part to the right part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same for the health bar frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_40_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.40: The splitter anchor in the health bar'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the **Rect Transform** settings’ **Left** and **Right** properties in
    the **Inspector** window, which represent the current distance to their respective
    anchors. If you want, you can add a specific value, especially if your health
    bars are displayed outside the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_41_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.41: The Left and Right properties of a split anchor'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Canvas Scaler effectively helps maintain UI element proportions across
    various resolutions, a crucial aspect of modern game design.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, the object will always be at a fixed distance of a relative position
    to the screen—in this case, the sides of the screen. If you are working with a
    child object, as is the case with the **Text** and **Image** components of the
    buttons, the anchors are relative to the parent. If you pay attention to the anchors
    of the text, they are not only split horizontally but also vertically. This allows
    the text to adapt its position to the size of the button, so you won’t have to
    change it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_42_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.42: The split anchors of the text of the button'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this solution is not suitable for all scenarios. Let’s consider a case
    where the hero avatar is displayed in a higher resolution than what it was designed
    for. Even if the avatar is correctly placed, it will be displayed smaller because
    the screen has more pixels per inch than screens with lower resolutions and the
    same physical size. You could consider using split anchors, but the width and
    height anchors could be scaled differently on different aspect ratio screens,
    so the original image becomes distorted. Instead, we can use the **Canvas Scaler**
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The **Canvas Scaler** component defines what one pixel means in our scenario.
    If our UI design resolution is 1080p but we see it on a 4K display (which is twice
    the horizontal and vertical resolution of 1080p, meaning four times the number
    of pixels), we can scale the UI so that a pixel becomes two pixels, adapting its
    size to keep the same proportional size as the original design. Basically, the
    idea is that if the screen is bigger, our elements should also be bigger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this component by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Canvas** object, and locate the **Canvas Scaler** component in
    the **Inspector** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **UI Scale Mode** property to **Scale With Screen Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If working with an artist, set the reference resolution to the resolution in
    which the artist created the UI, keeping in mind that it must be the highest target
    device resolution (this isn’t the case for us). In our case, we are not sure which
    resolution the artist of the downloaded assets had in mind, so we can select `1920
    x 1080`, which is the full HD resolution size and is very common nowadays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Match** property to **Height**. The idea of this property is that
    it sets which side of the resolution will be considered when carrying out the
    scaling calculation. In our case, if we are playing the game in 1080p resolution,
    1 UI pixel equals 1 real screen pixel. However, if we are playing in 720p resolution,
    1 UI pixel will be 0.6 real pixels, so the elements will be smaller on smaller-resolution
    screens, keeping the correct size. We didn’t choose a **Width** value in this
    case because we can have extreme widths of screens, such as ultra-wide, and if
    we picked that option, those screens would scale the UI unnecessarily. Another
    option is to set this value to `0.5` to consider the two values, but on a PC,
    this doesn’t make too much sense. On a mobile device, you should choose this based
    on the orientation of the game, setting the height for landscape mode and the
    width for portrait mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try previewing a wider and higher screen to see how this setting works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screenshot of a computer  Description automatically generated with low
    confidence](img/B21361_15_43_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.43: Canvas Scaler with the correct settings for standard PC games'
  prefs: []
  type: TYPE_NORMAL
- en: You will find that your UI will be smaller than your original design, which
    is because we should have set these properties before. Right now, the only fix
    is to resize everything again. Take this into account the next time you try this
    exercise; we only followed this order for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to make your UI adapt to its contents is by using layout components,
    like Horizonal Layout. These components will automatically adapt the size and
    position of their child elements to follow certain rules, like making sure all
    elements are next to each other. This is especially useful in things like item
    lists, where you add and remove elements, and you can expect the list to adapt
    to these changes. For more info, check out this documentation: [https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html](mailto:https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/comp-UIAutoLayout.html)'
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now ready to start scripting the UI to reflect
    what’s happening in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We previously created a UI layout with elements such as bars, text, and buttons,
    but so far, they are static. We need to make them adapt to the game’s actual state.
    In this section, we are going to discuss the following UI scripting concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing information in the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming the Pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by seeing how to display and update dynamic information in our
    UI, using scripts that modify the text and images that are displayed with Canvas
    elements. After that, we will create thepause functionality, which will be used
    throughout the UI. Developing the pause functionality is more than just adding
    a feature; it’s about enhancing user control and game interaction, a key aspect
    of the UX.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this understanding, you’re set to bring your game’s UI to an interactive
    level. It’s time to make your UI not just a visual element but also an integral
    part of your game’s storytelling.
  prefs: []
  type: TYPE_NORMAL
- en: Showing information in the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve touched on using the UI to convey critical game data. Now, let’s dive
    into the practical aspect: scripting the UI to dynamically reflect the player’s
    health status in real time, using the `Life` script we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new script called **Life Bar** to the **HealthBar** Canvas child object,
    which is the UI **Image** component we created earlier to represent the life bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_44_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.44: The Life Bar component in the player’s HealthBar Canvas'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `LifeBar`, the script adds a `Life` type field. This way, our script will
    ask the editor which `Life` component we will be monitoring. Save the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_45_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.45: Editor-configurable reference to a Life component'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the editor, drag the **Player** GameObject from the **Hierarchy** window
    to the **Target Life** property to make the life bar reference the player’s life,
    and remember to have the **HealthBar** object selected before dragging **Player**.
    This way, we tell our **LifeBar** script which Life component to check to see
    how much life the player has remaining. Something interesting here is that the
    enemies have the same Life component, so we can easily use this component to create
    life bars for every other object that has a life in our game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A screen shot of a computer  Description automatically generated with low
    confidence](img/B21361_15_46_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.46: Dragging Player to reference its Life component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `using UnityEngine.UI;` line right after the `using` statements in
    the first few lines of the script. This will tell C# that we will interact with
    the UI scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_47_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.47: All the using statements in our script. We are not going to use
    them all, but let’s keep them for now'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `private` field (without the `public` keyword) of the `Image` type.
    We will save the reference to the component here shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_48_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.48: Private reference to an image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `GetComponent` in `Awake`, access the reference to the `Image` component
    in our GameObject (`HealthBar`) and save it in the `image` field. As usual, the
    idea is to get this reference just once and save it for later use in the `Update`
    function. Of course, this will always work when you put this component in an object
    with an `Image` component. If not, the other option would be to create a public
    field of the `Image` type and drag the image component into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing text, font, screenshot, line  Description automatically
    generated](img/B21361_15_49_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.49: Saving the reference to the Image component in this object'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up an `Update` event function in the `LifeBar` script. This function
    will be the heart of our UI update logic, keeping the health bar in sync with
    the player’s health.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Update` event, divide the amount of life by `100` to have our current
    life percentage expressed in the `0` to `1` range (assuming our maximum life is
    `100`), and set the result in the `fillAmount` field of the `Image` component,
    as shown in the following screenshot. Remember that `fillAmount` expects a value
    between `0` and `1`, with `0` signaling that the bar is empty and `1` signaling
    that the bar is at its full capacity:![A picture containing text, font, screenshot,
    line  Description automatically generated](img/B21361_15_50_PE.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 15.50: Updating the fill amount of the LifeBar script’s Image component
    according to the Life component'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a specific number like 100 directly in the code is a classic example of
    hardcoding. To maintain flexibility, consider referencing a `Maximum Life` field
    or using a constant.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save the script, and in the editor, select the player and play the game. During
    **Play** mode, press *Esc* to regain access to the mouse, and change the player’s
    health in the **Inspector** window to see how the life bar updates accordingly.
    You can also test this by making the player receive damage somehow, such as by
    making enemies spawn bullets (there’ll be more on enemies later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_51_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.51: Full LifeBar script'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we explored the concept of events to detect changes
    in the state of other objects. The life bar is another example of using an event,
    as we can change the fill amount of the image when the life actually changes.
    I challenge you to try to create an event when the life changes and implement
    this script using the one we looked at in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking that this UI behavior could be directly coded within the
    `Life` component, and that’s completely possible, but the idea here is to create
    simple scripts with little pressure to keep our code separated. Each script should
    have just one reason to be modified, and mixing UI behavior and gameplay behavior
    in a single script would give the script two responsibilities, which results in
    two possible reasons to change our script. With this approach, we can also set
    the player’s base life bar at the bottom by just adding the same script to its
    life bar but dragging the **Base Damage** object, which we created in the previous
    chapter, as the target life this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those using visual scripting, here’s a breakdown of what you’ll need to
    integrate. It’s about translating our C# logic into a more visual, node-based
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_52_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.52: Full LifeBar visual graph'
  prefs: []
  type: TYPE_NORMAL
- en: First, we added a `targetLife` variable of type `GameObject` to the **Variables**
    component of our life bar image. Then, we dragged our **Player** GameObject (called
    **Robot** so far) to this variable; the life bar now has a reference to the object
    from which we want to display its life. Then, we added a **LifeBar** visual graph;
    in the **Update** node, it calls the **Set Fill Amount** node in order to update
    the fill amount of the image. Remember that, in this case, just calling the **Set
    Fill Amount** node will show that we refer to the image component where this visual
    graph is located, so there’s no need to use **GetComponent** here. In order to
    calculate the fill amount, we get the **targetLife** GameObject reference, and,
    using a second **Get Variable** node, we extract the life variable of that object.
    Finally, we divide that by 100 (we needed to create a **Float Literal** node in
    order to represent the value **100**) and pass that to the **Set Fill Amount**
    node. As usual, you can check the complete version on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: The principle we applied here – single object responsibility – is part of the
    broader **SOLID** principles in object-oriented programming. These principles
    are foundational for robust and scalable code architecture. If you don’t know
    what SOLID is, I strongly recommend you search for `SOLID programming principles`
    on the internet to improve your programming best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have sorted out the player’s life bar, let’s make the `Bullets`
    label update according to the player’s remaining bullets. Something to consider
    here is that our current `PlayerShooting` script has unlimited bullets, so let’s
    change that by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a public `int` type field to the `PlayerShooting` script, called `bulletsAmount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `if` statement that checks the pressure of the left mouse button, add
    a condition to check whether the number of bullets is greater than `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `if` statement, reduce the number of bullets by `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_53_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.53: Limiting the number of bullets to shoot'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the visual scripting version, the modified shooting condition of the **PlayerShooting**
    visual graph will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_54_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.54: Shooting only if bullets are available and reducing the number
    of bullets after shooting'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we simply check if the new **bullets** variable we added is
    greater than zero and then use an **If** node condition for the execution of the
    **Instantiate** node. The bullet decrement will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_55_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.55: Decrementing the bullet count in the visual graph'
  prefs: []
  type: TYPE_NORMAL
- en: We simply subtract one from the **bullets** variable and set the bullets again
    with this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a dedicated counter for bullets in place, our next step is to bring this
    element to life in the UI. Visualizing the bullet count is not just a feature
    – it’s an essential aspect of gameplay that keeps players tactically aware:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `PlayerBulletsUI` script to the bullet’s `Text` GameObject. In my case,
    I called it `Bullets Label`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `using TMPro;` statement at the beginning of the file, given that we
    will modify the `TextMesh Pro` component of our label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a private field of the `TMP_Text` type, saving it in the reference to the
    `Text` component in `Awake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_56_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.56: Caching the reference to the Text component'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `public` field of the `PlayerShooting` type called `targetShooting`,
    and drag **Player** to this property in the Editor. As was the case for the `LifeBar`
    component, the idea is that our UI script will access the script that has the
    remaining bullets to update the text, bridging the two scripts (`Text` and `PlayerShooting`)
    to keep their responsibilities separated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `Update` statement, and inside it, set the `text` field of the text
    reference (I know, confusing) with a concatenation of `"Bullets: "` and the `bulletsAmount`
    field of the `targetShooting` reference. This way, we will replace the text of
    the label according to the current amount of bullets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![A picture containing chart  Description automatically generated](img/B21361_15_57_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.57: Updating the Bullets text label'
  prefs: []
  type: TYPE_NORMAL
- en: A key coding principle to remember is that string concatenation allocates memory.
    To maintain optimal performance, it’s prudent to concatenate strings only when
    it’s essential – a strategic approach to memory management in game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding visual scripting, before actually setting the text, we need to add
    support for TextMesh Pro in visual scripting. Visual scripting requires manually
    specifying which Unity systems and packages we are going to use, and as TextMesh
    Pro is not strictly a core Unity feature, it might not be included by default.
    We can add support for TextMesh Pro in visual scripting by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Edit | Project Settings** and select the **Visual Scripting** category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Node Library** option using the arrow to its left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if you have **Unity.TextMesh Pro** in that list. If you do, feel free
    to skip the rest of these steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **+** button at the bottom of the list to add a new library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click where it says (**No Assembly**), and search for **Unity.TextMesh Pro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Regenerate Nodes** button, and wait until the regeneration process
    is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B21361_15_58_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.58: Adding TextMesh Pro support to visual scripting'
  prefs: []
  type: TYPE_NORMAL
- en: 'After making those settings, this is what the visual graph to add to the **Bullets**
    text GameObject will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_59_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.59: Updating the Bullets text label in visual scripting'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we need a reference to the player to check its bullets, so we created
    a `targetBullets` variable of type **GameObject** and dragged the **Player** there.
    Then, we use a **Get Variable** node to extract the bullets amount from that reference
    and concatenate the string `"Bullets: "`, using the **String Literal** node, with
    the amount of bullets using the **Concat** node. That node will do the same as
    when we added two strings together using the **+** operator in C#. Finally, we
    use the **Set Text (Source Text, Sync Text InputBox)** node to update the text
    of our text field.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the two scripts, you will find a pattern. You can access the
    **UI** and **Gameplay** components and update the **UI** component accordingly,
    and most UI scripts will behave in the same way. Keeping this in mind, I challenge
    you to create the necessary scripts to make the **Score**, **Enemies**, and **Waves**
    counters work. Remember to add `using TMPro;` to use the `TMP_Text` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing this, you can compare your solution with the one in the following
    screenshot, starting with `ScoreUI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_60_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.60: The ScoreUI script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need the `WavesUI` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_61_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.61: The WavesUI script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need `EnemiesUI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_62_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.62: The EnemiesUI script'
  prefs: []
  type: TYPE_NORMAL
- en: Note how we took advantage of the existence of the **onChanged** events in the
    **WavesManager** and **EnemyManager** scripts to only update the text fields when
    needed. Also, note how we didn’t need to drag a reference to get the values to
    display, as all these scripts use managers to get that info.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding visual scripting, we have the **ScoreUI** script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_63_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.63: The ScoreUI visual script'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the **WavesUI** script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_64_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.64: The WavesUI visual script'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the **EnemiesUI** script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_65_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.65: The EnemiesUI visual script'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have used the events already coded in the managers to change
    the UI only when necessary. Also, note how we used **Scene** variables to get
    the info to display. With our UI labels and bars in place, our next step is to
    bring the Pause menu to life. This involves scripting interactions that enhance
    the game’s interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Programming the Pause menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s revisit our previously designed Pause menu, which is ready to be brought
    to life. Coding a pause feature might seem intricate, but with a strategic approach,
    we can simplify the process. So again, we will use a simple approach to pause
    most behaviors, which is stopping time! Remember that most of our movement scripts
    use time functionality, such as **Delta Time** (which we discussed in *Chapter
    2*, *Crafting Scenes and Game Elements*), as a way to calculate the amount of
    movement to apply. There is also a way to simulate time going slower or faster,
    which is by setting `timeScale`. This field will affect Unity’s time system’s
    speed, and we can set it to `0` to simulate that time has stopped, which will
    pause animations, stop particles, and reduce **Delta Time** to `0`, making our
    movements stop. So let’s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a script called `Pause`, and add it to a new GameObject called `Pause`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `using UnityEngine.InputSystem;` statement at the beginning of the script
    file to be able to read input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Update`, detect when the *Esc* key is pressed. We can add a mapping to
    our **Player Input** asset file and read the input, as we did in *Chapter 2*,
    *Crafting Scenes and Game Elements*, but to learn a new way of using the input
    system, we will use the `Keyboard.current` variable to directly read the state
    of a key in the **Update** method, instead of using mapping. Consider that it
    is always recommended to use input mapping, but let’s do this for learning purposes.
    You can set the `Time.timeScale` variable to `0` when the *Esc* key is pressed,
    as you can see in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21361_15_66_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.66: Stopping time to simulate a pause'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save and test this by playing the game and pressing the *Esc* key. You will
    notice that almost everything will stop, like animations of characters’ movement,
    but you can see how the shoot functionality still works. That’s because the `PlayerShooting`
    script is not time-dependent. One solution here could be to simply check whether
    `Time.timeScale` is greater than `0` to prevent this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_67_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.67: Checking Pause in the player shooting script'
  prefs: []
  type: TYPE_NORMAL
- en: The same needs to be done in our `EnemyFSM` `Shoot` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As usual, we have pursued the simplest way here, but there is a better approach.
    I challenge you to try to create `PauseManager` with a Boolean, indicating whether
    the game is paused or not and changing `timeScale` in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a simple but effective way to pause the game, let’s make the
    **Pause** menu visible to resume the game by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a field of the `GameObject` type, called `pauseMenu`, in the `Pause` script.
    The idea is to drag the **Pause** menu here so that we have a reference to enable
    and disable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Awake`, add `pauseMenu.SetActive(false);` to disable the **Pause** menu
    at the beginning of the game. Even if we disabled the **Pause** menu in the Editor,
    we add this just in case we re-enable it by mistake. It must always start as disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the same function but passing `true` as the first parameter, enable the
    **Pause** menu in the *Esc* key pressure check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_68_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.68: Enabling the Pause menu when pressing the Esc key'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make the **Pause** menu buttons work. If you recall, we explored
    the concept of events, implementing them with UnityEvents in the different managers.
    Our **Pause** menu buttons use the same class to implement the `onClick` event,
    which is an event that informs us that a specific button has been pressed. Let’s
    resume the game when pressing those buttons by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a field of the `Button` type in our `Pause` script called `resumeButton`,
    and drag `resumeButton` to it; this way, our `Pause` script has a reference to
    the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Awake`, add a listener function called `OnResumePressed` to the `onClick`
    event of `resumeButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make the `OnResumePressed` function set `timeScale` to `1` and disable the
    **Pause** menu, as we did in `Awake`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_69_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.69: Unpausing the game'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you save and test this, you will notice that you cannot click the **Resume**
    button because we disabled the cursor at the beginning of the game, so make sure
    you re-enable it while in `Pause` mode and disable it when you resume:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_70_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.70: Showing and hiding the cursor while in pause mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'One final thing to consider is that we want to set the time scale to `1` again
    on the **OnDestroy** method. This method gets executed when the **Pause** object
    is destroyed, which will happen when we manually destroy the object via scripting
    or, most importantly in this case, if we change scenes. The idea is to make sure
    to resume the time system if we change scenes while in the **Pause** menu so that
    the next scene can play the game properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated with medium
    confidence](img/B21361_15_71_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.71: Resetting the time scale when leaving the scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the visual scripting version of the **Pause** script, note that we
    don’t have an equivalent to `Keyboard.current`, so we will need to replace using
    the input mappings. In order to add an input mapping for the *Esc* key, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the **Player Input** asset to edit it. You can find it by selecting
    the **Player** GameObject, and then clicking the box at the right of the **Actions**
    property of the **PlayerInput** component in the Inspector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the **+** button in the top-right corner of the **Actions** list (the
    middle list), create a new action called `Pause`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, table  Description automatically generated](img/B21361_15_72_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.72: Creating a new input mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **<No Binding>** item inside the **Pause** action we just created
    (below it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Path** property in the **Binding Properties** section (on the right
    side of the screen), click the empty rectangle at its left, and search and select
    the **Escape [Keyboard]** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_73_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.73: Adding a key to the mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Save Asset** button in the top-middle part of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you can add the following graph, this time to the **Player** GameObject,
    as we need to read input from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21361_15_74_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.74: Pausing when Esc is pressed'
  prefs: []
  type: TYPE_NORMAL
- en: So far, nothing new; we detect that *Esc* is pressed, when it happens, we call
    **Set Time Scale** and specify the `0` value. Then, we activate the **Pause**
    menu (having a reference via a variable, `pauseMenu`, in the **Variables** component),
    and we enable the cursor. Finally, we set the time scale to `1` when the object
    is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the **Resume** behavior, the nodes to add to the same **Pause** graph
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21361_15_75_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.75: Unpausing when the Resume button is clicked'
  prefs: []
  type: TYPE_NORMAL
- en: The only new element on this graph is the usage of the **On Button Click** node.
    As you might expect, that node is an event, and anything connected to it will
    execute under the pressure of a button. The way to specify which button we refer
    to is by connecting the **Button** reference variable to the input pin of **On
    Button Click**. You can see how we created a variable of type **Button** called
    `resumeButton` in the **Variables** component to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to code buttons, I challenge you to code the `Exit` button’s
    behavior. Again, remember to add `using UnityEngine.UI`. Also, you will need to
    call `Application.Quit();` to exit the game, but take into account that this will
    do nothing in the editor; we don’t want to close the editor while creating the
    game. This function only works when you build the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for now, just call it, and if you want to print a message to be sure that
    the button works properly, you can; a solution is provided in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, chat or text message  Description
    automatically generated](img/B21361_15_76_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.76: The Quit button script'
  prefs: []
  type: TYPE_NORMAL
- en: This solution proposes that you add this script directly to the **Quit** button
    GameObject itself so that the script listens to the `onClick` event on its `Button`
    sibling component and, when receiving the event, it executes the `Quit` function.
    You could also add this behavior to the `Pause` script, and while that will work,
    remember that if a script can be split into two because it does two unrelated
    tasks, it is always best to split it so that separate behavior is unrelated. Here,
    the pause behavior is not related to the quit behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the visual scripting version, the graph to add to the **Quit** button
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21361_15_77_PE.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.77: The Quit button visual script'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, right? As we put this in the button itself, we don’t even need to specify
    which button it is, as it automatically detects that we refer to ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our pause system set up using the UI and buttons, we are ready
    for the next chapter, where we will continue to look at other visual and auditive
    ways to make our player aware of what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the basics of the UI, understanding the **Canvas**
    and **RectTransform** components to locate objects onscreen and create a UI layout.
    We also covered different kinds of UI elements, mainly **Image** and **Text**,
    to give life to our UI layout and make it appealing to the user. Finally, we discussed
    how to adapt UI objects to different resolutions and aspect ratios to make our
    UI adapt to different screen sizes, even though we cannot predict the exact monitor
    our user will play the game on. All of this allows us to create any UI we will
    need in our game using the Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to create UIs using UI Toolkit instead,
    another Unity system to create UIs, and compare both the Canvas and UI Toolkit
    to see when to use which.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read this book alongside other users, Unity game development experts, and the
    author himself. Ask questions, provide solutions to other readers, chat with the
    author via Ask Me Anything sessions, and much more. Scan the QR code or visit
    the link to join the community:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/unitydev](https://packt.link/unitydev)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1498477041053909218.png)'
  prefs: []
  type: TYPE_IMG
