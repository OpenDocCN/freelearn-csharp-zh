- en: HTTP in .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In each of the previous chapters, we explored the fundamental building blocks
    with which network software is built. In this chapter, we'll use those building
    blocks to construct an application that leverages the most common network protocol,
    **Hypertext Transfer Protocol** (**HTTP**). We'll re-examine where in the **Open
    Systems Interconnection** (**OSI**) network stack HTTP falls, and why it is categorized
    as such. We'll more deeply consider the conventions around HTTP requests and responses,
    and spend some time exploring request, response, and content headers. We'll demonstrate
    how to use standard headers for specifying the content you want from an external
    HTTP resource, and how custom headers can be used to toggle specific features
    and functions of your application. Lastly, we'll explore how to serve content
    over the protocol to service HTTP requests made to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The background for the HTTP protocol, and the strengths and limitations of its
    specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP request methods, including how to generate, and respond to, those requests
    out of the box with C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to construct `HttpRequestMessage`, or use `HttpClient` to send requests,
    and the various classes available for responding to requests with a valid HTTP
    response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How HTTPS is implemented in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New features supported by HTTP/2 and how to leverage those features in .NET
    Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be using sample applications available in the GitHub
    repository for the book here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    9](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%209).
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be using each of the tools we leveraged in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*. So, if you didn't take the time to install and start working
    with them before, I suggest you do so now. Specifically, I recommend installing
    Postman from here: [https://www.getpostman.com/apps](https://www.getpostman.com/apps).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use the Insomnia REST client, which can be found here: [https://insomnia.rest/](https://insomnia.rest/)[.](https://insomnia.rest/)
  prefs: []
  type: TYPE_NORMAL
- en: And, while it's not going to be featured heavily in this chapter, since deployment
    options will fall outside the scope of this chapter, I would encourage you to
    use this opportunity to begin working with Docker. I'll point out opportunities
    to modify and extend your Dockerfile and deploy your changes locally.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2HY5WaA](http://bit.ly/2HY5WaA)
  prefs: []
  type: TYPE_NORMAL
- en: Cracking open HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols*,
    we had a section, *The application layer*, where we looked at why certain protocols
    fell at that layer. With a little bit more exposure to the nitty-gritty details
    of network transactions under our belt, I'm hoping it will be easier to distinguish
    between the transport layer and the application layer. With HTTP, we have the
    best opportunity to explore that distinction. As a protocol, it has by far the
    broadest, and most robust, support from out-of-the-box C# libraries. That depth
    of in-language resources will give us a sharp lens through which to view the distinction
    between the application layer and its underlying transport layer. So, before we
    learn how to use HTTP, let's learn just exactly what it is.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we worked with low-level streams in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Ports and Sockets*, we saw the responsibility that falls on a developer when
    you have to work directly with byte streams, serializing and deserializing data,
    and manually parsing your input headers. There's a mountain of boilerplate code
    just to get a simple string from one machine to another. Obviously, writing the
    same boilerplate code every time you need to make an external resource request
    is tedious and error-prone. This is where protocols come in.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the topic briefly in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml),
    *Communication Protocols*, where we looked at the protocols defined for each layer
    in the network stack. However, in the intervening chapters, we've established
    a better understanding of how different protocols are separated across the OSI
    stack. So, hopefully, some of the distinctions that may have been hazy back in
    [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols,*
    will be a bit more clear now.
  prefs: []
  type: TYPE_NORMAL
- en: When writing networked software in .NET, there are two primary tiers in the
    OSI stack on which we'll be working. The first, and most obvious, is the application
    layer. That's where HTTP lives, where FTP and SMTP live, and where any web application
    software that you likely have interacted with in the past would have lived. The
    other layer that's commonly written for in .NET, though, is the transport layer.
    Handling TCP and UDP calls directly within a listening server is easily done (and
    we'll see how in later chapters) using some of the versatile and easy-to-use utility
    classes you've likely come to expect from .NET Core. But what's the difference
    between those two layers, from the perspective of the programmer? When we're writing
    HTTP software, we're still very much concerned with the format and structure of
    our serialized data. So, why is that concern different when writing HTTP than
    when handling streams directly with a TCP client?
  prefs: []
  type: TYPE_NORMAL
- en: The application layer and the transport layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important thing to internalize when you're trying to understand this
    distinction is the smallest piece of data with which each layer is concerned.
    The application layer is predominantly concerned with application objects*.* So,
    as long as the language you're working with provides a fully-realized abstraction
    of the rest of the network stack (as is the case with C#), you can write code
    that communicates with external resources exclusively through business and application
    models. You'll never have to worry about composing those models from their serialized
    datagrams, or wondering about the character encoding, or the endianness of integers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you'll be speaking and thinking in terms of the end result of the network
    transaction—for example, "*I'm requesting a database record,"* instead of "*I'm
    requesting a series of bytes for the database record."* If you find yourself falling
    into the anti-pattern of making your application layer software over-generalized
    and abstract, you'll quickly find that it doesn't provide any meaningful value.
    Application layer software should describe and rely on at least some concrete
    business models; otherwise, it's just an unnecessary additional layer in between
    the transport layer and the segment of your code that does use those business
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, on the other side of this conceptual coin, we have the transport
    layer. And as you''ve likely figured out, software written at this level needs
    no business context to be implemented properly and provide its expected value.
    In fact, any representation of non-primitive `Object`s beyond simple generics,
    such as `Serialize<T>()`, would render your transport layer software pretty much
    useless outside the context of a specific business application. Any architecture
    for transport-layered software built around concrete business objects would be
    like a house made out of toothpicks and held together with bubblegum: unstable
    and short-lived.'
  prefs: []
  type: TYPE_NORMAL
- en: I highlight the distinction between application- and transport-layer software
    now to make the content of the rest of this chapter more intuitive. Going forward,
    some of the classes we'll be working with and thinking about in .NET, and some
    of the advice I'll be giving you around this, will rely on your understanding
    of this distinction. Moreover, though, it's good to understand how HTTP came to
    be, and how it transformed into what it is today.
  prefs: []
  type: TYPE_NORMAL
- en: The history of HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication
    Protocols*, while, today, HTTP is the de-facto protocol of web-based software,
    its original design and intent is actually much simpler and more limited. Even
    its namesake, **hypertext**, has grown well beyond its original conception.
  prefs: []
  type: TYPE_NORMAL
- en: First described in 1965, hypertext was defined as a specification for rendering
    text on a computer, or other electronic device, with references to other hypertext
    documents, which could be immediately accessed through a system of references,
    known as **hyperlinks**. At its most basic, this describes little more than a
    primitive web page. In fact, you've undoubtedly already realized the link between *hypertext* as
    a concept and the hypertext markup language, or HTML, file format, which is used
    to render web pages. These basic specifications served as the precursor to the
    modern internet.
  prefs: []
  type: TYPE_NORMAL
- en: Like much of our modern world, the origins for hypertext, HTML, and HTTP can
    be traced back to an influential work of science fiction! A 1941 short story titled
    *The Garden of Forking Paths*, by Jorge Luis Borges, is often credited with being
    the inspiration for the first definition of hypertext.
  prefs: []
  type: TYPE_NORMAL
- en: Decades later, in 1989, researchers at the **European Organization for Nuclear
    Research** (**CERN**) began to formalize their efforts to define the standards
    for a global computer network, now known as the **World Wide Web** (**WWW**).
    This work included defining a standard for document representation, as well as
    a protocol for transmitting those documents between machines. In 1991, the first
    ever formal definition for HTTP was drafted, and dubbed **v0.9**.
  prefs: []
  type: TYPE_NORMAL
- en: This original definition was extremely limited in its scope, intended only to
    define the process of requesting hypertext pages from a given server; the specification
    defined a single method, which is `GET`. As the early internet began to reach
    consumers, however, the needs of the wider audience forced the evolution of the
    standards for the network. By the time HTTP v1.0 was formalized and broadly recognized
    in 1996, the standard grew to include message headers, security, and a wider array
    of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Still, though, it was almost exclusively used to transmit web pages from servers
    to clients. Each request had to negotiate its own connection with the server,
    and once that request was serviced, the connection was closed. This kind of behavior
    makes sense if you're only requesting a static web page, but what if you wanted
    to incorporate user interaction? That connection negotiation comes at a cost.
  prefs: []
  type: TYPE_NORMAL
- en: The engineers at CERN recognized this, and in only one year, in 1997, they released
    an updated HTTP v1.1 (often written as HTTP/1.1) specification that provided an
    even richer feature set. This included headers to specify response-caching behavior,
    persistent connections, authentication and authorization, message syntax, and
    routing or redirection behavior. In fact, HTTP/1.1 remains largely unchanged and
    widely used today. However, while the protocol has remained largely unchanged
    until the recent advent of HTTP/2, introduced in 2015, the ways in which engineers
    *use* the protocol have grown exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: Web services and HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the internet began to grow from a niche utility for business and engineering
    professionals to share resources and information in the early-to-mid 1990s to
    the wide-spread platform it is today, the software written for the internet had
    to grow along with it. The simplicity and extensibility of HTTP provided such
    a reliable, broadly understood, and broadly supported protocol that it rapidly
    outgrew its original stated intent. Engineers began to leverage it for almost
    every instance of networked services and resource access. Now HTTP is the protocol
    of choice for almost any open API available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Early on, Microsoft recognized this, and when it released the first version
    of the .NET framework back in 2001, it did so with full support for HTTP as the
    de-facto application layer protocol for general-purpose network-resource access.
    Later, with the advent of the **Windows Communication Foundation** (**WCF**),
    along with the **Windows Presentation Foundation** (**WPF**), Microsoft continued
    to lean heavily on HTTP for application-layer network services.
  prefs: []
  type: TYPE_NORMAL
- en: For those who may not know, WCF was Microsoft's suite of libraries and frameworks
    for network-specific, service-oriented application development. Meanwhile, WPF
    was Microsoft's framework for asynchronous user-interface code paradigms. It sought
    to provide the same rich set of features and controls for any desktop or web applications
    with a UI, with a consistent look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: The advent of SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of WCF was tailored specifically to the implementation of **Simple Object
    Access Protocol** (**SOAP**) services. At first glance, SOAP seems to be an application-layer
    protocol in itself. However, in practice, it's actually a protocol that exists
    one layer above the actual OSI network stack. So, while an application that implements
    the SOAP protocol ensures reliable behavior for any consumers, it doesn't do so
    in any way that is necessary for interaction between network-available resources,
    as we discussed in [Chapter 3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication
    Protocols*. Instead, it sits comfortably on top of the OSI stack, interacting
    directly with application-layer protocols to service the actual network interactions
    required by SOAP applications and their consumers. So, while SOAP-based applications
    rigidly defined their interactions through a protocol, those interactions were
    still most often initiated over an HTTP network transaction.
  prefs: []
  type: TYPE_NORMAL
- en: This had an interesting side effect, however. While SOAP services were leaning
    heavily on HTTP as their transport protocol of choice, it carried with it several
    drawbacks for the emerging web ecosystem of consumer-facing applications and services.
    SOAP was notoriously verbose in both its request and response message structure.
    It had slow transfer and message-parsing performance due to its heavy reliance
    on XML for serialization. Lastly, as a protocol, its implementations were heavily
    fragmented, leading to no reliable SOAP request pattern for use across the vast
    array of services that were, ostensibly, SOAP-based.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning in the year 2007, with the release of the first iPhone, and continuing
    into the next decade, smartphones rapidly became a viable platform for dedicated,
    consumer-facing applications. While access to broadband internet connections was
    exploding across the globe, cellular networks, which served most of the internet-connected
    devices entering the market, were still several years behind in terms of performance
    and reliability. Meanwhile, all of the disadvantages of SOAP led to poor performance
    and longer development cycles for engineers writing applications to consume one
    or more SOAP-based web services. Across the industry, engineers were realizing
    that they needed an alternative. Millions of dollars were there to be made, but
    with the change needing to be made seemingly overnight for the mobile app market,
    there was almost no time for SOAP to adapt, or even for an alternative version
    to materialize.
  prefs: []
  type: TYPE_NORMAL
- en: The rise of REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how did engineers and leaders in the market space adapt? They went back
    to the basics and looked to leverage the underlying protocol more robustly—less
    bloat, fewer intermediary interactions, and less serializing and parsing and negotiating
    connections. Instead, they would use HTTP as the interaction protocol and leverage
    its features to allow for more dynamic and robust interaction while minimizing
    time spent writing custom, service-specific access protocols. To satisfy these
    goals, engineers across the world would leverage REST.
  prefs: []
  type: TYPE_NORMAL
- en: Short for **Representational State Transfer**, REST was designed as an architectural
    pattern, as opposed to an access protocol. It is convention-based, instead of
    contract-based. This means that anyone familiar with the conventions can use any
    RESTful web service simply by following those conventions. This reduces development
    time for engineers, because it means they can learn the architectural patterns
    once, and then use them everywhere that REST is used. This is obviously much more
    preferable than having to consume and develop for a given contract for a single
    SOAP service, and then having to do the same for each new contract for each new
    service they might have to consume.
  prefs: []
  type: TYPE_NORMAL
- en: By refusing to implement a custom protocol on top of the application layer of
    the OSI stack, REST reduces overhead in terms of message negotiation and parsing.
    And since HTTP is, far and away, the most common application-layer protocol used
    for REST services, those services are free to serve up their responses in whatever
    format HTTP can deliver. This means no more strict reliance on XML as your serialization
    language of choice. Instead, JSON has risen as the quick-to-serialize and quick-to-parse
    format of choice for RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: The improved performance and increased flexibility of pure HTTP meant that any
    APIs or services that were intended for consumption by mobile applications were,
    almost universally, REST services. So, in effect, REST rose to replace SOAP as
    the web service paradigm of choice for modern network interactions, and it did
    so on the back of HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP web services in .NET core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the broad applicability of the convention-based REST paradigm, Microsoft''s
    WCF has fallen, somewhat quickly, by the wayside. In its place has risen the web
    API template from ASP.NET, and now ASP.NET Core. Leveraging the patterns first
    formally described in the book *Design Patterns: Elements of Reusable Object-Oriented
    Software*, byGang of Four,ASP.NET released the **Model-View-Controller** (**MVC**)
    application template and libraries to enable the use of clean, convention-based
    software patterns right out of the box.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For those not familiar with it, the MVC design pattern describes a strategy
    for isolating the logical responsibilities of complex, user-interactive software
    into logical groupings and organizational structures. The view tier was exactly
    what it sounds like: any UI code or markup that would be sent to the client (typically,
    a user''s web browser of choice). The model tier described your data models, and
    how you access them from whatever persistence mechanism the application is using.
    It typically includes your data-access code as well as any data models that are
    sent to or from your application. Finally, the controller tier describes the business
    application logic that ties your models into a useful context for your users,
    and ultimately returns that context to your user as a view. It serves as an intermediary
    between the other two tiers.'
  prefs: []
  type: TYPE_NORMAL
- en: When the ASP.NET team wanted to define a newer, REST-based pattern for full-featured
    web applications that would leave the bloat of SOAP behind, its members looked
    to MVC. The MVC project template associates every available public resource (in
    the case of early MVC, this was almost always a web page, or a fragment of a web
    page) with a specific HTTP verb at a specific URI. This simplified access to resources,
    as developers only ever needed to know what the target address was and how to
    make a generic HTTP request against that address. It also communicated a lot about
    the nature of the resource based on the HTTP verb required to access it. We'll
    see more of this later in the chapter, but that correlation of semantic structure
    to operational use is a massive shortcut when working with new web services.
  prefs: []
  type: TYPE_NORMAL
- en: From MVC to web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Originally, MVC was designed for full-featured web applications serving a UI
    with which users could interact with their backend services. However, the extent
    to which the project template so closely matched the REST paradigm made it a popular
    choice for backend web services that provided no UI whatsoever. In the early 2010s,
    it was common for .NET developers to start from an MVC template, only to scrap
    any semblance of frontend UI code, instead allowing their controller components
    to return raw JSON responses. Needless to say, it didn't take very long for Microsoft
    to recognize the trend and release the Web API project template with an update
    to Visual Studio's project template library.
  prefs: []
  type: TYPE_NORMAL
- en: With the Web API template, developers can have a basic, RESTful web service
    up and running with only two simple commands in the .NET Core CLI. Controller
    endpoints listen for designated HTTP request methods and return arbitrary responses,
    with no assumptions made about any corresponding UI components. Almost every modern
    REST API implemented in .NET will have been created with this project template
    as its starting point. To that end, we'll spend the rest of this chapter exploring
    HTTP from the context of a Web API project, which will both listen for, and respond
    to, incoming HTTP requests, as well as sending outgoing requests to external APIs.
    This pattern of writing an intermediary aggregator API is extremely common in
    modern enterprise web development, especially in the growing trend of microservices
    and cloud-hosted applications. With that in mind, let's stand up our application
    and start exploring how .NET makes HTTP programming enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: The many methods of HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we took some time to explore the concept all the way back in [Chapter
    3](84e54d31-1726-477b-b753-4408a3ee6286.xhtml), *Communication Protocols*, in
    this section, we''ll take a much closer look at the modus operandi of HTTP: the methods.
    We''ll look at each one in the context of our Web API app, and discuss their intended
    use case, limitations, and the conventions of those methods that you would do
    well to follow. To do that, though, we''ll need our app up and running. So, let''s
    first take a look at how that happens with the Web API project created by the
    .NET CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a web API project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we did for our sample application in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*, we''ll be creating an instance of a Web API project with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That name might seem odd, so let's describe our application's basic expected
    functionality, and then hopefully it will make more sense. We'll be writing an
    API that will allow users to track fitness activity over time, along with an almost
    identical API that will serve as our data source. This will give us an opportunity
    to see how to listen for different HTTP requests made of our own app, while also
    giving us just enough context to work with generating HTTP requests to an outbound
    service. The actual shape and functionality of our data store app will be almost
    identical to the user-facing API. The only difference is that when our `FitnessApp`
    needs to persist data, it will do so by making HTTP calls to our `FitnessDataStore`
    app. Meanwhile, when our `FitnessDataStore` app needs to store data, it will do
    so by writing to a file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: The only code we'll be working with in this chapter will be the `FitnessApp`
    code, since that will encapsulate all of the interactions we'll want to learn
    about. The backend data service is available in the sample code for this chapter,
    though, so feel free to browse it, extend it, and modify it if you're curious.
    Also, since our focus will be on the HTTP interactions of this application, and
    it's for demonstration purposes only, we'll be making a lot of naive assumptions
    about data modeling, persistence, and error handling. Instead, I'll leave those
    considerations as an exercise for you to consider and re-evaluate in your own
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Our application will allow consumers to create new workouts with titles; workout
    types and comments; look up previous workouts by their title, workout type, or
    the contents of their comments; retrieve a list of all previous workouts; edit
    an existing workout's comments; and, finally, it will allow users to delete previous
    workouts from their history. As I said before, each of these operations is specifically
    designed to highlight some aspect of HTTP, as implemented by a .NET Core Web API,
    so the implementation details of these operations will be somewhat simplistic
    and naive, or even overlooked entirely. What's important here is to understand
    the expected I/O and how to model these operations to their appropriate HTTP methods.
    With that in mind, let's look at the project we've just created for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at our Solution Explorer, you''ll notice that there''s not a whole
    lot to this project template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89a7ad74-8f22-4e56-bf55-cef7100cbe7b.png)'
  prefs: []
  type: TYPE_IMG
- en: There's just two configuration `.json` files, a single controller class, and
    then the initialization and program files. At this point, those new to web development
    in .NET Core might be wondering why we have both a `Program.cs` file and a `Startup.cs`
    file. This is because, like all .NET Core applications, our Web API project is
    actually a console application executed in the context of the `dotnet` host application
    running on the target machine. So, our `Program.cs` provides the conventional
    `Main()` method as the entry point for our `dotnet` execution context to start
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: However, since we're running an active web application, we'll want to stand
    up a listening web server and provide it the context of our application so that
    it responds to requests appropriately. That's where the `Startup.cs` file comes
    in. This provides all of the configuration, including registering our concrete
    types for dependency injection, and defining the active features and services
    we intend to leverage. Once we've defined all of that, the `Startup` class is
    provided to our web server instance and used to configure the server.
  prefs: []
  type: TYPE_NORMAL
- en: IWebHostBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking at our `Program.cs` file, you can see that''s exactly what happens:
    the `Main()` method only builds our web host, and starts it running with no terminating
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `WebHost` class is part of the `Microsoft.AspNetCore` namespace, and its
    default implementation provides a running Kestrel web server that interacts with
    your application code using the `Startup.cs` file provided to the `UseStartup<T>()`
    method on the `IWebHostBuilder` instance you return to your `Main()` method to
    be run by your program.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the web server created by the call to `CreateDefaultBuilder()` is
    going to be an instance of a **Kestrel** web server. Kestrel is a cross-platform
    server that will acquire a designated port so it can listen for inbound requests
    against that port, passing all received requests through to your application code.
    It supports HTTP/HTTPS, WebSockets, Unix sockets, and HTTP/2, all out of the box.
    In modern .NET Core apps, there's rarely an occasion to use anything other than
    the default Kestrel server anymore. It can run as an edge server, which means
    it is the first point of contact for any incoming requests made of your application
    (listening at the edge or boundary of your host machine). Likewise, it can be
    run behind a reverse proxy, such as **Internet Information Services** (**IIS**)
    or Nginx, as discussed in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of advantages to running Kestrel behind a reverse proxy.
    For example, a reverse proxy allows your Kestrel instance to listen for requests
    targeting the same port registered for other listening applications, while running
    it as an edge server blocks the port it is registered to from being used by other
    applications. This leaves your Kestrel instance to handle every inbound request
    made to its registered port, regardless of the targeted URI path or host name
    specified in the requests headers. If the IP is resolved to your application's
    host machine, and the port is the one Kestrel is registered on, Kestrel will service
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This port-blocking behavior might make perfect sense if your application is
    the only software deployed and running inside a Docker container published to
    a cloud-hosting platform. However, if it's deployed to an on-premises server hosting
    dozens or even hundreds of other web services, then managing the port registration,
    traffic load, and other resourcing or configuration would likely be unwise, or
    at the very least unpleasant. In that case, a reverse proxy would be the most
    reliable deployment solution. It's up to you to determine the pros and cons of
    using a reverse proxy or running Kestrel as an edge server, but whatever you choose,
    you'll have the tools you need to enable your decision.
  prefs: []
  type: TYPE_NORMAL
- en: So, when you want to define the behavior of your application code, you do so
    in the `Startup.cs` file, whereas when you want to define the behavior of the
    Kestrel web server that exposes your application code, you do so with your `IWebHostBuilder`.
    Let's look at how to configure our server for now, and then dive into our application
    code's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's set the URLs we want our application to listen on. For our purposes,
    we'll have direct control over the entire hosting context of any software on our
    machine, so we'll be running Kestrel as an edge server for simplicity's sake.
    Now, to register our server to listen at a specific port, we'll be using the extension
    methods made available on our `IWebHostBuilder` instance that are returned when
    we call `WebHost.CreateDefaultBuilder(args)`.
  prefs: []
  type: TYPE_NORMAL
- en: It might not be obvious when you look at it, but the `UseStartup<T>()` method
    is actually one of those extension methods. It just happens to be so common that
    the Web API project template pre-configures that for you whenever you create a
    new project. And this is a good thing. The methods in `Startup.cs` provide users
    with the opportunity to centralize a lot of boilerplate code and dynamically register
    their concrete classes for dependency injection at runtime. If you haven't used
    dependency injection before, you'll quickly see why this is a huge quality of
    life improvement, and why this little snippet of code is included by the default
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first extension method we''ll use is the `UseUrls(string[])` method to
    register the IP addresses and ports on which our Kestrel instance will be actively
    listening for incoming requests. To do so, change the `CreateWebHostBuilder(string[]
    args)` method to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that I've registered our server to listen on multiple ports for
    both HTTP and HTTPS requests. I mostly did this for demonstration purposes. It's
    rare that you'll want to actively listen on multiple ports with a single application,
    but this highlights that the `UseUrls()` method will allow you to register and
    listen on an arbitrary number of available ports.
  prefs: []
  type: TYPE_NORMAL
- en: This code won't work if you plan to ping your API using a mock host name by
    adding entries into your `hosts` file, as we did in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml),
    *DNS and Resource Location. *Because any host entries you create will be explicitly
    mapped to the IP address `127.0.0.1`, you'll have to explicitly configure Kestrel
    to listen for that exact IP address. You can look at the `FitnessDataStore` sample
    code for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Using launchSettings.json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alternately, you can define your application's listening URLs using the `launchSettings.json`
    file. This file allows you to specify behavior based on the specific environment
    your application is deployed under. Launch profiles can be customized based on
    the web server hosting your application (IIS Express, or Kestrel, which is defined
    as a profile under your project's name when you first create a project using the
    CLI).
  prefs: []
  type: TYPE_NORMAL
- en: When you launch your application with the `dotnet run` command, .NET will look
    for a `launchSettings.json` file, then search for the first profile whose `commandName`
    parameter has a value of `"Project"`, which will use the Kestrel web server. From
    within this profile, you can set environment variables that you intend to be leveraged
    by your application. Any environment variables you define in your launch profile
    will override the values of environment variables that exist on your host system.
    This allows you to define different values for environment variables for different
    circumstances, simply by setting them in their corresponding launch profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set various configurations for your web server inside your launch
    profile. If you look in the `launchSettings.json` file that was created when we
    stood up our `FitnessApp`, you''ll see that it has a profile named `FitnessApp`,
    with a `commandName` value of `Property` as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to the `applicationUrl` property there, as it will come
    up in just a moment, as we're running our app for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the sake of simplicity when using Postman, we''ll change our server
    settings to not use HTTPS redirection for inbound requests to `http://` URLs.
    This just prevents us from having to configure Postman to follow re-directs, and
    gives us a more direct correlation between the code we''re writing and the behavior
    we observe when we test it. To disable the behavior, simply navigate to your `Startup.cs`
    file and, near the bottom of the file, find and remove the line that reads as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that''s done, it''s time to run our application. Simply navigate to the
    folder you created the project in with your command prompt and then execute `dotnet
    run`. Once you have, you should see the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b887810c-c368-451f-8bdb-7ecc1cd2b084.png)'
  prefs: []
  type: TYPE_IMG
- en: You probably noticed that the application is currently listening on each of
    the ports we specified in the array we passed to the `UseUrls()` method, but on
    none of the ports that were specified by the `launchSettings.json` profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to test this code, you''ll first need to prevent Postman from checking
    for the SSL certificates it''s expecting whenever you navigate to an `https://
    url`. To do so, simply open your SETTINGS and disable SSL certificate verification,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/317f93f6-9df1-4863-a4a4-51ffd2624251.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll look closer at SSL certificates and what this particular Postman setting
    means in [Chapter 13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml), *Transport
    Layer Security*. For now, though, it''s sufficient to simply disable that setting
    and proceed accordingly. Once that''s done, open Postman and send `GET` requests
    to each of the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following JSON get returned by all four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed we didn't have to specify ports 80 or 443 in that list.
    This is because, as discussed in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*, each of those ports is reserved for HTTP and HTTPS, respectively.
    So, no port specification on an `http://` or `https://` request is the same as
    specifying 80 or 443.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, if you try to navigate to either of the URLs configured in the `launchSettings.json`
    file, you'll get no response at all. This is because, while settings configured
    in a launch profile in your `launchSettings.json` file will always override any
    system settings that have already been defined, settings configured inside your
    application code when you launch and run your Kestrel server will always override
    any launch profiles. Settings lower down in your scope will always override settings
    configured higher up in your scope.
  prefs: []
  type: TYPE_NORMAL
- en: Since configuring your web server in your application's code will always override
    any other configuration values, you should only use that for the most important
    settings that you always want to behave in a single, specific way. Otherwise,
    the `ASPNETCORE_*` environment variables and launch profiles should be used. They
    provide a high degree of flexibility with a low maintenance cost.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our web server is configured to listen for requests to our designated
    ports, let's use our `Startup.cs` file to set up our application to make HTTP
    requests of its own.
  prefs: []
  type: TYPE_NORMAL
- en: Registering dependencies in startup.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using the `ConfigureServices(IServiceCollection services)` method
    in our `Startup.cs` class to register our specific classes for dependency injection,
    starting with our `IHttpClientFactory` class instances. If you''ve never used
    it before, dependency injection is a great tool for creating loose coupling between
    different aspects of your software that are likely to change over time. Essentially,
    whenever one class (`ClassA`) leverages the properties or methods of another (`ClassB`)
    in order to perform its own functions, a dependency is created. We can say that
    `ClassA` depends on `ClassB`. There are a number of ways to resolve that dependency.
    The naive approach would have us creating instances of `ClassB` directly inside
    of `ClassA` wherever its methods are used, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But this brings with it a whole host of problems over the course of development.
    If `ClassB` ever needs to be changed, then we'll have to change it everywhere
    it's referenced. The more explicit dependencies we have, the more places we have
    to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can injectthe dependency. To do so, we define an interface for
    the useful functionality that `ClassB` provides for `ClassA` and then define `ClassB`
    as an implementer of that interface. In our example, this `IClassB` interface
    would need to define a method with the signature `string GetSpecialString();`
    and that''s it. Next, we can simply say that `ClassA` needs something that implements
    the `IClassB` interface. To make this dependency clear, without demanding an instance
    of the concrete `ClassB`, we define a constructor that accepts any implementer
    of `IClassB`. This changes our naive approach into the following definition for `ClassA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, now,  the `ClassA` class doesn't depend on the `ClassB` class; instead,
    we can say it depends on some functionality that the `ClassB` class happens to
    provide. But it doesn't concern itself with how it gets that functionality. Instead,
    determining what the best concrete class to use is falls on the calling code that
    instantiates `ClassA`. Whatever uses `ClassA` has to determine the best concrete
    instance of `IClassB`, create an instance of it, and then inject it into the newly
    created instance of `ClassA`. If the `IClassB` implementer will ever change based
    on context, or new project requirements, we can make those functional changes
    without having to modify `ClassA` at all. And that is dependency injection in
    a nutshell!
  prefs: []
  type: TYPE_NORMAL
- en: There's actually a whole lot more to dependency injection when you find yourself
    using it in a professional context. Entire books have been written about the subject.
    And, as with any design pattern, you'll find as many opinions about it as engineers
    you ask for those opinions, and it can be a subject of heated debate in some circles.
    It is way beyond the scope of this chapter (and even this book) to go into detail
    about the many nuances of dependency injection. However, my hope is that this
    explanation will serve as enough of a primer for any readers who have never used
    it before to understand the concept enough to understand how to register dependencies
    in our `Startup.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: The IHttpClientFactory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first service we'll want to register will be our `HttpClientFactory`. This
    class is an incredibly useful factory class that will provide managed instances
    of the `HttpClient` class. Prior to this wrapper class managing instances of `HttpClient`
    for us, there was actually a very painful and difficult-to-track-down bug that
    would arise when using common patterns for creating and disposing of instances
    of `HttpClient` by hand. Since the `HttpClient` class implements the `IDisposable`
    interface, many developers would instantiate it within the context of a `using(var
    client = new HttpClient())` statement. While this is the recommended pattern for
    almost every other class that implements `IDisposable`, in the specific case of
    `HttpClient`, there was an issue with instances of the client failing to release
    their listening threads. This bug lead to infrequent and inconsistent thread starvation
    in applications with high volumes of outbound HTTP requests. It was a painful
    problem, and the solution we have for it is the `HttpClientFactory` class.
  prefs: []
  type: TYPE_NORMAL
- en: With this class, we can request instances of `HttpClient` and trust that they
    will be allocated resources on the thread pool properly, and reused wherever possible
    to reduce memory overhead and performance concerns. Given that, it only seems
    appropriate that this is where we take our first steps with registering our dependencies
    in the `Startup.cs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, we'll need to create a class thathasa dependency on the `HttpClientFactory`
    class. In the root of your project folder, create a new folder named `Services`,
    and inside that folder, create a new class file named `FitnessDataStoreClient.cs`.
    This is the class we'll eventually use to write our data back to our `FitnessDataStore`
    API, which means this is the class that will need an `HttpClient` class to send
    those requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the file created, add a `private readonly` instance of the `IHttpClientFactory`
    interface. Then create a single constructor for your new class that accepts an
    instance of `IHttpClientFactory` as its only argument. Finally, assign the argument
    instance to your private member variable. After doing so, your file should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You might be wondering why you can assign to a variable that's marked as `readonly`.
    Any class property or member variable that is marked as `readonly` can be written
    to only in the constructors for the class, or when they are explicitly declared.
    This little feature of the language is especially nice in the case of dependency
    injection, as it gives developers the opportunity to inject dependencies that
    might otherwise need to remain immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now that we''ve established our dependency, we''ll need to register a concrete
    instance of it for use in our `Startup.cs` file. With this particular class, since
    the need for an `HttpClient` class is so common in so many web applications, there''s
    actually an extension method on the `IServiceCollection` to register an `IHttpClientFactory`
    instance for injection. To use it in its most basic form, we''ll only need to
    add a single line to our file. In the `ConfigureServices(IServiceCollection services)`
    method, simply insert the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, when you run your application, your `FitnessDataStoreClient`
    will have access to a valid instance of `HttpClientFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, though, this implementation is fairly basic. With what we've
    written, we'll have to configure our `HttpClient` instance every time we request
    it from the factory class. That means defining the base URL, any default headers
    we may want to apply, and other minutia. Instead, we can use the overload method
    of `AddHttpClient()` to create a named client. By doing this, we can centralize
    some of the boilerplate client configuration into our `Startup.cs` file, and then
    when we invoke the named client in our application code, we can skip straight
    ahead to sending requests with it. Using named clients also gives us a simple
    way to manage the need to connect to multiple distinct data sources. Doing so
    not only makes our code easier by eliminating some of the boilerplate of establishing
    a connection for HTTP requests, but can also improve performance by sharing connections
    between various references to the same named `HttpClient` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, I''ll actually be creating two distinct aliases in my
    hosts file for the `FitnessDataStore` API. So, even though, behind the scenes,
    all requests to that API will be going to the same IP address, from the perspective
    of our `FitnessApp` API, it will look as though we''re leveraging two distinct
    APIs with two distinct URLs, and two distinct named `HttpClient` instances. To
    test out this code for yourself, add the following lines to your hosts file, similar
    to how we did it in [Chapter 2](ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml), *DNS
    and Resource Location*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can configure our `HttpClient` instances for each of these host names.
    With named instances of `HttpClientFactory`, we can specify the name by which
    we''ll identify the specific instance we want to create, as well as define some
    default behavior for the client we''re naming. We''ll just call our different
    clients `WRITER` and `READER` for now. So, modify our `ConfigureServices(IServiceCollection
    services)` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While the `Accept` header isn't usually the most important thing to concern
    ourselves with, this should be sufficient to demonstrate how you might configure
    the common properties for all requests bound generated by the named client. If
    you have a common authorization scheme, you can simply define those values once,
    in your `Startup.cs` class, and not have to concern yourself with updating authentication
    or authorization keys everywhere in your code that makes requests using those
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Since named `HttpClient` instances must be created using the same name they
    were registered with, it's usually best to keep the names in a central configuration
    file, and then reference the value out of that file in both the `Startup.cs` code
    that registers the named client, as well as the application code that requests
    it. Always avoid magic strings wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our named clients registered, let's get our data-access client
    set up to register with the dependency injection framework so we can start working
    with our controller class.
  prefs: []
  type: TYPE_NORMAL
- en: Registering services in Startup.cs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the sample code, you''ll find a simple model representing a record in our
    fitness activity database. I placed it in a `Models` folder, which is located
    in the root of the `project` directory. This is a common convention in MVC/Web
    API applications, but you can organize your code however makes the most sense
    for you. This class itself is relatively straightforward, and represents all the
    fields described in the project requirements I set out at the start of this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now, inside our `FitnessDataStoreClient` class, we''ll want to define the
    operations we expect to be able to perform on our data store. According to our
    specs, we''ll want to be able to look up all current records, look up individual
    records by their unique `title` property, look up records by `workoutType`, modify
    the `comments` field, and delete a record with a given `title`. For now, let''s
    define those methods to return either a mock response, or just throw `NotImplementedException()`
    to satisfy our build system. We''ll come back to fill out the implementation later
    in the chapter when we look at formatting and generating our requests using `HttpClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'While we have our implementation defined, we still need to define the interface
    that we''ll use to register the class for dependency injection into our controller.
    We''ve already declared our `FitnessDataStoreClient` class to implement `IDataStoreClient`,
    so that''s the name of the interface we''ll create for dependency injection. So,
    either at the top of the current file, or in a new file located in the same folder,
    add the following interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And since our data store client is going to be entirely stateless (that is
    to say, having no instance properties that might vary between instances of the
    class), we can safely register it as a singleton instance in our `Startup.cs`
    file. So, from inside the `ConfigureServices(...)` method, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This particular helper method will allow our dependency injection container
    to create a single instance of the concrete class the first time the class is
    created. The dependency injection container will then provide a reference to that
    single created instance for all subsequent requests for an instance. `WebHost`
    will then inject a reference to that single instance into each other class that
    requests an implementer of the `IDataStoreClient` interface for dependency injection.
    If you need multiple instances created for requesting your API handles, you can
    use the `services.AddScoped<Interface, Implementation>()` variant of this method,
    as this allows new instances to be created with a state that lives only as long
    as it takes to return a response for a given request. Alternatively, if you need
    a new instance every time an instance is injected anywhere in your application,
    regardless of scope, you can use the `services.AddTransient<Interface, Implementation>()`
    variant. Each of these alternatives will provide the same inversion of control
    that is necessary for dependency injection without holding a single managed instance
    of the implementation class over the lifetime of the application, as is the case
    with `AddSingleton()`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling incoming HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our service class defined and registered for use in our `Startup.cs`
    file, it''s time to leverage it in our controller and start responding to incoming
    HTTP requests. First, though, we''ll want to modify our controller class so it''s
    a bit more useful for our purposes. Start by changing the name of the class to `FitnessController` and
    removing all of the method stubs provided by the initial project template. At
    the top of the class definition, you''ll see two DataAttributes defined, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These provide context for your `WebServer` about the nature of this class file.
    The first one specifies that your `WebServer` should respond to all requests to
    the URI path `api/[controller]` by looking for valid methods inside this particular
    class. Now, here, `[controller]` is a special placeholder that is replaced with
    the name of your controller class (the segment of your class name that prefixes
    `controller`), so when we change the name of our class file to `FitnessController`
    and run the application, we should begin seeing valid responses by navigating
    to `http://localhost/api/fitness`.
  prefs: []
  type: TYPE_NORMAL
- en: The second DataAttribute, `[ApiController]` method, is actually very important
    if we want our controller to behave as expected. Using that attribute at the top
    of a type definition tells our `WebHostBuilder` to use this particular class as
    a controller and explore its method signatures to discover endpoints that should
    be exposed by the server. It also notifies our `WebServer` to perform automatic
    model-binding validation. What that means is that whenever a request comes in
    targeting one of the controller's endpoints, the inputs specified in the signature
    of the endpoint should match the shape of the request message. By specifying our
    controller as an `ApiController`, `WebServer` will make sure that requests messages
    match our expected inputs before it invokes our controller's methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the name changed, and the methods removed, we need to set up our controller
    to use the registered instance of the `IDataStoreClient` implementation. So, let''s
    create a private member variable and inject our instance with a constructor for
    our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, with the `IDataStoreClient` operations as our guide, we can start implementing
    our controller endpoints. Each of our endpoints will demonstrate a different HTTP
    method, so let's consider how those methods are used and how that impacts the
    implementation of our endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The GET method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first and most basic method we'll implement a listener for is the `GET`
    method. This method is used to access a resource at a specific endpoint, and,
    conventionally, `GET` requests carry no content, as specific constraints on the
    lookup are typically passed along as either segments of the URL path, or as key-value
    specifications sent as part of the URL's query parameters. It's up to you (or
    your project's specifications) to enforce those conventions, if you choose to.
    It's worth noting, though, that for most engineers, and for the `HttpClient` methods
    implemented by C#, the assumption is that those conventions will be followed by
    active HTTP services.
  prefs: []
  type: TYPE_NORMAL
- en: One other important note about the `GET` method is that it is generally considered
    both *safe* and *idempotent*. For an HTTP method to be considered *safe*, then
    a request of that method must not have any impact on the state of the resource
    on which the request was made. So, if I request a list of names from a server
    using a simple `GET` request, the server should still have those names stored
    in its database. The server should be exactly the same after it services my request
    as it was before it serviced my request. Meanwhile, if an operation is not safe,
    that means that the state of information stored on the server will be different
    after it processes a request of that unsafe method. The only HTTP methods that
    are always considered safe are `OPTIONS`, `HEAD`, and `GET`.
  prefs: []
  type: TYPE_NORMAL
- en: If you've never seen the word idempotent before, don't worry; it's nothing complicated.
    For a method or operation to be considered idempotent, you should be able to execute
    that operation any number of times without ever getting a different outcome from
    the first time you executed it. So, if I request a record with its ID, it doesn't
    matter how many times I request that record, I should always get the same response
    back that I got the first time I requested it. So, naturally, `GET` is considered
    an idempotent HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we understand how a `GET` method should be handled (that is to
    say, safely, and in such a way to render `GET` requests idempotent), how do we
    configure our controller to respond to a `GET` request? Well, if you read the
    source code I told you to delete before you deleted it, you already know the answer
    to this. But for those who don''t know, we specify our methods as handlers for
    `GET` requests using the `[HttpGet]` method attribute. So, let''s look at all
    of our `read` operations and implement their methods in our controller using `IDataStoreClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the attribute takes an optional string argument specifying a more
    specific URL path that the annotated method is meant to respond to. When the attribute
    is used without the optional parameter, though, the method annotated by the `[HttpGet]`
    attribute will simply respond to any `[HttpGet]` requests made to whatever URL
    path is handled by the parent `Controller` class. So, in this case, our `Get()`
    method will respond to any `GET` requests made against the `api/fitness` path.
    Meanwhile, requests made to `api/fitness/type/{type}` will return all records
    whose `workoutType` field contains the value of the `{type}` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: I should also note here that (as you probably already guessed) the curly-brace
    syntax in the route specification is used as a placeholder for dynamic path variables.
    What's more, you can always safely reference any variable used inside curly braces
    in a route as an argument to your implementing method, and the web server will
    properly map whatever value was used in the request URL's path to its invocation
    of your method.
  prefs: []
  type: TYPE_NORMAL
- en: You may have also noticed that each of our methods has a return type of `ActionResult<T>`
    (ignoring the `Task<T>` outer type that's required for asynchronous methods).
    This is a custom wrapper around our return object that is applied to our methods'
    return values by `ControllerBase`. It will provide the appropriate HTTP status
    code and response headers for whatever result we return within our methods, and
    it does so entirely behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The POST method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, with our `GET` requests serviced, let's look at what a `POST` request is,
    and how to handle it with our application. The `POST` method is typically used
    when a client needs to send a payload of content to the listening server, usually
    for storage or as an input to some calculation or processing that the server is
    responsible for. While, in some cases, some specific `POST` endpoints might be
    both safe and idempotent (because, again, it's up to each developer to adhere
    to the conventions of HTTP and RESTful API development), in the general case,
    `POST` as a method should be assumed to be neither safe nor idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary distinction between a `POST` request and a `GET` request is the
    payload associated with the `POST` request. So, let''s look at how we can access
    and parse that payload for processing by our Web API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using the `[FromBody]` parameter attribute on our method's only
    argument, and we're specifying that we expect to receive an instance of the `FitnessRecord`
    class from our request's content body. This attribute will use the `Content-Type`
    header of the request to determine how to parse the incoming message's content
    body and attempt to de-serialize the message into the type specified as the parameter.
    So, here, it would expect the message to be in the format of the `FitnessRecord`
    type. If the message body cannot be deserialized to the expected type, Web API
    will throw an appropriate 4XX status code response indicating some form of a bad
    request was sent.
  prefs: []
  type: TYPE_NORMAL
- en: I've used the `[FromBody]` attribute here primarily for demonstration purposes,
    as a way to illustrate the various `[From*]` attributes. Interestingly, though,
    because of our use of the `[ApiController]` attribute at the top of our class
    definition, we actually already reap the benefits of this input validation without
    needing to specify the `[FromBody]` attribute when we only have a single class
    specified as the input for a `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of `[From*]` attributes you can apply to incoming messages
    to map your formal argument variable to some part of the incoming request. These
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[FromBody]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromForm]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromQuery]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromRoute]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[FromHeader]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these parameter bindings will attempt to retrieve your the value of
    your formal parameter from the target location, and, if possible, will attempt
    to de-serialize the specific message component into the simple type you've declared
    for your formal parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is a `[FromServices]` attribute. This is unique from the
    others in that it doesn't actually attempt to parse the designated argument from
    any part of your incoming message. Instead, this allows you to retrieve an instance
    of a dependency-injected interface from your registered services and assign it
    to a variable scoped to that single method, instead of having a class member variable
    whose value is assigned in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The other interesting concept we've introduced with this method is sending generalized
    HTTP responses using the built-in methods of the `BaseController` class. Our two
    possible return values are determined by the `Ok()` and `StatusCode()` methods.
    Each of these will do the work of formatting an `HttpResponse` object for the
    desired `StatusCode`, with `Ok()` obviously returning a `200` code, and the `StatusCode()`
    method returning a response with whichever status code you specify as your argument.
  prefs: []
  type: TYPE_NORMAL
- en: The PUT and PATCH methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next let's look at the HTTP methods that will allow us to apply updates to records
    that already exist on the server. This can be done with either of the `PUT` or
    `PATCH` methods. Now, since I've just described them as updating the state of
    the server, it should be obvious that neither of these methods are considered
    safe. However, a `PUT`  method should be idempotent (when properly implemented).
    We'll see why momentarily, but `PATCH` is not considered generally idempotent.
    The difference between the two is subtle, and often they are implemented in a
    way as to be interchangeable, so let's learn how they work and think about which
    is the most appropriate for our update operation.
  prefs: []
  type: TYPE_NORMAL
- en: When a `PUT` method has been implemented to the HTTP standard, the client is
    expected to provide a full instance of a minimum payload and a target destination
    for that payload. If there is a record at that target destination, then the payload
    is considered an update to that record, and the entire existing record is overwritten
    with the payload. Meanwhile, if there is no record at that target destination,
    then the payload is inserted, just as with `POST`, at the target URI. So, now,
    hopefully, you can see why this operation is idempotent. Using a single given
    payload, it doesn't matter how many times we execute the `PUT` method; it will
    always set the record at the target location to the value of that same payload.
    Subsequent executions have no effect after the first operation succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the more astute readers may have identified a risk inherent to the `PUT`
    operation. Specifically, unless you have the most up-to-date version of the record
    you intend to update, you run the risk of overwriting recent changes to the record
    that you were unaware of with your `PUT`. Thus, it's usually wise to do a `GET`
     operation on the target record prior to applying any `PUT` updates to it to ensure
    that no recent updates are accidentally reverted. This introduces a performance
    hit in the form of additional round trips to your server, and, likely, a resource-locking
    mechanism to ensure that no one updates your target record in the time between
    your `GET` and your `PUT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PATCH` method, on the other hand, only requires that a *set of changes,
    as described in the request payload*, be applied to an entity identified by the
    request URI. This means that our payload could describe a change be made to only
    a specific property on the target resource, without having to send the new, wholly
    updated state of the record with each `PATCH` request. For example, a properly
    formatted `PATCH` request could have a payload that describes your changes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, when the operation is called, your API would have the information necessary
    to update only the relevant field you hope to update. You''ll note, though, that
    the definition of a patch is vague enough that you could describe a set of changes
    that apply new content and change the state of the server with each subsequent
    request. For example, imagine the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If this operation appended the value of a suffix to the target property, then
    each subsequent `PATCH` with the same payload would result in a longer and longer
    `comments` field. Because of this broad spectrum of a possible *set of changes,
    as described by the payload*, the `PATCH` operation is not assumed to be idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, technically, the standard produced by the **Internet Engineering Task
    Force** (**IETF**) that describes the `PATCH` operation (RFC 5789) specifies that
    the payload of a `PATCH` request contains a set of instructions describing how
    a resource currently residing on the origin server should be modified to produce
    the new version. This seems to indicate that the payload actually explicitly describes
    a sequence of operations to perform on the target resource, as opposed to representing
    a partial object state with only the fields that are meant to be updated. Under
    this interpretation, the following `PATCH` payload might be considered non-standard,
    or incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, there are a number of purists who insist that using `PATCH` to send
    only partial object structures is an explicitly incorrect use of the method as
    defined in the standard. However, I would argue that a payload containing a partial
    object structure is itself a highly streamlined description of a set of changes
    to apply to the resource. I would actually make the case that such an implementation
    does not violate the spirit or letter of the standard. To wit, the stated intent
    of RFC 5789 is to provide the partial-update functionality that is not provided
    by the `PUT` operation, and a partial object structure does exactly that. In fact,
    there is even a new standard out for comment that specifies that exact payload
    structure: RFC 7936.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you decide how to implement `PATCH`, I would encourage you to read the opinions
    of others on how it should be written so as to meet the standard, and then decide
    for yourself whether you should take a more pure approach, or allow the partial
    object structure. I''ve already explained my reasoning for accepting the partial
    object approach, and so that''s how we''ll implement our comment-update method
    in our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, since we're only allowing our users to update their comments, we'll use
    the REST paradigm of using our path to describe the most specific part of our
    system that we want to interact with. Thus, our path and method specify that we
    want to `PATCH` the value of the comments at the record with the given title.
    This, semantically, communicates everything we need to know about this operation,
    and I would assert accomplishes all of the goals of RESTful design, within the
    standards of the HTTP operation.
  prefs: []
  type: TYPE_NORMAL
- en: The DELETE method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we''ll look at perhaps the most intuitive method described for HTTP,
    the `DELETE` method. Sending a `DELETE` request to a target resource will do exactly
    that: it will delete the resource from the server, replacing it with nothing.
    Since this updates the state on the server, the method is not safe. However, since
    you can''t delete a record that''s already been deleted, the operation is considered
    idempotent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `DELETE` request may receive a response with a body describing the object
    that was deleted, or the success or failure of the operation, but, typically,
    just a 2XX status code message is delivered on a successful deletion. This method
    is as simple as it sounds, so let''s implement it in our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Exactly as you would expect, the method is defined as a valid handler for `DELETE`
    requests using the `[HttpDelete("{title}")]` attribute, and merely returns a status
    code of either `200` or `400`, with a success message.
  prefs: []
  type: TYPE_NORMAL
- en: And just like that, we've written a service that will listen for and properly
    respond to the full suite of valid HTTP methods for which you'll be expected to
    write custom software. So, now that we can handle incoming HTTP requests, let's
    look at how to build and send outbound requests of our own.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With it being such a common aspect of most modern software projects, it should
    come as no surprise that generating HTTP requests has been so thoroughly streamlined
    by the .NET Core standard that it's an absolute breeze to use. We'll be using
    the `HttpClient` class to send outbound requests that perfectly mirror the `FitnessApp`
    API we just defined in our controller class, so understanding the expected paths
    and inputs should be a straightforward endeavor. So, with that in mind, let's
    crack open our `FitnessDataStoreClient` class and start generating requests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HttpClient instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with the simple read operations in our API, but in order to do
    that, we''ll need to spin up an instance of the `HttpClient` class for use to
    use to generate our requests. To do this, we''ll want to request the instance
    of the class that we registered for read operations. This is as simple as calling
    `CreateClient()` with the same key we used to register the `READER` instance in
    the first place. So, inside our `GetAllRecords()` method, simply add the following
    line to the start of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And now, our client variable contains an instance of `HttpClient` that's already
    configured with the `BaseAddress` and `DefaultHeaders` properties we set in our
    `Startup.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever need to create an `HttpClient` class without pre-registering it
    (suppose you needed it to access a URL that you don't know the value of until
    runtime), you can do so by simply leaving the arguments of the `CreateClient()`
    call empty. You'll then be responsible for setting the `BaseAddress`  property
    for your requests and any necessary headers on your newly created client, but
    that's done in exactly the same way as we did it in our `Startup.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Building a request message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our client, creating an outbound `GET` request is as simple
    as defining an `HttpRequestMessage` instance and specifying the method and target
    path we intend to send our request with. And since `GET` requests conventionally
    have no content body, that initial `HttpRequestMessage` definition is sufficient
    to give to our `HttpClient` for transmission. If you need to apply headers, you
    can do so with the `Headers` property of the `HttpRequestMessage` class, but since
    we don''t, let''s just create our message, and send it with our client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And just like that, we have the response from our server in a variable for
    us to work with. Before we proceed with parsing the response message, though,
    we''ll want to make sure that our operation completed successfully. A common pattern
    is to wrap any error-handling code (which we won''t be implementing here, for
    brevity''s sake) in a conditional clause checking the success of the request.
    Once we''ve confirmed that behavior, though, we can safely attempt to parse our
    `response` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `response` object we get back represents the entirety of the HTTP response
    from the server, including any headers the server sent back, and the status code,
    and even the content of the original request message. Typically, though, you'll
    only be concerned with the `StatusCode` property, and the `Content` property.
    The `StatusCode` property is actually an enum type that enumerates all valid HTTP
    response status codes, and is what's used to determine the result of the derived
    `IsSuccessStatusCode` property. Meanwhile, the `Content` property is an instance
    of the `HttpContent` class, which contains an array of headers specific to the
    content, as well as a number of utility methods for reading and parsing the body
    of the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we know that the output of our request will be the JSON representation
    of a list of fitness records, we can use the `JsonConvert` static class to de-serialize
    and return the response content. And with that simple pattern, we can proceed
    to define the rest of our `GET` operations. First, we have the `GetAllRecords()`
    method, which will simply return the list of any records stored in our data source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have our `GetRecordsByWorkoutType()` method, which allows the user
    to filter based on the `workoutType` field of the fitness record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll implement our `GetRecordByTitle()` method, which allows us
    to search our fitness records by the (presumably) unique `title` assigned to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With each of these methods, you'll notice that we're not actually implementing
    any additional filtering logic inside our data service class. Instead, we're relying
    on that work to be done by the server. The abstraction we're introducing is over
    the direct interaction with the server, and not on the logic of filtering the
    records. So, now that we have our `GET` operations in place, we can look at what
    additional steps we need to take to `POST` data.
  prefs: []
  type: TYPE_NORMAL
- en: Posting request content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the main difference between a `GET` request and a `POST` request is the
    content attached to the `POST` request, let''s take a look at how to apply our
    content to our request message. First, we''ll change the method specified when
    we create our `HttpRequestMessage` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then, we'll need to create our `Content`. The `HttpContent` class is an abstract
    class instantiated by a variety of sub-classes that each implement different valid
    formats for `POST` content. You can define `FormContent` for an `x-www-form-urlencoded`
    request; `MultiPartFormContent` for large messages, file transfer, or binary data
    transmitted in several discrete chunks; `StreamContent` to represent an open and
    active stream connection; and many more. For our purposes, though, since we'll
    be serializing to and from JSON, we'll just define the payload as an instance
    of `StringContent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re using `StringContent`, there are several override implementations
    that allow you to specify the specific character encoding and the media type for
    the message. This is used by the `HttpClient` class to apply the appropriate content-type
    header to the request, which means that in most cases, you''ll never have to concern
    yourself with that specific value. Since our string will be well-formed JSON,
    the `HttpClient` class will be able to infer our media type from the string alone,
    so applying the `POST` body is a fairly straightforward task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With our message body in place, the rest of our code proceeds exactly as it
    did with our `GET` requests, leaving us with a final implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'So, with this pattern in place, we can complete our implementation by adding
    the code to update and delete records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Running this application side by side with the `FitnessDataStore` app, you should
    see all of the expected behavior described in our initial project description.
    Fire them up, bring up your REST client of choice, and start hitting every endpoint.
    Set breakpoints in your code, and see what happens every step of the way. And
    with that, we've covered the essentials of HTTP in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS – security over HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we'll discuss it more in [Chapter 13](2b8a5eae-9085-43d1-9e48-5c21513e8339.xhtml),
    *Transport Layer Security*, we should take a moment to consider how to establish
    secure connections at the application layer. In the HTTP protocol, security is
    achieved through **Hypertext Transfer Protocol Secure** (**HTTPS**). This provides
    a mechanism for authenticating the source of a remote resource, such as a web
    page or an API response. HTTPS also provides protection of the data in transit
    that is passed between client and server with each request/response interaction.
    This is done by leveraging the **Secure Sockets Layer** (**SSL**) or, more recently,
    the **Transport Layer Security** (**TLS**) on the underlying transport-layer interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing outbound HTTPS connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With outbound connections, using HTTPS is as simple as defining the schema in
    your request URL to be of type `https://...`. While this may seem trivial, the
    value in HTTPS connections comes from a trusted and validated server certificate,
    usually signed by a third party, which gives consumers confidence that the site
    they are trying to access is, in fact, the site they intended to access.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, you'll want to test out your application on a development server
    using production-ready configurations. Typically, in these scenarios, you won't
    have the requested **Certificate Authority** (**CA**) provide you with a trusted,
    signed SSL certificate for that development server. When that happens, your calling
    code will throw an error warning users that the HTTPS connection couldn't be validated
    with an SSL certificate signed by a trusted CA. This happens because, behind the
    scenes of the `HttpClient` class, there is an `HttpClientHandler` function that
    validates any outbound HTTPS connections before checking for an SSL certificate
    signed by a trusted CA. This means that, in a case where you're connecting to
    a trusted and certified resource over HTTPS, you don't have to do any additional
    work to ensure that security. A successful connection with your `HttpClient` ensures
    that security.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to override that behavior with a custom server certificate validator,
    which we'll look at in later chapters focusing on security. In general, though,
    if you're getting that error from any remote resource that you don't directly
    control, *listen to it*. It's a fantastic warning system that you get for free
    from .NET Core, and you'd be wise to leverage it.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting HTTPS on your server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This should come as no surprise to any of you, but we''ve already seen exactly
    how we can support HTTPS for incoming HTTP requests being made of our application.
    It''s that tricky little line of code we keep removing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Provided we have this line of code, and our web server is configured to listen
    over at least an HTTPS URL, our application will support HTTPS. With this value
    set, the web server will respond to all incoming HTTP connection attempts with
    a `302`, which is a redirection status code notifying the client that their request
    should be redirected to the HTTPS URI for processing.
  prefs: []
  type: TYPE_NORMAL
- en: The reason I've been removing this particular piece of code and using HTTP in
    all of our examples so far is because of what I mentioned in the previous section titled
    *Establishing outbound HTTPS connections.* Trying to connect to a server over
    HTTPS will cause our software (and most REST clients such as Postman or Insomnia)
    to attempt to validate an SSL certificate. However, while we're in development,
    our local machines typically won't have a signed certificate to return with HTTPS
    responses. So, by removing the `UseHttpsRedirection()` method, we simply remove
    that variable from the equation while we're still in development. However, once
    you're ready to deploy your code to a production environment, you'll want to enforce
    HTTPS wherever possible, and I would even go so far as to recommend you configure
    your server to only listen on HTTPS URLs.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2015, the **Internet Engineering Task Force** (**IETF**) introduced the first
    major revision of the HTTP standard since HTTP 1.1 was codified in 1997\. This
    new protocol, now named HTTP/2, introduces a number of extension features on top
    of the existing HTTP 1.1 protocol definition, while leaving the expected behavior
    of the previous standard almost entirely unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: New features of HTTP/2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Originally developed by Google under the moniker **SPDY** (short for *speedy*),
    HTTP/2 was designed to provide major speed improvements over HTTP 1.1\. Its objectives
    were to reduce latency to improve the performance of web browsers loading content.
    This latency reduction is accomplished by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Header compression:** All transmission headers are compressed with either
    gzip or DEFLATE compression mechanisms by default. The reduced packet size and
    volume for basic protocol/request negotiation has a noticeable impact on high-latency
    network connections, such as cellular networks (thus improving page-load performance
    on mobile devices, such as Google''s Android phones).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request multiplexing:** Sends multiple queued outbound requests over a single
    active connection. This can prevent bottlenecks of outbound requests for web resources
    on pages with a lot of content, and head-of-line blocking, which occurs when the
    first request in a queue hangs, preventing the processing of subsequent, potentially
    smaller and faster requests, from resolving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server push:** This allows a server to send content directly with a client
    over a previously established connection. This is useful if, for instance, you
    know that every request for a web page will be shortly followed by requests for
    additional resources referenced by the web page. Instead of forcing the client
    to initiate an additional HTTP request cycle for those additional resources, the
    server can simply push out the data directly and, if configured properly, the
    client can handle the incoming data without the overhead of processing the full
    HTTP message structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request prioritization:** This enables the developer to determine which requests
    will most likely need to be resolved first and provide priorities to ensure they
    are. Similar to multiplexing, it seeks to reduce the impact of head-of-line blocking,
    but can do so without needing to fully support a multiplexing transport mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 in .NET core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring your application to start leveraging these features happens at with
    your `WebHostBuilder`, since the web server negotiates all of the incoming HTTP
    requests and determines support for various protocols. Once that's done, though,
    your clients will begin seeing the benefits of the protocol extensions without
    any additional change in your code to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, at the time of writing, Kestrel doesn't support some features,
    such as server push and stream prioritization. So, while the client can send a
    prioritization tag with its requests, Kestrel simply won't act on that request.
    And one other caveat to HTTP/2 support is that your hosting environment's native
    cryptography library must support **Application Layer Protocol Negotiation** (**ALPN**)
    to establish the secure connection necessary for HTTP/2\. That means HTTP2 is
    supported only for .NET Core apps deployed to either Windows environments or Linux
    hosts with OpenSSL 1.0.2 or higher. Thankfully, though, if your environment doesn't
    support HTTP/2, Kestrel will silently fall back to using standard HTTP 1.1 request
    processing. That means you can configure the protocol and deploy it to any environment
    without worrying about environment specific Kestrel configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to support HTTP/2, simply leverage the `ConfigureKestrel()` method
    on your `WebHostBuilder`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, you've got support for multiplexing, header compression,
    and request streaming, out of the box, with no change to your application code.
    And I'll note that further support for HTTP/2 is on the horizon for Kestrel, so
    as the protocol matures (it's only been a standard for about three years at the
    time of writing), expect to see wider adoption, and the improved performance that
    goes with it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in this chapter, and for good reason. HTTP is, as I suggest
    in the title of this chapter, integral to programming software being able to function
    on the web. We learned about the distinctions between application-layer protocols
    and transport-layer protocols with a bit more clarity and context. We explored
    the history of HTTP, and saw how its design lent itself for use far beyond its
    original intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Once we had that background, we looked at the Web API project template, and
    learned how .NET Core leverages the cross-platform Kestrel web server to expose
    network-aware applications to incoming requests. We looked at how to configure
    our web server using the `WebHostBuilder` extension classes. We learned how to
    configure our application code for use on our web server, in our given hosting
    environment, using the `Startup.cs` class. Then we took the time to set up our
    application to leverage ASP.NET Core's dependency injection framework for our
    service and utility classes.
  prefs: []
  type: TYPE_NORMAL
- en: With our application wired up and ready to go, we looked at how to expose the
    controller endpoints to listen for each specific HTTP method at specific routes,
    and the various ways we could respond to those requests. Then we looked at how
    to format outbound HTTP messages of our own, including building a content body,
    formatting and applying request headers, and finally sending our requests using
    the `HttpClient`. Finally, we took some time to consider how to allow secure connections
    with HTTPS, and what the future holds with the HTTP/2 specification. With this
    perspective, we're well positioned to explore how some of the other application-layer
    protocols are tuned to their specific use cases in the next chapter, where we'll
    dive into the **File Transfer Protocol** (**FTP**) and the **Simple Mail Transfer
    Protocol** (**SMTP**).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the definition of HTTP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does SOAP mean? What does REST mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the primary differences between SOAP services and REST services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does MVC stand for, and how does it apply to the Web API project template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Kestrel and how is it used in ASP.NET Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the various methods of HTTP? Which are safe? Why are they safe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does HTTPS stand for? How does it provide security?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What new features are supported in HTTP/2? What requirements must be met to
    leverage it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information about HTTP in .NET Core, or using ASP.NET Core, you have
    a wealth of resources at your disposal. Particularly, I'd recommend *Hands-On
    Full-Stack Web Development with ASP.NET Core*, by Tamir Dresher, Amir Zuker, and
    Shay Friedman, available through Packt Publishing here: [https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core](https://www.packtpub.com/web-development/hands-full-stack-web-development-aspnet-core).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to take a deeper dive into the patterns and principles that informed
    the developers of ASP.NET Core, I'd recommend reading *ASP.NET Core 2 Fundamentals*,
    by Onur Gumus and Mugilan T S Ragupathi. It's also available from Packt, and you
    can find it here: [https://www.packtpub.com/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/web-development/aspnet-core-2-fundamentals).
  prefs: []
  type: TYPE_NORMAL
- en: If you're more interested in the fundamentals of the MVC design pattern, and
    how ASP.NET Core uses it to provide clean architectural templates for web applications,
    check out *ASP.NET Core MVC 2.0 Cookbook*, by Engin Polat and Stephane Belkheraz.
    That book can be found through Packt Publishing here: [https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook](https://www.packtpub.com/application-development/aspnet-core-mvc-20-cookbook).
  prefs: []
  type: TYPE_NORMAL
