<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-126"><a id="_idTextAnchor245"/>6</h1>
<h1 id="_idParaDest-127"><a id="_idTextAnchor246"/>Data Access in ASP.NET Core (Part 2 – Entity Relationships)</h1>
<p>In <a href="B18971_05.xhtml#_idTextAnchor198"><em class="italic">Chapter 5</em></a>, we introduced the fundamentals of <code>DbContext</code> class and how to use it to access data.</p>
<p>You can recap the basic concepts of relationships in <a href="B18971_01.xhtml#_idTextAnchor012"><em class="italic">Chapter 1</em></a>, in the <em class="italic">Defining the Relationships between Resources </em>section, where we introduced relationships between resources. For example, in a blog system, a post has a collection of comments, and a user has a collection of posts. In an invoice system, an invoice has a collection of invoice items, and an invoice item belongs to an invoice. An invoice also has a contact, which can have one or more contact persons and can have one address.</p>
<p>In this chapter, we will continue to explore the features of EF Core. We will learn how to manage relationships between entities using Fluent APIs. Finally, we will discuss how to implement CRUD operations for entities with relationships.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>Understanding one-to-many relationships</li>
<li>Understanding one-to-one relationships</li>
<li>Understanding many-to-many relationships</li>
<li>Understanding owned entities</li>
</ul>
<p>After reading this chapter, you should be able to configure relationships between entities using Fluent APIs in EF Core and implement CRUD operations for entities with relationships in your ASP.NET Core applications.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor247"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6</a>. You can use VS 2022 or VS Code to open the solutions.</p>
<p>You are expected to have basic knowledge of <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) queries and <strong class="bold">Language-Integrated Query</strong> (<strong class="bold">LINQ</strong>). If you are not familiar with them, you can refer to the following resources:</p>
<ul>
<li><strong class="bold">SQL </strong><strong class="bold">queries</strong>: <a href="https://www.w3schools.com/sql/">https://www.w3schools.com/sql/</a></li>
<li><strong class="bold">LINQ</strong>: <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/">https://learn.microsoft.com/en-us/dotnet/csharp/linq/</a></li>
</ul>
<h1 id="_idParaDest-129"><a id="_idTextAnchor248"/>Understanding one-to-many relationships</h1>
<p>One-to-many relationships <a id="_idIndexMarker537"/>are the most common relationships in a relational database. They are <a id="_idIndexMarker538"/>also called <strong class="bold">parent-child (children)</strong> relationships. For example, an invoice has a collection of invoice items. In this section, we will learn how to configure a one-to-many relationship in EF Core and how to implement CRUD operations for entities with a one-to-many relationship.</p>
<p>Let us continue to use the invoice sample application. You can find the sample code of the <code>EfCoreRelationshipsDemo</code> project in the <code>chapter6</code> folder. If you would like to test the code following the book, you can continue to work on the <code>BasicEfCoreDemo</code> project. Note that the <code>InvoiceDbContext</code> class has been renamed <code>SampleDbContext</code> in the sample code.</p>
<p>Next, let us update the <code>Invoice</code> class and create an <code>InvoiceItem</code> class, then define the one-to-many relationship between them<a id="_idTextAnchor249"/>.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor250"/>One-to-many configuration</h2>
<p>To demonstrate a<a id="_idIndexMarker539"/> one-to-many relationship, we need to add a new class named <code>InvoiceItem</code> in the <code>Models</code> folder and add some additional properties to the <code>Invoice</code> class to represent the relationship between them.</p>
<p>The code of the <code>InvoiceItem</code> class is as follows:</p>
<pre class="source-code">
public class InvoiceItem{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public decimal UnitPrice { get; set; }
    public decimal Quantity { get; set; }
    public decimal Amount { get; set; }
    public Guid InvoiceId { get; set; }
    public Invoice? Invoice { get; set; }
}</pre>
<p>The <code>InvoiceItem</code> class has a set of properties to store the invoice item data, such as <code>Name</code>, <code>Description</code>, <code>UnitPrice</code>, and so on. It also has an <code>InvoiceId</code> property to store the ID of the invoice that the invoice item belongs to, and an <code>Invoice</code> property <a id="_idIndexMarker540"/>to reference the invoice. To get started with the configuration process, follow these steps:</p>
<ol>
<li>Update the <code>Invoice</code> class as follows:<pre class="source-code">
public class Invoice{    public Guid Id { get; set; }    // Omitted for brevity    // Add a collection of invoice items    public List&lt;InvoiceItem&gt; InvoiceItems { get; set; } = new ();}</pre><p class="list-inset">In the preceding code, we defined a relationship between <code>Invoice</code> and <code>InvoiceItem</code>. An invoice has a collection of invoice items, and an invoice item belongs to an invoice. It is a one-to-many relationship, where we can identify these terms:</p><ul><li><code>Invoice</code> is the principal entity.</li><li><code>InvoiceItem</code> is the dependent entity. It has an <code>InvoiceId</code> foreign key property to identify the parent entity.</li><li><code>Id</code> property of the <code>Invoice</code> class is the principal key.</li><li><code>InvoiceId</code> property of the <code>InvoiceItem</code> class is the foreign key, which<a id="_idIndexMarker544"/> is used to store the principal key value of the parent entity.</li><li><code>InvoiceItems</code> property of the <code>Invoice</code> class is a collection navigation property.</li><li><code>Invoice</code> property of the <code>InvoiceItem</code> class is a reference navigation property.</li></ul></li></ul></li> <li>Because <a id="_idIndexMarker548"/>we added a new model, we need to update the <code>DbContext</code> class. Open the <code>SampleDbContext</code> class and add the following code:<pre class="source-code">
public DbSet&lt;InvoiceItem&gt; InvoiceItems =&gt; Set&lt;InvoiceItem&gt;();</pre></li> <li>Also, it is a good practice to configure the mapping for the new model. Add a new class <a id="_idIndexMarker549"/>in the <code>Data</code> folder and name it <code>InvoiceItemConfiguration</code>:<pre class="source-code">
public class InvoiceItemConfiguration : IEntityTypeConfiguration&lt;InvoiceItem&gt;{    public void Configure(EntityTypeBuilder&lt;InvoiceItem&gt; builder)    {        builder.ToTable("InvoiceItems");        builder.Property(p =&gt; p.Id).HasColumnName(nameof(InvoiceItem.Id));        builder.Property(p =&gt; p.Name).HasColumnName(nameof(InvoiceItem.Name)).HasMaxLength(64).IsRequired();        builder.Property(p =&gt; p.Description).HasColumnName(nameof(InvoiceItem.Description)).HasMaxLength(256);        builder.Property(p =&gt; p.UnitPrice).HasColumnName(nameof(InvoiceItem.UnitPrice)).HasPrecision(8, 2);        builder.Property(p =&gt; p.Quantity).HasColumnName(nameof(InvoiceItem.Quantity)).HasPrecision(8, 2);        builder.Property(p =&gt; p.Amount).HasColumnName(nameof(InvoiceItem.Amount)).HasPrecision(18, 2);        builder.Property(p =&gt; p.InvoiceId).HasColumnName(nameof(InvoiceItem.InvoiceId));    }}</pre></li> <li>Once we define navigation properties for <code>Invoice</code> and <code>InvoiceItem</code>, EF Core can discover the relationship between these two entities. Let us create a migration using the <code>dotnet ef migrations add AddInvoiceItem</code> command. Then, check the generated migration file. You will find that EF Core <a id="_idIndexMarker550"/>has added the following code:<pre class="source-code">
migrationBuilder.CreateTable(    name: "InvoiceItems",    columns: table =&gt; new    {        Id = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),        // Omitted for brevity        InvoiceId = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false)    },    constraints: table =&gt;    {        table.PrimaryKey("PK_InvoiceItems", x =&gt; x.Id);        table.ForeignKey(            name: "FK_InvoiceItems_Invoices_InvoiceId",            column: x =&gt; x.InvoiceId,            principalTable: "Invoices",            principalColumn: "Id",            onDelete: ReferentialAction.Cascade);    });// Omitted for brevitymigrationBuilder.CreateIndex(    name: "IX_InvoiceItems_InvoiceId",    table: "InvoiceItems",    column: "InvoiceId");</pre><p class="list-inset">EF Core will create a new <code>InvoiceItems</code> table and add a foreign key constraint to the <code>InvoiceId</code> column. The name of the foreign key constraint is <code>FK_&lt;dependent type name&gt;_&lt;principal type name&gt;_&lt;foreign key property name&gt;</code>. It will also create an index on the <code>InvoiceId</code> column.</p></li> </ol>
<p>Another <a id="_idIndexMarker551"/>thing you need to be aware of is that the <code>onDelete</code> action is set to <code>ReferentialAction.Cascade</code>, which means that if the parent entity is deleted, all related child entities will also be deleted.</p>
<p>Let's think about a question – what if we do not have the <code>InvoiceId</code> property in the <code>InvoiceItem</code> class? Can EF Core still discover the relationship between these two entities? You can use the <code>dotnet ef migrations remove</code> command to remove the last migration, delete the <code>InvoiceId</code> property in the <code>InvoiceItem</code> class, and then add a migration again. You will see that EF Core can still create a column named <code>InvoiceId</code> in the <code>InvoiceItems</code> table, and apply the foreign key constraint to it, which is <a id="_idIndexMarker552"/>called <strong class="bold">shadow foreign key</strong> property. This is because EF Core has its built-in convention to do this. There are a few scenarios where EF Core can discover one-to-many relationships between entities:</p>
<ul>
<li>The dependent entity has a reference navigation property to the principal entity</li>
<li>The principal entity has a collection navigation property to the dependent entity</li>
<li>The reference navigation property and the collection navigation property are included at both ends</li>
<li>The reference navigation property and the collection navigation property are included at both ends, and the foreign key property is included in the dependent entity</li>
</ul>
<p>We can <a id="_idIndexMarker553"/>explicitly configure the relationship between entities to change the default behavior of EF Core if the convention does not work for us. Follow these steps:</p>
<ol>
<li>To explicitly configure the one-to-many relationship between entities, we can use the <code>HasOne()</code>, <code>WithMany()</code>, and <code>HasMany()</code>, <code>WithOne()</code> methods. Add the following code to the <code>InvoiceConfiguration</code> class:<pre class="source-code">
builder.HasMany(x =&gt; x.InvoiceItems)    .WithOne(x =&gt; x.Invoice)    .HasForeignKey(x =&gt; x.InvoiceId);</pre><p class="list-inset">The <code>HasMany()</code> method is used to configure the collection navigation property, and the <code>WithOne()</code> method is used to configure the reference navigation property. The <code>HasForeignKey()</code> method is used to configure the foreign key property. So, the preceding code explicitly configures that one invoice can have many invoice items, and the <code>InvoiceId</code> property of the <code>InvoiceItem</code> class is the foreign key. If you add a migration now, you will find that EF Core will generate the same code as that generated by the convention.</p></li> <li>A relationship can be also defined for the <code>InvoiceItem</code> class. Remove the preceding configuration code for the <code>Invoice</code> class, and add the following code to the <code>InvoiceItemConfiguration</code> class:<pre class="source-code">
builder.HasOne(i =&gt; i.Invoice)    .WithMany(i =&gt; i.InvoiceItems)    .HasForeignKey(i =&gt; i.InvoiceId)    .OnDelete(DeleteBehavior.Cascade);</pre><p class="list-inset">It should be easy to understand now. The <code>HasOne()</code> method is used to configure the reference navigation property, and the <code>WithMany</code> method is used to configure the collection navigation property.</p><p class="list-inset">Note that we also explicitly configured the <code>OnDelete()</code> action to <code>Cascade</code>, which is the same as the one generated by the convention. But we can change it to other options if needed. That said, the Fluent API is more flexible than the convention.</p></li> <li>We <a id="_idIndexMarker554"/>just need to configure the relationship on one side of the relationship. So, please clean up the test code before you add the migration file and apply the migration to the database. After the migration is applied, you can check the database schema to see if the foreign key constraint is created, as shown in the following figure:</li>
</ol>
<div><div><img alt="Figure 6.1 – A foreign key constraint is created in the database" src="img/B18971_06_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – A foreign key constraint is created in the database</p>
<p>As a one-to-many relationship can be defined in either direction, which side should we configure the relationship on? It depends on the scenario. If the two entities have a strong one-to-many relationship, it does not really matter which side we configure the relationship on. But if the two entities are loosely coupled, we had better configure the relationship on the dependent entity.</p>
<p>For example, a <code>User</code> entity is shared by many other entities, such as <code>Post</code>, <code>Comment</code>, <code>Invoice</code>, and so on. Each <code>Post</code> entity can have an <code>Author</code> property that is a reference navigation property to the <code>User</code> entity, and <code>Comment</code> and <code>Invoice</code> also do the same. However, the <code>User</code> entity does not need to have the collection navigation properties to the <code>Post</code>, <code>Comment</code>, and <code>Invoice</code> entities. In this case, we should configure the relationship on the <code>Post</code>, <code>Comment</code>, and <code>Invoice</code> entities.</p>
<p>To configure<a id="_idIndexMarker555"/> this kind of relationship, we can ignore the parameter for the <code>WithMany</code> method, because the <code>User</code> entity does not have the collection navigation property to the <code>Post</code> entity, as shown in the following code:</p>
<pre class="source-code">
public void Configure(EntityTypeBuilder&lt;Post&gt; builder){
    // Omitted for brevity
    builder.HasOne(x =&gt; x.Author)
        .WithMany()
        .HasForeignKey(x =&gt; x.AuthorId);
    // Omitted for brevity
}</pre>
<p>Next, let's see how we implement CRUD operations for entities with a one-to-m<a id="_idTextAnchor251"/>any relationship.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor252"/>One-to-many CRUD operations</h2>
<p>CRUD operations<a id="_idIndexMarker556"/> for entities with<a id="_idIndexMarker557"/> a one-to-many relationship differ from those without a relationship. For example, when retrieving an invoice, we may need to query both the <code>Invoices</code> table and the <code>InvoiceItems</code> table in order to also retrieve the associated invoice items. Additionally, when deleting an invoice, we must consider whether to delete the related invoice items as well.</p>
<p>EF Core can assist us in managing various scenarios. For instance, when we need to retrieve an invoice and its invoice items, EF Core can generate a <code>LEFT JOIN</code> query to join the two tables. To implement<a id="_idIndexMarker558"/> CRUD operations for entities with a one-to-many relationship, let us explore the<a id="_idTextAnchor253"/> following sections.</p>
<h3>Creating data</h3>
<p>First, let <a id="_idIndexMarker559"/>us create a new invoice with a few invoice items. You do not need to update the code of the <code>PostInvoice</code> action:</p>
<ol>
<li>Run the application using <code>dotnet run</code>. Send a <code>POST</code> request to the <code>/api/Invoices</code> endpoint. The JSON body is like this:<pre class="source-code">
{  "invoiceNumber": "INV-004",  "contactName": "Hulk",  "description": "Invoice for the first month",  "amount": 300,  "invoiceDate": "2022-12-28T01:39:42.915Z",  "dueDate": "2022-12-28T01:39:42.915Z",  "status": 1,  "invoiceItems": [    {      "name": "Invoice Item 1",      "description": "",      "unitPrice": 100,      "quantity": 2,      "amount": 200    },    {      "name": "Invoice Item 2",      "description": "",      "unitPrice": 50,      "quantity": 2,      "amount": 100    }  ]}
An unhandled exception has occurred while executing the request.System.Text.Json.JsonException: A possible object cycle was detected. This can either be due to a cycle or if the object depth is larger than the maximum allowed depth of 32. Consider using ReferenceHandler.Preserve on JsonSerializerOptions to support cycles. Path: $.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.Invoice.InvoiceItems.</pre><p class="list-inset">The exception is thrown because the <code>Invoice</code> class has a collection navigation property to the <code>InvoiceItem</code> class, and the <code>InvoiceItem</code> class has a reference navigation property to the <code>Invoice</code> class. So, there is a cycle in the JSON serialization. Some serialization frameworks, such as <code>Newtonsoft.Json</code>, <code>System.Text.Json</code>, do not allow such cycles. ASP.NET Core uses <code>System.Text.Json</code> for JSON serialization by default. So, we need to configure the <code>System.Text.Json</code> framework to ignore the cycle.</pre></li> <li>Open <a id="_idIndexMarker561"/>the <code>Program.cs</code> file and add the following code to <code>builder.Services.AddControllers()</code>:<pre class="source-code">
builder.Services    .AddControllers()    .AddJsonOptions(options =&gt;    {        options.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.IgnoreCycles;    });</pre><p class="list-inset">Another way to fix the exception is to use the <code>[JsonIgnore]</code> attribute to decorate the <code>Invoice</code> property in the <code>InvoiceItem</code> class. But if you have many entities with such a relationship, it is tedious to decorate all of them. Choose the way you prefer.</p><p class="list-inset">This exception occurs after data is saved to the database. So, if you check the database, you will find that the invoice and the invoice items are saved to the database:</p></li> </ol>
<div><div><img alt="Figure 6.2 – The invoice items are saved to the database with the invoice ID" src="img/B18971_06_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – The invoice items are saved to the database with the invoice ID</p>
<p class="callout-heading">What is System.Text.Json?</p>
<p class="callout"><code>System.Text.Json</code> is a new JSON serialization framework provided since .NET Core 3.0. It is faster and more efficient than <code>Newtonsoft.Json</code>. It is also the default JSON serialization framework in ASP.NET Core 3.0 and later versions. It is recommended to use <code>System.Text.Json</code> instead of <code>Newtonsoft.Json</code> in new projects.</p>
<p>From the <a id="_idIndexMarker562"/>preceding example, you can see these points:</p>
<ul>
<li>EF Core generates an <code>Id</code> property of the principal entity if it is not defined in the model.</li>
<li>EF Core generates an <code>Id</code> property of the dependent entity if it is not defined in the model.</li>
<li>EF Core generates a foreign key property of the dependent entity, which is <code>InvoiceId</code> in this case, if it is not defined in the model.</li>
<li>When the principal entity is added to the database, dependent entities are also added to the database automatically. You do not need to add dependent entities explicitly.</li>
</ul>
<p>So, what if you want to add a new invoice item to an existing invoice? You can do it in two ways:</p>
<ul>
<li>Get the invoice first, then add the new invoice item to the <code>InvoiceItems</code> collection of the invoice, and then call the <code>SaveChanges()</code> method to save the changes to the database. This is an <code>Update</code> operation for the invoice, which means it should be a <code>PUT</code> action.</li>
<li>Create a new invoice item, set the <code>InvoiceId</code> property to the <code>Id</code> property of the invoice, and then call the <code>SaveChanges()</code> method to save the changes to the database. This is a <code>Create</code> operation for the invoice item, which means it should be a <code>POST</code> action. Also, you need to provide an endpoint for the invoice item separately.</li>
</ul>
<p>An invoice item cannot exist without an invoice. So, typically, you interact with the invoice item through the invoice. From a practical point of view, the first way is more common if the dependent entity count is not large. However, it depends on your scenario. If the principal entity has a large number of dependent entities, updating the entire principal entity may be inefficient and expensive. In this case, you can expose a separate endpoint to operate the dependent entity. For example, one blog post <a id="_idIndexMarker563"/>may have a large number of comments. It is common to add a new comment to a blog post, but it is not necessary to update the entire blog post and other comments. This is related to another concept, <strong class="bold">domain-driven design</strong> (<strong class="bold">DDD</strong>), which is <a id="_idIndexMarker564"/>to model domain objects and their relationships. We will talk ab<a id="_idTextAnchor254"/>out it in later chapters.</p>
<h3>Querying data</h3>
<p>Now we have <a id="_idIndexMarker565"/>an invoice and some invoice items in the database, we can send a <code>GET</code> request to the <code>/api/Invoices</code> endpoint. You can see the following response:</p>
<pre class="source-code">
[  {
    "id": "a224e90a-c01c-499b-7a9b-08dae9f04218",
    "invoiceNumber": "INV-004",
    "contactName": "Hulk",
    "description": "Invoice for the first month",
    "amount": 300,
    "invoiceDate": "2022-12-28T01:39:42.915+00:00",
    "dueDate": "2022-12-28T01:39:42.915+00:00",
    "status": 1,
    "invoiceItems": []
  },
  ...
]</pre>
<p>The response contains a list of invoices. But the <code>InvoiceItems</code> property is empty. This is because the <code>InvoiceItems</code> property is a collection navigation property. By default, EF Core does not include dependent entities in the query result, so you need to explicitly include these in the query result. Follow these steps to query the invoice and invoice<a id="_idIndexMarker566"/> items from the database:</p>
<ol>
<li>Open the <code>InvoicesController.cs</code> file, and update the code of the <code>GetInvoices()</code> method to this:<pre class="source-code">
// GET: api/Invoices[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,    InvoiceStatus? status = null){    // Omitted for brevity    return await context.Invoices        .Include(x =&gt; x.InvoiceItems)        .Where(x =&gt; status == null || x.Status == status)        .OrderByDescending(x =&gt; x.InvoiceDate)        .Skip((page - 1) * pageSize)        .Take(pageSize)        .ToListAsync();}</pre><p class="list-inset">In the preceding code, we use the <code>Include</code> method to include dependent entities in the query result.</p></li> <li>Restart the application and send the same request again. Now, you will see the result includes invoice items, as shown here:<pre class="source-code">
[  {    "id": "a224e90a-c01c-499b-7a9b-08dae9f04218",    "invoiceNumber": "INV-004",    "contactName": "Hulk",    "description": "Invoice for the first month",    "amount": 300,    "invoiceDate": "2022-12-28T01:39:42.915+00:00",    "dueDate": "2022-12-28T01:39:42.915+00:00",    "status": 1,    "invoiceItems": [      {        "id": "8cc52722-5b99-4d0c-07ef-08dae9f04223",        "name": "Invoice Item 1",        "description": "",        "unitPrice": 100,        "quantity": 2,        "amount": 200,        "invoiceId": "a224e90a-c01c-499b-7a9b-08dae9f04218",        "invoice": null      },      {        "id": "2d3f739a-2280-424b-07f0-08dae9f04223",        "name": "Invoice Item 2",        "description": "",        "unitPrice": 50,        "quantity": 2,        "amount": 100,        "invoiceId": "a224e90a-c01c-499b-7a9b-08dae9f04218",        "invoice": null      }    ]  },  ...]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (35ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']      SELECT [t].[Id], [t].[Amount], [t].[ContactName], [t].[Description], [t].[DueDate], [t].[InvoiceDate], [t].[InvoiceNumber], [t].[Status], [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice]      FROM (          SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]          FROM [Invoices] AS [i]          ORDER BY [i].[InvoiceDate] DESC          OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY      ) AS [t]      LEFT JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]      ORDER BY [t].[InvoiceDate] DESC, [t].[Id]</pre><p class="list-inset">As you see, when the LINQ query uses the <code>Include()</code> method to include dependent entities, EF Core will generate a <code>LEFT </code><code>JOIN</code> query.</pre></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">The <code>Include()</code> method is a convenient way to include dependent entities. However, it may cause performance issues when the collection of dependent entities is large. For example, a post may have hundreds or thousands of comments. It is not a good idea to include all comments in the query result for a list page. In this case, it is not necessary to include dependent entities in the query.</p>
<ol>
<li value="3">Note <a id="_idIndexMarker568"/>that the query includes <code>Invoice</code> data in each row of the result. For some scenarios, it may cause a <a id="_idIndexMarker569"/>so-called <code>AsSplitQuery()</code> method as follows:<pre class="source-code">
[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,    InvoiceStatus? status = null){    // Omitted for brevity    return await context.Invoices        .Include(x =&gt; x.InvoiceItems)        .Where(x =&gt; status == null || x.Status == status)        .OrderByDescending(x =&gt; x.InvoiceDate)        .Skip((page - 1) * pageSize)        .Take(pageSize)        .AsSplitQuery()        .ToListAsync();}
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      FROM (          SELECT [i].[Id], [i].[InvoiceDate]      Executed DbCommand (2ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]      FROM [Invoices] AS [i]      ORDER BY [i].[InvoiceDate] DESC, [i].[Id]      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLYinfo: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (2ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']      SELECT [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice], [t].[Id]      FROM (          SELECT [i].[Id], [i].[InvoiceDate]          FROM [Invoices] AS [i]          ORDER BY [i].[InvoiceDate] DESC          OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY      ) AS [t]      INNER JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]      ORDER BY [t].[InvoiceDate] DESC, [t].[Id]</pre><p class="list-inset">The query contains two <code>SELECT</code> statements. The first <code>SELECT</code> statement is used to query the invoices. The second <code>SELECT</code> statement is used to query the invoice items. The <code>INNER JOIN</code> query is used to join the two queries.</pre></li> <li>You can<a id="_idIndexMarker571"/> also configure the default query-splitting behavior globally by using the <code>UseQuerySplittingBehavior()</code> method in the <code>OnConfiguring()</code> method of your <code>DbContext</code> class. The following code shows how to configure the default query splitting behavior to <code>SplitQuery</code> in the <code>SampleDbContext</code> class:<pre class="source-code">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder){    base.OnConfiguring(optionsBuilder);    optionsBuilder.UseSqlServer(_configuration.GetConnectionString("DefaultConnection"),        b =&gt; b.UseQuerySplittingBehavior(QuerySplittingBehavior.SplitQuery));}</pre><p class="list-inset">In this case, you<a id="_idIndexMarker572"/> don’t need to use the <code> AsSplitQuery()</code> method in your LINQ queries. If you want to execute a specific query in a single query, you can use the <code>AsSingleQuery()</code> method like this:</p><pre class="source-code">[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(int page = 1, int pageSize = 10,    InvoiceStatus? status = null){    // Omitted for brevity    return await _context.Invoices        .Include(x =&gt; x.InvoiceItems)        .Where(x =&gt; status == null || x.Status == status)        .OrderByDescending(x =&gt; x.InvoiceDate)        .Skip((page - 1) * pageSize)        .Take(pageSize)        .AsSingleQuery()        .ToListAsync();}</pre></li> </ol>
<p>However, split queries may cause other issues. For example, multiple queries increase the number of round trips to the database. In addition, if another thread modifies the <a id="_idIndexMarker573"/>data between the two queries, the result may be inconsistent. Therefore, you should consider the pros and cons of sp<a id="_idTextAnchor255"/>lit queries to fit your scenarios.</p>
<h3>Retrieving data</h3>
<p>Next, let's<a id="_idIndexMarker574"/> see how to retrieve data by ID. In the <code>GetInvoice</code> action, we use <code>await _context.Invoices.FindAsync(id)</code> to find the invoice by its ID. Send a <code>Get</code> request to the <code>/api/Invoices/{id}</code> endpoint with a valid ID. You will see the response contains an empty <code>InvoiceItems</code> array. This is because the <code>InvoiceItems</code> property is not included in the query. To include the <code>InvoiceItems</code> property in the query, you can use the <code>Include</code> method in the LINQ query. The following code shows how to use the <code>Include</code> method to include the <code>InvoiceItems</code> property in the query:</p>
<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(int id)
{
    var invoice = await context.Invoices
        .Include(x =&gt; x.InvoiceItems)
        .SingleOrDefaultAsync(x =&gt; x.Id == id);
    if (invoice == null)
    {
        return NotFound();
    }
    return invoice;
}</pre>
<p>The generated SQL query is as follows:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (4ms) [Parameters=[@__id_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT [i0].[Id], [i0].[Amount], [i0].[Description], [i0].[InvoiceId], [i0].[Name], [i0].[Quantity], [i0].[UnitPrice], [t].[Id]
      FROM (
          SELECT TOP(1) [i].[Id]
          FROM [Invoices] AS [i]
          WHERE [i].[Id] = @__id_0
      ) AS [t]
      INNER JOIN [InvoiceItems] AS [i0] ON [t].[Id] = [i0].[InvoiceId]
      ORDER BY [t].[Id]</pre>
<p>The query <a id="_idIndexMarker575"/>contains two <code>SELECT</code> statements, and the <code>INNER JOIN</code> query is used to join the two statements. In this way, you can retrieve the invoice <a id="_idTextAnchor256"/>and invoice items in a single query.</p>
<h3>Deleting data</h3>
<p>In the <em class="italic">One-to-many configuration</em> section, we introduced how to configure the <code>OnDelete</code> action to set the <code>DeleteBehavior</code> enum to <code>Cascade</code>. There are other options for<a id="_idIndexMarker576"/> the <code>DeleteBehavior</code> enum. Think about the following scenario in a one-to-many relationship:</p>
<ul>
<li>An invoice has a list of invoice items</li>
<li>A user deletes an invoice</li>
</ul>
<p>In this case, you may want to delete the related invoice items when the invoice is deleted because an invoice item cannot exist without an invoice. This behavior is called <strong class="bold">cascade delete</strong>. To<a id="_idIndexMarker577"/> delete the data, follow these steps:</p>
<ol>
<li>Run the application and send a <code>Delete</code> request to the <code>/api/Invoices/{id}</code> endpoint with a valid ID. You will see the invoice and the related invoice items are deleted from the database. Note that if the <code>OnDelete()</code> method is configured as <code>Cascade</code> or <code>ClientCascade</code>, loading related entities using the <code>Include()</code> method in the LINQ query is not required. The<a id="_idIndexMarker578"/> cascade delete behavior is applied at the database level. You can see the generated SQL query, which just deletes the <code>Invoice</code> entity, here:<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (9ms) [Parameters=[@__id_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']      DELETE FROM [i]      FROM [Invoices] AS [i]      WHERE [i].[Id] = @__id_0</pre><p class="list-inset">However, in some scenarios, you may want to keep dependent entities when the principal entity is deleted, for example:</p><ul><li>A category has a list of blog posts</li><li>A user deletes a category</li></ul><p class="list-inset">It is not necessary to delete blog posts when a category is deleted, because the blog posts can still exist without a category and can be assigned to another category. However, if a category is deleted, the <code>CategoryId</code> property of a blog post, which is a foreign key, will no longer match the primary key of any category. Therefore, you may want to set the <code>CategoryId</code> property to <code>null</code> when a category is deleted. This behavior is called <code>CategoryId</code> property is nullable. If the <code>CategoryId</code> property of a blog post entity is not nullable, EF Core will throw an exception when you try to delete a category because it will violate the foreign key constraint.</p></li> <li>In the sample code, there is an example of this case. You can find the <code>Category</code> and <code>Post</code> classes in the <code>Models</code> folder. Similar to the <code>Invoice</code> and <code>InvoiceItem</code> classes, they have a one-to-many relationship. However, the <code>CategoryId</code> property in the <code>Post</code> class is nullable. Therefore, you can set <code>DeleteBehavior</code> to <code>ClientSetNull</code> to nullify the <code>CategoryId</code> property when a category is deleted.<p class="list-inset">The following <a id="_idIndexMarker580"/>code shows how to configure <code>DeleteBehavior</code> to <code>ClientSetNull</code>:</p><pre class="source-code">
public class PostConfiguration : IEntityTypeConfiguration&lt;Post&gt;{    public void Configure(EntityTypeBuilder&lt;Post&gt; builder)    {        builder.ToTable("Posts");        // Omitted for brevity        builder.Property(p =&gt; p.CategoryId).HasColumnName("CategoryId");        builder.HasOne(p =&gt; p.Category)            .WithMany(c =&gt; c.Posts)            .HasForeignKey(p =&gt; p.CategoryId)            .OnDelete(DeleteBehavior.ClientSetNull);    }}</pre><p class="list-inset">In the <code>OnDelete()</code> method, you can pass the <code>DeleteBehavior</code> enum to set <code>DeleteBehavior</code> to <code>ClientSetNull</code>. The <code>ClientSetNull</code> value means that the foreign key property will be set to <code>null</code> when the principal entity is deleted.</p></li> <li>In the <code>CategoriesController</code> class, you can find the <code>DeleteCategory()</code> method. It is similar to the <code>DeleteInvoice()</code> method in the <code>InvoicesController</code> class. The only difference is that we need to remove the relationship between the category and the blog posts before deleting the category. The following code shows how to remove the relationship between the category and the blog posts:<pre class="source-code">
var category = await context.Categories.Include(x =&gt; x.Posts).SingleOrDefaultAsync(x =&gt; x.Id == id);if (category == null){    return NotFound();}category.Posts.Clear();// Or you can update the posts to set the category to null// foreach (var post in category.Posts)// {//     post.Category = null;// }context.Categories.Remove(category);await context.SaveChangesAsync();</pre><p class="list-inset">You <a id="_idIndexMarker581"/>can clear the <code>Posts</code> property of the category entity, or you can update the <code>Category</code> property of the blog posts to set it to <code>null</code>. In this way, the <code>CategoryId</code> property of the blog posts will be set to <code>null</code> when the category is deleted. Also, it is required to load related entities using the <code>Include</code> method, because EF Core needs to track the changes of related entities as well.</p></li> <li>Run the application and send a <code>Delete</code> request to the <code>/api/Categories/{id}</code> endpoint with a valid ID. Check the database, and you will see the category is deleted, but the blog posts are not deleted. Instead, the <strong class="bold">CategoryId</strong> property of the blog posts is set to <strong class="bold">NULL</strong>:</li>
</ol>
<div><div><img alt="Figure 6.3 – The CategoryId property of the blog posts is set to NULL when the category is deleted" src="img/B18971_06_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – The CategoryId property of the blog posts is set to NULL when the category is deleted</p>
<ol>
<li value="5">Check <a id="_idIndexMarker582"/>the generated SQL query, and you will see that EF Core executes two SQL queries. The first query is to update the <code>CategoryId</code> property of the blog posts to <code>null</code>. The second query is to delete the category. The generated SQL query is as follows:<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (6ms) [Parameters=[@p1='?' (DbType = Guid), @p0='?' (DbType = Guid), @p2='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']      SET NOCOUNT ON;      UPDATE [Posts] SET [CategoryId] = @p0      OUTPUT 1      WHERE [Id] = @p1;      DELETE FROM [Categories]      OUTPUT 1      WHERE [Id] = @p2;</pre><p class="list-inset">That says the posts now have no category, which means the relationship between the category and the blog posts is removed. You can assign the blog posts to another category to recreate the relationship following your business logic.</p></li> </ol>
<p>It is important <a id="_idIndexMarker583"/>to understand the consequences of deleting an entity when it has relationships. Keep in mind that some databases may not support cascading deletes. So, the <code>DeleteBehavior</code> enum contains quite a few values to allow you to fine-tune the behavior when deleting an entity. Generally, it is recommended to use <code>ClientCascade</code> or <code>ClientSetNull</code> because EF Core can perform cascading deletes or nullification if the database does not support cascading deletes.</p>
<p>So far, we have learned how to configure a one-to-many relationship and how to implement CRUD operations for entities with a one-to-many relationship. Next, let's move on to another type <a id="_idTextAnchor257"/>of relationship: a one-to-one relationship.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor258"/>Understanding one-to-one relationships</h1>
<p>A one-to-one relationship<a id="_idIndexMarker584"/> means that one entity has a relationship with only one entity of another type. For example, a bicycle requires one lock, which can only be used for that particular bicycle. Similarly, a person is only allowed to possess one driver’s license, which is designated for their use only. In our sample code, a <code>Contact</code> entity has only one <code>Address</code> entity, and an <code>Address</code> entity belongs to only one <code>Contact</code> entity. In the previous section, you learned how to configure a one-to-many relationship using the <code>HasOne()/WithMany()</code> and <code>HasMany()/WithOne()</code> methods. In this section, you will learn how to configure a one-to-one relati<a id="_idTextAnchor259"/>onship using the <code>HasOne()</code> and <code>WithOne()</code> methods.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor260"/>One-to-one configuration</h2>
<p>In a<a id="_idIndexMarker585"/> one-to-one relationship, both sides have a reference navigation property. Technically, both sides have equal positions. However, to explicitly configure the relationship, we need to specify which side is the dependent side and which side is the principal side. The foreign key property is normally defined on the dependent side. In the following example, we will configure a one-to-one relationship between the <code>Contact</code> class and the <code>Address</code> class:</p>
<pre class="source-code">
public class Contact{
    public Guid Id { get; set; }
    public string FirstName { get; set; } = string.Empty;
    public string LastName { get; set; } = string.Empty;
    public string? Title { get; set; }
    public string Email { get; set; } = string.Empty;
    public string Phone { get; set; } = string.Empty;
    public Address Address { get; set; }
}
public class Address
{
    public Guid Id { get; set; }
    public string Street { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
    public string State { get; set; } = string.Empty;
    public string ZipCode { get; set; } = string.Empty;
    public string Country { get; set; } = string.Empty;
    public Guid ContactId { get; set; }
    public Contact Contact { get; set; }
}</pre>
<p>In the <a id="_idIndexMarker586"/>preceding code, a <code>ContactId</code> foreign key is defined in the <code>Address</code> class, which implies that the <code>Address</code> class is the dependent entity, and the <code>Contact</code> class is the principal entity. If you do not define a foreign key property here, EF Core will automatically choose one of the entities to be the dependent entity. However, because <code>Contact</code> and <code>Address</code> are equal in a one-to-one relationship, EF Core may not choose the correct <a id="_idIndexMarker587"/>entity as we expect. So, we need to explicitly define a foreign key property in the dependent entity.</p>
<p>The configuration of a one-to-one relationship is as follows:</p>
<pre class="source-code">
public class ContactConfiguration : IEntityTypeConfiguration&lt;Contact&gt;{
    public void Configure(EntityTypeBuilder&lt;Contact&gt; builder)
    {
        builder.ToTable("Contacts");
        builder.HasKey(c =&gt; c.Id);
        // Omitted for brevity
        builder.Property(c =&gt; c.Phone).IsRequired();
    }
}
public class AddressConfiguration : IEntityTypeConfiguration&lt;Address&gt;
{
    public void Configure(EntityTypeBuilder&lt;Address&gt; builder)
    {
        builder.ToTable("Addresses");
        builder.HasKey(a =&gt; a.Id);
        // Omitted for brevity
        builder.Ignore(a =&gt; a.Contact);
        builder.HasOne(a =&gt; a.Contact)
            .WithOne(c =&gt; c.Address)
            .HasForeignKey&lt;Address&gt;(a =&gt; a.ContactId);
    }
}</pre>
<p>The <a id="_idIndexMarker588"/>preceding code uses <code>HasOne</code>/<code>WithOne</code> to define the one-to-one relationship. This can be defined in either the <code>Contact</code> configuration or <code>Address</code> configuration. The <code>HasForeignKey</code> method is used to specify the foreign key property. If you want to define the relationship in the <code>Contact</code> configuration, the code may look like this:</p>
<pre class="source-code">
builder.HasOne(c =&gt; c.Address)    .WithOne(a =&gt; a.Contact)
    .HasForeignKey&lt;Address&gt;(a =&gt; a.ContactId);</pre>
<p>Run the following code to add the migration and update the database:</p>
<pre class="console">
dotnet ef migrations add AddContactAndAddressdotnet ef database update</pre>
<p>You will see the following code creates a <code>ContactId</code> foreign key on the <code>Addresses</code> table:</p>
<pre class="source-code">
migrationBuilder.CreateTable(    name: "Addresses",
    columns: table =&gt; new
    {
        Id = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
        // Omitted for brevity
    },
    constraints: table =&gt;
    {
        table.PrimaryKey("PK_Addresses", x =&gt; x.Id);
        table.ForeignKey(
            name: "FK_Addresses_Contacts_ContactId",
            column: x =&gt; x.ContactId,
            principalTable: "Contacts",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade);
    });</pre>
<p>After the <a id="_idIndexMarker589"/>migration is applied, the relationship between <strong class="bold">Contacts</strong> and <strong class="bold">Addresses</strong> is configured successfully, as shown in <em class="italic">Figure 6</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 6.4 – A ContactId foreign key is created on the Addresses table" src="img/B18971_06_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A ContactId foreign key is created on the Addresses table</p>
<p>Next, let's see how to implement CRUD operati<a id="_idTextAnchor261"/>ons for entities with a one-to-one relationship.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor262"/>One-to-one CRUD operations</h2>
<p>The CRUD operations <a id="_idIndexMarker590"/>of a one-to-one relationship <a id="_idIndexMarker591"/>are similar to those of a one-to-many relationship. EF Core can simplify CRUD operations for you. So, in this section, we will not explain all CRUD operations in detail. You will find a controller named <code>ContactsController.cs</code> in the sample repo, which implements CRUD operations for the <code>Contact</code> entity. You can check the code for the details.</p>
<p>The <code>Contact</code> and <code>Address</code> entities <a id="_idIndexMarker592"/>have a one-to-one relationship, meaning each <code>Contact</code> entity has one <code>Address</code> property and each <code>Address</code> entity belongs to only one <code>Contact</code> property. To illustrate how to query a <a id="_idIndexMarker593"/>contact with its address, we will use this example:</p>
<ol>
<li>To create a new contact with its address, you can send a <code>POST</code> request to the <code>api/contacts</code> endpoint. The request body is as follows:<pre class="source-code">
{    "firstName": "John",    "lastName": "Doe",    "email": "john.doe@example.com",    "phone": "1234567890",    "address": {        "street": "123 Main St",        "city": "Wellington",        "state": "Wellington",        "zipCode": "6011",        "country": "New Zealand"    }}</pre><p class="list-inset">In the JSON request body, the <code>address</code> object is a property of the <code>Contact</code> object. It is not required to send the <code>ContactId</code> property in the request body. EF Core will automatically set the <code>ContactId</code> property to the <code>Id</code> property of the <code>Contact</code> object.</p></li> <li>Similarly, when you query the contacts through the <code>api/contacts</code> endpoint, the <code>Address</code> object will not be included in the response body by default. You need to explicitly use the <code>Include</code> method to include the <code>Address</code> object <a id="_idIndexMarker594"/>in the query, as shown in the following code:<pre class="source-code">
// GET: api/Contacts[HttpGet]public async Task&lt;ActionResult&lt;IEnumerable&lt;Contact&gt;&gt;&gt; GetContacts(){    if (context.Contacts == null)    {        return NotFound();    }    return await context.Contacts.Include(x =&gt; x.Address).ToListAsync();}</pre></li> </ol>
<p>You can <a id="_idIndexMarker595"/>check the <code>ContactsController.cs</code> file for other CRUD operations and test them in Postman or any other REST client you like.</p>
<p>We have explored two types of relationships: one-to-many and one-to-one. Now, let us <a id="_idTextAnchor263"/>delve into another type of relationship: many-to-many.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor264"/>Understanding many-to-many relationships</h1>
<p>A <a id="_idIndexMarker596"/>many-to-many relationship is when an entity can be associated with multiple entities and vice versa. For example, a movie can have many actors, and an actor can act in many movies; a post can have many tags, and a tag can have many posts; a student can enroll in many courses, and a course can have many students, and so on. In this section, we will introduce h<a id="_idTextAnchor265"/>ow to configure a many-to-many relationship in EF Core.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor266"/>Many-to-many configuration</h2>
<p>In a <a id="_idIndexMarker597"/>many-to-many relationship, we need to define a collection navigation property on both sides. Here is an example of a many-to-many relationship between a <code>Movie</code> entity and an <code>Actor</code> entity:</p>
<pre class="source-code">
public class Movie{
    public Guid Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public string? Description { get; set; }
    public int ReleaseYear { get; set; }
    public List&lt;Actor&gt; Actors { get; set; } = new List&lt;Actor&gt;();
}
public class Actor
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public List&lt;Movie&gt; Movies { get; set; } = new List&lt;Movie&gt;();
}</pre>
<p>EF Core can detect the many-to-many relationship automatically following the convention. If you run the <code>dotnet ef migrations add AddMovieAndActor</code> command to add a migration, you will see the following code in the migration file:</p>
<pre class="source-code">
migrationBuilder.CreateTable(    name: "ActorMovie",
    columns: table =&gt; new
    {
        ActorsId = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
        MoviesId = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false)
    },
    constraints: table =&gt;
    {
        table.PrimaryKey("PK_ActorMovie", x =&gt; new { x.ActorsId, x.MoviesId });
        table.ForeignKey(
            name: "FK_ActorMovie_Actors_ActorsId",
            column: x =&gt; x.ActorsId,
            principalTable: "Actors",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade);
        table.ForeignKey(
            name: "FK_ActorMovie_Movies_MoviesId",
            column: x =&gt; x.MoviesId,
            principalTable: "Movies",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade);
    });</pre>
<p>Besides the code that creates <code>Movies</code> and <code>Actors</code> tables, the migration file also creates a join table named <code>ActorMovie</code> to store the foreign keys for both sides. The <code>ActorMovie</code> table has two foreign key properties, <code>ActorsId</code> and <code>MoviesId</code>, to associate the <code>Actor</code> entity and the <code>Movie</code> entity.</p>
<p>However, sometimes <a id="_idIndexMarker598"/>the automatic detection of the many-to-many relationship may not meet our requirements. For example, we may want to call the table <code>MovieActor</code> instead of <code>ActorMovie</code>, we may want to specify the foreign key properties as <code>ActorId</code> and <code>MovieId</code> instead of <code>ActorsId</code> and <code>MoviesId</code>, or we may even want to add some additional properties to the join table. In these cases, we can explicitly configure the many-to-many relationship.</p>
<p>First, we need to define a join entity to store the foreign keys for both sides. Here is an example of a join entity named <code>MovieActor</code>:</p>
<pre class="source-code">
public class MovieActor{
    public Guid MovieId { get; set; }
    public Movie Movie { get; set; } = null!;
    public Guid ActorId { get; set; }
    public Actor Actor { get; set; } = null!;
    public DateTime UpdateTime { get; set; }
}</pre>
<p>Also, we need to add a collection navigation property to the <code>Movie</code> and <code>Actor</code> entities:</p>
<pre class="source-code">
public class Movie{
    public Guid Id { get; set; }
    // Omitted other properties
    public List&lt;MovieActor&gt; MovieActors { get; set; } = new ();
}
public class Actor
{
    public Guid Id { get; set; }
    // Omited other properties
    public List&lt;MovieActor&gt; MovieActors { get; set; } = new ();
}</pre>
<p>Then, we<a id="_idIndexMarker599"/> configure the many-to-many relationship in the <code>Movie</code> configuration using the <code>HasMany()/WithMany()</code> methods, as shown here:</p>
<pre class="source-code">
public class MovieConfiguration : IEntityTypeConfiguration&lt;Movie&gt;{
    public void Configure(EntityTypeBuilder&lt;Movie&gt; builder)
    {
        // Omitted for brevity
        builder.HasMany(m =&gt; m.Actors)
            .WithMany(a =&gt; a.Movies)
            .UsingEntity&lt;MovieActor&gt;(
                j =&gt; j
                    .HasOne(ma =&gt; ma.Actor)
                    .WithMany(a =&gt; a.MovieActors)
                    .HasForeignKey(ma =&gt; ma.ActorId),
                j =&gt; j
                    .HasOne(ma =&gt; ma.Movie)
                    .WithMany(m =&gt; m.MovieActors)
                    .HasForeignKey(ma =&gt; ma.MovieId),
                j =&gt;
                {
                    // You can add more configuration here
                    j.Property(ma =&gt; ma.UpdateTime).HasColumnName("UpdateTime").HasDefaultValueSql("CURRENT_TIMESTAMP");
                    j.HasKey(ma =&gt; new { ma.MovieId, ma.ActorId });
                }
            );
    }
}</pre>
<p>Similarly, the <a id="_idIndexMarker600"/>configuration can be added to the <code>Actor</code> configuration as well. After adding the configuration, run the <code>dotnet ef migrations add AddMovieAndActor</code> command to add a migration; you will see the following code in the migration file:</p>
<pre class="source-code">
migrationBuilder.CreateTable(    name: "MovieActor",
    columns: table =&gt; new
    {
        MovieId = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
        ActorId = table.Column&lt;Guid&gt;(type: "uniqueidentifier", nullable: false),
        UpdateTime = table.Column&lt;DateTime&gt;(type: "datetime2", nullable: false, defaultValueSql: "CURRENT_TIMESTAMP")
    },
    constraints: table =&gt;
    {
        table.PrimaryKey("PK_MovieActor", x =&gt; new { x.MovieId, x.ActorId });
        table.ForeignKey(
            name: "FK_MovieActor_Actors_ActorId",
            column: x =&gt; x.ActorId,
            principalTable: "Actors",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade);
        table.ForeignKey(
            name: "FK_MovieActor_Movies_MovieId",
            column: x =&gt; x.MovieId,
            principalTable: "Movies",
            principalColumn: "Id",
            onDelete: ReferentialAction.Cascade);
    });</pre>
<p>You can <a id="_idIndexMarker601"/>see that the join table is renamed <code>MovieActor</code>, and the foreign key properties are renamed <code>MovieId</code> and <code>ActorId</code>. Also, the <code>UpdateTime</code> property is added to the join table.</p>
<p>After the migration is applied, you can see the join table in the database:</p>
<div><div><img alt="Figure 6.5 – The join table in the database" src="img/B18971_06_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The join table in the database</p>
<p>Another way (before EF Core 5.0) to configure a many-to-many relationship is to use the<a id="_idIndexMarker602"/> join entity to represent two separate one-to-many relationships. Here is an example of configuring a many-to-many relationship for the <code>Movie</code> and <code>Actor</code> entities:</p>
<pre class="source-code">
public class MovieActorsConfiguration : IEntityTypeConfiguration&lt;MovieActor&gt;{
    public void Configure(EntityTypeBuilder&lt;MovieActor&gt; builder)
    {
        builder.ToTable("MovieActors");
        builder.HasKey(sc =&gt; new { sc.MovieId, sc.ActorId });
        builder.HasOne(sc =&gt; sc.Actor)
            .WithMany(s =&gt; s.MovieActors)
            .HasForeignKey(sc =&gt; sc.ActorId);
        builder.HasOne(sc =&gt; sc.Movie)
            .WithMany(c =&gt; c.MovieActors)
            .HasForeignKey(sc =&gt; sc.MovieId);
    }
}</pre>
<p>In the preceding code, we configured two one-to-many relationships for the <code>Movie</code> and <code>Actor</code> entities on the <code>MovieActor</code> join entity. Each one-to-many relationship uses the <code>HasMany(), WithMany()</code>, and <code>HasForeignKey()</code> methods to configure the relationship. This <a id="_idIndexMarker603"/>combination of one-to-one relationships creates a many-to-many relationship.</p>
<p>You can use either way to configure a many-to-many relationship. The <code>HasMany()/WithMany()</code> methods is more convenient and easier to use.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor267"/>Many-to-many CRUD operations</h2>
<p>In a <a id="_idIndexMarker604"/>many-to-many relationship, such as <code>Movie</code> and <code>Actor</code>, we may need to get the actors of a movie or get the movies of an actor. So, we need to expose both entities through the REST API. You can create two controllers using the following commands:</p>
<pre class="source-code">
dotnet-aspnet-codegenerator controller -name MoviesController -api -outDir Controllers --model Movie --dataContext SampleDbContext -async -actionsdotnet-aspnet-codegenerator controller -name ActorsController -api -outDir Controllers --model Actor --dataContext SampleDbContext -async -actions</pre>
<p>Run the application and create some movies and actors.</p>
<p>We can include the actors of a movie when creating a movie. For example, we can create a movie with a couple of actors using the following JSON payload format:</p>
<pre class="source-code">
{    "title": "The Shawshank Redemption",
    "releaseYear": "1994",
    "actors": [
        {
            "name": "Tim Robbins"
        },
        {
            "name": "Morgan Freeman"
        },
        {
            "name": "Bob Gunton"
        },
        {
            "name": "William Sadler"
        }
    ]
}</pre>
<p>You will <a id="_idIndexMarker605"/>see the following result in the database:</p>
<div><div><img alt="Figure 6.6 – The join table has been populated" src="img/B18971_06_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The join table has been populated</p>
<p>Similarly, you can also include the movies of an actor when creating an actor. However, if we include related entities arbitrarily, we may end up with duplicate entities. For example, we create an actor with a couple of movies using the following JSON payload format:</p>
<pre class="source-code">
{    "name": "Tim Robbins",
    "movies": [
        {
            "title": "The Shawshank Redemption",
            "releaseYear": "1994"
        },
        {
            "title": "Green Mile",
            "releaseYear": "1999"
        }
    ]
}</pre>
<p>As a result, you<a id="_idIndexMarker606"/> will have two movies with the same title in the database. To avoid this, there are some options:</p>
<ul>
<li>Add a unique index to the <code>Title</code> property of the <code>Movie</code> entity to ensure that the title is unique. This is the simplest solution and can prevent duplicate entities from being added to the database.</li>
<li>Check if the entity already exists in the database before adding it.</li>
<li>Add movies and actors separately, and then update either the movie or the actor to include the other entity using the IDs of the other entity, instead of the whole entity.</li>
</ul>
<p>You can use a combination of the preceding options to improve the implementation. To add a unique index to the <code>Title</code> property of the <code>Movie</code> entity, you can update the following code of the <code>MovieConfiguration</code> class:</p>
<pre class="source-code">
public void Configure(EntityTypeBuilder&lt;Movie&gt; builder){
    builder.ToTable("Movies");
    builder.HasKey(m =&gt; m.Id);
    builder.Property(p =&gt; p.Title).HasColumnName("Title").HasMaxLength(128).IsRequired();
    // Add a unique index to the Title property
    builder.HasIndex(p =&gt; p.Title).IsUnique();
    // Omitted for brevity
}</pre>
<p>You can make <a id="_idIndexMarker607"/>the same change to the <code>Name</code> property of the <code>Actor</code> entity. After the change, you need to create a new migration and apply it to the database. This helps to prevent duplicate entities on the database level. If a request contains duplicate entities, the database will throw an exception.</p>
<p>It is possible to add or update related entities in the same request as the main entity. But sometimes, it might not be necessary. For example, an actor just acts in a new movie, and you want to create a new movie and add the actor to the movie. You can update the actor to include the new movie, but you have to send the whole actor entity in the request, including existing movies. It causes unnecessary data transfer.</p>
<p>To make the API easy to use, it is pragmatic to expose an additional API endpoint to update a collection of related entities only, rather than updating the whole entity. For example, we can create an <code>/api/actors/{id}/movies</code> endpoint to update the movies of an actor. It is a good practice to avoid updating a collection of related entities in the same request. We can just send the IDs of the related entities to the API endpoint. From the perspective of the API, the relationship is treated as a resource. In the <code>ActorsController.cs</code> file, you will find the following code:</p>
<pre class="source-code">
[HttpPost("{id}/movies/{movieId}")]public async Task&lt;IActionResult&gt; AddMovie(Guid id, Guid movieId)
{
    if (_context.Actors == null)
    {
        return NotFound("Actors is null.");
    }
    var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync(x =&gt; x.Id == id);
    if (actor == null)
    {
        return NotFound($"Actor with id {id} not found.");
    }
    var movie = await _context.Movies.FindAsync(movieId);
    if (movie == null)
    {
        return NotFound($"Movie with id {movieId} not found.");
    }
    if (actor.Movies.Any(x =&gt; x.Id == movie.Id))
    {
        return Problem($"Movie with id {movieId} already exists for Actor {id}.");
    }
    actor.Movies.Add(movie);
    await _context.SaveChangesAsync();
    return CreatedAtAction("GetActor", new { id = actor.Id }, actor);
}
[HttpGet("{id}/movies")]
public async Task&lt;IActionResult&gt; GetMovies(Guid id)
{
    if (_context.Actors == null)
    {
        return NotFound("Actors is null.");
    }
    var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync();
    if (actor == null)
    {
        return NotFound($"Actor with id {id} not found.");
    }
    return Ok(actor.Movies);
}
[HttpDelete("{id}/movies/{movieId}")]
public async Task&lt;IActionResult&gt; DeleteMovie(Guid id, Guid movieId)
{
    if (_context.Actors == null)
    {
        return NotFound("Actors is null.");
    }
    var actor = await _context.Actors.Include(x =&gt; x.Movies).SingleOrDefaultAsync();
    if (actor == null)
    {
        return NotFound($"Actor with id {id} not found.");
    }
    var movie = await _context.Movies.FindAsync(movieId);
    if (movie == null)
    {
        return NotFound($"Movie with id {movieId} not found.");
    }
    actor.Movies.Remove(movie);
    await _context.SaveChangesAsync();
    return NoContent();
}</pre>
<p>The preceding code exposes a few endpoints to add, get, and delete the movies of an actor. You can test the endpoints using the JSON payload format, as shown in the preceding <a id="_idIndexMarker608"/>code snippet:</p>
<ul>
<li>To add a movie to an actor, send a <code>POST</code> request to the <code>/api/actors/{id}/movies/{movieId}</code> endpoint. The <code>AddMovie</code> action will check if the movie already exists in the database. If it does, it will then check if the movie already exists in the movies of the actor. If not, it adds the movie to the collection and then saves the changes to the database.</li>
<li>To get the movies of an actor, send a <code>GET</code> request to the <code>/api/actors/{id}/movies</code> endpoint. The <code>GetMovies</code> action will return the movies of the actor. This endpoint can be updated to support pagination, sorting, and filtering.</li>
<li>To delete a movie from an actor, send a <code>DELETE</code> request to the <code>/api/actors/{id}/movies/{movieId}</code> endpoint. The <code>DeleteMovie</code> action will remove the movie from the collection and then save the changes to the database. Note that it does not delete the movie from the database; it just deletes the relationship between the movie and the actor.</li>
</ul>
<p>It is also possible to add a similar endpoint to the <code>MoviesController.cs</code> file to update the actors of a movie. You can use the same approach to implement endpoints. Try it yourself!</p>
<p class="callout-heading">Important note</p>
<p class="callout">When you call the <code>/api/actors</code> endpoint, you may find that the response contains <code>MovieActors</code> as well. This is not useful for the client. You can use the <code>JsonIgnore</code> attribute to ignore the property when serializing the response.</p>
<p>We have now discussed three common types of relationships: one-to-many, one-to-one, and many-to-many. You should now have a good understanding of how to configure relationships and implement CRUD operations for entities with rel<a id="_idTextAnchor268"/>ationships. Let's move on to our next topic: owned entity types.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor269"/>Understanding owned entities</h1>
<p>In the previous sections, we<a id="_idIndexMarker609"/> have learned some relationships are optional, but some are required. For example, a post can exist without a category, but a student ID card cannot exist without a student. For the latter, we can say a student owns an ID card. Similarly, a contact owns an address. We can also find some examples of one-to-many relationships. For example, an invoice owns many invoice items because an invoice item cannot exist without an invoice. In this section, we will introduce the concept of owned entities.</p>
<p>Owned entity types are entity types that are part of the owner and cannot exist without the owner. You can use common one-to-one or one-to-many relationships to model the owned entities, but EF Core provides a more convenient way called owned entity types. You can use the <code>OwnsOne()</code> or <code>OwnsMany()</code> method to define owned entity types, instead of using the <code>HasOne()</code> or <code>HasMany()</code> method. For example, to configure the <code>InvoiceItem</code> entity as an owned entity type of the <code>Invoice</code> entity, you can use the following code:</p>
<pre class="source-code">
public class InvoiceConfiguration : IEntityTypeConfiguration&lt;Invoice&gt;{
    public void Configure(EntityTypeBuilder&lt;Invoice&gt; builder)
    {
        // Omitted for brevity
        // Use the owned type to configure the InvoiceItems collection
        builder.OwnsMany(p =&gt; p.InvoiceItems, a =&gt;
            {
                a.WithOwner( =&gt; x.Invoice).HasForeignKey(x =&gt; x.InvoiceId);
                a.ToTable("InvoiceItems");
                // Omitted for brevity
            }
        );
    }
}</pre>
<p>As shown in<a id="_idIndexMarker610"/> the preceding code, you can use the <code>OwnsMany()/WithOwner()</code> methods to configure the owned entity type. The <code>OwnsMany()/WithOwner()</code> method specifies the owner of the owned entity type. The <code>HasForeignKey()</code> method specifies the foreign key property of the owned entity type. The configuration of the <code>InvoiceItem</code> entity is stored in the <code>InvoiceConfiguration</code> class.</p>
<p>Similarly, the configuration of the <code>Address</code> entity could be stored in the <code>ContactConfiguration</code> class like this:</p>
<pre class="source-code">
public class ContactConfiguration : IEntityTypeConfiguration&lt;Contact&gt;{
    public void Configure(EntityTypeBuilder&lt;Contact&gt; builder)
    {
        // Omitted for brevity
        // Use owned entity type
        builder.OwnsOne(c =&gt; c.Address, a =&gt;
        {
            a.WithOwner(x =&gt; x.Contact);
            a.Property(a =&gt; a.Street).HasColumnName("Street").HasMaxLength(64).IsRequired();
            // Omitted for brevity
        });
    }
}</pre>
<p>When you use the <code>OwnsOne()/WithOwner()</code> methods, you do not need to specify the foreign key property because the owned entity type will be stored in the same table as the owner by default. You can use the <code>ToTable</code> method to specify the table name of the owned entity type.</p>
<p>So, what is the <a id="_idIndexMarker611"/>difference between normal one-to-one or one-to-many and owned entity types? There are some differences:</p>
<ul>
<li>You cannot create a <code>DbSet&lt;T&gt;</code> property for an owned entity type. You can only use the <code>DbSet&lt;T&gt;</code> property for the owner. That means you do not have any way to access the owned entity type directly. You must access the owned entity type through the owner.</li>
<li>When you query the owner, the owned entity type will be included automatically. You do not need to use the <code>Include()</code> method to include the owned entity type explicitly. So, please be careful if the owner has many owned entities. It may cause performance issues.</li>
</ul>
<p>If your entities have a simple one-to-one or one-to-many relationship and the data is not large, you can use owned entity types to simplify the configuration. However, if the relationship is complex and the data size is large, you would be better off using normal one-to-one or one-to-many relationships <a id="_idTextAnchor270"/>because you can decide which related entities to include explicitly.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor271"/>Summary</h1>
<p>In this comprehensive chapter, we delved into modeling relationships between entities in EF Core. We explored various common relationship types, including one-to-one, one-to-many, and many-to-many relationships. We learned how to configure these relationships using essential methods such as <code>HasOne()/WithMany()</code>, <code>HasMany()/WithOne()</code>, and <code>HasMany()/WithMany()</code>. To broaden our understanding, we also explored configuring owned entity types using the <code>OwnsOne()/WithOwner()</code> and <code>OwnsMany/WithOwner()</code> methods.</p>
<p>To effectively operate on entities with relationships, we explained how to implement CRUD operations for each type of relationship. Particularly, we explained cascading delete operations, ensuring data integrity and efficient management of related entities.</p>
<p>The concepts learned in this chapter will help you model relationships between entities in your ASP.NET Core applications. In the next chapter, we will learn about some advanced topics of EF Core, such as concurrency control, performance tuning, and more.</p>
</div>
</body></html>