<html><head></head><body>
		<div id="_idContainer088">
			<h1 id="_idParaDest-137" class="chapter-number"><a id="_idTextAnchor144"/>8</h1>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor145"/>Storing and Retrieving Data</h1>
			<p>You now have all the fundamentals to create and navigate pages, layouts, and the controls used to populate pages. Congratulations! You are now a .NET <span class="No-Break">MAUI programmer.</span></p>
			<p>This chapter begins the intermediate section of the book, in which you will see how to store and retrieve data and then create unit tests – both critical aspects of writing real-world and, especially, <span class="No-Break">enterprise apps.</span></p>
			<p>Programs interact with data, and most need to store that data after an app closes and restore it as needed when the app resumes. In this chapter, we will consider two variations on this – long-term persistence of user preferences and long-term <span class="No-Break">database storage.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Storing <span class="No-Break">user preferences</span></li>
				<li>Storing to a database on <span class="No-Break">your device</span></li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor146"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need Visual Studio. You will also install another <strong class="source-inline">NuGet</strong> package, as shown later in <span class="No-Break">this chapter.</span></p>
			<p>The source code for the finished code in this chapter can be found here: <a href="https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence">https://github.com/PacktPublishing/.NET-MAUI-for-C-Sharp-Developers/tree/persistence</a>. To follow along, you will need to use the code from the <span class="No-Break">previous chapter.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor147"/>Storing user preferences</h1>
			<p>Most apps allow a <a id="_idIndexMarker330"/>user to set preferences that can be stored on a phone and retrieved, typically when the app starts. .NET MAUI provides a service for this, easily storing <em class="italic">key/value pairs</em>, such as theme preferences, the last date used, the login name, and <span class="No-Break">so on.</span></p>
			<p>.NET MAUI provides the <strong class="source-inline">IPreferences</strong> interface to help store these preferences. With this, and the associated <strong class="source-inline">Preferences</strong> class (both in the <strong class="source-inline">Microsoft.Maui.Storage</strong> namespace), you can store string keys and values of any of the <span class="No-Break">following types:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Boolean</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Double</strong></span></li>
				<li><strong class="source-inline">Int</strong> (<strong class="source-inline">int32</strong>, <strong class="source-inline">single</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">int64</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="source-inline">String</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">DateTime</strong></span></li>
			</ul>
			<p class="callout-heading">Persisting DateTime</p>
			<p class="callout"><strong class="source-inline">DateTime</strong> values are stored as 64-bit integers and use the <strong class="source-inline">ToBinary</strong> and <strong class="source-inline">FromBinary</strong> methods to encode and <span class="No-Break">decode respectively.</span></p>
			<p>Let’s create a <strong class="source-inline">UserPreferences</strong> page with a short form to gather a user’s preferences. We’ll also add <strong class="source-inline">Button</strong>, which will display all the saved preferences and allow the user to delete one or all <span class="No-Break">of them.</span></p>
			<p class="callout-heading">Name collisions</p>
			<p class="callout">We have a preferences page, which may cause a problem because we want to use the built-in <strong class="source-inline">Preferences</strong> object. To solve this, go to <strong class="source-inline">PreferencesViewModel</strong> and rename <strong class="source-inline">List&lt;Preference&gt;</strong> <strong class="source-inline">preferenceList</strong>. There should be no other conflicts. The safest way to rename is to use the Visual Studio rename functionality, which you can get to by putting your cursor on the name and entering <strong class="source-inline">Control-R R</strong>. After you rename, you may have to manually rename <strong class="source-inline">ObservableProperties</strong>, depending on the latest update to <span class="No-Break">Visual Studio.</span></p>
			<p>The<a id="_idIndexMarker331"/> new <strong class="source-inline">UserPreferences</strong> page will gather three preferences from the user, which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The user’s <span class="No-Break">display name</span></li>
				<li>The <span class="No-Break">preferred theme</span></li>
				<li>Whether the app can be used on cellular or <span class="No-Break">Wi-Fi only</span></li>
			</ul>
			<p class="callout-heading">Light and dark themes</p>
			<p class="callout">It has become common in apps to offer a user light and dark themes. In .NET MAUI, you can offer the user the choice, or if you are ambitious, you can create your <span class="No-Break">own themes.</span></p>
			<p class="callout">We will gather but not implement a user’s preferences relating to light and <span class="No-Break">dark themes.</span></p>
			<p>Here is the <span class="No-Break"><strong class="source-inline">UserPreferences</strong></span><span class="No-Break"> page:</span></p>
			<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;ContentPage
    Title="User Preferences"
    x:Class="ForgetMeNotDemo.View.UserPreferencesPage"
    xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"&gt;
    &lt;VerticalStackLayout&gt;
        &lt;Grid
            ColumnDefinitions="*,*"
            RowDefinitions="*,*,*,*"&gt;
            &lt;Label
                Grid.Column="0"
                Grid.Row="0"
                Text="Display Name" /&gt;
            &lt;Entry
                Grid.Column="1"
                Grid.Row="0"
                Placeholder="Your name as you want it
                   displayed"
                Text="{Binding DisplayName}" /&gt;</pre>
			<p>Having <a id="_idIndexMarker332"/>gathered the user’s display name, we can go on to ask them which of the two mutually exclusive themes they’d like. To do so, we will use <strong class="source-inline">RadioButtonGroup</strong> and two <strong class="source-inline">RadioButtons</strong>, initializing <strong class="source-inline">Light</strong> to <span class="No-Break">be selected:</span></p>
			<pre class="source-code">
            &lt;Label
                Grid.Column="0"
                Grid.Row="1"
                Text="Theme" /&gt;
            &lt;HorizontalStackLayout
                Grid.Column="1"
                Grid.Row="1"
                RadioButtonGroup.GroupName="{Binding
                    ThemeGroupName}" [1]
                RadioButtonGroup.SelectedValue="{Binding
                    ThemeSelection}"&gt; [2]
                &lt;RadioButton Content="Dark" /&gt;
                &lt;RadioButton
                    Content="Light"
                    IsChecked="True" /&gt; [3]
            &lt;/HorizontalStackLayout&gt;</pre>
			<p>We now<a id="_idIndexMarker333"/> want to ask the user whether the app should only be used when connected to Wi-Fi. We can do this with a switch control, where <strong class="source-inline">on</strong> indicates <strong class="source-inline">WiFi only</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
            &lt;Label
                Grid.Column="0"
                Grid.Row="2"
                Text="Wifi Only?" /&gt;
            &lt;Switch                  [4]
                Grid.Column="1"
                Grid.Row="2"
                HorizontalOptions="Start"
                IsToggled="{Binding WifiOnly}"
                OnColor="Green"
                ThumbColor="Blue" /&gt;
            &lt;Button
                Command="{Binding SavePreferencesCommand}"
                Grid.Column="0"
           Grid.ColumnSpan="2"
                Grid.Row="3"
                HorizontalOptions="Center"
                Text="Save" /&gt;
        &lt;/Grid&gt;
    &lt;/VerticalStackLayout&gt;
&lt;/ContentPage&gt;</pre>
			<p><strong class="source-inline">[1]</strong> Here, we<a id="_idIndexMarker334"/> introduce a new control, <strong class="source-inline">RadioButton</strong>. Radio buttons are in either implicit or explicit groups. Implicit groups are created by putting all the <strong class="source-inline">RadioButtons</strong> into the same container (for example, <strong class="source-inline">VerticalStackLayout</strong>). Explicit groups are given <strong class="source-inline">GroupName</strong>, as we <span class="No-Break">see here.</span></p>
			<p><strong class="source-inline">[2]</strong> The user’s choice is recorded by the <span class="No-Break"><strong class="source-inline">SelectedValue</strong></span><span class="No-Break"> property.</span></p>
			<p><strong class="source-inline">[3]</strong> When defining <strong class="source-inline">RadioButtons</strong>, you can (and should) set exactly one <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IsChecked=true</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">[4]</strong> The switch control toggles off and on (<strong class="source-inline">false</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">).</span></p>
			<p>Now that we know how to gather the information the user wants to save, let’s take a look at the lightweight mechanism provided by .NET MAUI to <span class="No-Break">do so.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor148"/>UserPreferencesViewModel</h2>
			<p>As you <a id="_idIndexMarker335"/>might expect, the first thing we’ll do is create properties for the <span class="No-Break">bound controls:</span></p>
			<pre class="source-code">
[ObservableObject]
public partial class UserPreferencesViewModel
{
  [ObservableProperty] private string displayName;
  [ObservableProperty] private string themeSelection;
  [ObservableProperty] private bool wifiOnly;
  public string ThemeGroupName =&gt; "Theme";</pre>
			<p>Next, we need to handle the <strong class="source-inline">SavePreferences</strong> command. We do this using the .NET MAUI <strong class="source-inline">Preferences</strong> object, calling the static <span class="No-Break"><strong class="source-inline">Set</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
[RelayCommand]
public async Task SavePreferences()
{
  Preferences.Default.Set("DisplayName", displayName);
  Preferences.Default.Set("ThemeSelection",
    themeSelection);
  Preferences.Default.Set("WifiOnly", wifiOnly);
}</pre>
			<p>.NET MAUI will <a id="_idIndexMarker336"/>handle the persistence <span class="No-Break">for us.</span></p>
			<p>Now that we’ve created the page, let’s set up navigation to get <span class="No-Break">to it.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor149"/>Navigating to UserPreferences</h2>
			<p>We need a way to <a id="_idIndexMarker337"/>get to our new page. A typical place to put this would be an <strong class="bold">About</strong> page. Let’s add <strong class="source-inline">Button</strong> as the last item <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">VerticalStackLayout</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;Button
    Command="{Binding OpenPreferencesCommand}"
    Text="Preferences"
    WidthRequest="150"
    Margin="10,50,10,0"/&gt;</pre>
			<p>The <strong class="source-inline">OnPreferences</strong> command simply navigates to our <span class="No-Break">new page:</span></p>
			<pre class="source-code">
[RelayCommand]
public async Task OpenPreferences()
{
  await Shell.Current.GoToAsync("userpreferences");
}</pre>
			<p>Make sure you register the <strong class="source-inline">userpreferences</strong> page in <strong class="source-inline">AppShell</strong> before invoking <span class="No-Break">this method.</span></p>
			<p>The page isn’t pretty, but it is ready to gather a user’s preferences, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_8.1_B19723.jpg" alt="Figure 8.1 – The preferences page&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – The preferences page</p>
			<p>A user is <a id="_idIndexMarker338"/>now able to set their preferences. The next time they start up the app, we’ll want to retrieve those preferences and set the <span class="No-Break">app accordingly.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor150"/>Retrieving the preferences</h2>
			<p>When a <a id="_idIndexMarker339"/>user closes the app, the preferences are preserved. The next time we return to the preferences page, we should see the preferences restored. We accomplish this using the <strong class="source-inline">Get</strong> method <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">Preferences.Default</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Get</strong> method takes two parameters, the <em class="italic">key</em> and <em class="italic">a default value</em>. We’ll put this in the <strong class="source-inline">ViewModel</strong> constructor so that the preferences page is populated when it <span class="No-Break">is displayed:</span></p>
			<pre class="source-code">
public UserPreferencesViewModel()
{
  displayName = Preferences.Default.Get("DisplayName",
    "Unknown");
  themeSelection = Preferences.Default.Get
    ("ThemeSelection", "Light");
  wifiOnly = Preferences.Default.Get("WifiOnly", false);
}</pre>
			<p>Note that the <a id="_idIndexMarker340"/>first argument to <strong class="source-inline">Get</strong> is the key, as defined in the <strong class="source-inline">Set</strong> method in the <strong class="source-inline">SavePreferences</strong> method. The second argument is the default value that will be provided if the key is <span class="No-Break">not present.</span></p>
			<p class="callout-heading">Checking for a key</p>
			<p class="callout">While you don’t have to check that a key exists before trying to retrieve it, there are times when you’ll want to differentiate between the value you get back being the default value or the value that is actually stored (for example, is <strong class="source-inline">WiFiOnly</strong> <strong class="source-inline">false</strong> because it really is <strong class="source-inline">false</strong>, or because that key doesn’t exist and you received the <span class="No-Break">default value?).</span></p>
			<p class="callout">To manage this, you can use the <strong class="source-inline">ContainsKey</strong> method <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">Preferences.Default</strong></span><span class="No-Break">:</span></p>
			<p class="callout"><strong class="source-inline">bool knowsWifi = </strong><span class="No-Break"><strong class="source-inline">Preferences.DefaultContainsKey("WifiOnly");</strong></span></p>
			<p>The user can now store their preferences, and in theory, they can be restored. Let’s make sure that this <span class="No-Break">is working.</span></p>
			<h3>Testing the persistence</h3>
			<p>To see that <a id="_idIndexMarker341"/>this works, navigate to the <strong class="source-inline">UserPreferences</strong> page by way of the <strong class="bold">About</strong> page, and fill in the three preferences. Then, stop the program and restart it. When you return to the <strong class="source-inline">UserPreferences</strong> page, you should see that your entered values have <span class="No-Break">been restored.</span></p>
			<p class="callout-heading">Clear</p>
			<p class="callout">If you want to clear a specific <strong class="source-inline">UserPreference</strong>, use the <span class="No-Break"><strong class="source-inline">Remove</strong></span><span class="No-Break"> method:</span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">Preferences.Default.Remove("DisplayName");</strong></span></p>
			<p class="callout">To remove them all, use the <span class="No-Break"><strong class="source-inline">Clear</strong></span><span class="No-Break"> method:</span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">Preferences.Default.Clear()</strong></span></p>
			<p>The <strong class="source-inline">Preferences</strong> interface<a id="_idIndexMarker342"/> is designed to hold simple data in key/value pairs. Microsoft warns against storing long strings, as it may negatively affect performance. If you need to store more complex or larger data, you’ll want to use a database, and the database of choice for many .NET MAUI developers<a id="_idIndexMarker343"/> <span class="No-Break">is </span><span class="No-Break"><strong class="bold">SQLite</strong></span><span class="No-Break">.</span></p>
			<p>The lightweight persistence mechanism is great for storing relatively short strings and other primitives, but if you are going to store substantial data, you’ll need a <span class="No-Break">real database.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor151"/>Storing to a database on your device</h1>
			<p>There are a <a id="_idIndexMarker344"/>couple of contenders for storing data on your device. The most popular is SQLite, which is an open source, small, fast, and highly reliable database. It is the most used database in the world and is built into all mobile phones and <span class="No-Break">most computers.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor152"/>Installing SQLite</h2>
			<p>To get started, install <a id="_idIndexMarker345"/>the latest version of the <strong class="bold">sqlite-net-pcl</strong> NuGet package, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_8.2_B19723.jpg" alt="Figure 8.2 – Installing sqlite-net-pcl&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Installing sqlite-net-pcl</p>
			<p class="callout-heading">Installing the correct package</p>
			<p class="callout">There are a number of SQLite packages available on NuGet. The one you want is <strong class="bold">sqlite-net-pcl</strong> and has the author <strong class="bold">SQLite-net</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_8.3_B19723.jpg" alt="Figure 8.3 – The author should be SQLite-net&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The author should be SQLite-net</p>
			<p>Once <strong class="bold">sqlite-net-pcl</strong> is <a id="_idIndexMarker346"/>installed, also search for <strong class="source-inline">sqlitepclraw.bundle_green</strong> and if it is not automatically installed, manually install <strong class="bold">SQLitePCLRaw.bundle_green</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_8.4_B19723.jpg" alt="Figure 8.4 – Installing SQLitePCLRaw.bundle_green&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Installing SQLitePCLRaw.bundle_green</p>
			<p>With the packages installed, you are ready to set up your program to create and use an <span class="No-Break">SQLite database.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor153"/>Getting started with SQLite</h2>
			<p>To create <a id="_idIndexMarker347"/>your database, you’ll need to store the database filename and its path among other constant values. To do so, right-click on your project and create a <strong class="source-inline">Constants.cs</strong> file. For convenience, I’ll create a <strong class="source-inline">Database</strong> folder <a id="_idIndexMarker348"/>and place <span class="No-Break">it there:</span></p>
			<pre class="source-code">
namespace ForgetMeNotDemo.Database;
public static class Constants
{
  public const string DatabaseFilename =
    "ForgetMeNotDemo.db3"; [1]
  public const SQLite.SQLiteOpenFlags Flags = [2]
    SQLite.SQLiteOpenFlags.ReadWrite |
    SQLite.SQLiteOpenFlags.Create |
    SQLite.SQLiteOpenFlags.SharedCache;
  public static string DatabasePath =&gt;
    Path.Combine(FileSystem.AppDataDirectory,
      DatabaseFilename); [3]
}</pre>
			<p><strong class="source-inline">[1]</strong> Set the name for your database. Feel free to use the name as shown or rename it to whatever <span class="No-Break">you like.</span></p>
			<p><strong class="source-inline">[2]</strong> Set the flags for how the file should be managed. Here, we’ve set it to read/write mode, to create the database if it doesn’t exist, and finally, to enable multithreaded <span class="No-Break">database access.</span></p>
			<p><strong class="source-inline">[3]</strong> Append the <a id="_idIndexMarker349"/>database filename we created earlier to the directory name for <span class="No-Break">the app.</span></p>
			<p>With these constants established, we’re ready to create the database. We’ll encapsulate that work in <span class="No-Break">a class.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor154"/>The Database class</h2>
			<p>It is a <a id="_idIndexMarker350"/>common pattern to wrap a database access layer in a class, abstracting it away and decoupling it from the rest of the app. We’ll put all the query logic into this class. This centralization of database concerns will help make our app scalable <span class="No-Break">over time.</span></p>
			<p>The class will need an <strong class="source-inline">Init()</strong> method to create the database and our first table. To get us started, let’s create a table to hold all <span class="No-Break">our preferences:</span></p>
			<pre class="source-code">
using ForgetMeNotDemo.Database;
using ForgetMeNotDemo.Model;
using SQLite;
namespace ForetMeNotDemoDatabase;
public class ForgetMeNotDemoDatabase
{
    private SQLiteAsyncConnection Database;  [1]
    private async Task Init()
    {
        if (Database is not null)  [2]
            return;
        Database = new SQLiteAsyncConnection(  [3]
              Constants.DatabasePath,
              Constants.Flags);
        await Database.CreateTableAsync&lt;Preference&gt;(); [4]
    }
}</pre>
			<p><strong class="source-inline">[1]</strong> Declare an object of type <strong class="source-inline">SQLiteAsyncConnection</strong> and name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">Database</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">[2]</strong> If it already exists, then return (that is, treat it as <span class="No-Break">a singleton).</span></p>
			<p><strong class="source-inline">[3]</strong> Create <strong class="source-inline">SQliteAsyncConnection</strong>, passing in the path and flags from the <span class="No-Break"><strong class="source-inline">constant</strong></span><span class="No-Break"> class.</span></p>
			<p><strong class="source-inline">[4]</strong> Create our first table, declaring<a id="_idIndexMarker351"/> the type of object we’ll store in the table (the <span class="No-Break"><strong class="source-inline">Preference</strong></span><span class="No-Break"> objects).</span></p>
			<p>We are ready to start using the database, to add and manipulate <span class="No-Break">our table.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor155"/>CRUD</h2>
			<p>As is true for virtually all databases, we’ll want to support <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>). For now, let’s just implement the methods to create and read records. The method to create<a id="_idIndexMarker352"/> is typically combined with the <span class="No-Break">update method.</span></p>
			<h3>Create/update</h3>
			<p>We’re <a id="_idIndexMarker353"/>going to want to know whether a <strong class="source-inline">Preference</strong> is already in the table so that we know, when given a <strong class="source-inline">Preference</strong> record, whether to add it or update it. It will need a unique ID. Fortunately, SQLite is very good at <span class="No-Break">providing IDs.</span></p>
			<p>Start by opening <strong class="source-inline">Preference.cs</strong> in the <strong class="source-inline">Model</strong> folder and adding an <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> property:</span></p>
			<pre class="source-code">
[ObservableObject]
public partial class Preference
{
    [ObservableProperty] private int id;
    [ObservableProperty] private string preferencePrompt;
    [ObservableProperty] private string preferenceValue;
}</pre>
			<p>Next, return to <strong class="source-inline">ForgetMeNotDemoDatabase.cs</strong> and add the <span class="No-Break"><strong class="source-inline">SavePreference</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
public async Task&lt;int&gt; SavePreference(Preference
    preference) [1]
{
    await Init();  [2]
    if (preference.Id != 0) [3]
    {
        return await Database.UpdateAsync(preference);
    }
    else
    {
        return await Database.InsertAsync(preference);
    }
}</pre>
			<p><strong class="source-inline">[1]</strong> Our <strong class="source-inline">SavePreference</strong> method <a id="_idIndexMarker354"/>takes the type (<strong class="source-inline">Preference</strong>) as an argument and returns the number of rows updated (in this case, zero <span class="No-Break">or one).</span></p>
			<p><strong class="source-inline">[2]</strong> Call <strong class="source-inline">Init</strong> on the database each time you take <span class="No-Break">an action.</span></p>
			<p><strong class="source-inline">[3]</strong> Check to see whether the <strong class="source-inline">Preference</strong> object has <strong class="source-inline">Id</strong>. Since <strong class="source-inline">Id</strong> is an <strong class="source-inline">int</strong> type, it defaults to zero, so if it is not zero, we need to do an update; otherwise, we need to do <span class="No-Break">an insert.</span></p>
			<p>Now that we can create (or update) a record, let’s write code to read that data out of <span class="No-Break">the database.</span></p>
			<h3>Read</h3>
			<p>We’ll <a id="_idIndexMarker355"/>want to be able to get all our preferences back from the database. For that, we’ll create a <strong class="source-inline">GetPreferences</strong> method that returns a list of <span class="No-Break"><strong class="source-inline">Preference</strong></span><span class="No-Break"> objects:</span></p>
			<pre class="source-code">
public async Task&lt;List&lt;Preference&gt;&gt; GetPreferences()
{
    await Init();
    return await Database.Table&lt;Preference&gt;();
}</pre>
			<p class="callout-heading">Soft deletion</p>
			<p class="callout">When we write our <strong class="source-inline">Delete</strong> method, we probably will want to do a <em class="italic">soft</em> deletion – that is, mark it as deleted rather than actually removing it. For this to work, you’ll need to add another property to <strong class="source-inline">Preference</strong>, <strong class="source-inline">Deleted</strong>, and also <strong class="source-inline">int</strong>. Our read statement will then take a <strong class="source-inline">where</strong> clause, checking that the <strong class="source-inline">Deleted</strong> property is equal <span class="No-Break">to zero.</span></p>
			<p>Once you have a database design, you need to decide whether you are going to keep the database locally on a device or in the cloud, accessed through <span class="No-Break">your API.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor156"/>Local or remote?</h1>
			<p>A <a id="_idIndexMarker356"/>design question for this app is whether we want to store our preferences, buddies, invitations, and so forth in tables on a device, or instead use a web service and database in <span class="No-Break">the cloud.</span></p>
			<p>To facilitate a secure interaction when sending and receiving invitations and lists of preferences, we’ve decided to move all the database operations to the cloud. However, everything in this chapter is not only relevant to <strong class="source-inline">ForgetMeNotDemo</strong>; it will be of use to you if you decide to store data locally on a phone <span class="No-Break">or computer.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor157"/>Summary</h1>
			<p>In this chapter, we reviewed two ways of storing data. The simplest and most lightweight is to use the preferences facilities of .NET MAUI. This is great if all you need is to store primitives and short strings that are targeted at persisting a user’s preferences for <span class="No-Break">a program.</span></p>
			<p>If you need to persist more substantial data, you’ll need a database, and by far the most popular type for on-device storage is SQLite. We examined the CRUD functionality of SQLite and then pointed out the alternative of not storing everything on a device but, rather, storing in the cloud and gaining access through a <span class="No-Break">program’s API.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor158"/>Quiz</h1>
			<ol>
				<li>What is the class that handles simple storage of user data in <span class="No-Break">key/value pairs?</span></li>
				<li>What two values do we pass to the <strong class="source-inline">Get</strong> method to retrieve the <span class="No-Break">stored value?</span></li>
				<li>Which <strong class="source-inline">NuGet</strong> packages do we need to work with SQLite in .<span class="No-Break">NET MAUI?</span></li>
				<li>What type of object do we use to create <span class="No-Break">a table?</span></li>
			</ol>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor159"/>You try it</h1>
			<p>Add the remaining CRUD operations to the <strong class="source-inline">Preference</strong> table (for example, delete and get <span class="No-Break">by ID).</span></p>
		</div>
		<div>
			<div id="_idContainer089" class="IMG---Figure">
			</div>
		</div>
	</body></html>