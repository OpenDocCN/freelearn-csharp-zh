- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Unit Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Let’s dive into something critical: **unit testing**. Think of it as your safety
    net. It’s not just about knowing your app runs smoothly now, but ensuring that
    after every tweak, update, or overhaul, your app keeps on ticking without hiccups
    or unexpected surprises. Regression bugs? We’re looking at you! With MVVM and
    the right testing practices, we can effectively guard against these potential
    issues.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨一个关键点：**单元测试**。把它想象成你的安全网。这不仅仅是知道你的应用程序现在运行顺畅，而是确保在每次调整、更新或彻底改造后，你的应用程序都能平稳运行，没有故障或意外惊喜。回归bug？我们正在关注你！使用MVVM和正确的测试实践，我们可以有效地防范这些潜在问题。
- en: 'In this chapter, we’re going to tackle the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解决以下问题：
- en: The importance of unit testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的重要性
- en: Setting up a unit test project
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单元测试项目
- en: Generating data with Bogus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bogus生成数据
- en: Mocking dependencies with Moq
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Moq模拟依赖
- en: Testing MAUI-specific code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试MAUI特定的代码
- en: 'While we won’t be diving deep into the weeds (after all, the intricacies can
    vary widely depending on the tools you use), I’ll guide you using a set of tools
    I’m familiar with: **xUnit**, **Bogus**, **AutoBogus**, and **Moq**. These are
    my go-to building blocks, but let’s remember: the .NET ecosystem is vast and versatile.
    There are several other fantastic frameworks and libraries out there, such as
    **NUnit**, **AutoFixture**, **NSubstitute**, and more. The principles we cover
    will largely remain the same; it’s just a matter of which tools resonate with
    your workflow. At the end of the day, it’s all about personal preference.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会深入细节（毕竟，根据你使用的工具，复杂性可能会有很大差异），但我将使用我熟悉的工具集来引导你：**xUnit**、**Bogus**、**AutoBogus**和**Moq**。这些是我的首选构建块，但让我们记住：.NET生态系统庞大而灵活。还有许多其他出色的框架和库，例如**NUnit**、**AutoFixture**、**NSubstitute**等。我们涵盖的原则将大致保持不变；这只是哪个工具与你的工作流程相协调的问题。最终，一切都关乎个人喜好。
- en: By the end of this chapter, you should be firmly convinced of the immense value
    unit tests offer. Additionally, you’ll have a clear view of how to effectively
    use tools and techniques for writing unit tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该坚信单元测试带来的巨大价值。此外，你将清楚地了解如何有效地使用工具和技术来编写单元测试。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To ensure you’re in sync with the upcoming content, make your way to our GitHub
    repository: [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13).
    Kick off with the materials in the `Start` folder. And remember – if you’re ever
    in need of a consolidated reference, the `Finish` folder holds the final, refined
    code at the chapter’s close.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你与即将到来的内容保持同步，请访问我们的GitHub仓库：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter13)。从`Start`文件夹中的材料开始。记住——如果你需要综合参考，`Finish`文件夹在章节结束时包含了最终、精炼的代码。
- en: The importance of unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的重要性
- en: 'A lesson I learned the hard way forever transformed my stance on software development:
    *never underestimate* *unit testing*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过艰难的方式学到的教训永远改变了我对软件开发的态度：**永远不要低估**单元测试。
- en: Years ago, I was part of a dedicated team crafting an ambitious app. Our expertise
    in C# and the platform was undeniable. Yet, we overlooked unit tests, placing
    our faith in manual testing and our **Quality Assurance** (**QA**) team. The end
    product was highly recognized and praised, but the journey was a tumultuous one.
    Feedback from QA often revealed bugs, making each code adjustment feel risky.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，我曾是制作一款雄心勃勃的应用程序的专业团队的一员。我们在C#和平台方面的专业知识无可否认。然而，我们忽视了单元测试，将我们的信任寄托在手动测试和我们的**质量保证**（**QA**）团队上。最终产品得到了高度认可和赞扬，但过程是动荡的。QA的反馈经常揭示bug，使得每次代码调整都感觉风险重重。
- en: Nearing deadlines was synonymous with sleepless nights, hasty bug fixes, and
    a looming fear of regressions. Post-project, I collaborated with diverse developers
    and encountered a colleague profoundly devoted to **test-driven development**
    (**TDD**). It was a true eye-opener, not just for the essence of unit testing
    but also for the flaws in our previous design choices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接近截止日期意味着失眠的夜晚、匆忙的bug修复以及即将到来的回归恐惧。项目完成后，我与不同背景的开发者合作，遇到了一位对**测试驱动开发**（**TDD**）投入极大的同事。这真是一个真正的启发，不仅对单元测试的本质，也对我们之前设计选择中的缺陷有了深刻的认识。
- en: 'My evolving journey underscored the real benefits of unit tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我的单元测试之旅
- en: '**Efficiency**: No more long-lasting deployments before manual verifications.
    Unit tests swiftly validate my code, streamlining development.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：不再需要在手动验证之前进行长期部署。单元测试迅速验证我的代码，简化了开发过程。'
- en: '**Quality and confidence**: With each test, the software’s quality rises, as
    does my confidence. It becomes a safety net, allowing explorative coding without
    the fear of unintended consequences.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量和信心**：随着每个测试的进行，软件的质量提高，我的信心也随之增强。它成为了一个安全网，允许探索性编码而不必担心意外的后果。'
- en: '**Guarding against regressions**: Unit tests ensure alterations don’t unintentionally
    break existing features.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止回归**：单元测试确保更改不会无意中破坏现有功能。'
- en: With time, I’ve also observed that unit tests serve as an evolving documentation.
    New team members can determine the expected behavior and logic from these tests,
    facilitating quicker integration and more confident code modifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我也观察到单元测试充当着不断演变的文档。新团队成员可以从这些测试中确定预期的行为和逻辑，从而加快集成并增强代码修改的信心。
- en: 'My old teammates and I still meet up from time to time. We chat about the old
    days and our shared experiences. In our conversations, a shared realization stands
    out: after our time together, each of us matured in our individual projects. This
    often leads us to a mutual reflection: if we had embraced unit testing in that
    project we did years ago, our work lived might have been a lot smoother. Don’t
    get me wrong; our clients were happy with what we delivered. But for all of us,
    on a personal level, having tests from the get-go could have saved many stressful
    nights, health issues, and uncertainties.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我和我的老队友们时不时还会聚在一起。我们谈论过去的日子和共同的经历。在我们的对话中，一个共同的认知脱颖而出：在我们共同度过的时光里，我们每个人都在各自的项目中成熟起来。这往往导致我们进行相互反思：如果我们多年前在那个项目中就采用了单元测试，我们的工作可能会更加顺利。请别误会；我们的客户对我们交付的成果感到满意。但对我们所有人来说，从个人层面来看，从一开始就有测试可能会节省许多压力之夜、健康问题和不确定性。
- en: While unit testing enjoys acclaim in many developer circles, I still witness
    hesitancy, especially in parts of the .NET world. My advocacy isn’t about achieving
    a coverage metric or TDD fanaticism. It’s about recognizing unit tests for their
    benefits, from ensuring code reliability to uplifting team morale.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试在许多开发者圈子中受到赞誉，但我仍然目睹了犹豫不决，尤其是在.NET世界的某些部分。我的倡导并不是为了达到一个覆盖率指标或TDD狂热。它是为了认识到单元测试的好处，从确保代码可靠性到提升团队士气。
- en: 'Unit testing is not about achieving an abstract notion of perfection. It’s
    about having a safety net, allowing for code acrobatics without fearing a misstep.
    Do I write tests for every single line of code I have? In all honesty: no. Is
    all my code easy to test? Not always. But the tests I write really do help. They
    let me know quickly if things work, if I broke something, or if I fixed a bug
    the right way. And that gives me confidence in my work. When a bug is being reported,
    the first thing I do is write a failing test, exposing this bug. I can then go
    ahead and work on this bug, and as soon as the test passes, I know I’ve fixed
    it. And not only is the bug now fixed, but with the additional test (or tests),
    the code has become even more robust and protected against future regressions.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不是关于达到一个抽象的完美概念。它是关于拥有一个安全网，允许进行代码杂技表演而不必担心出错。我是否为每一行代码都编写了测试？坦白说：不是。我的所有代码都容易测试吗？并不总是。但我编写的测试确实很有帮助。它们让我快速知道事情是否正常工作，是否破坏了某些东西，或者是否正确地修复了一个错误。这让我对自己的工作充满信心。当报告错误时，我首先做的事情就是编写一个失败的测试，暴露这个错误。然后我可以继续处理这个错误，一旦测试通过，我就知道我已经修复了它。而且，不仅错误现在已经被修复，而且由于额外的测试（或测试），代码变得更加健壮，并得到了对未来回归的保护。
- en: As software continuously evolves in our fast-paced world, unit testing is not
    just best practice; it’s a lifeline. The peace of mind it offers is unparalleled,
    ensuring that the software not only functions but is robust against inevitable
    change.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个快节奏的世界中，软件持续发展，单元测试不仅是一种最佳实践，更是一条生命线。它带来的安心感是无与伦比的，确保软件不仅能够运行，而且能够抵御不可避免的变化。
- en: 'To those beginning their developer journey or reevaluating unit tests: don’t
    mimic my initial oversight. See tests not as a chore but as a trusty companion.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚开始开发者旅程或重新评估单元测试的人来说：不要模仿我最初的疏忽。将测试看作是一项任务，而不是一个可靠的伙伴。
- en: 'Having said that, it’s time to pivot from the *why* to the *how*. For those
    still with me, let’s delve into the details: setting up unit tests for ViewModels.
    Believe me, it’s simpler than it seems!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，是时候从“为什么”转向“如何”了。对于那些仍然和我在一起的人，让我们深入了解细节：为ViewModel设置单元测试。相信我，这比看起来简单得多！
- en: Setting up a unit test project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试项目
- en: In this section, we will be walking through the steps of setting up a unit test
    project and creating a first test. We’ll be using xUnit in this section. We’re
    not going to get all tangled up in the tiny details of this specific library because
    there are tons of other awesome ones. No matter what you choose, the big takeaways
    should stick with you. So, without further ado, let’s dive in and start setting
    the stage for effective ViewModel testing!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍设置单元测试项目并创建第一个测试的步骤。我们将在本节中使用 xUnit。我们不会深入探讨这个特定库的细节，因为还有许多其他出色的库。无论你选择哪个，重要的收获都应该记住。所以，无需多言，让我们开始设置有效的
    ViewModel 测试的舞台！
- en: Creating a unit test project
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单元测试项目
- en: 'Let’s start by creating an xUnit Test project. In xUnit, one of the things
    I appreciate is its simplicity. Test classes and methods are just normal classes
    and methods, without the need for special base classes or complex setups. Here’s
    how:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 xUnit 测试项目。在 xUnit 中，我欣赏的一点是它的简单性。测试类和方法只是普通的类和方法，无需特殊基类或复杂的设置。以下是步骤：
- en: In the **Solution Explorer** in **Visual Studio**, right-click **Solution ‘Recipes
    App’** and select **Add** | **New Project…**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Visual Studio** 的 **解决方案资源管理器** 中，右键单击 **“Recipes App” 解决方案**，然后选择 **添加**
    | **新建项目…**。
- en: 'In the `xunit` in the search box and select **xUnit Test Project** from the
    list (*Figure 13**.1*):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中输入 `xunit` 并从列表中选择 **xUnit 测试项目** (*图 13.1*)：
- en: '![Figure 13.1: Creating a new xUnit test project](img/B20941_13_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：创建新的 xUnit 测试项目](img/B20941_13_01.jpg)'
- en: 'Figure 13.1: Creating a new xUnit test project'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：创建新的 xUnit 测试项目
- en: Click the `Recipes.Client.Core.UnitTests` as the project name. Click **Next**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Recipes.Client.Core.UnitTests` 作为项目名称。点击 **下一步**。
- en: When prompted, select **.NET 8.0 (Long Term Support)** from the **Framework**
    list and hit the **Create** button.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，从 **框架** 列表中选择 **.NET 8.0 (长期支持**)，然后点击 **创建** 按钮。
- en: Once the project is generated, right-click on it, select `Recipes.Client.Core`
    project from the list.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目生成，右键单击它，从列表中选择 `Recipes.Client.Core` 项目。
- en: With the project and its reference to the `Recipes.Client.Core` project in place,
    we can start writing our unit tests. Let’s go ahead and write our first one!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目及其对 `Recipes.Client.Core` 项目的引用就绪后，我们可以开始编写我们的单元测试。让我们继续编写我们的第一个测试！
- en: Creating unit tests
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建单元测试
- en: 'Let’s start by testing something pretty straightforward: testing the initialization
    of the `RecipeListItemViewModel`. Here’s how:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从测试一些相对简单的事情开始：测试 `RecipeListItemViewModel` 的初始化。以下是步骤：
- en: Delete the generated `UnitTest1.cs` file.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除生成的 `UnitTest1.cs` 文件。
- en: Add a new C# class called `RecipeListItemViewModelTests` to the project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为 `RecipeListItemViewModelTests` 的新 C# 类添加到项目中。
- en: 'Make the class public and add a public method called `ViewModel_Initialized_PropertiesSetCorrectly`,
    as shown in the following snippet:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为公共的，并添加一个名为 `ViewModel_Initialized_PropertiesSetCorrectly` 的公共方法，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how the `Fact` attribute is added to this method. This attribute signals
    that this is a test method. Without it, the method won’t be identified as a test
    and therefore won’t be executed as one during test runs.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意如何将 `Fact` 属性添加到这个方法中。这个属性表示这是一个测试方法。如果没有它，这个方法就不会被识别为测试方法，因此在测试运行期间也不会作为测试方法执行。
- en: 'Add the following code to this method:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到这个方法中：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates and validates a `RecipeListItemViewModel` instance. This code block
    first creates an instance of the `RecipeListItemViewModel` class using sample
    data. It then calls a series of assertions to confirm that the object’s properties
    were initialized as expected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建并验证一个 `RecipeListItemViewModel` 实例。此代码块首先使用示例数据创建 `RecipeListItemViewModel`
    类的实例。然后调用一系列断言以确认对象的属性已按预期初始化。
- en: In unit testing jargon, our instantiated object is named `sut`, which stands
    for **system under test**. This is a name commonly used in unit tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试术语中，我们实例化的对象被称为 `sut`，代表 **系统测试对象**。这是一个在单元测试中常用的名称。
- en: Lastly, the role of the `Assert` statements, inherent to the xUnit framework,
    deserves special mention. `Assert` methods play a pivotal role in validating object
    states to ensure they meet our expectations. `Assert.True`, `Assert.Empty`, `Assert.Contains`,
    and many more are at our disposal. The `Assert.Equal` method, as shown in this
    example, evaluates if the expected value matches the object’s actual value. In
    this context, it ensures that properties of our `sut` object, such as `Id`, `Title`,
    `IsFavorite`, and `Image`, were initialized as expected.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得特别注意的是，xUnit 框架固有的 `Assert` 语句的作用。`Assert` 方法在验证对象状态以确保它们符合我们的预期中起着关键作用。`Assert.True`、`Assert.Empty`、`Assert.Contains`
    以及更多方法都在我们的掌握之中。正如本例所示，`Assert.Equal` 方法评估预期值是否与对象的实际值匹配。在这种情况下，它确保我们的 `sut` 对象的属性，如
    `Id`、`Title`、`IsFavorite` 和 `Image`，被初始化为预期值。
- en: 'In the previous code snippet, you may notice the clear structure, which is
    guided by comments: `//Arrange`, `//Act`, and `//Assert`. This corresponds to
    a fundamental pattern in unit testing known as **Arrange-Act-Assert** (**AAA**).
    Let’s delve briefly into what each stage signifies:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可能注意到了清晰的架构，这是由注释引导的：`//Arrange`、`//Act` 和 `//Assert`。这对应于单元测试中的一个基本模式，称为
    **Arrange-Act-Assert**（**AAA**）。让我们简要地探讨一下每个阶段的意义：
- en: '`Arrange`: This stage involves setting up any prerequisites for a test. We
    establish the conditions our test operates under. This might include initializing
    variables, creating mock objects, or setting up resources. In our example, this
    is where we define our sample data: `id`, `title`, `isFavorite`, and `image`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Arrange`: 这个阶段涉及为测试设置任何先决条件。我们确定测试运行的条件。这可能包括初始化变量、创建模拟对象或设置资源。在我们的例子中，这是定义我们的样本数据的地方：`id`、`title`、`isFavorite`
    和 `image`。'
- en: '`Act`: Here, we perform the action that we intend to test. This is where the
    `sut` object is invoked, and it’s typically a single action. In our context, it’s
    the instantiation of `RecipeListItemViewModel` with the sample data we arranged.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Act`: 在这里，我们执行我们打算测试的操作。这是 `sut` 对象被调用的地方，通常是一个单一的操作。在我们的上下文中，这是使用我们安排的样本数据实例化
    `RecipeListItemViewModel`。'
- en: '`Assert`: This final stage is where we verify if the test has passed or failed
    by checking the outcome against the expected results. In our example, this is
    done using the `Assert.Equal` method to ensure that our `RecipeListItemViewModel`
    object’s properties match the values we initialized them with.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert`: 这个最终阶段是通过检查结果与预期结果是否一致来验证测试是否通过或失败。在我们的例子中，这是通过使用 `Assert.Equal`
    方法来确保我们的 `RecipeListItemViewModel` 对象的属性与我们初始化它们的值相匹配来完成的。'
- en: Following the AAA pattern ensures that tests are organized and readable, making
    it easier for you, or anyone reviewing your code, to understand the purpose and
    behavior of each test.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 AAA 模式可以确保测试是有组织和可读的，这使得你或任何审查你代码的人更容易理解每个测试的目的和行为。
- en: 'Go ahead and run the test! This can be done by right-clicking inside the test
    method you want to test and selecting **Run Tests**. Alternatively, you can choose
    **Debug Tests**, which runs your test and breaks on any breakpoints you have added,
    allowing you to step through the unit test. Test methods are also visible in the
    **Test Explorer** in **Visual Studio**. From there, you can easily run multiple
    tests. This pane also shows the current status of your tests: which ran successfully
    and which failed, alongside other relevant info, as shown in *Figure 13**.2*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试吧！这可以通过在要测试的测试方法内部右键单击并选择 **运行测试** 来完成。或者，你可以选择 **调试测试**，这将运行你的测试并在你添加的任何断点处中断，允许你逐步执行单元测试。测试方法在
    **Visual Studio** 的 **测试资源管理器** 中也是可见的。从那里，你可以轻松地运行多个测试。此面板还显示了你的测试的当前状态：哪些成功运行，哪些失败，以及其他相关信息，如图
    *图 13.2* 所示：
- en: '![Figure 13.2: Visual Studio’s Test Explorer](img/B20941_13_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：Visual Studio 的测试资源管理器](img/B20941_13_02.jpg)'
- en: 'Figure 13.2: Visual Studio’s Test Explorer'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：Visual Studio 的测试资源管理器
- en: 'Let’s add a couple more tests! Each instance of a `RecipeListItemViewModel`
    should listen for a `FavoriteUpdateMessage` and when such a message arrives, its
    `IsFavorite` property should be updated accordingly. So, let’s first write a test
    that validates that a newly instantiated `RecipeListItemViewModel` is registered
    as a recipient for a `FavoriteUpdateMessage` message. Secondly, in separate tests,
    we can check if the class reacts as expected to such a message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些更多的测试！`RecipeListItemViewModel`的每个实例都应该监听`FavoriteUpdateMessage`，当这样的消息到达时，它的`IsFavorite`属性应该相应更新。所以，首先，让我们编写一个测试来验证新实例化的`RecipeListItemViewModel`已注册为`FavoriteUpdateMessage`消息的接收者。其次，在单独的测试中，我们可以检查类是否对这样的消息做出预期的反应：
- en: 'Let’s start off by adding the following test to the `RecipeListItemViewModelTests`
    class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向`RecipeListItemViewModelTests`类添加以下测试开始：
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `WeakReferenceMessenger.Default.IsRegistered` method allows us to check
    whether a particular object is registered for a particular message. We expect
    our `sut` to be registered for the `FavoriteUpdateMessage`, so we can call this
    method and validate the outcome to be true with `Assert.True`.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`WeakReferenceMessenger.Default.IsRegistered`方法允许我们检查特定对象是否已注册接收特定消息。我们期望我们的`sut`已注册接收`FavoriteUpdateMessage`，因此我们可以调用此方法，并使用`Assert.True`验证结果为真。'
- en: 'We should also validate that when a `FavoriteUpdateMessage` is received by
    the `sut`, the `IsFavorite` property is updated accordingly – only, of course,
    when the id sent by the message matches the id of the `sut`. Take a look:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该验证，当`sut`接收到`FavoriteUpdateMessage`时，`IsFavorite`属性会相应更新——当然，前提是消息发送的id与`sut`的id匹配。看看这里：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FavoriteUpdateMessage` sends the inverse of the `originalValue` value that
    is used to instantiate the sut. After sending the message, which contains the
    same `RecipeId` as the sut, we can check whether the value of the `IsFavorite`
    property equals the value we’ve sent.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FavoriteUpdateMessage`发送用于实例化`sut`的`originalValue`值的逆值。在发送包含与`sut`相同的`RecipeId`的消息后，我们可以检查`IsFavorite`属性的值是否等于我们发送的值。'
- en: 'As a last test, we might want to validate that a `RecipeListItemViewModel`
    doesn’t react to a `FavoriteMessage` with a different `RecipeId`. This is very
    similar to our previous test, as you can see here:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的测试，我们可能想要验证`RecipeListItemViewModel`不会对具有不同`RecipeId`的`FavoriteMessage`做出反应。这和之前的测试非常相似，正如你在这里看到的：
- en: '[PRE4]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Because the message sends a different `RecipeId` than the ID on the `RecipeListItemViewModel`,
    we want to validate that the `IsFavorite` property on the sut is still the same
    as the originally set value.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为消息发送的`RecipeId`与`RecipeListItemViewModel`上的ID不同，我们想要验证`sut`上的`IsFavorite`属性仍然与最初设置的值相同。
- en: The “unit” in unit tests
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中的“单元”
- en: When we talk about *unit tests*, that *unit* part is crucial. It’s all about
    keeping things small and focused. Take a peek at the tests we just created. The
    first one ensures the ViewModel is registered for incoming `FavoriteUpdateMessage`s,
    while the other one checks how the ViewModel responds to an incoming message.
    Sure – the latter indirectly verifies the message listener too, but that doesn’t
    mean we can skip the first test. Each *unit* test should stick to checking one
    tiny piece of the puzzle to make sure every bit is working as it should.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论*单元测试*时，那个*单元*部分至关重要。这全部关于保持事物小而专注。看看我们刚刚创建的测试。第一个确保ViewModel已注册接收传入的`FavoriteUpdateMessage`，而另一个则检查ViewModel如何响应传入的消息。当然——后者间接验证了消息监听器，但这并不意味着我们可以跳过第一个测试。每个*单元*测试都应该专注于检查拼图中的一小部分，以确保每个部分都按预期工作。
- en: With our first test passing, let’s see how we can make them more data-driven.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个测试通过后，让我们看看如何使它们更具数据驱动性。
- en: Looking at data-driven tests
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看数据驱动测试
- en: '`false` as the third parameter. Now, if we were to remove `IsFavorite = isFavorite;`
    from the `RecipeListItemViewModel` class’s constructor, our test would deceptively
    still pass – a classic example of a false positive in testing. This is because,
    by coincidence, the default value of `IsFavorite` is `false`, but in fact, it
    is never assigned the value we passed in as a parameter. We could create another
    test method with different values in the `Theory` and `InlineData` attributes
    to leverage data-driven tests.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将第三个参数设为`false`。现在，如果我们从`RecipeListItemViewModel`类的构造函数中移除`IsFavorite = isFavorite;`，我们的测试仍然会欺骗性地通过——这是一个测试中的假阳性经典例子。这是因为，出于巧合，`IsFavorite`的默认值是`false`，但实际上，它从未被分配我们作为参数传递的值。我们可以创建另一个具有不同值的`Theory`和`InlineData`属性的其他测试方法，以利用数据驱动测试。
- en: 'In xUnit, while the `Fact` attribute denotes a straightforward unit test that
    runs once, there’s another powerful feature: the `Theory` attribute. Paired with
    the `InlineData` attribute, `Theory` allows us to create parameterized tests.
    This means we can run the same test logic with different input values, ensuring
    our code is robust against a variety of scenarios without duplicating our test
    methods. Let’s dive in and refactor our earlier test to take advantage of this
    capability:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在xUnit中，虽然`Fact`属性表示一个简单的单元测试，它只运行一次，但还有一个强大的功能：`Theory`属性。与`InlineData`属性结合使用，`Theory`允许我们创建参数化测试。这意味着我们可以用不同的输入值运行相同的测试逻辑，确保我们的代码能够应对各种场景，而无需重复测试方法。让我们深入探讨并重构我们之前的测试，以利用这一功能：
- en: 'Modify the `ViewModel_Initialized_PropertiesSetCorrectly` method to include
    the following parameters:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ViewModel_Initialized_PropertiesSetCorrectly`方法，包括以下参数：
- en: '[PRE5]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: //Arrange, Act
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //Arrange, Act
- en: var sut = new RecipeListItemViewModel(id, title,
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var sut = new RecipeListItemViewModel(id, title,
- en: isFavorite, image);
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: isFavorite, image);
- en: //Assert
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //Assert
- en: Assert.Equal(id, sut.Id);
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Assert.Equal(id, sut.Id);
- en: Assert.Equal(title, sut.Title);
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Assert.Equal(title, sut.Title);
- en: Assert.Equal(isFavorite, sut.IsFavorite);
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Assert.Equal(isFavorite, sut.IsFavorite);
- en: Assert.Equal(image, sut.Image);
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Assert.Equal(image, sut.Image);
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s now remove the `Fact` attribute and add a `Theory` attribute and some
    `InlineData` attributes to this method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们从这个方法中移除`Fact`属性，并添加一个`Theory`属性和一些`InlineData`属性：
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Theory` attribute is used to mark a test method as being a data-driven
    test. This means that the test method will be executed once for each set of data
    values specified using the `InlineData` attribute. Each of those runs of the test
    will have access to the data values provided by `InlineData`. When the `Theory`
    method is executed, xUnit will create a new instance of the test class for each
    set of data values specified in the `InlineData` attribute, and then execute the
    test method using those data values. The values provided in the `InlineData` attribute
    should exactly match the number and types of parameters on the method that is
    being tested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Theory`属性用于标记一个测试方法为数据驱动测试。这意味着测试方法将为使用`InlineData`属性指定的每组数据值执行一次。每个测试运行的测试都将访问由`InlineData`提供的值。当`Theory`方法执行时，xUnit将为`InlineData`属性中指定的每组数据值创建测试类的新的实例，然后使用这些数据值执行测试方法。`InlineData`属性中提供的值应与正在测试的方法上的参数数量和类型完全匹配。'
- en: 'Here’s how we can update the `FavoriteUpdateMsgReceived_SameId_FavoriteUpdated`
    method to turn it into a data-driven test method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将`FavoriteUpdateMsgReceived_SameId_FavoriteUpdated`方法更新为数据驱动测试方法的示例：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `FavoriteUpdateMsgReceived_DifferentId_FavoriteNotUpdated` can be updated
    similarly, as shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`FavoriteUpdateMsgReceived_DifferentId_FavoriteNotUpdated`可以像下面这样更新：'
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By adopting the `Theory` and `InlineData` attributes, we’ve enhanced our testing
    capability significantly. These updated test methods can now validate across a
    diverse set of values, ensuring that our ViewModel behaves consistently in varied
    scenarios. It’s an elegant way to increase test coverage without adding redundant
    code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用`Theory`和`InlineData`属性，我们显著增强了我们的测试能力。这些更新的测试方法现在可以验证一系列不同的值，确保我们的ViewModel在多种场景下表现一致。这是一种优雅的方式来增加测试覆盖率，而无需添加冗余代码。
- en: Sometimes, it’s beneficial to have test data generated for us, especially when
    we’re more concerned about the logic than the specific values. That’s where tools
    such as Bogus and AutoBogus come into play, helping us effortlessly generate diverse
    test values without manual intervention. Let’s have a look!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，让我们自动生成测试数据是有益的，尤其是当我们更关注逻辑而不是具体值时。这正是Bogus和AutoBogus等工具发挥作用的地方，它们帮助我们无需手动干预就能轻松生成各种测试值。让我们看看吧！
- en: Generating data with Bogus
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bogus生成数据
- en: 'While handpicked data has its place in unit tests, it often comes with inherent
    bias: because we’ve written the functionality that we want to test, we have a
    certain expectation about the format of the values being used. To combat this,
    many tests benefit from randomized or generated data, especially when the specific
    input matters less than the resulting outcome. Bogus is a powerful tool tailored
    for those moments when you need reliable, unbiased test data without the manual
    labor.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在单元测试中手动选择数据有其位置，但它往往带有固有的偏见：因为我们已经编写了我们想要测试的功能，所以我们对于使用的值的格式有一定的期望。为了对抗这种偏见，许多测试受益于随机化或生成数据，特别是当具体输入不如结果重要时。Bogus是一个针对那些需要可靠、无偏见的测试数据而不需要手动劳动的时刻的强大工具。
- en: In this section, we’ll introduce Bogus and AutoBogus and explore some of its
    basic capabilities. However, it’s worth noting that we’re merely scratching the
    surface here. These tools offer many features, but for the sake of brevity and
    focus, we’ll keep our discussion high-level, touching only upon a few fundamental
    use cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍 Bogus 和 AutoBogus，并探索其一些基本功能。然而，值得注意的是，我们在这里只是触及了表面。这些工具提供了许多功能，但为了简洁和专注，我们将保持讨论的高级性，仅涉及一些基本用例。
- en: 'Let’s start off by adding AutoBogus (and thus also Bogus) to our project:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将 AutoBogus（以及因此也包含 Bogus）添加到我们的项目中：
- en: In `Recipes.Client.Core.UnitTests` project and select **Manage** **NuGet Packages…**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Recipes.Client.Core.UnitTests` 项目中，选择 **Manage** **NuGet Packages…**。
- en: 'In the `autobogus` and install the **AutoBogus** package:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `autobogus` 中安装并选择 **Manage** **NuGet Packages…**。
- en: '![Figure 13.3: AutoBogus NuGet Package](img/B20941_13_03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3：AutoBogus NuGet 包](img/B20941_13_03.jpg)'
- en: 'Figure 13.3: AutoBogus NuGet Package'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：AutoBogus NuGet 包
- en: 'Now that we have installed these packages, let’s put this library into practice
    by testing the `EmptyOrWithinRangeAttribute` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了这些包，让我们通过测试 `EmptyOrWithinRangeAttribute` 类来将这个库付诸实践：
- en: Create a new class called `EmptyOrWithinRangeAttributeTests`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `EmptyOrWithinRangeAttributeTests` 的新类。
- en: 'Place the following member variables into the new class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下成员变量放入新类中：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this class, we’ll be putting our `sut` object as a class member. This allows
    us to write the instantiation code of the `sut` object once in the constructor
    (or inline), preventing repeatable code in each test for setting everything up.
    As each test method runs in a separate instance of the `EmptyOrWithinRangeAttributeTests`
    class, this also has no side effects on other tests.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个类中，我们将把我们的 `sut` 对象作为类成员。这允许我们在构造函数（或内联）中一次性编写 `sut` 对象的实例化代码，从而防止在每个测试中设置重复的代码。由于每个测试方法都在
    `EmptyOrWithinRangeAttributeTests` 类的单独实例中运行，这也对其他测试没有副作用。
- en: 'Add a constructor to the class and add the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类添加一个构造函数，并添加以下代码：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of manually creating an instance of the `EmptyOrWithinRangeAttribute`
    class, we are delegating this to the Bogus framework. We do this by instantiating
    a new `Faker` class, passing in the type we want it to generate. With the `RuleFor`
    methods of the `Faker` class, we can configure the values for the individual properties.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是手动创建 `EmptyOrWithinRangeAttribute` 类的实例，而是将此委托给 Bogus 框架。我们通过实例化一个新的 `Faker`
    类，传入我们想要它生成的类型来实现这一点。通过 `Faker` 类的 `RuleFor` 方法，我们可以配置单个属性的值。
- en: In a `RuleFor` method, we first need to point to the property we want to configure.
    The next parameter of this method is a function with a `Faker` class as a parameter
    that allows us to define the value of the property. In this case, we use the `Faker`’s
    `Random.Int` method to indicate we want it to be a generated int value between
    two values.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RuleFor` 方法中，我们首先需要指向我们想要配置的属性。这个方法的下一个参数是一个带有 `Faker` 类作为参数的函数，它允许我们定义属性的值。在这种情况下，我们使用
    `Faker` 的 `Random.Int` 方法来表示我们想要它在两个值之间生成一个生成的 int 值。
- en: By calling the `Generate` method, the Bogus framework will generate an instance
    of the type we want, adhering to the rules we’ve defined. This gives back the
    instance of the `EmptyOrWithinRangeAttribute` we want to work with.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `Generate` 方法，Bogus 框架将生成我们想要的类型的实例，并遵循我们定义的规则。这会返回我们想要与之工作的 `EmptyOrWithinRangeAttribute`
    实例。
- en: 'Let’s go ahead and implement a test that checks if `EmptyOrWithinRangeAttribute`
    validates input correctly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现一个测试，检查 `EmptyOrWithinRangeAttribute` 是否正确验证输入：
- en: 'Add the `Value_WithinRange_IsValid` to this class, as shown here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Value_WithinRange_IsValid` 添加到这个类中，如下所示：
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `Arrange` step, we’re using Bogus’ `Faker` class to generate a random
    string with a length that falls between the `MinLength` and `MaxLength` properties
    of the `sut`. Remember – these `MinLength` and `MaxLength` properties are values
    generated by Bogus. This generated string value can now be used to check whether
    the `IsValid` method of the `EmptyOrWithingRangeAttribute` does what we expect
    it to do. The returned value should be `true`, which we can easily check with
    the `Assert.True` method.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Arrange` 步骤中，我们使用 Bogus 的 `Faker` 类生成一个随机字符串，其长度介于 `sut` 的 `MinLength` 和
    `MaxLength` 属性之间。记住——这些 `MinLength` 和 `MaxLength` 属性是由 Bogus 生成的值。现在，这个生成的字符串值可以用来检查
    `EmptyOrWithingRangeAttribute` 的 `IsValid` 方法是否如我们所期望的那样工作。返回的值应该是 `true`，我们可以很容易地使用
    `Assert.True` 方法来检查。
- en: 'Similarly, we can add a `Value_TooShort_IsNotValid` method that checks that
    the `IsValid` method returns `false` when the provided value isn’t correct:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们可以添加一个 `Value_TooShort_IsNotValid` 方法来检查当提供的值不正确时，`IsValid` 方法返回 `false`：
- en: '[PRE13]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While we’re at it, let’s also add a check to see if an empty string is returned
    as being valid. This is shown in the following code block:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们进行这项工作时，让我们也添加一个检查，看看是否返回空字符串被视为有效。这将在下面的代码块中展示：
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how short and straightforward these test methods are! Adding extra checks
    for input values being too long or null really isn’t hard labor. And because we
    are not working with hardcoded data, we can be pretty confident the `IsValid`
    method of the `EmptyOrWithingRangeAttributes` class works as expected in many
    different scenarios. On top of that, think about the speed and efficiency with
    which we’re validating this `ValidationAttribute` class. We haven’t deployed our
    app or clicked through its interface. Still, we’re already certain about the correctness
    of our code. That’s a significant boost in development efficiency!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些测试方法是多么简短和直接！添加额外的检查以确保输入值过长或为空实际上并不困难。而且因为我们不使用硬编码的数据，我们可以相当有信心 `EmptyOrWithingRangeAttributes`
    类的 `IsValid` 方法在许多不同场景下都能按预期工作。除此之外，想想我们验证这个 `ValidationAttribute` 类的速度和效率。我们还没有部署我们的应用程序或点击其界面。尽管如此，我们已经开始确信我们代码的正确性。这极大地提高了开发效率！
- en: 'Remember the `VM_Initialized_SubscribedToFavoriteUpdateMessage` method in the
    `RecipeListItemViewModelTests` class we wrote earlier? This method checks whether
    an instance of the `RecipeListItemViewModel` is registered as a receiver for the
    `FavoriteUpdateMessage`. In this test method, we had to initialize our sut. However,
    the values that were used to create it aren’t of any value inside the test: whichever
    values are used, the instance should listen for the `FavoriteUpdateMessage`. This
    is an ideal scenario to introduce AutoBogus. Just take a look at the updated code
    of the `VM_Initialized_SubscribedToFavoriteUpdateMessage` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前在 `RecipeListItemViewModelTests` 类中编写的 `VM_Initialized_SubscribedToFavoriteUpdateMessage`
    方法吗？这个方法检查 `RecipeListItemViewModel` 的一个实例是否已注册为 `FavoriteUpdateMessage` 的接收者。在这个测试方法中，我们必须初始化我们的系统单元（sut）。然而，用于创建它的值在测试中没有任何价值：无论使用什么值，实例都应该监听
    `FavoriteUpdateMessage`。这是一个引入 AutoBogus 的理想场景。只需看看 `VM_Initialized_SubscribedToFavoriteUpdateMessage`
    方法的更新代码：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the static `Generate` method of the `AutoFaker` class, we can generate
    an instance of `RecipeListItemViewModel`. The `Faker` class typically requires
    a default constructor for the object type we want to instantiate. The `RecipeListItemViewModel`
    doesn’t have a default constructor and that’s where `AutoFaker` comes into play:
    it will automatically provide fake values for the parameters. We basically don’t
    care which values are used to create this class. All that we are interested in
    in this test, is the fact the instantiated class is registered for the `FavoriteUpdateMessage`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `AutoFaker` 类的静态 `Generate` 方法，我们可以生成 `RecipeListItemViewModel` 的一个实例。`Faker`
    类通常需要一个默认构造函数来实例化我们想要创建的对象类型。`RecipeListItemViewModel` 没有默认构造函数，这就是 `AutoFaker`
    发挥作用的地方：它会自动为参数提供假值。我们基本上不关心用于创建这个类的值是什么。在这个测试中，我们感兴趣的唯一事实是实例化的类已注册为 `FavoriteUpdateMessage`。
- en: 'In other test methods, such as those in `RecipeListItemViewModelTests`, we’ve
    relied on hardcoded dummy data. We can use AutoBogus to get rid of these hardcoded
    values as well. Take a look at the updated `FavoriteUpdateMsgReceived_SameId_FavoriteUpdated`
    method:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他测试方法中，例如 `RecipeListItemViewModelTests` 中的方法，我们依赖于硬编码的虚拟数据。我们也可以使用 AutoBogus
    来消除这些硬编码的值。看看更新后的 `FavoriteUpdateMsgReceived_SameId_FavoriteUpdated` 方法：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this previous code block, we’re leveraging AutoBogus’ `Generate` method to
    generate random data for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个之前的代码块中，我们正在利用 AutoBogus 的 `Generate` 方法为我们生成随机数据。
- en: Bogus and AutoBogus automate .NET testing by generating unbiased, randomized
    test data, eliminating manual and potentially biased inputs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Bogus 和 AutoBogus 通过生成无偏、随机的测试数据来自动化 .NET 测试，从而消除手动和可能存在偏见的输入。
- en: Instead of merely providing fake data, we often need to mock entire components
    or behavior. This is where a dedicated mocking framework, such as Moq, becomes
    invaluable. Let’s delve into how Moq empowers us to effectively mock dependencies
    and streamline our testing process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供假数据之外，我们通常需要模拟整个组件或行为。这就是专门的模拟框架，如 Moq，变得非常有价值的地方。让我们深入了解 Moq 如何帮助我们有效地模拟依赖项并简化我们的测试过程。
- en: Mocking dependencies with Moq
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Moq 模拟依赖项
- en: Testing frequently involves scenarios where our system under test interacts
    with external dependencies, whether they are databases, APIs, or other services.
    Running tests against these real dependencies can lead to slow, unpredictable
    outcomes and potentially unwanted side effects. Mocking provides a solution by
    simulating these dependencies, ensuring our tests focus purely on the component
    at hand. Through mocking, we gain control over external interactions, ensuring
    our tests are swift, reliable, and free from external influences.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测试往往涉及我们的系统与外部依赖项交互的场景，这些依赖项可能是数据库、API或其他服务。针对这些真实依赖项运行测试可能导致缓慢、不可预测的结果，并可能产生不希望出现的副作用。模拟通过模拟这些依赖项提供了解决方案，确保我们的测试纯粹关注于当前组件。通过模拟，我们控制了外部交互，确保我们的测试快速、可靠且不受外部影响。
- en: Integration tests
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: When writing unit tests, we typically want to mock external dependencies as
    much as possible. However, it is often valuable to also test the integration of
    different components to ensure they work together seamlessly. This is where integration
    tests come in. Unlike unit tests, which focus heavily on mocking to test units
    in isolation, integration tests often involve fewer mocks. This ensures that components
    interact with each other in the exact manner we expect, verifying that they behave
    correctly as a unified whole.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写单元测试时，我们通常希望尽可能多地模拟外部依赖。然而，测试不同组件的集成以确保它们无缝协作通常也很有价值。这就是集成测试的用武之地。与侧重于模拟以测试独立单元的单元测试不同，集成测试通常涉及较少的模拟。这确保了组件以我们期望的确切方式相互交互，验证它们作为一个统一整体的行为是否正确。
- en: The principles of DI and separation of concerns accentuate this approach. When
    we design our components to be decoupled and inject their dependencies, it becomes
    seamless to replace real dependencies with mock versions during testing. Think
    of DI, SoC, and mocking as interlocking puzzle pieces, each complementing the
    other, leading to a comprehensive and maintainable testing strategy. Now, let’s
    dive into how Moq assists us in achieving this goal.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DI和关注点分离的原则强调了这种方法。当我们设计组件以解耦并注入它们的依赖项时，在测试期间用模拟版本替换真实依赖项变得无缝。将DI、SoC和模拟视为相互咬合的拼图碎片，每个都补充了其他，从而形成全面且可维护的测试策略。现在，让我们深入了解Moq如何帮助我们实现这一目标。
- en: 'When we inspect the `RecipeDetailViewModel`’s constructor, it’s evident that
    it depends on several services:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`RecipeDetailViewModel`的构造函数时，很明显它依赖于几个服务：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To effectively test this ViewModel, we need to abstract away its external dependencies.
    Mocking the `recipeService` parameter can be achieved like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地测试这个ViewModel，我们需要抽象出其外部依赖。可以通过以下方式模拟`recipeService`参数：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The mocked value can then be passed-in the `RecipeDetailViewModel` as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将模拟的值传递给`RecipeDetailViewModel`如下：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Task<Result<RecipeDetail>> LoadRecipe(string id);
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Task<Result<RecipeDetail>> LoadRecipe(string id);
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: recipeServiceMock
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: recipeServiceMock
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
- en: .ReturnsAsync(
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: .ReturnsAsync(
- en: Result<RecipeDetail>.Success(new RecipeDetail(...));
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Result<RecipeDetail>.Success(new RecipeDetail(...));
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: readonly Mock<IRecipeService> _recipeServiceMock;
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly Mock<IRecipeService> _recipeServiceMock;
- en: readonly Mock<IFavoritesService>
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly Mock<IFavoritesService>
- en: _favoritesServiceMock;
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _favoritesServiceMock;
- en: readonly Mock<IRatingsService> _ratingsServiceMock;
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly Mock<IRatingsService> _ratingsServiceMock;
- en: readonly Mock<INavigationService>
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly Mock<INavigationService>
- en: _navigationServiceMock;
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _navigationServiceMock;
- en: readonly Mock<IDialogService> _dialogServiceMock;
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly Mock<IDialogService> _dialogServiceMock;
- en: readonly RecipeDetailViewModel sut;
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: readonly RecipeDetailViewModel sut;
- en: '[PRE22]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: public RecipeDetailViewModelTests()
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public RecipeDetailViewModelTests()
- en: '{'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: _recipeServiceMock = new();
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _recipeServiceMock = new();
- en: _favoritesServiceMock = new();
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _favoritesServiceMock = new();
- en: _ratingsServiceMock = new();
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _ratingsServiceMock = new();
- en: _navigationServiceMock = new();
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _navigationServiceMock = new();
- en: _dialogServiceMock = new();
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _dialogServiceMock = new();
- en: _ratingsServiceMock
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _ratingsServiceMock
- en: .Setup(m =>
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .Setup(m =>
- en: m.LoadRatingsSummary(It.IsAny<string>()))
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: m.LoadRatingsSummary(It.IsAny<string>()))
- en: .ReturnsAsync(Result<RatingsSummary>.Success(
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: .ReturnsAsync(Result<RatingsSummary>.Success(
- en: AutoFaker.Generate<RatingsSummary>()));
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AutoFaker.Generate<RatingsSummary>()));
- en: sut = new RecipeDetailViewModel(
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sut = new RecipeDetailViewModel(
- en: _recipeServiceMock.Object,
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _recipeServiceMock.Object,
- en: _favoritesServiceMock.Object,
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _favoritesServiceMock.Object,
- en: _ratingsServiceMock.Object,
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _ratingsServiceMock.Object,
- en: _navigationServiceMock.Object,
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _navigationServiceMock.Object,
- en: _dialogServiceMock.Object);
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _dialogServiceMock.Object);
- en: '}'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Fact]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Fact]'
- en: public async Task OnNavigatedTo_Should_Load_Recipe()
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public async Task OnNavigatedTo_Should_Load_Recipe()
- en: '{'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE24]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: //Arrange
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //Arrange
- en: var recipeId = AutoFaker.Generate<string>();
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ "id", recipeId }'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: .Success(AutoFaker.Generate<RecipeDetail>()));
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: //Act
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: //Assert
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _recipeServiceMock.Verify(
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: m => m.LoadRecipe(recipeId), Times.Once);
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Fact]'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: public async Task OnNavigatedTo_Should_Map_RecipeDetail()
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: //Arrange
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: var recipeDetail = AutoFaker.Generate<RecipeDetail>();
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '{ "id", AutoFaker.Generate<string>() }'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: _recipeServiceMock
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: .Success(recipeDetail));
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: //Act
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: //Assert
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Assert.Equal(recipeDetail.Name, sut.Title);
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Assert.Equal(recipeDetail.Author, sut.Author);
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Fact]'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: public async Task FailedLoad_Should_ShowDialog()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: //Arrange
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: var parameters = new Dictionary<string, object> {
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '{ "id", AutoFaker.Generate<string>() }'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: _recipeServiceMock
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.LoadRecipe(It.IsAny<string>()))
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(Result<RecipeDetail>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: .Fail(AutoFaker.Generate<string>()));
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: _dialogServiceMock
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: .Setup(m => m.AskYesNo(It.IsAny<string>(), ...))
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: .ReturnsAsync(false);
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: //Act
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: await sut.OnNavigatedTo(parameters);
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: //Assert
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: _dialogServiceMock.Verify(m =>       m.AskYesNo (It.IsAny<string>(), ...), Times.Once);
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: _navigationServiceMock.Verify(m => m.GoBack(),
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Times.Once);
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <TargetFrameworks>net8.0;net8.0-android;net8.0-
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ios;net8.0-maccatalyst</TargetFrameworks>
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <OutputType Condition="'$(TargetFramework)' !=
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recipes.Mobile project and select Unload Project. Once unloaded, right-click
    it again and select Reload Project.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: public void Convert_Should_Return_ExpectedOutput(
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: object input, string expectedOutput)
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Arrange
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var sut = new Converters.RatingToStarsConverter();
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Act
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var result = sut.Convert(input,
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: null, null, null);
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Assert
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(expectedOutput, result);
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[InlineData("foo", "")]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(-1d, "")]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(6d, "")]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(1d, "\ue838")]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2d, "\ue838\ue838")]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.2d, "\ue838\ue838")]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.5d, "\ue838\ue838\ue839")]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[InlineData(2.9d, "\ue838\ue838\ue839")]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[Fact]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: public void SelectTemplate_NoteVM_Should_Return
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _NoteTemplate()
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Arrange
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var template = new DataTemplate();
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var sut = new InstructionsDataTemplateSelector();
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sut.NoteTemplate = template;
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sut.InstructionTemplate = new DataTemplate();
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Act
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var result = sut.SelectTemplate(
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: AutoFaker.Generate<NoteViewModel>(), null);
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: //Assert
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assert.Equal(template, result);
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
