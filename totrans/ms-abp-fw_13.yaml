- en: '*Chapter 10*: DDD – The Domain Layer'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：DDD – 领域层'
- en: The previous chapter was an overall view of **Domain-Driven Design** (**DDD**),
    where you learned about the fundamental layers, building blocks, and principles
    of DDD. You also gained an understanding of the structure of the ABP solution
    and its relation to DDD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章是对**领域驱动设计**（**DDD**）的整体概述，其中您学习了DDD的基本层、构建块和原则。您还了解了ABP解决方案的结构及其与DDD的关系。
- en: 'This chapter completely focuses on the implementation details of the domain
    layer with a lot of code examples and best practice suggestions. Here are the
    topics we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完全专注于领域层的实现细节，包含大量代码示例和最佳实践建议。以下是本章我们将涵盖的主题：
- en: Exploring the example domain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索示例领域
- en: Designing aggregates and entities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计聚合和实体
- en: Implementing domain services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现领域服务
- en: Implementing repositories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现仓储
- en: Building specifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建规范
- en: Publishing domain events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布领域事件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can clone or download the source code of the *EventHub* project from GitHub:
    [https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub克隆或下载*EventHub*项目的源代码：[https://github.com/volosoft/eventhub](https://github.com/volosoft/eventhub)。
- en: If you want to run the solution in your local development environment, you need
    to have an IDE/editor (such as Visual Studio) to build and run ASP.NET Core solutions.
    Also, if you want to create ABP solutions, you need to have the ABP CLI installed,
    as explained in [*Chapter 2*](B17287_02_Epub_AM.xhtml#_idTextAnchor026), *Getting
    Started with ABP Framework*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地开发环境中运行解决方案，您需要有一个IDE/编辑器（例如Visual Studio）来构建和运行ASP.NET Core解决方案。此外，如果您想创建ABP解决方案，您需要安装ABP
    CLI，如[*第2章*](B17287_02_Epub_AM.xhtml#_idTextAnchor026)中所述，*ABP框架入门*。
- en: Exploring the example domain
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索示例领域
- en: The examples in this chapter and the next chapter will mostly be based on the
    EventHub solution. So, it is essential to understand the domain first. [*Chapter
    4*](B17287_04_Epub_AM.xhtml#_idTextAnchor130), *Understanding the Reference Solution*,
    has already explained the solution. You can check it if you want to refamiliarize
    yourself with the application and the solution structure. Here, we will explore
    the technical details and the domain objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章中的示例将主要基于EventHub解决方案。因此，首先理解领域至关重要。[*第4章*](B17287_04_Epub_AM.xhtml#_idTextAnchor130)，*理解参考解决方案*已经解释了该解决方案。如果您想熟悉应用程序和解决方案结构，可以查看它。在这里，我们将探讨技术细节和领域对象。
- en: 'The following list introduces and explains the main concepts of the domain:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表介绍了并解释了领域的主要概念：
- en: '**Event** is the root object that represents an online or in-person event.
    An event has a title, description, start time, end time, registration capacity
    (optional), and a language (optional) as the main properties.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件**是表示在线或现场活动的根对象。事件具有标题、描述、开始时间、结束时间、注册容量（可选）和语言（可选）作为主要属性。'
- en: An event is created (organized) by an **Organization**. Any **User** in the
    application can create an organization and organize events within that organization.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件由**组织**创建（组织）。应用程序中的任何**用户**都可以创建组织并在该组织内组织活动。
- en: An event can have zero or more **Tracks** with a track name (typically a simple
    label such as 1, 2, 3 or A, B, C). A track is a sequence of sessions. An event
    with multiple tracks makes it possible to organize parallel sessions.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件可以有零个或多个**轨道**，每个轨道都有一个轨道名称（通常是一个简单的标签，如1、2、3或A、B、C）。轨道是一系列会议。具有多个轨道的事件使得组织并行会议成为可能。
- en: A track contains one or more **Sessions**. A session is a part of the event
    where attendees typically listen to a speaker for a certain length of time.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个轨道包含一个或多个**会议**。会议是活动的一部分，参与者通常会在一定时间内聆听演讲者。
- en: Finally, a session can have zero or more **Speakers**. A speaker is a person
    who talks in the session and makes a presentation. Generally, every session will
    have a speaker. But sometimes, there can be multiple speakers, or there can be
    no speaker associated with the session. *Figure 10.1* (in the next section) shows
    the relation of an event to its tracks, sessions, and speakers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一个会议可以有一个或多个**演讲者**。演讲者是会议中发言并做展示的人。通常，每个会议都会有一个演讲者。但有时可能会有多个演讲者，或者会议可能没有与演讲者相关联。[*图10.1*](下一节中)显示了事件与其轨道、会议和演讲者之间的关系。
- en: Any user in the application can **Register** for an event. Registered users
    are notified before the event starts or if the event time changes.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的任何用户都可以**注册**事件。注册用户在事件开始前或事件时间更改时会被通知。
- en: 'You''ve learned about the fundamental objects in the EventHub application.
    The next section explains the first building block of DDD: aggregates.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了EventHub应用程序中的基本对象。下一节将解释DDD的第一个构建块：聚合。
- en: Designing aggregates and entities
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计聚合和实体
- en: It is very important to design your entities and aggregate boundaries since
    the rest of the solution components will be based on that design. In this section,
    we will first understand what an aggregate is. Then we will see some key principles
    of an aggregate design. Finally, I will introduce some explicit rules and code
    examples to understand how we should implement aggregates.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 设计你的实体和聚合边界非常重要，因为解决方案的其他组件将基于该设计。在本节中，我们首先了解什么是聚合。然后我们将看到一些聚合设计的关键原则。最后，我将介绍一些明确的规则和代码示例，以了解我们应该如何实现聚合。
- en: What is an aggregate root?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是聚合根？
- en: An aggregate is a cluster of objects bound together by an aggregate root object.
    The aggregate root object is responsible for implementing the business rules and
    constraints related to the aggregate, keeping the aggregate objects in a valid
    state and preserving the data integrity. The aggregate root and the related objects
    have methods to achieve that responsibility.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是一组由聚合根对象绑定在一起的对象。聚合根对象负责实现与聚合相关的业务规则和约束，保持聚合对象的有效状态并保持数据完整性。聚合根和相关对象有方法来实现这一责任。
- en: 'The **Event** aggregate shown in the following figure is a good example of
    aggregates:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下图所示的事件聚合是一个聚合的好例子：
- en: '![Figure 10.1 – The Event aggregate'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 事件聚合'
- en: '](img/Figure_10.1_B17287.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B17287.jpg)'
- en: Figure 10.1 – The Event aggregate
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 事件聚合
- en: 'The examples in this chapter will mostly be based on the `Event` aggregate
    since it represents the essential concept of the EventHub solution. So, we should
    understand its design:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例将主要基于`事件`聚合，因为它代表了EventHub解决方案的基本概念。因此，我们应该理解其设计：
- en: The `Event` object is the aggregate root here, with a `GUID` primary key. It
    has a collection of `Track` objects (an event can have zero or more tracks).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`事件`对象是聚合根，具有`GUID`主键。它包含一个`Track`对象集合（一个事件可以有零个或多个轨道）。
- en: A `Track` is an entity with a `GUID` primary key and contains a list of `Session`
    objects (a track should have one or more sessions).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Track`是一个具有`GUID`主键的实体，包含一个`Session`对象列表（一个轨道应该有一个或多个会话）。'
- en: A `Session` is also an entity with a `GUID` primary key and contains a list
    of `Speaker` objects (a session can have zero or more speakers).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`会话`也是一个具有`GUID`主键的实体，包含一个`Speaker`对象列表（一个会话可以有零个或多个演讲者）。'
- en: A `Speaker` is an entity with a composite primary key that consists of `SessionId`
    and `UserId`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`演讲者`是一个具有复合主键的实体，由`SessionId`和`UserId`组成。'
- en: '`Event` is a relatively complex aggregate. Most of the aggregates in an application
    will consist of a single entity, the aggregate root entity.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`事件`是一个相对复杂的聚合。应用程序中的大多数聚合将只包含一个实体，即聚合根实体。'
- en: 'The aggregate root is also an entity with a special role in the aggregate:
    it is the root entity of the aggregate and is responsible for sub-collections.
    I will refer to the term **Entity** for both aggregate root and sub-collection
    entities. So, the entity rules are valid for both object types, unless I specifically
    refer to one of them.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合根也是一个在聚合中具有特殊角色的实体：它是聚合的根实体，负责子集合。我将使用术语**实体**来指代聚合根和子集合实体。因此，实体规则适用于这两种对象类型，除非我明确提到其中之一。
- en: In the next sections, I will introduce two fundamental properties of an aggregate,
    a single unit and a serialized object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将介绍聚合的两个基本属性：单个单元和序列化对象。
- en: A single unit
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个单元
- en: 'An aggregate is retrieved (from the database) and stored (in the database)
    as a single unit, including all the properties and sub-collection entities. For
    example, if you want to add a new `Session` to an `Event`, you should do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合作为一个单一单元检索（从数据库中）和存储（在数据库中），包括所有属性和子集合实体。例如，如果你想向一个`事件`添加一个新的`会话`，你应该执行以下操作：
- en: Read the related `Event` object from the database with all the `Track`, `Session,`
    and `Speaker` objects.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中读取包含所有`Track`、`Session`和`Speaker`对象的相关的`事件`对象。
- en: Use a method of the `Event` class to add the new `Session` object to a `Track`
    of the `Event`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Event` 类的方法将新的 `Session` 对象添加到 `Event` 的 `Track` 中。
- en: Save the `Event` aggregate to the database together with the new changes.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Event` 聚合体连同新更改一起保存到数据库中。
- en: This might seem inefficient to developers who are used to working with relational
    databases and ORMs such as EF Core. However, it is necessary because that's how
    we keep the aggregate objects consistent and valid by implementing the business
    rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对习惯于使用关系数据库和 ORM（如 EF Core）的开发者来说似乎效率不高。然而，这是必要的，因为这是通过实现业务规则来保持聚合对象的一致性和有效性的方式。
- en: 'Here is a simplified example application service method implementing that process:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个实现该过程的简化示例应用程序服务方法：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For this example, the `event.AddSession` method internally checks whether the
    new session's start time and end time conflict with another session on the same
    track. Also, the time range of the session should not overflow the event time
    range. We may have other business rules, too. We may want to limit the number
    of sessions in an event or check whether the session's speaker has another talk
    in the same time range.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，`event.AddSession` 方法内部会检查新会话的开始时间和结束时间是否与同一轨道上的另一个会话冲突。此外，会话的时间范围不应超出活动的时间范围。我们可能还有其他业务规则。我们可能希望限制活动中的会话数量或检查会话的演讲者是否在同一时间范围内有其他演讲。
- en: Remember that DDD is for state changes. If you need a mass query or to prepare
    a report, you can optimize your database query as much as possible. However, for
    any change on an aggregate, we need all the objects on that aggregate to apply
    the business rules related to that change. If you are worried about the performance,
    see the *Keep aggregates small* section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，领域驱动设计（DDD）是用于状态变化的。如果你需要进行大量查询或准备报告，你可以尽可能优化你的数据库查询。然而，对于任何对聚合体的更改，我们需要在该聚合体上的所有对象上应用与该更改相关的业务规则。如果你担心性能，请参阅*保持聚合体小*部分。
- en: At the end of the method, we've updated the `Event` entity using the repository's
    `UpdateAsync` method. If you are working with EF Core, you do not need to explicitly
    call the `UpdateAsync` method, thanks to EF Core's change tracking system. The
    changes will be saved since ABP's Unit of Work system calls the `DbContext.SaveChangesAsync()`
    method for you. However, for example, the MongoDB .NET Driver has no change tracking
    system, and you should explicitly call the `UpdateAsync` method to the `Event`
    object if you're using MongoDB.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法末尾，我们使用存储库的 `UpdateAsync` 方法更新了 `Event` 实体。如果你使用 EF Core，你不需要显式调用 `UpdateAsync`
    方法，因为 EF Core 的更改跟踪系统会为你调用 `DbContext.SaveChangesAsync()` 方法。然而，例如，MongoDB .NET
    驱动程序没有更改跟踪系统，如果你使用 MongoDB，你应该显式调用 `UpdateAsync` 方法到 `Event` 对象。
- en: About the IRepository.GetAsync Method
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `IRepository.GetAsync` 方法
- en: The `GetAsync` method of the repository (used in the preceding example code
    block) retrieves the `Event` object as an aggregate (with all sub-collections)
    as a single unit. It works out of the box for MongoDB, but you need to configure
    your aggregate for EF Core to enable that behavior. See the *The Aggregate pattern*
    section in [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)*, Working with
    the Data Access Infrastructure*, to remember how to configure it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库的 `GetAsync` 方法（在先前的示例代码块中使用）将 `Event` 对象作为一个聚合体（带有所有子集合）作为一个单元检索。对于 MongoDB，它默认工作，但你需要配置你的聚合体以启用
    EF Core 的该行为。请参阅[*第 6 章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)*，使用数据访问基础设施*中的*聚合模式*部分，以记住如何配置它。
- en: Retrieving and saving an aggregate as a single unit brings us the opportunity
    to make multiple changes to the objects of a single aggregate and save all of
    them together with a single database operation. This way, all the changes in that
    aggregate become atomic by nature without needing an explicit database transaction.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为单个单元检索和保存聚合体为我们提供了机会，可以对单个聚合体的对象进行多项更改，并使用单个数据库操作将它们全部保存。这样，该聚合体中的所有更改在本质上都是原子的，无需显式数据库事务。
- en: The Unit of Work System
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 工作单元系统
- en: If you need to change multiple aggregates (of the same or different types),
    you still need a database transaction. In this case, ABP's Unit of Work system
    (explained in [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working
    with the Data Access Infrastructure*) automatically handles database transactions
    by convention.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更改多个聚合（相同或不同类型），你仍然需要一个数据库事务。在这种情况下，ABP的单元工作系统（在[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)，*与数据访问基础设施一起工作*）会自动按照惯例处理数据库事务。
- en: A serializable object
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个可序列化的对象
- en: An aggregate should be serializable and transferrable on the wire as a single
    unit, including all of its properties and sub-collections. That means you are
    able to convert it to a byte array or an XML or JSON value, then deserialize (re-construct)
    it from the serialized value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聚合应该可序列化和可传输，作为一个单独的单元，包括其所有属性和子集合。这意味着你可以将其转换为字节数组或XML或JSON值，然后从序列化值反序列化（重新构造）它。
- en: EF Core does not serialize your entities, but a document database, such as MongoDB,
    may serialize your aggregate to a BSON/JSON value to store in the data source.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: EF Core不会序列化你的实体，但文档数据库，如MongoDB，可能会将你的聚合序列化为BSON/JSON值以存储在数据源中。
- en: This principle is not a design requirement for an aggregate, but it is a good
    guide while determining the aggregate boundary. For example, you cannot have properties
    referencing entities of other aggregates. Otherwise, the referenced object is
    also serialized as a part of your aggregate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则不是聚合的设计要求，但在确定聚合边界时是一个很好的指南。例如，你不能有引用其他聚合实体的属性。否则，引用的对象也将作为你聚合的一部分被序列化。
- en: Let's look at some more principles. The first rule, introduced in the next section,
    is the key practice to make an aggregate serializable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更多的原则。下一节中引入的第一条规则是使聚合可序列化的关键实践。
- en: Referencing other aggregates by their ID
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过ID引用其他聚合
- en: The first rule says that an aggregate (including the aggregate root and other
    classes) should not have navigation properties to other aggregates but can store
    their ID values when necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则指出，一个聚合（包括聚合根和其他类）不应该有导航属性到其他聚合，但在必要时可以存储它们的ID值。
- en: This rule makes the aggregate a self-contained, serializable unit. It also helps
    to not leak the business logic of an aggregate into another aggregate, by hiding
    aggregate details from other aggregates.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则使聚合成为一个自包含、可序列化的单元。它还有助于通过隐藏聚合细节来防止聚合的业务逻辑泄露到另一个聚合中。
- en: 'See the following example code block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例代码块：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Event` class has a navigation property to the `Organization` aggregate,
    which is prohibited by this rule. If we serialize an `Event` object to a JSON
    value, the related `Organization` object is also serialized.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类有一个导航属性到`Organization`聚合，这违反了该规则。如果我们将`Event`对象序列化为JSON值，相关的`Organization`对象也会被序列化。'
- en: 'In a proper implementation, the `Event` class can have an `OrganizationId`
    property for the related `Organization`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的实现中，`Event`类可以有一个`OrganizationId`属性来关联`Organization`：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once we have an `Event` object and need to access the related organization details,
    we should query the `Organization` object from the database using `OrganizationId`
    (or perform a `JOIN` query to load them together at the beginning).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个`Event`对象并且需要访问相关的组织详情，我们应该使用`OrganizationId`（或执行一个`JOIN`查询以在开始时一起加载它们）从数据库中查询`Organization`对象。
- en: If you are using a document database, such as MongoDB, this rule will seem natural
    to you. Because if you add a navigation property to the `Organization` aggregate,
    then the related `Organization` object is serialized and saved in the collection
    of `Event` objects in the database, which duplicates the organization data and
    copies it into all events. However, with relational databases, ORMs such as EF
    Core allow you to use such navigation properties and handle the relation without
    any problem. I still suggest implementing this rule since it keeps your aggregates
    simpler and reduces the complexity of loading related data. If you don't want
    to apply this rule, you can refer to the *Database provider independence* section
    of [*Chapter 9*](B17287_09_Epub_AM.xhtml#_idTextAnchor300), *Understanding Domain-Driven
    Design*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是文档数据库，如 MongoDB，这个规则对你来说将显得很自然。因为如果你向 `Organization` 聚合添加导航属性，那么相关的 `Organization`
    对象将被序列化并保存在数据库中 `Event` 对象的集合中，这会重复组织数据并将其复制到所有事件中。然而，在使用关系数据库时，EF Core 等ORM允许你使用这样的导航属性并处理关系而不会出现任何问题。我仍然建议实施这个规则，因为它可以使你的聚合更简单，并减少加载相关数据的复杂性。如果你不想应用这个规则，可以参考
    [*第9章*](B17287_09_Epub_AM.xhtml#_idTextAnchor300) 的 *数据库提供者独立性* 部分，*理解领域驱动设计*。
- en: 'The next section expresses a best practice: keep your aggregates small!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节表达了一个最佳实践：保持你的聚合小！
- en: Keep aggregates small
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持聚合小
- en: Once we load and save an aggregate as a single unit, we may have performance
    and memory usage problems if the aggregate is too big. Keeping an aggregate simple
    and small is an essential principle, not just for performance but also to reduce
    the complexity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将一个聚合作为一个单一单元加载和保存，如果聚合太大，我们可能会遇到性能和内存使用问题。保持聚合简单和小巧是一个基本原则，这不仅关乎性能，还关乎降低复杂性。
- en: The main aspect that makes an aggregate big is the potential number of sub-collection
    entities. If a sub-collection of an aggregate root contains hundreds of items,
    that's a sign of a bad design. In a good aggregate design, the items in a sub-collection
    should not exceed a few dozen and should remain below 100–150 in edge cases.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使聚合变大的主要方面是子集合实体可能的数量。如果一个聚合根的子集合包含数百个项目，这是一个设计不良的迹象。在一个好的聚合设计中，子集合中的项目不应超过几十个，并且在边缘情况下应保持在100-150以下。
- en: 'See the `Event` aggregate in the following code block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见以下代码块中的 `Event` 聚合：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are two sub-collections of the `Event` aggregate in this example: `Tracks`
    and `Registrations`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Event` 聚合有两个子集合：`Tracks` 和 `Registrations`。
- en: The `Tracks` sub-collection is a collection of parallel tracks in the event.
    It typically contains a few items, so there's no problem with loading the tracks
    while loading an `Event` entity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tracks` 子集合是事件中的并行轨道集合。它通常包含少量项目，因此在加载 `Event` 实体时加载轨道没有问题。'
- en: The `Registrations` sub-collection is a collection of the registration records
    for the event. Thousands of people can register for a single event, which will
    be a significant performance problem if we load all registered people whenever
    loading an event. Also, most of the time, we don't need all registered users while
    manipulating an `Event` object. So, it would be better not to include the collection
    of registered people in the `Event` aggregate. In this example, the `EventRegistration`
    class is a sub-collection entity. For a better design, we should make it a separate
    aggregate root class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Registrations` 子集合是事件的注册记录集合。成千上万的人可以为单个事件注册，如果我们每次加载事件时都加载所有注册的人，这将是一个重大的性能问题。而且，在操作
    `Event` 对象时，大多数时候我们不需要所有注册用户。因此，最好不在 `Event` 聚合中包含注册人员的集合。在这个例子中，`EventRegistration`
    类是一个子集合实体。为了更好的设计，我们应该将其作为一个独立的聚合根类。'
- en: 'There are three main considerations while determining the boundaries of an
    aggregate:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定聚合边界时，有三个主要考虑因素：
- en: The objects related and used together
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关并一起使用的对象
- en: Data integrity, validity, and consistency
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据完整性、有效性和一致性
- en: The load and save performance of the aggregate (as a technical consideration)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合的加载和保存性能（作为一个技术考虑因素）
- en: In real life, most aggregate roots won't have any sub-collections. When you
    think to add a sub-collection to an aggregate, think about the object size as
    a technical factor.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，大多数聚合根不会有任何子集合。当你考虑向一个聚合添加子集合时，要考虑对象大小作为一个技术因素。
- en: Concurrency Control
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 并发控制
- en: 'Another problem with big aggregate objects is that they increase the probability
    of the concurrent update problem since big objects are more likely to be changed
    by multiple users simultaneously. ABP Framework provides a standard model for
    concurrency control. Please refer to the documentation: [https://docs.abp.io/en/abp/latest/Concurrency-Check](https://docs.abp.io/en/abp/latest/Concurrency-Check).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大聚合对象的一个问题是它们增加了并发更新问题的概率，因为大对象更有可能被多个用户同时更改。ABP 框架提供了一个标准的并发控制模型。请参阅文档：[https://docs.abp.io/en/abp/latest/Concurrency-Check](https://docs.abp.io/en/abp/latest/Concurrency-Check)。
- en: In the next section, we will discuss single and composite primary keys for entities.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论实体的单键和复合键。
- en: Determining the primary keys for entities
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定实体的主键
- en: Entities are determined by their ID (a unique identifier or the `Guid` type
    for the entities of the pre-built modules. It also assumes that the user ID and
    tenant ID types are `Guid`. We discussed this topic in the *The GUID PK* section
    of [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the
    Data Access Infrastructure*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实体通过其 ID（一个唯一标识符或预构建模块的实体的 `Guid` 类型。它还假设用户 ID 和租户 ID 类型是 `Guid`。我们已在 [*第 6
    章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177) 的 *“使用数据访问基础设施”* 部分中讨论了此主题）来确定。
- en: ABP also allows you to use composite primary keys for your entities. A composite
    primary key consists of two or more properties (of an entity) that become a unique
    value together.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 还允许您为实体使用复合主键。复合主键由两个或多个属性（实体的属性）组成，这些属性组合成一个唯一值。
- en: As a best practice, use a single primary key (a `Guid` value, an incremental
    integer value, or whatever you want) for the aggregate root. You can use a single
    or composite primary for sub-collection entities.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，为聚合根使用单个主键（一个 `Guid` 值、一个递增整数值或您想要的任何值）。您可以为子集合实体使用单个或复合主键。
- en: Composite Keys in Non-Relational Databases
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库中的复合键
- en: Composite primary keys for sub-collection entities are generally used in relational
    databases because sub-collections have their own tables in a relational database.
    However, in a document database (such as MongoDB), you don't define primary keys
    for sub-collection entities since they don't have their own database collections.
    Instead, they are stored as a part of the aggregate root.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 子集合实体的复合主键通常用于关系型数据库，因为子集合在关系型数据库中有自己的表。然而，在文档数据库（如 MongoDB）中，您不需要为子集合实体定义主键，因为它们没有自己的数据库集合。相反，它们作为聚合根的一部分存储。
- en: In the *EventHub* project, `Event` is an aggregate root with a `Guid` primary
    key. `Track`, `Session`, and `Speaker` are sub-collection entities as a part of
    the `Event` aggregate. `Track` and `Session` entities have `Guid` primary keys,
    but the `Speaker` entity has a composite primary key.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *EventHub* 项目中，`Event` 是具有 `Guid` 主键的聚合根。`Track`、`Session` 和 `Speaker` 作为
    `Event` 聚合的一部分是子集合实体。`Track` 和 `Session` 实体具有 `Guid` 主键，但 `Speaker` 实体具有复合主键。
- en: 'The `Speaker` entity class is shown in the following code block:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Speaker` 实体类在以下代码块中显示：'
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`SessionId` and `UserId` compose the unique identifier for the `Speaker` entity.
    The `Speaker` class is derived from the `Entity` class (without a generic argument).
    When you derive from the non-generic `Entity` class, ABP Framework forces you
    to define the `GetKeys` method to obtain the components of the composite key.
    If you want to use composite keys, refer to the documentation of your database
    provider (such as EF Core) to learn how to configure them.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionId` 和 `UserId` 构成了 `Speaker` 实体的唯一标识符。`Speaker` 类是从 `Entity` 类（没有泛型参数）派生的。当您从非泛型
    `Entity` 类派生时，ABP 框架会强制您定义 `GetKeys` 方法以获取复合键的组件。如果您想使用复合键，请参考您数据库提供者的文档（如 EF
    Core）以了解如何配置它们。'
- en: Beginning with the next section, we will look at the implementation details
    of aggregates and entities.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将探讨聚合和实体的实现细节。
- en: Implementing entity constructors
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现实体构造函数
- en: A constructor method is used to create an object. The compiler creates a default
    parameterless constructor when we don't explicitly add a constructor to the class.
    Defining a constructor is a good way to ensure an object is properly created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数方法用于创建对象。当我们没有显式地将构造函数添加到类中时，编译器会创建一个默认的无参数构造函数。定义构造函数是确保对象正确创建的好方法。
- en: An entity's constructor is responsible for creating a valid entity. It should
    get the required values as the constructor parameters to force us to supply these
    values during object creation so the new object is useful just after creation.
    It should check (validate) these parameters and set the properties of the entity.
    It should also initialize sub-collections and perform additional initialization
    logic if necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的构造函数负责创建一个有效的实体。它应该获取作为构造函数参数的必需值，以强制我们在对象创建期间提供这些值，以便新创建的对象在创建后即可使用。它应该检查（验证）这些参数并设置实体的属性。它还应该初始化子集合，并在必要时执行其他初始化逻辑。
- en: 'The following code block shows an entity (an aggregate root entity) from the
    *EventHub* project:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块展示了来自*EventHub*项目的实体（一个聚合根实体）：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Country` is a very simple entity that has a single property: `Name`. The `Name`
    property is required, so the `Country` primary constructor (the actual constructor
    that is intended to be used by the application developers) forces the developer
    to set a valid value to that property by defining a `name` parameter and checking
    whether it is empty or exceeds a maximum length constraint. `Check` is a static
    class of ABP Framework with various methods used to validate method parameters
    and throw an `ArgumentException` error for invalid parameters.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`是一个非常简单的实体，它只有一个属性：`Name`。`Name`属性是必需的，因此`Country`的主要构造函数（实际构造函数，旨在由应用程序开发者使用）通过定义一个`name`参数并检查它是否为空或超过最大长度约束，强制开发者设置一个有效的值到该属性。`Check`是ABP框架的一个静态类，具有各种用于验证方法参数并抛出`ArgumentException`错误的`ArgumentException`错误。'
- en: The `Name` property has a private setter, so there is no way to change this
    value after the object creation. We can assume that countries don't change their
    names, for this example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Name`属性有一个私有设置器，因此创建对象后无法更改此值。我们可以假设在这个例子中，国家不会更改其名称。'
- en: The `Country` class's primary constructor takes another parameter, `Guid` `id`.
    We don't use `Guid.NewGuid()` in the constructor since we want to use the `IGuidGenerator`
    service of ABP Framework, which generates sequential GUID values (see *The GUID
    PK* section of [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working
    with the Data Access Infrastructure*). We directly pass the `id` value to the
    base class (`BasicAggregateRoot<Guid>` in this example) constructor, which internally
    sets the `Id` property of the entity.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`类的主要构造函数接受另一个参数`Guid id`。我们不在构造函数中使用`Guid.NewGuid()`，因为我们想使用ABP框架的`IGuidGenerator`服务，该服务生成顺序GUID值（见[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)的*GUID
    PK*部分，*与数据访问基础设施一起工作*）。我们直接将`id`值传递给基类构造函数（在这个例子中是`BasicAggregateRoot<Guid>`），该构造函数内部设置实体的`Id`属性。'
- en: The Need for Parameterless Constructors
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无参数构造函数的需求
- en: The `Country` class also defines a private, parameterless constructor. This
    constructor is just for ORMs, so they can construct an object while reading from
    the database. Application developers do not use it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`类还定义了一个私有、无参数的构造函数。这个构造函数仅用于ORM，以便它们可以在从数据库读取时构建对象。应用程序开发者不使用它。'
- en: 'Let''s see a more complex example, showing the primary constructor of the `Event`
    entity:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个更复杂的例子，展示`Event`实体的主要构造函数：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Event` class's constructor takes the minimal required properties as the
    parameters, and checks and sets them to the properties. All these properties have
    private setters (see the source code) and are set via the constructor or some
    methods of the `Event` class. The constructor uses these methods to set the `Title`,
    `Description`, `StartTime`, and `EndTime` properties.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类的构造函数接受作为参数的最小必需属性，并检查并设置它们为属性。所有这些属性都有私有设置器（见源代码），并且通过构造函数或`Event`类的某些方法设置。构造函数使用这些方法来设置`Title`、`Description`、`StartTime`和`EndTime`属性。'
- en: 'Let''s see the `SetTitle` method''s implementation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SetTitle`方法的具体实现：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `SetTitle` method assigns the given `title` value to the `Title` property
    by checking the constraints. It then sets the `Url` property, a calculated value
    based on the `Title` property, and the `UrlCode` property. This method is `public`,
    to use later when we need to change the `Event` entity's `Title` property.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetTitle`方法通过检查约束将给定的`title`值分配给`Title`属性。然后它设置`Url`属性，这是一个基于`Title`属性的计算值，以及`UrlCode`属性。此方法为`public`，以便在需要更改`Event`实体的`Title`属性时使用。'
- en: '`UrlCode` is an eight-character random unique value that is sent to the constructor
    and never changes. Let''s see another method that the constructor calls:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`UrlCode`是一个八位随机唯一值，它被发送到构造函数，并且永远不会改变。让我们看看构造函数调用的另一个方法：'
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we have a business rule: the `StartTime` value cannot be later than the
    `EndTime` value.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个业务规则：`StartTime`值不能晚于`EndTime`值。
- en: The `EventHub` constructor is `internal` to prevent creating `Event` objects
    out of the domain layer. The application layer should always use the `EventManager`
    domain service to create a new `Event` entity. In the next section, we will see
    why we've designed it like that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventHub`构造函数是`internal`，以防止在领域层之外创建`Event`对象。应用程序层应始终使用`EventManager`领域服务来创建一个新的`Event`实体。在下一节中，我们将看到为什么我们这样设计。 '
- en: Using services to create aggregates
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用服务创建聚合
- en: The best way to create and initialize a new entity is using its public constructor
    because it is the simplest way. However, in some cases, creating an object requires
    some more complex business logic that is not possible to implement in the constructor.
    For such cases, we can use a factory method on a domain service to create the
    object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和初始化新实体的最佳方式是使用其公共构造函数，因为这是最简单的方式。然而，在某些情况下，创建一个对象需要一些更复杂的业务逻辑，这些逻辑在构造函数中无法实现。对于这种情况，我们可以在领域服务上使用工厂方法来创建对象。
- en: 'The `Event` class''s primary constructor is `internal`, so the upper layers
    cannot directly create a new `Event` object. We should use the `EventManager`
    `CreateAsync` method to create a new `Event` object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`类的主要构造函数是`internal`，因此上层不能直接创建一个新的`Event`对象。我们应该使用`EventManager`的`CreateAsync`方法来创建一个新的`Event`对象：'
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will return to domain services later, in the *Implementing domain services*
    section of this chapter. With this simple `CreateAsync` method, we are creating
    a valid `Event` object and returning the new object. We needed such a factory
    method because we used the `eventUrlCodeGenerator` service to generate URL code
    for the new event. The `eventUrlCodeGenerator` service internally creates a random,
    eight-character code for the new event and also checks whether that code was used
    by another event before (see its source code if you want to learn more). That''s
    why it is `async`: it performs a database operation.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的“实现领域服务”部分稍后回到领域服务。通过这个简单的`CreateAsync`方法，我们创建了一个有效的`Event`对象，并返回了新对象。我们需要这样的工厂方法，因为我们使用了`eventUrlCodeGenerator`服务来为新事件生成URL代码。`eventUrlCodeGenerator`服务内部为新事件创建一个随机的、八位的代码，并检查该代码是否被另一个事件使用过（如果你想了解更多，请查看其源代码）。这就是为什么它是`async`：它执行数据库操作。
- en: We've used a factory method of a domain service to create a new `Event` object
    because the `Event` class's constructor cannot use the `eventUrlCodeGenerator`
    service. So, you can create factory methods if you need external services/objects
    while creating a new entity.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用领域服务的工厂方法创建了一个新的`Event`对象，因为`Event`类的构造函数不能使用`eventUrlCodeGenerator`服务。因此，如果你在创建新实体时需要外部服务/对象，你可以创建工厂方法。
- en: Factory Service versus Domain Service
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂服务与领域服务
- en: An alternative approach can be creating a dedicated class for the factory method.
    That means we could create an `EventFactory` class and move the `CreateAsync`
    method inside it. I prefer a domain service method for creating entities to keep
    the construction logic close to the other domain logic related to the entity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个专门用于工厂方法的类。这意味着我们可以创建一个`EventFactory`类，并将`CreateAsync`方法移入其中。我更喜欢使用领域服务方法来创建实体，以保持构建逻辑与其他与实体相关的领域逻辑紧密相连。
- en: Do not save the new entity to the database inside the `Factory` method and leave
    it to the client code (generally, an application service method). The `Factory`
    method's responsibility is to create the object and no more (think of it as an
    advanced constructor – an entity constructor cannot save the entity to the database,
    right?). The client code may need to perform additional operations on the entity
    before saving it. We will return to this topic in the next chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在`Factory`方法中将新实体保存到数据库中，并将其留给客户端代码（通常是一个应用程序服务方法）。`Factory`方法的责任是创建对象，不再有其他责任（把它想象成一个高级构造函数——实体构造函数不能将实体保存到数据库中，对吧？）。客户端代码可能需要在保存实体之前对实体执行额外的操作。我们将在下一章回到这个话题。
- en: Do not overuse factory methods and keep using simple public constructors wherever
    possible. Creating a valid entity is important, but it is just the beginning of
    an entity's lifecycle. In the next section, we will see how to change an entity's
    state in a controlled way.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度使用工厂方法，尽可能保持使用简单的公共构造函数。创建一个有效的实体很重要，但这只是实体生命周期的开始。在下一节中，我们将看到如何以受控的方式更改实体的状态。
- en: Implementing business logic and constraints
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现业务逻辑和约束
- en: An entity is responsible for keeping itself always valid. In addition to the
    constructor that ensures the entity is valid and consistent when it's first created,
    we can define methods on the entity class to change its properties in a controlled
    way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实体负责始终保持自身有效。除了确保实体在首次创建时有效和一致性的构造函数之外，我们还可以在实体类上定义方法，以受控的方式更改其属性。
- en: As a simple rule, if changing a property's value has pre-conditions, we should
    make its setter `private` and provide a method to change its value by implementing
    the necessary business logic and validating the provided value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条简单的规则，如果更改属性值的操作有先决条件，我们应该将其设置器 `private`，并提供一个方法来通过实现必要的业务逻辑和验证提供的值来更改其值。
- en: 'See the `Description` property of the `Event` class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `Event` 类的 `Description` 属性：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Description` property''s setter is `private`. We provide the `SetDescription`
    method as the only way to change its value. In this method, we validate the `description`
    value: it should be a string that has a length of more than `50` (`MinDescriptionLength`)
    and less than `2000` (`MaxDescriptionLength`). These constants are defined in
    the *EventHub.Domain.Shared* project, so we can reuse them in DTOs, as we will
    see in the next chapter.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Description` 属性的设置器是 `private` 的。我们提供 `SetDescription` 方法作为更改其值的唯一方式。在这个方法中，我们验证
    `description` 值：它应该是一个长度超过 `50` (`MinDescriptionLength`) 且小于 `2000` (`MaxDescriptionLength`)
    的字符串。这些常量定义在 `*EventHub.Domain.Shared*` 项目中，因此我们可以在 DTO 中重用它们，正如我们将在下一章中看到的。'
- en: Data Annotation Attributes on Entity Properties
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实体属性上的数据注释属性
- en: You may ask whether we can use `[Required]` or `[StringLength]` attributes on
    the `Description` property instead of creating a `SetDescription` method and manually
    performing the validation. Such attributes require another system that performs
    the validation. For example, EF Core can validate the properties based on these
    data annotation attributes while saving the entity to the database. However, that's
    not enough because, in that way, the entity could be invalid until we try to save
    it to the database. The entity should always be valid!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，我们是否可以在 `Description` 属性上使用 `[Required]` 或 `[StringLength]` 属性，而不是创建一个
    `SetDescription` 方法并手动执行验证。这些属性需要另一个执行验证的系统。例如，EF Core 可以在将实体保存到数据库时根据这些数据注释属性验证属性。然而，这还不够，因为以这种方式，实体可能在我们尝试将其保存到数据库之前就是无效的。实体应该始终是有效的！
- en: 'Let''s see a more complex example, again from the `Event` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更复杂的例子，再次来自 `Event` 类：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `AddSession` method accepts a `trackId` parameter since a session should
    belong to a track. It also accepts the `sessionId` of the new session (getting
    it as a parameter to let the client use the `IGuidGenerator` service to create
    the value). The remaining parameters are the required properties of the new session.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSession` 方法接受一个 `trackId` 参数，因为一个会话应该属于一个轨道。它还接受新会话的 `sessionId`（作为参数获取，以便客户端可以使用
    `IGuidGenerator` 服务来创建值）。其余参数是新会话的必需属性。'
- en: 'The `AddSession` method first checks whether the new session is within the
    event''s time range, then finds the right track (throws an exception otherwise)
    and delegates the remaining work to the `track` object. Let''s see the `track.AddSession`
    method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSession` 方法首先检查新会话是否在活动的时间范围内，然后找到正确的轨道（否则抛出异常），并将剩余的工作委托给 `track` 对象。让我们看看
    `track.AddSession` 方法：'
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First of all, this method is `internal` to prevent using it out of the domain
    layer. It is always used by the `Event.AddSession` method shown earlier in this
    section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这个方法是 `internal` 的，以防止在领域层之外使用它。它总是由本节前面展示的 `Event.AddSession` 方法使用。
- en: The `Track.AddSession` method loops through all the current sessions to check
    whether any session time conflicts with the new session. If there's no problem,
    it adds the session to the track.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Track.AddSession` 方法遍历所有当前会话，以检查是否有任何会话时间与新会话冲突。如果没有问题，它将会将会话添加到轨道中。'
- en: Returning `this` (the event object) from a setter method is a good practice
    since it allows us to chain the setters, for example, `eventObject.SetTime(…).SetDescription(…)`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从设置器方法返回`this`（事件对象）是一种良好的实践，因为它允许我们链式调用设置器，例如，`eventObject.SetTime(…).SetDescription(…)`。
- en: Both of the example methods used the properties on the event object and did
    not depend on any external object. What if we need to use an external service
    or repository to implement the business rule?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例方法都使用了事件对象上的属性，并且没有依赖于任何外部对象。如果我们需要使用外部服务或存储库来实现业务规则怎么办？
- en: Using external services in entity methods
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在实体方法中使用外部服务
- en: Sometimes, the business rule you want to apply needs to use external services.
    Entities cannot inject service dependencies because of technical and design restrictions.
    If you need to use a service in an entity method, the proper way to do this is
    to get that service as a parameter.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想应用的业务规则需要使用外部服务。由于技术和设计限制，实体不能注入服务依赖。如果你需要在实体方法中使用服务，正确的方式是作为参数获取该服务。
- en: 'Assume that we have a business rule for the event capacity: you cannot decrease
    the capacity to lower than the currently registered user count. A `null` capacity
    value means there is no registration limitation.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个关于事件容量的业务规则：你不能将容量降低到当前注册用户数以下。`null`容量值表示没有注册限制。
- en: 'See the following implementation on the `Event` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在`Event`类上的实现示例：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `SetCapacityAsync` method uses a repository object to execute a database
    query to get the currently registered user count. If the count is higher than
    the new capacity value, then it throws an exception. The `SetCapacityAsync` method
    is async since it performs an async database call. The client (generally an application
    service method) is responsible for injecting and passing the repository service
    to this method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetCapacityAsync`方法使用存储库对象执行数据库查询以获取当前注册用户数。如果计数高于新容量值，则抛出异常。由于它执行异步数据库调用，`SetCapacityAsync`方法是异步的。客户端（通常是一个应用程序服务方法）负责向此方法注入和传递存储库服务。'
- en: The `SetCapacityAsync` method guarantees implementing the business rule because
    the `Capacity` property's setter is `private`, and this method is the only way
    to change it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetCapacityAsync`方法保证了业务规则的实现，因为`Capacity`属性的设置器是`private`的，这是唯一更改它的方式。'
- en: You can get external services into methods as parameters, as shown in this example.
    However, that approach makes the entity dependent on external services, making
    it complicated and harder to test. It also violates the single responsibility
    principle and mixes the business logic of different aggregates (`EventRegistration`
    is another aggregate root).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将外部服务作为参数传递给方法，如本例所示。然而，这种方法使得实体依赖于外部服务，使得其变得复杂且难以测试。它还违反了单一职责原则，并混合了不同聚合体的业务逻辑（`EventRegistration`是另一个聚合根）。
- en: 'There is a better way to implement the business logic that depends on external
    services or works on multiple aggregates: domain services.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 实现依赖于外部服务或作用于多个聚合体的业务逻辑有更好的方法：领域服务。
- en: Implementing domain services
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现领域服务
- en: A domain service is another class in which we implement the domain rules and
    constraints. Domain services are typically needed when we need to work with multiple
    aggregates, and the business logic doesn't properly fit into any of these aggregates.
    Domain services are also used when we need to consume other services and repositories
    since they can use the dependency injection system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务是另一个类，我们在其中实现领域规则和约束。通常在需要与多个聚合体一起工作时，需要领域服务，并且业务逻辑不适合这些聚合体中的任何一个。当需要消费其他服务和存储库时，也使用领域服务，因为它们可以使用依赖注入系统。
- en: 'Let''s re-implement the `SetCapacityAsync` method (in the previous section)
    as a domain service method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新实现（在上一节中）的`SetCapacityAsync`方法作为领域服务方法：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we've injected `IRepository<EventRegistration, Guid>` into the
    `EventManager` domain service (see the source code for all the details) and got
    the `Event` object as a parameter. The setter of the `Event.Capacity` property
    is now `internal` so that it can be set only in the domain layer, in the `EventManager`
    class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`IRepository<EventRegistration, Guid>`注入到`EventManager`领域服务中（有关所有详细信息的源代码请参阅），并将`Event`对象作为参数获取。现在`Event.Capacity`属性的设置器是`internal`，这样它就只能在内层领域，即`EventManager`类中设置。
- en: 'A domain service method should be fine-grained: it should make a small (yet
    meaningful and consistent) change to the aggregate. The application layer then
    combines these small changes to perform different use cases.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务方法应该是细粒度的：它应该对聚合体进行小的（但有意义且一致的）更改。然后应用层将这些小的更改组合起来以执行不同的用例。
- en: 'We will explore application services in the next chapter. However, I find it
    useful to show an example application service method here that updates multiple
    properties on an event in a single request:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章探讨应用服务。然而，我认为在这里展示一个示例应用服务方法是有用的，该方法在一个请求中更新事件上的多个属性：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `UpdateAsync` method takes a DTO that contains the properties to be updated.
    It first retrieves the `Event` object from the database as a single unit, then
    uses `SetTitle` and `SetTime` methods on the `Event` object. These methods internally
    validate the provided values and properly change the property values.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateAsync`方法接受一个包含要更新属性的DTO。它首先从数据库中检索`Event`对象作为一个单一单元，然后使用`Event`对象上的`SetTitle`和`SetTime`方法。这些方法内部验证提供的值，并适当地更改属性值。'
- en: The `UpdateAsync` method then uses the domain service method, `eventManager.SetCapacity`,
    to change the capacity value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateAsync`方法随后使用领域服务方法`eventManager.SetCapacity`来更改容量值。'
- en: We directly set the `Language` property since it has a `public` setter and no
    business rule (it even accepts the `null` value). Do not create setter methods
    if they have no business rules or constraints. Also, do not create domain service
    methods simply to change the entity properties without any business logic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接设置`Language`属性，因为它有一个`public`的设置器，并且没有业务规则（它甚至接受`null`值）。如果没有业务规则或约束，不要创建设置器方法。同样，也不要仅仅为了改变实体属性而不涉及任何业务逻辑就创建领域服务方法。
- en: The `UpdateAsync` method finally uses the repository to update the `Event` entity
    in the database.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateAsync`方法最终使用存储库来更新数据库中的`Event`实体。'
- en: Domain Service Interfaces
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务接口
- en: You do not need to introduce interfaces (such as `IEventManager`) for domain
    services since they are essential parts of the domain and should not be abstracted.
    However, if you want to mock domain services in unit tests, you may still want
    to create interfaces.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是领域的基本部分，不应该被抽象化，因此不需要为领域服务引入接口（如`IEventManager`）。然而，如果你想对领域服务进行单元测试，你可能仍然想创建接口。
- en: A domain service method should not update the entity as a common principle.
    In this example, we set the `Language` property after calling the `SetCapacityAsync`
    method. If `SetCapacityAsync` updates the entity, we end up with two database
    update operations, which would be inefficient.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据一个普遍原则，领域服务方法不应该更新实体。在这个例子中，我们在调用`SetCapacityAsync`方法之后设置了`Language`属性。如果`SetCapacityAsync`更新了实体，我们最终会有两次数据库更新操作，这将是不高效的。
- en: As another good practice, accept the entity object as the parameter (as we've
    done in the `SetCapacityAsync` method) rather than its `id` value. If you accept
    its `id` value, you need to retrieve the entity from the database inside the domain
    service. This approach makes the application code load the same entity multiple
    times in different places in the same request (use case), which is inefficient
    and leads to bugs. Leave that responsibility to the application layer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个良好的实践，接受实体对象作为参数（就像我们在`SetCapacityAsync`方法中所做的那样），而不是它的`id`值。如果你接受它的`id`值，你需要在领域服务内部从数据库中检索实体。这种方法使得应用代码在同一个请求（用例）中的不同地方多次加载相同的实体，这是低效的，并可能导致错误。将这项责任留给应用层。
- en: A specific type of domain service method is the factory method to create aggregates,
    explained in the *Using services to create aggregates* section. Declare factory
    methods only if a public constructor on the aggregate root cannot implement the
    business constraints. This may be the case if checking the business constraint
    requires the use of external services.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 领域服务方法的一种特定类型是创建聚合的工厂方法，这在*使用服务创建聚合*部分中解释。只有当聚合根的公共构造函数无法实现业务约束时，才声明工厂方法。这可能是在检查业务约束需要使用外部服务的情况下。
- en: We've used repositories in many places so far. The next section explains the
    implementation details of repositories.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止已经在许多地方使用了存储库。下一节将解释存储库的实现细节。
- en: Implementing repositories
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现存储库
- en: To remember the definition, a repository is a collection-like interface used
    to access the domain objects stored in the data persistence system. It hides the
    complexity of data access logic behind a simple abstraction.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记住定义，存储库是一个类似于集合的接口，用于访问存储在数据持久化系统中的领域对象。它隐藏了数据访问逻辑的复杂性，提供了一个简单的抽象。
- en: 'There are some main rules for implementing repositories:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现存储库有一些主要规则：
- en: Repository interfaces are defined in the domain layer, so the domain and application
    layers can use them. They are implemented in the infrastructure (or database provider
    integration) layer.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库接口在领域层定义，因此领域和应用层可以使用它们。它们在基础设施（或数据库提供者集成）层实现。
- en: Repositories are created for aggregate root entities but not for sub-collection
    entities. That is because the sub-collection entities should be accessed over
    the aggregate root. Typically, you have a repository for each aggregate root.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库是为聚合根实体创建的，而不是为子集合实体创建的。这是因为子集合实体应该通过聚合根来访问。通常，你为每个聚合根有一个存储库。
- en: Repositories work with domain objects, not DTOs.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库与领域对象协同工作，而不是与DTO协同工作。
- en: In an ideal design, repository interfaces should be independent of the database
    provider. So, do not get or return EF Core objects, such as `DbContext` or `DbSet`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在理想的设计中，存储库接口应该独立于数据库提供者。因此，不要获取或返回EF Core对象，例如`DbContext`或`DbSet`。
- en: Do not implement business logic inside repository classes.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在存储库类中实现业务逻辑。
- en: ABP provides an implementation of the repository pattern out of the box. We
    explored how to use generic repositories and implement custom repositories in
    [*Chapter 6*](B17287_06_Epub_AM.xhtml#_idTextAnchor177), *Working with the Data
    Access Infrastructure*. Here, I will discuss a few best practices.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ABP提供了一种开箱即用的存储库模式实现。我们在[*第6章*](B17287_06_Epub_AM.xhtml#_idTextAnchor177)“与数据访问基础设施协同工作”中探讨了如何使用通用存储库和实现自定义存储库。在这里，我将讨论一些最佳实践。
- en: The last rule in the preceding list, "Do not implement business logic inside
    repository classes," is the most important rule because the others are clear to
    understand. Implementing business logic inside a repository is generally a result
    of incorrectly considering business logic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面列表中的最后一条规则“不要在存储库类中实现业务逻辑”是最重要的规则，因为其他规则都很容易理解。在存储库中实现业务逻辑通常是由于错误地考虑业务逻辑。
- en: 'See the following example repository interface:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例存储库接口：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At first sight, there is no problem; these methods are just performing some
    database operations. However, the devil is in the details.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，似乎没有问题；这些方法只是执行一些数据库操作。然而，问题出在细节上。
- en: 'The first method, `UpdateSessionTimeAsync`, changes the timing of a session
    in an event. If you remember, we had a business rule: a session''s timing cannot
    overlap with another session on the same track. It also cannot overflow the event
    time range. If we implement that rule in the repository method, we duplicate that
    business validation because it was already implemented inside the `Event` aggregate.
    If we don''t implement that validation, it is obviously a bug. In a true implementation,
    this logic should be done in the aggregate. The repository should only query and
    update the aggregate as a single unit.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`UpdateSessionTimeAsync`更改事件中会话的时间。如果你还记得，我们有一个业务规则：会话的时间不能与同一轨道上的另一个会话重叠。它也不能超出事件时间范围。如果我们在这个存储库方法中实现这个规则，我们就会重复业务验证，因为这项验证已经在`Event`聚合体内部实现了。如果我们不实现这个验证，显然是一个错误。在真正的实现中，这个逻辑应该在聚合体内部完成。存储库应该只查询和更新聚合体作为一个单一单元。
- en: The second method, `GetNearbyEventsAsync,` gets a list of events in the same
    city with the current user. The problem with this method is the *current user*
    is an application layer concept and requires an active user session. Repositories
    should not work with the current user. What if we want to reuse the same *nearby*
    logic in a background service where we don't have the current user in the current
    context? It is better to pass the city, date range, and other parameters to the
    method, so it simply brings the events. Entity properties are just values for
    the repositories. Repositories should not have any domain knowledge and should
    not use application layer features.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法 `GetNearbyEventsAsync` 获取与当前用户在同一城市的活动列表。这个方法的问题在于 *当前用户* 是一个应用层概念，需要活跃的用户会话。仓储不应该与当前用户一起工作。如果我们想在没有当前用户的当前上下文中重用相同的
    *附近* 逻辑在后台服务中怎么办？最好是将城市、日期范围和其他参数传递给方法，让它简单地获取事件。实体属性只是仓储的值。仓储不应该有任何领域知识，也不应该使用应用层功能。
- en: Repositories are fundamentally used to create, update, delete, and query entities.
    ABP's generic repository implementation provides most of the common operations
    out of the box. It also provides an `IQueryable` object that you can use to build
    and execute queries using LINQ. However, building complex queries at the application
    layer mixes your application logic with the data querying logic that should ideally
    be at the infrastructure layer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储主要用于创建、更新、删除和查询实体。ABP的通用仓储实现提供了大多数常见的操作。它还提供了一个 `IQueryable` 对象，您可以使用它来构建和执行使用LINQ的查询。然而，在应用层构建复杂的查询会将您的应用逻辑与理想中应在基础设施层的数据查询逻辑混合在一起。
- en: 'See the following example method, which uses `IRepository<Event, Guid>` to
    get a list of events that a given user has spoken at:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例方法，它使用 `IRepository<Event, Guid>` 获取给定用户演讲的事件列表：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the first line, we are obtaining an `IQueryable<Event>` object. Then we are
    using the `Where` method to filter the events. Finally, we are executing the query
    to get the event list.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们正在获取一个 `IQueryable<Event>` 对象。然后我们使用 `Where` 方法来过滤事件。最后，我们执行查询以获取事件列表。
- en: 'The problem with writing such queries into application services is leaking
    querying logic to the application layer and making it impossible to reuse the
    querying logic when we need it somewhere else. To overcome the problem, we generally
    create a custom repository method to query the events:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将此类查询写入应用程序服务的问题是将查询逻辑泄露到应用层，使得当我们需要在其他地方重用查询逻辑时变得不可能。为了克服这个问题，我们通常创建一个自定义仓储方法来查询事件：
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we can use this custom repository method anywhere we need to get the events
    at which a user was a speaker.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在需要获取用户曾经演讲的事件的任何地方使用这个自定义仓储方法。
- en: 'Creating custom repository methods is a good approach. But, with this approach,
    we have a lot of similar methods once the application grows. Assume that we wanted
    to get the event list in a specified date range, and we''ve added one more method:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义仓储方法是一个好方法。但随着应用的扩展，我们会有很多类似的方法。假设我们想在指定日期范围内获取事件列表，我们已经添加了一个新方法：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What if we want to query the events with a date range and speaker filter? Create
    another method as shown in the following code block:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想按日期范围和演讲者过滤器查询事件呢？创建另一个方法，如下面的代码块所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Actually, ABP provides the `GetListAsync` method, which takes an expression.
    So, we could remove all these methods and use the `GetListAsync` method with an
    arbitrary predicate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，ABP提供了 `GetListAsync` 方法，它接受一个表达式。因此，我们可以移除所有这些方法，并使用带有任意谓词的 `GetListAsync`
    方法。
- en: 'The following example uses the `GetListAsync` method to get a list of events
    at which a user is a speaker in the next 30 days:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用 `GetListAsync` 方法获取用户在接下来30天内作为演讲者的事件列表：
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, we''ve returned to the previous problem: mixing the querying complexity
    with the application code. Also, isn''t the query getting hard to understand?
    You know, in real life, we have queries with much more complexity.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们又回到了之前的问题：将查询复杂性与应用代码混合。此外，查询不是变得越来越难以理解吗？你知道，在现实生活中，我们有很多更复杂的查询。
- en: 'Completely getting rid of complex queries may not be possible, but the next
    section offers an interesting solution to that problem: the specification pattern!'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 完全消除复杂查询可能是不可能的，但下一节提供了一个有趣的解决方案：规范模式！
- en: Building specifications
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建规范
- en: A specification is a named, reusable, combinable, and testable class to filter
    domain objects based on business rules. In practice, we can easily encapsulate
    filter expressions as reusable objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 规范是一个命名的、可重用、可组合和可测试的类，用于根据业务规则过滤域对象。在实践中，我们可以轻松地将过滤表达式封装为可重用的对象。
- en: In this section, we will begin with the most simple, parameterless specifications.
    We will then see more complex, parameterized specifications. Finally, we will
    learn how to combine multiple specifications to create a more complex specification.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从最简单的无参数规范开始。然后我们将看到更复杂的参数化规范。最后，我们将学习如何组合多个规范以创建更复杂的规范。
- en: Parameterless specifications
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无参数规范
- en: 'Let''s begin with a very simple specification class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的规范类开始：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`OnlineEventSpecification` is used to filter online events, which means it
    selects an event if it is an online event. It is derived from the base `Specification<T>`
    class provided by ABP Framework to create specification classes easily. We override
    the `ToExpression` method to filter the event objects. This method should return
    a lambda expression that returns `true` if the given `Event` entity (here, the
    `x` object) satisfies the condition (we could simply write `return x => x.IsOnline`).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnlineEventSpecification` 用于过滤线上事件，这意味着它选择一个事件，如果它是线上事件。它是从 ABP 框架提供的基类 `Specification<T>`
    派生出来的，以轻松创建规范类。我们重写 `ToExpression` 方法来过滤事件对象。此方法应返回一个 lambda 表达式，如果给定的 `Event`
    实体（在这里，是 `x` 对象）满足条件（我们可以简单地写 `return x => x.IsOnline`）。'
- en: 'Now, if we want to get a list of online events, we can just use the repository''s
    `GetListAsync` method with a specification object:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想获取线上事件的列表，我们只需使用带有规范对象的存储库的 `GetListAsync` 方法：
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Specifications are implicitly converted to expressions (remember, the `GetListAsync`
    method can get an expression). If you want to explicitly convert them, you can
    call the `ToExpression` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 规范隐式转换为表达式（记住，`GetListAsync` 方法可以获取表达式）。如果您想显式转换它们，可以调用 `ToExpression` 方法：
- en: '[PRE24]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So, we can use a specification wherever we can use an expression. In this way,
    we can encapsulate expressions as named, reusable objects.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在可以使用表达式的任何地方使用规范。这样，我们可以将表达式封装为命名的、可重用的对象。
- en: 'The `Specification` class provides another method, `IsSatisfiedBy`, to test
    a single object. If you have an `Event` object, you can easily check whether it
    is an online event or not:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Specification` 类提供了一个名为 `IsSatisfiedBy` 的方法，用于测试单个对象。如果您有一个 `Event` 对象，您可以轻松地检查它是否是线上活动：'
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we have somehow obtained an `Event` object, and we want to
    check whether it is online. `IsSatisfiedBy` gets an `Event` object and returns
    `true` if that object satisfies the condition. I accept that this example seems
    absurd because we could simply write `if(evnt.IsOnline)`. Such a simple specification
    was not necessary. However, in the next section, we will see more complex examples
    to make it much clearer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们以某种方式获得了一个 `Event` 对象，我们想检查它是否是线上的。`IsSatisfiedBy` 接收一个 `Event` 对象，如果该对象满足条件，则返回
    `true`。我接受这个例子看起来很荒谬，因为我们可以直接写 `if(evnt.IsOnline)`。这样的简单规范是不必要的。然而，在下一节中，我们将看到更复杂的例子，以使其更加清晰。
- en: Parameterized specifications
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化规范
- en: 'Specifications can have parameters to be used in filtering expressions. See
    the following example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 规范可以具有用于过滤表达式的参数。请参见以下示例：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ve created a parameterized specification class that checks whether the
    given user is a speaker at an event. Once we have that specification class, we
    can filter the events as shown in the following code block:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个参数化规范类，用于检查给定的用户是否在活动中是演讲者。一旦我们有了这个规范类，我们就可以像以下代码块所示那样过滤事件：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we've just reused the `GetListAsync` method of the repository by providing
    a new `SpeakerSpecification` object. From now on, we can reuse this specification
    class if we need the same expression later, in another place in our application,
    without needing to copy/paste the expression. If we need to change the condition
    later, all those places will use the updated expression.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是通过提供一个新的 `SpeakerSpecification` 对象来重用了存储库的 `GetListAsync` 方法。从现在起，如果我们需要在应用程序的另一个地方稍后重用相同的表达式，我们可以重用这个规范类，而无需复制/粘贴表达式。如果我们稍后需要更改条件，所有这些地方都将使用更新的表达式。
- en: 'If we need to check whether a user is a speaker at the given `Event`, we can
    reuse the `SpeakerSpecification` class by calling its `IsSatisfiedBy` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要检查用户是否在给定的 `Event` 中是演讲者，我们可以通过调用其 `IsSatisfiedBy` 方法来重用 `SpeakerSpecification`
    类：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Specifications are powerful to create named and reusable filters, but they
    have another power too: combining specifications to create a composite specification
    object.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 规范非常强大，可以创建命名和可重用的过滤器，但它们还有另一个功能：将规范组合起来创建一个组合规范对象。
- en: Combining specifications
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合规范
- en: It is possible to combine multiple specifications using operator-like `And`,
    `Or`, and `AndNot` methods, or to reverse a specification with the `Not` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用类似操作符的 `And`、`Or` 和 `AndNot` 方法组合多个规范，或者使用 `Not` 方法反转一个规范。
- en: 'Assume that I want to find the events where a given user is a speaker, and
    the event is online:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想找到给定用户是演讲者且活动是线上的事件：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, I combined `SpeakerSpecification` and `OnlineEventSpecification`
    objects to create a composite specification object. Explicitly calling the `ToExpression`
    class is necessary in this case because C# doesn't support implicitly converting
    from interfaces (the `And` method returns an `ISpecification<T>` reference).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我结合了 `SpeakerSpecification` 和 `OnlineEventSpecification` 对象来创建一个组合规范对象。在这种情况下，显式调用
    `ToExpression` 类是必要的，因为 C# 不支持从接口（`And` 方法返回 `ISpecification<T>` 引用）隐式转换。
- en: 'The following example finds the in-person (offline) events in the next 30 days
    where the given user is a speaker:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例查找在接下来的 30 天内给定用户作为演讲者的现场（离线）活动：
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we've reversed the `OnlineEventSpecification` object's filtering
    logic with the `AndNot` method. We've also used a `DateRangeSpecification` object
    that we haven't defined yet. It is a good exercise for you to implement yourself.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `AndNot` 方法反转了 `OnlineEventSpecification` 对象的过滤逻辑。我们还使用了一个尚未定义的
    `DateRangeSpecification` 对象。自己实现它是一个很好的练习。
- en: 'An interesting example could be extending the `AndSpecification` class to create
    a specification class that combines two specifications:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是将 `AndSpecification` 类扩展以创建一个组合两个规范的规范类：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `OnlineSpeakerSpecification` class in this example combines the `SpeakerSpecification`
    class and the `OnlineEventSpecification` class, and can be used whenever you want
    to use a specification object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`OnlineSpeakerSpecification` 类结合了 `SpeakerSpecification` 类和 `OnlineEventSpecification`
    类，并且可以在你想使用规范对象时使用。
- en: When to Use Specifications
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用规范
- en: Specifications are especially useful if they filter objects based on domain
    rules that can be changed in the future, so you don't want to duplicate them everywhere.
    You do not need to define specifications for the expressions you are using just
    for reporting purposes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们基于可以未来更改的领域规则过滤对象，规范特别有用，因此你不想在各个地方重复它们。你不需要为仅用于报告目的的表达式定义规范。
- en: The next section explains how to use domain events to publish notifications.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释如何使用领域事件来发布通知。
- en: Publishing domain events
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布领域事件
- en: Domain events are used to inform other components and services about an important
    change to a domain object so that they can take action.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 领域事件用于通知其他组件和服务关于领域对象的重要更改，以便它们可以采取行动。
- en: 'ABP Framework provides two types of event buses to publish domain events, each
    with a different purpose:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ABP 框架提供了两种类型的事件总线来发布领域事件，每种类型都有不同的用途：
- en: The **local event bus** is used to notify the handlers in the same process.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地事件总线**用于通知同一进程中的处理器。'
- en: The **distributed event bus** is used to notify the handlers in the same or
    different processes.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事件总线**用于通知同一或不同进程中的处理器。'
- en: Publishing and handling events are pretty easy with ABP Framework. The next
    section shows how to work with the local event bus, and then we will look at the
    distributed event bus.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ABP 框架发布和处理事件非常简单。下一节将展示如何使用本地事件总线，然后我们将探讨分布式事件总线。
- en: Using the local event bus
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用本地事件总线
- en: A local event handler is executed in the same unit of work (in the same local
    database transaction). If you are building a monolith application or want to handle
    events in the same service, the local event bus is fast and safe to use because
    it works in the same process.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本地事件处理器在同一个工作单元（同一个本地数据库事务）中执行。如果你正在构建单体应用程序或想在同一个服务中处理事件，本地事件总线快速且安全，因为它在同一个进程中工作。
- en: Assume that you want to publish a local event when an event's time changes,
    and you have an event handler that sends emails to the registered users about
    the change.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在事件的时间改变时发布一个本地事件，并且你有一个事件处理器，它会向注册用户发送关于更改的电子邮件。
- en: 'See the simplified implementation of the `SetTime` method of the `Event` class:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `Event` 类的 `SetTime` 方法的简化实现：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we are adding a local event, which will be published while
    updating the entity. ABP Framework overrides EF Core's `SaveChangesAsync` method
    to publish the events (for MongoDB, it is done in the repository's `UpdateAsync`
    method).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在添加一个本地事件，该事件将在更新实体时发布。ABP 框架覆盖了 EF Core 的 `SaveChangesAsync` 方法来发布事件（对于
    MongoDB，这是在仓储的 `UpdateAsync` 方法中完成的）。
- en: 'Here, `EventTimeChangedEventData` is a plain class that holds the event data:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`EventTimeChangedEventData` 是一个简单的类，用于存储事件数据：
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Published events can be handled by creating a class that implements the `ILocalEventHandler<TEventData>`
    interface:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建一个实现 `ILocalEventHandler<TEventData>` 接口的类来处理发布的事件：
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `UserEmailingHandler` class can inject any service (or repository) to get
    a list of the registered users, and then send an email to inform them about the
    time change. You may have multiple handlers for the same event. If any handler
    throws an exception, the main database transaction is rolled back since the event
    handler is executed in the same database transaction.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserEmailingHandler` 类可以注入任何服务（或仓储）以获取注册用户的列表，然后发送电子邮件通知他们时间变更。对于同一事件，你可能会有多个处理器。如果任何处理器抛出异常，由于事件处理器是在同一数据库事务中执行的，因此主要数据库事务将被回滚。'
- en: Events can be published in entities, as shown in the previous examples. They
    can also be published using the `ILocalEventBus` service.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以在实体中发布，如前例所示。它们也可以使用 `ILocalEventBus` 服务发布。
- en: 'Let''s assume that we don''t publish the `EventTimeChangedEventData` event
    inside the `Event` class but want to publish it in an arbitrary class that can
    utilize the dependency injection system. See the following example application
    service:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不想在 `Event` 类内部发布 `EventTimeChangedEventData` 事件，而想在可以利用依赖注入系统的任意类中发布它。请看以下示例应用服务：
- en: '[PRE35]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `EventAppService` class injects the repository and `ILocalEventBus` service.
    In the `SetTimeAsync` method, we are using the local event bus to publish the
    same event.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventAppService` 类注入了仓储和 `ILocalEventBus` 服务。在 `SetTimeAsync` 方法中，我们使用本地事件总线发布相同的事件。'
- en: The `PublishAsync` method of the `ILocalEventBus` service immediately executes
    the event handlers. If any event handler throws an exception, you directly get
    the exception since the `PublishAsync` method doesn't handle exceptions. So, if
    you don't catch the exception, the whole unit of work is rolled back.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILocalEventBus` 服务的 `PublishAsync` 方法立即执行事件处理器。如果有任何事件处理器抛出异常，你会直接得到异常，因为
    `PublishAsync` 方法不处理异常。所以，如果你没有捕获异常，整个工作单元将被回滚。'
- en: It is better to publish the events in the entities or the domain services. If
    we publish the `EventTimeChangedEventData` event in the `Event` class's `SetTime`
    method, it is guaranteed to publish the event in any case. However, if we publish
    it in an application service, like in the last example, we may forget to publish
    the event in another place that changes the event times. Even if we don't forget,
    we will have duplicated code that is harder to maintain and open to potential
    bugs.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在实体或领域服务中发布事件会更好。如果我们把 `EventTimeChangedEventData` 事件发布在 `Event` 类的 `SetTime`
    方法中，那么在任何情况下都会保证发布该事件。然而，如果我们像在最后一个例子中那样在应用服务中发布它，我们可能会忘记在改变事件时间的另一个地方发布事件。即使我们没有忘记，我们也会产生难以维护且容易出错的重复代码。
- en: Local events are especially useful to implement side-effects such as taking
    extra action when the state of an object changes. It is perfect for de-coupling
    and integrating different aspects of the system. In this section, we have used
    it to send a notification email to the registered users when an event's time changes.
    However, it should not be misused by distributing business logic flow into event
    handlers and making the whole process hard to follow.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本地事件特别适用于实现副作用，例如在对象状态改变时采取额外行动。它非常适合解耦和集成系统的不同方面。在本节中，我们已用它来在事件的时间改变时向注册用户发送通知电子邮件。然而，不应滥用它，将业务逻辑流程分布到事件处理器中，从而使整个过程难以追踪。
- en: In the next section, we will see the second type of event bus.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到第二种类型的事件总线。
- en: Using the distributed event bus
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分布式事件总线
- en: In the distributed event bus, an event is published through a message broker
    service, such as RabbitMQ or Kafka. If you are building a microservice/distributed
    solution, the distributed event bus can asynchronously notify the handlers in
    other services.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式事件总线中，事件通过消息代理服务（如RabbitMQ或Kafka）发布。如果你正在构建微服务/分布式解决方案，分布式事件总线可以异步地通知其他服务中的处理程序。
- en: Using the distributed event bus is pretty similar to the local event bus, but
    it is important to understand the differences and limitations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分布式事件总线与本地事件总线非常相似，但理解它们之间的差异和限制是很重要的。
- en: 'Let''s assume that we want to publish a distributed event in the `Event` class''s
    `SetTime` method when the event''s time changes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在`Event`类的`SetTime`方法中事件时间变化时发布分布式事件：
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we call the `AddDistributedEvent` method to publish the event (it is published
    when the entity is updated in the database). As an important difference from the
    local event, we are not passing the entity (`this`) object as the event data but
    copying some properties to a new object. That new object will be transferred between
    processes. It will be serialized in the current process and deserialized in the
    target process (ABP Framework handles the serialization and deserialization for
    you). So, creating a DTO-like object that carries only the required properties
    rather than the full object is better. The **Eto** (**Event Transfer Object**)
    suffix is the naming convention that we suggest but it is not necessary to use
    it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`AddDistributedEvent`方法来发布事件（当实体在数据库中更新时发布）。与本地事件的一个重要区别是，我们不是将实体（`this`）对象作为事件数据传递，而是将一些属性复制到一个新对象中。这个新对象将在进程之间传输。它将在当前进程中序列化，并在目标进程中反序列化（ABP框架为你处理序列化和反序列化）。因此，创建一个只携带所需属性而不是完整对象的DTO-like对象更好。我们建议使用**Eto**（**事件传输对象**）后缀作为命名约定，但这不是必需的。
- en: 'The `AddDistributedEvent` (and `AddLocalEvent`) method is only available in
    the aggregate root entities, not for sub-collection entities. However, publishing
    a distributed event in an arbitrary service is still possible using the `IDistributedEventBus`
    service:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDistributedEvent`（以及`AddLocalEvent`）方法仅在聚合根实体中可用，而不是在子集合实体中。然而，使用`IDistributedEventBus`服务在任意服务中发布分布式事件仍然是可能的：'
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inject the `IDistributedEventBus` service and use the `PublishAsync` method
    – that's all.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注入`IDistributedEventBus`服务并使用`PublishAsync`方法——这就足够了。
- en: 'The application/service that wants to get notified can create a class that
    implements the `IDistributedEventHandler<T>` interface, as shown in the following
    code block:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 想要接收通知的应用程序/服务可以创建一个实现`IDistributedEventHandler<T>`接口的类，如下面的代码块所示：
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The event handler can use all the properties of the `EventTimeChangedEto` class.
    If it needs more data, you can add it to the `ETO` class. Alternatively, you can
    query the details from the database or perform an API call to the corresponding
    service in a distributed scenario.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序可以使用`EventTimeChangedEto`类的所有属性。如果需要更多数据，可以将其添加到`ETO`类中。或者，在分布式场景中，你可以从数据库查询详细信息或对相应的服务执行API调用。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered the first part of implementing DDD. We've explored the
    domain layer building blocks and understood their design and implementation practices
    using ABP Framework.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了实现DDD的第一部分。我们探讨了领域层构建块，并了解了使用ABP框架的设计和实现实践。
- en: The aggregate is the most fundamental DDD building block, and the way we change
    an aggregate's state is very important and needs care. An aggregate should preserve
    its validity and consistency by implementing business rules. It is essential to
    draw aggregate boundaries correctly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合是DDD最基础的构建块，我们改变聚合状态的方式非常重要，需要小心处理。聚合应通过实现业务规则来保持其有效性和一致性。正确绘制聚合边界是至关重要的。
- en: On the other hand, domain services are useful for implementing the domain logic
    that touches multiple aggregates or external services. They work with the domain
    objects, not DTOs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，领域服务对于实现涉及多个聚合或外部服务的领域逻辑非常有用。它们与领域对象一起工作，而不是与DTOs一起工作。
- en: The repository pattern abstracts the data access logic and provides an easy-to-use
    interface to other services in the domain and application layers. It is important
    not to leak your business logic into repositories. The specification pattern is
    a way to encapsulate data filtering logic. You can reuse and combine them when
    you want to select business objects.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 仓储模式抽象了数据访问逻辑，并为领域层和应用层中的其他服务提供了一个易于使用的接口。重要的是不要将业务逻辑泄露到仓储中。规范模式是一种封装数据过滤逻辑的方法。当你想要选择业务对象时，你可以重用和组合它们。
- en: Finally, we explored how we can publish and subscribe to domain events with
    ABP Framework. Domain events are used to react to changes to domain objects in
    a loosely coupled way.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何使用 ABP 框架发布和订阅领域事件。领域事件用于以松耦合的方式响应领域对象的变更。
- en: The next chapter will continue with the building blocks, this time in the application
    layer. It will also discuss the differences between the domain and application
    layers with practical examples.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续介绍构建块，这次是在应用层。它还将通过实际示例讨论领域层和应用层之间的差异。
