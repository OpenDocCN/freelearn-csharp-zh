- en: Optimizing for Performance and Comfort
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化性能和舒适度
- en: As we've mentioned throughout these chapters, the success of your VR app will
    be negatively impacted by any discomfort your users feel. It is a fact that VR
    can cause motion sickness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这些章节中提到的，你的VR应用程序的成功将受到用户感受到的任何不适的负面影响。一个事实是，VR可以引起运动病。
- en: 'The symptoms of motion sickness are nausea, sweating, headaches, even vomiting.
    It can take hours, perhaps an overnight sleep, to recover. In real life, humans
    are susceptible to motion sickness: riding a roller coaster, a bumpy airplane,
    a rocking boat. It''s caused when one part of the balance-sensing system thinks
    your body is moving but other parts don''t.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 运动病症状包括恶心、出汗、头痛，甚至呕吐。可能需要数小时，甚至一整夜的睡眠才能恢复。在现实生活中，人类容易患运动病：乘坐过山车、颠簸的飞机、摇晃的船只。当平衡感知系统的一部分认为你的身体在运动，而其他部分则没有这种感觉时，就会发生这种情况。
- en: In VR, this could occur when the eyes see motion but your body doesn't sense
    it. We've considered ways you can design your VR apps to avoid this. With locomotion,
    always give the user control over their first person movement. Try to avoid riding-the-rails
    experiences and especially avoid free-falling. Include using a horizon line or
    dashboard in the foreground so at least the player feels they're grounded in a
    cockpit if not on solid ground.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，这可能会发生在眼睛看到运动，但你的身体没有感觉到运动的时候。我们已经考虑了你可以设计你的VR应用程序来避免这种情况的方法。在移动时，始终让用户控制他们的第一人称移动。尽量避免乘坐轨道体验，尤其是避免自由落体。包括使用前景中的地平线或仪表盘，至少让玩家感觉到他们在一个驾驶舱中，如果不是在坚实的地面上。
- en: 'The opposite is also true: when you body feels motion but your eyes don''t
    see it.  Even very subtle discord can have a bad effect. In VR, a major culprit
    is latency. If you move your head but the view you see doesn''t keep up with the
    movement, that can cause nausea.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来也是一样：当你身体感觉到运动，但你的眼睛没有看到运动时。即使是非常微妙的失调也可能产生不良影响。在VR中，一个主要的原因是延迟。如果你移动你的头，但你看到的视图没有跟上运动，这可能会导致恶心。
- en: 'Although this chapter is at the end of this book, we do not mean to suggest
    that performance issues be left for the end of your project implementation. The
    old adage "first get it to work, then get it to work faster" doesn''t necessarily
    apply to VR development. You need to pay attention to performance and comfort
    throughout your development process, which we will address as the main topics
    in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一章位于本书的末尾，但我们并不想建议将性能问题留到项目实施的最后。老话“先让它工作，再让它更快”并不一定适用于VR开发。你需要在整个开发过程中关注性能和舒适度，这是我们将在本章中讨论的主要主题：
- en: Optimizing your artwork and 3D models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的艺术作品和3D模型
- en: Optimizing your scene and lighting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的场景和照明
- en: Optimizing your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化你的代码
- en: Optimizing the rendering with shaders and settings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用着色器和设置优化渲染
- en: Key tools in analyzing and diagnosing performance issues are the built-in Unity
    Profiler and Stats windows. We will start with a quick introduction to these.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 分析和诊断性能问题的关键工具是内置的Unity Profiler和Stats窗口。我们将从对这些窗口的快速介绍开始。
- en: Using the Unity Profiler and Stats
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity Profiler和Stats
- en: Optimizing can be a lot of work, and there is a learning curve to get the hang
    of it. The good news is that it can be accomplished incrementally. Tackle the
    more obvious, bigger bang-for-the-buck things first. You can accomplish a lot
    with little or no visual degradation after a bit of experimentation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 优化可能是一项大量工作，并且需要学习曲线来掌握它。好消息是，它可以逐步完成。先解决更明显、收益更大的问题。经过一些实验后，你可以用很少或没有视觉降级来完成很多事情。
- en: 'The Unity Editor includes two built-in tools to assess performance: the Stats window
    and the Profiler window.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器包括两个内置工具来评估性能：Stats窗口和Profiler窗口。
- en: The Stats window
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stats窗口
- en: The Stats window shows real-time rendering statistics when you press Play in
    the Unity Editor. Reviewing and understanding these statistics is your first line
    in evaluating and improving the performance of your app, and can help you decide
    which optimization strategies, including those covered in this chapter, to tackle
    first.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Unity编辑器中按Play时，Stats窗口会显示实时渲染统计信息。审查和理解这些统计信息是评估和改进你的应用程序性能的第一步，并可以帮助你决定首先解决哪些优化策略，包括本章中涵盖的策略。
- en: 'In the Game window, enable Stats by pressing the Stats button. A screenshot
    is shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Game窗口中，通过按Stats按钮启用Stats。这里显示了一个截图：
- en: '![](img/8472ef1b-22cf-4eed-8592-8332d6ed18ae.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8472ef1b-22cf-4eed-8592-8332d6ed18ae.png)'
- en: 'The actual statistics displayed will vary depending on your current build target (see [http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html)),
    including:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的实际统计数据将根据您当前的构建目标而变化（见[http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html)），包括：
- en: Graphics FPS (frames per seconds) and time per frame
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形帧率（FPS）和每帧时间
- en: CPU time per frame
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每帧的CPU时间
- en: Tris (triangles)/Verts (vertices)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三角形（Tris）/顶点（Verts）
- en: Batches
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批次
- en: In VR, you want to pay close attention to the frames per second. The minimum
    acceptable rate varies depending on your target device, but generally for desktop
    devices you should keep it at or above 90 FPS, while 60 FPS (or 75 FPS) is considered
    an absolute minimum. The Sony PlayStation VR accepts 60 FPS but uses hardware
    to automatically double the rate to 120 FPS to compensate. Windows Mixed Reality
    HMD will throttle the frame rate between 90 and 60 depending on the graphics processor
    hardware on your computer, allowing laptops with slower mobile GPU to run VR.
    Phone-based mobile VR devices can target 60 FPS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR中，您需要密切关注每秒帧数。可接受的最小速率因目标设备而异，但通常对于桌面设备，您应该将其保持在90 FPS或以上，而60 FPS（或75 FPS）被认为是绝对最低。索尼PlayStation
    VR接受60 FPS，但使用硬件自动将速率加倍至120 FPS以补偿。Windows Mixed Reality HMD将根据您计算机上的图形处理器硬件调整帧率在90到60之间，允许配备较慢移动GPU的笔记本电脑运行VR。基于手机的移动VR设备可以针对60
    FPS。
- en: When in Editor Play mode, the FPS is not necessarily the same as you'd experience
    running a built executable in your device, so it should be used as an indicator,
    not necessarily an actual value. But, thankfully, it does not include any editor-only
    processing such as drawing the Scene view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器播放模式下，FPS不一定与您在设备上运行构建的可执行文件时的体验相同，因此它应该用作指示器，而不是实际值。但幸运的是，它不包括任何仅编辑器处理的操作，例如绘制场景视图。
- en: Examining the CPU time per frame and comparing that with the overall graphics
    time per frame will tell you whether your game is CPU bound or GPU bound. That
    is, which process is the bottleneck, slowing you down the most. The CPU is used
    for physics calculations, geometry culling, and other operations that prepare
    the data for rendering in the GPU. The GPU runs the shaders and actually generates
    the pixel values for display. Knowing if you're CPU or GPU bound can help dictate
    where to focus your optimization efforts to improve your game performance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查每帧的CPU时间并与整体图形时间每帧进行比较，可以告诉您您的游戏是CPU受限还是GPU受限。也就是说，哪个过程是瓶颈，最慢地减慢了您的速度。CPU用于物理计算、几何剔除和其他准备数据以供GPU渲染的操作。GPU运行着色器并实际生成用于显示的像素值。了解您是CPU受限还是GPU受限可以帮助您决定在哪里集中优化努力以提高游戏性能。
- en: The Tris (triangles) and Verts (vertices) values show the size of your geometric
    models' meshes that are drawn. Only the visible faces of your meshes are counted,
    so your scene could include much more.  That is, the values in Stats are the geometry
    the camera is looking at, not including any vertices outside the view, and after
    any occluded surfaces have been removed. As you move the camera or as objects
    in the scene move, the numbers will change. As we'll see in the next topic, reducing
    the poly count of your models can lead to significant gains in performance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形（Tris）和顶点（Verts）值显示了绘制的几何模型网格的大小。只有网格的可见面被计算，因此您的场景可能包含更多内容。也就是说，Stats中的值是摄像机正在查看的几何形状，不包括任何视图外的顶点，以及任何遮挡表面被移除后的情况。当您移动摄像机或场景中的对象移动时，数字会变化。正如我们将在下一个主题中看到的，减少模型的顶点数可以显著提高性能。
- en: The Batches value is an indicator of how hard your GPU is working. The more
    batches, the more rendering the GPU must perform each frame. The number of batches,
    not the size of a batch, is the bottleneck. You can reduce batches by reducing
    the geometry in your scene. Since it's faster to have fewer (albeit larger) batches
    than lots of small ones, you can tell Unity to optimize the graphics by combining
    more geometry into larger batches, and pump that through the GPU pipeline.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 批次（Batches）值是衡量您的GPU工作强度的指标。批次越多，GPU每帧必须执行的渲染就越多。批次的数量，而不是批次的大小，是瓶颈。您可以通过减少场景中的几何形状来减少批次。由于少量（尽管较大）的批次比大量小批次更快，因此您可以告诉Unity通过将更多几何形状组合成更大的批次来优化图形，并通过GPU管道推送这些批次。
- en: When profiling and optimizing, write down (or take screenshots of) the stats
    and label them, perhaps in a spreadsheet, to log your progress and measure the
    effectiveness of each technique that you try.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析和优化时，写下（或截图）统计数据并标记它们，可能是在电子表格中，以记录你的进度并衡量你尝试的每种技术的有效性。
- en: Overview of the Profiler
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析器概述
- en: 'The Unity Profiler is a performance instrumentation tool that reports how much
    processing time is spent in various areas of your game, including rendering and
    scripts. It records the statistics over time during gameplay and shows them in
    a timeline graph. Clicking lets you drill down into the details. See [http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html) and
    the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Unity性能分析器是一个性能监控工具，它报告了你在游戏中的各个区域（包括渲染和脚本）所花费的处理时间。它记录游戏过程中的统计数据，并在时间轴图中显示。点击可以让你深入查看详细信息。请参阅[http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html)和以下截图：
- en: '![](img/ffb8bf9d-6826-42fa-8580-c642473f0db7.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffb8bf9d-6826-42fa-8580-c642473f0db7.png)'
- en: The Profiler compacts a lot of information into a small space, so you should
    recognize its various parts to understand better what you're seeing. Along the
    top of the window is the Profiler controls toolbar, which enables you to turn
    profiling on and off (Record) and navigate through profiled frames. The white
    vertical line in the profile Tracks is the playhead, indicating the current frame
    being examined.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器将大量信息压缩到一个小空间中，因此你应该识别其各个部分，以便更好地理解你所看到的内容。窗口顶部的性能分析器控制工具栏允许你开启和关闭性能分析（记录）并浏览分析过的帧。性能分析跟踪中的白色垂直线是播放头，指示当前正在检查的帧。
- en: The Deep Profile button lets you drill down into more detail, recording all
    function calls in your scripts. This can be useful to see exactly where time is
    spent in your game code. Note that deep profiling incurs a lot of overhead and
    causes your game to run very slowly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 深度分析按钮允许你深入查看更多细节，记录脚本中的所有函数调用。这有助于你确切地了解游戏代码中时间花费的位置。请注意，深度分析会带来大量的开销，并导致游戏运行非常缓慢。
- en: Underneath the toolbar are the profile tracks. Scroll down the Tracks pane to
    reveal more.  You can add and remove tracks using the Add Profiler select list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具栏下方是性能分析跟踪。通过滚动“跟踪”面板可以显示更多内容。你可以使用“添加性能分析器选择列表”来添加和删除跟踪。
- en: Each track includes stats for many parameters pertaining to that category of
    processing. For example, CPU Usage includes Scripts and Physics; the Rendering
    one include Batches and Triangles. The visual graph allows you to readily detect
    anomalies. When troubleshooting, look for stretches and spikes where the data
    exceeds your expected thresholds.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个跟踪都包含与该处理类别相关的许多参数的统计数据。例如，CPU使用率包括脚本和物理；渲染跟踪包括批量和三角形。可视图表允许你轻松检测异常。在故障排除时，寻找数据超过预期阈值的长段和尖峰。
- en: You can profile your game running in the Unity Editor, or remote profile your
    game running in a separate player, such as a mobile device.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Unity编辑器中分析运行的游戏，或者远程分析在单独的玩家中运行的游戏，例如移动设备。
- en: Optimizing your art
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的艺术作品
- en: Some decisions that impact performance the most are your intentionally creative
    ones. Maybe you want hyper-realistic graphics with high-fidelity sound because
    *its gotta be so awesome!* Realizing you must dial that down may constitute a
    difficult design compromise. However, it's also likely that with a little creative
    *outside-the-box* thinking and experimentation, you can achieve (nearly) identical
    visual results with much better performance. The one thing that you have most
    control over in your project is the content of your scenes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 影响性能最大的决策中，有些是你有意为之的创意决策。也许你想要超逼真的图形和高质量的音效，因为“它必须非常棒！”意识到你可能需要降低这些设置可能构成一个困难的设计妥协。然而，通过一点创新的“跳出思维定式”思考和实验，你可能会以（几乎）相同的外观效果实现更好的性能。在你的项目中，你最有控制权的是场景内容。
- en: Quality is not only how it looks, but also how it feels. Optimizing for user
    experience is as fundamental a design decision as any.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 质量不仅仅是外观，还包括感觉。优化用户体验与任何基本的设计决策一样重要。
- en: In general, try to minimize the number of vertices and faces in your model's
    meshes. Avoid complex meshes. Remove faces that will never be seen, such as the
    ones inside of solid objects. Clean up duplicate vertices and remove doubles.
    This will most likely be done in the same 3D modeling application you used to
    create them in the first place. For example, Blender has the tools for this. Also,
    there are third-party tools that you can purchase to simplify model meshes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，尽量减少模型网格中的顶点和面的数量。避免使用复杂的网格。移除那些永远不会被看到的面，例如固体物体内部的那些面。清理重复的顶点并移除双面。这很可能会在最初创建模型时使用的相同3D建模应用程序中完成。例如，Blender就有这样的工具。此外，您还可以购买第三方工具来简化模型网格。
- en: Be sure to check out Unity's Import Settings for your FBX models. There are
    option to compress and optimize your meshes, for example. See [https://docs.unity3d.com/Manual/FBXImporter-Model.html](https://docs.unity3d.com/Manual/FBXImporter-Model.html).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要检查Unity的FBX模型导入设置。例如，有选项可以压缩和优化您的网格。请参阅[https://docs.unity3d.com/Manual/FBXImporter-Model.html](https://docs.unity3d.com/Manual/FBXImporter-Model.html)。
- en: Let's demonstrate what we mean. We are going to set up a scene with a high polygon
    count model, replicate that model 1000 times, examine it in the Profiler, and
    try some optimization techniques.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来演示一下我们的意思。我们将设置一个具有高多边形计数的模型场景，复制该模型1000次，在分析器中检查它，并尝试一些优化技术。
- en: Setting up the scene
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: To begin, we'll need a high-poly model. We found one of a pair of sunglasses
    on Turbosquid with over 5,800 triangles, and which includes a transparent material
    for the lenses ([https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082](https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082)).
    Please download the FBX file now. A copy is also included with the files for this
    book, for convenience. We will refer to this as `Sunglasses-original.fbx` to distinguish
    it from other versions we'll modify along the way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个高多边形模型。我们在Turbosquid上找到了一副太阳镜的模型，超过5,800个三角形，并且包括用于镜片的透明材料（[https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082](https://www.turbosquid.com/3d-models/3ds-sunglasses-blender/764082)）。请现在下载FBX文件。本书的文件中也包含了一个副本，以方便使用。我们将称这个文件为`Sunglasses-original.fbx`，以区别于我们将在途中修改的其他版本。
- en: 'Then, go into Unity, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，进入Unity，如下所示：
- en: Create a new scene (File | New Scene), then save it (File | Save Scene As) and
    name it `Optimization`
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景（文件 | 新场景），然后保存它（文件 | 保存场景为）并命名为“优化”
- en: Import the model into your Project `Assets Models` folder (Assets | Import New
    Asset)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型导入到您的项目`Assets Models`文件夹中（资产 | 导入新资产）
- en: Create a ground plane for reference (Create | 3D  Object | Plane), named `Ground
    Plane`, reset its Transform, and create or assign it a material with a neutral
    color (such as our `Ground Material` with Albedo `#908070FF`)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个参考地面（创建 | 3D对象 | 平面），命名为“地面平面”，重置其变换，并创建或分配一个中性颜色的材料（例如我们的“地面材料”具有Albedo
    `#908070FF`）
- en: Create a cube (Create | 3D Object | Cube), Positioned at (`-1, 1, 1`), and give
    it a colored material (such as  our `Red Material` with Albedo `#E52A2AFF`)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体（创建 | 3D对象 | 立方体），位置在（`-1, 1, 1`），并给它一个着色材料（例如我们的“红色材料”具有Albedo `#E52A2AFF`）
- en: Move the `Main Camera` to Position (`0, 0.5, -2`)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主摄像机移动到位置（`0, 0.5, -2`）
- en: 'Now add a copy of the sunglasses:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加一副太阳镜的副本：
- en: Drag a copy of the `Sunglasses-original` model into the scene
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Sunglasses-original`模型的副本拖入场景
- en: Set its Position (`0, 1, 0`), Rotation (`90, 180, 15`), and Scale (`10, 10,
    10`)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其位置（`0, 1, 0`），旋转（`90, 180, 15`），和缩放（`10, 10, 10`）
- en: 'As a baseline, let''s look at its Stats and Profile, and make a note of the
    values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基线，让我们看看它的统计数据和配置文件，并记录下数值：
- en: In the Game window, press Stats
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏窗口中，按下Stats
- en: Also, open the Profiler window (Window | Profile)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，打开分析器窗口（窗口 | 分析器）
- en: Press Play
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放
- en: 'The Game window has the following scene and Stats window, showing the graphics
    hovering around 420 FPS, CPU main 2.4ms, with 22.6k Tris:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏窗口具有以下场景和统计数据窗口，显示图形大约在420 FPS，CPU主频2.4ms，22.6k三角形：
- en: '![](img/606e83c4-8de1-4c75-a9fd-a10524379c10.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/606e83c4-8de1-4c75-a9fd-a10524379c10.png)'
- en: 'The corresponding Profiler window is shown next. You can see in the Rendering
    timeline where I moved the HMD around:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个窗口显示了相应的分析器窗口。您可以看到在渲染时间线中我移动了HMD的位置：
- en: '![](img/a6c71367-764e-431f-9aa4-5bc42d401d5c.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6c71367-764e-431f-9aa4-5bc42d401d5c.png)'
- en: 'This scene is too simple to gather much in the way of meaningful statistics.
    Let''s create 1000 copies of the sunglasses in the scene; follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景太简单了，无法收集到多少有意义的统计数据。让我们在场景中创建1000个太阳镜的副本；按照以下步骤操作：
- en: Create an Empty game object and name it `SunglassesReplicator`
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象，并将其命名为`SunglassesReplicator`
- en: 'Create a new C# script on it, named `SunglassesReplicator`, and write it as
    follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其上创建一个新的C#脚本，命名为`SunglassesReplicator`，并编写如下：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The script takes a `prefab` object and instantiates it the `dup` number of times
    (`10`) in each of the X, Y, and Z axes, offsetting each by `delta` units (`2`),
    generating a total of 1000 instances of the prefab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接受一个`prefab`对象，并在X、Y和Z轴的每个轴上实例化`dup`次数（`10`），每个轴偏移`delta`单位（`2`），总共生成1000个预制件实例。
- en: 'Save the script, then back in Unity, set up and assign the replicator parameters
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，然后回到Unity中，设置并分配复制器参数如下：
- en: Make a prefab of your sunglasses. Drag the `Sunglasses-original` from Hierarchy
    into your Project `Assets prefabs` folder
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你太阳镜的预制件。将“Sunglasses-original”从层次结构拖到你的项目“Assets prefabs”文件夹
- en: Select the `SunglassesReplicator` in Hierarchy again and drag the prefab from
    Project Assets onto its Prefab slot
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在层次结构中选择“SunglassesReplicator”，并将预制件从项目资产拖到其预制件槽中
- en: Set the `SunglassesReplicator` Position to (`-10, 1, 0`) as the origin of our
    stack of sunglasses
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SunglassesReplicator`的位置设置为（`-10, 1, 0`）作为我们一叠太阳镜的起点
- en: 'Press Play and the generated sunglasses Borg is shown in the Scene window:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放，生成的太阳镜博格在场景窗口中显示：
- en: '![](img/66cdabb4-35c6-495c-97e5-4d3ea06b8099.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66cdabb4-35c6-495c-97e5-4d3ea06b8099.png)'
- en: 'The Stats now report over 36 million tris and a frame rate under 60 FPS. Ugh!
    The corresponding Profiler timeline is shown here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的统计数据显示超过3600万个三角形，帧率低于60 FPS。哎呀！相应的Profiler时间线如下所示：
- en: '![](img/6acd84f0-0c62-40a1-b67e-29b6dc19761d.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6acd84f0-0c62-40a1-b67e-29b6dc19761d.png)'
- en: OK, now that we have a poorly performing scene, let's see what we can do about
    it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们有一个性能不佳的场景，让我们看看我们能做些什么。
- en: Decimating models
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少模型数量
- en: 'One thing we can do is try to simplify the models that we imported into Unity.
    If you select the `SunGlasses-original` object in your Project Assets, you can
    see it consists of two meshes: the `Frame` with 4176 tris, and the `Lens` with
    1664 tris. We should reduce the number of faces on the mesh, or *decimate* the
    model. Presently, we will use the separate free and open source Blender application
    ([https://www.blender.org/](https://docs.unity3d.com/Manual/LevelOfDetail.html)).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试简化导入到Unity中的模型。如果你在项目资产中选择`SunGlasses-original`对象，你可以看到它由两个网格组成：`Frame`网格有4176个三角形，`Lens`网格有1664个三角形。我们应该减少网格上的面数，或者*减少模型数量*。目前，我们将使用独立的免费和开源Blender应用程序（[https://www.blender.org/](https://docs.unity3d.com/Manual/LevelOfDetail.html)）。
- en: Note that the original FBX file of this model downloaded from Turbosquid is
    in FBX 6 ASCII format, which is not compatible with Blender 2.7+. The version
    of the file provided with this book was converted using Autodesk FBX Converter
    2013 ([http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909](http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从Turbosquid下载的此模型的原始FBX文件是FBX 6 ASCII格式，与Blender 2.7+不兼容。本书提供的文件版本是使用Autodesk
    FBX Converter 2013转换的（[http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909](http://usa.autodesk.com/adsk/servlet/pc/item?siteID=123112&id=22694909)）。
- en: 'Follow these steps to decimate the model in Blender:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤在Blender中减少模型数量：
- en: Open Blender, and delete all to clear the default scene (keyboard A | A again
    | X | Delete)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Blender，删除所有内容以清除默认场景（键盘A | 再次A | X | 删除）
- en: Import the source Sunglasses fbx file (File | Import | FBX)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入原始太阳镜fbx文件（文件 | 导入 | FBX）
- en: Select the sunglasses' frame model mesh (right-click)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择太阳镜的框架模型网格（右键点击）
- en: On the right, choose the Modify tool (wrench icon)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，选择修改工具（扳手图标）
- en: Select Add Modifier | Decimate
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加修改器 | 减少模型数量
- en: 'Set Ratio to `0.1`, as shown here:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将比例设置为`0.1`，如图所示：
- en: '![](img/4f409db7-ea4b-4662-9a5b-1f87f337d137.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f409db7-ea4b-4662-9a5b-1f87f337d137.png)'
- en: Then, press Apply
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按下应用
- en: Select the sunglass' lens model mesh (right-click)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择太阳镜的镜片模型网格（右键点击）
- en: Decimate it also to Ratio `0.1` and Apply
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也将其减少到比例`0.1`并应用
- en: Delete the camera, light, and background objects (select with mouse, keyboard
    X to delete)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除相机、灯光和背景对象（用鼠标选择，键盘X删除）
- en: Export as FBX (File | Export | FBX) and give it a new name, such as `SunGlasses-decimated.fbx`
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以FBX格式导出（文件 | 导出 | FBX）并给它一个新的名称，例如`SunGlasses-decimated.fbx`
- en: 'Now back in Unity, import the model and use it in our replicator as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到Unity中，导入模型并在我们的复制器中使用它如下：
- en: Import the new `SunGlasses-decimated.fbx` file (Assets | Import New Asset) into
    your `Models` folder
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`SunGlasses-decimated.fbx`文件导入到你的`Models`文件夹（资产 | 导入新资产）
- en: Drag a copy of this model, `SunGlasses-decimated`, into the scene
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此模型 `SunGlasses-decimated` 的副本拖入场景
- en: Copy/paste the transform from the original (using Transform Copy Component from
    the original, and Paste Component Values on the decimated version)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制/粘贴原始对象的变换（使用原始对象的变换复制组件，并在减面版本上粘贴组件值）
- en: Save this as a prefab (drag `SunGlasses-decimated` from Hierarchy into your
    Project `Assets Prefabs` folder)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存为预制件（将 `SunGlasses-decimated` 从层次结构拖到项目 `Assets Prefabs` 文件夹中）
- en: Set this one in the `SunglassesReplicator` (drag the prefab from Project Assets
    onto the replicator's Prefab slot)
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SunglassesReplicator` 中设置此材质（将项目资源中的预制件拖到复制器的预制件槽中）
- en: Press Play and as expected, we are now running about 3.4M tris, about 10% of 
    what we had before, and we've boosted the FPS some, consistently more than 60
    FPS. Better, but not good enough.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放键，正如预期的那样，我们现在运行大约3.4M个三角形，大约是之前的10%，并且我们提高了FPS，始终超过60 FPS。更好，但还不够好。
- en: Transparent materials
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透明材质
- en: Another killer of graphics processing and frame rate is the use of transparency
    and other rendering techniques that require each pixel to be rendered multiple
    times. For the sunglasses lens to appear transparent, Unity will render the solid
    objects behind it first, then render the semi-transparent lens pixels on top,
    effectively merging the pixel values. Possibly dozens of lenses stacked in front
    of one another causes a considerable amount of processing work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图形处理和帧率的另一个杀手是使用透明度和其他需要渲染每个像素多次的渲染技术。为了使太阳镜镜头看起来透明，Unity将首先渲染其后面的实体对象，然后渲染半透明镜头像素，从而有效地合并像素值。可能有一打镜头堆叠在一起，这会导致相当多的处理工作。
- en: 'Let''s see what happens when we replace the transparent lens material with
    an opaque one:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们用不透明材质替换透明镜头材质会发生什么：
- en: In your Project `Assets Materials` folder, create a new Material and name it
    `Lens_Opaque`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目 `Assets Materials` 文件夹中，创建一个新的材质并将其命名为 `Lens_Opaque`
- en: For its Albedo color, choose an opaque gray, such as `#333333FF`
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其 Albedo 颜色，选择一个不透明的灰色，例如 `#333333FF`
- en: Drag a copy of `Sunglasses-source` to Hierarchy and rename it `Sunglasses-opaque`
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-source` 的副本拖到层次结构中并重命名为 `Sunglasses-opaque`
- en: Unfold it and select the `Lens` child object
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开它并选择 `Lens` 子对象
- en: Drag the `Lens_Opaque` material onto the Lens
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Lens_Opaque` 材质拖到镜头上
- en: Select the `Sunglasses-opaque` and drag it into the `Prefabs` folder, creating
    a new prefab
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Sunglasses-opaque` 并将其拖入 `Prefabs` 文件夹，创建一个新的预制件
- en: With `SunglassesReplicator` selected, drag the `Sunglasses-opaque` prefab onto
    its Prefab slot
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `SunglassesReplicator` 后，将 `Sunglasses-opaque` 预制件拖到其预制件槽中
- en: When you press Play now, we have 1000 of the opaque sunglasses and we get a
    much better frame rate, about 80 FPS.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下播放键时，我们现在有1000副不透明太阳镜，并且我们得到了更好的帧率，大约80 FPS。
- en: 'What happens if we combine these two techniques? Let''s use the opaque material
    on the decimated lenses. Like we just did, create another version of the prefab,
    named `Sunglasses-decimated-opaque`, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这两种技术结合起来会怎样？让我们在减面后的镜头上使用不透明材质。就像我们刚才做的那样，创建另一个预制件版本，命名为 `Sunglasses-decimated-opaque`，如下所示：
- en: Drag a copy of `Sunglasses-decimated` to Hierarchy and rename it `Sunglasses-decimated-opaque`
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-decimated` 的副本拖到层次结构中并重命名为 `Sunglasses-decimated-opaque`
- en: Unfold it and select the `Lens` child object
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开它并选择 `Lens` 子对象
- en: Drag the `Lens_Opaque` material onto the Lens
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Lens_Opaque` 材质拖到镜头上
- en: Select the `Sunglasses-decimated-opaque` and drag it into the `Prefabs` folder,
    creating a new prefab with the opaque lenses
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Sunglasses-decimated-opaque` 并将其拖入 `Prefabs` 文件夹，创建一个新的预制件，具有不透明镜头
- en: With `SunglassesReplicator` selected, drag the `Sunglasses-decimated-opaque` prefab
    onto its Prefab slot
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 `SunglassesReplicator` 后，将 `Sunglasses-decimated-opaque` 预制件拖到其预制件槽中
- en: 'Pressing Play we consistently get about 100 FPS, as shown in the Profiler timeline:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放键，我们在Profiler时间轴上始终得到大约100 FPS
- en: '![](img/18ff4448-d9eb-44df-aa46-deebc8b5793c.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18ff4448-d9eb-44df-aa46-deebc8b5793c.png)'
- en: Terrific! We have the frame rate we want. But... that's not the look we want
    either. We have opaque lenses, but we expect translucent ones. And, disappointingly,
    the low poly versions of the glasses look... low poly. That's just not acceptable.
    Perhaps there's a compromise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们得到了想要的帧率。但是……这也不是我们想要的外观。我们有不透明的镜头，但我们期望的是半透明的。而且，令人失望的是，眼镜的低多边形版本看起来……就是低多边形。这根本不能接受。也许有一个折衷方案。
- en: Levels of detail
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细程度
- en: Reviewing our scene, we realize that the high-poly sunglasses are really only
    needed for the ones closest to you. As they recede further into the distance,
    the low-poly version is just fine. Likewise, the transparency on the lenses is
    really mostly needed on the ones near you. The sunglasses in the distance, and
    those occluded by other glasses, do not really need transparency. Unity understands
    this and provides a component to automatically manage levels of detail, called
    **LOD Group** (see [https://docs.unity3d.com/Manual/LevelOfDetail.html](https://docs.unity3d.com/Manual/LevelOfDetail.html)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的场景，我们发现高多边形太阳镜实际上只需要在你最近的地方。随着它们退到更远的地方，低多边形版本就足够了。同样，镜片上的透明度实际上主要只需要在你附近的地方。远处的太阳镜和被其他眼镜遮挡的太阳镜实际上不需要透明度。Unity
    理解这一点，并提供了一个组件来自动管理细节级别，称为 **LOD 组**（见 [https://docs.unity3d.com/Manual/LevelOfDetail.html](https://docs.unity3d.com/Manual/LevelOfDetail.html)）。
- en: 'Let''s use this now. We''ll create a group of sunglasses, with each of our
    versions for levels of detail:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用它。我们将创建一组太阳镜，每个版本都有不同的细节级别：
- en: In Hierarchy, create an Empty game object, name it `SunglassesLOD`, and reset
    its Transform
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中，创建一个空的游戏对象，命名为 `SunglassesLOD`，并重置其变换
- en: Drag a copy of the `Sunglasses-original` prefab as a child of `SunglassesLOD`
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-original` 预制体的副本作为 `SunglassesLOD` 的子对象拖动
- en: Drag a copy of the `Sunglasses-decimated` prefab as a child also
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-decimated` 预制体的副本也作为子对象拖动
- en: And drag a copy of the `Sunglasses-decimated-opaque` too
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还拖动一个 `Sunglasses-decimated-opaque` 的副本
- en: Select the parent `Sunglasses` object and Add Component | LOD Group
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择父对象 `Sunglasses` 并添加组件 | LOD 组
- en: Look at the LOD Group component in Inspector. Notice it has several ranges for
    when to use each model based on camera distance, labeled LOD0, LOD1, and LOD2\.
    The range is a percentage of the object's bounding box height relative to the
    screen height. When closest, the LOD0 objects are active. Further away, those
    will be deactivated and the LOD1 ones will be active, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看检查器中的 LOD 组组件。注意它有几个基于相机距离使用每个模型的范围，标记为 LOD0、LOD1 和 LOD2。范围是对象边界框高度相对于屏幕高度的百分比。当最近时，LOD0
    对象是活动的。更远的地方，这些将停用，而 LOD1 对象将活动，依此类推。
- en: 'Let''s assign the LOD groups now:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分配 LOD 组：
- en: Select LOD0
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 LOD0
- en: Drag the `Sunglasses-original` game object from Hierarchy onto the Add button
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-original` 游戏对象从层次结构拖动到添加按钮
- en: Select LOD1
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 LOD1
- en: Drag the `Sunglasses-decimated` game object onto the Add button
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-decimated` 游戏对象拖动到添加按钮
- en: Select LOD2
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 LOD2
- en: Drag the `Sunglasses-decimated-opaque` object onto Add also
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sunglasses-decimated-opaque` 对象也拖动到添加
- en: 'A screen capture of the Inspector is shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了检查器的屏幕截图：
- en: '![](img/ebf71c76-3614-4e92-b3ad-8bd0d99824da.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebf71c76-3614-4e92-b3ad-8bd0d99824da.png)'
- en: Notice there is a little camera icon on the top edge of the LODn groups. You 
    can select and slide it across to preview the LOD activations based on camera
    distance. You can also configure the active range of each LOD (percentage) by
    sliding the edge of each area box.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 LODn 组的顶部边缘有一个小相机图标。你可以选择并滑动它来预览基于相机距离的 LOD 激活。你还可以通过滑动每个区域框的边缘来配置每个 LOD
    的活动范围（百分比）。
- en: 'Now, let''s try it in our scene:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的场景中尝试它：
- en: Drag the `SunglassesLOD` object into your Project Prefabs folder
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SunglassesLOD` 对象拖动到你的项目预制体文件夹
- en: Select `SunglassesReplicator` in Hierarchy and drag the `SunglassesLOD` prefab
    onto its Prefab slot
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择 `SunglassesReplicator` 并将 `SunglassesLOD` 预制体拖动到其预制体槽
- en: 'Press Play. The Profiler timeline is shown next. There''s essentially no difference
    from our most optimized version, but we get the high-poly models and transparent
    lenses when we need them:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按下播放。接下来显示的是 Profiler 时间线。基本上与我们的最优化版本没有区别，但当我们需要时，我们得到了高多边形模型和透明镜片：
- en: '![](img/a31c6277-9e26-40bc-abc2-7265d7cd3979.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a31c6277-9e26-40bc-abc2-7265d7cd3979.png)'
- en: 'Next is a screen capture of the Game view using SunglassesLOD. Closest to us
    are the high-poly glasses. The middle are low-poly, but with transparent lenses.
    Further away are low-poly and opaque versions of the model:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是使用 SunglassesLOD 的游戏视图的屏幕截图。离我们最近的是高多边形眼镜。中间的是低多边形，但带有透明镜片。更远的地方是低多边形和不透明的模型版本：
- en: '![](img/fb109066-c9c6-4c71-9670-c56a3f07bde1.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb109066-c9c6-4c71-9670-c56a3f07bde1.png)'
- en: There are a number LOD tools available in the Unity Asset Store to help manage
    levels of detail and even generate decimated meshes from your models. Unity itself
    is toying with such a tool, AutoLOD, available free on GitHub ([https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/](https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Asset Store中提供了许多LOD工具，可以帮助管理细节级别，甚至可以从你的模型中生成降级的网格。Unity本身也在尝试这样的工具，AutoLOD，它可以在GitHub上免费获得([https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/](https://blogs.unity3d.com/2018/01/12/unity-labs-autolod-experimenting-with-automatic-performance-improvements/))。
- en: Optimizing your scene with static objects
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态对象优化场景
- en: In addition to your art objects, the next step in optimization might be how
    your scene itself is organized. If we tell Unity that specific objects will not
    move in the scene, it can precompute a lot of the rendering in advance rather
    than at runtime. We do this by defining these game objects as *static*, and then
    *baking* them into specific contexts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你的艺术对象之外，优化的下一步可能就是你的场景本身是如何组织的。如果我们告诉Unity某些对象在场景中不会移动，它可以在运行前预先计算大量的渲染，而不是在运行时。我们通过将这些游戏对象定义为*静态*，然后将其*烘焙*到特定的上下文中来实现这一点。
- en: We used static objects in [Chapter 4](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml),
    *Gazed-Based Control*, when we set up a `Navmesh` for Ethan to run through. His
    walkable *nav* area was defined by the flat ground plane minus any large static
    objects that might get in his way, baked into a *navmesh*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第4章](b12be869-72d7-4dc4-a9bc-d166b9002bb1.xhtml)“基于注视的控制”中使用了静态对象，当我们为Ethan设置`Navmesh`时。他的可通行*nav*区域由平坦的地面平面减去可能挡路的任何大型静态对象定义，并烘焙到*navmesh*中。
- en: Statics can also be used to help precompute the scene rendering. Baked lightmaps
    and shadowmaps precompute lighting and shadows. Baked occlusions divide the scene
    into static volumes that can be readily culled when out of view, saving processing
    by possibly eliminating many objects from consideration at once. Let's try some
    examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 静态对象也可以用来帮助预先计算场景渲染。烘焙的光照图和阴影图预先计算光照和阴影。烘焙的遮挡将场景划分为静态体积，当它们在视图中不可见时可以轻松剔除，从而通过可能一次消除许多对象来节省处理时间。让我们尝试一些示例。
- en: Setting up the scene
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置场景
- en: 'To demonstrate the use of static game objects, we cannot use the dynamically
    instantiated sunglasses by `SunglassesReplicator`. But given we have this script,
    we''ll use it to our advantage now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示静态游戏对象的使用，我们不能使用由`SunglassesReplicator`动态实例化的太阳镜。但既然我们有这个脚本，现在我们就利用它：
- en: In Hierarchy, select `SunglassesReplicator` and drag the `Sunglasses-original`
    prefab from Project Assets onto its Prefab slot
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`SunglassesReplicator`，并将`Sunglasses-original`预制体从项目资产拖动到其预制体槽中
- en: Press Play
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放
- en: While playing, in the Hierarchy, select all the `Sunglasses-original(Clone)`
    objects (there's 1000 of them!). Right-click and select Copy
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在播放时，在层次结构中选择所有`Sunglasses-original(Clone)`对象（有1000个！）。右键单击并选择复制
- en: Stop the play mode
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止播放模式
- en: In Hierarchy, create an Empty game object and name it `SunglassesBorg`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中创建一个空的游戏对象，并将其命名为`SunglassesBorg`。
- en: Paste the cloned sunglasses as children of `SunglassesBorg`
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的太阳镜作为`SunglassesBorg`的子对象
- en: Disable the `SunglassesReplicator` object, as we no longer want to use it
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用`SunglassesReplicator`对象，因为我们不再想使用它
- en: 'If you had the need to do this more than once, you could write an *Editor Script*.
    For example, maybe you need a BorgMaker menu option in the Editor''s main menubar.
    It could prompt you with a dialog box asking for the prefab object, duplication
    counts, and offset parameters, much like our `SunglassesReplicator`. Writing scripts
    that customize and extend the Unity Editor is common practice. If you''re interested,
    see the *Manual: Extending the Editor* ([https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html))
    and the *Editor Scripting Intro* tutorial ([https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro](https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro)).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要多次这样做，你可以编写一个*编辑器脚本*。例如，你可能需要在编辑器的主菜单栏中添加一个BorgMaker菜单选项。它可以通过一个对话框提示你输入预制体对象、复制次数和偏移参数，就像我们的`SunglassesReplicator`一样。编写自定义和扩展Unity编辑器的脚本是一种常见做法。如果你感兴趣，请参阅*手册：扩展编辑器*([https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html))和*编辑器脚本入门*教程([https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro](https://unity3d.com/learn/tutorials/topics/scripting/editor-scripting-intro))。
- en: Lighting and baking
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光和烘焙
- en: The use of lights in your scene affects frame rate. You have a great deal of
    control over the number of lights, types of lights, their placement, and settings. Read
    up on it in the Unity manual, which can be found at [http://docs.unity3d.com/Manual/LightPerformance.html](http://docs.unity3d.com/Manual/LightPerformance.html).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中灯光的使用会影响帧率。你可以在灯光数量、灯光类型、位置和设置方面拥有很大的控制权。请参阅Unity手册中的相关信息，手册可以在[http://docs.unity3d.com/Manual/LightPerformance.html](http://docs.unity3d.com/Manual/LightPerformance.html)找到。
- en: Use baked lightmaps whenever possible, which precalculates the lighting effects
    into a separate image rather than at runtime. Use real-time shadows sparingly.
    When an object casts shadows, a shadow map is generated, which will be used to
    render the other objects that might receive shadows. Shadows have a high rendering
    overhead and generally require high-end GPU hardware.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用烘焙光照贴图，这会将光照效果预先计算到单独的图像中，而不是在运行时。谨慎使用实时阴影。当一个物体投射阴影时，会生成一个阴影贴图，该贴图将用于渲染可能接收到阴影的其他物体。阴影具有很高的渲染开销，通常需要高端GPU硬件。
- en: 'Let''s see the impact of using baked lightmaps on our scene:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用烘焙光照贴图对我们场景的影响：
- en: Select `SunglassesBorg` and click its Static checkbox in the upper right of Inspector
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`SunglassesBorg`并在检查器右上角点击其静态复选框
- en: When prompted, answer Yes, change children
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当提示时，回答是，更改子项
- en: If you get an error, "Mesh doesn't have UVs suitable for lightmapping," select
    the imported fbx model in your Project window, choose Generate Lightmap UVs, and Apply.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到错误，“网格没有适合光照贴图的UVs”，请在你项目的窗口中选择导入的fbx模型，选择生成光照贴图UVs，并应用。
- en: 'Depending on your Lighting settings, the lightmaps may begin generating right
    away.  Review and modify the lightmap settings as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的光照设置，光照贴图可能会立即开始生成。以下是如何审查和修改光照贴图设置：
- en: Open the Lighting window (Window | Lighting)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开光照窗口（窗口 | 光照）
- en: With Auto Generate checked, it will start generating lightmaps any time your
    scene changes
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果勾选了自动生成，那么每次场景变化时都会开始生成光照贴图
- en: Or, uncheck it and click Generate Lighting to build them manually
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，取消选中它并点击生成光照来手动构建
- en: 'Here is a screen capture of the Game window running with 1000 high-poly Sunglasses
    with transparency. We''re getting 90 FPS now, and as I move the non-static red
    cube around, it still renders with transparency and shadows present:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏窗口运行时的屏幕截图，使用了1000个高多边形透明太阳镜。我们现在得到了90 FPS，当我移动非静态的红色立方体时，它仍然以透明度和阴影的形式渲染：
- en: '![](img/75ce6640-0463-4187-b607-caa25432e429.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75ce6640-0463-4187-b607-caa25432e429.png)'
- en: In the Lighting window, there are also settings for Realtime Lighting (enabled
    by default), Baked Global Illumination (enabled by default), Lightmapper subsystem
    (Enlighten by default), and Fog effects (disabled by default), all of which affect
    the quality and performance of your scene.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在光照窗口中，还有实时光照（默认启用）、烘焙全局光照（默认启用）、光照映射子系统（默认为Enlighten）和雾效果（默认禁用）的设置，所有这些都会影响场景的质量和性能。
- en: 'Here are some more tips when dealing with lighting:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理光照时，这里有一些额外的提示：
- en: Avoid dynamic shadows, just use a "blurry blob" underneath moving things by
    using a Projector (see [https://docs.unity3d.com/Manual/class-Projector.html](https://docs.unity3d.com/Manual/class-Projector.html)).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用动态阴影，只需使用投影仪（见[https://docs.unity3d.com/Manual/class-Projector.html](https://docs.unity3d.com/Manual/class-Projector.html)）在移动物体下方创建一个“模糊的块”
- en: Check your project’s Quality Settings (Edit | Project Settings | Quality). Use
    fewer Pixel Lights (on mobile, limit to 1 or 2). Use High Resolution on Hard and
    Soft Shadows.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查你项目的质量设置（编辑 | 项目设置 | 质量）。使用较少的像素灯光（在移动设备上，限制为1或2）。在硬阴影和软阴影上使用高分辨率。
- en: You can have as many baked lights as you want. Baked lighting produces high
    quality results, whereas real-time shadows can appear blocky.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以拥有任意数量的烘焙灯光。烘焙光照产生高质量的结果，而实时阴影可能会显得块状。
- en: When baking, you can improve lightmap quality by increasing the baked resolution
    (a 40-100 pixel resolution is reasonable).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在烘焙时，可以通过增加烘焙分辨率（40-100像素的分辨率是合理的）来提高光照贴图的质量。
- en: Use light probes with baked lighting to illuminate dynamic objects.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用烘焙光照与光照探针照亮动态物体。
- en: Use reflection probes for reflective surfaces. These can be static (baked) or
    dynamic (real-time).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反射探针照亮反射表面。这些可以是静态的（烘焙）或动态的（实时）。
- en: Light probes (either real-time or baked) and the choice of shaders (and the
    shader options), can make your scene look really amazing. However, they can also
    have a significant effect on the performance. Balancing aesthetics and graphics
    performance is an art and a science.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 光探针（实时或烘焙）和着色器（以及着色器选项）的选择可以使你的场景看起来非常惊艳。然而，它们也可能对性能产生重大影响。平衡美学和图形性能是一门艺术和科学。
- en: Occlusion culling
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮挡剔除
- en: As we've seen, the more you try to reduce the number of objects that need to
    be rendered, the better. Whether or not you are using high- or low-poly models,
    Unity still needs to figure out which faces are in view. When there are a lot
    of objects, perhaps we could help Unity out by giving it some clues.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，你尝试减少需要渲染的对象数量越多，效果越好。无论你使用的是高多边形还是低多边形模型，Unity 都需要确定哪些面在视图中。当有很多对象时，我们可能可以通过提供一些线索来帮助
    Unity。
- en: Occlusion culling disables the rendering of objects when they are not seen by
    the camera because they are obscured (occluded) by other objects. (See [http://docs.unity3d.com/Manual/OcclusionCulling.html](http://docs.unity3d.com/Manual/OcclusionCulling.html).)
    It examines your scene and, using the bounding boxes (extents) of each object,
    divides the world space into a hierarchy of cubes. When Unity needs to determine
    if an object is within view, it will throw away any objects who's culling box
    is obviously outside of the view, and continue through the hierarchy.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡剔除在对象被其他对象遮挡而看不到时禁用渲染。请参阅[http://docs.unity3d.com/Manual/OcclusionCulling.html](http://docs.unity3d.com/Manual/OcclusionCulling.html)。它会检查你的场景，并使用每个对象的边界框（范围），将世界空间划分为一系列的立方体。当
    Unity 需要确定一个对象是否在视图中时，它会丢弃任何显然在视图之外的剔除框中的对象，并继续通过层次结构。
- en: 'To demonstrate, we''ll replicate a few copies of our `SunglassesBorg` and set
    up occlusion culling:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将复制几个 `SunglassesBorg` 的副本并设置遮挡剔除：
- en: In Hierarchy, select `SunglassesBorg`, right-click, then Duplicate three times
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中选择 `SunglassesBorg`，右键点击，然后重复三次复制
- en: For the first copy, set the Y-Rotation to `90`, then move it off to Position
    X = `20`
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个副本，将 Y 旋转设置为 `90`，然后将其移动到位置 X = `20`
- en: For the second copy, set Y-Rotation to `-90` and move it to Position X = `-20`
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个副本，将 Y 旋转设置为 `-90` 并将其移动到位置 X = `-20`
- en: For the third copy, set Y-Rotation to `180` and move it Position Z = `-20`
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第三个副本，将 Y 旋转设置为 `180` 并将其位置 Z = `-20`
- en: When I press Play, with so many objects, we are down to about a 50 FPS frame
    rate.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我按下播放时，由于有这么多对象，我们的帧率下降到大约50 FPS。
- en: 'Now, with the following changes, we can address our performance problem:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下更改，我们可以解决我们的性能问题：
- en: 'All four Borgs are already Static, but verify that the Static: Occluder and
    Occludee are checked (inspect the Static drop-down list)'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有四个 Borgs 已经设置为静态，但请确认静态：遮挡者和被遮挡者都被勾选了（检查静态下拉列表）
- en: Open the Occlusion Culling window (Window | Occlusion Culling)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开遮挡剔除窗口（窗口 | 遮挡剔除）
- en: Click Bake
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 烘焙
- en: Note that we could have, but didn't, distinguish Occludees versus Occluders in
    our scene. Occludees are objects that get occluded. Ocluders are ones that may
    be in front, occluding the others. Translucent objects that do not occlude should
    be marked as Occludees, but not Occluders.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们本来可以，但并没有在我们的场景中区分遮挡者和被遮挡者。被遮挡者是那些被遮挡的对象。遮挡者是那些可能位于前面，遮挡其他对象的对象。不遮挡的半透明对象应标记为被遮挡者，而不是遮挡者。
- en: 'This may take a while. Here is a top-down Scene view with the generated culling
    volumes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间。这里是一个从上到下的场景视图，显示了生成的剔除体积：
- en: '![](img/ce571836-350e-4eeb-bb9a-0fc105b9c30c.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce571836-350e-4eeb-bb9a-0fc105b9c30c.png)'
- en: Now when I press Play, the performance is back up to 90 FPS again (more or less,
    depending on where you're looking, as a user in the scene).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我按下播放，性能又回到了90 FPS（多多少少，取决于你从哪里看，作为场景中的用户）。
- en: Another way to reduce the details in a scene is by using Global Fog, which is
    based on distance. Objects further away than the fog limits will not be drawn.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少场景中细节的方法是使用基于距离的全局雾，超出雾限制的对象将不会绘制。
- en: Optimizing your code
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化你的代码
- en: Another area prone to performance problems and ripe for optimization is your
    script code. Throughout this book, we have used various coding best practices,
    without necessarily explaining why. (On the other hand, some examples in this
    book are not necessarily efficient, in favor of simplicity and explanation.) In
    [Chapter 8](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml), *Playing with Physics
    and Fire*, for example, we implemented an object pool memory manager to avoid
    repeatedly instantiating and destroying game objects that causes memory **garbage
    collection** (**GC**) issues, which in turn slows down your app.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个容易产生性能问题且适合优化的领域是你的脚本代码。在这本书中，我们使用了各种编码最佳实践，但并不一定解释了原因。（另一方面，本书中的一些示例可能并不一定高效，为了简单和解释。）例如，在[第8章](77d724d8-4ba8-4991-b4c0-35f4ea1c70b6.xhtml)“玩转物理与火焰”中，我们实现了一个对象池内存管理器，以避免反复实例化和销毁游戏对象，这会导致内存**垃圾回收**（**GC**）问题，进而减慢你的应用程序速度。
- en: In general, try to avoid code that repeats a lot of computation over and over.
    Try to pre-compute as much work as you can and store the partial results in variables.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尽量减少重复大量计算代码。尽量预先计算尽可能多的工作，并将部分结果存储在变量中。
- en: At some point, you may have to use a profiling tool to see how your code is
    performing under the hood. If the Profiler indicates that a large amount of time
    is spent in the scripts that you've written, you should consider another way to
    refactor the code so that it's more efficient. Often, this is related to memory
    management, but it could be math or physics. (See [http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html](http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html).)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能需要使用分析工具来查看你的代码在底层是如何运行的。如果分析器显示你编写的脚本中花费了大量时间，你应该考虑另一种重构代码的方法，使其更高效。这通常与内存管理有关，但也可能是数学或物理问题。（参见[http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html](http://docs.unity3d.com/Manual/MobileOptimizationPracticalScriptingOptimizations.html)。）
- en: Please follow coding best practices, but otherwise avoid going out of your way
    with premature optimization. One mistake people make is putting too much effort
    into optimizing areas of their code that don't need it, sacrificing readability
    and maintainability in the process. Use the Profiler to analyze where the performance
    bottlenecks are and focus your optimization efforts there first.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循编码最佳实践，但避免过度优化。人们常犯的一个错误是，在不需要优化的代码区域投入过多精力，在这个过程中牺牲了可读性和可维护性。使用分析器来分析性能瓶颈所在，并首先集中精力优化这些区域。
- en: Understanding the Unity life cycle
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Unity的生命周期
- en: 'Like all video game engines, when your game runs, Unity is executing a giant
    loop, repeating over and over each frame update. Unity provides many *hooks* to
    tap into events at just about every step in the game loop. Depicted below is the
    life cycle flowchart, taken from the Unity Manual page Execution Order of Event
    Functions ([https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)).
    The two event functions you are most familiar with, `Start` and `Update`, are
    highlighted with the red arrows. The green dots highlight a number of other events
    we''ll reference in this conversation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有视频游戏引擎一样，当你的游戏运行时，Unity正在执行一个巨大的循环，每帧更新时都会重复。Unity提供了许多*钩子*，可以在游戏循环的每个步骤中接入事件。下面是生命周期流程图，摘自Unity手册页面“事件函数执行顺序”（[https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html)）。你最熟悉的两个事件函数`Start`和`Update`用红色箭头突出显示。绿色圆点突出显示了我们将在这次对话中引用的许多其他事件：
- en: '![](img/ebe8a3a5-399a-4859-8d10-8ea0792291e8.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebe8a3a5-399a-4859-8d10-8ea0792291e8.png)'
- en: Starting at the top of this chart, when your game starts, each GameObject's
    component, which is derived from the `MonoBehaviour` class, will be woke with
    a call to `Awake`. Unless you need to use `Awake` or `OnEnable`, we typically
    initialize objects in `Start`. Skipping down to the Game Logic section, `Update`
    is called on each frame iteration. Note the loop line/arrows. (The physics engine
    has its own loop timing, for dealing with RigidBodies, which may be more frequent
    than the frame updates. You hook into it with `FixedUpdate`.) The `OnDestroy`
    event is called to decommission the object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表的顶部开始，当游戏开始时，每个从 `MonoBehaviour` 类派生的 GameObject 的组件将通过调用 `Awake` 来唤醒。除非你需要使用
    `Awake` 或 `OnEnable`，我们通常在 `Start` 中初始化对象。跳到游戏逻辑部分，`Update` 在每一帧迭代时被调用。注意循环线/箭头。（物理引擎有自己的循环计时，用于处理刚体，可能比帧更新更频繁。你可以通过
    `FixedUpdate` 来挂钩它。）`OnDestroy` 事件被调用以退役对象。
- en: For the current discussion, the important thing to notice is which events are
    within the game loop, and which are outside.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的讨论，重要的是要注意哪些事件在游戏循环内，哪些在游戏循环外。
- en: Writing efficient code
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写高效的代码
- en: We want to keep all of the code within the game loop (such as`FixedUpdate`, `Update`,
    and `LateUpdate`) as lean as possible. Move any initialization into `Awake`, `OnEnable`,
    or `Start`. We also want to precompute and cache any computationally expensive
    work in the initialization functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将所有代码（如 `FixedUpdate`、`Update` 和 `LateUpdate`）保持在游戏循环中尽可能精简。将任何初始化移动到 `Awake`、`OnEnable`
    或 `Start`。我们还希望在初始化函数中预先计算并缓存任何计算密集型工作。
- en: 'For example, a call to `GetComponent` is expensive. As we''ve seen in many
    scripts in this book, it is a best practice to get references to any components
    that Update will need, outside the game logic loop, in `Start`. The following
    code, used in [Chapter 7](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml), Lo*comotion
    and Comfort*, gets the `CharacterController` component in `Start`, caches it in
    a variable, and then references it in `Update`, rather than calling `GetComponent`
    every frame:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，调用 `GetComponent` 是昂贵的。正如我们在本书的许多脚本中看到的，在 `Start` 中获取 Update 需要的任何组件的引用，而不是在游戏逻辑循环中，是一种最佳实践。以下代码，用于
    [第 7 章](f2007cb4-12b9-4c13-b47e-7143866f3e50.xhtml)，《运动与舒适》，在 `Start` 中获取 `CharacterController`
    组件，将其缓存到变量中，然后在 `Update` 中引用它，而不是每帧调用 `GetComponent`：
- en: '[PRE1]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any time you declare an `Update()` function in your script (or any other event
    function), Unity will call it, even if it's empty. Therefore, you should remove
    any unused `Updates` even though they're part of the default template when you
    create a new C# `MonoBehaviour` script.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你在脚本中声明 `Update()` 函数（或任何其他事件函数）的时候，Unity 都会调用它，即使它是空的。因此，你应该删除任何未使用的 `Updates`，即使它们在创建新的
    C# `MonoBehaviour` 脚本时的默认模板中。
- en: 'Likewise, if you have code in `Update` that does not need to be called every
    frame, turn off the calculations using a state variable (and an `if` statement)
    when they are not needed, for example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你在 `Update` 中的代码不需要每帧调用，当它们不需要时，使用状态变量（以及一个 `if` 语句）关闭计算，例如：
- en: '[PRE2]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Avoiding expensive API calls
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免昂贵的 API 调用
- en: Other than moving expensive API calls out of Update into an initialization function,
    there are some APIs that should be avoided altogether if possible. Here are a
    few.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将昂贵的 API 调用从 `Update` 移动到初始化函数之外，还有一些 API 如果可能的话应该完全避免。以下是一些例子。
- en: Avoid `Object.Find()`. To obtain a reference to a game object in your scene,
    do not call `Find`. Not only is `Find` by name expensive, as it must search the
    Hierarchy tree, but it is brittle (might break) if you rename the object it is
    looking for. If you can, define a `public` variable to reference the object and
    associate it in the Editor Inspector. If you must find the object at runtime,
    use Tags or perhaps Layers to limit the search to a known fixed set of candidates.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `Object.Find()`。为了获取场景中游戏对象的引用，不要调用 `Find`。不仅 `Find` 按名称搜索是昂贵的，因为它必须搜索
    Hierarchy 树，而且如果重命名了它正在寻找的对象，它可能是不稳定的（可能会出错）。如果你可以，定义一个 `public` 变量来引用对象，并在编辑器检查器中将其关联。如果你必须在运行时找到对象，请使用标签或可能使用层来限制搜索到一个已知的固定候选集。
- en: Avoid `SendMessage()`. The legacy use of `SendMessage` is computationally expensive
    (because it makes use of runtime *reflection*). To trigger functions in another
    object, use Unity Events instead.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `SendMessage()`。`SendMessage` 的传统用法是计算密集型的（因为它使用了运行时 *反射*）。要触发另一个对象中的函数，请使用
    Unity 事件代替。
- en: Avoid fragmenting memory and garbage collection. Temporary allocations of data
    and objects may cause memory to fragment. Unity will periodically go through the
    memory heap to consolidate free blocks, but this is expensive and can cause frames
    to skip in your app.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 避免内存碎片化和垃圾回收。数据和对象的临时分配可能会导致内存碎片化。Unity会定期遍历内存堆以合并空闲块，但这很昂贵，可能会导致应用中的帧跳过。
- en: For more suggestions and a deeper discussion, see the Unity best practices guide,
    *Understanding Optimization in Unity* ([https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更多建议和深入讨论，请参阅Unity最佳实践指南，*Unity中的优化理解* ([https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html](https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity.html))。
- en: Another area of optimization is Unity Physics. In previous chapters, we briefly
    mentioned using layers for ray casting, to limit the objects Unity needs to search,
    for example, for gaze-based selection in VR. Likewise, physics collision detection
    can be limited to objects on specific layers by defining a Layer Collision Matrix.
    See the manual page on Optimizing Physics Performance ([https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html))
    and the Physics Best Practices tutorial ([https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优化领域是Unity物理。在前面的章节中，我们简要提到了使用层进行射线投射，以限制Unity需要搜索的对象，例如，在VR中进行基于注视的选择。同样，可以通过定义层碰撞矩阵将物理碰撞检测限制在特定层上的对象。请参阅优化物理性能的手册页面([https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](https://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html))和物理最佳实践教程([https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices](https://unity3d.com/learn/tutorials/topics/physics/physics-best-practices))。
- en: Optimizing the rendering
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化渲染
- en: There are a number of important performance considerations that are specific
    to how Unity does its rendering. Some of these may be common for any graphics
    engine. Some recommendations may change as newer versions of Unity emerge, the
    technology advances, and algorithms get replaced.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的性能考虑因素是针对Unity如何进行渲染的特定问题。其中一些可能对任何图形引擎都适用。一些建议可能会随着Unity新版本的推出、技术的进步和算法的替换而改变。
- en: 'There are many articles offering recommendations for which setting to use to
    optimize your VR apps, and it''s not unusual for one''s advice to contradict another''s.
    Here are some good ones:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多文章提供了关于如何设置以优化VR应用的推荐，而且一个人的建议与另一个人的建议相矛盾并不罕见。这里有一些好的建议：
- en: Use the Forward Rendering path. This is the default in Graphics Settings.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前向渲染路径。这是图形设置中的默认设置。
- en: Use `4X` MSAA (multi-sampling anti-aliasing). This is a low-cost anti-aliasing
    technique that helps remove jagged edges and shimmering effects in Quality Settings.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`4X` MSAA（多采样抗锯齿）。这是一种低成本抗锯齿技术，有助于在质量设置中去除锯齿边缘和闪烁效果。
- en: Use Single Pass Stereo Rendering. It performs efficient rendering of parallax
    perspective for each eye in a single pass in Player Settings.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单次遍历立体渲染。在玩家设置中，它可以在单次遍历中高效地为每只眼睛渲染视差透视。
- en: Enable Static Batching and Dynamic Batching in Player Settings. These are discussed
    later.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在玩家设置中启用静态批处理和动态批处理。这些将在后面讨论。
- en: Note that some rendering settings are device- or platform-specific, and found
    in the Player Settings (Edit | Project Settings | Player). Others have been abstracted
    by Unity into project Quality Settings (Edit | Project Settings | Quality). Still
    others are in the Graphics Settings (Edit | Project Settings | Graphics).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些渲染设置是设备或平台特定的，可以在玩家设置中找到（编辑 | 项目设置 | 玩家）。其他一些已经被Unity抽象为项目质量设置（编辑 | 项目设置
    | 质量）。还有一些在图形设置中（编辑 | 项目设置 | 图形）。
- en: The phrase *Player Settings* in Unity does not refer to the user (player) nor
    a first-person character (player rig). Rather it's referring to the platform executable
    that *plays* your app. More like a media player, such as a video player that plays
    mp4s, the Unity *player* runs your game after it has been compiled. The Player
    Settings configure the generated executable.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的短语*玩家设置*并不指用户（玩家）或第一人称角色（玩家装置）。相反，它指的是*播放*你应用的平台可执行文件。更像是媒体播放器，例如播放mp4的视频播放器，Unity的*玩家*在编译后运行你的游戏。玩家设置配置生成的可执行文件。
- en: Life's a batch
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活就是批量处理
- en: Perhaps, the biggest bang for the buck is a feature in Unity that groups different
    meshes into a single batch, which is then shoveled into the graphics hardware
    all at once. This is much faster than sending the meshes separately. Meshes are
    actually first compiled into an OpenGL vertex buffer object, or VBO, but that's
    a low-level detail of the rendering pipeline.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，Unity中最大的性价比特性是能够将不同的网格组合成一个批处理的功能，然后一次性将它们推送到图形硬件。这比分别发送网格要快得多。实际上，网格首先被编译成OpenGL顶点缓冲对象，或VBO，但这只是渲染管道的低级细节。
- en: Each batch takes one draw call. Reducing the number of draw calls in a scene
    is more significant than the actual number of vertices or triangles. For mobile
    VR, for example, stay around 50 (up to 100) draw calls.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每个批处理占用一个绘制调用。在场景中减少绘制调用的数量比实际的顶点数或三角形数更重要。例如，对于移动VR，保持大约50（最多100）个绘制调用。
- en: There are two types of batching, **static batching** and **dynamic batching***,* enabled
    in Player Settings.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种批处理类型，**静态批处理**和**动态批处理**，这些功能在玩家设置中启用。
- en: For static batching, simply mark the objects as static by checking off the Static checkbox
    in the Unity Inspector for each object in the scene. Marking an object static
    tells Unity that it will never move, animate, or scale. Unity will automatically
    batch together the meshes that share the same material into a single, large mesh.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态批处理，只需在Unity检查器中为场景中的每个对象勾选“静态”复选框即可标记对象为静态。将对象标记为静态告诉Unity该对象永远不会移动、动画化或缩放。Unity将自动将共享相同材质的网格批处理成一个单一的、大的网格。
- en: 'The caveat here is meshes must share the same Material settings: the same texture,
    shader, shader parameters, and the material pointer object. How can this be? They''re
    different objects! This can be done by combining multiple textures into a single
    macro-texture file or TextureAtlas and then UV-mapping as many models as will
    fit. It''s a lot like a sprite image used for 2D and web graphics. There are third-party
    tools that help you build these.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的限制是网格必须共享相同的材质设置：相同的纹理、着色器、着色器参数和材质指针对象。这怎么可能呢？它们是不同的对象！这可以通过将多个纹理组合成一个单独的宏纹理文件或TextureAtlas来实现，然后对尽可能多的模型进行UV贴图。这就像用于2D和网页图形的精灵图像。有一些第三方工具可以帮助您构建这些。
- en: A useful analytic tool for checking resources in your scene, including active
    textures, materials and meshes, is the Unity Resource Checker, found here: [https://github.com/handcircus/Unity-Resource-Checker](https://github.com/handcircus/Unity-Resource-Checker).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 检查场景中资源的实用分析工具是Unity资源检查器，您可以在以下链接找到：[https://github.com/handcircus/Unity-Resource-Checker](https://github.com/handcircus/Unity-Resource-Checker)。
- en: Dynamic batching is similar to static batching. For objects that are not marked Static,
    Unity will still try to batch them, albeit it will be a slower process since it
    needs to think about it frame by frame (the CPU cost). The shared Material requirement
    still holds, as well as other restrictions such as vertex count (less than 300
    vertices) and uniform Transform Scale rules. (See [http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html).)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 动态批处理与静态批处理类似。对于未标记为静态的对象，Unity仍然会尝试批处理它们，但这是一个较慢的过程，因为它需要逐帧考虑（CPU成本）。共享材质的要求仍然存在，以及其他限制，如顶点计数（少于300个顶点）和均匀的变换缩放规则。（参见[http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html)。）
- en: When managing textures in scripts, use `Renderer.sharedMaterial` rather than `Renderer.material` to
    avoid creating duplicate materials. Objects receiving a duplicate material will
    opt out of the batch.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中管理纹理时，使用`Renderer.sharedMaterial`而不是`Renderer.material`来避免创建重复的材料。接收重复材料的对象将退出批处理。
- en: Currently, only Mesh Renderers and Particle Systems are batched. This means
    that skinned meshes, cloth, trail renderers, and other types of rendering components
    are not.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有网格渲染器和粒子系统被批处理。这意味着蒙皮网格、布料、尾迹渲染器和其他类型的渲染组件不被批处理。
- en: Multipass pixel filling
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多通道像素填充
- en: Another concern in the rendering pipeline is sometimes referred to as the pixel
    fill-rate. If you think about it, the ultimate goal of rendering is to fill each
    pixel on the display device with the correct color value. If it has to paint any
    pixels more than once, that's more costly. For example, watch out for transparent
    particle effects, such as smoke, that touch many pixels with mostly transparent
    quads.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染管线中，有时将像素填充率作为一个关注点。如果你这么想，渲染的最终目标是在显示设备上的每个像素中填充正确的颜色值。如果必须多次绘制任何像素，那将更加昂贵。例如，要注意透明粒子效果，如烟雾，它们与许多像素接触，大部分是透明的四边形。
- en: For VR, Unity paints into a frame buffer memory that is larger than the physical
    display dimensions, which is then post-processed for ocular distortion correction
    (barrel effect) and chromatic aberration correction (color separation), before
    getting tossed onto the HMD display. In fact, there may be multiple overlay buffers
    that get composited before the post-processing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 VR，Unity 将图像绘制到一个比物理显示尺寸更大的帧缓冲区中，然后进行后处理以校正视觉畸变（桶形效应）和色差校正（颜色分离），最后才被投射到
    HMD 显示器上。实际上，在后期处理之前可能还有多个叠加缓冲区。
- en: This multipass pixel filling is how some advanced renderers work, including
    lighting and material effects such as multiple lights, dynamic shadows, and transparency
    (Transparent and Fade Render modes) - the Unity Standard Shader as well. Basically,
    all the good stuff!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多次遍历像素填充是某些高级渲染器的工作方式，包括光照和材料效果，如多个光源、动态阴影和透明度（透明和淡入渲染模式）——Unity 标准着色器也是如此。基本上，所有的好东西！
- en: VBO batches with materials that require multipass pixel filling get submitted
    multiple times, thus increasing the net number of draw calls. Depending on your
    project, you may choose to either optimize the heck out of it and avoid multipass
    pixel filling altogether, or carefully curate the scenes with an understanding
    of what should have a high performance and what should have a high fidelity.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多次遍历像素填充的材料 VBO 批次会被多次提交，从而增加了总的绘制调用次数。根据你的项目，你可能选择对其进行优化，避免完全使用多次遍历像素填充，或者仔细策划场景，理解哪些应该有高性能，哪些应该有高保真度。
- en: You can use Light Probes to inexpensively simulate dynamic lighting of your
    dynamic objects. Light probes are baked cubemaps that store information about
    direct, indirect, and even emissive light at various points in your scene. As
    a dynamic object moves, it interpolates samples of the nearby light probes to
    approximate the lighting at that specific position. This is a cheap way of simulating
    realistic lighting on dynamic objects without using expensive real-time lights.
    (See [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html).)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Light Probes 以低成本模拟动态对象的动态光照。Light Probes 是烘焙的立方体贴图，存储了关于场景中各个点的直接、间接甚至发射光的信息。当动态对象移动时，它会插值附近的
    Light Probes 的样本，以近似特定位置的光照。这是一种在不使用昂贵的实时灯光的情况下，以低成本模拟动态对象真实光照的简单方法。（参见 [http://docs.unity3d.com/Manual/LightProbes.html](http://docs.unity3d.com/Manual/LightProbes.html)。）
- en: Unity 2018 introduces a new Scriptable Render Pipeline, providing a way of configuring
    and controlling rendering from C# scripts. Unity 2018 includes alternative built-in
    pipelines for lightweight rendering (such as for mobile and VR apps), and high
    definition rendering (such as for high fidelity physically based renders), and
    there's an opportunity for the community to build and share more. Use of these
    pipelines may supersede information and recommendations made here.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2018 引入了一种新的可脚本渲染管线，提供了一种从 C# 脚本中配置和控制渲染的方法。Unity 2018 包含了用于轻量级渲染（如移动和
    VR 应用）的替代内置管线，以及用于高清晰度渲染（如高保真物理渲染）的管线，社区有机会构建和分享更多。使用这些管线可能会超越此处提供的信息和建议。
- en: VR-optimized shaders
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VR 优化的着色器
- en: Shaders are small programs that are compiled to run in the GPU. They process
    your 3D vectors and polygons (triangles), prepared by the game engine on the CPU,
    along with lighting information, texture maps, and other parameters, to generate
    pixels on the display.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是编译后在 GPU 上运行的程序。它们处理由游戏引擎在 CPU 上准备好的 3D 向量和多边形（三角形），包括光照信息、纹理贴图和其他参数，以在显示设备上生成像素。
- en: Unity comes with a rich set of shaders. The Default Surface Shader is a powerful
    and optimized one that supports textures, normal maps, height maps, occlusion
    maps, emission map, specular highlights, reflections, and more.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了一套丰富的着色器。默认表面着色器是一个强大且优化的着色器，支持纹理、法线贴图、高度贴图、遮挡贴图、发射贴图、镜面高光、反射等。
- en: Unity also includes a set of mobile optimized shaders that are popular for mobile
    (and desktop) VR development. While they may not provide as high-quality lighting
    and rendering support, they are designed to perform well on mobile devices and
    should be considered in any developer's toolbox, even on desktop VR apps.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还包含一套针对移动设备优化的着色器，这些着色器在移动（和桌面）虚拟现实开发中很受欢迎。虽然它们可能不会提供与高保真度 AAA 渲染能力相匹配的照明和渲染支持，但它们旨在在移动设备上表现良好，并且应该被任何开发者的工具箱所考虑，即使在桌面虚拟现实应用中也是如此。
- en: VR device manufacturers and developers have released their own custom shaders
    that optimize graphics processing in ways they see fit.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实设备制造商和开发者已经发布了他们自己的定制着色器，以他们认为合适的方式优化图形处理。
- en: '**Daydream Renderer** ([https://developers.google.com/vr/develop/unity/renderer](https://developers.google.com/vr/develop/unity/renderer))
    is a Unity package designed for high-quality rendering optimized for the Daydream
    platform. It supports normal maps, specular highlights with up to eight dynamic
    lights, "hero shadows" with significant performance improvements over Unity''s
    standard shaders.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**Daydream Renderer** ([https://developers.google.com/vr/develop/unity/renderer](https://developers.google.com/vr/develop/unity/renderer))
    是一个为 Daydream 平台优化的高质量渲染 Unity 包。它支持法线贴图、最多八个动态光源的镜面高光，“英雄阴影”在性能上比 Unity 的标准着色器有显著提升。'
- en: Valve (Steam) released the VR shaders used in their impressive demo project,
    *The Lab*, as a Unity Package ([https://assetstore.unity.com/packages/tools/the-lab-renderer-63141](https://assetstore.unity.com/packages/tools/the-lab-renderer-63141)).
    It supports up to 18 dynamic shadowing lights in a single pass with MSAA.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Valve (Steam) 将他们在令人印象深刻的演示项目 *The Lab* 中使用的 VR 着色器作为 Unity 包([https://assetstore.unity.com/packages/tools/the-lab-renderer-63141](https://assetstore.unity.com/packages/tools/the-lab-renderer-63141))发布。它支持在单次遍历中使用
    MSAA 支持多达 18 个动态阴影光源。
- en: The Oculus OVRPlugin, included with Unity, contains a number of Oculus-specific
    shaders, used by their prefabs and script components.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 内含的 Oculus OVRPlugin 包含了多个针对 Oculus 特定的着色器，这些着色器用于他们的预制件和脚本组件。
- en: Third-party developers also provide shaders with their tools and utilities. As
    mentioned in [Chapter 2](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml), *Content,
    Objects, and Scale*, the Google Poly Toolkit for Unity include shaders for models
    downloaded from Poly, including artwork created with TiltBrush.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方开发者也通过他们的工具和实用程序提供着色器。如[第 2 章](b9905cec-c089-4696-a683-bc7b65c4fa83.xhtml)，*内容、对象和规模*中提到的，Unity
    的 Google Poly Toolkit 包含从 Poly 下载的模型的着色器，包括使用 TiltBrush 创建的艺术作品。
- en: And you can experiment and write your own shader. In [Chapter 10](df997d92-d63c-4701-9786-da7ba54082b6.xhtml),
    *Using All 360 Degrees,* we looked at the Unity **ShaderLab** language when we
    wrote our own inward shader. Unity 2018 introduces a new **Shader Graph** tool
    for visually building shaders instead of using code. It's intended to be "simple
    enough that new users can become involved in shader creation."
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进行实验并编写自己的着色器。在[第 10 章](df997d92-d63c-4701-9786-da7ba54082b6.xhtml)，*使用所有
    360 度*，我们编写自己的内向着色器时，研究了 Unity **ShaderLab** 语言。Unity 2018 引入了一个新的 **Shader Graph**
    工具，用于可视化构建着色器而不是使用代码。它旨在“足够简单，让新用户也能参与着色器的创建”。
- en: Runtime performance and debugging
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时性能和调试
- en: 'Graphics hardware architectures continue to evolve towards performance that
    benefits rendering pipelines of virtual reality (and augmented reality). VR introduces
    requirements that weren''t so important for traditional video gaming. Latency
    and dropped frames (where rendering a frame takes longer than the refresh rate)
    took a back seat to high-fidelity AAA rendering capabilities. VR needs to render
    each frame in time and do it twice: once for each eye. Driven by the requirements
    of this emerging industry, semiconductor and hardware manufacturers are building
    new and improved devices, which will inevitably impact how content developers
    think about optimization.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图形硬件架构继续朝着有利于虚拟现实（和增强现实）渲染管道的性能方向发展。VR 引入了对于传统视频游戏不那么重要的要求。延迟和丢帧（渲染帧所需时间超过刷新率）在高质量
    AAA 渲染能力方面退居次要位置。VR 需要在时间上渲染每一帧，并且要渲染两次：一次为每只眼睛。受这个新兴行业需求驱动，半导体和硬件制造商正在构建新的和改进的设备，这不可避免地会影响内容开发者对优化的思考。
- en: That said, most likely you should develop and optimize for the lower specs that
    you want to target. If such optimizations necessitate undesirable compromises,
    consider separate versions of the game for high- versus low-end platforms. VR
    device manufacturers have started publishing minimum/recommended hardware specifications,
    which take much of the guesswork out of it. Start with the recommended Unity settings
    of your target device and adjust as needed.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，您很可能应该针对您想要的目标的低规格进行开发和优化。如果此类优化需要不希望做出的妥协，请考虑为高端和低端平台提供游戏的不同版本。VR设备制造商已经开始发布最低/推荐硬件规格，这减少了猜测。从目标设备的推荐Unity设置开始，并根据需要进行调整。
- en: For instance, for mobile VR, it is recommended that you tune for CPU-bound rather
    than GPU-bound usage. Some games will make the CPU work harder, others will impact
    the GPU. Normally, you should favor CPU over GPU. The Oculus Mobile SDK (GearVR)
    has an API that is used to throttle the CPU and GPU to control heat and battery
    drain.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于移动VR，建议您针对CPU密集型而不是GPU密集型使用进行调整。有些游戏会使CPU工作更努力，而有些游戏会影响GPU。通常，您应该优先考虑CPU而不是GPU。Oculus移动SDK（GearVR）有一个API，用于限制CPU和GPU以控制热量和电池消耗。
- en: Running in the editor is not the same as running on a mobile device. But, you
    can still use the Profiler while running in the device.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中运行与在移动设备上运行不同。但是，您仍然可以在设备上运行时使用Profiler。
- en: 'It can be useful to have a developer mode in your app that shows a heads up
    display (HUD) with current **frames per second** (**FPS**) and other vital statistics
    at runtime. To make your how FPS HUD display, add a UI Canvas to your scene with
    a child Text object. The following script updates the text string with the FPS
    value:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用中拥有一个开发者模式，显示运行时的当前**每秒帧数**（**FPS**）和其他重要统计数据，这可能很有用。要制作一个如何显示FPS HUD的教程，请将一个UI
    Canvas添加到场景中，并添加一个子Text对象。以下脚本会更新文本字符串，包含FPS值：
- en: '[PRE3]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some VR devices also provide their own tools, which we will look at next.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些VR设备也提供自己的工具，我们将在下一部分讨论。
- en: Daydream
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Daydream
- en: Daydream developer options include the `GvrInstalPreviewMain` prefab that lets
    you use your Daydream device with the Unity Editor Play mode.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Daydream开发者选项包括`GvrInstalPreviewMain`预制件，它允许您使用Daydream设备与Unity编辑器播放模式一起使用。
- en: 'The *Daydream Performance HUD* ([https://developers.google.com/vr/develop/unity/perfhud](https://developers.google.com/vr/develop/unity/perfhud))
    is built into Android. To enable it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*Daydream性能抬头显示*（[https://developers.google.com/vr/develop/unity/perfhud](https://developers.google.com/vr/develop/unity/perfhud)）已内置到Android中。要启用它：'
- en: Launch the Daydream application on your phone
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的手机上启动Daydream应用程序
- en: Tap the gear icon on the top right of the screen
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕右上角的齿轮图标
- en: Tab Build Version six times to make the Developer Options item appear
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按Tab键构建版本六次以使开发者选项项出现
- en: Select Developer Options | Enable performance heads-up display
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开发者选项 | 启用性能抬头显示
- en: Then, run a VR app and you will see the performance overlay.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行一个VR应用程序，您将看到性能叠加层。
- en: Oculus
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oculus
- en: Oculus offers a suite of performance analysis and optimization tools ([https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/)),
    which includes extensive documentation and a workflow guide for developers. Good
    stuff! It also includes an Oculus Debug Tool, Lost Frame Capture Tool, Performance
    Profiler, and a Performance Head-Up Display ([https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/)).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Oculus提供了一套性能分析和优化工具（[https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-performance/)），其中包括广泛的文档和开发者的工作流程指南。非常好！它还包括Oculus调试工具、丢失帧捕获工具、性能分析器和性能抬头显示（[https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/](https://developer.oculus.com/documentation/pcsdk/latest/concepts/dg-hud/)）。
- en: 'To activate the Performance Head-Up Display, you run it from the Oculus Debug
    Tool as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活性能抬头显示，您可以从Oculus调试工具中运行它，如下所示：
- en: Go to `Program Files\Oculus\Support\oculus-diagnostics\`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Program Files\Oculus\Support\oculus-diagnostics\`。
- en: Double-click `OculusDebugTool.exe`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`OculusDebugTool.exe`。
- en: They recommend you first turn off Asynchronous Spacewarp (ASW) to get a good
    sense of your app's performance without ASW. Find Asynchronous Spacewarp and choose
    Disabled from the select list.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们建议您首先关闭异步空间扭曲（ASW），以在没有ASW的情况下获得您应用程序性能的良好感觉。找到异步空间扭曲并从选择列表中选择禁用。
- en: 'Find Visible HUD and choose the type you''d like to see: Performance, Stereo
    Debug, Layer, or None.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找可见的HUD并选择你想要看到的类型：性能、立体调试、层或无。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Latency and low frames-per-second rates are not acceptable and can cause motion
    sickness in VR. We are bound by the capabilities and limitations of the hardware
    devices we run on and their SDKs. In this chapter, we dove into some of the more
    technical aspects of making great VR, considering four separate areas that affect
    performance: the artwork, the scene, the code, and the rendering pipeline.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟和低帧率是不可接受的，并且可能导致VR中的运动病。我们受限于我们运行的硬件设备的性能和限制以及它们的SDK。在本章中，我们深入探讨了制作优秀VR的一些更技术性的方面，考虑了影响性能的四个独立领域：艺术作品、场景、代码和渲染管线。
- en: 'We started the chapter by introducing the built-in Unity Profiler and Stats
    windows, our primary weapons in this battle. To illustrate the impacts of designing
    models and materials, we built a scene with 1000 high-poly Sunglasses with transparent
    lenses, examined the performance stats, and then tried several ways to improve
    the frame rate: decimating the models (making them low poly), removing transparency
    in the materials, and managing level of detail (LOD) in the scene. Then, we considered
    things we can do at the scene level, using static objects, baked lightmaps, and
    occlusion culling.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从介绍内置的Unity分析器和Stats窗口开始本章，这是我们这场战斗的主要武器。为了说明设计模型和材料的影响，我们构建了一个包含1000副高多边形透明镜片的场景，检查了性能统计信息，然后尝试了多种提高帧率的方法：降低模型的多边形数量（使其成为低多边形）、移除材料中的透明度，以及管理场景中的细节级别（LOD）。然后，我们考虑了在场景级别可以做的事情，使用静态对象、烘焙光照贴图和遮挡剔除。
- en: Next, we looked at basic practices for optimizing your C# scripts. A key to
    this is understanding the Unity life cycle, game loop, and expensive API functions,
    encouraging you to make the frame `Update` processing as lean as possible. Then,
    we looked at the rendering pipeline, gaining some insight into how it works and
    how to use recommended Quality, Graphics and Player settings, VR optimized shaders,
    and runtime tools to analyze and improve performance.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了优化你的C#脚本的基本实践。关键是理解Unity的生命周期、游戏循环和昂贵的API函数，鼓励你尽可能使帧`Update`处理变得瘦。然后，我们研究了渲染管线，获得了一些关于它是如何工作的以及如何使用推荐的品质、图形和玩家设置、VR优化着色器和运行时工具来分析和改进性能的见解。
- en: It should be abundantly clear by now that developing for VR has many facets
    (pun intended). You work hard to create an awesome scene with beautiful models,
    textures, and lighting. You try to provide a thrilling interactive experience
    for your visitors. At the same time, you should also be thinking about the requirements
    of your target platform, rendering performance, frames per second, latency, and
    motion sickness. It's never too early to focus on performance. It's a mistake
    to start too late. Follow recommended best practices that are easy to implement,
    while keeping your code and object hierarchy clean and maintainable. However,
    take a thoughtful, scientific approach to troubleshooting and performance tuning,
    using the Profiler and other tools to analyze your project so you can zero in
    on the root causes rather than spend time on areas that may yield little net effect.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，应该已经很清楚，为VR开发有很多方面（这不是字面意义上的）。你努力创造一个令人惊叹的场景，拥有美丽的模型、纹理和照明。你试图为你的访客提供令人兴奋的交互体验。同时，你也应该考虑你的目标平台的需求、渲染性能、每秒帧数、延迟和运动病。专注于性能永远不会太早。开始得太晚是一个错误。遵循易于实施的推荐最佳实践，同时保持你的代码和对象层次结构干净、可维护。然而，在故障排除和性能调整方面采取深思熟虑、科学的方法，使用分析器和其他工具分析你的项目，以便你能专注于根本原因，而不是花费时间在可能产生微乎其微净效果的领域。
- en: We developers rapidly become immune to all but the most obvious rendering errors,
    and as a result we are the worst people at testing our own code. It introduces
    a new and exciting variation of the coder's defense that "it works on my machine"
    - in this case, "it works for my brain." -Tom Forsyth, Oculus
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发者很快就会对所有但最明显的渲染错误产生免疫力，因此我们是最糟糕的代码测试者。它引入了程序员防御的新颖和令人兴奋的变体，“在我的机器上它工作” -
    在这种情况下，“在我的大脑中它工作。” - 托姆·福赛斯，Oculus
- en: Developing for VR is a moving target. The platform hardware, software SDKs,
    and the Unity 3D engine itself are all changing and improving rapidly. Books,
    blog posts, and YouTube videos can be readily superseded as products improve and
    new developer insights emerge. On the other hand, great strides have already been
    made to establish best practices, preferred Unity settings, and optimized device
    SDKs that address the needs of VR developers.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 开发VR应用是一个不断变化的目标。平台硬件、软件SDK以及Unity 3D引擎本身都在快速变化和改进。随着产品的改进和新开发者见解的出现，书籍、博客文章和YouTube视频可能会迅速过时。另一方面，已经取得了巨大进步，确立了最佳实践、首选的Unity设置和针对VR开发者需求的优化设备SDK。
- en: As VR goes mainstream, it is coming into its own as a new medium for expression,
    communication, education, problem solving, and storytelling. Your grandparents
    needed to learn to type and read. Your parents needed to learn PowerPoint and
    browse the web. Your children will build castles and teleport between virtual
    spaces. VR will not replace the real world and our humanity; it will enhance it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 随着VR的普及，它正作为一个新的表达、沟通、教育、解决问题和讲故事媒介崭露头角。你的祖父母需要学习打字和阅读。你的父母需要学习PowerPoint和浏览网页。你的孩子们将在虚拟空间中建造城堡和传送。VR不会取代现实世界和我们的本性；它将增强它们。
