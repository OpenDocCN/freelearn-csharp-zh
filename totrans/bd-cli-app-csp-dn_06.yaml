- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Error Handling and Logging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- en: Logging and error handling are two important concepts to consider (and implement)
    when building any application, and CLI applications are no exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è®°å½•æ—¥å¿—å’Œé”™è¯¯å¤„ç†æ˜¯åœ¨æ„å»ºä»»ä½•åº”ç”¨ç¨‹åºæ—¶éœ€è¦è€ƒè™‘ï¼ˆå¹¶å®ç°ï¼‰çš„ä¸¤ä¸ªé‡è¦æ¦‚å¿µï¼ŒCLIåº”ç”¨ç¨‹åºä¹Ÿä¸ä¾‹å¤–ã€‚
- en: While error handling ensures graceful behavior of the application in the face
    of unexpected events, logging provides crucial insights into the applicationâ€™s
    runtime behavior and facilitates troubleshooting and debugging.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶é”™è¯¯å¤„ç†ç¡®ä¿äº†åº”ç”¨ç¨‹åºåœ¨é¢å¯¹æ„å¤–äº‹ä»¶æ—¶çš„ä¼˜é›…è¡Œä¸ºï¼Œä½†æ—¥å¿—è®°å½•æä¾›äº†å¯¹åº”ç”¨ç¨‹åºè¿è¡Œæ—¶è¡Œä¸ºçš„å®è´µè§è§£ï¼Œå¹¶æœ‰åŠ©äºæ•…éšœæ’é™¤å’Œè°ƒè¯•ã€‚
- en: Thatâ€™s why, in this chapter, we will cover these two concepts, starting with
    error handling.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¶µç›–è¿™ä¸¤ä¸ªæ¦‚å¿µï¼Œä»é”™è¯¯å¤„ç†å¼€å§‹ã€‚
- en: 'Specifically, weâ€™ll cover the following main topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: å…·ä½“æ¥è¯´ï¼Œæœ¬ç« å°†æ¶µç›–ä»¥ä¸‹ä¸»è¦å†…å®¹ï¼š
- en: Error handling in CLI applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLIåº”ç”¨ç¨‹åºä¸­çš„é”™è¯¯å¤„ç†
- en: Logging in CLI applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLIåº”ç”¨ç¨‹åºä¸­çš„æ—¥å¿—è®°å½•
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŠ€æœ¯è¦æ±‚
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« çš„ä»£ç å¯ä»¥åœ¨æœ¬ä¹¦é™„å¸¦çš„GitHubä»“åº“ä¸­æ‰¾åˆ°ï¼Œ[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter06)ã€‚
- en: Handling errors in CLI applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLIåº”ç”¨ç¨‹åºä¸­çš„é”™è¯¯å¤„ç†
- en: 'Error handling may take two forms:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: é”™è¯¯å¤„ç†å¯èƒ½æœ‰ä¸¤ç§å½¢å¼ï¼š
- en: An exception is raised, due to an unexpected event (such as an invalid input
    or an inaccessible dependency)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”±äºæ„å¤–äº‹ä»¶ï¼ˆå¦‚æ— æ•ˆè¾“å…¥æˆ–ä¸å¯è®¿é—®çš„ä¾èµ–é¡¹ï¼‰è€Œå¼•å‘å¼‚å¸¸
- en: The program is terminated, and we want to prevent it crashing by allowing it
    to gracefully shut down
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¨‹åºç»ˆæ­¢ï¼Œæˆ‘ä»¬å¸Œæœ›é€šè¿‡å…è®¸å®ƒä¼˜é›…åœ°å…³é—­æ¥é˜²æ­¢å®ƒå´©æºƒ
- en: In this section, we will cover both topics. Letâ€™s start with exception handling.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¶µç›–è¿™ä¸¤ä¸ªä¸»é¢˜ã€‚è®©æˆ‘ä»¬ä»å¼‚å¸¸å¤„ç†å¼€å§‹ã€‚
- en: Handling exceptions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¤„ç†å¼‚å¸¸
- en: There is nothing special about handling exceptions in a CLI application compared
    to other kinds of applications, as it follows the same guidelines and best practices.
    Thatâ€™s why, in this section, you might find that you already know all the concepts
    that we are going to talk about, and thatâ€™s perfectly normal because youâ€™d likely
    have implemented them in other applications, whether web, APIs, or desktop applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å…¶ä»–ç±»å‹çš„åº”ç”¨ç¨‹åºç›¸æ¯”ï¼Œåœ¨CLIåº”ç”¨ç¨‹åºä¸­å¤„ç†å¼‚å¸¸å¹¶æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«ä¹‹å¤„ï¼Œå› ä¸ºå®ƒéµå¾ªç›¸åŒçš„æŒ‡å—å’Œæœ€ä½³å®è·µã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨æœ¬èŠ‚ä¸­ï¼Œæ‚¨å¯èƒ½ä¼šå‘ç°æ‚¨å·²ç»çŸ¥é“æˆ‘ä»¬å°†è¦è®¨è®ºçš„æ‰€æœ‰æ¦‚å¿µï¼Œè¿™æ˜¯å®Œå…¨æ­£å¸¸çš„ï¼Œå› ä¸ºæ‚¨å¾ˆå¯èƒ½åœ¨å…¶ä»–åº”ç”¨ç¨‹åºä¸­å®ç°äº†å®ƒä»¬ï¼Œæ— è®ºæ˜¯Webã€APIè¿˜æ˜¯æ¡Œé¢åº”ç”¨ç¨‹åºã€‚
- en: However, it is important to note that a robust error-handling strategy will
    have a significant impact on the quality, reliability, and resilience of your
    application. This is why it is worth taking the time to design a good error-handling
    strategy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ªå¥å£®çš„é”™è¯¯å¤„ç†ç­–ç•¥å°†å¯¹åº”ç”¨ç¨‹åºçš„è´¨é‡ã€å¯é æ€§å’Œå¼¹æ€§äº§ç”Ÿé‡å¤§å½±å“ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆèŠ±æ—¶é—´è®¾è®¡ä¸€ä¸ªå¥½çš„é”™è¯¯å¤„ç†ç­–ç•¥æ˜¯å€¼å¾—çš„ã€‚
- en: As you certainly know, every error-handling strategy relies on a `try-catch-finally`
    block. But not always! Not every method needs to implement a `try-catch-finally`
    block. In fact, best practices of error handling state that only the *caller*
    method (usually the top-level method) should handle exceptions, while the *callee*
    method should let the exceptions bubble up to be caught, and handled, by the *caller*
    method. This results in leaner, cleaner, and more focused methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æ‚¨æ‰€çŸ¥ï¼Œæ¯ä¸ªé”™è¯¯å¤„ç†ç­–ç•¥éƒ½ä¾èµ–äºä¸€ä¸ª`try-catch-finally`å—ã€‚ä½†å¹¶éæ€»æ˜¯å¦‚æ­¤ï¼å¹¶éæ¯ä¸ªæ–¹æ³•éƒ½éœ€è¦å®ç°`try-catch-finally`å—ã€‚å®é™…ä¸Šï¼Œé”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µè¡¨æ˜ï¼Œåªæœ‰*è°ƒç”¨è€…*æ–¹æ³•ï¼ˆé€šå¸¸æ˜¯é¡¶çº§æ–¹æ³•ï¼‰åº”è¯¥å¤„ç†å¼‚å¸¸ï¼Œè€Œ*è¢«è°ƒç”¨è€…*æ–¹æ³•åº”è¯¥è®©å¼‚å¸¸å†’æ³¡åˆ°è¢«*è°ƒç”¨è€…*æ–¹æ³•æ•è·å’Œå¤„ç†ã€‚è¿™å¯¼è‡´æ–¹æ³•æ›´åŠ ç²¾ç®€ã€å¹²å‡€å’Œä¸“æ³¨ã€‚
- en: Another best practice is to never swallow exceptions unless it is absolutely
    necessary. Why? Because swallowing exceptions hides errors, making code appear
    functional while it fails. This obscures valuable error information, allowing
    unpredictable behavior and data corruption. It complicates debugging and violates
    the principle of failing fast. In other words, it leads to silent failures that
    are hard to detect and fix, making it a poor practice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªæœ€ä½³å®è·µæ˜¯é™¤éç»å¯¹å¿…è¦ï¼Œå¦åˆ™ä¸è¦åæ²¡å¼‚å¸¸ã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºåæ²¡å¼‚å¸¸éšè—äº†é”™è¯¯ï¼Œä½¿å¾—ä»£ç çœ‹èµ·æ¥åŠŸèƒ½æ­£å¸¸ï¼Œè€Œå®é™…ä¸Šå´åœ¨å¤±è´¥ã€‚è¿™æ©ç›–äº†å®è´µçš„é”™è¯¯ä¿¡æ¯ï¼Œå…è®¸ä¸å¯é¢„æµ‹çš„è¡Œä¸ºå’Œæ•°æ®æŸåã€‚å®ƒä½¿è°ƒè¯•å¤æ‚åŒ–ï¼Œå¹¶è¿åäº†å¿«é€Ÿå¤±è´¥çš„åŸåˆ™ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå¯¼è‡´éš¾ä»¥æ£€æµ‹å’Œä¿®å¤çš„é™é»˜å¤±è´¥ï¼Œå› æ­¤æ˜¯ä¸€ç§ä¸è‰¯å®è·µã€‚
- en: The `finally` block is important, although I see it often forgotten. It is important
    to remember that this block is used to ensure that resources are freed, even if
    an exception occurs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` å—å¾ˆé‡è¦ï¼Œå°½ç®¡æˆ‘ç»å¸¸çœ‹åˆ°å®ƒè¢«é—å¿˜ã€‚é‡è¦çš„æ˜¯è¦è®°ä½ï¼Œè¿™ä¸ªå—ç”¨äºç¡®ä¿å³ä½¿åœ¨å‘ç”Ÿå¼‚å¸¸çš„æƒ…å†µä¸‹ä¹Ÿèƒ½é‡Šæ”¾èµ„æºã€‚'
- en: 'When catching exceptions, use multiple `catch` blocks, catching exceptions
    from the most specific to the most generic. This will ensure far better error
    handling than catching all exceptions as a generic exception and applying the
    same error-handling processing to all of them. An example of that is when working
    with files: we donâ€™t want to handle the situation where the file is not found
    the same way as handling the situation where the file cannot be written to, because
    of a lack of permissions. By distinguishing each of these situations, we can apply
    a specific error-handling process and, ultimately, provide the user with appropriate
    details of what happened rather than having generic processing and telling the
    user that we couldnâ€™t write to the file.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ•è·å¼‚å¸¸æ—¶ï¼Œä½¿ç”¨å¤šä¸ª `catch` å—ï¼Œä»æœ€å…·ä½“åˆ°æœ€é€šç”¨çš„å¼‚å¸¸è¿›è¡Œæ•è·ã€‚è¿™å°†ç¡®ä¿æ¯”å°†æ‰€æœ‰å¼‚å¸¸ä½œä¸ºé€šç”¨å¼‚å¸¸æ•è·å¹¶åº”ç”¨ç›¸åŒçš„é”™è¯¯å¤„ç†è¿‡ç¨‹æœ‰æ›´å¥½çš„é”™è¯¯å¤„ç†ã€‚ä¸€ä¸ªä¾‹å­æ˜¯åœ¨å¤„ç†æ–‡ä»¶æ—¶ï¼šæˆ‘ä»¬ä¸å¸Œæœ›ä»¥å¤„ç†æ–‡ä»¶æ‰¾ä¸åˆ°çš„æ–¹å¼å¤„ç†æ–‡ä»¶æ— æ³•å†™å…¥çš„æƒ…å†µï¼Œå› ä¸ºæƒé™ä¸è¶³ã€‚é€šè¿‡åŒºåˆ†è¿™äº›æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥åº”ç”¨ç‰¹å®šçš„é”™è¯¯å¤„ç†è¿‡ç¨‹ï¼Œå¹¶æœ€ç»ˆå‘ç”¨æˆ·æä¾›å‘ç”Ÿæƒ…å†µçš„é€‚å½“ç»†èŠ‚ï¼Œè€Œä¸æ˜¯è¿›è¡Œé€šç”¨çš„å¤„ç†å¹¶å‘Šè¯‰ç”¨æˆ·æˆ‘ä»¬æ— æ³•å†™å…¥æ–‡ä»¶ã€‚
- en: We can also create our own exceptions. I do this often because it helps improve
    code readability. It is easy to understand what happens when the `CreateNewUser`
    method throws an instance of the `UserAlreadyExistsException` exception, isnâ€™t
    it?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥åˆ›å»ºè‡ªå·±çš„å¼‚å¸¸ã€‚æˆ‘ç»å¸¸è¿™æ ·åšï¼Œå› ä¸ºè¿™æœ‰åŠ©äºæé«˜ä»£ç çš„å¯è¯»æ€§ã€‚å½“ `CreateNewUser` æ–¹æ³•æŠ›å‡º `UserAlreadyExistsException`
    å¼‚å¸¸çš„å®ä¾‹æ—¶ï¼Œå¾ˆå®¹æ˜“ç†è§£å‘ç”Ÿäº†ä»€ä¹ˆï¼Œä¸æ˜¯å—ï¼Ÿ
- en: 'Hereâ€™s how this custom exception would look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯è¿™ä¸ªè‡ªå®šä¹‰å¼‚å¸¸çš„å¤–è§‚ï¼š
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To catch or not to catch exceptions?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ•è·è¿˜æ˜¯ä¸è¦æ•è·å¼‚å¸¸ï¼Ÿ
- en: Thereâ€™s a movement nowadays that is going against throwing exceptions because
    of the performance cost this may have, and I totally understand this. One great
    video about this topic is the one by Nick Chapsas, titled *Donâ€™t throw exceptions
    in C#. Do this instead*, which you can find on YouTube. I encourage you to go
    and watch it and make up your own mind.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæœ‰ä¸€ç§åå¯¹æŠ›å‡ºå¼‚å¸¸çš„è¿åŠ¨ï¼Œå› ä¸ºè¿™æ ·åšå¯èƒ½ä¼šå¸¦æ¥æ€§èƒ½æˆæœ¬ï¼Œæˆ‘å®Œå…¨ç†è§£è¿™ä¸€ç‚¹ã€‚å…³äºè¿™ä¸ªä¸»é¢˜çš„ä¸€ä¸ªå¾ˆå¥½çš„è§†é¢‘æ˜¯ç”±å°¼å…‹Â·æŸ¥å¸•æ–¯ï¼ˆNick Chapsasï¼‰åˆ¶ä½œçš„ï¼Œæ ‡é¢˜ä¸º
    *Donâ€™t throw exceptions in C#. Do this instead*ï¼Œä½ å¯ä»¥åœ¨ YouTube ä¸Šæ‰¾åˆ°å®ƒã€‚æˆ‘é¼“åŠ±ä½ å»çœ‹çœ‹ï¼Œå¹¶å½¢æˆä½ è‡ªå·±çš„çœ‹æ³•ã€‚
- en: However, whether you choose to throw the exception or handle it without throwing
    it, you will likely be dealing with exceptions. Also, keep in mind that both the
    .NET framework and some other libraries that you might be using are probably throwing
    exceptions, and you will need to catch these to handle them. Because of that,
    the principles described here are still valid and worth knowing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œæ— è®ºä½ é€‰æ‹©æŠ›å‡ºå¼‚å¸¸è¿˜æ˜¯ä¸æŠ›å‡ºå¼‚å¸¸è€Œå¤„ç†å®ƒï¼Œä½ å¾ˆå¯èƒ½ä¼šå¤„ç†å¼‚å¸¸ã€‚æ­¤å¤–ï¼Œè¯·è®°ä½ï¼Œ.NET æ¡†æ¶ä»¥åŠä½ å¯èƒ½ä½¿ç”¨çš„æŸäº›å…¶ä»–åº“å¯èƒ½æ­£åœ¨æŠ›å‡ºå¼‚å¸¸ï¼Œä½ éœ€è¦æ•è·è¿™äº›å¼‚å¸¸æ¥å¤„ç†å®ƒä»¬ã€‚æ­£å› ä¸ºå¦‚æ­¤ï¼Œè¿™é‡Œæè¿°çš„åŸåˆ™ä»ç„¶æœ‰æ•ˆï¼Œå¹¶ä¸”å€¼å¾—äº†è§£ã€‚
- en: When catching exceptions, you can also filter them. This is because some exceptions
    may require a different handling mechanism depending on the reason they were thrown.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ•è·å¼‚å¸¸æ—¶ï¼Œä½ ä¹Ÿå¯ä»¥è¿‡æ»¤å®ƒä»¬ã€‚è¿™æ˜¯å› ä¸ºæŸäº›å¼‚å¸¸å¯èƒ½éœ€è¦æ ¹æ®å®ƒä»¬è¢«æŠ›å‡ºçš„åŸå› é‡‡å–ä¸åŒçš„å¤„ç†æœºåˆ¶ã€‚
- en: 'A good example of this is the `HttpResponseException` exception type, as illustrated
    here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­æ˜¯ `HttpResponseException` å¼‚å¸¸ç±»å‹ï¼Œå¦‚è¿™é‡Œæ‰€ç¤ºï¼š
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see here, we are catching the same exception (`HttpResponseException`)
    twice, but in each `catch` block, we focus on a very specific situation: in the
    first one, we are handling the situation where the resource was not found, whereas,
    in the second one, we are handling the situation where the user accessing the
    resource was not authenticated.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸¤æ¬¡æ•è·äº†ç›¸åŒçš„å¼‚å¸¸ï¼ˆ`HttpResponseException`ï¼‰ï¼Œä½†åœ¨æ¯ä¸ª `catch` å—ä¸­ï¼Œæˆ‘ä»¬å…³æ³¨çš„æ˜¯ä¸€ä¸ªéå¸¸å…·ä½“çš„æƒ…å†µï¼šåœ¨ç¬¬ä¸€ä¸ªä¸­ï¼Œæˆ‘ä»¬å¤„ç†èµ„æºæœªæ‰¾åˆ°çš„æƒ…å†µï¼Œè€Œåœ¨ç¬¬äºŒä¸ªä¸­ï¼Œæˆ‘ä»¬å¤„ç†è®¿é—®èµ„æºçš„ç”¨æˆ·æœªè®¤è¯çš„æƒ…å†µã€‚
- en: One final best practice when handling exceptions is to avoid losing the stack
    trace of the exception when throwing it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å¤„ç†å¼‚å¸¸æ—¶çš„æœ€åä¸€ä¸ªæœ€ä½³å®è·µæ˜¯é¿å…åœ¨æŠ›å‡ºå¼‚å¸¸æ—¶ä¸¢å¤±å¼‚å¸¸çš„å †æ ˆè·Ÿè¸ªã€‚
- en: 'To illustrate this principle, letâ€™s consider this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜è¿™ä¸ªåŸåˆ™ï¼Œè®©æˆ‘ä»¬è€ƒè™‘è¿™ä¸ªä¾‹å­ï¼š
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we throw the exception using the `throw ex;` statement, we lose the stack
    trace containing the details of what happened up to this point. The proper way
    to do this is to simply use `throw` to ensure the stack trace is preserved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä½¿ç”¨ `throw ex;` è¯­å¥æŠ›å‡ºå¼‚å¸¸ï¼Œæˆ‘ä»¬å°†ä¸¢å¤±åŒ…å«åˆ°ç›®å‰ä¸ºæ­¢å‘ç”Ÿè¯¦æƒ…çš„å †æ ˆè·Ÿè¸ªã€‚æ­£ç¡®çš„æ–¹æ³•æ˜¯ç®€å•åœ°ä½¿ç”¨ `throw` æ¥ç¡®ä¿å †æ ˆè·Ÿè¸ªè¢«ä¿ç•™ã€‚
- en: 'However, in some cases, we may need to catch the exception, handle it, and
    rethrow it by encapsulating it into another exception type, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦æ•è·å¼‚å¸¸ï¼Œå¤„ç†å®ƒï¼Œå¹¶é€šè¿‡å°†å…¶å°è£…åˆ°å¦ä¸€ä¸ªå¼‚å¸¸ç±»å‹ä¸­é‡æ–°æŠ›å‡ºï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this case, the stack trace is preserved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå †æ ˆè·Ÿè¸ªè¢«ä¿ç•™ã€‚
- en: Now, letâ€™s apply these principles to *Bookmarkr*, and more specifically, to
    the ability to export bookmarks out of *Bookmarkr*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†è¿™äº›åŸåˆ™åº”ç”¨åˆ° *Bookmarkr* ä¸­ï¼Œæ›´å…·ä½“åœ°è¯´ï¼Œæ˜¯åº”ç”¨åˆ°ä» *Bookmarkr* å¯¼å‡ºä¹¦ç­¾çš„èƒ½åŠ›ã€‚
- en: 'If you recall from the previous chapter, the export handler method (`OnHandleExportCommand`)
    looked like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨è¿˜è®°å¾—ä¸Šä¸€ç« çš„å†…å®¹ï¼Œå¯¼å‡ºå¤„ç†æ–¹æ³• (`OnHandleExportCommand`) çœ‹èµ·æ¥æ˜¯è¿™æ ·çš„ï¼š
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, note that the `WriteAllText` method may throw many exceptions, such
    as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œ`WriteAllText` æ–¹æ³•å¯èƒ½ä¼šæŠ›å‡ºè®¸å¤šå¼‚å¸¸ï¼Œä¾‹å¦‚ä»¥ä¸‹è¿™äº›ï¼š
- en: '`UnauthorizedAccessException` will be thrown in the case of insufficient permissions
    to access the file'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ²¡æœ‰è¶³å¤Ÿçš„æƒé™è®¿é—®æ–‡ä»¶ï¼Œå°†æŠ›å‡º `UnauthorizedAccessException`
- en: '`DirectoryNotFoundException` will be thrown if the path is invalid'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœè·¯å¾„æ— æ•ˆï¼Œå°†æŠ›å‡º `DirectoryNotFoundException`
- en: '`PathTooLongException` will be thrown if the path exceeds the system-defined
    maximum length'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœè·¯å¾„è¶…è¿‡ç³»ç»Ÿå®šä¹‰çš„æœ€å¤§é•¿åº¦ï¼Œå°†æŠ›å‡º `PathTooLongException`
- en: 'So, letâ€™s handle these exceptions. The code would look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè®©æˆ‘ä»¬å¤„ç†è¿™äº›å¼‚å¸¸ã€‚ä»£ç å°†å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we are handling the most common exceptions, and we
    are also handling the general exception in case of an unexpected exception (yes,
    exceptions are exceptional situations but are nonetheless expected to happen,
    at least most of the time).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰é¢çš„ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬æ­£åœ¨å¤„ç†æœ€å¸¸è§çš„å¼‚å¸¸ï¼Œå¹¶ä¸”åœ¨å‡ºç°æ„å¤–å¼‚å¸¸çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¹Ÿåœ¨å¤„ç†ä¸€èˆ¬å¼‚å¸¸ï¼ˆæ˜¯çš„ï¼Œå¼‚å¸¸æ˜¯ä¾‹å¤–æƒ…å†µï¼Œä½†ä»ç„¶é¢„æœŸè‡³å°‘åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ä¼šå‘ç”Ÿï¼‰ã€‚
- en: Note that we handled exceptions for both the serialization process and the file-writing
    process.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œæˆ‘ä»¬å·²ç»å¤„ç†äº†åºåˆ—åŒ–è¿‡ç¨‹å’Œæ–‡ä»¶å†™å…¥è¿‡ç¨‹ä¸­çš„å¼‚å¸¸ã€‚
- en: 'If you want to learn more about best practices for handling exceptions, I recommend
    that you visit this page: [https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æƒ³äº†è§£æ›´å¤šå…³äºå¤„ç†å¼‚å¸¸çš„æœ€ä½³å®è·µï¼Œæˆ‘å»ºè®®æ‚¨è®¿é—®è¿™ä¸ªé¡µé¢ï¼š[https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)ã€‚
- en: Handling errors doesnâ€™t necessarily mean handling exceptions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¤„ç†é”™è¯¯å¹¶ä¸ä¸€å®šæ„å‘³ç€å¤„ç†å¼‚å¸¸
- en: As surprising as it may seem, this is true, and exceptions might be avoided
    (at least most of the time) by applying defensive programming techniques.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™çœ‹èµ·æ¥å¯èƒ½ä»¤äººæƒŠè®¶ï¼Œä½†è¿™ç¡®å®æ˜¯äº‹å®ï¼Œå¹¶ä¸”é€šè¿‡åº”ç”¨é˜²å¾¡æ€§ç¼–ç¨‹æŠ€æœ¯ï¼Œå¯ä»¥é¿å…ï¼ˆè‡³å°‘åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼‰å¼‚å¸¸çš„å‘ç”Ÿã€‚
- en: By validating inputs, enforcing preconditions, and proactively identifying potential
    failure scenarios, we can significantly reduce error occurrences and enhance the
    overall resilience of our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡éªŒè¯è¾“å…¥ã€å¼ºåˆ¶æ‰§è¡Œå…ˆå†³æ¡ä»¶å’Œç§¯æè¯†åˆ«æ½œåœ¨å¤±è´¥åœºæ™¯ï¼Œæˆ‘ä»¬å¯ä»¥æ˜¾è‘—å‡å°‘é”™è¯¯å‘ç”Ÿï¼Œå¹¶å¢å¼ºæˆ‘ä»¬åº”ç”¨ç¨‹åºçš„æ•´ä½“å¼¹æ€§ã€‚
- en: 'Letâ€™s see what we can do here in terms of defensive programming:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹åœ¨é˜²å¾¡æ€§ç¼–ç¨‹æ–¹é¢æˆ‘ä»¬èƒ½åšäº›ä»€ä¹ˆï¼š
- en: '**Validate inputs**: We could ensure that the input file exists, hence avoiding
    an exception being raised if the file doesnâ€™t exist.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**éªŒè¯è¾“å…¥**ï¼šæˆ‘ä»¬å¯ä»¥ç¡®ä¿è¾“å…¥æ–‡ä»¶å­˜åœ¨ï¼Œä»è€Œé¿å…åœ¨æ–‡ä»¶ä¸å­˜åœ¨æ—¶å¼•å‘å¼‚å¸¸ã€‚'
- en: '`bookmarks` list is not null. Otherwise, `JsonSerializer` will throw a `NullReferenceException`.
    We can also ensure that the list is not empty because, if it is empty, although
    the serialization will return an empty JSON array, we may not want to write this
    to a file, especially if this means overwriting the existing file.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœ `bookmarks` åˆ—è¡¨ä¸ä¸ºç©ºã€‚å¦åˆ™ï¼Œ`JsonSerializer` å°†æŠ›å‡º `NullReferenceException`ã€‚æˆ‘ä»¬è¿˜å¯ä»¥ç¡®ä¿åˆ—è¡¨ä¸ä¸ºç©ºï¼Œå› ä¸ºå¦‚æœåˆ—è¡¨ä¸ºç©ºï¼Œå°½ç®¡åºåˆ—åŒ–å°†è¿”å›ä¸€ä¸ªç©ºçš„
    JSON æ•°ç»„ï¼Œä½†æˆ‘ä»¬å¯èƒ½ä¸æƒ³å°†æ­¤å†™å…¥æ–‡ä»¶ï¼Œå°¤å…¶æ˜¯å¦‚æœè¿™æ„å‘³ç€è¦†ç›–ç°æœ‰æ–‡ä»¶ã€‚
- en: '**Identify potential failure scenarios**: We have already done this by catching
    the most common exceptions and handling them.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¯†åˆ«æ½œåœ¨å¤±è´¥åœºæ™¯**ï¼šæˆ‘ä»¬å·²ç»é€šè¿‡æ•è·æœ€å¸¸è§çš„å¼‚å¸¸å¹¶å¤„ç†å®ƒä»¬æ¥åšåˆ°è¿™ä¸€ç‚¹ã€‚'
- en: Okay. So, at this point, we know how to handle exceptions in our CLI applications,
    and we implemented this in *Bookmarkr*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ã€‚æ‰€ä»¥ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬çŸ¥é“å¦‚ä½•åœ¨æˆ‘ä»¬çš„ CLI åº”ç”¨ç¨‹åºä¸­å¤„ç†å¼‚å¸¸ï¼Œå¹¶ä¸”æˆ‘ä»¬åœ¨ *Bookmarkr* ä¸­å®ç°äº†è¿™ä¸€ç‚¹ã€‚
- en: However, there exists one other kind of unexpected event that represents, in
    fact, normal behavior. Iâ€™m talking about **program termination**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œå­˜åœ¨å¦ä¸€ç§æ„å¤–äº‹ä»¶ï¼Œå®é™…ä¸Šå®ƒä»£è¡¨äº†æ­£å¸¸è¡Œä¸ºã€‚æˆ‘æŒ‡çš„æ˜¯**ç¨‹åºç»ˆæ­¢**ã€‚
- en: Handling program termination
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¤„ç†ç¨‹åºç»ˆæ­¢
- en: A program might be terminated at any moment by pressing a specific keyboard
    combination (usually *Ctrl* + *C* or *Ctrl* + *Break*). When this happens, the
    operating system sends a signal to the program, instructing it to immediately
    stop its execution. This signal, often referred to as an interrupt or a termination
    signal, allows the program to perform any necessary cleanup operations, such as
    closing files, releasing resources, or saving state, before it exits. If the program
    has a signal handler for this specific signal, it can execute custom code to handle
    the termination gracefully. Otherwise, the program will terminate abruptly, and
    any unsaved data or incomplete operations may be lost.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç¨‹åºå¯èƒ½åœ¨ä»»ä½•æ—¶å€™é€šè¿‡æŒ‰ç‰¹å®šçš„é”®ç›˜ç»„åˆï¼ˆé€šå¸¸æ˜¯*Ctrl* + *C*æˆ–*Ctrl* + *Break*ï¼‰æ¥ç»ˆæ­¢ã€‚å½“è¿™ç§æƒ…å†µå‘ç”Ÿæ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šå‘ç¨‹åºå‘é€ä¸€ä¸ªä¿¡å·ï¼ŒæŒ‡ç¤ºå®ƒç«‹å³åœæ­¢æ‰§è¡Œã€‚è¿™ä¸ªä¿¡å·ï¼Œé€šå¸¸è¢«ç§°ä¸ºä¸­æ–­æˆ–ç»ˆæ­¢ä¿¡å·ï¼Œå…è®¸ç¨‹åºåœ¨é€€å‡ºä¹‹å‰æ‰§è¡Œä»»ä½•å¿…è¦çš„æ¸…ç†æ“ä½œï¼Œä¾‹å¦‚å…³é—­æ–‡ä»¶ã€é‡Šæ”¾èµ„æºæˆ–ä¿å­˜çŠ¶æ€ã€‚å¦‚æœç¨‹åºæœ‰é’ˆå¯¹æ­¤ç‰¹å®šä¿¡å·çš„ä¿¡å·å¤„ç†ç¨‹åºï¼Œå®ƒå¯ä»¥æ‰§è¡Œè‡ªå®šä¹‰ä»£ç ä»¥ä¼˜é›…åœ°å¤„ç†ç»ˆæ­¢ã€‚å¦åˆ™ï¼Œç¨‹åºå°†çªç„¶ç»ˆæ­¢ï¼Œä»»ä½•æœªä¿å­˜çš„æ•°æ®æˆ–ä¸å®Œæ•´çš„æ“ä½œå¯èƒ½ä¼šä¸¢å¤±ã€‚
- en: Program termination allows one to gracefully stop a program that is taking too
    long to execute or that has become unresponsive.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç¨‹åºç»ˆæ­¢å…è®¸ä¼˜é›…åœ°åœæ­¢æ‰§è¡Œæ—¶é—´è¿‡é•¿æˆ–å·²æ— å“åº”çš„ç¨‹åºã€‚
- en: '`System.CommandLine` provides a mechanism to handle program termination and
    execute custom code, allowing our CLI application to gracefully terminate.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.CommandLine`æä¾›äº†ä¸€ä¸ªå¤„ç†ç¨‹åºç»ˆæ­¢å¹¶æ‰§è¡Œè‡ªå®šä¹‰ä»£ç çš„æœºåˆ¶ï¼Œå…è®¸æˆ‘ä»¬çš„CLIåº”ç”¨ç¨‹åºä¼˜é›…åœ°ç»ˆæ­¢ã€‚'
- en: Letâ€™s implement it to handle the situation where the user terminates the program
    while the export operation is ongoing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®ç°å®ƒæ¥å¤„ç†ç”¨æˆ·åœ¨å¯¼å‡ºæ“ä½œè¿›è¡Œä¸­ç»ˆæ­¢ç¨‹åºçš„æƒ…å†µã€‚
- en: 'In order to handle program termination, we will need to modify the delegate
    of the `SetHandler` method to retrieve the cancellation token and pass it to the
    handler method itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å¤„ç†ç¨‹åºç»ˆæ­¢ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹`SetHandler`æ–¹æ³•çš„å§”æ‰˜ä»¥æ£€ç´¢å–æ¶ˆä»¤ç‰Œå¹¶å°†å…¶ä¼ é€’ç»™å¤„ç†æ–¹æ³•æœ¬èº«ï¼š
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can modify the handler method so it handles the program termination
    (i.e., catching the `OperationCanceledException` exception):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä¿®æ”¹å¤„ç†æ–¹æ³•ï¼Œä½¿å…¶å¤„ç†ç¨‹åºç»ˆæ­¢ï¼ˆå³æ•è·`OperationCanceledException`å¼‚å¸¸ï¼‰ï¼š
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run the program now and then terminate it by pressing the *Ctrl* + *C*
    keyboard combination, we get the following console output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç°åœ¨è¿è¡Œç¨‹åºç„¶åé€šè¿‡æŒ‰*Ctrl* + *C*é”®ç›˜ç»„åˆæ¥ç»ˆæ­¢å®ƒï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä»¥ä¸‹æ§åˆ¶å°è¾“å‡ºï¼š
- en: '![Figure 6.1 â€“ Handling program termination](img/B22400_06_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾6.1 â€“ å¤„ç†ç¨‹åºç»ˆæ­¢](img/B22400_06_01.jpg)'
- en: Figure 6.1 â€“ Handling program termination
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾6.1 â€“ å¤„ç†ç¨‹åºç»ˆæ­¢
- en: One thing worth mentioning here is that we need to use the asynchronous version
    of the `WriteAllText` method (aka `WriteAllTextAsync`) in order to be able to
    pass the cancellation token we received as a parameter, and for that reason, we
    needed to declare the `OnExportCommand` method as `async`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨`WriteAllText`æ–¹æ³•çš„å¼‚æ­¥ç‰ˆæœ¬ï¼ˆå³`WriteAllTextAsync`ï¼‰ï¼Œä»¥ä¾¿èƒ½å¤Ÿä¼ é€’æˆ‘ä»¬æ¥æ”¶åˆ°çš„å–æ¶ˆä»¤ç‰Œï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å°†`OnExportCommand`æ–¹æ³•å£°æ˜ä¸º`async`ã€‚
- en: Note that by handling program termination, we can gracefully handle the situation
    where the user abruptly stops the program. This results in a graceful shutdown
    of the program and release of the used resources, hence avoiding a crash and an
    error message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œé€šè¿‡å¤„ç†ç¨‹åºç»ˆæ­¢ï¼Œæˆ‘ä»¬å¯ä»¥ä¼˜é›…åœ°å¤„ç†ç”¨æˆ·çªç„¶åœæ­¢ç¨‹åºçš„æƒ…å†µã€‚è¿™å¯¼è‡´ç¨‹åºä¼˜é›…åœ°å…³é—­å¹¶é‡Šæ”¾æ‰€ä½¿ç”¨çš„èµ„æºï¼Œä»è€Œé¿å…å´©æºƒå’Œé”™è¯¯ä¿¡æ¯ã€‚
- en: Why are we passing the cancellation token as a parameter to the handler method
    and not using it?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦å°†å–æ¶ˆä»¤ç‰Œä½œä¸ºå‚æ•°ä¼ é€’ç»™å¤„ç†æ–¹æ³•è€Œä¸ä½¿ç”¨å®ƒï¼Ÿ
- en: This is an excellent question! As you have noticed, even though we receive the
    `CancellationToken` object as a parameter to the `OnExportCommand` method, we
    seem not to be using it. Then, why did we pass it in the first place?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„é—®é¢˜ï¼æ­£å¦‚ä½ æ‰€æ³¨æ„åˆ°çš„ï¼Œå°½ç®¡æˆ‘ä»¬åœ¨`OnExportCommand`æ–¹æ³•ä¸­ä½œä¸ºå‚æ•°æ¥æ”¶äº†`CancellationToken`å¯¹è±¡ï¼Œä½†æˆ‘ä»¬ä¼¼ä¹å¹¶æ²¡æœ‰ä½¿ç”¨å®ƒã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬æœ€åˆä¸ºä»€ä¹ˆè¦ä¼ é€’å®ƒå‘¢ï¼Ÿ
- en: This is related to how cancellation tokens work in .NET. Let me explain!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸.NETä¸­å–æ¶ˆä»¤ç‰Œçš„å·¥ä½œæ–¹å¼æœ‰å…³ã€‚è®©æˆ‘æ¥è§£é‡Šä¸€ä¸‹ï¼
- en: When `OperationCanceledException` is created in response to a cancellation request,
    it typically includes information about the `CancellationToken` object that triggered
    the cancellation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å“åº”å–æ¶ˆè¯·æ±‚åˆ›å»º`OperationCanceledException`æ—¶ï¼Œå®ƒé€šå¸¸åŒ…å«æœ‰å…³è§¦å‘å–æ¶ˆçš„`CancellationToken`å¯¹è±¡çš„ä¿¡æ¯ã€‚
- en: For that matter, the `OperationCanceledException` exception class has a constructor
    that takes a `CancellationToken` object as a parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ­¤è€Œè¨€ï¼Œ`OperationCanceledException`å¼‚å¸¸ç±»æœ‰ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ª`CancellationToken`å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚
- en: When .NET framework asynchronous methods create this exception, they usually
    use this constructor and pass the cancellation token that triggered the cancellation
    request.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: å½“.NETæ¡†æ¶å¼‚æ­¥æ–¹æ³•åˆ›å»ºæ­¤å¼‚å¸¸æ—¶ï¼Œå®ƒä»¬é€šå¸¸ä½¿ç”¨æ­¤æ„é€ å‡½æ•°å¹¶ä¼ é€’è§¦å‘å–æ¶ˆè¯·æ±‚çš„å–æ¶ˆä»¤ç‰Œã€‚
- en: The `OperationCanceledException` class has a `CancellationToken` property that
    can be then accessed to get the token associated with the cancellation request.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationCanceledException`ç±»æœ‰ä¸€ä¸ª`CancellationToken`å±æ€§ï¼Œå¯ä»¥ç”¨æ¥è·å–ä¸å–æ¶ˆè¯·æ±‚å…³è”çš„ä»¤ç‰Œã€‚'
- en: In our case, we are accessing it to check whether the cancellation was requested
    by the user or not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ä¸­ï¼Œæˆ‘ä»¬è®¿é—®å®ƒæ˜¯ä¸ºäº†æ£€æŸ¥å–æ¶ˆè¯·æ±‚æ˜¯å¦ç”±ç”¨æˆ·å‘èµ·ã€‚
- en: Having established a robust framework for error handling, it is equally important
    to ensure that these errors are recorded and monitored. Thatâ€™s where logging comes
    into play!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å»ºç«‹äº†ä¸€ä¸ªå¥å£®çš„é”™è¯¯å¤„ç†æ¡†æ¶ä¹‹åï¼ŒåŒæ ·é‡è¦çš„æ˜¯ç¡®ä¿è¿™äº›é”™è¯¯è¢«è®°å½•å’Œç›‘æ§ã€‚è¿™æ­£æ˜¯æ—¥å¿—è®°å½•å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ï¼
- en: Effective logging not only helps in diagnosing and resolving issues but also
    provides valuable insights into the applicationâ€™s behavior, performance, and usage.
    In the upcoming section, we will dive into the best practices and strategies for
    implementing comprehensive logging mechanisms that complement our error-handling
    strategy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰æ•ˆçš„æ—¥å¿—è®°å½•ä¸ä»…æœ‰åŠ©äºè¯Šæ–­å’Œè§£å†³é—®é¢˜ï¼Œè¿˜æä¾›äº†å…³äºåº”ç”¨ç¨‹åºçš„è¡Œä¸ºã€æ€§èƒ½å’Œä½¿ç”¨çš„å®è´µè§è§£ã€‚åœ¨æ¥ä¸‹æ¥çš„éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥äº†è§£å®æ–½å…¨é¢æ—¥å¿—è®°å½•æœºåˆ¶çš„æœ€ä½³å®è·µå’Œç­–ç•¥ï¼Œè¿™äº›æœºåˆ¶è¡¥å……äº†æˆ‘ä»¬çš„é”™è¯¯å¤„ç†ç­–ç•¥ã€‚
- en: At this point, we have covered a lot of information on error handling. However,
    error handling works together with logging to improve application reliability
    and maintainability. So, letâ€™s shift our focus to logging, and explore how to
    capture and preserve valuable information not only about errors but also about
    other significant events that will happen during program execution.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æ¶µç›–äº†å…³äºé”™è¯¯å¤„ç†çš„å¤§é‡ä¿¡æ¯ã€‚ç„¶è€Œï¼Œé”™è¯¯å¤„ç†ä¸æ—¥å¿—è®°å½•ä¸€èµ·å·¥ä½œï¼Œä»¥æé«˜åº”ç”¨ç¨‹åºçš„å¯é æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬å°†é‡ç‚¹è½¬å‘æ—¥å¿—è®°å½•ï¼Œå¹¶æ¢è®¨å¦‚ä½•æ•è·å’Œä¿å­˜æœ‰å…³é”™è¯¯ä»¥åŠç¨‹åºæ‰§è¡ŒæœŸé—´å‘ç”Ÿçš„å…¶ä»–é‡è¦äº‹ä»¶çš„å®è´µä¿¡æ¯ã€‚
- en: Logging in CLI applications
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: åœ¨CLIåº”ç”¨ç¨‹åºä¸­è®°å½•æ—¥å¿—
- en: While error handling is more of a â€œjust-in-timeâ€ compensation mechanism when
    an unexpected event or error occurs, we may want to keep track of what happened
    so we can reproduce the issue, analyze it, understand why it happened in the first
    place, and fix it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: å½“å‘ç”Ÿæ„å¤–äº‹ä»¶æˆ–é”™è¯¯æ—¶ï¼Œé”™è¯¯å¤„ç†æ›´åƒæ˜¯â€œå³æ—¶â€çš„è¡¥å¿æœºåˆ¶ï¼Œä½†æˆ‘ä»¬å¯èƒ½å¸Œæœ›è®°å½•å‘ç”Ÿäº†ä»€ä¹ˆï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥é‡ç°é—®é¢˜ã€åˆ†æå®ƒã€äº†è§£å®ƒæœ€åˆå‘ç”Ÿçš„åŸå› ï¼Œå¹¶ä¿®å¤å®ƒã€‚
- en: By â€œkeeping track of what happened,â€ we either mean the sequence of events that
    led to that unexpected behavior or error and/or the call stack of the exception
    raised when the error occurred.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: â€œè®°å½•å‘ç”Ÿäº†ä»€ä¹ˆâ€çš„æ„æ€ï¼Œè¦ä¹ˆæ˜¯æŒ‡å¯¼è‡´æ„å¤–è¡Œä¸ºæˆ–é”™è¯¯çš„äº‹ä»¶çš„åºåˆ—ï¼Œè¦ä¹ˆæ˜¯æŒ‡é”™è¯¯å‘ç”Ÿæ—¶å¼•å‘çš„å¼‚å¸¸çš„è°ƒç”¨å †æ ˆã€‚
- en: Selecting a logging format is important. We want to find a balance between the
    amount of data we are logging (and storing) and the usage we intend to do with
    it. Logging unnecessary information will complexify log analysis, increase storage
    (and retention) costs, and may also slow down the logging process. We will also
    need to ensure that we are not logging sensitive information (such as credit card
    data), and if we do, that we are doing it in a safe manner. Some of the popular
    log formats include XML, JSON, CSV, and syslog.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: é€‰æ‹©æ—¥å¿—æ ¼å¼ä¹Ÿå¾ˆé‡è¦ã€‚æˆ‘ä»¬å¸Œæœ›åœ¨æˆ‘ä»¬è®°å½•ï¼ˆå¹¶å­˜å‚¨ï¼‰çš„æ•°æ®é‡å’Œæˆ‘ä»¬æ‰“ç®—å¦‚ä½•ä½¿ç”¨å®ƒçš„ç”¨é€”ä¹‹é—´æ‰¾åˆ°ä¸€ä¸ªå¹³è¡¡ã€‚è®°å½•ä¸å¿…è¦çš„ä¿¡æ¯å°†ä½¿æ—¥å¿—åˆ†æå¤æ‚åŒ–ï¼Œå¢åŠ å­˜å‚¨ï¼ˆå’Œä¿ç•™ï¼‰æˆæœ¬ï¼Œä¹Ÿå¯èƒ½å‡æ…¢æ—¥å¿—è®°å½•è¿‡ç¨‹ã€‚æˆ‘ä»¬è¿˜éœ€è¦ç¡®ä¿æˆ‘ä»¬æ²¡æœ‰è®°å½•æ•æ„Ÿä¿¡æ¯ï¼ˆå¦‚ä¿¡ç”¨å¡æ•°æ®ï¼‰ï¼Œå¦‚æœç¡®å®è®°å½•äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¿…é¡»ä»¥å®‰å…¨çš„æ–¹å¼è¿›è¡Œã€‚ä¸€äº›æµè¡Œçš„æ—¥å¿—æ ¼å¼åŒ…æ‹¬XMLã€JSONã€CSVå’Œsyslogã€‚
- en: Choosing the logging destination is equally important. We need to understand
    that there are no good or bad options, only appropriate and inappropriate options
    depending on our context and needs. If our intent is to analyze the logs, we may
    want to store these logs in a solution that provides log analysis mechanisms out
    of the box, so we donâ€™t need to write code for that. Examples of such solutions
    are Azure Log Analytics, Splunk, Datadog, Dynatrace, Serilog, and Elasticsearch.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: é€‰æ‹©æ—¥å¿—è®°å½•ç›®çš„åœ°åŒæ ·é‡è¦ã€‚æˆ‘ä»¬éœ€è¦ç†è§£ï¼Œæ²¡æœ‰å¥½æˆ–åçš„é€‰æ‹©ï¼Œåªæœ‰æ ¹æ®æˆ‘ä»¬çš„ç¯å¢ƒå’Œéœ€æ±‚æ˜¯å¦åˆé€‚çš„é€‰æ‹©ã€‚å¦‚æœæˆ‘ä»¬æ‰“ç®—åˆ†ææ—¥å¿—ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›å°†è¿™äº›æ—¥å¿—å­˜å‚¨åœ¨æä¾›å¼€ç®±å³ç”¨æ—¥å¿—åˆ†ææœºåˆ¶çš„è§£å†³æ–¹æ¡ˆä¸­ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸éœ€è¦ä¸ºå®ƒç¼–å†™ä»£ç ã€‚è¿™ç±»è§£å†³æ–¹æ¡ˆçš„ä¾‹å­åŒ…æ‹¬Azure
    Log Analyticsã€Splunkã€Datadogã€Dynatraceã€Serilogå’ŒElasticsearchã€‚
- en: However, note that by relying on cloud solutions (such as Azure Log Analytics),
    our application needs either to be running in the cloud or to have a constant
    connection to the internet. Sure, we can also build our application to follow
    the **occasionally connected application** (**OCA**) pattern so it keeps logs
    locally when it is running offline and sends them to Azure Log Analytics when
    it goes back online, but the idea here is that we should select a logging solution
    that is coherent with the usage pattern of our application. So, for an application
    that is intended to run locally, we will favor a logging mechanism that runs locally
    as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼Œè¯·æ³¨æ„ï¼Œä¾èµ–äºäº‘è§£å†³æ–¹æ¡ˆï¼ˆå¦‚Azure Log Analyticsï¼‰ï¼Œæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºéœ€è¦è¿è¡Œåœ¨äº‘ä¸­æˆ–è€…ä¿æŒå¯¹äº’è”ç½‘çš„æŒç»­è¿æ¥ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ„å»ºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä»¥éµå¾ª**å¶å°”è¿æ¥çš„åº”ç”¨ç¨‹åº**ï¼ˆ**OCA**ï¼‰æ¨¡å¼ï¼Œè¿™æ ·å½“å®ƒç¦»çº¿è¿è¡Œæ—¶å¯ä»¥æœ¬åœ°è®°å½•æ—¥å¿—ï¼Œå½“å®ƒé‡æ–°ä¸Šçº¿æ—¶å°†å®ƒä»¬å‘é€åˆ°Azure
    Log Analyticsï¼Œä½†è¿™é‡Œçš„æƒ³æ³•æ˜¯æˆ‘ä»¬åº”è¯¥é€‰æ‹©ä¸æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä½¿ç”¨æ¨¡å¼ä¸€è‡´çš„æ—¥å¿—è§£å†³æ–¹æ¡ˆã€‚å› æ­¤ï¼Œå¯¹äºæ‰“ç®—æœ¬åœ°è¿è¡Œçš„åº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å°†ä¼˜å…ˆè€ƒè™‘æœ¬åœ°è¿è¡Œçš„æ—¥å¿—æœºåˆ¶ã€‚
- en: 'Finally, it is also important to define the log retention period. This can
    either be enforced by the organizationâ€™s compliance rules or by the relevance
    of the logged data: do you still need to analyze data from a bug or customer behavior
    that occurred three years ago? If not, you donâ€™t need to keep this data.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå®šä¹‰æ—¥å¿—ä¿ç•™æœŸä¹Ÿå¾ˆé‡è¦ã€‚è¿™å¯ä»¥ç”±ç»„ç»‡çš„åˆè§„æ€§è§„åˆ™æˆ–è®°å½•æ•°æ®çš„å…³è”æ€§æ¥å¼ºåˆ¶æ‰§è¡Œï¼šä½ è¿˜éœ€è¦åˆ†æä¸‰å¹´å‰å‘ç”Ÿçš„é”™è¯¯æˆ–å®¢æˆ·è¡Œä¸ºçš„æ•°æ®å—ï¼Ÿå¦‚æœä¸ï¼Œä½ ä¸éœ€è¦ä¿ç•™è¿™äº›æ•°æ®ã€‚
- en: Either way, it is important to separate the logging format from the solution
    you use to store and analyze these logs.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºå“ªç§æ–¹å¼ï¼Œå°†æ—¥å¿—æ ¼å¼ä¸æ‚¨ç”¨äºå­˜å‚¨å’Œåˆ†æè¿™äº›æ—¥å¿—çš„è§£å†³æ–¹æ¡ˆåˆ†å¼€æ˜¯å¾ˆé‡è¦çš„ã€‚
- en: Since our application is intended to run locally, we will select JSON as a logging
    format and Serilog as a logging mechanism.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºæ‰“ç®—æœ¬åœ°è¿è¡Œï¼Œæˆ‘ä»¬å°†é€‰æ‹©JSONä½œä¸ºæ—¥å¿—æ ¼å¼ï¼Œå¹¶ä½¿ç”¨Serilogä½œä¸ºæ—¥å¿—æœºåˆ¶ã€‚
- en: Why JSON?
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé€‰æ‹©JSONï¼Ÿ
- en: JSON-structured logs are easy to read and can easily be parsed by machines.
    Many modern log management solutions can ingest logs in JSON format, making it
    a good choice for structured logging.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: JSONç»“æ„çš„æ—¥å¿—æ˜“äºé˜…è¯»ï¼Œå¹¶ä¸”å¯ä»¥å¾ˆå®¹æ˜“åœ°è¢«æœºå™¨è§£æã€‚è®¸å¤šç°ä»£æ—¥å¿—ç®¡ç†è§£å†³æ–¹æ¡ˆå¯ä»¥æ¥å—JSONæ ¼å¼çš„æ—¥å¿—ï¼Œä½¿å…¶æˆä¸ºç»“æ„åŒ–æ—¥å¿—çš„å¥½é€‰æ‹©ã€‚
- en: In addition, JSON is less verbose than XML, which results in files that are
    lightweight in size, which, in turn, reduces the amount of storage we need to
    store them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼ŒJSONæ¯”XMLæ›´ç®€æ´ï¼Œè¿™å¯¼è‡´æ–‡ä»¶ä½“ç§¯æ›´å°ï¼Œåè¿‡æ¥åˆå‡å°‘äº†æˆ‘ä»¬éœ€è¦å­˜å‚¨å®ƒä»¬çš„å­˜å‚¨ç©ºé—´ã€‚
- en: Why Serilog?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé€‰æ‹©Serilogï¼Ÿ
- en: Serilog is a diagnostic logging library for .NET. It is built with powerful
    structured event data in mind and supports various â€œsinks,â€ which are the destinations
    where log events can be written to. Examples of such sinks include files, the
    console, databases or log management tools (such as Elasticsearch, Application
    Insights, Datadog, and Splunk). Itâ€™s easy to set up, has a clean API, and is portable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Serilogæ˜¯ä¸€ä¸ª.NETçš„è¯Šæ–­æ—¥å¿—åº“ã€‚å®ƒæ˜¯åŸºäºå¼ºå¤§çš„ç»“æ„åŒ–äº‹ä»¶æ•°æ®æ„å»ºçš„ï¼Œå¹¶æ”¯æŒå„ç§â€œsinkâ€ï¼Œå³æ—¥å¿—äº‹ä»¶å¯ä»¥å†™å…¥çš„ç›®çš„åœ°ã€‚æ­¤ç±»sinkçš„ä¾‹å­åŒ…æ‹¬æ–‡ä»¶ã€æ§åˆ¶å°ã€æ•°æ®åº“æˆ–æ—¥å¿—ç®¡ç†å·¥å…·ï¼ˆå¦‚Elasticsearchã€Application
    Insightsã€Datadogå’ŒSplunkï¼‰ã€‚å®ƒæ˜“äºè®¾ç½®ï¼Œå…·æœ‰å¹²å‡€çš„APIï¼Œå¹¶ä¸”æ˜¯å¯ç§»æ¤çš„ã€‚
- en: One of the key features of Serilog is its ability to log structured data, which
    allows for more meaningful and queryable logs. It uses message templates, a simple
    DSL extending .NET format strings, which can capture properties along with the
    log event.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Serilogçš„ä¸€ä¸ªå…³é”®ç‰¹æ€§æ˜¯å®ƒèƒ½å¤Ÿè®°å½•ç»“æ„åŒ–æ•°æ®ï¼Œè¿™ä½¿å¾—æ—¥å¿—æ›´æœ‰æ„ä¹‰ä¸”å¯æŸ¥è¯¢ã€‚å®ƒä½¿ç”¨æ¶ˆæ¯æ¨¡æ¿ï¼Œè¿™æ˜¯ä¸€ç§ç®€å•çš„DSLï¼Œæ‰©å±•äº†.NETæ ¼å¼å­—ç¬¦ä¸²ï¼Œå¯ä»¥æ•è·å±æ€§ä»¥åŠæ—¥å¿—äº‹ä»¶ã€‚
- en: I do like the way the NuGet packages for Serilog are structured. First, there
    is the base package, which provides Serilogâ€™s functionalities in our code. Then,
    there are â€œsinkâ€ packages, one for each sink, and there are tons of them. We can
    even create our very own sink should we need it. I havenâ€™t found a usage for that
    as there are already sinks for almost everything you can think ofâ€¦
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç¡®å®å–œæ¬¢Serilogçš„NuGetåŒ…çš„ç»“æ„ã€‚é¦–å…ˆï¼Œæœ‰ä¸€ä¸ªåŸºç¡€åŒ…ï¼Œå®ƒä¸ºæˆ‘ä»¬ä»£ç ä¸­çš„Serilogæä¾›åŠŸèƒ½ã€‚ç„¶åï¼Œæœ‰â€œsinkâ€åŒ…ï¼Œæ¯ä¸ªsinkéƒ½æœ‰ä¸€ä¸ªï¼Œè€Œä¸”æœ‰å¾ˆå¤šã€‚å¦‚æœæˆ‘ä»¬éœ€è¦çš„è¯ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºæˆ‘ä»¬è‡ªå·±çš„sinkã€‚æˆ‘è¿˜æ²¡æœ‰æ‰¾åˆ°å®ƒçš„ç”¨é€”ï¼Œå› ä¸ºå‡ ä¹æ‰€æœ‰ä½ èƒ½æƒ³åˆ°çš„ä¸œè¥¿éƒ½å·²ç»æœ‰äº†sink...
- en: Oh! And, by the way, the Serilog NuGet package has been downloaded (to this
    day) more than 1.24 billion times! That should mean something, right? ğŸ˜‰
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å“¦ï¼é¡ºä¾¿è¯´ä¸€ä¸‹ï¼ŒSerilog NuGet åŒ…ï¼ˆæˆªè‡³ä»Šå¤©ï¼‰å·²ç»è¢«ä¸‹è½½äº†è¶…è¿‡12.4äº¿æ¬¡ï¼è¿™åº”è¯¥æ„å‘³ç€ä»€ä¹ˆï¼Œå¯¹å§ï¼ŸğŸ˜‰
- en: Before we add Serilog to our CLI application, we need to modify our code to
    expose the `IServiceCollection` property so we can configure our services.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å°†Serilogæ·»åŠ åˆ°æˆ‘ä»¬çš„CLIåº”ç”¨ç¨‹åºä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹æˆ‘ä»¬çš„ä»£ç ä»¥å…¬å¼€`IServiceCollection`å±æ€§ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é…ç½®æˆ‘ä»¬çš„æœåŠ¡ã€‚
- en: Accessing IServiceCollection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®¿é—®IServiceCollection
- en: 'The first step we need to take is to add the `System.CommandLine.Hosting` NuGet
    package to our project. From the Visual Studio Code terminal, we can do so by
    typing this command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦é‡‡å–çš„ç¬¬ä¸€ä¸ªæ­¥éª¤æ˜¯å°†`System.CommandLine.Hosting` NuGetåŒ…æ·»åŠ åˆ°æˆ‘ä»¬çš„é¡¹ç›®ä¸­ã€‚ä»Visual Studio Codeç»ˆç«¯ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¾“å…¥ä»¥ä¸‹å‘½ä»¤æ¥å®Œæˆï¼š
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need to update our instantiation of the `CommandLineBuilder` class
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°æˆ‘ä»¬çš„`CommandLineBuilder`ç±»å®ä¾‹åŒ–æ–¹å¼å¦‚ä¸‹ï¼š
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have access to `IServiceCollection` and can thus add services to this
    collection and configure their behavior.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥è®¿é—®`IServiceCollection`ï¼Œå› æ­¤å¯ä»¥å‘è¿™ä¸ªé›†åˆæ·»åŠ æœåŠ¡å¹¶é…ç½®å®ƒä»¬çš„è¡Œä¸ºã€‚
- en: Adding Serilog to IServiceCollection
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å°†Serilogæ·»åŠ åˆ°IServiceCollection
- en: Adding Serilog to this collection will require the `Serilog.Extensions.Hosting`
    NuGet package. So, letâ€™s add it!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å°†Serilogæ·»åŠ åˆ°è¿™ä¸ªé›†åˆéœ€è¦`Serilog.Extensions.Hosting` NuGetåŒ…ã€‚æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬æ·»åŠ å®ƒï¼
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows us to add Serilog to `IServiceCollection` by adding this line of
    code to the preceding code sample:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å…è®¸æˆ‘ä»¬é€šè¿‡åœ¨å…ˆå‰çš„ä»£ç ç¤ºä¾‹ä¸­æ·»åŠ è¿™ä¸€è¡Œä»£ç æ¥å°†Serilogæ·»åŠ åˆ°`IServiceCollection`ï¼š
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding (and configuring) the required Serilog sinks
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ·»åŠ ï¼ˆå¹¶é…ç½®ï¼‰æ‰€éœ€çš„Serilogè¾“å‡º
- en: 'As mentioned earlier, there are tons of sinks available with Serilog. However,
    since we are building a CLI application, we will only use two sinks: `Console`
    and `File`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼ŒSerilogæä¾›äº†å¤§é‡çš„è¾“å‡ºã€‚ç„¶è€Œï¼Œç”±äºæˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªå‘½ä»¤è¡Œåº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬åªä¼šä½¿ç”¨ä¸¤ä¸ªè¾“å‡ºï¼š`Console`å’Œ`File`ã€‚
- en: 'We also mentioned that Serilog is structured in such a way that each sink has
    its own NuGet package. We will then need to add the appropriate NuGet packages
    using these commands:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜æåˆ°ï¼ŒSerilogçš„ç»“æ„æ˜¯è¿™æ ·çš„ï¼Œæ¯ä¸ªè¾“å‡ºéƒ½æœ‰è‡ªå·±çš„NuGetåŒ…ã€‚ç„¶åï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨è¿™äº›å‘½ä»¤æ·»åŠ é€‚å½“çš„NuGetåŒ…ï¼š
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can start using Serilog at this point by configuring the sinks in the code.
    The updated code for the instantiation of the `CommandLineBuilder` class would
    then be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä»£ç ä¸­é…ç½®è¾“å‡ºæ¥å¼€å§‹ä½¿ç”¨Serilogã€‚ç„¶åï¼Œç”¨äºå®ä¾‹åŒ–`CommandLineBuilder`ç±»çš„æ›´æ–°ä»£ç å¦‚ä¸‹ï¼š
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Letâ€™s take a closer look at the part of the code where Serilog is configured
    (i.e., the delegate function within the `AddSerilog` method):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ›´è¯¦ç»†åœ°çœ‹çœ‹é…ç½®Serilogçš„éƒ¨åˆ†ä»£ç ï¼ˆå³åœ¨`AddSerilog`æ–¹æ³•å†…çš„å§”æ‰˜å‡½æ•°ï¼‰ï¼š
- en: This code acts on an instance of the `LoggerConfiguration` class that is used
    to configure the behavior of Serilog and its sinks.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç ä½œç”¨äºä¸€ä¸ª`LoggerConfiguration`ç±»çš„å®ä¾‹ï¼Œç”¨äºé…ç½®SerilogåŠå…¶è¾“å‡ºçš„è¡Œä¸ºã€‚
- en: We define the minimum log level as `Information`. This means that every event
    that is informational or above (such as warnings and errors) will be logged unless
    overridden by a specific sink.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æœ€å°æ—¥å¿—çº§åˆ«å®šä¹‰ä¸º`Information`ã€‚è¿™æ„å‘³ç€é™¤éè¢«ç‰¹å®šçš„è¾“å‡ºè¦†ç›–ï¼Œå¦åˆ™æ‰€æœ‰ä¿¡æ¯æ€§æˆ–æ›´é«˜çº§åˆ«çš„æ—¥å¿—ï¼ˆå¦‚è­¦å‘Šå’Œé”™è¯¯ï¼‰éƒ½ä¼šè¢«è®°å½•ã€‚
- en: We notice that the `File` sink has overridden the log level in a way that only
    errors or higher severity events (such as `Fatal`) are logged.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ³¨æ„åˆ°`File`è¾“å‡ºå·²ç»ä»¥è¿™ç§æ–¹å¼è¦†ç›–äº†æ—¥å¿—çº§åˆ«ï¼Œå³åªæœ‰é”™è¯¯æˆ–æ›´é«˜ä¸¥é‡æ€§çš„äº‹ä»¶ï¼ˆå¦‚`Fatal`ï¼‰ä¼šè¢«è®°å½•ã€‚
- en: We can also notice that the `File` sink has defined the location of the files
    (the `logs` folder) and the naming convention for the log files (`bookmark-.txt`).
    The dash symbol in the filename is not a misspelling but rather intentional! It
    is there because Serilog will append a unique identifier to that filename. Since
    we defined our rolling interval to be on a daily basis, Serilog will create a
    new log file every day. Hence, our log folder will contain files that will be
    named `bookmark-20240705.txt`, `bookmark-20240706.txt`, and so on.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¯ä»¥æ³¨æ„åˆ°ï¼Œ`File`è¾“å‡ºå·²ç»å®šä¹‰äº†æ–‡ä»¶çš„ä½ç½®ï¼ˆ`logs`æ–‡ä»¶å¤¹ï¼‰å’Œæ—¥å¿—æ–‡ä»¶çš„å‘½åçº¦å®šï¼ˆ`bookmark-.txt`ï¼‰ã€‚æ–‡ä»¶åä¸­çš„ç ´æŠ˜å·ç¬¦å·ä¸æ˜¯æ‹¼å†™é”™è¯¯ï¼Œè€Œæ˜¯æ•…æ„çš„ï¼å®ƒåœ¨é‚£é‡Œæ˜¯å› ä¸ºSerilogä¼šå‘è¯¥æ–‡ä»¶åè¿½åŠ ä¸€ä¸ªå”¯ä¸€æ ‡è¯†ç¬¦ã€‚ç”±äºæˆ‘ä»¬å®šä¹‰çš„æ»šåŠ¨é—´éš”æ˜¯æŒ‰æ—¥è¿›è¡Œçš„ï¼ŒSerilogå°†æ¯å¤©åˆ›å»ºä¸€ä¸ªæ–°çš„æ—¥å¿—æ–‡ä»¶ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„æ—¥å¿—æ–‡ä»¶å¤¹å°†åŒ…å«åä¸º`bookmark-20240705.txt`ã€`bookmark-20240706.txt`ç­‰æ–‡ä»¶ã€‚
- en: We notice that we are also explicitly telling Serilog to log to the console.
    This is because even though we added a reference to the `Serilog.Sinks.Console`
    NuGet package, we still need to tell Serilog to actually use this sink.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬æ˜ç¡®å‘Šè¯‰Serilogå°†æ—¥å¿—è®°å½•åˆ°æ§åˆ¶å°ã€‚è¿™æ˜¯å› ä¸ºå°½ç®¡æˆ‘ä»¬æ·»åŠ äº†å¯¹`Serilog.Sinks.Console` NuGetåŒ…çš„å¼•ç”¨ï¼Œæˆ‘ä»¬ä»ç„¶éœ€è¦å‘Šè¯‰Serilogå®é™…ä½¿ç”¨è¿™ä¸ªè¾“å‡ºã€‚
- en: Finally, we call the `CreateLogger` method so that all this configuration is
    taken into account.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬è°ƒç”¨`CreateLogger`æ–¹æ³•ï¼Œä»¥ä¾¿è€ƒè™‘æ‰€æœ‰è¿™äº›é…ç½®ã€‚
- en: Configuring sinks in appsettings.json
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åœ¨appsettings.jsonä¸­é…ç½®è¾“å‡º
- en: Although configuring the behavior of Serilog and its sinks directly in the code
    works perfectly fine, it is less flexible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶åœ¨ä»£ç ä¸­ç›´æ¥é…ç½®SerilogåŠå…¶è¾“å‡ºçš„è¡Œä¸ºæ˜¯å®Œå…¨å¯ä»¥çš„ï¼Œä½†è¿™ç§æ–¹å¼ä¸å¤Ÿçµæ´»ã€‚
- en: What if we want to add a new sink or update the configuration of an existing
    one? Well, you guessed it, we need to update and redeploy the code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦æ·»åŠ ä¸€ä¸ªæ–°çš„è¾“å‡ºæˆ–æ›´æ–°ç°æœ‰è¾“å‡ºçš„é…ç½®å‘¢ï¼Ÿå—¯ï¼Œä½ å·²ç»çŒœåˆ°äº†ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°å’Œé‡æ–°éƒ¨ç½²ä»£ç ã€‚
- en: Moving this configuration into a configuration file (such as `appsettings.json`)
    brings more flexibility to our application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤é…ç½®ç§»åŠ¨åˆ°é…ç½®æ–‡ä»¶ï¼ˆå¦‚`appsettings.json`ï¼‰ä½¿æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºæ›´åŠ çµæ´»ã€‚
- en: Letâ€™s see how we can do this!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹ï¼
- en: 'We first need to add the `Serilog.Settings.Configuration` NuGet package to
    our application by typing this command into the Visual Studio Code terminal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆéœ€è¦é€šè¿‡åœ¨Visual Studio Codeç»ˆç«¯ä¸­è¾“å…¥ä»¥ä¸‹å‘½ä»¤å°†`Serilog.Settings.Configuration` NuGetåŒ…æ·»åŠ åˆ°æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¸­ï¼š
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We then need to add an `appsettings.json` file to our application. This can
    easily be done by adding a new file to the project in Visual Studio Code or in
    your favorite code editor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬éœ€è¦åœ¨æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¸­æ·»åŠ ä¸€ä¸ª`appsettings.json`æ–‡ä»¶ã€‚è¿™å¯ä»¥é€šè¿‡åœ¨Visual Studio Codeæˆ–ä½ å–œæ¬¢çš„ä»£ç ç¼–è¾‘å™¨ä¸­å‘é¡¹ç›®ä¸­æ·»åŠ æ–°æ–‡ä»¶è½»æ¾å®Œæˆã€‚
- en: 'For the `appsettings.json` file to be deployed with our application, we need
    to ensure that its latest version is always copied to the output directory. This
    can be done in the `bookmarkr.csproj` file by adding this snippet just before
    the closing `</``Project>` element:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ç¡®ä¿`appsettings.json`æ–‡ä»¶ä¸æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºä¸€èµ·éƒ¨ç½²ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å…¶æœ€æ–°ç‰ˆæœ¬å§‹ç»ˆè¢«å¤åˆ¶åˆ°è¾“å‡ºç›®å½•ã€‚è¿™å¯ä»¥é€šè¿‡åœ¨`bookmarkr.csproj`æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹ç‰‡æ®µåœ¨`</Project>`å…ƒç´ ä¹‹å‰å®Œæˆï¼š
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, letâ€™s move the configuration of Serilog and its sinks from the code to
    the `appsettings.json` configuration file. The content of this file will then
    be the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬å°†SerilogåŠå…¶è¾“å‡ºçš„é…ç½®ä»ä»£ç ç§»åŠ¨åˆ°`appsettings.json`é…ç½®æ–‡ä»¶ã€‚è¯¥æ–‡ä»¶çš„ä»¥ä¸‹å†…å®¹å°†æ˜¯ï¼š
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This file is easy to read and pretty self-explanatory. It describes the sinks
    to be used and their configuration and defines the minimum log level. There is
    one thing to pay attention to here, however! Notice that we have overridden the
    minimum log level for libraries of the `Microsoft` and `System` namespaces. This
    is because these libraries tend to be chatty, which may result in a large amount
    of log data that is not very useful. By setting their minimum log level to `Warning`,
    we can ensure to only capture relevant events such as warnings or errors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ–‡ä»¶å¾ˆå®¹æ˜“é˜…è¯»ï¼Œç›¸å½“ç›´è§‚ã€‚å®ƒæè¿°äº†è¦ä½¿ç”¨çš„è¾“å‡ºåŠå…¶é…ç½®ï¼Œå¹¶å®šä¹‰äº†æœ€å°æ—¥å¿—çº§åˆ«ã€‚ç„¶è€Œï¼Œè¿™é‡Œæœ‰ä¸€ä»¶äº‹éœ€è¦æ³¨æ„ï¼è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å·²ç»è¦†ç›–äº†`Microsoft`å’Œ`System`å‘½åç©ºé—´åº“çš„æœ€å°æ—¥å¿—çº§åˆ«ã€‚è¿™æ˜¯å› ä¸ºè¿™äº›åº“å¾€å¾€å¾ˆå¥è°ˆï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å¤§é‡ä¸å¤ªæœ‰ç”¨çš„æ—¥å¿—æ•°æ®ã€‚é€šè¿‡å°†å®ƒä»¬çš„æœ€ä½æ—¥å¿—çº§åˆ«è®¾ç½®ä¸º`Warning`ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿åªæ•è·ç›¸å…³äº‹ä»¶ï¼Œå¦‚è­¦å‘Šæˆ–é”™è¯¯ã€‚
- en: The `Enrich` section is a new one, however. As the name suggests, it is there
    to enrich the log data with extra information such as the machine name and the
    thread ID. If your CLI application is intended to be executed on multiple computers
    within your organization, knowing on which machine you got the error helps you
    narrow the search area. If that application is intended to run in multiple instances
    on the same machine, the thread ID will let you know which instance logged that
    information. This can be helpful in a concurrent execution scenario.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enrich`éƒ¨åˆ†æ˜¯ä¸€ä¸ªæ–°çš„éƒ¨åˆ†ã€‚æ­£å¦‚å…¶åæ‰€ç¤ºï¼Œå®ƒåœ¨é‚£é‡Œæ˜¯ä¸ºäº†é€šè¿‡æ·»åŠ é¢å¤–çš„ä¿¡æ¯ï¼ˆå¦‚æœºå™¨åå’Œçº¿ç¨‹IDï¼‰æ¥ä¸°å¯Œæ—¥å¿—æ•°æ®ã€‚å¦‚æœä½ çš„CLIåº”ç”¨ç¨‹åºæ‰“ç®—åœ¨ä½ çš„ç»„ç»‡å†…çš„å¤šå°è®¡ç®—æœºä¸Šæ‰§è¡Œï¼ŒçŸ¥é“é”™è¯¯å‘ç”Ÿåœ¨å“ªå°æœºå™¨ä¸Šå¯ä»¥å¸®åŠ©ä½ ç¼©å°æœç´¢èŒƒå›´ã€‚å¦‚æœè¯¥åº”ç”¨ç¨‹åºæ‰“ç®—åœ¨åŒä¸€å°æœºå™¨ä¸Šçš„å¤šä¸ªå®ä¾‹ä¸­è¿è¡Œï¼Œçº¿ç¨‹IDå°†å‘Šè¯‰ä½ å“ªä¸ªå®ä¾‹è®°å½•äº†è¯¥ä¿¡æ¯ã€‚è¿™åœ¨å¹¶å‘æ‰§è¡Œåœºæ™¯ä¸­å¯èƒ½å¾ˆæœ‰å¸®åŠ©ã€‚'
- en: Are we done?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å®Œæˆäº†å—ï¼Ÿ
- en: Not exactlyâ€¦ We still need to update the code inside the `ConfigureServices`
    method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å®Œå…¨æ˜¯è¿™æ ·â€¦â€¦æˆ‘ä»¬ä»ç„¶éœ€è¦æ›´æ–°`ConfigureServices`æ–¹æ³•å†…éƒ¨çš„ä»£ç ã€‚
- en: 'Since all the configuration has been moved to the `appsettings.json` file,
    the code becomes simpler, as you can see here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºæ‰€æœ‰é…ç½®éƒ½å·²ç§»åŠ¨åˆ°`appsettings.json`æ–‡ä»¶ä¸­ï¼Œä»£ç å˜å¾—æ›´åŠ ç®€å•ï¼Œæ­£å¦‚ä½ åœ¨è¿™é‡Œå¯ä»¥çœ‹åˆ°çš„ï¼š
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configuration in code or in a file?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ä»£ç ä¸­çš„é…ç½®è¿˜æ˜¯æ–‡ä»¶ä¸­çš„é…ç½®ï¼Ÿ
- en: You may be wondering whether to configure your logger in the code or in a configuration
    file. That is a great question!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æƒ³çŸ¥é“æ˜¯å¦åº”è¯¥åœ¨ä»£ç ä¸­è¿˜æ˜¯åœ¨é…ç½®æ–‡ä»¶ä¸­é…ç½®ä½ çš„æ—¥å¿—è®°å½•å™¨ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜ï¼
- en: 'I personally rely on both: I configure my sinks in the code and the log level
    in the `appsettings.json` file. This way, I can ensure that my â€œbase sinksâ€ are
    always in use even though more may be added later.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ªäººåŒæ—¶ä¾èµ–ä¸¤è€…ï¼šæˆ‘åœ¨ä»£ç ä¸­é…ç½®æˆ‘çš„è¾“å‡ºï¼Œåœ¨`appsettings.json`æ–‡ä»¶ä¸­é…ç½®æ—¥å¿—çº§åˆ«ã€‚è¿™æ ·ï¼Œæˆ‘å¯ä»¥ç¡®ä¿å³ä½¿ä»¥åå¯èƒ½æ·»åŠ æ›´å¤šï¼Œæˆ‘çš„â€œåŸºæœ¬è¾“å‡ºâ€å§‹ç»ˆåœ¨ä½¿ç”¨ä¸­ã€‚
- en: This is a personal choice, however. You are, of course, welcome to use whatever
    works best for you.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªä¸ªäººé€‰æ‹©ï¼Œå½“ç„¶ï¼Œä½ å½“ç„¶å¯ä»¥ä½¿ç”¨å¯¹ä½ æ¥è¯´æœ€æœ‰æ•ˆçš„æ–¹æ³•ã€‚
- en: Keep in mind that configuration in the code takes precedence over configuration
    in the configuration file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·è®°ä½ï¼Œä»£ç ä¸­çš„é…ç½®ä¼˜å…ˆäºé…ç½®æ–‡ä»¶ä¸­çš„é…ç½®ã€‚
- en: Letâ€™s log something!
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®°å½•ä¸€äº›ä¸œè¥¿ï¼
- en: Finally! Up to this point, all we did was configure our logger and its sinks.
    Letâ€™s now see how this works!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯é…ç½®äº†æˆ‘ä»¬çš„æ—¥å¿—è®°å½•å™¨å’Œå…¶æ¥æ”¶å™¨ã€‚ç°åœ¨è®©æˆ‘ä»¬çœ‹çœ‹å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼
- en: Once everything is in place and well configured, logging information using Serilog
    is quite straightforward.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€åˆ‡å°±ç»ªå¹¶æ­£ç¡®é…ç½®åï¼Œä½¿ç”¨Serilogè¿›è¡Œæ—¥å¿—è®°å½•å°±ç›¸å½“ç®€å•äº†ã€‚
- en: To illustrate this, letâ€™s take an example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è¯´æ˜è¿™ä¸€ç‚¹ï¼Œè®©æˆ‘ä»¬ä¸¾ä¸€ä¸ªä¾‹å­ã€‚
- en: When we implemented the `import` command back in [*Chapter 5*](B22400_05.xhtml#_idTextAnchor068),
    if an existing bookmark was to be updated (because a bookmark with the same URL
    but a different name already existed in the list of bookmarks held by the application),
    we had no way to track the name of that conflicting bookmark before the update.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬åœ¨[*ç¬¬5ç« *](B22400_05.xhtml#_idTextAnchor068)ä¸­å®ç°`import`å‘½ä»¤æ—¶ï¼Œå¦‚æœç°æœ‰çš„ä¹¦ç­¾éœ€è¦æ›´æ–°ï¼ˆå› ä¸ºä¸€ä¸ªå…·æœ‰ç›¸åŒURLä½†ä¸åŒåç§°çš„ä¹¦ç­¾å·²ç»å­˜åœ¨äºåº”ç”¨ç¨‹åºæŒæœ‰çš„ä¹¦ç­¾åˆ—è¡¨ä¸­ï¼‰ï¼Œæˆ‘ä»¬åœ¨æ›´æ–°ä¹‹å‰æ— æ³•è¿½è¸ªé‚£ä¸ªå†²çªä¹¦ç­¾çš„åç§°ã€‚
- en: If this was a piece of critical information (for compliance reasons, for example),
    logging would come in handy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™æ˜¯ä¸€æ¡å…³é”®ä¿¡æ¯ï¼ˆä¾‹å¦‚ï¼Œå‡ºäºåˆè§„æ€§åŸå› ï¼‰ï¼Œæ—¥å¿—è®°å½•å°†éå¸¸æœ‰ç”¨ã€‚
- en: We will revisit this functionality and implement logging to keep track of the
    name before and after the update, along with its URL and the date and time of
    the update.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†é‡æ–°è®¿é—®æ­¤åŠŸèƒ½å¹¶å®ç°æ—¥å¿—è®°å½•ä»¥è·Ÿè¸ªæ›´æ–°å‰åçš„åç§°ï¼Œä»¥åŠå…¶URLå’Œæ›´æ–°çš„æ—¶é—´æ—¥æœŸã€‚
- en: 'The log format would then be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆæ—¥å¿—æ ¼å¼å°†æ˜¯ä»¥ä¸‹è¿™æ ·ï¼š
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing we will do is to create a new version of the `import` method
    for the `BookmarkService` class. This new version will take a bookmark as a parameter
    and check whether a bookmark with the same URL but with a different name already
    exists in the list of bookmarks held by the application. If this is actually the
    case, it replaces the existing bookmark with the new name and then returns an
    instance of the `BookmarkConflictModel` type, which contains the original and
    updated name and the URL. If no conflict is detected, the method simply adds the
    bookmark and returns `null`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è¦åšçš„ç¬¬ä¸€ä»¶äº‹æ˜¯ä¸º`BookmarkService`ç±»åˆ›å»º`import`æ–¹æ³•çš„æ–°ç‰ˆæœ¬ã€‚è¿™ä¸ªæ–°ç‰ˆæœ¬å°†æ¥å—ä¸€ä¸ªä¹¦ç­¾ä½œä¸ºå‚æ•°ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨å…·æœ‰ç›¸åŒURLä½†åç§°ä¸åŒçš„ä¹¦ç­¾åœ¨åº”ç”¨ç¨‹åºæŒæœ‰çš„ä¹¦ç­¾åˆ—è¡¨ä¸­ã€‚å¦‚æœç¡®å®å¦‚æ­¤ï¼Œå®ƒå°†ç”¨æ–°åç§°æ›¿æ¢ç°æœ‰çš„ä¹¦ç­¾ï¼Œç„¶åè¿”å›ä¸€ä¸ªåŒ…å«åŸå§‹å’Œæ›´æ–°åç§°ä»¥åŠURLçš„`BookmarkConflictModel`ç±»å‹çš„å®ä¾‹ã€‚å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°å†²çªï¼Œè¯¥æ–¹æ³•ç®€å•åœ°æ·»åŠ ä¹¦ç­¾å¹¶è¿”å›`null`ã€‚
- en: 'Here is the code for this method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ­¤æ–¹æ³•çš„ä»£ç ï¼š
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code of the `BookmarkConflictModel` class is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookmarkConflictModel` ç±»çš„ä»£ç å¦‚ä¸‹ï¼š'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the code of the handler method of the `Import` command is updated to
    process each bookmark read from the file such that if a conflict is detected,
    Serilog is used to keep track of it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œ`Import`å‘½ä»¤çš„å¤„ç†æ–¹æ³•ä»£ç è¢«æ›´æ–°ï¼Œä»¥å¤„ç†ä»æ–‡ä»¶ä¸­è¯»å–çš„æ¯ä¸ªä¹¦ç­¾ï¼Œä»¥ä¾¿åœ¨æ£€æµ‹åˆ°å†²çªæ—¶ä½¿ç”¨Serilogæ¥è·Ÿè¸ªå®ƒã€‚
- en: 'Here is the updated code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ›´æ–°çš„ä»£ç ï¼š
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we run this program, we can see that was logged in case of a conflict:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå¦‚æœæˆ‘ä»¬è¿è¡Œè¿™ä¸ªç¨‹åºï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨å‘ç”Ÿå†²çªçš„æƒ…å†µä¸‹ä¼šè®°å½•æ—¥å¿—ï¼š
- en: '![Figure 6.2 â€“ Logging in case of a conflict](img/B22400_06_02.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾6.2 â€“ å‘ç”Ÿå†²çªæ—¶çš„æ—¥å¿—è®°å½•](img/B22400_06_02.jpg)'
- en: Figure 6.2 â€“ Logging in case of a conflict
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾6.2 â€“ å‘ç”Ÿå†²çªæ—¶çš„æ—¥å¿—è®°å½•
- en: As we can see, this information was both logged to the console and to the file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æˆ‘ä»¬æ‰€è§ï¼Œæ­¤ä¿¡æ¯æ—¢è¢«è®°å½•åˆ°æ§åˆ¶å°ï¼Œä¹Ÿè¢«è®°å½•åˆ°æ–‡ä»¶ä¸­ã€‚
- en: We are now able to use Serilog to log important information. But what happens
    if the application is closed or is terminated? In such a situation, we can rely
    on the `CloseAndFlush` method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç°åœ¨èƒ½å¤Ÿä½¿ç”¨Serilogæ¥è®°å½•é‡è¦ä¿¡æ¯ã€‚ä½†å¦‚æœåº”ç”¨ç¨‹åºå…³é—­æˆ–ç»ˆæ­¢ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä¾èµ–`CloseAndFlush`æ–¹æ³•ã€‚
- en: Closing and gracefully disposing of Serilog
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å…³é—­å¹¶ä¼˜é›…åœ°å¤„ç†Serilog
- en: When using Serilog, the `Log.CloseAndFlush` method is called to ensure that
    all pending log event messages are flushed out to the sinks and that the logging
    system is properly shut down. This is particularly important in applications that
    have a definite end to their life cycle, such as console applications or batch
    jobs, to make sure that no log entries are missed due to the application closing
    before the logs are fully written out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨Serilogæ—¶ï¼Œä¼šè°ƒç”¨`Log.CloseAndFlush`æ–¹æ³•ä»¥ç¡®ä¿æ‰€æœ‰æŒ‚èµ·çš„æ—¥å¿—äº‹ä»¶æ¶ˆæ¯éƒ½è¢«åˆ·æ–°åˆ°æ¥æ”¶å™¨ä¸­ï¼Œå¹¶ä¸”æ—¥å¿—ç³»ç»Ÿè¢«æ­£ç¡®å…³é—­ã€‚è¿™å¯¹äºæœ‰æ˜ç¡®ç”Ÿå‘½å‘¨æœŸçš„åº”ç”¨ç¨‹åºå°¤ä¸ºé‡è¦ï¼Œä¾‹å¦‚æ§åˆ¶å°åº”ç”¨ç¨‹åºæˆ–æ‰¹å¤„ç†ä½œä¸šï¼Œä»¥ç¡®ä¿ä¸ä¼šå› ä¸ºåº”ç”¨ç¨‹åºåœ¨æ—¥å¿—å®Œå…¨å†™å…¥ä¹‹å‰å…³é—­è€Œé”™è¿‡ä»»ä½•æ—¥å¿—æ¡ç›®ã€‚
- en: 'When calling this method, two things happen:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è°ƒç”¨æ­¤æ–¹æ³•æ—¶ï¼Œä¼šå‘ç”Ÿä¸¤ä»¶äº‹ï¼š
- en: '**Close**: This sends a signal to the logging subsystem to stop accepting new
    log events. This is important to prevent any new logs from being generated after
    we have decided to shut down the logging system.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Close**ï¼šè¿™å‘æ—¥å¿—å­ç³»ç»Ÿå‘é€ä¸€ä¸ªä¿¡å·ï¼Œåœæ­¢æ¥å—æ–°çš„æ—¥å¿—äº‹ä»¶ã€‚è¿™åœ¨æˆ‘ä»¬å†³å®šå…³é—­æ—¥å¿—ç³»ç»Ÿåï¼Œé˜²æ­¢ä»»ä½•æ–°çš„æ—¥å¿—è¢«ç”Ÿæˆéå¸¸é‡è¦ã€‚'
- en: '**Flush**: This ensures that all log events that have been captured and are
    currently buffered are written out to their respective sinks. Serilog may buffer
    events in memory for efficiency, and flushing ensures that these buffered events
    are not lost.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flush**ï¼šè¿™ç¡®ä¿äº†æ‰€æœ‰å·²æ•è·å¹¶å½“å‰ç¼“å­˜çš„æ—¥å¿—äº‹ä»¶éƒ½è¢«å†™å…¥å®ƒä»¬å„è‡ªçš„æ¥æ”¶å™¨ã€‚Serilog å¯èƒ½ä¸ºäº†æ•ˆç‡è€Œåœ¨å†…å­˜ä¸­ç¼“å†²äº‹ä»¶ï¼Œè€Œåˆ·æ–°æ“ä½œç¡®ä¿è¿™äº›ç¼“å†²çš„äº‹ä»¶ä¸ä¼šä¸¢å¤±ã€‚'
- en: I recommend calling this method when exiting the application, either by shutting
    it down or by terminating it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å»ºè®®åœ¨é€€å‡ºåº”ç”¨ç¨‹åºæ—¶è°ƒç”¨æ­¤æ–¹æ³•ï¼Œæ— è®ºæ˜¯é€šè¿‡å…³é—­è¿˜æ˜¯é€šè¿‡ç»ˆæ­¢ã€‚
- en: 'For that matter, I always create a method (which I call `FreeSerilogLoggerOnShutdown`)
    that will subscribe to two events:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ­¤è€Œè¨€ï¼Œæˆ‘æ€»æ˜¯åˆ›å»ºä¸€ä¸ªæ–¹æ³•ï¼ˆæˆ‘ç§°ä¹‹ä¸º `FreeSerilogLoggerOnShutdown`ï¼‰ï¼Œè¯¥æ–¹æ³•å°†è®¢é˜…ä¸¤ä¸ªäº‹ä»¶ï¼š
- en: '`AppDomain.CurrentDomain.ProcessExit`: This event is raised when the process
    is about to exit, allowing us to perform cleanup tasks or save data.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppDomain.CurrentDomain.ProcessExit`ï¼šå½“è¿›ç¨‹å³å°†é€€å‡ºæ—¶ï¼Œæ­¤äº‹ä»¶è¢«è§¦å‘ï¼Œå…è®¸æˆ‘ä»¬æ‰§è¡Œæ¸…ç†ä»»åŠ¡æˆ–ä¿å­˜æ•°æ®ã€‚'
- en: '`Console.CancelKeyPress`: This event is triggered when the user presses *Ctrl*
    + *C* or *Ctrl* + *Break*, terminating the currently running application.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.CancelKeyPress`ï¼šå½“ç”¨æˆ·æŒ‰ä¸‹ *Ctrl* + *C* æˆ– *Ctrl* + *Break* æ—¶ï¼Œæ­¤äº‹ä»¶è¢«è§¦å‘ï¼Œç»ˆæ­¢å½“å‰æ­£åœ¨è¿è¡Œçš„åº”ç”¨ç¨‹åºã€‚'
- en: In both cases, these subscription calls the same delegate method (which I call
    `ExecuteShutdownTasks`) that will call the `CloseAndFlush` method from Serilog.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œè¿™äº›è®¢é˜…è°ƒç”¨ç›¸åŒçš„å§”æ‰˜æ–¹æ³•ï¼ˆæˆ‘ç§°ä¹‹ä¸º `ExecuteShutdownTasks`ï¼‰ï¼Œè¯¥æ–¹æ³•å°†è°ƒç”¨ Serilog çš„ `CloseAndFlush`
    æ–¹æ³•ã€‚
- en: 'Here is the code for these two methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹é¢æ˜¯è¿™ä¸¤ä¸ªæ–¹æ³•çš„ä»£ç ï¼š
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The call to the `FreeSerilogLoggerOnShutDown` method is the first instruction
    of the `Main` method of the `Program` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: è°ƒç”¨ `FreeSerilogLoggerOnShutDown` æ–¹æ³•çš„ä»£ç æ˜¯ `Program` ç±»çš„ `Main` æ–¹æ³•çš„ç¬¬ä¸€æ¡æŒ‡ä»¤ã€‚
- en: While this is not a book about Serilog (which, in my opinion, deserves a book
    on its own), in this section, we covered the basics, which is enough for the purpose
    of the book. If you want to find more information about Serilog, visit [https://serilog.net/](https://serilog.net/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ä¸æ˜¯ä¸€æœ¬å…³äº Serilog çš„ä¹¦ï¼ˆåœ¨æˆ‘çœ‹æ¥ï¼ŒSerilog å€¼å¾—ä¸€æœ¬å•ç‹¬çš„ä¹¦ï¼‰ï¼Œä½†åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬æ¶µç›–äº†åŸºç¡€çŸ¥è¯†ï¼Œè¿™å¯¹äºæœ¬ä¹¦çš„ç›®çš„å·²ç»è¶³å¤Ÿã€‚å¦‚æœä½ æƒ³äº†è§£æ›´å¤šå…³äº
    Serilog çš„ä¿¡æ¯ï¼Œè¯·è®¿é—® [https://serilog.net/](https://serilog.net/)ã€‚
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‘˜è¦
- en: In this chapter, we improved our CLI application, *Bookmarkr*, by adding error
    handling and logging into the application.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æ·»åŠ é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•åˆ°åº”ç”¨ç¨‹åºä¸­ï¼Œæ”¹è¿›äº†æˆ‘ä»¬çš„ CLI åº”ç”¨ç¨‹åº *Bookmarkr*ã€‚
- en: With error handling, we implemented graceful degradation into our CLI application.
    This means that our application is now more fault-tolerant and will not crash
    abruptly should an unexpected event occur.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡é”™è¯¯å¤„ç†ï¼Œæˆ‘ä»¬åœ¨ CLI åº”ç”¨ç¨‹åºä¸­å®ç°äº†ä¼˜é›…é™çº§ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºç°åœ¨å…·æœ‰æ›´é«˜çš„å®¹é”™æ€§ï¼Œåœ¨å‘ç”Ÿæ„å¤–äº‹ä»¶æ—¶ä¸ä¼šçªç„¶å´©æºƒã€‚
- en: With logging, we can record application activities, errors, and exceptions so
    that they can be analyzed at a later point in time in order to understand the
    sequence of events that led up to that error or unexpected behavior. But logging
    also enables the monitoring of application health and performance over time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡æ—¥å¿—è®°å½•ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•åº”ç”¨ç¨‹åºçš„æ´»åŠ¨ã€é”™è¯¯å’Œå¼‚å¸¸ï¼Œä»¥ä¾¿åœ¨ç¨åçš„æ—¶é—´ç‚¹åˆ†æï¼Œä»¥äº†è§£å¯¼è‡´è¯¥é”™è¯¯æˆ–æ„å¤–è¡Œä¸ºçš„äº‹ä»¶çš„é¡ºåºã€‚ä½†æ—¥å¿—è®°å½•ä¹Ÿä½¿å¾—å¯ä»¥ç›‘æ§åº”ç”¨ç¨‹åºçš„å¥åº·çŠ¶å†µå’Œæ€§èƒ½éšæ—¶é—´çš„å˜åŒ–ã€‚
- en: In the upcoming chapter, we will see how to make our CLI application more interactive
    and user-friendly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å³å°†åˆ°æ¥çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°å¦‚ä½•ä½¿æˆ‘ä»¬çš„ CLI åº”ç”¨ç¨‹åºæ›´åŠ äº¤äº’å¼å’Œç”¨æˆ·å‹å¥½ã€‚
- en: Your turn!
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è½®åˆ°ä½ äº†ï¼
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: æŒ‰ç…§æä¾›çš„ä»£ç è¿›è¡Œæ“ä½œæ˜¯å­¦ä¹ å®è·µçš„å¥½æ–¹æ³•ã€‚
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the *Bookmarkr* application by adding the following features.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªæ›´å¥½çš„æ–¹æ³•æ˜¯æŒ‘æˆ˜è‡ªå·±å®Œæˆä»»åŠ¡ã€‚å› æ­¤ï¼Œæˆ‘æŒ‘æˆ˜ä½ é€šè¿‡æ·»åŠ ä»¥ä¸‹åŠŸèƒ½æ¥æ”¹è¿› *Bookmarkr* åº”ç”¨ç¨‹åºã€‚
- en: 'Task #1 â€“ Handling errors for the Import command'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'ä»»åŠ¡ #1 â€“ å¤„ç†å¯¼å…¥å‘½ä»¤çš„é”™è¯¯'
- en: If the input file cannot be accessed, or if its content cannot be deserialized,
    it is likely that the code will throw exceptions. Your mission is to identify
    what exceptions are likely to be thrown and handle them accordingly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ— æ³•è®¿é—®è¾“å…¥æ–‡ä»¶ï¼Œæˆ–è€…å…¶å†…å®¹æ— æ³•ååºåˆ—åŒ–ï¼Œä»£ç å¯èƒ½ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ä½ çš„ä»»åŠ¡æ˜¯è¯†åˆ«å¯èƒ½æŠ›å‡ºçš„å¼‚å¸¸ï¼Œå¹¶ç›¸åº”åœ°å¤„ç†å®ƒä»¬ã€‚
- en: 'Task #2 â€“ Logging errors to a file'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'ä»»åŠ¡ #2 â€“ å°†é”™è¯¯è®°å½•åˆ°æ–‡ä»¶'
- en: In the previous task, the goal was to handle the exceptions. However, it might
    be useful to log the details of these exceptions to a file so we can review them
    later and use this information to improve the robustness of our application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸Šä¸€ä¸ªä»»åŠ¡ä¸­ï¼Œç›®æ ‡æ˜¯å¤„ç†å¼‚å¸¸ã€‚ç„¶è€Œï¼Œå°†è¿™äº›å¼‚å¸¸çš„è¯¦ç»†ä¿¡æ¯è®°å½•åˆ°æ–‡ä»¶ä¸­å¯èƒ½å¾ˆæœ‰ç”¨ï¼Œè¿™æ ·æˆ‘ä»¬å¯ä»¥åœ¨ä»¥åå›é¡¾å®ƒä»¬ï¼Œå¹¶åˆ©ç”¨è¿™äº›ä¿¡æ¯æ¥æé«˜æˆ‘ä»¬åº”ç”¨ç¨‹åºçš„å¥å£®æ€§ã€‚
- en: Your mission here is to use Serilog to log exception data on a daily rolling
    interval and store these log files in the `logs/errors` folder.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡æ˜¯ä½¿ç”¨SerilogæŒ‰æ¯æ—¥æ»šåŠ¨é—´éš”è®°å½•å¼‚å¸¸æ•°æ®ï¼Œå¹¶å°†è¿™äº›æ—¥å¿—æ–‡ä»¶å­˜å‚¨åœ¨`logs/errors`æ–‡ä»¶å¤¹ä¸­ã€‚
- en: 'You are also asked to customize the output template so that logs contain the
    following information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è¿˜è¢«è¦æ±‚è‡ªå®šä¹‰è¾“å‡ºæ¨¡æ¿ï¼Œä»¥ä¾¿æ—¥å¿—åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š
- en: Date and time of the event
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº‹ä»¶çš„æ—¶é—´å’Œæ—¥æœŸ
- en: The name of the machine on which the event happened
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‘ç”Ÿäº‹ä»¶çš„æœºå™¨åç§°
- en: The type of event (warning, error, and so on)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: äº‹ä»¶ç±»å‹ï¼ˆè­¦å‘Šã€é”™è¯¯ç­‰ï¼‰
- en: The exceptionâ€™s details, including its stack trace
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¼‚å¸¸çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬å…¶å †æ ˆè·Ÿè¸ª
- en: 'Part 3: Advanced Topics in CLI Application Development'
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¬¬3éƒ¨åˆ†ï¼šCLIåº”ç”¨ç¨‹åºå¼€å‘çš„é«˜çº§ä¸»é¢˜
- en: In this part, you will explore the world of interactive command-line applications,
    learning how to create engaging user experiences using libraries like `Spectre.Console`.
    You'll discover techniques for implementing rich prompts, colorful output, and
    interactive menus that enhance user interaction. Next, you'll delve into building
    modular and extensible CLI applications, focusing on architectural patterns that
    promote maintainability and scalability. This includes structuring your code and
    organizing your project into logical components. Finally, you'll learn about integrating
    external APIs and services into your CLI applications. By the end of this part,
    you'll have the skills to develop sophisticated CLI tools that can consume various
    external services and APIs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬éƒ¨åˆ†ä¸­ï¼Œä½ å°†æ¢ç´¢äº¤äº’å¼å‘½ä»¤è¡Œåº”ç”¨ç¨‹åºçš„ä¸–ç•Œï¼Œå­¦ä¹ å¦‚ä½•ä½¿ç”¨`Spectre.Console`ç­‰åº“åˆ›å»ºå¼•äººå…¥èƒœçš„ç”¨æˆ·ä½“éªŒã€‚ä½ å°†å‘ç°å®ç°ä¸°å¯Œæç¤ºã€å½©è‰²è¾“å‡ºå’Œå¢å¼ºç”¨æˆ·äº¤äº’çš„äº¤äº’å¼èœå•çš„æŠ€æœ¯ã€‚æ¥ä¸‹æ¥ï¼Œä½ å°†æ·±å…¥ç ”ç©¶æ„å»ºæ¨¡å—åŒ–å’Œå¯æ‰©å±•çš„CLIåº”ç”¨ç¨‹åºï¼Œé‡ç‚¹å…³æ³¨ä¿ƒè¿›å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§çš„æ¶æ„æ¨¡å¼ã€‚è¿™åŒ…æ‹¬å¯¹ä½ çš„ä»£ç è¿›è¡Œç»“æ„åŒ–ä»¥åŠå°†ä½ çš„é¡¹ç›®ç»„ç»‡æˆé€»è¾‘ç»„ä»¶ã€‚æœ€åï¼Œä½ å°†äº†è§£å¦‚ä½•å°†å¤–éƒ¨APIå’ŒæœåŠ¡é›†æˆåˆ°ä½ çš„CLIåº”ç”¨ç¨‹åºä¸­ã€‚åˆ°æœ¬éƒ¨åˆ†ç»“æŸæ—¶ï¼Œä½ å°†å…·å¤‡å¼€å‘å¤æ‚çš„CLIå·¥å…·çš„æŠ€èƒ½ï¼Œè¿™äº›å·¥å…·å¯ä»¥æ¶ˆè´¹å„ç§å¤–éƒ¨æœåŠ¡å’ŒAPIã€‚
- en: 'This part has the following chapters:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬éƒ¨åˆ†åŒ…å«ä»¥ä¸‹ç« èŠ‚ï¼š
- en: '[*Chapter 7*](B22400_07.xhtml#_idTextAnchor105)*, Interactive CLI Applications*'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*ç¬¬7ç« *](B22400_07.xhtml#_idTextAnchor105)*ï¼Œäº¤äº’å¼å‘½ä»¤è¡Œåº”ç”¨ç¨‹åº*'
- en: '[*Chapter 8*](B22400_08.xhtml#_idTextAnchor120)*, Building Modular and Extensible
    CLI Applications*'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*ç¬¬8ç« *](B22400_08.xhtml#_idTextAnchor120)*ï¼Œæ„å»ºæ¨¡å—åŒ–å’Œå¯æ‰©å±•çš„CLIåº”ç”¨ç¨‹åº*'
- en: '[*Chapter 9*](B22400_09.xhtml#_idTextAnchor136)*, Working with External APIs
    and Services*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*ç¬¬9ç« *](B22400_09.xhtml#_idTextAnchor136)*ï¼Œä¸å¤–éƒ¨APIå’ŒæœåŠ¡åä½œ*'
