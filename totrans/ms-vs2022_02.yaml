- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Debugging Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We explored unit testing and **Test-Driven Development** ( **TDD** ) in the
    last chapter, establishing a sturdy groundwork for crafting dependable code. Now,
    our focus shifts toward the realm of advanced debugging strategies within Visual
    Studio. The aim of this chapter is to equip ourselves with the requisite tools
    and methodologies to effectively tackle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Visual Studio Debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced breakpoints and data inspections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevating debugging with auto-decompilation and External Sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending debugging capabilities beyond our codebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering remote debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we’ll be able to resolve complex bugs significantly
    faster, saving ourselves time and effort. We will also gain a deeper understanding
    of our code, leading to more robust and maintainable applications. Finally, we
    will understand how to work confidently in production environments, knowing we
    can handle unexpected issues with ease.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s set off on this journey of advanced debugging mastery together. With
    the knowledge and skills we’ll gain, we’ll be able to face any debugging challenge
    head-on, ensuring quality and performance in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While writing this chapter, I used the following version of Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Enterprise 2022 Version 17.12.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preview 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering Visual Studio Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of finding and fixing errors or bugs in the source
    code of any software. There are several steps to follow to correctly accomplish
    this task.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in debugging is defining the problem. This entails identifying
    its symptoms, comparing expected versus actual outcomes, determining its scope,
    assessing its severity and impact, and noting the steps to reproduce it. This
    clarity streamlines the troubleshooting process.
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the bug is often the most effective way to pinpoint its cause. However,
    if this can’t be done, try checking the environment where it occurred, searching
    for the error message online, assessing the system’s state at the time, noting
    how often it happens, and identifying any recurring patterns. Effective debugging
    skills are crucial for improving software quality and developer productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Entering debug mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To aid us in these debugging processes, modern **Integrated Development Environments**
    ( **IDEs** ) provide powerful debuggers. As a developer, if you have ever used
    Visual Studio, you should have already used the debugger available in Visual Studio.
    Now, let’s delve into its most valuable features.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve set up a project to walk through using the debugger functionality to analyze
    how the code is working, I’m sure you can play with what we will see in one of
    your current projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common options to launch the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the entire solution in debug mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Debug mode](img/B22218_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Debug mode
  prefs: []
  type: TYPE_NORMAL
- en: Debug unit test for the debug-specific public method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Debugging a unit test](img/B22218_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Debugging a unit test
  prefs: []
  type: TYPE_NORMAL
- en: The second option could be a good choice to save compile time in our development
    process. Regardless of our choice, the first thing to do is set a breakpoint by
    left-clicking on the left side of our source file to navigate through the code.
    We will discuss the details of breakpoints later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, a breakpoint is an intentional stopping or pausing place in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we set the breakpoint and launch the debugger ( *F5* ), we can observe the
    behavior of the method. Here’s a reminder of the three main options to navigate
    on our codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step Into** ( *F11* ): This command steps into the code, meaning it goes
    into the method or function that is being called on the current line. If there
    are nested calls, it steps into the most deeply nested one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Over** ( *F10* ): This command steps over the current line of code,
    which means it executes the current line and then stops at the next line in the
    current method or function. It does not step into any methods or functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Out** ( *Shift* + *F11* ): This command steps out of the current method
    or function, which means that it will execute the rest of the method and then
    stop at the next line after the method cal l.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In debug mode, Visual Studio 2022 provides several ways that help us navigate
    through our code application during debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced debug navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio 2022 allows us to play with the debugger cursor to explore different
    areas of our codebase, with two features, described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Run To Cursor (Ctrl + F10)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Run To Cursor** feature allows us to quickly navigate to a specific location
    in our code and execute the code up to that point. To use **Run To Cursor** ,
    we simply place the cursor on the line of code where we want execution to stop,
    then right-click and select **Run To Cursor** from the context menu. Alternatively,
    we can use the keyboard shortcut *Ctrl* + *F10* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Run to Cursor](img/B22218_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Run to Cursor
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the line of code where we place the cursor must
    be reachable, meaning it should be part of the code that gets executed when the
    application runs. If the line is unreachable, the **Run To Cursor** command will
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: This command will run the code until it reaches the cursor’s position, but if
    there’s a breakpoint set at a location before the cursor, the debugger will stop
    at that breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to directly reach a line of code with the debugger, since Visual
    Studio 2022, we have been able to use the **Force and Run to** **Click** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Force And Run to Click
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Force Run to Click** feature, available from Visual Studio 2022 onward,
    is a powerful tool that allows us to skip over breakpoints and any first-chance
    exceptions that occur during the execution of our code. This is particularly useful
    when we want to test updated code or focus on a specific area of our program without
    being interrupted by breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: To use the **Force Run to Click** feature, we need to be in a paused state in
    the debugger. While the debugger is paused, we can hover over a statement in the
    source code, press the *Shift* key, and then select **Run execution to here**
    (represented by a green arrow icon).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Run execution to here](img/B22218_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Run execution to here
  prefs: []
  type: TYPE_NORMAL
- en: When we choose this option, the application will continue to run until it reaches
    the cursor location, and any breakpoints and first-chance exceptions that occur
    during this process will be temporarily disabled.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is especially convenient when we have multiple breakpoints set
    in our application and we want to skip them all to quickly reach a specific point
    in our code for testing or debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve navigated through our codebase using the debugger, we need to
    understand what’s happening at each step. Visual Studio provides several tools
    to help us examine the state of our application during debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding debugger tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Visual Studio debugger offers several windows, some more recent than others,
    to explore our variables and objects. Let’s explore these windows in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Autos window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Autos** window displays variables and expressions that are automatically
    evaluated by the debugger. It shows the values of local variables and expressions
    that are currently in scope. The **Autos** window is useful when we have many
    variables and we don’t want to clutter the **Locals** window with all of them.
    It evaluates only the most relevant variables based on our current execution context.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The Autos window](img/B22218_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Autos window
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have a **int apple.Id = 1;** variable and the **apple**
    and **stockManager** objects in use; the **Autos** window might show just them
    along with their values, rather than showing every single variable in the current
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the **Locals** window.
  prefs: []
  type: TYPE_NORMAL
- en: Locals window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Locals** window shows all local variables in the current scope. Unlike
    the **Autos** window, which only shows a subset of variables, the **Locals** window
    lists all local variables regardless of their relevance. This can be helpful when
    we need to see the exact state of all local variables at a particular breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The Locals window](img/B22218_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – The Locals window
  prefs: []
  type: TYPE_NORMAL
- en: Here, the **Locals** window allows you to see the value of each variable at
    the time the code execution is paused.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at the **Watch** window.
  prefs: []
  type: TYPE_NORMAL
- en: Watch window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the **Watch** window to monitor specific variables or expressions. We
    can manually add variables or expressions to the **Watch** window, and the debugger
    will evaluate them whenever the execution is paused. This is particularly useful
    when we want to keep track of the changes in the value of a variable over time
    or when we want to evaluate complex expressions that involve multiple variables.
  prefs: []
  type: TYPE_NORMAL
- en: To add an expression to the **Watch** window, right-click on the code and select
    **Add Watch** . We can also type directly or code in the **Watch** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – The Watch window](img/B22218_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – The Watch window
  prefs: []
  type: TYPE_NORMAL
- en: The **Watch** window can also be used to modify the value of a variable during
    debugging, which can be helpful for testing different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Call Stack window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, if we enter the **UpdateProduct()** method, we can follow the sequence
    in the **Call** **Stack** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – The Call Stack window](img/B22218_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – The Call Stack window
  prefs: []
  type: TYPE_NORMAL
- en: The **Call Stack** window in Visual Studio is a critical tool for debugging
    as it allows us to view the sequence of function or method calls that led to the
    current point of execution in our program. This window is essential for understanding
    the flow of execution and for diagnosing issues within our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key functionalities of the **Call Stack** window in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Call Stack** : We can see the sequence of method and function calls
    that led to the current point of execution in our program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Switching stack frames** : We can switch to a different stack frame by right-clicking
    a frame in the **Call Stack** window and selecting **Switch to Frame** , or by
    double-clicking the frame. This allows us to inspect the code and data within
    that frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disassembly code view** : To view the disassembly code for a function on
    the call stack, simply right-click the function and select **Go** **To Disassembly**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loading Symbols** : The **Call Stack** window in Visual Studio has the capability
    to load debugging symbols for code that currently lacks them. These symbols may
    include .NET or system symbols obtained from Microsoft’s public symbol servers,
    or symbols located within a symbol path on our computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code map integration** : Visual Studio Enterprise provides the functionality
    to visually map the call stack during debugging. This feature enables us to observe
    the current call stack in a graphical format on a new code map, which updates
    automatically as debugging progresses. This visual representation facilitates
    a more intuitive understanding of the structure and flow of our code, aiding in
    the identification of potential issues or areas for optimization. Please note
    that adding the **CodeMap** extension to Visual Studio is necessary to utilize
    this feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, let us look at the **Immediate** Window.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Immediate** window in Visual Studio is an old, little-known debugging
    tool that allows us to execute code, evaluate expressions, and print variable
    values on the fly during a debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The Immediate window](img/B22218_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – The Immediate window
  prefs: []
  type: TYPE_NORMAL
- en: It is designed to help with dynamic code evaluation and the quick testing of
    code snippets without having to stop the execution of the application. To use
    the **Immediate** window, open it by going to the **Debug** menu, selecting **Windows**
    , and then choosing the **Immediate** window, or by pressing *Ctrl* + *Alt* +
    *I* . This window is particularly useful when debugging an application, as it
    allows us to check the value of variables, call functions, and execute statements
    without stepping through the code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some valuable tricks for using the **Immediate** window effectively
    during debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging methods from the Immediate window** : We can place breakpoints
    in methods and call them from the **Immediate** window to debug them, even if
    we’ve already passed that point in the code. Note that we can use the **Run to
    a cursor location** ( *Ctrl* + *Shift* + *F10* ) feature to return to any line
    of code in the same scope and step into methods with *F11* to debug as usual.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bypassing access rules** : The **Immediate** window does not enforce class
    accessibility rules, allowing us to call private, protected, and internal members
    that would not be accessible in regular code. However, IntelliSense (the built-in
    autocompletion tool) will still show only the public methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluating expressions without side effects** : Evaluating expressions in
    the **Immediate** window can change variable values and call methods, potentially
    causing side effects. To avoid this, append **No Side Effects** ( **nse** ) to
    an expression, which will evaluate it without altering the application state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessing special debugging variables** : The **Immediate** window can display
    values of special debugging variables such as **$exception** (the currently thrown
    exception), **$returnvalue** (the return value of the currently returned method),
    and **$user** (the current OS user and process information).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluating Make Object ID** : When debugging, you can **Make Object ID**
    for a variable in **DataTip** , which creates a unique identifier for the object.
    This identifier can be evaluated in the **Immediate** window at any time to see
    changes in the object’s value or existence in memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying bugs is an essential step in our debugging process, but the goal
    is to fix them. Let’s explore how we can enhance productivity by fixing them on
    the fly with Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing bugs on the fly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enhance our productivity during debugging and avoid the need to stop and
    start the debugger to fix a bug, Visual Studio 2022 allows us to do so on the
    fly with the following features.
  prefs: []
  type: TYPE_NORMAL
- en: Edit and Continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Edit and Continue** is a feature that allows you to modify your source code
    while your application is in break mode. When you apply the changes, Visual Studio
    attempts to recompile the modified code and apply those changes to the running
    application. This means that you can fix bugs, add features, or experiment with
    code changes without interrupting the flow of your debugging session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: We start debugging your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We hit a breakpoint and pause the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While paused, we can edit the code in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After editing, we can choose to continue execution with the new changes applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can even move the yellow execution pointer back to change the execution flow
    and execute our edited code.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is particularly useful when we find a bug during a debugging session,
    and we immediately know how to fix it. Instead of stopping the debugger, making
    the change, and then restarting the app, you can simply edit the code and continue.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Reload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hot Reload** is a newer feature introduced in **.NET 6** and supported in
    Visual Studio 2022. It allows us to make changes to our code while our application
    is running, and those changes are reflected in the running application almost
    instantly. This is like Edit and Continue, but with a few key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Hot Reload supports UI updates, whereas Edit and Continue does not. If we change
    the layout or appearance of our UI, Hot Reload will update the running app to
    reflect those changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot Reload is designed to work with .NET applications, including ASP.NET Core
    web apps and Blazor WebAssembly apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot Reload requires a bit more setup compared to Edit and Continue. We need
    to enable it in our project settings and ensure that our app is compatible with
    the feature. We will delve deeper into it in the next chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Hot Reload, we can see the effects of our changes immediately, which can
    speed up the development process, especially when working on UI or front-end code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both Edit and Continue and Hot Reload are powerful tools that can save time
    and reduce the frustration associated with stopping and restarting our application
    during the debugging process. They allow us to maintain a smooth workflow and
    quickly iterate on our code, which can lead to more efficient problem-solving
    and faster development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve conquered the art of navigating the debugger, taken an overview
    of their windows, and performed live fixes, let’s delve deeper into two powerful
    tools that elevate your debugging game: advanced breakpoints and data inspection.
    While we’ve already touched upon them, consider this a deep dive, equipping you
    to wield them with precision and unlock invaluable insights into your code’s behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced breakpoints and data inspections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced breakpoints in Visual Studio 2022 are powerful tools that allow us
    to inspect and control the execution flow of their programs during debugging sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the types of breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Breakpoints in Visual Studio can be divided into several types. Those are as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can control when a breakpoint executes by setting conditions. That feature
    has been available since Visual Studio 2005. We can right-click the breakpoint
    symbol and select **Conditions** , or right-click in the margin next to a line
    of code and select **Insert Conditional Breakpoint** from the context menu. In
    the **Breakpoint Settings** window, select **Conditional Expression** , **Hit
    Count** , or **Filter** , and set the conditional expression in the text box accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Conditional breakpoint](img/B22218_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Conditional breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: In this example, with our setup, the debugger will stop if **newQuantiy** is
    not equal to **product.QuantityStock**
  prefs: []
  type: TYPE_NORMAL
- en: Tracepoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced with Visual Studio 2005, a **tracepoint** serves as a breakpoint
    variant enabling users to log information to the **Output** window based on customizable
    conditions as conditional breakpoints without altering or pausing the code execution.
    Tracepoints are compatible with managed languages such as C#, Visual Basic, F#,
    and native code, as well as languages such as JavaScript and Python
  prefs: []
  type: TYPE_NORMAL
- en: To set a tracepoint, simply click on the gutter located to the left of the desired
    line number. Hover over the ensuing red circle and click on the gear icon to unveil
    the **Breakpoint Settings** window. Proceed by selecting the **Action** checkbox.
    This action will transform the red circle into a diamond shape, signifying the
    transition from a traditional breakpoint to a tracepoint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Tracepoint](img/B22218_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Tracepoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the message we want to log into the **Show a message in the Output Window**
    text box. If we want to add conditions that determine whether our message is displayed,
    we could select the **Conditions** checkbox. As for conditional breakpoints, we
    have three choices for conditions: **Conditional Expression** , **Filter** , and
    **Hit Count** . Tracepoints are useful for debugging because they allow us to
    log information without cluttering our code with print statements or functions
    such as **Debug.WriteLine()** .'
  prefs: []
  type: TYPE_NORMAL
- en: Data breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data breakpoints allow us, as developers, to pause execution when the value
    of a specific object’s property changes. This feature is particularly useful for
    debugging scenarios where we want to monitor changes to data without having to
    manually step through code. Data breakpoints can be set for **.NET Core 3.x**
    or **.NET 5+** projects, and they are particularly useful for tracking changes
    in object properties.
  prefs: []
  type: TYPE_NORMAL
- en: To set a data breakpoint in a .NET Core or .NET 5+ project, we start debugging
    and wait until a breakpoint is reached. Then, in the **Autos** , **Watch** , or
    **Locals** window, we right-click a property and select **Break when value changes**
    from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Break When Value Changes](img/B22218_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Break When Value Changes
  prefs: []
  type: TYPE_NORMAL
- en: This will set a data breakpoint that triggers when the selected property’s value
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Data breakpoints are subject to hardware and kernel limitations. The Windows
    kernel and the underlying hardware impose a maximum number of data breakpoints
    that can be set simultaneously. These limitations ensure that our debugging experience
    remains efficient and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that data breakpoints depend on specific memory addresses,
    and that the address of a variable can change from one debugging session to the
    next. Therefore, data breakpoints are automatically disabled at the end of each
    debugging session. If we set a data breakpoint on a local variable, the breakpoint
    remains enabled when the function ends, but the memory address is no longer applicable,
    leading to unpredictable behavior. It’s recommended to delete or disable such
    breakpoints before the function ends to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of data breakpoints for .NET Core in Visual Studio 2019 marked
    the start of this feature, making it a valuable tool for us when working with
    .NET Core 3.x or . NET 5+.
  prefs: []
  type: TYPE_NORMAL
- en: Function breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Visual Studio 2012, we have been able to set breakpoints on functions,
    which is useful when we know the function name but not its location, or when we
    have overloaded functions. To set a function breakpoint, select **Debug** | **New
    Breakpoint** | **Function Breakpoint** , or press *Ctrl* + *K* , then *B* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Function breakpoints](img/B22218_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Function breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: Enter the fully qualified function name, including parameter types for overloaded
    functions, or use the *!* symbol to specify the module. Here, we set a breakpoint
    to the **SearchProducts** method of the **StockManager** class.
  prefs: []
  type: TYPE_NORMAL
- en: Dependant breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual Studio 2022 introduced us to the possibility of setting up a dependent
    breakpoint, which is a powerful debugging feature that allows us to pause the
    execution of our program only when another specific breakpoint has been hit first.
    This is particularly useful in complex debugging scenarios, such as when we are
    working with multi-threaded applications or when we want to focus on debugging
    code in specific parts of our application.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a dependent breakpoint, we first need to identify the breakpoint that
    our current breakpoint will depend on. Then, we hover over the breakpoint symbol,
    choose the settings icon, and select **Only enable when the following breakpoint
    is hit** in the **Breakpoint** **Settings** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The Only enable when the following breakpoint is hit checkbox](img/B22218_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The Only enable when the following breakpoint is hit checkbox
  prefs: []
  type: TYPE_NORMAL
- en: From the dropdown, we select the prerequisite breakpoint that we want our current
    breakpoint to be dependent on. After setting this up, we can close the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to set a dependent breakpoint is by using the right-click context
    menu. We right-click in the far-left margin next to a line of code and select
    **Insert Dependent Breakpoint** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Insert Dependent Breakpoint](img/B22218_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Insert Dependent Breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that dependent breakpoints do not work if there is only
    a single breakpoint in our application. If the prerequisite breakpoint is deleted,
    the dependent breakpoint will be converted to a normal line breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is designed to streamline our debugging process by allowing us
    to focus on specific parts of our code that are relevant to the debugging task
    at hand, thereby potentially saving time and effort during the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Temporary breakpoints in Visual Studio 2022 are a powerful debugging feature
    that allows us, as developers, to pause the execution of our code only once at
    a specific location. Once the breakpoint is hit during our debugging session,
    it automatically disables itself, making it ideal for scenarios wherein we want
    to inspect a specific condition or behavior without repeatedly hitting the same
    breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a tempory breakpoint, we first need to identify the breakpoint that
    our current breakpoint will depend on. Then, we hover over the breakpoint symbol,
    choose the settings icon, and select **Disable breakpoint once hit** in the **Breakpoint
    Settings** window. This action configures the breakpoint to automatically disable
    itself after it’s hit during our debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Disable breakpoint once hit](img/B22218_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Disable breakpoint once hit
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can directly set a temporary breakpoint by right-clicking
    in the breakpoint gutter and selecting **Insert Temporary Breakpoint** from the
    context menu.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of temporary breakpoints in Visual Studio 2022 enhances our
    debugging experience by providing us with a tool to inspect specific points in
    the code without the need to manually remove or disable breakpoints after they
    have been hit. This feature is particularly useful for validating assumptions,
    checking the flow of execution, or verifying the state of variables at specific
    moments during our debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned all about breakpoints, let’s learn how we can organize
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use labels to sort and filter breakpoints in the **Breakpoints** window.
    Right-click a breakpoint and select **Edit labels...** to add or change labels.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Edit labels…](img/B22218_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Edit labels…
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the **Breakpoints** window, we can retrieve our settled labels to filter
    and organize them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Breakpoints with labels](img/B22218_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Breakpoints with labels
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I labeled my conditional breakpoint **UpdateQuantity** .
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know which breakpoints to use according to our needs, let’s see
    how to inspect the data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen before, the **Watch** window in Visual Studio is a powerful
    debugging tool that allows us to monitor the values of variables and expressions
    during the execution of our program. It is particularly useful when we want to
    keep an eye on the changes in variable values as your code executes, which can
    be especially helpful in debugging complex logic or performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the **Watch** window offers a dedicated space for monitoring variables,
    Visual Studio also empowers us with a more immediate option: **DataTips** . These
    handy popups appear right within the code editor, revealing variable values directly
    where they’re used.'
  prefs: []
  type: TYPE_NORMAL
- en: To leverage DataTips, simply hover our mouse over any variable name in our code.
    Then, a tooltip emerges, displaying the current value of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Displaying the datatips](img/B22218_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Displaying the datatips
  prefs: []
  type: TYPE_NORMAL
- en: In certain scenarios, such as the one shown in *Figure 2* *.19* , it can be
    challenging to locate specific items of interest within a large list.
  prefs: []
  type: TYPE_NORMAL
- en: Pinning properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When looking at a data list with a huge list of complex data, it could be difficult
    to focus on the part of the data we need. The solution is to utilize the **Pinnable
    Properties** feature, also available in the **Watch** window. To accomplish this,
    we expand a variable and pin the property that interests us. For example, if we’re
    interested in the name of the product, we can pin it for easy reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Pinning the Name property](img/B22218_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Pinning the Name property
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – A list of products with pinned names](img/B22218_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – A list of products with pinned names
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever we inspect this object with DataTips, even in the **Watch** window,
    the pinned property replaces the name of the object until we unpin it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Pinned properties in the Watch window](img/B22218_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – Pinned properties in the Watch window
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can easily access the product we want to inspect. Additionally, we can
    use the pin icon located next to our product object to keep the popup visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The DataTip pin](img/B22218_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – The DataTip pin
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I pin the **Name** and **Id** properties of the product so
    we can monitor its behavior during the execution of our loop.
  prefs: []
  type: TYPE_NORMAL
- en: Editing value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: DataTips enables us to edit the values of non-read-only variables, which can
    be useful for validating certain scenarios. To do this, we simply click on the
    value of the properties to update it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Editing value on DataTips](img/B22218_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Editing value on DataTips
  prefs: []
  type: TYPE_NORMAL
- en: DataTips also allows us to edit the values of our non-read-only variables, which
    can be useful for validating certain scenarios. This feature is also available
    in the **Watch** window, although it is not present in the **Local** or **Autos**
    windows.
  prefs: []
  type: TYPE_NORMAL
- en: While meticulous debugging practices within our own code are crucial, sometimes
    the true culprit lies hidden within external components. Understanding their behavior
    is the key to unlocking elusive bugs and crafting truly robust solutions. Let’s
    explore how Visual Studio, starting from version 17.7, assists us in this endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Elevating debugging with auto-decomplication and External Sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2022 has significantly enhanced the debugging experience with
    the introduction of auto-decompilation and External Sources. These features allow
    developers to debug external code, such as .NET libraries or **NuGet** packages,
    with the same ease as their own code.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-decompilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Auto-decompilation is a feature that transforms compiled binary code into a
    higher-level programming language, such as C#, allowing us to examine, troubleshoot,
    and fix issues in external code as if they were working with their own code. This
    is particularly useful for debugging scenarios where the source code is not available
    or when we need to inspect code from a third-party library.
  prefs: []
  type: TYPE_NORMAL
- en: How auto-decompilation works
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The debugger uses the **ILspy** decompiler engine to decompile external code
    in real time and incorporate it into the debugging session. The debugger first
    looks for local external sources on our machine, then uses **Source Link** or
    **Source Server** information from PDB files to load the source code. If these
    methods fail, the debugger falls back to decompiling the code.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling auto-decompilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET package authors could, in the past, control whether their code could be
    decompiled by implementing the **SuppressIldasmAttribute** attribute. Although
    this attribute is obsolete as of .NET 6+, Visual Studio still honors it.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of auto-decompilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There can be issues when trying to decompile .NET assemblies, such as inaccurate
    variable names or unavailable variables for evaluation. These limitations can
    be more pronounced when debugging optimized or release assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: External Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The External Sources feature in Visual Studio allows us to debug and step into
    code from dependent NuGet or .NET libraries that are not part of our solution.
    This is facilitated by the addition of an External Sources node in **Solution
    Explorer** , which appears during debugging and shows sources for managed modules
    with loaded symbols containing Source Link or Source Server information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find them below the top node of our solution in **Solution Explorer**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – External Sources nodes](img/B22218_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – External Sources nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a comprehensive guide on utilizing this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using External Sources** : The External Sources node organizes decompiled
    external code modules from different call stacks, allowing us to navigate and
    set breakpoints within this external code. This makes debugging external code
    as seamless as debugging our own code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling External Sources** : To debug external sources, we may need to enable
    **Load All Modules** to allow the debugger to load symbols for all modules. We
    can also manually load modules from the **Modules** window if necessary from the
    top bar menu by going to **Debug** | **Window** | **Modules** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Downloading source code** : If we double-click an item in the External Sources
    node, we may be prompted to download the source from the server. After accepting,
    we can view the source code in the editor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-decompilation and External Sources make it easier for us to debug external
    code, which can be particularly beneficial when dealing with complex libraries
    or when trying to resolve issues in third-party code. These features streamline
    our debugging process, reducing the time we spend on understanding and navigating
    external code. Package authors can prevent their code from being decompiled by
    using the **SuppressIldasmAttribute** attribute, ensuring that they maintain control
    over their intellectual property. However, debugging decompiled code may not always
    be as accurate as debugging source code, with potential issues such as inaccurate
    variable names or unavailable variables. Additionally, stepping through decompiled
    code may not always align with the original source code.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging these features, Visual Studio 2022 offers a more comprehensive
    debugging experience, enabling us to diagnose and resolve issues in their applications
    more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading is a technique whereby a process splits into multiple threads,
    allowing for better performance, especially on systems with multiple processors
    or cores. However, managing multiple threads can be challenging as they may need
    to access shared resources concurrently, leading to potential bugs such as deadlocks
    where threads are unable to progress. Debugging such issues can be difficult and
    time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to tackle this by using the **Threads** window
    and handling parallel debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will create a simple console application calling ten simple threads.
    Here’s the code we will use for our example :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code demonstrates the creation and execution of multiple threads in C#,
    each running an instance of a **Dummy** class’s **Instance** method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will set a breakpoint on **Thread.Sleep(3000)** on the **Instance**
    method and launch our project in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: We can track the thread by activating the **Show Threads in Source** button
    on the debug toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Show Threads in Source](img/B22218_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – Show Threads in Source
  prefs: []
  type: TYPE_NORMAL
- en: That will make **thread maker icons** appear on the left side of the window.
    When we hover over them, we can view the name and thread ID number for each stopped
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – List of threads](img/B22218_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – List of threads
  prefs: []
  type: TYPE_NORMAL
- en: 'By right-clicking on one of the threads, we can access different types of action
    to navigate through the threads, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flag** / **Unflag**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freeze** / **Thraw**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Switch** **To Thread**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Manipulating threads](img/B22218_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 – Manipulating threads
  prefs: []
  type: TYPE_NORMAL
- en: When we flag threads, it enables us to focus on one thread while ignoring the
    others.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve concurrency issues and control the order in which threads perform
    work, we must use the **Freeze** and **Thraw** features, allowing us to suspend
    and resume threads.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, **Switch To Thread** allows us to jump from one thread to another
    for step-by-step debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the common debugging process, Visual Studio offers a **Watch** window
    named **Parallel Watch** . We access it from the top bar menu by clicking on **Debug**
    | **Window** | **Parallel Watch** | **Parallel** **Watch 1** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Parallel Watch](img/B22218_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 – Parallel Watch
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can add data to watch by entering their names in the **<Add Watch>**
    cell. Additionally, we can easily switch to a thread by double-clicking on the
    thread line we are interested in. Right-clicking allows us to access the **Flag**
    and **Freeze** features. The flag button in the top left corner enables us to
    filter and display only the flagged threads.
  prefs: []
  type: TYPE_NORMAL
- en: Another view offered by Visual Studio to efficiently track threads is the **Parallel
    Stacks** window. To access it, we use the debug menu, which you can reach by clicking
    **Debug** | **Window** | **Parallel Stacks** .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – Parallel Stacks](img/B22218_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 – Parallel Stacks
  prefs: []
  type: TYPE_NORMAL
- en: This window provides both a **Thread** and a **Tasks** view, showing the call
    stack information for each thread. The current thread is indicated by a yellow
    arrow, allowing us to easily follow the path of each thread. This information
    can also be viewed in a list format in the **Threads** window by going to **Debug**
    | **Windows** | **Threads** .
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can utilize conditional breakpoints, which allow us to set breakpoints
    based on various conditions, such as the thread name or ID. This feature is particularly
    handy when setting conditions on data unique to each thread. It’s a common approach
    during debugging, especially when focusing on specific data values rather than
    individual threads.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone on a journey exploring the techniques and tools of Visual
    Studio 2022 concerning debugging, let’s see how we can resolve the famous “it
    works on my laptop” issues by leveraging the remote debugging feature.
  prefs: []
  type: TYPE_NORMAL
- en: Remote debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remote debugging is a powerful feature in Visual Studio that allows us to debug
    applications running on different machines, devices, or environments. This is
    particularly useful when we need to troubleshoot issues that occur in a production
    environment or on a different platform that we don’t have access to locally.
  prefs: []
  type: TYPE_NORMAL
- en: To leverage this functionality effectively, we need to ensure that Visual Studio
    is installed on both the local and remote machines. We need to configure the remote
    machine by installing the compatible Visual Studio version and allowing remote
    connections via the firewall settings.
  prefs: []
  type: TYPE_NORMAL
- en: On the local machine, we enable remote debugging in Visual Studio’s settings
    by specifying the remote machine’s address and credentials, if necessary. To do
    so, we go to the project properties of the application we want to debug and navigate
    to the **Debug** tab.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – The Project properties | Debug tab](img/B22218_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 – The Project properties | Debug tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can click on the **Open debug launch profiles UI** link. Once in the
    **Launch Profiles** window, we can check the **Use remote machine** checkbox that
    displays the two more fields that allow us to configure the remote connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – The Use remote machine checkbox](img/B22218_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 – The Use remote machine checkbox
  prefs: []
  type: TYPE_NORMAL
- en: In a critical situation wherein debugging a web application on a live production
    server, it’s becomes essential to be able to access to the debugger on production
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the application to the production server, ensuring that all necessary
    components are installed. After that, we need to configure Visual Studio on the
    server for remote debugging and adjust the firewall settings accordingly. In Visual
    Studio on the local machine, we attach to the remote process by entering the remote
    machine’s address and credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Then we can debug the application, select the process for the web application,
    and debug as usual, including setting breakpoints and inspecting variables. Finally,
    we can reproduce the issue while debugging, fix it once it has been identified,
    and deploy the updated application.
  prefs: []
  type: TYPE_NORMAL
- en: Remote debugging facilitates diagnosing issues in production-like environments
    without disrupting live traffic. Accessing production data aids in understanding
    the issue’s context. Security measures should be implemented to safeguard sensitive
    information. Be mindful of performance impacts, scheduling debugging during off-peak
    times or in staging environments. Utilizing remote debugging enhances application
    reliability by addressing issues in environments inaccessible through traditional
    means, bolstering overall quality and stability.
  prefs: []
  type: TYPE_NORMAL
- en: By using remote debugging, we can effectively diagnose and fix issues that occur
    in environments where we don’t have direct access to the code or data, thereby
    improving the reliability and quality of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter delved into the powerful world of advanced debugging strategies
    in Visual Studio 2022, equipping you with the skills to tackle even the most complex
    code effectively. We explored various debugging tools and techniques that are
    essential for identifying and resolving issues in your code.
  prefs: []
  type: TYPE_NORMAL
- en: We began by mastering the art of navigating your code, where we focused on breakpoints,
    step execution modes, and the call stack, all of which are crucial for pinpointing
    the source of errors. The chapter also introduced the concept of live code modification,
    allowing you to dynamically fix bugs and experiment with code changes on the fly
    through features like Edit and Continue and Hot Reload. We didn’t stop at debugging
    your own code; we also explored the advantages of auto-decompilation and External
    Sources, which enable seamless debugging of external libraries and NuGet packages.
    Furthermore, the chapter covered remote debugging, a technique that allows you
    to diagnose and fix issues in production-like environments without impacting live
    traffic. By mastering these advanced debugging techniques, you can resolve complex
    bugs more quickly, thereby reducing development time and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue our journey according to the TDD cycle seen
    in the first chapter. After fixing our code with debugging, we’ll delve into the
    art of shaping our code into its best form. We’ll be embarking on a journey of
    advanced code analysis and refactoring in Visual Studio 2022.
  prefs: []
  type: TYPE_NORMAL
