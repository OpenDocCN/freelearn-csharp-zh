<html><head></head><body>
<div><div><h1 id="_idParaDest-121"><em class="italic"><a id="_idTextAnchor120"/>Chapter 7</em>: Task Parallel Library (TPL) and Dataflow</h1>
<p>The <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>) <strong class="bold">dataflow library</strong> contains building blocks to orchestrate asynchronous workflows in .NET. This chapter will introduce the TPL Dataflow library, describe the types of <strong class="bold">dataflow blocks</strong> in the library, and illustrate some common patterns for using dataflow blocks through hands-on examples.</p>
<p>The dataflow library can be useful when processing large amounts of data in multiple stages or when your application receives data in a continuous stream. The dataflow blocks provide a fantastic way of implementing the <strong class="bold">producer/consumer design pattern</strong>. </p>
<p>To understand this, we will create a sample project that implements this pattern and examine other real-world uses of the dataflow library.</p>
<p class="callout-heading">Note</p>
<p class="callout">It’s important to know that the TPL Dataflow library isn’t distributed as part of the .NET runtime or SDK. It’s available as a NuGet package from Microsoft. We will add it to our sample projects with <strong class="bold">NuGet Package Explorer</strong> (<strong class="bold">NPE</strong>) in Visual Studio.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing the TPL Dataflow library</li>
<li>Implementing the producer/consumer pattern</li>
<li>Creating a data pipeline with multiple blocks</li>
<li>Manipulating data from multiple data sources</li>
</ul>
<p>By the end of this chapter, you will understand the purpose of each type of dataflow block and be able to add the dataflow library to your projects, where appropriate. </p>
<p>You will also know when dataflow blocks do not provide an advantage over simpler parallel programming alternatives, such as <code>Parallel.ForEach</code>.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Technical requirements</h1>
<p>To follow along with the examples in this chapter, the following software is recommended for Windows developers:</p>
<ul>
<li>Visual Studio 2022 version 17.0 or later</li>
<li>.NET 6</li>
<li>To complete the WPF sample, you will need to install the .NET desktop development workload for Visual Studio</li>
</ul>
<p>While these are recommended, if you have .NET 6 installed, you can use your preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later, JetBrains Rider, or Visual Studio Code will work just as well.</p>
<p>The code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07</a>.</p>
<p>Let’s get started by discussing the TPL Dataflow library and why it can be a great way to implement parallel programming in .NET.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Introducing the TPL Dataflow library</h1>
<p>The <a id="_idIndexMarker350"/>TPL Dataflow library has been available for as long as TPL itself. It was released in 2010 after <code>System.Threading.Tasks.Dataflow</code> namespace. The dataflow library is intended to build on the basics of parallel programming that are provided in TPL, expanding to address data flow scenarios (hence the name of the library). The dataflow library is made up of foundational classes<a id="_idIndexMarker351"/> called <strong class="bold">blocks</strong>. Each data flow block is responsible for a particular action or step in the overall flow.</p>
<p>The dataflow library consists of three basic types of blocks:</p>
<ul>
<li><code>ISourceBlock&lt;TOutput&gt;</code> interface. Source<a id="_idIndexMarker353"/> blocks can have their data read from the workflow you define.</li>
<li><code>ITargetBlock&lt;TInput&gt;</code> interface<a id="_idIndexMarker355"/> and is a data receiver.</li>
<li><code>IPropagatorBlock&lt;TInput, TOutput&gt;</code> interface. Applications can read data from these blocks and write to them.</li>
</ul>
<p>When you connect multiple dataflow blocks to create a workflow, the resulting system is referred to<a id="_idIndexMarker358"/> as a <code>ISourceBlock&lt;TOutput&gt;.LinkTo</code> method. This is where propagator blocks can fit in the middle of a pipeline. They can act as both the source and target of a link in the workflow. If a message from a source block can be processed by more than one target, you can add filtering to examine the properties of the object provided by the source to determine which target or propagator block should receive the object.</p>
<p>The objects that are passed between dataflow blocks are commonly referred to as <strong class="bold">messages</strong>. You can <a id="_idIndexMarker359"/>think of a dataflow pipeline <a id="_idIndexMarker360"/>as a <strong class="bold">network</strong> or messaging system. The units of data that flow through the network are the messages. Each block is responsible for reading, writing, or transforming each message in some way.</p>
<p>To send a <a id="_idIndexMarker361"/>message to a target block, you can use the <code>Post</code> method to send it synchronously or the <code>SendAsync</code> method to send it asynchronously. In source blocks, messages can be received with the <code>Receive</code>, <code>TryReceive</code>, and <code>ReceiveAsync</code> methods. The <code>Receive</code> and <code>TryReceive</code> methods are both synchronous. The <code>Choose</code> method will monitor multiple source blocks for data and return a message from the first source to provide data.</p>
<p>To offer a <a id="_idIndexMarker362"/>message from a source block to a target block, the source can call the <code>OfferData</code> method of a target. The <code>OfferData</code> method returns a <code>DataflowMessageStatus</code> enum that has several possible values:</p>
<ul>
<li><code>Accepted</code>: The message was accepted and will be processed by the target.</li>
<li><code>Declined</code>: The message was declined by the target. The source block still owns the message and cannot process its next message until the current message has been accepted by another target.</li>
<li><code>DecliningPermanently</code>: The message was declined, and the target is no longer available for processing. All subsequent messages will be declined by the current target. Source blocks will unlink from a target that returns this status.</li>
<li><code>Postponed</code>: Accepting the message has been postponed. It may be accepted by the target at a later time. In this case, the source can wait or attempt to pass the message to an alternative target block.</li>
<li><code>NotAvailable</code>: The <a id="_idIndexMarker363"/>message was no longer available when the target tried to accept it. This can occur when the target attempts to accept a message after it had been postponed, but the source block has already passed the message to a different target block.</li>
</ul>
<p>Dataflow blocks support the concept of <code>Complete</code> method and a <code>Completion</code> property. The <code>Complete</code> method is called to request completion on a block, while the <code>Completion</code> property returns a <code>Task</code>, known as the block’s <code>IDataflowBlock</code> interface, which is inherited by both <code>ISourceBlock</code> and <code>ITargetBlock</code>. </p>
<p>The completion task <a id="_idIndexMarker365"/>can be used to determine if a block has encountered an error or has been canceled. Let’s see how:</p>
<ol>
<li>The simplest way to handle errors encountered by a dataflow block is to call <code>Wait</code> on the <code>Completion</code> property of the block and handle the <code>AggregateException</code> exception type in the <code>try</code>/<code>catch</code> block:<pre>try
{
   inputBlock.Completion.Wait();
}
catch (AggregateException ae)
{
   ae.Handle(e =&gt;
   {
      Console.WriteLine($"Error processing input - 
          {e.GetType().Name}: {e.Message}");
   });
}</pre></li>
<li>If you want to do the same thing without using the blocking <code>Wait</code> call, you can <code>await</code> the <a id="_idIndexMarker366"/>completion task and handle the <code>Exception</code> type:<pre>try
{
    await inputBlock.Completion;
}
catch (Exception e)
{
    Console.WriteLine($"Error processing input - 
        {e.GetType().Name}: {e.Message}");
}</pre></li>
<li>Another alternative is to use the <code>ContinueWith</code> method on the completion task. Inside the continuation block, you can check the status of the task to determine if it is <code>Faulted</code> or <code>Canceled</code>:<pre>try
{
    <strong class="bold">inputBlock.ContinueWith(task =&gt;</strong>
<strong class="bold">    {</strong>
<strong class="bold">        Console.WriteLink($"Task completed with a </strong>
            <strong class="bold">status of {task.Status}");</strong>
<strong class="bold">    });</strong>
    await inputBlock.Completion;
}
catch (Exception e)
{
    Console.WriteLine($"Error processing input - 
        {e.GetType().Name}: {e.Message}");
}</pre></li>
</ol>
<p>We will see more comprehensive examples of dataflow block use when we create a sample project using the producer/consumer pattern in the next section. Before we examine the types of dataflow blocks, let’s discuss why Microsoft created the library.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Why use the TPL Dataflow library?</h2>
<p>The <a id="_idIndexMarker367"/>TPL dataflow library was created by Microsoft as a means of orchestrating asynchronous data processing workflows. Data flows into the first dataflow block in the pipeline from a data source. The source can be a database, a local or network folder, a camera, or just about any other type of input device that .NET can access. One or more blocks can be part of the pipeline, with each being responsible for a single operation. The following diagram illustrates two abstractions of dataflow pipelines:</p>
<div><div><img alt="Figure 7.1 – Dataflow pipeline examples " height="582" src="img/Figure_7.1_B18552.jpg" width="1167"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Dataflow pipeline examples</p>
<p>One <a id="_idIndexMarker368"/>real-world example you can consider is using a webcam to capture image frames. In a two-step flow, as shown in <em class="italic">Example 1</em>, consider the webcam as <strong class="bold">Data Input</strong>. <strong class="bold">Dataflow Block 1</strong> could perform some image processing to optimize the image appearance, while <strong class="bold">Dataflow Block 2</strong> will call an <strong class="bold">Azure Cognitive Services</strong> API to identify objects in each image. <strong class="bold">Result</strong> would contain a new .NET class for each input image containing the image binary data and properties that contain the identified objects within each image.</p>
<p>Next, let’s learn about the types of blocks available in the dataflow library.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Types of dataflow blocks</h2>
<p>There are<a id="_idIndexMarker369"/> nine predefined blocks in the dataflow library. These can be divided into three different categories. The first category is <strong class="bold">buffering blocks</strong>.</p>
<h3>Buffering blocks</h3>
<p>The<a id="_idIndexMarker370"/> purpose of <code>BufferBlock&lt;T&gt;</code>, <code>BroadcastBlock&lt;T&gt;</code>, and <code>WriteOnceBlock&lt;T&gt;</code>.</p>
<h4>BufferBlock</h4>
<p><code>BufferBlock&lt;T&gt;</code> is an <a id="_idIndexMarker374"/>asynchronous queuing mechanism that implements a <code>BufferBlock</code> can have multiple data sources and multiple targets configured. However, each message in a <code>BufferBlock</code> can only be delivered to one target block. The message is removed from the queue after it has been successfully delivered.</p>
<p>The following snippet pushes customer names into a <code>BufferBlock</code> and subsequently reads the first five names out to the console:</p>
<pre class="source-code">BufferBlock&lt;string&gt; customerBlock = new();</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine(await customerBlock.ReceiveAsync());</pre>
<pre class="source-code">}</pre>
<pre class="source-code">// The code could display the following output:</pre>
<pre class="source-code">//    Robert Jones</pre>
<pre class="source-code">//    Jita Smith</pre>
<pre class="source-code">//    Patty Xu</pre>
<pre class="source-code">//    Sam Alford</pre>
<pre class="source-code">//    Melissa Allen</pre>
<h4>BroadcastBlock</h4>
<p><code>BroadcastBlock&lt;T&gt;</code> is <a id="_idIndexMarker375"/>used similarly to <code>BufferBlock</code>, but it is intended to provide only the most recently posted message available to consumers. It can also be used to send the same value to many consumers. The message that’s posted to a <code>BroadcastBlock</code> is not removed after it has been received by a consumer.</p>
<p>The following snippet will read the same alert message each time the <code>Receive</code> method is called:</p>
<pre class="source-code">var alertBlock = new BroadcastBlock&lt;string&gt;(null);</pre>
<pre class="source-code">alertBlock.Post("Network is unavailable!");</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    Console.WriteLine(alertBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h4>WriteOnceBlock</h4>
<p>As the name<a id="_idIndexMarker376"/> suggests, <code>WriteOnceBlock&lt;T&gt;</code> can only be written to once. After the first message has been received, all calls to <code>Post</code> or <code>SendAsync</code> will be ignored by the block. No exceptions will be thrown. The data is simply discarded.</p>
<p>The following example is similar to our <code>BufferBlock</code> snippet. However, because we’re now using a <code>WriteOnceBlock</code>, only the first customer’s name will be accepted by the block:</p>
<pre class="source-code">WriteOnceBlock&lt;string&gt; customerBlock = new();</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">    await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">Console.WriteLine(await customerBlock.ReceiveAsync());</pre>
<h3>Execution blocks</h3>
<p><code>ActionBlock&lt;TInput&gt;</code> is a <code>TransformBlock&lt;TInput, TOuput&gt;</code> and <code>TransformManyBlock&lt;TInput, TOutput&gt;</code> are both <strong class="bold">propagator</strong> blocks.</p>
<h4>ActionBlock</h4>
<p><code>ActionBlock</code> is a block <a id="_idIndexMarker379"/>that accepts either <code>Action&lt;T&gt;</code> or <code>Func&lt;TInput, Task&gt;</code> as its constructor. An action on an input message is considered complete when the action returns or the task of <code>Func</code> completes. You can use an action for synchronous delegates or <code>Func</code> for async operations.</p>
<p>In this snippet, we will output customer names to the console with <code>Console.WriteLine</code>, which is provided in an <code>Action</code>, to the block:</p>
<pre class="source-code">var customerBlock = new ActionBlock&lt;string&gt;(name =&gt; </pre>
<pre class="source-code">    Console.WriteLine(name));</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   await customerBlock.SendAsync(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">customerBlock.Complete();</pre>
<pre class="source-code">await customerBlock.Completion;</pre>
<h4>TransformBlock</h4>
<p><code>TransformBlock&lt;TInput, TOutput&gt;</code> is similar to <code>ActionBlock</code>. However, as a propagator block, it returns<a id="_idIndexMarker380"/> an output value for each message that’s received. The two possible delegate signatures that can be provided to the <code>TransformBlock</code> constructor are <code>Func&lt;TInput, TOutput&gt;</code> for synchronous operations and <code>Func&lt;TInput, Task&lt;TOutput&gt;&gt;</code> for asynchronous operations.</p>
<p>The following <a id="_idIndexMarker381"/>example uses a <code>TransformBlock</code> that will convert a customer name into all capitals before the first five output values are retrieved to be displayed on the console:</p>
<pre class="source-code">var toUpperBlock = new TransformBlock&lt;string, string&gt;(name </pre>
<pre class="source-code">      =&gt; name.ToUpper());</pre>
<pre class="source-code">foreach (var customer in customers)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   toUpperBlock.Push(customer.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">for (int i = 0; i &lt; 5; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   Console.WriteLine(toUpperBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h4>TransformManyBlock</h4>
<p><code>TransformManyBlock&lt;TInput, TOutput&gt;</code> is similar to <code>TransformBlock</code> except that the block can <a id="_idIndexMarker382"/>return one or more values for every input value that’s received. The possible delegate signatures for <code>TransformManyBlock</code> are <code>Func&lt;TInput, IEnumerable&lt;TOutput&gt;&gt;</code> and <code>Func&lt;TInput, Task&lt;IEnumerable&lt;TOutput&gt;&gt;&gt;</code> for synchronous and asynchronous operations, respectively.</p>
<p>In this snippet, we will pass one customer name to <code>TransformManyBlock</code>, which will return an enumerable containing the individual characters in the customer’s name:</p>
<pre class="source-code">var nameCharactersBlock = new TransformManyBlock&lt;string, </pre>
<pre class="source-code">    char&gt;(name =&gt; name.ToCharArray());</pre>
<pre class="source-code">nameCharactersBlock.Post(customerName);</pre>
<pre class="source-code">for (int i = 0; i &lt; (customerName.Length; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   Console.WriteLine(nameCharactersBlock.Receive());</pre>
<pre class="source-code">}</pre>
<h3>Grouping blocks</h3>
<p><code>BatchBlock&lt;T&gt;</code> is a propagator block, while <code>JoinBlock&lt;T1, T2&gt;</code> and <code>BatchedJoinBlock&lt;T1, T2&gt;</code> are both source blocks.</p>
<h4>BatchBlock</h4>
<p><code>BatchBlock</code> accepts batches<a id="_idIndexMarker385"/> of data and produces arrays of output data. When creating a <code>BatchBlock</code>, you specify the input batch size. <code>BatchBlock</code> has a <code>Greedy</code> property in the <code>dataflowBlockOptions</code> optional constructor parameter that specifies<a id="_idIndexMarker386"/> the <strong class="bold">greedy mode</strong>:</p>
<ul>
<li>When <code>Greedy</code> is <code>true</code>, which is its default value, the block continues processing every input value as it is received and outputs an array as the batch size is reached. </li>
<li>When <code>Greedy</code> is <code>false</code>, incoming messages can be paused while an array of the batch size is being created.</li>
</ul>
<p><code>Greedy</code> mode usually performs better, but if you are coordinating input from multiple sources, you may need to<a id="_idIndexMarker387"/> use <strong class="bold">non-greedy mode</strong>.</p>
<p>In this example, <code>BatchBlock</code> separates student names into classes with a maximum size of 12:</p>
<pre class="source-code">var studentBlock = new BatchBlock&lt;string&gt;(12);</pre>
<pre class="source-code">// Assume studentList contains 20 students.</pre>
<pre class="source-code">foreach (var student in studentList)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   studentBlock.Post(student.Name);</pre>
<pre class="source-code">}</pre>
<pre class="source-code">// Signal that we are done adding items.</pre>
<pre class="source-code">studentBlock.Complete();</pre>
<pre class="source-code">// Print the size of each class.</pre>
<pre class="source-code">Console.WriteLine($"The number of students in class 1 is { </pre>
<pre class="source-code">    studentBlock.Receive().Count()}.");  // 12 students</pre>
<pre class="source-code">Console.WriteLine($"The number of students in class 2 is { </pre>
<pre class="source-code">    studentBlock.Receive().Count()}.");  // 8 students</pre>
<h4>JoinBlock</h4>
<p><code>JoinBlock</code> has two<a id="_idIndexMarker388"/> signatures: <code>JoinBlock&lt;T1, T2&gt;</code> and <code>JoinBlock&lt;T1, T2, T3&gt;</code>. <code>JoinBlock&lt;T1, T2&gt;</code> has <code>Target1</code> and <code>Target2</code> properties to accept inputs and returns a <code>Tuple&lt;T1, T2&gt;</code> as each pair of targets is filled. <code>JoinBlock&lt;T1, T2, T3&gt;</code> has <code>Target1</code>, <code>Target2</code>, and <code>Target3</code> properties and returns a <code>Tuple&lt;T1, T2, T3&gt;</code> as each set of targets is completed.</p>
<p><code>JoinBlock</code> also has greedy and non-greedy modes, with greedy mode being the default behavior. When you switch to non-greedy mode, all input is postponed to targets that have already received input until a complete output set is populated and sent as output.</p>
<p>In this example, we will create a <code>JoinBlock</code> to combine a person’s first name, last name, and age into the output tuple:</p>
<pre class="source-code">var joinBlock = new JoinBlock&lt;string, string, int&gt;();</pre>
<pre class="source-code">joinBlock.Target1.Post("Sally");</pre>
<pre class="source-code">joinBlock.Target1.Post("Raj");</pre>
<pre class="source-code">joinBlock.Target2.Post("Jones");</pre>
<pre class="source-code">joinBlock.Target2.Post("Gupta");</pre>
<pre class="source-code">joinBlock.Target3.Post(7);</pre>
<pre class="source-code">joinBlock.Target3.Post(23);</pre>
<pre class="source-code">for (int i = 0; i &lt; 2; i++)</pre>
<pre class="source-code">{</pre>
<pre class="source-code">   var data = joinBlock.Receive();</pre>
<pre class="source-code">   if (data.Item3 &lt; 18)</pre>
<pre class="source-code">   {</pre>
<pre class="source-code">         Console.WriteLine($"{data.Item1} {data.Item2} is a </pre>
<pre class="source-code">             child.");</pre>
<pre class="source-code">   }</pre>
<pre class="source-code">   else</pre>
<pre class="source-code">   {</pre>
<pre class="source-code">         Console.WriteLine($"{data.Item1} {data.Item2} is </pre>
<pre class="source-code">             an adult.");</pre>
<pre class="source-code">   }</pre>
<pre class="source-code">}</pre>
<h4>BatchedJoinBlock</h4>
<p>A <code>BatchedJoinBlock</code> is <a id="_idIndexMarker389"/>like a <code>JoinBlock</code> except the tuple in the output contains <code>IList</code> items of the size of the batch specified in the constructor: <code>Tuple(IList(T1), IList(T2))</code> or <code>Tuple(IList(T1), IList(T2), IList(T3))</code>. The batching concept is the same as it is for <code>BatchBlock</code>.</p>
<p>As an exercise, try to build on the <code>JoinBlock</code> example to add more people to the list, divide them into batches of four, and output the name of the oldest person in each batch.</p>
<p>Now that we have explored examples of all of the available dataflow blocks, let’s get into some real-world dataflow examples. In the next section, we will use some dataflow blocks to create a producer/consumer implementation.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Implementing the producer/consumer pattern</h1>
<p>The <a id="_idIndexMarker390"/>blocks in the TPL Dataflow library provide a fantastic platform for implementing the <strong class="bold">producer/consumer pattern</strong>. If you are not familiar with this design pattern, it involves two operations and a queue of work. The <strong class="bold">producer</strong> is the <a id="_idIndexMarker391"/>first operation. It is responsible for filling the queue with data or units of work. The <strong class="bold">consumer</strong> is<a id="_idIndexMarker392"/> responsible for taking items from the queue and acting on them in some way. There can be one or more producers and one or more consumers in the system. You can change the number of producers or consumers, depending on which part of the process is the bottleneck.</p>
<p class="callout-heading">Real-World Scenario Example</p>
<p class="callout">To relate the producer/consumer pattern to a <em class="italic">real-world scenario</em>, think about preparing gifts for a holiday gathering. You and a partner are working together to prepare the gifts. You are fetching and staging the gifts to be wrapped. You are the <em class="italic">producer</em>. Your partner is taking items from your queue and wrapping each gift. They are the <em class="italic">consumer</em>. If the queue starts to get backed up, you can find another friend (or consumer) to help with the wrapping and increase the overall throughput. If, on the other hand, you are taking too much time to find each gift to be wrapped, you can add another producer to help find them and fill the queue. This will keep the consumers busy and increase the efficiency of the process.</p>
<p>In our .NET producer/consumer example, we are going to build a simple WPF application that fetches blog posts from multiple RSS feeds and displays them in a single <code>ListView</code> control. Each row in the list will include the blog post’s date, categories, and an HTML summary of the post’s content. The producers in the application will fetch posts from an RSS feed and add a <code>SyndicationItem</code> to the queue for each blog post. We will get posts from three blogs and create a producer for each.</p>
<p>The consumers will take a <code>SyndicationItem</code> from the queue and use an <code>ActionBlock</code> delegate to create a <code>BlogPost</code> object for each <code>SyndicationItem</code>. We will create three consumers to keep up with the items that have been queued by our three producers. When the process completes, the list of <code>BlogPost</code> objects will be set as <code>ItemSource</code> for <code>ListView</code>. Let’s get started:</p>
<ol>
<li value="1">Start by<a id="_idIndexMarker393"/> creating a new WPF project with .NET 6. Name the project <code>ProducerConsumerRssFeeds</code>.</li>
<li>Open <strong class="bold">NuGet Package Manager</strong> for the solution, search for <strong class="bold">Syndication</strong> on the <strong class="bold">Install</strong> tab, and add the <strong class="bold">System.ServiceModel.Syndication</strong> package to the project. This package will make it simple to fetch data from any RSS feed.</li>
<li>Add a new class to the project named <code>BlogPost</code>. This will be our model object for each blog post to be displayed in <code>ListView</code>. Add the following properties to the new class:<pre>public class BlogPost
{
    public string PostDate { get; set; } = "";
    public string? Categories { get; set; }
    public string? PostContent { get; set; }
}</pre></li>
<li>Now, it’s time to create a service class to fetch the blog posts for a given RSS feed URL. Add a new class named <code>RssFeedService</code> to the project and add a method named <code>GetFeedItems</code> to the class:<pre>using System.Collections.Generic;
using System.ServiceModel.Syndication;
using System.Xml;
...
public static IEnumerable&lt;SyndicationItem&gt; 
    GetFeedItems(string feedUrl)
{
    using var xmlReader = XmlReader.Create(feedUrl);
    SyndicationFeed rssFeed = SyndicationFeed.Load
        (xmlReader);
    return rssFeed.Items;
}</pre></li>
</ol>
<p>The static <code>SyndicationFeed.Load</code> method uses <code>XmlReader</code> to fetch the XML from the provided <code>feedUrl</code> and transform it into <code>IEnumerable&lt;SyndicationItem&gt;</code> to return from the method.</p>
<ol>
<li value="5">Next, create <a id="_idIndexMarker394"/>a new class named <code>FeedAggregator</code>. This class will contain the producer/consumer logic that calls <code>GetFeedItems</code> for each blog and transforms the feed data for each blog post so that it can be displayed in the UI. The three blogs that we are aggregating are as follows:<ul><li>The .NET blog</li>
<li>The Windows blog </li>
<li>The Microsoft 365 blog</li>
</ul></li>
</ol>
<p>The first step with <code>FeedAggregator</code> is creating a producer method named <code>ProduceFeedItems</code> and a parent method named <code>QuseueAllFeeds</code> that will start three instances of the producer method:</p>
<pre>private async Task QueueAllFeeds(BufferBlock
    &lt;SyndicationItem&gt; itemQueue)
{
    Task feedTask1 = ProduceFeedItems(itemQueue, 
       "https://devblogs.microsoft.com/dotnet/feed/");
    Task feedTask2 = ProduceFeedItems(itemQueue, 
        "https://blogs.windows.com/feed");
    Task feedTask3 = ProduceFeedItems(itemQueue, 
        "https://www.microsoft.com/microsoft-
            365/blog/feed/");
    await Task.WhenAll(feedTask1, feedTask2, 
         feedTask3);
    itemQueue.Complete();
}
private async Task ProduceFeedItems
    (BufferBlock&lt;SyndicationItem&gt; itemQueue, string 
        feedUrl)
{
    IEnumerable&lt;SyndicationItem&gt; items = 
        RssFeedService.GetFeedItems(feedUrl);
    foreach (SyndicationItem item in items)
    {
        await itemQueue.SendAsync(item);
    }
}</pre>
<p>We are<a id="_idIndexMarker395"/> using <code>BufferBlock&lt;SyndicationItem&gt;</code> as our queue. Every producer calls <code>GetFeedItems</code> and adds each <code>SyndicationItem</code> that’s returned to <code>BufferBlock</code>. The <code>QueueAllFeeds</code> method uses <code>Task.WhenAll</code> to wait for all of the producers to finish adding items to the queue. Then, it signals to <code>BufferBlock</code> that all the producers are done by calling <code>itemQueue.Complete()</code>.</p>
<ol>
<li value="6">Next, we <a id="_idIndexMarker396"/>will create our consumer method. This method, named <code>ConsumeFeedItem</code>, will be responsible for taking a <code>SyndicationItem</code> provided by <code>BufferBlock</code> and converting it into a <code>BlogPost</code> object. Each <code>BlogPost</code> will be added to <code>ConcurrentBag&lt;BlogPost&gt;</code>. We’re using a thread-safe collection here because there will be multiple consumers adding output to the list:<pre>private void ConsumeFeedItem(SyndicationItem nextItem, 
    ConcurrentBag&lt;BlogPost&gt; posts)
{
    if (nextItem != null &amp;&amp; nextItem.Summary != null)
    {
        BlogPost newPost = new();
        newPost.PostContent = nextItem.Summary.Text
            .ToString();
        newPost.PostDate = nextItem.PublishDate
            .ToLocalTime().ToString("g");
        if (nextItem.Categories != null)
        {
            newPost.Categories = string.Join(",", 
                nextItem.Categories.Select(c =&gt; 
                    c.Name));
        }
        posts.Add(newPost);
    }
}</pre></li>
<li>Now, it’s time<a id="_idIndexMarker397"/> to tie the producer/consumer logic together. Create a method named <code>GetAllMicrosoftBlogPosts</code>:<pre>public async Task&lt;IEnumerable&lt;BlogPost&gt;&gt; 
    GetAllMicrosoftBlogPosts()
{
    var posts = new ConcurrentBag&lt;BlogPost&gt;();
    // Create queue of source posts
    BufferBlock&lt;SyndicationItem&gt; itemQueue = new(new 
        DataflowBlockOptions { BoundedCapacity = 
            10 });
    // Create and link consumers
    var consumerOptions = new Execution
        DataflowBlockOptions { BoundedCapacity = 1 };
    var consumerA = new ActionBlock&lt;SyndicationItem&gt;
        ((i) =&gt; ConsumeFeedItem(i, posts), 
            consumerOptions);
    var consumerB = new ActionBlock&lt;SyndicationItem&gt;
        ((i) =&gt; ConsumeFeedItem(i, posts), 
            consumerOptions);
    var consumerC = new ActionBlock&lt;SyndicationItem&gt;
        ((i) =&gt; ConsumeFeedItem(i, posts), 
            consumerOptions);
    var linkOptions = new DataflowLinkOptions { 
        PropagateCompletion = true, };
    itemQueue.LinkTo(consumerA, linkOptions);
    itemQueue.LinkTo(consumerB, linkOptions);
    itemQueue.LinkTo(consumerC, linkOptions);
    // Start producers
    Task producers = QueueAllFeeds(itemQueue);
    // Wait for producers and consumers to complete
    await Task.WhenAll(producers, consumerA.Completion,
        consumerB.Completion, consumerC.Completion);
    return posts;
}</pre><ol><li>The method <a id="_idIndexMarker398"/>starts by creating a <code>ConcurrentBag&lt;BlogPost&gt;</code> to aggregate the final list of posts for the UI. Then, it creates the <code>itemQueue</code> object with a <code>BoundedCapacity</code> of <code>10</code>. This bounded capacity means that no more than 10 items can be enqueued at any time. Once the queue reaches 10, all the producers must wait for the consumers to dequeue some items. This can slow the performance of the process, but it prevents potential out-of-memory issues in production code. Our sample is not in any danger of running out of memory when processing posts from three blogs, but you can see how to use <code>BoundedCapacity</code> when it is needed in your applications. You can create the queue with no <code>BoundedCapacity</code> like this:</li>
</ol><pre>BufferBlock&lt;SyndicationItem&gt; itemQueue = new();</pre><ol><li value="2">The next part of the method creates three consumers that use <code>ActionBlock&lt;SyndicationItem&gt;</code> with <code>ConsumeFeedItem</code> as the provided delegate. Each consumer is linked to the queue with the <code>LinkTo</code> method. Setting <code>BoundedCapacity</code> of the consumers to <code>1</code> tells the producers to move on to the next consumer if the current one is already busy processing an item.</li>
<li>Once the links have been established, we can start the producers by calling <code>QueueAllFeeds</code>. Then, we must <code>await</code> the producers and the <code>Completion</code> object of each consumer <code>ActionBlock</code>. By linking the completion of the producers and consumers, we don’t need to explicitly <code>await</code> the <code>Completion</code> object of the consumers:</li>
</ol><pre>var linkOptions = new DataflowLinkOptions { 
    PropagateCompletion = true, };</pre></li>
<li>The next step is<a id="_idIndexMarker399"/> to create some UI controls to display the information to our users. Open the <code>MainWindow.xaml</code> file and replace the existing <code>Grid</code> with the following markup:<pre>&lt;Grid&gt;
    &lt;ListView x:Name="mainListView"&gt;
        &lt;ListView.ItemTemplate&gt;
            &lt;DataTemplate&gt;
                &lt;Grid&gt;
                    &lt;Grid.ColumnDefinitions&gt;
                        &lt;ColumnDefinition 
                            Width="150"/&gt;
                        &lt;ColumnDefinition 
                            Width="300"/&gt;
                        &lt;ColumnDefinition 
                            Width="500"/&gt;
                    &lt;/Grid.ColumnDefinitions&gt;
                    &lt;TextBlock Grid.Column="0"  
                        Text="{Binding PostDate}"
                            Margin="3"/&gt;
                    &lt;TextBox IsReadOnly="True" 
                        Grid.Column="1"
                           Text="{Binding Categories}"
                               Margin="3"
                                 TextWrapping="Wrap"/&gt;
                    &lt;TextBox IsReadOnly="True" 
                        Grid.Column="2" 
                          Text="{Binding PostContent}"
                             Margin="3"/&gt;
                &lt;/Grid&gt;
            &lt;/DataTemplate&gt;
        &lt;/ListView.ItemTemplate&gt;
    &lt;/ListView&gt;
&lt;/Grid&gt;</pre></li>
</ol>
<p>Explaining the details of WPF, XAML, and data binding are outside the scope of this book. If you would like to learn more about WPF, check out <em class="italic">Mastering Windows Presentation Foundation</em>, by Sheridan Yeun: <a href="https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416">https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416</a>. What this markup does is create a new <code>ListView</code> control with a <code>DataTemplate</code> to define the structure of each list item in the control. For each item, we are defining either a <code>TextBlock</code> or <code>TextBox</code> to hold the values for each <code>BlogPost</code> object in the list.</p>
<ol>
<li value="9">The last thing<a id="_idIndexMarker400"/> we must do is call the <code>GetAllMicrosoftBlogPosts</code> method and populate the UI. Open <code>MainWindow.xaml.cs</code> and add the following code:<pre>public MainWindow()
{
    InitializeComponent();
    <strong class="bold">Loaded += MainWindow_Loaded;</strong>
}
<strong class="bold">private async void MainWindow_Loaded(object sender, </strong>
<strong class="bold">    RoutedEventArgs e)</strong>
<strong class="bold">{</strong>
<strong class="bold">    FeedAggregator aggregator = new();</strong>
<strong class="bold">    var items = await aggregator</strong>
<strong class="bold">        .GetAllMicrosoftBlogPosts();</strong>
<strong class="bold">    mainListView.ItemsSource = items;</strong>
<strong class="bold">}</strong></pre></li>
</ol>
<p>After <code>MainWindow</code> has loaded, the items that have been returned from <code>GetAllMicrosoftBlogPosts</code> are set as <code>mainListView.ItemsSource</code>. This will allow the data to bind to the elements in <code>DataTemplate</code>, which we defined in the XAML.</p>
<ol>
<li value="10">Now, run the project and see how things look:</li>
</ol>
<div><div><img alt="Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first time " height="821" src="img/Figure_7.2_B18552.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first time</p>
<p>As you<a id="_idIndexMarker401"/> can see, the list displays 10 blog post summaries from each of the Microsoft blogs. This is the default maximum number of items that can be returned by Microsoft’s blogs.</p>
<p>You can try experimenting by increasing or decreasing the number of producers and consumers in the project. Does adding more consumers speed up the process? Try adding some of your favorite blogs’ feeds to the list of producers and see what happens.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may have noticed that the content summary that’s returned by the RSS feeds contains HTML, and we are just rendering it as plain text in a <code>TextBox</code> control. If you would like to use a <code>RichTextBox</code> that renders the HTML properly, take a look at this sample project on CodeProject that uses a WPF <code>RichTextBox</code>: <a href="https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox">https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox</a>.</p>
<p>In the next section, we will create another example that uses different types of dataflow blocks to create a data pipeline.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor126"/>Creating a data pipeline with multiple blocks</h1>
<p>One of the <a id="_idIndexMarker402"/>biggest advantages of using dataflow <a id="_idIndexMarker403"/>blocks is the ability to link them and create a complete workflow or data pipeline. In the previous section, we saw how this linking worked between producer and consumer blocks. In this section, we will create a console application with a pipeline of five dataflow blocks all linked together to complete a series of tasks. We will leverage <code>TransformBlock</code>, <code>TransformManyBlock</code>, and <code>ActionBlock</code> to take an RSS feed and output a list of categories that are unique across all blog posts in the feed. Follow these steps:</p>
<ol>
<li value="1">Start by creating a new .NET 6 console application in Visual Studio named <code>OutputBlogCategories</code>.</li>
<li>Add the <strong class="bold">System.ComponentModel.Syndication</strong> NuGet package that we used in the previous example.</li>
<li>Add the same <code>RssFeedService</code> class from the previous example. You can right-click on the project in <code>RssFeedService</code> and copy/paste the same code we used in the previous example.</li>
<li>Add a new class named <code>FeedCategoryTransformer</code> to the project and create a method named <code>GetCategoriesForFeed</code>:<pre>public static async Task GetCategoriesForFeed(string 
    url)
{
}</pre></li>
<li>Over the next few steps, we will create the implementation for the <code>GetCategoriesForFeed</code> method. First, create a <code>TransformBlock</code> named <code>downloadFeed</code> that accepts <code>url</code> as a string and returns <code>IEnumerable&lt;SyndicationItem&gt;</code> from the <code>GetFeedItems</code> method:<pre>// Downloads the requested blog posts.
var downloadFeed = new TransformBlock&lt;string, 
    IEnumerable&lt;SyndicationItem&gt;&gt;(url =&gt;
{
    Console.WriteLine("Fetching feed from '{0}'...", 
        url);
    return RssFeedService.GetFeedItems(url);
});</pre></li>
<li>Next, create <a id="_idIndexMarker404"/>a <code>TransformBlock</code> that<a id="_idIndexMarker405"/> accepts <code>IEnumerable&lt;SyndicationItem&gt;</code> and returns <code>List&lt;SyndicationCategory&gt;</code>. This block will fetch the complete list of categories from every blog post and return them as a single list:<pre>// Aggregates the categories from all the posts.
var createCategoryList = new TransformBlock
    &lt;IEnumerable&lt;SyndicationItem&gt;, List
        &lt;SyndicationCategory&gt;&gt;(items =&gt;
{
    Console.WriteLine("Getting category list...");
    var result = new List&lt;SyndicationCategory&gt;();
    foreach (var item in items)
    {
        result.AddRange(item.Categories);
    }
    return result;
});</pre></li>
<li>Now, create another <code>TransformBlock</code>. This block will accept <code>List&lt;SyndicationCategory&gt;</code> from the previous block, remove all duplicates, and return the filtered <code>List&lt;SyndicationCategory&gt;</code>:<pre>// Removes duplicates.
var deDupList = new TransformBlock&lt;List
    &lt;SyndicationCategory&gt;, List&lt;SyndicationCategory&gt;&gt;
        (categories =&gt;
{
    Console.WriteLine("De-duplicating category 
        list...");
    var categoryComparer = new CategoryComparer();
    return categories.Distinct(categoryComparer)
        .ToList();
});</pre></li>
</ol>
<p>To use the LINQ<a id="_idIndexMarker406"/> Distinct extension method on a<a id="_idIndexMarker407"/> complex object such as <code>SyndicationCategory</code>, a custom comparer that implements <code>IEqualityComparer&lt;T&gt;</code> is required. You can get the complete source for <code>CategoryComparer</code> from this chapter’s GitHub repository: <a href="https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07">https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07</a>.</p>
<ol>
<li value="8">Next, create a <code>TransformManyBlock</code> named <code>createCategoryString</code>. This block will accept the de-duplicated <code>List&lt;SyndicationCategory&gt;</code> and return a string for each <code>Name</code> property of the categories. So, the block is invoked once for the entire list, but it will, in turn, invoke the next block in the flow once for every item in the list:<pre>// Gets the category names from the list of category 
    objects.
var createCategoryString = new TransformManyBlock
    &lt;List&lt;SyndicationCategory&gt;, string&gt;(categories =&gt;
{
    Console.WriteLine("Extracting category names...");
    return categories.Select(c =&gt; c.Name);
});</pre></li>
<li>The final <a id="_idIndexMarker408"/>block is an <code>ActionBlock</code> named <code>printCategoryInCaps</code>. This block will output each category name to the<a id="_idIndexMarker409"/> console in all caps using <code>ToUpper</code>:<pre>// Prints the upper-cased unique categories to the 
    console.
var printCategoryInCaps = new ActionBlock&lt;string&gt;
    (categoryName =&gt;
{
    Console.WriteLine($"Found CATEGORY 
        {categoryName.ToUpper()}");
});</pre></li>
<li>Now that the dataflow blocks have been configured, it’s time to link them. Create a <code>DataflowLinkOptions</code> that will propagate the completion of each block. Then, use the <code>LinkTo</code> method to link each block in the chain to the next one:<pre>var linkOptions = new DataflowLinkOptions { 
    PropagateCompletion = true };
downloadFeed.LinkTo(createCategoryList, linkOptions);
createCategoryList.LinkTo(deDupList, linkOptions);
deDupList.LinkTo(createCategoryString, linkOptions);
createCategoryString.LinkTo(printCategoryInCaps, 
    linkOptions);</pre></li>
<li>The last few steps of creating the <code>GetCategoriesForFeed</code> method involve sending <code>url</code> to the first block, marking it as <code>Complete</code>, and waiting for the last block in the chain:<pre>await downloadFeed.SendAsync(url);
downloadFeed.Complete();
await printCategoryInCaps.Completion;</pre></li>
<li>Now, open <code>Program.cs</code> and <a id="_idIndexMarker410"/>update the code so that<a id="_idIndexMarker411"/> it calls <code>GetCategoriesForFeed</code>, providing the URL for the Windows blog RSS feed:<pre>using OutputBlogCategories;
Console.WriteLine("Hello, World!");
await FeedCategoryTransformer.GetCategoriesForFeed
    ("https://blogs.windows.com/feed");
Console.ReadLine();</pre></li>
<li>Run the program and examine the list of categories in the output:</li>
</ol>
<div><div><img alt="Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog feed " height="596" src="img/Figure_7.3_B18552.jpg" width="828"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog feed</p>
<p>Now that you understand how to create a data pipeline with a series of dataflow blocks, we will look at an example of combining data from multiple sources with a <code>JoinBlock</code>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/>Manipulating data from multiple data sources</h1>
<p>A <code>JoinBlock</code> can be <a id="_idIndexMarker412"/>configured to receive different data types from two or three data sources. As each set of data types is completed, the block is completed with a <code>Tuple</code> containing all three object types to be acted upon. In this example, we will create a <code>JoinBlock</code> that accepts a <code>string</code> and <code>int</code> pair and passes <code>Tuple(string, int)</code> along to an <code>ActionBlock</code>, which outputs their values to the console. Follow these steps:</p>
<ol>
<li value="1">Start by creating a new console application in Visual Studio</li>
<li>Add a new class named <code>DataJoiner</code> to the project and add a static method to the class named <code>JoinData</code>:<pre>public static void JoinData()
{
}</pre></li>
<li>Add<a id="_idIndexMarker413"/> the following code to create two <code>BufferBlock</code> objects, a <code>JoinBlock&lt;string, int&gt;</code>, and an <code>ActionBlock&lt;Tuple&lt;string, int&gt;&gt;</code>:<pre>var stringQueue = new BufferBlock&lt;string&gt;();
var integerQueue = new BufferBlock&lt;int&gt;();
var joinStringsAndIntegers = new JoinBlock&lt;string, 
    int&gt;(
    new GroupingDataflowBlockOptions
    {
        Greedy = false
    });
var stringIntegerAction = new ActionBlock
    &lt;Tuple&lt;string, int&gt;&gt;(data =&gt;
{
    Console.WriteLine($"String received: 
        {data.Item1}");
    Console.WriteLine($"Integer received: 
        {data.Item2}");
});</pre></li>
</ol>
<p>Setting the block to non-greedy mode means it will wait for an item of each type before executing the block.</p>
<ol>
<li value="4">Now, create the links between the blocks:<pre>stringQueue.LinkTo(joinStringsAndIntegers.Target1);
integerQueue.LinkTo(joinStringsAndIntegers.Target2);
joinStringsAndIntegers.LinkTo(stringIntegerAction);</pre></li>
<li>Next, push <a id="_idIndexMarker414"/>some data to the two <code>BufferBlock</code> objects, wait for a second, and then mark them both as complete:<pre>stringQueue.Post("one");
stringQueue.Post("two");
stringQueue.Post("three");
integerQueue.Post(1);
integerQueue.Post(2);
integerQueue.Post(3);
stringQueue.Complete();
integerQueue.Complete();
Thread.Sleep(1000);
Console.WriteLine("Complete");</pre></li>
<li>Add the following code to <code>Program.cs</code> to run the example code:<pre>using JoinBlockExample;
DataJoiner.JoinData();
Console.ReadLine();</pre></li>
<li>Finally, run the application and examine the output. You will see that <code>ActionBlock</code> outputs a <code>string</code> and <code>integer</code> pair for each set of values provided:</li>
</ol>
<div><div><img alt="Figure 7.4 – Running the JoinBlockExample console application " height="436" src="img/Figure_7.4_B18552.jpg" width="1260"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Running the JoinBlockExample console application</p>
<p>That’s all <a id="_idIndexMarker415"/>there is to using the <code>JoinBlock</code> dataflow block. Try making some changes on your own, such as changing the <code>Greedy</code> option or the order in which data is added to each <code>BufferBlock</code>. How does that impact the output?</p>
<p>Before we finish up this chapter, let’s review everything we’ve learned.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Summary</h1>
<p>In this chapter, we learned all about the various blocks in the TPL Dataflow library. We started by learning a little about each block type and providing a brief code snippet for each. Next, we created a practical example that implemented the producer/consumer pattern to fetch blog data from three different Microsoft blogs. We also examined <code>TransformBlock</code>, <code>TransformManyBlock</code>, and <code>JoinBlock</code> more closely in .NET console applications. You should now feel confident in your ability to use some of the dataflow blocks in your applications to automate some complex data workflows.</p>
<p>If you would like some additional reading about the TPL Dataflow library, you can download <em class="italic">Introduction to TPL Dataflow</em> from the Microsoft Download Center: <a href="https://www.microsoft.com/en-us/download/details.aspx?id=14782">https://www.microsoft.com/en-us/download/details.aspx?id=14782</a>.</p>
<p>In the next chapter, <a href="B18552_08_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, we will take a closer look at the collections in the <code>System.Collections.Concurrent</code> namespace. We will also discover some practical uses of PLINQ in modern .NET applications.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">What type of data flow block aggregates data from two or three data sources?</li>
<li>What type of block is a <code>BufferBlock</code>?</li>
<li>What type of block is populated by a producer in the producer/consumer pattern?</li>
<li>What method links the completion of two blocks?</li>
<li>What method is called to signal that our code is done adding data to a source block?</li>
<li>What is the async equivalent of calling <code>Post()</code>?</li>
<li>What is the async equivalent of calling <code>Receive()</code>?</li>
</ol>
</div>
</div>
</body></html>