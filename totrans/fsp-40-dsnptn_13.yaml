- en: Chapter 13. Troubleshooting Functional Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I touch on an important aspect of the functional-first programming
    approach that kicks in when the F# code is in the process of being developed.
    It so happens that the troubleshooting of the functional-first code differs from
    the troubleshooting of, say, imperative code. The goal of this chapter is to share
    with you some of my observations collected while authoring idiomatic F# code.
    It should leave you equipped with some considerations and a few techniques for
    effective bug squashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reasons for idiomatic F# having a low defect rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using REPL and explorative programming style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressing some compile-time problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressing run-time problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why idiomatic F# admits less defects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without going back to the side-by-side comparison of functional-first and other
    paradigms available for F# programmer to employ, I will reiterate the (mostly
    anecdotal) point that an idiomatic F# code admits fewer defects than equivalent
    implementations based on object-oriented or imperative paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous twelve chapters have contributed significantly to this judgment.
    But let me briefly revisit some considerations in order to conclude that:'
  prefs: []
  type: TYPE_NORMAL
- en: This decrease in the defect rate is not something taken for granted. This artifact
    is what you gain in exchange for the pain of mind-bending while acquiring functional
    thinking habits and the following rigor in applying them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of F# by itself is not a remedy from the defects; there is still enough
    space for bugs to sneak into the code, although in significantly lower amounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical F# bugs are quite specific and often may be anticipated and avoided
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduced bug rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This observation is very important and stems from a few factors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The language''s succinctness contributes to the reduced bug rate literally:
    fewer lines of code carry fewer chances for bugs to sneak in and stay unnoticed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict static typing and type inference simply do not allow oversights that
    are typical for dynamic languages, when the misplacement of types may lead to
    bugs that are hard to detect and eliminate later on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raised level of abstraction, library higher-order functions, and immutability.
    All of these contribute to eliminating many bugs that come from the unpredictable
    execution order of stateful code, more "moving parts" involved, and needless re-implementation
    of core library facilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevalence of F# compile-time errors over run-time bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntactic correctness of a program written using a conventional programming
    language usually does not prompt any assumptions about the outcome of its execution.
    Generally speaking, these two factors are not correlated.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that this is not the case for the implementations following the F#
    functional-first approach. There is plenty of anecdotal evidence on the Internet
    in F# and non-F# functional programming context stating that
  prefs: []
  type: TYPE_NORMAL
- en: '*"if it compiles it works"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, this **Haskell wiki post** ([https://wiki.haskell.org/Why_Haskell_just_works](https://wiki.haskell.org/Why_Haskell_just_works)
    ) states a similar observation in relation to programs written in the allied Haskell
    programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, strict static typing and type inference may catch many random defects
    at compile-time, shielding programmers from the costly process of observing a
    problem at run-time and then often performing lengthy and skill-demanding activities
    known as *debugging* in order to nail down the genuine cause of the problem at
    the source code level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another extremely important factor is to implement the algorithm by sticking
    to a handful of idiomatic patterns supported by core libraries instead of manipulating
    lower-level language constructs. To give you a better idea of what I''m talking
    about here, try to answer this question: Which approach carries more chances for
    implementation mistakes, folding a sequence with `Seq.fold` or materializing the
    sequence into the array and traversing elements using indexing while aggregating
    the result in a mutable value? The right answer easily translates into what has
    been mentioned on many occasions throughout the book: the positive effect of "minimizing
    the amount of moving parts" in a functional paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: Still, your fold should be the rightly one for the overall correctness of the
    implementation from an algorithmic standpoint. And F# offers just another bug-squashing
    facility. This facility allows the developer to perform fast, easy, and frequent
    quick checks along the course of implementation with the help of so-called **REPL**
    covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using REPL and the explorative programming style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REPL** stands for **Read-Evaluate-Print Loop** ([https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)
    ) and represents a manner of program development that quite deviates from what
    old-style C# programmers were used to, namely *edit source code - build the compiled
    program version - run and debug loop* . From its very early days, F# has introduced
    **interactive development manner** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index)
    ). However, more broadly, it equips the F# developer with just another programming
    style collectively referred to as **exploratory programming** ([https://en.wikipedia.org/wiki/Exploratory_programming](https://en.wikipedia.org/wiki/Exploratory_programming)
    ). F# offers a tool known as **F# Interactive** (32-bit `fsi.exe` or 64-bit-capable
    `fsiAnyCPU.exe` ) both as a standalone, or as a part of Visual Studio reachable
    from any F# Project. It allows you to evaluate any F# expression presented in
    the form of a standalone F# script or just a selected F# program fragment in a
    dynamically built run-time environment.'
  prefs: []
  type: TYPE_NORMAL
- en: F# Interactive is a tool of immense versatility. Its use cases span a quick
    check of just implemented one-liner function behavior to running F#-implemented
    microservices in the production environment. Yes, I'm not kidding; the quality
    of the F# Interactive compiler is pretty much the same as that of normal build
    compiler. At one time, the whole Jet.com microservices architecture was implemented
    as a set of F# scripts, each executed by a dedicated `fsi` process.
  prefs: []
  type: TYPE_NORMAL
- en: The habit of doing quick checks while developing any F# code by evaluating this
    or that fragment in `fsi` may significantly help in achieving practically bug-free
    F# implementations. I highly recommend that you acquire and follow F# explorative
    programming style in your day after day practice.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing some compile-time problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although REPL can help explore and tweak correct F# code, it keeps compiler
    errors intact, as evaluating a code snippet includes compilation by the F# compiler
    embedded into `fsi` . And I must admit that some compile-time errors may puzzle
    an inexperienced F# developer. Here, I will analyze several kinds of such errors
    and provide advice on how to get rid of them. Before I do this, you should keep
    in mind that because an initial defect usually gets ingested by type inference
    as correct code, the reported compilation error is in line with that convoluted
    type inference determination. That is, type inference often masks the authentic
    cause of an error. We will go over some occasions of this layout soon.
  prefs: []
  type: TYPE_NORMAL
- en: The if-then return value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the easiest-to-grasp occurrences of the similar convoluted determination
    takes place for the result type of F# `if...then...` expressions. Usually, it
    seems counterintuitive that this result cannot be anything but `unit` . Let's
    look at why this happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, I chose the specific (`<` ) comparison operator within
    the implementation just to keep things simple (`Ch13_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the inferred signature of function `f` representing the result of evaluating
    the F# expression `if-then-else` is `f: ''a -> ''a -> ''a` (requires comparison),
    which makes perfect sense (it should not take much effort to recognize a generic
    implementation of the `min` function in the preceding code).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at what happens if I omit the `else` part (`Ch13_1.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the inferred signature of `f''` is `f'': unit->unit->unit` ; in other words,
    both arguments and the result must be of type `unit` . What gives? The reasoning
    behind the seemingly counterintuitive type inference outcome is, in fact, to continue
    making perfect sense. Let''s think what value the function `f''` must return when
    the condition `a < b` is `false` ? The compiler, in the absence of explicit directions,
    decides that it must be `unit` . But wait a minute; shouldn''t both branches of
    the `if-then-else` expression be of the same type? This condition can be only
    fulfilled if argument `a` is of type `unit` , which means argument `b` must be
    of type `unit` as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fine; but what would happen if I try to push type inference into certain ways,
    for example, forcefully attempting `a` to be of generic type `''a (Ch13_1.fsx)`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, what if we try pushing `a` in the direction of being less generic by forcing
    it to be of a concrete type, for example, `int (Ch13_1.fsx)` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Turns out both attempts are futile, as consideration about the `unit` return
    type of the omitted `else` branch is still valid. In the first case, the compiler
    will just make a nasty warning pointing that
  prefs: []
  type: TYPE_NORMAL
- en: '*This construct causes code to be less generic than indicated by the type annotations.
    The type variable `''a` has been constrained to be type `''unit''` .*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the second case, from a compiler standpoint, there's a plain and simple error
  prefs: []
  type: TYPE_NORMAL
- en: '*This expression was expected to have type unit but here has type `int` .*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So, how should we handle the `if...then...` expressions? The moral is that this
    short form of conditional statement may be used only in cases where a side-effect
    is needed. Good examples would be logging some diagnostics or changing a mutable
    value. For cases where a genuine non-`unit` result has to be returned, the full-blown
    `if-then-else` expression must be evaluated with both branches returning values
    of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Value restriction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This compile problem usually makes intermediate level F# developers who have
    grasped and proudly put to use F# features such as *partial application* and *automatic
    generalization* stumble. Imagine that you came out with a powerful data processing
    algorithm and are implementing it, enjoying the power and beauty of idiomatic
    F# code in the process. At some moment, you realize that you need a function that
    takes a list of lists and finds out whether all element lists are empty or not.
    Not a problem for a seasoned functional programmer like you, right? So you coin
    something like this (`Ch13_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Surprise! It does not compile with the compiler warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Value restriction. The value `''allEmpty''` has been inferred to have generic
    type `val allEmpty : (''_a list list -> bool) when ''_a:equality` Either make
    the arguments to `''allEmpty''` explicit or, if you do not intend for it to be
    generic, add a type annotation.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'And you (I should admit I did this on multiple occasions in the past) first
    stare at this mess in disbelief as the F# compiler has accurately inferred your
    intent but somehow dislikes it. Then you Google "f# value restriction" and get
    referred to **MSDN Automatic Generalization** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization)
    ), where you are told that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The compiler performs automatic generalization only on complete function definitions
    that have explicit arguments, and on simple immutable values.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is followed by practical recipes of working around a sudden problem. You
    try this advice and get the problem fixed, but you are left with the aftertaste
    of some black magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'For me, the eye-opener was reading through this excellent blog post: **Finer
    Points of F# Value Restriction** ([https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/](https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/)
    ). I will demonstrate the hidden dangers of generalization applied to mutable
    values that may create a motive for you to read this blog post and understand
    the rationale behind the F# compiler behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a seemingly innocuous code fragment here (`Ch13_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Guess what would be the printed `x` value upon this fragment execution? That
    would be `["a"]` , right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrong; `[]` is what happens! The cause of this is that `gr` , despite appearing
    as a value of type `''a list ref` , is, in fact, a type function. Used on the
    left-hand side of the `:=` operator, it just brings a fresh unbound reference
    instance. Used on the right-hand side of operator `!` , it brings just another
    fresh reference instance that refers to an empty list, `[]` . In order to achieve
    the intuitively expected behavior, we need to bind `gr` applied to the type argument
    string to the concrete typed variable `cr` , and then the latter, being a normal
    reference, will behave as expected (`Ch13_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the printed value is `["a"]` indeed. Imposing a value restriction error
    in all cases where the situation deviates from the safest use case compiler protects
    developers from the surprise code behavior of the kind demonstrated earlier. Getting
    back to my initial sample, the possible remedial action can be any of the following
    (`Ch13_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Imperfect pattern matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many seemingly counterintuitive F# compile-time errors and warnings belong
    to the field of pattern matching. For example, take a look the following naive
    detection of the integer argument sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite seeming completeness, this produces the compiler''s warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*incomplete pattern matches on this expression*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Turns out that the F# compiler, if presented with the `when` guards, assumes
    that this construction designates an incomplete match case by definition. This
    is why regardless of the fact that the given set of cases is semantically complete,
    the compiler considers the function definition incomplete. Simply removing the
    excessive last `when` guard immediately fixes the problem (`Ch13_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common related problem is unreachable matching rules. Most of the time,
    unreachable matching rules get into play when the programmer mistakenly uses a
    variable instead of a literal in the sequence of rules, creating a premature catch-all
    case. In such cases, the compiler uses benign warnings, although almost always,
    the run-time results are messed-up. Therefore, perhaps denoting these occasions
    as errors would be a better design choice. A couple of years ago I wrote a **blog
    post** ([https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/](https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/)
    ) on this matter, which I reproduce here as the illustration of the problem in
    the following snippet (`Ch13_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This may trick you into expecting the `Tick` output followed by `Tack` , but
    in fact, the `Tick` output is to be followed by `Tock` !
  prefs: []
  type: TYPE_NORMAL
- en: 'The F# compiler issues two warnings for the preceding fragment. The first warning
    prompts you that typo `Tock` is taken as a variable and not a literal, like literals
    of type `TickTack` in two other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Uppercase variable identifiers should not generally be used in patterns, and
    may indicate a misspelt pattern name*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The second warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*This rule will never be matched*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: directly indicates the outcome caused by the typo.
  prefs: []
  type: TYPE_NORMAL
- en: The moral here is that the F# developer should be attentive to warnings. Treating
    rule unreachability by the compiler as an error would be more adequate perhaps.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing run-time problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mantra " *if it compiles, it works* " helps followers score amazingly well
    in time-to-market ratings for enterprise software development.
  prefs: []
  type: TYPE_NORMAL
- en: Taking Jet.com as an example of building green field e-commerce platform implementation,
    it has really condensed the path from zero to **minimum viable product** ( **MVP**
    ) in less than a year. Release of the platform to the production mode took place
    in a bit more than a year from the reception.
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean following a functional-first approach is a software development
    silver bullet? Surely not on an absolute scale, although on a relative scale,
    the improvements are just great.
  prefs: []
  type: TYPE_NORMAL
- en: Why is the success not exhaustive? The thing is that the practice requires transition
    from gory ideas to mundane implementation issues. No matter how accurate our implementations
    are, there are always dark corners exist where unexpected problems may lurk.
  prefs: []
  type: TYPE_NORMAL
- en: Let me demonstrate this with a sample taken from F# enterprise development practice
    at Jet.com. Jet represents an innovative e-commerce platform, bringing together
    many business areas, such as Internet ordering, retail selling, warehousing, finance,
    accounting, transportation, you name it. Each of these areas usually carries its
    own unique metadata classifications; so, in order to run them side by side, one
    of the most common operations within the implementation is mapping. And the generally
    accepted practice of using unique non-clashing identifications is based on GUIDs
    or **Global Unique Identifiers** ([https://en.wikipedia.org/wiki/Globally_unique_identifier](https://en.wikipedia.org/wiki/Globally_unique_identifier)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Realistically assuming that quite frequently, enterprise software deals with
    dictionaries and caches using GUIDs as access keys, let's look at how good the
    core .NET library `System.Guid` implementation for the purpose would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here goes a quite simplistic explorative implementation using a dictionary
    that has instances of the `System.Guid` type as keys. I created a simple `dictionary`
    based on the standard F# core library implementation having type `IDictionary<Guid,int>`
    . I populated it with the size number of pairs (`Guid,int` ), just for the sake
    of simplicity. Now, I will imitate a big `trials` number of random accesses to
    the dictionary using array `keys` as a level of indirection and measuring the
    performance. The following snippet shows the composition of the required code
    pieces (`Ch13_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this snippet through FSI with timing turned on yields the performance
    indicators shown in the following screenshot (only the valuable output is shown
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Addressing run-time problems](img/Image00066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using native System.Guid to access a dictionary
  prefs: []
  type: TYPE_NORMAL
- en: '10 million accesses for 6.445 seconds translates into a bit higher than 1.5
    million accesses per second. Not too fast. Let''s take it for the baseline. Also,
    a worrying sign is a number of garbage collections that took place: 287 per 10000
    accesses is not light.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without digging dipper into the causes of the observed code behavior here,
    let me just show the results of the findings performed for Jet.com in an attempt
    to improve the watermark. I will introduce a simple change instead of using the
    genuine `System.Guid` type that is a quite complicated Windows system data structure
    as a dictionary key, I will use the representation of the GUID value as a hexadecimal
    string that is leftover when the canonical presentation is stripped of dashes.
    For example, the `f4d1734c-1e9e-4a25-b8d9-b7d96f48e0f` GUID will be represented
    as a `f4d1734c1e9e4a25b8d9b7d96f48e0f` string. This will require minimal changes
    to the previous snippet (`Ch13_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, I will just create a new `keys''` indirection layer made from corresponding
    parts of `keys` via a simple data conversion. Turning to FSI with this change
    brings a big surprise reflected in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Addressing run-time problems](img/Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Switching from System.Guid to string in order to access a dictionary
  prefs: []
  type: TYPE_NORMAL
- en: Compared to the baseline, the new access rate constitutes 16.4 millions accesses
    per second almost 11 times better! Also, garbage collection experiences a five-fold
    improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Now remember that mappings based on `System.Guid` are ubiquitous for the platform
    and you can imagine the amount of impact from the above simple change to the overall
    platform performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter should leave you prepared for the defect type displacement taking
    place in the functional-first development in comparison to other development paradigms.
    A decreased rate of run-time errors typical to F# code shortens the time to market
    for developed systems and releases development resources for performance optimizations
    if they are deemed necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of the book, where I equipped you with a whole slew
    of patterns of idiomatic F# use. The key assumption that the book makes is that
    such use requires from developers that come from other programming paradigms a
    certain shift in thinking habits, a distinct angle of seeing problems, and correspondent
    patterns and techniques populating the functional programmer tool belt. At this
    point you should be able to approach thinking through any problem by decomposing
    it into a handful of known building blocks and then composing the solution with
    appropriate functions and combinators. You also were shown the benefits of using
    standard F# algebraic data types over crafting custom .NET classes. Rely on patterns
    that you have acquired here in your functional designs; retain, recall, and reuse
    them in your day-to-day practices.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that this book may guide you onto a path to the field of idiomatic functional
    programming. Good luck getting there!
  prefs: []
  type: TYPE_NORMAL
