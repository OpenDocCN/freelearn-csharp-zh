- en: '*Chapter 12*: Unit Testing Async, Concurrent, and Parallel Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing asynchronous, concurrent, and parallel code can be a challenge
    for .NET developers. Fortunately, there are some steps you can take to help ease
    the difficulty. This chapter will provide some concrete advice and useful examples
    of how developers can unit test code that leverages multi-threaded constructs.
    These examples will illustrate how unit tests can still be reliable while covering
    code that performs multithreaded operations. In addition, we will explore a third-party
    tool that facilitates the creation of automated unit tests that monitor your code
    for potential memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests for your .NET projects is important to maintain the health
    of your code base as it grows and evolves. When developers make changes to code
    that has unit test coverage, they can run the existing tests to feel confident
    that no existing functionality has been broken by the code changes. Visual Studio
    makes it simple to create, run, and maintain unit test projects throughout the
    life cycle of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The **Test Explorer** window in Visual Studio can detect and run unit tests
    created with Microsoft’s MSTest framework, as well as third-party frameworks such
    as NUnit and xUnit.net. Whether you are developing applications for Windows, mobile
    devices, or the cloud, you should always plan to develop a suite of unit tests
    for your projects and define goals for test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter assumes that you have some familiarity with unit testing and good
    unit testing practices. For a good primer on unit testing projects with xUnit.net,
    you can review Microsoft’s documentation at [https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test](https://docs.microsoft.com/dotnet/core/testing/unit-testing-with-dotnet-test)
    and at [https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing](https://docs.microsoft.com/visualstudio/test/getting-started-with-unit-testing).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing concurrent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing parallel code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for memory leaks with unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be armed with tools and advice to help
    you confidently write modern multithreaded code with unit test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The unit tests in this chapter are created with the **xUnit.net** unit testing
    framework. You can achieve the same results with your unit testing framework of
    choice, including **MSTest** and **NUnit**. The memory unit testing framework
    we will be demonstrating later in this chapter uses xUnit.net, but it also supports
    MSTest and NUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.2 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JetBrains dotMemory Unit standalone console runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by examining how to write unit tests that cover `async` C#
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing asynchronous code requires the same approach as writing good asynchronous
    C# code. If you need a refresher on how to work with `async` methods, you can
    review [*Chapter 5*](B18552_05_ePub.xhtml#_idTextAnchor082).
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing a unit test for an `async` method, you will use the `await` keyword
    to wait for the method to complete. This requires that your unit test method is
    `async` and returns `Task`. Just like other C# code, creating `async void` methods
    is not permitted. Let’s look at a very simple test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This probably looks like most tests you have written for synchronous code.
    There are only a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the test method is `async` and returns `Task`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the call to `GetBookAsync` uses the `await` keyword to wait for the
    result. Otherwise, this test follows the typical **Arrange–Act–Assert** pattern
    and tests the result as you typically would.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a simple project to try this in Visual Studio and see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new `AsyncUnitTesting`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Creating a new Class Library project ](img/Figure_12.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Creating a new Class Library project
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add a test project to the `AsyncUnitTesting.Tests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Adding an xUnit Test project to the solution ](img/Figure_12.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Adding an xUnit Test project to the solution
  prefs: []
  type: TYPE_NORMAL
- en: In the `BookOrderService.cs`. When Visual Studio asks whether you want to rename
    all uses of `Class1`, select **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `BookOrderService` class and add an `async` method named `GetCustomerOrdersAsync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes `customerId` as a parameter and returns `List<string>` containing
    the order numbers. If `customerId` provided is less than `1`, `ArgumentException`
    is thrown. Otherwise, a list of six order numbers is created, with `customerId`
    as the prefix. After injecting `Task.Delay` of `1500` milliseconds, `orders` is
    returned to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, right-click the **AsyncUnitTesting.Tests** project and click on **Add**
    | **Project Reference**. In the **Reference Manager** dialog, check the box for
    the **AsyncUnitTesting** project and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, rename the `UnitTest1` class `BookOrderServiceTests` and open the file
    in the Visual Studio editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s time to start adding tests. Let’s start by testing the happy path. Add
    a test method named `GetCustomerOrdersAsync_Returns_Orders_For_Valid_CustomerId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After calling `GetCustomerOrdersAsync` with `customerId` of `3`, our code has
    three assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’re checking that the list of orders is not `null`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we’re checking that the list contains some items.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we check that the first order starts with `customerId`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on **Test** | **Run All Tests** to ensure that this test passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s write that same test with a new `customerId` but without `async` and
    `await`. Assume that you have some legacy test code that just cannot be refactored,
    and you have to test the `GetCustomerOrdersAsync` method. That code would look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test method is not `async` and returns `void`. Instead of using `await`
    to allow `GetCustomerOrdersAsync` to run to completion, we are calling `GetAwaiter().GetResult()`.
    The setup and assertion sections of the code remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Test** | **Run All Tests** to make sure both of our tests are *green*
    (passing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we are going to test the exception case. Create another test but pass
    a negative `customerId` to the method under test. The entire call to `GetCustomerOrdersAsync`
    will be wrapped in an `Assert.ThrowsAsync<ArgumentException>` invocation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute **Run All Tests** one last time and ensure that they are all passing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Viewing three passing tests in Test Explorer ](img/Figure_12.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Viewing three passing tests in Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: We now have three passing unit tests for the `GetCustomerOrdersAsync` method.
    The first two are essentially testing the same thing, but they are demonstrating
    two different ways of writing the test. You will be using the `async` method in
    most cases. The final test provides test coverage of the code that throws `ArgumentException`.
    If you are using Visual Studio Enterprise edition or a third-party tool such as
    dotCover, you can use their visualization tools to view which parts of your code
    are covered by unit tests and which are not.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some familiarity with testing `async` methods, let’s move on
    to working with concurrent data structures in a system under test.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing concurrent code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will adapt a sample from [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146),
    to add unit test coverage. When your code uses `async` and `await`, adding reliable
    test coverage is very simple. At the end of the example, we will examine an alternative
    method of waiting to perform your assertions by using the `SpinLock` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an xUnit.net unit test project for the `ConcurrentOrderQueue`
    project and add several tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by copying the **ConcurrentOrderQueue** project from [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).
    You can get the source code from the GitHub repository if you do not already have
    a copy of it: [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter09/ConcurrentOrderQueue).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **ConcurrentOrderQueue** solution in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the solution file in `ConcurrentOrderQueue.Tests`. Make sure to
    add the new project inside the **ConcurrentOrderQueue** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your new test project also appears as a folder under the **ConcurrentOrderQueue**
    project, right-click on the **ConcurrentOrderQueue.Tests** folder and select **Exclude
    from Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UnitTest1` class `OrderServiceTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to control which `CustomerId` values are used to generate the list
    of orders, we are going to create a new overload for the public `EnqueueOrders`
    method in the `OrderService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes a list of `customerId` and calls the private `EnqueueOrders`
    method for each of them, adding `Task` from each call to `List<Task>` to be awaited
    before exiting the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now optimize the parameterless version of `EnqueueOrders` by having
    it call this new overload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new unit test method in the `OrderServiceTests` class to test `EnqueueOrders`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test will call `EnqueueOrders` with three customer IDs. After `EnqueueOrders`
    and `DequeueOrders` are complete, we assert that the `orders` collection is not
    `null`, contains some orders, and contains orders with all three of our customer
    IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Run the new test and ensure that it passes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This covers the basics of working with a system under test that uses `ConcurrentQueue`.
    Let’s consider another scenario where we are working with code but cannot use
    `async` and `await` in our tests. Perhaps the method under test is not `async`.
    One of the tools at our disposal is the `SpinWait` struct. This struct contains
    some methods that provide non-locking mechanisms for waiting in our code. We will
    use `SpinWait.WaitUntil()` to wait until all orders have been enqueued.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will demonstrate how to reliably test the result of a method
    when you cannot explicitly wait for it to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new public variable to the `OrderService` class to expose
    the number of customers whose orders have been enqueued:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, increment `EnqueueCount` at the end of the private `EnqueueOrders` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create an `EnqueueOrdersSync` public method to be called from our new
    test. It will be similar to the public `EnqueueOrders` method. The differences
    between the previous example and this one are that it is not `async`, it resets
    `EnqueueCount` to `0`, and it does not wait for the tasks to be completed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a new synchronous test method to test `EnqueueOrdersSync`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The differences are highlighted in the preceding code snippet. `SpinWait.SpinUntil`
    will wait without locking until the `orderService.EnqueueCount` value matches
    the `orderNumbers.Count`. If you want to ensure it doesn’t spin forever, there
    are overloads for providing a timeout period as either `TimeSpan` or in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests again and make sure that they both pass. We now have unit test
    methods that are testing the two methods available to enqueue orders in the `OrderService`
    class. In your own projects, you would add more scenarios to increase the test
    coverage of the class. You should always test things, such as how your code handles
    invalid input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important to remember when unit testing multithreaded code that if you
    are not using `async` and `await` or some other synchronization method, your tests
    are going to be unreliable. Having unreliable tests is as bad as having no tests
    at all. Be sure to design and develop your unit tests with care. It is best to
    use `async`/`await` wherever possible for maximum reliability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will build some unit tests for code that use the `Parallel.ForEach`
    and `Parallel.ForEachAsync` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing parallel code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating unit tests for code that use `Parallel.Invoke`, `Parallel.For`, `Parallel.ForEach`,
    and `Parallel.ForEachAsync` is relatively straightforward. While they can run
    processes in parallel when conditions are suitable, they run synchronously relative
    to the invoking code. Unless you wrap `Parallel.ForEach` in a `Task.Run` statement,
    the flow of code will not continue until all iterations of the loop have been
    completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one caveat to consider when testing code that uses parallel loops is the
    type of exceptions to expect. If an exception is thrown within the body of one
    of these constructs, the surrounding code must catch `AggregateException`. The
    exception to this `Exception` rule is `Parallel.ForEachAsync`. Because it is called
    with `async`/`await`, you must handle `Exception` instead of `AggregateException`.
    Let’s create an example to illustrate these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ParallelExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename `Class1` `TextService` and create a method named `ProcessText` in this
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method accepts a list of strings and appends `Environment.TickCount` to
    each value inside a `Parallel.ForEach` loop. If any of the strings are `null`
    or empty, `Exception` will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `async` version of `ProcessText` and name it `ProcessTextAsync`.
    The `async` version uses `Parallel.ForEachAsync` to perform the same operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a new `ParallelExample.Tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `UnitTest1` class `TextServiceTests` and add a **Project** reference
    to the **ParallelExample** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will add two unit tests to test the `ProcessText` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first test calls `ProcessText` with a list of five-string values containing
    fruit names. The assertion checks that `results.Count` matches `fruits.Count`.
  prefs: []
  type: TYPE_NORMAL
- en: The second test makes the same call, but one of the `fruits` string values is
    empty. This test will ensure that `AggregateException` is thrown by the `Parallel.ForEach`
    loop in the method under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more tests. These two tests will run the same assertions on the `ProcessTextAsync`
    method. The difference here is that `Assert.ThrowsAsync` must check for `Exception`
    instead of `AggregateExceptoin` because we are using `async`/`await`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run all four tests with the **Run All Tests in View** button in the **Text
    Explorer** window. If the window is not visible in Visual Studio, you can open
    it from **View** | **Test Explorer**. All tests should pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Four tests passing in the TextServiceTests class ](img/Figure_12.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Four tests passing in the TextServiceTests class
  prefs: []
  type: TYPE_NORMAL
- en: You now have two tests for each of the methods for processing text in the `TextService`
    class. They are testing valid and invalid input data successfully. Spend some
    time on your own to examine how the test coverage could be expanded. What other
    types of input could be used?
  prefs: []
  type: TYPE_NORMAL
- en: In the final section of this chapter, we will examine how you can build memory
    leak detection into your automated unit test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for memory leaks with unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory leaks are by no means unique to multithreaded code, but they certainly
    can happen. The more code that is executing in your application, the more likely
    it is that some objects are going to leak. The company that makes the popular
    .NET tools, **ReSharper** and **Rider**, also makes a tool called **dotMemory**
    for analyzing memory leaks. While these tools are not free, JetBrains does offer
    its memory unit testing tool for free. It’s called **dotMemory Unit**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a dotMemory Unit test to check whether we are
    leaking one of our objects. You can run these dotMemory Unit tests for free with
    .NET on the command line by downloading the standalone test runner here: https://www.jetbrains.com/dotmemory/unit/.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about using the free tooling, you can read about it here:
    [https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml](https://www.jetbrains.com/help/dotmemory-unit/Using_dotMemory_Unit_Standalone_Runner.xhtml).
    JetBrains also has integration for dotMemory Unit in its ReSharper and Rider tools.
    If you have licenses for either of these tools, it greatly simplifies the process
    of running these tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an example demonstrating how to create a unit test that determines
    whether objects are being leaked in memory by the code under test:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new `MemoryExample`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename `Class1` `WorkService` and add another class named `Worker`. Add the
    following code to the `Worker` class. The `DoWork` method in this class will handle
    a `TimerElapsed` event in `WorkService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class implements `IDisposable`, so we can use it with a `using` statement
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `WorkWithTimer` method to the `WorkService` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code has some problems that will prevent the `worker` object from being
    released from memory. The `timer` object is not stopped or disposed of, and the
    `Elapsed` event is never unhooked. When we check for leaks, we should find some.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `MemoryExample.Tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a project reference to **MemoryExample** and add a **NuGet package reference**
    to **JetBrains.dotMemoryUnit**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Referencing the dotMemoryUnit NuGet package ](img/Figure_12.5_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Referencing the dotMemoryUnit NuGet package
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `UnitTest1` class in `WorkServiceMemoryTests` and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A few lines are highlighted in the previous snippet. An `assembly` attribute
    must be added to suppress an error in the console runner when using xUnit.net
    with dotMemory Unit. After calling the method under test, `WorkWithTimer`, we
    are calling `GC.Collect` to attempt to clean all unused managed objects from memory.
    Finally, `dotMemory.Check` is called to determine whether there are any objects
    of the `Worker` type remaining in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command either in `.\` characters are required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The path to .NET should be the same on your system. You will need to replace
    the path to `MemoryExample.Tests.dll` with your own output path where this DLL
    resides. The test should fail, with one `Worker` object remaining in memory, and
    your output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Reviewing the failed dotMemoryUnit test run ](img/Figure_12.6_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Reviewing the failed dotMemoryUnit test run
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix the problem, make the following changes to your `WorkService.WorkWithTimer`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make sure the `worker` object instance is released, we’re initializing `timer`
    in a `using` statement, stopping `timer` when it’s finished, and unhooking the
    `timer.Elapsed` event handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the `dotMemory` Unit command again. The test should succeed now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The dotMemoryUnit test runs successfully ](img/Figure_12.7_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – The dotMemoryUnit test runs successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'That concludes this example and the section on memory unit tests. If you would
    like to read more about dotMemory Unit, you can find its documentation here: [https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml](https://www.jetbrains.com/help/dotmemory-unit/Introduction.xhtml).
    The command-line tool can also be deployed to a **continuous integration** (**CI**)
    build server to execute these tests as part of a CI build process.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up by reviewing what we have learned in the final chapter of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about some tools and techniques to unit test .NET
    projects that contain different multithreaded constructs. We started by discussing
    the best methods for testing C# code that employs `async`/`await`. This will be
    common in modern applications, and it is important to have a suite of automated
    unit tests covering your `async` code.
  prefs: []
  type: TYPE_NORMAL
- en: We also walked through some examples of unit tests that test methods that leverage
    parallel constructs and concurrent data structures. In the last section of the
    chapter, we learned about dotMemory Unit from JetBrains. This free unit testing
    tool adds the ability to detect objects leaked by methods under test. It is a
    powerful automation tool for synchronous and asynchronous .NET code.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final chapter. Thanks for following along on this multithreading
    journey. Hopefully, you didn’t encounter any deadlocks or race conditions along
    the way. This book provided guidance for your path through the modern, multithreaded
    world of .NET and C#. You should now have an understanding of the asynchronous,
    concurrent, and parallel methods and structures to build fast and reliable .NET
    applications. If you want to learn more about these topics, I suggest reading
    the *.NET Parallel Programming* blog ([https://devblogs.microsoft.com/pfxteam/](https://devblogs.microsoft.com/pfxteam/))
    and relying on the .NET documentation ([https://docs.microsoft.com/dotnet/](https://docs.microsoft.com/dotnet/)).
    You can search for documentation on any of the topics in this book to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the keyword used in .NET attributes that decorate an `xUnit.net` test
    method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method can you use to add `await` to your code without locks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of exception should you expect in unit test assertions when the method
    under test contains a `Parallel.ForEach` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of exception should you expect in unit test assertions when the method
    under test contains a `Parallel.ForEachAsync` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check that an object isn’t `null` in an xUnit.net assertion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the window in Visual Studio where unit tests can be managed
    and run?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three most popular unit test frameworks for .NET?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which JetBrains products provide tooling to run dotMemory Unit tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
