- en: Reactive Programming Patterns and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式编程模式和技巧
- en: In the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), we delved into functional programming and
    learned about **Func**, **Predicate**, **LINQ**, **Lambda**, **anonymous functions**,
    **expression trees**, and **recursion**. We also looked at the implementation
    of the strategy pattern using functional programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章（[第 9 章](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)，*函数式编程实践*）中，我们深入探讨了函数式编程，并学习了
    **Func**、**Predicate**、**LINQ**、**Lambda**、**匿名函数**、**表达式树**和**递归**。我们还探讨了使用函数式编程实现策略模式。
- en: This chapter will explore the use of reactive programming and provides a hands-on
    demonstration of reactive programming using the C# language. We will delve into
    the principles and models of reactive programming and discuss the `IObservable`
    and `IObserver` providers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨反应式编程的使用，并通过使用 C# 语言提供反应式编程的动手演示。我们将深入研究反应式编程的原则和模型，并讨论 `IObservable` 和
    `IObserver` 提供者。
- en: 'The inventory application will be expanded in two main ways: by reacting to
    changes and by discussing the **Model-View-ViewModel** (**MVVM**) pattern.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 库存应用程序将通过两种主要方式扩展：通过响应变化，并讨论 **模型-视图-视图模型**（**MVVM**）模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The principles of reactive programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式编程的原则
- en: Reactive and IObservable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式和 IObservable
- en: Reactive extensions—.NET Rx Extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式扩展—.NET Rx 扩展
- en: Inventory application use case—getting inventory with a filter, paging, and
    sorting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存应用用例—使用过滤器、分页和排序获取库存
- en: Patterns and practices – MVVM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式和实践 – MVVM
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts of reactive
    programming. The code is kept simple and is only for demonstration purposes. Most
    of the examples involve a .NET Core console application written in C#.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例，以解释反应式编程的概念。代码保持简单，仅用于演示目的。大多数示例涉及使用 C# 编写的 .NET Core 控制台应用程序。
- en: 'The complete source code is available at the following link: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在以下链接获取：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter10)。
- en: 'Running and executing the code will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行和执行代码需要以下条件：
- en: Visual Studio 2019 (you can also use Visual Studio 2017)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用 Visual Studio 2017）
- en: Setting up .NET Core
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是 Express 版本）
- en: Installing Visual Studio
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'To run the code examples, you will need to install Visual Studio (the preferred
    IDE). To do so, you can follow these instructions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码示例，您需要安装 Visual Studio（首选 IDE）。为此，您可以按照以下说明操作：
- en: 'Download Visual Studio 2017 or the later version (2019) from the download link
    mentioned with the installation instructions: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从安装说明中提到的下载链接下载 Visual Studio 2017 或更高版本（2019）：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明操作。
- en: Multiple options are available for Visual Studio installation. Here, we are
    using Visual Studio for Windows.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 安装有多种选择。在这里，我们使用 Windows 版 Visual Studio。
- en: Setting up .NET Core
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未安装 .NET Core，您需要按照以下步骤操作：
- en: 'Download .NET Core for Windows: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Windows 版 .NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: For multiple versions and a related library, visit [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于多个版本和相关库，请访问 [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: Installing SQL Server
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 SQL Server
- en: 'If you do not have SQL Server installed, you can follow these instructions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您未安装 SQL Server，可以按照以下说明操作：
- en: 'Download SQL Server from the following link: [https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695).'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 SQL Server：[https://www.microsoft.com/en-in/download/details.aspx?id=1695](https://www.microsoft.com/en-in/download/details.aspx?id=1695)。
- en: 'You can find the installation instructions here: [https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在这里找到安装说明：[https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017](https://docs.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-2017)。
- en: 'For troubleshooting and for more information, refer to the following link:
    [https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于故障排除和更多信息，请参阅以下链接：[https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm](https://www.blackbaud.com/files/support/infinityinstaller/content/installermaster/tkinstallsqlserver2008r2.htm)。
- en: The principles of reactive programming
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程的原则
- en: These days, everyone is talking about **asynchronous programming**. Various
    applications are built on RESTful services that use asynchronous programming.
    The term *asynchronous* is relevant to reactive programming. Reactive is all about
    data streams, and reactive programming is a model structure that is built around
    asynchronous data streams. Reactive programming is also known as *the art of programming
    the propagation of changes*. Let's go back to our example from [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml),
    *Concurrent Programming in .NET Core,* where we were discussing the ticket collection
    counters at a big conference.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，每个人都在谈论**异步编程**。各种应用程序都是基于使用异步编程的 RESTful 服务构建的。术语*异步*与响应式编程相关。响应式编程全部关于数据流，响应式编程是一个围绕异步数据流构建的模型结构。响应式编程也被称为*编程传播变化的艺术*。让我们回到我们的例子，[第
    8 章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)，*.NET Core 中的并发编程*，在那里我们讨论了一个大型会议中的售票窗口收集计数器。
- en: 'In addition to the three ticket-collection counters, we have one more counter
    named the calculation counter. This fourth counter concentrates on counting the
    collection, and it counts how many tickets are distributed from each of the three
    counters. Consider the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了三个售票窗口外，我们还有一个名为计算窗口的额外窗口。这个第四个窗口专注于计数收集，它统计了从每个窗口分发出的票数。考虑以下图表：
- en: '![](img/747ea7b4-c8c3-4740-a44a-fb4986c84231.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/747ea7b4-c8c3-4740-a44a-fb4986c84231.png)'
- en: 'In the preceding diagram, the total of A+B+C is the sum of the remaining three
    columns; it is 1+1+1 = 3\. The **Total** column always shows the sum of rest of
    the three columns, and it will never show the actual person who is standing in
    the queue and waiting for their turn to collect the ticket. The value of the **Total**
    column depends upon the number of the remaining columns. If **Counter A** had
    two people in a queue, then the **Total** column would have the sum of 2+1+1 =
    4\. You can also refer to the **Total** column as a computed column. This column
    calculates the sum as soon as other rows/columns shift their counts (people waiting
    in the queue). If we were to write the **Total** column in C#, we would choose
    the computed property, and this would look as follows: `public int TotalColumn
    { get { return ColumnA + ColumnB + ColumnC; } }`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，A+B+C 的总和是剩余三列的总和；它是 1+1+1 = 3。**总计**列总是显示剩余三列的总和，它永远不会显示实际站在队列中等待轮到他们收集票的人。**总计**列的值取决于剩余列的数量。如果**计数器
    A**队列中有两个人，那么**总计**列将显示 2+1+1 = 4 的总和。你也可以将**总计**列称为计算列。此列在其它行/列的计数（队列中等待的人）改变时立即计算总和。如果我们用
    C# 编写**总计**列，我们会选择计算属性，它看起来如下：`public int TotalColumn { get { return ColumnA +
    ColumnB + ColumnC; } }`。
- en: 'In the preceding diagram, data flows from column to column. You can treat this
    as a data stream. You can create a stream for anything such as click events and
    hover events. Anything can be a stream variable: user inputs, properties, caches,
    data structures, and more. In the stream world, you can listen to the stream and
    react accordingly.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，数据从一列流向另一列。你可以将其视为数据流。你可以为任何东西创建一个流，例如点击事件和悬停事件。任何东西都可以是一个流变量：用户输入、属性、缓存、数据结构等等。在流的世界里，你可以监听流并根据需要进行反应。
- en: 'A sequence of events is called a **stream**. A stream can emit three things:
    a value, an error, and a signal for completion.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事件序列被称为**流**。一个流可以发出三件事：一个值、一个错误和一个完成信号。
- en: 'You can easily work with a stream in this way:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地以这种方式处理流：
- en: One stream can be the input for another stream.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个流可以是另一个流的输入。
- en: Multiple streams can be the input for another stream.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个流可以是另一个流的输入。
- en: Streams can be merged.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流可以合并。
- en: Data values can be mapped from one stream to another.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据值可以从一个流映射到另一个流。
- en: Streams can be filtered with the data/events that you need.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用所需的数据/事件对流进行过滤。
- en: 'To understand streams more closely, see the following diagram that represents
    a stream (a sequence of events):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解流，请参阅以下图表，该图表表示了一个流（事件序列）：
- en: '![](img/e147faca-305d-440c-87b6-0ba924c39f34.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e147faca-305d-440c-87b6-0ba924c39f34.png)'
- en: The preceding diagram is a representation of a stream (sequence of events) where
    we have one to four events. Any of these events can be triggered or someone can
    click on any of them. These events can be represented by values and these values
    can be strings. The X sign shows that an error has occurred during the operation
    where streams are merged or their data is being mapped. Finally, the | sign shows
    that a stream (or an operation) is complete.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表表示了一个流（事件序列），其中我们有一个到四个事件。这些事件中的任何一个都可以被触发，或者有人可以点击它们中的任何一个。这些事件可以用值来表示，这些值可以是字符串。X符号表示在流合并或数据映射操作期间发生了错误。最后，|符号表示流（或操作）已完成。
- en: Be reactive with reactive programming
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反应式编程来保持反应性
- en: Obviously, our computed property (discussed in the previous section) cannot
    be reactive or represent reactive programming. Reactive programming has specific
    designs and technologies. To experience the reactive programming or to be reactive,
    you can start with documents, available at [http://reactivex.io/](http://reactivex.io/)
    and experience it by going through the reactive manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))[.](https://www.reactivemanifesto.org/)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们之前讨论的计算属性（discussed in the previous section）不能是反应性的或代表反应式编程。反应式编程有特定的设计和技术。要体验反应式编程或保持反应性，你可以从[http://reactivex.io/](http://reactivex.io/)提供的文档开始，通过阅读反应式宣言([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))来体验它。
- en: In simple terms, reactive properties are binding properties that react when
    an event is triggered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，反应式属性是在事件触发时做出反应的绑定属性。
- en: Nowadays, when we deal with various large systems/applications, we find that
    they are too large to handle at once. These large systems are divided or composed
    into smaller systems. These smaller units/systems rely on reactive properties.
    To adhere to reactive programming, reactive systems apply design principles so
    that these properties can apply to all methods. With the help of this design/approach,
    we can make a composable system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们处理各种大型系统/应用程序时，我们发现它们太大，无法一次性处理。这些大型系统被分割或组合成更小的系统。这些较小的单元/系统依赖于反应式属性。为了遵循反应式编程，反应式系统应用设计原则，以便这些属性可以应用于所有方法。借助这种设计/方法，我们可以创建一个可组合的系统。
- en: According to the manifesto, reactive programming and reactive systems are both
    different.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 根据宣言，反应式编程和反应式系统都是不同的。
- en: 'On the basis of the reactive manifesto, we can conclude that reactive systems
    are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在反应式宣言的基础上，我们可以得出结论，反应式系统如下：
- en: '**Responsive**: Reactive systems are event-based design systems; these systems
    are quick to respond to any request in a short amount of time.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：反应式系统是基于事件的系统设计；这些系统能够快速响应任何请求，并在短时间内做出反应。'
- en: '**Scalable**: Reactive systems are reactive in nature. These systems can react
    to changing the scalability rate by expanding or reducing the allocated resources.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：反应式系统在本质上具有反应性。这些系统可以通过扩展或减少分配的资源来响应可伸缩率的改变。'
- en: '**Resilient**: A resilient system is one that will not stop even if there is
    a failure/exception. Reactive systems are designed in such a way so that in any
    exception or failure, the system will never die; it remains working.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：一个弹性的系统是指即使在出现故障/异常的情况下也不会停止的系统。反应式系统被设计成这样，在任何异常或故障发生时，系统永远不会死亡；它仍然在运行。'
- en: '**Message-based**: Any data item represents a message that can be sent to a
    specific destination. When a message or data item has arrived at a given state,
    an event emits a signal to notify the subscribers that a message has reached.
    Reactive systems rely on this message passing.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消息的**：任何数据项都代表可以发送到特定目的地的消息。当一个消息或数据项到达给定状态时，事件会发出信号通知订阅者消息已到达。反应式系统依赖于这种消息传递。'
- en: 'The following diagram shows a pictorial view of a reactive system:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了反应式系统的图示：
- en: '![](img/2e361032-d61e-429f-a4f8-9745429379ec.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e361032-d61e-429f-a4f8-9745429379ec.png)'
- en: In this diagram, a reactive system is composed of small systems that are resilient,
    scalable, responsive, and message-based.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，反应式系统由小型系统组成，这些系统具有弹性、可扩展性、响应性和基于消息的特性。
- en: Reactive streams in action
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式流的实际应用
- en: So far, we have discussed the fact that reactive programming is a data stream.
    In the previous sections, we have also discussed how streams work and how these
    streams travel in a timely manner. We have seen an example of events and discussed
    the data streams in a reactive program. Now, let's go ahead with the same example
    and look at how two streams work with various operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了反应式编程是一个数据流的事实。在前面的章节中，我们也讨论了流的工作方式和这些流如何及时地传输。我们看到了事件的一个例子，并讨论了反应程序中的数据流。现在，让我们继续使用相同的例子，看看两个流如何通过不同的操作工作。
- en: In the next example, we have two observable streams of an integer data type
    collection. Please note that we are using the pseudo code in this section to explain
    the behavior and the way in which these collections of data streams work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们有两个整数数据类型集合的反应式流。请注意，在本节中我们使用伪代码来解释行为以及这些数据流集合的工作方式。
- en: 'The following diagram represents two observable streams. The first stream,
    `Observer1`, contains numbers **1**, **2**, and **4**, whereas `Observer2`, which
    is a second stream, contains numbers **3** and **5**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示两个可观察的流。第一个流`Observer1`包含数字**1**、**2**和**4**，而第二个流`Observer2`包含数字**3**和**5**：
- en: '![](img/35ab0fbd-3968-400c-9032-08126e65ac7a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35ab0fbd-3968-400c-9032-08126e65ac7a.png)'
- en: 'Merging two streams involves combining their sequence elements into a new stream.
    The following diagram shows a new stream that results when `Observer1` and `Observer2`
    are merged:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 合并两个流涉及将它们的序列元素组合成一个新的流。以下图表显示了当`Observer1`和`Observer2`合并时产生的新流：
- en: '![](img/d4aeb61d-ed6b-4fcf-9a24-8562bed48a92.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d4aeb61d-ed6b-4fcf-9a24-8562bed48a92.png)'
- en: The preceding diagram is only a representation of a stream and is not an actual
    representation of the sequence of elements in the stream. In this diagram, we
    have seen that elements (numbers) are in the sequence **1**, **2**, **3**, **4**,
    **5**, but this is not true in a realistic example. The sequence can vary; it
    could be **1**, **2**, **4**, **3**, **5**, or in any other order.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表仅表示流的一种形式，并不是流中元素序列的实际表示。在这个图表中，我们看到元素（数字）的顺序是**1**、**2**、**3**、**4**、**5**，但在现实例子中并不一定如此。序列可能有所不同；它可能是**1**、**2**、**4**、**3**、**5**，或者任何其他顺序。
- en: 'Filtering a stream is just like skipping elements/records. You can imagine
    a `Where` clause in LINQ, which looks something like this: `myCollection.Where(num
    => num <= 3);`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤流就像跳过元素/记录。你可以想象LINQ中的`Where`子句，它看起来像这样：`myCollection.Where(num => num <=
    3);`。
- en: 'The following diagram illustrates a pictorial view of criteria, where we''re
    trying to pick only the elements that are meeting the specific criteria:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了我们试图选择满足特定条件的元素的准则图示：
- en: '![](img/1a2965f1-b4a3-4034-82f1-7119a41fad65.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1a2965f1-b4a3-4034-82f1-7119a41fad65.png)'
- en: We are filtering our stream and picking only those elements that are *<=3*.
    This means we are skipping elements **4** and **5**. In this case, we can say
    the filter is there to skip elements or to match the criteria.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在过滤我们的流，只选择那些**<=3**的元素。这意味着我们跳过了元素**4**和**5**。在这种情况下，我们可以说过滤器是用来跳过元素或匹配特定条件的。
- en: 'To understand a map stream, you can imagine any mathematical operation where
    you would be counting sequences or incrementing numbers by adding some constant
    values. For example, if we have an integer value of *3* and our map stream is
    *+3*, that means we are counting a sequence as *3 + 3 = 6*. You can also correlate
    this with the LINQ and select and project the output like this: `return myCollection.Select(num
    => num+3);`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解映射流，你可以想象任何数学运算，其中你会计算序列或通过添加一些常数来增加数字。例如，如果我们有一个整数值为 *3*，并且我们的映射流是 *+3*，这意味着我们正在计算一个序列为
    *3 + 3 = 6*。你还可以将此与 LINQ 和选择以及投影的输出相关联，如下所示：`return myCollection.Select(num =>
    num+3);`。
- en: 'The following diagram represents a map of the stream:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表表示流的映射：
- en: '![](img/031e8a71-9f81-475c-ac46-ae15cd06bc7c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/031e8a71-9f81-475c-ac46-ae15cd06bc7c.png)'
- en: After applying filters with the condition, *<= 3*, our stream has the elements
    **1**, **2**, and **3**. Additionally, we applied `Map (+3)` to the filtered stream
    with the elements **1**, **2**, and **3**, and, finally, our stream has the elements
    **4**,**5**,**6** (1+3, 2+3, 3+3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用条件 *<= 3* 的过滤器之后，我们的流包含元素 **1**、**2** 和 **3**。此外，我们还对过滤后的流（包含元素 **1**、**2**
    和 **3**）应用了 `Map (+3)`，最终我们的流包含元素 **4**、**5**、**6**（1+3、2+3、3+3）。
- en: 'In the real world, these operations would occur sequentially or on demand.
    We have already done this operation of sequences so that we can apply the operations
    of merge, filter, and mapping in a sequential manner. The following diagram represents
    the flow of our imaginary example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，这些操作将按顺序或按需发生。我们已经完成了序列的操作，以便我们可以按顺序应用合并、过滤和映射的操作。以下图表表示了我们想象中的示例的流程：
- en: '![](img/c3bfc2c2-2d3a-484f-a99f-8f8c3082316c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3bfc2c2-2d3a-484f-a99f-8f8c3082316c.png)'
- en: So, we have tried to represent our examples through diagrams, and we have gone
    through various operations where two streams talk to each other, and we got a
    new stream, and then we filtered and mapped the stream.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们尝试通过图表来表示我们的示例，并经历了各种操作，其中两个流相互通信，我们得到了一个新的流，然后过滤并映射了这个流。
- en: To understand this better, refer to [https://rxmarbles.com/](https://rxmarbles.com/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，请参阅 [https://rxmarbles.com/](https://rxmarbles.com/)。
- en: Now let's create a simple code to complete this example in the real world. First,
    we will study the code that implements the example, and then we will discuss the
    output of the stream.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的代码来在现实世界中完成这个示例。首先，我们将研究实现示例的代码，然后我们将讨论流的输出。
- en: 'Consider the following code snippet as an example of the `IObservable` interface:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码片段视为 `IObservable` 接口的示例：
- en: '`public static IObservable<T> From<T>(this T[] source) => source.ToObservable();`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static IObservable<T> From<T>(this T[] source) => source.ToObservable();`'
- en: This code represents an extension method of a `T` type array. We created a generic
    method and named it `From`. This method returns an `Observable` sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码表示 `T` 类型数组的扩展方法。我们创建了一个泛型方法，并将其命名为 `From`。此方法返回一个 `Observable` 序列。
- en: 'You can visit the official documentation to know more about extension methods
    here: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问官方文档以了解更多关于扩展方法的信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)。
- en: 'In our code, we have the `TicketCounter` class. This class has two observers
    that are actually arrays of the integer data type. The following code shows two
    observables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有 `TicketCounter` 类。这个类有两个观察者，实际上是整数数据类型的数组。下面的代码显示了两个可观察对象：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code, we apply the `From()` extension method to `Counter1` and `Counter2`.
    These counters actually represent our ticket counters and recall our example from
    [Chapter 8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent programming
    in .NET Core*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将 `From()` 扩展方法应用于 `Counter1` 和 `Counter2`。这些计数器实际上代表我们的票务计数器，并回忆起我们来自
    [第 8 章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)，*在 .NET Core 中的并发编程* 的示例。
- en: 'The following code snippet represents `Counter1` and `Counter2`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段表示 `Counter1` 和 `Counter2`：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this code, we have two fields, `Counter1` and `Counter2`, and they are initialized
    from the constructor. When the `TicketCounter` class is being initialized, these
    fields get the values from the constructor of the class, as defined in the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们有两个字段，`Counter1` 和 `Counter2`，它们由构造函数初始化。当 `TicketCounter` 类被初始化时，这些字段从类的构造函数中获取值，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To understand the complete code, go to and execute the code by hitting *F5*
    in Visual Studio. From here, you will see the following screen:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解完整的代码，请转到并执行代码，在Visual Studio中按*F5*键。从这里，你将看到以下屏幕：
- en: '![](img/7ca5c074-4bcc-4994-bb14-27c1f6df5946.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ca5c074-4bcc-4994-bb14-27c1f6df5946.png)'
- en: 'This is the console output and, in this console window, the user has been asked
    to enter a comma-separated number from `0` to `9`. Go ahead and enter a comma-separated
    number here. Please note that, here, we are trying to create a code that depicts
    our diagram of data stream representation, which was discussed earlier in this
    section:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台输出，在这个控制台窗口中，用户被要求从`0`到`9`输入一个以逗号分隔的数字。请在这里输入一个以逗号分隔的数字。请注意，在这里，我们试图创建一个代码，以描绘我们之前在本节中讨论的数据流表示图：
- en: '![](img/d898ad73-55f7-4510-8b2b-b860bce2c9cf.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d898ad73-55f7-4510-8b2b-b860bce2c9cf.png)'
- en: 'As per the preceding diagram, we have entered two different comma-separated
    numbers. The first is `1,2,4` and the second is `3,5`. Now consider our `Merge`
    method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的图示，我们输入了两个不同的以逗号分隔的数字。第一个是`1,2,4`，第二个是`3,5`。现在考虑我们的`Merge`方法：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Merge` method is merging two sequences of the data stream into `_observable`.
    The `Merge` operation is initiated with the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Merge`方法正在将数据流的两个序列合并到`_observable`中。`Merge`操作使用以下代码启动：'
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this code, the user is prompted to enter comma-separated numbers, and then
    the program stores these numbers into `counter1` and `counter2` by applying the
    `ToInts` method. The following is the code of our `ToInts` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，用户被提示输入以逗号分隔的数字，然后程序通过应用`ToInts`方法将这些数字存储到`counter1`和`counter2`中。以下是我们`ToInts`方法的代码：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is an extension method for `string`. The target variable is of a
    `string` type that contains integers separated by `separator`. In this method,
    we are using the built-in `ConvertAll` method that is provided by .NET Core. This
    first splits the string and checks whether the split value is of an `integer`
    type. It then returns the `Array` of integers. This method produces the output,
    as shown in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是`string`的扩展方法。目标变量是包含以`separator`分隔的整数的`string`类型。在这个方法中，我们使用.NET Core提供的内置`ConvertAll`方法。它首先分割字符串并检查分割值是否为`integer`类型。然后返回整数的`Array`。此方法产生以下截图所示的结果：
- en: '![](img/481c8752-3a12-4265-86d3-05dd0b57ceca.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/481c8752-3a12-4265-86d3-05dd0b57ceca.png)'
- en: 'The following is the output of our `merge` operation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`merge`操作的结果：
- en: '![](img/b45912b4-2e62-4a21-8fad-4ea7d1524d85.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b45912b4-2e62-4a21-8fad-4ea7d1524d85.png)'
- en: 'The preceding output shows that we now have a final merged observer stream
    with the elements in sequence. Let''s apply a filter to this stream. The following
    code is our `Filter` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示我们现在有一个最终合并的观察者流，其元素按顺序排列。现在让我们对这个流应用一个过滤器。以下是我们`Filter`方法的代码：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have the filter criteria for the number `<= 3`, which means we will pick
    only the elements whose values are either less than or equal to `3`. This method
    will initiate with the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有对数字`<= 3`的过滤条件，这意味着我们只会选择值小于或等于`3`的元素。此方法将使用以下代码启动：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the preceding code is executed, it produces the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码时，它产生以下输出：
- en: '![](img/22aede10-aae2-4fee-9e9d-8d549af5ea7d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22aede10-aae2-4fee-9e9d-8d549af5ea7d.png)'
- en: 'Finally, we have a filtered stream with the elements in the sequence 1,3,2\.
    Now we need to map on this stream. We need a mapped element with `num + 3`, which
    means we need to output an integer number by adding `3` to this number. The following
    is our `Map` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个过滤后的流，其元素按顺序为1,3,2。现在我们需要在这个流上应用映射。我们需要一个映射元素`num + 3`，这意味着我们需要通过给这个数字加`3`来输出一个整数。以下是我们`Map`方法的代码：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding method will be initialized with the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法将使用以下代码初始化：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On execution of the preceding method, we will see the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的方法后，我们将看到以下输出：
- en: '![](img/b1f0aa3c-79ef-48d4-98e2-c178c079b892.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1f0aa3c-79ef-48d4-98e2-c178c079b892.png)'
- en: 'After applying the `Map` method, we have the stream of an element in the sequence
    of 4,6,5\. We have discussed how reactive works even with an imaginary example.
    We have created a small .NET Core console application to see the power of `Merge`,
    `Filter`, and `Map` operations on the observables. The following is the output
    of our console application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用了 `Map` 方法之后，我们得到了序列 4,6,5 中元素的流。我们已经讨论了即使在想象中的例子中，响应式是如何工作的。我们创建了一个小的 .NET
    Core 控制台应用程序来查看 `Merge`、`Filter` 和 `Map` 操作在可观察对象上的力量。以下是我们控制台应用程序的输出：
- en: '![](img/8ed54e75-5467-4282-ab32-9dbf41194cfa.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ed54e75-5467-4282-ab32-9dbf41194cfa.png)'
- en: The previous snapshot is telling the whole story of the execution of our sample
    application; `Counter1` and `Counter2` are data streams that contain the sequences
    of data 1,2,4 and 3,5\. We have the preceding output for `Merge` with the result
    `1,3,2,5,4 Filter (<=3)`, with the result 1,3,2 and `Map (+3)` with the data 4,6,5.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的快照讲述了我们的示例应用程序执行的全过程；`Counter1` 和 `Counter2` 是包含数据序列 1,2,4 和 3,5 的数据流。我们得到了
    `Merge` 的前一个输出，结果为 `1,3,2,5,4 Filter (<=3)`，结果为 1,3,2，以及 `Map (+3)` 的数据 4,6,5。
- en: Reactive and IObservable
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式和 IObservable
- en: In the previous section, we discussed reactive programming and went through
    its model. In this section, we will discuss the Microsoft implementation of reactive
    programming. In response to reactive programming in .NET Core, we have various
    interfaces that provide a way to implement reactive programming in our application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了响应式编程并了解了其模型。在本节中，我们将讨论微软对响应式编程的实现。作为对 .NET Core 中响应式编程的响应，我们有各种接口，它们为我们提供了在应用程序中实现响应式编程的方法。
- en: '`IObservable<T>` is a generic interface that is defined in the `System` namespace
    and declared as `public interface IObservable<out T>`. Here, `T` represents a
    generic type of parameter that provides notification information. In simple terms,
    this interface helps us to define a provider for notifications, and these notifications
    can be pushed for information. You can use the observer pattern while implementing
    the `IObservable<T>` interface in your application.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservable<T>` 是在 `System` 命名空间中定义的一个泛型接口，声明为 `public interface IObservable<out
    T>`。在这里，`T` 代表一个泛型参数类型，它提供通知信息。简单来说，这个接口帮助我们定义通知的提供者，并且这些通知可以用于推送信息。你可以在应用程序中实现
    `IObservable<T>` 接口时使用观察者模式。'
- en: Observer pattern – implementation using IObservable<T>
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式 – 使用 IObservable<T> 实现
- en: In simple terms, a subscriber registers with a provider so that the subscriber
    may get notifications related to the message information. These notifications
    notify the provider that messages have been delivered to subscribers. This information
    may also be related to changes in operations or any other changes in the method
    or object itself. This is also known as **state changes**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，订阅者向提供者注册，以便订阅者可以获取与消息信息相关的通知。这些通知通知提供者消息已发送到订阅者。这些信息也可能与操作的变化或方法或对象本身的任何其他变化有关。这也被称为**状态变化**。
- en: 'The observer pattern specifies two terms: Observer and Observable. The observable
    is a provider also known as the **subject***.* The observer is registered with
    the `Observable`/`Subject`/`Provider` types, and the observer will be automatically
    notified by the provider whenever any changes occur due to the pre-defined criteria/condition,
    change or event, and so on.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式定义了两个术语：观察者和可观察对象。可观察对象是一个提供者，也称为**主题**。观察者注册在 `Observable`/`Subject`/`Provider`
    类型上，并且每当由于预定义的准则/条件、变化或事件等原因发生任何变化时，观察者将由提供者自动通知。
- en: 'The following diagram is a simple representation of the observer pattern, where
    the subject is notifying two different observers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示是观察者模式的一个简单表示，其中主题正在通知两个不同的观察者：
- en: '![](img/4d2b83fd-d913-4456-bf7a-b587b7e12da5.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d2b83fd-d913-4456-bf7a-b587b7e12da5.png)'
- en: Go back to the `FlixOne` inventory web application from [Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*, initiate your Visual Studio, and open the
    `FlixOne.sln` solution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第 9 章 [FlixOne 库存 Web 应用程序](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)，*函数式编程实践*，启动你的
    Visual Studio，并打开 `FlixOne.sln` 解决方案。
- en: 'Open Solution Explorer. From here, you will see that our project will look
    similar to the following snapshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器。从这里，你会看到我们的项目看起来与以下快照相似：
- en: '![](img/6c18ba34-8fb5-4905-b012-8d55995ca8fc.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c18ba34-8fb5-4905-b012-8d55995ca8fc.png)'
- en: 'Expand the Common folder under Solution Explorer and add two files: `ProductRecorder.cs`
    and `ProductReporter.cs`. These files are the implementation of the `IObservable<T>`
    and `IObserver<T>` interfaces. We also need to add a new ViewModel so that we
    can report actual messages to the users. To do so, expand the `Models` folder
    and add the `MessageViewModel.cs` file.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器下展开 Common 文件夹，并添加两个文件：`ProductRecorder.cs` 和 `ProductReporter.cs`。这些文件是实现
    `IObservable<T>` 和 `IObserver<T>` 接口的实现。我们还需要添加一个新的 ViewModel，以便我们可以向用户报告实际的消息。为此，展开
    `Models` 文件夹并添加 `MessageViewModel.cs` 文件。
- en: 'The following code is showing our `MessageViewModel` class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们的 `MessageViewModel` 类：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MessageViewModel` contains the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageViewModel` 包含以下内容：'
- en: '`MsgId`: A unique identifier'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MsgId`: 一个唯一标识符'
- en: '`IsSuccess`: Shows whether the operation has failed or succeeded'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSuccess`: 显示操作是否失败或成功'
- en: '`Message`: A success message or an error message that depends upon the value
    of `IsSuccess`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message`: 一个成功消息或错误消息，这取决于 `IsSuccess` 的值'
- en: '`ToString()`: An override method that returns a string after concatenating
    all the information'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToString()`: 一个重写方法，返回连接所有信息的字符串'
- en: 'Let''s now discuss our two classes; the following code is from the `ProductRecorder`
    class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论我们的两个类；以下代码来自 `ProductRecorder` 类：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `ProductRecorder` class implements the `IObservable<Product>` interface.
    If you recall our discussion regarding the observer pattern, you will come to
    know that this class is actually a provider, a subject, or an observable. The
    `IObservable<T>` interface has a `Subscribe` method that we need to use to subscribe
    our subscribers or observers (we will discuss the observer later in this section).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ProductRecorder` 类实现了 `IObservable<Product>` 接口。如果你还记得我们关于观察者模式的讨论，你会知道这个类实际上是一个提供者、主题或可观察对象。`IObservable<T>`
    接口有一个 `Subscribe` 方法，我们需要使用它来订阅我们的订阅者或观察者（我们将在本节后面讨论观察者）。
- en: 'There should be a criteria or a condition so that the subscriber can get notifications.
    In our case, we have a `Record` method that serves this purpose. Consider the
    following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个标准或条件，以便订阅者可以收到通知。在我们的例子中，我们有一个 `Record` 方法来满足这个目的。考虑以下代码：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding is a `Record` method. We created this method to showcase the power
    of the pattern. This method is simply checking for the valid discount rates. If
    `discount rate` is not valid, as per the criteria/condition, this method would
    raise an exception and share the product name with an invalid `discount rate`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是 `Record` 方法。我们创建这个方法来展示模式的力量。这个方法只是简单地检查有效的折扣率。如果 `discount rate` 无效，根据标准/条件，这个方法会抛出一个异常，并将产品名称与无效的
    `discount rate` 一起共享。
- en: 'The previous method validates the discount rate as per the criteria and sends
    a notification about the raised exception to the subscriber upon failure of the
    criteria. Take a look at the iteration block (the `foreach` loop) and imagine
    a situation where we do not have anything to iterate and all the subscribers have
    been notified. Can we imagine what will happen in this case? The same kind of
    situation may arise for `infinite` loop. To stop this, we need something that
    terminates the loop. For this, we have the following `EndRecording` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个方法根据标准验证折扣率，并在标准失败时向订阅者发送有关抛出异常的通知。看看迭代块（`foreach` 循环），想象一下我们没有可以迭代的内容，并且所有订阅者都已经收到通知的情况。我们能想象在这种情况下会发生什么吗？类似的情况也可能出现在
    `无限循环` 中。为了停止这种情况，我们需要某种可以终止循环的东西。为此，我们有了以下 `EndRecording` 方法：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `EndRecoding` method is looping through the collection of `_observers` and
    triggering the `OnCompleted()` method explicitly. Finally, it cleared the `_observers`
    collection.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `EndRecoding` 方法正在遍历 `_observers` 集合并显式触发 `OnCompleted()` 方法。最后，它清除了 `_observers`
    集合。
- en: 'Now, let''s discuss the `ProductReporter` class. This class is an example of
    the implementation of the `IObserver<T>` interface. Consider the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论 `ProductReporter` 类。这个类是 `IObserver<T>` 接口实现的例子。考虑以下代码：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `IObserver<T>` interface has the `OnComplete`, `OnError`, and `OnNext` methods
    that we have to implement in the `ProductReporter` class. The purpose of the `OnComplete`
    method is to notify the subscriber that the job has been done and then flush out
    the code. Furthermore, `OnError` is invoked when an error occurs during execution,
    while `OnNext` provides information of the next element in the sequence of a stream.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObserver<T>`接口有`OnComplete`、`OnError`和`OnNext`方法，我们必须在`ProductReporter`类中实现。`OnComplete`方法的目的是在工作完成后通知订阅者，然后清除代码。此外，`OnError`在执行过程中发生错误时被调用，而`OnNext`提供了流中下一个元素的信息。'
- en: 'In the following code, `PrepReportData` is a value addition that gives the
    user a formatted report about all the operations of the process:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`PrepReportData`是一个值添加，它给用户提供了有关所有操作过程的格式化报告：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding method is simply making additions to our `Reporter` collection,
    which is a collection of `MessageViewModel` classes. Note that, for simplicity
    purposes, you can also use the `ToString()` method that we have implemented in
    our `MessageViewModel` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法只是向我们的`Reporter`集合中添加内容，这是一个`MessageViewModel`类的集合。请注意，为了简化起见，您也可以使用我们在`MessageViewModel`类中实现的`ToString()`方法。
- en: 'The following code snippet shows the `Subcribe` and `Unsubscribe` methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了`Subscribe`和`Unsubscribe`方法：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous two methods tell the system that there is a provider. Subscribers
    could subscribe to the provider or unsubscribe/dispose of it upon completion of
    the operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法告诉系统存在一个提供者。订阅者可以订阅该提供者，或者在操作完成后取消订阅/处理它。
- en: Now it's time to showcase our implementation and see some good results. To do
    so, we need to make some changes to our existing `Product Listing` page and add
    a new View page to our project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候展示我们的实现了，看看一些好的结果。要做到这一点，我们需要对我们的现有`Product Listing`页面进行一些更改，并为我们项目添加一个新视图页面。
- en: 'Add the following link to our `Index.cshtml` page so that we can see the new
    link to view Audit Report:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下链接添加到我们的`Index.cshtml`页面，以便我们可以看到查看审计报告的新链接：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we added a new link to show the Audit Report
    based on our implementation of the `Report Action` method, which we have defined
    in our `ProductConstroller` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了一个新的链接来显示基于我们实现的`Report Action`方法的审计报告，该方法是我们在`ProductConstroller`类中定义的。
- en: 'After adding this code, our Product Listing page will look as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此代码后，我们的产品列表页面将如下所示：
- en: '![](img/8ef8a83f-a7a4-4df1-85cc-96b6ed21a54c.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ef8a83f-a7a4-4df1-85cc-96b6ed21a54c.png)'
- en: 'First, let''s discuss the `Report action` method. For this, consider the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下`Report action`方法。为此，请考虑以下代码：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, we are only taking the first three products for demonstration
    purposes. Please note that you can modify the code as per your own implementation.
    In the code, we have created a `productProvider` class and three observers to
    subscribe to our `productProvider` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是为了演示目的取了前三个产品。请注意，您可以根据自己的实现修改代码。在代码中，我们创建了一个`productProvider`类和三个观察者来订阅我们的`productProvider`类。
- en: 'The following diagram is a pictorial view of all the activities to showcase
    the `IObservable<T>` and `IObserver<T>` interfaces that we have discussed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表是展示我们讨论的`IObservable<T>`和`IObserver<T>`接口的所有活动的图形视图：
- en: '![](img/846c2b3f-d4ee-49c8-b5d5-106160ff4a5f.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/846c2b3f-d4ee-49c8-b5d5-106160ff4a5f.png)'
- en: 'The following code is used to subscribe to `productrovider`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码用于订阅`productrovider`：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we need to log the report and then unsubscribe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要记录报告然后取消订阅：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s come back to our screen and add the `Report.cshtml` file to Views |
    Product. The following code is part of our Report page. You can find the complete
    code in the `Product` folder:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的屏幕上，将`Report.cshtml`文件添加到视图 | 产品。以下代码是报告页面的部分。您可以在`Product`文件夹中找到完整的代码：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code will create a header for the columns of our table that shows the audit
    report.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将为显示审计报告的表格列创建一个标题。
- en: 'The following code will complete the table and add values to the `IsSuccess`
    and `Message` columns:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将完成表格，并将值添加到`IsSuccess`和`Message`列：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At this point, we are done with our implementation of the observer pattern
    using `IObservable<T>` and `IObserver<T>` interfaces. Run the project by pressing
    *F5* in Visual Studio, click on Product in the home page, and then click on the
    Audit Report link. From here, you will see that the audit report of our selected
    products, as shown in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 `IObservable<T>` 和 `IObserver<T>` 接口实现了观察者模式。通过在 Visual Studio
    中按 *F5* 运行项目，然后在主页面上点击产品，再点击审计报告链接来运行项目。从这里，您将看到我们选定产品的审计报告，如下面的截图所示：
- en: '![](img/078bcd2a-09a4-484c-8d76-95933be89587.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/078bcd2a-09a4-484c-8d76-95933be89587.png)'
- en: The preceding screenshot shows a simple listing page that shows the data from
    a `MessageViewModel` class. You can make the changes and modify them as per your
    requirement. In general, audit reports are coming from a lot of operational activities
    that we are seeing in the preceding screen. You could also save the audited data
    in the database and then serve this data accordingly for different purposes such
    as for reporting to admin and more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个简单的列表页面，显示了来自 `MessageViewModel` 类的数据。您可以根据自己的需求进行更改和修改。通常，审计报告来自我们在上一屏幕中看到的大量操作活动。您还可以将审计数据保存到数据库中，然后根据不同的目的（如向管理员报告等）相应地提供这些数据。
- en: Reactive extensions – .NET Rx extensions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反应式扩展 – .NET Rx 扩展
- en: The discussion in the previous session was aimed at reactive programming and
    the implementation of reactive programming using the `IObservable<T>` and `IObserver<T>`
    interfaces as an observer pattern. In this section, we will extend our learning
    with the help of **Rx Extensions**. If you would like to find out more about the
    development of Rx Extensions, you should follow the official repository at [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的讨论旨在介绍反应式编程以及使用 `IObservable<T>` 和 `IObserver<T>` 接口作为观察者模式实现反应式编程。在本节中，我们将借助
    **Rx 扩展** 来扩展我们的学习。如果您想了解更多关于 Rx 扩展的开发信息，请关注官方仓库 [https://github.com/dotnet/reactive](https://github.com/dotnet/reactive)。
- en: 'Please note that Rx Extensions are now merged with the `System` namespace,
    and you can find everything in the `System.Reactive` namespace. If you have experience
    with Rx Extensions, you should know that the namespace of these extensions has
    been changed, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Rx 扩展现在已与 `System` 命名空间合并，您可以在 `System.Reactive` 命名空间中找到所有内容。如果您有使用 Rx 扩展的经验，应该知道这些扩展的命名空间已经更改，如下所示：
- en: '`Rx.Main` has been changed to `System.Reactive`.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Main` 已更改为 `System.Reactive`。'
- en: '`Rx.Core` has been changed to `System.Reactive.Core`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Core` 已更改为 `System.Reactive.Core`。'
- en: '`Rx.Interfaces` has been changed to `System.Reactive.Interfaces`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Interfaces` 已更改为 `System.Reactive.Interfaces`。'
- en: '`Rx.Linq` has been changed to `System.Reactive.Linq`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Linq` 已更改为 `System.Reactive.Linq`。'
- en: '`Rx.PlatformServices` has been changed to `System.Reactive.PlatformServices`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.PlatformServices` 已更改为 `System.Reactive.PlatformServices`。'
- en: '`Rx.Testing` has been changed to `Microsoft.Reactive.Testing`.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rx.Testing` 已更改为 `Microsoft.Reactive.Testing`。'
- en: 'To initiate Visual Studio, open the `SimplyReactive` project (discussed in
    the previous section) and open the NuGet Package Manager. Click on Browse and
    enter the search term `System.Reactive`. From here, you will see the following
    results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Visual Studio，请打开 `SimplyReactive` 项目（在上一节中讨论过）并打开 NuGet 包管理器。点击浏览并输入搜索词
    `System.Reactive`。从这里，您将看到以下结果：
- en: '![](img/f1de57f4-7e26-4caa-9028-33a6d4e13cd5.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f1de57f4-7e26-4caa-9028-33a6d4e13cd5.png)'
- en: The aim of this section is to make you aware of reactive extensions but not
    delve into its internal development. These extensions are under the Apache2.0
    license and maintained by .NET Foundation. We have already implemented reactive
    extensions in our `SimplyReactive` application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是让您了解反应式扩展，但不会深入其内部开发。这些扩展位于 Apache2.0 许可证下，并由 .NET 基金会维护。我们已经在 `SimplyReactive`
    应用程序中实现了反应式扩展。
- en: Inventory application use case
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存应用程序用例
- en: In this section, we will continue with our FlixOne inventory application. Throughout
    this section, we will discuss the web application pattern and extend our web application
    developed in [Chapter 4](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml), *Implementing
    Design Patterns - Basics Part 2*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续我们的 FlixOne 库存应用程序。在本节中，我们将讨论 Web 应用程序模式并扩展我们在 [第 4 章](4f644693-85a7-4543-af8c-109d8519b2e5.xhtml)，*实现设计模式
    - 基础部分 2* 中开发的 Web 应用程序。
- en: This chapter continues looking at web applications that were discussed in the
    previous chapter. If you skipped the previous chapter ([Chapter 9](b1363fa4-f669-4670-9d40-a7e888557249.xhtml),
    *Functional Programming Practices*), please revisit it to get up to speed with
    the current chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续探讨上一章中讨论的网页应用。如果您跳过了上一章（[第9章](b1363fa4-f669-4670-9d40-a7e888557249.xhtml)，*函数式编程实践*），请重新阅读以跟上本章的内容。
- en: In this section, we will go through the process of requirement gathering and
    then discuss the various challenges of development and business with our web application
    that we developed previously.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论需求收集的过程，然后讨论我们之前开发的网页应用在开发和业务方面所面临的挑战。
- en: Starting the project
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始项目
- en: 'In [Chapter 7](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml), *Implementing Design
    Patterns for Web Applications - Part 2*, we added features to our FlixOne inventory
    web application. We extended the application after considering the following points:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](232b63cb-5006-431d-8378-b7e2ba4c1119.xhtml)，*为网页应用实现设计模式 - 第2部分*中，我们在我们的FlixOne库存网页应用中添加了功能。在考虑以下要点后，我们扩展了该应用：
- en: The business needs a rich UI.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务需要丰富的用户界面。
- en: New opportunities demand a responsive web application.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的机会需要响应式网页应用。
- en: Requirements
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: After several meetings and discussions with management, **Business Analyst**
    (**BA**), and presales folks, the management of the organization decided to work
    upon the following high-level requirements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 经过与管理部门、**业务分析师**（**BA**）和预销售人员的多次会议和讨论后，该组织的管理部门决定着手以下高级需求。
- en: Business requirements
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务需求
- en: 'Our business team listed the following requirements:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的业务团队列出了以下需求：
- en: '**Item filtering**: Currently, users are unable to filter items by category.
    To extend the list-view feature, the user should be able to filter the product
    item based on its respective category.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目过滤**：目前，用户无法按类别过滤项目。为了扩展列表视图功能，用户应该能够根据其相应的类别过滤产品项目。'
- en: '**Item sorting**: Currently, items are appearing in the order in which they
    have been added to the database. There is no mechanism where a user can sort items
    based on the item''s name, price, and so on.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目排序**：目前，项目以它们被添加到数据库中的顺序显示。没有机制允许用户根据项目的名称、价格等对项目进行排序。'
- en: The FlixOne inventory management web application is an imaginary product. We
    are creating this application to discuss the various design patterns required/used
    in the web project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne库存管理网页应用是一个虚构的产品。我们创建此应用是为了讨论在网页项目中需要/使用的各种设计模式。
- en: Getting inventory with a filter, paging, and sorting
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过滤器、分页和排序获取库存
- en: 'As per our business requirements, we need to apply a filter, paging, and sorting
    to our FlixOne inventory application. First, let''s start implementing the sorting.
    To do so, I''ve created a project and put this project in the `FlixOneWebExtended`
    folder. Start Visual Studio and open the FlixOne solution. We will apply to sort
    to our product listing sheet for these columns: `Category`, `productName`, `Description`,
    and `Price`. Please note that we will not be using any external component for
    sorting, but we will create our own login.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的业务需求，我们需要在我们的FlixOne库存应用中应用过滤器、分页和排序。首先，让我们开始实现排序。为此，我创建了一个项目并将此项目放在`FlixOneWebExtended`文件夹中。启动Visual
    Studio并打开FlixOne解决方案。我们将对这些列应用排序：`Category`、`productName`、`Description`和`Price`。请注意，我们不会使用任何外部组件进行排序，但我们将创建自己的登录。
- en: Open the Solution Explorer, and open `ProductController`, which is available
    in the `Controllers` folder. Add the `[FromQuery]Sort sort` parameter to the `Index`
    method. Please note that the `[FromQuery]` attribute indicates that this parameter
    is a query parameter. We will use this parameter to maintain our sorting order.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，打开`Controllers`文件夹中的`ProductController`。将`[FromQuery]Sort sort`参数添加到`Index`方法中。请注意，`[FromQuery]`属性表示此参数是一个查询参数。我们将使用此参数来维护我们的排序顺序。
- en: 'The following code shows the `Sort` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`Sort`类：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Sort` class contains three public properties as detailed here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`类包含三个公共属性，具体如下：'
- en: '`Order`: Indicates the sorting order. The `SortOrder` is an enum defined as
    `public enum SortOrder { D, A, N }`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Order`：表示排序顺序。`SortOrder`是一个定义为`public enum SortOrder { D, A, N }`的枚举。'
- en: '`ColName`: Indicates the column name.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColName`：表示列名。'
- en: '`ColType`: Indicates the type of a column; `ColumnType` is an enum defined
    as `public enum ColumnType { Text, Date, Number }`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColType`：表示列的类型；`ColumnType` 是定义为 `public enum ColumnType { Text, Date, Number
    }` 的枚举。'
- en: 'Open the `IInventoryRepositry` interface, and add the `IEnumerable<Product>
    GetProducts(Sort sort)` method. This method is responsible for sorting the results.
    Please note that we are going to use LINQ queries to apply sorting. Implement
    this `InventoryRepository` class method and add the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `IInventoryRepositry` 接口，并添加 `IEnumerable<Product> GetProducts(Sort sort)`
    方法。此方法负责排序结果。请注意，我们将使用 LINQ 查询来应用排序。实现此 `InventoryRepository` 类方法并添加以下代码：
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code is handling the case when `sort.ColName` is `productname`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了当 `sort.ColName` 为 `productname` 的情况：
- en: '[PRE25]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following code is handling the case when `sort.ColName` is `productprice`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码处理了当 `sort.ColName` 为 `productprice` 的情况：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous code, we set the value of the `sort` parameter as blank if it
    contains a null value, and then we process it by using `switch..case` in `sort.ColName.ToLower()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们如果 `sort` 参数包含空值，则将其值设置为空，然后通过在 `sort.ColName.ToLower()` 中使用 `switch..case`
    来处理它。
- en: 'The following is our `ListProducts()` method that gives us the result of the
    `IIncludeIQuerable<Product,Category>` type:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们 `ListProducts()` 方法，它给出了 `IIncludeIQuerable<Product,Category>` 类型的结果：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding code simply gives us `Products` by including `Categories` for
    each product. The sorting order will come from our user, so we need to modify
    our `Index.cshtml` page. We also need to add an anchor tag to the header columns
    of the table. For this, consider the following code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码简单地通过包括每个产品的 `Categories` 来给出 `Products`。排序顺序将来自我们的用户，因此我们需要修改我们的 `Index.cshtml`
    页面。我们还需要在表格的表头列中添加一个锚点标签。为此，请考虑以下代码：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code show the header columns of the table; `new Sort { ColName
    = "ProductName", ColType = ColumnType.Text, Order = SortOrder.A }` is the main
    way we are implementing `SorOrder`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了表格的表头列；`new Sort { ColName = "ProductName", ColType = ColumnType.Text,
    Order = SortOrder.A }` 是我们实现 `SortOrder` 的主要方式。
- en: 'Run the application and you will see the following snapshot of the Product
    Listing page with the sorting feature:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，您将看到以下带有排序功能的 `Product Listing` 页面的快照：
- en: '![](img/c72b4b9f-358a-41d8-9ff6-6f5c30f075af.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c72b4b9f-358a-41d8-9ff6-6f5c30f075af.png)'
- en: 'Now, open the `Index.cshtml` page, and add the following code to the page:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 `Index.cshtml` 页面，并将以下代码添加到页面中：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we are adding a textbox under `Form`. Here, the user
    inputs the data/value, and this data submits to the server as soon as the user
    clicks the submit button. At the server side, the filtered data will returned
    back and show the product listing. After the implementation of the preceding code,
    our Product Listing page will look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在 `Form` 下添加了一个文本框。在这里，用户输入数据/值，当用户点击提交按钮时，这些数据会立即提交到服务器。在服务器端，过滤后的数据将被返回并显示产品列表。在前面代码的实现之后，我们的产品列表页面将看起来像这样：
- en: '![](img/dcf4ab01-e7d0-46b5-be17-6a942f083335.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf4ab01-e7d0-46b5-be17-6a942f083335.png)'
- en: 'Go to the `Index` method in `ProductController` and change the parameters.
    Now the `Index` method looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `ProductController` 中的 `Index` 方法并修改参数。现在 `Index` 方法看起来是这样的：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, we need to update the method parameters of `GetProducts()` in `InventoryRepository`
    and `InventoryRepository`. The following is the code for the `InventoryRepository`
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还需要更新 `InventoryRepository` 和 `InventoryRepository` 中 `GetProducts()` 方法的参数。以下为
    `InventoryRepository` 类的代码：
- en: '[PRE31]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now run the project by pressing *F5* from Visual Studio and navigating to the
    filter/search option in Product Listing. For this, see this snapshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过从 Visual Studio 按下 *F5* 并导航到产品列表中的筛选/搜索选项来运行项目。为此，请参阅以下快照：
- en: '![](img/802ed721-1eb2-4afc-8b51-3be146702b5b.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/802ed721-1eb2-4afc-8b51-3be146702b5b.png)'
- en: 'After entering your search term, click on the Search button, and this will
    give you the results, as shown in the following snapshot:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入您的搜索词后，点击搜索按钮，这将给出以下快照所示的结果：
- en: '![](img/a6f32b34-7662-4b1d-be5f-6d5a7c0c1bec.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6f32b34-7662-4b1d-be5f-6d5a7c0c1bec.png)'
- en: 'In the preceding Product Listing screenshot, we are filtering our Product records
    with `searchTerm` `mango`, and it produces single results, as shown in the previous
    snapshot. There is one issue in this approach for searching data: add `fruit`
    as a search term, and see what will happen. It will produce zero results. This
    is demonstrated in the following snapshot:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的产品列表截图中，我们使用`searchTerm` `mango`筛选产品记录，并产生单个结果，如前一个快照所示。在搜索数据的方法中存在一个问题：添加`fruit`作为搜索词，看看会发生什么。它将产生零个结果。这在前面的快照中得到了演示：
- en: '![](img/06ac51ab-3dfb-47e7-9e2a-8aeea1d0f932.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06ac51ab-3dfb-47e7-9e2a-8aeea1d0f932.png)'
- en: We do not get any result, which means our search is not working when we are
    putting `searchTerm` in lowercase. This means our search is case-sensitive. We
    need to change our code to get it started.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有得到任何结果，这意味着当我们把`searchTerm`放在小写时，我们的搜索不起作用。这意味着我们的搜索是区分大小写的。我们需要更改我们的代码来启动它。
- en: 'Here is our modified code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的修改后的代码：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are ignoring the case to make our search case-insensitive. We used `StringComparison.InvariantCultureIgnoreCase`
    and ignored the case. Now our search will work with either capital or lowercase
    letters. The following is the snapshot that produces results using lowercase `fruit`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了大小写，使我们的搜索不区分大小写。我们使用了`StringComparison.InvariantCultureIgnoreCase`并忽略了大小写。现在我们的搜索将可以处理大写或小写字母。以下是一个使用小写`fruit`产生结果的快照：
- en: '![](img/80ddb52c-00e6-4041-b490-377f78e502a6.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80ddb52c-00e6-4041-b490-377f78e502a6.png)'
- en: 'In a previous discussion during the FlixOne app extension, we applied `Sort`
    and `Filter`; now we need to add `paging`. To do so, we have added a new class
    named, `PagedList` as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在FlixOne应用程序扩展的先前的讨论中，我们应用了`排序`和`筛选`；现在我们需要添加`分页`。为了做到这一点，我们添加了一个名为`PagedList`的新类，如下所示：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, change the parameters of the `Index` method of `ProductController` as
    follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式更改`ProductController`的`Index`方法的参数：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following code to the `Index.cshtml` page:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Index.cshtml`页面：
- en: '[PRE35]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code makes it possible to move our screen to the next or the
    previous page. Our final screen will look like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使得我们的屏幕可以移动到下一页或前一页。我们的最终屏幕将看起来像这样：
- en: '![](img/d2e1909c-873b-4285-b592-2c69ed0d6667.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2e1909c-873b-4285-b592-2c69ed0d6667.png)'
- en: In this section, we have discussed and extended the features of our FlixOne
    application by implementing `Sorting`, `Paging`, and `Filter`. The aim of this
    section was to give you hands-on experience with a working application. We have
    coded our application in such a way that it will directly meet real-world applications.
    With the preceding enhancement, our application is now capable of giving a product
    listing that can be sorted, paginated, and filtered.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过实现`排序`、`分页`和`筛选`功能，讨论并扩展了我们的FlixOne应用程序的特性。本节的目标是让您亲身体验一个实际运行的应用程序。我们的应用程序代码编写得可以直接应用于现实世界。通过前面的增强，我们的应用程序现在能够提供可排序、分页和筛选的产品列表。
- en: Patterns and Practices – MVVM
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式和实践 – MVVM
- en: In [Chapter 6](8e089021-1efb-4b88-8bf2-e26f69f883b9.xhtml), *Implementing Design
    Patterns for Web Applications - Part 1*, we discussed the **MVC** pattern and
    created an application based on this.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](8e089021-1efb-4b88-8bf2-e26f69f883b9.xhtml)，*实现Web应用程序的设计模式 - 第1部分*中，我们讨论了**MVC**模式并创建了一个基于此的应用程序。
- en: Ken Cooper and Ted Peters are the names behind the invention of the MVVM pattern.
    At the time of this invention, both Ken and Ted were architects at the Microsoft
    Corporation. They made this pattern to simplify the UI of event-driven programming.
    Later on, it was implemented in **Windows Presentation Foundation** (**WPF**)
    and **Silverlight**.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Ken Cooper和Ted Peters是MVVM模式发明的背后名字。在发明这个模式的时候，Ken和Ted都是微软公司的架构师。他们创建这个模式是为了简化事件驱动编程的UI。后来，这个模式在**Windows
    Presentation Foundation**（**WPF**）和**Silverlight**中得到了实现。
- en: The MVVM pattern was announced in 2005 by John Gossman. John has blogged about
    this pattern in context with building WPF applications. The link for this is at
    [https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM模式由John Gossman在2005年宣布。John在其关于构建WPF应用程序的博客中讨论了此模式。链接为[https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/](https://blogs.msdn.microsoft.com/johngossman/2005/10/08/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps/)。
- en: MVVM is considered to be one of the variations of MVC to meet the modern **User
    Interface** (**UI**) development approach, where UI development is the core responsibility
    of designer/UI-developers rather than application developers. In this approach
    of development, a designer who is a graphical enthusiast and is focused on making
    a UI more attractive may or may not bother about the development part of the application.
    Generally, designers (UI persons) use various tools to make the UI more attractive.
    The UI can be made with a simple HTML, CSS, and so on, using rich controls of
    WPF or Silverlight.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 被认为是 MVC 的变体之一，以满足现代**用户界面**（**UI**）开发方法，其中 UI 开发是设计师/UI 开发者的核心责任，而不是应用开发者。在这种开发方法中，一个图形爱好者设计师可能或可能不会关心应用的开发部分。通常，设计师（UI
    人员）使用各种工具使 UI 更具吸引力。UI 可以通过简单的 HTML、CSS 等实现，使用 WPF 或 Silverlight 的丰富控件。
- en: '**Microsoft Silverlight** is a framework that helps to develop applications
    with a rich UI. Many developers refer to it as an alternative of Flash by Adobe.
    In July 2015, Microsoft announced that it was no longer supporting Silverlight.
    Microsoft announced the support of WPF in .NET Core 3.0 during its build ([https://developer.microsoft.com/en-us/events/build](https://developer.microsoft.com/en-us/events/build)).
    There is also a blog with more insight into the plan to support WPF found here:
    [https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/](https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Microsoft Silverlight** 是一个帮助开发具有丰富 UI 的应用的框架。许多开发者将其视为 Adobe Flash 的替代品。2015
    年 7 月，微软宣布将不再支持 Silverlight。微软在其 Build 大会上宣布了对 .NET Core 3.0 中 WPF 的支持（[https://developer.microsoft.com/en-us/events/build](https://developer.microsoft.com/en-us/events/build)）。还可以在这里找到更多关于支持
    WPF 计划的博客文章：[https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/](https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/)。'
- en: 'The MVVM pattern can be elaborated with its various components as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 模式可以通过其各种组件进行详细阐述如下：
- en: '**Model**: Holds data and does not care about any business logic in the application.
    I prefer to refer to this as a domain object because it holds the actual data
    of the application we are working with. In other words, we can say that a model
    is not responsible for making the data beautiful. For example, in a product model
    of our FlixOne application, a product model holds the value of various properties,
    and these describe a product by its name, description, category name, price, and
    more. These properties contain the actual data of the product, but the model is
    not responsible for making behavioral changes to any of the data. For example,
    it''s not the responsibility of our product mode to format the product description
    to look perfect on the UI. On the other hand, many of our models contain validations
    and other computed properties. The main challenge is to maintain the pure and
    cleaned model, which means that the model should resemble the real-world model.
    In our case, our `product` model is called a **clean model**. A clean model is
    one that resembles the actual properties of real products. For example, if the
    `Product` model is storing the data of fruits, then it should show properties
    such as the color of fruits and so on. The following code is from a model of our
    imaginary application:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：存储数据，不关心应用中的任何业务逻辑。我更喜欢将其称为领域对象，因为它持有我们正在工作的应用的实际数据。换句话说，我们可以这样说，模型不负责使数据变得美观。例如，在我们
    FlixOne 应用的产品模型中，产品模型持有各种属性的值，并通过名称、描述、类别名称、价格等来描述产品。这些属性包含产品的实际数据，但模型不负责对任何数据进行行为上的更改。例如，我们的产品模型格式化产品描述以在
    UI 上看起来完美并不是其责任。另一方面，我们中的许多模型包含验证和其他计算属性。主要挑战是维护一个纯净和清洁的模型，这意味着模型应该类似于现实世界的模型。在我们的案例中，我们的
    `product` 模型被称为**清洁模型**。一个清洁模型是类似于真实产品的实际属性的模型。例如，如果 `Product` 模型存储水果的数据，那么它应该显示如水果的颜色等属性。以下代码来自我们想象中的应用的一个模型：'
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that the preceding code is written in Angular. We will discuss Angular
    code in detail in the upcoming section, *Implementing MVVM*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码是用 Angular 编写的。我们将在下一节中详细讨论 Angular 代码，即*实现 MVVM*。
- en: '**View**: This is a data representation for the end user to access via the
    UI. This simply displays the value of the data, and this value may or may not
    be formatted. For example, we can show the discount rate as 18% on the UI, while
    it would be stored as 18.00 in the model. The view can also responsible for behavioral
    changes. The view accepts user inputs; for example, there would be a view that
    provides a form/screen to add a new product. Also, the view can manage the user
    input such as the key pressed, detecting a keyword, and more. It could also be
    an active view or a passive view. The view that accepts the user input and manipulates
    the data model (properties) according to the user input is an active view. A passive
    view is one that does nothing. In other words, a view that is not associated with
    the model is a passive view, and this kind of view is manipulated by a controller.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是为最终用户通过UI访问的数据表示。它简单地显示数据的值，这个值可能已经格式化，也可能没有。例如，我们可以在UI上显示折扣率为18%，而在模型中它会被存储为18.00。视图还可以负责行为变化。视图接受用户输入；例如，可能会有一个视图提供一个表单/屏幕来添加新产品。此外，视图可以管理用户输入，如按键、检测关键词等。它也可以是主动视图或被动视图。接受用户输入并根据用户输入操作数据模型（属性）的视图是主动视图。被动视图是没有任何操作的视图。换句话说，与模型不关联的视图是被动视图，这种视图由控制器操作。'
- en: '**ViewModel**: This works as a middleman between View and Model. Its responsibility
    is to make the presentation better. In our previous example, where View shows
    the discount rate as 18% but Model has a discount rate of 18.00, it is the responsibility
    of View Model to format 18.00 to 18% so that View can display the formatted discount
    rate.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：它作为视图和模型之间的中间人工作。其责任是使展示更佳。在我们之前的例子中，视图显示折扣率为18%，但模型中的折扣率为18.00，视图模型的职责是将18.00格式化为18%，以便视图可以显示格式化后的折扣率。'
- en: 'If we combine all the points discussed, we can visualize the entire MVVM pattern,
    which would look like the following diagram:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有讨论的点结合起来，我们可以可视化整个MVVM模式，如下面的图所示：
- en: '![](img/61f3a6af-ade5-4d96-88d1-4d959db0bc1c.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61f3a6af-ade5-4d96-88d1-4d959db0bc1c.png)'
- en: The preceding diagram is a pictorial view of MVVM, and it shows us that **View
    Model** separates **View** and **Model**. **ViewModel** also maintains the `state`
    and `perform` operations. This helps **View** to present the final output to the
    end user. The view is UI, which gets data and presents it to the end user. In
    the next section, we will implement the MVVM pattern using Angular.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图是MVVM的图形视图，它显示**视图模型**将**视图**和**模型**分开。**视图模型**还维护`状态`和`执行`操作。这有助于**视图**向最终用户展示最终输出。视图是UI，它获取数据并向最终用户展示。在下一节中，我们将使用Angular实现MVVM模式。
- en: Implementation of MVVM
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM实现
- en: In the previous section, we understood what the MVVM pattern is and how it works.
    In this section, we will use our FlixOne application and build an application
    using Angular. To demonstrate the MVVM pattern, we will use the API built on ASP.NET
    Core 2.2.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解了MVVM模式是什么以及它是如何工作的。在本节中，我们将使用我们的FlixOne应用程序并使用Angular构建一个应用程序。为了演示MVVM模式，我们将使用基于ASP.NET
    Core 2.2构建的API。
- en: 'Start Visual Studio and open FlixOne Solution from the `FlixOneMVVM` folder.
    Run the `FlixOne.API` project where you will see the following Swagger documentation
    page:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Visual Studio并从`FlixOneMVVM`文件夹中打开FlixOne解决方案。运行`FlixOne.API`项目，您将看到以下Swagger文档页面：
- en: '![](img/9cc95489-4408-41f9-81a0-393b2ae85317.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9cc95489-4408-41f9-81a0-393b2ae85317.png)'
- en: 'The preceding screenshot is the snapshot of our Product APIs documentation,
    where we have incorporated Swagger for the API documentation. If you want to,
    you can test the API from this screen. If the APIs are returning results, then
    your project is successfully set up. If not, please check the prerequisites for
    this project, and also check the `README.md` file from the Git repository for
    this chapter. We have everything that is required to build a new UI; as discussed
    previously, we will create an Angular application that will consume our Product
    APIs. To get started, follow these steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图是我们产品API文档的快照，其中我们集成了Swagger用于API文档。如果您愿意，您可以从这个屏幕测试API。如果API返回结果，那么您的项目已成功设置。如果没有，请检查此项目的先决条件，并检查Git仓库中此章节的`README.md`文件。我们拥有构建新UI所需的一切；如前所述，我们将创建一个Angular应用程序来消费我们的产品API。要开始，请按照以下步骤操作：
- en: Open the Solution Explorer.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“解决方案资源管理器”。
- en: Right-click on FlixOne Solution.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击FlixOne解决方案。
- en: Click on Add New Project.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“添加新项目”。
- en: 'From the Add New Project window, select ASP.NET Core Web Application. Call
    it FlixOne.Web and click OK. After doing so, refer to this screenshot:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“添加新项目”窗口中，选择ASP.NET Core Web应用程序。命名为FlixOne.Web，然后单击“确定”。完成后，参考以下截图：
- en: '![](img/e9f81475-6de0-46c7-bfe0-fb72a917416f.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9f81475-6de0-46c7-bfe0-fb72a917416f.png)'
- en: 'From the next window, select Angular, make sure you have selected ASP.NET Core
    2.2, click OK, and refer to this screenshot:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，选择Angular，确保您已选择ASP.NET Core 2.2，然后单击“确定”，并参考以下截图：
- en: '![](img/798ace74-dc36-45d9-aebd-c958464837c1.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/798ace74-dc36-45d9-aebd-c958464837c1.png)'
- en: 'Open Solution Explorer and you will find the new `FlixOne.Web` project and
    folder hierarchy, which looks like this:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开解决方案资源管理器，您将找到新的`FlixOne.Web`项目和文件夹结构，它看起来像这样：
- en: '![](img/afcc2e76-f48c-4abf-910f-9e7382731283.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afcc2e76-f48c-4abf-910f-9e7382731283.png)'
- en: 'From the Solution Explorer, right-click on the FlixOne.Web project, and click
    on the Set as Startup project, and then refer to the following screenshot:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中，右键单击FlixOne.Web项目，然后单击“设置为启动项目”，然后参考以下截图：
- en: '![](img/a4bac5f7-1e4f-447a-bd53-ee09dcf3a150.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a4bac5f7-1e4f-447a-bd53-ee09dcf3a150.png)'
- en: 'Run the `FlixOne.Web` project and see the output, which will look like the
    following screenshot:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`FlixOne.Web`项目并查看输出，它将类似于以下截图：
- en: '![](img/f4643910-9a24-4f31-9102-f27f812cacf8.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f4643910-9a24-4f31-9102-f27f812cacf8.png)'
- en: 'We have set up our Angular app successfully. Go back to your Visual Studio
    and open the Output window. Refer to the following screenshot:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功设置我们的Angular应用程序。返回您的Visual Studio并打开输出窗口。参考以下截图：
- en: '![](img/5f215bcf-3786-4f4d-95aa-1737550c1192.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f215bcf-3786-4f4d-95aa-1737550c1192.png)'
- en: 'You will find `ng serve "--port" "60672"` from the Output window; this is a
    command that tells the Angular app to listen and serve. Open the `package.json`
    file from `Solution Explorer`; this file belongs to the `ClientApp` folder. You
    will notice `"@angular/core": "6.1.10"`, which means our application is built
    on `angular6`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '您将在输出窗口中找到`ng serve "--port" "60672"`；这是一个告诉Angular应用程序监听和服务的命令。从解决方案资源管理器打开`package.json`文件；此文件属于`ClientApp`文件夹。您会注意到`"@angular/core":
    "6.1.10"`，这意味着我们的应用程序是基于`angular6`构建的。'
- en: 'The following is the code of our `product.component.html` (this is a view):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`product.component.html`的代码（这是一个视图）：
- en: '[PRE37]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the application from Visual Studio, and click on Product, where you will
    get a Product Listing screen similar to this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio运行应用程序，然后单击“产品”，您将获得一个类似于以下的产品列表屏幕：
- en: '![](img/d2388694-3340-4811-bf69-d26781422dfa.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d2388694-3340-4811-bf69-d26781422dfa.png)'
- en: In this section, we have created a small demo application in Angular.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个小的Angular演示应用程序。
- en: Summary
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The aim of this chapter was to get you through the reactive programming by discussing
    its principles and the reactive programming model. Reactive is all about the data
    stream, which we have discussed with examples. We extended our example from [Chapter
    8](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml), *Concurrent Programming in .NET
    Core*, where we discussed the use case of the ticket collection counter at a conference.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是通过讨论其原理和响应式编程模型来帮助您理解响应式编程。响应式编程的核心是数据流，我们通过示例进行了讨论。我们扩展了[第8章](ac0ad344-5cd2-4c11-bcfe-cf55b9c4ce3c.xhtml)，*在.NET
    Core中的并发编程*中的示例，其中我们讨论了在会议中票务收集计数器的用例。
- en: We explored the reactive system during our discussion of the reactive manifesto.
    We discussed the reactive system through the help of showcasing the `merge`, `filter`,
    and `map` operations, and how streams work with the help of examples. Also, we
    discussed the `IObservable` interface and the Rx extensions, using examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的响应式宣言讨论中，我们探讨了响应式系统。我们通过展示`merge`、`filter`和`map`操作，以及通过示例说明流的工作方式来讨论响应式系统。我们还通过示例讨论了`IObservable`接口和Rx扩展。
- en: We carried forward our `FlixOne` inventory application and discussed the use
    cases to implement the paging and the sorting of inventory data for products.
    Finally, we discussed the MVVM pattern and created a small application on a MVVM
    architecture.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用`FlixOne`库存应用程序，并讨论了实现产品库存数据的分页和排序的用例。最后，我们讨论了MVVM模式，并在MVVM架构上创建了一个小型应用程序。
- en: In the next chapter ([Chapter 11](1dd82c08-3988-4c19-aa44-4bc2fd3277a9.xhtml),
    *Advanced Database Design and Application Techniques*), advanced database and
    application techniques will be explored, including applying **Command Query Responsibility
    Segregation** (**CQRS**) and a ledger-style database.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第11章](1dd82c08-3988-4c19-aa44-4bc2fd3277a9.xhtml)，*高级数据库设计和应用技术*）中，将探讨高级数据库和应用技术，包括应用**命令查询责任分离**（**CQRS**）和账本式数据库。
- en: Questions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: What is a stream?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是流？
- en: What are reactive properties?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是响应式属性？
- en: What is a reactive system?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是响应式系统？
- en: What is meant by merging two reactive streams?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两个响应式流意味着什么？
- en: What is the MVVM pattern?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是MVVM模式？
- en: Further reading
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, refer to the following
    book. This book will provide you with various in-depth and hands-on exercises
    for reactive programming:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涵盖的主题，请参考以下书籍。这本书将为您提供各种深入和实用的响应式编程练习：
- en: '*Reactive Programming for .NET Developer*s, *Antonio Esposito* and *Michael
    Ciceri*, Packt Publishing: [https://www.packtpub.com/web-development/reactive-programming-net-developers](https://www.packtpub.com/web-development/reactive-programming-net-developers)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《.NET开发者的响应式编程》，作者：*Antonio Esposito* 和 *Michael Ciceri*，Packt Publishing：[https://www.packtpub.com/web-development/reactive-programming-net-developers](https://www.packtpub.com/web-development/reactive-programming-net-developers)
