- en: Tactical Tips and Tricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 战术技巧和窍门
- en: Software engineers are an optimistic bunch and, as such, we often underestimate
    the amount of work it takes to fully implement new features or make changes to
    an existing code base. A common mistake is to only consider how long it will take
    to write the code that's required to create that feature. In such cases, we forget
    to include the time it takes for several important tasks. We often need to spend
    time refactoring other subsystems to support the changes we're making. This can
    happen either because we didn't think it would be necessary at the time, or because
    we thought of a better way to implement it halfway through, which can quickly
    turn into a rabbit hole dive of redesign and refactoring if we don't plan far
    ahead. We should also consider the time that's needed for testing and documentation.
    Even if a QA team does a testing pass against the change after it has been implemented,
    we still need to run through some scenarios on our own system during implementation
    in order to ensure that the change actually does what it's intended to do.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师是一群乐观的人，因此我们经常低估完全实现新功能或修改现有代码库所需的工作量。一个常见的错误是只考虑编写创建该功能所需代码所需的时间。在这种情况下，我们忘记了包括几个重要任务所需的时间。我们经常需要花费时间重构其他子系统以支持我们正在进行的更改。这可能是因为我们没有在当时认为这是必要的，或者是因为我们在中途想到了更好的实现方式，如果没有提前做好规划，这可能会迅速变成一个关于重新设计和重构的兔子洞，如果我们不提前做好规划。
- en: The one constant cost that's included in all performance optimization work is
    time. So, with limited time at our disposal to implement our features and keep
    everything working, an important skill for any developer to learn about is workflow
    optimization. Having a better understanding of the tools we use will save us more
    time in the long run, and hopefully provide the extra time we need to implement
    everything we want to, which applies not only to the Unity engine, but to every
    tool we use—IDEs, build systems, analytics systems, social media platforms, app
    stores, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有性能优化工作中，唯一恒定的成本就是时间。因此，在我们有限的时间内实现我们的功能和保持一切正常运行，对于任何开发者来说，学习工作流程优化都是一个重要的技能。更好地理解我们所使用的工具，将使我们从长远来看节省更多时间，并希望为我们提供实现我们想要实现的一切所需的多余时间，这不仅适用于Unity引擎，也适用于我们使用的每一个工具——集成开发环境（IDEs）、构建系统、分析系统、社交媒体平台、应用商店等等。
- en: There are a lot of little nuances to using the Unity engine that can help improve
    our project workflow. However, quite a lot of the Editor's functionality is not
    well documented, well-known, or just not something we think about until after
    quite some time—we realize the fact that it could have been applied perfectly
    to solve a particular problem we were having 6 months ago.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Unity引擎方面有很多小细节可以帮助改善我们的项目工作流程。然而，编辑器的许多功能并没有得到很好的文档记录，也不是众所周知，或者直到相当长一段时间后我们才会考虑——我们意识到这些功能可以完美地解决我们6个月前遇到的一个特定问题。
- en: The internet is crammed full of blogs, tweets, and forum posts that try to help
    other Unity developers learn about these useful features, but they only tend to
    focus on a handful of tips at a time. There doesn't seem to be any online resources
    that group many of them in one place. As a result, the internet browsers of intermediate
    and advanced Unity developers are probably bursting at the seams with links to
    these tips that we bookmark for later and then completely forget about.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上充满了博客、推文和论坛帖子，试图帮助其他Unity开发者了解这些有用的功能，但它们通常只关注少数几个技巧。似乎没有在线资源将它们集中在一个地方。因此，中级和高级Unity开发者的网络浏览器可能因为保存这些技巧的链接而爆满，我们为以后的书签并最终完全忘记。
- en: So, because this book is primarily for such users, I felt like it was worth
    including a short chapter to pool many of these tips and tricks together into
    one location. This chapter serves as a reference list in the hope of saving us
    time during future development efforts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鉴于这本书主要是为这类用户编写的，我觉得包括一个简短的章节将许多这些技巧和窍门集中在一起放在一个地方是值得的。这一章节作为参考列表，希望在未来开发工作中节省我们时间。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Editor hotkey tips
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器快捷键技巧
- en: Editor UI tips
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器UI技巧
- en: Scripting tips
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本技巧
- en: Custom Editor scripts and menu tips
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义编辑器脚本和菜单技巧
- en: External tips
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部技巧
- en: Other tips
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他技巧
- en: Editor hotkey tips
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器快捷键技巧
- en: The Editor is rife with hotkeys that can aid rapid development, and it's worth
    checking out the documentation. However, let's be honest—nobody reads the manual
    until they need something specific from it. In this section, we will go over some
    of the most useful, yet less well-known, hotkeys that are available when we're
    playing with the Unity Editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器中充满了可以辅助快速开发的快捷键，查看文档是值得的。然而，让我们说实话——直到需要从手册中获取特定信息之前，没有人会阅读手册。在本节中，我们将介绍一些最实用但不太为人所知的快捷键，这些快捷键在我们使用Unity编辑器进行操作时可用。
- en: For each case we'll be looking at, the Windows hotkey is listed. If the macOS
    hotkey requires a different set of keystrokes, then it will be shown in parentheses.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们每个要讨论的情况，都会列出Windows快捷键。如果macOS快捷键需要不同的按键组合，那么它将显示在括号中。
- en: Working with GameObjects
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与GameObject协同工作
- en: GameObjects can be duplicated by selecting them in the Hierarchy window and
    pressing *Ctrl* + *D* (*cmd *+ *D*). New, empty GameObjects can be created by
    pressing *Ctrl* + *Shift* + *N* (*cmd* + *shift* + *N*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在Hierarchy窗口中选择GameObject并按*Ctrl*+*D*（*cmd*+*D*）来复制GameObject。可以通过按*Ctrl*+*Shift*+*N*（*cmd*+*shift*+*N*）创建新的、空的GameObject。
- en: Press *Ctrl* + *Shift* + *A* (*cmd* + *shift* + *A*) to quickly open the Add
    Component menu. From there, you can type in the name of the component you wish
    to add.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl*+*Shift*+*A*（*cmd*+*shift*+*A*）可以快速打开添加组件菜单。从那里，您可以输入要添加的组件的名称。
- en: Scene window
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scene窗口
- en: Pressing *Shift* + *F* will lock the camera on an object in the Scene window (assuming
    that the Scene window is open and visible), which can be helpful for tracking
    high-velocity objects or figuring out why objects may be falling out of our scene.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Shift*+*F*将锁定Scene窗口中的对象（假设Scene窗口已打开且可见），这对于跟踪高速对象或找出为什么对象可能从我们的场景中掉落非常有用。
- en: Holding *Alt* and left-click and dragging with the mouse in the Scene window
    will make the Scene window's camera orbit the currently selected object (as opposed
    to looking around it). Holding *Alt* and right-click and dragging with the mouse
    in the Scene window will zoom the camera in/out (*Alt* + *Ctrl* + left-drag).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scene窗口中按住*Alt*并左键单击并拖动鼠标，将使Scene窗口的相机围绕当前选定的对象旋转（而不是围绕它查看）。在Scene窗口中按住*Alt*并右键单击并拖动鼠标将放大/缩小相机（*Alt*+*Ctrl*+左键拖动）。
- en: 'Holding *Ctrl* and left-click and dragging will cause the selected object to
    snap to the grid as it moves. The same can be done for rotation by holding *Ctrl* as
    we adjust the rotation widgets around the object. In the Scene window, you can
    click on the arrow near the grid icon (see the following screenshot) to open a
    window where we can edit the grid that objects snap to on a per-axis basis:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并左键单击并拖动将使所选对象在移动时对齐到网格。同样，可以通过在调整对象周围的旋转控件时按住*Ctrl*来进行旋转。在Scene窗口中，您可以点击网格图标附近的箭头（见以下截图）以打开一个窗口，我们可以根据每个轴编辑对象对齐到的网格：
- en: '![](img/7f276200-b30d-4812-9684-eedc2453e25a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f276200-b30d-4812-9684-eedc2453e25a.png)'
- en: 'In Unity 2020.1, the snap to grid setting has been moved from the Scene view
    toolbar to the main window toolbar (where the Play/Pause/Step buttons are):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 2020.1中，对齐到网格的设置已从Scene视图工具栏移动到主窗口工具栏（其中包含Play/Pause/Step按钮）：
- en: '![](img/04831f19-3ccd-4e34-a5bc-36764e4476fc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04831f19-3ccd-4e34-a5bc-36764e4476fc.png)'
- en: We can force objects to snap to each other through their vertices by holding
    down the *V* key as we move an object around in the Scene window. By doing so,
    the selected object will automatically snap its vertices to the nearest vertex
    of the nearest object. This is very useful for aligning scene pieces, such as
    floors, walls, platforms, and other tile-based systems, without needing to make
    small manual position adjustments.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在Scene窗口中移动对象时按住*V*键，通过对象的顶点强制对象相互对齐。这样做的话，所选对象将自动将其顶点对齐到最近对象的最近顶点。这对于对齐场景部件，如地板、墙壁、平台和其他基于瓦片的系统非常有用，而无需进行小的手动位置调整。
- en: Arrays
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: We can duplicate array elements that have been exposed in the Inspector window
    by selecting them and pressing *Ctrl* + *D* (*cmd* + *D*). This will copy the
    element and insert it into the array immediately after the current selection.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在Inspector窗口中选择它们并按*Ctrl*+*D*（*cmd*+*D*）来复制已暴露在Inspector窗口中的数组元素。这将复制元素并将其立即插入到当前选择之后。
- en: 'We can remove entries from an array of references (for example, an array of
    GameObjects) by selecting the element, right-clicking on it, and selecting Delete
    Array Element. This will strip the element and condense the array. Removing elements
    from arrays of primitive types (`int`, `float`, and so on) can be accomplished
    by simply pressing *delete* without the *shift* key (*cmd*) modifier being held
    down:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过选择元素，右键单击它并选择“删除数组元素”来从引用数组（例如，GameObject 数组）中删除条目。这将删除元素并压缩数组。从原始类型数组（`int`、`float`
    等）中删除元素可以通过简单地按下 *delete* 键实现，无需按住 *shift* 键 (*cmd*) 修饰符：
- en: '![](img/31a751e3-cd0a-4931-ac6b-9c60afb8a67a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/31a751e3-cd0a-4931-ac6b-9c60afb8a67a.png)'
- en: While holding down the right mouse button in the Scene window, we can use the *W*, *A*, *S*,
    and *D* keys to fly around with the camera in a typical first-person camera control
    style. The *Q* and *E* keys can also be used to fly up and down, respectively.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景窗口中按住右键鼠标按钮时，我们可以使用 *W*、*A*、*S* 和 *D* 键以典型的第一人称摄像头控制风格在周围飞行。*Q* 和 *E* 键也可以用来上下飞行。
- en: Interface
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 界面
- en: We can press *Alt* and click on any Hierarchy window arrow (the small gray arrow
    to the left of any parent object's name) to expand the object's entire hierarchy,
    rather than just the next level in the Hierarchy window. This works on GameObjects
    in the Hierarchy window, folders and Prefabs within the Project window, lists
    in the Inspector window, and so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按住 *Alt* 并单击任何层次结构窗口箭头（任何父对象名称左侧的小灰色箭头）来展开对象的整个层次结构，而不仅仅是层次结构窗口中的下一级。这适用于层次结构窗口中的
    GameObject，项目窗口中的文件夹和 Prefabs，检查器窗口中的列表等。
- en: 'We can save and restore object selections in the Hierarchy or Project windows much
    like a typical RTS game. Make the selection and press *Ctrl* + *Alt* + <*0-9*>
    (*cmd *+ *alt* + <*0*-*9*>) to save the selection. Press *Ctrl* + *Shift* + *<0*-*9>* (*cmd* + *shift* +
    <*0-9*>) to restore it. This is exceptionally useful if we find ourselves selecting
    the same handful of objects over and over again while we''re making adjustments.
    You can also find the save/load selections commands in Edit | Selection:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在层次结构或项目窗口中保存和恢复对象选择，就像典型的 RTS 游戏一样。做出选择并按下 *Ctrl* + *Alt* + <*0-9*> (*cmd
    *+ *alt* + <*0*-*9*>) 来保存选择。按下 *Ctrl* + *Shift* + *<0*-*9>* (*cmd* + *shift* +
    <*0-9*>) 来恢复它。如果我们发现自己反复选择相同的一小批对象进行调整，这会特别有用。您也可以在“编辑”|“选择”中找到保存/加载选择命令：
- en: '![](img/d84aacd2-8c0b-4702-8ea5-b7bc748ecb81.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d84aacd2-8c0b-4702-8ea5-b7bc748ecb81.png)'
- en: Pressing *Shift* + spacebar will expand the window under the mouse cursor so
    that it fills the entire Editor screen. Pressing it again will shrink the window
    and restore it to its previous location.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Shift* + 空格键将扩展鼠标光标下的窗口，使其填充整个编辑器屏幕。再次按下它将缩小窗口并恢复到其之前的位置。
- en: 'Pressing *Ctrl* + *Shift* + *P* (*cmd* + *shift* + *P*) will toggle the Pause button
    while in Playmode. This is usually an awkward key combination to press if we''re
    trying to pause in a hurry, so it often helps to create a custom hotkey for pausing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *Shift* + *P* (*cmd* + *shift* + *P*) 将在播放模式中切换暂停按钮。如果我们急于暂停，通常这个按键组合会比较尴尬，因此创建一个自定义的热键来暂停会很有帮助：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In-editor documentation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器内文档
- en: We can quickly access the documentation of any Unity keyword or class by highlighting
    it in Visual Studio Community and pressing *Ctrl* + *'* (*cmd* + *'*). This will
    open the default browser and perform a search on the Unity documentation for the
    given keyword or class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 Visual Studio Community 中突出显示任何 Unity 关键字或类，并按下 *Ctrl* + *'** (*cmd*
    + *'**) 来快速访问其文档。这将打开默认浏览器并在 Unity 文档中搜索给定的关键字或类。
- en: Note that users with European keyboards may also need to hold down the *Shift* key
    for this feature to work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用欧洲键盘的用户可能还需要按住 *Shift* 键才能使用此功能。
- en: The same can be done in Visual Studio by pressing *Ctrl* + *Alt* + *M*, followed
    by *Ctrl* + *H*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中，可以通过按下 *Ctrl* + *Alt* + *M*，然后按下 *Ctrl* + *H* 来实现同样的操作。
- en: Editor UI tips
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器 UI 小贴士
- en: The Editor's default behavior is designed to be efficient and satisfy every
    user; however, each of us is different, just like beautiful snowflakes, and so
    are our working preferences. Fortunately, Unity allows us to customize many aspects
    of the Editor's workflow. Let's see how with the following collection of tips.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的默认行为旨在高效且满足每位用户的需求；然而，我们每个人都是不同的，就像美丽的雪花一样，我们的工作偏好也是如此。幸运的是，Unity 允许我们自定义编辑器工作流程的许多方面。让我们通过以下一系列技巧来看看如何实现。
- en: Script Execution Order
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本执行顺序
- en: We can prioritize which scripts will have their `Update()` and `FixedUpdate()` callbacks
    called before others by navigating to Edit | Project Settings | Script Execution
    Order. If we find ourselves trying to solve complex problems using this feature
    (with the exception of time-sensitive systems, such as audio processing), it implies
    that we've got some very fragile and tight coupling going on between our components.
    From a software design perspective, this can be a warning sign that we may need
    to approach the problem from another angle. However, this can be helpful to use
    as a quick fix.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过导航到编辑 | 项目设置 | 脚本执行顺序来优先级排序哪些脚本将先于其他脚本调用其 `Update()` 和 `FixedUpdate()`
    回调。如果我们发现自己试图使用此功能（除时间敏感的系统，如音频处理外）来解决复杂问题，那么这表明我们在组件之间可能存在一些非常脆弱且紧密的耦合。从软件设计的角度来看，这可能是一个警告信号，表明我们可能需要从另一个角度来处理问题。然而，这可以作为快速修复很有帮助。
- en: Editor files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器文件
- en: Integrating Unity projects with a source control solution can be a little tricky.
    The first step is to include the `.meta` files that Unity generates for various
    assets; if we don't do this, then anyone pulling data into their local Unity project
    must regenerate their own metadata files. This could potentially cause conflicts,
    so it is essential that everyone uses the same versions. This can be enabled by
    navigating to Edit | Project Settings | Editor | Version Control | Mode | Visible
    Meta Files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Unity 项目与源代码控制解决方案集成可能有点棘手。第一步是包含 Unity 为各种资产生成的 `.meta` 文件；如果我们不这样做，那么任何将数据拉入其本地
    Unity 项目的用户都必须重新生成自己的元数据文件。这可能会引起冲突，因此，确保每个人都使用相同的版本是至关重要的。这可以通过导航到编辑 | 项目设置 |
    编辑 | 版本控制 | 模式 | 可见元数据文件来实现。
- en: It can also be helpful to convert certain asset data into text-only format,
    rather than into binary data, to allow data files to be manually edited. This
    turns many data files into the much more human-readable YAML format. For instance,
    if we're using ScriptableObjects to store custom data, we can use a text editor
    to search for and edit these files without having to do it all through the Unity
    Editor and serialization system. This can save a lot of time, especially when
    we're searching for a particular data value or performing multi-editing across
    different derived types. This option can be enabled by navigating to Edit | Project
    Settings | Editor | Asset Serialization | Mode | Force Text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将某些资产数据转换为纯文本格式，而不是二进制数据，也可以很有帮助，以便手动编辑数据文件。这会将许多数据文件转换为更易于人类阅读的 YAML 格式。例如，如果我们使用
    ScriptableObjects 来存储自定义数据，我们可以使用文本编辑器来搜索和编辑这些文件，而无需通过 Unity 编辑器和序列化系统来完成所有操作。这可以节省大量时间，尤其是在我们搜索特定数据值或在不同派生类型之间进行多编辑时。此选项可以通过导航到编辑
    | 项目设置 | 编辑 | 资产序列化 | 模式 | 强制文本来启用。
- en: The Editor has a log file that can be accessed by opening the Console window
    (where log messages are printed), left-clicking on the hamburger icon in the top
    right corner (which looks like three thin horizontal lines), and selecting Open
    Editor Log. This can help us get more information about build failures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器有一个日志文件，可以通过打开控制台窗口（日志消息在此打印），在右上角点击汉堡图标（看起来像三条细的水平线），然后选择打开编辑器日志来访问。这可以帮助我们获取更多关于构建失败的信息。
- en: 'Alternatively, if we successfully built our project, it will contain a breakdown
    of the compressed file sizes of all of the assets that were packed into the executable,
    ordered by size. This is an extremely helpful way of figuring out which assets
    consume the majority of our application''s footprint (hint: it''s almost always
    texture files) and which files take up more space than we would expect:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们成功构建了我们的项目，它将包含所有打包到可执行文件中的资产的压缩文件大小分解，按大小排序。这是一种极有帮助的方法，可以找出哪些资产消耗了我们应用程序的主要空间（提示：几乎总是纹理文件），以及哪些文件占用的空间比我们预期的要多：
- en: '![](img/5ffba58c-a1b8-4e8b-ac08-5961623a10b1.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ffba58c-a1b8-4e8b-ac08-5961623a10b1.png)'
- en: 'Additional windows can be added to the Editor by right-clicking on the title
    of an existing window and selecting Add Tab. This also allows us to add duplicate
    windows, such as having more than one Project window or Inspector window open
    at a time. This can be particularly useful for moving files between different
    locations via multiple Project windows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在现有窗口的标题上右键单击并选择添加选项卡，可以向编辑器添加额外的窗口。这也允许我们添加重复的窗口，例如同时打开多个项目窗口或检查器窗口。这特别有用，可以通过多个项目窗口在不同位置之间移动文件：
- en: '![](img/c1f14e08-c729-498a-adf6-3cb3d5f6d2e6.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1f14e08-c729-498a-adf6-3cb3d5f6d2e6.png)'
- en: 'Having duplicate Inspector windows can be virtually redundant, since they''ll
    show the exact same information when we click on a new object. However, by making
    use of the *lock icon*, we can lock the given Inspector window to its current
    selection. When we select an object, all the Inspector windows will be updated
    to show the object''s data, except for any locked Inspector windows, which continue
    to show the data of the object they were locked to:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有重复的检查器窗口，几乎可以说是多余的，因为当我们点击新的对象时，它们会显示完全相同的信息。然而，通过使用*锁定图标*，我们可以将给定的检查器窗口锁定到当前选择。当我们选择一个对象时，所有检查器窗口都会更新以显示该对象的数据，除了任何已锁定的检查器窗口，它们将继续显示它们被锁定到的对象的数据：
- en: '![](img/e369b91a-6711-489c-bcb1-f9b246ee6fa3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e369b91a-6711-489c-bcb1-f9b246ee6fa3.png)'
- en: 'Some common tricks that make use of window locking include the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些利用窗口锁定功能的一些常见技巧包括以下内容：
- en: Using two of the same window (Inspector, Animation, and so on) to compare two
    objects side by side or to easily copy data from one object to another
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个相同的窗口（检查器、动画等）并排比较两个对象或轻松地从对象复制数据到另一个对象
- en: Watching what happens to any dependent object if an object is tweaked during Playmode
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察在Playmode期间调整对象时，任何依赖对象会发生什么
- en: Selecting multiple objects in the Project window and then dragging and dropping
    them into a serialized array in the Inspector window without losing the original
    selection
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在项目窗口中选择多个对象，然后将它们拖放到检查器窗口中的序列化数组中，而不会丢失原始选择
- en: The Inspector window
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查器窗口
- en: We can enter calculations into numeric Inspector window fields. For example,
    typing `4*128` into an `int` field will resolve the value to `512`, sparing us
    from having to pull out a calculator or do the math in our head.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将计算输入到数字检查器窗口字段中。例如，在`int`字段中输入`4*128`将解析为`512`，这样我们就不需要拿出计算器或在脑海中计算了。
- en: Array elements can be duplicated and deleted from a list (in the same fashion
    as hotkeys can) by right-clicking on the root element and selecting Duplicate
    Array Element or Delete Array Element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过右键单击根元素并选择“复制数组元素”或“删除数组元素”来从列表中复制和删除数组元素（与热键类似）。
- en: A component's context menu can be accessed by clicking on the small *cog* icon
    in the upper right corner or by right-clicking on the name of the component. Every
    component's context menu contains a Reset option, which resets all of the values
    back to their default states, sparing us from having to reset values manually.
    This is useful when we're working with `Transform` components as this option will
    set the object's position and rotation to `(0,0,0)` and its scale to `(1,1,1)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过点击右上角的小*齿轮*图标或右键单击组件名称来访问组件的上下文菜单。每个组件的上下文菜单都包含一个重置选项，该选项将所有值重置为其默认状态，这样我们就不必手动重置值。当我们与`Transform`组件一起工作时，这很有用，因为这个选项将对象的位置和旋转设置为`(0,0,0)`，并将其缩放设置为`(1,1,1)`。
- en: It's commonly known that, if `GameObject` was spawned from a Prefab, then the
    entire object can be reverted back to its initial Prefab state using the Revert button
    at the top of the Inspector window. However, it's less well-known that individual
    values can be reverted by right-clicking on the name of the value and selecting Revert
    Value to Prefab. This restores the selected value while leaving the rest untouched.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，如果`GameObject`是从Prefab生成的，则可以使用检查器窗口顶部的“重置”按钮将整个对象重置为其初始Prefab状态。然而，不太为人所知的是，可以通过右键单击值的名称并选择“将值重置为Prefab”来重置单个值。这会恢复所选值，而其余部分保持不变。
- en: The Inspector window has a Debug mode that can be accessed by left-clicking
    on the hamburger icon next to the lock icon and selecting Debug. This will disable
    all custom Inspector window drawing from Editor scripts and instead reveal all
    the pieces of raw data within the given `GameObject` and its components. Even `private` data
    fields become visible. Although they are grayed out and cannot be modified through
    the Inspector window, this still gives us a useful way of examining the `private` data
    and other hidden values during Playmode. The Debug mode of the Inspector window
    also reveals internal ObjectIDs, which can be useful if we're doing interesting things
    with Unity's serialization system and want to resolve conflicts. Since Editor
    scripts are also disabled in this mode, it can be useful to debug such scripts
    by comparing its internal data to what we are trying to reveal in our Editor script.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: “检查器”窗口有一个“调试”模式，可以通过在锁图标旁边的汉堡图标上左键单击并选择“调试”来访问。这将禁用所有来自编辑器脚本的定制“检查器”窗口绘制，并揭示给定“GameObject”及其组件内的所有原始数据。即使是“私有”数据字段也会变得可见。尽管它们被灰色显示且无法通过“检查器”窗口进行修改，但这仍然为我们提供了一个在“播放模式”期间检查“私有”数据和其它隐藏值的有用方法。“检查器”窗口的“调试”模式还揭示了内部ObjectID，这在我们在Unity的序列化系统中做有趣的事情并想要解决冲突时非常有用。由于在此模式下编辑器脚本也被禁用，因此可以通过比较其内部数据与我们试图在编辑器脚本中揭示的内容来调试此类脚本。
- en: 'If we have an array of data elements serialized in the Inspector window, then
    they are typically labeled Element N, where `N` represents the array index of
    that element, starting from `0`. This can make it tricky to find a specific element
    if our array elements are a series of serialized classes or structs, which tend
    to have multiple children themselves. However, if the very first field in the
    object is a string, then the elements will be named after the value of the string
    field:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在“检查器”窗口中有一个数据元素数组序列化，那么它们通常被标记为“元素 N”，其中“N”代表该元素的数组索引，从“0”开始。这可能会使得在数组元素是一系列序列化的类或结构时找到特定元素变得有些棘手，因为这些类或结构本身可能有多个子元素。然而，如果对象中的第一个字段是一个字符串，那么元素将被命名为该字符串字段的值：
- en: '![](img/f50cf3c4-9990-401b-96fd-b44c942321bb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f50cf3c4-9990-401b-96fd-b44c942321bb.png)'
- en: When a mesh object is selected, the Preview subsection at the bottom of the Inspector window
    is often fairly small, which makes it hard for us to look at the details in the
    mesh and what it will look like when it appears in our scene. However, if we right-click
    on the top bar of the Preview subsection, it will be detached and enlarged into
    a separate Preview window, making it much easier for us to see our mesh. We don't
    have to worry about setting the detached window back to its original home because
    if the detached window is closed, then the Preview subsection will return to the
    bottom of the Inspector window.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择网格对象时，“检查器”窗口底部的“预览”子部分通常相当小，这使得我们难以查看网格的细节以及它在场景中呈现的样子。然而，如果我们右键单击“预览”子部分的顶部栏，它将被分离并扩展为一个单独的“预览”窗口，这使得我们更容易看到我们的网格。我们不必担心将分离的窗口放回原来的位置，因为如果关闭分离的窗口，那么“预览”子部分将返回到“检查器”窗口的底部。
- en: The Project window
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目窗口
- en: The Project window's search bar allows us to filter for objects of a particular
    type by clicking on the small icon to the right of the search bar. This provides
    a list of different types that we can filter by revealing all the objects of that
    type within the entire project. However, selecting these options simply fills
    the search bar with a string of the `t:<type>` format, which applies the appropriate
    filter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “项目”窗口的搜索栏允许我们通过点击搜索栏右侧的小图标来过滤特定类型的对象。这提供了一个我们可以通过显示整个项目中该类型所有对象来过滤的不同类型列表。然而，选择这些选项只是将搜索栏填充为“t:<type>”格式的字符串，这应用了适当的过滤器。
- en: Thus, we can simply type the equivalent strings into the search bar for the
    sake of speed. For instance, typing `t:prefab` will filter for all Prefabs, no
    matter where they are in the Hierarchy window. Similarly, `t:texture` will reveal
    textures, `t:scene` will reveal scene files, and so on. Adding multiple search
    filters to the search bar will include objects of all types (it doesn't reveal
    objects that only satisfy both filters). These filters are modifiers in addition
    to name-based filtering, so adding a plain text string will cause a name-based
    search to occur through the filtered objects. For example, `t:texture normalmap` will
    find all the texture files that include the word `normalmap` in their name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了提高速度，我们可以在搜索栏中简单地输入等效的字符串。例如，输入`t:prefab`将过滤出所有预制件，无论它们在层级窗口中的位置如何。同样，`t:texture`将揭示纹理，`t:scene`将揭示场景文件，等等。将多个搜索过滤器添加到搜索栏将包括所有类型的对象（它不会揭示仅满足两个过滤器的对象）。这些过滤器是除基于名称的过滤之外的修饰符，因此添加纯文本字符串将通过过滤对象执行基于名称的搜索。例如，`t:texture
    normalmap`将找到所有名称中包含`normalmap`一词的纹理文件。
- en: If we're making use of Asset Bundles and the built-in labeling system, the Project window's
    search bar also allows us to hunt down bundled objects by their label using `l:<label
    type>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用资源包和内置的标签系统，项目窗口的搜索栏也允许我们通过标签使用`l:<标签类型>`来查找捆绑的对象。
- en: 'If a `MonoBehaviour` script contains serialized references (using `[SerializeField]` or `public`)
    to Unity assets, such as meshes and textures, then we can assign default values
    to the script directly. Select the script file in the Project window; the Inspector window
    should contain a field for the asset so that we can drag and drop the default
    assignment into it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`MonoBehaviour`脚本包含序列化的对Unity资源的引用（使用`[SerializeField]`或`public`），例如网格和纹理，那么我们可以直接为脚本分配默认值。在项目窗口中选择脚本文件；检查器窗口应该包含一个用于资产的字段，以便我们可以将默认分配拖放到其中：
- en: '![](img/d34f6416-57a8-4786-8c34-b771a4758c4b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d34f6416-57a8-4786-8c34-b771a4758c4b.png)'
- en: By default, the Project window splits files and folders into two columns and
    treats them separately. If we prefer the Project window to have a typical hierarchical
    folder and file structure, then we can set it to One Column Layout in its context
    menu (the hamburger icon at the top right). This can be a great space saver in
    some Editor layouts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，项目窗口将文件和文件夹分为两列，并分别处理。如果我们希望项目窗口具有典型的分层文件夹和文件结构，则可以在其上下文菜单（右上角的汉堡图标）中将其设置为单列布局。这在某些编辑器布局中可以节省大量空间。
- en: Right-clicking on any object in the Project window and selecting Select Dependencies will
    reveal all the objects that this asset relies on so that it can exist, such as
    textures, meshes, and `MonoBehaviour` script files. For scene files, it will list
    all the entities that are referenced within that scene. This is helpful if we're
    trying to perform asset cleanup.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中右键单击任何对象并选择“选择依赖项”将揭示所有依赖于此资产才能存在的对象，例如纹理、网格和`MonoBehaviour`脚本文件。对于场景文件，它将列出场景中引用的所有实体。如果我们试图执行资源清理，这将很有帮助。
- en: The Hierarchy window
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层级窗口
- en: A less well-known feature of the Hierarchy window is its ability to perform
    component-based filtering within the currently active scene. This can be accomplished
    by typing `t:<component name>`. For example, typing `t:light` inside the Hierarchy window
    search bar will reveal all the objects in the scene that contain a Light component.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 层级窗口的一个不太为人所知的功能是它能够在当前活动场景中执行基于组件的过滤。这可以通过输入`t:<组件名称>`来完成。例如，在层级窗口的搜索栏中输入`t:light`将揭示场景中包含光组件的所有对象。
- en: This feature is not case-sensitive, but the string we input must match the full
    component name for the search to be completed. Components that derive from the
    given type will also be revealed, so typing `t:renderer` will reveal all the objects
    with derived components, such as `MeshRenderer` and `SkinnedMeshRenderer`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能不区分大小写，但输入的字符串必须与完整的组件名称完全匹配才能完成搜索。从给定类型派生的组件也将被揭示，因此输入`t:renderer`将揭示所有具有派生组件的对象，例如`MeshRenderer`和`SkinnedMeshRenderer`。
- en: The Scene and Game windows
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景和游戏窗口
- en: The Scene window camera is not visible from the Game window, but it is generally
    a lot easier to move around and place through the use of the hotkeys we mentioned
    previously. The Editor allows us to align the selected object to the same position
    and rotate the Scene window camera by navigating to GameObject | Align with View or
    pressing *Ctrl* + *Shift* + *F* (*cmd* + *shift* + *F*). This means that we can
    use the camera controls to place the Scene window camera where we would like our
    object to be and place the object there by aligning it with the camera.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 场景窗口相机在游戏窗口中不可见，但通常使用我们之前提到的快捷键移动和放置要容易得多。编辑器允许我们通过导航到“GameObject”|“与视图对齐”或按*Ctrl*
    + *Shift* + *F*（*cmd* + *shift* + *F*）来对齐所选对象并旋转场景窗口相机。这意味着我们可以使用相机控制将场景窗口相机放置在我们希望对象所在的位置，并通过与相机对齐来放置对象。
- en: Similarly, we can align the Scene window camera to the selected object by selecting GameObject | Align
    View to Selected (note that there is no hotkey for this on either Windows or macOS).
    This is useful for checking whether the given object is pointing in the right
    direction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以通过选择“GameObject”|“将视图对齐到所选对象”来将场景窗口相机对齐到所选对象（请注意，在Windows或macOS上都没有此快捷键）。这对于检查给定对象是否指向正确的方向很有用。
- en: We can perform similar component-based filtering on the Scene window, just like
    we can with the Hierarchy window, by using the `t:<component>` syntax within its
    search bar. This will cause the Scene window to only render objects containing
    the given component (or those that derive from it). Note that this textbox is
    linked to the same textbox in the Hierarchy window, so anything we type in one
    will automatically affect the other, which is very helpful when we're searching
    for elusive objects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在场景窗口中执行类似于层次窗口的基于组件的过滤，通过在其搜索栏中使用`t:<component>`语法。这将导致场景窗口仅渲染包含给定组件（或从它派生的）的对象。请注意，此文本框与层次窗口中的相同文本框链接，因此我们在一个中输入的内容将自动影响另一个，这在搜索难以找到的对象时非常有帮助。
- en: At the very top right of the Unity Editor is a dropdown menu labeled Layers.
    This contains a layer-based filtering and locking system for the Scene window.
    Enabling the eye icon for a given layer will show/hide all the objects of that layer within
    the Scene window. Toggling the lock icon will allow or prevent objects of the
    given layer from being selected or modified (through the Editor UI, at least).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity编辑器的最右上角是一个标签为“层”的下拉菜单。它包含场景窗口的基于层的过滤和锁定系统。启用给定层的眼睛图标将显示/隐藏场景窗口中该层的所有对象。切换锁定图标将允许或阻止选择或修改给定层的对象（至少是通过编辑器UI）。
- en: 'This is helpful when we wish to prevent someone from accidentally selecting
    and moving background objects that have already been placed correctly:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这在希望防止某人意外选择和移动已经正确放置的背景对象时很有帮助：
- en: '![](img/37a01587-902c-4fbf-953f-e6173e46467e.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37a01587-902c-4fbf-953f-e6173e46467e.png)'
- en: A well-known and useful feature of the Editor is that GameObjects can be given
    special icons or labels to make them easier to find in the Scene window. This
    is particularly helpful for objects with no renderer but that we wish to find easily.
    For instance, objects such as Lights and cameras have built-in icons that identify
    them in our Scene window more easily. However, the same gizmos can be revealed
    within the Game window by clicking on the Gizmos button at the top right of the Game window.
    The dropdown for this option determines what gizmos will be visible when this
    option is enabled.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的一个知名且实用的功能是，可以为游戏对象分配特殊的图标或标签，以便在场景窗口中更容易找到它们。这对于没有渲染器但我们希望容易找到的对象尤其有帮助。例如，灯光和相机等对象具有内置的图标，可以在我们的场景窗口中更容易地识别它们。然而，可以通过在游戏窗口右上角点击“
    Gizmos”按钮来显示相同的工具。此选项的下拉菜单确定在启用此选项时将可见哪些工具。
- en: Playmode
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放模式
- en: Since Playmode changes are not automatically saved, it is wise to modify the
    tint color that's applied during Playmode to make it blatantly obvious which mode
    we're currently working with. This value can be set by navigating to Edit | Preferences | Colors | Playmode
    tint.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“播放模式”更改不会自动保存，因此修改在“播放模式”期间应用的颜色调色板以使其明显，以便我们知道我们目前正在使用哪种模式是明智的。此值可以通过导航到“编辑”|“首选项”|“颜色”|“播放模式调色板”来设置。
- en: Changes can be saved from Playmode simply using the clipboard. If we're tweaking
    an object in Playmode and we're happy with its settings, then we can copy the
    object into the clipboard using *Ctrl* + *C* (*cmd* + *C*) and paste it back into
    the scene once Playmode ends via *Ctrl* + *V* (*cmd* + *V*).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单地使用剪贴板从“播放模式”保存更改。如果我们正在“播放模式”中调整对象，并且对其设置感到满意，那么我们可以使用 *Ctrl* + *C* (*cmd*
    + *C*) 将对象复制到剪贴板，并在“播放模式”结束后通过 *Ctrl* + *V* (*cmd* + *V*) 将其粘贴回场景。
- en: All of the settings that have been applied to the object at the time of the
    copy will be kept. The same can be done with individual values of entire components
    if we use the Copy Component and Paste Component options in the component's context
    menu. However, the clipboard can only contain data for one `GameObject`, component,
    or value at a time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制对象时应用的所有设置都将被保留。如果我们使用组件上下文菜单中的“复制组件”和“粘贴组件”选项，也可以对整个组件的单独值进行相同的操作。然而，剪贴板一次只能包含一个
    `GameObject`、组件或值的资料。
- en: Another approach, which allows us to save the data of multiple objects during Playmode,
    is to create Prefabs from them by dragging and dropping them into the Project window
    at runtime once we're happy with the settings. If the original object was derived
    from a Prefab, and we wish to update it across all instances, then we only need to
    overwrite the old Prefab with the new one we created by dragging and dropping
    the copy on top of the original. Note that this also works while Playmode is active,
    but it can be dangerous since there is no dialog popup to confirm the overwrite.
    Be very careful not to overwrite the wrong Prefab.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，允许我们在“播放模式”期间保存多个对象的资料，是通过在设置满意后，将它们拖放到运行时的“项目”窗口中创建 Prefabs。如果原始对象是从
    Prefab 派生的，并且我们希望更新所有实例，那么我们只需要用新创建的 Prefab 覆盖旧的 Prefab，方法是将复制的副本拖放到原始对象上方。请注意，这也可以在“播放模式”激活时进行，但它可能很危险，因为没有弹出对话框来确认覆盖。务必非常小心，不要覆盖错误的
    Prefab。
- en: We can use the Frame Skip button (the button to the right of the Pause button
    in the Editor) to iterate one frame at a time. This can be useful for watching
    frame by frame physics or gameplay behavior. Keep in mind that this causes one `FixedUpdate` and
    one `Update` to be called per iteration, in equal counts, which may not reflect
    the actual runtime behavior, where we tend to have an unequal number of calls
    to these callbacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“帧跳过”按钮（位于编辑器中“暂停”按钮右侧的按钮）逐帧迭代。这可以用来观察逐帧的物理或游戏玩法行为。请记住，这会导致每次迭代调用一个 `FixedUpdate`
    和一个 `Update`，数量相等，这可能不会反映实际的运行时行为，我们往往对这些回调的调用次数是不相等的。
- en: If the Pause button is enabled when Playmode begins, then the game will be paused
    just after the very first frame, giving us a chance to observe any anomalies that
    occurred during the initialization of our scene.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在“播放模式”开始时启用了“暂停”按钮，那么游戏将在第一帧之后立即暂停，给我们一个机会观察在场景初始化期间发生的任何异常。
- en: Scripting tips
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本技巧
- en: If you are a developer, you will spend a lot of time editing code. While artists
    and designers are playing with colorful images and visual effects, you may find
    yourself stuck in the black and white code editor domain. Coding may be hard sometimes,
    but it doesn't need to be tedious. In the following tips, we will learn how to
    simplify some of the most boring parts of the job.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名开发者，你将花费大量时间编辑代码。当艺术家和设计师在玩彩色图像和视觉效果时，你可能会发现自己被困在黑白代码编辑器领域。有时候编码可能很难，但它不需要枯燥。在以下技巧中，我们将学习如何简化工作中一些最无聊的部分。
- en: General
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用
- en: 'We can modify various templates of the new script, as well as shader and compute
    shader files. This can be helpful if we want to remove the empty Update stubs
    which, as we covered in Chapter 2, *Scripting Strategies*, can cause unnecessary
    runtime overhead. These files can be found in the following locations:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改新脚本的各个模板，以及着色器和计算着色器文件。如果我们想删除在第二章“脚本策略”中提到的可能导致不必要的运行时开销的空 Update 桩，这可能会很有帮助。这些文件可以在以下位置找到：
- en: Windows: `<Unity install>\Editor\Data\Resources\ScriptTemplates\`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows: `<Unity install>\Editor\Data\Resources\ScriptTemplates\`'
- en: macOS: `/Applications/Unity/Editor/Data/Resources/ScriptTemplates/`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'macOS: `/Applications/Unity/Editor/Data/Resources/ScriptTemplates/`'
- en: The `Assert` class allows for assert-based debugging, which some developers
    are more comfortable with, as opposed to exception-based debugging. Check out the Unity
    documentation for more information on `Assert`: [http://docs.unity3d.com/ScriptReference/Assertions.Assert.html](http://docs.unity3d.com/ScriptReference/Assertions.Assert.html).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Assert`类允许进行基于断言的调试，这对于一些开发者来说可能更舒适，而不是基于异常的调试。有关`Assert`的更多信息，请参阅Unity文档：[http://docs.unity3d.com/ScriptReference/Assertions.Assert.html](http://docs.unity3d.com/ScriptReference/Assertions.Assert.html)。'
- en: Attributes
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Attributes are very useful meta-level tags that can be given to almost any target
    in C#. They are commonly used on fields and classes, allowing us to flag them
    with special properties so that they can be processed differently. Intermediate
    and advanced Unity developers will find it worthwhile to read the C# documentation
    on attributes and use their imagination to come up with their own attributes that
    help accelerate their workflow. There are quite a few attributes built into the
    Unity engine that can be exceptionally useful when used in the right place.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是非常有用的元级标签，可以赋予C#中的几乎任何目标。它们通常用于字段和类上，允许我们用特殊属性标记它们，以便它们可以以不同的方式处理。中级和高级Unity开发者会发现阅读C#文档中的属性内容并发挥想象力来创建自己的属性以帮助加速他们的工作流程是值得的。Unity引擎中内置了许多属性，当在正确位置使用时可以非常有用。
- en: Advanced users will note that attributes can also be given to enums, delegates,
    methods, parameters, events, modules, and even assemblies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 高级用户会注意到，属性也可以赋予枚举、委托、方法、参数、事件、模块，甚至程序集。
- en: Variable attributes
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量属性
- en: The `[Range]` attribute can be added to an integer or floating-point field to
    convert it into a slider in the Inspector window. We can provide minimum and maximum
    values, thus limiting the range that the value can contain.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Range]`属性可以添加到整数或浮点字段中，将其转换为检查器窗口中的滑块。我们可以提供最小值和最大值，从而限制值可以包含的范围。'
- en: Normally, if a variable is renamed, even if we do a refactor through our IDE,
    then the values are lost as soon as Unity recompiles the `MonoBehaviour` and makes
    the appropriate changes to any instances of the component. However, the `[FormerlySerializedAs]` attribute
    is incredibly helpful if we want to rename a variable that has been previously
    serialized, since it will copy the data from the variable that was named within
    the attribute into the given variable at compile time. No more lost data due to
    renaming stuff!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果变量被重命名，即使我们通过IDE进行重构，那么值也会在Unity重新编译`MonoBehaviour`并对组件的任何实例进行适当更改时丢失。然而，如果我们要重命名之前已序列化的变量，`[FormerlySerializedAs]`属性非常有帮助，因为它将在编译时将属性中命名的变量的数据复制到指定的变量中。不再因为重命名而丢失数据！
- en: Note that it isn't safe to remove the `[FormerlySerializedAs]` attribute after
    the conversion is completed unless the variable has been manually changed and
    resaved into every relevant Prefab since the attribute was included. The `.prefab` data
    file will still contain the old variable name, and so it still needs the `[FormerlySerializedField]` attribute
    to figure out where it should place the data the next time the file is loaded
    (for example, when the Editor is closed and reopened). Thus, this is a helpful
    attribute, but extended use does tend to clutter up our code base a lot.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，转换完成后，除非变量已被手动更改并重新保存到自属性包含以来的每个相关Prefab中，否则移除`[FormerlySerializedAs]`属性是不安全的。`.prefab`数据文件仍将包含旧变量名，因此它仍然需要`[FormerlySerializedField]`属性来确定下次文件加载时应放置数据的位置（例如，当编辑器关闭并重新打开时）。因此，这是一个有用的属性，但过度使用往往会使我们的代码库变得杂乱。
- en: Class attributes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: The `[SelectionBase]` attribute will mark any `GameObject` the component is
    attached to as the root of selection for the Scene window. This is especially
    useful if we have meshes that are children of other objects since we may want
    the parent object to be selected with the first click, instead of the object with
    the `MeshRenderer` component.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`[SelectionBase]`属性将标记组件附加到的任何`GameObject`作为场景窗口的选择根。如果我们有其他对象的子对象网格，这特别有用，因为我们可能希望第一次点击时选择父对象，而不是带有`MeshRenderer`组件的对象。'
- en: If we have components with a strong dependency, we can use the `[RequireComponent]` attribute
    to force level designers to attach vital components to the same `GameObject`.
    This ensures that any dependencies that our code base relies on will be satisfied
    by designers, without us having to write out a whole bunch of documentation for
    them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一些具有强依赖性的组件，我们可以使用`[RequireComponent]`属性来强制关卡设计师将关键组件附加到同一个`GameObject`上。这确保了我们的代码库所依赖的任何依赖项都将由设计师满足，而无需为我们编写大量文档。
- en: 'The `[ExecuteInEditMode]` attribute will force the object''s `Update()`, `OnGUI()`,
    and `OnRenderObject()` callbacks to be called during Edit Mode. However, there
    are some caveats to this, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ExecuteInEditMode]`属性将强制在编辑模式期间调用对象的`Update()`、`OnGUI()`和`OnRenderObject()`回调。然而，这里有一些需要注意的事项，如下所示：'
- en: The `Update()` method is only called if something changes in the scene, such
    as moving the camera around or changing an object property
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在场景中发生变化时，例如移动相机或更改对象属性时，才会调用`Update()`方法。
- en: '`OnGUI()` is only called during Game window events and not for other window
    events, such as the Scene window'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnGUI()`仅在游戏窗口事件期间被调用，而不是其他窗口事件，例如场景窗口'
- en: '`OnRenderObject()` is called during any repaint event for the Scene and Game windows'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnRenderObject()`在场景和游戏窗口的任何重绘事件期间被调用'
- en: However, this attribute gives such objects a different set of event hooks and
    entry points compared to typical Editor scripts, so it still has its uses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个属性为这些对象提供了一组与典型编辑器脚本不同的事件钩子和入口点，因此它仍然有其用途。
- en: Logging
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: 'We can add rich text tags to debug strings. Tags such as `<size>`, `<b>` (bold), `<i>` (italics),
    and `<color>` work on debug strings. This can help us differentiate between the
    different kinds of log messages and allows us to highlight specific elements,
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向调试字符串添加丰富的文本标签。例如，`<size>`、`<b>`（粗体）、`<i>`（斜体）和`<color>`标签在调试字符串中有效。这可以帮助我们区分不同类型的日志消息，并允许我们突出显示特定元素，如下所示：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The error message we will obtain is as shown as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得的错误消息如下所示：
- en: '![](img/95010d6d-9171-49ff-ad7c-455b1351bf09.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95010d6d-9171-49ff-ad7c-455b1351bf09.png)'
- en: The `MonoBehaviour` class has a `print()` method for convenience, which does
    the same thing as `Debug.Log()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour`类有一个方便的`print()`方法，它与`Debug.Log()`做同样的事情。'
- en: It can help to create a custom logger class, which automatically appends `\n\n` to
    the end of every log message. This will push away the unnecessary `UnityEngine.Debug:Log(Object)` clutter
    that tends to fill the Console window.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自定义的日志器类可能会有所帮助，该类会自动将`\n\n`追加到每个日志消息的末尾。这将推离通常填充控制台窗口的`UnityEngine.Debug:Log(Object)`杂乱信息。
- en: Useful links
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用链接
- en: Unity provides many useful tutorials on the usage of various scripting features,
    which primarily target beginner- and intermediate-level developers. These tutorials
    can be found at [https://unity3d.com/learn/tutorials/topics/scripting](https://unity3d.com/learn/tutorials/topics/scripting).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了许多关于各种脚本功能使用的有用教程，这些教程主要针对初学者和中级开发者。这些教程可以在[https://unity3d.com/learn/tutorials/topics/scripting](https://unity3d.com/learn/tutorials/topics/scripting)找到。
- en: There's a helpful post on Unity Answers that provides a reference list that
    covers many of the different scripting and compilation errors we may run into
    during development. This can be found by searching for `Scripting` at [https://learn.unity.com/](https://learn.unity.com/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Answers上有一篇有用的帖子，提供了涵盖我们在开发过程中可能遇到的大多数不同脚本和编译错误的参考列表。您可以通过在[https://learn.unity.com/](https://learn.unity.com/)上搜索“Scripting”来找到它。
- en: Nested coroutines is an interesting and useful area of scripting that is not
    well documented. However, the following old but still valid third-party blog post,
    which covers a lot of the interesting details, should be considered when working
    with nested coroutines: [http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper](http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套协程是一个有趣且有用的脚本领域，但文档并不完善。然而，在处理嵌套协程时，以下这篇虽然老旧但仍然有效的第三方博客文章，涵盖了大量有趣细节，应该被考虑：[http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper](http://www.zingweb.com/blog/2013/02/05/unity-coroutine-wrapper)。
- en: Custom Editor scripts and menu tips
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义编辑器脚本和菜单提示
- en: 'While it''s common knowledge that we can create an Editor menu item in an Editor
    script with the `[MenuItem]` attribute, a less well-known ability is being able
    to set custom hotkeys for menu items. For example, we can make the <q>K</q> key
    trigger our menu item method by defining that the `[MenuItem]` attribute ends
    with `_k`, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然众所周知，我们可以在 Editor 脚本中使用 `[MenuItem]` 属性创建 Editor 菜单项，但一个不太为人所知的能力是能够为菜单项设置自定义快捷键。例如，我们可以通过定义
    `[MenuItem]` 属性以 `_k` 结尾来使 `<q>K</q>` 键触发我们的菜单项方法，如下所示：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also include modifier keys such as *Ctrl* (*cmd*), *Shift*, and *Alt* using
    the `%`, `#`, and `&` characters, respectively.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `%`、`#` 和 `&` 字符分别表示 *Ctrl* (*cmd*)、*Shift* 和 *Alt* 来包括修饰键。
- en: '`[MenuItem]` also has two overloads, which allow us to set two additional parameters:
    a Boolean that determines whether the menu item requires a validation method and
    an integer that determines the menu item''s priority in the Hierarchy window.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`[MenuItem]` 也有两个重载，这使我们能够设置两个额外的参数：一个布尔值，用于确定菜单项是否需要验证方法，以及一个整数，用于确定菜单项在 Hierarchy
    窗口中的优先级。'
- en: Check out the documentation for `[MenuItems]` for a complete list of available
    hotkey modifiers, special keys, and how to create validation methods: [http://docs.unity3d.com/ScriptReference/MenuItem.html](http://docs.unity3d.com/ScriptReference/MenuItem.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `[MenuItems]` 的文档，以获取可用的快捷键修饰符、特殊键以及如何创建验证方法的完整列表：[http://docs.unity3d.com/ScriptReference/MenuItem.html](http://docs.unity3d.com/ScriptReference/MenuItem.html)。
- en: It is also possible to *ping* an object in the Hierarchy window, similar to
    what happens when we click on a `GameObject` reference in the Inspector window
    and call `EditorGUIUtility.PingObject()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 Hierarchy 窗口中 *ping* 一个对象，这与我们在 Inspector 窗口中点击 `GameObject` 引用并调用 `EditorGUIUtility.PingObject()`
    时发生的情况类似。
- en: The original implementation of the `Editor` class, and the way that most people
    learned how to write Editor scripts, originally involved writing all the logic
    and content drawing in the same class. However, the `PropertyDrawer` class is
    an effective way of delegating Inspector window drawings to a different class
    from the main `Editor` class. This effectively separates input and validation
    behavior from display behavior, thus allowing for more fine-tuned control of rendering
    on a per-field basis and more effective reuse of code. We can even use `PropertyDrawer` to
    override default Unity drawings for built-in objects, such as `Vector` and `Quaternion`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Editor` 类的原始实现以及大多数人学习如何编写 Editor 脚本的方式，最初涉及在同一个类中编写所有逻辑和内容绘制。然而，`PropertyDrawer`
    类是有效地将 Inspector 窗口绘制委托给主 `Editor` 类之外的另一个类的方法。这有效地将输入和验证行为与显示行为分离，从而允许对每个字段进行更精细的渲染控制，并更有效地重用代码。我们甚至可以使用
    `PropertyDrawer` 来覆盖内置对象的默认 Unity 绘制，例如 `Vector` 和 `Quaternion`。'
- en: '`PropertyDrawer` makes use of the `SerializedProperty` class to accomplish
    the serialization of individual fields, and they should be preferred when writing
    Editor scripts since they make use of built-in undo, redo, and multi-edit functionality.
    Data validation can be a little problematic, and the best solution is to use `OnValidate()` calls
    in the *setter* properties. A session at Unite 2013, by Unity Technologies developer
    Tim Cooper, explains the benefits and pitfalls of various serialization and validation
    approaches in great detail ([https://www.youtube.com/watch?v=Ozc_hXzp_KU](https://www.youtube.com/watch?v=Ozc_hXzp_KU)).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`PropertyDrawer` 使用 `SerializedProperty` 类来完成单个字段的序列化，因此在编写 Editor 脚本时应优先使用它们，因为它们利用了内置的撤销、重做和多编辑功能。数据验证可能有点问题，最佳解决方案是在
    *setter* 属性中使用 `OnValidate()` 调用。Unity Technologies 开发者 Tim Cooper 在 2013 年 Unite
    大会上的一个会议详细解释了各种序列化和验证方法的优缺点 ([https://www.youtube.com/watch?v=Ozc_hXzp_KU](https://www.youtube.com/watch?v=Ozc_hXzp_KU))。'
- en: We can add entries to component context menus and even the context menus of
    individual fields with the `[ContextMenu]` and `[ContextMenuItem]` attributes.
    This allows us to customize the Inspector window's behavior for our components
    without needing to write broad `Editor` classes or custom Inspector windows.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `[ContextMenu]` 和 `[ContextMenuItem]` 属性向组件上下文菜单甚至单个字段的上下文菜单添加条目。这允许我们为我们的组件自定义
    Inspector 窗口的行为，而无需编写广泛的 `Editor` 类或自定义 Inspector 窗口。
- en: Advanced users may find it useful to store custom data within Unity metadata
    files through the `AssetImporter.userData` variable. There's also a multitude
    of opportunities to make use of Reflection in the Unity code base. Ryan Hipple's
    session at Unite 2014 outlines a huge number of neat little hacks and tricks we
    can use with Reflection in the Unity Editor ([https://www.youtube.com/watch?v=SyR4OYZpVqQ](https://www.youtube.com/watch?v=SyR4OYZpVqQ)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 高级用户可能会发现，通过`AssetImporter.userData`变量在Unity元数据文件中存储自定义数据很有用。在Unity代码库中还有许多利用反射的机会。Ryan
    Hipple在2014年Unite会议上的讨论概述了我们可以在Unity编辑器中使用反射的大量巧妙的小技巧和窍门（[https://www.youtube.com/watch?v=SyR4OYZpVqQ](https://www.youtube.com/watch?v=SyR4OYZpVqQ)）。
- en: External tips
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部技巧
- en: The following tips and tricks are related to topics outside the Unity Editor
    itself but can help Unity development workflow enormously.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下技巧和窍门与Unity编辑器本身之外的主题相关，但可以帮助极大地提高Unity开发工作流程。
- en: The Twitter hashtag `#unitytips` is a great resource for useful tips and tricks
    for Unity development and is, in fact, where many of the tips in this chapter
    originate from. However, hashtags are difficult to filter for tips you haven't
    seen before, and it tends to be abused for marketing. A great resource that pulls
    together a bundle of weekly tips from `#unitytips` can be found at [http://devdog.io/blog](http://devdog.io/blog).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter话题标签`#unitytips`是一个非常有用的Unity开发技巧和窍门的资源，实际上，本章中的许多技巧都源于此。然而，标签很难过滤出之前未看到的技巧，而且它往往被用于营销。可以在[http://devdog.io/blog](http://devdog.io/blog)找到这样一个资源，它汇集了来自`#unitytips`的一周内的一揽子技巧。
- en: Googling Unity-related problems or concerns can be made a lot faster if we start
    the search with `site:unity3d.com`, which will filter all the results so that
    only those under the `unity3d.com` domain will appear.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以`site:unity3d.com`开始搜索Unity相关的问题或担忧，可以大大加快搜索速度，这将过滤所有结果，只显示`unity3d.com`域下的结果。
- en: 'If the Unity Editor crashes, for whatever reason, then we can potentially restore
    our scene by renaming the following file to include the `.unity` extension (for
    scene files) and copying it into our `Assets` folder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Unity编辑器因任何原因崩溃，我们可以通过将以下文件重命名为包含`.unity`扩展名（对于场景文件）并将其复制到我们的`Assets`文件夹中来潜在地恢复我们的场景：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There is a great resource for game programming patterns (or, rather, typical
    programming patterns explained in a way that is pertinent to game development),
    and it's completely free and available online. The following guide includes more
    information on several of the design patterns and game features we explored in
    this book, such as the Singleton pattern, the Observer pattern, the Game loop,
    and doubling-up on frame buffers: [http://gameprogrammingpatterns.com/contents.html](http://gameprogrammingpatterns.com/contents.html).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于游戏编程模式的资源非常出色（或者更确切地说，是以与游戏开发相关的方式解释的典型编程模式），它是完全免费的，并且可在网上找到。以下指南包括关于我们在本书中探索的几个设计模式和游戏功能的信息，例如Singleton模式、观察者模式、游戏循环和帧缓冲区加倍：[http://gameprogrammingpatterns.com/contents.html](http://gameprogrammingpatterns.com/contents.html)。
- en: Keep an eye on any session videos that come from Unite conferences whenever
    they happen (or better yet, try to attend them). A couple of panels at each conference
    are usually held by Unity employees and experienced developers who will share
    lots of cool and interesting things they've been able to accomplish with the Engine
    and Editor. In addition to this, make sure that you involve yourself in the Unity
    community through the forums on[ https://unity3d.com](https://unity3d.com/), Twitter,
    Reddit, Stack Overflow, Unity Answers, or at whatever social gathering places
    pop out of the woodwork in the coming years.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时发生Unite会议，都要关注任何会议视频（或者更好的是，尝试参加它们）。每次会议通常都有几个由Unity员工和经验丰富的开发者主持的讨论小组，他们将分享他们能够使用引擎和编辑器完成的许多酷炫和有趣的事情。此外，确保您通过[https://unity3d.com](https://unity3d.com/)的论坛、Twitter、Reddit、Stack
    Overflow、Unity Answers或未来几年出现的任何社交聚会场所参与Unity社区。
- en: Every single tip that was included in this book wasn't conjured out of thin
    air. It started out as an idea or tidbit of knowledge that someone shared, somewhere,
    at some point, and somehow eventually found its way into this book. So, the best
    way to keep up to date on the best tips, tricks, and techniques is to keep our
    fingers on the pulse of where Unity is heading by staying involved in its community.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中包含的每一个技巧都不是凭空想出来的。它最初是一个想法或知识碎片，某人某时某地分享过，最终以某种方式进入了这本书。因此，要跟上最佳技巧、技巧和技术的前沿，最好的方式是保持对Unity未来方向的关注，通过参与其社区来保持我们的敏锐度。
- en: Other tips
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他技巧
- en: Finally, this section contains tips that didn't quite fit into the other categories.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本节包含了一些不太适合其他类别的技巧。
- en: It's always a good idea to organize our scenes using empty GameObjects and use
    them as parents for a group of objects while naming them something sensible for
    that group. The only drawback to this method is that the empty object's transform
    is included during position or rotation changes and is included during recalculations.
    As we know, reparenting `GameObject` to another transform has its own costs. Proper
    object referencing, transform change caching, and/or use of `localPosition`/`localRotation` can
    be used to solve some of these problems adequately. In almost all cases, the benefits
    of having a workflow from scene organization are significantly more valuable than
    such trivial performance losses.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空GameObject组织场景是一个好主意，并将它们用作一组对象的父对象，同时为该组对象命名一个合理的名称。这种方法唯一的缺点是，在位置或旋转更改期间，空对象的变换被包含在内，并且在重新计算时也被包含在内。正如我们所知，将`GameObject`重新父化到另一个变换有其自身的成本。适当的对象引用、变换更改缓存以及/或使用`localPosition`/`localRotation`可以适当地解决一些这些问题。在几乎所有情况下，从场景组织中获得的工作流程的好处远远超过这种微不足道的性能损失。
- en: Animator Override Controllers were introduced way back in Unity v4.3 but tend
    to be forgotten or rarely mentioned. They are an alternative to standard Animation
    Controllers, which allow us to reference an existing Animation Controller and
    then override specific animation states so that we can use different animation
    files. This allows for much faster workflows since we don't need to duplicate
    and tweak Animation Controllers multiple times; we only need to change a handful
    of animation states.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 动画器覆盖控制器（Animator Override Controllers）早在Unity v4.3版本中就已经引入，但往往被遗忘或很少被提及。它们是标准动画控制器（Animation
    Controllers）的替代品，允许我们引用现有的动画控制器，然后覆盖特定的动画状态，以便我们可以使用不同的动画文件。这允许我们拥有更快的流程，因为我们不需要多次复制和调整动画控制器；我们只需要更改少数几个动画状态。
- en: The amazing customizability of the Unity Editor and its ever-growing feature
    set means that there are tons of little opportunities to improve workflows, and
    more are being discovered or invented every single day. The asset store marketplace
    is absolutely rife with different products that try to solve some kind of problem
    that modern developers are having trouble with, which makes it a great place to
    browse if we're looking for ideas or, if we're willing, drop some money to save
    us a ton of hassle.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Unity编辑器的惊人可定制性和其不断增长的功能集意味着有无数的小机会可以改进工作流程，而且每天都有新的发现或发明。资产库市场充满了试图解决现代开发者遇到的各种问题的不同产品，这使得它成为寻找灵感或愿意花钱节省大量麻烦的好地方。
- en: Since these assets tend to sell to a broad audience, this keeps prices low,
    and we can pick up some amazingly useful tools and scripts for little to no cost.
    In almost all cases, it would take us a significant number of hours to develop
    the same solution ourselves. If we consider our time as valuable, then scanning
    the asset store once in a while can be a very cost-effective approach to development.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些资产倾向于销售给广泛的受众，这保持了价格低廉，我们可以以极低或无成本获得一些非常实用的工具和脚本。在几乎所有情况下，我们自己开发相同解决方案都需要花费大量的时间。如果我们认为我们的时间是宝贵的，那么偶尔扫描资产库可以是一种非常经济高效的开发方法。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to the end of this book. Hopefully, you have enjoyed the ride. To
    reiterate, perhaps the most important tip in this book is to always make sure
    that you verify the source of the performance bottleneck via benchmarking before
    making a single change. The last thing we want to waste time on is chasing ghosts
    in the code base when 5 minutes of Profiler testing can save us an entire day
    of work. In a lot of cases, the solution requires a cost-benefit analysis to determine
    whether we're not sacrificing too much in any other area at the risk of adding
    further bottlenecks. Make sure that you have a reasonable understanding of the
    root cause of the bottleneck to avoid putting other performance metrics at risk. To
    also reiterate the second most important tip in this book, always profile and
    test after making changes to ensure they had the intended effect.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的内容到此结束。希望你喜欢这次阅读之旅。再次强调，这本书中最重要的建议可能是，在做出任何更改之前，一定要通过基准测试来验证性能瓶颈的来源。我们最不想浪费时间的，就是在代码库中追逐幽灵，而5分钟的Profiler测试就能为我们节省整整一天的工作。在许多情况下，解决方案需要成本效益分析，以确定我们是否在其他任何领域牺牲了太多，从而增加了进一步的瓶颈。确保你对瓶颈的根本原因有合理的理解，以避免将其他性能指标置于风险之中。还要再次强调这本书的第二条重要建议，即在做出更改后，始终进行性能分析和测试，以确保它们产生了预期的效果。
- en: Performance enhancement is all about problem-solving, which can be a lot of
    fun since, due to the complexity of modern computer hardware, small tweaks can
    yield big rewards. There are many techniques that can be implemented to improve
    application performance or speed up our workflows. Some of these are hard to fully
    realize unless we have the necessary experience, skills, and time to implement
    them. In most cases, these fixes are relatively simple if we simply take the time
    to find and understand the source of the problem. So, go forth and use your repository
    of knowledge to make your games the best they can be!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升全在于问题解决，这可以是一件很有趣的事情，因为由于现代计算机硬件的复杂性，一些小的调整就能带来巨大的回报。有许多技术可以被实施来提高应用程序的性能或加快我们的工作流程。其中一些技术如果没有必要经验、技能和时间来实现，可能很难完全实现。在大多数情况下，如果我们花时间找到并理解问题的根源，这些修复相对简单。所以，大胆地去使用你的知识库，让你的游戏达到最佳状态！
