- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a 2D Collection Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015), you were introduced to the
    Unity Editor and its common windows and toolbars. We also created our first player
    character – the ladybug! Sadly, the ladybug is currently sitting in a vast nothingness
    without any goals providing value for its existence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll start putting the previous knowledge gained to good use
    by first adding more GameObjects to our Scene and creating a 2D, top-down environment
    for the *Outer World* collection game (our ladybugs will be happy indeed).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 2D top-down environment and designing a level is a trivial task when
    using the **Tilemap** feature. It allows you to create a palette of **Tiles**
    and then simply draw the level right within the Unity scene View.
  prefs: []
  type: TYPE_NORMAL
- en: There is only so much you can do with GameObjects and Unity’s built-in components
    alone, so you’ll be introduced to the **C#** language. Writing your own scripts
    in C# allows you to create the functionality your games and experiences require.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss how to create scripts and understand the best-practice approach
    to structuring code, principles, and patterns to follow that will keep your code
    easy to work with, maintain, and extend. These approaches to writing code will
    benefit you individually but also in a team environment, working with other professionals,
    since the structure and practices are widely adopted in the industry.
  prefs: []
  type: TYPE_NORMAL
- en: The first C# script we’ll be tackling is a **controller** to solve the problem
    of our ladybug character not having the ability to move. Throughout the book,
    we will use a *problem-solving* approach to define the process because it frames
    the coding requirements with an analytical mindset, breaking down a problem into
    smaller tasks while considering the overall solution. We’ll also be working with
    player input, so you’ll learn how to set up and connect your code to Unity’s new
    event-based **Input System**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 2D, top-down game environment with **Tilemap**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to creating scripts in C# – IDE, SOLID principles, and design
    patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a simple player controller with the new Input System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to quickly create a 2D, top-down,
    tile-based game environment, design a level, and understand how to create and
    edit C# scripts while considering best practice principles and design patterns.
    Our ladybug character will also be able to explore a cool new environment by responding
    to player input.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along in this chapter, you’ll need to have **Visual Studio Community
    2022** installed; we will be using this version throughout the chapters and projects
    in the book. This should have been installed with the Unity Editor in [*Chapter
    1*](B18347_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 2D, top-down game environment with Tilemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we will accomplish to create the collection game environment
    is some level design. The design of the level will affect how the game plays –
    how fun and how challenging it is. This will not be a comprehensive dive into
    level design; after all, we’re making a very simple collection game.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be focusing on just one principle of level design right now – guiding
    the player. Since this is a 2D, top-down view, the easiest way for us to guide
    the player is by using shapes in the level and introducing hazards. We can only
    do so much with such a simple game, but the principles can be applied to larger
    and more complex games.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visualizing design isn’t everyone’s strong suit – we all need creative help
    and inspiration sometimes. And while a **Game Design Document** (**GDD**) is good
    at describing things, it can only convey so much in so many words. As they say,
    a picture is worth a thousand words, so have a look at my initial sketch of what
    I was planning for the collection game’s level design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The collection game-level sketch](img/B18347_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – The collection game-level sketch
  prefs: []
  type: TYPE_NORMAL
- en: If you’re lacking inspiration or just prefer to follow along (no one here will
    judge you for it), then use my sketch for your own ends. I’ll probably sound like
    a broken record by the time you’re well into this book, but remember this – if
    you’re not having fun, you’re doing something wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore some examples of guiding the player.
  prefs: []
  type: TYPE_NORMAL
- en: Level design – Guiding the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By creating shapes in the level (also known as **leading lines**), we encourage
    the player to move in desirable directions. For example, from the position the
    player is spawned in, let’s start by giving them an open area directly in front
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: The sides of this open area will begin to angle inward as it gets farther from
    the player in the direction they face. This will create the appearance of an arrow
    shape. This shape will invite the player subconsciously to move forward in the
    direction the “arrow” is pointing.
  prefs: []
  type: TYPE_NORMAL
- en: Spawn/respawn/despawn player
  prefs: []
  type: TYPE_NORMAL
- en: '**Spawning** refers to the creation of the player in the game. This typically
    occurs at the beginning of gameplay when starting the game or when starting a
    level.'
  prefs: []
  type: TYPE_NORMAL
- en: A **respawn** is when the player is spawned after death or some game event that
    requires the player to restart at a specific position.
  prefs: []
  type: TYPE_NORMAL
- en: When the player is **despawned**, they are removed from the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Shapes are one of the tools we have in level design to guide the player through
    the environment, while another is hazards. Let’s have a look at using hazards
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hazards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The level design in a video game can influence the player’s movement through
    visual cues, and one of those cues is hazards. These elements can guide the player
    toward their next objective and progress gameplay forward while also changing
    the level’s difficulty by placing hazards in areas that the player must visit
    to complete the game’s objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | 2D level design
  prefs: []
  type: TYPE_NORMAL
- en: 'Level Design Patterns in 2D Games by *Ahmed* *Khalifa*: [https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games](https://www.gamedeveloper.com/design/level-design-patterns-in-2d-games)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned that shapes and hazards are simple concepts to
    guide the player, and they can be used with great effect if done well. It takes
    practice to make guidance subtle and blended/hidden into an environment design.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start practicing by creating the level for the 2D collection game. In
    the next section, we’ll be using the **Tilemap** feature that is a part of Unity’s
    2D toolset, and the first step in this workflow is to create a **Tile Palette**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tile Palettes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have closed Unity since the last time we worked on the player character
    in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015). To return where we left off
    in the project, open Unity Hub. The default view will list all of the projects
    you previously created. The list also includes some additional information about
    the project, such as the last time it was modified and the Editor version being
    used for it. You can see an example of this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Unity Hub Projects list](img/B18347_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The Unity Hub Projects list
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing projects from Unity Hub
  prefs: []
  type: TYPE_NORMAL
- en: You can add and remove projects from Unity Hub to keep your project list relevant.
    Add a project from disk by using the **Open** button at the top right of the window.
    Use the horizontal ellipses on the right side of each entry in the list to remove
    the project. Please note that removing a project from Hub will not delete it from
    the disk and will have to be cleaned up manually outside of Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Open the project you previously created from the **2D URP Core** template (in
    the screenshot shown in *Figure 2**.2*, it is the **My Project** project). Do
    that by simply clicking on the project name in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Before actually creating our tilemap, we need sprite images to work with. The
    following section will address adding sprites to the project that will form the
    basis of our first tilemap, used to construct the game’s level.
  prefs: []
  type: TYPE_NORMAL
- en: 2D game assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create the environment for our level, we’ll be using some freely available
    game assets. We’ll use original art assets in the upcoming chapters with different
    art pipelines and workflows, so you will gain a more rounded knowledge when dealing
    with 2D art in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Free game assets
  prefs: []
  type: TYPE_NORMAL
- en: '**Kenney** provides readymade game assets with no strings attached! Thousands
    of sprites are available – for many different themes and genres – for you to use
    in your own projects, with any kind of use allowed, even commercial. You can find
    all of the Kenney assets listed here: [https://kenney.nl/assets](https://kenney.nl/assets)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kenney** is a website that provides many pre-made sprite sheets and tilemap
    images. The main difference between these two graphics terms can be broken down
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: A **sprite sheet image** is an image made up of several smaller images (the
    left image in *Figure 2**.5*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **tilemap image** is an image made up of several smaller images arranged in
    a two-dimensional grid (the right image in *Figure 2**.5*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The terms *sprite sheet* and *tilemap* are often used interchangeably without
    much difference in meaning. I’ve attempted to clarify the terms practically and
    provide examples in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: 2D art is generally provided in sprite sheets since a single image is a more
    optimized way of working with images in a game engine instead of using individual
    images for each asset. Even if the 2D art is provided in single images, Unity
    has tooling that combines the individual sprite images into a single image for
    optimization (in this case, the combined or packed image in Unity is referred
    to as a **Sprite Atlas**). As mentioned previously, Kenney provides game assets
    in both sprite sheets and tilemap images.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: Sprite sheets are *more optimized* because they reduce the number of draw calls
    the renderer (graphics card) has to perform. All of the sprites included on the
    sheet can be drawn simultaneously, treating the entire sprite sheet as a single
    draw, whereas if they were individual sprites, they would need to be drawn separately.
    This reduction in draw calls can improve game performance (increasing the frame
    rate).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what 2D game asset images are, let’s import some assets
    from Kenney in the next section to understand importing and working with the images
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Importing sprites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Importing images into Unity is easy, but let’s first start with defining some
    organization in our project by creating some folders. Perform the following steps
    to create the `Sprites`, `Tile Palettes`, and `Tile` `Palettes/Tiles` folders:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the **Project** window to bring up the **Create** menu (or
    click on the **+** button at the top just under the **Project** tab) and select
    **Create** | **Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the folder `Sprites` and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 2* to create the `Tile` `Palettes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, after selecting the `Tile Palettes` folder, repeat *step 2* to create the
    `Tiles` folder (this folder is a subfolder of the `Tile` `Palettes` folder).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll be using two sprite sheets from Kenney in the collection game project
    to create the game environment – the **Top-down Tanks Redux** and **Tower Defense**
    (**top-down**) game assets. You can get the sprite sheets by downloading them
    directly from the [https://kenney.nl/assets](https://kenney.nl/assets) website,
    or they are also provided in the book’s project files available in the GitHub
    project (refer to the link in the *Technical* *requirements* section).
  prefs: []
  type: TYPE_NORMAL
- en: Once the folders are created and the sprite sheets have downloaded, we are now
    ready to import sprites. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: You can import sprites into Unity by either dragging them from the File Manager
    (Windows)/Finder (Mac) and dropping them into the Unity **Project** window or
    by right-clicking within the **Project** window and selecting **Import** **New
    Asset…**.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will be working with the *Tower Defense (top-down)* game asset’s `towerDefense_tilesheet.png`
    sprite sheet. Import the image into the `Assets/Sprites` folder, and once the
    asset has finished importing, selecting it in the **Project** window will display
    the sprite import settings in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Sprite import settings](img/B18347_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Sprite import settings
  prefs: []
  type: TYPE_NORMAL
- en: Since the sprite sheet comprises many images, we first want to change **Sprite
    Mode** to **Multiple**. Any time you change the import settings, you’ll have to
    click the **Apply** button at the bottom of the list of fields. Once clicked,
    we’ll move on to slicing the sprite sheet to create the individually selectable
    sprites.
  prefs: []
  type: TYPE_NORMAL
- en: Power of two textures
  prefs: []
  type: TYPE_NORMAL
- en: It is best to size textures with dimensions that are powers of two on all sides.
    The sizes are 2, 4, 8, 16, 32, 64, 128, 256, 512, 1,024, or 2,048 pixels (px).
    Note that the textures do not have to be square (for example, 256 x 1,024). Unity
    will use the non-power of two textures, although they will not be compressed (taking
    up more video memory) and not optimized (in some cases, slower to load and render).
    The **Inspector** window will display a warning when they cannot be compressed,
    as seen at the bottom of *Figure 2**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing the sprite sheet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With **Sprite Mode** set to *Multiple*, the imported image is now treated as
    a sprite sheet, with several smaller images needing to be defined. If we skip
    this step, all of the smaller images within the sprite sheet image will not be
    accessible, and we won’t be able to assign them to a **Sprite Renderer** or create
    tiles for use in the **Tilemap** **Tile Palette** for drawing or filling in our
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Sprite Editor by clicking the **Sprite Editor** button just below the
    **Sprite Mode** section fields (refer to *Figure 2**.3*). You’ll see that the
    sprite sheet is actually a tilemap image because the sprites are already arranged
    in a two-dimensional grid for us. This makes slicing easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: Next, click the `64` and `64`. This Kenney tilemap’s sprite cells are 64 pixels
    square, but you may end up working with sprites of different sizes, so you will
    have to set this value accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can keep the default values for the remainder of the fields in the dialog,
    so proceed to slice the image into sprites by clicking the **Slice** button. The
    slicing results should appear like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The Sprite Editor Tower Defense (top-down) tilemap](img/B18347_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The Sprite Editor Tower Defense (top-down) tilemap
  prefs: []
  type: TYPE_NORMAL
- en: Trimming sprites
  prefs: []
  type: TYPE_NORMAL
- en: For some sprites that don’t completely fill the grid cell, you may get some
    bleeding from neighboring sprites if some of the spacing was not adjusted just
    right. This is easy to fix by clicking on the offending sprite in the Sprite Editor
    and then clicking the **Trim** button (directly to the right of the **Slice**
    button).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s proceed to slice the other Kenney asset we’ll be using for the objects
    in the environment of the collection game now – the *Top-down Tanks Redux* game
    asset’s `Assets/Sprites/topdowntanks_onlyObjects_default.png` sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Again, after importing, select the image in the **Project** window to display
    the import settings in the **Inspector** window, set **Sprite Mode** to **Multiple**,
    click the **Apply** button (at the bottom), and finally, click the **Sprite**
    **Editor** button.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll likely notice right away that something is different with this image
    – it’s not a tilemap. Kenney provides game assets as sprite sheets for more game
    engines than just Unity. While this sprite sheet may work well in some other game
    engines, it, unfortunately, does not in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the smaller images had more padding (blank space represented by transparent
    pixels surrounding the image). In that case, Unity’s **Automatic** slice type
    setting may work as intended to slice into individual sprites – it does with sufficient
    padding – but in this case, it did not work and treated the whole sprite sheet
    image as a single Sprite.
  prefs: []
  type: TYPE_NORMAL
- en: So, to use the images from a sprite sheet that does not have sufficient padding
    to work well with Unity’s automatic slicing, you’ll have to open your favorite
    image editing software (for example, Adobe Photoshop, Gimp, or Krita) and rearrange
    the images with padding, or arrange them in a grid for slicing by cell size.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following screenshot, I chose to copy the images from
    the original Kenney sprite sheet (the left side) and create a new tilemap image
    with a consistent cell size layout (the right side – this image is included in
    the book’s project files).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Sprite Editor – automatic versus grid slicing](img/B18347_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Sprite Editor – automatic versus grid slicing
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: To reduce draw calls using a rendering technique called batching, a Sprite Atlas
    can be added to the project. Assigning individual sprites, sprite sheet images,
    and even folders to the Sprite Atlas will pack them into a single sprite sheet
    image to render from. This atlas will be the only asset being drawn from instead
    of multiple sprite images, where each additional sprite image would add a draw
    call to the renderer.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus activity, create a Sprite Atlas in the **Project** window from the
    **Create** menu by choosing **Create** | **2D** | **Sprite Atlas**. You can then
    assign both imported and sliced sprite sheets to the **Objects for Packing** list
    or the **Sprites** folder itself. You may need to verify that the feature is enabled
    (default) in **Project Settings** | **Editor** | **Sprite Packer** | **Mode =
    Sprite Atlas v2 –** **Enabled**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our tilemaps sliced into individual Sprites, we’re ready to
    create a Tile Palette. The Sprites will be added to a Tile Palette to create Tiles
    used to draw out the level. Let’s make our first Tile Palette in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Sprite** **Editor**: [https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/SpriteEditor.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tile Palettes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started creating Tile Palettes, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the **Tile Palette** window by going to **Windows** | **2D** | **Tile
    Palette**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll use the *Tower Defense (top-down)* game asset as our main environment
    map, so create a new **Tile Palette** by clicking the **Create New Palette** drop-down
    menu and selecting *New Palette*. This drop-down list is where we will be selecting
    the current Palette to use to draw the tilemap in the scene View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name it `Environment Main`; keep the defaults since we’re using a rectangle
    grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button, as shown in *Figure 2**.6*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Tile Palette is an asset saved in the `Project` folders, so you will be prompted
    to save it. Select the folder we previously created – `Assets/Tile Palettes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Creating a Tile Palette and Tiles](img/B18347_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Creating a Tile Palette and Tiles
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Tile Palette: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Palette.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: With the palette created, we can move on to the last step required before we
    can start drawing our level, and we’ll tackle that in the next section by adding
    Tiles to the Palette.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tiles are what the Tile Palette uses to draw sprites into the Scene. You may
    be wondering why we need to create Tiles if we already have our sprites sliced
    and ready to use as individual images. That’s because Tiles can provide additional
    functionality when drawing your tilemaps. Other types of Tiles are the **Rule
    Tile** and **Animated Tile**, but we’ll start by using the default Tile type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by dragging the `towerDefense_tilesheet.png` sprite sheet from the
    `Assets/Sprites` folder into the `Assets/Tile Palettes/Tiles` folder we already
    prepared for them. The result should look like the Tile Palette window in *Figure
    2**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start drawing our level, let’s have a quick look at two very useful
    types of Tiles.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Tiles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The common types of tiles include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule Tile**: This allows us to create rules where specified adjacent tiles
    will be used to draw complex shapes more easily. It is essentially an automated
    drawing tool. This is a huge time-saver!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a new Rule Tile, change to the `Tiles` folder in the `Assets/Tile
    Palettes/Tiles` named `Rule Tiles`. Right-click within the `Environment Area 1`,
    as shown in the **Inspector** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Rule Tile setup](img/B18347_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Rule Tile setup
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add Tiling Rules to create a filled square with appropriate corner sprites,
    adjacent to the horizontal and vertical side sprites. That makes nine sprites
    in total – four on the sides, four in the corners, and one in the center.
  prefs: []
  type: TYPE_NORMAL
- en: Set the `9`, and proceed to assign all the sprites from the environment sprite
    sheet by using *Figure 2**.7* as a guide. Once the sprites are assigned, we can
    set the “3 x 3” boxes that visualize the behavior of the Rule. Again, using *Figure
    2**.7*, set the box rules accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule** **Tile**: [https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/RuleTile.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Animated Tile**: This allows us to create a sprite animation by assigning
    several sprites to replace each other at a specified speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a new Animated Tile, change to the `Tiles` folder in the `Assets/Tile
    Palettes/Tiles`, named `Animated Tiles`. Right-click within the **Project** window
    to open the **Create** menu and go to **Create** | **2D** | **Tiles** | **Animated
    Tile** within the new folder. To use this tile, drag a sequence of sprites to
    the **Drag a Sprite or Sprite Texture assets to start creating an Animated** **Tile**
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Animated** **Tile**: [https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml](https://docs.unity3d.com/Packages/com.unity.2d.tilemap.extras%403.0/manual/AnimatedTile.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a quick recap concerning all the folders we’ve created to organize and
    contain all of our art assets, our **Project** window should look similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Project folder structure](img/B18347_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Project folder structure
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to create Tile Palettes, understood how to
    import and slice sprite sheets to create individual sprites, and explored the
    advantages of using Rule Tiles to make drawing easier.
  prefs: []
  type: TYPE_NORMAL
- en: This is all the prerequisite setup we need to draw the environment for our collection
    game level, so let’s get started doing just that. In the next section, we’ll add
    several tilemaps for the different components that make up the level design.
  prefs: []
  type: TYPE_NORMAL
- en: Building the collection game environment with Tilemap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need a new scene for the game level, so go to **File** | **New Scene**
    (*Ctrl*/*Cmd* + *N*). This will bring up the **New Scene** window, where we’ll
    select the **Lit 2D (URP)** Scene Template and then click the **Create** button
    in the window’s lower-right corner, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – New Scene Templates](img/B18347_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – New Scene Templates
  prefs: []
  type: TYPE_NORMAL
- en: Scene Templates – Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity provides a set of built-in Scene Templates, but you can add your own
    user-defined templates to create new scenes containing all of your starting content.
    For additional information on creating Scene Templates, refer to the Unity documentation
    here: [https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/scene-templates.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: A new `Game` or `Level`, since our game will consist entirely of just a single
    scene (that is, for a single game level).
  prefs: []
  type: TYPE_NORMAL
- en: With our new game scene saved, we’re ready to start adding tilemaps in the next
    section!
  prefs: []
  type: TYPE_NORMAL
- en: Adding tilemaps to a Scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Tilemap** is a component added to a GameObject that adds functionality just
    like any other component we previously discussed. The **Tilemap** component stores
    and manages the **Tile** assets used for creating 2D environments and levels.
    It also depends on a **Grid** component that provides a visual guide and aligns
    the painted tiles. We will make multiple tilemaps to serve different visual and
    functional purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To create a tilemap in the scene, from the `Tilemap – Background`. Refer to
    *Figure 2**.11* for an example of this in the **Hierarchy** window.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to control the drawing order of multiple
    tilemaps.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Layers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like we have a Sorting Layer on individual Sprites, we have one on tilemaps.
    The **Tilemap Sorting Layer** will allow us to draw sprites on different layers
    to control front-to-back layering (objects drawn on top of or behind others) and
    is applied to the whole tilemap (all the sprites that make up the tilemap).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new **Sorting Layer** for the background tilemap by clicking
    on the **Sorting Layer** drop-down list, which currently has a **Default** value,
    and click **Add Sorting Layer…**. The **Inspector** window will change to the
    **Tags & Layers** settings, where we’ll specify the following layers and their
    order: *Background*, *Collider*, *Objects*, and *Foreground*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Sorting Layers](img/B18347_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Sorting Layers
  prefs: []
  type: TYPE_NORMAL
- en: The renderer will draw the layers in the order they appear here, with **Layer
    0** (**Background**) at the back, **Layer 4** (**Foreground**) at the front, and
    the layers in between drawn in their respective locations.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the **+** button will add a new layer to the list while clicking the
    **-** button with a layer selected will remove it. Dragging **=** to the left
    of the field (for example, **Layer 0**) up/down will reorder. Once we’ve finished
    adding and setting the layer orders, click on **Tilemap - Background** in the
    **Hierarchy** window again and select *Background* in the **Tilemap Renderer Sorting**
    Layer drop-down field.
  prefs: []
  type: TYPE_NORMAL
- en: We still have the option of creating a second Tilemap background on the same
    Sorting Layer, and we can control which background draws above/below the other
    background by using the **Order in Layer** field – this is useful if you have
    two different style environments for your background and would like to manage
    them separately.
  prefs: []
  type: TYPE_NORMAL
- en: We are finally ready to start drawing with our Tiles in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the level in the scene view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’ve ever previously used a drawing program, then the painting tools in
    the Tile Palette’s toolbar will seem familiar, except that you will now be limited
    to painting on a grid. Paintbrush, flood fill, box fill, and eraser tools are
    all standard painting tools in drawing programs.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover all the painting tools in detail, but I encourage you to explore
    them on your own as you draw out your environment and level design – don’t be
    afraid to make mistakes! Like most things in Unity – and pretty much every program
    – you can quickly undo things by using *Ctrl*/*Cmd* + *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to save your progress as you go to keep what you like. Have fun with
    your drawing, and take the time to experiment because you never know where this
    type of creativity will lead.
  prefs: []
  type: TYPE_NORMAL
- en: Scene navigation
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder for getting around in the scene View while drawing out your level,
    refer back to *Navigating the scene View* section in [*Chapter 1*](B18347_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps every time you want to draw in the scene View using the
    painting tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by selecting the tilemap you want to paint on, either in the **Hierarchy**
    window or within the **Tile Palette** window, using the **Active Tilemap** drop-down
    list (just below the toolbar).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Palette** for the **Tile** you want to paint with using the **Tile
    Palettes** drop-down list located just below the **Active Tilemap** section on
    the left. For instance, we will choose the **Environment Main** palette that we
    created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the tile to paint with by clicking on it in the tiles section grid. Remember
    that we’re starting with the background of our level design, so pick a solid square
    tile that we can use to fill a large area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To paint individual tiles, by clicking on a grid cell in the scene View or painting
    continuous lines of sprites by clicking and dragging, select the **Paintbrush**
    tool (the paintbrush icon).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To draw a rectangular shape filled with the selected tile, select the **Box
    Fill** tool (the box icon).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also fill a larger contiguous area of grid cells with the selected tile
    by using the **Flood Fill** tool (the bucket icon).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Eraser** tool can erase tiles from the cell grid by clicking on them or
    clicking and dragging.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following figure illustrates the background tilemap selected in the **Hierarchy**
    window (*A*), a view of its components in the **Inspector** window (*B*), the
    environment palette (**Environment Main**) that we’re using to draw the background
    with (*C*), and both the selected tile (**grass**) (*D*) and painting tool (**Paintbrush**)
    currently being used (*E*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The Tilemap in the Hierarchy and Tile Palette windows](img/B18347_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The Tilemap in the Hierarchy and Tile Palette windows
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Painting on** **Tilemaps**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tilemap-Painting.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder of what we’re drawing here, we’re creating the background for
    the level of our collection game – defining the general play area. To visualize
    the overall level design plan, it may help to start drawing some of your ideas
    out on paper first, then using those ideas to start drawing things out in the
    Editor (refer to my initial sketch as a guide, if needed).
  prefs: []
  type: TYPE_NORMAL
- en: Paper prototyping
  prefs: []
  type: TYPE_NORMAL
- en: Paper prototyping is a widely used method in the game design process that helps
    you test out ideas before committing time to writing code or creating digital
    art assets. It’s also a quick way to validate your gameplay and discover potential
    problems early on.
  prefs: []
  type: TYPE_NORMAL
- en: While experimenting with your level design, consider that we’ll want to guide
    the player to where we’ll be placing collectibles throughout the level in the
    following sections. Don’t be afraid of making any mistakes; making changes in
    response to playtesting your games is something that you’ll have to do regularly
    – iterating changes to improve gameplay or balance the difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Before tailoring additional elements of the environment and level design, let’s
    make sure our art assets are looking their best in the game view by adjusting
    the **Camera** settings.
  prefs: []
  type: TYPE_NORMAL
- en: Camera settings for crisp graphics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The default settings Unity provides in new Scenes are not always ideal for the
    game assets you’ll be working with. Because of this, we’ll want to make some adjustments
    to our sprite sheet image import settings and our scene camera to have them looking
    their best!
  prefs: []
  type: TYPE_NORMAL
- en: The individual images in our tilemap image are 64 pixels square (note that these
    sizes could be different, depending on the desired size of the art for the game
    design dictates). The best way to work with tilemap images is to ensure that the
    individual sprite size equals the grid size. Since tilemap grid cells are sized
    to equal one square Unity unit, we’ll have to set our pixels per unit to equal
    one Unity unit.
  prefs: []
  type: TYPE_NORMAL
- en: To set the pixels per unit for the sprites in our *Tower Defense (top-down)*
    asset, click on the `towerDefense_tilesheet.png` image in the `Assets/Sprites`
    folder to view the import settings in the `64` (pixels).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now have to address the camera setting so that 64-pixel sprite images
    are represented on screen at their native resolution. These are the *crisp graphics*
    we are referring to – the native size. This will require a bit of math and a decision
    on the preferred resolution for the target platform. Assuming that most players
    on desktop systems – our target platform for the collection game – have a screen
    resolution of 1,920 px wide x 1,080 px high, let’s use that.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Main Camera** in the **Scene Hierarchy** window; then, in the **Projection**
    section, set the orthographic camera projection size (this is a vertical value)
    by taking the screen resolution height divided by the pixels per unit and dividing
    the result by 2 – we are dividing by 2 because the size value is half the vertical
    viewing volume of the camera. Here is what the calculation looks like with the
    resulting value set in the **Inspector** window – *(1,080 ÷ 64) ÷ 2 =* *8.4375*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – The camera orthographic size](img/B18347_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – The camera orthographic size
  prefs: []
  type: TYPE_NORMAL
- en: The number of sprites extending the vertical extent is now optimal for crisp
    graphics! To visualize the result in the Editor, switch to the **Game** view (by
    clicking on its tab next to **Scene**, just under the main toolbar) and set the
    **Aspect Ratio** drop-down list value to **Full HD (1920x1080)** – by default;
    this is set to **Free Aspect**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to draw tiles in the scene View to create the
    background environment and define the play area for the level. We also learned
    how to make our art assets look their best! Next, we’ll add some 2D lights – leveraging
    the Universal Render Pipeline’s (Universal RP, or URP) 2D features – to enhance
    the environment design.
  prefs: []
  type: TYPE_NORMAL
- en: Adding 2D lights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Universal RP 2D renderer allows us to enhance our environment by adding
    2D lights! Let’s add some 2D lights to the position of some tiles, representing
    light sources in our environment design. Follow these steps to add some *light
    sources*:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new tilemap for tiles that will draw above the background
    tilemap, and name it `Tilemap -` `Objects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Sorting Layer** to *Objects*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Environment Objects`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the sprites from the `topdowntanks_onlyObjects_default` sprite sheet to
    create the tiles used for painting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select *Tilemap - Objects* as **Active Tilemap** in the **Tile** **Palette**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the star-looking tile and paint a few in the Scene using the **Paintbrush**
    tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To focus work on a specific tilemap with the other GameObjects in the scene
    faded out, use the **Tilemap Focus** mode (the floating overlay in the scene View).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we have some light sources in the environment; now, let’s add some 2D
    lights to them by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty GameObject in the root of the scene’s `Lights`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Lights** GameObject – to open the **Create** menu – and
    select **Light** | **Freeform Light 2D** | **Circle.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the **Move** tool, position it over one of your *star* tiles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can experiment with what looks good to you. I changed the light’s **Blending**
    section’s **Blend Style** value to **Additive** (the default is **Multiply**)
    to better visualize the example screenshots. For a finished game, I would reduce
    the global light source intensity and use the **Multiply** blend style on many
    2D lights added to the environment to set the right lighting design tone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Light Blend** **Styles**: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4015.0/manual/LightBlendStyles.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Adjust the **Radius**, **Inner Spot Angle**/**Outer Spot Angle**, **Intensity**,
    and **Falloff Strength** values to your liking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat as necessary for all of the light sources in your environment design!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will want to adjust the overall lighting in the scene to use 2D lights to
    their full effect. Do this by selecting the **Global Light 2D** GameObject in
    the **Scene Hierarchy** window and adjusting the Light 2D component’s **Intensity**
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The results of adding 2D lights to the scene can be seen in *Figure 2**.13*
    – to the left and right sides of the player character (the ladybug). We’ll be
    using the different types of 2D lights in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to add 2D lights to your environment design
    to great effect. The following section will tackle a missing requirement to get
    our level playable by using the **TilemapCollider2D** component.
  prefs: []
  type: TYPE_NORMAL
- en: Making the level playable – Tilemap Collider 2D
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need to prepare our level design a bit more before we’re able to make
    it playable – we’ll be making the player character controllable in the next chapter
    by adding a custom script and mapping inputs.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the player from crossing into specified areas in the level, we need
    to add a special kind of collider to a tilemap. Colliders are a part of Unity’s
    Physics system and provide a way for developers to work with GameObjects, similar
    to how objects work in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Colliders prevent things from entering each other, and collisions of objects
    can all be responded to in code as events – we’ll be exploring this more in the
    upcoming chapters when adding features to our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a new tilemap to our scene to define areas that the player is not
    allowed to enter. This will be similar to how we created the previous tilemaps,
    except for having to add a **TilemapCollider2D** component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new tilemap for tiles that will draw above the background tilemap and
    contain areas the player cannot cross. Name it `Tilemap -` `Collider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Sorting Layer** to *Collider*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s use a `Rules Palette`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag in the `Assets/Tile Palettes/Rule` `Tiles` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select *Tilemap - Collider* as **Active Tilemap** in the **Tile** **Palette**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the rule tile and paint out areas in the scene using the **Filled** **Box**
    tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, to make this tilemap interactive, with **Tilemap - Collider** selected
    in the **Hierarchy** window, go to the bottom of the **Inspector** window and
    click the **Add Component** button. In the search field at the top of the dialog
    that opens, type *Tilemap*, and then select the **Tilemap Collider 2D** item to
    add it – we can use the default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following figure to get an idea of what we’re creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – A collider level design example in the scene View](img/B18347_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – A collider level design example in the scene View
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to add tilemaps, paint tiles in the scene, and sort
    the tilemap layers to set the proper drawing order, spend some time filling in
    environmental details. This is your time to experiment with detailing the environment’s
    design and think about how the player will be guided through the level to accomplish
    the game objective – collecting items.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned some key elements of level design. You understood
    how to create and work with tilemaps by importing and slicing sprite sheet images.
    To draw out a game level, you used tiles to paint individual sprites and areas.
    You completed the design by adding lights and making the graphics crisp. Finally,
    we made interactable objects through the use of colliders.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start bringing all of these concepts together in the following sections
    by adding C# scripts to move the player and collect items.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to creating scripts in C# – IDE, SOLID principles, and design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When making games in Unity, you’ll need to create your own functionality specific
    to the requirements of your game. We’ll need to learn how Unity provides programming
    support for writing scripts using the C# language to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll be introduced to the default code editor, get into the
    specifics of the C# language, and learn the best-practice approach to writing
    manageable, maintainable, and extensible code.
  prefs: []
  type: TYPE_NORMAL
- en: The IDE – Visual Studio Community 2022
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default **integrated development environment** (**IDE**) that Unity provides
    as part of the Unity Editor installation is **Microsoft Visual Studio 2022 Community
    Edition**. The Community Edition is free for students and individuals and provides
    a powerful IDE, with comprehensive tools and features for every stage of development,
    including tools specific to Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Visual Scripting
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Visual Studio 2022 to write C# code in this book, but it’s worth
    noting that Unity also offers a visual scripting option that uses a graph-based
    system instead of traditional code: [https://unity.com/features/unity-visual-scripting](https://unity.com/features/unity-visual-scripting)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Visual Studio 2022 interface, with its standard windows, features, and
    a script that is open for editing, can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Visual Studio 2022 Community Edition](img/B18347_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Visual Studio 2022 Community Edition
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to an essential script editing capability, let’s have a quick look
    at some of the features that Visual Studio 2022 provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliSense**: Aids in code completion by providing suggestions for naming,
    parameter info, and words – saving you keystrokes!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IntelliCode**: Enhances your software development with **artificial intelligence**
    (**AI**) that can automatically complete code – even up to a whole line!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeLens**: Keeps you focused on your code’s structure without leaving the
    IDE, code references, and contextual information at your fingertips!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live Share**: Provides a real-time collaborative coding session you can share
    with other members on your project – work together to produce results faster!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated debugging**: Allows the developer to control the execution, step
    through the code, and examine its state interactively while it’s running – see
    what your code is doing while it runs!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: '**What’s new in Visual Studio** **2022**: [https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/ide/whats-new-visual-studio-2022?view=vs-2022%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Before opening up the IDE to edit a script, we’ll first need to create one!
    Creating scripts can be performed in a couple of ways. It’s good practice to keep
    your project files organized from the start, so let’s first create a new folder
    named `Scripts` at the root of our project – `Assets/Scripts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new script in this folder, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the `Scripts` folder is the currently selected folder in the **Project**
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click within the **Project** window to open the **Create** menu (or use
    the **+** button).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **C# Script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the script from its default name of `PlayerController` (it’s currently
    highlighted to make naming it right away easier).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Do not use any spaces in your script filenames or start the script’s name with
    a number. Both are naming rule violations for C# classes, so your script will
    not work. You can use the underscore character in place of spaces. However, this
    naming convention style is generally frowned upon in the developer community –
    unless it is the first character of the name for private member variables (which
    is a common convention in C# and used in this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reference for a good naming convention standard to use – and stick to
    (because consistency and good naming improve code readability for everyone) –
    check out the following guide: https://[https://www.c-sharpcorner.com/UploadFile/8a67c0/C-Sharp-coding-standards-and-naming-conventions/](https://www.c-sharpcorner.com/UploadFile/8a67c0/C-Sharp-coding-standards-and-naming-conventions/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can also add new scripts (that is, components) to GameObjects directly in
    the **Inspector** window through the **Add Component** button at the bottom of
    the window (and when you currently have a GameObject selected). Click the **Add
    Component** button, and then select **New** **Script >**.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll be prompted to enter the script name, and then click `Assets` folder
    – so I prefer the methods previously mentioned to create in a specific folder.
  prefs: []
  type: TYPE_NORMAL
- en: New scripts are generated from the default template Unity provides (you can
    modify the template to suit your personal needs; see the following *C# Script
    Templates* callout box). New scripts are also given the `.cs` file extension,
    denoting them as C# script files (file extensions are not visible in the Unity
    **Project** window).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve named it `PlayerController` here, because the first C# code we’ll be writing
    in the next section is to give the ladybug player character we previously created
    the ability to move around from player input.
  prefs: []
  type: TYPE_NORMAL
- en: C# script templates – Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Script templates are what Unity uses to generate the default C# code when new
    scripts are created, providing commonly used code as a starting point for your
    scripts. You can modify the templates with your own changes, additions, notes,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional information can be found here: [https://support.unity.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates](https://support.unity.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Unity has also named the class in the script `PlayerController` as part of the
    script generation process (a function provided by the script template). Note that
    the filename and the class name must match for scripts that will need to be added
    as Components to GameObjects (otherwise, you’ll get a **Can’t add script component
    ‘ScriptName’ because the script class cannot be found.** error if you try). Refer
    to *Figure 2**.14* for an example of a new script’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: VS2022 is installed and configured as the default script editor for the C# scripts
    in your project when the Unity Editor is installed. You can verify this by going
    to **Edit** | **Preferences…** and selecting **External Tools** – the **External
    Script Editor** dropdown will be set to **Microsoft Visual Studio** **2022 [version]**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a script created and confirmed our script editor is configured,
    editing the script is as simple as doing any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-clicking on scripts in the **Project** Window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For components added to GameObjects in the Scene, right-clicking on the component
    in the **Inspector** window (or using the vertical ellipsis menu) and selecting
    **Edit Script**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening from within VS using the **Unity Project** **Explorer** window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned how to create a new script and open it for editing in VS, but
    we still need to understand what the C# code we’re looking at means. In the next
    section, let’s dissect the generated C# code for the player controller script.
  prefs: []
  type: TYPE_NORMAL
- en: The C# Language – Object-oriented programming (OOP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides coding support through the open source .NET **Common Language
    Runtime** (**CLR**) and uses the C# language – these are Microsoft technologies.
    C# is a managed language, which means that it provides a safe coding environment
    by – mostly – managing memory and the CLR safely executing the code (that is,
    not bytecode being executed by the operating system directly).
  prefs: []
  type: TYPE_NORMAL
- en: Code can be compiled to run **just-in-time** (**JIT**) or **ahead-of-time**
    (**AOT**), depending on which of the two scripting backends that Unity provides
    is used – Mono or **Intermediate Language to C++** (**IL2CPP**). The primary difference
    here is in compilation time, but some platform builds require one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Unity is a C++ game engine
  prefs: []
  type: TYPE_NORMAL
- en: The Unity game engine is written in C++, but C# is used as a “more friendly”
    coding language. The Unity Object type in C# is linked to a native C++ counterpart
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, the preceding paragraph was pretty boring. So, now comes the obligatory
    nerd warning… we’re going to talk about some programming concepts, principles,
    and design patterns in this and the next two sections. While these won’t teach
    you the basics of how to write a section of code that loops or even evaluates
    variables, I feel they are an important introduction at the onset of a developer’s
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: It’s essential to not only learn the basics (such as how to write code that
    loops and evaluates variables) but also to understand the broader concepts of
    how code should be structured – for the sake of your future developer self (and
    possibly for the benefit of your future developer teammates).
  prefs: []
  type: TYPE_NORMAL
- en: While I’ve attempted to make this section concise and provide relatable real-world
    analogies, these broader concepts on how code should be structured may be too
    early an introduction for some of you, so, in that case, don’t be afraid – still
    have a read and do your best to understand, but don’t worry if it’s difficult.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be implementing all of this as we work through the projects in the book
    (maybe you’ll even recall some of what was stated here or will want to come back
    and reread).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, with that now out of the way, let’s dive into the concepts that will level
    up your coding skills on your journey as a Unity developer!
  prefs: []
  type: TYPE_NORMAL
- en: The C# language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# (pronounced as *C sharp*) is a modern, object-oriented, type-safe, managed
    programming language. **Object-oriented programming** is a computer programming
    model that organizes software design around objects, which can contain data and
    code (classes) rather than functions and logic.
  prefs: []
  type: TYPE_NORMAL
- en: C# primarily being a type-safe language means that specific types can only interact
    through their defined protocols, which ensures each type’s consistency. For instance,
    you cannot write code to interact with a string type the same as if it were a
    number type.
  prefs: []
  type: TYPE_NORMAL
- en: 'OOP has four basic concepts for working with objects. We’ll review them briefly
    now and apply these concepts in practice while writing the code for our game in
    the upcoming chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**: Hide the internal data and behavior of an object (class)
    from other objects and only allow access through public methods; preventing objects
    from modifying other objects directly reduces the chance of making mistakes external
    to the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction**: An incomplete implementation that hides specific details and
    only provides required information but is also not associated with any particular
    instance, since an abstract class is intended only to be a base class of other
    classes. It provides a template to organize an object hierarchy with required
    details, such as a spotlight (object) being a type of light (abstract class) that
    requires a brightness property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: Abstraction is possible due to inheritance because a derived
    class inherits all properties and methods of the base class when creating a new
    class from it, which means we can reuse, extend, and modify the behavior of the
    base class. In the preceding light example, a point light will have the same brightness
    property as the spotlight if both are inherited from the light abstract base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism**: This is a Greek word, meaning *one name with many forms*
    or *having many forms*, which we can apply in C# to mean one name with multiple
    functions. Polymorphism allows a class to have multiple implementations with the
    same name by overriding it, thanks to inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuing with the preceding light example, we can implement inherited methods
    from the base class differently across the spotlight and point light abstractions
    by having different code for a `ChangeLightRadius()` method – a spotlight has
    a *cone* *of light*.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a point light is omnidirectional, so it behaves differently. Polymorphism
    helps in code reuse since classes, once written, tested, and implemented, can
    be reused as required and save a lot of time while keeping things more logically
    structured.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | C#
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft C# documentation for object-oriented** **programming**: [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/)'
  prefs: []
  type: TYPE_NORMAL
- en: The MonoBehaviour class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MonoBehaviour` class is the base class that every Unity script assignable
    to a GameObject derives from – this is Unity’s **component-based architecture**.
    You’ve seen the word *class* mentioned previously, so for clarity, a class is
    an object type. You will be creating custom object types that group variables,
    methods, and events together to give your script data and provide its intended
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving the class from `MonoBehaviour` – due to inheritance – provides a base
    set of variables, methods, and events for components added to GameObjects; this
    is also a requirement – you cannot add a script to a GameObject unless it inherits
    from `MonoBehaviour`. We’ll be using the functionality the `MonoBehaviour` base
    class provides for our custom script components throughout the projects in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Due to the nature of the **MonoBehaviour** class requiring it to be an instance
    of an object in the **Scene Hierarchy**, you cannot use the **new** keyword to
    create a new instance of it, as you could for a class that does not derive from
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the new `PlayerController` class we created previously, as generated
    from the default Unity template, already derives from `MonoBehaviour` for us –
    as denoted by `:` just after the `public class` declaration line in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: // (C#) | Code commenting
  prefs: []
  type: TYPE_NORMAL
- en: A single-line **comment** is started with two forward slashes (**//**). The
    C# compiler will strip out this text and ignore it when running the program.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be afraid to comment on anything and everything in the code to clarify
    the intent. There are always at least two people looking at your code when programming
    – you and yourself in 6 months’ time (or sometimes on any Monday morning). You
    *will* forget why you did what you did.
  prefs: []
  type: TYPE_NORMAL
- en: '**Self-commenting code**/**self-documenting code** is something that you may
    hear when discussing the topic of code commenting, which relies on good class,
    method, and variable naming. This, of course, is important. Still, my opinion
    is that you can spend an awful lot of time deliberating what to name things –
    while interrupting your train of thought – where a simple few words in a comment
    can instead bring quick clarity to the desired intention.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` and `Update()` methods are also provided for us. `MonoBehaviour`
    provides Message events for initializing any code in `Start()` and running code
    on each frame update in `Update()`. There are several other Message events that
    `MonoBehaviour` provides, and we’ll be exploring them in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: namespace (C#)
  prefs: []
  type: TYPE_NORMAL
- en: '**using UnityEngine;** at the top of the preceding **PlayerController** code
    example is what gives the containing code access to the **MonoBehaviour** base
    class. **Namespaces** are a way of organizing and providing levels of separation
    in your code. They are handy for providing containers to control the scope of
    classes and methods in larger projects. You can, and should, add your own namespaces
    to your classes.'
  prefs: []
  type: TYPE_NORMAL
- en: With the basics of understanding how to create a new C# script, open it in the
    VS IDE, and identify the essential parts of a `MonoBehaviour`-derived class out
    of the way, we can now explore some best-practice principles to follow as we write
    code for our game with SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SOLID** is an acronym adopted to represent the first five principles of object-oriented
    design by Robert C. Martin and applies to various programming languages, not just
    C#. They are basic design principles to keep the code you write maintainable and
    extensible while avoiding refactoring (restructuring existing code) unnecessarily
    in the future. The resulting code should be easily read and followed by other
    developers – avoid writing spaghetti code!'
  prefs: []
  type: TYPE_NORMAL
- en: Spaghetti code
  prefs: []
  type: TYPE_NORMAL
- en: '**Spaghetti code** is a phrase used to describe unstructured and difficult-to-understand-and-maintain
    source code in your projects. The cause can be attributed to several factors,
    which usually boil down to not following best practices such as SOLID principles,
    **don’t repeat yourself** (**DRY**), and clean code – code that is formatted correctly
    and organized in a manner that is easily read or modified by others, or by yourself
    in 6 months’ time!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SOLID principles are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**S –** **single-responsibility principle****(SRP)**: Each class or function
    (a *function* for a language-agnostic term, but I will refer to functions in C#
    as methods) in your code should only have a single responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It means *do one thing* and not everything, including the kitchen sink! Everything
    within the class should contribute to the one reason it exists. Multiple single-function
    classes can work together to complete larger, more complex tasks. If something
    breaks, it’s generally easier to know where the bug exists, and it will also be
    isolated from that class.
  prefs: []
  type: TYPE_NORMAL
- en: '**O –** **open-closed principle** **(OCP)**: Classes can be extended but not
    modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No, this is not a contradiction; how can something be both open and closed simultaneously?
    Well, it means that a class should be open for extension but closed for modification.
    Through polymorphism, we can change the behavior of an abstract base class by
    the inheriting class while leaving the base class unmodified. By designing base
    classes that *never change*, you prevent undesirable changes that propagate to
    dependent classes, contributing to code that is not reusable and ultimately harder
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '**L –** **Liskov substitution principle**: Methods that reference base classes
    must be able to use derived classes seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any function that uses a reference to a base class should be able to use a derivative
    of that class without knowing it. That might sound a bit confusing, so let’s use
    the light example from the earlier OOP concepts – a method that references a light
    should not care whether that light is a spotlight or a point light. We can substitute
    a point light for a spotlight, and the code should just work.
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish this substitution through the use of an **interface** (a type
    that is similar to a class, but it only represents a structure of declarations
    – this is commonly referred to as a **contract**, but you can also think of it
    as a *blueprint for a* *class definition*).
  prefs: []
  type: TYPE_NORMAL
- en: An interface can also be used to implement the **open-closed principle** by
    having a base class take an interface as an abstract reference for injecting different
    functionality. The functionality can be extended while the reference in the closed
    base class remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: '**I –** **Interface segregation principle**: Several smaller scope interfaces
    are preferred over a single monolithic interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes should not include behaviors they do not use in their single-responsibility
    role. In Martin’s original introduction, he describes it as a *disadvantage of
    fat interfaces*, where the functions of a large multipurpose interface can instead
    be broken up into groups of member functions to provide better cohesion. This
    can prevent classes from using interfaces that they do not require to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**D –** **Dependency inversion principle**: Use abstractions over direct class
    references.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last principle states that concrete classes should depend upon interfaces
    – or abstract functions and classes – rather than concrete functions and classes.
    Abstract classes should also not depend on concrete classes; interfaces should
    be used here. The advantage here means code requires less work to change because
    the interface abstractions decouple concrete classes – a change in one also does
    not break the other. Loosely coupled code is more flexible and easier to test.
    Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | SOLID principles
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the original quotes and ideas behind the SOLID principles, as introduced
    by Robert C. Martin, you can refer to this article: [https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp](https://learn.microsoft.com/en-us/archive/msdn-magazine/2014/may/csharp-best-practices-dangers-of-violating-solid-principles-in-csharp)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, just do some web searching on the subject: [https://www.google.com/search?q=SOLID+programming+principles](https://www.google.com/search?q=SOLID+programming+principles%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: After this brief introduction, you may not completely understand these principles,
    but don’t worry – we’ll be using them in practice in the upcoming chapters, so
    you will learn how they are implemented. With a basic understanding of the SOLID
    principles, we can now talk about design patterns that implement the ideas the
    SOLID principles present.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know what the C# language is and some principles to keep in mind
    while coding your games, let’s see how to apply them in practice.
  prefs: []
  type: TYPE_NORMAL
- en: When writing the code for your game, you can make your own decisions on how
    to approach the architecture. Within Unity, there aren’t any restrictions or specific
    ways things need to be set up – it can be as messy or as organized as you like.
  prefs: []
  type: TYPE_NORMAL
- en: However, it should be evident that the more disorganized and unstructured your
    code is, the harder it will be to work with and extend upon in the future. We’ve
    already touched on some fundamental principles with OOP and SOLID, but those are
    just principles to follow. To execute those principles, we use design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Common design patterns in games development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a list of common design patterns used to solve common problems
    when writing code – this is not an extensive list by any means, and we’re only
    touching on the reasons for the patterns here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MyClass.Instance.MyMember` (where `Instance` is the static variable and `MyMember`
    is any publicly accessible variable or method).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern gets a bad reputation for misuse, but it can be pretty helpful
    for small projects – it’s quick and easy to implement and use everywhere (hello,
    game jams!). This reputation is mainly related to more extensive projects where
    static variables make for code that’s harder to troubleshoot and debug – the general
    sentiment is that when you make something accessible to every part of the code,
    you’re just asking for trouble!
  prefs: []
  type: TYPE_NORMAL
- en: '`GetComponent()` method of its GameObject scripting API. Essentially, the locator
    will retrieve the reference to the required class or object instance so that it
    can be consumed in the calling method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer pattern (events)**: Another one of the most popular design patterns.
    This pattern enables a listener to register with and receive notifications from
    a provider. This is generally performed with a one-to-many relationship, where
    any number of listeners are notified when the provider object changes state and
    invokes the notification. This pattern in C# is implemented using events. An event
    is a special keyword in C# that enforces a proper pattern, where only the declaring
    class can invoke the notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameManager` class, where you could have states for loading, playing, paused,
    game over, win, lose, and so on. Events can be triggered when entering and exiting
    states to extend state-based functionality easily. The object the pattern is implemented
    on can also delegate state-related behavior to separate classes, such as a `Tick()`
    method called on every frame update.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command pattern**: This pattern turns a request for executing functions into
    an object that contains all the required information about the request. The command
    pattern is popular in C# for when we want to delay or queue a request’s execution,
    or when we would want to keep track of the sequence of operations (such as in
    a replay system).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other benefit of this pattern is that it decouples the invoking class from
    the object that executes the process – loosely coupled code (one class will not
    affect another class, reducing dependency) is easier to test and maintain!
  prefs: []
  type: TYPE_NORMAL
- en: '`Update()` method, each one is added to a list of scripts that need to be updated
    in each frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This pattern can reduce the number of `Update()` methods being called each frame
    to reduce overhead – these Unity messages are called from native C++ to managed
    C#, and they have a cost! For example, the manager will be the only object with
    an `Update()` method that runs on each frame update, while the many instances
    referenced only have a `Tick()` method that the manager calls.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Programming patterns
  prefs: []
  type: TYPE_NORMAL
- en: '**Game Programming Patterns** (the web version is free): [https://gameprogrammingpatterns.com/contents.xhtml](https://gameprogrammingpatterns.com/contents.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t need to use the Unity message events, then remove them from your
    code – even empty **Start()** and **Update()** methods are still cached and called
    on every script derived from **MonoBehaviour**, and in the case of **Update()**,
    it will be called on every frame update!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about creating scripts and editing them with the
    VS2022 IDE and received an introduction to the C# language, SOLID principles,
    and some common design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll dig into specific use cases in the upcoming chapters as we flesh out the
    features and functionality in our collection game, starting with the next section,
    where we’ll put together a simple player controller for our ladybug character.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a simple player controller with the new Input System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll be surprised to find that most of the work to make our player character
    move has already been done for us by Unity’s features. The features that we’ll
    be looking at in this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The new Input System**: For receiving keyboard device input from the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2D physics engine**: For translating input values into movement and providing
    interaction with objects in the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Input System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The new **Input System** is a package that provides input device support for
    controlling objects in your project in a flexible and configurable way. It also
    replaces the legacy Input Manager. We’ll first want to make sure that it’s installed
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Package Manager from the **File** menu by going to **Windows** | **Package
    Manager** and following these steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the **Packages** drop-down list is set to **Package: Unity Registry**
    (just under the window’s tab).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find **Input System** in the list of packages (the dialog’s left side) and click
    to select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, click the **Install** button in the window’s bottom-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.15 – The Input System installation Package Manager](img/B18347_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – The Input System installation Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: If, once the installation completes, you receive a warning stating **The project
    is using the new input system package, but the native platform backends for the
    new input system are not enabled in player settings**, go ahead and click **Yes**
    to enable the backends. Note that this will restart the Editor – so, if you have
    unsaved changes in your Scene, click **Save** when prompted.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Input** **System**: [https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/](https://docs.unity3d.com/Packages/com.unity.inputsystem%401.3/manual/)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re ready to start coding our player movement in the next section with the
    Input System installed.
  prefs: []
  type: TYPE_NORMAL
- en: Player controller script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we jump into coding, we’ll first need to understand that there are two
    ways we can work with the new Input System:'
  prefs: []
  type: TYPE_NORMAL
- en: Receiving input directly from an **Input Device**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving input through an **Input** **Action** indirectly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover both of these approaches in the book, but we’ll start with reading
    directly from an Input Device – the keyboard. Having determined our approach to
    receiving player input, let’s start coding that now, since we’ve already created
    our ladybug character’s player controller script in a previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving keyboard input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Processing player input through the keyboard directly from the Input Device
    is straightforward. You simply need to get a reference to the current keyboard
    device and read the property appropriate for the desired function. We read input
    in the `Update()` method because it runs every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at this portion of the `Update()` method in the following
    `PlayerController` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Within the `Update()` method (between the `{}` squiggly brackets), we start
    by assigning a variable (a container for storing data) for the current keyboard
    device with `var keyboard = Keyboard.current;` (in C#, every line of code to be
    executed must end in a semicolon).
  prefs: []
  type: TYPE_NORMAL
- en: var (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The **var** keyword is an implicitly typed variable that infers the type from
    the right side of the assignment statement (what comes after the equals sign).
    This means that we don’t need to use an **int** type for a math expression that
    returns an integer value – **var** will infer that it should be of an **int**
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '`Keyboard.current` is available to our code from the Input System, simply by
    including the namespace for `InputSystem` at the top of our script with the `using`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the current keyboard device is assigned to our keyboard variable, we can
    check to make sure a keyboard is connected by testing the variable against a `null`
    value, using the `== operator` (a single `=` is for assigning a value, whereas
    a double `==` is an *is* *equal?* operation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that if the keyboard value is equal to `null`, we stop running
    the code in this method immediately by using the `return` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: null (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The **null** value means there is *no* *object* assigned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: if (C#)
  prefs: []
  type: TYPE_NORMAL
- en: An **if** statement tests whether a condition is evaluated to **true** or **false**
    and executes the directly preceding block or line of code if **true**.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, a variable type that holds a **true** or **false** value is called a
    **bool** type (Boolean). A **bool** type has a default value of **false** when
    it’s declared without a specific value being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Moving with 2D physics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are receiving input from the player and are ready to process it now. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, following the single responsibility principle, we’d now
    create a second script to handle the player movement. For now, since our collection
    game is small, with a single input, it doesn’t require a more complex architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the player is holding down the *spacebar*, let’s move them forward while
    the key is held down and stop them moving when it’s released:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: else if (C#)
  prefs: []
  type: TYPE_NORMAL
- en: An **else if** statement tests a new condition only if the previous **if** statement
    evaluates to a **false** condition and executes the directly proceeding block
    or line of code if **true**. To evaluate multiple conditions, you can cascade
    multiple **else if** statements as many times as is required.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Update()` method is excellent for processing player input. Still,
    we want to move the player using `2D Physics`, and for that, we need to use `FixedUpdate()`
    – this is called every physics `0.02` (this value, generally, doesn’t need to
    be changed).
  prefs: []
  type: TYPE_NORMAL
- en: You might already wonder how we can tell a different Unity message event that
    is being called *automatically* to execute code from another Unity message event.
    We’ll simply use a `bool` variable as a *flag* to indicate that code should be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create one now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Public and private accessors (C#) | Serialization
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessors** such as **public** and **private** define the scope of a variable
    for how it can be accessed internally and externally by the class. A public accessor
    assigned to a variable makes it accessible to other external classes, whereas
    a private accessor makes it accessible only within the class. If you do not explicitly
    declare an accessor, the default will be internal (refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)).'
  prefs: []
  type: TYPE_NORMAL
- en: Another function of declaring a variable public is Unity marking it for serialization.
    **Serialization** is the process of transforming an object’s state into a format
    that Unity can use – this is required for fields to be available in the **Inspector**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created the variable as a private field to only be accessible within the
    `PlayerController` class. We did not assign a value when declaring it so that
    it will have a starting value of `false` – our flag will not prompt code execution
    when the program starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the code in `FixedUpdate()` to move the player, we’ll set it to
    `true`, with the *spacebar* key being held down and set back to `false` when it
    is released:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our player input code will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ll check the value of the `_shouldMoveForward` Boolean flag in `FixedUpdate()`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the **InputSystem** documentation for all the possible properties and
    methods available on a keyboard device. You can also see what is available right
    within the VS IDE when pressing the *.* (period/dot) character. IntelliSense will
    provide a list of all the possible choices for completion (for example, when typing
    **keyboard** and then **.**, the popup list will have both the **IsPressed()**
    method and the **wasReleasedThisFrame** property listed).
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody2D
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Moving objects in the Scene with the ability to interact with other objects
    is really quite easy when using the physics system – you get a lot of value *out
    of the box*, since you don’t have to program these interactions yourself. For
    example, moving the player is as simple as setting a velocity value for the direction
    of movement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following addition to our `FixedUpdate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added a line that assigns a value to an `Rb` object’s `velocity` property,
    by multiplying the `transform.up` value with a `MoveSpeed` variable’s value. `Rb`
    is a public field we declare, representing the `Rigidbody2D` component that we’ll
    add to the player GameObject in the `Rb` as public, assignments can also be made
    in the **Inspector** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add the declaration for `Rb` and the `MoveSpeed` variable – with a default
    value of `10f` (`f` indicates that this is a float value, a numeric value stored
    in floating-point representation) – to provide some speed to the movement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip | VS IntelliSense
  prefs: []
  type: TYPE_NORMAL
- en: You can type **MoveSpeed** first in the **Rb.velocity** assignment line of code,
    but VS will complain that it is not declared yet with a squiggly red underline.
    You can easily add the variable declaration to the code by first clicking on the
    underlined word, then pressing *Alt*/*Cmd* + *Enter*, and selecting the **Generate**
    field under **MoveSpeed**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting a value to `velocity`, we tell the object to move in a specified
    direction – that direction is indicated by `transform.up` – and at the speed indicated
    by the `MoveSpeed` multiplier value. The player sprite will always move in the
    direction indicated by `transform.up`, no matter its rotation, as seen in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The ladybug Sprite Transform.up direction](img/B18347_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The ladybug Sprite Transform.up direction
  prefs: []
  type: TYPE_NORMAL
- en: Transform.up (Unity API)
  prefs: []
  type: TYPE_NORMAL
- en: This manipulates the position of an object on the *Y* axis (the green axis)
    in world space. It’s similar to **Vector3.up**, but **Transform.up** instead moves
    the object while considering its rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Other axes available are right (the *X* axis – red) and forward (the *Z* axis
    – blue).
  prefs: []
  type: TYPE_NORMAL
- en: When the player releases the *spacebar* key, `_shouldMoveForward` is assigned
    `false`, which results in `Rb.velocity` being set to `Vector2.zero` – velocity
    is a `Vector2` structure, meaning that it can be used to represent 2D positions
    by `X` and `Y` values, as represented by this notation – `Vector2(float, float)`.
    `Vector2.zero` is shorthand for `Vector2(0`, `0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Vector2**: [https://docs.unity3d.com/ScriptReference/Vector2.xhtml](https://docs.unity3d.com/ScriptReference/Vector2.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Vector Math, Mathf, and Quaternion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code, so far, has tackled moving the player character in a forward direction
    in relation to the direction the sprite is facing. Still, it’s currently only
    facing one direction – up. We’ll guide our player around the environment by having
    it look in the direction of the mouse pointer – steering the forward movement.
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish this by reading another input device – the mouse – and using
    some vector math to rotate the player object, according to where the mouse pointer
    is positioned on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following `LookAtMousePointer()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the code item by item:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like how we verified we had a valid keyboard, `mouse` is being assigned
    and checked for `null` (stops running the code with `return` if none is assigned)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `mousePos` variable is assigned by the return value of the `mouse.position.ReadValue()`
    method, which returns a `Vector2` position, and uses the main camera reference
    in `Scene (Camera.main)` to convert its `Vector2` screen space position to a `Vector3`
    world point (the 3D coordinate system the Unity engine uses).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The direction from the mouse position to the `Rigidbody2D` position on the player
    is calculated using a simple vector math expression – subtracting one vector from
    another is a quick way to calculate the direction. Simple!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you can only use vector arithmetic operations on the same vector type
    – here, we have `Vector3` representing the mouse position and `Vector2` representing
    the `Rigidbody2D` position. To treat the `mousePos` variable as `Vector2` in the
    expression, we cast the value by prepending `(Vector2)` to it (we only need the
    `x` and `y` values for 2D).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need the rotation angle to apply to the player’s `Rigidbody2D`. Unity
    provides a math library for just such an occasion – `Mathf`. In particular, we’re
    using the `Atan2` method, which returns an angle in radians from a 2D vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll actually want our angle value to be in degrees of rotation – not radians
    – so again, `Mathf` to the rescue. `Mathf.Rad2Deg` is a conversion constant (equal
    to *360 / (PI x 2)*) that we’ll multiply with the returned radians, and with that,
    we have our degrees of rotation value. The `SpriteRotationOffset` public variable
    provides an offset if the sprite’s direction is not facing `Transform.right` –
    the direction the equation results in (we do need a value of -90 degrees here,
    since our ladybug sprite is pointing up, not right).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the resulting angle (in degrees of rotation) to the `Rb.rotation`
    property!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make sure our player rotation is being set every frame, add a call to the
    `LookAtMousePointer()` method at the end of `Update()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Smoothing rotation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Setting the `Rb.rotation` value for every frame update would be sufficient to
    make pointing the player in the direction of the mouse pointer work, but we can
    do better!
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish a smoother rotation and adjust the rotation speed to alter
    gameplay using an interpolation method that Unity provides, called **Slerp**.
    Slerp will smooth the rotation and remove abrupt rotations while providing a better
    game feel, enhancing the player experience.
  prefs: []
  type: TYPE_NORMAL
- en: Slerp (Unity API) | Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Slerp** is shorthand for **spherically interpolated**. It provides a method
    that interpolates values between *A* and *B* by an amount of *T*. The difference
    between this and **linear interpolation** (**Lerp**) is that the *A* and *B* vectors
    are treated as directions instead of location points.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quaternion.Slerp**: [https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml](https://docs.unity3d.com/ScriptReference/Quaternion.Slerp.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the direct rotation assignment (`Rb.rotation = angle;`) with the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this code:'
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate the rotation value, we’ll need to use a slightly different approach
    using `Quaternion` (based on complex numbers that represent rotations that can
    easily be interpolated and what Unity uses internally to represent all rotations).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first calculation we’ll need to get our angle degrees into a quaternion
    value (`var q`) is using the `AngleAxis()` method to calculate the rotation around
    an axis. Here, we provide `Vector3.forward` as our rotation axis – referring to
    *Figure 2**.16*, we can see that it will rotate the ladybug sprite on the *XY*
    plane, which is precisely what we want!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike with `Rb.rotation`, which required a float value for the angle degrees,
    we need to assign a quaternion value now, so we’ll have to use the `Rb.transform.rotation`
    property instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use `Quaternion.Slerp()` to interpolate the rotation value,
    producing a smooth rotation from the player character’s current rotation to the
    desired rotation – pointing in the direction of the mouse pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can change the rotation speed by using the `LookAtSpeed` public variable
    value. The speed value is multiplied by `Time.deltaTime` to make this a frame
    rate independent rotation speed (which means it will be consistent across all
    different performing systems that will run the game).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Time.deltaTime**: [https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml](https://docs.unity3d.com/ScriptReference/Time-deltaTime.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final variable declarations, including the newly added variables for `SpriteRotationOffset`
    and `LookAtSpeed`, with some default starting values assigned, look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: PlayerController.cs Code
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the completed code for the **PlayerCharacter** class, visit the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch2/Unity%20Project/Assets/Scripts)'
  prefs: []
  type: TYPE_NORMAL
- en: This section taught us how to read player input directly using Input Devices,
    move a `Rigidbody2D` object by manipulating its velocity, and implement smooth
    rotation using vector math and quaternions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced many subjects, including level design concepts, adding
    2D artwork to a project, preparing it with Unity’s 2D tooling as sprites, and
    using the prepared artwork to draw a 2D game environment with a **Tilemap**. We
    also created scripts using the C# language and Visual Studio IDE to add functionality
    to GameObjects, for reading input and moving the player character with physics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll add a virtual camera system to follow the ladybug
    character around the level, add a basic UI, and process conditions for winning
    and losing the game.
  prefs: []
  type: TYPE_NORMAL
