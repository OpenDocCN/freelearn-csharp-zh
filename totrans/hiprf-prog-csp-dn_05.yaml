- en: '*Chapter 4*: Memory Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at object generations and how to avoid memory
    issues, followed by a discussion on strong and weak references. Then, we will
    look at finalization and how we can suppress finalization by implementing the
    `IDisposable` pattern to clean up managed and unmanaged resources. Finally, we
    will take a high-level look at ways to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.OutOfMemoryException`. We learn how to predict out-of-memory errors
    before they happen by using the `System.Runtime.MemoryFailPoint` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding long and short weak references**: In this section, we learn
    about long and short weak references and how they are affected by the garbage
    collector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finalization**: In this section, we look at how to use finalizers to clean
    up resources, and understand why we have no control over if and when they will
    run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IDisposable` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preventing memory leaks**: In this section, we look at how the use of the
    **Component Object Model** (**COM**) and managed events can be sources that generate
    memory leaks and what we can do to avoid memory leaks from being generated. We
    will be using Microsoft Excel and JetBrains dotMemory in this section to see how
    leaks can be generated and to see how using a memory profiler can be very useful
    in identifying memory leaks and their sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have gained skills in the following areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object generations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how objects are disposed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding why it is best to avoid finalizers and implement `IDisposable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how to prevent memory leaks arising from the use of unmanaged
    COM libraries and components and from using events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using anonymous methods, long weak references, and short weak references to
    improve garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the steps in this chapter, there are some technical requirements,
    as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains dotMemory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source code: [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object generations and avoiding memory issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three object generations in the .NET runtime, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Generation 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 0 is the youngest generation and holds short-lived objects. Objects
    that are less than 80,000 bytes are generation 0 objects that get placed on the
    **small object heap** (**SOH**) when they are instantiated. Objects that are 80,000
    bytes or larger are usually generation 2 objects and live on the **large object
    heap** (**LOH**). Generation 1 objects are those objects that survived generation
    0 garbage collection and received a promotion to generation 1.
  prefs: []
  type: TYPE_NORMAL
- en: Generation 0 is where most of the garbage collection takes place. Objects that
    do not get collected when they are generation 0 will get promoted to generation
    1 to make room for more generation 0 objects to be added to the heap. If generation
    0 and 1 become full, then generation 1 objects are promoted to generation 2, and
    generation 0 objects are promoted to generation 1\. If generations 0, 1, and 2
    become full so that no more objects can be added to the heap, you then end up
    with a `System.OutOfMemoryException`-type exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to write a very simple program that will throw a `System.OutOfMemoryException`-type
    exception. Follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new .NET 6 console application project called `CH04_OutOfMemoryExceptions`.
    Add the following `using` statements to the `Program.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method calls to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DataExportToCsv()` method builds up a very large data file. `ReadCsvBroken()`
    reads in the `System.OutOfMemoryException`-type exception. The exception is avoided
    in the `ReadCsvPredictive()` method, as the method instantiates the `MemoryFailPoint`
    class to ensure that the data read of the file will not generate an exception.
    If the operation does generate a `System.OutOfMemory exception`-type exception,
    then the `MemoryFailPoint` object will raise an `OutOfMemoryException`-type exception.
    This saves memory, time, `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be the file we will write to and read from. Add the following `DataExportToCsv()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code writes 491,616,373 lines of data to a CSV file. Add the following
    `ReadCsvBroken()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `ReadCsvBroken()` method tries to read the massive 44.2 `string` variable.
    This operation throws a `System.OutOfMemoryException`-type exception. Add the
    following `ReadCsvPredictive()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code uses predictive memory checking using the `MemoryFailPoint` class.
    We show it working for the `alphabet` string, and we show that it highlights an
    error and fails with an `OutOfMemoryException`-type exception when the length
    of the file contents is assigned to the `length` variable that is passed into
    the `MemoryFailPoint` constructor. We use the unchecked struct since the length
    of the file is a long value, and this value to too big to be assigned to an `int`
    data type. If we used the checked struct instead, we would have an `ArithmeticOverflowException`-type
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building and running the code takes hours. I recommend you build the code in
    `Release` mode, and then run the executable from a command window. The code will
    successfully build up the CSV file and save it. When the file contents are read
    all at once, they will generate an `OutOfMemoryException`-type exception. Then,
    the program will do a precheck prior to loading the file and will fail before
    the file read is attempted with a more detailed `OutOfMemoryException`-type exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Predicting memory exceptions saves time and improves application performance,
    as you are not wasting CPU cycles and memory performing an operation that is ultimately
    going to fail.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how easy it is for an application to run out of memory and how
    we can predict and prevent memory exceptions. So, let’s now move on to discuss
    strong and weak references.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding long and short weak references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the .NET runtime, there are two types of references: **long weak references**
    and **short weak references**. These are described in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Finalize()` method has been called on an object, a long weak reference is
    retained in memory. You specify `true` in the `WeakReference` constructor to define
    a long reference. A long weak reference can be recreated, although its state can
    be unpredictable. A short weak reference will be applied when an object’s type
    does not have a `Finalize()` method. The weak reference will only remain until
    its target is collected sometime after the finalizer is run. You will need to
    cast the target property of a `WeakReference` constructor to the type of an object
    if you want to create a strong weak reference that will be reused. When the object
    is collected, the `Target` property will be `null`. If it is not `null`, then
    you can continue to use the object because the application has regained a strong
    reference to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WeakReference` is a short weak reference. When the garbage collector reclaims
    a short weak reference, its target becomes `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A long weak reference protects referenced objects from garbage collection, and
    a short weak reference does not protect referenced objects from garbage collection.
    This means that when garbage collection executes, the long weak referenced objects
    will not be garbage-collected, but the short weak referenced objects will be garbage-collected.
    We will demonstrate this with a code example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code example will show both long and short weak references at work. Follow
    these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a new .NET 6 console application called `CH04_WeakReferences`.
    Add the following class called `ReferenceObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class will be our reference object that we will be adding to two different
    object managers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `LongWeakReferenceObjectManager`. Then, add the following
    list field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our read-only `Objects` list will contain several `ReferenceObject` types.
    Now, add the following method to add items to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method adds a `ReferenceObject` object to the list of reference objects.
    Then, the next task is to add a method that will print a list of stored objects
    to the console, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ListObjects()` method prints out the contents of the list to the console
    window. That concludes our `LongWeakReferenceObjectManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a class called `ShortWeakReferenceObjectManager`. At the top of the
    class, add the following list field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice with the list that the `ReferenceObject` object is wrapped in a `WeakReference`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add a method to add items to the list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method wraps the passed-in `ReferenceObject` object in a `WeakReference`
    object and assigns it to the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now add the `ListObjects()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ListObjects()` method prints out to the console window all the weak objects
    that are stored in the list. Our focus now moves to the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two fields to the top of the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are our read-only strong and weak object managers that we will use to
    demonstrate strong and weak references in action, with regard to the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Main(string[] _)` method by adding the following three method calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `TestLongWeakreferences()`, `TestStrongReferences()`, and `TestWeakReferences()`
    methods build up our lists of strong referenced objects and weak referenced objects
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `TestStrongReferences()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method adds three `ReferenceObject` objects to the `StrongReferences` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `TestWeakReferences()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method adds three weak referenced objects to the `WeakReferences` list
    and then sets the objects it instantiated to `null` so that they will be garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `ProcessReferences()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ProcesseReferences()` method loops 10 times. During each iteration, the
    `ListObjects()` method is called on the `StrongReferences` and `WeakReferences`
    fields. The program sleeps for 2 seconds, and then the garbage collector is executed
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to run the program. When you run the program, you should see
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Weak references’ project output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – Weak references’ project output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from *Figure 4.1*, on the first iteration of the loop, both strong
    and weak reference objects exist, and the names of those objects are printed in
    the console window. However, after garbage collection is called, the weak references
    are garbage-collected, and so, from the second iteration onward, only the strongly
    referenced objects remain in memory.
  prefs: []
  type: TYPE_NORMAL
- en: A weakly referenced object’s lifespan is not extended as it is for strong references.
    This means that they can be garbage-collected once all strong references have
    gone out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that are large but cheap to rehydrate on-demand benefit from weak references.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To improve the performance of your applications, avoid using weak references
    on many small objects as they can take up more memory space than the objects they
    wrap, thus adding performance overhead. But if you are working with many large
    expensive objects, using cached weak references may help improve your application’s
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at strong and weak references. Let’s move our focus
    and attention to finalization in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Finalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, there is no direct way of destroying an object. The nearest thing we
    have is **finalization**. A finalizer in C# is the C# equivalent of a destructor
    in C++. Except in C#, you have no control over if and when it will run this down
    to the garbage collector to make that decision.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The terms *finalizer* and *destructor* are used interchangeably in C#. A finalizer
    is where the user-defined finalizer code is run. After the finalizer in an object
    is run, it is once again considered alive and the garbage collector will then
    finally collect the object. This means an object is actually marked “`collectable`”
    twice if it has a finalizer defined.
  prefs: []
  type: TYPE_NORMAL
- en: Finalization is used by an object to release resources and perform other housekeeping
    operations prior to the object being garbage-collected. Cleanup operations to
    release unmanaged resources held by an object can be performed by overriding the
    protected `Finalize()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You have to override the `Finalize()` method for the garbage collector to mark
    types derived from `Object` for finalization. When you override the `Finalize()`
    method, an entry for the instance is placed in a finalization queue. Before reclaiming
    memory, the `Finalize()` method is called for each object instance in the finalization
    queue. Once an object’s `Finalize()` method has been run, then its memory can
    be reclaimed by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The `Finalize()` method is not called if `GC.SupressFinalize()` has been called
    during the disposing of the object’s resources, but the `Finalize()` method will
    be called automatically when an object is discovered to be inaccessible, and during
    **application domain** (**AppDomain**) shutdown (even if the object is accessible).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: AppDomains isolate applications from one another, but their usage is very expensive.
    In .NET 5+, some AppDomain `AssemblyLoadContext` class for dynamic assembly loading.
  prefs: []
  type: TYPE_NORMAL
- en: '`Finalize()` methods only run once unless `GC.SuppressFinalize()` has not been
    called and `GC.ReRegisterForFinalize()` is called; then, the `Finalize()` method
    can be called again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When overriding `Finalize()`, there are a few things to keep in mind, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You have no control over when the `Finalize()` method will be called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To guarantee the release of managed and unmanaged resources within your instance,
    implement the `IDisposable.Dispose()` method using the `IDisposable` pattern.
    There is no guarantee of the order in which finalizers will run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizers run on an unspecified thread, and they implicitly call the `Finalize()`
    method on the base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid the need to override the `Finalize()` method and for us to ensure the
    cleanup of our managed and unmanaged resources, we will look at implementing the
    `IDisposable` pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Using finalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to write a sample application that demonstrates the use of `Finalize()`.
    Then, we will modify the program to implement the `IDisposable` pattern and suppress
    the call to `Finalize()`, while ensuring the deterministic release of our managed
    and unmanaged resources. Follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new .NET 6 console application called `CH04_Finalization`. Add a new
    internal class called `Product`. Then, add the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have created four properties—`Id`, `Name`, `Description`, and `UnitPrice`.
    Now, add the constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our constructor writes a message to the console window so that we know we have
    entered the constructor. Next, add the finalizer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our finalizer, we write a message to the console window so that we know
    our finalizer has been called. For the last bit of code in our `Product` class,
    we will override the `ToString()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `ToString()` method returns a string that outputs the values of each of
    the properties of the `Product` class. For now, unless stated otherwise, the following
    code is to be added to the `Program` class. Add the following variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `_product` variable will be used to store an instance of our `Product`
    class. Update the `Main` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we have several methods that instantiate the object, print
    object data, remove object references, display object generations, and run the
    garbage collector. We will now add each of the methods in turn. Add the `InitiateObject()`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we write a console window message, create a new product, and
    assign it to the `_product` member variable. Now, we will add the `PrintObjectData()`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are printing the contents of the `Product` class to the console window.
    Next, we will write the `RemoveObjectReference()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are setting the `Product` object to `null`. This removes references to the
    object and makes it eligible for garbage collection. We now add a method to call
    the garbage collection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we call the garbage collector, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this method, we create a local object. Then, we call the method to display
    the current generation. We then assign the local product to the member product,
    followed by a call to the garbage collector. Our final method, for now, is the
    `DisplayGeneration(Product product)` method, as illustrated in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method prints out the generation of the product passed into it. Run the
    code. You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The finalization project output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – The finalization project output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our code demonstrates construction and finalization. We have
    both generation 0 and generation 2 code, and both our constructor and finalizer
    methods do get called. Now, we will look at implementing `IDisposable` to make
    the cleanup of our code more deterministic so that `Finalize()` does not need
    to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IDisposable pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will implement a reusable `IDisposable` pattern. We will
    have a base class that implements `IDisposable`. This base class will provide
    two methods that subclasses can override. One method will be for cleaning up managed
    resources, and the other method will be for disposing of unmanaged resources.
    For us to implement the `IDisposable` pattern, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new class called `DisposableBase` that implements `IDisposable`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class acts as a base class that can be inherited. It implements the `IDisposable`
    interface and calls two virtual methods called `ReleaseManagedResources()` and
    `ReleaseUnmanagedResources()` that will be overridden in the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the code from `Main` into a new method called `Finalization()`. Then,
    modify `Main`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are calling two methods. The `Finalization()` method demonstrates using
    finalization to clean up resources that you have no control over when finalization
    will be called by the garbage collector. `Disposing()` demonstrates the determined
    disposing of managed and unmanaged resources, with finalization being suppressed
    so that it is not called by the garbage collector. Your `Finalization()` method
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We are passing `“Finalization”` into the `InstantiateObject(string cleanUpMethod)`
    and `InstantiateLocalObject(string cleanUpMethod)` methods so that we know the
    objects being finalized were instantiated in our `Finalization()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method called `Disposing()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Disposing()` method, we write a message to the console identifying that
    the `Disposing()` method is running. We then call `InstantiateObject(“Disposing”)`.
    Next, we print the object data and dispose of the object. Then, we instantiate
    a local object that will get assigned to the member variable. The generations
    of the local and member variables are printed to the console window, and then
    we dispose of the object and call garbage collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `DisposeofObject()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DisposeOfObject()` method calls the `Dispose()` method on the `_product`
    object to free up resources. Update the `Product` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are storing the name of the cleanup method we are using so that when the
    finalizer is called, we will know the method of cleanup the object uses. Modify
    the `InstantiateObject()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are assigning the method of cleanup to the `Product` object. Do the same
    with the `InstantiateLocalObject()` method so that the code looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, we are assigning the method of cleanup to the `Product` object. Update
    `Product` to inherit from `DisposableBase`. Then, add the `ReleaseManagedResources()`
    method to the `Product` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method will be used to release managed resources. Now, add the `ReleaseUnmanagedResources()`
    method to the `Product` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will be used for cleaning up unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and you should see the output, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The output of finalization and disposing code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – The output of finalization and disposing code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the finalization code calls the finalizer, but the methods used
    for releasing managed and unmanaged resources explicitly do not get called. Objects
    also survive the generation 0 garbage collection. Conversely, the disposing code
    explicitly releases the managed and unmanaged code, and finalization being suppressed
    is not called by the garbage collector. No objects in our example survive generation
    0 garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to implicitly call `Dispose()` on disposable classes is to use
    a `using` statement. Here is an example, as can be seen in the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `using` statement is used with disposable objects. When the code block completes,
    the object is automatically disposed of. The object’s generation is 0\. Add a
    call to `UsingDispose()` in the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: Well, you have seen how to use finalization and implement the `IDisposable`
    pattern in relation to the garbage collector. Now, let’s look at how we can avoid
    memory leaks in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will understand the issues around COM objects and what can
    lead to memory leaks using COM objects. We will look at interoping with the Excel
    COM library for our example code. We will see how instances of Excel are kept
    alive after our code exits. By using Windows Task Manager, we will be able to
    see instances of Excel being generated. Our Excel code will be developed in such
    a way as to avoid memory leaks and ensure that every Excel instance is closed
    when our code has completed running so that no instances of Excel remain in memory.
  prefs: []
  type: TYPE_NORMAL
- en: We will then move on to look at how using events can be a common source of memory
    leaks at runtime and how we can avoid them. Using JetBrains dotMemory, we will
    profile a runtime build executable of our program code. As the code is running,
    we will generate snapshots. As the profiler runs, you will see the memory usage
    gradually climbing. Clicking on the snapshots will display detailed memory information
    for our running profile. We will also be able to see if we have any memory leaks,
    and will see that we have event-based memory leaks. In this section, we will also
    be looking at anonymous methods and weak references.
  prefs: []
  type: TYPE_NORMAL
- en: The outcome of this section will be that you understand how COM and the use
    of events, if not handled correctly, can introduce memory exceptions, and you
    will see how you can write your code so that no memory exceptions are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dangers of using Marshal.ReleaseComObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Visual Studio team ran into problems with Visual Studio 2010\. Their problems
    arose due to rewriting native C++ components in managed C# code. The components
    that were rewritten as managed C# code were the window manager, command bars,
    and text editor.
  prefs: []
  type: TYPE_NORMAL
- en: With the release of Visual Studio 2010, there were two extension enablers—the
    existing extension mechanism that uses COM interfaces for older extensions, and
    a new managed programming model.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the `RuntimeCallableWrapper` or **RCW**. An RCW acts as a bridge
    between the worlds of COM and managed code.
  prefs: []
  type: TYPE_NORMAL
- en: All COM components must, at the very minimum, implement the `IUnknown` interface.
    When an object that implements the `IUnknown` interface enters the managed runtime,
    it is wrapped in an RCW. An RCW is, therefore, a regular managed object that references
    native code that implements the `IUnknown` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of objects that can reference an RCW in a managed .NET
    computer program: COM objects and managed objects. This is the point at which
    issues can start to present themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we will now consider a typical scenario that will result in memory
    issues between COM objects and managed objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `DatabaseSearch` component begins the `Find` operation by asking the `DatabaseManager`
    service. A valid instance of `IDatabaseManager` is returned to the `DatabaseSearch`
    component. The `DatabaseManager` component returned to the `DatabaseSearch` component
    is a native COM component. Because the `DatabaseManager` component is a native
    COM component, it is wrapped in an RCW by the runtime. The `DatabaseSearch` component
    does not know or care whether the `DatabaseManager` component is a native COM
    component or managed code component because all it sees is the `IDatabaseManager`
    interface. The `Find` operation continues with the `DatabaseSearch` component
    making various calls through `IDatabaseManager` to complete its task. Once the
    `Find` operation is completed, it is exited. Since `IDatabaseManager` is an RCW,
    it has the same lifetime semantics as managed objects. As a result, the `IDatabaseManager`
    component will be cleaned up when the garbage collector runs. The garbage collector
    may not run for a long time if there is not a lot of memory pressure, and there
    is the possibility that it may not even run. At this point, we end up with a native
    and managed memory clash because of the different ways in which they both manage
    system memory. The managed `DatabaseSearch` component is finished with the `DatabaseManager`
    component until it needs it again. If there are no references to the `DatabaseManager`
    component, then this would be a good time for the garbage collector to run and
    remove `DatabaseManager`. Any component written in native code would, as soon
    as the `Find` method is exited, call `Release` on `IDatabaseManager`. This would
    indicate that the reference to `IDatabaseManager` is no longer needed. Since the
    final `Release` is not being called until the next garbage collection, it appears
    that there is a memory leak with `IDatabaseManager`. This is an example of non-deterministic
    finalization. The inability to determine when an object should be garbage-collected
    is known as non-deterministic finalization. The `Finalize()` method is executed
    on a special thread allocated by the garbage collector whenever the object it
    belongs to is being garbage-collected and finalization has not been suppressed
    when there are non-managed resources to be disposed of.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario that we have looked at would result in expensive objects being
    reported as leaked objects, and this would be during application shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: The natural solution would be to call `Marshal.ReleaseComObject(object)`. This
    call would be made as soon as the expensive object is no longer needed. In our
    scenario, it would be when `DatabaseManager` is no longer needed. This call causes
    the RCW to be released, and the internal reference count is decremented by one.
    At this point, the underlying COM object is usually released.
  prefs: []
  type: TYPE_NORMAL
- en: However, calling `Marshal.ReleaseComObject(object)` can be dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that as part of a migration away from COM, `DatabaseManager` has been
    written in managed code. The `DatabaseSearch` managed component requests the `DatabaseManager`
    component via the GSP. An `IDatabaseManager` instance is returned to the `DatabaseSearch`
    component. The instance returned is an RCW that wraps a COM object. As a result,
    we have double wrapping that consists of an RCW wrapped around a `Find` operation
    exits that problems arise. The `DatabaseSearch` component still calls `Marshall.ReleaseComObject(object)`
    for the RCW of `DatabaseManager` when terminating.
  prefs: []
  type: TYPE_NORMAL
- en: This results in an `ArgumentException`-type exception being raised. The exception
    message generated is `“The object’s type must be _ComObject or derived from _ComObject.”`
    When this happens, remove the call to `Marshal.ReleaseComObject(object)`. An alternative
    is to call `Marshal.IsComObject` before `ReleaseComObject` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `Marshal.IsComObject` causes further problems. The `DatabaseManager`
    RCW has been declared as being no longer needed, but the problem is that the `DatabaseManager`
    RCW is still a valid object, meaning that it may still be reachable by managed
    objects. The next time the object is accessed, if reachable from managed code,
    an `InvalidComObjectException`-type exception will be raised by the CLR, stating:
    `“COM object that has been separated from its underlying RCW cannot be used.”`'
  prefs: []
  type: TYPE_NORMAL
- en: If the COM components used by our `DatabaseManager` RCW are cached by managed
    code instead of being returned to the GSP each time our `DatabaseManager` component
    is requested, our cached COM components will be checked first. This is done to
    avoid costly calls across the boundary between managed and unmanaged code. If
    several components then request the same COM component, they will each receive
    the same RCW.
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the component calling the RCW that has had `ReleaseComObject`
    called will often be blamed as the component that generated the exception. But
    this is not the case—it is the component that called `ReleaseComObject` that is
    the component at fault, which in our scenario would be the `DatabaseSearch` component.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended by Microsoft developers, especially those on the Visual Studio
    team, that unless you are 100% certain that there are no managed code items that
    have access to the RCW, you do not call `Marshal.ReleaseComObject`.
  prefs: []
  type: TYPE_NORMAL
- en: We will delve deeper into what we have just been discussing by looking at an
    Excel example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Microsoft Excel 16.0 Object Library in .NET 6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to be looking at COM interoperability in .NET 6 in this section,
    by referencing the Microsoft Excel 16.0 Object Library. This library is a COM
    library. You will see how to use Excel to create a new application, modify it,
    and save it. When the first example is run a few times, you will see that your
    code does not fail. But in Task Manager, each time the method is run, another
    instance of Excel will remain open, as seen in Windows Task Manager. Then, we
    will move on to see how we can correctly dispose of COM objects so that instances
    of Excel are not kept open when our applications complete. Let’s start by viewing
    what happens when we don’t release Excel COM objects.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating what happens when Excel COM objects are not released
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will create a spreadsheet, add data to it, and then save
    the file. This will reveal memory issues that arise from using Excel and not cleaning
    up properly after ourselves when we have finished using Excel. We will also see
    how to use Excel and clean up after ourselves so that we prevent memory issues
    through using Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Add a COM reference to the `CH04_PreventingMemoryLeaks` project for the *Microsoft
    Excel 16.0 Object Library*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you add a COM reference to your project, you will have IntelliSense available
    to you. But when you come to run your successfully compiled program, when it attempts
    to create an Excel application, it will raise a `FileNotFoundException`-type exception.
    Therefore, you need to set the values for `EmbedInteropTypes` and `Private` to
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a `FileNotFoundException`-type exception is the last thing we need, edit
    your project file and then update the `COMReference` section, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will ensure that we don’t experience the `FileNotFoundException`-type
    exception. Add a new `UsingExcel` class to the project, and then add the following
    `using` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the `RunExcelExamples()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This method calls two methods. It calls each of these methods 10 times and
    then exits. Let’s add the `NotReleasingExcelComObjects()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This method declares a `filename` string. It then instantiates a new Excel
    application that is not visible. It then adds a column header called “`Bucket
    List”`, and adds two items to that bucket list column in the rows below. It then
    checks if the file exists. If the file does exist, then it is deleted. The workbook
    is then saved and closed, and the Excel application is exited. Comment out the
    following lines from the `RunExcelExamples()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'If you then save your project and run it, you will find that once the program
    exits, you are left with multiple Excel processes. Each of these processes takes
    up memory. The following screenshot shows Excel processes that remain in memory
    after our program exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Windows Task Manager displaying Excel processes no longer in
    use using up memory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Windows Task Manager displaying Excel processes no longer in use
    using up memory
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, these Excel processes that remain in memory after our program
    finishes are using up 367.6 **megabytes** (**MB**) of RAM, which is the combined
    sum of all Excel processes’ RAM. If this program in its current form were to be
    run multiple times, you would eventually run out of memory, as the Excel processes
    left running in memory constitute a memory leak. Each time the program runs, you
    are using up another 367 MB of RAM, or thereabouts. Eventually, the amount of
    memory available will not be enough, and you will end up with an out-of-memory
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the display in Task Manager after the program
    has been run once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Windows Task Manager after the program has been run once'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Windows Task Manager after the program has been run once
  prefs: []
  type: TYPE_NORMAL
- en: 'From *Figure 4.5*, we can see that we are using 7.4 GB (793 MB), with 8.5 GB
    RAM still available to us. Run the program through a number of times continually.
    Each time the program is run, you will see the compressed memory rise and the
    available memory fall. At no point does the memory appear to be reclaimed, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished
    available memory after multiple program runs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Windows Task Manager displaying increased memory usage and diminished
    available memory after multiple program runs
  prefs: []
  type: TYPE_NORMAL
- en: After multiple continuous runs of our program, we can see that our **In use
    (Compressed)** memory has gone from 7.4 GB (793 MB) to 10.9 GB (799 MB) and our
    available memory has gone from 8.5 GB to 4.9 GB. This is clearly a problem that
    needs to be addressed, but how?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the `ReleasingExcelComObjects()` method shown here comes in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This rather lengthy method does what we need Excel to do—it releases the Excel
    COM objects, sets the managed objects to `null`, runs the garbage collector, and
    then terminates all running Excel processes. If you uncomment the code in the
    `RunExcelExamples()` method and then run the code once, you will see that we no
    longer have any Excel processes running in memory once our code has finished running.
    You will also see if you look at the **Performance** tab of Windows Task Manager
    that we have reclaimed our memory.
  prefs: []
  type: TYPE_NORMAL
- en: We have managed to fix our memory leak by terminating COM components and setting
    managed objects to `null` to remove managed references. Then, we killed all processes
    called `EXCEL`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when using the `process.Kill()` method to kill off all processes
    for a given name such as `EXCEL`. There may be other programs that also use that
    process that could be badly impacted by such termination. You should run such
    code in an isolated environment if doing batch processing on a server, or schedule
    such operations for a time when you can guarantee that other processes will not
    be affected by running such code.
  prefs: []
  type: TYPE_NORMAL
- en: It is now time to look at how using events can be a source of memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: How using events can be a source of memory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will look at how the use of events in your computer programs
    can be a source of memory leaks. We will demonstrate this using a very simple
    Windows Forms application that we will write. Then, we will analyze our memory
    usage using JetBrains dotMemory. There will be two methods employed to show events
    in use. One method will generate a memory leak, while the other won’t generate
    a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can using events generate memory leaks?
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you are using anonymous methods, subscribing to an event holds a reference
    to the class that holds that event until such time as the event is unsubscribed
    from. Consider the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'If the control outlives the `EventSubscriber` class, then all instances of
    `EventSubscriber` will not be deallocated by the garbage collector. The end result
    is a memory leak. Here are some different ways to avoid event-based memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to anonymous methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsubscribe from events when you are finished with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the weak-handler pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we look at each of these ways of avoiding memory leaks, we will write
    our Windows Forms application that demonstrates a way to avoid memory leaks and
    a way to generate memory leaks. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new .NET Core Windows Forms project, and then change the target framework
    from .NET Core 3.1 to .NET 5 in the project settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `Form1` to `MainForm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a label called `InformationLabel` with the text `“Information”`, a button
    called `RaiseEventsButton` with the text `“Raise Events”`, and another label called
    `ProgressLabel` with the text `“Progress:”`. You can lay the components out and
    style them according to your preference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `RaiseEventsButton` button. This will generate a click event
    handler method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class to the project called `EventOne`. You will need the following `using`
    statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the top of the `EventOne` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These elements are needed to handle the event and keep a count of how many
    instances are still being kept alive. Add the constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor code increments the _`count` member variable in an atomic and
    thread-safe manner for each instance of the class. Add the `RaiseEvent(EventArgs
    e)` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method is called by the clients and is responsible for firing the event
    upon request. Now, add the finalizer, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The finalizer decrements the _`count` member variable in a thread-safe manner
    each time an instance of the class is terminated and collected by the garbage
    collector. Add a new `EventTwo` class to the project. You will need the following
    `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the top of the `EventTwo` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The code stores the count of the number of alive instances and the current
    text of the subscribed control. Add the following constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor takes a Windows Forms control as a parameter. It increments
    the `_count` member variable by one in a thread-safe manner. It then subscribes
    to the `TextChanged` event that is handled by the `OnTextChanged` method. Add
    the `OnTextChanged` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method is fired when the `Text` property of the subscribed control is
    changed. It takes the `Text` content of the control and assigns it to the `Text`
    property of the `EventTwo` class. Add the `Finalizer()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The finalizer decrements the `_count` member variable by one in a thread-safe
    manner each time an instance is garbage-collected. We now have in place the two
    classes that our form will use for raising events. Switch back to the `MainForm`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `MainForm` class, add the following member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two values will store the number of events that have been generated.
    Add the `SetTitleText()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method sets the control’s `Text` property for each method that raises
    events. The text displays the number of events raised and the number of events
    still alive for the non-memory leak method, and the same again for the memory
    leak method. Add the `SetInformationLabelText()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `SetInformationLabelText()` method updates the `InformationLabel` text
    to display the number of events raised in each method and the number of events
    remaining in memory once both methods have finished executing. Add the `RaiseEvent`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `RaiseEvent` method updates the `ProgressLabel.Text` property, but so that
    it is updated in real time, it is necessary to call the `Invalidate()` and `Update()`
    methods. Now, add the `MemoryLeakMethod` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method declares a count of 10,000 items. It then loops through 10,000
    iterations. A new `EventTwo` object is subscribed to with the reference to `MainForm`
    passed in. Once the loop completes, the `_eventTwoCount` variable is incremented
    by 10,000\. Next, we will add the `NoMemoryLeakedMethod` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method declares a count of 10,000\. It iterates 10,000 times. During that
    10,000 times, it instantiates a new `EventOne` object, adds an event handler called
    `RaisedEvent`, and then raises the event. Once, the loop has completed, the `_eventOneCount`
    variable is incremented by 10,000\. Update the click event handler with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Change the build mode to `Release` and build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open **JetBrains dotMemory**. Select **Local** | **.NET Core Application**,
    select an executable generated by the build process, then check the **Collect
    memory allocation and traffic from start** box. Your screen should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – The JetBrains dotMemory configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – The JetBrains dotMemory configuration screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Run** button. This will start your application and profiling
    session, as shown in the next two screenshots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – JetBrains dotMemory profiling our Windows Forms application
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Our Windows Forms application before any events have been run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.9.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – Our Windows Forms application before any events have been run
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Raise Events** button a few times. Each time you click on the
    button, the memory profile should change and the memory usage should increase,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Our Windows Forms application showing 50,000 alive events,'
  prefs: []
  type: TYPE_NORMAL
- en: indicating we have a memory leak
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – Our Windows Forms application showing 50,000 alive events, indicating
    we have a memory leak
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have a memory leak. Our `NoMemoryLeakMethod` method does
    not generate a memory leak. As you can see, after 50,000 raised events, the objects
    kept alive in memory is 0\. But our `MemoryLeakMethod` method does produce a memory
    leak. Out of 50,000 raised events, 50,000 objects remain alive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the program a few more times, and pay attention to what is going on in
    dotMemory. When you see a point of interest, click on the area and then click
    on **Get Snapshot**. This will take a snapshot of that moment in time that users
    can analyze to see if there are any issues. You should end up with something similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application'
  prefs: []
  type: TYPE_NORMAL
- en: when events are raised and snapshots are taken
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – JetBrains dotMemory profile of our Windows Forms application when
    events are raised and snapshots are taken
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on any one of your snapshots. You should see an output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – A memory leak has been identified with the EventTwo class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – A memory leak has been identified with the EventTwo class
  prefs: []
  type: TYPE_NORMAL
- en: JetBrains dotMemory has detected a memory leak in the `EventTwo` class. This
    is because the class subscribes to an event of another object, but never unsubscribes
    from it. However, you will see that all the objects for the `EventOne` class have
    been finalized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have seen how to use events in such a way that generates memory leaks and
    in such a way that all objects are finalized and a memory leak is prevented. Let’s
    revisit the three ways to prevent memory leaks when using events, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to anonymous methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unsubscribe from events when you are finished with them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the weak-handler pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take a look at subscribing to anonymous methods and then unsubscribing
  prefs: []
  type: TYPE_NORMAL
- en: Using local methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to C# 7.0, you would use anonymous methods as a way of handling events
    such that you avoid introducing memory leaks. As of C# 7.0, you can use local
    methods. In this example, we will handle events using local methods. Follow these
    next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the `CH04_PreventingMemoryLeaks` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class called `Website`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This class has two events for logging in and logging out of a website. Add
    a new class called `AnonymousEventSubscription`. Add the `Login()` method, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Login()` method instantiates a new `Website` object. It then has a local
    method called `LoginHandler` that writes a message to the debug window and then
    unsubscribes from the `Website.Login` event. Then, outside of the local method,
    it subscribes to the `Website.Login` event and raises the event. Let’s add the
    `Logout()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Logout()` method instantiates a new `Website` object. It then has a local
    method called `LogoutHandler` that writes a message to the debug window and then
    unsubscribes from the `Website.Logout` event. Then, outside of the local method,
    it adds the event handler for the `Website.Logout` event, and then raises the
    event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Main` method, comment out the `RunExcelExamples()` line. Then, add
    the `UseAnonymousEventSubscription()` method call, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code runs through 1,000,000 iterations. For each iteration, a new `AnonymousEventSubscription`
    is instantiated, with calls to `Login()` and `Logout()` made. These two calls
    will each have a subscription to an event, an event executed via a local method,
    and, as the local method is executed, the event it will be unsubscribed from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you build and run the code, you should see the following lines printed 1,000,000
    times in your debug window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – The debug window showing events firing for Login and Logout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16617_Figure_4.13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – The debug window showing events firing for Login and Logout
  prefs: []
  type: TYPE_NORMAL
- en: If you perform a release build and run dotMemory, you will see that we have
    no memory leak, considering we have just generated 2,000,000 event subscriptions
    and unsubscriptions—that is, 1,000,000 for `Login()` and 1,000,000 for `Logout()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have seen how to effectively use anonymous events using local methods without
    causing memory leaks. Now, let’s look at our final topic of the chapter—weak references.
  prefs: []
  type: TYPE_NORMAL
- en: Using weak reference events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use the weak reference event pattern to allow an object to be garbage-collected
    if its only remaining link is an event handler. We will implement the weak reference
    event pattern in this section in the `CH04_PreventingMemoryLeaks` project. Follow
    these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Package Manager Console, type the following: `install-package WeakEventListener`.
    The `System.Windows.WeakEventManager` package only works with .NET 4.8 and older,
    which is why we install this package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `SampleClass` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this class, we declare an event called `RaiseEvent`. The `DoSomething()`
    method calls the `OnRaiseEvent()` method. The `OnRaiseEvent()` method checks if
    the event is `null`; if it is not `null`, then the event is invoked. Add a new
    class called `UsingWeakreferences`. You will need the following references:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `RaiseWeakReferenceEvents()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have two variables that are `true` when an event has been triggered and when
    it has been detached. We instantiate a new `SampleClass` class instance. Then
    we declare a `WeakEventListener` package that references the `SampleClass` class.
    Anonymous methods are used to handle the `OnEventAction` and `OnDetachAction`
    methods. The `WeakReferenceListener.OnEvent` method is then assigned as the handler
    for the `SampleClass.RaiseEvent` event. We then call the `DoSomething()` method
    that raises the event. Then, we assert that the event has been triggered, detach
    the event, and then assert that the event has been detached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the project is set to **Debug** mode, and then step through the code.
    It should work as expected, with the event being correctly triggered and detached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s now summarize what we have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at object generations and saw how easy it was to generate a `System.OutOfMemoryException`-type
    exception. We saw how we can use predictive out-of-memory exception checking to
    save time by preventing the running of code that will cause this exception.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved on to discuss long weak references and short weak references.
    We learned that strong references are not garbage-collected, and weak references
    are garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at finalization and saw how the `Finalize()` method will be called
    on objects that are not disposed of, and that we have no control over when the
    `Finalize()` method will run. Then, we looked at how to implement the `IDisposable`
    pattern and suppress the need for garbage collection to call `Finalize()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the various ways to prevent memory leaks, such as properly
    disposing of managed resources and unmanaged resources. We also saw how to correctly
    handle events so that we do not cause memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: With what you have learned in this chapter, you will be able to overcome out-of-memory
    exceptions, improve memory performance, and improve garbage collection in your
    applications, and you will be to correctly use events and event handlers without
    generating memory leaks and will be able to effectively release COM objects and
    allocated memory. This will lead to better quality and more stable programs that
    make good use of memory.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at application profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many object generations are there?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which sized objects get placed on the SOH?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which sized objects get placed on the LOH?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a strong reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a weak reference?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we clean up objects without having to rely on finalization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we avoid memory leaks when using events?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method do we use to release COM objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we prevent memory leaks when allocating memory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Weak references: [https://www.youtube.com/watch?v=2WcDhh8lvJs](https://www.youtube.com/watch?v=2WcDhh8lvJs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ComWrappers` class: https://docs.microsoft.com/ dotnet/api/system.runtime.interopservices.comwrappers?view=net-5.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Marshal.ReleaseComObject Considered Dangerous*: [https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/](https://devblogs.microsoft.com/visualstudio/marshal-releasecomobject-considered-dangerous/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WeakEventManager Class:* https://docs.microsoft.com /dotnet/api/system.windows.weakeventmanager?view=net-5.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Weak Event Patterns*: [https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8](https://docs.microsoft.com/en-us/dotnet/desktop/wpf/advanced/weak-event-patterns?view=netframeworkdesktop-4.8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to properly release Excel COM objects*: [https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/](https://www.add-in-express.com/creating-addins-blog/2013/11/05/release-excel-com-objects/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding and Avoiding Memory Leaks with Event Handlers and Event Aggregators*:
    [https://www.markheath.net/post/understanding-and-avoiding-memory-leaks](https://www.markheath.net/post/understanding-and-avoiding-memory-leaks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why and how to avoid event handler memory leaks: [https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks](https://stackoverflow.com/questions/4526829/why-and-how-to-avoid-event-handler-memory-leaks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Framework technologies unavailable on .NET Core and .NET 5+:* [https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable](https://docs.microsoft.com/en-us/dotnet/core/porting/net-framework-tech-unavailable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
