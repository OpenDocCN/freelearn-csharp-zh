- en: '*Chapter 11*: Quest Tracking and Branching Narratives'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：任务跟踪和分支叙事'
- en: In this chapter, we will review how to create an ink template for quests, track
    multiple quests based on this template, and show the player the values of variables
    across quests. In the first section, we will create an ink template and its required
    sections. Next, we will improve the ink template and create a `Quest` class to
    track multiple quests progressing independently from each other. Finally, we will
    show the player the results of progressing quests and view the values of change
    during this progression.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾如何创建任务的ink模板，根据此模板跟踪多个任务，并显示玩家跨任务变量的值。在第一部分，我们将创建ink模板及其所需的部分。接下来，我们将改进ink模板并创建一个`Quest`类来跟踪多个独立进展的任务。最后，我们将向玩家展示任务进展的结果并查看在此进展过程中的变化值。
- en: Many larger or narrative-focused video games are composed of separate quests
    for the player to complete. This chapter will provide a template for creating
    quests in ink and will also show you how to access and manipulate this template
    in Unity. Using multiple quests, a branching narrative approach is possible by
    allowing a player to progress through each quest separately, as explained in this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型或以叙事为重点的视频游戏由玩家需要完成的独立任务组成。本章将提供一个在ink中创建任务的模板，并展示如何在使用Unity中访问和操作此模板。通过使用多个任务，允许玩家分别通过每个任务进行进展，正如本章所解释的那样。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Making a quest count
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让任务有意义
- en: Tracking progress across multiple quests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨多个任务跟踪进展
- en: Displaying and awarding player progression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和奖励玩家进展
- en: Important
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要
- en: Each topic in this chapter has a separate, completed Unity project. Each topic
    includes instructions that state the name of the project and where to find it.
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的每个主题都有一个独立的、完成的Unity项目。每个主题都包含说明，说明项目的名称以及如何找到它。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The examples in this chapter have been divided into folders per project and
    can be found online on GitHub: [https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例已按项目划分文件夹，可在GitHub上找到：[https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11](https://github.com/PacktPublishing/Dynamic-Story-Scripting-with-the-ink-Scripting-Language/tree/main/Chapter11)。
- en: Making a quest count
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让任务有意义
- en: In narrative terms, a **quest** is a series of events connected to a character
    within a story. In video games, quests are a sequence of connected events experienced
    by the *player*. In role-playing games, a quest might include unlocking a weapon,
    rescuing a prince, or defeating some great evil. Each point along the way is a
    *step* of the quest. Translated in terms of story and code, a quest can be thought
    of as a series of steps where the resolution of each step unlocks the next.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从叙事的角度来看，**任务**是一系列与故事中某个角色相关的事件。在视频游戏中，任务是由玩家体验的一系列相关事件。在角色扮演游戏中，一个任务可能包括解锁武器、营救王子或击败某个大恶势力。沿途的每个点都是任务的**步骤**。从故事和代码的角度来看，任务可以被视为一系列步骤，其中每个步骤的解决都会解锁下一个步骤。
- en: ink supports this pattern of smaller parts within a larger whole as stitches
    within a knot. Thought of in this way, each step of the quest can become its own
    stitch within the code, with the outcome of each stitch being able to move to
    the next within the larger structure. Using `LIST` in ink also allows us to define
    the steps we want by name, with a special knot progressing the player from one
    stitch to the next within the quest structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ink支持在更大的整体中包含较小部分的模式，就像绳结中的线头。这样想，任务的每个步骤都可以成为代码中的自己的线头，每个线头的结局能够移动到更大的结构中的下一个位置。在ink中使用`LIST`也允许我们通过名称定义我们想要的步骤，有一个特殊的结将玩家从任务结构中的一个线头推进到下一个线头。
- en: 'In this section, we will learn how to design a quest template in ink and access
    its values in Unity across one single project, with each section building on the
    previous one:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在ink中设计任务模板并访问其在Unity中单个项目中的值，每个部分都是在前一个部分的基础上构建的：
- en: In the first section, *Creating a quest template in ink*, we will review how
    to use this pattern and the built-in automation available by using existing Ink
    functions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分，*在ink中创建任务模板*，我们将回顾如何使用此模式以及通过使用现有的Ink函数可用的内置自动化。
- en: In the second section, *Choosing specific knots in Unity*, we will move away
    from ink and look at Unity. Here, we will examine how to run the template in ink,
    as well as some potential issues to be aware of when using certain Story API methods.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二部分，*在Unity中选择特定的节点*，我们将从Ink转向Unity。在这里，我们将检查如何在Ink中运行模板，以及在使用某些Story API方法时需要注意的一些潜在问题。
- en: Reminder
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159),
    examples on GitHub folder, under the name `Chapter11,QuestProgression`. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本节的完成项目可以在[*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)中找到，GitHub文件夹下的示例，名称为`Chapter11,QuestProgression`。只会展示与该主题各部分探讨的概念相关的代码部分。
- en: Now let us understand the next topic where we will create a quest template.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解下一个主题，我们将创建一个任务模板。
- en: Creating a quest template in ink
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ink中创建一个任务模板
- en: 'ink stories are composed of different sections. In [*Chapter 1*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014),
    *Text Flow, Choices, and Weaves*, we learned how ink breaks code into different
    sections called `VAR` and `LIST` keywords in ink, which we did in [*Chapter 4*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062),
    *Variables, Lists, and Functions*, we can create a quest that''s composed of a
    series of steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ink故事由不同的部分组成。在[*第1章*](B17597_01_Final_PG_ePub.xhtml#_idTextAnchor014)中，*文本流、选择和编织*，我们学习了ink如何将代码分解为不同的部分，称为ink中的`VAR`和`LIST`关键字，我们在[*第4章*](B17597_04_Final_PG_ePub.xhtml#_idTextAnchor062)中，*变量、列表和函数*，我们可以创建一个由一系列步骤组成的任务：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code creates a list named `steps`, a variable named `step`, and a variable
    named `end` in ink. These three values keep track of the *quest''s progression*.
    The name of each step in the quest is added as an entry to the list, with the
    first used as the value of the `stage` variable:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在Ink中创建了一个名为`steps`的列表，一个名为`step`的变量和一个名为`end`的变量。这三个值跟踪*任务的进度*。任务中每个步骤的名称都被添加到列表中，第一个被用作`stage`变量的值：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The player is presented with their first options: `Sure` and `Not today`. If
    the first is selected, the flow moves into the `quest` knot. If the second is
    selected, the flow moves to a stitch inside of the `quest` knot named `stop`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家将看到他们的第一个选项：“当然”和“今天不”。如果选择第一个，流程将进入`quest`节点。如果选择第二个，流程将移动到`quest`节点内的一个名为`stop`的针脚：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The names *quest* and *stop* were chosen specifically. The use of the word *quest*
    helps in understanding the code as part of a template for other quests. As will
    be outlined in the next section, *Tracking progress across multiple quests*, multiple
    `Story` objects can exist at the same time in Unity. In this case, the word is
    used to show the pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选择*quest*和*stop*这两个名称是经过特别考虑的。使用*quest*这个词有助于理解代码作为其他任务模板的一部分。正如下一节将要概述的，*跨多个任务跟踪进度*，在Unity中可以同时存在多个`Story`对象。在这种情况下，这个词被用来展示模式。
- en: 'The `quest` knot contains the central logic of this pattern. Because the entries
    in a `LIST` in ink are Boolean values (either `true` or `false`), a multi-line
    comparison is used, where the order is important. The list named `steps` contains
    three entries, each of which are initially set to `true`. When the `quest` knot
    is first encountered, it will move the flow to the stitch named `first`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`quest`节点包含这个模式的中心逻辑。因为ink中`LIST`的条目是布尔值（要么是`true`要么是`false`），所以使用多行比较，顺序很重要。名为`steps`的列表包含三个条目，每个条目最初都设置为`true`。当第一次遇到`quest`节点时，它将流程移动到名为`first`的针脚：'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `first` stitch contains an unusual ending. The use of the `DONE` keyword
    usually signals that the story is over in ink. However, in this case, the `DONE`
    keyword is used to signal that the *step* is done. Instead of diverting to the
    `quest` knot or another section, the story seemingly stops. Progression happens
    using a combination of the `LIST_MIN()` function and the subtraction (`-`) operation
    for lists in Ink:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个针脚包含一个不寻常的结尾。在Ink中，使用`DONE`关键字通常表示故事以墨水结束。然而，在这种情况下，`DONE`关键字被用来表示步骤已完成。故事并没有转向`quest`节点或另一个部分，而是看似停止了。进度是通过结合`LIST_MIN()`函数和Ink中列表的减法（`-`）操作来实现的：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within the `progress` knot, each entry is removed (subtracted) and the top (minimum)
    value is used as part of the `step` variable. Each use of this knot *progresses*
    the quest by removing a step from the list and then using the top remaining one
    each time. However, the knot itself is not accessed directly. Instead, it is used
    externally by Unity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`progress`节点中，每个条目都会被移除（减去），而顶部（最小）值则作为`step`变量的一个部分。每次使用此节点都会通过从列表中移除一个步骤并使用剩余的最高值来推进任务。然而，节点本身并不是直接访问的。相反，它通过Unity外部使用。
- en: In this section, we learned how each step can be divided into stitches as part
    of a knot named `quest`. By using a `LIST` and different variables in ink, progress
    can be tracked across the quest. In the next section, we will learn how an ink
    template can be used as a series of steps to access the `progress` knot externally
    in Unity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将每个步骤作为名为`quest`的节点的一部分进行细分。通过使用ink中的`LIST`和不同的变量，可以在整个任务中跟踪进度。在下一节中，我们将学习如何将ink模板用作一系列步骤，以在Unity中外部访问`progress`节点。
- en: Choosing specific knots in Unity
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity中选择特定的节点
- en: Different methods and properties of the Story API provided by the ink-Unity
    Integration plugin were covered in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Unity API – Making Choices and Story Progression*, and [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123),
    *Story API – Accessing ink Variables and Functions*. However, what was not covered
    in those chapters was a useful but potentially very dangerous method named `ChoosePathString()`.
    In this section, we will look at an example of how this method can be used safely.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ink-Unity集成插件提供的Story API的不同方法和属性在[*第7章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106)，“Unity
    API – Making Choices and Story Progression”和[*第8章*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123)，“Story
    API – Accessing ink Variables and Functions”中都有涉及。然而，那些章节中没有涵盖的一个有用但可能非常危险的方法名为`ChoosePathString()`。在本节中，我们将探讨如何安全地使用此方法的一个示例。
- en: Internally, the ink runtime uses the term "path string" to describe any knot
    that is part of a story. When loaded, these can be accessed by using the `ChoosePathString()`
    method, which forcibly moves the story to that section. In most cases, this is
    unwanted behavior, as its use will disregard any existing tunnels or threads.
    It can be thought of as *ripping* the flow away from wherever it was and dropping
    it into a new location.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在ink运行时内部，术语“路径字符串”用于描述故事中任何作为部分的节点。当加载时，可以通过使用`ChoosePathString()`方法来访问这些路径，该方法强制将故事移动到该部分。在大多数情况下，这种行为是不受欢迎的，因为它的使用将忽略任何现有的隧道或线程。它可以被看作是*撕裂*流动从它所在的位置并丢弃到新的位置。
- en: As part of the ink runtime, variables are global. This means that while their
    values might be changed as part of the flow of a story, they exist outside of
    it. The values of variables are maintained despite any uses of the `ChoosePathString()`
    method. In other words, by carefully avoiding any structures that might be disrupted
    by its use, the `ChoosePathString()` method can be carefully used in projects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为ink运行时的一部分，变量是全局的。这意味着虽然它们的值可能会作为故事流程的一部分而改变，但它们存在于故事之外。变量的值在`ChoosePathString()`方法的使用过程中得到保持。换句话说，通过仔细避免任何可能被其使用所破坏的结构，可以在项目中谨慎地使用`ChoosePathString()`方法。
- en: 'In the previous section, the ink `progress` knot was introduced. To choose
    this path string in Unity using the `ChoosePathString()` method, only its name
    is needed:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，介绍了ink的`progress`节点。要使用`ChoosePathString()`方法在Unity中选择此路径字符串，只需要它的名称：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the `ChoosePathString()` method is used with the `progress` ink knot, it
    *does* disrupt the flow of the story that's kept within the `InkStory` C# variable.
    However, as we learned, the values of variables are maintained throughout the
    story because of their global nature. The use of the `progress` ink knot *progresses*
    the quest to its next step by updating the variables each time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`progress` ink节点与`ChoosePathString()`方法时，它确实会中断保存在`InkStory` C#变量中的故事流程。然而，正如我们所学的，由于它们的全局性质，变量的值在整个故事中保持不变。使用`progress`
    ink节点通过每次更新变量来推进任务到其下一个步骤。
- en: 'The code also includes calls to two other methods: `FlipProgress()` and `UpdateContent()`.
    The first method sets a `Button` game object in Unity to inactive by using the
    `SetActive()` method in Unity. When a game object is turned off (set to inactive)
    in Unity, it does not appear on the screen. This code effectively sets the game
    object to appear as needed and to disappear when the player is selecting dialogue
    options:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还包括对两个其他方法的调用：`FlipProgress()`和`UpdateContent()`。第一个方法使用Unity中的`SetActive()`方法将Unity中的`Button`游戏对象设置为非活动状态。当游戏对象在Unity中被关闭（设置为非活动状态）时，它不会出现在屏幕上。此代码有效地将游戏对象设置为按需显示，并在玩家选择对话选项时消失：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second method, `UpdateContent()`, follows the pattern we first introduced
    in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106), *Unity API –
    Making Choices and Story Progression*, where a `Prefab` is used to dynamically
    create `Button` game objects as needed:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法`UpdateContent()`遵循我们在[*第7章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106)中首次介绍的模式，即*Unity
    API – Making Choices and Story Progression*，其中使用`Prefab`动态创建所需的`Button`游戏对象：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this section, we learned how to create a template for quests in ink. Using
    a knot and then individual stitches for each step, the parts were divided into
    different sections. Next, we looked at the `progress` ink knot. After that, we
    looked at Unity and using the `ChoosePathString()` method. While it can be potentially
    dangerous with larger projects using more advanced techniques, using variables
    in the ink quest template helped maintain their values. Finally, at the end of
    this section, the `ChoosePathString()` method in Unity was paired with the `progress`
    knot in ink. By using this knot, the Unity code could *progress* the quest, with
    ink updating its internal variables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何在ink中创建任务模板。使用节点和每个步骤的单独线迹，部分被分为不同的部分。接下来，我们看了`progress` ink节点。之后，我们看了Unity和`ChoosePathString()`方法。虽然在使用更高级技术的较大项目中可能存在潜在危险，但在ink任务模板中使用变量有助于保持它们的值。最后，在本节的最后，Unity中的`ChoosePathString()`方法与ink中的`progress`节点配对。通过使用此节点，Unity代码可以*推进*任务，ink更新其内部变量。
- en: In the next section, we will continue with the pattern we looked at in this
    section by extending part of the quest template in ink and creating `Quest` and
    `Dialogue` classes in C#. These will allow us to track multiple quests at the
    same time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将继续在本节中查看的模式，通过扩展ink中的部分任务模板并创建C#中的`Quest`和`Dialogue`类。这将允许我们同时跟踪多个任务。
- en: Tracking progress across multiple quests
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨多个任务跟踪进度
- en: In the previous section, we created an ink template for a quest and then moved
    into Unity to create the user interface to progress the quest using the `ChoosePathString()`
    method. This forced the flow within ink to move to a specific location. In this
    section, we move beyond a single quest and start tracking multiple quests at the
    same time. To do this, the ink template needs additional variables. For this,
    we will need the `Quest` and `Dialogue` classes in C#. We also will depart from
    using a single ink file and start using multiple files. For every quest, we will
    create a separate file and use the `Quest` class to track the progress of each
    in Unity with the `Dialogue` class, which handles creating options for a player
    to choose from during each step in the quest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们为任务创建了一个ink模板，然后进入Unity创建用户界面，使用`ChoosePathString()`方法推进任务。这迫使ink中的流程移动到特定位置。在本节中，我们超越了单个任务，并开始同时跟踪多个任务。为此，ink模板需要额外的变量。为此，我们需要C#中的`Quest`和`Dialogue`类。我们还将停止使用单个ink文件，并开始使用多个文件。对于每个任务，我们将创建一个单独的文件，并使用`Quest`类在Unity中跟踪每个任务的进度，`Dialogue`类则负责在任务的每个步骤中为玩家创建选择选项。
- en: First, we will update the ink template with a new variable we will access later
    in Unity. Then, we will create the `Quest` and `Dialogue` classes in Unity. After
    that, we will access multiple ink files in Unity to present an interface containing
    multiple quests. Finally, we will allow a user to toggle between quests and progress
    them independently of each other.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用Unity中稍后要访问的新变量更新墨迹模板。然后，我们将在Unity中创建`Quest`和`Dialogue`类。之后，我们将访问Unity中的多个ink文件，以展示包含多个任务的界面。最后，我们将允许用户在任务之间切换，并独立推进每个任务。
- en: Reminder
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *examples on GitHub* folder, under the name *Chapter11-MultipleQuests*. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在 GitHub 的 [*第 11 章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *示例* 文件夹中找到，名称为 *Chapter11-MultipleQuests*。只会展示与该主题章节中探讨的概念相关的代码部分。
- en: Building on the ink quest template
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于 ink 任务模板构建
- en: As we saw in [*Chapter 8*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123),
    *Story API – Accessing ink Variables and Functions*, we can access ink variables
    that have been created with the `VAR` keyword using the `variablesState` property
    in Unity. This allows us to retrieve the value of a variable based on its name.
    With that in mind, the existing ink template can be expanded to include a new
    variable for each quest – its `name`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第 8 章*](B17597_08_Final_PG_ePub.xhtml#_idTextAnchor123) 中看到的，*Story
    API – Accessing ink Variables and Functions*，我们可以使用 Unity 中的 `variablesState`
    属性访问使用 `VAR` 关键字创建的 ink 变量。这允许我们根据变量的名称检索变量的值。考虑到这一点，现有的 ink 模板可以扩展以包括每个任务的新的变量
    – 它的 `name`。
- en: 'By understanding that the compiled ink files will be operated from Unity, we
    can anticipate certain needs we will have with quests. For example, a quest usually
    has a *name*. We can then define this variable alongside our existing values in
    Ink:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解编译后的墨迹文件将在 Unity 中操作，我们可以预测我们在任务中可能需要的某些需求。例如，一个任务通常有一个*名称*。然后我们可以在 Ink
    中定义这个变量，并与其现有的值一起：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once we know that the `name` variable exists in ink, we can read it in Unity.
    However, unlike what was shown in the previously section, we will need to observe
    the `end` ink variable as well:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道 ink 中的 `name` 变量存在，我们就可以在 Unity 中读取它。然而，与之前章节中展示的不同，我们还需要观察 `end` ink
    变量：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These small changes may not seem important, but by establishing a pattern where
    certain variables exist (`name` and `end`) and all files containing quests will
    also have a knot named `progress` (as defined in the previous section), we can
    write any quests we want if those parts remain the same.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小的变化可能看起来并不重要，但通过建立一个模式，其中某些变量存在（`name` 和 `end`），并且所有包含任务的文件也将有一个名为 `progress`
    的节点（如前一小节中定义的），如果这些部分保持不变，我们就可以编写任何我们想要的任务。
- en: Once these variables have been prepared, we can start creating the `Quest` and
    `Dialogue` classes, which will hold the values we defined in ink and read them
    in Unity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些变量已经准备好，我们就可以开始创建 `Quest` 和 `Dialogue` 类，这些类将持有我们在 ink 中定义的值并在 Unity 中读取它们。
- en: Making Quest and Dialogue classes in Unity
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity 中创建 Quest 和 Dialogue 类
- en: 'In the previous section, we combined a simple presentation of dialogue options
    with the values and methods to progress the single quest presented. In this section,
    we will break that functionality into two new classes in Unity: `Quest` and `Dialogue`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一小节中，我们将对话选项的简单展示与推进单个任务的值和方法结合起来。在本节中，我们将将该功能拆分为 Unity 中的两个新类：`Quest` 和 `Dialogue`。
- en: 'Most of the `Quest` class was shown in the previous section. However, its purpose
    is to hold a `Story` object and to expose a method named `Progress()` that internally
    calls the `ChoosePathString()` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的 `Quest` 类在前一小节中已经展示。然而，它的目的是持有 `Story` 对象，并公开一个名为 `Progress()` 的方法，该方法内部调用
    `ChoosePathString()` 方法：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Quest` class is small because it is used by other classes. Its sole purpose
    is to contain the quest (ink story) and provide a way to progress the quest (via
    the `Progress()` method).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Quest` 类很小，因为它被其他类使用。它的唯一目的是包含任务（ink 故事）并提供一种推进任务的方式（通过 `Progress()` 方法）。'
- en: 'The new class, `Dialogue`, performs most of the work to create the `Button`
    game objects needed and to remember what the last line of dialogue was as a reminder
    for the player. Its `UpdateContent()` method looks like the example code that
    was first shown in [*Chapter 7*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106),
    *Unity API – Making Choices and Story Progression*, except for using the new `Quest`
    class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类 `Dialogue` 执行创建所需的 `Button` 游戏对象的大部分工作，并记住最后一条对话内容，作为对玩家的提醒。它的 `UpdateContent()`
    方法看起来像在 [*第 7 章*](B17597_07_Final_PG_ePub.xhtml#_idTextAnchor106) 中首次展示的示例代码，*Unity
    API – Making Choices and Story Progression*，除了使用新的 `Quest` 类：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the updated ink template from the first section and the introduction of
    the `Quest` and `Dialogue` classes in this section, two more parts are needed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一节的更新墨迹模板和本节中引入 `Quest` 和 `Dialogue` 类的基础上，还需要两个部分：
- en: Quests need to be based on compiled JSON files
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务需要基于编译后的 JSON 文件
- en: Players need to be able to toggle which quest they are progressing
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家需要能够切换他们正在进行的任务
- en: In the next section, we will start with the first part by learning how to read
    files and creating a new `Quest` class per file found.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将从学习如何读取文件和为每个找到的文件创建一个新的`Quest`类开始。
- en: Organizing multiple quest files
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织多个任务文件
- en: In the previous examples in this book, a single ink file was used per project.
    This section will break away from that pattern. To track multiple quests, we will
    define each quest in its own file and then read the compiled JSON files. The `Quest`
    class, which we looked at in the previous section, will hold the contents and
    expose some of the values in each file. The `Dialogue` class will create the options
    the player will see based on the `Quest` class's values. First, however, we will
    need to read the files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前例中，每个项目使用了一个ink文件。本节将打破这种模式。为了跟踪多个任务，我们将为每个任务定义一个单独的文件，然后读取编译后的JSON文件。我们在上一节中查看的`Quest`类将包含内容并暴露每个文件中的某些值。`Dialogue`类将根据`Quest`类的值创建玩家将看到的选项。然而，首先我们需要读取文件。
- en: 'This book follows the recommended naming convention of Unity folders and has
    placed all the Ink files in a folder named `Ink`. Using the **Compile All Ink
    Automatically** option in the **Project Settings** window, each created ink file
    will also contain a JSON file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本书遵循Unity文件夹的推荐命名约定，并将所有Ink文件放置在一个名为`Ink`的文件夹中。使用**项目设置**窗口中的**自动编译所有Ink**选项，每个创建的ink文件也将包含一个JSON文件：
- en: '![Figure 11.1 – Compiled JSON files in the Ink folder'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – Ink文件夹中的编译JSON文件'
- en: '](img/Figure_11.1_B17597.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B17597.jpg)'
- en: Figure 11.1 – Compiled JSON files in the Ink folder
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – Ink文件夹中的编译JSON文件
- en: 'Because Unity can run on many different operating systems, it exposes the `Assets`
    folder (shown in the `Application.dataPath`. This is the *path* to the data, as
    part of the currently running application. Based on this value, any additional
    folders can be found, and their files can be accessed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Unity可以在许多不同的操作系统上运行，它暴露了`Assets`文件夹（如`Application.dataPath`所示。这是数据的*路径*，作为当前运行应用程序的一部分。基于此值，可以找到任何额外的文件夹，并访问它们的文件：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By using the `Application.dataPath` property, each compiled ink file (JSON file)
    can be read, and a new object based on the `Quest` class is created. This not
    only allows each quest to operate independently of each other via their quest
    progression, but it also exposes values that the `Dialogue` class can use to present
    different options to the player.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Application.dataPath`属性，每个编译的ink文件（JSON文件）都可以被读取，并基于`Quest`类创建一个新的对象。这不仅允许每个任务通过它们的任务进度独立运行，而且还暴露了`Dialogue`类可以使用以向玩家展示不同选项的值。
- en: In the next and final section, we will write some code that will allow a player
    to toggle between which quest is active for them and see the `Quest` and `Dialogue`
    classes in action.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节和最后一节中，我们将编写一些代码，允许玩家在哪个任务对他们来说是活动的之间切换，并看到`Quest`和`Dialogue`类的实际应用。
- en: Toggling quests
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换任务
- en: 'In Unity, the `Toggle` game object allows a user to select a single item among
    a group of items. For its usage in the project that''s part of this section, a
    `Toggle` prefab must be created. Like the usage of `Button` game objects, these
    are created as needed. As each `Toggle` game object is based on an object using
    the `Quest` class, this means the `GetFiles()` method (shown in the previous section,
    *Organizing multiple quest files*) is run first, and the resulting quests are
    used to make the `Toggle` game objects:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，`Toggle`游戏对象允许用户在多个项目中选择一个。对于本节中该项目的使用，必须创建一个`Toggle`预制件。就像`Button`游戏对象的使用一样，这些是按需创建的。由于每个`Toggle`游戏对象基于使用`Quest`类的对象，这意味着首先运行了上一节中显示的`GetFiles()`方法（*组织多个任务文件*），然后使用生成的任务来创建`Toggle`游戏对象：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `CreateQuestToggles()` method references a component named `ToggleScript`.
    This is a `Script` component that is part of each `Toggle` prefab. Each time one
    is created, its values are set:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateQuestToggles()`方法引用了一个名为`ToggleScript`的组件。这是一个`Script`组件，它是每个`Toggle`预制件的一部分。每次创建时，它的值都会被设置：'
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This process, starting with the `GetFiles()` method, creates objects based
    on the `Quest` class first. Next, `Toggle` prefabs are created, and values are
    passed to its `Script` component. Internally, the `Toggle` prefab creates an additional
    `Script` component based on the `Dialogue` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程，从`GetFiles()`方法开始，首先基于`Quest`类创建对象。接下来，创建`Toggle`预制体，并将值传递给其`Script`组件。内部，`Toggle`预制体基于`Dialogue`类创建了一个额外的`Script`组件：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The reason for this multiple-step process of creating objects based on the
    `Quest` class, and then leading to the `Dialogue` class, is to allow each `Toggle`
    prefab to control what is shown to the player:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于`Quest`类创建对象的多步骤过程，然后引导到`Dialogue`类的原因是允许每个`Toggle`预制体控制向玩家显示的内容：
- en: '![Figure 11.2 – Quest selection and options shown to the player'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 – 显示给玩家的探索选择和选项'
- en: '](img/Figure_11.2_B17597.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B17597.jpg)'
- en: Figure 11.2 – Quest selection and options shown to the player
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 显示给玩家的探索选择和选项
- en: Upon clicking on a `Toggle` prefab, its object is enabled based on the `Dialogue`
    class, showing the current text and options to the player. These, in turn, are
    based on the `Quest` class's values, as passed to the `Dialogue` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击一个`Toggle`预制体时，根据`Dialogue`类，其对象会启用，向玩家显示当前文本和选项。这些选项反过来又基于`Quest`类的值，这些值传递给了`Dialogue`类。
- en: The combined effect of the code is to create separate quests. Depending on which
    is active, as determined by each `Toggle` prefab selected by the player, they
    will see different dialogue options and be presented with the ability to progress
    each quest independently of each other at the end of each step. This combines
    the ink template that we created in the first section with a multiple-quest approach,
    as shown in this section, which uses multiple files and adds the ability to progress
    across individual quests, independent of each other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的综合效果是创建独立的探索。根据每个由玩家选择的`Toggle`预制体确定的哪个是活动的，玩家将看到不同的对话选项，并在每个步骤结束时独立于其他探索展示出推进每个探索的能力。这结合了我们第一部分创建的ink模板和本节展示的多个探索方法，使用多个文件并增加了跨独立探索推进的能力。
- en: In the next section, we will examine how to award player progression by passing
    information between quests. This will build on the project we created for this
    section and the concepts from the first section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何通过在探索之间传递信息来奖励玩家的进度。这将基于本节创建的项目和第一部分的概念。
- en: Displaying and awarding player progression
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和奖励玩家进度
- en: 'In programming, there are two approaches to accessing values in one system
    from another: **polling** and **events-based**. Either a value can be checked
    if it has changed (*polling*) or one system can wait for a message (*event*) from
    the other to signal that a value has changed. Because the second system must wait
    for an event to happen, this is often known as the **observer pattern** because
    the second system is *observing* events.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有两种方法可以从一个系统访问另一个系统的值：**轮询**和**基于事件**。要么检查一个值是否已更改（*轮询*），要么一个系统等待来自另一个系统的消息（*事件*）来指示值已更改。由于第二个系统必须等待事件发生，这通常被称为**观察者模式**，因为第二个系统正在*观察*事件。
- en: In the first section, we saw an example of polling in action. Each time a step
    of the quest came to its end, the Unity code checked (*polled*) the ink values
    to see if it should show a `Button` game object and allow the player to progress
    the quest. The second section moved us closer to an events-based approach, where
    the `ObserveVariable()` method was used within the `Quest` class. In the second
    project, whenever the `end` ink variable changed, it updated the `End` property
    of the `Quest` class in Unity. As this value (the `End` property) was used as
    part of determining whether the quest could progress, this made the second project
    more dynamic than the one that was used in the first project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们看到了一个投票动作的例子。每当探索的步骤结束时，Unity代码会检查（*轮询*）墨水值，以确定是否应该显示一个`Button`游戏对象并允许玩家推进探索。在第二部分，我们更接近基于事件的方法，其中在`Quest`类中使用`ObserveVariable()`方法。在第二个项目中，每当`end`墨水变量改变时，它会更新Unity中`Quest`类的`End`属性。由于这个值（`End`属性）被用作确定探索是否可以推进的一部分，这使得第二个项目比第一个项目更动态。
- en: To award a player for completing a quest or achieving some outcome as part of
    one quest in another, information needs to be passed between them. Because the
    ink runtime already supports an events-based approach via its `ObserveVariable()`
    and `ObserveVariables()` named methods, this makes the process slightly easier.
    However, as we introduced in the previous section, using a `Quest` class means
    each ink story is now independent of each other.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了奖励玩家完成一个任务或作为另一个任务的一部分实现某些结果，需要在它们之间传递信息。由于墨迹运行时已经通过其名为 `ObserveVariable()`
    和 `ObserveVariables()` 的命名方法支持基于事件的访问方式，这使得这个过程稍微容易一些。然而，正如我们在上一节中介绍的，使用 `Quest`
    类意味着每个墨迹故事现在都是相互独立的。
- en: In this section, we will start by creating a way for each `Quest` class to share
    changes as they happen while a player is progressing them. We will end by learning
    how to show the player this information as they complete different quests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先创建一种方式，让每个 `Quest` 类在玩家进行任务时共享变化。我们将以学习如何向玩家展示他们在完成不同任务时获得的信息结束。
- en: Reminder
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: The completed project for this section can be found in the [*Chapter 11*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *examples on GitHub* folder, under the name *Chapter11-TrackingQuests*. Only select
    parts of the code will be shown as they relate to the concepts examined in the
    sections of this topic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节完成的项目的示例可以在 GitHub 的 [*第11章*](B17597_11_Final_PG_ePub.xhtml#_idTextAnchor159)
    *示例文件夹下找到，名称为 *Chapter11-TrackingQuests*。只会展示与该主题各部分中检查的概念相关的代码部分。
- en: Tracking quest values
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪任务值
- en: 'The `Story` class method, `ObserveVariables()`, can track different variables
    based on their names. However, the existing ink template contains the variables
    it uses to track progression. This means that the first step of tracking quest
    values is to make a list of variables to exclude from tracking as part of an expanded
    `Quest` class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Story` 类方法 `ObserveVariables()` 可以根据其名称跟踪不同的变量。然而，现有的墨迹模板包含了它用于跟踪进度的变量。这意味着跟踪任务值的第一个步骤是创建一个变量列表，排除作为扩展
    `Quest` 类一部分的跟踪：'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, all the variables contained in the `variablesState` property, excluding
    those in the created list used to track quest progression, need to be tracked.
    This means that for each variable, it can be added to a separate list to be passed
    to the `Story` method known as `ObserveVariables()`. This can be part of the `ObserveVariables()`
    method, as part of the `Quest` method, so that it matches the one on the `Story`
    class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要跟踪 `variablesState` 属性中包含的所有变量，除了用于跟踪任务进度的创建列表中的那些变量。这意味着对于每个变量，它可以被添加到一个单独的列表中，以便传递给名为
    `ObserveVariables()` 的 `Story` 方法。这可以是 `ObserveVariables()` 方法的部分，也可以是 `Quest`
    方法的部分，以便与 `Story` 类上的对应方法相匹配：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new `ObserveVariables()` method that was added to the `Quest` class accepts
    a single parameter, `Story.VariableObserver`. Internally, the `Story` class defines
    a `delegate` method called `VariableObserver`. Using the same type for the new
    method allows other methods to be passed through the `Quest` method to the `Story`
    method of the same name. In other words, the new method works the same as the
    existing one, but it will exclude a specific list of variable names.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 `Quest` 类的新 `ObserveVariables()` 方法接受一个单一参数，`Story.VariableObserver`。内部，`Story`
    类定义了一个名为 `delegate` 的方法，称为 `VariableObserver`。使用相同类型的新方法允许其他方法通过 `Quest` 方法传递到同名的
    `Story` 方法。换句话说，新方法与现有方法的工作方式相同，但它将排除特定的一组变量名称。
- en: 'While observing variables, there also needs to be a way to update the values
    of variables across all quests whenever a value changes in one. Using the existing
    `variablesState` property, a new method can be added to the `Quest` class named
    `UpdateVariable()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察变量时，还需要有一种方法，在其中一个变量的值发生变化时，更新所有任务中变量的值。使用现有的 `variablesState` 属性，可以向 `Quest`
    类添加一个名为 `UpdateVariable()` 的新方法：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside the `UpdateVariable()` method are two important checks. The first uses
    the `GlobalVariableExistsWithName()` method. This method checks if a variable
    exists. Without this check, if one quest added a variable another did not have,
    the entire project could crash. The second check verifies whether the variable
    to be updated does not already have the same value. Without this second check,
    updating a variable would trigger a variable change in any other quests, which
    would trigger another update. This would eventually cause a crash as quests would
    be trying to update each other in an endless loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateVariable()`方法中包含两个重要的检查。第一个使用`GlobalVariableExistsWithName()`方法。此方法检查变量是否存在。如果没有这个检查，如果一个任务添加了一个变量而另一个没有，整个项目可能会崩溃。第二个检查验证要更新的变量是否已经具有相同的值。如果没有这个第二个检查，更新变量将触发其他任何任务中的变量更改，这将触发另一个更新。这最终会导致崩溃，因为任务将尝试在无限循环中相互更新。
- en: 'Between the two new methods, `ObserveVariables()` and `UpdateVariable()`, one
    more part is needed: the two methods must be combined. Based on the project from
    the second section, *Tracking progress across multiple quests*, the `InkStoryScript`
    code is the best place to add this combination. The reason for this placement
    is because this will allow each quest to be configured as part of the existing
    loop:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个新方法`ObserveVariables()`和`UpdateVariable()`之间，还需要一个额外的部分：这两个方法必须结合使用。基于第二部分的工程，*跨多个任务跟踪进度*，`InkStoryScript`代码是添加这个组合的最佳位置。这样做的原因是因为这将允许每个任务作为现有循环的一部分进行配置：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This new code references an additional method, `UpdateAllQuests()`. When passed
    the name of a variable and its value, this new method works through the existing
    quests and updates their values by calling `UpdateVariable()` per quest:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码引用了一个额外的函数，`UpdateAllQuests()`。当传入一个变量的名称及其值时，这个新函数会遍历现有的任务，并通过为每个任务调用`UpdateVariable()`来更新它们的值：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we have defined multiple new methods. We added two to the `Quest`
    class called `ObserveVariables()` and `UpdateVariable()`. These detect changes
    using the event approach. ink will signal to Unity when a variable in one of the
    quests changes. We also added code to `InkStoryScript` by using a new method called
    `UpdateAllQuests()`, which will update the same variable in other quests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们定义了多个新方法。我们向`Quest`类添加了两个名为`ObserveVariables()`和`UpdateVariable()`的方法。这些方法使用事件方法来检测更改。ink将在某个任务中的变量更改时向Unity发出信号。我们还通过使用名为`UpdateAllQuests()`的新方法在`InkStoryScript`中添加了代码，这个方法将更新其他任务中的相同变量。
- en: In the next section, we will finalize this project. Detecting changes and updating
    other quests help keep all of them updated as changes happen. Next, we need to
    show data to the player as changes happen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将完成这个项目。检测更改并更新其他任务有助于在发生更改时保持所有任务更新。接下来，我们需要在发生更改时向玩家展示数据。
- en: Showing player progress
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示玩家进度
- en: 'In the previous section, we created the necessary code to keep all the variables
    used across quests updated. To show the player this data, we must add a new game
    object named `StatisticsText`. Next, we need to use a special keyword in C#: `static`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了必要的代码来保持跨任务使用的所有变量更新。为了向玩家展示这些数据，我们必须添加一个新的游戏对象名为`StatisticsText`。接下来，我们需要在C#中使用一个特殊的关键字：`static`。
- en: 'Any method or property using the `static` keyword in C# exists outside of any
    instances of the class. This means that the property can be accessed or the method
    can be called anywhere in the project. However, this comes with a major caveat:
    any `static` method can only access `static` properties. To allow another class
    (`Dialogue`) to be able to call a `static` method in `InkStoryScript` (which holds
    all the quests), the existing `quests` and new `StatisticsText` variable must
    both use the `static` keyword:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，使用`static`关键字的方法存在于类的任何实例之外。这意味着属性可以在项目的任何地方被访问或方法可以被调用。然而，这也带来一个主要的限制：任何`static`方法只能访问`static`属性。为了允许另一个类（`Dialogue`）能够调用`InkStoryScript`（其中包含所有任务）中的`static`方法，现有的`quests`和新`StatisticsText`变量都必须使用`static`关键字：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the `quests` and `StatisticsText` properties, they can be accessed by
    a new method named `ShowStatistics()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quests`和`StatisticsText`属性，它们可以通过一个名为`ShowStatistics()`的新方法被访问：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The new `ShowStatistics()` method uses a `Dictionary<string, object>`. This
    combines the name of the variable (`string`) with its value (`object`). However,
    a `Dictionary` in C# comes with an obstacle: it can only contain unique keys.
    In the `ShowStatistics()` method, the use of the `ContainsKey()` method prevents
    this issue.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ShowStatistics()`方法使用`Dictionary<string, object>`。这结合了变量的名称（`string`）和其值（`object`）。然而，C#中的`Dictionary`存在一个障碍：它只能包含唯一的键。在`ShowStatistics()`方法中，使用`ContainsKey()`方法防止了这个问题。
- en: 'To set up a method that can be called by another class, the new `ShowStatistics()`code
    must be placed within the `Dialogue` class as part of its `UpdateContent()` method,
    after the creation of the `Button` game objects based on the current choices:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置一个可以被其他类调用的方法，新的`ShowStatistics()`代码必须放置在`Dialogue`类中，作为其`UpdateContent()`方法的一部分，在基于当前选择的创建`Button`游戏对象之后：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The new code will always show the latest values of the variables as the values
    are updated. Because each quest handles updating its variables based on an event-based
    approach, any user action for making choices or selecting a quest will update
    all the values being tracked by the project and constantly show player progression.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码将始终显示变量的最新值，因为值被更新。由于每个任务都根据基于事件的方法来处理其变量的更新，任何用户动作，如做出选择或选择任务，都将更新项目跟踪的所有值，并不断显示玩家进度。
- en: In this section, we awarded player progression by showing the player's the updated
    values. We started by adding some code from the previous section to constantly
    update the variables with the same names across all quests. This keeps all the
    quests connected. Then, we created a `ShowStatistics()` method to show these values
    and updated a `Text` game object with their names and values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过向玩家展示更新的值来奖励玩家的进度。我们首先添加了上一节的一些代码，以不断更新所有任务中具有相同名称的变量。这保持了所有任务的连接。然后，我们创建了一个`ShowStatistics()`方法来显示这些值，并更新了一个`Text`游戏对象，以显示它们的名称和值。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by creating an ink template. By defining variables and
    a `progress` knot in ink, we can move through the various sections of a quest
    as individual stitches within a larger knot. Next, we looked at the `ChoosePathString()`
    method, which can forcibly move a story to a new section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建墨迹模板来开始本章。通过在墨迹中定义变量和一个`progress`节点，我们可以像更大节点中的单个线迹一样，在任务的各个部分之间移动。接下来，我们研究了`ChoosePathString()`方法，它可以强制将故事移动到新的部分。
- en: In the second section, we broke away from single files and developed a `Quest`
    class. Each object based on the `Quest` class contained an ink `Story` object
    based on different files and a method named `Progress()`, which calls the `ChoosePathString()`
    method internally. As part of this section, we learned how the `Quest` and `Dialogue`
    classes can help organize functionality into different classes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们摆脱了单个文件，并开发了一个`Quest`类。基于`Quest`类的每个对象都包含一个基于不同文件的ink`Story`对象和一个名为`Progress()`的方法，该方法内部调用`ChoosePathString()`方法。作为本部分的一部分，我们学习了`Quest`和`Dialogue`类如何帮助将功能组织到不同的类中。
- en: Finally, we displayed the name and values of variables. First, we added new
    methods to detect variable changes in any quest using an events-based approach.
    This triggered other variables with the same name in other quests to have their
    values updated. Then, we added the `ShowStatistics()` method to display these
    updating values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示了变量的名称和值。首先，我们添加了新的方法，使用基于事件的方法来检测任何任务中的变量变化。这触发了其他任务中具有相同名称的其他变量的值更新。然后，我们添加了`ShowStatistics()`方法来显示这些更新的值。
- en: In the next chapter, [*Chapter 12*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174),
    *Procedural Storytelling with ink*, we will review the basics of procedurally
    organizing different story sections and content. While looking at two approaches,
    either coding values in ink or loading data into ink dynamically, we will examine
    when one approach might be better, depending on the context.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[*第12章*](B17597_12_Final_PG_ePub.xhtml#_idTextAnchor174)，*使用ink进行程序化叙事*，我们将回顾程序化组织不同故事部分和内容的基本知识。在查看两种方法时，即直接在ink中编码值或动态将数据加载到ink中，我们将研究在特定情况下哪种方法可能更好。
- en: Q&A
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问答
- en: What is a quest?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是任务？
- en: What is the name of the knot that's used to progress a quest based on the ink
    template shown in this chapter?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于根据本章中显示的墨迹模板推进任务的节点的名称是什么？
- en: How does the `ChoosePathString()` method work?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ChoosePathString()`方法是如何工作的？'
- en: What is the name of the global property where Unity records the path for the
    data of the application?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity记录应用程序数据路径的全局属性叫什么名字？
- en: What is the difference between polling and events-based approaches?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轮询和基于事件的两种方法有什么区别？
