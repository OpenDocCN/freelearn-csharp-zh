["```cs\n    public class Counter  \n    { \n      private int i = 0; \n      public int AddOneRO (int x) //Referentially Opaque \n      { \n        i += 1; \n        return x + i; \n      } \n      public int AddOneRT (int x) //Referentially Transparent \n      { \n        return x + 1; \n      } \n    } \n\n```", "```cs\n        Func<T1, T2, . . . , Tn, TReturn>\n```", "```cs\n        Action<T1, T2, . . . , Tn>\n```", "```cs\n        Predicate<T1, T2, . . . , Tn>\n```", "```cs\n    public static IEnumerable<T> GenerateSequences<T> ( \n    int noOfElements, Func<T> generator) \n    { \n      for ( int i = 0; i < noOfElements; i++ ) \n      { \n        yield return generator(); \n      } \n    } \n\n    public static IEnumerable<TSource> Where<TSource> ( \n    IEnumerable<TSource> source, Predicate<TSource> predicate) \n    { \n      foreach ( TSource element in source ) \n      { \n        if ( predicate(element) ) \n          yield return element; \n      } \n    } \n\n```", "```cs\n    int startEven = -2; \n    int startOdd = -1; \n    int increment = 2; \n\n    //To Generate first 1000 even numbers \n    IEnumerable<int> evenSequences = GenerateSequences<int> ( \n      1000, () => startEven += increment); \n\n    //To Generate first 1000 odd numbers \n    IEnumerable<int> oddSequences = GenerateSequences<int> ( \n      1000, () => startOdd += increment); \n\n```", "```cs\n    public static int AddOperation (int x, int y) \n    { \n      return x + y; \n    } \n\n```", "```cs\n    Func<int, int, int> AddOperation = delegate(int x, int y) \n    { \n      return x + y; \n    }; \n\n```", "```cs\n    Func<int, int, int> AddOperation = (x, y) => x + y; \n\n```", "```cs\n    Func<string, string, string> ConcatOperation = (x, y) => x + y; \n\n```", "```cs\n    public static Func<int, Func<int, int>> sum =  \n    x => y => x + y; \n\n```", "```cs\n    var add10 = sum(10); //Returns closure with 10 \n    var add50 = sum(50); //Returns closure with 50 \n\n    Console.WriteLine(add10(90));  //Returns 100 \n    Console.WriteLine(add10(190)); //Returns 200 \n    Console.WriteLine(add50(70));  //Returns 120 \n\n```", "```cs\n    public static int AddOperation (int x, int y) \n    { \n      return x + y; \n    } \n\n```", "```cs\n    public static Func<T1, Func<T2, TReturn>> Curry<T1, T2, TReturn> \n    (Func<T1, T2, TReturn> f) \n    { \n      return a => b => f(a, b); \n    } \n\n```", "```cs\n    var curriedSum = Curry<int, int, int>(AddOperation); \n\n    Console.WriteLine( \"Sum: {0}\", curriedSum(10)(90));\n    //Prints Sum: 100 \n\n```", "```cs\n    public static Func<T1, Func<T2, TReturn>> Curry<T1, T2, TReturn> \n    (this Func<T1, T2, TReturn> f) \n    { \n      return a => b => f(a, b); \n    } \n\n```", "```cs\n    Func<int, int, int> op = AddOperation; \n    var curriedSum = op.Curry<int, int, int>(); \n\n    Console.WriteLine( \n      \"Sum: {0}\",  \n      curriedSum1(10)(90) \n    );                \n    //Prints Sum: 100 \n\n```", "```cs\n    public static string ConcatOperation (string x, string y) \n    { \n      return x + y; \n    } \n\n    Func<string, string, string> op2 = ConcatOperation; \n    var curriedConcat = op2.Curry<string, string, string>(); \n\n    Console.WriteLine( \n      \"Concatenation: {0}\",  \n      curriedConcat(\"Currying \")(\"Rocks!!!\") \n    );                  \n    //Prints \"Concatenation: Currying Rocks!!!\" \n\n```", "```cs\n    //Currying Extension Method that Supports 3 Input Parameters \n\n    public static Func<T1, Func<T2, Func<T3, TReturn>>>  \n    Curry<T1, T2, T3, TReturn>  \n    (this Func<T1, T2, T3, TReturn> f) \n    { \n      return a => b => c => f(a, b, c); \n    } \n    // Currying Extension Method that Supports 4 Input Parameters \n\n    public static Func<T1, Func<T2, Func<T3, Func<T4, TReturn>>>>  \n      Curry<T1, T2, T3, T4, TReturn> \n      (this Func<T1, T2, T3, T4, TReturn> f) \n      { \n        return a => b => c => d => f(a, b, c, d); \n      } \n\n```", "```cs\n    public static string ConcatOperation(string a, string b, string c,  \n    string d) \n    { \n      return a + b + c + d; \n    } \n\n    //Partial Application in functions that have 3 Input Parameters \n\n    public static Func<T2, T3, TReturn>  \n    PartialApply<T1, T2, T3, TReturn> \n    (this Func<T1, T2, T3, TReturn> f, T1 arg1) \n    { \n      return (arg2, arg3) => f(arg1, arg2, arg3); \n    } \n\n    //Partial Application in functions that have 4 Input Parameters \n\n    public static Func<T2, T3, T4, TReturn>  \n    PartialApply<T1, T2, T3, T4, TReturn> \n    (this Func<T1, T2, T3, T4, TReturn> f, T1 arg1) \n    { \n      return (arg2, arg3, arg4) => f(arg1, arg2, arg3, arg4); \n    } \n\n    //Sample code that illustrates usage \n\n    Func<string, string, string, string, string> op3 = ConcatOperation; \n\n    var partiallyAppliedConcat = op3\\. \n    PartialApply<string, string, string, string, string> \n    (\"Partial \"); \n\n    Console.WriteLine( \n      \"Concatenation: {0}\",  \n      partiallyAppliedConcat( \n        \"Function \",  \n        \"Application \",  \n        \"Rocks!!!\") \n      ); \n    //Prints \"Concatenation: Partial Function Application Rocks!!!\" \n\n```", "```cs\n    //The formula that confirms a Pythagorean Triplet \n\n    public static bool IsPythagoreanTriplet (int x, int y, int z) \n    { \n      return (x * x + y * y) == (z * z); \n    } \n\n    //Function that generates the triples within a given range based    \n    //on the above formula. \n\n    public static IEnumerable<IEnumerable<int>>  \n    PythagoreanTriples (int range) \n    { \n      Func<int, int, int, bool> formula = IsPythagoreanTriplet; \n      HashSet<string> capturedTriplets = new HashSet<string>(); \n\n      for (int a = 1; a < range; a++) \n      { \n        for (int b = 1; b < range; b++) \n        { \n          for (int c = 1; c < range; c++) \n          { \n            if (formula(a, b, c))      //Direct Evaluation \n            { \n              string keyPart1 = a.ToString(); \n              string keyPart2 = b.ToString(); \n              //This check filters the duplicate triplets \n              if (!capturedTriplets \n              .Contains(keyPart1 + \":\" + keyPart2) \n              && \n              !capturedTriplets \n              .Contains(keyPart2 + \":\" + keyPart1) \n              ) \n              { \n                capturedTriplets \n                .Add(keyPart1 + \":\" + keyPart2); \n                yield return new List<int>() { a, b, c }; \n              } \n            } \n          } \n        } \n      } \n    } \n\n```", "```cs\n    public static IEnumerable<IEnumerable<int>>  \n    PythagoreanTriplesCurried (int range) \n   { \n     Func<int, int, int, bool> formula = IsPythagoreanTriplet; \n var cFormula = formula.Curry<int, int, int, bool>(); \n     HashSet<string> capturedTriplets = new HashSet<string>(); \n\n     for (int a = 1; a < range; a++) \n     { \n       for (int b = 1; b < range; b++) \n       { \n         for (int c = 1; c < range; c++) \n         { \n           if (cFormula(a)(b)(c))    //Curried Evaluation \n           { \n             // Use same code from PythagoreanTriples function\n           } \n         } \n       } \n     } \n   } \n\n```", "```cs\n    public static IEnumerable<IEnumerable<int>>  \n    PythagoreanTriplesPartiallyApplied (int range) \n    { \n      Func<int, int, int, bool> formula = IsPythagoreanTriplet; \n      HashSet<string> capturedTriplets = new HashSet<string>(); \n\n      for (int a = 1; a < range; a++) \n      { \n        var paFormula = formula \n        .PartialApply<int, int, int, bool>(a); \n        for (int b = 1; b < range; b++) \n        { \n          for (int c = 1; c < range; c++) \n          { \n            //Final Evaluation with remaining arguments \n            if (paFormula(b, c))     \n            { \n              // Use same code from PythagoreanTriples function\n            } \n          } \n        } \n      } \n    } \n\n```", "```cs\n    Console.WriteLine(\"PythagoreanTriples within 50....\"); \n\n    foreach (var triplets in PythagoreanTriplesPartiallyApplied(50)) \n    { \n      Console.WriteLine(string.Join(\",\", triplets.ToArray())); \n    } \n    Console.ReadLine(); \n\n```", "```cs\n    //Regular Recursion \n\n    Func<int, int> factorial = (n) => \n    { \n      Func<int, int> fIterator = null; //Work-around for \"use of \n        unassigned variable\" error! \n      fIterator = (m) =>  \n        (m < 2) ? 1 : m * fIterator(m - 1); \n      return fIterator(n); \n    };\n```", "```cs\n    //Tail Call Elimination with Tail Recursion \n\n    Func<int, int> factorial = (n) => \n    { \n      Func<int, int, int> fIterator = null; \n      fIterator = (product, i) =>  \n        (i < 2) ? product : fIterator(product * i, i - 1); \n      return fIterator(1, n); \n    };\n```", "```cs\n    //Tail Recursion with Trampolining \n\n    Func<int, int> factorial = (n) => \n    { \n      Func<int, int, int> trampoline = null; \n      Func<int, int, int> fIterator = (product, i) =>  \n        (i < 2) ? product : trampoline(product * i, i - 1); \n      trampoline = (product, i) =>  \n        fIterator(product * i, i - 1); \n      return trampoline(1, n); \n    }; \n\n```", "```cs\n    public static IEnumerable<string> NorvigSpellChecker  \n    (string word, int count) \n    { \n      var alphabets = @\"abcdefghijklmnopqrstuvwxyz\"; \n      var WORDS = new ConcurrentDictionary<string, int>(); \n      var trainingFile = @\"D:\\Packt\\Code\\NSC_Training_Model.txt\"; \n\n      //Training Model Creation \n\n      var Train = Task.Factory.StartNew(() => \n      { \n        foreach (var line in File \n          .ReadLines(trainingFile) \n          .AsParallel())    //Parallel read \n        { \n          foreach (Match match in  \n          Regex.Matches( \n            line,  \n            @\"([a-z]+)\",     //Word detection \n            RegexOptions.IgnoreCase \n          ) \n          .AsParallel()) \n          { \n            WORDS.AddOrUpdate(    //Add detected word to dictionary\n              match.Value,             \n              0, \n              (k, v) => v + 1);   //Increment word count \n          } \n      } \n    }); \n\n    //All edits that are 1 edit away from word \n\n    Func<string, Task<IEnumerable<string>>> edits1 =  \n    (tWord) => Task.Factory.StartNew(() => \n    { \n      return from i in Enumerable.Range(0, tWord.Length) \n      select new \n      { \n        part1 = tWord.Substring(0, i), \n        part2 = tWord.Substring(i) \n      }; //splits \n    }) \n    .ContinueWith(ant => \n    { \n      return (from splits in ant.Result \n      where splits.part2 != \"\" \n      select splits.part1 +  \n      splits.part2 \n      .Substring(1))                    //deletes \n      .Union(from splits in ant.Result \n      where splits.part2.Length > 1 \n      select splits.part1 +  \n      splits.part2[1] +  \n      splits.part2[0] +  \n      splits.part2 \n      .Substring(2))                    //transposes \n      .Union(from splits in ant.Result \n      from c in alphabets \n      where splits.part2 != \"\" \n      select splits.part1 + c + splits.part2.Substring(1)) //replaces \n      .Union(from splits in ant.Result \n      from c in alphabets \n      select splits.part1 + c + splits.part2);             //inserts \n    }); \n\n    //All edits that are 2 edits away from word \n\n    Func<string, Task<IEnumerable<string>>> edits2 =  \n    (tWord) => Task.Factory.StartNew(() => \n    { \n      return (from e1 in edits1(tWord).Result \n      from e2 in edits1(e1).Result \n      where WORDS.ContainsKey(e2) \n      select e2); \n    }); \n\n    //Returns the subset of words that appear in the  \n    //dictionary of WORDS \n\n    Func<IEnumerable<string>, Task<IEnumerable<string>>> known =  \n    (tWords) => Task.Factory.StartNew(() => \n    { \n      return (from e1 in tWords \n      where WORDS.ContainsKey(e1) \n      select e1); \n    }); \n\n    //Generate all possible spelling corrections for word \n\n    Func<string, Task<IEnumerable<string>>> candidates =  \n    (tWord) => Task.Factory.StartNew(() => \n    { \n      List<string> tWords = new List<string>(); \n      tWords.Add(word); \n      return ((from e1 in known(tWords).Result \n      select e1) \n      .Union(from e2  \n      in known(edits1(tWord).Result).Result \n      select e2) \n      .Union(from e3  \n      in known(edits2(tWord).Result).Result \n      select e3) \n      .Union(from e4  \n      in tWords \n      select e4)) \n      .Distinct(); \n    }); \n\n    //Returns most probable spelling correction for word in the  \n    //order of their probability of occurrence in the corpus \n\n    Func<string, Task<IEnumerable<string>>> corrections =  \n    (tWord) => Task.Factory.StartNew(() => \n    { \n      var N = (from x in WORDS \n      select x.Value) \n      .Sum(); \n      List<string> tWords = new List<string>(); \n      return (from e1 in candidates(tWord).Result \n        .OrderByDescending( \n          e1 => WORDS.ContainsKey(e1) ?  \n          (float) WORDS[e1] / (float) N : 0) \n          select e1) \n      .Take(count); \n    }); \n    Task.WaitAll(Train);            //Ensures Training Model is Created! \n    return corrections(word).Result; \n  } \n\n```", "```cs\n    static void SpellCheckerClient () \n    { \n      var corrections = NorvigSpellChecker(\"somthing\", 10); \n\n      foreach (var correction in corrections) \n      { \n        Console.WriteLine(correction); \n      } \n      Console.WriteLine(\"Training Model Creation Complete! {0}\",  \n      corrections.Count()); \n    } \n\n```", "```cs\n    public static IEnumerable<IEnumerable<T>>  \n    Subsets<T> (IEnumerable<T> inputSet) \n    { \n      T[] _input = inputSet.ToArray<T>(); \n      int _bitcount = _input.Length; \n      int _mask = Convert.ToInt32(Math.Pow(2.0d, _bitcount)); \n      int i = 0; \n      while (i < _mask) \n      { \n        List<T> _output = new List<T>(); \n        int j = 0; \n        while (j < _bitcount) \n        { \n          if ((i & (1 << j)) > 0) \n          { \n            _output.Add(_input[j]); \n          } \n          j++; \n        } \n        yield return _output.ToArray<T>(); \n        i++; \n      } \n    } \n\n```", "```cs\n    string[] names = { \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" }; \n\n    var result = from i in Enumerable \n    .Range(0, Convert.ToInt32(Math.Pow(2.0d, names.Length))) \n    .AsParallel() \n    from j in Enumerable \n    .Range(0, names.Length) \n    .AsParallel() \n    let k = new \n    { \n      a = i, \n      b = names[j] \n    } \n    where ((i & (1 << j)) > 0) \n    orderby k.a \n    group k.b by k.a; \n\n```", "```cs\n    public static IEnumerable<IEnumerable<T>>  \n    BigSubsetsP<T> (IEnumerable<T> inputSet) \n    { \n      T[] _input = inputSet.ToArray<T>(); \n      BlockingCollection<IEnumerable<T>> output = new  \n      BlockingCollection<IEnumerable<T>>(boundedCapacity: 20); \n      int _bitcount = _input.Length; \n      BitArray bits = new BitArray(_bitcount); \n      BitArray _bitsIncrement = new BitArray(_bitcount); \n      _bitsIncrement.Set(0, true); \n\n      //Stage#1 [GENERATE] \n\n      var generate = Task.Factory.StartNew(() => \n      { \n        try \n        { \n          Parallel.For(0, _bitcount, \n          (chunkIndex) => \n          { \n            BitArray _bits = new BitArray(_bitcount); \n            bool overFlow = false; \n            _bits.Set(chunkIndex, true); \n            output.Add(new[] { _input[chunkIndex] }); \n            while (!overFlow) \n            { \n              List<T> _output = new List<T>(); \n              int j = 0; \n              bool a; \n              bool b; \n              bool cIN = false; \n              bool cOUT = false; \n              bool bSUM = false; \n              while (j <= chunkIndex) //Full-Adder Addition \n              { \n                a = _bits[j]; \n                b = _bitsIncrement[j]; \n                bSUM = a ^ b ^ cIN;   \n                cOUT = (a & b) | (cIN & (a ^ b)); \n                _bits.Set(j, bSUM); \n                if (bSUM) \n                { \n                  _output.Add(_input[j]); \n                } \n                cIN = cOUT; \n                j++; \n              } \n              overFlow = cIN; \n              if (_output.Count > 0) \n              { \n                output.Add(_output.ToArray<T>()); \n              } \n              _output.Clear(); \n              _output = null; \n            } \n            _bits = null; \n          }); \n        } \n        finally \n        { \n          output.CompleteAdding(); \n        } \n      }); \n\n      //Stage#2 [CONCURRENT READ] \n\n      foreach (var subset in \n      output.GetConsumingEnumerable().AsParallel()) \n      { \n        yield return subset; \n      } \n      generate.Wait(); \n    } \n\n```", "```cs\n    static void GenerateBoxingCombinations () \n    { \n      Console.WriteLine(\"All possible packages:\"); \n      var watch = Stopwatch.StartNew(); \n      var resultSet = from subset in  \n      Program4.BigSubsetsP<int>( \n        new List<int>() { 3, 1, 1, 2, 2, 1 }) \n      .AsParallel() \n      where subset.Sum() == 5 \n      select subset; \n      foreach (var set in resultSet) \n      { \n        Console.WriteLine( \n          \"SET >> {0} :: SUM >> {1}\",  \n          string.Join(\",\", set),  \n          set.Sum()); \n      } \n      Console.WriteLine( \n        \"Elapsed Time for Package set Generation : {0} seconds\",    \n        watch.ElapsedMilliseconds / 1000D); \n      } \n\n```", "```cs\n    var empInfo = from emp in db.Employee\n    join dept in db.Department\n    on emp.deptid equals dept.nid\n    select new\n    {\n      emp.Name,\n      dept.Name,\n      emp.Location\n    };\n```"]